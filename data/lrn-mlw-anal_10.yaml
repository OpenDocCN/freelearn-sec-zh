- en: Hunting Malware Using Memory Forensics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存取证进行恶意软件猎杀
- en: In the chapters covered so far, we looked at the concepts, tools, and techniques
    that are used to analyze malware using static, dynamic, and code analysis. In
    this chapter, you will understand another technique, called *memory forensics
    (or Memory Analysis)*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了使用静态分析、动态分析和代码分析来分析恶意软件的概念、工具和技术。在本章中，您将了解另一种技术，称为*内存取证（或内存分析）*。
- en: Memory forensics (or Memory Analysis) is an investigative technique which involves
    finding and extracting forensic artifacts from the computer's physical memory
    (RAM). A computer's memory stores valuable information about the runtime state
    of the system. Acquiring the memory and analyzing it will reveal necessary information
    for forensic investigation, such as which applications are running on the system,
    what objects (file, registry, and so on) these applications are accessing, active
    networks connections, loaded modules, loaded kernel drivers, and other information.
    For this reason, memory forensics is used in incident response and malware analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存取证（或内存分析）是一种调查技术，涉及从计算机的物理内存（RAM）中查找和提取取证工件。计算机的内存存储着关于系统运行时状态的宝贵信息。获取并分析内存将揭示用于取证调查的必要信息，例如系统上正在运行的应用程序、这些应用程序正在访问的对象（文件、注册表等）、活动的网络连接、加载的模块、加载的内核驱动程序等。因此，内存取证在事件响应和恶意软件分析中被广泛使用。
- en: During incident response,  in most cases, you will not have access to the malware
    sample but you may only have the memory image of a suspect system. For instance,
    you may receive an alert from a security product about a possible malicious behavior
    from a system, in that case, you may acquire the memory image of the suspect system,
    to perform memory forensics for confirming the infection and to find the malicious
    artifacts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件响应过程中，大多数情况下，您将无法访问恶意软件样本，但可能只有嫌疑系统的内存映像。例如，安全产品可能会警告某个系统存在可能的恶意行为，在这种情况下，您可以获取嫌疑系统的内存映像，以确认感染并查找恶意工件的内存取证。
- en: In addition to using memory forensics for incident response, you can also use
    it as part of malware analysis (where you have the malware sample) to gain additional
    information about the behavior of the malware post-infection. For instance, when
    you have a malware sample, in addition to performing static, dynamic, and code
    analysis, you can execute the sample in an isolated environment and then acquire
    the infected computer memory and examine the memory image to get an idea of the
    malware's behavior after infection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在事件响应中使用内存取证外，您还可以将其作为恶意软件分析的一部分（拥有恶意软件样本时）使用，以获取有关感染后恶意软件行为的额外信息。例如，当您拥有恶意软件样本时，除了执行静态、动态和代码分析外，还可以在隔离环境中执行样本，然后获取感染计算机的内存并检查内存映像，以了解感染后恶意软件的行为。
- en: Another reason why you use memory forensics is that some malware samples may
    not write malicious components to the disk (only in memory). As a result, disk
    forensics or the filesystem analysis might fail. In such cases, memory forensics
    can be extremely useful in finding the malicious component.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用内存取证的原因是，某些恶意软件样本可能不会将恶意组件写入磁盘（仅存在于内存中）。因此，磁盘取证或文件系统分析可能会失败。在这种情况下，内存取证可以极大地帮助查找恶意组件。
- en: Some malware samples trick the operating system and live forensic tools by hooking
    or by modifying operating system structures. In such cases, memory forensics can
    be useful as it can bypass the tricks used by the malware to hide from the operating
    system and live forensic tools. This chapter introduces you to the concept of
    memory forensics and covers tools used to acquire and analyze the memory image.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件样本通过挂钩或修改操作系统结构来欺骗操作系统和实时取证工具。在这种情况下，内存取证非常有用，因为它可以绕过恶意软件用来隐藏自身的技巧。本章介绍了内存取证的概念，并涵盖了用于获取和分析内存映像的工具。
- en: 1\. Memory Forensics Steps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 内存取证步骤
- en: 'Whether you use memory forensics as part of the incident response or for malware
    analysis, the following are the general steps in memory forensics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是作为事件响应的一部分还是用于恶意软件分析，内存取证的一般步骤如下：
- en: '**Memory Acquisition**: This involves acquiring (or dumping) the memory of
    a target machine to disk. Depending on whether you are investigating an infected
    system or using memory forensics as part of your malware analysis, the target
    machine can be a system (on your network) that you suspect to be infected, or
    it could be an analysis machine in your lab environment where you executed the
    malware sample.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存获取**：这涉及将目标机器的内存（或转储）到磁盘。根据您是调查受感染系统还是将内存取证作为恶意软件分析的一部分，目标机器可以是您怀疑受感染的系统（在您的网络上），也可以是您实验室环境中执行恶意软件样本的分析机器。'
- en: '**Memory Analysis**: After you dump the memory to disk, this step involves
    analyzing the dumped memory to find and extract forensic artifacts.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分析**：将内存转储到磁盘后，这一步涉及分析转储的内存以查找和提取取证物件。'
- en: 2\. Memory Acquisition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 内存获取
- en: 'Memory acquisition is the process of acquiring volatile memory (RAM) to non-volatile
    storage (file on the disk). There are various tools that allow you to acquire
    the memory of a physical machine. The following are some of the tools that allow
    you to acquire (dump) the physical memory onto Windows. Some of these tools are
    commercial, and many of them can be downloaded for free after registration. The
    following tools work with both x86 (32-bit) and x64 (64-bits) machines:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 内存获取是将易失性内存（RAM）获取到非易失性存储（磁盘文件）的过程。有各种工具可让您获取物理机器的内存。以下是一些允许您将物理内存（转储）到Windows的工具。其中一些工具是商业软件，许多工具可以在注册后免费下载。以下工具适用于x86（32位）和x64（64位）机器：
- en: '*Comae Memory Toolkit (DumpIt)* by Comae Technologies *(free download with
    registration):* [https://my.comae.io/](https://my.comae.io/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Comae Memory Toolkit (DumpIt)*由Comae Technologies提供（需要注册才能免费下载）：[https://my.comae.io/](https://my.comae.io/)'
- en: '*Belkasoft RAM Capturer (free download with registration):* [https://belkasoft.com/ram-capturer](https://belkasoft.com/ram-capturer)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Belkasoft RAM Capturer*（需要注册才能免费下载）：[https://belkasoft.com/ram-capturer](https://belkasoft.com/ram-capturer)'
- en: '*FTK Imager* by AccessData *(free download with registration):* [https://accessdata.com/product-download](https://accessdata.com/product-download)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FTK Imager*由AccessData提供（需要注册才能免费下载）：[https://accessdata.com/product-download](https://accessdata.com/product-download)'
- en: '*Memoryze* by FireEye *(free download with registration):* [https://www.fireeye.com/services/freeware/memoryze.html](https://www.fireeye.com/services/freeware/memoryze.html)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Memoryze*由FireEye提供（需要注册才能免费下载）：[https://www.fireeye.com/services/freeware/memoryze.html](https://www.fireeye.com/services/freeware/memoryze.html)'
- en: '*Surge Collect* by Volexity (*Commercial*): [https://www.volexity.com/products-overview/surge/](https://www.volexity.com/products-overview/surge/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Surge Collect*由Volexity提供（商业软件）：[https://www.volexity.com/products-overview/surge/](https://www.volexity.com/products-overview/surge/)'
- en: '*OSForensics* by PassMark Software *(commercial):* [https://www.osforensics.com/osforensics.html](https://www.osforensics.com/osforensics.html)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OSForensics*由PassMark Software提供（商业软件）：[https://www.osforensics.com/osforensics.html](https://www.osforensics.com/osforensics.html)'
- en: '*WinPmem (open source), part of Rekall Memory forensic framework:* [http://blog.rekall-forensic.com/search?q=winpmem](http://blog.rekall-forensic.com/search?q=winpmem)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WinPmem*（开源），属于Rekall内存取证框架的一部分：[http://blog.rekall-forensic.com/search?q=winpmem](http://blog.rekall-forensic.com/search?q=winpmem)'
- en: 2.1 Memory Acquisition Using DumpIt
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 使用DumpIt进行内存获取
- en: '*DumpIt* is an excellent memory acquisition tool that allows you to dump physical
    memory on Windows. It supports the acquisition of both 32-bit (x86) and 64-bit
    (x64) machines. DumpIt is part of a toolkit called the *Comae memory toolkit*,
    which consists of various standalone tools that assist with memory acquisition
    and conversion between different file formats. To download the latest copy of
    the *Comae memory toolkit*, you need to create an account by registering on [https://my.comae.io](https://my.comae.io).
    Once the account is created, you can log in and download the latest copy of the *Comae
    memory toolkit.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*DumpIt*是一款出色的内存获取工具，可让您在Windows上转储物理内存。它支持获取32位（x86）和64位（x64）机器的内存。DumpIt是*Comae
    memory toolkit*的一部分，该工具包含各种独立工具，可帮助进行内存获取和在不同文件格式之间进行转换。要下载最新版本的*Comae memory
    toolkit*，您需要在[https://my.comae.io](https://my.comae.io)上注册账户。创建账户后，您可以登录并下载最新版本的*Comae
    memory toolkit*。'
- en: After downloading the Comae toolkit, extract the archive, and navigate to the
    32-bit or 64-bit directory, depending on whether you want to dump the memory of
    a 32-bit or 64-bit machine. The directory consists of various files, including
    *DumpIt.exe*. In this section, we will mainly focus on how to use DumpIt to dump
    the memory. If you are interested in understanding the functionality of other
    tools in the directory, read the *readme.txt* file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Comae工具包后，解压缩存档文件，并根据你希望转储32位或64位机器的内存，进入相应的32位或64位目录。该目录包含多个文件，其中包括*DumpIt.exe*。本节主要介绍如何使用DumpIt进行内存转储。如果你有兴趣了解该目录中其他工具的功能，请阅读*readme.txt*文件。
- en: The easiest method to acquire memory using *DumpIt* is to right-click on the
    *DumptIt.exe* file and select *Run as administrator*. By default, DumpIt dumps
    the memory to a file as a *Microsoft Crash Dump (with a .dmp extension),* which
    can then be analyzed with Memory Analysis tools such as *Volatility* (which will
    be covered next) or by using a Microsoft debugger such as *WinDbg*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*DumpIt*获取内存的最简单方法是右键点击*DumptIt.exe*文件，并选择*以管理员身份运行*。默认情况下，DumpIt将内存转储到一个文件中，该文件是*Microsoft崩溃转储（.dmp扩展名）*，然后可以使用内存分析工具，如*Volatility*（接下来将介绍），或者使用Microsoft调试器，如*WinDbg*，对其进行分析。
- en: 'You can also run *DumpIt* from the command line; this provides you with multiple
    options. To display different options, run *cmd.exe* as an Administrator, navigate
    to the directory containing *DumpIt.exe*, and type the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从命令行运行*DumpIt*；这样你将拥有多个选项。要显示不同的选项，请以管理员身份运行*cmd.exe*，进入包含*DumpIt.exe*的目录，并输入以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To acquire the memory of the Microsoft Crash dump from the command line, and
    to save the output to a file name of your choice, use the `/o` or `/OUTPUT` option,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行获取Microsoft崩溃转储的内存，并将输出保存到你选择的文件名中，可以使用`/o`或`/OUTPUT`选项，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To acquire the memory as a raw memory dump instead of the default Microsoft
    crash dump, you can specify that with the `/t` or `/TYPE` option, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内存作为原始内存转储而非默认的Microsoft崩溃转储，你可以使用`/t`或`/TYPE`选项进行指定，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you wish to acquire memory from servers consisting of large memory, you can
    use the `/R` or `/COMPRESS` option in *DumpIt*, which creates a `.zdmp` (*Comae
    compressed crash dump*) file, which reduces the file size and also makes acquisition
    faster. The dump file (`.zdmp`) can then be analyzed with the Comae Stardust enterprise
    platform: [https://my.comae.io](https://my.comae.io). For more details, refer
    to the following blog post: [https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0](https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从包含大量内存的服务器中获取内存，可以使用*DumpIt*中的`/R`或`/COMPRESS`选项，这将创建一个`.zdmp`（*Comae压缩崩溃转储*）文件，从而减少文件大小，并加快获取速度。然后可以使用Comae
    Stardust企业平台分析该转储文件（`.zdmp`）：[https://my.comae.io](https://my.comae.io)。更多细节，请参阅以下博客文章：[https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0](https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0)。
- en: In most cases, you can acquire the memory of a *Virtual Machine (VM)* by suspending
    the VM. For instance, after executing the malware sample on VMware Workstation/VMware
    Fusion, you can suspend the VM, which will write the guest's memory (RAM) to a
    file with a `.vmem` extension on the host machine's disk. For those applications
    (such as VirtualBox) where the memory cannot be acquired by suspending, then you
    can use DumpIt inside the guest machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可以通过暂停虚拟机（*Virtual Machine (VM)*）来获取内存。例如，在VMware Workstation/VMware
    Fusion上执行恶意软件样本后，你可以暂停虚拟机，这将把客户机的内存（RAM）写入主机磁盘上的一个`.vmem`扩展名的文件中。对于那些无法通过暂停获取内存的应用程序（如VirtualBox），你可以在客户机内使用DumpIt。
- en: 3\. Volatility Overview
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. Volatility概述
- en: Once you acquire the memory of an infected system, the next step is to analyze
    the acquired memory image. *Volatility* ([http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases))
    is an open source advanced memory forensics framework written in *Python* that
    allows you to analyze and extract digital artifacts from the memory image. Volatility
    can run on various platforms (Windows, macOS, and Linux), and it supports analysis
    of memory from 32-bit and 64-bit versions of Windows, macOS, and Linux operating
    systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了被感染系统的内存，下一步就是分析获取的内存镜像。*Volatility* ([http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases))
    是一个用 *Python* 编写的开源高级内存取证框架，允许你从内存镜像中分析和提取数字证据。Volatility 可以在各种平台上运行（Windows、macOS
    和 Linux），并支持分析来自 32 位和 64 位版本的 Windows、macOS 和 Linux 操作系统的内存。
- en: 3.1 Installing Volatility
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 安装 Volatility
- en: Volatility is distributed in several formats, and it can be downloaded from
    [http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases).
    At the time of writing this book, the latest version of Volatility is version
    2.6\. Depending on the operating system that you intend to run Volatility on,
    follow the installation procedure for the appropriate operating system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 以多种格式分发，并可从 [http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases)
    下载。在撰写本书时，Volatility 的最新版本是 2.6。根据你打算在其上运行 Volatility 的操作系统，按照适当操作系统的安装过程进行安装。
- en: 3.1.1 Volatility Standalone Executable
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1.1 Volatility 独立可执行文件
- en: The fastest way to get started with Volatility is to use the *standalone executable*.
    The standalone executable is distributed for Windows, macOS, and Linux operating
    systems. The advantage of a standalone executable is that you don't need to install
    the Python interpreter or Volatility dependencies, since it comes packaged with
    Python 2.7 Interpreter and all the required dependencies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 快速开始使用 Volatility 的方法是使用*独立可执行文件*。独立可执行文件适用于 Windows、macOS 和 Linux 操作系统。独立可执行文件的优点在于你无需安装
    Python 解释器或 Volatility 依赖项，因为它已经打包了 Python 2.7 解释器和所有必需的依赖项。
- en: 'On Windows, once the standalone executable is downloaded, you can check whether
    Volatility is ready to use by executing the standalone executable with the `-h
    (--help)` option from the command line, as shown here. The help option displays
    various options and plugins that are available in Volatility:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，一旦下载了独立可执行文件，你可以通过在命令行中执行带有 `-h (--help)` 选项的独立可执行文件来检查 Volatility
    是否准备就绪，如下所示。帮助选项会显示 Volatility 中可用的各种选项和插件：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the same manner, you can download the standalone executables for Linux or
    macOS and check if Volatility is ready to use by executing the standalone executable
    with the `-h` (or `--help`) option, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你可以下载 Linux 或 macOS 的独立可执行文件，并通过在命令行中执行带有 `-h`（或 `--help`）选项的独立可执行文件来检查
    Volatility 是否准备就绪，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3.1.2 Volatility Source Package
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1.2 Volatility 源码包
- en: 'Volatility is also distributed as a source package; you can run it on *Windows*,
    macOS, or *Linux* operating systems. Volatility relies on various plugins to perform
    tasks, and some of these plugins depend on third-party Python packages. To run
    Volatility, you need to install Python 2.7 Interpreter and its dependencies. The
    web page: [https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages](https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages) contains
    a list of the third-party Python packages that are required by some of the Volatility
    plugins. You can install these dependencies by reading the documentation. Once
    all the dependencies are installed, download the Volatility source code package,
    extract it, and run *Volatility*, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 也以源码包的形式分发；你可以在 Windows、macOS 或 Linux 操作系统上运行它。Volatility 依赖于各种插件来执行任务，其中一些插件依赖于第三方
    Python 包。要运行 Volatility，你需要安装 Python 2.7 解释器及其依赖项。网页：[https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages](https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages)
    包含了一些 Volatility 插件所需的第三方 Python 包的列表。你可以通过阅读文档来安装这些依赖项。一旦安装了所有依赖项，下载 Volatility
    源代码包，解压缩并运行 *Volatility*，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the examples mentioned in this book use the Volatility Python script (`python
    vol.py`) from the source package. You are free to choose a standalone executable,
    but just remember to replace `python vol.py` with the standalone executable name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中提到的所有示例都使用 Volatility Python 脚本（`python vol.py`）来自源代码包。你可以自由选择独立可执行文件，但请记住将
    `python vol.py` 替换为独立可执行文件的名称。
- en: 3.2 Using Volatility
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 使用 Volatility
- en: 'Volatility consists of various plugins that can extract different information
    from the memory image. The `python vol.py -h` option displays the supported plugins.
    For instance, if you wish to list the running processes from the memory image,
    you can use a plugin such a `pslist`, or if you wish to list the network connections,
    you can use a different plugin. Irrespective of the plugin that you use, you will
    use the following command syntax. Using `-f`, you specify the path to the memory
    image file, and `--profile` tells Volatility which system and architecture the
    memory image was acquired from. The plugin can vary depending on what type of
    information you would like to extract from the memory image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 由多个插件组成，这些插件可以从内存镜像中提取不同的信息。`python vol.py -h` 选项显示支持的插件。例如，如果你希望列出内存镜像中的正在运行的进程，可以使用
    `pslist` 插件，或者如果你希望列出网络连接，可以使用另一个插件。无论你使用哪个插件，都将使用以下命令语法。使用 `-f`，你可以指定内存镜像文件的路径，`--profile`
    告诉 Volatility 内存镜像来自哪个系统和架构。根据你想从内存镜像中提取的信息类型，插件可能会有所不同：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following command uses the `pslist` plugin to list the running processes
    from the memory image acquired from Windows 7 (32-bit) running Service Pack 1:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用 `pslist` 插件列出从运行 Windows 7（32 位）服务包 1 获取的内存镜像中的正在运行的进程：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes, you might not know what profile to supply to Volatility. In that
    case, you can use the `imageinfo` plugin, which will determine the correct profile.
    The following command displays multiple profiles that are suggested by the `imageinfo`
    plugin; you can use any of the suggested profiles:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不知道该为 Volatility 提供哪个配置文件。在这种情况下，你可以使用 `imageinfo` 插件，它会确定正确的配置文件。以下命令显示了
    `imageinfo` 插件建议的多个配置文件；你可以使用任何一个建议的配置文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of the Volatility plugins, such as `pslist`, rely on extracting the information
    from the Windows operating system structures. These structures vary across different
    versions of Windows; the profile (`--profile`) tells Volatility which data structures,
    symbols, and algorithms to use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Volatility 插件，如 `pslist`，依赖于从 Windows 操作系统结构中提取信息。这些结构在不同版本的 Windows 中有所不同；配置文件（`--profile`）告诉
    Volatility 使用哪些数据结构、符号和算法。
- en: 'The help option, `-h (--help)`, which that you saw previously, displays help
    that applies to all of the Volatility plugins. You can use the same `-h (--help)`
    option to determine various options and arguments supported by a plugin. To do
    that, just type `-h (--help)` next to the plugin name. The following command displays
    the help options for the `pslist` plugin:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的帮助选项 `-h (--help)` 显示适用于所有 Volatility 插件的帮助。你也可以使用相同的 `-h (--help)` 选项来确定插件支持的各种选项和参数。要做到这一点，只需在插件名称旁输入
    `-h (--help)`。以下命令显示 `pslist` 插件的帮助选项：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, you should have an understanding of how to run *Volatility* plugins
    on an acquired memory image and how to determine various options supported by
    a plugin. In the following sections, you will learn about the different plugins
    and how to use them to extract forensic artifacts from the memory image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，你应该已经了解如何在获取的内存镜像上运行 *Volatility* 插件，以及如何确定插件支持的各种选项。在接下来的章节中，你将学习不同插件的使用方法，以及如何使用它们从内存镜像中提取取证数据。
- en: 4\. Enumerating Processes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 列举进程
- en: 'When you are investigating a memory image, you will mainly focus on identifying
    any suspicious process running on the system. There are various plugins in Volatility
    that allow you to enumerate processes. Volatility''s `pslist` plugin lists the
    processes from the memory image, similar to how *task manager* lists the process
    on a live system. In the following output, running the `pslist` plugin against
    a memory image infected with a malware sample (*Perseus*) shows two suspicious
    processes: `svchost..exe` *(*`pid 3832`*)* and `suchost..exe` ( `pid 3924`). The
    reason why these two processes are suspicious is that the names of these processes
    have an additional *dot* character before the `.exe` extension (which is abnormal).
    On a clean system, you will find multiple instances of `svchost.exe` processes
    running. By creating a process such as `svchost..exe` and `suchost..exe`, the
    attacker is trying to blend in by making these processes look similar to the legitimate 
    `svchost.exe` process:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调查内存镜像时，你主要关注的是识别系统中是否有可疑的进程正在运行。Volatility 提供了多种插件，允许你枚举进程。Volatility 的
    `pslist` 插件列出了来自内存镜像的进程，类似于 *任务管理器* 在实时系统上列出进程的方式。在以下输出中，运行 `pslist` 插件对一个被恶意软件（*Perseus*）感染的内存镜像进行分析，显示了两个可疑的进程：`svchost..exe`
    (*`pid 3832`*) 和 `suchost..exe` (`pid 3924`)。这两个进程之所以可疑，是因为它们的进程名称在 `.exe` 扩展名之前多了一个
    *点* 字符（这不正常）。在一个干净的系统中，你会发现多个 `svchost.exe` 进程正在运行。通过创建 `svchost..exe` 和 `suchost..exe`
    这样的进程，攻击者试图通过让这些进程看起来与合法的 `svchost.exe` 进程相似来掩盖其身份：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the Volatility plugin is easy; you can run the plugin without knowing
    how it works. Understanding how the plugins work will help you assess the accuracy
    of the results, and it will also help you choose the right plugin when an attacker
    uses stealth techniques. The question is, how does `pslist` work? To understand
    that first, you need to understand what a process is and how *Windows kernel*
    keeps track of processes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Volatility 插件很容易；你可以在不理解其工作原理的情况下运行插件。理解插件的工作原理将帮助你评估结果的准确性，也将帮助你在攻击者使用隐蔽技术时选择正确的插件。那么问题是，`pslist`
    是如何工作的呢？要理解这一点，首先需要了解什么是进程，以及 *Windows 内核* 是如何跟踪进程的。
- en: 4.1 Process Overview
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 过程概述
- en: A *process* is an object. The Windows operating system is object-based (not
    to be confused with the term object used in object-oriented languages). An object
    refers to a system resource such as a process, file, device, directory, mutant,
    and so on, and they are managed by a component of a kernel called *object manager*.
    To get an idea of all the object types on Windows, you can use the *WinObj tool*
    ([https://docs.microsoft.com/en-us/sysinternals/downloads/winobj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj)).
    To look at the object types in *WinObj*, launch *WinObj* as an Administrator and,
    in the left-hand pane, click on *ObjectTypes*, which will display all the Windows
    objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程* 是一个对象。Windows 操作系统是基于对象的（不要与面向对象语言中使用的对象一词混淆）。对象指的是系统资源，例如进程、文件、设备、目录、突变体等，它们由内核中的一个组件——*对象管理器*
    管理。为了了解 Windows 上所有的对象类型，你可以使用 *WinObj 工具*（[https://docs.microsoft.com/en-us/sysinternals/downloads/winobj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj)）。要查看
    *WinObj* 中的对象类型，作为管理员启动 *WinObj*，然后在左侧窗格中点击 *ObjectTypes*，这将显示所有 Windows 对象。'
- en: The objects (such as processes, files, threads, and so on) are represented as
    structures in C. What this means is that a process object has a structure associated
    with it, and this structure is called the `_EPROCESS` structure. The `_EPROCESS`
    structure resides in the kernel memory, and the Windows kernel uses the `EPROCESS`
    structure to represent a process internally. The `_EPROCESS` structure contains
    various information related to a process such as *the name of the process*, *process
    ID*, *parent process ID*, *number of threads associated with the process*, *the
    creation time of the process,* and so on. Now, go back to the `pslist` output
    and note what kind of information is displayed for a particular process. For example,
    if you look at the second entry from the `pslist` output, it shows the name of
    the `smss.exe` process, its process ID `(272)`, parent process ID (`4`), and so
    on. As you might have guessed, the information related to a process is coming
    from its `_EPROCESS` structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对象（如进程、文件、线程等）在C中表示为结构。 这意味着进程对象有一个与之关联的结构，该结构称为`_EPROCESS`结构。 `_EPROCESS`结构位于内核内存中，Windows内核使用`EPROCESS`结构来内部表示一个进程。
    `_EPROCESS`结构包含与进程相关的各种信息，例如*进程的名称*、*进程ID*、*父进程ID*、*与进程关联的线程数*、*进程的创建时间*等。 现在，返回到`pslist`输出，并注意为特定进程显示了什么类型的信息。
    例如，如果查看`pslist`输出的第二个条目，它显示了`smss.exe`进程的名称，其进程ID为`(272)`，父进程ID为`4`，等等。 正如您可能已经猜到的那样，与进程相关的信息来自其`_EPROCESS`结构。
- en: 4.1.1 Examining the _EPROCESS Structure
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1.1 检查_EPROCESS结构
- en: 'To examine the `_EPROCESS` structure and the kind of information it contains,
    you can use a kernel debugger such as *WinDbg*. *WinDbg* helps in exploring and
    understanding the operating system data structures, which is often an important
    aspect of *Memory forensics*. To install *WinDbg*, you need to install the <q
    class="calibre256">"Debugging Tools for Windows"</q> package, which is included
    as part of *Microsoft SDK* (refer to [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)
    for different installation types). Once the installation is complete, you can
    find *WinDbg.exe* in the installation directory (in my case, it is located in
    *C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x64*). Next, download the *LiveKD*
    utility from *Sysinternals* ([https://docs.microsoft.com/en-us/sysinternals/downloads/livekd](https://docs.microsoft.com/en-us/sysinternals/downloads/livekd)),
    extract it, and then copy *livekd.exe* into the installation directory of *WinDbg*.
    *LiveKD* enables you to perform local kernel debugging on a live system. To launch
    *WinDbg* via *livekd*, open Command Prompt (as *Administrator*), navigate to the
    *WinDbg installation directory,* and run `livekd` with the `-w` switch, as shown
    here. You can also add the *Windbg* installation directory to the path environment
    variable so that you can launch *LiveKD* from any path:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`_EPROCESS`结构及其包含的信息类型，您可以使用诸如*WinDbg*之类的内核调试器。 *WinDbg*有助于探索和理解操作系统数据结构，这通常是*内存取证*的重要方面。
    要安装*WinDbg*，您需要安装<q class="calibre256">"Windows调试工具"</q>包，该包作为*Microsoft SDK*的一部分（有关不同的安装类型，请参考[https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)）。
    安装完成后，您可以在安装目录中找到*WinDbg.exe*（在我的情况下，它位于*C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x64*）。
    接下来，从*Sysinternals*（[https://docs.microsoft.com/en-us/sysinternals/downloads/livekd](https://docs.microsoft.com/en-us/sysinternals/downloads/livekd)）下载*LiveKD*实用程序，解压缩并将*livekd.exe*复制到*WinDbg*的安装目录中。
    *LiveKD*使您能够在实时系统上执行本地内核调试。 要通过*livekd*启动*WinDbg*，打开命令提示符（作为*管理员*），导航到*WinDbg安装目录*，并运行`livekd`与`-w`开关，如下所示。
    您还可以将*Windbg*安装目录添加到路径环境变量中，以便您可以从任何路径启动*LiveKD*：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `livekd -w` command automatically launches `Windbg`, loads the symbols,
    and presents you with a `kd>` prompt that''s ready to accept commands, as shown
    in the following screenshot. To explore the data structures (such as `_EPROCESS`),
    you will type the appropriate command into the Command Prompt (next to `kd>`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`livekd -w`命令会自动启动`Windbg`，加载符号，并为您提供一个准备接受命令的`kd>`提示符，如下面的屏幕截图所示。 要探索数据结构（如`_EPROCESS`），您将在命令提示符旁边键入适当的命令：'
- en: '![](../images/00333.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00333.jpeg)'
- en: 'Now, going back to our discussion of the `_EPROCESS` structure, to explore
    the `_EPROCESS` structure, we will use the `Display Type` command `(dt).` The
    `dt` command can be used to explore a symbol that represents a variable, a structure,
    or a union. In the following output, the `dt` command is used to display the `_EPROCESS`
    structure defined in the `nt` module (the name of the kernel executive). The `EPROCESS`
    structure consists of multiple fields, storing all sorts of metadata of a process.
    Here is what it looks like for a 64-bit Windows 7 system (some of the fields have
    been removed to keep it small):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们对`_EPROCESS`结构的讨论，为了探索`_EPROCESS`结构，我们将使用`Display Type`命令`(dt)`。`dt`命令可用于探索表示变量、结构或联合体的符号。在以下输出中，`dt`命令用于显示在`nt`模块（内核执行文件的名称）中定义的`_EPROCESS`结构。`EPROCESS`结构包含多个字段，存储进程的各种元数据。以下是64位Windows
    7系统的示例（为了保持简洁，已删除部分字段）：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are some of the interesting fields in the `_EPROCESS` structure
    that we will use for this discussion:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本讨论中使用的`_EPROCESS`结构中一些有趣的字段：
- en: '`CreateTime`: Timestamp that indicates when the process was first started'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateTime`: 时间戳，指示进程首次启动的时间'
- en: '`ExitTime`: Timestamp that indicates when the process exited'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExitTime`: 时间戳，指示进程退出的时间'
- en: '`UniqueProcessID`: An integer that references the *process ID (PID)* of the
    process'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueProcessID`: 一个整数，引用*进程ID（PID）*的进程'
- en: '`ActiveProcessLinks`: A double linked list that links all the active processes
    running on the system'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActiveProcessLinks`: 一个双向链表，链接系统上所有正在运行的活动进程'
- en: '`InheritedFromUniqueProcessId`: An integer that specifies the PID of the parent
    process'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InheritedFromUniqueProcessId`: 一个整数，指定父进程的PID'
- en: '`ImageFileName`: An array of 16 ASCII characters which store the name of the
    process executable'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageFileName`: 一个包含16个ASCII字符的数组，存储进程可执行文件的名称'
- en: 'With an understanding of how to examine the `_EPROCESS` structure, let''s now
    take a look at the `_EPROCESS` structure of a specific process. To do that, let''s
    first list all active processes using *WinDbg*. You can use the `!process` extension
    command to print metadata of a particular process or all processes. In the following
    command, the first argument, `0`, lists metadata of all the processes. You can
    also display the information of a single process by specifying the address of
    the `_EPROCESS` structure. The second argument indicates the level of detail:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何检查`_EPROCESS`结构后，现在让我们来看看特定进程的`_EPROCESS`结构。为此，让我们首先使用*WinDbg*列出所有活动进程。您可以使用`!process`扩展命令打印特定进程或所有进程的元数据。在以下命令中，第一个参数`0`列出所有进程的元数据。您还可以通过指定`_EPROCESS`结构的地址来显示单个进程的信息。第二个参数表示详细程度：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For detailed information on WinDbg commands, refer to the Debugger.chm help,
    which is located in the WinDbg installation folder. You can also refer to the
    following online resources: [http://windbg.info/doc/1-common-cmds.html](http://windbg.info/doc/1-common-cmds.html)
    and [http://windbg.info/doc/2-windbg-a-z.html](http://windbg.info/doc/2-windbg-a-z.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WinDbg命令的详细信息，请参考位于WinDbg安装文件夹中的Debugger.chm帮助。您还可以参考以下在线资源：[http://windbg.info/doc/1-common-cmds.html](http://windbg.info/doc/1-common-cmds.html)
    和 [http://windbg.info/doc/2-windbg-a-z.html](http://windbg.info/doc/2-windbg-a-z.html)。
- en: 'From the preceding output, let''s look at the second entry, which describes
    `smss.exe`. The address, `fffffa8061d35700`, next to the `PROCESS`, is the address
    of the `_EPROCESS` structure associated with this instance of `smss.exe.` The
    `Cid` field, which has a value of `00fc` (`252` in decimal), is the process ID,
    and `ParentCid`, which has a value of `0004`, represents the process ID of the
    parent process. You can verify this by examining the values in the fields for
    the `_EPROCESS` structure of `smss.exe.` You can suffix the address of the `_EPROCESS`
    structure at the end of the `Display Type (dt)` command, as shown in the following
    code. In the following output, notice the values in the fields `UniqueProcessId`
    (process ID), `InheritedFromUniqueProcessId` (parent process ID), and `ImageFileName`
    (process executable name). These values match with the results that you determined
    previously from the `!process 0 0`  command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，让我们来看第二项，描述的是 `smss.exe`。在 `PROCESS` 旁边的地址 `fffffa8061d35700` 是与此 `smss.exe`
    实例关联的 `_EPROCESS` 结构的地址。`Cid` 字段的值为 `00fc`（十进制为 `252`），即进程 ID，`ParentCid` 字段的值为
    `0004`，表示父进程的进程 ID。你可以通过检查 `smss.exe` 的 `_EPROCESS` 结构中的字段值来验证这一点。你可以在 `Display
    Type (dt)` 命令的后面加上 `_EPROCESS` 结构的地址，如下代码所示。在以下输出中，注意字段 `UniqueProcessId`（进程 ID）、`InheritedFromUniqueProcessId`（父进程
    ID）和 `ImageFileName`（进程可执行文件名）的值。这些值与之前从 `!process 0 0` 命令中获得的结果相匹配：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So far, we know that the operating system keeps all kinds of metadata information
    about a process in the `_EPROCESS` structure, which resides in the kernel memory.
    This means that if you can find the address of the `_EPROCESS` structure for a
    particular process, you can get all the information about that process. Then,
    the question is, how do you get information about all the processes running on
    the system? For that, we need to understand how active processes are tracked by
    the Windows operating system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道操作系统将所有关于进程的元数据保存在 `_EPROCESS` 结构中，该结构存在于内核内存中。这意味着，如果你能找到某个特定进程的
    `_EPROCESS` 结构的地址，就能获取到关于该进程的所有信息。那么，问题是，如何获取系统中所有正在运行的进程的信息呢？为此，我们需要了解 Windows
    操作系统是如何追踪活动进程的。
- en: 4.1.2 Understanding ActiveProcessLinks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1.2 理解 ActiveProcessLinks
- en: 'Windows uses a circular double linked list of `_EPROCESS` structures to keep
    track of all the active processes. The `_EPROCESS` structure contains a field
    called `ActiveProcessLinks` which is of type `LIST_ENTRY.` The `_LIST_ENTRY` is
    another structure that contains two members, as shown in the following code. The
    `Flink` (forward link) points to the `_LIST_ENTRY` of the next `_EPROCESS` structure,
    and the `Blink` (backward link) points to the `_LIST_ENTRY` of the previous `_EPROCESS`
    structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 使用一个圆形双向链表来追踪所有活动的进程，每个节点都是一个 `_EPROCESS` 结构。`_EPROCESS` 结构中包含一个名为 `ActiveProcessLinks`
    的字段，类型是 `LIST_ENTRY`。`_LIST_ENTRY` 是另一种结构，包含两个成员，如下代码所示。`Flink`（正向链接）指向下一个 `_EPROCESS`
    结构的 `_LIST_ENTRY`，而 `Blink`（反向链接）指向前一个 `_EPROCESS` 结构的 `_LIST_ENTRY`：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Flink` and `Blink` together create a chain of process objects; this can be
    visualized as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flink` 和 `Blink` 一起构成了一个进程对象链表，可以像下面这样可视化：'
- en: '![](../images/00334.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00334.jpeg)'
- en: 'A point to note is that `Flink` and `Blink` do not point to the start of the
    `_EPROCESS` structure. `Flink` points to the start (first byte) of the `_LIST_ENTRY`
    structure of the next `_EPROCESS` structure, and `Blink` points to the first byte
    of the `_LIST_ENTRY` structure of the previous `_EPROCESS` structure. The reason
    why this is important is that, once you find the `_EPROCESS` structure of a process,
    you can walk the doubly linked list forward (using `Flink)` or backward `(Blink)`
    and then subtracting an offset value to get to the start of the `_EPROCESS` structure
    of the *next* or the *previous* process. To help you understand what this means,
    let''s look at the values of the fields `Flink` and `Blink` in the `_EPROCESS`
    structure of `smss.exe`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的点是，`Flink` 和 `Blink` 并不指向 `_EPROCESS` 结构的开始位置。`Flink` 指向下一个 `_EPROCESS`
    结构的 `_LIST_ENTRY` 结构的起始位置（第一个字节），而 `Blink` 指向前一个 `_EPROCESS` 结构的 `_LIST_ENTRY`
    结构的第一个字节。之所以重要，是因为一旦你找到了某个进程的 `_EPROCESS` 结构，你可以通过 `Flink` 向前（正向）遍历双向链表，或者通过 `Blink`
    向后（反向）遍历链表，然后减去偏移量来获取下一个或上一个进程的 `_EPROCESS` 结构的开始位置。为了帮助你理解这意味着什么，我们来看一下 `smss.exe`
    的 `_EPROCESS` 结构中 `Flink` 和 `Blink` 字段的值：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Flink` has a value of `0xfffffa8062583cb8`; this is the start address of the
    `ActiveProcessLinks` (`Flink`) of the next `_EPROCESS` structure. Since `ActiveProcessLinks`,
    in our example, is at offset `0x188` from the start of the `_EPROCESS`, you can
    get to the beginning of the `_EPROCESS` structure of the *next* process by subtracting
    `0x188` from the `Flink` value. In the following output, note how by subtracting
    `0x188` we landed on the `_EPROCESS` structure of the next process, which is `csrss.exe`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flink`的值为`0xfffffa8062583cb8`；这是下一个`_EPROCESS`结构的`ActiveProcessLinks`（`Flink`）的起始地址。由于在我们的示例中，`ActiveProcessLinks`位于`_EPROCESS`结构起始处的偏移量`0x188`，你可以通过从`Flink`值中减去`0x188`来到达下一个进程的`_EPROCESS`结构的起始位置。在以下输出中，注意通过减去`0x188`我们到达了下一个进程的`_EPROCESS`结构，即`csrss.exe`：'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, by walking the doubly linked list, it is possible to list the
    information about all the active processes running on the system. On a live system,
    tools such as *task manager* or *Process Explorer* make use of API functions,
    which ultimately rely on finding and walking the same doubly linked list of `_EPROCESS`
    structures that exist in kernel memory. The `pslist` plugin also incorporates
    the logic of finding and walking the same doubly linked list of `_EPROCESS` structures
    from the memory image. To do that, the `pslist` plugin finds a symbol named `_PsActiveProcessHead`,
    which is defined in `ntoskrnl.exe` (or `ntkrnlpa.exe`). This symbol points to
    the beginning of the doubly linked list of `_EPROCESS` structures; the `pslist`
    then walks the doubly linked list of the `_EPROCESS` structures to enumerate all
    the running processes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过遍历双向链表，可以列出系统上所有正在运行的活动进程的信息。在实时系统中，像*任务管理器*或*Process Explorer*这样的工具使用API函数，这些函数最终依赖于找到并遍历存在于内核内存中的同一个`_EPROCESS`结构的双向链表。`pslist`插件也包含了查找和遍历来自内存镜像的相同`_EPROCESS`结构双向链表的逻辑。为此，`pslist`插件找到一个名为`_PsActiveProcessHead`的符号，该符号定义在`ntoskrnl.exe`（或`ntkrnlpa.exe`）中。该符号指向`_EPROCESS`结构双向链表的起始位置；然后，`pslist`遍历`_EPROCESS`结构的双向链表来列出所有正在运行的进程。
- en: 'For detailed information on the workings and the logic used by the Volatility
    plugins covered in this book, refer to <q class="calibre259">The Art of Memory
    Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory</q> by
    Michael Hale Ligh, Andrew Case, Jamie Levy, and Aaron Walters.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '有关本书中所涉及的Volatility插件的详细工作原理和逻辑，请参阅Michael Hale Ligh、Andrew Case、Jamie Levy和Aaron
    Walters的《内存取证艺术：检测Windows、Linux和Mac内存中的恶意软件和威胁》（The Art of Memory Forensics: Detecting
    Malware and Threats in Windows, Linux, and Mac Memory）。'
- en: 'As mentioned earlier, a plugin such as `pslist` supports multiple options and
    arguments; this can be displayed by typing `-h (--help)` next to the plugin''s
    name. One of the `pslist` options is `--output-file`. You can use this option
    to redirect the `pslist` output to the file, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，像`pslist`这样的插件支持多种选项和参数；通过在插件名称后输入`-h (--help)`可以显示这些选项。`pslist`的一个选项是`--output-file`。你可以使用此选项将`pslist`的输出重定向到文件，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another option is `-p (--pid)`. Using this option, you can determine the information
    of a specific process if you know its **process ID** (**PID**):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是`-p (--pid)`。使用此选项，如果你知道某个进程的**进程ID**（**PID**），你可以获取该进程的信息：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 4.2 Listing Processes Using psscan
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 使用psscan列出进程
- en: '`psscan` is another Volatility plugin that lists the processes running on the
    system. Unlike `pslist`, `psscan` does not walk the doubly linked list of `_EPROCESS`
    objects. Instead, it scans the physical memory for the signature of the process
    objects. In other words, `psscan` uses a different approach to list the processes
    as compared to the `pslist` plugin. You might be thinking, what is the need for
    the `psscan` plugin when the `pslist` plugin can do the same thing? The answer
    lies in the technique used by `psscan`. Due to the approach it uses, it can detect
    terminated processes and also the hidden processes. An attacker can hide a process
    to prevent a forensic analyst from spotting the malicious process during live
    forensics. Now, the question is, how can an attacker hide a process? To understand
    that, you need to understand an attack technique known as *DKOM (Direct Kernel
    Object Manipulation)*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`psscan`是另一个列出系统上运行进程的Volatility插件。与`pslist`不同，`psscan`并不遍历`_EPROCESS`对象的双向链表。相反，它扫描物理内存以查找进程对象的特征码。换句话说，`psscan`使用与`pslist`插件不同的方法来列出进程。你可能会想，当`pslist`插件也能做同样的事情时，为什么还需要`psscan`插件？答案就在于`psscan`使用的技术。由于它采用的方式，它可以检测已终止的进程和隐藏的进程。攻击者可以隐藏进程，从而防止取证分析师在实时取证过程中发现恶意进程。那么，问题是，攻击者如何隐藏一个进程呢？要理解这一点，你需要了解一种攻击技术，称为*DKOM（直接内核对象操控）*。'
- en: 4.2.1 Direct Kernel Object Manipulation (DKOM)
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2.1 直接内核对象操控（DKOM）
- en: '*DKOM* is a technique that involves modifying the kernel data structures. Using
    DKOM, it is possible to hide a process or a driver. To hide a process, an attacker
    finds the `_EPROCESS` structure of the malicious process he/she wants to hide
    and modifies the `ActiveProcessLinks` field. In particular, the `Flink` of the
    previous `_EPROCESS` block is made to point to the `Flink` of the following `_EPROCESS`
    block, and the `Blink` of the following `_EPROCESS` block is set to point to the
    previous `_EPROCESS` block''s `Flink.` As a result of this, the `_EPROCESS` block
    associated with the malware process is unlinked from the doubly linked list (as
    shown here):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*DKOM*是一种涉及修改内核数据结构的技术。通过使用DKOM，可以隐藏一个进程或驱动程序。为了隐藏一个进程，攻击者找到他/她想要隐藏的恶意进程的`_EPROCESS`结构，并修改`ActiveProcessLinks`字段。具体来说，前一个`_EPROCESS`块的`Flink`被指向下一个`_EPROCESS`块的`Flink`，而下一个`_EPROCESS`块的`Blink`则指向前一个`_EPROCESS`块的`Flink`。由于这一操作，恶意进程相关的`_EPROCESS`块被从双向链表中解除链接（如图所示）：'
- en: '![](../images/00335.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00335.jpeg)'
- en: 'By unlinking a process, an attacker can hide the malicious process from the
    live forensic tools that rely on walking the doubly linked list to enumerate the
    active processes. As you might have guessed, this technique also hides the malicious
    process from the `pslist` plugin (which also relies on walking the doubly linked
    list). The following is the `pslist` and `psscan` output from a system infected
    with the *prolaco* rootkit, which performs *DKOM* to hide a process. For the sake
    of brevity, some of the entries are truncated from the following output. When
    you compare the output from `pslist` and `psscan`, you will notice an additional
    process called `nvid.exe` (`pid 1700`) in the `psscan` output that''s not present
    in the `pslist`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解除链接一个进程，攻击者可以使恶意进程对依赖遍历双向链表来枚举活动进程的实时取证工具隐藏。如你所猜测的，这种技术同样会使恶意进程对`pslist`插件隐藏（该插件也依赖遍历双向链表）。以下是一个被*prolaco*
    rootkit感染的系统的`pslist`和`psscan`输出，*prolaco* rootkit通过执行*DKOM*来隐藏一个进程。为了简洁起见，以下输出中的一些条目已被截断。当你对比`pslist`和`psscan`的输出时，会注意到`psscan`输出中有一个额外的进程`nvid.exe`（`pid
    1700`），但在`pslist`中并未出现：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned earlier, the reason `psscan` detects the hidden process is that
    it uses a different technique to list the processes, called *pool tag scanning*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`psscan`能够检测隐藏进程的原因在于它使用了不同的技术来列出进程，即*池标签扫描*。
- en: 4.2.2 Understanding Pool Tag Scanning
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2.2 理解池标签扫描
- en: 'If you recall, I previously referred to system resources such as processes,
    files, threads, and so on, as objects (or executive objects). The executive objects
    are managed by a component of a kernel called the *object manager*. Every executive
    object has a structure associated with it (such as `_EPROCESS` for process object).
    The executive object structure is preceded by a `_OBJECT_HEADER` structure, which
    contains information about an object''s type and some reference counters. The
    `_OBJECT_HEADER` is then preceded by zero or more optional headers. In other words,
    you can think of an object as the combination of executive object structure, the
    object header, and the optional headers, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我之前提到过将进程、文件、线程等系统资源称为对象（或执行对象）。这些执行对象由内核中的一个组件——*对象管理器*来管理。每个执行对象都有一个与之相关的结构（如进程对象的`_EPROCESS`）。执行对象结构前面有一个`_OBJECT_HEADER`结构，包含有关对象类型的信息以及一些引用计数。`_OBJECT_HEADER`结构前面可能会有零个或多个可选头结构。换句话说，你可以将对象视为执行对象结构、对象头和可选头的组合，如下图所示：
- en: '![](../images/00336.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00336.jpeg)'
- en: To store an object, memory is needed, and this memory is allocated by the Windows
    memory manager from kernel pools. A kernel pool is a range of memory that can
    be divided into smaller blocks for storing data such as objects. The pool is divided
    into a *paged pool* (whose content may be swapped to disk) and a *non-paged pool*
    (whose content permanently resides in memory). The objects (such as process and
    threads) are kept in a non-paged pool in the kernel, which means they will always
    reside in the physical memory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对象需要内存，而这些内存由Windows内存管理器从内核池中分配。内核池是一个可以被分割成更小块的内存范围，用于存储诸如对象之类的数据。内核池被划分为*分页池*（其内容可以被交换到磁盘）和*非分页池*（其内容永久驻留在内存中）。对象（如进程和线程）被保存在内核的非分页池中，这意味着它们将始终驻留在物理内存中。
- en: 'When the Windows kernel receives the request to create an object (possibly
    due to API calls made by processes such as `CreateProcess` or `CreateFile`), memory
    is allocated for the object either from the paged pool or non-paged pool (depending
    on the object type). This allocation is tagged by prepending a `_POOL_HEADER`
    structure to the object, so that in memory, each object will have a predictable
    structure, similar to the ones shown in the following screenshot. The `_POOL_HEADER`
    structure includes a field named `PoolTag` that contains a four-byte tag (referred
    to as a *pool tag*). This *pool tag* can be used to identify an object. For the
    *process object*, the tag is `Proc` and for the *File object*, the tag is `File`,
    and so on. The `_POOL_HEADER`  structure also contains fields that tell the *size
    of the allocation* and the type of memory (*paged* or *non-paged pool*) it describes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows内核接收到创建对象的请求时（可能是由于进程调用了如`CreateProcess`或`CreateFile`的API），内存将被分配给该对象，可能来自分页池或非分页池（具体取决于对象类型）。这个分配通过在对象前面加上一个`_POOL_HEADER`结构来标记，以便在内存中，每个对象都会有一个可预测的结构，类似于下面的截图所示。`_POOL_HEADER`结构包含一个名为`PoolTag`的字段，存储一个四字节的标签（称为*池标签*）。这个*池标签*可以用来识别对象。对于*进程对象*，标签是`Proc`，对于*文件对象*，标签是`File`，依此类推。`_POOL_HEADER`结构还包含一些字段，告诉内存分配的*大小*以及它所描述的内存类型（*分页池*或*非分页池*）：
- en: '![](../images/00337.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00337.jpeg)'
- en: You can think of all the process objects residing in the non-paged pool of kernel
    memory (which ultimately maps to physical memory) as marked with a tag, `Proc`.
    It is this tag that the Volatility's `psscan` uses as the starting point to identify
    the process object. In particular, it scans the physical memory for the `Proc`
    tag to identify the pool tag allocation associated with the *process object*,
    and it further confirms it by using a more robust signature and heuristics. Once
    the `psscan` finds the process object, it extracts the necessary information from
    its `_EPROCESS` structure. The `psscan` repeats this process until it finds all
    the process objects. In fact, many volatility plugins rely on *pool tag scanning*
    to identify and extract information from the memory image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有驻留在内核内存的非分页池中的进程对象（最终映射到物理内存）视为带有`Proc`标签的对象。正是这个标签，Volatility的`psscan`使用它作为起点来识别进程对象。具体来说，它扫描物理内存中的`Proc`标签，以识别与*进程对象*相关联的池标签分配，并通过使用更强大的签名和启发式方法进一步确认。一旦`psscan`找到进程对象，它会从其`_EPROCESS`结构中提取必要的信息。`psscan`会重复这一过程，直到找到所有的进程对象。事实上，许多Volatility插件依赖于*池标签扫描*来识别并提取内存镜像中的信息。
- en: The `psscan` plugin not only detects the hidden process, because of the approach
    it uses, but it can also detect terminated processes. When an object is destroyed
    (such as when a process is terminated), the memory allocation containing that
    object is released back to the kernel pool, but the content in the memory is not
    immediately overwritten, which means the process object can still be in the memory,
    unless that memory is allocated for a different purpose. If the memory containing
    the terminated process object is not overwritten, then `psscan` can detect the
    terminated process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`psscan` 插件不仅可以检测隐藏的进程，还能通过其使用的方法检测已终止的进程。当一个对象被销毁（例如当进程被终止时），包含该对象的内存分配会被释放回内核池，但内存中的内容不会立即被覆盖，这意味着进程对象仍然可能保留在内存中，除非该内存被分配用于其他用途。如果包含已终止进程对象的内存没有被覆盖，那么
    `psscan` 可以检测到已终止的进程。'
- en: For detailed information on pool tag scanning, refer to the paper *Searching
    for Processes and Threads in Microsoft Windows Memory Dumps *by Andreas Schuster,
    or read the book *The Art of Memory Forensics*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关池标签扫描的详细信息，请参阅 Andreas Schuster 的论文《*在 Microsoft Windows 内存转储中搜索进程和线程*》或阅读书籍《*记忆取证的艺术*》。
- en: At this point, you should have an understanding of how Volatility plugins work;
    most plugins use similar logic. To summarize, critical information exists in the
    data structures maintained by the kernel. The plugins rely on finding and extracting
    information from these data structures. The approach for finding and extracting
    forensic artifacts varies; some plugins rely on walking the doubly linked list
    (like `pslist`), and some use the pool tag scanning technique (such as `psscan`)
    to extract relevant information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该已经了解了 Volatility 插件是如何工作的；大多数插件使用类似的逻辑。总的来说，关键信息存在于由内核维护的数据结构中。插件依赖于从这些数据结构中查找并提取信息。查找和提取取证信息的方法有所不同；有些插件依赖于遍历双向链表（例如
    `pslist`），有些则使用池标签扫描技术（例如 `psscan`）来提取相关信息。
- en: 4.3 Determining Process Relationships
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 确定进程关系
- en: 'When examining processes, it can be useful to determine the parent/child relationships
    between the processes. During malware investigation, this will help you understand
    which other processes are related to the malicious process. The `pstree` plugin
    displays the parent-child process relationships by using the output from the `pslist`
    and formatting it in a tree view. In the following example, running the `pstree`
    plugin against an infected memory image displays a process relationship; a child
    process is indented to the right and prepended with periods. From the output,
    you can see that `OUTLOOK.EXE` was started by the `explorer.exe` process. This
    is normal because whenever you launch an application by double-clicking, it is
    the explorer that launches the application. `OUTLOOK.EXE` `(pid 4068)` launched
    `EXCEL.EXE (pid 1124)`, which in turn invoked `cmd.exe (pid 4056)` to execute
    the malware process `doc6.exe (pid 2308)`. By looking at the events, you can assume
    that the user opened a malicious Excel document sent via email, which probably
    exploited a vulnerability or executed a macro code to drop the malware and executed
    it via `cmd.exe`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查进程时，确定进程之间的父子关系是很有用的。在恶意软件调查过程中，这有助于你了解哪些其他进程与恶意进程相关联。`pstree` 插件通过使用 `pslist`
    的输出并以树状视图格式化，显示父子进程关系。在以下示例中，运行 `pstree` 插件对感染的内存镜像进行分析，显示了进程关系；子进程向右缩进并以点号表示。通过输出，你可以看到
    `OUTLOOK.EXE` 是由 `explorer.exe` 进程启动的。这是正常的，因为每当你通过双击启动一个应用程序时，启动该应用程序的正是资源管理器。`OUTLOOK.EXE`
    `(pid 4068)` 启动了 `EXCEL.EXE (pid 1124)`，而后者又调用了 `cmd.exe (pid 4056)` 来执行恶意进程 `doc6.exe
    (pid 2308)`。通过查看这些事件，你可以推测用户打开了通过电子邮件发送的恶意 Excel 文档，该文档可能利用了一个漏洞或执行了宏代码，从而下载并通过
    `cmd.exe` 执行了恶意软件。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the `pstree` plugin relies on the `pslist` plugin, it cannot list the
    hidden or terminated processes. Another method to determine the process relationship
    is to use the `psscan` plugin to generate a visual representation of the parent/child
    relationships. The following `psscan` command prints the output in the *dot* format,
    which can then be opened with Graph Visualization Software such as *Graphviz*
    ([https://www.graphviz.org/](https://www.graphviz.org/)) or *XDot* (which can
    be installed on a Linux system using `sudo apt install xdot`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pstree` 插件依赖于 `pslist` 插件，因此无法列出隐藏或已终止的进程。另一种确定进程关系的方法是使用 `psscan` 插件生成父子关系的可视化表示。以下
    `psscan` 命令以 *dot* 格式打印输出，然后可以使用图形可视化软件（如 *Graphviz* [https://www.graphviz.org/](https://www.graphviz.org/)
    或 *XDot*）打开（可以通过在 Linux 系统上运行 `sudo apt install xdot` 来安装 XDot）：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Opening the *infected.dot* file with XDot displays the relationship between
    the processes discussed previously:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XDot 打开 *infected.dot* 文件，显示之前讨论的进程之间的关系：
- en: '![](../images/00338.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00338.jpeg)'
- en: 4.4 Process Listing Using psxview
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 使用 psxview 列出进程
- en: 'Previously, you saw how process listing could be manipulated to hide a process;
    you also understood how `psscan` uses pool tag scanning to detect the hidden process.
    It turns out that `_POOL_HEADER` (which `psscan` relies on) is only used for debugging
    purposes, and it does not affect the stability of the operating system. This means
    an attacker can install a kernel driver to run in the kernel space and modify
    the pool tags or any other field in the `_POOL_HEADER.` By modifying the pool
    tag, an attacker can prevent the plugins that rely on *pool tag scanning* from
    working properly. In other words, by modifying the pool tag, it is possible to
    hide the process from the `psscan`. To overcome this problem, The `psxview` plugin
    relies on extracting process information from different sources. It enumerates
    the process in seven different ways. By comparing the output from different sources,
    it is possible to detect discrepancies caused by the malware. In the following
    screenshot, `psxview` enumerates the processes using seven different techniques.
    Each process'' information is displayed as a single row, and the techniques it
    uses are displayed as columns containing `True` or `False`. A `False` value under
    a particular column indicates that the process was not found using the respective
    method. In the following output, `psxview` detected the hidden process `nvid.exe`
    `(pid 1700)` using all the methods except the `pslist` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你已经看到如何操控进程列表来隐藏进程；你还理解了 `psscan` 如何通过池标签扫描来检测隐藏的进程。事实证明，`_POOL_HEADER`（`psscan`
    依赖的字段）仅用于调试目的，并不会影响操作系统的稳定性。这意味着攻击者可以安装一个内核驱动程序，运行在内核空间，并修改池标签或 `_POOL_HEADER`
    中的任何其他字段。通过修改池标签，攻击者可以防止依赖 *池标签扫描* 的插件正常工作。换句话说，通过修改池标签，攻击者可以将进程从 `psscan` 中隐藏。为了解决这个问题，`psxview`
    插件依赖于从不同来源提取进程信息。它通过七种不同的方式列举进程。通过比较来自不同来源的输出，可以检测到恶意软件引起的差异。在下面的截图中，`psxview`
    使用七种不同的技术列出了进程。每个进程的信息以单独的行显示，使用的技术显示为包含 `True` 或 `False` 的列。某一列下的 `False` 值表示该进程未通过相应方法找到。在以下输出中，`psxview`
    使用所有方法检测到隐藏的进程 `nvid.exe`（`pid 1700`），除了 `pslist` 方法：
- en: '![](../images/00339.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00339.jpeg)'
- en: 'In the preceding screenshot, you will notice false values for a few processes.
    For example, the `cmd.exe` process is not present in any of the methods except
    the `psscan` method. You might think that `cmd.exe` is hidden, but that is not
    true; the reason why you see `False` is that `cmd.exe` is terminated (you can
    tell that from the `ExitTime` column). As a result, all other techniques were
    not able to find it where `psscan` was able to find it, because pool tag scanning
    can detect terminated process. In other words, a `False` value in a column does
    not necessarily mean that the process is hidden from that method; it can also
    mean that it is expected (depending on how and from where that method is getting
    the process information). To know whether it is expected or not, you can use the `-R
    (--apply-rules)` option as follows. In the following screenshot, notice how the
    `False` values are replaced with `Okay`**.** An `Okay` means `False`, but it is
    an expected behavior. After running the `psxview` plugin with `-R` (`--apply-rules`),
    if you still see a `False` value (such as `nvid.exe` with `pid 1700` in the following
    screenshot), then it is a strong indication that the process is hidden from that
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你会注意到一些进程显示为“假”值。例如，`cmd.exe` 进程除 `psscan` 方法外，在其他任何方法中都不存在。你可能会认为 `cmd.exe`
    被隐藏了，但事实并非如此；你看到 `False` 的原因是 `cmd.exe` 已经终止（你可以从 `ExitTime` 列看出这一点）。因此，所有其他技术都未能找到它，而
    `psscan` 方法能找到它，因为池标签扫描能够检测已终止的进程。换句话说，某一列中的 `False` 值并不一定意味着该进程对该方法是隐藏的；它也可能意味着这种情况是预期中的（取决于该方法如何以及从哪里获取进程信息）。要知道这是否是预期的，你可以使用
    `-R (--apply-rules)` 选项，如下所示。在下面的截图中，注意 `False` 值是如何被替换为 `Okay` 的**。** `Okay`
    表示 `False`，但这是预期的行为。在使用 `-R`（`--apply-rules`）运行 `psxview` 插件后，如果你仍然看到 `False`
    值（例如以下截图中的 `nvid.exe`，`pid 1700`），那么这强烈表明该进程对该方法是隐藏的：
- en: '![](../images/00340.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00340.jpeg)'
- en: 5\. Listing Process Handles
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 列出进程句柄
- en: During your investigation, once you pin down a malicious process, you may want
    to know which objects (such as processes, files, registry keys, and so on) the
    process is accessing. This will give you an idea of the components associated
    with the malware and an insight into their operation, for example, a keylogger
    may be accessing a log file to log captured keystrokes, or malware might have
    an open handle to the configuration file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查过程中，一旦锁定了一个恶意进程，你可能希望了解该进程正在访问哪些对象（如进程、文件、注册表项等）。这将帮助你了解与恶意软件相关的组件以及它们的操作方式。例如，一个键盘记录器可能正在访问一个日志文件以记录捕获的按键，或者恶意软件可能已经打开了一个配置文件的句柄。
- en: To access an object, a process needs to first open a handle to that object by
    calling an API such as `CreateFile` or `CreateMutex.` Once it opens a handle to
    an object, it uses that handle to perform subsequent operations such as writing
    to a file or reading from a file. A handle is an indirect reference to an object;
    think of a handle as something that represents an object (the handle is not the
    object itself). The objects reside in the kernel memory, whereas the process runs
    in the user space, because of which a process cannot access the objects directly,
    hence it uses a handle which represents that object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个对象，进程首先需要通过调用 `CreateFile` 或 `CreateMutex` 等 API 来打开该对象的句柄。一旦打开了对象的句柄，它就可以使用该句柄执行后续操作，如写入文件或读取文件。句柄是对象的间接引用；可以把句柄看作是代表一个对象的东西（句柄不是对象本身）。这些对象存在于内核内存中，而进程运行在用户空间中，因此进程无法直接访问对象，它通过使用句柄来代表该对象。
- en: Each process is given a private handle table that resides in the kernel memory.
    This table contains all the kernel objects such as files, processes, and network
    sockets that are associated with the process. The question is, how does this table
    get populated? When the kernel gets the request from a process to create an object
    (via an API such as `CreateFile`), the object is created in the *kernel memory.*
    The pointer to the object is placed in the first available slot in the process
    handle table, and the corresponding index value is returned to the process. The
    index value is the handle which represents the object, and the handle is used
    by the process to perform subsequent operations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个私有的句柄表，存储在内核内存中。这个表包含与进程相关联的所有内核对象，例如文件、进程和网络套接字。问题是，这个表是如何填充的？当内核接收到来自进程的请求以创建对象（通过如
    `CreateFile` 等 API），该对象将在 *内核内存* 中创建。指向该对象的指针会放入进程句柄表中的第一个可用槽中，并将相应的索引值返回给进程。该索引值就是表示该对象的句柄，进程会使用该句柄执行后续操作。
- en: 'On a live system, you can inspect the kernel objects accessed by a particular
    process using the *Process Hacker* tool. To do that, launch Process Hacker as
    an *Administrator***,** right-click on any process, and then select the *Handles*
    tab. The following screenshot shows the process handles of the *csrss.exe* process.
    *csrss.exe* is a legitimate operating system process that plays a role in the
    creation of every process and thread. For this reason, you will see *csrss.exe*
    having open handles to most of the processes (except itself and its parent processes)
    running on the system. In the following screenshot, the third column is the *handle
    value*, and the fourth column shows the *address of the object* in the kernel
    memory. For example, the first process, *wininit.exe*, is located at address `0x8705c410`
    (the address of its `_EPROCESS` structure) in the kernel memory, and the handle
    value representing this object is `0x60`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个实时系统中，你可以使用 *Process Hacker* 工具检查特定进程访问的内核对象。为此，启动 Process Hacker 并以 *管理员*
    身份运行，右键单击任意进程，然后选择 *Handles* 标签。以下截图显示了 *csrss.exe* 进程的进程句柄。*csrss.exe* 是一个合法的操作系统进程，参与每个进程和线程的创建。因此，你会看到
    *csrss.exe* 打开了大多数进程（除了它自己和它的父进程）的句柄。以下截图中，第三列是 *句柄值*，第四列显示了 *对象的地址* 在内核内存中的位置。例如，第一个进程
    *wininit.exe* 位于内核内存地址 `0x8705c410`（它的 `_EPROCESS` 结构的地址），表示该对象的句柄值是 `0x60`：
- en: '![](../images/00341.jpeg)One of the methods used by the `psxview` plugin relies
    on walking the *csrss.exe* process''s handle table to identify the process objects.
    If there are multiples instances of *csrss.exe*, then `psxview` parses the handle
    table of all *csrss.exe* instances to list the running processes, except the *csrss.exe*
    process and its parent processes (the *smss.exe* and *system* processes).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00341.jpeg) `psxview` 插件使用的方法之一依赖于遍历 *csrss.exe* 进程的句柄表来识别进程对象。如果存在多个
    *csrss.exe* 实例，`psxview` 将解析所有 *csrss.exe* 实例的句柄表，以列出正在运行的进程，除了 *csrss.exe* 进程及其父进程（*smss.exe*
    和 *system* 进程）。'
- en: 'From the memory image, you can get a list of all the kernel objects that were
    accessed by a process using the `handles` plugin. The following screenshot displays
    the handles of the process with `pid 356`. If you run the `handles` plugin without
    `-p` options, it will display handle information for all the processes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存镜像中，你可以通过 `handles` 插件获取所有被进程访问的内核对象的列表。以下截图展示了 `pid 356` 进程的句柄。如果你在没有 `-p`
    选项的情况下运行 `handles` 插件，它将显示所有进程的句柄信息：
- en: '![](../images/00342.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00342.jpeg)'
- en: 'You can also filter the results for a specific object type (`File`, `Key`,
    `Process`, `Mutant`, and so on) using the `-t` option. In the following example,
    the `handles` plugin was run against the memory image infected with *Xtreme RAT*.
    The handles `plugin` was used to list the mutexes opened by the malicious process
    (with `pid 1772`). From the following output, you can see that *Xtreme RAT* creates
    a mutex called `oZ694XMhk6yxgbTA0` to mark its presence on the system. A mutex
    such as the one created by *Xtreme RAT* can make a good host-based indicator to
    use in host-based monitoring:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `-t` 选项来过滤特定对象类型（如 `File`、`Key`、`Process`、`Mutant` 等）的结果。在以下示例中，`handles`
    插件被运行在一个感染了 *Xtreme RAT* 的内存镜像上。`handles` 插件被用来列出恶意进程（`pid 1772`）打开的互斥体。从以下输出中，你可以看到
    *Xtreme RAT* 创建了一个名为 `oZ694XMhk6yxgbTA0` 的互斥体，以标记其在系统中的存在。像 *Xtreme RAT* 创建的这样的互斥体可以作为一个很好的主机基础指示器，用于主机基础监控：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the following example of a memory image that''s been infected with the *TDL3
    rootkit*, the `svchost.exe` process `(pid 880)` has open file handles to the malicious
    DLL and the kernel driver associated with the rootkit:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的内存镜像示例中，感染了*TDL3 rootkit*，`svchost.exe`进程（`pid 880`）打开了恶意 DLL 文件和与 rootkit
    相关的内核驱动程序的文件句柄：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6\. Listing DLLs
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 列出 DLL 文件
- en: 'Throughout this book, you have seen examples of malware using DLL to implement
    the malicious functionality. Therefore, in addition to investigating processes,
    you may also want to examine the list of loaded libraries. To list the loaded
    modules (executable and DLLs), you can use Volatility''s `dlllist` plugin. The
    `dlllist` plugin also displays the full path associated with a process. Let''s
    take an example of the malware named *Ghost RAT*. It implements the malicious
    functionality as the *Service DLL*, and as a result, the malicious DLL gets loaded
    by the `svchost.exe` process (for more information on Service DLL, refer to the* Service*
    section in [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485),
    *Malware Functionalities and Persistence*). The following is the output from the
    `dlllist`, where you can see a suspicious module with a non-standard extension
    `(.ddf)` loaded by the `svchost.exe` process (`pid 800`). The first column, `Base`,
    specifies the base address, that is, the address in the memory where the module
    is loaded:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经看到了恶意软件使用 DLL 实现恶意功能的例子。因此，除了调查进程外，你可能还需要检查加载的库列表。要列出已加载的模块（可执行文件和 DLL），你可以使用
    Volatility 的 `dlllist` 插件。`dlllist` 插件还显示与进程相关联的完整路径。让我们以名为*Ghost RAT*的恶意软件为例。它将恶意功能实现为*Service
    DLL*，因此，恶意 DLL 被 `svchost.exe` 进程加载（有关 Service DLL 的更多信息，请参阅[第 7 章](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485)，*恶意软件功能和持久性*）。以下是
    `dlllist` 的输出，其中可以看到由 `svchost.exe` 进程（`pid 800`）加载的一个具有非标准扩展名 `(.ddf)` 的可疑模块。第一列，`Base`，指定了基地址，即模块加载在内存中的地址：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `dlllist` plugin gets the information about the loaded modules from a structure
    named the *Process Environment Block (PEB)*. If you recall from [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485), *Code
    Injection and Hooking*, when covering the process memory components, I mentioned
    that the *PEB* structure resides in the process memory (in the user space). The
    PEB contains metadata information about where the process executable is loaded,
    its full path on the disk, and information about the loaded modules (executable
    and DLLs). The `dlllist` plugin finds the *PEB* structure of each process and
    gets the preceding information. Then, the question is, how do you find the PEB
    structure? The `_EPROCESS` structure has a field named `Peb` that contains the
    pointer to the *PEB.* What this means is that once the plugin finds the `_EPROCESS`
    structure, it can find the *PEB*. A point to remember is that `_EPROCESS` resides
    in the kernel memory (kernel space), whereas the `PEB` resides in the process
    memory (user-space).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlllist` 插件从名为*进程环境块（PEB）*的结构中获取有关加载模块的信息。如果你回想一下[第 8 章](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485)，*代码注入与钩子*，在讲解进程内存组件时，我提到过*PEB*
    结构位于进程内存中（用户空间）。PEB 包含关于进程可执行文件加载位置、磁盘上的完整路径以及已加载模块（可执行文件和 DLL）的元数据。`dlllist`
    插件查找每个进程的*PEB* 结构并获取上述信息。那么，问题是，如何找到 PEB 结构呢？`_EPROCESS` 结构有一个名为 `Peb` 的字段，里面包含指向*PEB*的指针。这意味着，一旦插件找到了
    `_EPROCESS` 结构，它就可以找到*PEB*。需要记住的一点是，`_EPROCESS` 位于内核内存（内核空间），而 `PEB` 位于进程内存（用户空间）。'
- en: 'To get the address of the *PEB* in a debugger, you can use the `!process` extension
    command, which shows the address of the `_EPROCESS` structure. It also specifies
    the address of the *PEB*. From the following output, you can see that the PEB
    of the `explorer.exe` process is at address `7ffd3000` in its process memory,
    and its `_EPROCESS` structure is at `0x877ced28` (in its kernel memory):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在调试器中获取*PEB*的地址，你可以使用 `!process` 扩展命令，该命令显示 `_EPROCESS` 结构的地址。它还指定了*PEB*的地址。从以下输出中可以看到，`explorer.exe`
    进程的 PEB 位于其进程内存中的地址 `7ffd3000`，而其 `_EPROCESS` 结构位于 `0x877ced28`（在其内核内存中）：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another method to determine the address of the PEB is to use the `display type
    (dt)` command. You can find the address of the *PEB* of the `explorer.exe` process
    by examining the `Peb` field in its `EPROCESS` structure, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种确定 PEB 地址的方法是使用 `display type (dt)` 命令。你可以通过检查 `explorer.exe` 进程的 `EPROCESS`
    结构中的 `Peb` 字段来找到其*PEB*的地址，如下所示：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You now know how to find the *PEB*, so now, let''s try to understand what kind
    of information *PEB* contains. To get the human-readable summary of the *PEB*
    for a given process, first, you need to switch to the context of the process whose
    *PEB* you want to examine. This can be done using the `.process` extension command.
    This command accepts the address of the `_EPROCESS` structure. The following command
    sets the current process context to the `explorer.exe` process:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何找到*PEB*，接下来，我们来了解一下*PEB*包含什么样的信息。要获取给定进程的*PEB*的人类可读摘要，首先，你需要切换到你想要检查其*PEB*的进程上下文。这可以通过使用`.process`扩展命令来完成。该命令接受`_EPROCESS`结构的地址。以下命令将当前进程上下文设置为`explorer.exe`进程：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can then use the `!peb` extension command followed by the address of the
    *PEB*. In the following output, some of the information is truncated for the sake
    of brevity. The `ImageBaseAddress` field specifies the address where the process
    executable (`explorer.exe`) is loaded in the memory. The *PEB* also contains another
    structure called the Ldr structure (of type `_PEB_LDR_DATA`), which maintains
    three doubly linked lists, which are `InLoadOrderModuleList`, `InMemoryOrderModuleList`,
    and `InInitializationOrderModuleList.` Each of these three doubly linked lists
    contains information regarding the modules (process executable and DLLs). It is
    possible to get information regarding the modules by walking any of these doubly
    linked lists. `InLoadOrderModuleList` organizes modules in the order in which
    they are loaded, `InMemoryOrderModuleList` organizes modules in the order in which
    they reside in the process memory, and `InInitializationOrderModuleList` organizes
    modules in the order in which their `DllMain` function was executed:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`!peb`扩展命令，后跟*PEB*的地址。在以下输出中，为了简洁起见，部分信息被省略。`ImageBaseAddress`字段指定了进程可执行文件（`explorer.exe`）在内存中加载的地址。*PEB*还包含另一个结构，称为Ldr结构（类型为`_PEB_LDR_DATA`），它维护三个双向链表，分别是`InLoadOrderModuleList`、`InMemoryOrderModuleList`和`InInitializationOrderModuleList`。这三种双向链表中的每一项都包含关于模块的信息（包括进程可执行文件和DLL）。通过遍历这些双向链表中的任何一个，你都可以获取有关模块的信息。`InLoadOrderModuleList`按照模块加载的顺序组织模块，`InMemoryOrderModuleList`按照模块在进程内存中驻留的顺序组织模块，`InInitializationOrderModuleList`按照其`DllMain`函数执行的顺序组织模块：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In other words, all the three PEB lists contain information about the loaded
    modules such as the base address, size, the full path associated with the module,
    and so on. An important point to remember is that `InInitializationOrderModuleList`
    will not contain the information about the process executable because the executable,
    is initialized differently as compared to the DLLs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这三种PEB链表都包含关于已加载模块的信息，例如基地址、大小、与模块相关的完整路径等。需要记住的一个重要点是，`InInitializationOrderModuleList`不包含进程可执行文件的信息，因为可执行文件与DLL的初始化方式不同。
- en: 'To help you understand better, the following diagram uses `Explorer.exe` as
    an example (the concept is similar to other processes as well). When `Explorer.exe`
    is executed, its process executable is loaded into the process memory at some
    address (let''s say `0xb0000`) with `PAGE_EXECUTE_WRITECOPY` (`WCX`) protection.
    The associated DLLs are also loaded into the process memory. The process memory
    also includes the PEB structure which contains metadata information of where the
    `explorer.exe` is loaded (base address) in the memory. The `Ldr` structure in
    the PEB maintains three doubly linked lists; each element is a structure (of type
    `_LDR_DATA_TABLE_ENTRY`) that contains information (base address, full path, and
    so on) about the loaded modules. The `dlllist` plugin relies on walking the `InLoadOrderModuleList`
    to get the module''s information:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解，以下图示使用`Explorer.exe`作为示例（这一概念也适用于其他进程）。当`Explorer.exe`执行时，它的进程可执行文件会以某个地址（假设是`0xb0000`）加载到进程内存中，并具有`PAGE_EXECUTE_WRITECOPY`（`WCX`）保护。相关的DLL也会被加载到进程内存中。进程内存还包括PEB结构，其中包含有关`explorer.exe`在内存中加载位置（基地址）的元数据。PEB中的`Ldr`结构维护三个双向链表；每个元素是一个结构（类型为`_LDR_DATA_TABLE_ENTRY`），它包含有关已加载模块的信息（基地址、完整路径等）。`dlllist`插件依赖于遍历`InLoadOrderModuleList`来获取模块的信息：
- en: '![](../images/00343.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00343.jpeg)'
- en: The problem with getting the module information from any of these three PEB
    lists is that they are susceptible to *DKOM* attacks. All three PEB lists reside
    in the user space, which means an attacker can load the malicious DLL into the
    address space of a process and can unlink the malicious DLL from one or all PEB
    lists to hide from the tools which rely on walking these lists. To overcome this
    problem, we can use another plugin named `ldrmodules`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这三个 PEB 列表中获取模块信息的问题在于，它们容易受到 *DKOM* 攻击。这三个 PEB 列表都位于用户空间，这意味着攻击者可以将恶意 DLL
    加载到进程的地址空间中，并将恶意 DLL 从一个或所有 PEB 列表中解绑，从而隐藏起来，避开依赖于遍历这些列表的工具。为了解决这个问题，我们可以使用另一个插件，名为
    `ldrmodules`。
- en: 6.1 Detecting a Hidden DLL Using ldrmodules
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 使用 ldrmodules 检测隐藏的 DLL
- en: 'The `ldrmodules` plugin compares module information from the three PEB lists
    (in the process memory) with the information from a data structure residing in
    the kernel memory known as *VADs* (*Virtual Address Descriptors*). The memory
    manager uses VADs to keep track of whichvirtual addresses in the process memory
    that are reserved (or free). The VAD is a binary tree structure that stores information
    about the virtually contiguous memory regions in the process memory. For each
    process, the memory manager maintains a set of VADs and each VAD node describes
    a virtually contiguous memory region. If the process memory region contains a
    memory-mapped file (such as an executable, DLL), then the VAD node stores information
    about its base address, file path, and memory protection. The following example
    should help you understand this concept. In the following screenshot, one of the
    VAD nodes in the kernel space is describing information about where the process
    executable (*explorer.exe*) is loaded, its full path, and memory protection. Similarly,
    other VAD nodes will describe process memory ranges, including the ones that contain
    mapped executable images such as DLLs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldrmodules` 插件将进程内存中的三个 PEB 列表中的模块信息与存在于内核内存中的一种数据结构——*VADs*（*虚拟地址描述符*）的信息进行比较。内存管理器使用
    VADs 跟踪进程内存中哪些虚拟地址已被保留（或空闲）。VAD 是一种二叉树结构，存储有关进程内存中虚拟连续内存区域的信息。对于每个进程，内存管理器维护一组
    VADs，每个 VAD 节点描述一个虚拟连续的内存区域。如果进程内存区域包含内存映射文件（例如可执行文件、DLL），则 VAD 节点存储其基地址、文件路径和内存保护信息。以下示例应能帮助你理解这个概念。在以下截图中，内核空间中的一个
    VAD 节点描述了进程可执行文件（*explorer.exe*）的加载位置、其完整路径和内存保护。类似地，其他 VAD 节点将描述进程内存范围，包括包含映射的可执行映像（如
    DLL）的范围：'
- en: '![](../images/00344.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00344.jpeg)'
- en: 'To get the module''s information, the `ldrmodules` plugin enumerates all the
    VAD nodes that contain mapped executable images and compares the results with
    the three PEB lists to identify any discrepancies. The following is the module
    listing of a process from a memory image infected with the *TDSS rootkit* (which
    we saw earlier). You can see that the `ldrmodules` plugin was able to identify
    a malicious DLL called `TDSSoiqh.dll`, which hides from all the three PEB lists
    (`InLoad`, `InInit`, and `InMem`). The `InInit` value is set to `False` for `svchost.exe`, which
    is expected for an executable, as mentioned earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取模块的信息，`ldrmodules` 插件枚举所有包含映射可执行映像的 VAD 节点，并将结果与三个 PEB 列表进行比较，以识别任何不一致之处。以下是来自一个被
    *TDSS rootkit*（我们之前看到的）感染的内存镜像中进程的模块列表。你可以看到，`ldrmodules` 插件成功识别出一个名为 `TDSSoiqh.dll`
    的恶意 DLL，该 DLL 在所有三个 PEB 列表（`InLoad`、`InInit` 和 `InMem`）中都隐藏了。`InInit` 值对于 `svchost.exe`
    被设置为 `False`，这对于可执行文件来说是预期的，正如前面所提到的：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7\. Dumping an Executable and DLL
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 转储可执行文件和 DLL
- en: 'After you have identified the malicious process or DLL, you may want to dump
    it for further investigation (such as for extracting strings, running yara rules,
    disassembly, or scanning with Antivirus software). To dump a process executable
    from memory to disk, you can use the `procdump` plugin. To dump the process executable,
    you need to know either its process ID or its physical offset. In the following
    example of a memory image infected with *Perseus malware* (covered previously
    while discussing the `pslist` plugin), the `procdump` plugin is used to dump its
    malicious process executable `svchost..exe` (`pid 3832`). With the `-D` (`--dump-dir`)
    option, you specify the name of the directory in which to dump executable files.
    The dumped file is named based on the pid of a process such as `executable.PID.exe`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了恶意进程或DLL后，您可能希望转储它以便进一步调查（例如提取字符串、运行YARA规则、反汇编或使用杀毒软件扫描）。要将进程可执行文件从内存转储到磁盘，可以使用`procdump`插件。要转储进程可执行文件，您需要知道其进程ID或物理偏移量。在下面的示例中，内存镜像被*Perseus恶意软件*感染（之前在讨论`pslist`插件时有提到），`procdump`插件用于转储其恶意进程可执行文件`svchost..exe`（`pid
    3832`）。使用`-D`（`--dump-dir`）选项，您可以指定要转储可执行文件的目录名称。转储的文件名基于进程的pid，例如`executable.PID.exe`：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To dump a process with the physical offset, you can use the `-o (--offset)`
    option, which is useful if you want to dump a hidden process from memory. In the
    following example of a memory image infected with `prolaco` malware (covered previously
    while discussing the `psscan` plugin), the hidden process is dumped using its
    physical offset. The physical offset was determined from the `psscan` plugin.
    You can also get the physical offset from the `psxview` plugin.  When using the
    `procdump` plugin, if you don''t specify the `-p (--pid)` or `-o (--offset)` option,
    then it will dump the process executables of all the active processes running
    on the system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要转储带有物理偏移量的进程，可以使用`-o (--offset)`选项。如果您想从内存中转储隐藏进程，这个选项非常有用。在下面的示例中，内存镜像被`prolaco`恶意软件感染（之前在讨论`psscan`插件时有提到），通过物理偏移量转储了隐藏进程。物理偏移量是通过`psscan`插件确定的。您也可以通过`psxview`插件获取物理偏移量。使用`procdump`插件时，如果没有指定`-p
    (--pid)`或`-o (--offset)`选项，则会转储系统上所有正在运行的活动进程的可执行文件：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similar, to the process executable, you can dump a malicious DLL to disk using
    the `dlldump` plugin. To dump the DLL, you need to specify the process ID (`-p`
    option) of the process that loaded the DLL, and the base address of the DLL, using
    the `-b (--base)` option. You can get the base address of a DLL from the `dlllist`
    or `ldrmodules` output. In the following example of a memory image infected with
    *Ghost RAT* (which we covered while discussing the `dlllist` plugin), the malicious
    DLL loaded by the `svchost.exe` (`pid 880`) process is dumped using the `dlldump`
    plugin:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程可执行文件类似，您可以使用`dlldump`插件将恶意DLL转储到磁盘。要转储DLL，您需要指定加载该DLL的进程ID（`-p`选项）和DLL的基址，使用`-b
    (--base)`选项。您可以从`dlllist`或`ldrmodules`输出中获取DLL的基址。在下面的示例中，内存镜像被*Ghost RAT*恶意软件感染（我们在讨论`dlllist`插件时有提到），`svchost.exe`（`pid
    880`）进程加载的恶意DLL被`dlldump`插件转储：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 8\. Listing Network Connections and Sockets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 列出网络连接和套接字
- en: 'Most malicious programs perform some network activity, either to download additional
    components, to receive commands from the attacker, to exfiltrate data, or to create
    a remote backdoor on the system. Inspecting the networking activity will help
    you determine the network operations of the malware on the infected system. In
    many cases, it is useful to associate the process running on the infected system
    with the activities detected on the network. To determine the active network connections
    on pre-vista systems (such as Windows XP and 2003), you can use the `connections`
    plugin. The following command shows an example of using the `connections` plugin
    to print the active connections from a memory dump infected with *BlackEnergy*
    malware. From the following output, you can see that the process with a process
    ID of `756` was responsible for the C2 communication on port `443`. After running
    the `pslist` plugin, you can tell that the pid of `756` is associated with the
    `svchost.exe` process:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数恶意程序会执行一些网络活动，要么是下载附加组件，要么是接收攻击者的命令，要么是窃取数据，或是在系统上创建远程后门。检查网络活动将帮助你确定恶意软件在感染系统上的网络操作。在许多情况下，将运行在感染系统上的进程与网络上检测到的活动关联起来非常有用。为了确定在
    Vista 之前的系统（如 Windows XP 和 2003）上的活动网络连接，你可以使用 `connections` 插件。以下命令显示了使用 `connections`
    插件从感染了 *BlackEnergy* 恶意软件的内存转储中打印活动连接的示例。从以下输出中，你可以看到进程 ID 为 `756` 的进程负责了端口 `443`
    上的 C2 通信。在运行 `pslist` 插件之后，你可以得知 `756` 的 pid 与 `svchost.exe` 进程相关联：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another plugin that you can use to list the network connections on pre-vista
    systems is `connscan`.  It uses the pool tag scanning approach to determine the
    connections. As a result, it can also detect terminated connections. In the following
    example of the memory image infected with *TDL3* rootkit, the `connections` plugin
    does not return any results, whereas the `connscan` plugin displays the network
    connections. This does not necessarily mean that the connection is hidden, it
    just means that the network connection was not active (or terminated) when the
    memory image was acquired:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可以在 Vista 之前的系统上使用来列出网络连接的插件是 `connscan`。它使用池标签扫描方法来确定连接。因此，它也可以检测到已终止的连接。在以下的内存镜像感染
    *TDL3* rootkit 的示例中，`connections` 插件没有返回任何结果，而 `connscan` 插件则显示了网络连接。这并不一定意味着连接被隐藏，只是意味着在获取内存镜像时，网络连接并未处于活动状态（或已被终止）：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sometimes, you may want to get the information about the open sockets and their
    associated processes. On pre-vista systems, you can get the information about
    the open ports using the `sockets` and `sockscan` plugins. The `sockets` plugin
    prints the list of open sockets, and the `sockscan` plugin uses the pool tag scanning
    approach. As a result, it can detect the ports that have been closed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要获取关于打开的套接字及其关联进程的信息。在 Vista 之前的系统上，你可以使用 `sockets` 和 `sockscan` 插件来获取打开端口的信息。`sockets`
    插件打印出打开套接字的列表，而 `sockscan` 插件使用池标签扫描方法。因此，它可以检测到已关闭的端口。
- en: 'On Vista and later systems (such as Windows 7), you can use the `netscan` plugin
    to display both the network connections and the sockets. The `netscan` plugin
    uses the pool tag scanning approach, similar to the `sockscan` and `connscan`
    plugins. In the following example of the memory image being infected with *Darkcomet
    RAT*, the `netscan` plugin displays C2 communication on port `81`, which has been
    made by the malicious process `dmt.exe (pid 3768)`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vista 及更高版本的系统（如 Windows 7）上，你可以使用 `netscan` 插件来显示网络连接和套接字。`netscan` 插件使用池标签扫描方法，类似于
    `sockscan` 和 `connscan` 插件。在以下的内存镜像被 *Darkcomet RAT* 感染的示例中，`netscan` 插件显示了在端口
    `81` 上的 C2 通信，这是由恶意进程 `dmt.exe (pid 3768)` 发起的：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 9\. Inspecting Registry
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 检查注册表
- en: 'From a forensics perspective, the registry can provide valuable information
    about the context of the malware. While discussing the persistence methods in
    [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485), *Malware Functionalities
    and Persistence*, you saw how malicious programs add entries in the registry to
    survive the reboot. In addition to persistence, the malware uses the registry
    to store configuration data, encryption keys, and so on. To print the registry
    key, subkeys, and its values, you can use the `printkey` plugin by providing the
    desired registry key path using the `-K` (`--key`) argument. In the following
    example of a memory image infected with *Xtreme Rat*, it adds the malicious executable
    `C:\Windows\InstallDir\system.exe` in the Run registry key. As a result, the malicious
    executable will be executed every time the system starts:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证角度来看，注册表可以提供有关恶意软件上下文的宝贵信息。在讨论[第7章](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485)《恶意软件功能与持久性》中的持久性方法时，您已经看到恶意程序如何通过向注册表中添加条目来实现重启后的生存。除了持久性，恶意软件还使用注册表来存储配置数据、加密密钥等。要打印注册表键、子键及其值，您可以使用`printkey`插件，并通过`-K`（`--key`）参数提供所需的注册表键路径。在以下受*Xtreme
    Rat*感染的内存镜像示例中，它将恶意可执行文件`C:\Windows\InstallDir\system.exe`添加到“运行”注册表键中。因此，每次系统启动时，恶意可执行文件都会被执行：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following example, the *Darkcomet RAT* adds an entry in the registry
    to load its malicious `DLL (mph.dll)` via `rundll32.exe`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，*Darkcomet RAT*在注册表中添加了一条条目，通过`rundll32.exe`加载其恶意的`DLL (mph.dll)`：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are other registry keys that store valuable information in binary form,
    which can be of great value to a forensic investigator. The volatility plugins
    such as `userassist`, `shellbags`, and `shimcache` parse these registry keys that
    contain binary data and display information in a much more readable format.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他注册表键存储着以二进制形式存在的宝贵信息，对于取证调查员来说，这些信息极具价值。Volatility插件，如`userassist`、`shellbags`和`shimcache`，可以解析这些包含二进制数据的注册表键，并以更易读的格式显示信息。
- en: 'The `Userassist` registry key contains a list of programs that have been executed
    by the user on the system and the time when the program was run. To print `userassist`
    registry information, you can use Volatility''s `userassist` plugin, as shown
    here. In the following example, a suspiciously named executable `(info.doc.exe)`
    was executed from the **E:\** drive (possibly the USB drive) at `2018-04-30 06:42:37`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Userassist`注册表键包含了用户在系统上执行的程序列表以及程序执行的时间。要打印`userassist`注册表信息，您可以使用Volatility的`userassist`插件，如下所示。在以下示例中，一个名为(info.doc.exe)的可疑可执行文件在`2018-04-30
    06:42:37`从**E:\**驱动器（可能是USB驱动器）执行：'
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `shimcache` and `shellbags` plugins can be useful when investigating a malware
    incident. The `shimcache` plugin can be helpful for proving the existence of a
    malware on the system and the time it ran. The `shellbags` plugin can give information
    about access to the files, folder, external storage devices, and network resources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查恶意软件事件时，`shimcache`和`shellbags`插件非常有用。`shimcache`插件有助于证明恶意软件在系统上的存在及其运行时间。`shellbags`插件则可以提供有关对文件、文件夹、外部存储设备和网络资源访问的信息。
- en: 10\. Investigating Service
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 服务调查
- en: 'In [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485), *Malware
    Functionalities and Persistence*, we looked at how an attacker can persist on
    the system by installing on or modifying an existing service. In this section,
    we will focus on how to investigate services from the memory image. To list the
    services and their information such as *display name*, *type of service,* and
    *startup type* from the memory image, you can use the `svcscan` plugin. In the
    following example, the malware creates a service of type `WIN32_OWN_PROCESS` with
    the display name and service name as `svchost`. From the binary path, you can
    tell that the `svchost.exe` is malicious because it is running from the non-standard
    path *C:\Windows* instead of *C:\Windows\System32*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485)《恶意软件功能与持久性》中，我们探讨了攻击者如何通过安装或修改现有服务来在系统上保持持久性。在本节中，我们将重点讨论如何从内存镜像中调查服务。要列出服务及其信息，例如*显示名称*、*服务类型*和*启动类型*，您可以使用`svcscan`插件。在以下示例中，恶意软件创建了一个类型为`WIN32_OWN_PROCESS`的服务，显示名称和服务名称均为`svchost`。从二进制路径中可以看出，`svchost.exe`是恶意的，因为它是从非标准路径*C:\Windows*而不是*C:\Windows\System32*运行的：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For a service that is implemented as DLL (a service DLL), you can display the
    full path of the service DLL (or a kernel driver) by passing the `-v (--verbose)`
    option to the `svcscan` plugin. The `-v` option prints detailed information related
    to the service. The following is an example of the malware that runs a service
    as a DLL. The Service State is set to `SERVICE_START_PENDING`, and the start type
    is set to `SERVICE_AUTO_START`, which tells you that this service is not yet started
    and will be automatically started during system startup:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为DLL实现的服务（即服务DLL），你可以通过向`svcscan`插件传递`-v (--verbose)`选项来显示服务DLL（或内核驱动程序）的完整路径。`-v`选项会打印与服务相关的详细信息。以下是一个示例，展示了作为DLL运行的恶意软件服务。服务状态被设置为`SERVICE_START_PENDING`，启动类型设置为`SERVICE_AUTO_START`，这告诉你该服务尚未启动，并将在系统启动时自动启动：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Some malicious programs hijack the existing service that is unused or disabled
    to persist on the system. An example of such a malware is *BlackEnergy*, which
    replaces a legitimate kernel driver called `aliide.sys` on the disk. This kernel
    driver is associated with a service named `aliide.` After replacing the driver,
    it modifies the registry entry associated with the `aliide` service and sets it
    to autostart (that is, the service starts automatically when the system starts).
    It is hard to detect such attacks. One method to detect such a modification is
    to keep a list of all the services from a clean memory image, and compare that
    with the list of services from the suspect image to look for any modification.
    The following is the service configuration of the aliide service from the clean
    memory image. The legitimate aliide service is set to on-demand start (the service
    needs to be manually started) and the service is in the stopped state:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意程序劫持现有的未使用或已禁用的服务以保持在系统上的持久性。*BlackEnergy*就是这种恶意软件的一个例子，它替换了磁盘上名为`aliide.sys`的合法内核驱动程序。该内核驱动程序与一个名为`aliide`的服务相关联。替换驱动程序后，它修改了与`aliide`服务相关的注册表项并设置为自动启动（即系统启动时自动启动该服务）。此类攻击很难被检测到。检测此类修改的一种方法是保持一个干净内存镜像中所有服务的列表，并将其与可疑镜像中的服务列表进行比较，以寻找任何修改。以下是来自干净内存镜像中的aliide服务配置。合法的aliide服务被设置为按需启动（即需要手动启动该服务），且服务处于停止状态：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the `svcscan` output from a memory image infected with *BlackEnergy**.***
    After modification, the `aliide` service is set to autostart (the service starts
    automatically when the system starts) and is still in the stopped state. What
    this means is that after restarting the system, the service will automatically
    start and load the malicious `aliide.sys` driver. For a detailed analysis of this
    *BlackEnergy* dropper, refer to the author''s blog post at [https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/](https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是受*BlackEnergy**感染的内存镜像中的`svcscan`输出。***经过修改后，`aliide`服务被设置为自动启动（即系统启动时自动启动该服务），但仍处于停止状态。这意味着在系统重启后，服务将自动启动并加载恶意的`aliide.sys`驱动程序。有关此*BlackEnergy*劫持程序的详细分析，请参阅作者的博客文章：[https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/](https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/)：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 11\. Extracting Command History
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 提取命令历史
- en: After compromising the system, an attacker may execute various commands on the
    command shell to enumerate users, groups, and shares on your network, or an attacker
    may transfer a tool such as *Mimikatz* ([https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz))
    to the comprised system and execute it to dump Windows credentials. Mimikatz is
    an open source tool that was written by Benjamin Delpy in 2011\. It is one of
    the most popular tools for gathering credentials from Windows systems. Mimikatz
    is distributed in different flavors, such as the compiled version ([https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)),
    and is part of PowerShell Modules such as *PowerSploit* ([https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit))
    and *PowerShell Empire* ([https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻陷系统后，攻击者可能会在命令行中执行各种命令，以枚举网络上的用户、组和共享，或者攻击者可能会将像 *Mimikatz* 这样的工具（[https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)）传输到被攻陷的系统并执行，以提取
    Windows 凭据。Mimikatz 是一款开源工具，由 Benjamin Delpy 于 2011 年编写。它是收集 Windows 系统凭据最流行的工具之一。Mimikatz
    有多种版本，例如编译版（[https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)），并且它是
    PowerShell 模块的一部分，比如 *PowerSploit*（[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)）和
    *PowerShell Empire*（[https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)）。
- en: Command history can provide valuable information about an attacker's activity
    on the compromised system. By examining the command history, you can determine
    information such as the commands that have been executed, programs invoked, and
    files and folders accessed by the attackers. The two volatility plugins, `cmdscan`,
    and `consoles` can extract command history from the memory image. These plugins
    extract the command history from `csrss.exe` (before Windows 7) or `conhost.exe`
    (Windows 7 and later versions) processes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 命令历史记录能够提供关于攻击者在被攻陷系统上活动的宝贵信息。通过检查命令历史记录，你可以确定执行过的命令、调用的程序，以及攻击者访问的文件和文件夹。两个
    Volatility 插件，`cmdscan` 和 `consoles` 可以从内存镜像中提取命令历史记录。这些插件从 `csrss.exe`（Windows
    7 之前）或 `conhost.exe`（Windows 7 及以后版本）进程中提取命令历史记录。
- en: To understand the detailed workings of these plugins, read the book <q class="calibre259">"The
    Art of Memory Forensics"</q> or read the research paper <q class="calibre259">"Extracting
    Windows Command Line Details from Physical Memory"</q> by Richard Stevens and
    Eoghan Casey ([http://www.dfrws.org/2010/proceedings/2010-307.pdf](http://www.dfrws.org/2010/proceedings/2010-307.pdf)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些插件的详细工作原理，可以阅读书籍《<q class="calibre259">内存取证的艺术</q>》或阅读 Richard Stevens
    和 Eoghan Casey 的研究论文《<q class="calibre259">从物理内存提取 Windows 命令行细节</q>》([http://www.dfrws.org/2010/proceedings/2010-307.pdf](http://www.dfrws.org/2010/proceedings/2010-307.pdf))。
- en: 'The `cmdscan` plugin lists the commands executed by `cmd.exe`. The following
    example gives insight into the credential-stealing activity on the system. From
    the `cmdscan` output, you can see that an application with the name `net.exe`
    was invoked via the command shell `(cmd.exe).` From the commands extracted from
    `net.exe`, you can tell that the commands `privilege::debug` and `sekurlsa::logonpasswords`
    are associated with Mimikatz. In this case, the Mimikatz application was renamed
    to `net.exe`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmdscan` 插件列出了 `cmd.exe` 执行的命令。以下示例展示了系统上窃取凭据的活动。从 `cmdscan` 输出中，你可以看到一个名为
    `net.exe` 的应用程序是通过命令行 `cmd.exe` 调用的。从 `net.exe` 提取的命令可以看出，命令 `privilege::debug`
    和 `sekurlsa::logonpasswords` 与 Mimikatz 相关。在这种情况下，Mimikatz 应用程序被重命名为 `net.exe`：'
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `cmdscan` plugin displays the commands executed by the attacker. To get
    an idea of whether the command succeeded or not, you can use the `consoles` plugin.
    After running the `consoles` plugin, you can see that `net.exe` is indeed a Mimikatz
    application and, to dump the credentials, Mimkatz commands were executed using
    the Mimikatz shell. From the output, you can tell that the credentials were successfully
    dumped and that the password was retrieved in clear text:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmdscan` 插件显示攻击者执行的命令。为了判断命令是否成功执行，你可以使用 `consoles` 插件。运行 `consoles` 插件后，你可以看到
    `net.exe` 确实是一个 Mimikatz 应用程序，并且为了提取凭据，Mimikatz 命令通过 Mimikatz shell 执行。从输出中你可以看出，凭据已成功提取，并且密码以明文形式被获取：'
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may not be able to dump a password in clear text using Mimikatz on Windows
    8.1 and later versions, however, Mimikatz provides various capabilities to an
    attacker. An attacker may use an extracted NTLM hash to impersonate an account.
    For detailed information on Mimikatz and how it can be used to extract Windows
    credentials, read [https://adsecurity.org/?page_id=1821](https://adsecurity.org/?page_id=1821).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 8.1及更高版本上，你可能无法使用Mimikatz以明文形式转储密码，但Mimikatz为攻击者提供了多种功能。攻击者可能使用提取的NTLM哈希值来冒充账户。有关Mimikatz的详细信息及如何使用它提取Windows凭证，请阅读[https://adsecurity.org/?page_id=1821](https://adsecurity.org/?page_id=1821)。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Memory forensics is a great technique to find and extract forensic artifacts
    from the computer's memory. In addition to using memory forensics for malware investigation,
    you can use it as part of the malware analysis to gain additional information
    about the behavior and the characteristics of a malware. This chapter covered
    different Volatility plugins, which enabled you to gain an understanding of the
    events that occurred on the comprised system and provided insight into the malware's
    activity. In the next chapter, we will determine the advanced malware capabilities,
    using a few more Volatility plugins, and you will understand how to extract forensic
    artifacts using these plugins.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 内存取证是一种出色的技术，可以从计算机内存中查找和提取取证证据。除了在恶意软件调查中使用内存取证外，你还可以将其作为恶意软件分析的一部分，以获取有关恶意软件行为和特征的更多信息。本章介绍了不同的Volatility插件，帮助你了解在受感染系统上发生的事件，并提供对恶意软件活动的洞察。在下一章，我们将使用更多Volatility插件来确定高级恶意软件的功能，你将学会如何使用这些插件提取取证证据。
