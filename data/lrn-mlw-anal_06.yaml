- en: Debugging Malicious Binaries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试恶意二进制文件
- en: Debugging is a technique in which malicious code is executed in a controlled
    manner. A debugger is a program that gives you the ability to inspect malicious
    code at a more granular level. It provides full control over the malware's runtime
    behavior and allows you to execute a *single instruction*, *multiple instructions*,
    or *select functions* (instead of executing the entire program), while studying
    the malware's every action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一种以受控方式执行恶意代码的技术。调试器是一种程序，它使您能够在更细粒度的层面上检查恶意代码。它提供了对恶意软件运行时行为的完全控制，并允许您执行*单个指令*、*多个指令*或*选择函数*（而不是执行整个程序），同时研究恶意软件的每个动作。
- en: In this chapter, you will mainly learn the debugging features offered by *IDA
    Pro (commercial disassembler/debugger)* and *x64dbg (open source x32/x64 debugger)*.
    You will learn about the features offered by these debuggers, and how to use them
    to inspect the runtime behavior of a program. Depending on the resources available,
    you will be free to choose either of these debuggers or both, for debugging the
    malicious binary. When you are debugging a malware, proper care needs to be taken,
    as you will be running the malicious code on a system. It is highly recommended
    that you perform any malware debugging in an isolated environment (as covered
    in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction
    to Malware Analysis*). At the end of this chapter, you will also see how to debug
    a .NET application using a .NET decompiler/debugger, *dnSpy* ([https://github.com/0xd4d/dnSpy](https://github.com/0xd4d/dnSpy)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将主要学习*IDA Pro（商业反汇编器/调试器）*和*x64dbg（开源 x32/x64 调试器）*提供的调试功能。您将了解这些调试器提供的功能，以及如何使用它们检查程序的运行时行为。根据可用的资源，您可以选择使用其中任何一个调试器或同时使用两者来调试恶意二进制文件。在调试恶意软件时，需要特别小心，因为您将会在系统上运行恶意代码。强烈建议您在隔离的环境中进行任何恶意软件的调试（如[第1章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)《恶意软件分析简介》中所述）。在本章结束时，您还将看到如何使用.NET反编译器/调试器*dnSpy*（[https://github.com/0xd4d/dnSpy](https://github.com/0xd4d/dnSpy)）调试.NET应用程序。
- en: Other popular disassemblers/debuggers include *radare2* ([http://rada.re/r/index.html](http://rada.re/r/index.html)),
    the *WinDbg* part of debugging tools for Windows ([https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/)), *Ollydbg*
    ([http://www.ollydbg.de/version2.html](http://www.ollydbg.de/version2.html)),
    *Immunity Debugger* ([https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/)),
    *Hopper* ([https://www.hopperapp.com/](https://www.hopperapp.com/)), and *Binary
    Ninja* ([https://binary.ninja/](https://binary.ninja/)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的反汇编器/调试器包括*radare2*（[http://rada.re/r/index.html](http://rada.re/r/index.html)），*WinDbg*（Windows
    调试工具的一部分，[https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/)），*Ollydbg*（[http://www.ollydbg.de/version2.html](http://www.ollydbg.de/version2.html)），*Immunity
    Debugger*（[https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/)），*Hopper*（[https://www.hopperapp.com/](https://www.hopperapp.com/)），和*Binary
    Ninja*（[https://binary.ninja/](https://binary.ninja/)）。
- en: 1\. General Debugging Concepts
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 一般调试概念
- en: Before we delve into the features offered by these debuggers (*IDA Pro*, *x64dbg*,
    and *DnSpy*), It is essential to understand some of the common features that most
    debuggers provide. In this section, you will mainly see the general debugging
    concepts; in the subsequent sections, we will focus on the essential features
    of *IDA Pro*, *x64dbg,* and *dnSpy*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解这些调试器（*IDA Pro*、*x64dbg*和*DnSpy*）提供的功能之前，了解大多数调试器提供的一些常见功能是很重要的。在本节中，您将主要看到一般的调试概念；在后续章节中，我们将重点介绍*IDA
    Pro*、*x64dbg*和*dnSpy*的核心功能。
- en: 1.1 Launching And Attaching To Processes
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 启动和附加到进程
- en: Debugging normally begins by selecting the program to debug. There are two ways
    to debug a program: *(a) attach the debugger to a running process,* and *(b) launch
    a new process*. When you attach the debugger to a running process, you will not
    be able to control or monitor the process's initial actions, because by the time
    you have a chance to attach to the process, all of its startup and initialization
    code will have already been executed. When you attach the debugger to a process,
    the debugger suspends the process, giving you a chance to inspect the process's
    resources or set a breakpoint before resuming the process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 调试通常从选择要调试的程序开始。有两种方法可以调试程序：*(a) 将调试器附加到正在运行的进程*，以及 *(b) 启动一个新进程*。当你将调试器附加到正在运行的进程时，你将无法控制或监控进程的初始动作，因为在你有机会附加到进程时，它的所有启动和初始化代码已经执行完毕。当你将调试器附加到进程时，调试器会暂停进程，给你机会检查进程的资源或设置断点，然后再恢复进程的执行。
- en: On the other hand, launching a new process allows you to monitor or debug every
    action the process takes, and you will also be able to monitor the process's initial
    actions. When you start the debugger, the original binary will be executed with
    the privileges of the user running the debugger. When the process is launched
    under a debugger, the execution will pause at the *program's entry point*. A program's
    entry point is the address of the first instruction that will be executed. In
    later sections, you will learn how to *launch* and *attach* to a process using
    *IDA Pro*, *x64dbg*, and *dnSpy*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，启动一个新进程可以让你监控或调试进程的每个动作，你还将能够监控进程的初始操作。当你启动调试器时，原始二进制文件将在运行调试器的用户权限下执行。当进程在调试器下启动时，执行将在
    *程序的入口点* 暂停。程序的入口点是将要执行的第一条指令的地址。在后续章节中，你将学习如何使用 *IDA Pro*、*x64dbg* 和 *dnSpy*
    来 *启动* 和 *附加* 进程。
- en: A program's entry point is not necessarily the `main` or `WinMain` function;
    before transferring control to `main` or `WinMain`, the initialization routine
    (startup routine) is executed. The purpose of the startup routine is to initialize
    the program's environment before passing control to the `main` function. This
    initialization is designated, by the debuggers, as the entry point of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的入口点不一定是 `main` 或 `WinMain` 函数；在将控制权转交给 `main` 或 `WinMain` 之前，会执行初始化例程（启动例程）。启动例程的目的是在将控制权传递给
    `main` 函数之前初始化程序的环境。调试器将此初始化过程指定为程序的入口点。
- en: 1.2 Controlling Process Execution
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 控制进程执行
- en: A debugger gives you the ability to control/modify the behavior of the process
    while it is executing. The two important capabilities offered by a debugger are: *(a)
    the ability to control execution,* and *(b) the ability to interrupt execution
    (using breakpoints)*. Using a debugger, you can execute one or more instructions
    (or select functions) before returning control to the debugger. During analysis,
    you will combine both the debugger's controlled execution and the interruption
    (breakpoint) feature to monitor a malware's behavior. In this section, you will
    learn about the common *execution control* functionalities offered by the debuggers;
    in later sections, you will learn how to use these features in *IDA Pro*, *x64dbg*,
    and *dnSpy.*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器使你能够在进程执行时控制/修改其行为。调试器提供的两个重要功能是：*(a) 控制执行的能力*，以及 *(b) 中断执行的能力（使用断点）*。使用调试器时，你可以在将控制权返回给调试器之前执行一条或多条指令（或选择函数）。在分析过程中，你将结合调试器的控制执行和中断（断点）功能来监控恶意软件的行为。在本节中，你将了解调试器提供的常见
    *执行控制* 功能；在后续章节中，你将学习如何在 *IDA Pro*、*x64dbg* 和 *dnSpy* 中使用这些功能。
- en: 'The following are some of the common execution control options provided by
    the debuggers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调试器提供的一些常见执行控制选项：
- en: '**Continue (Run)**: This executes all of the instructions, until a breakpoint
    is reached or an exception occurs. When you load a malware into a debugger and
    use the *continue (Run)* option without setting the breakpoint, it will execute
    all of the instructions without giving you any control; so, you normally use this
    option along with breakpoint, to interrupt the program at the breakpoint location.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续（运行）**： 这将执行所有指令，直到到达断点或发生异常。当你将恶意软件加载到调试器中并使用 *继续（运行）* 选项而不设置断点时，它将执行所有指令而不给你任何控制；因此，你通常会将此选项与断点一起使用，在断点位置中断程序。'
- en: '**Step into and Step over**: Using *step into* and *step over,* you can execute
    a single instruction. After executing the single instruction, the debugger stops,
    giving you a chance to inspect the process''s resources. The difference between
    *step into* and *step over* occurs when you are executing an instruction that
    calls a function. For example, in the following code, at ➊, there is a call to
    the function `sub_401000`. When you use the *step into* option on this instruction,
    the debugger will stop at the start of the function (at the address `0x401000`),
    whereas when you use *step over*, the entire function will be executed, and the
    debugger will pause at the next instruction, ➋ (that is, the address `0x00401018`).
    You will normally use *step into* to get inside a function, to understand its
    inner workings. S*tep over* is used when you already know what a function does
    (such as in an API function) and would like to skip over it:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入和跳过**：通过使用*进入*和*跳过*，你可以执行一条指令。执行完这条指令后，调试器会暂停，给你一个机会检查进程的资源。*进入*和*跳过*的区别出现在你执行一条调用函数的指令时。例如，在以下代码中，在➊处有对函数`sub_401000`的调用。当你在这条指令上使用*进入*选项时，调试器会在函数的开始处（地址`0x401000`）停下来，而当你使用*跳过*时，整个函数会被执行，调试器会在下一条指令（➋，即地址`0x00401018`）处暂停。通常，当你想深入了解一个函数的内部实现时，使用*进入*；而当你已经知道一个函数的作用（例如一个API函数），并且希望跳过它时，使用*跳过*：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Execute till Return (Run until return)**: This option allows you to execute
    all of the instructions in the current function, until it returns. This is useful
    if you accidentally step into a function (or step into a function that is not
    interesting) and would like to come out of it. Using this option inside a function
    will take you to the end of the function (`ret` or `retn`), after which you can
    use either the *step into* or *step over* option to return to the calling function.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行直到返回（运行直到返回）**：这个选项允许你执行当前函数中的所有指令，直到它返回。这在你不小心进入了一个函数（或者进入了一个不感兴趣的函数）时很有用，能够让你快速退出。使用这个选项时，调试器会一直执行到函数的结尾（`ret`或`retn`），然后你可以使用*进入*或*跳过*选项返回到调用该函数的地方。'
- en: '**Run to cursor (Run until selection)**: This allows you to execute instructions
    until the *current cursor location,* or until the *selected instruction* is reached.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行到光标（运行直到选择）**：这个选项允许你执行指令，直到*当前光标位置*，或者直到*选择的指令*被到达。'
- en: 1.3 Interrupting a Program with Breakpoints
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 使用断点中断程序
- en: 'A *breakpoint* is a debugger feature that allows you to interrupt program execution
    at a very specific location within a program. Breakpoints can be used to pause
    the execution at a particular instruction, or when the program calls a function/API
    function, or when the program reads, writes, or executes from a memory address.
    You can set multiple breakpoints all over a program, and execution will be interrupted
    upon reaching any of the breakpoints. Once a breakpoint has been reached, it is
    possible to monitor/modify various aspects of the process. Debuggers typically
    allow you to set different types of breakpoints:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*断点* 是一种调试器功能，允许你在程序中的特定位置中断程序的执行。断点可以用来暂停程序执行在某一特定指令处，或者在程序调用函数/API函数时，或者在程序从某个内存地址读取、写入或执行时。你可以在程序的各个位置设置多个断点，程序执行将会在到达任何一个断点时被中断。到达断点后，可以监控/修改进程的各个方面。调试器通常允许你设置不同类型的断点：'
- en: '**Software Breakpoints**: By default, debuggers make use of software breakpoints.
    Software breakpoints are implemented by replacing the instruction at a breakpoint
    address with a software breakpoint instruction, such as the `int 3` instruction
    (having an opcode of `0xCC`). When a software breakpoint instruction (such as `int
    3`) is executed, the control is transferred to the debugger, which is debugging
    the interrupted process. The advantage of using software breakpoints is that you
    can set an unlimited number of breakpoints. The disadvantage is that malware can
    look for the breakpoint instruction (`int 3`) and modify it to change the normal
    operation of an attached debugger.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件断点**：默认情况下，调试器使用软件断点。软件断点通过将断点地址处的指令替换为软件断点指令（如`int 3`指令，操作码为`0xCC`）来实现。当软件断点指令（如`int
    3`）被执行时，控制权会转移到调试器，调试器将调试被中断的进程。使用软件断点的优点是你可以设置无限数量的断点。缺点是恶意软件可以查找断点指令（`int 3`），并修改它，从而改变附加调试器的正常操作。'
- en: '**Hardware Breakpoints**: A CPU, such as x86, supports hardware breakpoints
    through the use of the CPU''s debug registers, `DR0 - DR7`. You can set a maximum
    of four hardware breakpoints using `DR0-DR3`; the other remaining debug registers
    are used to specify additional conditions on each breakpoint. In the case of hardware
    breakpoints, no instruction is replaced, but the CPU decides whether the program
    should be interrupted, based on the values contained within the debug registers.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件断点**：像 x86 这样的 CPU 通过使用 CPU 的调试寄存器 `DR0 - DR7` 支持硬件断点。你最多可以使用 `DR0-DR3`
    设置四个硬件断点；其他剩余的调试寄存器用于指定每个断点的附加条件。在硬件断点的情况下，没有指令被替换，而是由 CPU 根据调试寄存器中的值来决定是否中断程序。'
- en: '**Memory Breakpoints**: These breakpoints allow you to pause the execution
    when an instruction accesses (*reads from* or *writes to*) the memory, rather
    than the execution. This is useful if you want to know when a particular memory
    is accessed (*read* or *write*), and to know which instruction accesses it. For
    example, if you find an interesting string or data in the memory, you can set
    a memory breakpoint on that address to determine under what circumstances the
    memory is accessed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存断点**：这些断点允许你在指令访问（*读取*或*写入*）内存时暂停执行，而不是在执行时暂停。这在你想知道何时访问特定内存（*读取*或*写入*）以及知道哪条指令访问它时非常有用。例如，如果你在内存中发现一个有趣的字符串或数据，你可以在该地址设置内存断点，以确定在什么情况下该内存被访问。'
- en: '**Conditional Breakpoints**: Using conditional breakpoints, you can specify
    the condition that must be satisfied to trigger the breakpoint. If a conditional
    breakpoint is reached but the condition is not satisfied, the debugger automatically
    resumes the execution of the program. Conditional breakpoints are not an instruction
    feature or a CPU feature; they are a feature offered by the debugger. You can
    therefore specify conditions for both software and hardware breakpoints. When
    the conditional breakpoint is set, it is the debugger''s responsibility to evaluate
    the conditional expression and determine whether the program needs to be interrupted
    or not.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件断点**：使用条件断点，你可以指定必须满足的条件，以触发断点。如果条件断点被触及但条件未满足，调试器会自动恢复程序的执行。条件断点不是指令功能或
    CPU 功能；它们是调试器提供的功能。因此，你可以为软件和硬件断点指定条件。设置条件断点时，由调试器负责评估条件表达式，并确定是否需要中断程序。'
- en: 1.4 Tracing Program Execution
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 程序执行跟踪
- en: '*Tracing* is a debugging feature that allows you to record (*log*) specific
    events while the process is executing. Tracing gives you detailed execution information
    on a binary. In later sections, you will learn about the different types of tracing
    capabilities provided by *IDA* and *x64dbg*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪* 是一种调试功能，允许你在进程执行时记录（*日志*）特定事件。跟踪为你提供有关二进制文件的详细执行信息。在后续章节中，你将了解 *IDA* 和
    *x64dbg* 提供的不同类型的跟踪功能。'
- en: 2\. Debugging a Binary Using x64dbg
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 调试二进制文件使用 x64dbg
- en: '*x64dbg* ([https://x64dbg.com](https://x64dbg.com)) is an open source debugger.
    You can use *x64dbg* to debug both 32-bit and 64-bit applications. It has an easy-to-use
    GUI and offers various debugging features ([https://x64dbg.com/#features](https://x64dbg.com/#features)).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*x64dbg* ([https://x64dbg.com](https://x64dbg.com)) 是一个开源调试器。你可以使用 *x64dbg*
    调试 32 位和 64 位应用程序。它具有易于使用的 GUI，并提供各种调试功能 ([https://x64dbg.com/#features](https://x64dbg.com/#features))。'
- en: In this section, you will see some of the debugging features offered by *x64dbg,*
    and how to use it to debug a malicious binary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到一些 *x64dbg* 提供的调试功能，以及如何使用它来调试恶意二进制文件。
- en: 2.1 Launching a New Process in x64dbg
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 在 x64dbg 中启动新进程
- en: 'In *x64dbg*, to load an executable, select File | Open and browse to the file
    that you wish to debug; this will start the process, and the debugger will pause
    at the *System Breakpoint*, the *TLS callback,* or the *program entry point* function,
    depending on the configuration settings. You can access the settings dialog by
    choosing Options | Preferences | Events. The default settings dialog is shown
    as follows, with the default settings when the executable is loaded. The debugger
    first breaks in the system function (because the System Breakpoint* option is
    checked). Next, after you run the debugger, it will pause at the *TLS Callback*
    function, if present (because the TLS callbacks* option is checked). This is sometimes
    useful, because some anti-debugger tricks contain TLS entries that allow malware
    to execute code before the main application runs. If you further execute the program,
    the execution pauses at the entry point of the program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x64dbg*中，要加载一个可执行文件，选择文件 | 打开，并浏览到你希望调试的文件；这将启动进程，调试器会根据配置设置在*系统断点*、*TLS回调*或*程序入口点*函数处暂停。你可以通过选择选项
    | 偏好设置 | 事件来访问设置对话框。默认设置对话框如下所示，显示了加载可执行文件时的默认设置。调试器首先会在系统函数处中断（因为选中了*系统断点*选项）。接着，在你运行调试器后，它会在*TLS回调*函数处暂停（如果存在的话，因为选中了*TLS回调*选项）。有时这很有用，因为一些反调试技巧包含TLS条目，允许恶意软件在主应用程序运行之前执行代码。如果你继续执行程序，执行会在程序的入口点处暂停：
- en: '![](../images/00125.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00125.jpeg)'
- en: 'If you want the execution to pause directly at the *program''s entry point*,
    then uncheck the System Breakpoint* and TLS Callbacks* options (this configuration
    should work fine for most malware programs, unless the malware uses anti-debugging
    tricks). To save the configuration settings, just click the save button. With
    this configuration, when an executable is loaded, the process starts, and execution
    is paused at the *program''s entry point,* as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望执行在*程序入口点*直接暂停，那么取消选中系统断点*和TLS回调*选项（此配置对大多数恶意软件程序应该有效，除非恶意软件使用反调试技巧）。要保存配置设置，只需点击保存按钮。通过此配置，当加载可执行文件时，进程开始执行，并在*程序入口点*暂停，如下所示：
- en: '![](../images/00126.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00126.jpeg)'
- en: 2.2 Attaching to an Existing Process Using x64dbg
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 使用 x64dbg 附加到现有进程
- en: 'To attach to an existing process in *x64dbg*, select File | Attach (or *Alt *+
    *A*); this will bring up a dialog displaying the running processes, as follows.
    Choose the process that you wish to debug and click on the Attach button. When
    the debugger is attached, the process is suspended, giving you time to set breakpoints
    and inspect the process''s resources. When you close the debugger, the attached
    process will terminate. If you do not want the attached process to terminate,
    you can detach a process by selecting File | Detach (*Ctrl* + *Alt* + *F2*); this
    ensures that the attached process is not terminated when you close the debugger:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加到现有的进程中，在*x64dbg*中选择文件 | 附加（或*Alt* + *A*）；这将弹出一个对话框，显示正在运行的进程，如下所示。选择你希望调试的进程，并点击附加按钮。当调试器附加后，进程会被挂起，给你时间设置断点并检查进程的资源。当你关闭调试器时，附加的进程将终止。如果你不希望附加的进程终止，可以通过选择文件
    | 分离（*Ctrl* + *Alt* + *F2*）来分离进程；这确保在你关闭调试器时，附加的进程不会终止：
- en: '![](../images/00127.jpeg)Sometimes, when you try attaching the debugger to
    a process, you will find that not all of the processes are listed in the dialog.
    In that case, make sure that you are running the debugger as an *administrator; *you
    need to enable the *debug privilege* settings by selecting Options | Preferences and,
    in the Engine tab, checking the Enable Debug Privilege option.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00127.jpeg)有时，当你尝试将调试器附加到进程时，你会发现并非所有进程都列在对话框中。在这种情况下，确保你以*管理员*身份运行调试器；你需要通过选择选项
    | 偏好设置，在引擎标签页中勾选启用调试权限选项，来启用*调试权限*设置。'
- en: 2.3 x64dbg Debugger Interface
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 x64dbg 调试器界面
- en: 'When you load a program in *x64dbg*, you will be presented with a debugger
    display, as follows. The debugger display contains multiple tabs; each tab displays
    different windows. Each window contains different information regarding the debugged
    binary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*x64dbg*中加载一个程序时，会出现调试器显示，如下所示。调试器显示包含多个标签页；每个标签页显示不同的窗口。每个窗口包含有关被调试二进制文件的不同信息：
- en: '![](../images/00128.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00128.jpeg)'
- en: '**Disassembly Window (CPU Window)**: This shows the disassembly of all of the
    instructions of the debugged program. This window presents the disassembly in
    a linear fashion, and it is synchronized with the current value of the instruction
    pointer register (`eip` or `rip`). The left portion of this window displays an
    *arrow* to indicate the program''s non-linear flow (such as *branching* or *looping*).
    You can display the control flow graph by pressing the *G* hotkey. The control
    graph is shown as follows; conditional jumps use *green* and *red* arrows. The
    green arrow indicates that the jump will be taken if the condition is true, and
    the red arrow indicates that the jump will not be taken. The blue arrow is used
    for unconditional jumps, and a loop is indicated by the upward (backward) blue
    arrow:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反汇编窗口（CPU窗口）**：此窗口显示调试程序所有指令的反汇编。反汇编以线性方式呈现，并与当前的指令指针寄存器（`eip` 或 `rip`）的值同步。该窗口的左侧部分显示一个*箭头*，以指示程序的非线性流程（例如*分支*或*循环*）。您可以通过按下*G*热键来显示控制流图。控制流图如下所示；条件跳转使用*绿色*和*红色*箭头。绿色箭头表示当条件为真时会跳转，红色箭头表示跳转不会发生。蓝色箭头用于无条件跳转，向上的（向后的）蓝色箭头表示循环：'
- en: '![](../images/00129.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00129.jpeg)'
- en: '**Registers Window**: This window displays the current state of the CPU registers.
    The value in a register can be modified by double-clicking on the register and
    entering a new value (you can also right-click and modify the value of a register
    to *zero* or *increment*/*decrement* the value of the register). You can toggle
    the flag bits *on* or *off* by double-clicking on the values of the flag bits.
    You cannot change the value of the instruction pointer (`eip` or `rip`). As you
    are debugging the program, the register values can change; the debugger highlights
    register values with a *red color,* to indicate a change since the last instruction.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器窗口**：此窗口显示CPU寄存器的当前状态。可以通过双击寄存器并输入新值来修改寄存器的值（您也可以右键单击寄存器并将其值修改为*零*，或*递增*/*递减*寄存器的值）。您可以通过双击标志位的值来切换标志位的*开启*或*关闭*状态。您不能更改指令指针（`eip`
    或 `rip`）的值。在调试程序时，寄存器的值可能会发生变化；调试器通过*红色*高亮寄存器值，表示自上次指令以来的变化。'
- en: '**Stack Window**: The *stack view* displays the data contents of the process''s
    runtime stack. During malware analysis, you will typically inspect the stack before
    calling a function, to determine the number of arguments passed to the function
    and the types of the function arguments (such as *integer* or *character pointer*).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈窗口**：*堆栈视图*显示进程运行时堆栈的数据内容。在恶意软件分析中，通常会在调用函数之前检查堆栈，以确定传递给函数的参数个数及参数类型（例如*整数*或*字符指针*）。'
- en: '**Dump Window**: This displays the standard hex dump of the memory. You can
    use the dump window to examine the contents of any valid memory address in the
    debugged process. For example, if a stack location, register, or instruction contains
    a valid memory location, to examine the memory location, right-click on the address
    and choose the Follow in Dump option.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转储窗口**：此窗口显示内存的标准十六进制转储。您可以使用转储窗口查看调试进程中任何有效内存地址的内容。例如，如果堆栈位置、寄存器或指令包含有效的内存位置，要查看该内存位置，请右键点击地址并选择“在转储中跟踪”选项。'
- en: '**Memory Map Window**: You can click on the Memory Map tab to display the contents
    of the *Memory Map* *window*. This provides the layout of the process memory and
    gives you the details of the allocated memory segments in the process. It is a
    great way to see where the executables and their sections are loaded in the memory.
    This window also contains information about the process DLLs and their sections
    in the memory. You can double-click on any entry to relocate the display to the
    corresponding memory location:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存映射窗口**：您可以点击“内存映射”标签，显示*内存映射*窗口的内容。此窗口提供进程内存的布局，并显示进程中已分配内存段的详细信息。它是查看可执行文件及其各个部分加载到内存中的位置的好方法。此窗口还包含有关进程DLL及其内存部分的信息。您可以双击任何条目，将显示定位到相应的内存位置：'
- en: '![](../images/00130.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00130.jpeg)'
- en: '**Symbols Window**: You can click on the Symbols tab to display the contents
    of the *Symbols window*. The left pane displays a list of the loaded modules (the
    executable and its DLLs); clicking on a module entry will display its *import*
    and *export* functions in the right pane, as follows. This window can be useful
    in determining where the import and export functions reside in the memory:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号窗口**：你可以点击符号标签以显示*符号窗口*的内容。左侧窗格显示已加载模块的列表（可执行文件及其DLL）；点击某个模块条目将在右侧窗格显示该模块的*导入*和*导出*函数，如下所示。此窗口有助于确定导入和导出函数在内存中的位置：'
- en: '![](../images/00131.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00131.jpeg)'
- en: '**References Window**: This window displays the references to the API calls.
    Clicking on the References tab will not display the references to the API by default.
    To populate this window, right-click anywhere in the *disassembly (CPU)* window
    (with the executable loaded), then select Search for | Current Module | Intermodular
    calls; this will populate the *references window* with the references to all of
    the API calls in the program. The following screenshot displays references to
    the multiple API functions; the first entry tells you that at the address `0x00401C4D`, the
    instruction calls the `CreateFileA` API (which is exported by `Kernel32.dll`).
    Double-clicking on the entry will take you to the corresponding address (in this
    case, `0x00401C4D`). You can also set a breakpoint at this address; once the breakpoint
    is hit, you can inspect the parameters passed to the `CreateFileA` function:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用窗口**：此窗口显示API调用的引用。默认情况下，点击引用标签不会显示API的引用。要填充此窗口，请右键单击*反汇编（CPU）*窗口中的任何位置（确保已加载可执行文件），然后选择 搜索
    | 当前模块 | 模块间调用；这将把所有程序中API调用的引用填充到*引用窗口*中。以下截图显示了多个API函数的引用；第一项告诉你，在地址`0x00401C4D`，该指令调用了`CreateFileA`
    API（由`Kernel32.dll`导出）。双击该条目将带你到相应的地址（在此例中为`0x00401C4D`）。你还可以在该地址设置断点；一旦命中断点，你可以检查传递给`CreateFileA`函数的参数：'
- en: '![](../images/00132.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00132.jpeg)'
- en: '**Handles Window**: You can click on the Handles tab to bring up the *handles
    window*; to display the contents, right-click inside the handles window and selectRefresh (or
    *F5*). This displays the details of all of the open handles. In the previous chapter,
    when we discussed the Windows API, you learned that the process can open handles
    to an object (such as the *file*, *registry*, and so on), and these handles can
    be passed to functions, such as `WriteFile`, to perform subsequent operations.
    The handles are useful when you are inspecting an API, such as `WriteFile`, that
    will tell you the object associated with the handle. For example, when debugging
    a malware sample, it is determined that the `WriteFile` API call accepts a handle
    value of `0x50`. Inspecting the handles window shows that the handle value `0x50` is
    associated with the file `ka4a8213.log`, as shown here:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**句柄窗口**：你可以点击句柄标签打开*句柄窗口*；要显示内容，右键点击句柄窗口内部并选择刷新（或按*F5*）。这将显示所有打开的句柄的详细信息。在前一章中，当我们讨论Windows
    API时，你了解到进程可以打开指向某个对象（如*文件*、*注册表*等）的句柄，这些句柄可以传递给函数，例如`WriteFile`，以执行后续操作。当你检查API时，句柄会非常有用，像`WriteFile`这样的API会告诉你与句柄相关联的对象。例如，在调试恶意软件样本时，发现`WriteFile`
    API调用接受句柄值`0x50`。检查句柄窗口显示句柄值`0x50`与文件`ka4a8213.log`关联，如下所示：'
- en: '![](../images/00133.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00133.jpeg)'
- en: '**Threads Window**: This displays the list of threads in the current process.
    You can right-click on this window and *suspend* a thread/threads or *resume*
    a suspended thread.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程窗口**：此窗口显示当前进程中的线程列表。你可以右键点击此窗口并*挂起*一个或多个线程，或*恢复*已挂起的线程。'
- en: 2.4 Controlling Process Execution Using x64dbg
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用x64dbg控制进程执行
- en: 'In S*ection 1.2*, *Controlling Process Execution*, we looked at the different
    execution control features provided by the debuggers. The following table outlines
    the common execution options and how to access these options in *x64dbg*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第*1.2节*，*控制进程执行*中，我们讨论了调试器提供的不同执行控制功能。以下表格概述了常见的执行选项及如何在*x64dbg*中访问这些选项：
- en: '| Functionality | Hotkey | Menu |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 快捷键 | 菜单 |'
- en: '| Run | *F9* | Debugger &#124; Run |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 运行 | *F9* | 调试器 &#124; 运行 |'
- en: '| Step into | *F7* | Debugger &#124; Step into |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 单步进入 | *F7* | 调试器 &#124; 单步进入 |'
- en: '| Step over | *F8* | Debugger &#124; Step over |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 单步跳过 | *F8* | 调试器 &#124; 单步跳过 |'
- en: '| Run until selection | *F4* | Debugger &#124; Run until selection |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 运行直到选择 | *F4* | 调试器 &#124; 运行直到选择 |'
- en: 2.5 Setting a Breakpoint in x64dbg
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 在x64dbg中设置断点
- en: In *x64dbg*, you can set a software breakpoint by navigating to the address
    where you want the program to pause and pressing the *F2* key (or right-clicking
    and selecting Breakpoint | Toggle). To set a hardware breakpoint, right-click
    on the location where you want to set the breakpoint and select Breakpoint | Set
    Hardware on Execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x64dbg*中，你可以通过导航到你希望程序暂停的地址并按 *F2* 键（或者右键点击并选择 断点 | 切换）来设置软件断点。要设置硬件断点，右键点击你希望设置断点的位置，并选择 断点
    | 设置硬件执行断点。
- en: 'You can also use hardware breakpoints to break on *write* or break on *read/write*
    (access) to a memory location. To set a hardware breakpoint on memory access,
    in the dump pane, right-click on the desired address and select Breakpoint | Hardware,
    Access, and then choose the appropriate data type (such as byte, word, dword,
    or qword), as shown in the following screenshot. In the same manner, you can set
    the hardware breakpoint on memory write by choosing the Breakpoint | Hardware,
    Write option:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用硬件断点来在*写入*时或者在内存位置的*读/写*（访问）时进行断点。要在内存访问上设置硬件断点，在转储面板中，右键点击所需的地址，选择 断点
    | 硬件，访问，然后选择适当的数据类型（例如字节、字、双字或四字），如下面的截图所示。同样，你也可以通过选择 断点 | 硬件，写入 选项来设置硬件断点，以进行内存写入：
- en: '![](../images/00134.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00134.jpeg)'
- en: In addition to hardware memory breakpoints, you can also set memory breakpoints
    in the same manner. To do that, in the dump pane, right-click on the desired address
    and select Breakpoint | Memory, Access (for memory access) or Breakpoint | Memory,
    Write (for memory write).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬件内存断点外，你还可以以相同的方式设置内存断点。为此，在转储面板中，右键点击所需的地址，选择 断点 | 内存，访问（用于内存访问）或 断点 | 内存，写入（用于内存写入）。
- en: To view all of the active breakpoints, just click on the Breakpoints tab; this
    will list all of the software, hardware, and memory breakpoints in the Breakpoints
    window. You can also right-click on any instruction inside the Breakpoints window
    and remove a single breakpoint, or all of the breakpoints.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有活动的断点，只需点击“断点”标签；这会列出“断点”窗口中所有的软件、硬件和内存断点。你也可以在“断点”窗口中的任何指令上右键点击，移除单个断点，或者移除所有断点。
- en: For more information on the options available in *x64dbg,* refer to the *x64dbg*
    online documentation at [http://x64dbg.readthedocs.io/en/latest/index.html](http://x64dbg.readthedocs.io/en/latest/index.html).
    You can also access the *x64dbg* help manual by pressing *F1* while you are in
    the *x64dbg* interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关* x64dbg *中可用选项的更多信息，请参考*x64dbg*的在线文档：[http://x64dbg.readthedocs.io/en/latest/index.html](http://x64dbg.readthedocs.io/en/latest/index.html)。你也可以通过在*x64dbg*界面中按
    *F1* 来访问*x64dbg*帮助手册。
- en: 2.6 Debugging 32-bit Malware
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 调试32位恶意软件
- en: 'With an understanding of debugging features, let''s look at how debugging can
    help us to understand malware behavior. Consider a code excerpt from a malware
    sample, where the malware calls the `CreateFileA` function to create a file. To
    determine the name of the file that it creates, you can set a breakpoint at the
    call to the `CreateFileA` function and execute the program until it reaches the
    breakpoint. When it reaches the breakpoint (that is, before calling `CreateFileA`),
    all of the parameters to the function will be pushed onto the stack; we can then
    examine the *first parameter* on the stack to determine the name of the file.
    In the following screenshot, when the execution is paused at the breakpoint, *x64dbg*
    adds a comment (if it''s a string) next to the instruction and next to the argument
    on the stack, to indicate what parameter is being passed to the function. From
    the screenshot, you can tell that the malware creates an executable file, `winlogdate.exe`,
    in the `%Appdata%\Microsoft` directory. You can also get this information by right-clicking
    on the first argument in the stack window and selecting the follow DWORD in dump
    option, which displays the contents in the hex window:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了调试功能后，接下来我们来看调试如何帮助我们理解恶意软件的行为。考虑到一个恶意软件样本的代码片段，其中恶意软件调用`CreateFileA`函数创建文件。为了确定它创建的文件名，你可以在调用`CreateFileA`函数的地方设置断点，并执行程序直到到达断点。当执行到达断点时（也就是在调用`CreateFileA`之前），所有的函数参数都会被压入栈中；然后我们可以检查栈中的*第一个参数*以确定文件名。在下图中，当执行在断点处暂停时，*x64dbg*会在指令旁边和栈中的参数旁边添加一个注释（如果是字符串的话），以指示传递给函数的参数是什么。从截图中可以看出，恶意软件在`%Appdata%\Microsoft`目录下创建了一个可执行文件`winlogdate.exe`。你也可以通过右键点击栈窗口中的第一个参数，选择“在转储中查看DWORD”选项，来显示十六进制窗口中的内容，获取这些信息：
- en: '![](../images/00135.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00135.jpeg)'
- en: 'After creating the executable file, the malware passes the handle value (`0x54`)
    returned by the `CreateFile` as the first parameter to the `WriteFile`, and writes
    the executable content (which is passed as the second parameter), as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可执行文件后，恶意软件将`CreateFile`返回的句柄值（`0x54`）作为第一个参数传递给`WriteFile`，并写入可执行内容（作为第二个参数传递），如下所示：
- en: '![](../images/00136.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00136.jpeg)'
- en: 'Let''s assume that you do not know which object is associated with the handle `0x54`,
    probably because you set a breakpoint directly on `WriteFile` without initially
    setting a breakpoint on `CreateFile`. To determine the object that is associated
    with a handle value, you can look it up in the Handles window. In this case, the
    handle value `0x54`, passed as the first parameter to the `WriteFile`, is associated
    with `winlogdate.exe`, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不知道哪个对象与句柄`0x54`相关联，可能是因为你直接在`WriteFile`上设置了断点，而没有最初在`CreateFile`上设置断点。要确定与句柄值相关联的对象，可以在句柄窗口中查找。在此案例中，作为第一个参数传递给`WriteFile`的句柄值`0x54`，与`winlogdate.exe`相关联，如下所示：
- en: '![](../images/00137.gif)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00137.gif)'
- en: 2.7 Debugging 64-bit Malware
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 调试 64 位恶意软件
- en: You will use the same technique to debug a 64-bit malware; the difference is,
    you will be dealing with *extended registers*, *64-bit memory addresses/pointers*,
    and slightly different *calling conventions*. If you recall (from [Chapter 4](part0088.html#2JTHG0-ac10ba3f98854c44bac1c2c5641ca485), *Assembly
    Language and Disassembly Primer*), a 64-bit code uses the `FASTCALL` calling convention
    and passes the first four parameters to the function in the registers (`rcx`, `rdx`, `r8`,
    and `r9`), and the rest of the parameters are placed on the stack. While debugging
    the call to a function/API, depending on the parameter you are inspecting, you
    will have to inspect the *register* or the *stack*. The calling convention mentioned
    previously is applicable to compiler-generated code. An attacker writing code
    in the assembly language need not follow these rules; as a result, the code can
    exhibit unusual behavior. When you come across code that is not compiler-generated,
    a further investigation of the code may be required.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用相同的技巧来调试 64 位恶意软件；区别在于，你将处理*扩展寄存器*、*64 位内存地址/指针*和略有不同的*调用约定*。如果你还记得（来自[第
    4 章](part0088.html#2JTHG0-ac10ba3f98854c44bac1c2c5641ca485)，*汇编语言与反汇编入门*），64 位代码使用`FASTCALL`调用约定，并将前四个参数传递给函数的寄存器（`rcx`、`rdx`、`r8`和`r9`），其余的参数则放在栈上。在调试调用函数/API时，依据你检查的参数，你需要检查*寄存器*或*栈*。前面提到的调用约定适用于编译器生成的代码。攻击者编写的汇编语言代码不必遵循这些规则；因此，代码可能表现出不寻常的行为。当你遇到非编译器生成的代码时，可能需要进一步调查该代码。
- en: 'Before we debug a 64-bit malware, let''s try to understand the behavior of
    a 64-bit binary with the following trivial C program, which was compiled for the
    64-bit platform using the *Microsoft Visual C/C++* compiler:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调试 64 位恶意软件之前，让我们先通过下面这个简单的 C 程序来了解 64 位二进制文件的行为，该程序是使用*Microsoft Visual
    C/C++* 编译器为 64 位平台编译的：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding program, the `printf` function takes eight arguments; this
    program was compiled and opened in *x64dbg*, and a breakpoint was set at the `printf` function.
    The following screenshot shows the program, which is paused before the call to
    the `printf` function. In the registers window, you can see that the first four
    parameters are placed in the `rcx`, `rdx`, `r8`, and `r9` registers. When the
    program calls a function, the function reserves `0x20` (`32` bytes) of space on
    the stack (space for four items, each `8` bytes in size); this is to make sure
    that the called function has the necessary space, if it needs to save the register
    parameters (`rcx`, `rdx`, `r8`, and `r9`). This is the reason the next four parameters
    (the 5^(th), 6^(th), 7^(th), and 8^(th) parameters) are placed on the stack, starting
    from the fifth item (`rsp+0x20`). We are showing you this example to give you
    an idea of how to find the parameters on the stack:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的程序中，`printf`函数接受八个参数；该程序在*x64dbg*中编译并打开，并且在`printf`函数处设置了断点。以下截图显示了程序，在调用`printf`函数之前暂停。在寄存器窗口中，你可以看到前四个参数已放置在`rcx`、`rdx`、`r8`和`r9`寄存器中。当程序调用一个函数时，该函数会在栈上保留`0x20`（`32`
    字节）的空间（为四个项目保留每个`8` 字节的空间）；这是为了确保调用的函数在需要保存寄存器参数（`rcx`、`rdx`、`r8`和`r9`）时有足够的空间。这就是为什么接下来的四个参数（第5、6、7、8个参数）会放置在栈上，从第五个项目（`rsp+0x20`）开始。我们给你展示这个例子是为了让你了解如何在栈上找到参数：
- en: '![](../images/00138.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00138.jpeg)'
- en: In the case of a 32-bit function, the stack grows as the arguments are *pushed*,
    and shrinks when the items are *popped*. In a 64-bit function, the stack space
    is allocated at the beginning of the function, and does not change until the end
    of the function. The allocated stack space is used to store the local variables
    and the function parameters. In the preceding screenshot, note how the first instruction, `sub
    rsp,48`, allocates `0x48` (`72`) bytes of space on the stack, after which no stack
    space is allocated in the middle of the function; also, instead of using `push` and `pop` instructions,
    the `mov` instructions are used to place the 5^(th), 6^(th), 7^(th), and 8^(th)
    parameters on the stack (highlighted in the preceding screenshot). The lack of `push` and `pop` instructions
    makes it difficult to determine the number of parameters accepted by the function,
    and it is also hard to say whether the memory address is being used as a local
    variable or a parameter to the function. Another challenge is, if the values are
    moved into the registers `rcx` and `rdx` before the function call, it's hard to
    say whether they are parameters passed to the function, or if they are moved into
    registers for any other reason.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 32 位函数，堆栈在参数被 *压入* 时增长，在项被 *弹出* 时收缩。对于 64 位函数，堆栈空间在函数开始时分配，并且直到函数结束之前不会改变。分配的堆栈空间用于存储局部变量和函数参数。在前面的截图中，注意第一条指令
    `sub rsp,48` 如何在堆栈上分配了 `0x48`（`72`）字节的空间，在函数中间之后没有再分配堆栈空间；此外，`push` 和 `pop` 指令没有使用，改为使用
    `mov` 指令将第 5、6、7、8 个参数放入堆栈（在前面的截图中已突出显示）。没有 `push` 和 `pop` 指令使得确定函数接受的参数数量变得困难，而且也很难判断内存地址是作为局部变量还是作为函数的参数使用。另一个挑战是，如果在函数调用之前，值已经移入了寄存器
    `rcx` 和 `rdx`，那么很难判断它们是作为参数传递给函数的，还是被移入寄存器用于其他目的。
- en: Even though there are challenges in reverse engineering a 64-bit binary, you
    should not have too much difficulty analyzing the API calls, because the API documentation
    tells you the *number of function parameters*, the *data types of the parameters,*
    and what *type of data* they return. Once you have an idea of where to find the
    function parameters and the return values, you can set a breakpoint at the API
    call and inspect its parameters to understand the malware functionality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在反向工程一个 64 位二进制文件时遇到一些挑战，你也不应该遇到太多困难来分析 API 调用，因为 API 文档告诉你 *函数参数的数量*、*参数的数据类型*
    以及它们返回的 *数据类型*。一旦你知道在哪里找到函数参数和返回值，你可以在 API 调用处设置断点，检查其参数，以了解恶意软件的功能。
- en: 'Let''s look at an example of a 64-bit malware sample that calls `RegSetValueEx` to
    set some value in the registry. In the following screenshot, the breakpoint is
    triggered before the call to the `RegSetValueEx`. You will need to look at the
    values in the registers and the stack window (as mentioned previously) to examine
    the parameters passed to the function; this will help you determine what registry
    value is set by the malware. In *x64dbg*, the easiest way to get a quick summary
    of function parameters is to look at the Default Window (below the registers window),
    which is highlighted in the following screenshot. You can set a value in the Default
    window to display the number of parameters. In the following screenshot, the value
    is set to `6`, because from the API documentation ([https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx)),
    you can tell that the `RegSetValueEx` API takes `6` parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个 64 位恶意软件示例，它调用 `RegSetValueEx` 来设置注册表中的某些值。在下图中，断点在调用 `RegSetValueEx`
    之前被触发。你需要查看寄存器和堆栈窗口中的值（如前所述），以检查传递给函数的参数；这将帮助你确定恶意软件设置了哪个注册表值。在 *x64dbg* 中，获取函数参数的最快方法是查看默认窗口（在寄存器窗口下方），该窗口在以下截图中被突出显示。你可以在默认窗口中设置一个值来显示参数的数量。在下图中，值设置为
    `6`，因为从 API 文档中（[https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx)）可以看出，`RegSetValueEx`
    API 有 `6` 个参数：
- en: '![](../images/00139.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00139.jpeg)'
- en: 'The first parameter value, `0x2c`, is the handle to the open registry key.
    Malware can open a handle to the registry key by calling either the `RegCreateKey` or `RegOpenKey` API.
    From the handles window, you can tell that the handle value `0x2c` is associated
    with the registry key shown in the following screenshot. From the handle information,
    and through inspecting the 1^(st,) 2^(nd), and 5^(th) parameters, you can tell
    that malware modifies the registry key, `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Winlogon\shell`, and
    adds an entry, `"explorer.exe,logoninit.exe"`. On a clean system, this registry
    key points to `explorer.exe` (the default Windows shell). When the system starts,
    the `Userinit.exe` process uses this value to launch the Windows shell (`explorer.exe`).
    By adding `logoninit.exe`, along with `explorer.exe`, the malware makes sure that `logoninit.exe` is
    also launched by `Userinit.exe`; this is another type of persistence mechanism
    used by the malware:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数值`0x2c`是打开注册表键的句柄。恶意软件可以通过调用`RegCreateKey`或`RegOpenKey`API打开注册表键的句柄。从句柄窗口中，您可以看到句柄值`0x2c`与以下截图中显示的注册表键相关联。通过句柄信息，并检查第1、2和5个参数，您可以知道恶意软件修改了注册表键`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Winlogon\shell`，并添加了一个条目`"explorer.exe,logoninit.exe"`。在干净的系统上，此注册表键指向`explorer.exe`（默认的Windows
    shell）。当系统启动时，`Userinit.exe`进程使用此值启动Windows shell（`explorer.exe`）。通过添加`logoninit.exe`，以及`explorer.exe`，恶意软件确保`Userinit.exe`也启动了`logoninit.exe`；这是恶意软件使用的另一种持久性机制：
- en: '![](../images/00140.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00140.jpeg)'
- en: At this point, you should have an understanding of how to debug a malicious
    executable to understand its functionality. In the next section, you will learn
    how to debug a malicious DLL to determine its behavior.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该已经了解如何调试恶意可执行文件以了解其功能。在下一节中，您将学习如何调试恶意DLL以确定其行为。
- en: 2.8 Debugging a Malicious DLL Using x64dbg
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 使用x64dbg调试恶意DLL
- en: In [chapter 3](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485),* Dynamic
    Analysis*, you learned techniques to execute a DLL to perform dynamic analysis.
    In this section, you will use some of the concepts that you learned in [chapter
    3](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522),* Dynamic
    Analysis*, to debug a DLL using *x64dbg*. If you are not already familiar with
    the dynamic analysis of a DLL, it is highly recommended to read S*ection 6*, *Dynamic-Link
    Library (DLL) Analysis*, from [Chapter 3](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522),* Dynamic
    Analysis,* before proceeding further.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485)，*动态分析*中，您学习了执行DLL以执行动态分析的技术。在本节中，您将使用在[第3章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522)，*动态分析*中学到的一些概念来使用*x64dbg*调试DLL。如果您还不熟悉DLL的动态分析，强烈建议在继续之前阅读[第3章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522)，*动态分析*中的*第6节*，*动态链接库（DLL）分析*。
- en: 'To debug a DLL, launch *x64dbg* (preferably with administrator privileges)
    and load the DLL (via File | Open). When you load the DLL, *x64dbg* drops an executable
    (named `DLLLoader32_xxxx.exe`, where `xxxx` are random hexadecimal characters)
    into the same directory where your DLL is located; this executable acts as a generic
    host process, which will be used to execute your DLL (in the same manner as `rundll32.exe`).
    After you load the DLL, the debugger may pause at the `System Breakpoint`, `TLS
    callback`, or `DLL entry point` function, depending on the configuration settings
    (mentioned earlier, in the *Launching a New Process in x64dbg* section). With
    the System Breakpoint* and TLS callback* options unchecked, the execution will
    pause at the *DLL''s entry point* upon loading the DLL, as shown in the following
    screenshot. Now, you can debug the DLL like any other program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试DLL，请启动*x64dbg*（最好具有管理员权限）并加载DLL（通过文件 | 打开）。当您加载DLL时，*x64dbg*会在与DLL位于同一目录的地方放置一个可执行文件（名为`DLLLoader32_xxxx.exe`，其中`xxxx`是随机的十六进制字符），此可执行文件充当通用主机进程，将用于执行您的DLL（与`rundll32.exe`相同的方式）。加载DLL后，调试器可能会在`系统断点`，`TLS回调`或`DLL入口点`函数处暂停，具体取决于配置设置（在*在x64dbg中启动新进程*部分中提到）。如果未选中`系统断点`和`TLS回调`选项，则在加载DLL时会在*DLL的入口点*处暂停执行，如下截图所示。现在，您可以像调试其他程序一样调试DLL：
- en: '![](../images/00141.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00141.jpeg)'
- en: 2.8.1 Using rundll32.exe to Debug the DLL in x64dbg
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8.1 使用rundll32.exe在x64dbg中调试DLL
- en: 'Another effective method is to use `rundll32.exe` to debug the DLL (let''s
    suppose that you want to debug a malware DLL named `rasaut.dll`). To do so, first
    load `rundll32.exe` from the system32 directory (via File | Open) into the debugger,
    which will pause the debugger at the `system breakpoint` or the `Entry point` of `rundll32.exe` (depending
    on the settings mentioned earlier). Then, select Debug | Change Command Line and
    specify the command-line arguments to `rundll32.exe` (specify the full path to
    the DLL and the export function), as follows, and click on OK:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有效的方法是使用`rundll32.exe`来调试 DLL（假设你想要调试一个名为`rasaut.dll`的恶意软件 DLL）。为此，首先从系统32目录（通过文件
    | 打开）加载`rundll32.exe`到调试器中，这将在`系统断点`或`rundll32.exe`的`入口点`（取决于之前提到的设置）处暂停调试器。然后，选择调试
    | 更改命令行，并指定`rundll32.exe`的命令行参数（指定 DLL 的完整路径和导出函数），如下所示，并单击确定：
- en: '![](../images/00142.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00142.jpeg)'
- en: 'Next, select the Breakpoints tab, right-click inside the Breakpoints window,
    and choose the Add DLL breakpoint option, which will bring up a dialog window
    prompting you to enter the module name. Enter the DLL name (in this case, `rasaut.dll`),
    shown as follows. This will tell the debugger to break when the DLL (`rasaut.dll`)
    is loaded. After configuring these settings, close the debugger:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择断点选项卡，在断点窗口内右键单击，并选择添加 DLL 断点选项，这将弹出一个对话框窗口提示您输入模块名称。输入 DLL 名称（在本例中为`rasaut.dll`），如下所示。这将告诉调试器在加载
    DLL（`rasaut.dll`）时中断。配置这些设置后，关闭调试器：
- en: '![](../images/00143.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00143.jpeg)'
- en: 'Next, reopen the debugger and load `rundll32.exe` again; when you load it again,
    the previous command-line settings will still be intact. Now, select Debug | Run
    (*F9*), till you break at the entry point of the DLL (you may have to select Run
    (*F9)* multiple times, till you reach the DLL entry point). You can keep track
    of where the execution has paused every time you run (*F9*), by looking at the
    *comment* next to the *breakpoint address. Y*ou can also find the same comment
    next to the `eip` register. In the following screenshot, you can see that the
    execution has paused at the entry point of `rasaut.dll`. At this point, you can
    debug the DLL like any other program. You can also set breakpoints on any function
    exported by the DLL. You can find the export functions by using the Symbols window;
    after you have found the desired *export* function, double-click on it (which
    will take you to the code of the export function in the disassembly window). Then,
    set a breakpoint at the desired address:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重新打开调试器并再次加载`rundll32.exe`；当您再次加载时，之前的命令行设置仍将保持不变。现在，选择调试 | 运行（*F9*），直到您在
    DLL 的入口点中断（您可能需要多次选择运行（*F9*），直到达到 DLL 入口点）。您可以通过查看*断点地址旁的注释*，每次运行（*F9*）时跟踪执行暂停的位置。您还可以在`eip`寄存器旁找到相同的注释。在下面的屏幕截图中，您可以看到执行已在`rasaut.dll`的入口点处暂停。在这一点上，您可以像调试任何其他程序一样调试
    DLL。您还可以在 DLL 导出的任何函数上设置断点。您可以使用符号窗口找到导出函数；在找到所需的*导出*函数后，双击它（这将带您到反汇编窗口中导出函数的代码）。然后，在所需地址处设置断点：
- en: '![](../images/00144.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00144.jpeg)'
- en: 2.8.2 Debugging a DLL in a Specific Process
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8.2 在特定进程中调试 DLL
- en: Sometimes, you may want to debug a DLL that only runs in a specific process
    (such as `explorer.exe`). The procedure is similar to the one covered in the previous
    section. First, *launch the process* or *attach* to the desired host process using
    x64dbg; this will pause the debugger. Allow the process to run by selecting Debug
    | Run (*F9*). Next, select the Breakpoints tab, right-click inside the Breakpoints
    window, and select the Add DLL breakpoint option, which will bring up a dialog
    window prompting you to enter the module name. Enter the DLL name (as covered
    in the previous section); this will tell the debugger to break when the DLL is
    loaded. Now, you need to inject the DLL into the host process. This can be done
    using a tool like *RemoteDLL* ([https://securityxploded.com/remotedll.php](https://securityxploded.com/remotedll.php)).
    When the DLL is loaded, the debugger will pause somewhere in `ntdll.dll`; just
    hit Run (*F9*) till you reach the entry point of the injected DLL (you might have
    to run multiple times before you reach the entry point). You can keep track of
    where the execution has paused every time you hit **Run** (*F9*) by looking at
    the comment next to the breakpoint address or next to the `eip` register, as mentioned
    in the previous section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望调试仅在特定进程（如`explorer.exe`）中运行的DLL。该过程类似于前一节中介绍的过程。首先，使用x64dbg*启动进程*或*附加*到所需的主机进程；这将暂停调试器。通过选择Debug
    | Run (*F9*)允许进程运行。接下来，选择Breakpoints选项卡，在Breakpoints窗口内右键单击，并选择Add DLL breakpoint选项，这将弹出一个对话框提示您输入模块名称。输入DLL名称（如前一节中介绍的），这将告诉调试器在加载DLL时中断。现在，您需要将DLL注入到主机进程中。可以使用类似*RemoteDLL*（[https://securityxploded.com/remotedll.php](https://securityxploded.com/remotedll.php)）的工具来完成此操作。当DLL加载时，调试器将在`ntdll.dll`中的某处暂停；只需连续运行（*F9*）直到达到注入的DLL的入口点（可能需要多次运行才能到达入口点）。您可以通过查看断点地址旁边或前一节中提到的`eip`寄存器旁边的注释来跟踪每次运行（*F9*）时暂停的执行位置。
- en: 2.9 Tracing Execution in x64dbg
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 在x64dbg中跟踪执行
- en: '*Tracing* allows you to log events while the process is executing. x64dbg supports *trace
    into* and *trace over* conditional tracing options. You can access these options
    via Trace | Trace into (*Ctrl*+*Alt*+*F7*) and **Trace | Trace over** (*Ctrl+Alt+F8*).
    In *trace into*, the debugger internally traces the program by setting *step into* breakpoint,
    until a condition is satisfied or the maximum number of steps is reached. In *trace
    over*, the debugger traces the program by setting *step over* breakpoint, until
    the condition is satisfied or the maximum number of steps is reached. The following
    screenshot shows the Trace into dialog (the same options are provided in the Trace
    over dialog). To trace the logs, at a minimum, you need to specify the *log text* and
    the full path to the log file (via the Log File button) where the trace events
    will be redirected:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪*允许您在进程执行时记录事件。x64dbg支持*跟踪进入*和*跟踪覆盖*条件跟踪选项。您可以通过Trace | Trace into (*Ctrl*+*Alt*+*F7*)和**Trace
    | Trace over** (*Ctrl+Alt+F8*)访问这些选项。在*跟踪进入*中，调试器通过设置*步入*断点内部跟踪程序，直到条件满足或达到最大步数。在*跟踪覆盖*中，调试器通过设置*步过*断点跟踪程序，直到条件满足或达到最大步数。以下屏幕截图显示了跟踪进入对话框（跟踪覆盖对话框中提供相同选项）。要跟踪日志，至少需要指定*log
    text*和将跟踪事件重定向到的日志文件的完整路径（通过Log File按钮）：'
- en: '![](../images/00145.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00145.jpeg)'
- en: 'The following includes brief descriptions of some of the fields:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包括一些字段的简要描述：
- en: '**Breakpoint Condition**: You can specify a condition in this field. This field
    defaults to a value of `0` (`false`). To specify the condition, you need to specify
    any valid expression ([http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html](http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html))
    that evaluates to a non zero value (`true`). Expressions that evaluate to non-zero
    values are considered `true`, thereby triggering the breakpoint. The debugger
    continues tracing by evaluating the provided expression, and stops when the specified
    condition is satisfied. If the condition is not satisfied, the tracing continues
    until the *maximum trace count* is reached.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点条件**：您可以在此字段中指定条件。此字段默认为`0`（`false`）。要指定条件，您需要指定任何有效表达式（[http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html](http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html)）来评估为非零值（`true`）。评估为非零值的表达式被视为`true`，从而触发断点。调试器通过评估提供的表达式继续跟踪，并在满足指定条件时停止。如果条件不满足，则跟踪将继续直到达到*最大跟踪计数*。'
- en: '**Log Text**: This field is used to specify the format that will be used to
    log the trace events in the log file. The valid formats that can be used in this
    field are mentioned at [http://help.x64dbg.com/en/latest/introduction/Formatting.html](http://help.x64dbg.com/en/latest/introduction/Formatting.html)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志文本**：此字段用于指定将用于记录日志文件中跟踪事件的格式。此字段可以使用的有效格式在[http://help.x64dbg.com/en/latest/introduction/Formatting.html](http://help.x64dbg.com/en/latest/introduction/Formatting.html)中列出。'
- en: '**Log Condition**: This field defaults to a value of `1`. You can optionally
    provide a log condition that will tell the debugger to log an event only when
    a specific condition is met. The log condition needs to be a valid expression
    ([http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html](http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html)).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志条件**：此字段的默认值为`1`。你可以选择性地提供一个日志条件，这样调试器只有在特定条件满足时才会记录事件。日志条件需要是有效的表达式（[http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html](http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html)）。'
- en: '**Maximum Trace Count**: This fields specifies the maximum step count to trace
    before the debugger gives up. The default value is set to `50000`, and you can
    increase or decrease this value, as required.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大跟踪次数**：此字段指定调试器放弃之前可以跟踪的最大步骤数。默认值设置为`50000`，你可以根据需要增加或减少此值。'
- en: '**Log File Button**: You can use this button to specify the full path to the
    log file where the trace logs will be saved.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志文件按钮**：你可以使用此按钮指定日志文件的完整路径，跟踪日志将保存在此文件中。'
- en: 'x64dbg does not have specific *instruction tracing* and *function tracing*
    features, but the *trace into* and *trace over* options can be used to perform
    instruction tracing and function tracing. You can control the tracing by adding
    breakpoints. In the following screenshot, the `eip` is pointing at the 1^(st)
    instruction, and a breakpoint is set at the 5^(th) instruction. When the tracing
    has initiated, the debugger starts tracing from the first instruction, and pauses
    at the breakpoint. If there is no breakpoint, the tracing continues until the
    program ends, or until the maximum trace count is reached. You can choose *trace
    into* if you want to trace the instructions that are inside the function, or *trace
    over* to step over the function and trace the rest of the instructions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: x64dbg 没有特定的*指令跟踪*和*函数跟踪*功能，但可以使用*追踪进入*和*追踪跳过*选项来执行指令跟踪和函数跟踪。你可以通过添加断点来控制跟踪。在下面的截图中，`eip`
    指向第 1 条指令，并且在第 5 条指令处设置了断点。当跟踪开始时，调试器从第一条指令开始跟踪，并在断点处暂停。如果没有断点，跟踪将继续，直到程序结束，或者直到达到最大跟踪次数。如果你想跟踪函数内部的指令，可以选择*追踪进入*，或者选择*追踪跳过*来跳过该函数并跟踪其余的指令：
- en: '![](../images/00146.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00146.jpeg)'
- en: 2.9.1 Instruction Tracing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9.1 指令跟踪
- en: 'To perform *instruction tracing* (for example, *trace into*) on the previous
    program, you can use the following settings in the Trace into dialog. As mentioned
    previously, to capture the trace events in a log file, you need to specify the
    full path to the log file and the Log Text:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在前面的程序中执行*指令跟踪*（例如，*追踪进入*），你可以在“追踪进入”对话框中使用以下设置。如前所述，为了在日志文件中捕获跟踪事件，你需要指定日志文件的完整路径和日志文本：
- en: '![](../images/00147.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00147.jpeg)'
- en: 'The Log Text value in the preceding screenshot (`0x{p:cip} {i:cip}`) is in
    the string format, which specifies the debugger to log the *address* and the *disassembly*
    of all the traced instructions. The following is the trace log of the program.
    As a result of choosing the *Trace into* option, the instructions inside the function
    (`0xdf1000`) are also captured (highlighted in the following code). Instruction
    tracing is useful to get a quick idea of a program''s execution flow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图中的日志文本值（`0x{p:cip} {i:cip}`）是字符串格式，指定调试器记录所有跟踪指令的*地址*和*反汇编*。以下是程序的跟踪日志。由于选择了*追踪进入*选项，函数内部的指令（`0xdf1000`）也被捕获（在下面的代码中高亮显示）。指令跟踪有助于快速了解程序的执行流程：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 2.9.2 Function Tracing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9.2 函数跟踪
- en: 'To demonstrate *function tracing*, consider the program shown in the following
    screenshot. In this program, the `eip` is pointing to the first instruction, the
    breakpoint is set at the fifth instruction (to stop tracing at this point), and
    the third instruction calls a function at `0x311020`. We can use function tracing
    to determine what other functions are called by the function (`0x311020`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示*函数跟踪*，请看以下截图中的程序。在这个程序中，`eip`指向第一条指令，断点设置在第五条指令（以在此点停止追踪），第三条指令调用了`0x311020`地址的函数。我们可以使用函数跟踪来确定`0x311020`函数调用了哪些其他函数：
- en: '![](../images/00148.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00148.jpeg)'
- en: 'To perform function tracing (Trace into was chosen in this case), the following
    setting is used. This is similar to *instruction tracing*, except that in the
    Log Condition field, an expression, telling the debugger to log only the function
    call is specified:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行函数跟踪（在此案例中选择了“进入追踪”），使用了以下设置。这类似于*指令跟踪*，不同之处在于在日志条件字段中，指定了一个表达式，指示调试器仅记录函数调用：
- en: '![](../images/00149.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00149.jpeg)'
- en: 'The following are the events captured in the log file, as a result of *function
    tracing*. From the following events, you can tell that the function `0x311020` calls
    two other functions, at `0x311000` and `0x311010`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过*函数跟踪*在日志文件中捕获的事件。从这些事件中，你可以看出，函数`0x311020`调用了两个其他函数，分别位于`0x311000`和`0x311010`：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding examples, the breakpoints were used to control the tracing.
    When the debugger reaches the breakpoint, the execution is paused, and the *instructions/functions*
    till the breakpoint are logged. When you resume the debugger, the rest of the
    instructions are executed, but not logged.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用了断点来控制追踪。当调试器到达断点时，执行暂停，且*指令/函数*在断点之前会被记录。当你恢复调试器时，剩下的指令会被执行，但不会被记录。
- en: 2.10 Patching in x64dbg
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 在x64dbg中修补
- en: 'While performing malware analysis, you may want to modify the binary to change
    its functionality or reverse its logic to suit your needs. x64dbg allows you to
    modify data in the memory or instructions of a program. To modify the data in
    a memory, navigate to the memory address and select the sequence of bytes you
    want to modify, then right-click and choose Binary | Edit (*Ctrl* + *E*), which
    will bring up a dialog (shown as follows) that you can use to modify the data
    as ASCII, UNICODE, or a sequence of hex bytes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行恶意软件分析时，你可能想修改二进制文件以改变其功能或逆向其逻辑，以满足你的需求。x64dbg允许你修改程序的内存数据或指令。要修改内存中的数据，导航到内存地址，选择你要修改的字节序列，然后右键点击并选择“二进制
    | 编辑”（*Ctrl* + *E*），这将弹出一个对话框（如下所示），你可以用它来修改数据为ASCII、UNICODE或一系列十六进制字节：
- en: '![](../images/00150.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00150.jpeg)'
- en: 'The following screenshot shows the code excerpt from the *TDSS rootkit* DLL
    (this is the same binary that was covered in the previous chapter, in the section
    *Patching the Binary Using IDA*). If you recall, this DLL used string comparison
    to perform a check to ensure that it was running under the `spoolsv.exe` process.
    If the string comparison fails (that is, if the DLL is not running under `spoolsv.exe`),
    then the code jumps to the end of the function and returns from the function without
    exhibiting malicious behavior. Suppose that you want this binary to run under
    any process (not just `spoolsv.exe`). You can modify the *conditional jump* instruction
    (`JNE tdss.10001Cf9`) with a `nop` instruction, to remove the process restriction.
    To do that, right-click on the conditional jump instruction and select Assemble,
    which will bring up the dialog shown as follows, using which you can enter the
    instructions. Note that, in the screenshot, the fill with NOP''s option is checked,
    to make sure that the instruction alignment is correct:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了*TDSS rootkit* DLL的代码片段（这与前一章中涉及的相同二进制文件，在*使用IDA修补二进制文件*的部分有介绍）。如果你记得的话，这个DLL使用字符串比较来检查它是否在`spoolsv.exe`进程下运行。如果字符串比较失败（也就是说，DLL没有在`spoolsv.exe`进程下运行），代码就会跳转到函数的末尾，并在不表现出恶意行为的情况下返回函数。如果你希望这个二进制文件能够在任何进程下运行（而不仅仅是`spoolsv.exe`），你可以用`nop`指令修改*条件跳转*指令（`JNE
    tdss.10001Cf9`），以去除进程限制。为此，右键点击条件跳转指令并选择“汇编”，这将弹出如下对话框，使用它可以输入指令。请注意，在截图中，已勾选“填充NOP”的选项，以确保指令对齐正确：
- en: '![](../images/00151.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00151.jpeg)'
- en: 'After you have modified the data in the memory or the instruction, you can
    apply the patch to the file by choosing File | Patch file, which will bring up
    a patches dialog showing all of the modifications made to the binary. Once you
    are satisfied with the modifications, click on Patch file and save the file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改了内存中的数据或指令之后，你可以通过选择 **文件 | 补丁文件** 来将补丁应用到文件中，这将弹出一个补丁对话框，显示对二进制文件所做的所有修改。满意修改后，点击
    **补丁文件** 并保存文件：
- en: '![](../images/00152.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00152.jpeg)'
- en: 3\. Debugging a Binary Using IDA
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 使用 IDA 调试二进制文件
- en: In the previous chapter, we looked at the disassembly features of *IDA Pro*.
    In this chapter, you will learn about IDA's debugging capabilities. The commercial
    version of IDA can debug both 32-bit and 64-bit applications, whereas the demo
    version only allows you to debug a 32-bit Windows binary. In this section, you
    will see some of the debugging features offered by IDA Pro, and you will learn
    how to use it to debug a malicious binary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们查看了 *IDA Pro* 的反汇编功能。在本章中，你将了解 IDA 的调试能力。IDA 的商业版本可以调试 32 位和 64 位应用程序，而演示版只允许调试
    32 位 Windows 二进制文件。在本节中，你将看到 IDA Pro 提供的一些调试功能，并将学习如何使用它调试恶意二进制文件。
- en: 3.1 Launching a New Process in IDA
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 在 IDA 中启动新进程
- en: There are different ways to launch a new process; one method is to directly
    launch the debugger, without initially loading the program. To do that, launch
    IDA (without loading the executable), then select Debugger | Run | Local Windows
    debugger; this will bring up a dialog where you can choose the file to debug.
    If the executable takes any parameters, you can specify them in the Parameters
    field. This method will start a new process, and the debugger will pause the execution
    at the program's *entry point:*
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启动新进程有不同的方法；一种方法是直接启动调试器，而不先加载程序。要做到这一点，启动 IDA（不加载可执行文件），然后选择 **调试器 | 运行 | 本地
    Windows 调试器**；这将弹出一个对话框，你可以在其中选择要调试的文件。如果可执行文件需要任何参数，你可以在 **参数** 字段中指定它们。此方法将启动一个新进程，调试器将在程序的
    *入口点* 暂停执行：
- en: '![](../images/00153.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00153.jpeg)'
- en: The second method of launching a process is to first load the executable in
    IDA (which performs the initial analysis and displays the disassembled output).
    First, choose the correct debugger via Debugger | Select debugger (or *F9*); then,
    you can place the cursor on the first instruction (or the instruction where you
    want the execution to pause) and select Debugger | Run to cursor (or *F4*). This
    will start a new process, and will execute until the current cursor location (in
    this case, the breakpoint is automatically set at the current cursor location).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 启动进程的第二种方法是先在 IDA 中加载可执行文件（这将执行初步分析并显示反汇编输出）。首先，通过 **调试器 | 选择调试器**（或 *F9*）选择正确的调试器；然后，你可以将光标放在第一个指令上（或你希望执行暂停的指令），并选择
    **调试器 | 运行到光标处**（或 *F4*）。这将启动一个新进程，并将执行直到当前光标位置（在这种情况下，断点会自动设置在当前光标位置）。
- en: 3.2 Attaching to an Existing Process Using IDA
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 使用 IDA 附加到现有进程
- en: 'The way you attach to a process depends on whether the program has already
    loaded or not. When a program has not loaded, select Debugger | Attach | Local
    Windows debugger. This will list all of the running processes. Simply select the
    process to attach to. After attaching, the process will be paused immediately,
    giving you the chance to inspect the process''s resources and set breakpoints,
    prior to resuming execution of the process. In this method, IDA will not be able
    to perform its initial auto-analysis of the binary, because IDA''s loader will
    not get a chance to load the executable image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你附加到进程的方式取决于程序是否已经加载。当程序没有加载时，选择 **调试器 | 附加 | 本地 Windows 调试器**。这将列出所有正在运行的进程。只需选择要附加的进程即可。附加后，进程将立即暂停，给你机会在继续执行之前检查进程的资源并设置断点。在这种方法中，IDA
    无法执行其初始的自动分析，因为 IDA 的加载器没有机会加载可执行映像：
- en: '![](../images/00154.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00154.jpeg)'
- en: An alternate method of *attaching to a process* is loading the executable associated
    with a process into IDA before attaching to that process. To achieve this, load
    the associated executable using IDA; this allows IDA to perform its initial analysis.
    Then, select **Debugger** | **Select debugger** and check the Local Win32 debugger (or
    Local Windows debugger) option, and click OK. Then, select Debugger | Attach to
    process again, and choose the process to attach the debugger.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种*附加到进程*的方法是将与进程关联的可执行文件加载到IDA中，然后再附加到该进程。要实现这一点，首先使用IDA加载相关的可执行文件，这样IDA就可以执行初步分析。然后，选择**调试器**
    | **选择调试器**，勾选Local Win32调试器（或Local Windows调试器）选项，并点击确认。接着，再次选择**调试器** | **附加到进程**，并选择要附加调试器的进程。
- en: 3.3 IDA's Debugger Interface
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 IDA的调试器界面
- en: 'After you launch the program in the IDA debugger, the process will pause, and
    the following debugger display will be presented to you:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 启动程序后，进程会暂停，并会向你展示以下调试器界面：
- en: '![](../images/00155.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00155.jpeg)'
- en: 'When the process is under debugger control, the disassembly toolbar is replaced
    with the debugger toolbar. This toolbar consists of buttons related to the debugging
    functionality (such as *process control* and *breakpoint*):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程在调试器控制下时，反汇编工具栏会被调试器工具栏替代。此工具栏包含与调试功能相关的按钮（例如*进程控制*和*断点*）：
- en: '**Disassembly Window**: This window is synchronized with the current value
    of the *instruction pointer* register (`eip` or `rip`). The disassembly windows
    offer the same functionality that you learned in the previous chapter. You can
    also switch between the *graph view* and the *text view* modes by pressing the
    *spacebar* key.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反汇编窗口**：此窗口与当前*指令指针*寄存器（`eip`或`rip`）的值同步。反汇编窗口提供了你在前一章节中学到的相同功能。你还可以通过按下*空格键*在*图形视图*和*文本视图*模式之间切换。'
- en: '**Register Window**: This window displays the current contents of the CPU''s
    general-purpose register. You can right-click a register value and click Modify
    value, Zero value, Toggle value, Increment, or Decrement value. Toggling a value
    is particularly useful if you want to change the states of CPU flag bits. If the
    value of the register is a valid memory location, the *right-angle arrow* next
    to the register''s value will be active; clicking on this arrow will relocate
    the view to the corresponding memory location. If you ever find that you have
    navigated to a different location and would like to go to the location pointed
    to by the *instruction pointer,* then just click on the *right-angle arrow* next
    to the value of the instruction pointer register (`eip` or `rip`).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器窗口**：此窗口显示CPU通用寄存器的当前内容。你可以右键单击寄存器值，点击修改值、清零值、切换值、增值或减值。切换值特别有用，尤其是当你想要更改CPU标志位的状态时。如果寄存器的值是一个有效的内存位置，则寄存器值旁边的*右箭头*会变为可用状态；点击该箭头可以将视图移动到对应的内存位置。如果你发现自己导航到了其他位置，并希望返回到*指令指针*指向的位置，只需点击指令指针寄存器（`eip`或`rip`）值旁的*右箭头*。'
- en: '**Stack View**: The *stack view* displays the data contents of the process''s
    runtime stack. Inspecting the stack before calling a function can yield information
    about the number of function arguments and the types of function arguments.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈视图**：*栈视图*显示进程运行时栈的数据信息。在调用函数之前检查栈可以获取有关函数参数数量和类型的信息。'
- en: '**Hex View**: This displays the standard hex dump of the memory. *Hex view*
    is useful if you want to display the contents of a valid memory location (contained
    within a *register*, a *stack*, or the *instruction*).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十六进制视图**：此视图显示内存的标准十六进制转储。*十六进制视图*在你想要显示有效内存位置的内容时很有用（该位置可能在*寄存器*、*栈*或*指令*中）。'
- en: '**Modules View**: This displays the list of modules (*executables* and their *shared
    libraries*) loaded into the process memory. Double-clicking any module in the
    list displays a list of symbols exported by that module. This is an easy way to
    navigate to the functions within the loaded libraries.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块视图**：此视图显示加载到进程内存中的模块列表（*可执行文件*及其*共享库*）。双击列表中的任何一个模块，都会显示该模块导出的符号列表。这是一个方便的方式，可以快速跳转到加载库中的函数。'
- en: '**Threads View**: Displays a list of threads in the current process. You can
    right-click on this window to *suspend a thread* or *resume a suspended thread*.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程视图**：显示当前进程中线程的列表。你可以右键单击此窗口来*挂起线程*或*恢复挂起的线程*。'
- en: '**Segments Window**: The *s**egments window* is available via View | Open Subviews
    | Segments (or *Shift* + *F7*). When you are debugging a program, the segments
    window provides information regarding the allocated memory segments in a process.
    This window displays the information about where the executable and its sections
    are loaded in memory. It also contains details on all of the loaded DLLs, and
    their section information. Double-clicking on any entry will take you to the corresponding
    memory location in either the *disassembly window* or the *hex window*. You can
    control where the contents of the memory address should be displayed (in the disassembly
    or hex window); to do that, just place the cursor anywhere in the disassembly
    or hex window, and then double-click on the entry. Depending on the cursor location,
    the contents of the memory address will be displayed in the appropriate window:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**段窗口**：*段窗口*可以通过 视图 | 打开子视图 | 段（或 *Shift* + *F7*）打开。当你调试一个程序时，段窗口提供有关进程中已分配内存段的信息。此窗口显示可执行文件及其各个部分在内存中的加载位置的信息，还包含所有已加载
    DLL 及其段信息。双击任何条目将会将你带到相应的内存位置，进入 *反汇编窗口*或 *十六进制窗口*。你可以控制内存地址的内容应该显示在哪里（在反汇编窗口或十六进制窗口中）；只需将光标放在反汇编或十六进制窗口中的任何位置，然后双击该条目。根据光标的位置，内存地址的内容将显示在相应的窗口中：'
- en: '![](../images/00156.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00156.jpeg)'
- en: '**Imports and Exports Window**: When the process is under debugger control,
    the Imports and Exports windows are not displayed by default. You can bring up
    these windows via Views | Open subviews. The Imports window lists all of the functions
    imported by the binary, and the Exports window lists all of the exported functions.
    The exported functions are normally found in the DLLs, so this window can be particularly
    useful when you are debugging malicious DLLs.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入和导出窗口**：当进程在调试器控制下时，导入和导出窗口默认情况下不会显示。你可以通过 视图 | 打开子视图来显示这些窗口。导入窗口列出了二进制文件导入的所有函数，导出窗口列出了所有导出的函数。导出的函数通常位于
    DLL 文件中，因此在调试恶意 DLL 时，这个窗口特别有用。'
- en: The other IDA windows, explained in the previous chapter, can also be accessed
    via Views | Open Subviews.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中解释的其他 IDA 窗口，也可以通过 视图 | 打开子视图进行访问。
- en: 3.4 Controlling Process Execution Using IDA
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 使用 IDA 控制进程执行
- en: 'In *Section 1.2*, *Controlling Process Execution*, we looked at the different
    execution control features provided by the debuggers. The following table outlines
    the common execution control functionalities that you can use in IDA when debugging
    a program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第1.2节*，*控制进程执行* 中，我们讨论了调试器提供的不同执行控制功能。下表概述了在调试程序时，你可以在 IDA 中使用的常见执行控制功能：
- en: '| Functionality | Hotkey | Menu Option |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 热键 | 菜单选项 |'
- en: '| Continue (Run) | *F9* | Debugger &#124; Continue process |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 继续（运行） | *F9* | 调试器 &#124; 继续进程 |'
- en: '| Step into | *F7* | Debugger &#124; Step into |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 单步进入 | *F7* | 调试器 &#124; 单步进入 |'
- en: '| Step over | *F8* | Debugger &#124; Step over |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 单步跳过 | *F8* | 调试器 &#124; 单步跳过 |'
- en: '| Run to cursor | *F4* | Debugger &#124; Run to cursor |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 跳转到光标 | *F4* | 调试器 &#124; 跳转到光标 |'
- en: 3.5 Setting a Breakpoint in IDA
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 在 IDA 中设置断点
- en: To set a software breakpoint in IDA, you can navigate to the location where
    you want the program to pause, and press the *F2 *key (or right-click and select Add
    breakpoint). After you set the breakpoint, the addresses where breakpoints are
    set are highlighted in a red color. You can remove the breakpoint by pressing *F2 *on
    the line containing the breakpoint.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 IDA 中设置软件断点，你可以导航到希望程序暂停的地点，按下 *F2* 键（或右键点击并选择 添加断点）。设置断点后，断点所在的地址会以红色高亮显示。你可以通过按 *F2* 键删除设置的断点。
- en: 'In the following screenshot, the breakpoint was set at the address `0x00401013` (`call
    sub_401000`). To pause the execution at the breakpoint address, first, choose
    the debugger (such as Local Win32 Debugger), as mentioned previously, and then
    run the program by selecting Debugger | Start Process (or the *F9* hotkey). This
    will execute all of the instructions before reaching the breakpoint, and will
    pause at the breakpoint address:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，断点被设置在地址 `0x00401013` （`call sub_401000`）处。要在断点地址处暂停执行，首先选择调试器（例如本地
    Win32 调试器），然后通过选择 调试器 | 启动进程 （或 *F9* 热键）来运行程序。这样会执行所有指令，直到到达断点，并在断点地址处暂停：
- en: '![](../images/00157.gif)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00157.gif)'
- en: 'In IDA, you can set hardware and conditional breakpoints by editing the breakpoint
    that is already set. To set a hardware breakpoint, right-click on an existing
    breakpoint and select Edit breakpoint. In the dialog that pops up, check the Hardware
    checkbox, shown as follows. IDA allows you to set more than four hardware breakpoints,
    but only four of them will work; the additional hardware breakpoints will be ignored:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 中，你可以通过编辑已经设置的断点来设置硬件断点和条件断点。要设置硬件断点，右键单击一个已有的断点，然后选择编辑断点。在弹出的对话框中，勾选硬件复选框，如下所示。IDA
    允许你设置超过四个硬件断点，但只有四个断点会生效；额外的硬件断点将会被忽略：
- en: '![](../images/00158.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00158.jpeg)'
- en: You can use hardware breakpoints to specify whether to *break on execute* (default),
    *break on write,* or *break on read/write*. The *break on write* and *break on read/write* options
    allow you to create memory breakpoints when the specified memory location is accessed
    by any instruction. This breakpoint is useful if you want to know when your program
    accesses a piece of data (read/write) from a memory location. The *break on execute* option
    allows you to set a breakpoint when the specified memory location is executed.
    In addition to specifying a mode, you must also specify a size. A hardware breakpoint's
    size is combined with its address to form a range of bytes for which the breakpoint
    may be triggered.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用硬件断点来指定是否在*执行时断点*（默认），*写入时断点*，或*读/写时断点*。*写入时断点* 和 *读/写时断点* 选项允许你在任何指令访问指定的内存位置时创建内存断点。如果你想知道程序何时从内存位置读取或写入数据，这个断点非常有用。*执行时断点*
    选项允许你在指定的内存位置被执行时设置断点。除了指定模式外，你还必须指定大小。硬件断点的大小与其地址结合，形成一个字节范围，这个范围内的地址可能会触发断点。
- en: You can set a conditional breakpoint by specifying the condition in the condition
    field. The condition can be an actual condition, or IDC or IDAPython expressions.
    You can click on the ... button next to the condition field, which will open up
    the editor, where you can use IDC or IDAPython scripting language to evaluate
    the condition. You can find some examples of setting conditional breakpoints at [https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml](https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在条件字段中指定条件来设置条件断点。条件可以是一个实际条件，或者是 IDC 或 IDAPython 表达式。你可以点击条件字段旁边的`...`按钮，这将打开编辑器，在编辑器中你可以使用
    IDC 或 IDAPython 脚本语言来评估条件。你可以在 [https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml](https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml)
    查找到设置条件断点的一些示例。
- en: You can view all of the active breakpoints by navigating to Debugger | Breakpoints
    | Breakpoint List (or typing *Ctrl* + *Alt* + *B*). You can right-click on the
    breakpoint entry and *disable* or *delete* the breakpoint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到 调试器 | 断点 | 断点列表 （或按 *Ctrl* + *Alt* + *B*）来查看所有活动断点。你可以右键点击断点条目并*禁用*或*删除*该断点。
- en: 3.6 Debugging Malware Executables
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 恶意软件可执行文件调试
- en: 'In this section, we will look at how to use IDA to debug a malware binary.
    Consider the disassembly listing from a 32-bit malware sample. The malware calls
    the `CreateFileW` API to create a file, but, just by looking at the disassembly
    listing, it is not clear what file the malware creates. From the MSDN documentation
    for `CreateFile`, you can tell that the first parameter to `CreateFile` will contain
    the name of the file; also, the suffix `W` in the `CreateFile` specifies that
    the name of the file is a UNICODE string (details regarding the API were covered
    in the previous chapter). To determine the name of the file, we can set a breakpoint
    at the address where the call to the `CreateFileW` ➊ is made, and then run the
    program (*F9*) till it reaches the breakpoint. When it reaches the breakpoint
    (before calling `CreateFileW`), all of the parameters to the function will be
    pushed onto the stack, so we can examine the first parameter on the stack to determine
    the name of the file. After the call to `CreateFileW`, the handle to the file
    will be returned in the `eax` register, which is copied into the `esi` register
    at ➋:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用IDA调试恶意二进制文件。考虑一个32位恶意软件样本的反汇编列表。恶意软件调用`CreateFileW`API创建文件，但仅从反汇编列表中并不清楚恶意软件创建了哪个文件。通过查看`CreateFile`的MSDN文档，你可以了解到`CreateFile`的第一个参数将包含文件名；此外，`CreateFile`中的`W`后缀表示文件名是一个UNICODE字符串（有关该API的详细信息，请参阅前一章）。为了确定文件名，我们可以在调用`CreateFileW`的位置设置一个断点，然后运行程序（*F9*）直到程序达到断点。当程序达到断点时（即在调用`CreateFileW`之前），所有函数的参数将被推送到栈上，因此我们可以检查栈中的第一个参数来确定文件名。在调用`CreateFileW`之后，文件的句柄将通过`eax`寄存器返回，并在➋处被复制到`esi`寄存器中：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following screenshot, the execution is paused at the call to the `CreateFileW` (as
    a result of setting the breakpoint and running the program). The first parameter
    to the function is the address (`0x003F538`) of the UNICODE string (`filename`).
    You can use the Hex-View window in IDA to inspect the contents of any valid memory
    location. Dumping the contents of the first argument, by right-clicking on the
    address `0x003F538` and choosing the Follow in hex dump option, displays the filename
    in the Hex-View window, shown as follows. In this case, the malware is creating
    a file, `SHAMple.dat`, in the `C:\Users\test\AppData\Local\Temp` directory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，执行在调用`CreateFileW`时已暂停（这是通过设置断点并运行程序实现的）。函数的第一个参数是UNICODE字符串（`filename`）的地址（`0x003F538`）。你可以使用IDA中的十六进制视图窗口来检查任何有效内存位置的内容。通过右键点击地址`0x003F538`并选择“Follow
    in hex dump”选项，可以显示文件名的十六进制内容，如下所示。在此情况下，恶意软件正在`C:\Users\test\AppData\Local\Temp`目录中创建一个文件`SHAMple.dat`：
- en: '![](../images/00159.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00159.jpeg)'
- en: 'The malware, after creating the file, passes the file handle as the first argument
    to the `WriteFile` function. This indicates that the malware writes some content
    to the file `SHAmple.dat`. To determine what content it writes to the file, you
    can inspect the second argument to the `WriteFile` function. In this case, it
    is writing the string `FunFunFun` to the file, as shown in the following screenshot.
    If the malware is writing executable content to the file, you will also be able
    to see it using this method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件在创建文件后，将文件句柄作为第一个参数传递给`WriteFile`函数。这表明恶意软件将某些内容写入文件`SHAmple.dat`。要确定它写入文件的内容，可以检查`WriteFile`函数的第二个参数。在这种情况下，它将字符串`FunFunFun`写入文件，如下图所示。如果恶意软件正在将可执行内容写入文件，你也可以通过这种方法查看：
- en: '![](../images/00160.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00160.jpeg)'
- en: 3.7 Debugging a Malicious DLL Using IDA
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 使用IDA调试恶意DLL
- en: In [Chapter 3](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485), *Dynamic
    Analysis*, you learned the techniques to execute a DLL to perform dynamic analysis.
    In this section, you will use some of the concepts that you learned in [Chapter
    3](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485), *Dynamic Analysis*, to
    debug a DLL using IDA. If you not familiar with dynamic analysis of a DLL, it
    is highly recommended to read *S**ection 6*, *Dynamic-Link Library (DLL) Analysis,* from
    [Chapter 3](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522),
    *Dynamic Analysis,* before proceeding further.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485)，*动态分析*中，你学习了执行DLL进行动态分析的技巧。在本节中，你将使用在[第3章](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485)，*动态分析*中学到的一些概念，通过IDA调试DLL。如果你不熟悉DLL的动态分析，强烈建议在继续之前阅读[第3章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522)，*动态分析*中的*S**ection
    6*，*动态链接库（DLL）分析*。
- en: 'To debug a DLL using the IDA debugger, you first need to designate the executable
    (such as `rundll32.exe`) that will be used to load the DLL. To debug a DLL, first,
    load the DLL into IDA, which will likely display the disassembly of the `DLLMain` function.
    Set a breakpoint (*F2*) at the first instruction in the `DLLMain` function, as
    shown in the following screenshot. This ensures that when you run the DLL, the
    execution will pause at the first instruction in the `DLLMain` function. You can
    also set breakpoints on any function exported by the DLL by navigating to it from
    IDA''s Exports window:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用IDA调试器调试DLL，首先需要指定将用于加载DLL的可执行文件（如`rundll32.exe`）。要调试DLL，首先将DLL加载到IDA中，IDA可能会显示`DLLMain`函数的反汇编代码。在`DLLMain`函数的第一条指令上设置断点（*F2*），如以下截图所示。这样，当你运行DLL时，执行将会在`DLLMain`函数的第一条指令处暂停。你也可以通过IDA的导出窗口，导航到DLL导出的任何函数上并设置断点。
- en: '![](../images/00161.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00161.jpeg)'
- en: 'After you have set the breakpoint on the desired address (where you want the
    execution to pause), select the debugger via Debugger | Select debugger | Local
    Win32 debugger (or **Debugger** | **Select debugger** | **Local Windows debugger**)
    and click on OK. Next, select Debugger | Process options, which will bring up
    the dialog shown in the following screenshot. In the Application field, enter
    the full path to the executable that is used to load the DLL (`rundll32.exe`).
    In the Input file field, enter the full path to the DLL that you wish to debug,
    and in the Parameters field, enter the command-line arguments to pass to `rundll32.exe`, and
    click on OK. Now, you can run the program to reach the breakpoint, after which
    you can debug it, as you would debug any other program. The arguments that you
    pass to `rundll32.exe` should have the correct syntax to successfully debug the
    DLL (refer to the *Working of rundll32.exe *section in [Chapter 3](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485),
    *Dynamic Analysis*). A point to note is that `rundll32.exe` can also be used to
    execute a 64-bit DLL, in the same manner:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在你设置了期望的地址断点（即你希望程序暂停执行的地方）之后，通过选择调试器菜单 Debugger | Select debugger | Local Win32
    debugger（或者**Debugger** | **Select debugger** | **Local Windows debugger**）并点击OK，来选择调试器。接下来，选择 Debugger
    | Process options，打开如下截图所示的对话框。在 Application 字段中，输入用于加载DLL的可执行文件的完整路径（`rundll32.exe`）。在 Input
    file 字段中，输入你想要调试的DLL的完整路径，在 Parameters 字段中，输入传递给`rundll32.exe`的命令行参数，然后点击OK。现在，你可以运行程序，直到程序到达断点，之后你可以像调试任何其他程序一样调试它。你传递给`rundll32.exe`的参数应该具有正确的语法，以成功调试DLL（参考[第3章](part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485)，*动态分析*中的*Working
    of rundll32.exe*部分）。需要注意的一点是，`rundll32.exe`同样可以用来执行64位DLL，方法相同：
- en: '![](../images/00162.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00162.jpeg)'
- en: 3.7.1 Debugging a DLL in a Specific Process
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7.1 在特定进程中调试DLL
- en: 'In *[Chapter 3](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522), Dynamic
    Analysis*, you learned how some DLLs can perform process checks to determine whether
    they are running under a particular process, such as `explorer.exe` or `iexplore.exe`.
    In that case, you may want to debug a DLL inside a specific host process, rather
    than`rundll32.exe`. To pause the execution at the DLL''s entry point, you can
    either *start* a new instance of the host process or *attach* to the desired host
    process using the debugger, and then select Debugger | Debugger options and check
    the option Suspend on library load/unload. This option will tell the debugger
    to pause whenever a new module is *loaded* or *unloaded*. After these settings,
    you can resume the paused host process and let it run by pressing the *F9* hotkey. You
    can now inject the DLL into the debugged host process with a tool like *RemoteDLL*. When
    the DLL is loaded by the host process, the debugger will pause, giving you a chance
    to set breakpoints in the address of the loaded module. You can get an idea of
    where the DLL has loaded into the memory by looking at the Segments window, as
    shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *[第3章](https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&action=edit#post_522)，动态分析*
    中，您学到了如何通过一些 DLL 执行进程检查，以判断它们是否在特定进程下运行，比如 `explorer.exe` 或 `iexplore.exe`。在这种情况下，您可能希望在特定的宿主进程内调试
    DLL，而不是 `rundll32.exe`。为了在 DLL 的入口点暂停执行，您可以选择 *启动* 一个新的宿主进程实例，或使用调试器 *附加* 到目标宿主进程，然后选择
    调试器 | 调试器选项，并勾选“在库加载/卸载时暂停”选项。该选项会告诉调试器每当加载或卸载一个新模块时暂停执行。在进行这些设置后，您可以通过按 *F9*
    快捷键恢复暂停的宿主进程并让它继续运行。现在，您可以使用像 *RemoteDLL* 这样的工具将 DLL 注入到调试的宿主进程中。当 DLL 被宿主进程加载时，调试器会暂停，给您一个机会在加载模块的地址设置断点。您可以通过查看“段”窗口来了解
    DLL 已经加载到内存的地址，如下所示：
- en: '![](../images/00163.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00163.jpeg)'
- en: In the preceding screenshot, you can see that the injected DLL (`rasaut.dll`) has
    loaded into the memory at the address `0x10000000` (the base address). You can
    set a breakpoint at the address of the entry point by adding the base address (`0x10000000`) with
    the value of the `AddressOfEntryPoint` field in the `PE header`. You can determine
    the value of the address of the entry point by loading the DLL into a tool such
    as *pestudio* or *CFFexplorer*. For example, if the `AddressOfEntryPoint` value
    is `0x1BFB`, the DLL entry point can be determined by adding the base address (`0x10000000`) with
    the value `0x1BFB`, which results in `0x10001BFB`. You can now navigate to the
    address `0x10001BFB` (or jump to the address by pressing the *G* key) and set
    a breakpoint at this address, and then resume the paused process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到被注入的 DLL (`rasaut.dll`) 已加载到内存中的地址 `0x10000000`（基址）。您可以通过将基地址（`0x10000000`）与
    `PE 头` 中的 `AddressOfEntryPoint` 字段的值相加来在入口点的地址设置断点。您可以通过将 DLL 加载到如 *pestudio*
    或 *CFFexplorer* 等工具中来确定入口点的地址值。例如，如果 `AddressOfEntryPoint` 的值为 `0x1BFB`，那么 DLL
    的入口点地址可以通过将基地址（`0x10000000`）与值 `0x1BFB` 相加得到，结果是 `0x10001BFB`。现在，您可以跳转到地址 `0x10001BFB`（或者按
    *G* 键跳转到该地址），并在该地址设置断点，然后恢复暂停的进程。
- en: 3.8 Tracing Execution Using IDA
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 使用 IDA 跟踪执行
- en: '*Tracing* allows you to record (log) specific events while a process is executing.
    It can provide detailed execution information on a binary. IDA supports three
    types of tracing:* instruction tracing*, *function tracing,* and *b**asic block
    tracing*. To enable tracing in IDA, you need to set a breakpoint, then right-click
    on the breakpoint address and choose Edit breakpoint, which will bring up a breakpoint
    settings dialog. In the dialog, check the Enable tracing option, and choose the
    appropriate Tracing type. Then, select the debugger via the **Debugger** | **Select
    debugger** menu (as covered previously), and Run (*F9*) the program. The location
    field in the following screenshot specifies the breakpoint being edited, and it
    will be used as the starting address to perform tracing. The tracing will continue
    until it reaches a breakpoint, or until it reaches the end of the program. To
    indicate which instructions were traced, IDA highlights the instructions by color-coding
    them. After tracing, you can view the results of the trace by selecting Debugger
    | Tracing | Trace window. You can control the tracing options via Debugger | Tracing
    | Tracing options:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪* 允许你在进程执行时记录（日志）特定的事件。它可以提供二进制文件的详细执行信息。IDA 支持三种类型的跟踪：*指令跟踪*、*函数跟踪*和 *基本块跟踪*。要在
    IDA 中启用跟踪，你需要设置一个断点，然后右键点击断点地址并选择“编辑断点”，这会弹出一个断点设置对话框。在对话框中，勾选“启用跟踪”选项，并选择合适的跟踪类型。然后，通过
    **调试器** | **选择调试器** 菜单（如前所述）选择调试器，并运行（*F9*）程序。以下截图中的位置字段指定了正在编辑的断点，它将作为起始地址执行跟踪。跟踪会一直持续，直到达到一个断点或程序结束。为了指示哪些指令已被跟踪，IDA
    通过颜色编码高亮显示指令。跟踪完成后，你可以通过选择 **调试器** | **跟踪** | **跟踪窗口** 来查看跟踪结果。你可以通过 **调试器** |
    **跟踪** | **跟踪选项** 控制跟踪选项：'
- en: '![](../images/00164.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00164.jpeg)'
- en: '***Instruction tracing*** records the execution of each instruction and displays
    the modified register values. Instruction tracing is slower, because the debugger
    internally *single-steps* through the process, to monitor and log all of the register
    values. *Instruction tracing* is useful for determining the execution flow of
    the program, and to know which registers were modified during the execution of
    each instruction. You can control the tracing by adding breakpoints.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '***指令跟踪*** 记录每条指令的执行并显示修改后的寄存器值。指令跟踪较慢，因为调试器会通过单步执行（*single-step*）进程来监控和记录所有寄存器的值。*指令跟踪*
    对于确定程序的执行流非常有用，并可以了解在执行每条指令期间哪些寄存器被修改。你可以通过添加断点来控制跟踪。'
- en: 'Consider the program in the following screenshot. Let''s assume that you want
    to trace the first four instructions (which also includes a function call, in
    the third instruction). To do that, first, set a breakpoint at the first instruction
    and another breakpoint at the fifth instruction, as shown in the following screenshot.
    Then, edit the first breakpoint (at the address `0x00401010`) and enable instruction
    tracing. Now, when you start debugging, the debugger traces the first four instructions
    (including the instructions inside the function) and pauses at the fifth instruction.
    If you don''t specify the second breakpoint, it will trace all of the instructions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下截图中的程序。假设你想跟踪前四条指令（其中第三条指令包含一个函数调用）。为此，首先，在第一条指令处设置一个断点，在第五条指令处设置另一个断点，如下图所示。然后，编辑第一个断点（地址为
    `0x00401010`），并启用指令跟踪。现在，当你开始调试时，调试器会跟踪前四条指令（包括函数内的指令），并在第五条指令处暂停。如果没有指定第二个断点，调试器将跟踪所有指令：
- en: '![](../images/00165.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00165.jpeg)'
- en: 'The following screenshot shows the *instruction tracing* events in the trace
    window, when the debugger paused at the fifth instruction. Note how the execution
    flows from `main` to `sub_E41000`, and then back to `main`. If you wish to trace
    the rest of the instructions, you can do that by resuming the paused process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在调试器暂停于第五条指令时，*指令跟踪* 事件在跟踪窗口中的表现。注意执行流是如何从 `main` 流向 `sub_E41000`，然后又返回到
    `main`。如果你希望跟踪剩余的指令，可以通过恢复暂停的进程来实现：
- en: '![](../images/00166.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00166.jpeg)'
- en: '**Function Tracing**: This records all of the function calls and the return,
    no register values are logged for function trace events. *Function tracing* is useful for determining
    which *functions* and *sub-functions* are called by the program. You can perform
    function tracing by setting the Tracing type to Functions and following the same
    procedure as in *instruction tracing*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数跟踪**：这会记录所有的函数调用和返回，但不会记录函数跟踪事件中的寄存器值。*函数跟踪*对于确定程序调用了哪些*函数*和*子函数*非常有用。你可以通过将跟踪类型设置为函数，并按照与*指令跟踪*相同的步骤进行函数跟踪。'
- en: 'In the following example, the malware sample calls two functions. Let''s suppose
    that we want to get a quick overview of what other functions are called by the
    first function call. To do that, we can set the first breakpoint at the *first
    instruction* and enable function tracing (by editing the breakpoint), and then
    we can set another breakpoint at the *second instruction*. The second breakpoint
    will act as the stop point (tracing will be performed until the second breakpoint
    is reached). The following screenshot shows both of the breakpoints:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，恶意软件样本调用了两个函数。假设我们想快速了解第一个函数调用时调用了哪些其他函数。为了做到这一点，我们可以在*第一条指令*处设置第一个断点，并启用函数跟踪（通过编辑断点），然后可以在*第二条指令*处设置另一个断点。第二个断点将作为停止点（跟踪将一直进行到达第二个断点）。以下截图展示了这两个断点：
- en: '![](../images/00167.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00167.jpeg)'
- en: 'The following screenshot shows the results of function tracing. From the traced
    events, you can see that the function `sub_4014A0` calls registry-related API
    functions; this tells you that the function is responsible for performing registry
    operations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了函数跟踪的结果。从跟踪的事件中，你可以看到函数`sub_4014A0`调用了与注册表相关的 API 函数；这表明该函数负责执行注册表操作：
- en: '![](../images/00168.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00168.jpeg)'
- en: Sometimes, your tracing may take a long time and seem to never end; this happens
    if the function is not returning to its caller and is running in a loop, waiting
    for an event to occur. In such a case, you will still be able to see the trace
    logs in the trace window.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的跟踪可能需要很长时间，并且似乎永远不会结束；如果函数没有返回到其调用者并且在等待事件发生的循环中运行，就会发生这种情况。在这种情况下，你仍然可以在跟踪窗口中看到跟踪日志。
- en: '**Block Tracing**: IDA allows you to perform *block tracing*, which is useful
    for knowing which blocks of code were executed during runtime. You can enable
    block tracing by setting the Tracing type to Basic blocks. In the case of block
    tracing, the debugger sets the breakpoint at the *last instructio*n of each basic
    block of every function, and it also sets breakpoints at any call instructions
    in the middle of the traced blocks. *Basic block tracing* is slower than normal
    execution, but faster than *instruction* or *function tracing*.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**块跟踪**：IDA 允许你进行*块跟踪*，这对于了解在运行时哪些代码块被执行非常有用。你可以通过将跟踪类型设置为基本块来启用块跟踪。在块跟踪的情况下，调试器将在每个函数的每个基本块的*最后一条指令*处设置断点，并且还会在跟踪块中间的任何调用指令处设置断点。*基本块跟踪*比正常执行慢，但比*指令*或*函数跟踪*要快。'
- en: 3.9 Debugger Scripting Using IDAPython
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 使用 IDAPython 的调试器脚本
- en: You can use debugger scripting to automate routine tasks related to malware
    analysis. In the previous chapter, we looked at examples of using IDAPython for
    static code analysis. In this section, you will learn how to use IDAPython to
    perform debugging-related tasks. The IDAPython scripts demonstrated in this section
    make use of the new IDAPython API, meaning that if you are using older versions
    of IDA (lower than IDA 7.0), these scripts will not work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用调试器脚本来自动化与恶意软件分析相关的常规任务。在上一章中，我们介绍了如何使用 IDAPython 进行静态代码分析。在本节中，你将学习如何使用
    IDAPython 执行与调试相关的任务。本节中展示的 IDAPython 脚本使用了新的 IDAPython API，这意味着如果你使用的是旧版本的 IDA（低于
    IDA 7.0），这些脚本将无法工作。
- en: 'The following resources should help you get started with IDAPython debugger
    scripting. Most of these resources (except the IDAPython documentation) demonstrate
    scripting capabilities using the old IDAPython API, but they should be good enough
    for you to get the idea. Anytime you get stuck, you can refer to IDAPython documentation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源应帮助你开始使用 IDAPython 调试器脚本。这些资源中的大部分（除了 IDAPython 文档）使用旧版 IDAPython API 演示脚本功能，但它们足够帮助你理解。如果你遇到困难，可以参考
    IDAPython 文档：
- en: '**IDAPython API Documentation**: [https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html](https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDAPython API 文档**：[https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html](https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html)'
- en: '**Magic Lantern Wiki**: [http://magiclantern.wikia.com/wiki/IDAPython](http://magiclantern.wikia.com/wiki/IDAPython)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔灯 Wiki**：[http://magiclantern.wikia.com/wiki/IDAPython](http://magiclantern.wikia.com/wiki/IDAPython)'
- en: '**IDA Scriptable Debugger**: [https://www.hex-rays.com/products/ida/debugger/scriptable.shtml](https://www.hex-rays.com/products/ida/debugger/scriptable.shtml)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDA 可脚本化调试器**：[https://www.hex-rays.com/products/ida/debugger/scriptable.shtml](https://www.hex-rays.com/products/ida/debugger/scriptable.shtml)'
- en: '**Using IDAPython to Make Your Life Easier (Series)**: [https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/](https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 IDAPython 让你的生活更轻松（系列）**：[https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/](https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/)'
- en: This section will give you a feel for how to use IDAPython for debugging-related
    tasks. First, load the executable in IDA, and select the debugger (via Debugger
    | Select debugger). For testing the following script commands, Local Windows debugger
    was chosen. After the executable has loaded, you can execute the Python code snippets
    mentioned in the following in IDA's Python shell, or by selecting File | Script
    Command (*Shift* + *F2*) and choosing the Scripting language as Python (from the
    drop-down menu). If you wish to run it as a standalone script, you may have to
    import the appropriate modules (for example, `import idc`).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助你了解如何使用 IDAPython 进行调试相关任务。首先，在 IDA 中加载可执行文件，并选择调试器（通过 Debugger | Select
    debugger）。在测试以下脚本命令时，选择了本地 Windows 调试器。可执行文件加载后，你可以在 IDA 的 Python 控制台中执行以下提到的
    Python 代码片段，或者通过选择 File | Script Command (*Shift* + *F2*) 并从下拉菜单中选择 Python 作为脚本语言。如果你希望将其作为独立脚本运行，你可能需要导入适当的模块（例如，`import
    idc`）。
- en: 'The following code snippet sets a breakpoint at the current cursor location,
    starts the debugger, waits for the `suspend debugger` event to occur, and then
    prints the *address* and the *disassembly text* associated with the breakpoint
    address:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段在当前光标位置设置一个断点，启动调试器，等待 `suspend debugger` 事件发生，然后打印与断点地址相关的 *地址* 和 *反汇编文本*：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the output generated as a result of executing the preceding
    script commands:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述脚本命令后，生成的输出如下：
- en: '[PRE6]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following code snippet *steps into* the next instruction and prints the
    *address* and the *disassembly text*. In the same manner, you can use `idc.step_over()` to
    *step over* the instruction:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段 *单步进入* 下一条指令，并打印 *地址* 和 *反汇编文本*。同样，你可以使用 `idc.step_over()` 来 *单步跳过* 指令：
- en: '[PRE7]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The results of executing the preceding script commands are shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述脚本命令后的结果如下所示：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To get the value of a register,  you can use `idc.get_reg_value()`. The following
    example gets the value of the `esp` register and prints it in the *output window:*
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取寄存器的值，你可以使用 `idc.get_reg_value()`。以下示例获取 `esp` 寄存器的值，并在 *输出窗口* 中打印它：
- en: '[PRE9]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To get the `dword` value at the address `0x14fb04`, use the following code.
    In the same manner, you can use `idc.read_dbg_byte(ea)`, `idc.read_dbg_word(ea)`,
    and `idc.read_dbg_qword(ea)` to get the `byte`, `word`, and `qword` values at
    a particular address:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取地址 `0x14fb04` 处的 `dword` 值，可以使用以下代码。同样，你可以使用 `idc.read_dbg_byte(ea)`、`idc.read_dbg_word(ea)`
    和 `idc.read_dbg_qword(ea)` 来获取特定地址处的 `byte`、`word` 和 `qword` 值：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get an ASCII string at the address `0x01373000`, use the following. By default,
    the `idc.get_strlit_contents()` function gets the ASCII string at a given address:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取地址 `0x01373000` 处的 ASCII 字符串，可以使用以下方法。默认情况下，`idc.get_strlit_contents()` 函数会获取给定地址处的
    ASCII 字符串：
- en: '[PRE11]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To get the UNICODE string, you can use the `idc.get_strlit_contents()` function
    by setting its `strtype` argument to a constant value, `idc.STRTYPE_C_16`, as
    follows. You can find the defined constant values in the `idc.idc` file, which
    is located in your IDA installation directory:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 UNICODE 字符串，你可以通过设置 `strtype` 参数为常量值 `idc.STRTYPE_C_16`，使用 `idc.get_strlit_contents()`
    函数，如下所示。你可以在 `idc.idc` 文件中找到已定义的常量值，文件位于你的 IDA 安装目录：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code lists all of the loaded modules (executables and DLLs) and
    their base addresses:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列出所有加载的模块（可执行文件和 DLL）及其基地址：
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of executing the preceding script commands is shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面脚本命令的结果如下所示：
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To get the address of the `CreateFileA` function in `kernel32.dll`, use the
    following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`CreateFileA`函数在`kernel32.dll`中的地址，请使用以下代码：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To resume a suspended process, you can use the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复暂停的进程，可以使用以下代码：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.9.1 Example – Determining Files Accessed by Malware
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9.1 示例 – 确定恶意软件访问的文件
- en: In the previous chapter, while discussing IDAPython, we wrote an IDAPython script
    to determine all of the cross-references to the `CreateFileA` function (the address
    where `CreateFileA` was called). In this section, let's enhance that script to
    perform debugging tasks and determine the name of the file created (or opened)
    by the malware.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了IDAPython，并编写了一个IDAPython脚本来确定所有指向`CreateFileA`函数的交叉引用（即`CreateFileA`被调用的地址）。在本节中，让我们增强该脚本，执行调试任务并确定恶意软件创建（或打开）的文件名。
- en: 'The following script sets a breakpoint on all of the addresses where `CreateFileA` is
    called within the program, and runs the malware. Before running the following
    script, the appropriate debugger is selected (Debugger | Select debugger | Local
    Windows debugger). When this script is executed, it pauses at each breakpoint
    (in other words, before calls to `CreateFileA`), and it prints the first parameter
    (`lpFileName`), the second parameter `(dwDesiredAccess)`, and    the fifth parameter `(dwCreationDisposition)`.
    These parameters will give us the name of the file, a constant value that represents
    the operation performed on the file (such as *read*/*write*), and another constant
    value, indicating the action that will be performed (such as *create* or *open*).
    When the breakpoint is triggered, the first parameter can be accessed at `[esp]`, the
    second parameter at `[esp+0x4]`, and the fifth parameter at `[esp+0x10]`. In addition
    to printing some of the parameters, the script also determines the `handle` to
    the file (*return value*) by retrieving the value of the `EAX` register after
    *stepping over* the `CreateFile` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本会在程序中调用`CreateFileA`的所有地址处设置断点，并运行恶意软件。在运行以下脚本之前，选择适当的调试器（调试器 | 选择调试器 |
    本地Windows调试器）。当此脚本执行时，它将在每个断点暂停（也就是说，在调用`CreateFileA`之前），并打印第一个参数（`lpFileName`）、第二个参数（`dwDesiredAccess`）和第五个参数（`dwCreationDisposition`）。这些参数将告诉我们文件名、表示对文件执行操作的常量值（如*读取*/*写入*），以及表示将执行的操作的另一个常量值（如*创建*或*打开*）。当断点被触发时，第一个参数可以通过`[esp]`访问，第二个参数通过`[esp+0x4]`访问，第五个参数通过`[esp+0x10]`访问。除了打印一些参数外，脚本还通过获取`EAX`寄存器的值来确定文件的`handle`（*返回值*），该值是在*步进过*`CreateFile`函数后获得的：
- en: '[PRE17]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the result of executing the preceding script. The `DesiredAccess`
    values, `0x40000000` and `0x80000000`, represent the `GENERIC_WRITE` and `GENERIC_READ` operations,
    respectively. The `createDisposition` values, `0x2` and `0x3`, signify `CREATE_ALWAYS` (create
    a new file always) and `OPEN_EXISTING` (open a file, only if it exists), respectively.
    As you can see, by using debugger scripting, it was possible to quickly determine
    the filenames created/accessed by malware:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行前面脚本的结果。`DesiredAccess`值`0x40000000`和`0x80000000`分别表示`GENERIC_WRITE`和`GENERIC_READ`操作。`createDisposition`值`0x2`和`0x3`分别表示`CREATE_ALWAYS`（始终创建一个新文件）和`OPEN_EXISTING`（仅在文件存在时打开文件）。如您所见，通过使用调试器脚本，可以快速确定恶意软件创建/访问的文件名：
- en: '[PRE18]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 4\. Debugging a .NET Application
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 调试.NET应用程序
- en: 'When performing malware analysis, you will have to deal with analyzing a wide
    variety of code. You are likely to encounter malware created using *Microsoft
    Visual C/C++*, *Delphi*, and the *.NET framework*. In this section, we will take
    a brief look at a tool called *dnSpy* ([https://github.com/0xd4d/dnSpy](https://github.com/0xd4d/dnSpy)),
    which makes analyzing .NET binaries much easier. It is quite effective when it
    comes to decompiling and debugging a .*NET application*. To load a .NET application,
    you can drag and drop the application into *dnSpy,* or launch *dnSpy* and select
    File | Open, giving it the path to the binary. Once the .NET application has loaded,
    dnSpy decompiles the application, and you can access the program''s methods and
    classes in the left-hand window, named Assembly explorer. The following screenshot
    shows the `main` function of the decompiled .NET malicious binary (named `SQLite.exe`):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行恶意软件分析时，您将需要分析各种不同的代码。您很可能会遇到使用*Microsoft Visual C/C++*、*Delphi*和*.NET框架*创建的恶意软件。在本节中，我们将简要介绍一个名为*dnSpy*的工具（[https://github.com/0xd4d/dnSpy](https://github.com/0xd4d/dnSpy)），它使得分析
    .NET 二进制文件变得更加简单。它在反编译和调试.*NET应用程序*方面非常有效。要加载 .NET 应用程序，您可以将应用程序拖放到*dnSpy*中，或者启动*dnSpy*并选择“文件
    | 打开”，然后提供二进制文件的路径。一旦 .NET 应用程序加载完成，dnSpy 将反编译该应用程序，您可以在左侧窗口（名为“程序集浏览器”）中访问程序的各个方法和类。以下截图显示了反编译后的
    .NET 恶意二进制文件（名为`SQLite.exe`）的`main`函数：
- en: '![](../images/00169.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00169.jpeg)'
- en: 'Once the binary has decompiled, you can either read the code (*static code
    analysis*) to determine the malware''s functionality, or debug the code and perform
    *dynamic code analysis*. To debug the malware, you can either click on the Start
    button on the toolbar, or choose Debug | Debug an Assembly (*F5*); this will pop
    up the dialog shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦二进制文件被反编译，您可以通过阅读代码（*静态代码分析*）来确定恶意软件的功能，或者通过调试代码进行*动态代码分析*。要调试恶意软件，您可以点击工具栏上的“开始”按钮，或者选择“调试
    | 调试程序集”(*F5*)；这将弹出如下所示的对话框：
- en: '![](../images/00170.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00170.jpeg)'
- en: 'Using the Break at drop-down option, you can specify where to *break* when
    the debugger starts. Once you are satisfied with the options, you can click on OK, which
    will start the process under debugger control and pause the debugger at the entry
    point. Now, you can access various debugger options (such as Step Over, Step into,
    Continue, and so on) via the Debug menu, shown in the following screenshot. You
    can also set a breakpoint by double-clicking on a line, or by choosing **Debug
    | Toggle Breakpoint** (*F9*). While you are debugging, you can make use of the
    Locals window to examine some of the local variables or memory locations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“Break at drop-down”选项，您可以指定在调试器启动时*断点*的位置。设置好选项后，您可以点击“确定”按钮，这将启动调试过程并在入口点暂停调试器。现在，您可以通过“调试”菜单访问各种调试器选项（如“步过”、“步入”、“继续”等），如以下截图所示。您还可以通过双击某行或选择**调试
    | 切换断点**（*F9*）来设置断点。在调试过程中，您可以使用本地窗口检查一些局部变量或内存位置：
- en: '![](../images/00171.jpeg)To get an idea of .NET binary analysis, and for a
    detailed analysis of the previously mentioned binary (named `SQLite.exe`), you
    can read the author''s blog post at [https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/](https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00171.jpeg)要了解 .NET 二进制分析，并对前面提到的二进制文件（名为`SQLite.exe`）进行详细分析，您可以阅读作者的博客文章：[https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/](https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/)。'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The debugging techniques covered in this chapter are effective methods for understanding
    the inner workings of a malicious binary. The debugging features provided by code
    analysis tools such as IDA, x64dbg, and dnSpy can greatly enhance your reverse
    engineering process. During malware analysis, you will often combine both disassembly
    and debugging techniques to determine malware functionalities and obtain valuable
    information from a malicious binary.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的调试技术是理解恶意二进制文件内部工作原理的有效方法。像IDA、x64dbg和dnSpy等代码分析工具提供的调试功能，可以大大增强您的逆向工程过程。在恶意软件分析中，您通常会结合反汇编和调试技术来确定恶意软件的功能，并从恶意二进制文件中获取有价值的信息。
- en: In the next chapter, we will use the skills that we have learned so far to understand
    various malware characteristics and functionalities.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将运用到目前为止学到的技能，理解各种恶意软件的特征和功能。
