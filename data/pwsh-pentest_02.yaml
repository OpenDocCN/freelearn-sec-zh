- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Programming Principles in PowerShell
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell中的编程原则
- en: 'In the world of **penetration testing**, information is the lifeblood of success.
    The ability to extract, manipulate, and make sense of data from various sources
    can mean the difference between a security breach and a secure system. In this
    pivotal chapter, we delve into the potent capabilities of **PowerShell**, Microsoft’s
    versatile command-line shell and scripting language, and its profound relevance
    to penetration testing, particularly its prowess in dealing with **JavaScript
    Object Notation** (**JSON**) and **Extensible Markup Language** (**XML**) data
    formats. In this chapter, we will discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在**渗透测试**的世界里，信息是成功的命脉。从各种来源提取、处理和理解数据的能力，可能意味着安全漏洞和安全系统之间的区别。在这一关键章节中，我们将深入探讨**PowerShell**的强大功能，它是微软的多用途命令行外壳和脚本语言，以及它与渗透测试的深刻关联，特别是在处理**JavaScript对象表示法**（**JSON**）和**可扩展标记语言**（**XML**）数据格式方面的卓越能力。在本章中，我们将讨论以下内容：
- en: PowerShell’s versatility in penetration testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell在渗透测试中的多功能性
- en: Navigating JSON and XML with PowerShell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerShell浏览JSON和XML
- en: Automation, integration, and reporting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化、集成和报告
- en: PowerShell has earned its place as a cornerstone tool for penetration testers
    due to its adaptability and efficiency. Its extensive support for JSON and XML
    is of paramount importance in this context. These data formats are ubiquitous,
    often containing vital information within systems, applications, or web services
    that require thorough analysis during penetration testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其适应性和高效性，PowerShell已经成为渗透测试人员的重要工具。它对JSON和XML的广泛支持在此背景下尤为重要。这些数据格式无处不在，通常包含系统、应用程序或Web服务中需要在渗透测试中进行深入分析的重要信息。
- en: Within this chapter, we will embark on a journey to explore how PowerShell’s
    rich set of **cmdlets** and functionalities empower testers to navigate, parse,
    and manipulate JSON and XML data seamlessly. We will uncover how PowerShell serves
    as the bridge between raw data and actionable insights. From extracting sensitive
    information buried within JSON responses to dissecting XML configurations, you’ll
    gain a comprehensive understanding of how to leverage these capabilities effectively.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探索如何通过PowerShell丰富的**cmdlets**和功能，帮助测试人员无缝地浏览、解析和处理JSON和XML数据。我们将揭示PowerShell如何充当原始数据和可操作洞察之间的桥梁。从提取JSON响应中埋藏的敏感信息到解剖XML配置文件，您将全面了解如何有效利用这些功能。
- en: As we progress, we’ll uncover the immense value PowerShell brings to the table
    through automation, integration, and streamlined reporting. We’ll discover how
    to automate routine tasks, integrate PowerShell with other penetration testing
    tools and frameworks, and create polished reports for stakeholders by processing
    JSON and XML data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入，我们将揭示PowerShell通过自动化、集成和简化报告所带来的巨大价值。我们将学习如何自动化常规任务，将PowerShell与其他渗透测试工具和框架集成，并通过处理JSON和XML数据创建精美的报告供利益相关者查看。
- en: In this chapter, we equip you with the knowledge and skills needed to wield
    PowerShell as a formidable weapon in your penetration testing arsenal. Get ready
    to harness the power of data with precision and finesse, uncovering vulnerabilities,
    and fortifying the security of your target systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供必要的知识和技能，使您能够将PowerShell作为渗透测试武器的一部分，发挥其强大作用。准备好以精准和巧妙的方式驾驭数据的力量，揭示漏洞并加固目标系统的安全性。
- en: 'The following are the topics that will be covered in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: Basic concepts of PowerShell and pipeline in PowerShell
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell的基本概念和管道
- en: JSON in PowerShell
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell中的JSON
- en: XML in PowerShell
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell中的XML
- en: '**Component Object Model** (**COM**), **Windows Management Instrumentation**
    (**WMI**), and .NET in PowerShell'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件对象模型**（**COM**）、**Windows管理工具**（**WMI**）和.NET在PowerShell中的应用'
- en: Basic concepts of PowerShell and pipelines in PowerShell
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell的基本概念和管道
- en: 'PowerShell is a versatile and powerful programming language designed to automate
    administrative tasks and streamline complex processes in the world of Windows
    environments. Originally released by Microsoft in 2006, PowerShell quickly gained
    popularity among IT professionals, system administrators, and developers for its
    extensive capabilities and ease of use. Often referred to as a **command-line
    shell** or **task automation framework**, PowerShell extends beyond traditional
    shells by combining a command-line interface with a scripting language. As a standard
    programming language, PowerShell supports the following constructs:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一种多功能且强大的编程语言，旨在自动化管理任务并简化 Windows 环境中复杂的流程。PowerShell 最初由微软于 2006
    年发布，迅速在 IT 专业人员、系统管理员和开发人员中获得了广泛的欢迎，因其强大的功能和易于使用的特点。PowerShell 常被称为 **命令行外壳**
    或 **任务自动化框架**，它通过将命令行界面与脚本语言结合，超越了传统的外壳功能。作为一种标准编程语言，PowerShell 支持以下结构：
- en: Sequence
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序
- en: Selection
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择
- en: Iteration
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代
- en: Encapsulation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: At its core, PowerShell is built on the .NET Framework, enabling seamless integration
    with Windows system components and third-party libraries. Its syntax and scripting
    capabilities borrow from popular languages such as C#, making it approachable
    for developers familiar with the Microsoft ecosystem. However, even those without
    extensive programming knowledge can harness PowerShell’s power thanks to its intuitive
    scripting model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，PowerShell 是建立在 .NET 框架之上的，这使得它能够与 Windows 系统组件和第三方库无缝集成。它的语法和脚本功能借鉴了
    C# 等流行语言，使得熟悉微软生态系统的开发人员能够轻松上手。然而，即使是没有广泛编程知识的人，也可以凭借 PowerShell 直观的脚本模型充分利用其强大功能。
- en: 'One of PowerShell’s standout features is its ability to manage objects and
    manipulate structured data easily. Unlike traditional shell scripting languages
    that primarily deal with text streams, PowerShell treats information as objects
    with properties and methods. This object-oriented approach simplifies data manipulation
    and enables complex operations with minimal code. PowerShell also boasts an extensive
    set of cmdlets, which are pre-built commands for performing a wide range of system
    management tasks. With a vast array of cmdlets available out of the box, users
    can execute tasks such as file management, process control, registry manipulation,
    and network configuration, all without needing to write custom code from scratch.
    Moreover, PowerShell is not limited to Windows systems alone. With the advent
    of **PowerShell Core** (also known as **PowerShell 7**), Microsoft extended support
    to macOS, Linux, and other platforms, making it a truly cross-platform solution.
    For this book, we will focus on PowerShell 7\. PowerShell 7 can be found at the
    following link: [https://github.com/PowerShell/PowerShell](https://github.com/PowerShell/PowerShell).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的一大亮点是其处理对象和操作结构化数据的能力。与传统的 shell 脚本语言主要处理文本流不同，PowerShell 将信息视为具有属性和方法的对象。这种面向对象的方法简化了数据操作，并能够用最少的代码完成复杂的操作。PowerShell
    还拥有一套丰富的 cmdlet，它们是用于执行各种系统管理任务的预构建命令。凭借丰富的 cmdlet 库，用户可以执行如文件管理、进程控制、注册表操作和网络配置等任务，无需从头编写自定义代码。此外，PowerShell
    不仅限于 Windows 系统。随着 **PowerShell Core**（也称为 **PowerShell 7**）的发布，微软扩展了对 macOS、Linux
    和其他平台的支持，使其成为一个真正的跨平台解决方案。本书将重点介绍 PowerShell 7。PowerShell 7 可通过以下链接访问：[https://github.com/PowerShell/PowerShell](https://github.com/PowerShell/PowerShell)。
- en: As automation becomes increasingly essential in modern IT environments, PowerShell
    stands out as a go-to solution for orchestrating and automating repetitive tasks,
    reducing human error, and saving valuable time. Its rich scripting capabilities,
    object-oriented approach, and vast collection of cmdlets make it an indispensable
    tool for managing and maintaining Windows-based systems effectively.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自动化在现代 IT 环境中的日益重要，PowerShell 成为了一种主流的解决方案，能够协调和自动化重复任务，减少人为错误并节省宝贵时间。它丰富的脚本功能、面向对象的方法以及大量的
    cmdlet 使其成为有效管理和维护基于 Windows 系统的重要工具。
- en: 'So, let us begin by identifying the version of PowerShell that we are running.
    We can achieve this by examining the **$PSVersionTable** local variable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从识别我们正在运行的 PowerShell 版本开始。我们可以通过检查 **$PSVersionTable** 本地变量来实现：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we know the version of PowerShell that is running on the target system,
    our next step is to understand the execution policy that the target implements
    for PowerShell scripts. To achieve this, we can execute the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了目标系统上运行的 PowerShell 版本，下一步是了解目标系统为 PowerShell 脚本实现的执行策略。为此，我们可以执行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'PowerShell is a scripting language. The ability to execute PowerShell scripts
    can be enabled or disabled on the local machine. To enable PowerShell, we can
    use the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一种脚本语言。执行 PowerShell 脚本的能力可以在本地计算机上启用或禁用。要启用 PowerShell，我们可以使用以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have created the ability to execute PowerShell scripts on the target
    system, we need to identify the modules that are available to us to download and
    install. To support software reuse, PowerShell makes use of **modules**. We can
    list all available modules using the **find-module** command, where can search
    for a module containing a keyword using the **tag** option as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在目标系统上创建了执行 PowerShell 脚本的能力，我们需要识别可供我们下载和安装的模块。为了支持软件复用，PowerShell 使用**模块**。我们可以使用**find-module**命令列出所有可用的模块，可以使用**tag**选项按关键字搜索模块，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have identified the module that we wish to install, we can download
    and install it using the **Install-Module** command. So, in the following, we
    will download and install the **SSH** module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们识别了想要安装的模块，我们可以使用**Install-Module**命令下载并安装它。因此，接下来我们将下载并安装**SSH**模块：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also import a PowerShell module directly. In the following, we will
    import the functions/cmdlets from the **PowerSploit.psd1** module. To install
    a PowerShell module, you must run the command in PowerShell with administrator/root-level
    privileges:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接导入一个 PowerShell 模块。接下来，我们将导入**PowerSploit.psd1**模块中的函数/命令。要安装 PowerShell
    模块，必须以管理员/root 权限在 PowerShell 中运行命令：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we can import a module, we can examine the functions/cmdlets that it supports
    via the **Get-Command** cmdlet. In the following, we will use the **Get-Command**
    cmdlet to identify the functions supported by the module SSH:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够导入模块，我们可以通过**Get-Command** cmdlet 检查它支持的函数/命令。接下来，我们将使用**Get-Command**
    cmdlet 来识别 SSH 模块支持的函数：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can identify how to use the PowerShell module by using the **get-help**
    command. In the following, we will identify how to use the **Get-Location** cmdlet/function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**get-help**命令来识别如何使用 PowerShell 模块。接下来，我们将识别如何使用**Get-Location** cmdlet/函数：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have learned how to install PowerShell and modules, let us look
    at the programming constructs associated with PowerShell. In PowerShell 7, variables
    and data types play a crucial role in storing and manipulating data. Variables
    act as containers to hold values, while data types define the nature and characteristics
    of the data being stored. Understanding how to work with variables and data types
    is fundamental for effective scripting and automation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何安装 PowerShell 和模块，让我们来看看与 PowerShell 相关的编程构造。在 PowerShell 7 中，变量和数据类型在存储和处理数据中起着至关重要的作用。变量充当容器来存储值，而数据类型则定义了所存储数据的性质和特征。理解如何使用变量和数据类型是有效编写脚本和自动化的基础。
- en: 'Variables in PowerShell are created by using the **$** symbol followed by the
    variable name. PowerShell is a dynamically typed language, meaning you don’t need
    to explicitly define the data type of a variable before using it. The data type
    is determined based on the value assigned to the variable. Some commonly used
    data types in PowerShell are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的变量通过使用**$**符号后跟变量名来创建。PowerShell 是一种动态类型语言，这意味着在使用变量之前，您不需要显式定义变量的数据类型。数据类型是基于分配给变量的值来确定的。PowerShell
    中一些常用的数据类型如下：
- en: '**Boolean**: This is used to define a binary state. A Boolean variable can
    either be true or false.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**：用于定义二进制状态。布尔变量可以是 true 或 false。'
- en: '**Strings**: This is used to store text or characters. They can be defined
    using single or double quotes:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：用于存储文本或字符。可以使用单引号或双引号定义：'
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Integers**: This is used to store whole numbers:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：用于存储整数：'
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Arrays**: This is used to store multiple values in a single variable:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：用于在单个变量中存储多个值：'
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Hash tables**: These are used to store key-value pairs:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希表**：用于存储键值对：'
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using variables and data types effectively in PowerShell 7 enables you to store,
    manipulate, and manage data efficiently in your scripts, making it a powerful
    tool for automation, system administration, and data processing tasks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 7 中有效使用变量和数据类型使你能够高效地存储、操作和管理数据，使它成为自动化、系统管理和数据处理任务的强大工具。
- en: 'In PowerShell, the **if** statement is a fundamental control structure that
    allows you to execute specific blocks of code based on certain conditions. It
    is commonly used to make decisions in scripts and automate tasks. The syntax for
    the **if** statement is straightforward:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，**if** 语句是一个基本的控制结构，它允许你根据特定条件执行特定的代码块。它通常用于脚本中的决策，并实现任务自动化。**if**
    语句的语法非常简单：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s explore some examples to illustrate how the **if** statement can be used
    in PowerShell. Suppose you want to check whether a file exists before performing
    further actions. The **Test-Path** cmdlet is frequently used in conjunction with
    the **if** statement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来说明如何在 PowerShell 中使用 **if** 语句。假设你想在执行进一步操作之前检查某个文件是否存在。**Test-Path**
    cmdlet 经常与 **if** 语句一起使用：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In PowerShell, loops and repeat structures are vital control flow constructs
    that allow you to execute a block of code repeatedly based on specified conditions.
    These loops are crucial for automating tasks that involve iterating through collections,
    processing data, and performing repetitive operations. PowerShell provides several
    loop constructs, such as **for**, **foreach**, **while**, **do...while**, and
    the pipeline loop, which we’ll explore with examples to understand how they can
    be effectively utilized:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，循环和重复结构是重要的控制流结构，它们允许你根据指定的条件重复执行一段代码。这些循环对于自动化涉及遍历集合、处理数据和执行重复操作的任务至关重要。PowerShell
    提供了几种循环结构，如 **for**、**foreach**、**while**、**do...while** 和管道循环，我们将通过示例来探索它们，了解如何有效地使用这些结构：
- en: '**for**: The **for** loop is used to execute a block of code a specific number
    of times, typically when you know the exact number of iterations required. It
    consists of an initialization, a condition, and an iteration statement:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**：**for** 循环用于执行一段代码特定次数，通常在你知道需要的迭代次数时使用。它由初始化、条件和迭代语句组成：'
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**foreach**: The **foreach** loop is used to iterate through items in a collection
    (arrays, lists, etc.) and perform an action for each item. It automatically iterates
    through each element in the collection:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**foreach**：**foreach** 循环用于遍历集合（数组、列表等）中的项，并对每个项执行一个操作。它会自动遍历集合中的每个元素：'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**while**: The **while** loop executes a block of code repeatedly as long as
    a condition remains true. It continuously evaluates the condition before each
    iteration:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while**：**while** 循环在条件为真时重复执行一段代码。它会在每次迭代前评估条件：'
- en: '[PRE16]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**do...While**: The **do...while** loop is like the **while** loop, but it
    has one key difference: it executes the code block first and then checks the condition.
    This ensures that the loop runs at least once:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**do...while**：**do...while** 循环与 **while** 循环相似，但有一个关键区别：它先执行代码块，然后再检查条件。这确保了循环至少执行一次：'
- en: '[PRE17]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**ForEach-Object** (Pipeline Loop): In addition to the foreach loop, PowerShell
    provides a pipeline-based loop using the **ForEach-Object** cmdlet. It allows
    you to process objects that are passed through the pipeline one by one:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ForEach-Object**（管道循环）：除了 foreach 循环外，PowerShell 还提供了一个基于管道的循环，使用 **ForEach-Object**
    cmdlet。它允许你逐个处理通过管道传递的对象：'
- en: '[PRE18]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: PowerShell provides a rich set of loop/repeat structures that allow you to automate
    repetitive tasks, process collections of data, and control the flow of your scripts
    effectively. Understanding and utilizing these constructs will make your PowerShell
    scripts more versatile and powerful. When using loops, be mindful of potential
    infinite loops, and always include break or continue statements where necessary
    to manage the flow of your code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 提供了一套丰富的循环/重复结构，允许你自动化重复任务、处理数据集合并有效地控制脚本的流程。理解并利用这些结构将使你的 PowerShell
    脚本更加多才多艺和强大。使用循环时，要注意潜在的无限循环，并在必要时始终包含 break 或 continue 语句，以管理代码的流程。
- en: JSON in PowerShell
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 中的 JSON
- en: Penetration testing is a critical activity that involves simulating real-world
    attacks to identify vulnerabilities and weaknesses in a system or network. PowerShell,
    a powerful scripting language native to the Windows environment, is a valuable
    tool for penetration testers due to its flexibility, extensive automation capabilities,
    and ability to interact with web services and APIs. In this section, we will explore
    how PowerShell can be used to handle JSON data as part of penetration testing.
    We will cover scenarios such as retrieving JSON data from web APIs, parsing JSON
    responses, extracting valuable information from JSON objects, and manipulating
    JSON payloads for testing purposes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试是一项重要活动，涉及模拟现实世界的攻击以识别系统或网络中的漏洞和弱点。PowerShell 是一种强大的脚本语言，原生支持 Windows 环境，对于渗透测试人员来说是一个宝贵的工具，因为它具有灵活性、广泛的自动化能力，并能够与
    Web 服务和 API 进行交互。在本节中，我们将探讨 PowerShell 如何在渗透测试中处理 JSON 数据。我们将涵盖如从 Web API 检索 JSON
    数据、解析 JSON 响应、从 JSON 对象中提取有价值信息以及为测试目的操作 JSON 有效载荷等场景。
- en: Retrieving JSON data from web APIs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Web API 获取 JSON 数据
- en: 'Penetration testers often need to interact with web APIs to gather information
    or perform assessments. PowerShell can be used to make HTTP requests to APIs and
    retrieve JSON data. This can be achieved using the **Invoke-RestMethod** cmdlet,
    which simplifies the process of making HTTP requests and handling responses:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员经常需要与 Web API 进行交互，以收集信息或执行评估。PowerShell 可用于向 API 发出 HTTP 请求并检索 JSON 数据。此操作可以通过
    **Invoke-RestMethod** cmdlet 完成，它简化了 HTTP 请求和响应处理的过程：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we are sending an HTTP GET request to the specified URL using
    the **Invoke-RestMethod** cmdlet. The response will be in JSON format, and PowerShell
    will automatically convert it into a PowerShell object. This makes it easier to
    access and manipulate the data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 **Invoke-RestMethod** cmdlet 向指定 URL 发送 HTTP GET 请求。响应将以 JSON 格式返回，PowerShell
    会自动将其转换为 PowerShell 对象。这使得访问和操作数据变得更加容易。
- en: Parsing JSON data
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 JSON 数据
- en: 'Once the JSON data is retrieved, it needs to be parsed to extract specific
    information. PowerShell provides the **ConvertFrom-Json** cmdlet to convert JSON
    data into PowerShell objects, making it easy to access individual elements. Let’s
    parse the JSON response from the GitHub API to extract the repository’s name and
    description:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了 JSON 数据，就需要对其进行解析以提取特定信息。PowerShell 提供了 **ConvertFrom-Json** cmdlet，将
    JSON 数据转换为 PowerShell 对象，便于访问各个元素。让我们解析来自 GitHub API 的 JSON 响应，提取仓库的名称和描述：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we use the **ConvertFrom-Json** cmdlet to convert the JSON
    response into a PowerShell object named **$repoObject**. We can then access specific
    properties of the object, such as the repository name and description.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 **ConvertFrom-Json** cmdlet 将 JSON 响应转换为名为 **$repoObject** 的 PowerShell
    对象。然后，我们可以访问该对象的特定属性，如仓库名称和描述。
- en: JSON manipulation for payloads
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于有效载荷的 JSON 操作
- en: 'During penetration testing, manipulating JSON data is essential, especially
    when crafting payloads for web application testing. PowerShell can easily create,
    modify, and send JSON payloads. Let’s create a JSON payload for an HTTP POST request
    to a vulnerable API:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试过程中，操作 JSON 数据至关重要，特别是在为 Web 应用程序测试构造有效载荷时。PowerShell 可以轻松创建、修改并发送 JSON
    有效载荷。让我们为向脆弱 API 发送 HTTP POST 请求创建一个 JSON 有效载荷：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we define a PowerShell hash table named **$payload** with username
    and password fields. We then use the **ConvertTo-Json** cmdlet to convert the
    hash table into a JSON payload. The **Invoke-RestMethod** cmdlet sends the JSON
    payload in an HTTP POST request to the specified API.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个名为 **$payload** 的 PowerShell 哈希表，其中包含用户名和密码字段。然后，我们使用 **ConvertTo-Json**
    cmdlet 将哈希表转换为 JSON 有效载荷。**Invoke-RestMethod** cmdlet 将 JSON 有效载荷通过 HTTP POST
    请求发送到指定的 API。
- en: Interacting with JSON from files
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与文件中的 JSON 交互
- en: 'Penetration testers often deal with JSON data stored in files. PowerShell provides
    easy ways to read and write JSON data to/from files. Let’s read JSON data from
    a file, add a new property, and then save it back to the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员经常处理存储在文件中的 JSON 数据。PowerShell 提供了简便的方式来读取和写入 JSON 数据到文件中。让我们从文件中读取 JSON
    数据，添加一个新属性，然后将其保存回文件：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we read JSON data from a file using the **Get-Content** cmdlet.
    The **-Raw** parameter ensures that the content is read as a single string rather
    than an array of lines. We then convert the JSON content into a PowerShell object
    named **$jsonData**. After adding a new property to the object, we use the **ConvertTo-Json**
    cmdlet to convert it back to JSON format and save it back to the file using the
    **Set-Content** cmdlet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 **Get-Content** cmdlet 从文件中读取 JSON 数据。**-Raw** 参数确保内容作为一个单一字符串而不是一行行的数组被读取。然后，我们将
    JSON 内容转换为一个名为 **$jsonData** 的 PowerShell 对象。在向该对象添加新属性后，我们使用 **ConvertTo-Json**
    cmdlet 将其转换回 JSON 格式，并使用 **Set-Content** cmdlet 将其保存回文件中。
- en: Web scraping and data extraction
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络抓取和数据提取
- en: 'In some scenarios, penetration testers may need to extract specific information
    from web pages containing JSON data. PowerShell can interact with web pages, extract
    JSON content, and process it accordingly. Let us extract information from a web
    page containing JSON data and display it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，渗透测试人员可能需要从包含 JSON 数据的网页中提取特定信息。PowerShell 可以与网页交互，提取 JSON 内容并进行相应处理。让我们从包含
    JSON 数据的网页中提取信息并显示出来：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we use the **Invoke-RestMethod** cmdlet to retrieve the JSON
    data from the specified URL. The response is then stored in the **$response**
    variable. We assume that the JSON data contains an array of objects with **Name**,
    **Age**, and **Occupation** properties. We use a **foreach** loop to iterate through
    each object in the array and display the extracted information.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 **Invoke-RestMethod** cmdlet 从指定的 URL 获取 JSON 数据。响应随后被存储在 **$response**
    变量中。我们假设 JSON 数据包含一个具有 **Name**、**Age** 和 **Occupation** 属性的对象数组。我们使用 **foreach**
    循环遍历数组中的每个对象并显示提取的信息。
- en: PowerShell is a valuable tool for processing JSON data as part of penetration
    testing. Its native support for JSON manipulation, ease of making web requests,
    and ability to parse JSON responses make it a versatile choice for working with
    JSON-based APIs and web services. As a penetration tester, understanding how to
    effectively process JSON data in PowerShell can significantly enhance your ability
    to gather information, exploit vulnerabilities, and carry out various security
    assessments. From retrieving JSON data from web APIs to crafting JSON payloads
    and handling parsing errors, PowerShell’s capabilities in dealing with JSON data
    are indispensable in the penetration tester’s toolkit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一个在渗透测试中处理 JSON 数据的有价值工具。它对 JSON 操作的原生支持、进行 Web 请求的简便性，以及解析 JSON
    响应的能力，使其成为处理基于 JSON 的 API 和 Web 服务的多功能选择。作为一名渗透测试人员，了解如何有效地在 PowerShell 中处理 JSON
    数据，可以显著提升你收集信息、利用漏洞和进行各种安全评估的能力。从从 Web API 获取 JSON 数据到构建 JSON 负载和处理解析错误，PowerShell
    在处理 JSON 数据方面的能力是渗透测试工具包中不可或缺的一部分。
- en: XML in PowerShell
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 中的 XML
- en: Penetration testing is a crucial activity in cybersecurity that involves simulating
    real-world attacks to identify vulnerabilities and weaknesses in a system or network.
    PowerShell, a versatile scripting language native to the Windows environment,
    is a valuable tool for penetration testers due to its flexibility, extensive automation
    capabilities, and ability to interact with various data formats, including XML.
    In this section, we will explore how PowerShell can be used to handle XML data
    as part of penetration testing. We will cover scenarios such as parsing XML files,
    extracting valuable information from XML nodes, and manipulating XML payloads
    for testing purposes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试是网络安全中一项至关重要的活动，旨在模拟真实世界的攻击，以识别系统或网络中的漏洞和弱点。PowerShell 是一种多功能的脚本语言，原生支持
    Windows 环境，是渗透测试人员的宝贵工具，因其灵活性、广泛的自动化能力以及与多种数据格式（包括 XML）交互的能力。在本节中，我们将探讨如何在渗透测试中使用
    PowerShell 处理 XML 数据。我们将覆盖解析 XML 文件、从 XML 节点提取有价值的信息以及为了测试目的操作 XML 负载等场景。
- en: Reading and parsing XML files
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和解析 XML 文件
- en: 'Penetration testers often encounter XML files containing configuration data
    or other sensitive information. PowerShell provides a simple way to read and parse
    XML files using the **Get-Content** cmdlet in conjunction with the **Select-Xml**
    cmdlet. Let’s read and parse an XML file that contains configuration settings
    for a web application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员经常遇到包含配置数据或其他敏感信息的 XML 文件。PowerShell 提供了一种简单的方法，通过将 **Get-Content** cmdlet
    与 **Select-Xml** cmdlet 结合使用，来读取和解析 XML 文件。让我们来读取并解析一个包含 Web 应用程序配置设置的 XML 文件：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we use the **Get-Content** cmdlet to read the content of the
    XML file specified by **$xmlFilePath**. We then cast the content to an XML object
    using the **[xml]** type accelerator. The XML object, represented by **$xmlDoc**,
    allows us to access individual elements and attributes within the XML.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 **Get-Content** cmdlet 来读取由 **$xmlFilePath** 指定的 XML 文件的内容。然后，我们使用
    **[xml]** 类型加速器将内容转换为 XML 对象。该 XML 对象，由 **$xmlDoc** 表示，允许我们访问 XML 中的各个元素和属性。
- en: Extracting information from XML nodes
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 XML 节点提取信息
- en: 'XML files often contain nested structures with multiple nodes and attributes.
    PowerShell provides ways to navigate through these hierarchical structures and
    extract valuable information. Let us extract information from an XML file that
    contains data about employees. Let’s define the following XML:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件通常包含嵌套结构，具有多个节点和属性。PowerShell 提供了方法来遍历这些层次结构并提取有价值的信息。让我们从一个包含员工数据的 XML
    文件中提取信息。我们定义以下 XML：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we’ve defined the preceding XML, we can create the following PowerShell
    to process it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了前面的 XML，我们可以创建以下 PowerShell 脚本来处理它：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we read and parse the XML file using the same approach as before.
    We then access the **employees** node and iterate through each employee node using
    a **foreach** loop. Within the loop, we extract information such as employee ID,
    name, age, and position from each node and display it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用与之前相同的方法读取和解析 XML 文件。然后，我们访问 **employees** 节点，并使用 **foreach** 循环遍历每个员工节点。在循环内，我们从每个节点中提取信息，例如员工
    ID、姓名、年龄和职位，并将其显示出来。
- en: Modifying XML data
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 XML 数据
- en: 'Penetration testers may need to modify XML data in certain scenarios, such
    as testing for input validation vulnerabilities or bypassing security controls.
    Let’s modify an XML file that contains user settings and save the updated XML
    back to the file. Let’s define the following XML:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员在某些场景下可能需要修改 XML 数据，例如测试输入验证漏洞或绕过安全控制。让我们修改一个包含用户设置的 XML 文件，并将更新后的 XML
    保存回文件。我们定义以下 XML：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we’ve defined the preceding XML, we can create the following PowerShell
    to process it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了前面的 XML，我们可以创建以下 PowerShell 脚本来处理它：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we read and parse the XML file as before. We then use the **Where-Object**
    cmdlet to filter the setting nodes based on the name attribute. Once we find the
    setting with the name **theme**, we modify its value attribute to **light**. Finally,
    we use the **Save** method to save the updated XML back to the file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们像之前一样读取和解析 XML 文件。然后，我们使用 **Where-Object** cmdlet 根据 name 属性过滤设置节点。一旦我们找到名称为
    **theme** 的设置，我们将其值属性修改为 **light**。最后，我们使用 **Save** 方法将更新后的 XML 保存回文件。
- en: Crafting XML payloads
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 XML 负载
- en: 'During penetration testing, it is common to craft custom XML payloads to test
    for XML-based vulnerabilities such as **XML External Entity** (**XXE**) injection.
    Let’s craft an XML payload for testing an application for XXE vulnerabilities:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，常常需要构建自定义 XML 负载来测试基于 XML 的漏洞，例如 **XML 外部实体** (**XXE**) 注入。让我们为测试一个应用程序的
    XXE 漏洞构建一个 XML 负载：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we define an XML payload containing an external entity declaration
    that fetches an external **Document Type Definition** (**DTD**) file from the
    attacker’s server. This is a common XXE payload. We then save the payload to a
    file that can be used for testing XXE vulnerabilities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个包含外部实体声明的 XML 负载，该声明从攻击者的服务器获取外部的 **文档类型定义** (**DTD**) 文件。这是一个常见的
    XXE 负载。然后，我们将该负载保存到一个文件中，以便用于测试 XXE 漏洞。
- en: XML injection testing
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 注入测试
- en: 'Penetration testers often test web applications for XML injection vulnerabilities.
    PowerShell can be used to craft and inject malicious XML payloads into input fields
    to assess the application’s XML parsing and validation mechanisms. Let’s craft
    a malicious XML payload to test for XML injection vulnerabilities in a web application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员通常会测试 Web 应用程序的 XML 注入漏洞。PowerShell 可以用来构建和注入恶意 XML 负载到输入字段中，以评估应用程序的
    XML 解析和验证机制。让我们构建一个恶意 XML 负载来测试 Web 应用程序中的 XML 注入漏洞：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we create a malicious XML payload containing an XXE injection
    payload inside the data element. We then inject this payload into an input field
    (represented by **$injectionPoint**) of a web application to test whether the
    application is vulnerable to XXE attacks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建一个包含 XXE 注入负载的恶意 XML 负载，负载被嵌入在数据元素中。然后，我们将这个负载注入到 Web 应用程序的输入字段（由
    **$injectionPoint** 表示）中，以测试应用程序是否容易受到 XXE 攻击。
- en: COM, WMI, and .NET in PowerShell
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COM、WMI 和 .NET 在 PowerShell 中
- en: Penetration testing is a crucial activity in cybersecurity that involves simulating
    real-world attacks to identify vulnerabilities and weaknesses in a system or network.
    PowerShell, a versatile scripting language native to the Windows environment,
    is a valuable tool for penetration testers due to its flexibility, extensive automation
    capabilities, and ability to interact with various technologies such as COM, WMI,
    and .NET. In this section, we will explore how PowerShell can be used to interact
    with and leverage COM objects, WMI queries, and .NET assemblies as part of penetration
    testing. We will cover scenarios such as accessing system information, querying
    WMI data, interacting with COM components, and using .NET assemblies to perform
    specific tasks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试是网络安全中的一项关键活动，它涉及模拟现实世界中的攻击，以识别系统或网络中的漏洞和弱点。PowerShell 是一种多功能的脚本语言，原生支持
    Windows 环境，因其灵活性、广泛的自动化功能以及与多种技术（如 COM、WMI 和 .NET）的互动能力，成为渗透测试人员的宝贵工具。在本节中，我们将探讨如何利用
    PowerShell 与 COM 对象、WMI 查询和 .NET 程序集进行交互，并在渗透测试中加以应用。我们将涵盖诸如访问系统信息、查询 WMI 数据、与
    COM 组件交互以及使用 .NET 程序集执行特定任务等场景。
- en: Using WMI for system information gathering
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WMI 进行系统信息收集
- en: 'WMI is a powerful management technology in Windows that provides a standardized
    way to access system information, configuration, and control. PowerShell allows
    penetration testers to query WMI data to gather valuable information about the
    target system. Let’s use PowerShell to query WMI to retrieve the list of installed
    software on the target machine:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 是 Windows 中一项强大的管理技术，提供了一个标准化的方式来访问系统信息、配置和控制。PowerShell 允许渗透测试人员查询 WMI
    数据，以收集有关目标系统的有价值信息。让我们使用 PowerShell 查询 WMI，获取目标机器上已安装软件的列表：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we use the **Get-WmiObject** cmdlet to query the **Win32_Product**
    class, which represents installed software on the system. We then select specific
    properties such as **Name**, **Vendor**, and **Version** and display the information
    in the output.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用 **Get-WmiObject** cmdlet 查询 **Win32_Product** 类，该类代表系统上已安装的软件。然后，我们选择具体的属性，如
    **Name**、**Vendor** 和 **Version**，并将信息显示在输出中。
- en: Querying WMI for network information
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询 WMI 获取网络信息
- en: 'Penetration testers often need to gather information about the network configuration
    of the target system. PowerShell can query WMI to obtain network-related data.
    Let’s use PowerShell to query WMI for network adapter information:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员通常需要收集目标系统的网络配置相关信息。PowerShell 可以查询 WMI 以获取与网络相关的数据。让我们使用 PowerShell 查询
    WMI，获取网络适配器信息：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we use the **Get-WmiObject** cmdlet to query the **Win32_NetworkAdapterConfiguration**
    class, which represents network adapter configurations. We filter the results
    to exclude adapters without IP addresses **($_.IPAddress -ne $null)**. We then
    display the adapter description, IP address, and MAC address for each network
    adapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用 **Get-WmiObject** cmdlet 查询 **Win32_NetworkAdapterConfiguration**
    类，该类代表网络适配器配置。我们筛选结果，排除没有 IP 地址的适配器 **($_.IPAddress -ne $null)**。然后，我们显示每个网络适配器的适配器描述、IP
    地址和 MAC 地址。
- en: Interacting with COM objects
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 COM 对象交互
- en: 'COM is a Microsoft technology that enables software components to communicate
    and interact with each other. PowerShell provides access to COM objects, allowing
    penetration testers to interact with and use COM components for various purposes.
    Let’s use PowerShell to create a COM object for manipulating Excel files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: COM 是 Microsoft 的一项技术，旨在使软件组件能够相互通信和交互。PowerShell 提供了访问 COM 对象的功能，使渗透测试人员能够与
    COM 组件进行交互，并将其用于各种目的。让我们使用 PowerShell 创建一个 COM 对象，用于操作 Excel 文件：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we use the **New-Object** cmdlet to create a new instance of
    the Excel application COM object. We then create a new workbook and worksheet,
    set the values in cells, and make the Excel application visible. This allows us
    to automate Excel operations and perform tasks such as data extraction, manipulation,
    and reporting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用 **New-Object** cmdlet 创建 Excel 应用程序 COM 对象的新实例。然后，我们创建一个新的工作簿和工作表，设置单元格中的值，并使
    Excel 应用程序可见。这样，我们就可以自动化 Excel 操作，并执行数据提取、处理和报告等任务。
- en: Using .NET for cryptographic operations
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET 进行加密操作
- en: 'PowerShell can also utilize .NET classes for cryptographic operations such
    as hashing and encryption, which are commonly used in penetration testing for
    securing data or testing security controls. Let us use PowerShell and .NET to
    calculate the MD5 hash of a file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 还可以利用 .NET 类进行加密操作，如哈希和加密，这在渗透测试中常用于保护数据或测试安全控制。让我们使用 PowerShell
    和 .NET 来计算文件的 MD5 哈希值：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we use the **System.Security.Cryptography.MD5CryptoServiceProvider**
    .NET class to calculate the MD5 hash of a file. We open the file in binary mode,
    compute the hash, and convert the hash bytes to a hexadecimal string representation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用**System.Security.Cryptography.MD5CryptoServiceProvider** .NET 类来计算文件的
    MD5 哈希值。我们以二进制模式打开文件，计算哈希值，并将哈希字节转换为十六进制字符串表示。
- en: Using .NET for network operations
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET 进行网络操作
- en: 'PowerShell can leverage .NET classes for network-related operations, which
    is useful in penetration testing for tasks such as sending HTTP requests, parsing
    responses, and interacting with web services. Let’s use PowerShell and .NET to
    make an HTTP GET request and process the response:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 可以利用 .NET 类进行与网络相关的操作，这在渗透测试中对于发送 HTTP 请求、解析响应以及与 Web 服务交互等任务非常有用。让我们使用
    PowerShell 和 .NET 来发出 HTTP GET 请求并处理响应：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we use the **System.Net.WebRequest** and **System.IO.StreamReader**
    .NET classes to make an HTTP GET request to the specified URL. We then read the
    response content and display it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用**System.Net.WebRequest**和**System.IO.StreamReader** .NET 类来向指定的
    URL 发出 HTTP GET 请求。然后，我们读取响应内容并显示出来。
- en: Analyzing .NET assemblies for vulnerabilities
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析 .NET 程序集中的漏洞
- en: 'PowerShell can be used to analyze .NET assemblies for potential vulnerabilities
    or malicious code. For instance, penetration testers can scan assemblies for sensitive
    API keys or hardcoded credentials. Let’s use PowerShell to extract strings from
    a .NET assembly and search for potentially sensitive information:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 可以用来分析 .NET 程序集中的潜在漏洞或恶意代码。例如，渗透测试人员可以扫描程序集，查找敏感的 API 密钥或硬编码的凭证。让我们使用
    PowerShell 从 .NET 程序集中提取字符串并搜索潜在的敏感信息：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we read the entire .NET assembly as text using **[System.IO.File]::ReadAllText**.
    We then use regular expressions to search for potential API keys in the assembly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用**[System.IO.File]::ReadAllText**将整个 .NET 程序集作为文本读取。然后，我们使用正则表达式在程序集里搜索潜在的
    API 密钥。
- en: PowerShell is a valuable tool for processing COM, WMI, and .NET in penetration
    testing. Its ability to interact with COM objects, query WMI data, leverage .NET
    assemblies, and perform various tasks with .NET functionality provides penetration
    testers with a wide range of capabilities for identifying vulnerabilities and
    weaknesses in target systems. From gathering system and network information using
    WMI and automating tasks with COM objects to utilizing .NET for cryptographic
    operations and network-related tasks, PowerShell is a versatile scripting language
    that empowers penetration testers to conduct comprehensive security assessments
    and identify potential security risks. Understanding how to effectively use PowerShell
    for COM, WMI, and .NET operations enhances the penetration tester’s toolkit and
    allows for more efficiency against real-world attacks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是处理 COM、WMI 和 .NET 的有价值工具，尤其在渗透测试中。它能够与 COM 对象交互、查询 WMI 数据、利用 .NET
    程序集并执行各种与 .NET 功能相关的任务，为渗透测试人员提供广泛的功能，用于识别目标系统中的漏洞和弱点。从通过 WMI 收集系统和网络信息、使用 COM
    对象自动化任务，到利用 .NET 进行加密操作和与网络相关的任务，PowerShell 是一款多功能的脚本语言，使渗透测试人员能够进行全面的安全评估，并识别潜在的安全风险。了解如何有效地使用
    PowerShell 进行 COM、WMI 和 .NET 操作，可以提升渗透测试人员的工具包，并在面对现实攻击时提高效率。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'PowerShell is a versatile and powerful command-line shell and scripting language
    developed by Microsoft. It has gained significant popularity in the field of penetration
    testing due to its ability to manipulate and interact with various data formats,
    including JSON and XML. Here is what we have covered regarding PowerShell in this
    chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一款多功能且强大的命令行 shell 和脚本语言，由微软开发。由于其能够操作和交互多种数据格式，包括 JSON 和 XML，PowerShell
    在渗透测试领域获得了显著的普及。以下是我们在本章中涉及的 PowerShell 内容：
- en: '**JSON and XML handling**: PowerShell provides robust support for handling
    JSON and XML data, making it an invaluable tool for penetration testers. JSON
    and XML are commonly used data interchange formats, and PowerShell allows testers
    to easily parse, manipulate, and extract information from files and web services
    in these formats.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON 和 XML 处理**：PowerShell 提供了强大的支持来处理 JSON 和 XML 数据，使其成为渗透测试人员不可或缺的工具。JSON
    和 XML 是常用的数据交换格式，PowerShell 允许测试人员轻松解析、操作和提取这些格式中的文件和 Web 服务的信息。'
- en: '**Data extraction**: In penetration testing, extracting information from various
    sources is crucial. PowerShell’s ability to parse JSON and XML data enables testers
    to sift through large datasets, extract specific information, and use it for analysis
    or exploitation.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据提取**：在渗透测试中，从各种来源提取信息至关重要。PowerShell 解析 JSON 和 XML 数据的能力使测试人员能够从大型数据集中筛选出特定信息，并将其用于分析或利用。'
- en: '**Automation**: Penetration testers often need to automate repetitive tasks,
    and PowerShell’s scripting capabilities shine here. With JSON and XML support,
    testers can create scripts to automate data retrieval, analysis, and reporting,
    streamlining their workflow and saving time.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：渗透测试人员常常需要自动化重复性任务，而 PowerShell 的脚本功能在这里大放异彩。借助 JSON 和 XML 的支持，测试人员可以创建脚本来自动化数据提取、分析和报告，简化工作流程并节省时间。'
- en: '**Integration with other tools**: PowerShell’s flexibility allows it to integrate
    seamlessly with other penetration testing tools and frameworks. It can communicate
    with APIs, databases, and web services, making it an ideal choice for orchestrating
    complex attacks or reconnaissance activities.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他工具的集成**：PowerShell 的灵活性使其能够与其他渗透测试工具和框架无缝集成。它可以与 API、数据库和 Web 服务通信，是执行复杂攻击或侦察活动的理想选择。'
- en: '**Reporting and documentation**: Penetration testers need to document their
    findings thoroughly. PowerShell scripts can generate detailed reports in various
    formats, including HTML and CSV, by processing JSON and XML data, helping testers
    communicate their results effectively.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告与文档**：渗透测试人员需要彻底记录他们的发现。PowerShell 脚本可以通过处理 JSON 和 XML 数据生成各种格式的详细报告，包括
    HTML 和 CSV，帮助测试人员有效地传达他们的结果。'
- en: In summary, PowerShell’s capability to handle JSON and XML data makes it a valuable
    asset for penetration testers. Its versatility, automation capabilities, and integration
    with other tools make it a go-to choice for conducting efficient and effective
    penetration testing activities while maintaining thorough documentation of the
    process and results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，PowerShell 处理 JSON 和 XML 数据的能力使其成为渗透测试人员的宝贵资产。其多功能性、自动化能力以及与其他工具的集成，使其成为执行高效且有效的渗透测试活动的首选工具，同时保持过程和结果的详尽文档。
- en: In the next chapter, we will delve into the intricate world of **network services**
    and **Domain Name System** (**DNS**) management, leveraging the power of PowerShell
    to streamline and optimize these critical components of modern IT infrastructure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 **网络服务** 和 **域名系统** (**DNS**) 管理的复杂世界，利用 PowerShell 的强大功能来简化和优化这些现代
    IT 基础设施中的关键组件。
- en: 'Part 2: Identification and Exploitation'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：识别与利用
- en: In this section, you will be introduced to leveraging PowerShell for network
    identification and exploitation. It provides an overview of how PowerShell can
    be utilized as a tool for identifying and exploiting vulnerabilities within networks.
    By delving into the fundamentals of PowerShell usage, you will gain an insight
    into its capabilities in the context of network security. Through practical examples
    and demonstrations, you’ll develop a comprehensive understanding of how PowerShell
    can be harnessed effectively for these purposes. This foundational knowledge will
    empower you to proficiently navigate network environments, identify potential
    vulnerabilities, and apply appropriate remediation measures to enhance the overall
    security posture.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何利用 PowerShell 进行网络识别和利用。它概述了如何将 PowerShell 用作工具来识别和利用网络中的漏洞。通过深入了解 PowerShell
    使用的基础知识，你将了解它在网络安全领域的应用能力。通过实际示例和演示，你将全面理解如何有效地利用 PowerShell 达成这些目标。这些基础知识将使你能够熟练地操作网络环境，识别潜在漏洞，并采取适当的修复措施，以增强整体安全防护。
- en: 'This part has the following chapters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 3*](B21364_03.xhtml#_idTextAnchor046), *Network Services in DNS*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 3 章*](B21364_03.xhtml#_idTextAnchor046)，*DNS 中的网络服务*'
- en: '[*Chapter 4*](B21364_04.xhtml#_idTextAnchor058), *Network Enumeration and Port
    Scanning*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B21364_04.xhtml#_idTextAnchor058)，*网络枚举与端口扫描*'
- en: '[*Chapter 5*](B21364_05.xhtml#_idTextAnchor071), *The WEB, REST, and OAP*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21364_05.xhtml#_idTextAnchor071)，*WEB、REST与OAP*'
- en: '[*Chapter 6*](B21364_06.xhtml#_idTextAnchor100), *SMB, Active Directory, LDAP,
    and Kerberos*'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21364_06.xhtml#_idTextAnchor100)，*SMB、Active Directory、LDAP和Kerberos*'
- en: '[*Chapter 7*](B21364_07.xhtml#_idTextAnchor135), *Databases**:* *MySQL**, PostgreSQL
    and MSSQL*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21364_07.xhtml#_idTextAnchor135)，*数据库：* *MySQL*，PostgreSQL与MSSQL*'
- en: '[*Chapter 8*](B21364_08.xhtml#_idTextAnchor164), *Email Services**: Exchange,*
    *SMTP, IMAP, and POP*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21364_08.xhtml#_idTextAnchor164)，*电子邮件服务：Exchange，* *SMTP，IMAP和POP*'
- en: '[*Chapter 9*](B21364_09.xhtml#_idTextAnchor183), *PowerShell and* *FTP, TFTP,
    SSH, and Telent*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21364_09.xhtml#_idTextAnchor183)，*PowerShell与* *FTP，TFTP，SSH和Telent*'
- en: '[*Chapter 10*](B21364_10.xhtml#_idTextAnchor213) *Brute Forcing in PowerShell*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21364_10.xhtml#_idTextAnchor213)，*PowerShell中的暴力破解*'
- en: '[*Chapter 11*](B21364_11.xhtml#_idTextAnchor256), *PowerShell and* *Remote
    Control and Administration*'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21364_11.xhtml#_idTextAnchor256)，*PowerShell与* *远程控制和管理*'
