- en: '*Chapter 9*: Ninja 308'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：Ninja 308'
- en: 'In the previous chapter, we discussed the fundamentals of industrial protocols
    and specifically the nuances of two in particular: Modbus and Ethernet/IP. We
    discussed and used tools that allowed us to enumerate ports and discover services
    running on those devices. We also used tools to traverse directories and vhosts
    in [*Chapter 7*](B16321_07_Epub_AM.xhtml#_idTextAnchor081), *Scanning 101*, which
    means that we have a great foundational knowledge of both ends of the attack chain.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了工业协议的基础知识，特别是两种协议的细节：Modbus和Ethernet/IP。我们讨论并使用了可以枚举端口和发现这些设备上运行的服务的工具。我们还使用了工具来遍历目录和虚拟主机，在[*第7章*](B16321_07_Epub_AM.xhtml#_idTextAnchor081)《扫描101》中也提到过，这意味着我们在攻击链的两端都有很好的基础知识。
- en: Now, we need to spend time looking at attacks and, most importantly, brute forcing.
    As exciting as it is to find a legacy service that we then spend time reverse
    engineering and building an exploit for, time is typically not on our side. If
    you discover a system such as Ignition SCADA, which we installed in [*Chapter
    7*](B16321_07_Epub_AM.xhtml#_idTextAnchor081), *Scanning 101*, it is fairly common
    for operational personnel to use simple passwords or factory defaults to access
    the system. Gaining access to a SCADA system as a user allows you to take over
    absolute control of the industrial process. Acquiring this level of access is
    similar to the crown jewels of "Domain Admin" inside the Enterprise IT security
    landscape. Learning how to use a web pentesting tool such as BurpSuite is very
    important as it will aid in opening access to various systems by divulging real-world
    credentials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要花时间研究攻击，最重要的是暴力破解。尽管发现一个遗留服务并花时间进行逆向工程并构建漏洞利用工具非常令人兴奋，但时间通常并不站在我们这边。如果你发现一个像Ignition
    SCADA这样的系统（我们在[*第7章*](B16321_07_Epub_AM.xhtml#_idTextAnchor081)《扫描101》中安装了它），通常情况下，操作人员会使用简单的密码或工厂默认密码来访问系统。作为用户访问SCADA系统可以让你完全控制工业过程。获得这种访问权限类似于企业IT安全领域中的“域管理员”权限。学习如何使用像BurpSuite这样的Web渗透测试工具非常重要，因为它将帮助你通过泄露真实的凭证来打开各种系统的访问权限。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Installing FoxyProxy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装FoxyProxy
- en: Running BurpSuite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行BurpSuite
- en: Building a script for brute-forcing SCADA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个用于暴力破解SCADA的脚本
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将需要以下内容：
- en: A Kali Linux VM running with Firefox installed.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装了Firefox的Kali Linux虚拟机。
- en: 'BurpSuite Community Edition installed. Go to this link to find the latest version:
    [https://portswigger.net/burp/communitydownload](https://portswigger.net/burp/communitydownload).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了BurpSuite Community Edition。前往以下链接查找最新版本：[https://portswigger.net/burp/communitydownload](https://portswigger.net/burp/communitydownload)。
- en: 'A default list of SCADA equipment passwords, which can be found at this link:
    [https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv](https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份SCADA设备默认密码列表，可以通过以下链接找到：[https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv](https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv)。
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3lAinwm](https://bit.ly/3lAinwm)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看本章代码的实际操作：[https://bit.ly/3lAinwm](https://bit.ly/3lAinwm)
- en: Installing FoxyProxy
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装FoxyProxy
- en: 'Before diving into the installation of FoxyProxy, we should define what a proxy
    server is and why we would want to use one. A **proxy server** is a system that
    translates traffic from one network or device into another device or network.
    This is easier said than done, though: what does this mean for us and why would
    we care about translating traffic? A proxy server allows us to intercept all communication
    originating from and designated to our attacking host. This allows us to augment
    and change the behavior of how the request interacts with the server, such as
    by dropping JavaScript UI filtering and other interesting tasks. So, now that
    we know what a proxy server is, what is FoxyProxy? FoxyProxy is a simple but powerful
    proxy switch. It takes all the tediousness out of having to change the internal
    proxy settings of your browser. Simply add your new setting and use a switch to
    toggle between proxy servers and turn them on and off.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始安装 FoxyProxy 之前，我们需要先定义什么是代理服务器以及为什么我们需要使用它。**代理服务器**是一个将来自一个网络或设备的流量转换为另一个设备或网络的系统。然而，这并不容易理解：这对我们意味着什么，为什么我们要关心流量的转换呢？代理服务器允许我们拦截所有来自和指定到我们的攻击主机的通信。这使我们能够增强并更改请求与服务器交互的方式，例如，通过删除
    JavaScript UI 过滤和执行其他有趣的任务。那么，既然我们知道了什么是代理服务器，FoxyProxy 又是什么呢？FoxyProxy 是一个简单但强大的代理切换工具。它消除了您必须更改浏览器内部代理设置的繁琐操作。只需添加新的设置并使用开关在代理服务器之间切换，开启或关闭它们。
- en: 'Follow these steps to install FoxyProxy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 FoxyProxy：
- en: To start, you will need to access your Kali Linux VM and start Firefox ESR.
    Once you have Firefox open, navigate to the right-hand side, where you will see
    the hamburger button or menu button; select it. It will bring up the following
    drop-down menu:![Figure 9.1 – Menu dropdown
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要访问 Kali Linux 虚拟机并启动 Firefox ESR。一旦打开 Firefox，导航到右侧，您会看到一个汉堡按钮或菜单按钮；点击它。它将弹出以下下拉菜单：![图
    9.1 – 菜单下拉
- en: '](image/Figure_9.01_B16321.jpg)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.01_B16321.jpg)'
- en: Figure 9.1 – Menu dropdown
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.1 – 菜单下拉
- en: With the menu open, select the **Add-ons** option. You will be presented with
    a screen showing recommendations, extensions, themes, and plugins. Navigate to
    the search bar, type in **foxyproxy**, and then press *Enter*, as shown in the
    following screenshot:![Figure 9.2 – Add-on search pop-up
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单打开后，选择**附加组件**选项。您将看到一个显示推荐、扩展、主题和插件的界面。导航到搜索框，输入**foxyproxy**，然后按*回车*键，如下图所示：![图
    9.2 – 附加组件搜索弹窗
- en: '](image/Figure_9.02_B16321.jpg)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.02_B16321.jpg)'
- en: Figure 9.2 – Add-on search pop-up
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.2 – 附加组件搜索弹窗
- en: By doing this, you will see a list of possible matching add-ons. You will see
    **FoxyProxy Standard** at the top of the list, as shown in the following screenshot:![Figure
    9.3 – FoxyProxy Standard
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做后，您将看到一个可能匹配的附加组件列表。您会在列表顶部看到**FoxyProxy 标准版**，如下图所示：![图 9.3 – FoxyProxy
    标准版
- en: '](image/Figure_9.03_B16321.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.03_B16321.jpg)'
- en: Figure 9.3 – FoxyProxy Standard
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.3 – FoxyProxy 标准版
- en: Clicking the **FoxyProxy Standard** link will cause a popup to appear that allows
    you to click the **Add to Firefox** button. This is shown in the following screenshot:![Figure
    9.4 – Installing FoxyProxy
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**FoxyProxy 标准版**链接，将弹出一个窗口，您可以点击**添加到 Firefox**按钮。如下图所示：![图 9.4 – 安装 FoxyProxy
- en: '](image/Figure_9.04_B16321.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.04_B16321.jpg)'
- en: Figure 9.4 – Installing FoxyProxy
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.4 – 安装 FoxyProxy
- en: Proceed by clicking the **Add to Firefox** button. At this point, you will be
    presented with a permissions request. This is important as you will be allowing
    FoxyProxy to change your browser settings. The following are the permissions that
    you will be granting FoxyProxy by adding it to your browser:![Figure 9.5 – FoxyProxy
    permissions
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续点击**添加到 Firefox**按钮。此时，您将看到一个权限请求提示。这很重要，因为您将允许 FoxyProxy 更改您的浏览器设置。以下是您通过将其添加到浏览器时将授予
    FoxyProxy 的权限：![图 9.5 – FoxyProxy 权限
- en: '](image/Figure_9.05_B16321.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.05_B16321.jpg)'
- en: Figure 9.5 – FoxyProxy permissions
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5 – FoxyProxy 权限
- en: Click the **Add** button to successfully install FoxyProxy. You should now see
    a fox icon in the toolbar, on the right-hand side of Firefox. Clicking the icon
    brings up the following screen:![Figure 9.6 – FoxyProxy configuration
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮以成功安装 FoxyProxy。此时，您应该会看到一个狐狸图标出现在 Firefox 的工具栏上，位于右侧。点击该图标将显示以下界面：![图
    9.6 – FoxyProxy 配置
- en: '](image/Figure_9.06_B16321.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.06_B16321.jpg)'
- en: Figure 9.6 – FoxyProxy configuration
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6 – FoxyProxy 配置
- en: We currently don't have any proxy settings so we will add some by clicking the
    **+ Add** link, as shown in the following screenshot:![Figure 9.7 – Adding settings
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前我们没有任何代理设置，所以我们将通过点击**+ 添加**链接来添加一些，如下图所示：![图 9.7 – 添加设置
- en: '](image/Figure_9.07_B16321.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.07_B16321.jpg)'
- en: Figure 9.7 – Adding settings
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7 – 添加设置
- en: 'Upon clicking this, you will be presented with a page that allows you to add
    your first proxy settings, as shown here:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击此按钮后，你将看到一个页面，允许你添加第一个代理设置，如下所示：
- en: '![Figure 9.8 – First proxy settings'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.8 – 第一个代理设置'
- en: '](image/Figure_9.08_B16321.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_9.08_B16321.jpg)'
- en: Figure 9.8 – First proxy settings
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8 – 第一个代理设置
- en: 'For these settings, I tend to set the following parameters:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这些设置，我通常设置以下参数：
- en: '- **Title or Description**: **BurpSuite**'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **标题或描述**：**BurpSuite**'
- en: '- **Proxy Type**: **HTTP**'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **代理类型**：**HTTP**'
- en: '- **Proxy IP**: **127.0.0.1**'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **代理IP**：**127.0.0.1**'
- en: '- **Port**: **8080**'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **端口**：**8080**'
- en: 'Click the **Save** button. Now, you should have the newly added setting when
    you click the fox icon in your toolbar, as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮。现在，当你点击工具栏中的狐狸图标时，应该能看到新添加的设置，如下图所示：
- en: '![Figure 9.9 – BurpSuite proxy'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – BurpSuite代理'
- en: '](image/Figure_9.09_B16321.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.09_B16321.jpg)'
- en: Figure 9.9 – BurpSuite proxy
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – BurpSuite代理
- en: With that, we have successfully installed FoxyProxy and configured our first
    proxy setting, which is convenient for BurpSuite. This is the next topic that
    we will be discussing. The simplicity of quickly configuring proxies and having
    the ability to toggle them on and off, as well as switching between the different
    proxies, will be very useful in your pentesting career.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就成功安装了FoxyProxy并配置了第一个代理设置，这对BurpSuite来说非常方便。接下来我们将讨论这个主题。快速配置代理的简便性，以及能够开关代理并在不同代理之间切换，在你的渗透测试职业生涯中将非常有用。
- en: Running BurpSuite
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行BurpSuite
- en: In the previous section, we installed FoxyProxy and configured some settings
    to accommodate our BurpSuite software. In this section, we are going to utilize
    BurpSuite to help us understand the **Request**/**Response** actions that Ignition
    SCADA utilizes to perform authentication and authorization. Now, for us to proceed,
    we need to add BurpSuite's certificate as a trusted source; otherwise, we will
    be forced to acknowledge every website we've visited as an exception.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们安装了FoxyProxy并配置了一些设置，以适应我们的BurpSuite软件。在本节中，我们将利用BurpSuite帮助我们理解Ignition
    SCADA使用的**请求**/**响应**操作，以执行身份验证和授权。现在，为了继续操作，我们需要将BurpSuite的证书添加为受信任的源；否则，我们将被迫将每个访问过的网站标记为例外。
- en: 'To do this, we must navigate to the IP address and port that we configured
    in our settings. Upon doing this, you will be presented with a **BurpSuite Community
    Edition** splash page with a **CA Certificate** button on the right-hand side,
    as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须导航到我们在设置中配置的IP地址和端口。完成此操作后，你将看到一个**BurpSuite社区版**的启动页面，右侧有一个**CA证书**按钮，如下所示：
- en: '![Figure 9.10 – CA Certificate location'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – CA证书位置'
- en: '](image/Figure_9.10_B16321.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.10_B16321.jpg)'
- en: Figure 9.10 – CA Certificate location
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – CA证书位置
- en: 'Upon clicking this button, you will be presented with the following screen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮后，你将看到以下屏幕：
- en: '![Figure 9.11 – Saving the CA Certificate'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 保存CA证书'
- en: '](image/Figure_9.11_B16321.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.11_B16321.jpg)'
- en: Figure 9.11 – Saving the CA Certificate
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 保存CA证书
- en: 'Select **Save File** and click the **OK** button. Next, we want to navigate
    to our menu under the hamburger icon and select **Preferences**, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**保存文件**并点击**确定**按钮。接下来，我们需要导航到菜单中的汉堡图标，并选择**首选项**，如图所示：
- en: '![Figure 9.12 – Preferences'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 首选项'
- en: '](image/Figure_9.12_B16321.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.12_B16321.jpg)'
- en: Figure 9.12 – Preferences
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 首选项
- en: 'Then, we want to select **Privacy & Security** on the left-hand side, as shown
    in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要选择左侧的**隐私与安全**，如下图所示：
- en: '![Figure 9.13 – Privacy & Security'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13 – 隐私与安全'
- en: '](image/Figure_9.13_B16321.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.13_B16321.jpg)'
- en: Figure 9.13 – Privacy & Security
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 隐私与安全
- en: 'Scroll down until you see the **Certificates** area, as shown in the following
    screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动，直到看到**证书**区域，如下图所示：
- en: '![Figure 9.14 – Certificates'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.14 – 证书'
- en: '](image/Figure_9.14_B16321.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.14_B16321.jpg)'
- en: Figure 9.14 – Certificates
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 证书
- en: 'Click the **View Certificates** button. You will be presented with the following
    pop-up:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **查看证书** 按钮。系统将弹出以下窗口：
- en: '![Figure 9.15 – Importing certificates'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.15 – 导入证书'
- en: '](image/Figure_9.15_B16321.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.15_B16321.jpg)'
- en: Figure 9.15 – Importing certificates
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 导入证书
- en: Click the **Import** button, navigate to the recently downloaded **ca.cert**
    file, and click **OK**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Import** 按钮，导航到最近下载的 **ca.cert** 文件，然后点击 **OK**。
- en: 'You will see the following screen:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下屏幕：
- en: '![Figure 9.16 – Setting trust options'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.16 – 设置信任选项'
- en: '](image/Figure_9.16_B16321.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.16_B16321.jpg)'
- en: Figure 9.16 – Setting trust options
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 设置信任选项
- en: 'Select **Trust this CA to identify websites** and then the **OK** button. Scroll
    down to find the **PortSwigger** certificate to make sure that the import went
    smoothly. You should see the following screen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **信任此 CA 以识别网站**，然后点击 **OK** 按钮。向下滚动以找到 **PortSwigger** 证书，确保导入顺利完成。您应该会看到以下屏幕：
- en: '![Figure 9.17 – PortSwigger certificate'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17 – PortSwigger 证书'
- en: '](image/Figure_9.17_B16321.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.17_B16321.jpg)'
- en: Figure 9.17 – PortSwigger certificate
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – PortSwigger 证书
- en: Finish installing the certificate by clicking **OK**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成证书安装，点击 **OK**。
- en: 'There you have it! We have successfully installed the certificate. Now, it
    is time to open up BurpSuite. Find and open BurpSuite on your Kali Linux VM. You
    will be presented with the option to configure a project. This is a great opportunity
    for you to start organizing engagements into various projects, as it will help
    you in the long run when it comes to writing your findings report. I will use
    a **Temporary project** going forward, as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经成功安装了证书。现在，是时候打开 BurpSuite 了。找到并打开 Kali Linux 虚拟机上的 BurpSuite。系统将提示您配置一个项目。这是您开始将工作安排到各种项目中的好机会，因为这将帮助您在编写报告时更高效。我将在接下来的操作中使用
    **临时项目**，如下所示的截图：
- en: '![Figure 9.18 – Temporary project'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18 – 临时项目'
- en: '](image/Figure_9.18_B16321.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.18_B16321.jpg)'
- en: Figure 9.18 – Temporary project
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 临时项目
- en: 'On the next screen, you will have the option to load preset configurations
    or use BurpSuite''s default settings. I am going to select **Use Burp defaults**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，您将有机会加载预设配置或使用 BurpSuite 的默认设置。我将选择 **使用 Burp 默认设置**：
- en: '![Figure 9.19 – Burp default settings'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.19 – Burp 默认设置'
- en: '](image/Figure_9.19_B16321.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.19_B16321.jpg)'
- en: Figure 9.19 – Burp default settings
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – Burp 默认设置
- en: 'Next, we want to make sure that Burp is using the correct proxy listener. So,
    select the **Proxy** menu item and then select **Options**. From here, add a new
    proxy listener with the interface set to an IP **Address:Port** number and **Certificate**
    set to **Per-host**, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保 Burp 使用正确的代理监听器。因此，选择 **Proxy** 菜单项，然后选择 **Options**。在这里，添加一个新的代理监听器，将接口设置为
    IP **Address:Port** 编号，**Certificate** 设置为 **Per-host**，如下面的截图所示：
- en: '![Figure 9.20 – Proxy Listeners'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.20 – 代理监听器'
- en: '](image/Figure_9.20_B16321.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.20_B16321.jpg)'
- en: Figure 9.20 – Proxy Listeners
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 代理监听器
- en: 'Make sure that you have your proxy selected and that **Intercept is on is enabled**,
    as shown in the following screenshot. Also, make sure that you have toggled BurpSuite
    on in FoxyProxy:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您选择了代理，并且 **拦截开启** 已启用，如下所示的截图所示。同时，确保您在 FoxyProxy 中切换了 BurpSuite：
- en: '![Figure 9.21 – Intercept is on'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.21 – 拦截开启'
- en: '](image/Figure_9.21_B16321.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.21_B16321.jpg)'
- en: Figure 9.21 – Intercept is on
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 拦截开启
- en: 'Now for the fun part: this is where we will be intercepting traffic and analyzing
    its behavior in BurpSuite. Navigate to Ignition SCADA''s login page:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入有趣的部分：我们将在此拦截流量并使用 BurpSuite 分析其行为。请导航到 Ignition SCADA 的登录页面：
- en: '![Figure 9.22 – Ignition login'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.22 – Ignition 登录'
- en: '](image/Figure_9.22_B16321.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.22_B16321.jpg)'
- en: Figure 9.22 – Ignition login
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – Ignition 登录
- en: 'You may notice a lack of functionality, and that is because BurpSuite has intercepted
    the **GET** request that you just initiated. If BurpSuite didn''t automatically
    pop up when it should have, you can simply navigate to it and click the **Proxy**
    tab and then the **Intercept** sub-tab:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到功能缺失，这是因为 BurpSuite 已经拦截了您刚刚发起的 **GET** 请求。如果 BurpSuite 没有在该出现的时候自动弹出，您可以直接导航到它并点击
    **Proxy** 标签，然后点击 **Intercept** 子标签：
- en: '![Figure 9.23 – Login intercept'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.23 – 登录拦截'
- en: '](image/Figure_9.23_B16321.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.23_B16321.jpg)'
- en: Figure 9.23 – Login intercept
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 登录拦截
- en: 'If we look a little closer at the details, we will find that by simply opening
    the login screen, we kick off a bunch of traffic, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微仔细查看细节，会发现仅仅打开登录界面就会启动一大堆流量，如下所示：
- en: GET /idp/default/authn/login?app=gateway&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74
    Xz1TcxT7cnQ&token=GH3KbGJqdSGsTTUQNDqKB7WFLR0NOoJgwFni Bohji40&response_type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZyI 6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncmZ
    nakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9wI1fdM1wsPJgxpM&prompt=login&max_age=1
    HTTP/1.1
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GET /idp/default/authn/login?app=gateway&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74
    Xz1TcxT7cnQ&token=GH3KbGJqdSGsTTUQNDqKB7WFLR0NOoJgwFni Bohji40&response_type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZyI 6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncmZ
    nakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9wI1fdM1wsPJgxpM&prompt=login&max_age=1
    HTTP/1.1
- en: 'Host: 192.168.2.10:8088'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: 192.168.2.10:8088'
- en: 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0)'
- en: Gecko/20100101 Firefox/78.0
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Gecko/20100101 Firefox/78.0
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
- en: 'Accept-Language: en-US,en;q=0.5'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US,en;q=0.5'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'Referer: http://192.168.2.10:8088/idp/default/authn/login?app=gateway&token=KeaSv4c6jR0-KTtpNQ16ob3dYKBs8D9BO1aokZUQ
    il0&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74Xz1TcxT7cnQ&response _type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZy I6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncm
    ZnakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm 0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9w
    I1fdM1wsPJgxpM&prompt=login&max_age=1'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'Referer: http://192.168.2.10:8088/idp/default/authn/login?app=gateway&token=KeaSv4c6jR0-KTtpNQ16ob3dYKBs8D9BO1aokZUQ
    il0&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74Xz1TcxT7cnQ&response _type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZy I6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncm
    ZnakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm 0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9w
    I1fdM1wsPJgxpM&prompt=login&max_age=1'
- en: 'Connection: close'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'Connection: close'
- en: 'Cookie: default.sid=fj0zNMpRCctgmCAWcfJlJwrhPIVrZD-Auda96Bmghk4; JSESSIONID=node01u4ie14zjwage1dqw2zu6fs16q8.node0'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cookie: default.sid=fj0zNMpRCctgmCAWcfJlJwrhPIVrZD-Auda96Bmghk4; JSESSIONID=node01u4ie14zjwage1dqw2zu6fs16q8.node0'
- en: 'Upgrade-Insecure-Requests: 1'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Upgrade-Insecure-Requests: 1'
- en: 'Cache-Control: max-age=0'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cache-Control: max-age=0'
- en: 'Now, try to log in with the **admin**:**admin** credentials. I know that we
    set the real credentials to **scada**:**scada**, but we are going to approach
    this as if we have just discovered the system during a pentest. Also, there is
    a high probability that you could accidentally guess the correct credentials by
    doing this. This is because one of the most prevalent problems in the **Operational
    Technology** (**OT**) space is the continued use of factory credentials. You should
    be sitting on the login screen after filling out these credentials, similar to
    what''s shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用 **admin**:**admin** 凭证登录。我知道我们将真实的凭证设置为 **scada**:**scada**，但我们将假设在进行渗透测试时刚刚发现了这个系统。此外，你很有可能通过这样做意外猜到正确的凭证。这是因为
    **运营技术**（**OT**）领域的一个普遍问题是继续使用工厂凭证。填写这些凭证后，你应该处于登录界面，类似于以下截图所示的状态：
- en: '![Figure 9.24 – admin:admin credentials'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.24 – admin:admin 凭证'
- en: '](image/Figure_9.24_B16321.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.24_B16321.jpg)'
- en: Figure 9.24 – admin:admin credentials
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – admin:admin 凭证
- en: 'Now, we want to navigate to BurpSuite and have a look at the **POST** request
    that we have just intercepted, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要导航到 BurpSuite，查看刚刚拦截到的 **POST** 请求，如下所示：
- en: '![Figure 9.25 – POST request'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.25 – POST 请求'
- en: '](image/Figure_9.25_B16321.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.25_B16321.jpg)'
- en: Figure 9.25 – POST request
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – POST 请求
- en: 'From here, we want to utilize a powerful tool built into BurpSuite known as
    **Repeater**. This allows us to modify and test our request over and over again,
    hence its name. To do this, we are going to right-click and select the **Send
    to Repeater** option, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要利用 BurpSuite 中一个强大的工具，叫做 **Repeater**。它允许我们反复修改并测试请求，因此得名。为此，我们将右键点击并选择
    **Send to Repeater** 选项，如下所示：
- en: '![Figure 9.26 – Send to Repeater'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.26 – 发送到 Repeater'
- en: '](image/Figure_9.26_B16321.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.26_B16321.jpg)'
- en: Figure 9.26 – Send to Repeater
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 发送到 Repeater
- en: 'This will now pass the **POST** request that we intercepted to the **Repeater**
    tool. You should see a screen similar to the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们拦截到的**POST**请求传递到**Repeater**工具。你应该会看到类似以下的界面：
- en: '![Figure 9.27 – Repeater tool'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.27 – Repeater工具'
- en: '](image/Figure_9.27_B16321.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.27_B16321.jpg)'
- en: Figure 9.27 – Repeater tool
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 – Repeater工具
- en: 'Once inside the **Repeater** tool, press the **Send** button to pass the request
    through to the server. Notice the response on the right-hand side of the screen.
    Looking closely, you will see that the message being relayed is **Invalid token**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**Repeater**工具后，按下**发送**按钮将请求传递到服务器。注意屏幕右侧的响应。仔细观察，你会看到传递的信息是**无效令牌**：
- en: '![Figure 9.28 – Invalid token'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28 – 无效令牌'
- en: '](image/Figure_9.28_B16321.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.28_B16321.jpg)'
- en: Figure 9.28 – Invalid token
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 – 无效令牌
- en: 'Looking closer at the request that we just sent with the **Repeater** tool,
    we can see what looks like a **Cross-Site Request Forgery** (**CSRF**) token.
    This makes it much more complex to brute force as now, we have to figure out how
    or what utility Ignition is using to generate these tokens:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察我们刚刚使用**Repeater**工具发送的请求，我们可以看到一个看起来像**跨站请求伪造**（**CSRF**）令牌。这使得暴力破解变得更加复杂，因为现在，我们必须弄清楚Ignition是如何或者通过什么工具生成这些令牌的：
- en: '![Figure 9.29 – CSRF token'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.29 – CSRF令牌'
- en: '](image/Figure_9.29_B16321.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.29_B16321.jpg)'
- en: Figure 9.29 – CSRF token
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 – CSRF令牌
- en: 'Knowing that we are going to have to find the source of the token''s generation
    means deeper investigation on our side. Let''s start by going back to our **Proxy**
    | **HTTP** history and then clicking the **GET** method to show the details of
    our **Request** and **Response**, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们需要找到令牌生成的源头意味着我们需要进行更深的调查。让我们从回到**代理** | **HTTP**历史开始，然后点击**GET**方法，显示我们的**请求**和**响应**的详细信息，如下图所示：
- en: '![Figure 9.30 – HTTP history'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.30 – HTTP历史'
- en: '](image/Figure_9.30_B16321.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.30_B16321.jpg)'
- en: Figure 9.30 – HTTP history
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 – HTTP历史
- en: 'Nothing pops out as being of interest to us in this particular session. Somewhere
    inside this exchange of various **Requests**, where the CSRF token has to have
    been created and shared, click on the **POST** method above the **GET** request,
    as shown in the following screenshot, to see if this happens to reveal any clues
    about the token''s creation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的会话中，并没有什么特别引起我们注意的地方。在这些不同的**请求**交换过程中，应该是创建并共享了CSRF令牌，在这个过程中，点击**GET**请求上方的**POST**方法，如下图所示，看看是否能发现任何关于令牌创建的线索：
- en: '![Figure 9.31 – POST request'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.31 – POST请求'
- en: '](image/Figure_9.31_B16321.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.31_B16321.jpg)'
- en: Figure 9.31 – POST request
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 – POST请求
- en: 'OK, this looks very promising as we can see a token being passed in the response
    from **/idp/default/authn/next-challenge**. It looks like the token that''s required
    in the username-password **POST** request, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这看起来很有希望，因为我们可以看到一个令牌从**/idp/default/authn/next-challenge**的响应中传递出来。它看起来像是用户名-密码**POST**请求中需要的令牌，如下图所示：
- en: '![Figure 9.32 – The next-challenge token'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.32 – 下一个挑战令牌'
- en: '](image/Figure_9.32_B16321.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.32_B16321.jpg)'
- en: Figure 9.32 – The next-challenge token
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 – 下一个挑战令牌
- en: 'Now, right-click **Request** and send it to **Repeater**, as we did previously,
    to try and generate the **next-challenge** token. Once you are back inside the
    **Repeater** tab, go ahead and press **Send** to test the **POST** request. You
    should see an output similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键点击**请求**并将其发送到**Repeater**，就像之前那样，尝试生成**下一个挑战**令牌。返回到**Repeater**标签后，按下**发送**按钮以测试**POST**请求。你应该会看到类似以下的输出：
- en: '![Figure 9.33 – Resend token'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33 – 重新发送令牌'
- en: '](image/Figure_9.33_B16321.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.33_B16321.jpg)'
- en: Figure 9.33 – Resend token
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 – 重新发送令牌
- en: 'Once again, we have an **Invalid token** message, which means that our **Request**
    token has expired. We need to go back further to see how our **next-challenge**
    token is generated. Navigate back to **Proxy** | **Http history** and look at
    the requests prior to the **next-challenge** POST request. In the following screenshot,
    we can see that there are a series of **GET** requests before a previous **next-challenge**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们收到了**无效的令牌**消息，这意味着我们的**请求**令牌已经过期。我们需要进一步追溯，查看我们的**下一个挑战**令牌是如何生成的。返回到**代理**
    | **HTTP 历史**，查看**下一个挑战**POST请求之前的请求。在下图中，我们可以看到在之前的**下一个挑战**之前有一系列**GET**请求：
- en: '![Figure 9.34 – The oidc GET request'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.34 – oidc GET请求'
- en: '](image/Figure_9.34_B16321.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.34_B16321.jpg)'
- en: Figure 9.34 – The oidc GET request
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.34 – oidc GET 请求
- en: 'There''s one very interesting **GET** request here, and it happens to contain
    **oidc** in the path. **OpenID Connect** (**OIDC**) is used to verify users that
    are attempting to authenticate to a web application securely and easily. To read
    more about **oidc**, take a look at [https://www.onelogin.com/blog/openid-connect-explained-in-plain-english](https://www.onelogin.com/blog/openid-connect-explained-in-plain-english).
    For our uses, all we need to know is that this is most likely the starting point
    for creating our tokens. Now, upon clicking on this **GET** method, we will see
    the following **Request** and **Response** output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常有趣的**GET**请求，它恰好在路径中包含**oidc**。**OpenID Connect**（**OIDC**）用于验证尝试安全、轻松地进行身份验证的用户。如果想了解更多关于**oidc**的信息，可以查看[https://www.onelogin.com/blog/openid-connect-explained-in-plain-english](https://www.onelogin.com/blog/openid-connect-explained-in-plain-english)。就我们的用途而言，我们只需要知道这是创建我们令牌的起点。现在，点击这个**GET**方法，我们将看到以下**请求**和**响应**输出：
- en: '![Figure 9.35 – OIDC 302 error'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.35 – OIDC 302 错误'
- en: '](image/Figure_9.35_B16321.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.35_B16321.jpg)'
- en: Figure 9.35 – OIDC 302 error
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.35 – OIDC 302 错误
- en: 'As you can see, we get a response code of **302**, and deeper inside **Location:**,
    we can see our **next-challenge** token. For a third time now, let''s send our
    **Request** to the **Repeater** tool and push the **Send** button. You will receive
    the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到一个响应代码**302**，并且在**Location:**字段中，我们可以看到我们的**next-challenge**令牌。现在，再次点击发送我们的**请求**到**Repeater**工具，并点击**发送**按钮。你将收到以下输出：
- en: '![Figure 9.36 – OIDC next-challenge token'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.36 – OIDC 下一挑战令牌'
- en: '](image/Figure_9.36_B16321.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.36_B16321.jpg)'
- en: Figure 9.36 – OIDC next-challenge token
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.36 – OIDC 下一挑战令牌
- en: 'This is very promising, as we can now see that a new token has been created
    and that there are no failure messages. The great part about the **Repeater**
    tool is that we can edit data and resend it to see how that input data affects
    the response. Go ahead and press **Send** a few times; you will notice that the
    only thing that changes is that specific token. Now, if you have been following
    along so far, you should have three tabs in your **Repeater** header:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有希望，因为我们现在可以看到已经创建了一个新令牌，并且没有错误信息。**Repeater**工具的优点是我们可以编辑数据并重新发送，查看输入数据如何影响响应。继续点击**发送**几次；你会注意到唯一变化的就是那个特定的令牌。现在，如果你一直跟着操作，你的**Repeater**标签中应该有三个标签：
- en: '![Figure 9.37 – Three Repeater sessions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.37 – 三个重复器会话'
- en: '](image/Figure_9.37_B16321.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.37_B16321.jpg)'
- en: Figure 9.37 – Three Repeater sessions
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.37 – 三个重复器会话
- en: 'The **Repeater** tool will keep track of the requests that we sent in the previous
    steps, which makes it a very useful tool for testing our theory regarding CRSF
    token creation. With that said, press **Send** one more time to generate a fresh
    **oidc** token. Copy the dedicated token, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Repeater**工具会跟踪我们在之前步骤中发送的请求，这使得它成为一个非常有用的工具，帮助我们测试关于CRSF令牌生成的理论。话虽如此，再点击一次**发送**按钮以生成一个新的**oidc**令牌。复制专用的令牌，如下截图所示：'
- en: '![Figure 9.38 – OIDC token generation'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.38 – OIDC 令牌生成'
- en: '](image/Figure_9.38_B16321.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.38_B16321.jpg)'
- en: Figure 9.38 – OIDC token generation
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.38 – OIDC 令牌生成
- en: 'Now, we want to click on the tab labeled with the number **2**. You will see
    our previous failed attempt at generating a **next-challenge** token. Replace
    the token under **Request** with our newly generated **oidc** token, as shown
    in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要点击标有数字**2**的标签。你将看到我们之前生成**next-challenge**令牌失败的尝试。用我们新生成的**oidc**令牌替换**请求**中的令牌，如下截图所示：
- en: '![Figure 9.39 – Replacing the failed token with a new oidc token'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.39 – 用新 oidc 令牌替换失败的令牌'
- en: '](image/Figure_9.39_B16321.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.39_B16321.jpg)'
- en: Figure 9.39 – Replacing the failed token with a new oidc token
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.39 – 用新 oidc 令牌替换失败的令牌
- en: 'Resend the request. If you followed along and performed these steps correctly,
    you should get a **200** response, which will look similar to this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发送请求。如果你按照步骤正确操作，你应该会得到一个**200**响应，内容类似如下：
- en: '![Figure 9.40 – 200 response'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.40 – 200 响应'
- en: '](image/Figure_9.40_B16321.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.40_B16321.jpg)'
- en: Figure 9.40 – 200 response
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.40 – 200 响应
- en: 'Excellent! Now, we are stepping in the right direction. From here, we want
    to copy our newly generated **next-challenge** token and click the **Repeater**
    tab labeled with the number **1**. You will see our original failed **username-password-challenge**
    attempt with a response message of **Invalid token**. Replace the CSRF token with
    our generated **next-challenge** token. Our **Request** should appear as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们正朝着正确的方向前进。从这里开始，我们需要复制我们新生成的**next-challenge**令牌，并点击标记为**1**的**重复器**标签。你会看到我们最初失败的**用户名密码挑战**尝试，响应消息为**无效令牌**。用我们生成的**next-challenge**令牌替换
    CSRF 令牌。我们的**请求**应该如下所示：
- en: '![Figure 9.41 – username-password-challenge new token'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.41 – 用户名密码挑战 新令牌'
- en: '](image/Figure_9.41_B16321.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.41_B16321.jpg)'
- en: Figure 9.41 – username-password-challenge new token
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.41 – 用户名密码挑战 新令牌
- en: 'Now, resend this **Request**; you should see a **200** response, indicating
    that we passed a valid CSRF token and have returned a JSON response. In the output,
    we can see that **success** was **false**, meaning that the credentials we used
    were wrong, which we knew would be the case, and also a valid **Response** token,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新发送这个**请求**；你应该看到一个**200**响应，表示我们传递了一个有效的 CSRF 令牌，并且返回了 JSON 响应。在输出中，我们可以看到**success**为**false**，这意味着我们使用的凭证是错误的，这是我们预期的结果，同时也看到一个有效的**响应**令牌，如下所示：
- en: '![Figure 9.42 – Bypassing the CSRF token'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.42 – 绕过 CSRF 令牌'
- en: '](image/Figure_9.42_B16321.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.42_B16321.jpg)'
- en: Figure 9.42 – Bypassing the CSRF token
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.42 – 绕过 CSRF 令牌
- en: 'We now want to verify if our theory is truly correct. Seeing as we installed
    Ignition with the credentials of **scada**:**scada** inside our **Industrial Control
    System** (**ICS**) lab, let''s rerun our steps to verify that everything works
    as expected. You should see the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要验证我们的理论是否正确。鉴于我们在**工业控制系统**（**ICS**）实验室中使用**scada**:**scada**凭证安装了 Ignition，我们重新执行步骤以验证一切是否如预期工作。你应该看到以下输出：
- en: '![Figure 9.43 – Successful authentication'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.43 – 成功认证'
- en: '](image/Figure_9.43_B16321.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.43_B16321.jpg)'
- en: Figure 9.43 – Successful authentication
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.43 – 成功认证
- en: 'And just like that, we''ve found a way to generate unique CSRF tokens and brute
    force the auth of Ignition. Now, beyond the euphoria of thwarting CRSF, we realize
    that manually doing this would take a lifetime, and we just don''t have that luxury
    of time during a pentesting engagement. Using BurpSuite, we have various ways
    of automating these steps. If you are using the Pro version, you can **Generate
    CSRF PoC** by navigating to the following menu:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们找到了生成唯一 CSRF 令牌并暴力破解 Ignition 认证的方法。现在，除了击败 CRSF 的兴奋感，我们意识到手动执行这个过程将需要一生的时间，而在渗透测试过程中我们根本没有这么多时间。因此，使用
    BurpSuite，我们有多种方法来自动化这些步骤。如果你使用的是专业版，你可以通过以下菜单**生成 CSRF PoC**：
- en: '![Figure 9.44 – Pro version – Generate CSRF PoC'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.44 – 专业版 – 生成 CSRF PoC'
- en: '](image/Figure_9.44_B16321.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.44_B16321.jpg)'
- en: Figure 9.44 – Pro version – Generate CSRF PoC
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.44 – 专业版 – 生成 CSRF PoC
- en: 'As you can see, though, I am using the Community Edition, which means that
    I can use **Session Rules** to run various macros or import a Burp extension such
    as **Custom Parameter Handler**, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我正在使用社区版，这意味着我可以使用**会话规则**来运行各种宏，或导入 Burp 扩展，比如**自定义参数处理器**，如下图所示：
- en: '![Figure 9.45 – Custom Parameter Handler'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.45 – 自定义参数处理器'
- en: '](image/Figure_9.45_B16321.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.45_B16321.jpg)'
- en: Figure 9.45 – Custom Parameter Handler
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.45 – 自定义参数处理器
- en: However, due to the throttled limitations of the Community Edition, this type
    of attack would take forever – maybe not as long as manually running the attack,
    but far too long for our requirements. So, the suggestion is either to upgrade
    to the Pro version or write your own script. We will be doing this in the next
    section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于社区版的限制，这种攻击方法将需要很长时间 – 可能没有手动执行攻击那么久，但对于我们的需求来说，时间仍然太长。因此，建议要么升级到专业版，要么编写自己的脚本。我们将在下一部分进行这一操作。
- en: Building a script for brute-forcing SCADA
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为暴力破解 SCADA 编写脚本
- en: 'I am going to assume that by reading this book, you have a relative level of
    proficiency or exposure to programming/bash scripting. If not, I strongly recommend
    brushing up on bash scripting and/or Python. Two books that I personally recommend
    are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设通过阅读本书，你对编程/bash 脚本有一定的熟悉程度。如果没有，我强烈建议你复习一下 bash 脚本和/或 Python。以下是我个人推荐的两本书：
- en: '*Cybersecurity Ops with bash*, by Paul Troncone and Carl Albing, PhD'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用bash进行网络安全操作*，作者Paul Troncone和Carl Albing，博士'
- en: '*Black Hat Python*, by Justin Seitz'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*黑帽Python*，作者Justin Seitz'
- en: These are great resources for you to get a good idea of how and what Bash and
    Python can do and perform. The biggest takeaway is that by reading this book and
    going through these chapters, you will learn how to make these scripting/programming
    languages useful inside your pentesting engagement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您了解Bash和Python可以做什么以及如何执行的好资源。最重要的是，通过阅读这本书并阅读这些章节，您将学会如何使这些脚本/编程语言在您的渗透测试中发挥作用。
- en: I prefaced this section with the preceding note as I am going to try and make
    this process as painless as possible. As a disclaimer, I have to say that I am
    a developer at best, not a programmer by any means. I am making this distinction
    as programmers who decide to make their career by building test-driven programs
    will review my code and have a good chuckle. However, I can say that I can get
    from point A to point B with my code and frankly, the end result is all I care
    about.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节之前加了上述说明，因为我将尽力使这个过程尽可能轻松。作为免责声明，我必须说我最多只是一个开发者，绝不是程序员。我之所以要做出这种区分，是因为决定通过构建测试驱动程序来开展职业生涯的程序员将审查我的代码并会心一笑。然而，我可以说我可以通过我的代码从A点到B点，坦率地说，最终结果才是我关心的。
- en: 'With that said, let''s jump right in, shall we? The quickest way is by starting
    with the **Repeater** tool, navigating to the **Request** column, and specifically
    starting with the **/idp/default/oidc/auth?** request, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们开始吧？最快的方法是从**Repeater**工具开始，导航到**Request**列，并具体从**/idp/default/oidc/auth?**请求开始，如下截图所示：
- en: '![Figure 9.46 – OIDC request'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.46 – OIDC请求'
- en: '](image/Figure_9.46_B16321.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.46_B16321.jpg)'
- en: Figure 9.46 – OIDC request
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.46 – OIDC请求
- en: 'Now, we want to right-click on **Request**. You will be presented with a context
    menu where you have the option to **Copy as curl command**, as shown in the following
    screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要右键单击**Request**。您将看到一个上下文菜单，您可以选择**复制为curl命令**，如下截图所示：
- en: '![Figure 9.47 – Right-clicking Request'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.47 – 右键单击请求'
- en: '](image/Figure_9.47_B16321.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.47_B16321.jpg)'
- en: Figure 9.47 – Right-clicking Request
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.47 – 右键单击请求
- en: 'Open a terminal and test what you have copied as a **curl** command by pasting
    it into the command line and running it. You should see the following results.
    Here, we will focus on the token that was generated. This should match what we
    performed in the previous section using the **Repeater** tool:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端，并通过将其粘贴到命令行并运行来测试您复制的**curl**命令。您应该看到以下结果。在这里，我们将专注于生成的令牌。这应该与我们在上一节中使用**Repeater**工具执行的内容相匹配：
- en: '![Figure 9.48 – curl OIDC request'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.48 – curl OIDC请求'
- en: '](image/Figure_9.48_B16321.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.48_B16321.jpg)'
- en: Figure 9.48 – curl OIDC request
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48 – curl OIDC请求
- en: 'Run the command a few more times and analyze the results. You should see that
    this token has been uniquely generated. Awesome – now what? You must create a
    **bash** file with your favorite editor! I will be using nano for simplicity''s
    sake. Run the following command in your terminal:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行命令并分析结果。您应该看到此令牌已被唯一生成。太棒了 - 现在怎么办？您必须使用您喜爱的编辑器创建一个**bash**文件！为了简单起见，我将使用nano。在您的终端中运行以下命令：
- en: nano exploit.sh
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: nano exploit.sh
- en: 'This will bring up the nano editor. Here, we will want to paste in the **curl**
    command that we were just using. Next, we want to wrap our **curl** command in
    an **eval** statement and **grep** out our token, as shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开nano编辑器。在这里，我们要粘贴刚刚使用的**curl**命令。接下来，我们要将我们的**curl**命令包装在**eval**语句中，并使用**grep**提取我们的令牌，如下截图所示：
- en: '![Figure 9.49 – Our bash OIDC token script'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.49 – 我们的bash OIDC令牌脚本'
- en: '](image/Figure_9.49_B16321.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.49_B16321.jpg)'
- en: Figure 9.49 – Our bash OIDC token script
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.49 – 我们的bash OIDC令牌脚本
- en: 'Taking a closer look at the specific commands, you can see that we are assigning
    our **curl** command to a variable called **oidc_cmd**. Then, we are running **eval**
    against the command and piping it into the **grep** command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下具体的命令，您会看到我们将我们的**curl**命令分配给一个名为**oidc_cmd**的变量。然后，我们对该命令运行**eval**并将其传输到**grep**命令中：
- en: oidc_token=$(eval $oidc_cmd | grep -oP '(?<=c\&token=).*(?=\&response)')
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: oidc_token=$(eval $oidc_cmd | grep -oP '(?<=c\&token=).*(?=\&response)')
- en: We are grepping to find a string that is in-between **c&token=** and **&response**
    from our **curl** response. It is important to note that the **c** character in
    the preceding command is the last character from the previous token, so it may
    need to be adjusted before you run this script. It is important to add this character
    here in the **grep** statement as the **curl** response generates two tokens,
    and we are only concerned with our **oidc** token.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用grep查找位于**c&token=**和**&response**之间的字符串，它来自我们**curl**的响应。需要注意的是，前一个命令中的**c**字符是前一个令牌的最后一个字符，因此在运行此脚本之前，可能需要对其进行调整。务必在**grep**语句中添加此字符，因为**curl**响应生成了两个令牌，我们只关心我们的**oidc**令牌。
- en: 'Now, go ahead and test the script you just created by running the following
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续测试你刚刚创建的脚本，运行以下命令：
- en: bash exploit.sh
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: bash exploit.sh
- en: 'You should see the following output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 9.50 – OIDC token created'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.50 – 创建的 OIDC 令牌'
- en: '](image/Figure_9.50_B16321.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.50_B16321.jpg)'
- en: Figure 9.50 – OIDC token created
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.50 – 创建的 OIDC 令牌
- en: 'Now, let''s repeat the same steps with the request for **/idp/default/authn/next-challenge**
    by right-clicking **Request** under the **Repeater** tool in BurpSuite and then
    selecting **Copy as curl command**. We must paste this into our text editor and
    wrap it, as we did previously. However, this time, we need to pass **oidc_token**
    as a parameter into the newly wrapped **curl** command, as shown in the following
    screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重复相同的步骤，右键点击 BurpSuite 中**Repeater**工具下的**Request**，然后选择**Copy as curl
    command**来请求**/idp/default/authn/next-challenge**。我们必须将其粘贴到文本编辑器中并进行封装，正如我们之前所做的那样。然而，这一次，我们需要将**oidc_token**作为参数传递到新封装的**curl**命令中，如以下屏幕截图所示：
- en: '![Figure 9.51 – The next-challenge token script'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.51 – next-challenge 令牌脚本'
- en: '](image/Figure_9.51_B16321.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.51_B16321.jpg)'
- en: Figure 9.51 – The next-challenge token script
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.51 – next-challenge 令牌脚本
- en: Comparing our **grep** statements between the two commands shows us that there
    is a slight variation, since the response from the **/next-challenge** request
    returns the output as a JSON object, so we need to parse it out accordingly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两条命令中的**grep**语句可以看出，它们之间存在轻微的差异，因为**/next-challenge**请求的响应以 JSON 对象的形式返回，因此我们需要相应地解析它。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you get stuck here and you can't get **/next-challenge** to provide you with
    a **200** response code so that you can find this token, you may have to refresh
    your session ID for the **default.sid** cookie by refreshing the Ignition login
    screen, capturing the request in BurpSuite, and updating your **default.sid**
    value for each **curl** request. You will know right away that you need to refresh
    if you get a response code of **400** and a message of **Invalid Session**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这里遇到问题，无法让**/next-challenge**提供**200**响应代码，从而找到此令牌，可能需要通过刷新 Ignition 登录屏幕来刷新**default.sid**的会话
    ID，捕获 BurpSuite 中的请求，然后更新每个**curl**请求的**default.sid**值。如果你收到**400**响应代码并显示**Invalid
    Session**消息，那么你就知道需要刷新了。
- en: 'If you have followed along, copied everything, and have a valid session ID,
    you should see the following output as you run your exploit:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟着操作，复制了所有内容，并且拥有有效的会话 ID，那么在运行你的利用脚本时，你应该看到以下输出：
- en: '![Figure 9.52 – The next-challenge token generated'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.52 – 生成的 next-challenge 令牌'
- en: '](image/Figure_9.52_B16321.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.52_B16321.jpg)'
- en: Figure 9.52 – The next-challenge token generated
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.52 – 生成的 next-challenge 令牌
- en: 'At this point, you should have the **oidc** token and the **next-challenge**
    token. Now, it is time to pass the newly generated **next-challenge** token into
    the auth request. Repeat the steps that we completed previously:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该已经拥有**oidc**令牌和**next-challenge**令牌。现在，是时候将新生成的**next-challenge**令牌传递到
    auth 请求中了。重复我们之前完成的步骤：
- en: Right-click our **/idp/default/authn/submit-username-password-challenge** request.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击我们的**/idp/default/authn/submit-username-password-challenge**请求。
- en: Select **Copy as curl command**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Copy as curl command**。
- en: Paste the **curl** command that you just copied into the text editor.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你刚才复制的**curl**命令粘贴到文本编辑器中。
- en: Wrap the **curl** command for evaluation.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为评估封装**curl**命令。
- en: Pass the **next-challenge** token into the **auth** request.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**next-challenge**令牌传递给**auth**请求。
- en: Update **default.sid** if it has timed out.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果超时，请更新**default.sid**。
- en: 'The **auth** section of your exploit script should look similar to the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你的利用脚本中的**auth**部分应该类似于以下内容：
- en: '![Figure 9.53 – auth command'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.53 – auth 命令'
- en: '](image/Figure_9.53_B16321.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.53_B16321.jpg)'
- en: Figure 9.53 – auth command
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.53 – auth 命令
- en: 'Here, you can see that we are hardcoding the default creds of **scada**:**scada**
    to test if our script is successful. If everything is correct and **default.sid**
    is still valid, when you run the script, your output should appear like so:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们将默认的凭据 **scada**:**scada** 硬编码以测试我们的脚本是否成功。如果一切正常，并且 **default.sid**
    仍然有效，当你运行脚本时，输出应如下所示：
- en: '![Figure 9.54 – Successful authentication'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.54 – 成功的身份验证'
- en: '](image/Figure_9.54_B16321.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.54_B16321.jpg)'
- en: Figure 9.54 – Successful authentication
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.54 – 成功的身份验证
- en: We can refactor the parameters that we know will change from engagement to engagement.
    I used the **host**, **sid**, **user**, and **pass** parameters.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构那些我们知道会在不同测试中发生变化的参数。我使用了 **host**、**sid**、**user** 和 **pass** 参数。
- en: 'We know from past pentest engagements that customers will change their host
    address, so we should create a variable to handle this. We know that an initial
    **default.sid** is created that we need to pass through all three requests, so
    we will create a variable for this behavior. Our username and password should
    both have variables as well. Here is what the initial refactor looks like:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从过去的渗透测试经验中知道，客户会更改他们的主机地址，因此我们应该创建一个变量来处理这个问题。我们知道需要创建一个初始的 **default.sid**，并且我们需要将其传递给所有三个请求，所以我们将为此行为创建一个变量。我们的用户名和密码也应该分别有变量。以下是初始重构的样子：
- en: '![Figure 9.55 – Script refactor'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.55 – 脚本重构'
- en: '](image/Figure_9.55_B16321.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.55_B16321.jpg)'
- en: Figure 9.55 – Script refactor
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.55 – 脚本重构
- en: 'We need to test our results post-refactoring to verify that we haven''t broken
    anything. So, run the exploit script; you should get something similar to the
    following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试重构后的结果，以验证我们没有破坏任何内容。所以，运行 exploit 脚本，你应该会得到类似以下的结果：
- en: '![Figure 9.56 – Post-refactor test'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.56 – 重构后的测试'
- en: '](image/Figure_9.56_B16321.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.56_B16321.jpg)'
- en: Figure 9.56 – Post-refactor test
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.56 – 重构后的测试
- en: 'Now, this section''s title has "brute-forcing" in it. This means we need to
    incorporate a way to read a list of users and passwords and attempt to authenticate
    against Ignition''s login screen. I took the liberty of refactoring yet again
    and removing some of the unnecessary headers that were being passed, and I also
    wrapped the three curl requests into a function, as shown here:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一节的标题中有“穷举”的字样。这意味着我们需要结合一种方法来读取用户和密码的列表，并尝试在 Ignition 的登录页面上进行身份验证。我再次进行了重构，移除了传递的一些不必要的头部信息，并且将三个
    curl 请求封装成了一个函数，如下所示：
- en: '![Figure 9.57 – test_auth function'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.57 – test_auth 函数'
- en: '](image/Figure_9.57_B16321.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.57_B16321.jpg)'
- en: Figure 9.57 – test_auth function
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.57 – test_auth 函数
- en: 'Here, you can see that **next_cmd** and **auth_cmd** have drastically been
    reduced in size. From here, we need to build out a way to read a list of users
    and a list of passwords. We want to add the ability to open a file, read it line
    by line, and pass it to the variables that we declared earlier. Using the following
    pseudocode, we can adjust it to our needs:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 **next_cmd** 和 **auth_cmd** 的大小大大缩小。从这里开始，我们需要构建一种方法来读取用户列表和密码列表。我们希望添加打开文件、逐行读取并将其传递给我们之前声明的变量的功能。使用以下伪代码，我们可以根据需要调整：
- en: while IFS='' read -r user || [[ -n "${user}" ]]; do
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: while IFS='' read -r user || [[ -n "${user}" ]]; do
- en: test_auth
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: test_auth
- en: if [[ $success == "true" ]]; then
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: if [[ $success == "true" ]]; then
- en: echo $output
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: echo $output
- en: fi
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: fi
- en: done < $1
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: done < $1
- en: 'The general idea here is that we are going to pass in a filename for users.
    Then, a **while** loop will iterate through each user, set our **$user** variable,
    and launch the **test_auth** function, which will kick off the token''s creation
    and auth attempt. Run the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思路是我们将为用户传入一个文件名。然后，**while** 循环将遍历每个用户，设置我们的 **$user** 变量，并启动 **test_auth**
    函数，后者将开始令牌的创建和身份验证尝试。运行以下命令：
- en: bash exploit.sh users.txt
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: bash exploit.sh users.txt
- en: 'This will allow us to pass **users.txt** to the **while** loop and have an
    **internal field separator** (**IFS**) iterate through the individual users. Inside
    **users.txt**, we have three usernames – **"plc"**, **"scada"**, and **"test"**
    – to make things simple. I have also taken the liberty of baking in reading a
    password file and creating some verbosity. Have a look at the following code sample:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们将 **users.txt** 传递给 **while** 循环，并让 **internal field separator** (**IFS**)
    遍历每个用户。在 **users.txt** 中，我们有三个用户名 – **"plc"**、**"scada"** 和 **"test"**，以简化操作。我还额外增加了读取密码文件和创建一些详细信息的功能。请查看以下代码示例：
- en: '![Figure 9.58 – Brute-forcing the username and password'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.58 – 穷举用户名和密码'
- en: '](image/Figure_9.58_B16321.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.58_B16321.jpg)'
- en: Figure 9.58 – Brute-forcing the username and password
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.58 – 暴力破解用户名和密码
- en: 'The command you should run now is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该运行的命令如下：
- en: bash exploit.sh users.txt passwords.txt -v
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: bash exploit.sh users.txt passwords.txt -v
- en: 'Inside **passwords.txt**, for simplicity''s sake, I only added four passwords,
    and they were **"admin"**, **"password"**, **"scada"**, and **"changeme"**. Running
    the preceding command should generate the following output, whereby we get a successful
    authentication:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在**passwords.txt**中，为了简便起见，我只添加了四个密码，它们分别是**"admin"**、**"password"**、**"scada"**和**"changeme"**。运行上述命令应该会生成以下输出，其中我们成功进行了身份验证：
- en: '![Figure 9.59 – Successful authentication'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.59 – 成功的身份验证'
- en: '](image/Figure_9.59_B16321.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.59_B16321.jpg)'
- en: Figure 9.59 – Successful authentication
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.59 – 成功的身份验证
- en: Here, you have a fully baked brute-forcing script. We created **oidc** tokens
    and used them to autogenerate CSRF tokens, as well as to test usernames and passwords
    against the Ignition SCADA system with our newly minted script.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经有了一个完全成熟的暴力破解脚本。我们创建了**oidc**令牌，并用它们自动生成 CSRF 令牌，还用新编写的脚本对用户名和密码进行了测试，验证了
    Ignition SCADA 系统的安全性。
- en: Disclaimer
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明
- en: Before sounding alarm bells and submitting vulns to your local **Computer Emergency
    Response Team** (**CERT**), Inductive Automation has implemented server-side mitigations
    for brute-forcing attempts. If you try your known username with five incorrect
    passwords, Ignition will lock out that account for 5 minutes from the time you
    made your last attempt.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在响起警报并向本地**计算机应急响应团队**（**CERT**）提交漏洞之前，Inductive Automation 已经为暴力破解攻击实施了服务器端的缓解措施。如果你使用已知的用户名尝试五次错误密码，Ignition
    会在你最后一次尝试后 5 分钟内锁定该账户。
- en: So, unless you have a well-curated list of users and a laser-focused password
    list, you will have to adjust your script to accommodate the fact that you will
    lock out any real accounts for every five failed attempts for 5 minutes. Not to
    mention that this type of brute-forcing at this level is bound to be picked up
    by an IDS if you haven't done your due diligence, which was mentioned in [*Chapter
    6*](B16321_06_Epub_AM.xhtml#_idTextAnchor063), *Packet Deep Dive*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除非你有一个精心整理的用户列表和一个高度集中的密码列表，否则你将不得不调整脚本，以适应每五次失败尝试就锁定任何真实账户 5 分钟的事实。更不用说，如果你没有进行充分的工作，暴力破解的这种行为很可能会被
    IDS 发现，这一点在[*第 6 章*](B16321_06_Epub_AM.xhtml#_idTextAnchor063)，*数据包深入分析*中已提到。
- en: Now, the irony here is that if you were to adjust your script to intentionally
    lock out real users, it would force someone to authenticate to the server to reboot
    Ignition to override these lockouts. This would ultimately cause a **Denial Of
    Service** (**DOS**) against the SCADA server.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，讽刺的是，如果你调整脚本故意锁定真实用户，它将迫使某人进行身份验证以重启 Ignition，从而覆盖这些锁定。这最终会对 SCADA 服务器造成**拒绝服务**（**DOS**）攻击。
- en: In this section, we went through the steps of pulling information out of BurpSuite
    and translating it into a useful brute-forcing tool. We built on skills that we
    covered in earlier chapters and then extended our knowledge by working around
    client-side token generation. This is a very important skill to learn when it
    comes to pentesting, understanding your environment, and extracting as much information
    as possible to open doors that, at a glance, appear to be locked.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们讲解了如何从 BurpSuite 中提取信息并将其转化为有用的暴力破解工具。我们在前几章中涵盖的技能基础上进行了扩展，通过绕过客户端令牌生成拓宽了我们的知识。这是进行渗透测试时非常重要的一项技能，它帮助你理解环境，并尽可能多地提取信息，以打开那些乍一看似乎被锁住的门。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I feel that we have covered a lot in this chapter, from installing FoxyProxy
    and using BurpSuite to capture and replay requests, to formulating how Ignition
    SCADA handles authentication and extracting that knowledge and building scriptable
    tools to help automate and generate tokens for brute forcing. You will definitely
    use each and every one of these tools and techniques throughout your career.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我们在本章中涵盖了很多内容，从安装 FoxyProxy 和使用 BurpSuite 捕获并重放请求，到制定 Ignition SCADA 如何处理身份验证、提取知识并构建可编写脚本的工具来帮助自动化和生成暴力破解的令牌。你肯定会在你的职业生涯中使用这些工具和技巧。
- en: In the next chapter, we will be using everything we have learned up to this
    point to perform a pseudo mock pentest against our ICS lab.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用到目前为止学到的所有知识，对我们的 ICS 实验室进行伪模拟渗透测试。
