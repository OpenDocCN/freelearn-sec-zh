- en: Pentesting CMSes - Drupal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渗透测试CMS - Drupal
- en: In the previous chapter, we explained how to perform penetration testing on
    Joomla websites. There's quite a difference between WordPress, Joomla, and Drupal,
    especially in terms of security and architecture. In this chapter, we will be
    learning about Drupal, its architecture, and how we can test a Drupal-based website.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解释了如何对Joomla网站进行渗透测试。WordPress、Joomla和Drupal之间存在相当大的差异，特别是在安全性和架构方面。在本章中，我们将学习有关Drupal、其架构以及如何测试基于Drupal的网站的内容。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Drupal and its architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal及其架构简介
- en: Drupal reconnaissance and enumeration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal侦察和枚举
- en: Drupal vulnerability scanning using droopescan
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用droopescan进行Drupal漏洞扫描
- en: Exploiting Drupal
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Drupal
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: Some knowledge of PHP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些PHP知识
- en: An understanding of the basics of the Metasploit Framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Metasploit Framework的基础了解
- en: Knowledge of basic Linux commands, such as `grep` and `ag`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解基本的Linux命令，如`grep`和`ag`
- en: An understanding of the basics of Burp Suite
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Burp Suite的基础了解
- en: Introduction to Drupal and its architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal及其架构简介
- en: Drupal is a free and open source **Content Management System** (**CMS**) written
    in PHP. It was originally written by **Dries Buytaert** as a message board, but
    became an open source project in 2001\. Although Drupal is considered a bit tricky
    to use when compared with other CMSes, it does provide a built-in API to facilitate
    the development of custom modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal是一个用PHP编写的免费开源**内容管理系统**（**CMS**）。它最初是由**Dries Buytaert**作为留言板编写的，但在2001年成为一个开源项目。尽管与其他CMS相比，Drupal被认为使用起来有点棘手，但它确实提供了内置的API来促进自定义模块的开发。
- en: Drupal's architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal的架构
- en: 'A general way to describe Drupal''s architecture would be to divide it into
    four major parts, as is the case in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 描述Drupal架构的一般方法是将其分为四个主要部分，如下图所示：
- en: '![](img/d71d78c6-8415-43a1-96b9-6626a2d3383a.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d71d78c6-8415-43a1-96b9-6626a2d3383a.png)'
- en: 'To understand the architecture, let''s first learn about the components of
    Drupal. Drupal''s components are listed here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解架构，首先让我们了解Drupal的组件。Drupal的组件列在这里：
- en: '**Themes:** Themes are collections of files that define the user interface
    of a Drupal website. The files contain code written in PHP, HTML, and JavaScript.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：主题是定义Drupal网站用户界面的文件集合。这些文件包含用PHP、HTML和JavaScript编写的代码。'
- en: '**Modules:** Modules are event-driven code files that can be used to extend
    Drupal''s functionality. Some modules are known core modules that are maintained
    by the Drupal development team as they are an essential part of Drupal''s operation.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：模块是事件驱动的代码文件，可用于扩展Drupal的功能。一些模块是已知的核心模块，由Drupal开发团队维护，因为它们是Drupal运行的重要部分。'
- en: '**Core APIs:** At Drupal''s core are the APIs that are used to communicate
    with content and other modules. These APIs include the following:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心API**：Drupal的核心是用于与内容和其他模块通信的API。这些API包括以下内容：'
- en: '**Database API**: This allows a developer to easily update/modify data in the
    database.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库API**：这允许开发人员轻松更新/修改数据库中的数据。'
- en: '**Caching API**: This API stores page responses so that the browser doesn''t
    have to render pages every time a request is made.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存API**：此API存储页面响应，以便浏览器不必在每次请求时重新渲染页面。'
- en: '**Session Handling API**: This keeps track of different users and their activity
    on the website.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话处理API**：这可以跟踪网站上不同用户及其活动。'
- en: '**Database**: This is where all the data is stored. Drupal supports different
    types of databases, such as MySQL, Postgres, and SQLite.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：这是存储所有数据的地方。Drupal支持不同类型的数据库，如MySQL、Postgres和SQLite。'
- en: Now that we have a basic understanding of Drupal's architecture, let's look
    at the directory structure next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Drupal的架构有了基本了解，让我们接下来看目录结构。
- en: Directory structure
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录结构
- en: 'Drupal has the following directory structure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal具有以下目录结构：
- en: '**Core**: This consists of files used by the default Drupal installation.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心**：这包括默认Drupal安装使用的文件。'
- en: '**Modules**: All the custom-created modules that are installed in Drupal are
    stored here.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：安装在Drupal中的所有自定义模块都存储在这里。'
- en: '**Profiles**: This folder stores the installation profile. The installation
    profile contains information about pre-installed modules, themes, and the configuration
    of the given Drupal site.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：此文件夹存储安装配置文件。安装配置文件包含有关预安装模块、主题和给定Drupal站点配置的信息。'
- en: '**Sites**: This contains site-specific modules in the event that Drupal is
    used with more than one site.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：如果Drupal与多个站点一起使用，则包含特定于站点的模块。'
- en: '**Themes**: The base theme and all other custom themes are stored in this directory.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：基础主题和所有其他自定义主题都存储在此目录中。'
- en: '**Vendors**: This directory contains backend libraries used by Drupal, such
    as Symfony.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商**：此目录包含Drupal使用的后端库，如Symfony。'
- en: 'The directory structure of a default Drupal installation is shown in the following
    screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认Drupal安装的目录结构如下截图所示：
- en: '![](img/d1bf7a31-cca4-4596-b2a0-156a89a49364.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1bf7a31-cca4-4596-b2a0-156a89a49364.png)'
- en: 'Now that we have an idea of the basics of Drupal and its directory structure,
    let''s move on to the next topic: Drupal reconnaissance and enumeration.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Drupal的基础知识和目录结构有了了解，让我们继续下一个主题：Drupal侦察和枚举。
- en: Drupal reconnaissance and enumeration
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal侦察和枚举
- en: As we talked about in earlier chapters, reconnaissance and enumeration is a
    crucial step in any kind of penetration testing. In this section, we will look
    at some of the methods that can be used to identify a Drupal installation and
    the installed version.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所讨论的，侦察和枚举是任何渗透测试的关键步骤。在本节中，我们将看一些可用于识别Drupal安装和已安装版本的方法。
- en: Detection via README.txt
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过README.txt进行检测
- en: 'This is the easiest and the most basic technique. All we have to do is visit
    the `README.txt` page and we will see a line that reads `"Protect files and directories
    from prying eyes"`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单和最基本的技术。我们只需要访问`README.txt`页面，就会看到一行文字，上面写着“保护文件和目录免受窥视”：
- en: '![](img/1abf36c4-7030-48a4-8185-c8ea7708e7cf.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1abf36c4-7030-48a4-8185-c8ea7708e7cf.png)'
- en: This will indicate that the instance is indeed a Drupal instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表明该实例确实是Drupal实例。
- en: Detection via meta tags
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过元标记检测
- en: 'The meta tag with a `name` attribute of `"Generator"` identifies the software
    that is being used to generate a document/web page. The version number is disclosed
    in the `content` attribute of the meta tag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`name`属性为“Generator”的元标记标识用于生成文档/网页的软件。版本号在元标记的`content`属性中公开：
- en: '![](img/49ec88ea-884d-491e-bee6-457eafafb59c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49ec88ea-884d-491e-bee6-457eafafb59c.png)'
- en: Drupal-based websites often have this tag in their source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Drupal的网站通常在其源代码中有这个标签。
- en: Detection via server headers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过服务器标头检测
- en: 'Drupal can also be recognized if one of the following headers exists in the
    server response:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应中存在以下标头之一，也可以识别Drupal：
- en: '**X-Generator HTTP header**: This identifies a Drupal website.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-Generator HTTP标头**：这标识了Drupal网站。'
- en: '**X-Drupal-Cache header**: This header is used by Drupal''s cache. If the header
    value is **X-Drupal-Cache: MISS**, this means that the pages are not served from
    the cached display, and if you see **X-Drupal-Cache: HIT**, this means that the
    pages are served from the cache.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-Drupal-Cache标头**：这个标头由Drupal的缓存使用。如果标头值为**X-Drupal-Cache: MISS**，这意味着页面不是从缓存显示中提供的，如果你看到**X-Drupal-Cache:
    HIT**，这意味着页面是从缓存中提供的。'
- en: '**X-Drupal-Dynamic-Cache header**: The dynamic cache is used by the site to
    load dynamic content (cached pages), with the exception of personalized parts.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-Drupal-Dynamic-Cache标头**：该动态缓存用于加载动态内容（缓存页面），但不包括个性化部分。'
- en: '**Expires: Sun, 19 Nov 1978**.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期：1978年11月19日**。'
- en: 'The following screenshot shows these headers in a server response:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了服务器响应中的这些标头：
- en: '![](img/7fdeff02-29d4-4706-8798-5a9a6dcc56e3.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fdeff02-29d4-4706-8798-5a9a6dcc56e3.png)'
- en: The dynamic cache header `X-Drupal-Dynamic-Cache` was introduced in Drupal version
    8+ and is not available for Drupal version 7 or earlier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal版本8+引入了动态缓存标头`X-Drupal-Dynamic-Cache`，不适用于Drupal版本7或更早版本。
- en: Detection via CHANGELOG.txt
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CHANGELOG.txt检测
- en: 'Sometimes, the `CHANGELOG.txt` file also discloses the version number. This
    file can be found here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`CHANGELOG.txt`文件也会公开版本号。该文件可以在这里找到：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can browse `/CHANGELOG.txt` or `/core/CHANGELOG.txt` to identify the Drupal
    version that''s installed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以浏览`/CHANGELOG.txt`或`/core/CHANGELOG.txt`来识别已安装的Drupal版本：
- en: '![](img/99bfdd0d-92f0-4fe8-a16b-0a58bee864d6.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99bfdd0d-92f0-4fe8-a16b-0a58bee864d6.png)'
- en: In some cases, we may not find the `CHANGELOG.txt` file. In that case, we can
    try the other detection techniques mentioned in this section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能找不到`CHANGELOG.txt`文件。在这种情况下，我们可以尝试本节中提到的其他检测技术。
- en: Detection via install.php
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过install.php检测
- en: 'Although it''s recommended that the `install.php` file is removed after installation,
    developers often leave it on the server. It can be used to find the version number
    of a Drupal installation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管建议在安装后删除`install.php`文件，但开发人员经常将其留在服务器上。它可以用于找到Drupal安装的版本号：
- en: '![](img/432fa7c9-6292-4c5a-834b-ab42cc1158fc.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/432fa7c9-6292-4c5a-834b-ab42cc1158fc.png)'
- en: This method can only be used for Drupal version 8.x.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅适用于Drupal版本8.x。
- en: These detection techniques will only identify whether a site has Drupal installed
    and the version being used if it is installed. It will not find plugins, themes,
    and modules installed in Drupal. To identify plugins, themes, and modules, we
    need to enumerate them. We need to enumerate plugins, themes, and modules because
    these are entry points that can be used by an attacker to take control of a Drupal
    site. As a penetration tester, we need to find vulnerable plugins, themes, and
    modules (with installed versions) and report them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检测技术只能确定站点是否安装了Drupal以及使用的版本。它不会找到Drupal中安装的插件、主题和模块。要识别插件、主题和模块，我们需要枚举它们。我们需要枚举插件、主题和模块，因为这些是攻击者可以利用的入口点，以控制Drupal站点。作为渗透测试人员，我们需要找到有漏洞的插件、主题和模块（已安装的版本）并报告它们。
- en: Plugin, theme, and module enumeration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件、主题和模块枚举
- en: 'There''s a very common technique that is used by almost all the open source
    tools available online right now to enumerate Drupal plugins, themes, and modules.
    For enumeration, we just have to look for the following files in the `themes/`,
    `plugins/`, and `modules/` directories:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在几乎所有在线可用的开源工具都使用了一种非常常见的技术来枚举Drupal插件、主题和模块。要进行枚举，我们只需在`themes/`、`plugins/`和`modules/`目录中寻找以下文件：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `README.txt` file provides plugin, theme, and module versions. It even discloses
    the Drupal version number as well. The `LICENSE.txt` file includes the GNU **General
    Public License** (**GPL**) license. If any of the `plugins/`, `themes/`, or `modules/`
    directories have this file, this means that the specific plugin, theme, or module
    is installed. The `CHANGELOG.txt` file discloses the version number of the installed
    plugin, theme, or module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.txt`文件提供了插件、主题和模块的版本。它甚至还公开了Drupal版本号。`LICENSE.txt`文件包括GNU**通用公共许可证（GPL）**许可证。如果`plugins/`、`themes/`或`modules/`目录中有这个文件，这意味着特定的插件、主题或模块已安装。`CHANGELOG.txt`文件公开了已安装的插件、主题或模块的版本号。'
- en: 'The module name can be found either from the `README.txt` file or from the
    URL itself, as can be seen in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名称可以从`README.txt`文件或URL本身中找到，如下面的屏幕截图所示：
- en: '![](img/f08b6880-a5dc-459e-810f-8966663d79d9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f08b6880-a5dc-459e-810f-8966663d79d9.png)'
- en: For enumeration, we can either write our own Metasploit wrapper module or we
    can use a third-party, open source tool – droopescan. To code our own wrapper,
    we can follow what we did in the previous chapter, [Chapter 8](e13c4d6e-8576-4fc0-aa78-aa4d54536bca.xhtml),
    *Pentesting CMSes – WordPress*. We will now be proceeding with vulnerability scanning
    using droopescan.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举方面，我们可以编写自己的Metasploit包装模块，或者使用第三方开源工具droopescan。要编写自己的包装器，我们可以按照上一章[第8章](e13c4d6e-8576-4fc0-aa78-aa4d54536bca.xhtml)中所做的进行。我们现在将继续使用droopescan进行漏洞扫描。
- en: Drupal vulnerability scanning using droopescan
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用droopescan进行Drupal漏洞扫描
- en: 'There''s no Metasploit module that can perform a vulnerability scan on Drupal.
    As such, we need to use a third-party tool, such as droopescan, to help us find
    vulnerabilities in Drupal. droopescan can be downloaded from [https://github.com/droope/droopescan](https://github.com/droope/droopescan):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Metasploit模块可以对Drupal进行漏洞扫描。因此，我们需要使用第三方工具，如droopescan，来帮助我们发现Drupal中的漏洞。droopescan可以从[https://github.com/droope/droopescan](https://github.com/droope/droopescan)下载：
- en: 'Let''s clone the Git repository of droopescan for installation using the following
    command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令克隆droopescan的Git存储库进行安装：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前命令的输出截图：
- en: '![](img/11fd5fe7-a373-405b-ac8c-eb972a52afe8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11fd5fe7-a373-405b-ac8c-eb972a52afe8.png)'
- en: 'Before running droopescan, we still need to install the necessary Python modules,
    which can be done using the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行droopescan之前，我们仍然需要安装必要的Python模块，可以使用以下命令完成：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once all the packages are installed on the system, we can test the installation
    by executing droopescan using the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统上安装了所有软件包后，我们可以通过执行以下命令来测试安装droopescan：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If there''s an error while executing droopescan, we can execute it using the
    following command as well:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在执行droopescan时出现错误，我们也可以使用以下命令来执行它：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Following the installation of droopescan, we can execute the following command
    to run a vulnerability scan on Drupal:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装droopescan后，我们可以执行以下命令对Drupal进行漏洞扫描：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前命令的输出截图：
- en: '![](img/f166934c-7acd-40ff-9eea-7305462df76c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f166934c-7acd-40ff-9eea-7305462df76c.png)'
- en: droopescan is a plugin-based scanner that identifies vulnerabilities in several
    CMSes, but mainly Drupal. droopescan uses a pre-built word list, and the detection
    of modules, themes, and plugins is done by brute force. So, this all depends on
    how good our word list is. We can find other Drupal-based vulnerability scanners
    as well, which can be used to identify vulnerabilities in Drupal. The only difference
    is the language they are written in (for efficiency) and the word list they use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: droopescan是一个基于插件的扫描器，用于识别多个CMS中的漏洞，但主要是Drupal。droopescan使用预先构建的单词列表，并通过暴力破解来检测模块、主题和插件。因此，这完全取决于我们的单词列表有多好。我们也可以找到其他基于Drupal的漏洞扫描器，用于识别Drupal中的漏洞。唯一的区别是它们所使用的语言（为了效率）和单词列表。
- en: When we have found vulnerabilities in the Drupal CMS, we can move on to finding
    public exploits for them. One of the most famous vulnerabilities is Drupalgeddon.
    In the next section, we will cover the Drupalgeddon2 vulnerability and learn how
    it is exploited.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Drupal CMS中发现漏洞后，我们可以继续寻找它们的公开利用程序。其中最著名的漏洞之一是Drupalgeddon。在接下来的部分中，我们将介绍Drupalgeddon2漏洞，并学习如何利用它。
- en: Exploiting Drupal
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Drupal
- en: 'When exploiting Drupal, the following are the attack vectors that we need to
    keep in mind:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用Drupal时，以下是我们需要牢记的攻击向量：
- en: Enumerating Drupal users for brute-force attacks
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行暴力破解攻击，枚举Drupal用户。
- en: Exploiting Drupal via broken authentication (guessable passwords)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过猜测密码利用Drupal的破损认证
- en: Exploiting plugins, themes, or modules for arbitrary file disclosures and uploads,
    persistent **Cross-Site Scripting** (**XSS**), and more
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用插件、主题或模块进行任意文件泄露和上传、持久性**跨站脚本**（**XSS**）等
- en: Exploiting Drupal core components for SQL injection and **Remote Code Execution**
    (**RCE**)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Drupal核心组件进行SQL注入和**远程代码执行**（**RCE**）
- en: For different versions of Drupal, there are different public exploits that can
    be used. Sometimes, we can get access to a Drupal site using public exploits,
    and other times we have to change the exploits to make them work. It is always
    good practice to understand an exploit first and execute it later. Let's focus
    on the public exploits for Drupalgeddon2 for now.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同版本的Drupal，可以使用不同的公开利用程序。有时，我们可以使用公开利用程序访问Drupal站点，而其他时候我们必须更改利用程序使其生效。了解利用程序并在后期执行它总是一个好的实践。现在让我们先专注于Drupalgeddon2的公开利用程序。
- en: Exploiting Drupal using Drupalgeddon2
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Drupal使用Drupalgeddon2
- en: 'On March 28, 2018, Drupal issued an advisory that highlighted an RCE vulnerability
    in various versions of Drupal. This was later renamed Drupalgeddon2\. Drupal version
    6 was introduced with the Form API, which was used to alter data during form rendering,
    and, in Drupal 7, this was generalized as **renderable arrays**. Renderable arrays
    contain metadata in a key-value structure and are used in the rendering process:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年3月28日，Drupal发布了一份公告，强调了Drupal各个版本中的RCE漏洞。后来这个漏洞被重新命名为Drupalgeddon2。Drupal
    6版本引入了Form API，用于在表单渲染期间修改数据，在Drupal 7中，这被泛化为**可渲染数组**。可渲染数组以键值结构包含元数据，并在渲染过程中使用：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's now learn about this forms-based vulnerability.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解一下基于表单的漏洞。
- en: Understanding the Drupalgeddon vulnerability
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Drupalgeddon漏洞
- en: 'The Drupalgeddon vulnerability is to do with a particular registration form.
    This form is available in all Drupal installations and can be accessed without
    any authentication. In this form, the email field allows unsanitized input from
    the user, which allows attackers to inject an array into the form array structure
    (as the value of the `email` field). The following properties can be used to exploit
    this vulnerability:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Drupalgeddon漏洞与特定注册表单有关。此表单在所有Drupal安装中都可用，并且可以在没有任何身份验证的情况下访问。在此表单中，电子邮件字段允许用户输入未经过处理的输入，这允许攻击者将数组注入到表单数组结构中（作为`email`字段的值）。以下属性可用于利用此漏洞：
- en: '`#post_render`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#post_render`'
- en: '`#lazy_builder`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#lazy_builder`'
- en: '`#pre_render`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pre_render`'
- en: '`#access_callback`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#access_callback`'
- en: 'Metasploit''s exploit module uses the `#post_render` property to inject the
    payload into the `mail` array, which looks something like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit的利用模块使用`#post_render`属性将有效载荷注入到`mail`数组中，大致如下所示：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Upon rendering, the `exec()` function will be called, which will execute the
    `whoami` command and return the output. Let's now move forward and see this exploit
    in action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时，将调用`exec()`函数，该函数将执行`whoami`命令并返回输出。现在让我们继续看看这个利用程序的实际操作。
- en: 'The following code can be found in `/core/lib/Drupal/Core/Render/Renderer.php`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在`/core/lib/Drupal/Core/Render/Renderer.php`中找到：
- en: '![](img/be660a7c-1d53-487f-853c-d05648a9997d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be660a7c-1d53-487f-853c-d05648a9997d.png)'
- en: '`/core/modules/file/src/Element/ManagedFile.php` is shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`/core/modules/file/src/Element/ManagedFile.php`如下所示：'
- en: '![](img/a5a0017f-828c-48f1-ac59-72b9ddabcd1b.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5a0017f-828c-48f1-ac59-72b9ddabcd1b.png)'
- en: We can see that the form values are broken down using slashes and then used
    to fetch values using the `NestedArray::getValue()` function. Based on the data returned, the
    result is rendered. In this case, `$form["user_picture"]["widget"][0]` becomes
    `user_picture/widget/0`. We can input our own path to the desired element. In
    the account registration form, there are the `mail` and `name` parameters. The
    `name` parameter filters user data, but the `email` parameter does not. We can
    convert this parameter into an array and submit a line beginning with `#` as a
    key.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到表单值使用斜杠进行分解，然后使用`NestedArray::getValue()`函数来获取值。根据返回的数据，渲染结果。在这种情况下，`$form["user_picture"]["widget"][0]`变成了`user_picture/widget/0`。我们可以输入我们自己的路径到所需的元素。在帐户注册表单中，有`mail`和`name`参数。`name`参数过滤用户数据，但`email`参数不会。我们可以将此参数转换为数组，并提交以`#`开头的行作为键。
- en: 'Going back to `/core/lib/Drupal/Core/Render/Renderer.php`, we see that the
    `#post_render` property takes the `#children` element and then passes it to the `call_user_func()`
    function, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`/core/lib/Drupal/Core/Render/Renderer.php`，我们看到`#post_render`属性将`#children`元素并将其传递给`call_user_func()`函数，如下所示：
- en: '![](img/6ce011fc-841b-4398-995c-ef246f48e348.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ce011fc-841b-4398-995c-ef246f48e348.png)'
- en: 'This is from PHP''s manual:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自PHP手册的：
- en: '![](img/677cb687-a188-4d27-83ef-8ce9b2514175.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/677cb687-a188-4d27-83ef-8ce9b2514175.png)'
- en: 'If we pass `call_user_func(system,id)`, it will be executed as `system(id)`.
    So, we need `#post_render` to be defined as `exec()`, and `#children` to be defined
    as the value we want to pass into `exec()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递`call_user_func(system,id)`，它将被执行为`system(id)`。因此，我们需要将`#post_render`定义为`exec()`，并将`#children`定义为我们要传递给`exec()`的值：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another method is to use the `#markup` element, which is used by other exploits
    available on the internet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`#markup`元素，该元素由互联网上提供的其他漏洞利用所使用。
- en: Exploiting Drupalgeddon2 using Metasploit
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit利用Drupalgeddon2
- en: 'A Metasploit module is also available to exploit the Drupalgeddon2 vulnerability,
    and we can use it by executing this command in msfconsole:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个Metasploit模块可用于利用Drupalgeddon2漏洞，我们可以通过在msfconsole中执行以下命令来使用它：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, perform the following steps to exploit the vulnerability:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤来利用漏洞：
- en: 'To view the options, we run `show options`, as shown here:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看选项，我们运行`show options`，如下所示：
- en: '![](img/dd93cd7f-20c2-4ae7-8caa-036106f54951.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd93cd7f-20c2-4ae7-8caa-036106f54951.png)'
- en: 'Next, we set the options of `rhosts` and `rport`, as shown in the following
    screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置`rhosts`和`rport`的选项，如下截图所示：
- en: '![](img/4a43b16c-906d-41e6-be30-5d7a22b4bf6d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a43b16c-906d-41e6-be30-5d7a22b4bf6d.png)'
- en: 'When the exploit is run, it first performs fingerprinting by looking for the
    Drupal version in the response header or meta tag by making a request to `/`,
    as shown here:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当利用程序运行时，首先通过向`/`发出请求来查找响应标头或元标记中的Drupal版本来进行指纹识别，如下所示：
- en: '![](img/1140cab0-4235-4607-bb13-fdc91999c4ed.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1140cab0-4235-4607-bb13-fdc91999c4ed.png)'
- en: 'Next, it performs a patch-level check by calling `CHANGELOG.txt` and looking
    for the `SA-CORE-2018-002` patch, as shown here:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过调用`CHANGELOG.txt`并查找`SA-CORE-2018-002`补丁来执行补丁级别检查，如下所示：
- en: '![](img/e744cbc6-c914-498d-ae85-65c49566d635.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e744cbc6-c914-498d-ae85-65c49566d635.png)'
- en: 'When the previous two steps are complete, the exploit then confirms the existence
    of RCE by simply calling the `printf` function to print a value in response:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前两个步骤后，利用程序通过简单调用`printf`函数来确认RCE的存在并打印响应中的值：
- en: '![](img/973be9fe-dbff-4f6c-a5c4-efc109b40f0f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/973be9fe-dbff-4f6c-a5c4-efc109b40f0f.png)'
- en: 'In the preceding screenshot, we used the `testing123` string. If the server
    responds with `testing123`, the server has the Drupalgeddon2 vulnerability:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们使用了`testing123`字符串。如果服务器响应`testing123`，则服务器存在Drupalgeddon2漏洞：
- en: '![](img/06e70d9a-93fd-4c93-8e8b-4655ae043bdc.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06e70d9a-93fd-4c93-8e8b-4655ae043bdc.png)'
- en: 'Confirm the RCE using the `passthru()` function of PHP to execute the `id`,
    `whoami`, and `uname -a` commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的`passthru()`函数来确认RCE以执行`id`、`whoami`和`uname -a`命令：
- en: '![](img/5090a9af-6328-4612-9102-01a5a2b2fc59.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5090a9af-6328-4612-9102-01a5a2b2fc59.png)'
- en: 'The server returns the response to the commands executed, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将响应返回给执行的命令，如下所示：
- en: '![](img/1c624e12-a14a-42fd-90d2-ae84db657c13.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c624e12-a14a-42fd-90d2-ae84db657c13.png)'
- en: 'The final step is to send the PHP meterpreter payload, which is injected and
    executed in the memory as shown here:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是发送PHP meterpreter有效载荷，如下所示，将其注入并在内存中执行：
- en: '![](img/53499d94-19c2-4618-b0dc-9d398321ebd9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53499d94-19c2-4618-b0dc-9d398321ebd9.png)'
- en: 'Upon successful execution, we will have a meterpreter session open in our terminal:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行后，我们将在终端中打开一个meterpreter会话：
- en: '![](img/7ad41191-f982-420a-8449-4710ee434b3a.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ad41191-f982-420a-8449-4710ee434b3a.png)'
- en: Now, let's look at another example of a Drupal exploit and try to understand
    how it works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看另一个Drupal漏洞的例子，并尝试理解它是如何工作的。
- en: The RESTful Web Services exploit – unserialize()
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web Services漏洞 - unserialize()
- en: 'In February 2019, CVE-2019-6340 was released, which disclosed a bug in the
    RESTful web services module of Drupal. This bug can be exploited to perform RCE.
    RCE is only possible if the Drupal installation has all the web services installed
    (**HAL**, **Serialization**, **RESTful Web Services**, and **HTTP Basic Authentication**,
    shown in the following screenshot):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年2月，CVE-2019-6340发布，披露了Drupal的RESTful web服务模块中的一个漏洞。这个漏洞可以被利用来执行RCE。只有当Drupal安装了所有的web服务（**HAL**，**Serialization**，**RESTful
    Web Services**和**HTTP Basic Authentication**，如下面的截图所示）时，才可能发生RCE：
- en: '![](img/28e062fc-3526-4c96-ac10-737f7e4bee1c.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28e062fc-3526-4c96-ac10-737f7e4bee1c.png)'
- en: 'The RESTful Web Services module communicates with Drupal using REST APIs, which
    can perform operations such as update, read, and write on website resources. It
    depends on the serialization module for the serialization of data that is sent
    to and from the API. Drupal 8 Core uses the **Hypertext Application Language**
    (**HAL**) module, which serializes entities using HAL when enabled. We can check
    whether a Drupal server has these web services enabled by requesting a node using
    the `GET` method with the `_format=hal_json` parameter, as can be seen in the
    following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web Services模块使用REST API与Drupal通信，可以对网站资源执行更新、读取和写入等操作。它依赖于序列化模块对发送到API和从API接收的数据进行序列化。Drupal
    8核心使用**Hypertext Application Language**（**HAL**）模块，在启用时使用HAL对实体进行序列化。我们可以通过使用`GET`方法请求节点并带上`_format=hal_json`参数来检查Drupal服务器是否启用了这些web服务，如下面的截图所示：
- en: '![](img/e721e86a-a4ee-4f2f-85b4-df93db8c2299.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e721e86a-a4ee-4f2f-85b4-df93db8c2299.png)'
- en: 'If the modules are installed, then we''ll get a JSON-based response, as shown
    here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了模块，我们将得到一个基于JSON的响应，如下所示：
- en: '![](img/1d2ac192-34b1-4eca-bdfb-97413a18184c.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d2ac192-34b1-4eca-bdfb-97413a18184c.png)'
- en: 'If the server does not have the web service modules, we''ll get a `406` (`Not
    Acceptable`) HTTP code error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器没有web服务模块，我们将收到`406`（`不可接受`）的HTTP代码错误：
- en: '![](img/1a9fa8b6-f200-4f68-8191-8c3265b97bdb.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a9fa8b6-f200-4f68-8191-8c3265b97bdb.png)'
- en: 'This vulnerability exists because the `LinkItem` class takes unsanitized user
    input and passes it to the `unserialize()` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞存在是因为`LinkItem`类接受未经过处理的用户输入，并将其传递给`unserialize()`函数：
- en: '![](img/b8d2ce64-296d-4e26-a1f5-3a7b359837e5.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8d2ce64-296d-4e26-a1f5-3a7b359837e5.png)'
- en: 'As we can see in the following screenshot, according to the PHP manual for
    the `unserialize()` function, when using `unserialize()`, we should not let untrusted
    user input be passed to this function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的截图中可以看到，根据`unserialize()`函数的PHP手册，当使用`unserialize()`时，我们不应该让不受信任的用户输入传递给这个函数：
- en: '![](img/e9d74ccb-6fff-40b8-907d-f2654f0b8e97.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9d74ccb-6fff-40b8-907d-f2654f0b8e97.png)'
- en: 'In order to exploit this vulnerability, **three** conditions should be satisfied:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个漏洞，需要满足**三个**条件：
- en: The application should have an `unserialize()` function that can be controlled
    by us.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该有一个我们可以控制的`unserialize()`函数。
- en: The application must have a class that implements a PHP magic method (`destruct()`
    or `wakeup()`) that carries out dangerous statements.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须有一个实现PHP魔术方法（`destruct()`或`wakeup()`）的类，执行危险语句。
- en: There needs to be a serialized payload that uses the classes loaded in the application.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要有一个序列化的有效负载，使用应用程序中加载的类。
- en: 'From the previous screenshot, we can confirm that we have control over the `$value[''options'']`
    form entity. To check for the magic methods, let''s search for the `destruct()`
    function within the source code using the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以确认我们可以控制`$value['options']`表单实体。为了检查魔术方法，让我们使用以下命令在源代码中搜索`destruct()`函数：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了前面命令的输出：
- en: '![](img/08e86e24-974d-4070-98be-bfe6d28f49aa.png) **Note**: You have to install
    the `ag` package before executing the preceding command.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/08e86e24-974d-4070-98be-bfe6d28f49aa.png) **注意**：在执行上述命令之前，您必须安装`ag`包。'
- en: In the preceding screenshot, we grepped out `guzzlehttp` because Guzzle is used
    by Drupal 8 as a PHP HTTP client and framework for building RESTful web service
    clients.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们排除了`guzzlehttp`，因为Guzzle被Drupal 8用作PHP HTTP客户端和用于构建RESTful web服务客户端的框架。
- en: 'From looking at the `FnStream.php` file (refer to the preceding screenshot),
    we can see that the `__destruct()` magic method is calling the `call_user_func()`
    function, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看`FnStream.php`文件（参考上面的截图）中，我们可以看到`__destruct()`魔术方法调用了`call_user_func()`函数，如下面的截图所示：
- en: '![](img/5387edda-be4c-4204-98f4-5b18a8a9e62a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5387edda-be4c-4204-98f4-5b18a8a9e62a.png)'
- en: '`call_user_func()` is quite a dangerous function to use, especially when more
    than one argument is passed. We can use this function to perform a function injection attack:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_user_func()`是一个非常危险的函数，特别是当传递多个参数时。我们可以使用这个函数来执行函数注入攻击：'
- en: '![](img/d881b08a-7212-47d7-b563-931509ee6ddb.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d881b08a-7212-47d7-b563-931509ee6ddb.png)'
- en: According to OWASP, a function injection attack consists of the insertion or
    **injection **of a function name from the client into an application. A successful
    function injection exploit can execute any built-in or user-defined function.
    Function injection attacks are a type of injection attack in which arbitrary function
    names, sometimes with parameters, are injected into an application and executed.
    If parameters are passed to the injected function, this leads to RCE.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OWASP的说法，函数注入攻击包括将客户端的函数名称插入或**注入**到应用程序中。成功的函数注入利用可以执行任何内置或用户定义的函数。函数注入攻击是一种注入攻击类型，其中任意函数名称，有时带有参数，被注入到应用程序中并执行。如果参数被传递到注入的函数，这将导致RCE。
- en: 'According to the Drupal API documentation, the `LinkItem` class is used to
    implement the `link` field type:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Drupal API文档，`LinkItem` 类用于实现 `link` 字段类型：
- en: '![](img/13a4dcde-1e0f-4148-a7ad-be1fc1c8d976.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13a4dcde-1e0f-4148-a7ad-be1fc1c8d976.png)'
- en: 'We know that the `LinkItem` class passes unsanitized user input to the `unserialize()`
    function, but to invoke this class, we need to invoke an entity first. An entity
    would be one instance of a particular entity type, such as a comment, a taxonomy
    term, or a user profile, or a bundle of instances, such as a blog post, article,
    or product. We need to find an entity that is used by `LinkItem` for navigation.
    Let''s search for an entity in the source code using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `LinkItem` 类将未经过处理的用户输入传递给 `unserialize()` 函数，但要调用此类，我们需要首先调用一个实体。实体将是特定实体类型的一个实例，例如评论、分类术语或用户配置文件，或者是一组实例，例如博客文章、文章或产品。我们需要找到一个被
    `LinkItem` 用于导航的实体。让我们使用以下命令在源代码中搜索实体：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前述命令的输出：
- en: '![](img/7bccca3c-e951-4a7d-bb8f-50780360ece6.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bccca3c-e951-4a7d-bb8f-50780360ece6.png)'
- en: 'As we can see from the preceding screenshot, `LinkItem` is used to navigate
    to the `MenuLinkContent.php` and `Shortcut.php` entities and, as we can see from
    the `Shortcut.php` file, the shortcut entity is creating a `link` property:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看到，`LinkItem` 用于导航到 `MenuLinkContent.php` 和 `Shortcut.php` 实体，并且从
    `Shortcut.php` 文件中可以看到，快捷方式实体正在创建一个 `link` 属性：
- en: '![](img/90eb533f-940f-4f5d-8317-2f814f4095d0.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90eb533f-940f-4f5d-8317-2f814f4095d0.png)'
- en: 'To trigger the `unserialize()` function, we need to align together all the
    elements that we have explained so far:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发 `unserialize()` 函数，我们需要将我们迄今为止解释的所有元素对齐在一起：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have met two out of the three conditions, the only thing left to
    do is to create our serialized payload. There are various ways to create a serialized
    payload, but we will use a library known as **PHP Generic Gadget Chains** (**PHPGGC**)
    to create a serialized payload for Guzzle. To generate a serialized payload using
    `phpggc`, we use the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经满足了三个条件中的两个，唯一剩下的就是创建我们的序列化有效负载。有各种方法可以创建序列化有效负载，但我们将使用一个名为**PHP通用小工具链**（**PHPGGC**）的库来为Guzzle创建一个序列化有效负载。要使用
    `phpggc` 生成序列化有效负载，我们使用以下命令：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前述命令的输出：
- en: '![](img/f1b16264-0f54-4cdb-8b9c-e8acf296f33b.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b16264-0f54-4cdb-8b9c-e8acf296f33b.png)'
- en: The JSON serialized payload generated in the preceding screenshot will call
    the `system()` function and run the `id` command. We will submit the entire payload
    with a `GET/POST/PUT` method in the following URL format: `localhost/node/1?_format=hal_json`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述屏幕截图中生成的JSON序列化有效负载将调用 `system()` 函数并运行 `id` 命令。我们将以以下URL格式使用 `GET/POST/PUT`
    方法提交整个有效负载：`localhost/node/1?_format=hal_json`
- en: 'The server will execute the `id` command and return us the output shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将执行 `id` 命令并返回我们在此处显示的输出：
- en: '![](img/e99611e3-3515-4e8a-87c2-7e3d72f64152.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e99611e3-3515-4e8a-87c2-7e3d72f64152.png)'
- en: 'We have successfully achieved the RCE, but the question still remains: why
    did the serialized payload work? To answer this question, we need to understand
    what general serialized data looks like and learn about serialized formats.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功实现了RCE，但问题仍然存在：为什么序列化有效负载有效？要回答这个问题，我们需要了解一般序列化数据的外观，并了解序列化格式。
- en: Understanding serialization
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解序列化
- en: 'For a basic understanding of the `serialize()` function, let''s take a look
    at the following PHP code snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基本了解 `serialize()` 函数，让我们看一下以下PHP代码片段：
- en: '![](img/6bc0db63-b4d7-453f-b13a-f8437195ddf1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc0db63-b4d7-453f-b13a-f8437195ddf1.png)'
- en: 'In the preceding code, we initialized an array named `my_array` with the following
    elements:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们初始化了一个名为 `my_array` 的数组，其中包含以下元素：
- en: '`my_array[0] = "Harpreet"`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_array[0] = "Harpreet"`'
- en: '`my_array[1] = "Himanshu"`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_array[1] = "Himanshu"`'
- en: 'We then used the `serialize()` function to generate serialized data for the
    array. As you can see in the following screenshot, the serialized data stream
    is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `serialize()` 函数为数组生成序列化数据。如下屏幕截图所示，序列化数据流如下：
- en: '![](img/6f514979-d1e7-4650-a6e2-feae11be981f.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f514979-d1e7-4650-a6e2-feae11be981f.png)'
- en: 'The other PHP serialized formats that are commonly used are these:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常用的PHP序列化格式包括：
- en: '`a`: Array'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：数组'
- en: '`b`: Boolean'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：布尔值'
- en: '`i`: Integer'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：整数'
- en: '`d`: Double'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：双精度'
- en: '`O`: Common object'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O`: 通用对象'
- en: '`r`: Object reference'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：对象引用'
- en: '`s`: String'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：字符串'
- en: '`C`: Custom object'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`：自定义对象'
- en: 'Metasploit also has a built-in exploit for this vulnerability. Taking a look
    at the source code of the exploit, we notice that it uses almost the same payload
    as that generated by PHPGCC:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit还针对此漏洞内置了一个利用程序。查看利用程序的源代码，我们注意到它使用的有效负载几乎与PHPGCC生成的有效负载相同：
- en: '![](img/5dfc91eb-4d83-46d3-b7fb-145af8c686a3.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dfc91eb-4d83-46d3-b7fb-145af8c686a3.png)'
- en: The only difference is that the command and its length are set dynamically as
    per the input given by us via the exploit options.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是命令及其长度根据我们通过利用选项给出的输入动态设置。
- en: 'As we can see in the following screenshot (where we are calling the `__destruct()`
    function), to perform function injection in `call_user_func()`, we have to control
    the `_fn_close` method so that dangerous functions, such as `system()`, `passthru()`,
    and `eval()`, are easily passed to `call_user_func()` as the first argument:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的截图中所看到的（在这里我们调用`__destruct()`函数），要在`call_user_func()`中执行函数注入，我们必须控制`_fn_close`方法，以便危险函数（如`system()`、`passthru()`和`eval()`）可以轻松地作为第一个参数传递给`call_user_func()`：
- en: '![](img/ea3ce84e-d2e6-4f59-831b-6b207d8dc051.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea3ce84e-d2e6-4f59-831b-6b207d8dc051.png)'
- en: 'To control the `_fn_close` method, we have to look at the constructor ( `__construct()`):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制`_fn_close`方法，我们必须查看构造函数（`__construct()`）：
- en: '![](img/dccd4d87-9547-458a-8991-9e695d07cffa.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dccd4d87-9547-458a-8991-9e695d07cffa.png)'
- en: 'As can be seen from the preceding screenshot, the `$methods` array is passed
    as an argument to the constructor. The `__construct()` function will create functions
    by looping through the `$methods` array and then prepending the `_fn_` string.
    If the `$methods` array has a `close` string in it, the string will be prepended
    with `_fn_`, making the `_fn_close `method. Now, let''s see the elements inside
    the `$methods` array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中可以看出，`$methods`数组作为参数传递给构造函数。`__construct()`函数将通过循环遍历`$methods`数组来创建函数，然后在`_fn_`字符串之前添加。如果`$methods`数组中有一个`close`字符串，该字符串将被添加上`_fn_`，从而形成`_fn_close`方法。现在，让我们看看`$methods`数组中的元素：
- en: '![](img/c0298697-61c6-426b-b948-32420e3352f7.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0298697-61c6-426b-b948-32420e3352f7.png)'
- en: From the preceding screenshot, it's clear that the `$methods` array has an element
    with the value `close` in it. Now that we know how to control the `_fn_close`
    method, next, we have to find a way to pass the dangerous function and the command
    to be executed to `_fn_close`. For this, we have to create a **POP chain**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中可以清楚地看到`$methods`数组中有一个值为`close`的元素。现在我们知道如何控制`_fn_close`方法，接下来，我们必须找到一种方法将危险函数和要执行的命令传递给`_fn_close`。为此，我们必须创建一个**POP链**。
- en: What is a POP chain?
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是POP链？
- en: In memory corruption vulnerabilities such as buffer overflows and format strings,
    if memory defenses such as **Data Execution Prevention** (**DEP**) and **Address
    Space Layout Randomization** (**ASLR**) are in place, code reuse techniques such
    as **Return-to-libc** (**ret2libc**) and **Return-Oriented Programming** (**ROP**)
    can be used to bypass those defenses. Code reuse techniques are also viable in
    the case of PHP-based web applications, which use the concept of objects. One
    code reuse technique that can utilize the properties of the object for exploitation
    is **Property-Oriented Programming (POP)**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存损坏漏洞（如缓冲区溢出和格式字符串）中，如果存在内存防御措施，如**数据执行防护**（**DEP**）和**地址空间布局随机化**（**ASLR**），则可以使用代码重用技术，如**返回到libc**（**ret2libc**）和**返回导向编程**（**ROP**）来绕过这些防御措施。代码重用技术在基于PHP的Web应用程序的情况下也是可行的，这些应用程序使用对象的概念。可以利用对象属性进行利用的一种代码重用技术是**基于属性的编程（POP）**。
- en: A POP chain is an exploitation approach for object injection vulnerabilities
    in web applications that exploit the ability to arbitrarily modify the properties
    of an object that is injected into a given web application. The data and control
    flow of the victim application can then be manipulated accordingly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: POP链是一种利用Web应用程序中对象注入漏洞的利用方法，利用能够任意修改被注入到给定Web应用程序中的对象的属性的能力。然后可以相应地操纵受害应用程序的数据和控制流。
- en: 'To create a POP chain, the serialized payload uses the `HandlerStack` class
    of `GuzzleHttp`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个POP链，序列化的负载使用`GuzzleHttp`的`HandlerStack`类：
- en: '![](img/b863d5af-a05a-4373-9aee-26ab0e7d1bfc.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b863d5af-a05a-4373-9aee-26ab0e7d1bfc.png)'
- en: 'We''ll pass our command to the `handler` method, and the dangerous function
    to the `stack[]` method, as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的命令传递给`handler`方法，将危险函数传递给`stack[]`方法，如下图所示：
- en: '![](img/d2cd4c36-ebe9-4e5b-a78d-75dfe3b18823.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2cd4c36-ebe9-4e5b-a78d-75dfe3b18823.png)'
- en: 'Once the destructor is called (the calling is done automatically at the time
    of object destruction), the properties of the `_fn_close` method are passed to
    `call_user_func()`, and `system(id)` is executed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦析构函数被调用（在对象销毁时会自动调用），`_fn_close`方法的属性将被传递给`call_user_func()`，并执行`system(id)`：
- en: '![](img/130a43e7-9a43-42bf-8dcd-d80855746173.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/130a43e7-9a43-42bf-8dcd-d80855746173.png)'
- en: Next, we will deserialize the payload.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将反序列化负载。
- en: Deserializing the payload
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反序列化负载
- en: 'To understand the payload more clearly, we can deserialize it and use `var_dump`
    on it. According to the PHP manual, `var_dump` displays structured information
    (including the type and value) about one or more expressions. Arrays and objects
    are explored recursively by `var_dump`, and values are indented to show structure.
    We could also use the `print_r()` function to perform the same operation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解负载，我们可以对其进行反序列化并使用`var_dump`。根据PHP手册，`var_dump`显示关于一个或多个表达式的结构化信息（包括类型和值）。`var_dump`会递归地探索数组和对象，并缩进显示结构。我们也可以使用`print_r()`函数执行相同的操作：
- en: '![](img/1e4e11bb-a571-4201-ad87-ca29d6df17ec.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e4e11bb-a571-4201-ad87-ca29d6df17ec.png)'
- en: 'Since we used the payload based on the `GuzzleHttp` client, we need to have
    Guzzle installed. We can unserialize it using the following PHP code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用基于`GuzzleHttp`客户端的负载，我们需要安装Guzzle。我们可以使用以下PHP代码对其进行反序列化：
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the code will give us the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将给我们以下输出：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This, when executed, causes the `system()` function to be executed with the
    command passed as an argument to this function, and the output is returned to
    us.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，会导致`system()`函数执行传递给该函数的命令，并将输出返回给我们。
- en: Exploiting RESTful Web Services RCE via unserialize() using Metasploit
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Metasploit使用unserialize()利用RESTful Web Services RCE
- en: 'Now that we understand the concept of serialization and how a payload is serialized,
    let''s use the Metasploit `exploit` module to exploit this vulnerability. Let''s
    execute the following command to use the `exploit` module:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了序列化的概念以及如何对有效载荷进行序列化，让我们使用Metasploit的`exploit`模块来利用这个漏洞。执行以下命令来使用`exploit`模块：
- en: '[PRE17]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前述命令的输出：
- en: '![](img/53af4093-02c2-4f7e-a999-34476b2a707d.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53af4093-02c2-4f7e-a999-34476b2a707d.png)'
- en: 'We then set the options and run the exploit. Upon running the Metasploit module,
    we will observe that it first performs a patch-level check by asking `CHANGELOG.txt`
    to look for the **SA-CORE-2019-003** patch. The `id` command is executed to confirm
    the RCE on the Drupal installation as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置选项并运行利用。运行Metasploit模块后，我们会观察到它首先通过询问`CHANGELOG.txt`来查找**SA-CORE-2019-003**补丁来执行补丁级别检查。执行`id`命令以确认Drupal安装上的RCE，如下所示：
- en: '![](img/a8a4bfbc-a4ce-4363-8680-084c41f9b7b3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8a4bfbc-a4ce-4363-8680-084c41f9b7b3.png)'
- en: 'Upon successful exploitation, the server will return the output of the `id`
    command as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 成功利用后，服务器将返回`id`命令的输出，如下所示：
- en: '![](img/1623bd94-efad-4951-90f7-103f4d0f8ddd.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1623bd94-efad-4951-90f7-103f4d0f8ddd.png)'
- en: 'Then, the PHP meterpreter code is serialized and sent to the server and a meterpreter
    session opens in our Metasploit, as shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，PHP meterpreter代码被序列化并发送到服务器，一个meterpreter会话在我们的Metasploit中打开，如下所示：
- en: '![](img/2339fefb-69b9-4c2e-9ab8-47141bf4dcce.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2339fefb-69b9-4c2e-9ab8-47141bf4dcce.png)'
- en: We have achieved access to the Drupal server by exploiting the RESTful Web Services
    module.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过利用RESTful Web Services模块获得了对Drupal服务器的访问。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by discussing the architecture of Drupal, as well as
    the directory structure. Then, we learned how to perform reconnaissance of Drupal
    both manually and automatically. After that, we looked at examples of two exploits
    and did a step-by-step walkthrough of the entire exploitation process.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从讨论Drupal的架构和目录结构开始了本章。然后，我们学习了如何手动和自动执行Drupal的侦察。之后，我们看了两个利用的例子，并逐步介绍了整个利用过程。
- en: In the next chapter, we will look at the enumeration and exploitation of JBoss
    servers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下对JBoss服务器的枚举和利用。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can the same vulnerability be used to exploit different versions of Drupal?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的漏洞可以用来利用不同版本的Drupal吗？
- en: Do we need to install Drupal locally to exploit a remote Drupal site?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在本地安装Drupal来利用远程Drupal网站吗？
- en: The RESTful API Web Services exploit isn't working – what can we do about this?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTful API Web Services利用不起作用-我们能做些什么？
- en: We have access to the Drupal administrator account – how can we achieve RCE
    on the server?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以访问Drupal管理员帐户-我们如何在服务器上实现RCE？
- en: We found a `.swp`file on a Drupal site – can this be used for exploitation?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Drupal网站上发现了一个`.swp`文件-这可以用于利用吗？
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The architecture of Drupal 8: [https://www.drupal.org/docs/8/modules/entity-browser/architecture](https://www.drupal.org/docs/8/modules/entity-browser/architecture)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal 8的架构：[https://www.drupal.org/docs/8/modules/entity-browser/architecture](https://www.drupal.org/docs/8/modules/entity-browser/architecture)
- en: An in-depth look at Drupal 8 RCE: [https://www.ambionics.io/blog/drupal8-rce](https://www.ambionics.io/blog/drupal8-rce)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drupal 8 RCE的深入研究：[https://www.ambionics.io/blog/drupal8-rce](https://www.ambionics.io/blog/drupal8-rce)
