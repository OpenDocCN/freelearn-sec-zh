- en: Understanding Web Application Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Web 应用程序漏洞
- en: This chapter is going to be your main pillar of application security. You will
    learn the logic behind the most popular vulnerabilities in this field. Most attacks
    that are executed remotely use the web application infrastructure to get in. Finding
    a vulnerability such as SQL Injection on a site can be very harmful, as the attacker
    can take complete control of the server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将成为你应用程序安全性的主要支柱。你将了解该领域中最常见漏洞背后的逻辑。大多数远程执行的攻击都利用 Web 应用程序基础设施进行入侵。在网站上发现像
    SQL 注入这样的漏洞可能非常危险，因为攻击者可以完全控制服务器。
- en: Web applications are written in different programming languages, but the most
    popular ones are Java, .NET, and PHP. These days, we see a shift in web application
    programming, where the JavaScript language or the frontend takes an important
    part. Companies are using light-weight frontend technologies such as AngularJS
    to implement the idea of Single-Page Applications. As an application security
    pentester, you need to be aware of the vulnerabilities that exist for these types
    of technologies because developers tend to use these shiny functionalities without
    understanding the security risks that come with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序是用不同的编程语言编写的，但最常见的语言是 Java、.NET 和 PHP。如今，我们看到 Web 应用程序编程正在发生转变，JavaScript
    语言或前端发挥了重要作用。公司正在使用轻量级的前端技术，如 AngularJS，来实现单页面应用程序的理念。作为一名应用程序安全渗透测试员，你需要了解这些技术中存在的漏洞，因为开发人员往往使用这些炫酷的功能而没有理解其带来的安全风险。
- en: 'So, this chapter will explain attacks that can happen to a web application,
    and after finishing it, you will be able to use your skills to manually manipulate
    your findings during pentests. In this chapter, you will learn about the following
    important topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将解释可能发生在 Web 应用程序中的攻击，完成本章后，你将能够在渗透测试中手动操作你的发现，运用你的技能。在本章中，你将学习以下重要内容：
- en: Remote and Local File Inclusion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程和本地文件包含
- en: '**Cross-Site Scripting** (**XSS**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击** (**XSS**)'
- en: '**Cross-Site Request Forgery** (**CSRF**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求伪造** (**CSRF**)'
- en: '**SQL Injection** (**SQLi**)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL 注入** (**SQLi**)'
- en: Command Injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令注入
- en: OWASP Top 10 List
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP 十大安全漏洞
- en: File Inclusion
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件包含
- en: As the name suggests, this vulnerability can be exploited by including a file
    in the URL (by entering the path). The file that was included can be local to
    the server, and thus be called **Local File Inclusion**, or it (the path of the
    file) can point to a remote file, and thus be called a **Remote File Inclusion**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这种漏洞可以通过在 URL 中包含文件（通过输入路径）来利用。被包含的文件可以是服务器本地的，因此称为 **本地文件包含**，也可以是指向远程文件的路径，因此称为
    **远程文件包含**。
- en: Modern programming languages and web servers have built-in mechanisms to protect
    against this flaw. Unfortunately, in real life, you will encounter a lot of applications
    developed by legacy programming languages such as JSP (Java), ASP (Microsoft),
    and PHP, so the chance of finding a similar vulnerability is still there. One
    problem that can cause this issue is when the developer forgets to include a validation
    on the server side.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言和 Web 服务器内置了保护机制以防止此类缺陷。不幸的是，在现实中，你会遇到许多由遗留编程语言（如 JSP（Java）、ASP（Microsoft）和
    PHP）开发的应用程序，因此仍然有可能找到类似的漏洞。造成此问题的一个原因是开发人员忘记在服务器端进行验证。
- en: Local File Inclusion
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地文件包含
- en: '**Local File Inclusion** (**LFI**) is exploited by including a file path in
    the URL that points to the local web server that hosts the web application. This
    vulnerability, when exploited, will allow directory traversal characters (such
    as dot-dot-slash) to be injected.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地文件包含** (**LFI**) 是通过在 URL 中包含指向托管 Web 应用程序的本地 Web 服务器的文件路径来利用的。当这个漏洞被利用时，会允许注入目录遍历字符（如点点斜杠）。'
- en: 'Consider the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What if I can change the `hackme` file to another file on the web server system?
    Let's check it out!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能将 `hackme` 文件更改为 Web 服务器系统上的另一个文件，怎么办？让我们来看看吧！
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Interesting, right? This will load the `passwd` file on a Linux Web Server.
    Let''s see a more concrete example using Mutillidae:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣吧？这将加载 Linux Web 服务器上的 `passwd` 文件。让我们看一个更具体的例子，使用 Mutillidae：
- en: 'Browse to the Mutillidae homepage and select OWASP 2017 from the left menu,
    then Broken Access Control | Insecure Direct Object References, and after that,
    click on Arbitrary File Inclusion:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 Mutillidae 首页，选择左侧菜单中的 OWASP 2017，然后选择 Broken Access Control | 不安全的直接对象引用，接着点击任意文件包含：
- en: '![](Images/fc68a497-ee64-4ca4-af1e-677fc38967be.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fc68a497-ee64-4ca4-af1e-677fc38967be.png)'
- en: Look at the URL, do you see the same pattern that we just saw together?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下这个网址，你看到我们刚才一起看到的相同模式了吗？
- en: '![](Images/bac93bbf-0b5f-4442-a21c-0c3055d02a46.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bac93bbf-0b5f-4442-a21c-0c3055d02a46.png)'
- en: 'Let''s try to see whether we can display a file from the server:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试看能否从服务器上显示一个文件：
- en: '![](Images/5c137226-15c4-48b9-980b-17d5bf230405.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5c137226-15c4-48b9-980b-17d5bf230405.png)'
- en: Voila! I just exploited this vulnerability. Now, try it yourself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看！我刚刚利用了这个漏洞。现在，试试自己操作吧。
- en: Remote File Inclusion
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程文件包含
- en: '**Remote File Inclusion** (**RFI**) is exploited by including a file path in
    the URL that points to the remote file outside the boundaries of the web server
    that hosts the web application.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程文件包含**（**RFI**）是通过在URL中包含一个指向远程文件的文件路径来利用的，这个文件路径指向托管Web应用程序的Web服务器之外的远程文件。'
- en: 'Consider the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding URL, the victim server will load the `malware.php` page that
    resides on the hacker''s server. Let''s see a practical example using Mutillidae:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的URL中，受害者服务器将加载位于黑客服务器上的`malware.php`页面。让我们通过使用Mutillidae来看一个实际示例：
- en: Browse to the Mutillidae homepage and select OWASP 2017. We will choose the
    same menu that we used previously for the Local File Inclusion, that is, Broken
    Access Control | Insecure Direct Object References | Arbitrary File Inclusion.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到Mutillidae首页并选择OWASP 2017。我们将选择之前用于本地文件包含的相同菜单，即，**破损访问控制** | **不安全的直接对象引用**
    | **任意文件包含**。
- en: 'So, it''s the same page that we tested for the Local File Inclusion but now,
    we will see if we can include a remote file. Before exploiting this vulnerability,
    we need to change a few things at the server level first. This page provides you
    with the help for changing the config file on the server. I will log into the
    web server and change the `php.ini` file under `C:\xampp\php\` (your path will
    be different if you''re using Linux to host Mutillidae):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，这是我们之前测试过的本地文件包含页面，但现在，我们将看看能否包含一个远程文件。在利用这个漏洞之前，我们需要先在服务器级别进行一些更改。此页面为您提供了更改服务器配置文件的帮助。我将登录到Web服务器并更改`C:\xampp\php\`下的`php.ini`文件（如果你使用Linux托管Mutillidae，你的路径会有所不同）：
- en: '![](Images/272546aa-e68a-4963-b07a-7de690a06c43.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/272546aa-e68a-4963-b07a-7de690a06c43.png)'
- en: 'Now that we have changed the configs, restart the web server using the XAMPP
    Control Panel. Let''s see if we can hack this page. So, change the URL and let
    it point to and load another site, `http://ethicalhackingblog.com`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经更改了配置，使用XAMPP控制面板重新启动Web服务器。让我们看看是否能攻破这个页面。所以，修改URL，让它指向并加载另一个站点，`http://ethicalhackingblog.com`：
- en: '![](Images/d030faaa-d5c6-48da-b8cd-e305ea5e9603.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d030faaa-d5c6-48da-b8cd-e305ea5e9603.png)'
- en: As you can see I was able to load my blogging website inside the Mutillidae
    application. Imagine a hacker loading his infected website inside another application
    that is accessible to millions of people, such as Facebook, or your client/employer
    website; the damage could be disastrous.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我成功地将我的博客网站加载到了Mutillidae应用程序中。试想一下，如果黑客将他的感染网站加载到另一个对数百万用户可访问的应用程序中，比如Facebook，或者你的客户/雇主的网站，造成的损害将是灾难性的。
- en: Cross-Site Scripting
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: '**Cross-Site Scripting** (**XSS**), is exploited when the attacker can successfully
    execute any type of script (for example, JavaScript) on the victim''s browser.
    These types of flaws exist because the developer did not validate the request
    or correctly encoded the response of the application. JavaScript is not the only
    script language used for XSS but it is the most common (in fact it''s my favorite);
    attackers sometimes use scripting languages such as VBScript, ActiveX, Flash,
    and many more.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**（**XSS**）是在攻击者能够在受害者的浏览器上成功执行任何类型的脚本（例如，JavaScript）时被利用的。这类漏洞的存在是因为开发人员没有验证请求或没有正确编码应用程序的响应。JavaScript并不是唯一用于XSS的脚本语言，但它是最常见的（事实上，这是我最喜欢的）；攻击者有时还会使用其他脚本语言，如VBScript、ActiveX、Flash等。'
- en: 'XSS is very popular and I encounter it every day while testing web applications. Every
    time I see a message displayed on the page that reflects a user input or behavior,
    then most probably it is vulnerable to XSS. But don''t worry, with experience
    and practice, things will become more obvious to you as well. There are three
    types of XSS attacks: **Stored**, **Reflected**, and **DOM Injection**. Let''s
    start with the easiest to understand, the reflected XSS.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: XSS非常普遍，在测试Web应用时我每天都会遇到。每当我看到页面上显示的信息反映了用户的输入或行为时，那么它很可能存在XSS漏洞。但不用担心，随着经验和实践的积累，很多问题会变得更加明显。XSS攻击有三种类型：**存储型**、**反射型**和**DOM注入**。我们从最容易理解的反射型XSS开始。
- en: Reflected XSS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射型XSS
- en: 'This flaw is exploited often when the page displays to the user something that
    can be manipulated dynamically through a URL or in the body of the page. Nothing
    is better than a visual example so let''s see a reflected XSS case using Mutillidae:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞常常在页面展示给用户的内容可以通过URL或页面正文动态修改时被利用。没有什么比视觉示例更能说明问题了，接下来我们来看一个使用Mutillidae的反射型XSS案例：
- en: 'In your Kali Linux, open your browser and go to the Homepage, then on the left
    Menu, choose OWASP 2017 | Cross Site Scripting | Reflected | DNS Lookup. The first
    thing that you need to test is the happy path, so let''s enter a real IP address
    (for this example, I will use the IP `10.0.0.1` which is my home router) and click
    on the Lookup DNS button:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Kali Linux上，打开浏览器并访问首页，然后在左侧菜单中选择OWASP 2017 | Cross Site Scripting | Reflected
    | DNS Lookup。你需要测试的第一件事是正常路径，所以让我们输入一个真实的IP地址（在这个例子中，我使用的是`10.0.0.1`，也就是我的家庭路由器）并点击“Lookup
    DNS”按钮：
- en: '![](Images/9df0c55d-d7bb-49ab-b8a8-311a449f0ece.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9df0c55d-d7bb-49ab-b8a8-311a449f0ece.png)'
- en: 'As you can see, the page has displayed the IP address that we just entered.
    This means that if I replace the IP address with a JavaScript code, it will execute
    it. In the textbox, replace the IP address with a test script, `<script>alert(1)</script>`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，页面已经显示了我们刚刚输入的IP地址。这意味着，如果我将IP地址替换为一段JavaScript代码，它将执行该代码。在文本框中，将IP地址替换为测试脚本，`<script>alert(1)</script>`：
- en: '![](Images/85fdcd68-6932-4bc9-9393-91ce925c5175.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/85fdcd68-6932-4bc9-9393-91ce925c5175.png)'
- en: 'Click on the Lookup DNS button and see if this script will execute:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Lookup DNS”按钮，看看这个脚本是否会执行：
- en: '![](Images/ba165874-4227-4642-816d-b33d77000095.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ba165874-4227-4642-816d-b33d77000095.png)'
- en: In this example, I used the `alert(1)` JavaScript, and that's probably all you
    need during the penetration tests. On the other hand, a hacker will use a more
    sophisticated JavaScript logic to collect personal information from its victim.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了`alert(1)` JavaScript，通常这就足够用于渗透测试了。另一方面，黑客会使用更复杂的JavaScript逻辑来收集受害者的个人信息。
- en: For more advanced XSS attacks check out **Beef XSS Framework** on your Kali
    Linux host. After using this tool you will be amazed by the attack choices that
    an XSS vulnerability can bring to the table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更高级的XSS攻击，可以在你的Kali Linux主机上查看**Beef XSS框架**。使用这个工具后，你会对XSS漏洞带来的攻击选择感到惊讶。
- en: Stored XSS
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储型XSS
- en: The second type of attack is stored XSS. Exploiting this one will be accomplished
    by saving the script (JavaScript) into a stored location through a page (for example,
    Blogs, CMS, Forums) into some sort of a storage file (for example, database, file,
    and logs). This flaw is dangerous because it is persisted and will execute when
    anyone visits the infected page later. Imagine that on Facebook (or any social
    media platform), you can submit a post that contains a JavaScript code that will
    execute by anyone who sees that post; amazing, right?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种攻击是存储型XSS。利用这种漏洞时，攻击者通过页面（例如博客、CMS、论坛）将脚本（JavaScript）保存到某个存储位置（例如数据库、文件、日志）。这个漏洞很危险，因为它是持久的，且在任何人稍后访问受感染页面时都会执行。想象一下，在Facebook（或任何社交媒体平台）上，你可以提交一条包含JavaScript代码的帖子，任何看到该帖子的用户都会执行这段代码；是不是很惊人？
- en: Please don't try it on Facebook - I'm just giving an example here, you don't
    want to get yourself in trouble! (By the way, Facebook and other big companies
    offers bug bounty programs and they will pay you money if you find any bugs).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要在Facebook上尝试——我这里只是给出一个例子，你可不想惹麻烦！（顺便说一下，Facebook和其他大公司提供漏洞赏金计划，如果你发现任何漏洞，他们会付钱给你。）
- en: 'That''s why we have Mutillidae; to test our concept and check how things work:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要Mutillidae的原因；它帮助我们测试这个概念并查看它是如何工作的：
- en: 'Go to the homepage of Mutillidae, then on the left menu, choose OWASP 2017 |
    Cross Site Scripting | Persistent | Add to your blog:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Mutillidae的首页，然后在左侧菜单中选择OWASP 2017 | Cross Site Scripting | Persistent | Add
    to your blog：
- en: '![](Images/9a648e7d-4020-4407-890d-5d92129a2351.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9a648e7d-4020-4407-890d-5d92129a2351.png)'
- en: 'Same as before, we will try to insert the same JavaScript alert that we did
    before and try to execute it by clicking on the S**ave Blog Entry** button (but
    this time, it will be stored as a blog):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和之前一样，我们将尝试插入与之前相同的JavaScript警报，并通过点击**保存博客条目**按钮来执行它（但这次它将作为博客内容被存储）：
- en: '![](Images/46a21ef1-1296-490c-9fdf-e08df6957321.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/46a21ef1-1296-490c-9fdf-e08df6957321.png)'
- en: Now, every time a user visits this blog, he or she will be prompted when the
    page loads with the JavaScript alert because it's stored in the database.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次用户访问这个博客时，页面加载时都会弹出JavaScript警报，因为它被存储在数据库中。
- en: Exploiting stored XSS using the header
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用头部进行存储型XSS攻击
- en: Another interesting example that I would like to share with you is using the
    header to inject JavaScript into the page. Tricky right? But don't be surprised
    to see that the nature of web applications will allow us to manipulate the web
    page through the header.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我想与您分享的有趣示例是使用头部将JavaScript注入页面。很狡猾吧？但是不要惊讶，网络应用程序的本质使我们能够通过头部操控网页。
- en: 'Let''s visualize this case so you can understand things better:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化这个案例，以便您能更好地理解：
- en: 'Go to the homepage of Mutillidae then on the left menu, choose OWASP 2017 |
    Cross Site Scripting | Persistent| Show Log:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Mutillidae的主页，然后在左侧菜单中选择OWASP 2017 | 跨站脚本攻击 | 持久性 | 查看日志：
- en: '![](Images/61535c9b-ec47-476d-88c7-7e660cd120ce.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/61535c9b-ec47-476d-88c7-7e660cd120ce.png)'
- en: This page records every visit to the Mutillidae application. The third column
    stores the Browser Agent value of the visitor. What if that visitor is malicious
    and replaces his browser agent with JavaScript using Burp?
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此页面记录了每次访问Mutillidae应用程序的情况。第三列存储了访问者的浏览器代理值。如果该访问者是恶意的，使用Burp将他的浏览器代理替换为JavaScript会怎样？
- en: '![](Images/3da42edd-402c-4dd1-b124-054ce70ba03e.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3da42edd-402c-4dd1-b124-054ce70ba03e.png)'
- en: 'So, I will intercept the page using the Proxy tab in Burp, then modify the
    Browser Agent with a JavaScript alert and forward it to the server (using the
    Forward button):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我将使用Burp的代理选项卡拦截页面，然后通过JavaScript警报修改浏览器代理，并将其转发到服务器（使用转发按钮）：
- en: '![](Images/d823e34d-89d3-4fee-a66e-43f83dee368e.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d823e34d-89d3-4fee-a66e-43f83dee368e.png)'
- en: Voila! This is the result of changing the user agent of our browser using our
    XSS trick in Burp. Again, this is a persistent XSS and every time the admin of
    the site visits this page, he or she will be prompted with our payload.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看！这是我们使用XSS技巧在Burp中更改浏览器用户代理的结果。这是一个持久性的XSS攻击，每次该网站的管理员访问此页面时，都会看到我们的有效负载。
- en: DOM XSS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM XSS
- en: 'In the first two types above, we''ve used the HTML to exploit the XSS vulnerability.
    DOM XSS injection, however, is accomplished through the JavaScript code instead
    of the HTML elements. Let''s see a practical example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述前两种类型中，我们已经使用HTML利用了XSS漏洞。然而，DOM XSS注入是通过JavaScript代码完成的，而不是通过HTML元素。让我们看一个实际的例子：
- en: Go to the homepage of Mutillidae, then on the left Menu, choose OWASP 2017 |
    Cross-Site Scripting | DOM-Based | Password Generator.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Mutillidae的主页，然后在左侧菜单中选择OWASP 2017 | 跨站脚本攻击 | 基于DOM的 | 密码生成器。
- en: This page uses the username query string value (which is anonymous in this case)
    to display on the page (it shows in the message This password is for [username]).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面使用用户名查询字符串值（在本例中为匿名）在页面上显示（它显示为“此密码适用于[用户名]”）。
- en: 'First, let''s try to change the anonymous username value to `gus` in the URL:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们尝试在URL中将匿名用户名的值更改为`gus`：
- en: '![](Images/bb031df2-a069-45d5-930f-e0f8779e76d3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bb031df2-a069-45d5-930f-e0f8779e76d3.png)'
- en: 'Let''s inspect the page source by hitting the *F12* key on your keyboard, and
    see if we can analyze it. In the developer inspector section of Firefox, hit *Ctrl*
    + *F* to find the word `gus` in the DOM. The first match shows you the HTML part
    and the second one shows you the JavaScript part:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过按*F12*键查看页面源代码，看看我们是否能分析它。在Firefox的开发者工具中，按*Ctrl* + *F*查找DOM中的`gus`。第一次匹配会显示HTML部分，第二次匹配会显示JavaScript部分：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking at the results, we can manipulate the DOM string to look legit and
    executable in JavaScript:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下结果，我们可以操作DOM字符串，使其在JavaScript中看起来合法并且可执行：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, go to the Decoder tab in Burp/Decoder and paste the value there to encode
    it as an URL (in the right section select Encode as... then select URL from the
    dropdown list):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到Burp/Decoder中的解码器选项卡，并将该值粘贴到那里，将其编码为URL（在右侧部分选择“Encode as...”然后从下拉列表中选择“URL”）：
- en: '![](Images/a1a530db-bed8-415e-a052-00904193f822.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a1a530db-bed8-415e-a052-00904193f822.png)'
- en: 'Finally, let''s paste the encoded result in the Password Generator page URL.
    Hit the refresh button in your browser and you should get an alert:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将编码后的结果粘贴到密码生成器页面的URL中。点击浏览器中的刷新按钮，你应该会看到一个警报：
- en: '![](Images/657ac18d-c372-4553-b01b-c0923e50db59.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/657ac18d-c372-4553-b01b-c0923e50db59.png)'
- en: JavaScript validation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript验证
- en: 'What if the page is protected by JavaScript validation, do you think we still
    can hack it? Of course we can; the JavaScript validation is not enough—we should
    do it on the server as well. Let''s see how to overcome JavaScript using Burp:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面受到了JavaScript验证保护，你认为我们还能攻击它吗？当然可以；JavaScript验证是不够的——我们还应该在服务器端进行验证。让我们看看如何使用Burp克服JavaScript验证：
- en: 'First, we will switch the security level to 1, which will enable JavaScript
    validation, by clicking on the **Toggle Security** button in the Mutillidae menu
    bar:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将安全级别切换到1，这样就会启用JavaScript验证，方法是点击Mutillidae菜单栏中的**Toggle Security**按钮：
- en: '![](Images/7205fec2-33d0-442c-becb-4243e7f43129.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7205fec2-33d0-442c-becb-4243e7f43129.png)'
- en: 'Try to visit the same page above from the menu; on the left menu, choose OWASP
    2017 | Cross Site Scripting | Reflected | DNS Lookup and let''s try to execute
    our alert script:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从菜单中访问上述相同页面；在左侧菜单中，选择OWASP 2017 | 跨站脚本攻击 | 反射型 | DNS查找，然后让我们尝试执行我们的警报脚本：
- en: '![](Images/5df9510f-e162-48eb-9e77-fd42e5a29fb7.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5df9510f-e162-48eb-9e77-fd42e5a29fb7.png)'
- en: 'As you can see, the script was blocked by the browser, it didn''t even allow
    me to continue typing my script because of the validation rule applied to the
    textbox field. But this should not be a reason to stop us from going forward;
    I will enable the proxy in my browser (as I showed you in the previous chapter)
    and start Burp/Proxy to intercept the request:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，脚本被浏览器阻止了，它甚至没有允许我继续输入脚本，因为文本框字段上应用了验证规则。但这不应该成为阻止我们继续前进的原因；我将启用浏览器中的代理（如我在上一章中向你展示的），并启动Burp/Proxy来拦截请求：
- en: '![](Images/233caa85-4e52-402b-81a6-c54ed2770280.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/233caa85-4e52-402b-81a6-c54ed2770280.png)'
- en: 'I will change the `target_host` value and insert my alert script. Next, let''s
    forward it to the server (using the Forward button):'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将更改`target_host`值并插入我的警报脚本。接下来，我们将其转发到服务器（使用“Forward”按钮）：
- en: '![](Images/5f410111-bbf7-4090-adb7-b74dacf061d1.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5f410111-bbf7-4090-adb7-b74dacf061d1.png)'
- en: 'Check this out! The JavaScript has executed successfully:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 看这里！JavaScript成功执行了：
- en: '![](Images/5daeb0be-427b-41bb-a23c-e1f39e21352a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5daeb0be-427b-41bb-a23c-e1f39e21352a.png)'
- en: Cross-Site Request Forgery
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: A **Cross-Site Request Forgery** (**CSRF**) (some people pronounce it as *sea
    surf*), can be exploited when an attacker takes advantage of the user session
    to perform state-changing requests such as posting to a social network platform,
    money transfers, and much more.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）（有些人将其发音为*sea surf*），当攻击者利用用户会话执行更改状态的请求时，如发布到社交网络平台、转账等，可以被利用。'
- en: 'This attack will involve some social engineering efforts from the attacker
    to convince the victim to visit the infected site. Imagine that the victim is
    an admin of a system, then the attacker can manipulate that system if it doesn''t
    have a CSRF protection. The most popular question in interviews for Application
    Security Engineer positions is the following: *What is the difference between
    XSRF and XSS? *The simpler the answer is, the better. In summary, XSS attacks
    rely on executing JavaScript in the victim''s browser, while XSRF relies on taking
    advantage of the victim''s session. Next time you have an interview, keep that
    in mind, maybe it will get you your dream job!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击将需要攻击者进行一些社会工程学操作，来说服受害者访问被感染的站点。假设受害者是系统的管理员，那么攻击者可以在该系统没有CSRF保护的情况下操控它。在应用安全工程师职位的面试中，最常见的问题是：*XSRF和XSS有什么区别？*
    答案越简洁越好。简而言之，XSS攻击依赖于在受害者的浏览器中执行JavaScript，而XSRF依赖于利用受害者的会话。下次面试时，记住这一点，或许这能帮助你获得梦寐以求的工作！
- en: 'First of all, you need to understand an important basic concept. When you first
    authenticate to a website, a session cookie will be created uniquely for you and
    this cookie will remain until it expires. Another tricky thing about this concept
    is that your session cookie will remain even if you browse to another site (for
    example, the attacker site). Let''s take a look at an example of CSRF:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要理解一个重要的基本概念。当你第一次对网站进行身份验证时，一个会话cookie会为你唯一创建，并且该cookie将保持有效直到过期。这个概念的另一个棘手之处在于，即使你浏览到另一个站点（例如攻击者站点），你的会话cookie仍然会保持。我们来看一个CSRF的例子：
- en: Step 01 – victim
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤01 - 受害者
- en: 'The poor victim in this scenario will log into his account using the login
    page of Mutillidae. Once in, he browses to his blog page (using the left menu
    and then selecting OWASP 2017 | CSRF | Add to your blog). He uses his blog to
    add a new article (you know the guy is a super blogger!):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者将在这种情况下使用 Mutillidae 的登录页面登录他的账户。一旦登录，他会浏览到他的博客页面（使用左侧菜单，然后选择 OWASP 2017
    | CSRF | 添加到你的博客）。他用博客添加了一篇新文章（你知道这个家伙是个超级博客写手！）：
- en: '![](Images/c27254ef-6e66-4faa-af34-77e5a26939c4.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c27254ef-6e66-4faa-af34-77e5a26939c4.png)'
- en: Step 02 – attacker
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 02 – 攻击者
- en: 'On the other hand, the attacker has already accessed the same blog site and
    he has a different account that he uses to blog about anonymous activities on
    a daily basis. The attacker saw that this site is already vulnerable to Cross-Site
    Request Forgery using his favorite scanner, Burp. Next, he will build a malicious
    page to infect his victims. To build his page, he enabled the proxy/intercept
    in Burp to analyze the contents of the web requests. On the Intercept page, he
    will right-click on the request and try to generate a CSRF POC:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，攻击者已经访问了同一个博客网站，并且他有一个不同的账号，每天用来发布关于匿名活动的博客文章。攻击者发现这个网站已经存在跨站请求伪造（CSRF）漏洞，他使用他最喜欢的扫描工具
    Burp 进行了扫描。接下来，他将构建一个恶意页面来感染他的受害者。为了构建该页面，他启用了 Burp 的代理/拦截功能，分析 Web 请求的内容。在拦截页面中，他会右键点击请求并尝试生成
    CSRF POC（概念验证）：
- en: '![](Images/2ea37056-11d3-41d4-b5a0-0d508e016f80.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2ea37056-11d3-41d4-b5a0-0d508e016f80.png)'
- en: 'After that, a new pop-up window will show. At this moment, the attacker can
    take the generated HTML code and use it by copying the contents (using the Copy
    HTML button) generated by Burp:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，一个新的弹出窗口会出现。在这一刻，攻击者可以将生成的 HTML 代码复制出来，并使用 Burp 生成的内容（通过点击复制 HTML 按钮）：
- en: '![](Images/ffe55a27-821c-4f63-b7fb-97ae7d96c51c.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ffe55a27-821c-4f63-b7fb-97ae7d96c51c.png)'
- en: 'Then, Elliot, the attacker, takes this HTML code and saves it on his Kali machines''
    web server (he copied the HTML file to the `/var/www/html/` directory and later
    started his Apache server using the command `service apache2 start`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，攻击者 Elliot 将这段 HTML 代码保存到他的 Kali 机器的 web 服务器上（他将 HTML 文件复制到`/var/www/html/`目录，并使用命令`service
    apache2 start`启动了 Apache 服务器）：
- en: '![](Images/c5e6b56f-827c-4b78-aec1-fda47c73a910.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5e6b56f-827c-4b78-aec1-fda47c73a910.png)'
- en: 'Now, Elliot''s server is ready for his victim to visit. He used social engineering
    tactics to convince his victim to go to that page and click this magic button:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Elliot 的服务器已经准备好让受害者访问。他运用了社会工程学手段，成功说服受害者访问该页面并点击这个神奇的按钮：
- en: For this attack to work, the victim needs to be already signed in using Mutillidae.
    Remember, we will use his session, so we need it to be active by having the victim
    logged in to the system.![](Images/716b77e0-3182-439f-9063-18fe7fe9ca59.png)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个攻击成功，受害者需要先通过 Mutillidae 登录。记住，我们将使用他的会话，因此我们需要确保他已登录系统并且会话处于活动状态！[](Images/716b77e0-3182-439f-9063-18fe7fe9ca59.png)
- en: Results
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果
- en: After clicking on this button (the Submit request button), the victim will be
    surprised when he visits his blog page and sees a blog that he did not save. Oops!
    Too bad Mr. Victim, that's because the blog is vulnerable to a CSRF flaw!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这个按钮（提交请求按钮）后，受害者将会惊讶地发现，当他访问自己的博客页面时，看到了一篇他没有保存的博客。哎呀！太可惜了，先生，受害者，因为博客存在
    CSRF 漏洞！
- en: '![](Images/26945e0b-3789-4db7-a6a7-487f90b06a09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26945e0b-3789-4db7-a6a7-487f90b06a09.png)'
- en: SQL Injection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 注入
- en: The SQL Injection is my favorite one, and it's the most dangerous one that you
    will encounter in your career. An SQL Injection vulnerability will allow a malicious
    user to execute SQL commands on the database through the web browser. The cause
    of this problem is like any other web vulnerability; the developer forgot to add
    any validation on the server side to protect against SQLi attacks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入是我最喜欢的攻击方式，也是你在职业生涯中最危险的一种。SQL 注入漏洞允许恶意用户通过 Web 浏览器在数据库上执行 SQL 命令。这个问题的根源和其他
    Web 漏洞类似；开发人员忘记在服务器端添加验证以防范 SQLi 攻击。
- en: 'Here''s the most interesting part; an SQLi vulnerability will allow you to
    do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有趣的部分；SQL 注入漏洞将允许你做以下事情：
- en: Query the database using a `select` statement (for example, select the users
    table, thereby extracting the usernames and passwords)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `select` 语句查询数据库（例如，选择 users 表，从而提取用户名和密码）
- en: Bypass the login page by executing successful query results (you'll see an example
    soon)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行成功的查询结果绕过登录页面（你将很快看到一个示例）
- en: Execute system commands in the database in order to compromise the web server
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中执行系统命令以入侵 Web 服务器
- en: Execute inserts/delete commands to manipulate the records in the database
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行插入/删除命令以操作数据库中的记录
- en: It's time to see some actions folks! You will be shocked to see how powerful
    this vulnerability can be to a system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该展示的时候到了，大家准备好震惊吧！你将看到这个漏洞对系统的威力有多强大。
- en: Authentication bypass
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过身份验证
- en: 'When a user tries to authenticate to a system, the backend will execute a query
    that looks like this (for this example I''m using the credentials that I use to
    log in to Mutillidae):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试进行系统身份验证时，后端会执行一个类似这样的查询（在这个示例中，我使用的是我登录Mutillidae时的凭据）：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After executing the preceding query, the database will check if the record
    exists and if yes (the record exists) then a Boolean `True` value is returned
    and the user is authenticated. Hackers will take advantage of this theory to trick
    the database with a query that will always return a `True` value:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述查询后，数据库将检查记录是否存在，如果存在（记录确实存在），则返回布尔值`True`，并且用户通过身份验证。黑客将利用这个理论，通过一个始终返回`True`值的查询来欺骗数据库：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`or 1=1` will always return a true value and the `--` symbol is telling MySQL
    that everything after it is a comment, so it will ignore the rest of the query;
    tricky right?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`or 1=1`将始终返回一个正确的值，而`--`符号告诉MySQL在其后面的内容是注释，因此它会忽略查询的其余部分；巧妙吧？'
- en: 'To test this idea in Mutillidae, in the menu, select: OWASP 2017 | Injection
    SQL | SQLi - Bypasss Authentication | Login.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mutillidae中测试这个思路，在菜单中选择：OWASP 2017 | 注入 SQL | SQLi - 绕过身份验证 | 登录。
- en: 'Once you''re on the login page, enter the magic query that we saw previously
    to bypass the authentication of this page (sometimes you have to enter a space
    character after the `--` for this query to work):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入登录页面，输入我们之前看到的魔法查询来绕过此页面的身份验证（有时你需要在`--`后输入一个空格字符才能使此查询生效）：
- en: '![](Images/b51e1cb5-bbb8-48c4-8543-2ea89915a3ea.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b51e1cb5-bbb8-48c4-8543-2ea89915a3ea.png)'
- en: 'Check this out, folks! I''m a super admin authenticated user (see the following
    screenshot):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 看这里，伙计们！我是一个超级管理员已认证用户（见下图截图）：
- en: '![](Images/30b736fe-bba7-4529-b52f-6b5b12f8a3fb.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/30b736fe-bba7-4529-b52f-6b5b12f8a3fb.png)'
- en: Extracting the data from the database
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中提取数据
- en: 'Most of the leaked online passwords are done through this kind of attack. If
    you encounter this vulnerability during your pentests then it means you just hit
    the jackpot. The idea here is to be able to execute the famous query:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在线泄露的密码就是通过这种攻击方式获得的。如果你在渗透测试中遇到这个漏洞，那就意味着你中了大奖。这里的关键是能够执行著名的查询：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assuming that the database has a users table, this query will extract all the
    user's records from the database. It's like Christmas day; you're going to have
    all the usernames and passwords in a wrapped gift.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中有一个用户表，这个查询将从数据库中提取所有用户的记录。这就像圣诞节一样；你将得到所有的用户名和密码，仿佛是包裹里的礼物。
- en: Error-based SQLi enumeration
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于错误的SQLi枚举
- en: This technique relies on manipulating any input (for example, query string)
    to the backend and waiting for an error message to appear.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术依赖于操控任何输入（例如，查询字符串）到后端，并等待错误消息出现。
- en: 'Nothing is better than a real example, so let me show you one using Mutillidae:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比真实示例更有说服力了，让我用Mutillidae给你展示一个例子：
- en: 'In the home page of Mutillidae, select the following item from the left menu:
    OWASP 2017 | Injection SQL | SQLi - Extract Data | User Info (SQL).'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mutillidae的首页，从左侧菜单中选择以下项目：OWASP 2017 | 注入 SQL | SQLi - 提取数据 | 用户信息 (SQL)。
- en: 'In the User Lookup page, enter your credentials and hit the View Account Details
    button:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户查找页面，输入你的凭据并点击“查看账户详情”按钮：
- en: '![](Images/20e2b93f-38a5-4700-bc38-bbbcf2a4458d.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/20e2b93f-38a5-4700-bc38-bbbcf2a4458d.png)'
- en: 'This page is executing a query in the backend to get our username and password.
    Let''s enter a single quote `''` in the name field and check the results (the
    single quote):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面在后端执行一个查询以获取我们的用户名和密码。让我们在名字字段中输入一个单引号`'`并检查结果（单引号）：
- en: '![](Images/9a91645d-1559-488a-b472-57ed42fbc8a7.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9a91645d-1559-488a-b472-57ed42fbc8a7.png)'
- en: 'As you can see at the bottom, we have an error message telling us that the
    SQL server did not understand our single quote:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，底部有一个错误信息，告诉我们SQL服务器无法理解我们的单引号：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In other words (in the hacker world), the SQL database has executed our single
    quote, hence, we can write our own query to extract data from the database. If
    we try to execute the magic query that we used to bypass the login page (`admin''
    or 1=1 --` ), then guess what? The database will be happy to return all the records
    in the accounts table:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 换句话说（在黑客世界中），SQL数据库执行了我们的单引号，因此我们可以编写自己的查询来从数据库中提取数据。如果我们尝试执行绕过登录页面的魔法查询（`admin'
    or 1=1 --`），那么猜猜看？数据库将很高兴地返回所有账户表中的记录：
- en: '![](Images/42092b0c-9d00-488f-9ea6-a873af4fb1ed.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/42092b0c-9d00-488f-9ea6-a873af4fb1ed.png)'
- en: Blind SQLi
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blind SQLi
- en: 'When we don''t have a verbose error message and the database still executes
    a query in the backend, then we can blindly SQL inject our query: it''s called
    **Blind SQL Injection**. You can use the same examples shown previously, but assume
    that the server will not return an error message for you. In the end, you can
    still execute the magic query (`admin'' or 1=1 --`).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有详细的错误消息，且数据库仍然在后台执行查询时，我们就可以盲目地进行SQL注入：这被称为**盲SQL注入**。你可以使用前面展示的相同示例，但假设服务器不会为你返回错误消息。最终，你仍然可以执行魔法查询（`admin'
    or 1=1 --`）。
- en: Command Injection
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令注入
- en: Command Injection is very simple, you just exploit it by executing commands
    on a web page because it allows you to do so. In other words, if you ever see
    a page that offers the functionality of executing a command in the backend, then
    it's probably vulnerable to this attack. Command Injection is very popular in **Capture
    the Flag** (**CTF**) because it allows you to completely own a remote machine
    (the machine that hosts the web application).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入非常简单，你只需要通过在网页上执行命令来利用它，因为它允许你这么做。换句话说，如果你曾经看到一个页面提供了在后台执行命令的功能，那么它很可能容易受到这种攻击。命令注入在**CTF（夺旗赛）**中非常流行，因为它允许你完全控制远程机器（托管网页应用程序的机器）。
- en: 'As usual, let''s see a practical example using Mutillidae. Open the left menu 
    OWASP 2017 | Injection | Command Injection | DNS Lookup:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，让我们使用Mutillidae来看一个实际例子。打开左侧菜单 OWASP 2017 | 注入 | 命令注入 | DNS查找：
- en: '![](Images/bde5d290-7055-4588-bc6a-141aa9d646f4.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bde5d290-7055-4588-bc6a-141aa9d646f4.png)'
- en: This page executes the DNS Lookup command in the backend. In this example, I
    entered the IP address `10.0.0.1` and clicked on the **Lookup DNS** button.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面在后端执行DNS查找命令。在这个例子中，我输入了IP地址`10.0.0.1`并点击了**Lookup DNS**按钮。
- en: 'Do you think we can override the normal behavior of this page and execute any
    command of our liking? (Or maybe execute a backdoor such as `netcat`, just a hint).
    Let''s analyze the functionality on this page first. We are passing the IP address
    (or hostname) as a variable to a function in the backend that executes most probably
    in the following way:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为我们能否覆盖此页面的正常行为并执行任何我们喜欢的命令？（或者可能执行一个后门，例如`netcat`，仅供参考）。我们先来分析一下这个页面的功能。我们将IP地址（或主机名）作为变量传递给后端的一个函数，后端很可能是以如下方式执行的：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we''re lucky and the developer didn''t validate it, we can append other
    commands after the variable and the application will be happy to execute it for
    us. Our goal is to make the backend execute something like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运气好，而且开发者没有做验证，我们可以在变量后附加其他命令，应用程序将会很高兴地为我们执行它。我们的目标是让后端执行如下内容：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's see if this is going to work! For the POC, I will use the `dir` command
    (since it's a Windows machine that hosts Mutillidae).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是否有效！对于POC，我将使用`dir`命令（因为它是托管Mutillidae的Windows机器）。
- en: 'I will enter the IP address and the `dir` command in the Hostname/IP: `10.0.0.1
    && dir` and click on the Lookup DNS button:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在主机名/IP中输入IP地址和`dir`命令：`10.0.0.1 && dir`，然后点击Lookup DNS按钮：
- en: '![](Images/d4b6ae29-8760-4808-a4da-ae8746892390.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d4b6ae29-8760-4808-a4da-ae8746892390.png)'
- en: Amazing! The `dir` command has executed successfully!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`dir`命令已成功执行！
- en: OWASP Top 10
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OWASP Top 10
- en: In the preceding section, you've seen the most important web application vulnerabilities
    in the OWASP Top 10\. The OWASP list includes even more items than what you have
    witnessed up until now. Application Security Professionals always keep the OWASP
    Top 10 as a reference in their career. This list is always kept up to date by
    the OWASP community and the latest version is the one that you saw in the Mutillidae
    Menu OWASP Top 10 – 2017; if you're reading this book in the future then there
    will probably be a newer list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了 OWASP Top 10 中最重要的 Web 应用程序漏洞。OWASP 列表中包含的项目比你到目前为止看到的还要多。应用程序安全专家在职业生涯中总是将
    OWASP Top 10 作为参考。这个列表始终由 OWASP 社区保持更新，最新版本就是你在 Mutillidae 菜单中看到的 OWASP Top 10
    – 2017；如果你在未来阅读这本书，可能会看到更新的版本。
- en: If you have any doubts about the understanding of any of the top 10 items, then
    don't worry, because we will revisit those items one more time in the web intrusion
    tests later in this book with more practical examples; for the time being, try
    to see the big picture.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前面提到的十大项目中的任何一项存在疑问，请不要担心，因为我们将在本书后面的 Web 入侵测试部分使用更多实际示例再次回顾这些项目；目前，尽量从大局上理解。
- en: Let's take a look at the Top 10 items in a simplified way so you can understand
    these vulnerabilities from a high-level overview.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以简化的方式来看看排名前十的项目，这样你可以从高层次的视角理解这些漏洞。
- en: 1 – Injection
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 – 注入漏洞
- en: Injection flaws can happen when an attacker can inject and execute a custom
    command in the backend because of missing sanitization. In this chapter, you've
    seen SQL Injection and Command Injection but there are more, for example, LDAP,
    XPath, NoSQL,**Object Relational Mapping** (**ORM**) tool, XML Parsers, and SMTP
    Headers (and the list is increasing over time).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞可能发生在由于缺乏清理而导致攻击者可以在后台注入并执行自定义命令的情况下。在本章中，你已经看到了 SQL 注入和命令注入，但还有更多类型，例如
    LDAP、XPath、NoSQL、**对象关系映射**（**ORM**）工具、XML 解析器和 SMTP 头（这个列表还在不断增加）。
- en: 2 – Broken Authentication
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 – 身份验证失败
- en: 'This flaw occurs when a hacker finds the user''s identity, credentials (both
    username and password), or web session. This can happen when a system:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当黑客找到用户的身份、凭证（包括用户名和密码）或 Web 会话时，会发生这种漏洞。系统可能会在以下情况下发生：
- en: Allows automated attacks, where the attacker can guess valid usernames and passwords
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许自动化攻击，攻击者可以猜测有效的用户名和密码
- en: Permits brute force or other automated attacks
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许暴力破解或其他自动化攻击
- en: Allows default, weak, or well-known passwords, such as `Password123`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用默认的、弱的或常见的密码，例如`Password123`
- en: Uses weak or ineffective credential recovery and forgot-password methods
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱或无效的凭证恢复和忘记密码方法
- en: Uses plain text, encrypted, or weakly hashed passwords
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用明文、加密或弱哈希的密码
- en: Exposes Session IDs in the URL
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 URL 中暴露会话 ID
- en: Does not manage the Session properly after a successful login
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功登录后未正确管理会话
- en: 3 – Sensitive Data
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 – 敏感数据
- en: 'This flaw occurs when the web application handles confidential information
    in clear text, either at rest (for example, a database connection string password
    in clear text) or in transit (for example, HTTP instead of HTTPS). In practice,
    you need to look for the following issues:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 应用程序以明文处理机密信息时，无论是在静态状态下（例如，数据库连接字符串密码以明文形式存储）还是在传输过程中（例如，使用 HTTP 而不是
    HTTPS），都会发生此漏洞。实际上，你需要注意以下问题：
- en: Missing security headers (I will show you the security headers in upcoming chapters
    when we talk about secure coding practices)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少安全头（稍后我们将在讨论安全编码实践时向你展示安全头）
- en: Any weak cipher algorithms used at rest or in transit (for example, MD5)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何在静态状态或传输过程中使用的弱加密算法（例如，MD5）
- en: Any clear text protocols used to transmit data (for example, HTTP, FTP, Telnet,
    or SMTP)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何用于传输数据的明文协议（例如，HTTP、FTP、Telnet 或 SMTP）
- en: Any issues with the TLS/SSL certificate
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 TLS/SSL 证书的问题
- en: 4 – XML External Entities
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 – XML 外部实体
- en: 'Old applications that still use XML/SOAP web services are the ones that are
    the most susceptible to this kind of attack. In fact, any application (or backend)
    that uses XML to execute its functions will be a victim of this kind of flaw;
    this attack can lead to DOS (denial of service). So, here''s the list that you
    should keep in mind when handling XML items:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用 XML/SOAP Web 服务的旧应用程序最容易受到此类攻击。事实上，任何使用 XML 来执行其功能的应用程序（或后端）都会成为这种漏洞的受害者；这种攻击可能导致拒绝服务（DOS）。因此，以下是你在处理
    XML 项目时应牢记的清单：
- en: Is the application using a SOAP version older than 1.2?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否使用早于 1.2 版本的 SOAP？
- en: Does the application use SAML within a federated or **single sign-on** (**SSO**)
    environment?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否在联合身份认证或**单点登录**（**SSO**）环境中使用SAML？
- en: Does the application support any XML file upload?
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否支持任何XML文件上传？
- en: Does the application execute any of the items in the XML that can be manipulated?
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否执行XML中的任何可被篡改的项目？
- en: 5 – Broken Access Control
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 – 访问控制破坏
- en: 'This attack can happen when the attacker can execute functionalities that he
    is not allowed to perform (for example, admin privileges). This flaw can lead
    to information disclosure and performing unwanted actions such as deleting, adding,
    or changing data. From a practical point of view, as a penetration tester, ask
    yourself the following questions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者能够执行他不允许执行的功能（例如，管理员权限）时，就会发生这种攻击。这个漏洞可能导致信息泄露以及执行不想要的操作，如删除、添加或修改数据。从实际操作的角度看，作为渗透测试人员，问自己以下问题：
- en: Can you call the back-end web services (SOAP or REST) and perform unintended
    actions?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能调用后端Web服务（SOAP或REST）并执行非预期的操作吗？
- en: As a normal user, can you call admin functions?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为普通用户，你能调用管理员功能吗？
- en: Does the server validate the **JSON Web Tokens** (**JWT**)?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是否验证**JSON Web Tokens**（**JWT**）？
- en: 6 – Security Misconfiguration
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 – 安全配置错误
- en: 'This flaw is due to a nonsecure configuration on any of the servers (web, web
    service, or database). This includes the infrastructure and not only the application
    level configurations. As an application security expert, you need to check both
    the infrastructure level security and the application level as well. Let''s see
    a few tips that can give us some ideas about this issue:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞是由于服务器（Web、Web服务或数据库）中的不安全配置引起的。它包括基础设施级别的配置，而不仅仅是应用程序层面的配置。作为一名应用程序安全专家，你需要检查基础设施层级的安全性和应用程序层级的安全性。我们来看一些可以给我们提供灵感的建议：
- en: Are any of the production servers (web, web service, or database) missing any
    patches?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何生产服务器（Web、Web服务或数据库）缺少补丁？
- en: Do any of the production servers (web, web service, or database) have some default
    non-secure settings? (For example, default credentials.)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何生产服务器（Web、Web服务或数据库）存在默认的非安全设置？（例如，默认凭证。）
- en: Are any unnecessary services enabled on any of the servers?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否在任何服务器上启用了不必要的服务？
- en: Is the application using default error messages that display to users details
    about the stack trace?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否使用显示给用户的默认错误消息，透露堆栈跟踪的详细信息？
- en: Are any dev environments deployed into production? (For example, test pages,
    test credentials, test data.)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何开发环境被部署到生产环境中？（例如，测试页面、测试凭证、测试数据。）
- en: 7 – Cross-Site Scripting (XSS)
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 – 跨站脚本攻击（XSS）
- en: 'You already know this one, right? Just a quick reminder: this flaw is exploited
    when the attacker can execute JavaScript on the browser (reflected, stored, or
    DOM-based).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经知道这个漏洞了吧？只需提醒一下：当攻击者能够在浏览器上执行JavaScript时（反射型、存储型或基于DOM的XSS攻击），就会利用此漏洞。
- en: 8 – Insecure Deserialization
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 – 不安全的反序列化
- en: This one is rare and you will probably never see it in your career, but since
    it's there on the list, I still owe you an explanation. This attack can be executed
    on any system that serializes/deserializes data. This attack can be achieved when
    the attacker modifies the application's logic or tries to run a remote code execution
    if there are objects in the application that can change behavior or execute during
    or after deserialization.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个情况很少见，可能在你的职业生涯中永远也不会遇到，但既然它出现在列表中，我还是得给你一个解释。这个攻击可以在任何序列化/反序列化数据的系统上执行。当攻击者修改应用程序的逻辑或试图运行远程代码执行时，如果应用程序中有能够改变行为或在反序列化过程中或之后执行的对象，就可以实现此攻击。
- en: 9 – Using Components with Known Vulnerabilities
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 – 使用存在已知漏洞的组件
- en: 'This flaw is related to unsecured or vulnerable application components  (for
    example, third-party libraries). In practice, always ask yourself the following
    questions to know if you have this type of flaw:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞与不安全或易受攻击的应用程序组件有关（例如，第三方库）。在实践中，总是问自己以下问题，看看是否存在这种漏洞：
- en: Are any unsecured libraries used in the application?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否使用了任何不安全的库？
- en: Is any unpatched/legacy software used?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用了任何未修补/遗留软件？
- en: Are any unsecured components used to support the application? (Flash, ActiveX,
    VBS, and so on; you get the idea.)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用了任何不安全的组件来支持应用程序？（例如，Flash、ActiveX、VBS等；你懂的。）
- en: 10 – Insufficient Logging & Monitoring
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 – 日志记录与监控不足
- en: Insufficient logging and monitoring will allow an attacker to execute an attack
    without any detection. Also, insufficient logging will not allow us to prove any
    actions. In other words, we cannot verify the repudiation of the user action.
    For example, a user can buy an item with 0$ from our online store, but we have
    no proof that he/she did it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不足的日志记录和监控将允许攻击者在没有任何检测的情况下发动攻击。此外，不足的日志记录还将无法证明任何行为。换句话说，我们无法验证用户行为的否认。例如，一个用户可以在我们的在线商店购买一件价值0$的商品，但我们没有任何证据证明他/她做过这件事。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope that you understood this chapter very well! I mean it; this chapter is
    key to your success in understanding application security vulnerabilities. If
    you're hesitant about any of the preceding topics, please stop and try to review
    them one more time. You should already have installed Mutillidae on your lab machine
    and started practicing all the preceding examples.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经很好地理解了这一章！我是认真的；这一章是你理解应用安全漏洞的关键。如果你对前面提到的任何内容有疑问，请停下来再复习一次。你应该已经在实验机上安装了Mutillidae，并开始练习所有前面的示例。
- en: The topics that we discussed in this chapter do not incorporate all web application
    vulnerabilities, but I covered the most important ones that you will encounter
    in your career. SQLi is the most dangerous one and XSS is the most popular one
    that you will face during Web Intrusion Tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题并没有涵盖所有的Web应用漏洞，但我涵盖了你在职业生涯中将会遇到的最重要的一些。SQL注入是最危险的，而跨站脚本（XSS）则是你在Web渗透测试中最常遇到的漏洞。
- en: Later, we will re-visit these vulnerabilities over and over again, and that's
    why you must master this chapter; if you don't, you will find the upcoming chapters
    difficult to understand.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将反复回顾这些漏洞，这就是为什么你必须掌握这一章的原因；如果你没有掌握，接下来的章节你将很难理解。
