- en: '*Chapter 11*: Shellcoding – Bypassing Protections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：Shellcoding – 绕过保护'
- en: When I’m in a conversation with friends and family about airport security, a
    quip I often hear is *maybe we should just ban the passengers*. Though this is
    obviously facetious, let’s think about it for a moment—no matter what we do to
    screen everyone walking onto an airplane, we have to allow at least some people
    through the gates, particularly the pilots. There’s a clear divide between the
    malicious outsider with no good intention and the trusted insider who, by virtue
    of their role, must be given the necessary access to get some work done. Let’s
    think of the malicious outsiders trying to get on the plane as shellcode, and
    the trusted pilot who runs the show as a legitimate native binary. With perfect
    security screenings guaranteeing that no malicious individual can walk onto a
    plane, you will still have to trust that the pilot isn’t corrupted by an outside
    influence; that is, their power is being leveraged to execute a malicious deed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我和朋友或家人谈论机场安全时，我常常听到一句玩笑话：“也许我们应该直接禁止乘客登机”。虽然这显然是讽刺的，但让我们稍作思考——无论我们如何筛查每个登机的人，我们仍然必须让至少一些人通过，特别是飞行员。恶意的外部人员与信任的内部人员之间有明显的界限，后者因为他们的角色需要被赋予必要的访问权限以完成工作。我们可以将恶意的外部人员比作shellcode，将负责操作的信任飞行员比作合法的本地二进制文件。在完美的安全筛查确保没有恶意人员能登机的情况下，你仍然必须相信飞行员没有受到外部影响的腐蚀；也就是说，他们的权力被用来执行恶意行为。
- en: Welcome to the concept of **return-oriented programming** (**ROP**), where the
    world we live in is a paradise in which no shellcode can be injected and executed,
    but we’ve figured out how to leverage the code that’s already there to do our
    dirty work. We’re going to learn how combining the density of the x86 instruction
    set with a good old-fashioned buffer vulnerability in a program allows us to construct
    almost any arbitrary functionality. We’ll take a break from injecting bad code
    and learn how to turn the good code against itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**返回导向编程**（**ROP**）的概念，在这个世界中，我们生活在一个没有办法注入和执行shellcode的“天堂”，但我们已经找到了如何利用已有代码来完成我们的“肮脏工作”。我们将学习如何将x86指令集的密度与传统的程序缓冲区漏洞结合，从而构造几乎任何任意功能。我们将暂时不再注入恶意代码，学习如何将“好代码”反过来用在自身。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the core defense concepts, such as **data execution prevention**
    (**DEP**) and **address space layout randomization** (**ASLR**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解核心防御概念，如**数据执行防护**（**DEP**）和**地址空间布局随机化**（**ASLR**）
- en: Learning how to examine machine code and memory to identify instructions that
    we can leverage for our purposes, called **gadgets**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何检查机器码和内存，识别可以为我们所用的指令，这些指令被称为**小工具**（gadgets）
- en: Understanding the different types of ROP-based attacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于ROP的不同类型的攻击
- en: Exploring the tools used by hackers to pull off ROP attacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索黑客们用来实施ROP攻击的工具
- en: Writing and attacking a vulnerable C program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并攻击一个易受攻击的C程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For ROP, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ROP，你需要以下内容：
- en: 32-bit Kali Linux 2021.3
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位Kali Linux 2021.3
- en: ROPgadget
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROPgadget
- en: DEP and ASLR – the intentional and the unavoidable
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DEP和ASLR——有意为之与不可避免的情况
- en: 'So far, we’ve only mentioned these concepts in passing: DEP (which is also
    called NX for no-execute) and ASLR. I’m afraid we can’t put them off forever.
    I think I hear a couple of hackers at the back saying, *good! It took the impact
    out of the demonstrations when we had to disable basic protection to make the
    attack work*. Fair enough. When we introduced a basic buffer overflow in [*Chapter
    10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding – The Stack*,
    we explicitly disabled ASLR. (To be fair, Windows 7 comes out of the box like
    that.) This is all by design, though—we can’t understand the core concept without,
    first, taking a step back. These protection mechanisms are *responses* to the
    attacks we’ve demonstrated. But look at me, going off on a tangent again without
    defining these simple concepts.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是稍微提到了这些概念：DEP（也叫做NX，禁止执行）和ASLR。我恐怕我们不能永远避开它们。我听到后面有几个黑客在说，*好啊！当我们必须禁用基本保护才能让攻击生效时，演示的冲击力就消失了*。这说得也有道理。当我们在[*第10章*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)中介绍基本的缓冲区溢出时，*Shellcoding
    – 栈*，我们显式地禁用了ASLR。（公平来说，Windows 7系统开箱即用就是这样。）不过，这一切都是经过设计的——我们首先要回过头来，才能理解核心概念。这些保护机制是*应对*我们已展示过的攻击。但看看我，又在跑题，没定义这些简单的概念。
- en: Understanding DEP
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解DEP
- en: Do you remember where we stuff our shellcode? The answer is inside the stack
    or the heap, which is memory set aside for a thread of execution. When a function
    is running, space is allocated for variables and other data needed to get the
    work done; in other words, these are areas that are not intended to contain executable
    code. Picking a spot in memory to store a number but then later being told, *hey,
    remember that spot in memory? Let’s execute whatever’s sitting there*, should
    be suspicious. But don’t forget that processors are incredible, lightning-fast,
    and dumb. They will do what they’re told. This simple design of executing whatever
    is sitting at the location pointed to by the instruction pointer is what the shellcoding
    hacker exploits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们把shellcode放到哪里吗？答案是在栈或堆内存中，它是为执行线程预留的内存。当一个函数运行时，会为变量和其他完成任务所需的数据分配空间；换句话说，这些区域并不打算存放可执行代码。在内存中选择一个位置来存储一个数字，但后来被告知，*嘿，记得那个内存位置吗？让我们执行那里存放的内容*，应该是值得怀疑的。但不要忘了，处理器是非常强大、迅速且愚笨的。它们会按指令执行。这个简单的设计，即执行指令指针指向的位置的内容，就是shellcoding黑客所利用的。
- en: 'Enter DEP. The basic premise of DEP is to monitor whether the location that
    the instruction pointer is referencing has been explicitly marked as executable.
    If it isn’t, an access violation occurs. Windows has two types of DEP—*software-enforced* and *hardware-enforced*.
    The following screenshot shows what the DEP settings look like on the Windows
    interface:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进入DEP。DEP的基本原理是监控指令指针引用的内存位置是否被明确标记为可执行。如果没有标记，便会发生访问冲突。Windows有两种DEP——*软件强制*和*硬件强制*。以下截图展示了Windows界面上DEP设置的样子：
- en: '![Figure 11.1 – The DEP settings in Windows ](image/Figure_11.01_B17616.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – Windows中的DEP设置](image/Figure_11.01_B17616.jpg)'
- en: Figure 11.1 – The DEP settings in Windows
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – Windows中的DEP设置
- en: 'Software-enforced DEP operates at the higher levels of the OS, and hence, it
    is available on any machine that can run Windows and can protect against any attempts
    to ride on exception handling mechanisms. Hardware-enforced DEP uses the processor’s
    **Execute Disable** (**XD**) bit to mark memory locations as non-executable. Let’s
    take a look at the distinction between software-enforced and hardware-enforced:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件强制DEP在操作系统的更高层运行，因此，任何能运行Windows的机器都可以使用，并且可以防止任何试图利用异常处理机制的攻击。硬件强制DEP则使用处理器的**执行禁用**（**XD**）位来标记内存位置为不可执行。我们来看一下软件强制和硬件强制的区别：
- en: '![Figure 11.2 – Two kinds of DEP: software and hardware ](image/Figure_11.02_B17616.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 两种DEP：软件和硬件](image/Figure_11.02_B17616.jpg)'
- en: 'Figure 11.2 – Two kinds of DEP: software and hardware'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 两种DEP：软件和硬件
- en: So, how does this affect us as wily hackers? The whole trick is allocating memory
    for our code, which the program is treating like an ordinary variable. Meanwhile,
    we’re hoping the processor will take our word for it that the flow of execution
    is intended to jump to the instruction pointer address. First, let’s take a look
    at the randomization of locations in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对我们这些狡猾的黑客有什么影响呢？整个技巧在于为我们的代码分配内存，而程序将其视为普通变量。同时，我们希望处理器能信任我们，认为执行流的跳转是指向指令指针地址的。首先，让我们来看一下内存位置的随机化。
- en: Understanding ASLR
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ASLR
- en: Take a stroll back down memory lane to when we worked on the stack overflow
    attacks. We found the vulnerable **strcpy()** function in our code, we stuffed
    the buffer with nonsense characters and deliberately overflowed it, and we checked
    our debugger and found that EIP had been overwritten with our nonsense. With careful
    payload crafting, we could find the precise location in memory where we needed
    to place the pointer to our NOP sled to, ultimately, result in the execution of
    shellcode. Now, recall that we used gdb’s examine (**x**) tool to identify the
    exact location in memory where the EIP lies. Therefore, we could map out the stack
    and *reliably* land on top of that instruction pointer with each run of the process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下我们在处理栈溢出攻击时的经历。我们在代码中找到了易受攻击的**strcpy()**函数，往缓冲区填入无意义的字符，故意溢出它，然后查看调试器，发现
    EIP 被我们无意义的数据覆盖。通过精心构造有效载荷，我们能够找到内存中需要放置 NOP sled 指针的准确位置，最终执行 shellcode。现在，回想一下我们使用
    gdb 的 examine (**x**) 工具来确定 EIP 在内存中的确切位置。因此，我们能够绘制出栈的结构，并且每次运行进程时都能*可靠地*到达该指令指针的位置。
- en: 'Note that I emphasized “reliably.” Modern operating systems such as Windows
    allow for multiple programs to be open at once, and they all have massive amounts
    of addressable memory available to them—and by massive, I mean more than can be
    physically fit in a piece of RAM. Part of the operating system’s job is to figure
    out which portions of memory are less important so that they can be stored on
    the hard drive and brought into play via paging as needed. So, the program sees
    a large continuous block of memory space that is actually *virtual*, and the memory
    management unit manages the layer of abstraction that hides the physical reality
    behind the curtain:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我强调了“可靠性”一词。现代操作系统，如 Windows，允许多个程序同时运行，并且它们都有大量可寻址的内存可用——而这里的“大量”是指超出了物理内存所能容纳的范围。操作系统的部分职责是找出那些不太重要的内存部分，以便将它们存储在硬盘上，并在需要时通过分页调入使用。因此，程序看到的是一个庞大的连续内存块，实际上是*虚拟*的，而内存管理单元则管理着那一层隐藏物理现实的抽象：
- en: '![Figure 11.3 – The abstraction between virtual memory and its physical basis
    ](image/Figure_11.03_B17616.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 虚拟内存与其物理基础之间的抽象](image/Figure_11.03_B17616.jpg)'
- en: Figure 11.3 – The abstraction between virtual memory and its physical basis
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 虚拟内存与其物理基础之间的抽象
- en: Enter ASLR. The name is quite descriptive—the layout of the program’s nuts and
    bolts in virtual address space is moved around each time the program is run. This
    includes things such as libraries and the stack and heap. Sure, finding the places
    in memory where we can do our dirty deeds required good ole’ fashioned trial and
    error (a hacker’s greatest technique), but once discovered, they would remain
    consistent. ASLR destroys that for us by making targeting locations in memory
    a game of chance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 ASLR。这个名字很形象——程序在虚拟地址空间中的布局在每次运行时都会发生变化。这包括像库文件、栈和堆之类的内容。当然，要找到可以做我们“脏活”的内存位置，需要通过传统的试错方法（黑客的最大技巧），但一旦发现，它们就会保持一致。ASLR
    打破了这一点，它通过将内存中的目标位置变成一个机会游戏，来消除我们的依赖。
- en: I haven’t talked about libraries, and such a subject deserves its own massive
    book. Let’s have a quick refresher, though. Imagine the namesake, your local public
    library. It’s a place of *shared resources*—you can go take out a book to use
    the information inside it and then return it for someone else to use. Libraries
    are collections of resources for programs that can be reused. For example, the
    tasks of reading information out of files and writing data back into files need
    code to tell the computer how to do them, but they’re tasks that many different
    programs will need to do. So, instead of reinventing the wheel for every program,
    the numerous programs can all use the libraries that contain those functions.
    It’s possible to have your libraries included with your code when you compile
    your program—this uses more memory, but it will, understandably, run faster. These
    are static libraries. The more common method is dynamic libraries, which are linked
    when you run the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有讨论过库，这个话题值得一本巨大的书来讲解。虽然我们快速回顾一下吧。想象一下，名义上的“你所在的公共图书馆”。它是一个*共享资源*的地方——你可以去借一本书，利用其中的信息，然后再归还给其他人使用。库是程序可以重用的资源集合。例如，从文件中读取信息和将数据写回文件的任务，需要代码来告诉计算机如何执行，但这是许多不同程序都会需要做的事情。因此，不必为每个程序重新发明轮子，许多程序都可以使用包含这些功能的库。你可以在编译程序时将库与代码一起包含，这会使用更多内存，但可以更快速地运行。这些是静态库。更常见的方法是动态库，它们在你运行程序时被链接。
- en: Demonstrating ASLR on Kali Linux with C
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kali Linux上使用C演示ASLR
- en: We can watch ASLR in action on our native Kali Linux since it’s enabled by default.
    We’re going to type up a quick C program that merely prints the current location
    pointed to by ESP.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地的Kali Linux上观察ASLR的工作情况，因为它默认启用。我们将编写一个简单的C程序，仅仅打印当前ESP指向的位置。
- en: 'Fire up **vim stackpoint.c** to create the blank file, and punch out the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 启动**vim stackpoint.c**来创建一个空文件，然后输入以下内容：
- en: '![Figure 11.4 – A quick C program to print the location of ESP ](image/Figure_11.04_B17616.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 一个快速的C程序，打印ESP的位置](image/Figure_11.04_B17616.jpg)'
- en: Figure 11.4 – A quick C program to print the location of ESP
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 一个快速的C程序，打印ESP的位置
- en: 'That wasn’t so bad. Now compile it with **gcc -o stackpoint stackpoint.c**,
    and execute it a few times. You’ll see that the stack pointer bounces around with
    each run of the program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难。现在使用**gcc -o stackpoint stackpoint.c**编译它，然后执行几次。你会看到每次运行程序时栈指针的位置都会发生变化：
- en: '![Figure 11.5 – Our stack pointer program in action with randomization ](image/Figure_11.05_B17616.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 我们的栈指针程序在启用随机化时的运行情况](image/Figure_11.05_B17616.jpg)'
- en: Figure 11.5 – Our stack pointer program in action with randomization
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 我们的栈指针程序在启用随机化时的运行情况
- en: 'This is what virtual memory randomization looks like. Check out the stark contrast
    between the outputs when we run this same program after disabling ASLR:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是虚拟内存随机化的样子。看看禁用ASLR后运行相同程序时输出的鲜明对比：
- en: '![Figure 11.6 – Our stack pointer program after we disable randomization  ](image/Figure_11.06_B17616.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 我们的栈指针程序在禁用随机化后](image/Figure_11.06_B17616.jpg)'
- en: Figure 11.6 – Our stack pointer program after we disable randomization
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 我们的栈指针程序在禁用随机化后
- en: With that demonstration, let’s introduce the basic concepts of ROP.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个演示，让我们介绍ROP的基本概念。
- en: Introducing ROP
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ROP
- en: So, now we’re seeing two distinct countermeasures that work together to make
    the lives of the bad guys more difficult. We’re taking away the predictability
    necessary to find the soft spots of the vulnerable program when loaded in memory,
    and we’re filing down the areas of memory where execution is allowed to the bare
    minimum. In other words, DEP/NX and ASLR take a big and stationary target and
    turn it into a tiny moving target. Hopefully, the hacker in you is already brainstorming
    the security assumptions of these protection mechanisms. Think of it this way—we’re
    setting certain regions of memory as non-executable. However, this is a program,
    so some instructions have to be executed. We’re randomizing the address space
    so that it’s hard to predict where to find certain structures, but there’s a flow
    of execution. There *has* to be a way to find everything needed to get the job
    done. ROP takes advantage of this reality. Let’s take a look at how it does this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们看到两种不同的反制措施，它们相互配合，使坏人的生活变得更加困难。我们正在消除加载程序到内存时，找到脆弱点所需的可预测性，同时将执行允许的内存区域限制到最小。换句话说，DEP/NX
    和 ASLR 将一个大而固定的靶子转变成一个小而移动的靶子。希望你作为黑客，已经在为这些保护机制的安全假设进行头脑风暴。可以这样理解——我们将内存的某些区域设置为不可执行。然而，这毕竟是一个程序，所以某些指令必须执行。我们正在随机化地址空间，使得很难预测在哪里找到某些结构，但执行流程依然存在。*必须*有一种方法可以找到完成任务所需的一切。ROP
    就利用了这一现实。让我们来看看它是如何做到的。
- en: Borrowing chunks and returning to libc – turning the code against itself
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借用代码块并返回到 libc —— 让代码反过来为自己服务
- en: 'When we introduced buffer overflow attacks, we exploited the vulnerability
    in our homegrown C program—the presence of the infamous **strcpy()** function.
    As this function will pass any sized input into the fixed-size buffer, we know
    that it’s just a matter of research to find the right input to overflow the instruction
    pointer with an arbitrary value. We have control over where to send the flow of
    execution, so where do we send it? Well, to our injected shellcode, silly. We’re
    making two huge assumptions to pull this off—that we can get a chunk of arbitrary
    code into memory and that we can convince the processor to actually execute those
    instructions. Let’s suppose those two feats aren’t an option—do we pack up and
    go home, leaving this juicy **strcpy()** function just sitting there? Without
    those two assumptions, we can still overwrite the return address. We can’t point
    at our injected shellcode, but we can point at some other instruction that’s already
    there. This is the heart and soul of the whole concept: borrowing chunks of code
    from within the program itself and using returns to do it. Before you take low-level
    dives into the dark world of assembly, you might have intuited that a program
    designed to load a web page will only contain code that loads a web page. You,
    the esteemed hacker, understand that programs of all complexity levels are doing
    fairly simple things at the lowest levels. Your friendly web browser and my dangerous
    backdoor shellcode share the same language and the same low-level activities of
    moving things in and out of temporary storage boxes and telling the processor
    where the next chunk of work is located.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍缓冲区溢出攻击时，我们利用了我们自制 C 程序中的漏洞——那就是臭名昭著的**strcpy()**函数。由于该函数会将任何大小的输入传入固定大小的缓冲区，我们知道，只要进行一些研究，找到合适的输入就能使指令指针溢出并填入任意值。我们能够控制程序执行流的去向，那么我们该把它发送到哪里呢？当然是发送到我们注入的
    shellcode 啦，傻瓜。为了实现这一点，我们做了两个重要假设——我们可以将任意代码块注入内存，并且可以说服处理器执行这些指令。假设这两个条件不成立——我们是应该打包回家，任由这个美味的**strcpy()**函数继续存在吗？没有这两个假设，我们仍然可以覆盖返回地址。我们不能直接指向我们注入的
    shellcode，但我们可以指向程序中已存在的其他指令。这就是这个概念的核心：从程序内部借用代码块并使用返回来实现这一点。在你深入低级汇编世界之前，你可能已经直觉到，设计用于加载网页的程序只包含加载网页的代码。作为尊敬的黑客，你明白所有复杂程度的程序在最低层次上都在做一些非常简单的事情。你的友好网页浏览器和我那危险的后门
    shellcode 共享相同的语言和相同的低级操作，都是在临时存储区中搬运数据，并告诉处理器下一段工作的地址。
- en: 'Okay, so we’re borrowing code from inside the vulnerable program to do something
    for us. It sounds as though very small programs that hardly do anything would
    have far less code to rope into our scheme. I can hear the programmers in the
    back row shouting at me: *don’t forget about libraries!* Remember, even tiny little
    programs that are only useful for the demos in this book need complex code to
    do the things we take for granted. For example, take **printf()**. How would the
    program know how to actually print information on the screen? Try to create a
    C program with the **printf()** function but without the **<#include stdio.h>**
    line at the top. What happens? That’s right—it won’t compile:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们正在借用来自脆弱程序中的代码来为我们做一些事情。听起来那些几乎什么也不做的小程序似乎会有更少的代码可供我们利用。我能听到后排的程序员在对我喊：*别忘了库！*
    记住，甚至是那些仅供本书示范的小程序，也需要复杂的代码来做我们视为理所当然的事情。例如，拿 **printf()** 来说。程序怎么知道如何在屏幕上打印信息？试试创建一个包含
    **printf()** 函数的 C 程序，但**没有**在顶部加上 **<#include stdio.h>** 这一行。会发生什么？没错——它无法编译：
- en: '![Figure 11.7 – Forgetting our input/output preprocessing directive ](image/Figure_11.07_B17616.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 忘记了我们的输入/输出预处理指令](image/Figure_11.07_B17616.jpg)'
- en: Figure 11.7 – Forgetting our input/output preprocessing directive
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 忘记了我们的输入/输出预处理指令
- en: Bear in mind that the **include** preprocessing directive literally includes
    the defined chunk of code. Even two or three lines of code will, when compiled,
    be full of goodies. These goodies aren’t just any tasty treats—they’re shared
    DNA among C programs. The headers at the top of your C code reference the C standard
    library (**libc**). The **libc** standard library contains things such as type
    definitions and macros, but it also contains the functions for a whole gamut of
    tasks that are often taken for granted. What’s important to note here is that
    multiple functions can come from the same library. Tying this all together, one
    possibility for the attacker when overwriting that return address is to point
    at some function that’s in memory precisely because the functionality was pulled
    in with the **include** directive. Being the standard library for the C language,
    **libc** is the obvious target; it’ll be linked to almost any program, even the
    simplest ones, and it will contain powerful functionality for us to leverage.
    These attacks are dubbed **return-to-libc** attacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**include** 预处理指令字面上是将定义的代码块包含进来。即使是两三行代码，在编译后也会充满“好东西”。这些“好东西”不仅仅是一些美味的小点心——它们是
    C 程序中共享的 DNA。你 C 代码顶部的头文件引用了 C 标准库（**libc**）。**libc** 标准库包含了类型定义和宏等内容，还包含了许多我们常常视为理所当然的任务的函数。这里需要注意的一点是，多个函数可能来自同一个库。将这些联系在一起，当攻击者覆盖返回地址时，一种可能性是指向某个函数，这个函数在内存中存在正是因为它的功能是通过
    **include** 指令引入的。作为 C 语言的标准库，**libc** 是显而易见的攻击目标；几乎任何程序，甚至是最简单的程序，它都会被链接进去，并且包含了许多我们可以利用的强大功能。这些攻击被称为
    **return-to-libc** 攻击。
- en: 'The return-to-libc technique gets us around that pesky no-execute defense.
    The arbitrary code that we’ve just dumped into the stack is residing in non-executable
    space; on the other hand, the **libc** functions are elsewhere in memory. Returning
    to them gives the attacker access to powerful functions without the need for our
    own shellcode. There is one issue with this approach: memory layout randomization
    or ASLR. The actual location of these handy **libc** functions was easy to determine
    until ASLR came along. In this chapter, the hands-on lab is going to look at a
    variation of the **return-to-libc** method.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: return-to-libc 技术帮助我们绕过了那种讨厌的不可执行防御。我们刚刚丢入栈中的任意代码实际上位于不可执行的空间中；另一方面，**libc**
    函数则位于内存中的其他地方。返回到这些函数能让攻击者访问强大的功能，而无需我们自己写 shellcode。但这种方法有一个问题：内存布局随机化或 ASLR。在
    ASLR 出现之前，这些有用的 **libc** 函数的位置很容易确定。在本章中，实操实验将查看 **return-to-libc** 方法的一种变体。
- en: It Still Has to Work – ASLR and Offsets
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然需要有效 – ASLR 和偏移量
- en: Keep in mind that although ASLR will randomize the base address, the program
    still needs to work—that is, it needs to be able to find the locations of its
    numerous bits and pieces. Therefore, ASLR simply can’t change the *distance* from
    one place to another—the offsets. Sometimes, a breed of vulnerability called *memory
    leaks* can inform the attacker about the randomized memory layout, and from there,
    adding the offset to the desired function can yield the correct location in memory—even
    though it’s been randomized!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管ASLR会随机化基础地址，但程序仍然需要正常工作——也就是说，它需要能够找到自己各个部分的位置。因此，ASLR根本无法改变从一个地方到另一个地方的*距离*——即偏移量。有时，一种叫做*内存泄漏*的漏洞可以向攻击者泄露随机化后的内存布局，从而帮助攻击者通过添加偏移量来找到目标函数的正确内存位置——即使它已经被随机化了！
- en: As you can see, ROP is a breed of attack, and there are different ways of approaching
    this technique. Proper treatment of the variations of this concept is beyond the
    scope of this book, so we’ll be taking a look at a basic demonstration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，ROP是一种攻击方式，而且有不同的方法来实现这种技术。对于这种概念的各种变体的正确处理超出了本书的范围，所以我们将仅展示一个基本示范。
- en: The basic unit of ROP – gadgets
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROP的基本单元——gadget
- en: The x86 instruction set that we’re working with is, sometimes, described as
    *dense*. A *single* byte instruction can have significant power; for example,
    **lodsb** loads a byte from memory while incrementing a pointer. What about a
    program with only a handful of bytes in it? Well, we won’t have a tremendous number
    of options available. But what about any program linked to the C standard library?
    There’s enough inherent instruction power to let the attacker get away with just
    about anything. We can turn the code against itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的x86指令集有时被描述为*紧凑*的。一个*单一*字节的指令可能拥有强大的功能；例如，**lodsb**从内存中加载一个字节，并同时递增指针。那么，只有少量字节的程序呢？好吧，我们可用的选项就不会太多。但如果是任何一个链接到C标准库的程序呢？它的指令足够强大，足以让攻击者几乎做任何事情。我们可以利用代码的漏洞，将其反过来对付自己。
- en: When a function is called, its instructions are pushed onto the stack on top
    of the return address so that the execution can proceed where it left off with
    the procedure call. During a buffer overflow, we overwrite the return address
    to control the flow of execution. Now, imagine that we’ve overwritten the return
    address so that it points to some instructions that end in a return. That points
    to some other instructions ending in a return, which points to some other instructions
    that end in a—you get the idea. These individual pieces of code are called **gadgets**.
    Typically, a gadget is short but always ends in an instruction that sends the
    execution somewhere else. We chain these together to create arbitrary functionality—all
    without injection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被调用时，它的指令会被推送到栈上，位于返回地址之上，这样执行就可以从上次的过程调用处继续。在缓冲区溢出期间，我们会覆盖返回地址以控制执行流。现在，假设我们已经覆盖了返回地址，使其指向一些以返回结尾的指令。那些指令指向其他以返回结尾的指令，这些又指向其他以返回结尾的指令——你明白了。这些单独的代码片段被称为**gadget**（小工具）。通常，一个gadget比较短，但总是以将执行流转移到其他地方的指令结束。我们将这些gadget连接起来，创建任意功能——完全不需要注入。
- en: Hopefully, you have a core understanding of what we’re up against—now we need
    to examine the standard toolset for this job.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经对我们所面临的情况有了基本的理解——现在我们需要检查这个任务的标准工具集。
- en: Getting cozy with our tools – MSFrop and ROPgadget
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉我们的工具——MSFrop和ROPgadget
- en: Enough lecturing—let’s take a peek inside the two tools that you’ll likely use
    the most when developing ROP exploits. In the spirit of taking Kali Linux to the
    limit, we’ll explore MSFrop. This tool is excellent for assisted research of the
    gadgets in a target binary. It will find them for you and even output them in
    a friendly way so that you can review them. However, the tool that we really put
    on our lab coats for is ROPgadget.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的讲解——让我们来看看你在开发ROP漏洞时最常用的两个工具。在将Kali Linux发挥到极限的精神下，我们将探索MSFrop。这个工具非常适合在目标二进制文件中辅助研究gadget。它会为你找到gadget，并以友好的方式输出，供你回顾。然而，我们真正穿上实验服的工具是ROPgadget。
- en: Metasploit Framework’s ROP tool – MSFrop
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metasploit Framework的ROP工具——MSFrop
- en: 'We are used to **msfvenom**, which is standalone but still a part of Metasploit.
    MSFrop is different—it needs to be run from the MSF console. Let’s fire up **msfconsole**
    followed by **msfrop** to start getting familiar with this nifty gadget hunter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯使用**msfvenom**，它是独立的，但仍然是Metasploit的一部分。MSFrop则不同——它需要从MSF控制台运行。让我们启动**msfconsole**，然后运行**msfrop**，开始熟悉这个巧妙的工具猎人：
- en: msfconsole
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfconsole
- en: msf6 > msfrop
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: msf6 > msfrop
- en: 'This will just display the help page outlining the options. Let’s step through
    them and get an idea of MSFrop’s power:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会显示一页帮助页面，列出所有选项。让我们逐步分析这些选项，了解MSFrop的强大功能：
- en: '**--depth** is, essentially, a measure of how deep into the code your search
    for gadgets will go. Since a gadget ends with a return instruction, the **depth**
    flag finds all the returns and works backward from that point. Depth is the number
    of bytes we’re willing to search from a given return.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--depth**本质上是衡量你的gadget搜索深入代码的深度。由于gadget以返回指令结束，**depth**标志会从返回指令开始，向后搜索。深度是我们愿意从给定的返回位置向后搜索的字节数。'
- en: '**--search** is for when we’re hunting for particular bytes in our gadgets.
    This flag takes a regular expression as a search query; one of the most common
    regular expressions is **\x** to signify hexadecimal numbers.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--search**用于当我们要在gadget中寻找特定字节时。此标志接受一个正则表达式作为搜索查询；最常见的正则表达式之一是**\x**，表示十六进制数字。'
- en: '**--nocolor** is just aesthetics; it removes the display colors for piping
    your output to other tools.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--nocolor**仅仅是为了美观；它去除了显示颜色，方便将输出结果传递给其他工具。'
- en: '**--export** is, along with **depth**, a pretty standard parameter of MSFrop,
    especially at higher depths. This puts the gadgets into a CSV file for your review
    when the Terminal window gets old.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--export**与**depth**一样，是MSFrop的一个标准参数，特别是在较深的查找时。这会将gadget导出到CSV文件中，方便你在终端窗口过时后进行查看。'
- en: 'Now we’ll examine the other big player in the world of ROP: ROPgadget.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看ROP世界中的另一个重要工具：ROPgadget。
- en: Your sophisticated ROP lab – ROPgadget
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的高级ROP实验室 – ROPgadget
- en: 'I’ll be blunt—I think MSFrop is more of an *honorable mention* when we’re comparing
    ROP tools. It’s great that Metasploit Framework has the sophistication to serve
    as a solid one-stop shop for hacking, and knowing that we can study gadgets in
    a binary without leaving the MSF console is handy. But my favorite dedicated tool
    is the Python-coded ROPgadget. It’s a breeze to install inside our Kali box with
    **pip**. If you don’t have **pip** already installed, get that done with **apt
    install python3-pip**. Then, ROPgadget is a single step away:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我直说了——我认为MSFrop在我们比较ROP工具时更像是一个*荣誉提名*。Metasploit Framework能够作为一个全面的黑客工具非常棒，能在MSF控制台内研究二进制中的gadget也很方便。但我最喜欢的专用工具是用Python编写的ROPgadget。它在我们的Kali盒子中用**pip**安装起来非常简单。如果你还没有安装**pip**，可以通过**apt
    install python3-pip**来安装它。然后，ROPgadget只需一步安装：
- en: '![Figure 11.8 – The installation of ROPgadget with pip ](image/Figure_11.08_B17616.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 使用pip安装ROPgadget](image/Figure_11.08_B17616.jpg)'
- en: Figure 11.8 – The installation of ROPgadget with pip
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 使用pip安装ROPgadget
- en: 'Let’s take a look at the options available to us, leaving out a couple of the
    processor-specific commands:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可用的选项，暂时不考虑一些特定处理器的命令：
- en: '**--binary** specifies our target, which can be in ELF format, PE format, Mach-object
    format, and raw.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--binary**指定我们的目标，可以是ELF格式、PE格式、Mach对象格式或原始格式。'
- en: '**--opcode** searches for the defined opcodes in the executable segments of
    the binary, while **--string** searches for a given string in the readable segments
    of the binary. One use for **--string** is to look at specific functions, such
    as **main()**.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--opcode**在二进制的可执行段中搜索已定义的操作码，而**--string**则在二进制的可读段中搜索指定的字符串。**--string**的一种用途是查看特定函数，如**main()**。'
- en: '**--memstr** is your lifeline for borrowing characters from your target binary.
    Let’s suppose that you want to copy the ASCII characters, **sh**, into the buffer
    without injecting them. You pass the **--memstr "sh"** argument and ROPgadget
    will search for **\x73** and **\x68** in memory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--memstr**是你借用目标二进制字符的生命线。假设你想将ASCII字符**sh**复制到缓冲区，而不进行注入。你可以传递**--memstr
    "sh"**参数，ROPgadget将搜索内存中的**\x73**和**\x68**。'
- en: '**--depth** means the same thing here as it does in MSFrop. Once a **ret**
    is found, this parameter is how many bytes back we’ll be searching for gadgets.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--depth**在这里的含义与MSFrop中的相同。一旦找到**ret**，这个参数表示我们将搜索多少字节以找到gadget。'
- en: '**--only** and **--filter** are the instruction filters. **--only** will hide
    everything but the specified instructions; **--filter** will show everything but the
    specified instructions.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--only**和**--filter**是指令过滤器。**--only**会隐藏所有内容，除了指定的指令；**--filter**会显示所有内容，除了指定的指令。'
- en: '**--range** specifies a range of memory addresses to limit our gadget search.
    Without this option, the entire binary will be searched.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--range**指定一个内存地址范围，以限制我们的gadget搜索范围。如果不使用此选项，将会搜索整个二进制文件。'
- en: '**--badbytes** means exactly what you think it means, my weary shellcoder.
    Just when you thought that by borrowing code, you could escape the trouble of
    bytes that shatter both our shellcode and our dreams, experienced ROP engineers
    will run into this occasionally. It really doesn’t matter where the bytes are
    coming from; the break happens during execution. There’s another factor to bear
    in mind, too—the actual exploit code itself. In this chapter, we’ll be working
    with Python to generate our payload. We’ll be using the powerful **struct** module
    to pack binary data into strings that are then handled like any ordinary string
    variable by Python. Remember **--badbytes** when you’re sitting there with a broken
    script; it might be what you’re looking for.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--badbytes** 就是字面意思，我疲惫的 shellcoder。就在你以为通过借用代码就能逃避那些破坏我们 shellcode 和梦想的字节时，经验丰富的
    ROP 工程师偶尔会遇到这个问题。无论字节来自哪里，问题都会在执行时发生。还有一个需要记住的因素——实际的利用代码本身。在本章中，我们将使用 Python
    来生成有效载荷。我们将使用强大的 **struct** 模块将二进制数据打包成字符串，然后像普通的字符串变量一样由 Python 处理。当你坐在那里调试破损的脚本时，记住
    **--badbytes**，它可能正是你在找的东西。'
- en: '**--rawArch** and **--rawMode** are used for defining 32-bit and 64-bit architectures
    and modes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--rawArch** 和 **--rawMode** 用于定义 32 位和 64 位架构及模式。'
- en: '**--re** takes a regular expression (for example, **\x35**).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--re** 接受一个正则表达式（例如，**\x35**）。'
- en: '**--offset** takes a hex value as an offset for calculating gadget addresses.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--offset** 接受一个十六进制值，作为计算 gadget 地址的偏移量。'
- en: '**--ropchain** is a wonderful coup de grace option that generates the Python
    exploit code for us. It isn’t as easy as throwing it into a **.py** file and executing
    it; we need to know exactly how it’s being passed to the vulnerable program.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--ropchain** 是一个绝妙的致命一击选项，可以为我们生成 Python 利用代码。它不像把它丢进一个 **.py** 文件然后执行那么简单；我们需要知道它是如何传递给易受攻击程序的。'
- en: '**--console** is for interactive gadget hunting. Essentially, it brings up
    a Terminal window within ROPgadget for conducting specific searches. We’ll take
    a look at it later.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--console** 用于交互式 gadget 寻找。基本上，它会在 ROPgadget 中弹出一个终端窗口，以便进行特定的搜索。稍后我们会仔细看。'
- en: '**--norop**, **--nojop**, and **--nosys** disable the search engines for specific
    gadget types—return-oriented, jump-oriented, and system call instruction gadgets,
    respectively. When you’re trying to understand the full complement of gadgets
    available to you, you’ll generally want to avoid these options; they’re only for
    fine-tuned attacks.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--norop**、**--nojop** 和 **--nosys** 分别禁用特定 gadget 类型的搜索引擎——面向返回的、面向跳转的和系统调用指令的
    gadgets。当你想了解你可以使用的所有 gadgets 时，通常不建议使用这些选项；它们仅用于精细化攻击。'
- en: By default, duplicate gadgets are suppressed; you can use **--all** to see everything.
    This is handy for gathering all of the memory addresses associated with your binary’s
    gadgets.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，会抑制重复的 gadgets；你可以使用 **--all** 来查看所有内容。这对于收集与二进制文件中的 gadgets 相关的所有内存地址非常有用。
- en: '**--dump** is, essentially, an **objdump -x** object for your gadgets; this
    will display the disassembled gadgets and then their raw bytes.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--dump** 本质上是一个 **objdump -x** 对象，显示你的 gadgets；它会展示反汇编后的 gadgets 及其原始字节。'
- en: There are several other great ROP programs available, but ROPgadget should get
    just about any of your projects done. Let’s prepare to take it out for a test
    drive by preparing our vulnerable executable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他很棒的 ROP 程序可用，但 ROPgadget 应该可以完成几乎所有你的项目。让我们准备好进行测试，准备好我们的易受攻击可执行文件。
- en: Creating our vulnerable C program without disabling the protections
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不禁用保护的情况下创建我们的易受攻击 C 程序
- en: 'The full breadth of ROP attacks deserves more space than we can offer here,
    so let’s build a small and relatively simple demonstration for an x86 Linux target
    environment. Fire up **vim buff.c** to prepare a new C file in the Vim editor.
    Type in the following familiar code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 攻击的广泛内容值得更多空间，但在这里我们只能提供一个简单的小示范，针对的是 x86 Linux 目标环境。启动 **vim buff.c** 来准备一个新的
    C 文件，在 Vim 编辑器中输入以下熟悉的代码：
- en: '![Figure 11.9 – The tried-and-true vulnerable program ](image/Figure_11.09_B17616.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 经久不衰的易受攻击程序](image/Figure_11.09_B17616.jpg)'
- en: Figure 11.9 – The tried-and-true vulnerable program
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 经久不衰的易受攻击程序
- en: Now we can compile our fancy new program. But let’s try something different.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编译我们的全新程序。但让我们尝试一些不同的做法。
- en: No PIE for you – compiling your vulnerable executable without ASLR hardening
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有 PIE 给你 —— 编译你的易受攻击可执行文件时不启用 ASLR 加固。
- en: 'Hit *Esc* followed by **:wq!** to save and quit Vim; then, compile your executable.
    This time, let’s introduce Clang. The differences between GCC and Clang are outside
    the scope of this discussion, and similar to the editor war, you’ll find solid
    arguments on either side. Clang is more lightweight, and the compiled code it
    produces is a little “cleaner” for the purposes of our lab (it also runs natively
    on Windows). Fire it up and compile your new C program with the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Esc*，然后输入**:wq!**保存并退出Vim；接着，编译你的可执行文件。这次，我们引入Clang。GCC和Clang的差异超出了本讨论的范围，类似于编辑器之争，你会在两者之间找到有力的论据。Clang更加轻量，其编译的代码对我们实验的目的来说更加“干净”（它也可以在Windows上原生运行）。启动它并使用以下命令编译你的新C程序：
- en: '![Figure 11.10 – Disabling PIE hardening at compilation ](image/Figure_11.10_B17616.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 禁用PIE加固在编译时](image/Figure_11.10_B17616.jpg)'
- en: Figure 11.10 – Disabling PIE hardening at compilation
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 禁用PIE加固在编译时
- en: 'Recall that when we originally created a *vulnerable C program*, the focus
    of its vulnerability was in the code (specifically, by using the infamous **strcpy()**
    function). This time, we’re using vulnerable code and compiling the executable
    with a vulnerable option enabled: **-no-pie**. When a **Position Independent Executable**
    (**PIE**) loads up in an ASLR environment, the kernel loads all the code and assigns
    random virtual addresses (except for the entry point, of course). Typically, security-sensitive
    executables are PIEs, but as you can see, this won’t necessarily be the case.
    In some distros—notably, Kali Linux—you have to explicitly disable compiling a
    PIE with Clang or GCC.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们最初创建一个*易受攻击的C程序*时，其漏洞主要存在于代码中（具体来说，通过使用臭名昭著的**strcpy()**函数）。这次，我们使用易受攻击的代码并在启用了易受攻击选项的情况下编译可执行文件：**-no-pie**。当**位置无关可执行文件**（**PIE**）在ASLR环境中加载时，内核加载所有代码并分配随机虚拟地址（当然，入口点除外）。通常，安全敏感的可执行文件是PIE，但正如你所看到的，这并不一定是这样。在某些发行版中——特别是Kali
    Linux——你需要显式地禁用Clang或GCC编译PIE。
- en: Walk Before You Run – Disabling PIE
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 先走再跑 – 禁用PIE
- en: 'Similar to what we did with stack protection in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187),
    *Shellcoding – The Stack*, this demonstration disables a package hardening strategy
    that could be found in secure environments: PIEs. However, unlike the absence
    of DEP and ASLR, software with absolute addresses is still common in some enterprise
    environments.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在[*第10章*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)中进行的堆栈保护演示，*Shellcoding
    – 堆栈*，本演示禁用了可能在安全环境中找到的一种包加固策略：PIE。然而，不同于缺少DEP和ASLR，使用绝对地址的软件在一些企业环境中仍然很常见。
- en: Now that we have our lab executable, let’s understand the low-level mechanisms
    we are going to compromise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了实验的可执行文件，接下来让我们理解我们将要破坏的低级机制。
- en: Generating an ROP chain
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成ROP链
- en: If you recall the humble vulnerable C programs we wrote earlier, this time around,
    you’ll notice something different. We’re already familiar with the **strcpy()**
    function, but in this program, we have the **system()** function. A part of the
    C standard library, **system()** will pass a command to the host to be executed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们之前写的简单易受攻击的C程序，这次你会注意到一些不同之处。我们已经熟悉了**strcpy()**函数，但在这个程序中，我们有了**system()**函数。作为C标准库的一部分，**system()**将把命令传递给主机执行。
- en: We can grab individual bytes out of our program’s own code, link them together
    with returns, and pass whatever bytes we want to **system()**. The potential is
    there, but we have the problem of figuring out where **system()** is located.
    Let’s take the spirit of return-to-libc in a different direction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从程序的代码中提取单独的字节，将它们通过返回地址链接起来，并传递我们想要的字节到**system()**函数。潜力是有的，但我们面临的问题是如何找出**system()**的位置。让我们将返回到libc的思想朝着另一个方向发展。
- en: Getting hands-on with the return-to-PLT attack
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲自动手进行返回到PLT攻击
- en: I say this about a lot of topics, but the **Procedure Linkage Table** (**PLT**)
    and the **Global Offset Table** (**GOT**) are subjects that deserve their own
    book. However, we’ll try to run through a crash course to understand how we’re
    going to get around memory space randomization. Our executable is not a position-independent
    executable thanks to our **-no-pie** compilation configuration, so the actual
    location of global structures in the program wasn’t known at compile time. The
    GOT is literally a table of addresses used by the executable during runtime to
    convert PIE addresses into absolute ones. At runtime, our executable needs its
    shared libraries; these are loaded and linked using the dynamic linker during
    the bootstrapping process. That is when the GOT is updated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过很多次，**过程链接表**（**PLT**）和**全局偏移表**（**GOT**）是值得专门写一本书的主题。然而，我们将尝试通过速成课程理解如何绕过内存空间随机化。由于我们的可执行文件不是位置无关可执行文件，这要归功于我们的**-no-pie**编译配置，所以全局结构在编译时的实际位置是未知的。GOT实际上是可执行文件在运行时使用的地址表，用来将PIE地址转换为绝对地址。在运行时，我们的可执行文件需要共享库，这些库在引导过程中通过动态链接器加载和链接。这时，GOT会被更新。
- en: Since the addresses are dynamically linked at runtime, the compiler doesn’t
    really know whether the addresses in our non-position-independent code will be
    resolved from the GOT. So, with the **-no-pie** specification, the compiler does
    its usual thing of generating a call instruction; this is interpreted by the linker
    to determine absolute destination addresses and updates the PLT. Now I know what
    you’re thinking—the PLT and GOT kinda sound like the same thing. They’re similar
    concepts, and the GOT helps the position-independent programs maintain their hard-earned
    independence. But we have a dynamically-linked, non-position-independent executable.
    Here’s a simple distinction—the GOT is used for converting *address calculations*
    into absolute destination addresses, whereas the PLT is used for converting our *function
    calls* into absolute destinations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地址在运行时是动态链接的，编译器实际上并不知道我们非位置无关代码中的地址是否会从GOT中解析出来。所以，使用**-no-pie**指定后，编译器按常规生成调用指令；这被链接器解释用来确定绝对目标地址并更新PLT。现在我知道你在想什么——PLT和GOT听起来有点像。它们是相似的概念，GOT帮助位置无关程序保持它们的独立性。但我们有一个动态链接的非位置无关可执行文件。这里有一个简单的区别——GOT用于将*地址计算*转换为绝对目标地址，而PLT则用于将我们的*函数调用*转换为绝对目标地址。
- en: Now, let’s consider the return-to-PLT moniker. We’re setting up those ROP chains
    with our returns pointing to particular places to send the flow; in this scenario,
    we’re directing flow to the PLT function call and, thus, removing any need for
    address knowledge at runtime. Our linker is an unwitting accomplice to the crime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑返回到PLT这个术语。我们通过设置ROP链，将返回指向特定位置来发送流程；在这个场景下，我们将流程引导到PLT函数调用，从而消除了在运行时需要知道地址的需求。我们的链接器无意中成了这场罪行的同谋。
- en: Extracting gadget information for building your payload
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取构建有效负载所需的工具信息
- en: Now, we’ll step through ROP chain and exploit generation. The return-to-PLT
    part is easy to figure out with **gdb**. It’s also easy to use ROPgadget for finding
    the bytes that we’re going to use to construct our chain. But what about writing
    into the program’s memory? First, let’s figure out where everything is.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步解析ROP链和漏洞利用生成。返回到PLT部分通过**gdb**很容易理解。使用ROPgadget查找我们将用来构建链的字节也很简单。但程序内存写入呢？首先，我们来搞清楚一切所在的位置。
- en: Finding the .bss address
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找.bss地址
- en: 'We need to work with the program’s design to write data somewhere. We can use
    the **.bss** section of our executable for this task, as **.bss** is a place to
    put variables that don’t have any value just yet. Essentially, it’s space set
    aside for these variables; therefore, it won’t occupy space within the object
    file. For our purposes here, we just need to know where it is. Use the **info
    file** command in **gdb** to get a list of the sections with their ranges and
    take down the initial address of **.bss**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要与程序的设计一起工作，以便将数据写入某个地方。我们可以使用可执行文件中的**.bss**段来完成这项任务，因为**.bss**是一个存放还没有值的变量的地方。它本质上是为这些变量预留的空间，因此不会占用目标文件中的空间。对于我们的目的来说，我们只需要知道它的位置。使用**gdb**中的**info
    file**命令来获取带有范围的段列表，并记录下**.bss**的初始地址：
- en: gdb buff
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb buff
- en: (gdb) info file
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) info file
- en: 'Here’s an example of a memory map from these commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些命令生成的内存映射示例：
- en: '![Figure 11.11 – File information in gdb ](image/Figure_11.11_B17616.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – gdb 中的文件信息](image/Figure_11.11_B17616.jpg)'
- en: Figure 11.11 – File information in gdb
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – gdb 中的文件信息
- en: In our example, we’ll write down **0x0804c028** for **.bss**. Now, we’ll look
    for the pieces that will allow us to jump around the program’s code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将为 **.bss** 写下 **0x0804c028**。现在，我们将寻找允许我们跳转程序代码的部件。
- en: Finding a pop pop ret structure
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找 pop pop ret 结构
- en: 'The **strcpy()** function pops off stack pointer offsets for source and destination
    arguments and then returns; therefore, the glue in our chain is a **pop pop ret** machine
    instruction structure. Thankfully, this is easy for ROPgadget’s **search** function.
    First, get into the interactive console mode, load the gadgets, and then conduct
    a search for the relevant structures. You’ll get a lot of hits, but you’re looking
    for a **pop pop ret** structure and then copying its address:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**strcpy()** 函数弹出堆栈指针偏移量，用于源和目标参数，然后返回；因此，我们链条中的粘合剂是一个 **pop pop ret** 机器指令结构。幸运的是，这对于
    ROPgadget 的 **search** 函数来说很容易。首先，进入交互式控制台模式，加载小工具，然后搜索相关结构。你会得到很多结果，但你要找的是一个
    **pop pop ret** 结构，然后复制它的地址：'
- en: ROPgadget --binary buff --depth 5 –console
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROPgadget --binary buff --depth 5 –console
- en: (ROPgadget)> load
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (ROPgadget)> load
- en: (ROPgadget)> search pop ; pop ; ret
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (ROPgadget)> search pop ; pop ; ret
- en: 'The preceding command should produce the result shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应生成如下截图所示的结果：
- en: '![Figure 11.12 – Finding the pop pop ret gadgets in our program ](image/Figure_11.12_B17616.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 在我们的程序中找到 pop pop ret 小工具](image/Figure_11.12_B17616.jpg)'
- en: Figure 11.12 – Finding the pop pop ret gadgets in our program
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 在我们的程序中找到 pop pop ret 小工具
- en: Note the depth of 5 bytes. Remember, that means we’re searching backward from
    a given return instruction by 5 bytes to find the gadgets. But we’re not done
    – we need to find the locations of the **system** and **strcpy** functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 5 字节的深度。记住，这意味着我们从给定的返回指令向后搜索 5 字节来查找小工具。但我们还没有完成 – 我们需要找到 **system** 和 **strcpy**
    函数的位置。
- en: Finding addresses for the system@plt and strcpy@plt functions
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找 system@plt 和 strcpy@plt 函数的地址
- en: 'Our **main()** function needs to call **system()** and **strcpy()**. This is
    a no-PIE target, so we’re looking for the addresses corresponding to **<system@plt>**
    and **<strcpy @plt>**. Use the **disas** command in **gdb** to investigate the
    **main()** function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 **main()** 函数需要调用 **system()** 和 **strcpy()**。这是一个非PIE目标，所以我们要查找对应于 **<system@plt>**
    和 **<strcpy @plt>** 的地址。使用 **gdb** 的 **disas** 命令来调查 **main()** 函数：
- en: gdb buff
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb 缓冲区
- en: (gdb) disas main
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) disas main
- en: 'Remember that we’re using **strcpy()** to copy our chosen bytes into memory
    and **system()** to make an actual system command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们使用 **strcpy()** 将所选字节复制到内存中，使用 **system()** 执行实际的系统命令：
- en: '![Figure 11.13 – Identifying the locations for system@plt and strcpy@plt ](image/Figure_11.13_B17616.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 标识 system@plt 和 strcpy@plt 的位置](image/Figure_11.13_B17616.jpg)'
- en: Figure 11.13 – Identifying the locations for system@plt and strcpy@plt
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 标识 system@plt 和 strcpy@plt 的位置
- en: At this point, we have four addresses in our notes. Now we just need to find
    the characters that represent our command. Thankfully, they’re already present
    in the program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的笔记中有四个地址。现在我们只需找到代表我们命令的字符。幸运的是，它们已经存在于程序中。
- en: Finding target characters in memory with ROPgadget and Python
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ROPgadget 和 Python 在内存中查找目标字符
- en: 'The question of what specific command you’ll try to pass to **system()** is
    for you to decide. In our actual demo, I’m just launching **sh**. However, there’s
    potential for remote compromise here. Take the following **netcat** command as
    an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你将尝试传递什么具体命令给 **system()** 是由你决定的。在我们的实际演示中，我只是启动 **sh**。但是，这里存在远程攻击的潜力。以以下
    **netcat** 命令为例：
- en: '**nc -e /bin/sh -lvnp 1066**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**nc -e /bin/sh -lvnp 1066**'
- en: 'This will set up a session with **sh** and pass it to a local listener on port
    **1066**. All we need are the precise locations in the vulnerable program where
    we can find the characters needed to construct this line. This sounds daunting,
    but ROPgadget is here to save us a lot of time with the **--memstr** flag. Naturally,
    we only need a single memory address per character, so it’d be cleanest to just
    pass a string of the unique characters in our **bash** command. Use Python for
    this task, look slick, and impress your friends. Start the interactive interpreter
    with **python3** and then run this command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个与 **sh** 的会话，并将其传递给本地监听器，监听端口 **1066**。我们只需要在易受攻击的程序中找到构造这一行所需的字符的精确位置。这听起来很艰巨，但
    ROPgadget 会通过 **--memstr** 标志为我们节省很多时间。自然，我们每个字符只需要一个内存地址，因此最干净的方法是直接传递我们 **bash**
    命令中的唯一字符字符串。使用 Python 来完成这项任务，看起来很酷，还能给朋友留下深刻印象。启动交互式解释器 **python3**，然后运行此命令：
- en: '''''.join(set(''nc -e /bin/sh -lvnp 1066''))'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '''''.join(set(''nc -e /bin/sh -lvnp 1066''))'
- en: 'This should spit out a clean one-per-unique-character result that you can then
    pass to ROPgadget, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出一个干净的每个唯一字符一个结果，你可以将其传递给 ROPgadget，正如下面的截图所示：
- en: '![Figure 11.14 – A clean way to handle repeated characters ](image/Figure_11.14_B17616.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14 – 处理重复字符的干净方法](image/Figure_11.14_B17616.jpg)'
- en: Figure 11.14 – A clean way to handle repeated characters
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 处理重复字符的干净方法
- en: 'Use **exit()** to close the interpreter, and then pass the result of that command
    as an argument to **--memstr**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **exit()** 关闭解释器，然后将该命令的结果作为参数传递给 **--memstr**：
- en: '![Figure 11.15 – Memory locations for each byte ](image/Figure_11.15_B17616.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图11.15 – 每个字节的内存位置](image/Figure_11.15_B17616.jpg)'
- en: Figure 11.15 – Memory locations for each byte
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 – 每个字节的内存位置
- en: For our lab, we’ll keep it simple—let’s just find the characters for **sh;**
    and see whether we can pass that to **system**. Finally, let’s look at how it
    comes together.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实验，我们保持简单——让我们只找到 **sh;** 的字符，看看我们是否能将其传递给 **system**。最后，让我们看看它是如何组合在一起的。
- en: Go, go, gadget ROP chain – bringing it together for the exploit
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前进，前进，装备 ROP 链——将其组合起来以进行利用
- en: We’re so close, but there’s one last variable to figure out—our offset to the
    return address. This is more of the traditional overflow research for injecting
    shellcode. So, back we go into the debugger.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很接近了，但还有一个最后的变量需要搞清楚——返回地址的偏移量。这更像是传统的溢出研究，用于注入 shellcode。所以，我们再次进入调试器。
- en: Finding the offset to return with gdb
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 gdb 查找返回偏移量
- en: 'Our chain starts with a **strcpy()** function. We’ve overwritten EIP before,
    which tells the processor where to find the next instruction (why, in a grand
    field of NOPs, of course). In this case, we’re adjusting where we’ll *return* to,
    essentially spoofing the calling frame. Therefore, we need to overflow deeply
    enough to overwrite the stack base pointer EBP. Once we find this sweet spot,
    we can send the flow to our first **strcpy()** function by overwriting it with
    our **strcpy@plt** address:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的链条从 **strcpy()** 函数开始。我们之前已经覆盖了 EIP，这告诉处理器在哪里找到下一条指令（当然，是在一大堆 NOP 中）。在这种情况下，我们正在调整我们将要
    *返回* 到的位置，实际上是在伪造调用帧。因此，我们需要进行足够深的溢出，以覆盖堆栈基指针 EBP。一旦找到这个合适的位置，我们就可以通过将其覆盖为我们的
    **strcpy@plt** 地址，将流程传送到我们的第一个 **strcpy()** 函数：
- en: '![Figure 11.16 – The calling frame and current frame layout ](image/Figure_11.16_B17616.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16 – 调用帧和当前帧布局](image/Figure_11.16_B17616.jpg)'
- en: Figure 11.16 – The calling frame and current frame layout
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 调用帧和当前帧布局
- en: 'At this point, this should simply be a review for you. We’re firing up **gdb**
    and executing the **run** command with the test input. The easiest way to do this
    is with a Python call; for example, within **gdb**, and with our target executable
    loaded: **run $(python -c ''print "z" * 1028 + "AAAA"'')**. We understand that
    this will load up 1,028 z’s -- hexadecimal **0x7a**—and then 4 A’s -- hexadecimal
    **0x41**. So, we’ll know we landed on the sweet spot when we see that we pushed
    **0x41414141** into EBP:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，这应该只是你的复习内容。我们启动 **gdb** 并执行带有测试输入的 **run** 命令。最简单的方法是使用 Python 调用；例如，在
    **gdb** 中，加载我们的目标可执行文件后：**run $(python -c 'print "z" * 1028 + "AAAA"')**。我们知道这将加载
    1,028 个 z 字符——十六进制 **0x7a**——然后是 4 个 A 字符——十六进制 **0x41**。所以，当我们看到将 **0x41414141**
    推送到 EBP 时，我们就知道自己已经找到了合适的地方：
- en: '![Figure 11.17 – Examining memory after the expected segfault ](image/Figure_11.17_B17616.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – 预期的段错误后的内存检查](image/Figure_11.17_B17616.jpg)'
- en: Figure 11.17 – Examining memory after the expected segfault
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 预期的段错误后的内存检查
- en: In this case, let’s check out the value of EBP. What’s our offset? Once you’ve
    figured that out, let’s look at how it might be conveyed via Python.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，让我们检查EBP的值。我们的偏移量是多少？一旦你搞清楚这一点，让我们看看如何通过Python来传递它。
- en: Writing the Python exploit
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Python漏洞利用
- en: 'Finally, we can bring it together. Again, we’re testing **sh;** in this exploit.
    Let’s step through what’s going on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将其整合在一起。同样，我们在这个漏洞利用中测试的是**sh;**。让我们逐步分析发生了什么：
- en: '![Figure 11.18 – The exploit in Python ](image/Figure_11.18_B17616.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – Python中的利用](image/Figure_11.18_B17616.jpg)'
- en: Figure 11.18 – The exploit in Python
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – Python中的利用
- en: Hopefully, it’s clear that this is pretty repetitive—once you figure out the
    chain, it’s fairly trivial to construct longer ones. Bear in mind that because
    of how Python 3 handles types, we’re just using Python 2 with this example. You
    can upgrade it for Python 3 as long as you convert your string into bytes first.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 希望能清楚看到这一点是相当重复的——一旦你搞清楚了链条，构建更长的链条就相对简单了。请记住，由于Python 3处理类型的方式，我们在这个示例中使用的是Python
    2。你可以将其升级到Python 3，只需先将字符串转换为字节即可。
- en: Note we’ve imported **pack()** from the **struct** module. This function allows
    us to work with raw binary within Python by treating it like any ordinary string.
    If you’re feeling particularly masochistic, you can just pass the regex representation
    of the packed bytes directly to the program as an argument. I have a feeling you’ll
    try this way first. There are two arguments—the byte ordering and type, and the
    data itself. The **<** character is important for any Intel exploit—that’s our
    little-endian ordering.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经从**struct**模块导入了**pack()**。这个函数使我们能够在Python中处理原始二进制数据，将其当作普通字符串处理。如果你特别喜欢自虐，也可以将打包字节的正则表示形式直接传递给程序作为参数。我有预感你会先尝试这种方法。有两个参数——字节顺序和类型，以及数据本身。**<**字符对于任何Intel漏洞利用来说都很重要——这是我们的小端字节顺序。
- en: 'The location of the **strcpy()** function and our **pop pop ret** structure
    are declared first, as they’re used with each chain link. After that, the pattern
    is pretty easy:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**strcpy()**函数的位置和我们的**pop pop ret**结构首先被声明，因为它们在每个链节中都会用到。之后，模式就相对简单了：'
- en: Enough fluff (1,028 bytes of the character **z**) to reach the return.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 足够的填充（1,028字节的字符**z**）以达到返回。
- en: Overwrite with the address of **strcpy()** and return to **pop pop ret**. Note
    that the **pop pop** structure isn’t really important to us; the bytes have been
    copied into memory and we’re hitting the return. Rinse and repeat.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**strcpy()**的地址并返回到**pop pop ret**。请注意，**pop pop**结构对我们来说并不重要；字节已经被复制到内存中，我们正在触发返回。反复操作即可。
- en: Nab the first byte representing the character in our command and place it in
    **.bss**, byte by byte, using **strcpy()** and **pop pop ret** to return, thus
    keeping the chain going.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获代表命令中字符的第一个字节，并使用**strcpy()**和**pop pop ret**逐字节地将其放入**.bss**中以保持链条继续。
- en: End with a junk terminator and make that call to **system()**, pointing back
    at the base address of **.bss**. At this point, starting at that base address,
    **sh** should reside in memory. If all goes as planned, **system()** will execute
    **sh.**
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以一个垃圾终止符结尾，并调用**system()**，指向**.bss**的基地址。此时，从该基地址开始，**sh**应该已存在于内存中。如果一切顺利，**system()**将执行**sh**。
- en: The keywords are—*if all goes as planned*. A real target environment isn’t going
    to look like your lab, and there are numerous factors that can cause this attack
    to fail. It requires fine-tuning, but in a world where large enterprises are clinging
    to legacy applications, we see these attacks and their variants today. Hopefully,
    this introduction will springboard you into deeper research on all things ROP.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是——*如果一切顺利的话*。一个真实的目标环境不会像你的实验室那样，存在很多因素可能导致这个攻击失败。它需要精细调试，但在一个大企业依然依赖遗留应用的世界里，我们今天仍然能看到这些攻击及其变种。希望这篇介绍能够帮助你深入研究ROP相关内容。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: For a couple of years now, some security professionals have been sounding the
    death knell of ROP. It’s considered old and unreliable, and new technology promises
    to mitigate even a carefully constructed exploit with shadow registers that track
    returns during an execution flow. Then again, Windows XP has been dead for several
    years, but anyone spending time in large production environments today is bound
    to see it still clinging for life, running legacy applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一些安全专家一直在宣告ROP的终结。它被认为是陈旧且不可靠的，而新技术则承诺通过使用跟踪执行流中返回的影子寄存器来缓解即使是精心构建的漏洞。然而，Windows
    XP已经死亡多年，但今天在大型生产环境中工作的人仍然会看到它顽强地生存着，运行着旧版应用程序。
- en: Today, a significant effort in many organizations is not replacing XP but rather
    indirect mitigation via the network or third-party software controlling the execution
    of code. ROP is still relevant for the time being, even if just to verify that
    it doesn’t work in your client’s environment. The unique nature of this attack
    renders it particularly dangerous, despite its current signs of aging.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多组织的主要工作并不是替换XP，而是通过网络或第三方软件间接缓解，控制代码执行。ROP目前仍然相关，即使它只是为了验证它在客户环境中无法正常工作。这种攻击的独特性使其尤其危险，尽管它目前已经显现出老化的迹象。
- en: 'In this chapter, we reviewed DEP and ASLR as theoretical concepts and demonstrated
    these technologies in action on Linux. We introduced ROP and two primary tools
    of the trade: MSFrop and ROPgadget. We typed up a C program with a critical vulnerability
    and left the default protections intact. The remainder of the chapter was spent
    covering the fundamentals of ROP, return-to-PLT, return-to-libc, and gadget discovery
    and review. We explored how to bring the pieces together for a functioning exploit.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了DEP和ASLR作为理论概念，并在Linux上演示了这些技术的实际应用。我们介绍了ROP以及两种主要的工具：MSFrop和ROPgadget。我们编写了一个存在重大漏洞的C程序，并保持默认保护不变。章节的其余部分讲解了ROP的基础知识，包括返回到PLT、返回到libc、gadget发现和复习。我们探索了如何将这些部分结合起来形成一个可行的漏洞利用。
- en: In the next chapter, we’ll wrap up our shellcoding review by diving into the
    world of antivirus evasion. Instead of bypassing stack protection mechanisms,
    we’ll learn how to piggyback our code inside an injected executable, and we’ll
    learn how to pass our shellcode to a script interpreter. We’ll get hands-on with
    PowerShell to learn how to live off the land and take advantage of PowerShell’s
    privileged position in the Windows operating system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过深入探讨防病毒逃避技术来结束我们的shellcoding回顾。我们将不再绕过堆栈保护机制，而是学习如何将我们的代码附加到注入的可执行文件中，并学习如何将我们的shellcode传递给脚本解释器。我们将亲自操作PowerShell，学习如何利用PowerShell在Windows操作系统中的特权位置，并发挥它的优势。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，以测试你对本章内容的掌握：
- en: Name the two types of DEP in Windows.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出Windows中两种类型的DEP。
- en: Define **libc**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义**libc**。
- en: How many bytes long can a gadget be prior to its return?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回之前，一个gadget的长度最多可以有多少字节？
- en: '**gcc -no-pie** disables ______________ hardening.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**gcc -no-pie**禁用_______________硬化。'
- en: What’s the difference between the PLT and the GOT?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLT和GOT之间有什么区别？
- en: What’s a quick and easy way to find **system@plt** with gdb?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用gdb快速找到**system@plt**的方法是什么？
- en: Why won’t the **pack(">I", 0x0804a02c)** function work in the ROP context on
    an x86 processor?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么**pack(">I", 0x0804a02c)**函数在x86处理器上的ROP上下文中不起作用？
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章所涉及主题的更多信息，请查看以下资源：
- en: 'Black Hat presentation on ROP: [https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf](https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于ROP的Black Hat演讲：[https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf](https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf)
- en: 'Presentation on ROP by the creator of ROPgadget: [http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf](http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROP的创始人Jonathan Salwan关于ROP的演讲：[http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf](http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf)
