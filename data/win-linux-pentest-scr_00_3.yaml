- en: '*Chapter 2*: Bypassing Network Access Control'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 2 章*：绕过网络访问控制'
- en: The network is the first thing we think about when we imagine computers getting
    hacked. It’s the pen tester’s playground. It’s both the first step and the final
    frontier of compromising a computer. It’s also what makes the compromise of a
    single computer effectively the compromise of an entire building full of computers.
    It’s fitting, then, that we continue our journey with a discussion about compromising
    the network and using its own power and weaknesses to inform the pen test.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是我们想象计算机被黑客攻击时首先考虑的部分。它是渗透测试人员的游乐场。它既是入侵计算机的第一步，也是最终的边界。它还使得单一计算机的妥协实际上成为整栋大楼内所有计算机的妥协。因此，我们继续我们的旅程，讨论如何妥协网络，并利用其自身的力量和弱点来指导渗透测试。
- en: The first step is getting on the network, and there are human, architectural,
    and protocol factors that make the mere presence of an attacker on the network
    potentially devastating. For this reason, defenders often deploy **Network Access
    Control** (**NAC**) systems. The intent of these systems is to detect and/or prevent
    an intrusion on the network by identifying and authenticating devices on the network.
    In this chapter, we will review some of the methods employed by NACs and demonstrate
    practical methods of bypassing these controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是连接到网络，存在一些人类、架构和协议因素，使得攻击者在网络上的存在可能造成灾难性后果。因此，防御者通常会部署**网络访问控制**（**NAC**）系统。这些系统的目的是通过识别和认证网络上的设备来检测和/或防止网络入侵。在本章中，我们将回顾
    NAC 系统采用的一些方法，并演示绕过这些控制的实用方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Bypassing NACs with physical access to clone an authorized device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过物理访问绕过 NAC 并克隆授权设备
- en: Captive portal methods and their weaknesses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制门户方法及其弱点
- en: Policy checks for new devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新设备的政策检查
- en: Masquerading the stack of an authorized device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪装授权设备的堆栈
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are required before you move further into the chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章内容之前，以下是必备条件：
- en: Kali Linux installed on a laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本电脑上安装 Kali Linux
- en: A USB wireless network interface card that supports promiscuous mode in Kali
    – I recommend Alfa cards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Kali 中混杂模式的 USB 无线网络接口卡——我推荐使用 Alfa 卡
- en: Bypassing media access control filtering – considerations for the physical assessor
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过媒体访问控制过滤——物理评估者的考虑事项
- en: 'An attacker needs to be aware of methods for remote compromise: attacking the
    VPN, wireless infiltration from a distance using high-gain antennas, and so on.
    However, the pen tester can never forget the big picture. This is a field where
    it is very easy to get caught up in the highly specific technical details and
    miss the human element of security design.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者需要了解远程攻击的方法：攻击 VPN、使用高增益天线从远距离进行无线渗透等。然而，渗透测试人员永远不能忘记大局。在这个领域中，很容易陷入极其具体的技术细节，忽视安全设计中的人为因素。
- en: There is a design flaw concept that pen testers like to call the *candy bar
    model*. This simply refers to a network that is tough and crunchy on the outside
    but gooey on the inside. In other words, it is a model that emphasizes the threats
    of the outside world when designing the security architecture, while assuming
    that someone who is physically inside company facilities has been vetted and is
    therefore trusted. The mindset here dates back many years; in the earliest days
    of what became the internet, the physical access points to the network were inside
    highly secure facilities. Packets coming in over the network were safely assumed
    to be from a secure environment and sent by an authorized individual. In today’s
    world, a packet hitting the border of a company’s network could be from an authorized
    individual on a business trip or it could be from a clever teenager on the other
    side of the planet, eager to try out some newly learned tricks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员喜欢称之为 *糖果棒模型* 的设计缺陷概念。这指的是一种网络，它的外部坚硬且具有防护性，但内部却软弱且易受攻击。换句话说，它是一种在设计安全架构时强调外部威胁的模型，同时假设公司设施内的人员已经经过验证，因此是值得信任的。这个思维方式可以追溯到许多年前；在互联网初期，网络的物理接入点位于高度安全的设施内部。通过网络传入的数据包通常被安全地假定来自一个安全的环境，并由授权个人发送。在今天的世界里，进入公司网络边界的数据包可能来自正在出差的授权人员，也可能来自地球另一端的聪明少年，迫不及待地想尝试一些新学到的技巧。
- en: The candy bar model will come up in later chapters when we discuss other network
    attacks. Once you crack that outer shell, you’ll often find that the path forward
    seems paved especially for you – and a successful compromise will inform your
    client of the devastating consequences of this mistaken assumption. Feel free
    to treat yourself to an actual candy bar upon successful compromise – you deserve
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 糖果棒模型将在后面的章节中讨论其他网络攻击时出现。一旦你破解了外壳，你经常会发现前进的道路似乎特别为你铺设 - 一个成功的妥协将告诉你的客户这种错误假设的毁灭性后果。在成功妥协后，随时可以奖励自己一个真正的糖果棒
    - 你值得拥有。
- en: How you social-engineer your target is a subject for another book altogether,
    but for the purposes of this discussion, let’s assume that you have physical access
    to network drops. Not all physical access is the same, though; if you convinced
    your target to hire you as a full-time employee, then you’ll have constant physical
    access. They’ll even hand you a computer. However, what’s more likely is that
    you’ve exploited a small gap in their physical security stance, and your presence
    can be undetected or tolerated for only a short period of time. You’ve snuck in
    through the smokers’ door after striking up some conversation with an unwitting
    employee, or you’ve been given permission to walk around for an hour with a convincing-looking
    contractor uniform and clipboard, or (my personal favorite) you’ve earned trust
    and affection by bringing in a big box of donuts for the people expecting an auditor’s
    visit based on a well-scripted phone call. (My clients, still shaken after the
    test, would ask whether the donuts were real.) For now, we’ll demonstrate how
    to set up a Kali box to function as a rogue wireless access point while impersonating
    the **Media Access Control** (**MAC**) address of a **Voice over Internet Protocol**
    (**VoIP**) phone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如何社会工程你的目标是另一本书的主题，但在这次讨论中，让我们假设你有网络插座的物理访问权限。然而，并非所有的物理访问都是相同的；如果你说服你的目标雇佣你作为全职员工，那么你将拥有持续的物理访问权限。他们甚至会给你一台电脑。然而，更有可能的是你已经利用了他们物理安全立场的一个小漏洞，你的存在可能不会被察觉或者只能被容忍很短的时间。你通过吸引一名毫不知情的员工的谈话后从吸烟者门潜入，或者你已经得到了穿着看起来像承包商制服和夹板的许可，或者（我个人最喜欢的）通过带来一大箱甜甜圈赢得了信任和喜爱，这些人期待着根据一个精心策划的电话来访的审计员。
    （我的客户，在测试后仍然震惊，会问甜甜圈是真的吗。）现在，我们将演示如何设置一个Kali盒子，将其设置为一个伪造的无线访问点，同时冒充一个**媒体访问控制**（**MAC**）地址的**互联网电话**（**VoIP**）电话。
- en: Configuring a Kali wireless access point to bypass MAC filtering
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Kali无线访问点以绕过MAC过滤
- en: You’ve found an unoccupied cubicle with an empty desk and a generic IP phone.
    The phone is plugged in and working, so you know the network drop is active. We’ll
    drop our small laptop running Kali here and continue the attack from outside.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到了一个空置的小隔间，里面有一张空桌子和一个普通的IP电话。电话已经插上并且在工作，所以你知道网络插座是激活的。我们将把运行Kali的小型笔记本放在这里，然后从外部继续攻击。
- en: First, we unplug the IP phone so that our bad guy can take the port. We are
    then going to clone the MAC address of the IP phone on our Kali box’s Ethernet
    port. From the perspective of a simple MAC address whitelisting methodology of
    NAC, this will look like the phone merely rebooted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们拔掉IP电话，这样我们的坏家伙就可以占用端口。然后我们将在我们的Kali盒子的以太网端口上克隆IP电话的MAC地址。从NAC的简单MAC地址白名单方法的角度来看，这将看起来像电话仅仅重新启动了。
- en: I use **ifconfig** to bring up the interface configuration. In my example, my
    Ethernet port interface is called **eth0** and my wireless interface is called
    **wlan0**. I’ll note this for later, as I will need to configure the system to
    run an access point with **Dynamic Host Configuration Protocol** (**DHCP**) and
    **Domain Name System** (**DNS**) on **wlan0**, while running **Network Address
    Translation** (**NAT**) through to my **eth0** interface. I can use **ifconfig
    eth0 hw ether** to change the physical address of the **eth0** interface. I’ve
    sneaked a peek at the label on the back of the IP phone – the MAC address is **AC:A0:16:23:D8:1A**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用**ifconfig**来启动接口配置。在我的例子中，我的以太网端口接口被称为**eth0**，我的无线接口被称为**wlan0**。我会记下这一点，因为我需要配置系统在**wlan0**上运行一个带有**动态主机配置协议**（**DHCP**）和**域名系统**（**DNS**）的访问点，同时通过我的**eth0**接口运行**网络地址转换**（**NAT**）。我可以使用**ifconfig
    eth0 hw ether**来更改**eth0**接口的物理地址。我已经偷偷看了一眼IP电话背面的标签 - MAC地址是**AC:A0:16:23:D8:1A**。
- en: 'So, I bring the interface down for the change, bring it back up, then run **ifconfig**
    one more time to confirm the status of the interface with the new physical address,
    as shown in *Figure 2.1*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我先将接口关闭进行更改，然后重新启动接口，最后再次运行 **ifconfig** 确认接口状态是否已更新为新的物理地址，如 *图 2.1* 所示：
- en: '![Figure 2.1 – Bringing up the interface with its new MAC address ](image/Figure_2.01_B17616.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 使用新的 MAC 地址启动接口](image/Figure_2.01_B17616.jpg)'
- en: Figure 2.1 – Bringing up the interface with its new MAC address
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 使用新的 MAC 地址启动接口
- en: Don’t Forget to Sudo!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了使用 Sudo！
- en: The subject of running things as **root** in Kali has been a contentious one.
    One of the fundamental rules of Linux usage is that you should never log in as
    **root** – if the need for **root** privileges comes along, use the **sudo** command.
    Kali Linux used to do things a little differently; it was expected that you would
    log on as **root**. The idea is that Kali is only meant for pen testing, not to
    be your personal machine (and certainly not a production server). Accordingly,
    in the first edition of this book, we never used **sudo** because we were always
    logged on as **root**. This time around, I’ll switch to a **root** session with
    **sudo -s**. The folks at Offensive Security have kept their sense of humor –
    you’ll be reminded of your superpowers with a skull icon.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 中，作为 **root** 用户运行程序的话题一直存在争议。Linux 使用的基本规则之一是你不应该以 **root** 身份登录；如果需要
    **root** 权限，请使用 **sudo** 命令。Kali Linux 以前有所不同，默认要求以 **root** 身份登录。Kali 设计的初衷是只用于渗透测试，而不是作为个人机器（当然也不是生产服务器）。因此，在本书的第一版中，我们从未使用过
    **sudo**，因为我们始终是以 **root** 用户身份登录的。这一次，我将切换到一个 **root** 会话，使用 **sudo -s** 命令。Offensive
    Security 的团队保持了他们的幽默感，你会看到一个骷髅图标提醒你拥有超级权限。
- en: 'Two handy tools in the Kali repository are **dnsmasq** and **hostapd**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 仓库中有两个非常实用的工具：**dnsmasq** 和 **hostapd**：
- en: '**dnsmasq** is a lightweight network infrastructure utility. Completely free
    and written in C, this is a nifty tool for setting up a quick and dirty network
    on the fly, complete with DHCP and DNS forwarding. In our example, we’re using
    it as a DHCP and DNS service for the wireless clients who connect to our access
    point (which would be you and your colleagues, of course).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dnsmasq** 是一款轻量级的网络基础设施工具。它是完全免费的，并且用 C 语言编写，是一款便捷的工具，能够快速搭建临时网络，包括 DHCP
    和 DNS 转发。在我们的示例中，我们将其用作无线客户端连接到接入点时的 DHCP 和 DNS 服务（当然，这里的无线客户端就是你和你的同事）。'
- en: '**hostapd** (**host access point daemon**) is, as the name implies, access
    point software for turning your ordinary wireless network interface into an access
    point and even an authentication server. You can confirm that whatever Wi-Fi card
    you’re using supports AP mode with this command:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostapd**（**host access point daemon**）顾名思义，是一款接入点软件，可以将普通的无线网络接口变成接入点，甚至可以作为认证服务器。你可以使用以下命令来确认你使用的无线网卡是否支持
    AP 模式：'
- en: '**# iw list |grep "Supported interface modes" -A 8**'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**# iw list |grep "Supported interface modes" -A 8**'
- en: If you see **AP** in the results, you’re good to go. We use **apt-get install
    hostapd dnsmasq** to grab the tools.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在结果中看到 **AP**，那么就可以继续了。我们使用 **apt-get install hostapd dnsmasq** 来安装这些工具。
- en: If you run into problems with **apt-get** (for instance, **package not found**),
    always review your repository’s **sources.list** file as a first step. Don’t add
    arbitrary sources to the **sources.list** file; this is a great way to break your
    Kali installation. In my copy of Kali 2021.1, I had to first run **apt-get update**.
    You shouldn’t need to do this more than once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到 **apt-get** 问题（例如 **找不到软件包**），请首先检查你的仓库 **sources.list** 文件。不要随意向 **sources.list**
    文件添加源；这样做可能会破坏你的 Kali 安装。在我使用的 Kali 2021.1 中，我必须先运行 **apt-get update**。通常只需要执行一次此命令。
- en: 'Back to our AP adventure. First, let’s configure **dnsmasq**. Open up **/etc/dnsmasq.conf**
    using the **nano** command. Then, punch in the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 AP 冒险。首先，让我们配置 **dnsmasq**。使用 **nano** 命令打开 **/etc/dnsmasq.conf** 文件。然后，输入以下内容：
- en: '![Figure 2.2 – The dnsmasq configuration file ](image/Figure_2.02_B17616.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – dnsmasq 配置文件](image/Figure_2.02_B17616.jpg)'
- en: Figure 2.2 – The dnsmasq configuration file
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – dnsmasq 配置文件
- en: 'You can see that the configuration file has everything you need to know commented
    out; I strongly recommend you sit down with the **readme** file to understand
    the full capability of this tool, especially so that you can fine-tune your use
    for whatever you’re doing in the field. Since this is a hands-on demonstration,
    I’m keeping it pretty simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到配置文件中的所有内容都已经注释了出来；我强烈建议你坐下来阅读**readme**文件，以理解该工具的全部功能，特别是为了让你根据实际需要进行精细调校。由于这是一个动手示范，我会保持简单：
- en: '**interface=wlan0**: I set my interface to **wlan0**, where the USB wireless
    card that will play the role of the access point is located.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**interface=wlan0**：我将接口设置为**wlan0**，这是 USB 无线网卡所在的位置，该网卡将作为接入点。'
- en: '**dhcp-range=10.11.12.2,10.11.12.20,4h**: I set the DHCP range where new clients
    will be assigned IP addresses when they request an assignment. The format is **[bottom
    address],[top address],[lease time]**. The address range here is what would be
    assigned to new clients, so make sure you don’t overlap with the gateway address.
    You’re the gateway!'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dhcp-range=10.11.12.2,10.11.12.20,4h**：我设置了 DHCP 范围，在新客户端请求分配 IP 地址时，将从该范围分配地址。格式是**[底部地址]，[顶部地址]，[租用时间]**。这里的地址范围将分配给新客户端，因此请确保不要与网关地址重叠。你就是网关！'
- en: '**dhcp-option=3,10.11.12.1** and **dhcp-option=6,10.11.12.1**: DHCP options
    specification. This isn’t arbitrary – these numbers are specified in RFC 2132
    and subsequent RFCs, so there’s a lot of power here. For our purposes here, I’m
    setting the gateway with option **3** and DNS with option **6**. In this case,
    they’re the same address, as we would expect on a tiny LAN like this one. Note
    the address: **10.11.12.1**. That’s the gateway that, by definition, will be your
    **wlan0** interface. You’ll define that address when you bring up the wireless
    interface just prior to firing up the access point.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dhcp-option=3,10.11.12.1** 和 **dhcp-option=6,10.11.12.1**：DHCP 选项的指定。这不是随意的——这些数字在
    RFC 2132 和后续的 RFC 中有明确规定，因此它具有很大的功能。就我们的目的而言，我通过选项**3**设置网关，通过选项**6**设置 DNS。在这种情况下，它们是相同的地址，因为我们预计在这样的局域网中会是这样的。注意这个地址：**10.11.12.1**。这就是网关，按照定义，它将是你的**wlan0**接口。在启动接入点之前，你将定义这个地址，当你启动无线接口时。'
- en: '**server=8.8.8.8**: I defined the upstream DNS server; I set it to Google **8.8.8.8**,
    but you can use something different.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**server=8.8.8.8**：我定义了上游 DNS 服务器；我将其设置为 Google 的 **8.8.8.8**，但你可以使用其他服务器。'
- en: '**log-queries** and **log-dhcp**: I did some logging, just in case we need
    it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**log-queries** 和 **log-dhcp**：我做了一些日志记录，以防我们需要它。'
- en: 'Hit *Ctrl* + *X* and confirm the file name to save it. Now, we’ll move on to
    the **hostapd** configuration. Open up **/etc/hostapd/hostapd.conf** using the
    **nano** command. Keep in mind that this file doesn’t already exist, but **hostapd**
    will know to use what we create here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *X* 并确认文件名以保存它。现在，我们将继续进行**hostapd**配置。使用**nano**命令打开 **/etc/hostapd/hostapd.conf**
    文件。请记住，这个文件本来不存在，但**hostapd**会知道使用我们在这里创建的文件：
- en: '![Figure 2.3 – Configuring our access point for hostapd ](image/Figure_2.03_B17616.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 为 hostapd 配置接入点](image/Figure_2.03_B17616.jpg)'
- en: Figure 2.3 – Configuring our access point for hostapd
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 为 hostapd 配置接入点
- en: 'Again, this is a tool with a lot of power, so check out the **readme** file
    so you can fully appreciate everything it can do. You can create a rather sophisticated
    access point with this software, but we’ll just keep it simple for this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这是一个功能强大的工具，因此请查看**readme**文件，以便你能充分理解它能做的一切。你可以使用这个软件创建一个相当复杂的接入点，但我们在这个示例中会保持简单：
- en: '**interface=wlan0**: I set the interface to **wlan0**, of course.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**interface=wlan0**：我将接口设置为**wlan0**，当然。'
- en: '**driver=nl80211**: I defined the wireless driver; this is **nl80211**, the
    interface between **cfg80211** and user space, and it allows for management of
    the device.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**driver=nl80211**：我定义了无线驱动程序；这是**nl80211**，它是**cfg80211**和用户空间之间的接口，允许管理设备。'
- en: '**ssid=NotABadGuy**: This is our service set identifier – our network’s name.
    I’m using **NotABadGuy** because I want to convince the world that I’m really
    a good guy, but of course, you’ll fine-tune this to your needs. There’s a bit
    of social-engineering potential here to minimize suspicion on the part of those
    casually scanning the environment.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ssid=NotABadGuy**：这是我们的服务集标识符——我们网络的名称。我使用**NotABadGuy**是因为我想向世界证明我真的是个好人，但当然，你可以根据自己的需要进行调整。在这里有一点社交工程潜力，可以减少那些随意扫描环境的人的怀疑。'
- en: '**hw_mode=g**: This is the 802.11 modulation standard; **b**, **g**, and **n**
    are common.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hw_mode=g**：这是 802.11 调制标准；**b**、**g** 和 **n** 是常见的标准。'
- en: '**channel=2**: I’ve defined the channel here, but you can configure it to pick
    the channel automatically based on surveying.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**channel=2**：我在这里定义了频道，但你可以配置它根据调查自动选择频道。'
- en: '**macaddr_acl=0**: This is a Boolean flag to tell **hostapd** if we’re using
    a MAC-based access control list. You’ll have to decide whether this is something
    you need for your purposes. In my example, I’ve configured encryption, and I like
    to use randomly generated MACs on my devices anyway, so I’d rather not deal with
    whitelisting MACs.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macaddr_acl=0**：这是一个布尔标志，告诉**hostapd**我们是否使用基于MAC的访问控制列表。你需要决定这是否是你所需的功能。在我的示例中，我已经配置了加密，而且我喜欢在我的设备上使用随机生成的MAC地址，所以我不想处理MAC地址的白名单问题。'
- en: '**max_num_sta=1**: This is a way to keep the population of wireless clients
    restricted – this is the maximum number of clients that are allowed to join. I
    set mine as **1** here since I only expect myself to be joining, but you could
    omit this.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max_num_sta=1**：这是一种限制无线客户端数量的方法——这是允许加入的最大客户端数量。我在这里将其设置为**1**，因为我只期望我自己加入，但你可以省略这个选项。'
- en: '**ignore_broadcast_ssid=0**: This option simply allows you to hide the network.
    What it really does is cause your AP to ignore probe request frames that don’t
    specify the SSID, so it will hide your network from active scans, but you should
    never consider a functional access point to be hidden. I want to see it in my
    example, so I set it to **0**.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ignore_broadcast_ssid=0**：这个选项简单地让你隐藏网络。它的实际作用是让你的接入点忽略那些没有指定SSID的探测请求帧，因此它会将你的网络从主动扫描中隐藏，但你永远不应认为一个功能正常的接入点是完全隐藏的。我想在我的示例中看到它，所以我将其设置为**0**。'
- en: The remaining options allow me to configure WPA2 encryption.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩下的选项允许我配置WPA2加密。
- en: Believe it or not, those are the basics for our quick and dirty access point
    to the physical network. Now, I’ll bring up the **wlan0** interface and specify
    the gateway address I defined earlier. Then, I bring up **dnsmasq** and tell it
    to use my configuration file. We enable IP forwarding to tell Kali to act as a
    router with **sysctl**. We allow our traffic through and enable NAT functionality
    with **iptables**. Finally, we fire up **hostapd** with our configuration file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这些就是我们快速搭建接入点以连接物理网络的基础。现在，我将启动**wlan0**接口，并指定我之前定义的网关地址。接着，我启动**dnsmasq**并告诉它使用我的配置文件。我们启用IP转发，告诉Kali作为路由器工作，并使用**sysctl**。我们通过**iptables**允许流量通过并启用NAT功能。最后，我们启动带有配置文件的**hostapd**。
- en: We’ll be looking at **iptables** again, so don’t worry about the details here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次查看**iptables**，所以不用担心这里的细节。
- en: 'When a wireless client connects to this network, they will have access to the
    corporate network via **eth0**; to a MAC filter, traffic coming from that port
    will appear to be coming from a Cisco IP phone:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当无线客户端连接到这个网络时，他们将通过**eth0**访问公司网络；对于MAC过滤器来说，来自该端口的流量看起来像是来自Cisco IP电话：
- en: '![Figure 2.4 – Configuring routing with iptables to make our AP work ](image/Figure_2.04_B17616.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 使用iptables配置路由以使我们的接入点工作](image/Figure_2.04_B17616.jpg)'
- en: Figure 2.4 – Configuring routing with iptables to make our AP work
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 使用iptables配置路由以使我们的接入点工作
- en: As you’ve no doubt noticed, this is a really useful setup. Having your box work
    as a hotspot can be invaluable, and since Kali will run on such a wide variety
    of hardware, the limit is your imagination.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你无疑注意到的，这是一个非常有用的设置。让你的设备作为热点工作可以非常宝贵，而且由于Kali能够在如此广泛的硬件上运行，唯一的限制就是你的想象力。
- en: Design weaknesses – exploiting weak authentication mechanisms
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计缺陷 – 利用弱认证机制
- en: With NAC, authentication is the name of the game. In our first attack scenario,
    we saw that the network verifies that a device is permitted by MAC address whitelisting.
    The principle is simple – a list of allowed devices is checked when a device joins
    the network. Many people, even outside of the field, are familiar with MAC filtering
    from the common implementation of this technique in SOHO wireless routers. However,
    you may be surprised at how often the VoIP phone masquerade will work in highly
    secured environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在NAC中，认证是关键。在我们的第一个攻击场景中，我们看到网络通过MAC地址白名单验证设备是否被允许。原理很简单——当设备加入网络时，会检查允许设备的列表。许多人，甚至是行业外的人，都对MAC过滤有一定了解，这项技术常常在SOHO无线路由器中实施。然而，你可能会惊讶地发现，在高度安全的环境中，VoIP电话伪装攻击是多么有效。
- en: It’s network security 101 – MAC addresses are very easily faked, and networks
    will take your word for it when you claim to be a particular value. I’ve had clients
    detail, at length, the various features of their state-of-the-art NAC, only to
    look puzzled when I show them I had network access to their server environment
    by pretending to be a conference-room phone. It’s important to test for this bypass;
    not many clients are aware of simple threats.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络安全基础知识 – MAC地址非常容易伪造，当你声称自己是某个特定的值时，网络会信任你。我曾经有客户详细描述他们先进的NAC的各种功能，然而当我向他们展示我通过伪装成会议室电话来访问他们的服务器环境时，他们都显得非常困惑。测试这种绕过方法非常重要；并不是所有客户都意识到这些简单的威胁。
- en: 'We’re now going to look at another attack that can fly surprisingly low under
    the radar: exploiting authentication communications in the initial restricted
    network. We’ll be using Wireshark for quick and easy packet analysis in this section;
    a more advanced Wireshark discussion will take place in [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050),
    *Sniffing and Spoofing*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨一种能够在雷达下悄无声息地进行的攻击：利用初始受限网络中的认证通信。在本节中，我们将使用Wireshark进行快速且简便的数据包分析；关于Wireshark的更高级讨论将在[*第3章*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050)中进行，*嗅探与欺骗*。
- en: Capturing captive portal authentication conversations in the clear
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获清晰的登录门户认证对话
- en: Speaking of security mechanisms that even non-security folks will have some
    familiarity with, captive portals are a common NAC strategy. They’re the walls
    you encounter when trying to get online in a hotel or an airplane; everything
    you try to access takes you to a specially configured login screen. You will receive
    credentials from an administrator, or you will submit a payment – either way,
    after you’ve authenticated, the captive portal will grant access via some means
    (a common one is **Simple Network Management Protocol** (**SNMP**) management
    post-authentication).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 说到即使是非安全领域的人也会有所了解的安全机制，*登录门户*（captive portals）是常见的网络访问控制（NAC）策略。当你在酒店或飞机上尝试连接网络时，你会遇到这种“墙”，无论你试图访问什么，都会被引导到一个专门配置的登录页面。你会从管理员那里获得凭据，或者提交支付–无论哪种方式，认证通过后，*登录门户*将通过某种方式授予访问权限（常见的一种方式是**简单网络管理协议**（**SNMP**）认证后管理）。
- en: 'I know what the hacker in you is saying: *When the unauthenticated client tries
    to send an HTTP request, they get a 301 redirect to the captive portal authentication
    page, so it''s really nothing more than a locally hosted web page. Therefore,
    it may be susceptible to ordinary web attacks.* Well done, I couldn’t have said
    it better. But don’t fire up **sslstrip** just yet; would it surprise you to learn
    that unencrypted authentication is actually fairly common? We’re going to take
    a look at an example: the captive portal to grant internet access to guests in
    my house. This isn’t your run-of-the-mill captive portal functionality built into
    an off-the-shelf home router; this is a pfSense firewall running on a dedicated
    server.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你心中的黑客在说什么：*当未认证的客户端尝试发送HTTP请求时，它们会被301重定向到登录门户认证页面，所以这不过是一个本地托管的网页罢了。它可能会受到普通的网络攻击。*
    干得好，我简直无法说得更好了。但别急着启动**sslstrip**；如果你知道未加密的认证其实相当普遍，你会感到惊讶吗？我们将来看一个例子：我家中为访客提供互联网访问的登录门户。这不是一种普通的家用路由器自带的登录门户功能；这是一台运行pfSense防火墙的专用服务器。
- en: This is used in some enterprises, so trust me, you will run into something like
    this in your adventures as a pen tester. I don’t think you’ll see my cat in your
    clients’ captive portals, but you can never be too sure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一些企业中得到了应用，所以相信我，作为渗透测试人员，你会在冒险过程中遇到类似的情况。我不认为你会在客户的登录门户中看到我的猫，但谁知道呢，还是不能太确定。
- en: '![Figure 2.5 – A pfSense-powered captive portal, guarded by my cat ](image/Figure_2.05_B17616.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 一台由pfSense驱动的登录门户，守卫着我的猫](image/Figure_2.05_B17616.jpg)'
- en: Figure 2.5 – A pfSense-powered captive portal, guarded by my cat
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 一台由pfSense驱动的登录门户，守卫着我的猫
- en: What we see here is the captive portal presented to a user immediately upon
    joining the network. I wanted to have a little fun with it, so I wrote up the
    HTML myself (the bad cat pun is courtesy of my wife). However, the functionality
    is exactly the same as you’ll see in companies that utilize this NAC method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到的是用户加入网络后立即看到的登录门户。我想玩得开心一点，于是自己写了HTML代码（那个坏猫的双关语是我妻子的创意）。不过，它的功能和你在使用这种NAC方法的公司中看到的一模一样。
- en: 'Let’s get in the Kali driver’s seat. We’ve already established a connection
    to this network, and we’re immediately placed into the restricted zone. Fire up
    a terminal and start Wireshark as the superuser:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坐进 Kali 的驾驶座。我们已经建立了与该网络的连接，并且立即被置于受限区。启动终端，并以超级用户身份启动 Wireshark：
- en: '![Figure 2.6 – Capturing traffic on a switched network with Wireshark ](image/Figure_2.06_B17616.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 使用 Wireshark 捕获交换网络上的流量](image/Figure_2.06_B17616.jpg)'
- en: Figure 2.6 – Capturing traffic on a switched network with Wireshark
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 使用 Wireshark 捕获交换网络上的流量
- en: 'Not a lot is going on here, even with our card in promiscuous mode. This looks
    like we’re dealing with a switched network, so traffic between our victim and
    the gateway is not broadcasted for us to see. But, take a closer look at the highlighted
    packet: it’s being broadcasted to **255.255.255.255** – the broadcast address
    of the zero network (that is, the network we’re on). We can see that it’s a DHCP
    request. So, our victim with an unknown IP address is joining the network and
    will soon authenticate to the portal. Though the victim isn’t the destination,
    we’ll find the IP address assignment in the DHCP Ack packet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的网卡处于混杂模式，这里也没有太多的活动。这看起来像是我们正在处理一个交换式网络，所以我们无法看到受害者与网关之间的广播流量。但仔细看看高亮的数据包：它正在广播到
    **255.255.255.255** —— 零网络的广播地址（也就是我们所在的网络）。我们可以看到它是一个 DHCP 请求。因此，我们的受害者正在加入网络，IP
    地址未知，稍后会认证到门户。虽然受害者并不是目标，但我们会在 DHCP Ack 数据包中找到 IP 地址分配：
- en: '![Figure 2.7 – Examining a DHCP packet with Wireshark ](image/Figure_2.07_B17616.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 使用 Wireshark 检查 DHCP 数据包](image/Figure_2.07_B17616.jpg)'
- en: Figure 2.7 – Examining a DHCP packet with Wireshark
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用 Wireshark 检查 DHCP 数据包
- en: 'Wireshark is kind enough to convert that hex into a human-friendly IP address:
    **192.168.80.71**. We’re on a switched LAN, so our victim’s HTTP authentication
    is going directly to the gateway, right? Yes, it is, but the keyword here is LAN.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 很贴心地将十六进制转换为易于理解的 IP 地址：**192.168.80.71**。我们处在一个交换式局域网（LAN）中，所以受害者的
    HTTP 认证直接发送到网关，对吧？是的，没错，但这里的关键词是 LAN。
- en: Layer-2 attacks against the network
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对网络的第二层攻击
- en: 'The lowest layer of the internet protocol suite is the link layer, which is
    the realm of adjacent hosts on a LAN segment. Link-layer communication protocols
    don’t leave the network via routers, so it’s important to be aware of them and
    their weaknesses when you are attacking LANs. When you join a LAN, even a restricted
    one outside of the protected network, you’re sharing that space with anything
    else on that segment: the captive portal host itself, other clients waiting to
    be authenticated, and, in some cases, even with authenticated clients.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议栈的最低层是链路层，这是局域网段上相邻主机的领域。链路层通信协议不会通过路由器离开网络，因此在攻击 LAN 时，了解这些协议及其弱点非常重要。当你加入一个局域网，甚至是一个受限的局域网（不在受保护网络中），你与该段上任何其他设备共享这个空间：捕获门户主机本身、等待认证的其他客户端，甚至在某些情况下，与已认证的客户端共享。
- en: The unqualified term **LAN** doesn’t necessarily mean that all members of the
    LAN are in the same broadcast domain, also called a **layer-2 segment**. For our
    purposes here, we’re talking about hosts sharing the same link-layer environment,
    as the attack described won’t work in private VLANs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAN** 这个未经限定的术语并不意味着 LAN 中的所有成员都处于同一个广播域，也叫做 **第二层段**。在这里，我们讨论的是共享相同链路层环境的主机，因为所描述的攻击在私有
    VLAN 中不起作用。'
- en: When our victim joined the LAN, it was assigned an IP address by DHCP. But any
    device with a message for that IP address has to know the link-layer hardware
    address associated with the destination IP. This layer-2–layer-3 mapping is accomplished
    with the **Address Resolution Protocol** (**ARP**). An ARP message informs the
    requester *where* (that is, at which link-layer address) a particular IP address
    is assigned. The clients on the network maintain a local table of ARP mappings.
    For example, on Windows, you can check the local ARP table with the **arp -a**
    command. The fun begins when we learn that these tables are updated by ARP messages
    without any kind of verification. If you’re an ARP table and I tell you that the
    gateway IP address is mapped to **00:01:02:aa:ab:ac**, you’re going to just believe
    it and update accordingly. This opens the possibility of *poisoning* the ARP table
    – feeding it bad information.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的受害者加入局域网时，DHCP为其分配了一个IP地址。但是，任何发送到该IP地址的设备都必须知道与目标IP地址相关联的链路层硬件地址。这个链路层到网络层的映射是通过**地址解析协议**（**ARP**）完成的。ARP消息告诉请求者某个IP地址被分配到*哪个*（即哪个链路层地址）设备上。网络中的客户端维护一个本地的ARP映射表。例如，在Windows上，你可以使用**arp
    -a**命令查看本地的ARP表。趣味开始于我们了解到，这些表是通过ARP消息更新的，而没有任何验证。如果你是ARP表，并且我告诉你网关的IP地址与**00:01:02:aa:ab:ac**的MAC地址映射，那么你会直接相信并做出更新。这为*中毒*ARP表——向其中注入错误信息——提供了可能性。
- en: What we’re going to do is feed the network bad ARP information so that the gateway
    believes that the Kali attacker’s MAC address is assigned the victim’s IP address;
    meanwhile, we’re also telling the network that the Kali attacker’s MAC address
    is assigned the gateway IP address. The victim will send data meant for the gateway
    to me, and the gateway will send data meant for the victim to me. Of course, that
    would mean nothing is getting from the gateway to the victim and vice versa, so
    we’ll need to enable packet forwarding so that the Kali machine will hand off
    the message to the actual destination. By the time the packet gets to where it
    was meant to go, we’ve processed it and sniffed it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是向网络注入错误的ARP信息，使得网关认为Kali攻击者的MAC地址被分配给了受害者的IP地址；同时，我们还告诉网络Kali攻击者的MAC地址被分配给了网关的IP地址。这样，受害者将把发送给网关的数据发送给我，网关则会把发送给受害者的数据发送给我。当然，这意味着从网关到受害者，或者从受害者到网关的通信都不会进行，因此我们需要启用数据包转发，以便Kali机器将数据转发到实际的目标。当数据包到达目标时，我们已经对其进行了处理和嗅探。
- en: We will cover spoofing in more detail in [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050),
    *Sniffing and Spoofing*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050)，*嗅探与欺骗*中更详细地讲解欺骗技术。
- en: 'First, we enable packet forwarding with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用以下命令启用数据包转发：
- en: echo 1 > /proc/sys/net/ipv4/ip_forward
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: echo 1 > /proc/sys/net/ipv4/ip_forward
- en: 'An alternative command is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条命令如下：
- en: sysctl -w net.ipv4.ip_forward=1
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sysctl -w net.ipv4.ip_forward=1
- en: '**arpspoof** is a lovely tool for really fast and easy ARP poisoning attacks.
    Overall, I prefer Ettercap; however, I will be covering Ettercap later on, and
    it’s always nice to be aware of the quick and dirty ways of doing things for when
    you’re in a pinch. Ettercap is ideal for more sophisticated reconnaissance and
    attack, but with **arpspoof**, you can literally have an ARP man-in-the-middle
    attack running in a matter of seconds.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**arpspoof**是一个非常快速且简单的ARP中毒攻击工具。总体来说，我更喜欢Ettercap；不过，稍后我会讲解Ettercap，了解一些快速且简单的方法在紧急情况下也是很有用的。Ettercap更适合进行复杂的侦察和攻击，而使用**arpspoof**，你几乎可以在几秒钟内启动一个ARP中间人攻击。'
- en: Earlier versions of Kali had this tool ready to go – in Kali 2021.1, you’ll
    need to run **apt-get install dsniff** first. A few seconds later, you’ll be ready
    to go.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的Kali已经准备好这个工具 – 在Kali 2021.1版本中，你需要首先运行**apt-get install dsniff**命令。几秒钟后，你就可以开始使用了。
- en: 'I fire off the **arpspoof –i wlan0 –t 192.168.80.1 -r 192.168.80.71** command.
    The **-i** flag is the interface, the **-t** flag is the target, and the **-r**
    flag tells **arpspoof** to poison both sides to make it bidirectional. (The older
    version didn’t have the **-r** flag, so we had to set up two separate attacks.)
    Keep in mind that the target can be the gateway or the victim; since we’re creating
    a bidirectional attack, it doesn’t matter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入了**arpspoof –i wlan0 –t 192.168.80.1 -r 192.168.80.71**命令。**-i**标志是接口，**-t**标志是目标，**-r**标志告诉**arpspoof**进行双向中毒。（旧版本没有**-r**标志，因此我们必须设置两个单独的攻击。）请记住，目标可以是网关或受害者；由于我们正在创建一个双向攻击，所以无论是哪一方都不重要：
- en: '![Figure 2.8 – Poisoning the ARP tables with arpspoof ](image/Figure_2.08_B17616.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 使用 arpspoof 进行 ARP 表中毒](image/Figure_2.08_B17616.jpg)'
- en: Figure 2.8 – Poisoning the ARP tables with arpspoof
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 使用 arpspoof 进行 ARP 表中毒
- en: Here, we can see **arpspoof** in action, telling the network that the gateway
    and the victim are actually my Kali box. Meanwhile, the packets will be forwarded
    as received to the other side of the intercept. When it works properly (that is,
    your machine doesn’t create a bottleneck), neither side will know the difference
    unless they are sniffing the network. When we check back with Wireshark, we can
    see what an ARP poisoning attack looks like.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到**arpspoof**的实际操作，告诉网络网关和受害者实际上是我的 Kali 主机。同时，数据包将按原样转发到拦截的另一端。当它正常工作时（即你的机器没有产生瓶颈），除非他们在嗅探网络，否则双方不会察觉出差异。当我们使用
    Wireshark 检查时，我们可以看到 ARP 欺骗攻击的表现。
- en: 'We can see communication between the victim and the gateway, so now it’s a
    matter of filtering for what you need. In our demonstration here, we’re looking
    for authentication to a web portal – likely a **POST** message. When I find it,
    I follow the conversation in Wireshark by right-clicking a packet and selecting
    **Follow**, and there are the victim’s credentials in plain text:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到受害者和网关之间的通信，现在只需要过滤出你需要的内容。在我们的示范中，我们正在寻找对一个 Web 门户的身份验证——很可能是一个**POST**消息。当我找到它时，我通过右键单击一个数据包并选择**跟踪**来在
    Wireshark 中查看会话，受害者的凭证以明文显示：
- en: '![Figure 2.9 – Capturing credentials by following the authentication HTTP stream
    with Wireshark ](image/Figure_2.09_B17616.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 通过跟踪身份验证 HTTP 流来捕获凭证，使用 Wireshark ](image/Figure_2.09_B17616.jpg)'
- en: Figure 2.9 – Capturing credentials by following the authentication HTTP stream
    with Wireshark
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 通过跟踪身份验证 HTTP 流来捕获凭证，使用 Wireshark
- en: Take Only Packets, Leave Only Re-ARP
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 只接收数据包，留下一次重新 ARP
- en: Make sure you don’t close the terminal window where **arpspoof** is running
    – use *Ctrl* + *C* to send the kill signal. The program will recognize it and
    attempt to re-ARP your network. Remember, you’ve been poisoning the ARP tables
    on other hosts; that data will persist until new ARP messages correct it. Gracefully
    closing **arpspoof** will do just that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要关闭运行**arpspoof**的终端窗口——使用*Ctrl* + *C*来发送终止信号。程序将识别该信号并尝试重新 ARP 你的网络。记住，你已经在其他主机上进行了
    ARP 欺骗；这些数据会持续存在，直到新的 ARP 消息进行修正。优雅地关闭**arpspoof**将实现这一点。
- en: Bypassing validation checks
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过验证检查
- en: We’ve seen how NAC systems can employ simple MAC address filtering and captive
    portal authentication to control network access. Now, suppose that you’re coming
    away from the ARP poisoning attack just described, excited that you scored yourself
    some legitimate credentials. You try to log in with your Kali box and you’re slapped
    down by a validation check that you hadn’t foreseen. You have the correct username
    and password – how does the NAC know it isn’t the legitimate user?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 NAC 系统如何利用简单的 MAC 地址过滤和捕获门户身份验证来控制网络访问。现在，假设你刚刚从前面描述的 ARP 欺骗攻击中得手，兴奋地发现自己获得了一些合法的凭证。你尝试使用
    Kali 主机登录，但却遇到了一个你未曾预见的验证检查。你拥有正确的用户名和密码——NAC 怎么知道这不是合法用户呢？
- en: 'NAC vendors quickly figured out that it was a simple matter for anyone to spoof
    a MAC address, so some systems perform additional verification to match the hardware
    address to other characteristics of the system. Imagine the difference between
    authenticating someone by fingerprint alone and authenticating someone by fingerprint,
    clothing style, vocal patterns, and so on. The latter prevents simple spoof attacks.
    In this context, the NAC is checking that the MAC address matches other characteristics:
    the manufacturer, operating system, and user-agent are common checks. It turns
    out that the captive portal knows this **Phil** user you’ve just spoofed, and
    it was expecting an Apple iPad (common in the enterprise as an *approved device*).
    Let’s review these three checks in detail.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: NAC 供应商迅速意识到，任何人都可以轻松地伪造 MAC 地址，因此一些系统执行额外的验证，将硬件地址与系统的其他特征进行匹配。想象一下，仅凭指纹进行身份验证和通过指纹、穿衣风格、声纹等多种方式进行身份验证之间的区别。后者能防止简单的伪造攻击。在这个背景下，NAC
    正在检查 MAC 地址是否与其他特征匹配：制造商、操作系统和用户代理是常见的检查项目。结果证明，捕获门户识别出你刚刚伪造的**Phil**用户，并且它本来是期望一台
    Apple iPad（在企业中作为*已批准设备*）。让我们详细回顾一下这三项检查。
- en: Confirming the organizationally unique identifier
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认组织唯一标识符
- en: 'There are two main parts to a MAC address: the first three octets are the **Organizationally
    Unique Identifier** (**OUI**), and the last three octets are **Network Interface
    Controller-specific** (**NIC-specific**). The OUI is important here because it
    uniquely identifies a manufacturer. The manufacturer will purchase an OUI from
    the IEEE Registration Authority and then hardcode it into their devices in-factory.
    This is not a secret – it’s public information, encoded into all the devices a
    particular manufacturer makes. A simple Google search for **Apple OUI** helps
    us narrow it down, though you can also pull up the IEEE Registration Authority
    website directly. We quickly find out that **00:21:e9** belongs to Apple, so we
    can try to spoof a random NIC address with that (for example, **00:21:e9:d2:11:ac**).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MAC 地址有两个主要部分：前三个字节是**组织唯一标识符**（**OUI**），后三个字节是**网络接口控制器特定的**（**NIC-specific**）。OUI
    在这里很重要，因为它能唯一标识一个制造商。制造商会从 IEEE 注册管理机构购买一个 OUI，并将其在工厂中硬编码到他们的设备中。这不是一个秘密——它是公开的信息，已编码到该制造商生产的所有设备中。一个简单的
    Google 搜索 **Apple OUI** 可以帮助我们缩小范围，当然你也可以直接访问 IEEE 注册管理机构网站。我们很快发现 **00:21:e9**
    属于 Apple，所以我们可以尝试用这个来伪造一个随机的 NIC 地址（例如，**00:21:e9:d2:11:ac**）。
- en: But again, vendors are already well aware of the fact that MAC addresses are
    not reliable for filtering, so they’re likely going to look for more indicators.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但再说一次，厂商们已经充分意识到 MAC 地址在过滤中的不可靠性，所以他们很可能会寻找更多的指示符。
- en: Passive operating system fingerprinter
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被动操作系统指纹识别器
- en: Anyone who has dissected a packet off a network should be familiar with the
    concept of operating system fingerprinting. Essentially, operating systems have
    little nuances in how they construct packets to send over the network. These nuances
    are useful as signatures, giving us a good idea of the operating system that sent
    the packet. We’re preparing to spoof the stack of a chosen OS as previously explained,
    so let’s cover a tool in Kali that will come in handy for a variety of recon situations
    – the **passive operating system fingerprinter** (**p0f**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何分析过网络数据包的人都应该熟悉操作系统指纹识别的概念。本质上，操作系统在构造通过网络发送的数据包时有一些小的细微差别。这些细微差别作为签名非常有用，可以帮助我们大致判断发送数据包的操作系统是什么。我们正在准备伪造一个选择的操作系统的堆栈，正如前面所解释的那样，所以让我们来了解一下
    Kali 中一个在多种侦察场景下都会派上用场的工具——**被动操作系统指纹识别器**（**p0f**）。
- en: 'Its power is in its simplicity: it watches for packets, matches signatures
    according to a signature database of known systems, and gives you the results.
    Of course, your network card has to be able to see the packets that are to be
    analyzed. We saw with our example that the restricted network is switched, so
    we can’t see other traffic in a purely passive manner; we had to trick the network
    into routing traffic through our Kali machine. So, we’ll do that again, except
    on a larger scale, as we want to fingerprint a handful of clients on the network.
    Let’s ARP-spoof with Ettercap, a tool that should easily be in your handiest tools
    top 10\. Once Ettercap is running and doing its job, we’ll fire up p0f and see
    what we find.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它的强大之处在于其简洁性：它监听数据包，根据已知系统的签名数据库匹配签名并给出结果。当然，您的网络卡必须能够看到待分析的数据包。我们在示例中看到，由于网络被限制，我们无法以完全被动的方式看到其他流量；我们必须通过欺骗网络将流量路由到我们的
    Kali 机器上。所以，我们将再次这样做，只不过这次是在更大的规模上，因为我们希望对网络中的一些客户端进行指纹识别。让我们使用 Ettercap 进行 ARP
    欺骗，这个工具应该轻松地位列你最常用的前十名工具中。一旦 Ettercap 启动并开始工作，我们将启动 p0f 看看能找到什么。
- en: 'We’re going to bring up Ettercap with the graphical interface, featuring a
    very scary-looking network-sniffing spider:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动 Ettercap 图形界面，界面上有一个看起来非常吓人的网络嗅探蜘蛛：
- en: '**# ettercap -G**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**# ettercap -G**'
- en: '![Figure 2.10 – The startup screen for Ettercap ](image/Figure_2.10_B17616.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – Ettercap 启动屏幕](image/Figure_2.10_B17616.jpg)'
- en: Figure 2.10 – The startup screen for Ettercap
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – Ettercap 启动屏幕
- en: Let’s start sniffing, and then we’ll configure our man-in-the-middle attack.
    Note that **Bridged sniffing** is currently unchecked – this means we’re in unified
    sniffing mode. Unified sniffing means we’re just sniffing from one network card;
    we aren’t forwarding anything to another interface right now. We will cover the
    beauty of bridged sniffing in the next chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始嗅探，然后配置我们的中间人攻击。请注意，**桥接嗅探**目前未选中——这意味着我们正在使用统一嗅探模式。统一嗅探意味着我们仅从一个网络卡嗅探；我们现在并没有将任何东西转发到另一个接口。我们将在下一章讲解桥接嗅探的美妙之处。
- en: Now, we tell Ettercap to find out who’s on the network. Click the check at the
    top to approve the initial settings (make sure your primary interface is correct),
    and then click the three dots button. Under **Hosts**, click on **Scan for hosts**.
    When the scan is complete, you can click **Hosts** again to bring up the host
    list. This tells us what Ettercap knows about who’s on the network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们告诉 Ettercap 查找网络上的设备。点击顶部的勾选框确认初始设置（确保你的主要网络接口正确），然后点击三个点的按钮。在**主机**下，点击**扫描主机**。扫描完成后，你可以再次点击**主机**，查看主机列表。这会告诉我们
    Ettercap 知道的网络上的设备信息。
- en: Now, we’re doing something rather naughty; I’ve selected the gateway as **Target
    1** (by selecting it and then clicking **Add to Target 1**) and a handful of clients
    as **Target 2**. This means Ettercap is going to poison the network with ARP announcements
    for all of those hosts, and we’ll soon be managing the traffic for all of those
    hosts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在做一件相当不正经的事；我选择了网关作为**目标 1**（通过选择它然后点击**添加到目标 1**），并选择了一些客户端作为**目标 2**。这意味着
    Ettercap 将使用 ARP 公告对这些主机进行欺骗，很快我们就会开始管理这些主机的流量。
- en: Always Poison ARP Responsibly
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 始终负责地进行 ARP 欺骗
- en: Be very careful when playing man-in-the-middle with more than a few hosts at
    a time. Your machine can quickly bottleneck the network. I’ve been known to kill
    a client’s network doing this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在与多个主机同时进行中间人攻击时要非常小心。你的机器很容易导致网络瓶颈。我也曾因为这样导致某个客户端的网络瘫痪。
- en: Select **MITM** (small globe icon at the top)| **ARP poisoning**. I like to
    select **Sniff remote connections**, though you don’t have to for this particular
    scenario.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**MITM**（顶部的小地球图标）| **ARP 欺骗**。我喜欢选择**嗅探远程连接**，不过这个场景下你不必这样做。
- en: That’s it. Click **OK** and now Ettercap will work its magic. Click **View**
    | **Connections** to see all the details on connections that Ettercap has seen
    so far.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。点击**确定**，现在 Ettercap 就会施展它的魔法。点击**查看** | **连接**，可以看到 Ettercap 到目前为止所看到的所有连接详情。
- en: 'Those of you who are familiar with Ettercap may know that the **Profiles**
    option in the **View** menu will allow us to fingerprint the OS of the targets,
    but in keeping with presenting the tried-and-true, quick-and-dirty tool for our
    work, let’s fire up p0f. (You’ll need to first install p0f on Kali 2021.1 with
    **apt-get install p0f**.) The **-o** flag allows us to output to a file – trust
    me, you’ll want to do this, especially for a spoofing attack of this magnitude:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Ettercap 的用户，可能知道**查看**菜单中的**配置文件**选项可以让我们识别目标的操作系统，但为了展示简单快捷、直接有效的工具，我们还是使用
    p0f。（你需要先在 Kali 2021.1 上通过**apt-get install p0f**安装 p0f。）**-o** 标志允许我们输出到一个文件——相信我，你会想这么做，尤其是在进行这种大规模欺骗攻击时：
- en: p0f -o poflog
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: p0f -o poflog
- en: 'p0f likes to show you some live data as it’s collecting the juicy gossip. Here,
    we can see that **192.168.108.199** is already fingerprinted as a Linux host by
    looking at a single SYN packet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: p0f 喜欢在收集信息时给你展示一些实时数据。在这里，我们可以看到通过一个单独的 SYN 包，**192.168.108.199** 已经被识别为 Linux
    主机：
- en: '![Figure 2.11 – p0f capturing OS fingerprints ](image/Figure_2.11_B17616.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – p0f 捕获操作系统指纹](image/Figure_2.11_B17616.jpg)'
- en: Figure 2.11 – p0f capturing OS fingerprints
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – p0f 捕获操作系统指纹
- en: '*Ctrl* + *C* closes p0f. Now, let’s open up our (greppable) log file with nano:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *C* 关闭 p0f。现在，让我们用 nano 打开我们的（可搜索的）日志文件：'
- en: '![Figure 2.12 – Reviewing the raw signatures in the p0f log file ](image/Figure_2.12_B17616.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 查看 p0f 日志文件中的原始签名](image/Figure_2.12_B17616.jpg)'
- en: Figure 2.12 – Reviewing the raw signatures in the p0f log file
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 查看 p0f 日志文件中的原始签名
- en: 'Beautiful, isn’t it? The interesting stuff is the raw signature at the end
    of each packet detail line, which is made up of colon-delimited fields in the
    following order:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮吧？有趣的部分是每个数据包详情行末尾的原始签名，它由以冒号分隔的字段组成，顺序如下：
- en: Internet protocol version (for example, *4* means *IPv4*).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络协议版本（例如，*4* 代表 *IPv4*）。
- en: Initial **Time To Live** (**TTL**). It would be weird if you saw anything other
    than *64*, *128*, or *255*, but some OSes use different values; for example, you
    may see AIX hosts using *60*, and legacy Windows (‘95 and ‘98) using *32*.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始**生存时间**（**TTL**）。如果你看到的不是*64*、*128* 或 *255*，那就有点奇怪了，但有些操作系统使用不同的值；例如，你可能会看到
    AIX 主机使用 *60*，而旧版 Windows（‘95 和 ‘98）使用 *32*。
- en: '*IPv4* options length, which will usually be *0*.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*IPv4* 选项长度，通常为 *0*。'
- en: '**Maximum Segment Size** (**MSS**), which is not to be confused with MTU. It’s
    the maximum size in bytes of a single TCP segment that the device can handle.
    The difference from MTU is that the TCP or IP header is not included in the MSS.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最大报文段大小**（**MSS**），不要与MTU混淆。它是设备可以处理的单个TCP段的最大字节大小。与MTU的不同之处在于，MSS不包括TCP或IP头部。'
- en: TCP receive window size, usually specified as a multiple of the MTU or MSS.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP接收窗口大小，通常指定为MTU或MSS的倍数。
- en: Window-scaling factor, if specified.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了，窗口缩放因子。
- en: A comma-delimited ordering of the TCP options (if any are defined).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个逗号分隔的TCP选项排序（如果有定义的话）。
- en: A field that the **readme** file calls *quirks* – weird stuff in the TCP or
    IP headers that can help us narrow down the stack creating it. Check out the **readme**
    file to see what kind of options are displayed here; an example is **df** for
    the **don't fragment** flag set.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**readme**文件中称为*quirks*的字段——TCP或IP头中的奇怪内容，能够帮助我们缩小创建它的协议栈范围。查看**readme**文件，看看这里显示了哪些选项；一个例子是**df**，表示**不分片**标志被设置。'
- en: Why are we concerned with these options anyway? That’s what the fingerprint
    database is for, isn’t it? Of course, but part of the wild and wacky fun of this
    tool is the ability to customize your own signatures. You might see some funky
    stuff out there and it may be up to you, playing with a quirky toy in your lab,
    to make it easier to identify in the wild. However, of particular concern to the
    pen tester is the ability to craft packets that have these signatures to fool
    these NAC validation mechanisms. We’ll be doing that in the next section, but
    for now, you have the information needed to research the stack you want to spoof.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要关注这些选项呢？这不就是指纹库的作用吗？当然，但是这个工具的一个有趣之处在于你可以自定义自己的签名。你可能会看到一些奇怪的东西，可能由你在实验室里玩弄这些古怪的玩具时，帮助它们在实际环境中更容易被识别出来。然而，对于渗透测试人员来说，特别关注的是能够构造具有这些签名的报文，以欺骗这些NAC验证机制。我们将在下一节进行这些操作，但现在，你已经有了研究你想要伪造的协议栈所需的信息。
- en: Spoofing the HTTP user agent
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造HTTP用户代理
- en: Some budding hackers may be surprised to learn that browser user-agent data
    is a consideration in NAC systems, but it is commonly employed as an additional
    validation of a client. Thankfully for us, spoofing the **HTTP user agent** (**UA**)
    field is easy. Back in my day, we used custom UA strings with cURL, but now you
    have fancy browsers that allow you to override the default.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些新手黑客可能会惊讶地发现浏览器用户代理数据在NAC系统中有一定的考虑，但它通常被作为客户端的额外验证。幸运的是，伪造**HTTP用户代理**（**UA**）字段非常简单。回到我那时候，我们用自定义的UA字符串与cURL一起使用，但现在你有了高级浏览器，允许你覆盖默认设置。
- en: Let’s try to emulate an iPad. Sure, you can experiment with an actual iPad to
    capture the UA data, but UA strings are kind of like MAC addresses in that they’re
    easy to spoof, and detailed information is readily available online. So, I’ll
    just search the web for iPad UA data and go with the more common ones. As the
    software and hardware change over time, the UA string can change as well. Keep
    that in mind if you think all iPads (or any device) are created equal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试模拟iPad。你可以通过实际的iPad来捕获UA数据，但UA字符串有点像MAC地址，容易伪造，且详细信息在网上很容易找到。所以，我会在网上搜索iPad的UA数据，选择更常见的那几个。随着软件和硬件的变化，UA字符串也可能会变化。如果你认为所有iPad（或任何设备）都相同，那可要小心了。
- en: 'In Kali, we open up Mozilla Firefox and navigate to **about:config** in the
    address bar. Firefox will politely warn you that this area isn’t for noobs; go
    ahead and accept the warning. Now, search for **useragent** and you’ll see the
    configuration preferences that reference the UA:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali中，我们打开Mozilla Firefox并在地址栏中导航到**about:config**。Firefox会礼貌地提醒你，这个区域不适合新手；继续并接受这个警告。现在，搜索**useragent**，你会看到引用UA的配置选项：
- en: '![Figure 2.13 – Accessing advanced configuration of Firefox ](image/Figure_2.13_B17616.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 访问Firefox的高级配置](image/Figure_2.13_B17616.jpg)'
- en: Figure 2.13 – Accessing advanced configuration of Firefox
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 访问Firefox的高级配置
- en: 'Note that there isn’t an override preference name with a string data type (so
    we can provide a **useragent** string). So, we have to create it. Go back to the
    search bar and type **general.useragent.override**. The only result here will
    be the option for you to create it; select the **String** data type and then click
    the plus sign:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里没有一个带有字符串数据类型的覆盖首选项名称（因此我们可以提供**useragent**字符串）。所以，我们需要创建它。回到搜索栏，输入**general.useragent.override**。这里唯一的结果是你可以创建它的选项；选择**String**数据类型，然后点击加号：
- en: '![Figure 2.14 – Creating the UA override in Firefox Advanced Preferences ](image/Figure_2.14_B17616.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 在 Firefox 高级设置中创建 UA 重写](image/Figure_2.14_B17616.jpg)'
- en: Figure 2.14 – Creating the UA override in Firefox Advanced Preferences
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 在 Firefox 高级设置中创建 UA 重写
- en: 'A field will appear where you type in the value for this new preference. Keep
    in mind that there isn’t a handy builder that will take specific values and put
    together a nicely formatted UA string; you have to punch it in character by character,
    so check the data you’re putting there for accuracy. You could pretend to be a
    refrigerator if you wanted to, but I’m not sure that helps us here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一个字段，在其中输入这个新偏好的值。请记住，没有一个方便的构建工具可以将特定值组合成格式良好的 UA 字符串；你必须逐个字符输入，因此请检查你输入的数据的准确性。如果你愿意，可以假装自己是冰箱，但我不确定这对我们有任何帮助：
- en: '![Figure 2.15 – Firefox is now telling the world it''s an iPhone ](image/Figure_2.15_B17616.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – Firefox 现在告诉世界它是一个 iPhone](image/Figure_2.15_B17616.jpg)'
- en: Figure 2.15 – Firefox is now telling the world it’s an iPhone
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – Firefox 现在告诉世界它是一个 iPhone
- en: 'I’ve just dumped in the UA data for an iPhone running iOS 12.2, opened a new
    tab, and verified what the web thinks I am:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚输入了一个运行 iOS 12.2 的 iPhone 的 UA 数据，打开了一个新标签页，并验证了网站认为我是什么：
- en: '![Figure 2.16 – Confirming the UA spoof worked ](image/Figure_2.16_B17616.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 确认 UA 欺骗成功](image/Figure_2.16_B17616.jpg)'
- en: Figure 2.16 – Confirming the UA spoof worked
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 确认 UA 欺骗成功
- en: The **Website Goodies** page is now convinced that my Kali box is actually a
    friendly iPhone.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Website Goodies** 页面现在相信我的 Kali 主机实际上是一个友好的 iPhone。'
- en: 'While we’re here, we should cover ourselves from JavaScript validation techniques
    as well. Some captive portals may inject some JavaScript to validate the operating
    system by checking the **Document Object Model** (**DOM**) fields in the browser.
    You can manipulate these responses in the same way you did for the UA data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还应该防范 JavaScript 验证技术。一些认证门户可能会注入一些 JavaScript 来通过检查浏览器中的 **文档对象模型** (**DOM**)
    字段来验证操作系统。你可以像处理 UA 数据一样操控这些响应：
- en: general.[DOM key].override
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: general.[DOM key].override
- en: 'For example, the **oscpu** field will disclose the CPU type on the host, so
    we can override the response with the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**oscpu** 字段会显示主机上的 CPU 类型，因此我们可以用以下内容来重写响应：
- en: general.oscpu.override
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: general.oscpu.override
- en: As before, the data type is a string. This seems too easy, but keep in mind
    that the only code that will get the true information instead of your override
    preferences that are defined here is privileged code (for example, code with **UniversalBrowserRead**
    privileges). If it was easy enough to inject JavaScript that could run privileged
    code, then we’d have a bit of a security nightmare on our hands. This is one of
    those cases where the trade-off helps us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据类型是字符串。这看起来很简单，但请记住，只有具有特权的代码（例如，具有 **UniversalBrowserRead** 权限的代码）才能获取真实信息，而不是你在这里定义的重写偏好。如果注入可以运行特权代码的
    JavaScript 足够容易，那么我们可能会面临一些安全问题。这是一个权衡的例子，它对我们有帮助。
- en: Breaking out of jail – masquerading the stack
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破牢笼 – 伪装堆栈
- en: Imagine you’re trying to get past a guarded door. The moment you open that door,
    a guard sees you and, identifying you as unauthorized, immediately kicks you out.
    But, suppose that an authorized person opens the door and props it open, and the
    guard will only verify the identity of the person walking through every 10 minutes
    or so, instead of continuously. They assume that an authorized person is using
    the door during that 10-minute window because they already authenticated the first
    person who opened it and propped it open.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正试图通过一扇有守卫把守的门。你一打开门，守卫看到你，认定你没有授权，于是立即把你赶了出去。但假设一个授权人员打开了门并把它撑开，而守卫则每
    10 分钟左右验证一次进入的人身份，而不是持续验证。他们假设在这 10 分钟的时间窗口内是一个授权人员正在使用这扇门，因为他们已经验证过了第一个打开门并撑开它的人。
- en: Of course, this wouldn’t happen in the real world (at least, I sure hope not),
    but the principle is often seen even in sophisticated industry-standard NAC systems.
    Instead of people, we’re talking about packets on the network. As we learned from
    our fingerprinting exercise, the fine details of how a packet is formed betray
    a particular source system. These details make them handy indicators of a source.
    It quacks like a duck and it walks like a duck, so it is a duck, and definitely
    not a guy in a duck costume.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这在现实世界中不会发生（至少，我希望不会发生），但这一原理在复杂的工业标准NAC系统中常常能够看到。我们讨论的不是人，而是网络中的数据包。正如我们在指纹识别实验中所学到的，数据包的形成细节可以泄露特定源系统的信息。这些细节使它们成为源的有用指示器。它像鸭子叫，也像鸭子走路，所以它就是鸭子，而绝对不是穿着鸭子服装的人。
- en: 'NACs employing this kind of fingerprinting technique will conduct an initial
    evaluation, and then assume the subsequent packets match the signature, just like
    our guard who figures the door is being used by the good guy after they do their
    first check. The reason for this is simple: performance. Whether the follow-up
    checks are every few minutes or never will depend on the NAC and configuration.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种指纹识别技术的NAC将进行初步评估，然后假设随后的数据包与签名匹配，就像我们的守卫在第一次检查后认为门是由好人使用的一样。其原因很简单：性能。后续检查是否每隔几分钟进行一次或从不进行，取决于NAC及其配置。
- en: 'We’re going to introduce a tool called **Scapy** to demo this particular attack.
    As we progress through this book, you will see that Scapy could easily replace
    most of the tools that pen testers take for granted: port scanners, fingerprinters,
    spoofers, and so on. We’re going to do a quick demo for our NAC bypass here, but
    we will be leveraging the power of Scapy in the coming chapters.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一个工具叫做**Scapy**，用来演示这个特定的攻击。在本书的后续章节中，您将看到Scapy可以轻松替代渗透测试人员所习惯使用的大多数工具：端口扫描器、指纹识别工具、欺骗工具等等。我们将在这里快速演示NAC绕过，但在接下来的章节中，我们将利用Scapy的强大功能。
- en: Following the rules spoils the fun – suppressing normal TCP replies
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循规则会破坏乐趣 —— 抑制正常的TCP回应
- en: 'The details of a TCP handshake are beyond the scope of this chapter, but we’ll
    discuss the basics to understand what we need to do to pull off the masquerade.
    Most of us are familiar with the TCP three-way handshake:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TCP握手的详细过程超出了本章的范围，但我们将讨论基本知识，以便理解我们需要做什么才能完成伪装。大多数人都熟悉TCP的三次握手：
- en: The client sends a **SYN** request (**synchronize**).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送**SYN**请求（**同步**）。
- en: The receiver replies with a **SYN-ACK** acknowledgment (**synchronize-acknowledge**).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收方回复**SYN-ACK**确认（**同步-确认**）。
- en: The client confirms with an **ACK** acknowledgment; the channel is established,
    and communication can begin.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端确认并发送**ACK**确认；通道已建立，通信可以开始。
- en: 'This is a very simple description (I’ve left out sequence numbers; we’ll discuss
    those later), and it’s nice when it works as designed. However, those of you with
    any significant Nmap experience should be familiar with the funny things that
    can happen when a service receives something out of sequence. *Section 3.4* of
    RFC 793 is where the fun is really laid out, and I encourage everyone to read
    it. Basically, the design of TCP has mechanisms to abort if something goes wrong
    – in TCP terms, we abort with the **RST** control packet (**reset**) Make sure
    there is a space between (reset) and this new addition: (We’ll cover TCP and Nmap
    in greater detail in [*Chapter 5*](B17616_05_Final_VK_ePub.xhtml#_idTextAnchor085),
    *Assessing Network Security*). This matters to us here because we’re about to
    establish a fraudulent TCP connection, designed to mimic one created by the Safari
    browser on an iPad. Kali will be very confused when we get our acknowledgment
    back:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的描述（我省略了序列号，稍后我们会讨论），当它按设计工作时，非常好。然而，那些有一定Nmap经验的人应该对服务在接收到异常顺序的数据时可能发生的奇怪情况有所了解。RFC
    793的*第3.4节*详细描述了这些有趣的情况，我鼓励大家阅读。基本上，TCP的设计有机制，在出现问题时会中止——用TCP术语来说，我们通过**RST**控制包（**重置**）来中止。请确保（重置）和这个新补充部分之间有一个空格：（我们将在[*第5章*](B17616_05_Final_VK_ePub.xhtml#_idTextAnchor085)，*评估网络安全性*中更详细地讨论TCP和Nmap）。这对我们来说非常重要，因为我们即将建立一个伪造的TCP连接，旨在模仿Safari浏览器在iPad上创建的连接。当我们收到确认信息时，Kali会非常困惑：
- en: Scapy uses our network interface to send the forged **SYN** packet.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scapy使用我们的网络接口来发送伪造的**SYN**数据包。
- en: The captive portal web service sends a **SYN-ACK** acknowledgment back to our
    address.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获门户Web服务向我们的地址发送**SYN-ACK**确认。
- en: The Kali Linux system itself, having not sent any **SYN** requests, will receive
    an unsolicited **SYN-ACK** acknowledgment.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kali Linux 系统本身并未发送任何 **SYN** 请求，因此将接收到一个未经请求的 **SYN-ACK** 确认包。
- en: Per RFC specification, Kali decides something is wrong here and aborts with
    the **RST** packet, exposing our operating system’s identity.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 RFC 规范，Kali 判断出某些地方出错，并通过 **RST** 包中止，暴露了我们的操作系统身份。
- en: Well, this won’t do. We have to duct-tape the mouth of our Kali box until we
    get through validation. It’s easy enough with **iptables**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这样不行。我们必须临时封住 Kali 主机的口，直到完成验证。这用 **iptables** 很容易做到。
- en: '**iptables** is the Linux firewall. It works with policy chains where rules
    for handling packets are defined. There are three policy categories: *input*,
    *output*, and *forward*. Input is data destined for your machine, output is data
    originating from your machine, and forward is for data not really destined for
    your machine but that will be passed on to its destination. Unless you’re doing
    some sort of routing or forwarding – like during our man-in-the-middle attack
    earlier in the chapter – then you won’t be doing anything with the forward policy
    chain. For our purposes here, we just need to restrict data originating from our
    machine.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**iptables** 是 Linux 防火墙。它通过策略链来处理数据包。规则是为数据包处理定义的。共有三种策略类别：*input*（输入）、*output*（输出）和
    *forward*（转发）。Input 是指目标为你机器的数据，output 是指来源于你机器的数据，forward 是指并非真正面向你机器的数据，但会被转发到其目标。如果你没有进行某种路由或转发操作——就像在本章前面我们进行的中间人攻击——那么你就不会操作
    forward 策略链。在我们这里的目的，只需要限制从我们机器发出的数据。'
- en: 'Extra credit if you’ve already realized that, if we aren’t careful, we’ll end
    up restricting the Scapy packets! So, what are we restricting, exactly? We want
    to restrict a TCP **RST** packet destined for port **80** on the gateway and coming
    from our Kali box. For our demonstration, we’ve set up the listener at **192.168.108.239**
    and our Kali attack box is at **192.168.108.253**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经意识到这一点，额外的奖励：如果我们不小心，可能会限制到 Scapy 包！那么，我们到底在限制什么呢？我们想要限制的是目标为网关 **80**
    端口的 TCP **RST** 包，并且来自我们的 Kali 主机。为了演示，我们已经在 **192.168.108.239** 上设置了监听器，而我们的
    Kali 攻击主机则位于 **192.168.108.253**。
- en: iptables -F && iptables -A OUTPUT -p tcp --destination-port 80 --tcp-flags RST
    RST -s 192.168.108.225 -d 192.168.108.215 -j DROP
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iptables -F && iptables -A OUTPUT -p tcp --destination-port 80 --tcp-flags RST
    RST -s 192.168.108.225 -d 192.168.108.215 -j DROP
- en: 'Let’s break this down:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来拆解一下：
- en: '**-F** tells **iptables** to *flush* any currently configured rules. We were
    tinkering with rules for our ARP attack, so this resets everything.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-F** 告诉 **iptables** 清除当前配置的所有规则。我们正在调整用于 ARP 攻击的规则，因此这将重置一切。'
- en: '**-A** means *append* a rule. Note that I didn’t use the potentially misleading
    term *add*. Remember that firewall rules have to be in the correct order to work
    properly. We don’t need to worry about that here as we don’t have any other rules,
    so that’s for a different discussion.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-A** 表示 *附加* 规则。请注意，我没有使用可能令人误解的词语 *add*。记住，防火墙规则必须按正确的顺序工作。我们在这里不需要担心这一点，因为我们没有其他规则，所以这属于另一个话题。'
- en: '**OUTPUT** identifies the policy chain to which we’re about to append a rule.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OUTPUT** 标识我们即将附加规则的策略链。'
- en: '**-p** identifies the protocol – in this case, TCP.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p** 表示协议——在这个例子中是 TCP。'
- en: '**--destination-port** and **--tcp-flags** are self-explanatory: we’re targeting
    any **RST** control packets destined for the HTTP port.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--destination-port** 和 **--tcp-flags** 不言自明：我们瞄准的是任何目标为 HTTP 端口的 **RST**
    控制包。'
- en: '**-s** is our source and **-d** is our destination.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s** 是我们的源地址，**-d** 是目标地址。'
- en: '**-j** is the *jump*, which specifies the rule target. This just defines the
    actual action taken. If this were omitted, then nothing would happen, but the
    rule packet counter would increment.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-j** 是 *跳转*，它指定规则的目标。它定义了实际执行的动作。如果省略这个选项，那么什么也不会发生，但规则包计数器会递增。'
- en: 'The following screenshot illustrates the output of the preceding command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前述命令的输出：
- en: '![Figure 2.17 – Listing our modifications in iptables ](image/Figure_2.17_B17616.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 列出我们在 iptables 中的修改](image/Figure_2.17_B17616.jpg)'
- en: Figure 2.17 – Listing our modifications in iptables
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 列出我们在 iptables 中的修改
- en: We’re ready to send our forged packets to the captive portal authentication
    page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将伪造的包发送到强制门户认证页面。
- en: Fabricating the handshake with Scapy and Python
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scapy 和 Python 制造握手
- en: You can bring up the Scapy interpreter interface by simply commanding **scapy**,
    but for this discussion, we’ll be importing its power into a Python script.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地输入 **scapy** 命令来启动 Scapy 解释器界面，但为了本讨论，我们将把它的功能导入到 Python 脚本中。
- en: Scapy is a sophisticated packet manipulation and crafting program. It is a Python
    program, but Python plays an even bigger role in Scapy as the syntax and interpreter
    for Scapy’s domain-specific language. What this means for the pen tester is a
    packet manipulator and forger with unmatched versatility because it allows you
    to literally write your own network tools, on the fly, with very few lines of
    code – and it leaves the interpretation up to you, instead of within the confines
    of what a tool author imagined.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 是一款复杂的包操作和构建程序。它是一个 Python 程序，但 Python 在 Scapy 中扮演的角色更大，作为 Scapy 专用语言的语法和解释器。这对于渗透测试者来说意味着一个功能强大的包操控和伪造工具，它具有无与伦比的灵活性，因为它允许你在飞行过程中用很少的代码行编写自己的网络工具——并且解释权完全掌握在你手中，而不是局限于工具作者的设想。
- en: What we’re doing here is a crash course in scripting with Python and Scapy,
    so don’t be intimidated. We will be covering Scapy and Python in detail later
    on in the book. We’ll step through everything happening here in our NAC bypass
    scenario so that, when we fire up Scapy in the future, it will quickly make sense.
    If you’re like me, you learn faster when you’re shoved into the pool. That being
    said, don’t neglect curling up with the Scapy documentation and some hot cocoa.
    The documentation on Scapy is excellent.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是 Python 和 Scapy 脚本编写的速成课程，所以不要害怕。稍后我们会更详细地讨论 Scapy 和 Python。我们将在这里的
    NAC 绕过场景中逐步分析每个步骤，这样当我们以后使用 Scapy 时，就能迅速理解。如果你像我一样，在被推入泳池后学习更快的话，那就大大欢迎你阅读 Scapy
    的文档和喝一杯热可可。Scapy 的文档非常棒。
- en: 'As you know, we set up our captive portal listener and OS fingerprinter at
    **192.168.108.239**. Let’s try to browse this address with an unmodified Firefox
    ESR in Kali and see what p0f picks up:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，我们已经在 **192.168.108.239** 设置了我们的捕获门户监听器和操作系统指纹识别器。让我们尝试在 Kali 中用未修改的 Firefox
    ESR 浏览这个地址，看看 p0f 能发现什么：
- en: '![Figure 2.18 – Busted: p0f knows it''s Linux ](image/Figure_2.18_B17616.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 被识破：p0f 知道它是 Linux ](image/Figure_2.18_B17616.jpg)'
- en: 'Figure 2.18 – Busted: p0f knows it’s Linux'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 被识破：p0f 知道它是 Linux
- en: We can see in the very top line, representing the very first **SYN** packet
    received, that p0f has already identified us as a Linux client. Remember, p0f
    is looking at how the TCP packet is constructed, so we don’t need to wait for
    any HTTP requests to divulge system information. Linux fingerprints are all over
    the TCP three-way handshake before the browser has even established a connection
    to the site.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在最上面一行看到，表示收到的第一个 **SYN** 包，p0f 已经识别出我们是 Linux 客户端。记住，p0f 是通过查看 TCP 包的构造来判断的，所以我们无需等待任何
    HTTP 请求来泄露系统信息。在浏览器与网站建立连接之前，Linux 的指纹就已经出现在 TCP 三次握手中。
- en: 'In our example, let’s emulate our trusty iPhone from earlier. Putting on our
    hacker hat (the white one, please), we can put two and two together:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，让我们模拟之前的老朋友 iPhone。戴上黑客帽子（请戴白色的），我们可以将两者结合起来：
- en: p0f has a database of signatures (**p0f.fp**) that it references in order to
    fingerprint a source.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: p0f 有一个签名数据库（**p0f.fp**），它通过这个数据库来指纹识别源。
- en: Scapy allows us to construct TCP packets, and, with a little scripting, we can
    tie together several Scapy lines into a single TCP three-way handshake utility.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scapy 让我们能够构建 TCP 包，并且通过简单的脚本，我们可以将多个 Scapy 命令组合成一个完整的 TCP 三次握手工具。
- en: 'We now have a recipe for our spoofing attack. Now, Scapy lets you construct
    communications in its interpreter, using the same syntax as Python, but what we’re
    going to do is fire up nano and put together a Python script that will import
    Scapy. We’ll discuss what’s happening here after we confirm the attack works:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了伪造攻击的配方。Scapy 让你在其解释器中构建通信，使用与 Python 相同的语法，但我们要做的是启动 nano，编写一个导入 Scapy
    的 Python 脚本。我们将在确认攻击成功后讨论这里发生的事情：
- en: '[PRE0]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once I’m done typing this up in nano, I save it as a **.py** file and **chmod**
    it to allow execution. That’s it – the attack is ready:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我在 nano 中完成输入，我将其保存为 **.py** 文件并使用 **chmod** 命令设置为可执行。就这样——攻击准备就绪：
- en: '![Figure 2.19 – Our Scapy Python script is ready ](image/Figure_2.19_B17616.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 我们的 Scapy Python 脚本已准备好 ](image/Figure_2.19_B17616.jpg)'
- en: Figure 2.19 – Our Scapy Python script is ready
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 我们的 Scapy Python 脚本已准备好
- en: 'The **iptables** outbound rule is set, and the script is ready to execute.
    Let it fly:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**iptables** 出站规则已设置，脚本准备好执行。让我们开始吧：'
- en: '![Figure 2.20 – Scapy reporting the successful transmission ](image/Figure_2.20_B17616.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – Scapy报告成功传输](image/Figure_2.20_B17616.jpg)'
- en: Figure 2.20 – Scapy reporting the successful transmission
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – Scapy报告成功传输
- en: 'That’s it – not very climactic at this end. But let’s take a look at the receiving
    end:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——到这里并没有什么高潮。但让我们看看接收端：
- en: '![Figure 2.21 – p0f thinks we''re an iOS device ](image/Figure_2.21_B17616.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – p0f认为我们是iOS设备](image/Figure_2.21_B17616.jpg)'
- en: Figure 2.21 – p0f thinks we’re an iOS device
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – p0f认为我们是iOS设备
- en: 'Voila! The OS fingerprinter is convinced that the packets were sent by an iOS
    device. When we scroll down, we can see the actual HTTP request with the UA data.
    At this point, the NAC allows access and we can go back to doing our usual business.
    Don’t forget to open up **iptables**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！操作系统指纹识别工具相信这些数据包是由iOS设备发送的。当我们向下滚动时，可以看到实际的HTTP请求及其UA数据。这时，NAC允许访问，我们可以继续进行平常的工作。别忘了打开**iptables**：
- en: iptables -F
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iptables -F
- en: 'So what happened here, exactly? Let’s break it down:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里到底发生了什么呢？让我们分解一下：
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’re declaring a variable for the captive portal IP address and the source
    port. The source port is a random integer between **1024** and **65535** so that
    an ephemeral port is used:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个变量用于捕获门户的IP地址和源端口。源端口是**1024**到**65535**之间的随机整数，因此使用了一个临时端口：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we’re defining the layers of the packets we will send. **ip** is the IP
    layer of our packet with our captive portal as the destination, a don’t-fragment
    flag set, and a TTL of **64**. Now, when Scapy is ready to send this particular
    packet, we’ll simply reference **ip**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义将要发送的数据包的各个层。**ip**是我们数据包的IP层，目标是我们的捕获门户，设置了不分片标志，并且TTL为**64**。当Scapy准备好发送这个特定的数据包时，我们只需引用**ip**。
- en: We define **tcpopt** with the TCP options we’ll be using. This is the meat and
    potatoes of the OS signature, so this is based on our signature research.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用将要使用的TCP选项定义**tcpopt**。这是操作系统指纹的核心内容，因此它是基于我们的指纹研究。
- en: Next, we declare **SYN**, which is the TCP layer of our packet, defining our
    randomly chosen ephemeral port, the destination port **80**, the **SYN** flag
    set, a sequence number, and a window size (also part of the signature). We set
    the TCP options with our just-defined **tcpopt**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明**SYN**，这是我们数据包的TCP层，定义了我们随机选择的临时端口、目标端口**80**、设置的**SYN**标志、序列号和窗口大小（也是指纹的一部分）。我们用刚定义的**tcpopt**设置TCP选项。
- en: 'Then, we send the **SYN** request with **sr1**. However, **sr1** means *send
    a packet, and record 1 reply*. The reply is then stored as **SYNACK**:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过**sr1**发送**SYN**请求。然而，**sr1**表示*发送一个数据包，并记录1个回复*。回复被存储为**SYNACK**：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We sent a **SYN** packet with **sr1**, which told Scapy to record the reply
    – in other words, record the **SYN-ACK** acknowledgment that comes back from the
    server. That packet is now stored as **SYNACK**. So, now we’re constructing the
    third part of the handshake, our **ACK**. We use the same port information and
    switch the flag accordingly, and we take the sequence number from **SYN-ACK**
    and increment it by one. Since we’re just acknowledging **SYN-ACK** and thus completing
    the handshake, we only send this packet without needing a reply, so we use the
    **send** command instead of **sr1**:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过**sr1**发送了一个**SYN**包，它指示Scapy记录回复——换句话说，记录从服务器返回的**SYN-ACK**确认包。该数据包现在被存储为**SYNACK**。接下来，我们构造握手的第三部分，即我们的**ACK**。我们使用相同的端口信息并相应地切换标志，同时从**SYN-ACK**中获取序列号并将其加一。由于我们只是确认**SYN-ACK**并完成握手，因此我们只发送这个数据包而不需要回复，因此使用**send**命令而不是**sr1**：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that the TCP session is established, we craft our **GET** request for the
    HTTP server. We’re constructing the payload and storing it as **request**. Note
    the use of Python syntax to concatenate the target IP address and create returns
    and newlines. We construct the TCP layer with the **PSH + ACK** flag and an incremented
    sequence number. Finally, we use another **send** command to send the packet using
    the same IP layer, the newly defined TCP layer called **PUSH**, and the HTTP payload
    as **request**:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在TCP会话已经建立，我们为HTTP服务器构造了**GET**请求。我们正在构建有效载荷并将其存储为**request**。请注意使用Python语法来连接目标IP地址并创建回车符和换行符。我们构造带有**PSH
    + ACK**标志的TCP层，并增加序列号。最后，我们使用另一个**send**命令发送数据包，使用相同的IP层、新定义的名为**PUSH**的TCP层和HTTP有效载荷作为**request**：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we tidy up, having completed our duty. We build a **RST** packet to
    tear down the TCP connection we have just established and send it with the **send**
    command.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们整理好一切，完成了我们的任务。我们构建了一个**RST**数据包，用于断开我们刚刚建立的TCP连接，并使用**send**命令发送它。
- en: I hope I have whetted your appetite for Scapy and Python, because we will be
    taking these incredibly powerful tools to the next level later in this book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我已经激发了你对Scapy和Python的兴趣，因为我们将在本书后面将这两个强大的工具提升到一个新层次。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed NAC systems and some of their techniques. We learned
    how to construct a wireless access point with Kali for a physical drop while masquerading
    as an authorized IP phone. We learned how to attack switched networks with layer-2
    poisoning to intercept authentication data for authorized users while trapped
    in a restricted LAN. Other validation checks were discussed and methods for bypassing
    them were demonstrated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们回顾了NAC系统及其一些技术。我们学习了如何使用Kali构建一个无线接入点，通过伪装成授权的IP电话进行物理降级攻击。我们学习了如何通过二层中毒攻击交换网络，以便在被困于受限局域网时拦截授权用户的认证数据。还讨论了其他验证检查，并展示了绕过这些检查的方法。
- en: We learned how operating system fingerprinting works and developed ways to research
    signatures for recon and construct spoofing attacks for a target system, using
    the iOS running on an iPad as an example. We reviewed a more advanced operating
    system fingerprinting method, fingerprinting the stack, and introduced the packet
    manipulation utility Scapy to demonstrate a stack masquerade by writing up a Python
    script.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了操作系统指纹识别的工作原理，并开发了研究签名进行侦察的方式，同时为目标系统构建欺骗攻击，示例使用了运行在iPad上的iOS。我们回顾了一个更高级的操作系统指纹识别方法——指纹识别堆栈，并介绍了数据包操作工具Scapy，通过编写Python脚本演示了堆栈伪装。
- en: In the next chapter, we will take our sniffing and spoofing to the next level,
    and even combine the two concepts to create a clean and quiet man-in-the-middle
    attack.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将把嗅探和欺骗提升到新的水平，甚至将这两个概念结合起来，创建一个干净安静的中间人攻击。
- en: Questions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题来测试你对本章的知识掌握情况：
- en: What does **apd** in **hostapd** stand for?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**hostapd**中的**apd**代表什么？'
- en: How can you quickly tell whether your wireless card supports access point mode?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何快速判断你的无线网卡是否支持接入点模式？
- en: What does the **hostapd** configuration parameter **ignore_broadcast_ssid**
    do?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**hostapd**配置参数**ignore_broadcast_ssid**的作用是什么？'
- en: '**255.255.255.255** is the broadcast address of the ____________.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**255.255.255.255**是___________的广播地址。'
- en: You’re running an ARP poisoning attack. You know the target and gateway IP addresses,
    so you immediately fire up **arpspoof**. Suddenly, communication between the target
    and the gateway is broken. What happened?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在进行一个ARP欺骗攻击。你知道目标和网关的IP地址，所以你立即启动了**arpspoof**。突然，目标与网关之间的通信中断了。发生了什么事？
- en: What do the first three octets and the last three octets of the MAC address
    represent respectively?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAC地址的前三个八位字节和后三个八位字节分别代表什么？
- en: The MSS and the MTU are the same size. True or false?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MSS和MTU的大小是一样的吗？对还是错？
- en: What does the **-j** flag do in **iptables**?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**iptables**中的**-j**标志是做什么的？'
- en: You have defined the IP and TCP layers of a specially crafted packet as **IP**
    and **TCP** respectively. You want Scapy to send the packet and save the reply
    as **REPLY**. What’s the command?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已将一个特别构造的数据包的IP层和TCP层分别定义为**IP**和**TCP**。你希望Scapy发送这个数据包并将回复保存为**REPLY**。命令是什么？
- en: Further reading
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resource:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章所涵盖的主题，查看更多信息，请查看以下资源：
- en: 'Scapy documentation: [https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scapy文档：[https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)
