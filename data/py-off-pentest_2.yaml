- en: Advanced Scriptable Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级可脚本化Shell
- en: The problem with the back door, which we created in the previous chapter, is
    that if the attacker IP changes we don't have a built-in mechanism to inform our
    target that it should connect to the new IP address. In this chapter we will look
    into a method that lets you keep a fixed reserved name for your attacker machine
    even if its IP changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建的后门问题在于，如果攻击者的IP地址发生变化，我们没有内建机制来通知目标它应该连接到新的IP地址。本章将介绍一种方法，即使IP地址发生变化，你也可以为你的攻击者机器保留一个固定的预定名称。
- en: 'The following are the topics that will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Dynamic DNS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态DNS
- en: Interacting with Twitter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Twitter交互
- en: Replicating Metasploit's screen capturing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟Metasploit的屏幕捕捉
- en: Replicating Metasploit searching for content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟Metasploit搜索内容
- en: Integrating a low-level port scanner
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成一个低级端口扫描器
- en: Dynamic DNS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态DNS
- en: 'Now, one of the methods we''ll discuss here is dynamic DNS. Let''s say that
    the attacker IP is `1.1.1.1` on day 1\. Then, the next day, we get an IP address
    of `2.2.2.2`. Then, how would our target know the new IP address ? The answer
    is **dynamic DNS** (**DDNS**). It is a method to preserve a unique name for you
    on a DNS server. While the reserved name is fixed, the correlated IP address will
    change each time you change your public IP address. For demonstration, we will
    use [noip.com](https://www.noip.com/). It provides a free dynamic DNS service.
    So I have previously preserved a name called `pythonhussam.ddns.net`. So on the
    target side, instead of hard-coding the IP address on that script, we will do
    a DNS lookup for this name; then we will retrieve the IP address to make the connection.
    Now, you''re probably asking: When the attacker IP address changes, how does [noip.com](https://www.noip.com/) know
    the new IP address to update its DNS record? Well, the answer is via a software
    agent, which should be installed on our Kali machine. The agent will connect to
    [noip.com](https://www.noip.com/) servers, and let them know our new IP address.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在这里讨论的其中一种方法是动态DNS。假设攻击者的IP地址在第1天是 `1.1.1.1`，然后在第二天，我们得到一个IP地址 `2.2.2.2`。那么，我们的目标如何知道新的IP地址呢？答案就是**动态DNS**（**DDNS**）。它是一种方法，可以在DNS服务器上为你保留一个唯一的名称。当保留的名称是固定的时，每次你更改公共IP地址时，相关联的IP地址也会变化。为了演示，我们将使用
    [noip.com](https://www.noip.com/)。它提供了免费的动态DNS服务。因此，我之前已经保留了一个名为 `pythonhussam.ddns.net`
    的名称。所以，在目标端，我们不再在脚本中硬编码IP地址，而是对这个名称进行DNS查询，然后获取IP地址来建立连接。现在，你可能会问：当攻击者的IP地址发生变化时，如何通过
    [noip.com](https://www.noip.com/) 知道新的IP地址并更新其DNS记录？答案是通过一个软件代理，它应该安装在我们的Kali机器上。该代理会连接到
    [noip.com](https://www.noip.com/) 的服务器，并通知它们我们的新IP地址。
- en: To save time, you can create a free account on [noip.com](https://www.noip.com/).
    It should be quite simple and straightforward. Then, reserve a name of your choice,
    In the next section, we will install **No-IP agent** on our Kali Linux and modify
    the code in our previous TCP reverse shell version to resolve a DNS lookup on
    `pythonhussam.ddns.net`, which will be the reserved name that we will use for
    demonstration purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，你可以在 [noip.com](https://www.noip.com/) 创建一个免费账户。这个过程应该非常简单直接。然后，预定一个你选择的名称，接下来的章节中，我们将会在Kali
    Linux上安装**No-IP代理**，并修改我们之前的TCP反向Shell版本中的代码，以解析`pythonhussam.ddns.net`的DNS查询，这将是我们为演示目的保留的名称。
- en: DNS aware shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持DNS的Shell
- en: 'In this section, we will start by installing the No-IP agent on our Kali Linux
    machine. Ensure that our Kali machine is connected to the internet so that we
    can download and install the agent software:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将从在Kali Linux机器上安装No-IP代理开始。确保我们的Kali机器已连接到互联网，以便下载和安装代理软件：
- en: 'Parse to `/usr/local/src/` by executing:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以解析到 `/usr/local/src/`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Download the agent software:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载代理软件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Extract the file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取文件：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`cd` into the `noip` folder we just extracted:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd` 进入我们刚刚提取的 `noip` 文件夹：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the agent:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装代理：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, at this point, it''ll prompt you to enter your `email` and `password`,
    which you used to register on the [noip.com](http://noip.com) website. So I''ll
    type my email address here. And now we can see that `pythonhussam.ddns.net` is
    already registered to our account, and a new configuration file has been created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，此时，它会提示你输入在 [noip.com](http://noip.com) 网站注册时使用的 `email` 和 `password`。我将在这里输入我的电子邮件地址。现在我们可以看到
    `pythonhussam.ddns.net` 已经注册到我们的账户，并且一个新的配置文件已经创建：
- en: '![](../images/00037.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: 'Now, let''s jump to the target machine. In Python, it''s very simple to do
    a DNS lookup. It''s just a matter of a single line to resolve the IP address,
    and we will do that using either `socket.gethostname` or `socket.gethostbyname`,
    as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到目标机器。在 Python 中，进行 DNS 查询非常简单。只需要一行代码来解析 IP 地址，我们将使用 `socket.gethostname`
    或 `socket.gethostbyname` 来完成，如下代码所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we store the result, which is the IP address of the attacker machine,
    in a variable called `ip`. For now, we will just comment the `connect(ip)` function
    and print out the result, just to make sure that our script is working fine here.
    So we''ll run the module, and it says the IP address is `37.202.101`, as shown
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将结果存储在一个名为 `ip` 的变量中，它是攻击者机器的 IP 地址。现在，我们只需注释掉 `connect(ip)` 函数，并打印出结果，以确保我们的脚本在这里运行正常。所以我们将运行该模块，它会显示
    IP 地址为 `37.202.101`，如下所示：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's go back to the attacker machine and verify our public IP address by searching
    `what is my ip address` in Google. If everything goes well we will see the same
    address that the target identified as the updated public IP address of the attacker
    machine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到攻击者机器，并通过在 Google 上搜索 `what is my ip address` 来验证我们的公网 IP 地址。如果一切顺利，我们将看到目标机器识别出的与攻击者机器的更新公网
    IP 地址相同的地址。
- en: So since the IP variable stores our attacker IP, we will pass this value into
    the connect function and use this value to connect back to the attacker machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，由于 IP 变量存储了我们攻击者的 IP 地址，我们将这个值传递到连接函数中，并使用这个值连接回攻击者的机器。
- en: Note that we have replaced the static IP address in `s.connect((ip, 8080))` 
    with a variable called `ip`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经用一个名为 `ip` 的变量替换了 `s.connect((ip, 8080))` 中的静态 IP 地址。
- en: Interacting with Twitter
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Twitter 互动
- en: 'Now, we will discuss a technique that is used frequently these days: relying
    on well-known servers to perform certain tasks or transfer a piece of information.
    This technique has been used by a Russian malware. What the attackers did was
    they sent the data over their Twitter account and made the target parse it later
    on. So, on the attacker machine, we just send an order or command as a normal
    tweet to our Twitter account. Note that there is no direct communication between
    the attacker and its target, which is really evil here. Later on, the target will
    parse the tweet and execute that order. The benefits of doing this is are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论一种当前常用的技术：依赖于知名服务器来执行某些任务或传输信息。俄罗斯的恶意软件使用了这种技术。攻击者的做法是，他们通过自己的 Twitter
    账户发送数据，并让目标在稍后解析它。所以，在攻击者的机器上，我们只是发送一个正常的推文作为命令到我们的 Twitter 账户。注意，攻击者与目标之间没有直接的通信，这正是其中的邪恶之处。稍后，目标将解析推文并执行该命令。这样做的好处有：
- en: Twitter is a trusted website and it has a very good reputation; most likely,
    it's a whitelisted website
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter 是一个受信任的网站，且具有很高的声誉；很可能它是一个白名单网站。
- en: This type of attack is very hard to detect, where an unskilled security team
    would never have thought that this data could be malicious—and one of my goals
    here is to open your eyes to such malicious attacks
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型的攻击非常难以检测，一个缺乏经验的安全团队绝对不会想到这些数据可能是恶意的——而我在这里的目标之一就是让你对这种恶意攻击有警觉。
- en: In the next section, from the Kali machine we will send `hello` from the Python
    string as a normal tweet to our account. On the client side, we will parse the
    tweet, then we will print out the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将从 Kali 机器向我们的账户发送一个普通的 `hello` 字符串作为推文。在客户端，我们将解析这条推文，然后打印出结果。
- en: Now, technically speaking, anybody can view your tweet without even logging
    into Twitter. I recommend you read the FireEye report to see how attackers took
    advantage of this situation, [https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html](https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从技术角度讲，任何人都可以在不登录 Twitter 的情况下查看你的推文。我建议你阅读 FireEye 的报告，看看攻击者是如何利用这种情况的，[https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html](https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html)。
- en: Believe it or not, in five lines of Python script, you will connect to the attacker
    page over HTTPS retrieve the HTML and parse it and finally extract the data from
    the tweet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，在五行 Python 脚本中，你将通过 HTTPS 连接到攻击者页面，检索 HTML 内容并解析它，最后从推文中提取数据。
- en: Parsing a tweet in three lines
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用三行代码解析推文
- en: For this demonstration, I created an account on Twitter. My profile name is
    `@HussamKhrais`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我在 Twitter 上创建了一个账户。我的个人资料名称是 `@HussamKhrais`。
- en: 'So, I will log into my Twitter account from the Kali machine and send a tweet,
    and we will see how easy it is to grab that tweet from the target machine. So
    let''s get started by first composing a new tweet (for example `Hello from kali
    python`) and log out from the account. Let''s now have a quick look at the HTML
    page that gets created after posting the tweet, by viewing the page source. Search
    and find the the tweet we just made. Then, if we scroll to the left a little bit,
    notice the HTML meta tag parameters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我将从 Kali 机器登录到我的 Twitter 账户并发送一条推文，我们将看看从目标机器获取这条推文有多么简单。首先，让我们开始创建一条新推文（例如`Hello
    from kali python`），然后从账户中登出。现在，让我们快速看一下在发布推文后创建的 HTML 页面，通过查看页面源代码。搜索并找到我们刚刚发布的推文。然后，如果我们稍微向左滚动一点，注意到
    HTML meta 标签参数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter, `name`, has `description` as a value,  and the second parameter
    called `content` contains our tweet. Now, we'll use these HTML tags to parse the
    HTML and extract the tweet eventually.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`name`的值是`description`，第二个参数`content`包含了我们的推文。现在，我们将使用这些 HTML 标签来解析 HTML，并最终提取推文。
- en: Python has a library called Beautiful Soup, which is a very well-known tool
    used to parse HTML pages. You can download it from: [https://pypi.python.org/pypi/BeautifulSoup/](https://pypi.python.org/pypi/BeautifulSoup/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个叫做 Beautiful Soup 的库，这是一个非常著名的工具，用于解析 HTML 页面。你可以从以下地址下载：[https://pypi.python.org/pypi/BeautifulSoup/](https://pypi.python.org/pypi/BeautifulSoup/)。
- en: To install this library, just navigate to the directory where Beautiful Soup
    exists, then run `python setup.py` and install it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这个库，只需导航到 Beautiful Soup 所在的目录，然后运行`python setup.py`并进行安装。
- en: 'Let''s have a quick look at the code, which we will use on the target side:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下代码，这是我们将在目标端使用的：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So using `urllib` or the URL library, we'll browse to my Twitter home page.
    And once we retrieve the HTML page, we'll store it on the `html` variable. Then,
    we pass the HTML page or a variable to the `soupy` function.  Remember the HTML
    meta tag that contains our tweet? We will look for it using the `find` function
    in Beautiful Soup. So, we will look for a `meta name` and a value of `description`. Using
    a regular expression, we will do a final filter to print only the exact string
    between the quotation mark, which is basically the tweet that we sent. On running
    the script you will see that we got back the same tweet that we sent.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，使用`urllib`或者 URL 库，我们将浏览到我的 Twitter 主页。一旦我们获取到 HTML 页面，就会把它存储到`html`变量中。然后，我们将
    HTML 页面或变量传递给`soupy`函数。记得包含我们推文的 HTML meta 标签吗？我们将使用 Beautiful Soup 的`find`函数查找它。所以，我们将寻找一个`meta
    name`和`description`的值。使用正则表达式，我们将进行最后的筛选，仅打印出引号之间的精确字符串，这基本上就是我们发送的推文。运行脚本时，你会看到我们返回了发送的相同推文。
- en: So, we will clean the code a little bit by removing the `print x` command. We
    will log into the Twitter account one more time and send another tweet. This time,
    we will tweet `We made it`. So, on the target side, we should be able to view
    the latest tweet on running the script.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将稍微清理一下代码，删除`print x`命令。我们将再次登录 Twitter 账户，并发送另一条推文。这一次，我们将推文内容设为`We made
    it`。所以，在目标端，运行脚本时，我们应该能够看到最新的推文。
- en: Keep in mind that we were able to get the tweet without any login or authentication.
    Now, in the next section, you will see how you could use this information or script
    in a real-world scenario.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们能够在没有任何登录或身份验证的情况下获取到推文。接下来的部分，你将看到如何在实际场景中使用这个信息或脚本。
- en: Countermeasures
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对策
- en: 'In this section, we''ll discuss possible countermeasures for malware that is
    designed to interact with Twitter. Now, notice that I said a possible countermeasure,
    because this is not an easy job to do; and that''s because of one of the following
    reasons:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论针对与 Twitter 交互的恶意软件可能采取的对策。现在，请注意我说的是可能的对策，因为这并不是一件容易的事；这是因为以下原因之一：
- en: Blocking Twitter
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止 Twitter
- en: Terminating SSL
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止 SSL
- en: 'The first thing that may come to your mind is to simply block Twitter, and
    this will definitely prevent the attack. However, what if you work for a social
    marketing company or your daily job involves the use of Twitter? Then in this
    case, it''s not an option. Also, it''s not only limited to Twitter. Imagine that
    the target downloads an image from Instagram, and then, using stenography, the
    target parses a hidden text or hidden command within that image. The second point
    you might think about is, we have seen that the Twitter home page is using HTTPS,
    where the traffic is encrypted. And you might think that we can simply terminate
    the SSL and see the traffic in clear text. So let''s assume that we have such
    a device for decryption, and we can see the tweet as clear text and the transit
    path. But the question is: What resources do we need to check each single packet
    going back and forth from our network to Twitter, as it could be 100 MB of data?
    Also, how we can distinguish between the good and the bad one?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先想到的可能是简单地封锁Twitter，这肯定能阻止攻击。然而，如果你为一家社交营销公司工作，或者你的日常工作涉及使用Twitter，那这种做法就不可行了。并且，问题不仅仅限于Twitter。假设目标从Instagram下载了一张图片，然后，利用隐写术，目标解析出图片中的隐藏文本或命令。你可能会想到的第二点是，我们已经看到Twitter主页使用HTTPS，流量是加密的。你可能会认为，我们可以简单地终止SSL并查看明文流量。那么，假设我们有一个解密设备，能够看到明文的推文和传输路径。问题是：我们需要哪些资源来检查从我们网络到Twitter之间的每一个数据包？因为可能会有100MB的数据流量。而且，如何区分哪些是好的，哪些是坏的呢？
- en: 'So let''s say that we have a tweet saying, `Follow this website`. So how can
    we tell that this is a malicious or innocent site, without actively inspecting
    that website? And overall, this will be a bigger headache in our process. Another
    point to consider here is: What if the tweet itself was encrypted? So, instead
    of seeing hello world or `ipconfig`, the attacker could encrypt this tweet in
    AES and send it to Twitter, and decrypt it back once it reaches the target side.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一条推文写着，`Follow this website`。那么，如何在不主动检查该网站的情况下判断它是恶意网站还是无害网站呢？总的来说，这将是我们流程中的一个更大头疼的问题。这里还有一个需要考虑的点是：如果推文本身被加密了呢？所以，攻击者可能将这条推文加密为AES，并发送到Twitter，待它到达目标方后再解密回来，而不是看到"hello
    world"或者`ipconfig`。
- en: Also, what the attacker can do is mislead anyone watching the traffic. He can
    make the malware parse hundreds of Twitter pages in addition to the hacker page,
    and this leads us back into the resource issue which we discussed. Last but not
    least, the attacker can tweet another IP to create a chain of connections. If
    you read the report from FireEye on how the Russian malware works, then you will
    see that the attackers tweeted a link for an image located on GitHub. So, the
    victim initiated a new session to GitHub, and that's what's called a **chained
    connection**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，攻击者还可以通过误导观察流量的任何人来进行攻击。他可以让恶意软件解析数百个Twitter页面，除了黑客页面之外，这会让我们重新回到之前讨论的资源问题。最后但同样重要的是，攻击者可以发布另一个IP地址的推文，以创建一条连接链。如果你阅读FireEye关于俄罗斯恶意软件如何工作的报告，你会发现攻击者发布了一个指向GitHub上图像的链接。因此，受害者启动了一个新的GitHub会话，这就是所谓的**链式连接**。
- en: So if we think again about how we get infected with this malware, it will tell
    us that the same countermeasures we discussed in the previous chapter are still
    valid in our current scenario.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们再次考虑如何感染这种恶意软件，这将告诉我们，在当前情景中，前一章中讨论的相同对策依然有效。
- en: Replicating Metasploit's screen capturing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制Metasploit的屏幕截图功能
- en: In this section, we will automate capturing a screenshot from the target machine
    and retrieve it over HTTP reverse shell. Getting a screenshot from the target
    `Desktop` can be useful to see what programs and activities are going on on the
    target side. In Metasploit Meterpreter, there is a function called **`screengrab()`**,
    which will take a snapshot from the target machine and transfer it back to the
    attacker machine. So here, we will do something similar in our existing HTTP shell.
    For this purpose, we will be using a library called `Pillow` at the target. This
    is a high-level image library in Python. The installation is quite simple. You
    just need to run `pip install Pillow` via `cmd`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将自动化捕获目标机器的屏幕截图并通过HTTP反向Shell获取它。从目标`桌面`获取屏幕截图可以帮助我们查看目标端正在进行的程序和活动。在Metasploit
    Meterpreter中，有一个名为**`screengrab()`**的功能，它将从目标机器拍摄快照并将其传回攻击者的机器。所以在这里，我们将在现有的HTTP
    shell中做类似的操作。为此，我们将在目标机器上使用一个名为`Pillow`的库。这是一个Python的高级图像处理库。安装过程非常简单，你只需要通过`cmd`运行`pip
    install Pillow`即可。
- en: Before doing that, just make sure that you have internet access. Once we install
    this library, I will go to Devices|Network|Network Settings... in VirtualBox, and
    change the network mode back to Internal Network as we did in the previous chapter. We
    will also give our target the static IP address so that we can reach out to the
    attacker machine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，请确保你有互联网连接。安装完这个库后，我将进入VirtualBox中的“设备|网络|网络设置...”，并像上一章中一样将网络模式改回内部网络。我们还将为目标分配静态IP地址，以便能够连接到攻击者机器。
- en: Make sure that we got a connection with our attacker by pinging its IP address
    .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们通过ping攻击者的IP地址与其建立了连接。
- en: 'In our HTTP code, we start by importing our library. So we import the `ImageGrab()`
    function and we need to add a new `if` statement saying that, if we received a
    `screencap` keyword, then we will take a snapshot and save it to the current working
    directory with the name `img.jpg`. Then, we will transfer it back to the attacker
    machine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTTP代码中，我们首先导入库。所以我们导入`ImageGrab()`函数，并需要添加一个新的`if`语句，表示如果收到`screencap`关键字，那么我们将拍摄快照并将其保存到当前工作目录，文件名为`img.jpg`。然后，我们会将其传输回攻击者机器：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's now try and test the script. Ensure the HTTP Data Exfiltration Server
    script is running at the attacker end. Once we get the `Shell>` run `screencap` at
    the attacker go to the `Desktop` and change the file extension to `.jpeg` so that
    we will be able to view the screenshot. If we go to the target machine, you will
    see that our `screencap` image is saved on the same current working directory
    as our script.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试测试脚本。确保HTTP数据泄露服务器脚本在攻击者端运行。一旦我们看到`Shell>`，在攻击者端运行`screencap`，然后进入`桌面`，将文件扩展名更改为`.jpeg`，这样我们就能查看截图。如果我们去到目标机器，你会看到我们的`screencap`图像保存在与脚本相同的当前工作目录中。
- en: Now, the problem with this is that it's very obvious that someone is doing some
    malicious activity on our PC. Even if we remove the image after doing the transfer,
    there is still a chance that the target could catch us. Now, to overcome this,
    we will use the OS's `temp` directory to create a temporary directory and save
    the image over there. And once the transfer is completed, we will remove the entire
    directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题在于，这非常明显，表明有人在我们的PC上进行恶意活动。即使在传输完成后我们删除了图像，目标仍有可能发现我们。为了克服这一点，我们将使用操作系统的`temp`目录来创建一个临时目录，并将图像保存在其中。一旦传输完成，我们将删除整个目录。
- en: Python has a built-in library that uses the operating system's temporary directory.
    Let's have a quick look. We will go to Command Prompt and open a Python interactive
    mode and run `import tempfile`. This `tempfile` will handle the task of creating
    a `temporary` directory. But before creating one, open the Windows `temp` directory.
    Run `print tempfile.mkdtemp`, which will make a temporary directory for us and
    print out all the directory names. Now, to get rid of this temporary directory,
    we will use another library called `shutil`. We will `import` this one and we
    will create a new temporary directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内置库，使用操作系统的临时目录。让我们快速看一下。我们将进入命令提示符并打开Python交互模式，运行`import tempfile`。这个`tempfile`将处理创建`temporary`目录的任务。但在创建之前，先打开Windows的`temp`目录。运行`print
    tempfile.mkdtemp`，这将为我们创建一个临时目录并打印出所有目录名称。现在，为了删除这个临时目录，我们将使用另一个名为`shutil`的库。我们将导入它，并创建一个新的临时目录。
- en: 'Notice that, once we do this, a new folder is created in the `temp` directory.
    Now, we will remove it by running `shutil.rmtree(x)` since the variable `x` contains
    the name of that `temp` folder:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦我们执行此操作，将会在`temp`目录下创建一个新文件夹。现在，我们将通过运行`shutil.rmtree(x)`来删除它，因为变量`x`包含该`temp`文件夹的名称：
- en: '![](../images/00038.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: 'To reflect these changes in our script, we will just go back and edit our target
    script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在脚本中反映这些更改，我们将返回并编辑目标脚本：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we'll create a `temp` directory and store its path in the `dirpath` variable.
    Then, we will tell`ImageGrab` to save the `screencap` in the newly created `temp`
    directory. Also we'll modify the save directory. We will also need to reflect
    this change to the file transfer function, so it knows the new path for the image
    file. The last thing is, once the transfer gets completed, we have to make sure
    that the file gets closed since we cannot remove a file that is currently opened
    by an application or a process. We will delete the whole directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`temp`目录，并将其路径存储在`dirpath`变量中。接下来，我们将告诉`ImageGrab`将`screencap`保存在新创建的`temp`目录中。同时，我们还会修改保存目录。我们还需要将这个更改反映到文件传输函数中，这样它才能知道图像文件的新路径。最后，一旦传输完成，我们必须确保文件被关闭，因为我们不能删除当前正在被应用程序或进程打开的文件。我们将删除整个目录。
- en: Give it a try, and verify that we didn't leave any track behind. Try a filter
    on `img` inside the `temp` directory, which is the filename or the image name,
    and we will see if anything shows up by running the script as we did before. Once
    we get the `Shell>` at the attacker machine run a `screencap`. Once you get the
    screenshot on the attacker rename it, jump to the target side, and see if any
    file has been created. You will see that there is nothing there because we removed
    the `temp` directory after we did the transfer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，确保没有留下任何痕迹。在`temp`目录中对`img`进行过滤，`img`是文件名或图像名称，然后像之前那样运行脚本，看看是否会有任何东西显示出来。一旦我们在攻击者机器上获得了`Shell>`，就运行`screencap`。当你在攻击者端截图后重命名，跳到目标端，看看是否有任何文件被创建。你会发现那儿什么也没有，因为我们在完成传输后删除了`temp`目录。
- en: Replicating Metasploit searching for content
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制 Metasploit 搜索内容
- en: 'We will now code a Python function that will search into target directories
    and provide us with a list of file locations for a certain specific file extension.
    For instance, say we need to search for a PDF or document file on the target machine;
    instead of checking each directory, we will add a new function to automatically
    do the job for us. This is very useful when you first land in a target machine
    and try to explore as much data as possible such as documents, PDF files, and
    so on. The coding part is quite easy. We will use the Python `os` library to do
    the job for us. So, as usual, I have added a new `if` statement to specify that
    if we get a `search` keyword we will do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个 Python 函数，它会在目标目录中搜索，并提供特定文件扩展名的文件位置列表。例如，假设我们需要在目标机器上搜索 PDF 或文档文件；我们不需要检查每个目录，而是将添加一个新函数来自动完成这个任务。这在你首次进入目标机器并尽可能多地探索数据（如文档、PDF
    文件等）时非常有用。编写代码部分相当简单。我们将使用 Python 的`os`库来完成这个任务。所以，像往常一样，我添加了一个新的`if`语句来指定，如果我们获取到`search`关键字，我们将执行以下操作：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So first, we define the format as `search C:\\*.pdf` . Note that we are only
    interested in the second part, which is the directory that we want to search and
    the file extension. Right now, to clean the `received` command and to split it
    into parameters, we will have to cut off the first leading seven characters; and
    we will do so to get rid of the unwanted search string and space. Now, if we count
    the first seven characters, it will be up to the `C` directory here; the output
    after doing that, will be much cleaner. Next, we split the string into path and
    file extensions, and we store them in path and extension variables. So the first
    parameter will be the `path`, which will be stored in the path variable, and the
    second one will be stored in the extension variable. Next, we define a list variable,
    and this one will be our placeholder to store the file directories. Now, the actual
    function that will do the search for us is the `os.walk(path)` function. This
    function will navigate all the directories specified in the provided `path` directory,
    and return three values: the `dirpath`, which is a string that contains the path
    to the directory; the `dirname` , which is a list of the names for the sub directories
    in the `dirpath`; and  finally `files`, which is a list of filenames in `dirpath`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，我们将格式定义为`search C:\\*.pdf`。请注意，我们只关注第二部分，也就是我们要搜索的目录和文件扩展名。现在，为了清理`received`命令并将其拆分为参数，我们需要去掉前面七个字符；这样做是为了去掉不需要的搜索字符串和空格。现在，如果我们数一数前面七个字符，它将会包括`C`目录；完成这个操作后，输出会干净许多。接下来，我们将字符串拆分为路径和文件扩展名，并将它们存储在路径和扩展名变量中。所以第一个参数将是`path`，它将存储在路径变量中，第二个将存储在扩展名变量中。接下来，我们定义一个列表变量，这将是我们用来存储文件目录的占位符。现在，实际执行搜索的函数是`os.walk(path)`函数。这个函数将遍历提供的`path`目录中所有指定的目录，并返回三个值：`dirpath`，它是包含目录路径的字符串；`dirname`，它是`dirpath`中子目录名称的列表；最后是`files`，它是`dirpath`中所有文件名的列表。
- en: Next, we perform another loop to check each file in the `files` list. If the
    files end with our desired extension, such as `.pdf`, then we add the directory
    value into the list string. In the end, the `os.path.join()` function represents
    a path relative to our file to the current directory, and in our case, it's the
    `C:\` directory. Finally, we'll post the result back to the attacker side.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行另一个循环，检查`files`列表中的每个文件。如果文件的扩展名是我们想要的扩展名，例如`.pdf`，那么我们就将该目录值加入到列表字符串中。最终，`os.path.join()`函数表示相对于当前目录的文件路径，在我们的例子中是`C:\`目录。最后，我们将结果发送回攻击者端。
- en: 'On running the script on both sides, as a start let''s search for every PDF
    file in the `C:\` directory by running:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本时，作为开始，让我们通过运行以下命令搜索`C:\`目录中的所有PDF文件：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this let''s try to grab `Documents\Module 3.pdf`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试抓取`Documents\Module 3.pdf`：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also search for each text file in the system. It should be a huge list:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以搜索系统中的每个文本文件。应该会有一大堆文件：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can narrow down our search, and just do a search for the `Desktop` directory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以缩小搜索范围，仅在`Desktop`目录中进行搜索。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And we have a file there called `passwords.txt`. Try to grab that one, and verify
    its content as we did in the previous chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在那儿有一个叫做`passwords.txt`的文件。尝试抓取它，并像在上一章一样验证它的内容。
- en: Target directory navigation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标目录导航
- en: We will now address a directory navigation issue. Now, the problem is that browsing
    directories is restricted to the shell working directories. For instance, if the
    target has executed our Python script on the `Desktop`, then our working directory
    will be the `Desktop`. And due to shell limitations, we cannot simply type `cd`
    and move on to another directory. Remember we learned that some commands won't
    work in a shell, and `cd` is one of them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解决一个目录导航问题。现在，问题是浏览目录受到shell工作目录的限制。例如，如果目标已经在`Desktop`执行了我们的Python脚本，那么我们的工作目录就会是`Desktop`。由于shell的限制，我们不能简单地输入`cd`命令并切换到另一个目录。记住，我们学到的一些命令在shell中无法执行，`cd`就是其中之一。
- en: Once we run our previous TCP reverse shell on both sides, you will see our current
    working directory is on the `Desktop`, where our Python exists. Notice what will
    happen when a `cd` command is issued to change the current working directory to
    `C:\Users`. Our script will become non-responsive once we try the `cd C:\Users`
    command, and this is because the shell fails to handle the `cd` command properly.
    Now, to overcome this problem, we need to explicitly tell the script to change
    its working directory. Again, that's because our shell working directory is restricted
    to the working directory of our Python script.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在两端运行之前的TCP反向Shell，你会看到我们当前的工作目录是在 `Desktop`，也就是我们的Python脚本所在的地方。注意，当执行
    `cd` 命令来更改当前工作目录到 `C:\Users` 时会发生什么。我们的脚本在尝试执行 `cd C:\Users` 命令时会变得没有响应，这是因为Shell未能正确处理
    `cd` 命令。现在，为了解决这个问题，我们需要明确地告诉脚本改变它的工作目录。再次强调，这是因为我们的Shell工作目录被限制在Python脚本的工作目录中。
- en: 'The formula here will be `cd` followed by space, then the path that we want
    to go to. Then, we will split up the received command based on the space into
    two variables. Thankfully, changing the directory is a matter of a single line
    in Python. Finally, we send back a string mentioning the new current working directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的公式是 `cd` 后跟空格，然后是我们想要进入的路径。接下来，我们将基于空格将接收到的命令拆分成两个变量。幸运的是，改变目录在Python中只需一行代码。最后，我们返回一个字符串，表示当前的工作目录：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we try the previous script, after typing `cd C:\Users`, you will be able
    to see whether we have changed or moved to the `Users` directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们尝试了之前的脚本，在输入 `cd C:\Users` 后，你将能够看到我们是否已更改或移动到 `Users` 目录：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try navigating to the location of the file that you want to `grab`. You will
    notice that, once we are on the same directory as the file we want to `grab`,
    then we don''t need to specify the absolute path anymore. We can simply grab the
    file by specifying just the filename, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试导航到你想要 `grab` 的文件位置。你会注意到，一旦我们在与目标文件相同的目录中，我们就不再需要指定绝对路径。我们可以通过仅指定文件名来直接抓取文件，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will get us the file on the Kali machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够获取Kali机器上的文件。
- en: Integrating low-level port scanner
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成低级端口扫描器
- en: During penetration testing, sometimes you encounter a scenario where your client
    is using some kind of an internal server that is not accessible through the internet.
    And just because of this they think it's secure. In this section, we will see
    how we can integrate a simple port scanner with our script to prevent a possible
    attack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，有时你会遇到这样的场景：你的客户使用某种无法通过互联网访问的内部服务器。仅仅因为这个原因，他们认为这个服务器是安全的。在这一部分，我们将看到如何将一个简单的端口扫描器与我们的脚本集成，以防止可能的攻击。
- en: 'Usually, once you get into your target machine, you start looking for other
    possible targets. For example, if we were able to access machine A, then we can
    extend our attack and scan machine B to see what ports and services are running
    on that machine. The other usages are to make the target scan an online server
    on our behalf to hide our activities. Now, let''s get to the coding part. We will
    build a basic low-level scanner. It''s named low-level because we will use the
    built-in socket library and then build on it. The formula or the format for sending
    scan requests is `scan` followed by a space, then the IP address followed by a
    colon, and then the port list, for example `scan 10.0.2.15:22,80` :'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦你进入目标机器，你会开始寻找其他可能的目标。例如，如果我们能够访问机器A，那么我们可以扩展攻击，扫描机器B，查看该机器上正在运行的端口和服务。其他用途是让目标代表我们扫描在线服务器，以隐藏我们的活动。现在，让我们进入编码部分。我们将构建一个基本的低级扫描器。之所以称之为低级，是因为我们将使用内置的socket库，然后在此基础上进行扩展。发送扫描请求的公式或格式是
    `scan` 后跟一个空格，然后是IP地址，接着是冒号，再然后是端口列表，例如 `scan 10.0.2.15:22,80`：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, the first thing to do is to cut off the leading first character, so this
    part will be removed. After that, we will split the right part into two sections.
    The first section is the IP address that we want to scan, and we will store it
    in the `ip` variable. The second section is the list of ports for which we want
    to check the access status, and it will be saved in the `ports` variable. To keep
    the coding clean, an entire function called scanner is there to do our stuff.
    So, we will pass the `socket` object, the `ip`, and the `ports` variables to this
    function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先要做的是去掉第一个字符，所以这部分内容将被移除。然后，我们将把右边的部分分为两部分。第一部分是我们要扫描的IP地址，并将其存储在`ip`变量中。第二部分是我们要检查访问状态的端口列表，这将保存在`ports`变量中。为了保持代码简洁，我们创建了一个名为scanner的函数来处理这些事情。所以，我们将`socket`对象、`ip`和`ports`变量传递给这个函数。
- en: Once we get these variables, we will define `scan_result` as a variable, which
    stores our scanning result. Now, remember that the ports are separated by a comma,
    like this: `21, 22, 80, 443, 445`, for example. So what we will do is, we will
    loop over each one of these ports and try to make a connection using a `socket` library
    for each one of them. Notice that I have used the `connect_ex()` function, where
    the function returns `0` if the operation succeeds. And, in our case, the operation
    succeeded, which means that the connection happens and that the port is open.
    Otherwise, the port would be closed or the host would be unreachable in the first
    place. In the end, we will close the socket and repeat the whole process until
    the last port in our list here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到这些变量，我们将定义`scan_result`作为一个变量，用来存储我们的扫描结果。现在，请记住，端口是用逗号分隔的，例如：`21, 22,
    80, 443, 445`。所以我们要做的是，遍历这些端口并尝试通过`socket`库与每个端口建立连接。请注意，我使用了`connect_ex()`函数，当操作成功时，该函数会返回`0`。在我们的案例中，操作成功了，这意味着连接已经建立，并且端口是开放的。否则，端口将是关闭的，或者主机根本无法访问。最后，我们将关闭套接字并重复整个过程，直到最后一个端口。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So we'll go for port `22` until we reach the last one. The result of our scan
    will be stored in `scan_result`, and the `+` sign is used to append the result.
    Finally, we send back the result to our Kali machine. Since our Kali machine and
    the target are on the same virtual subnet here, we should appear on the target
    `arp` table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将从端口`22`开始，直到达到最后一个端口。我们的扫描结果将存储在`scan_result`中，`+`符号用于追加结果。最后，我们将结果发送回我们的Kali机器。由于我们的Kali机器和目标在同一个虚拟子网中，我们应该出现在目标的`arp`表中。
- en: 'Lets proceed to the rest of the code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看其余的代码：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On running our scripts on both sides, we will do an `arp -a` and this will
    give the IP address of our Kali machine: `10.0.2.15`. So, as a proof of concept,
    we can scan our Kali machine from the target side and run Wireshark to confirm
    the scanning:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在两边运行我们的脚本时，我们会执行`arp -a`，这将显示我们Kali机器的IP地址：`10.0.2.15`。所以，作为概念验证，我们可以从目标端扫描我们的Kali机器，并运行Wireshark来确认扫描过程：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we run Wireshark and filter on TCP, we can see that the TCP session comes
    over. In the scan result, we can see that port `8080` is opened and all others
    are closed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行Wireshark并过滤TCP流量，我们可以看到TCP会话的传输。在扫描结果中，我们可以看到端口`8080`是打开的，而其他端口都关闭：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can check the completed three-way handshake for TCP on port `8080`. We can
    see the `[SYN]`, `[SYN, ACK]`, then `[ACK]` that complete the three-way handshake;
    and we can see that the target, after completing the three-way handshake, sends
    a `[FIN]` request to close the socket here because we opted to close the socket
    after scanning. If you still remember, in the code here we said `sock.close()`.
    So `[FIN]` acts as an indicator to close the socket.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查端口`8080`上的TCP三次握手过程。我们可以看到`[SYN]`、`[SYN, ACK]`，然后是`[ACK]`，这完成了三次握手；并且我们可以看到，目标在完成三次握手后，发送了一个`[FIN]`请求来关闭套接字，因为我们选择在扫描后关闭套接字。如果你还记得，在这里的代码中我们写了`sock.close()`。所以，`[FIN]`作为关闭套接字的指示符。
- en: 'Now to double-check, we can open a terminal to see what process is using port
    `8080`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了再三确认，我们可以打开终端查看哪个进程正在使用端口`8080`：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will see that it's opened by another Python script. But if we do the same
    for port `21`, we will get nothing since the port is closed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到它是被另一个Python脚本打开的。但是如果我们对端口`21`做同样的操作，我们什么也得不到，因为该端口是关闭的。
- en: 'Let''s do another test: we will use a `netcat` to open port `21`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 做另一个测试：我们将使用`netcat`打开端口`21`：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, I will do the scan again to see whether the result is going to change.
    Right now, we are listening on port `21` since it's opened.  So if we go back
    to our shell, and then repeat the same scan; if it's working, we should see port
    `21` open.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我会再次进行扫描，看看结果是否会发生变化。现在，我们正在监听`21`端口，因为它已经开放。所以，如果我们回到我们的 shell，再次重复相同的扫描；如果它有效，我们应该看到`21`端口是开放的。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about DDNS and the DDNS-aware shell. We also learned
    how to interact with Twitter, and replicate Metasploit's screen capturing, and
    we searched for the content and looked into target directory navigation. Last,
    we saw how to integrate a low-level port scanner.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们学习了DDNS和支持DDNS的 shell。我们还学习了如何与 Twitter 进行交互，如何复制 Metasploit 的屏幕捕获功能，以及如何搜索内容并查看目标目录导航。最后，我们看到如何集成一个低级端口扫描器。
- en: In the next chapter, we will learn about password hacking.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习密码破解。
