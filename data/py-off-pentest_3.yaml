- en: Password Hacking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码破解
- en: Most hackers assume that their target is running a legacy unpatched Windows
    XP, where the antivirus is disabled, the firewall is turned off, and the IPS may
    not be in place. After all, you may or may not hack into their systems. This is
    definitely not real-world penetration testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数黑客认为他们的目标在运行过时且没有打补丁的 Windows XP，在这种系统上，防病毒软件已禁用，防火墙已关闭，可能也没有入侵防御系统。毕竟，你可能成功入侵他们的系统，也可能没有。这绝对不是现实世界中的渗透测试。
- en: 'In this chapter, we will deal with the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理以下主题：
- en: Antivirus free keylogger
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无病毒的键盘记录器
- en: Man in the browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中的人
- en: Firefox API hooking with Immunity Debugger
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Immunity Debugger 对 Firefox 进行 API 钩取
- en: Python in Firefox **proof of concept** (**POC**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 中的 Python **概念验证**（**POC**）
- en: Python in Firefox EXE
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 中的 Python EXE
- en: Password phishing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码钓鱼
- en: Countermeasures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对措施
- en: Antivirus free keylogger
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无病毒的键盘记录器
- en: In this section, we will code a simple software keylogger, purely in Python.
    To do so, we will be using a library called `pyHook`. The `pyHook` library wraps
    the low-level mouse and keyboard hooks in Windows. As per the `pyHook` documentation,
    any application that wishes to receive notification from a global input event
    must have a Windows message pump. For this, we need another library, called `pywin`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个简单的软件键盘记录器，完全使用 Python 来实现。为此，我们将使用一个名为`pyHook`的库。`pyHook`库封装了 Windows
    中的低级鼠标和键盘钩子。根据`pyHook`文档，任何希望接收全局输入事件通知的应用程序都必须有一个 Windows 消息泵。为此，我们还需要另一个名为`pywin`的库。
- en: So, let's start by installing these libraries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始安装这些库吧。
- en: Installing pyHook and pywin
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 pyHook 和 pywin
- en: You can download the `pyHook` library from [http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/](http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/)
    and install it easily following the on-screen instructions.[ ](http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/](http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/)下载`pyHook`库，并按照屏幕上的指示轻松安装。
- en: Make sure that you do not have another Python instance running in the background
    or you will get an error during installation.The `pywin` library can also be installed
    in the same manner. You can download the library from [https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确保后台没有运行其他 Python 实例，否则在安装过程中会遇到错误。`pywin`库也可以以相同的方式安装。你可以从[https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/)下载该库。
- en: Adding code to keylogger
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向键盘记录器添加代码
- en: 'The following is the script for keylogger:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是键盘记录器的脚本：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look into the steps in the script:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看脚本中的步骤：
- en: Import the `pyHook` and `pythoncom` libraries, as shown in the previous script, `import
    pythoncom, pyHook`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pyHook`和`pythoncom`库，如前面的脚本所示，`import pythoncom, pyHook`。
- en: The `pyHook` library will handle low-level communication with a Windows function
    called `SetWindowsHookExA`. This function will install a hook for us to monitor
    the keyboard event.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyHook`库将处理与 Windows 函数`SetWindowsHookExA`的低级通信。此函数将为我们安装一个钩子，以监控键盘事件。'
- en: Import the `pythoncom` library, which will do the Windows message pumping for
    us.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pythoncom`库，它将为我们处理 Windows 消息泵。
- en: Define a string `store`. This is where we will store all of the pressed keys.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个字符串`store`，这是我们将存储所有按下的键的地方。
- en: Create and register a `HookManager`. Once the user hits any keyboard button,
    the `keypressed()` function will be executed, and that action will be stored in
    the event.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并注册一个`HookManager`。一旦用户按下任意键，`keypressed()`函数将被执行，且该操作将被存储在事件中。
- en: Start the hooking loop and pump out the messages.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动钩子循环并提取消息。
- en: Keep in mind that, as per the `pyHook` documentation, we must have a Windows
    message pump here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据`pyHook`文档，我们必须在这里有一个 Windows 消息泵。
- en: Since the `Enter` and `Back space` buttons are not handled properly. we need
    to statically configure their values.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Enter`和`Backspace`按钮未正确处理，我们需要静态配置它们的值。
- en: Keep in mind that we know whether the user input was *Enter* or *Backspace*,
    based on their ASCII values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们可以通过它们的 ASCII 值来判断用户输入的是*Enter*还是*Backspace*。
- en: Append the ASCII key to the `store` variable, and finally write them in a `keylogs.txt`
    file here. We can append the data and the text file instead of writing over them,
    but it is suggested to use the write technique instead of the append for more
    stability.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ASCII 键值追加到 `store` 变量中，最后将它们写入 `keylogs.txt` 文件。我们可以选择追加数据和文本文件，而不是覆盖它们，但建议使用写入技术而不是追加操作，以确保更高的稳定性。
- en: After intercepting the keyboard event, we need to return a `True` value; otherwise,
    we will simply disable the keyboard functionality.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拦截键盘事件后，我们需要返回一个 `True` 值；否则，我们将禁用键盘功能。
- en: So, let's do a quick test by running the module. We will create a new text file
    just for testing. Lets type into the text Error! Hyperlink reference not valid.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们通过运行该模块做一个快速测试。我们将创建一个新的文本文件来进行测试。输入错误信息：Error! Hyperlink reference not
    valid.
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember to use *Backspace* in between while typing the above lines. Notice
    that we will get our key logs in the `keylogs` file that we created. It will look
    similar to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述内容时，记得在每行之间使用 *Backspace*。请注意，我们将在创建的 `keylogs` 文件中获取到我们的键盘日志。它看起来会像下面这样：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we typed *Backspace*, you can see that we got `BACK SPACE` in keylogs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们按下了 *Backspace*，你可以看到在 keylogs 中记录了 `BACK SPACE`。
- en: Now, terminate the `keylogger` and remove the files `keylogs` and `New Text
    Document`. Copy the name of the file `keylogger` so that we can export it to EXE
    using the setup file for `py2exe`. You can then run the module. The `keylogger`
    EXE will be created. Now, let's do a quick scan of the `.exe` file named `keylogger`
    with AVG antivirus, just to see if we've got a signature for this EXE file. If
    it says No threats detected, run the keylogger in EXE format. Next, log into your
    Facebook account and notice that once we type even a single key on the keyboard,
    we get that on our `keylogs.txt` file. Enter your email address and password to
    open the Facebook page and open the `keylogs.txt` file. You can see your password
    and the email there.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终止 `keylogger` 并删除 `keylogs` 和 `New Text Document` 文件。复制 `keylogger` 文件的名称，以便我们可以通过
    `py2exe` 的安装文件将其导出为 EXE 格式。然后，你可以运行该模块，`keylogger` EXE 文件将会创建。现在，让我们使用 AVG 防病毒软件快速扫描名为
    `keylogger` 的 `.exe` 文件，看看是否有该 EXE 文件的签名。如果显示“未检测到威胁”，则运行该 EXE 格式的键盘记录器。接下来，登录到你的
    Facebook 账户，注意到一旦我们按下键盘上的任意一个键，都会出现在 `keylogs.txt` 文件中。输入你的电子邮件地址和密码打开 Facebook
    页面，并打开 `keylogs.txt` 文件。你可以看到你的密码和电子邮件地址。
- en: Keep in mind that you have to terminate the `keylogger` process manually. Also,
    the `keylogs` file is located on the same directory as our binary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你必须手动终止 `keylogger` 进程。另外，`keylogs` 文件位于与我们的二进制文件相同的目录下。
- en: In the next section, we will see how to enhance our keylogger features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何增强我们的键盘记录器功能。
- en: Hijacking KeePass password manager
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 劫持 KeePass 密码管理器
- en: If you have ever worked with network engineers or system administrators who
    work on multiple devices, then you have probably come across a password manager,
    simply because remembering each password is impossible for them. Usually, they
    use a password manager to securely store device credentials.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经和网络工程师或系统管理员一起工作过，尤其是他们操作多个设备时，那么你很可能接触过密码管理器，因为对他们来说，记住每个密码几乎是不可能的。通常，他们使用密码管理器来安全存储设备凭据。
- en: 'In this section, we will use a very common cross-platform software called KeePass
    and we will see how we can hijack passwords with the help of this software. You
    can download and install the software from [https://keepass.info/download.html](https://keepass.info/download.html).
    After installing:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个非常常见的跨平台软件 KeePass，看看如何借助该软件劫持密码。你可以从 [https://keepass.info/download.html](https://keepass.info/download.html)
    下载并安装该软件。安装后：
- en: Create a `NewDatabase` by clicking on the New icon.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击新建图标来创建一个 `NewDatabase`。
- en: Define Master password and click on OK.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主密码并点击 OK。
- en: Next, click on eMail and create a new account or a new entry for the `gmail`
    account by right-clicking and selecting the Add Entry... option.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 eMail 并通过右键点击选择 “添加条目...” 为 `gmail` 账户创建一个新账户或新条目。
- en: Now, let's create a new entry for the PayPal account. Click on Homebanking,
    then right-click and select the Add Entry... option.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为 PayPal 账户创建一个新条目。点击 Homebanking，然后右键点击并选择 “添加条目...” 选项。
- en: So, let's log in and see whether we can use the password manager for the login.
    Let's go to [https://accounts.google.com](https://accounts.google.com), the login
    page. In the case of password manager, you need to copy and paste the username
    and the password to the login page from the database. Note that in this case the
    keylogger will not work, simply because the passwords are copied into the clipboard
    and it's just a matter of copy and paste without touching the keyboard here.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，让我们登录并看看是否能够使用密码管理器进行登录。我们前往[https://accounts.google.com](https://accounts.google.com)，这是登录页面。对于密码管理器，您需要从数据库中复制并粘贴用户名和密码到登录页面。请注意，在这种情况下，键盘记录器将无法工作，因为密码是复制到剪贴板中的，这只是一个复制和粘贴的过程，不涉及触摸键盘。
- en: For now, log out from your account.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请退出您的账户。
- en: In Python, to interact with a clipboard, you need a library called `pyperclip`,
    which you can download from [https://pypi.python.org/pypi/pyperclip/1.5.11](https://pypi.python.org/pypi/pyperclip/1.5.11).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中，要与剪贴板进行交互，您需要一个名为`pyperclip`的库，您可以从[https://pypi.python.org/pypi/pyperclip/1.5.11](https://pypi.python.org/pypi/pyperclip/1.5.11)下载。
- en: Installing the `pyperclip` library is quite simple. We just need to copy and
    paste the library file into the `site-packages` folder.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`pyperclip`库非常简单。我们只需要将库文件复制并粘贴到`site-packages`文件夹中。
- en: If you experienced some issues while using the setup file, then do it manually.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用安装文件时遇到问题，请手动操作。
- en: The directory is `Python27/Lib`, then `site-packages`. The file is now installed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目录是`Python27/Lib`，然后是`site-packages`。文件现在已安装。
- en: Now, go to the `password manager` folder and open the file to take a look at
    the code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入`password manager`文件夹并打开文件查看代码。
- en: 'We start by importing the libraries:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从导入库开始：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we create a `list`, which will store the clipboard content:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们创建一个`list`，用来存储剪贴板内容：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, we will go into an infinite loop to continuously check the clipboard:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将进入一个无限循环，不断检查剪贴板：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the clipboard content is not empty (here, empty means `None`), then we will
    take its value, and store it in a variable called `value`. To make sure that we
    don't get replicated items in our `list`, before appending the `value` variable
    into our `list`, we will check whether the value is stored in the first place.
    If not, then this means that it is a new item, and we will store it. In the end,
    we will print out our result, or you could save it to a text file. Then, we will
    sleep for `3` seconds, and check the clipboard status again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果剪贴板内容不为空（这里，空表示`None`），那么我们将获取它的值，并将其存储在一个名为`value`的变量中。为了确保`list`中不会出现重复项，在将`value`变量追加到`list`之前，我们会检查该值是否已经存在。如果没有，那么意味着这是一个新项，我们将存储它。最后，我们会打印出结果，或者您可以将其保存到文本文件中。然后，我们将休眠`3`秒，再次检查剪贴板的状态。
- en: Now, let's run the the script and repeat the whole process one more time.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本并重复整个过程一次。
- en: Let's see what happens once we copy the username and password of the Gmail account.
    Once it is copied into the clipboard, our script will immediately get the clipboard
    value and print it out.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们复制Gmail账户的用户名和密码时会发生什么。一旦它被复制到剪贴板，我们的脚本会立即获取剪贴板的值并将其打印出来。
- en: Let's try with our stored PayPal account. Once we make a copy, we can see the
    random password we entered earlier.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试我们保存的PayPal账户。一旦我们复制，就能看到之前输入的随机密码。
- en: This is how the password manager works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是密码管理器的工作原理。
- en: Man in the browser
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器中的中间人攻击
- en: In this section, we will discuss a new method. As you may already know, all
    browsers offer to save your username and password when you submit the data into
    a login page. The next time you visit the same login page, you will see that your
    username and password are automatically filled in without typing a single letter.
    Also, there is dedicated third-party software such as **LastPass,** that can do
    the same job for you. The point here is that, if the target is using this method
    to log in, then neither the keylogger nor the clipboard methods will work.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一种新方法。正如您可能已经知道的那样，所有浏览器在您提交数据到登录页面时，都提供保存用户名和密码的功能。下次访问同一登录页面时，您会看到您的用户名和密码会自动填充，无需输入任何字符。此外，还有一些专用的第三方软件，如**LastPass**，也可以为您完成相同的工作。这里的关键是，如果目标用户使用这种方法登录，那么无论是键盘记录器还是剪贴板方法都无法奏效。
- en: 'Let''s take a quick look. We''ll be using the LastPass plugin on the Firefox
    browser. Open the browser here and go to the Gmail account. We will use the previous
    clipboard script before logging into the Gmail account:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下。我们将在Firefox浏览器中使用LastPass插件。在这里打开浏览器并访问Gmail账户。在登录Gmail账户之前，我们将使用之前的剪贴板脚本：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the script and then log into the Gmail account using LastPass. You will
    notice that LastPass has inserted the email and password automatically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，然后使用LastPass登录Gmail账户。你会注意到LastPass已经自动填入了电子邮件和密码。
- en: After logging in successfully, you will notice that the clipboard script could
    not catch anything here. Let's log out from the Gmail account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，你会注意到剪贴板脚本在这里没捕捉到任何内容。现在我们从Gmail账户退出。
- en: In response to this, hackers have created a new attack, called **man in the
    browser attack** to overcome this dilemma. In a nutshell, man in the browser attack
    intercepts the browser API calls and extracts the data while it's in clear text,
    before it gets out to the network socket where the SSL encryption happened.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这一点，黑客们创造了一种新的攻击方式，称为**浏览器中人攻击**，以克服这个困境。简而言之，浏览器中人攻击拦截浏览器的API调用，并在数据以明文形式出现时提取数据，避免数据进入网络套接字并进行SSL加密。
- en: Firefox process
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firefox进程
- en: 'We will debug and get inside the Firefox process now. Then, we will intercept
    the API calls for a specific Function inside a DLL module:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将调试并进入Firefox进程。然后，我们将拦截DLL模块中特定函数的API调用：
- en: '![](../images/00039.gif)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.gif)'
- en: 'This is the DLL and we will perform intercepting for a specific Function inside
    the DLL. After that, we will extract data and continue the flow. In summary, the
    steps for doing so are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DLL，我们将在DLL中对特定函数进行拦截。之后，我们将提取数据并继续流程。总结起来，执行的步骤如下：
- en: Get the process ID of the browser process.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取浏览器进程的进程ID。
- en: Attach our debugger to this process ID.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的调试器附加到此进程ID。
- en: Specify the DLL library that we want to intercept, as well as the function name
    inside the DLL. Keep in mind that we need to know the memory address of the function
    so that we can continue the flow after intercepting.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定我们想要拦截的DLL库，以及DLL中的函数名称。请记住，我们需要知道函数的内存地址，以便在拦截后继续流程。
- en: Set a breakpoint and register a `callback` function.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个断点并注册一个`callback`函数。
- en: In the `callback` function, we will print out the sensitive data from the memory
    in clear text.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`callback`函数中，我们将以明文形式打印出内存中的敏感数据。
- en: Wait for the debug event using the debug loop.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试循环等待调试事件。
- en: Once the debug event happens, execute the `callback` function.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦发生调试事件，执行`callback`函数。
- en: After executing the `callback` function, we will return to the original process
    to continue the normal flow.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`callback`函数后，我们将返回到原始进程继续正常流程。
- en: In the next two sections, we will see these steps in action. It's much simpler
    than it appears to be.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将看到这些步骤的实际操作。比看起来要简单得多。
- en: Firefox API hooking with Immunity Debugger
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Immunity Debugger进行Firefox API钩取
- en: Firefox uses a function called `PR_Write` to write data into a TCP socket. This
    function is located inside a DLL module called `nss3.dll`. For this demonstration,
    we need to prepare a Twitter account. Once that account is created and you are
    logged in, sign out of the account and then log in again. Since we use LastPass,
    the login credentials will already have been entered by LastPass. Once we click
    on the Log in button, what will happen behind the scenes?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox使用一个名为`PR_Write`的函数将数据写入TCP套接字。这个函数位于一个名为`nss3.dll`的DLL模块中。为了演示，我们需要准备一个Twitter账户。创建该账户并登录后，退出账户，然后再登录。由于我们使用LastPass，登录凭据已经由LastPass自动填写。点击登录按钮后，幕后会发生什么？
- en: '![](../images/00040.gif)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.gif)'
- en: Behind the scenes, Firefox will load the `nss3.dll` library and call the `PR_Write`
    function to submit the data (login ID and password). Once Firefox performs these
    steps, we'll set up a breakpoint and intercept traffic. Let's start by installing
    the **Immunity Debugger** software from [https://debugger.immunityinc.com/ID_register.py](https://debugger.immunityinc.com/ID_register.py).
    The installation part is quite straightforward. Immunity Debugger will get the
    process ID of the browser process and attach a debugger to the PID in one shot.
    We just need to attach the Firefox process from the list of processes to attach
    shown when we go to File | Attach. By default, Immunity Debugger will resolve
    the process ID and attach it for us. The next action is to specify the DLL library
    and function name, that is, `nss3.dll` and `PR_Write`, respectively. To do so,
    you just need to go to View | Executable modules. Search for the proper DLL by
    checking the Name field. Right-click on the highlighted DLL and then select View
    names. Scroll down until you find the `PR_Write` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Firefox将加载`nss3.dll`库并调用`PR_Write`函数以提交数据（登录ID和密码）。一旦Firefox执行这些步骤，我们将设置一个断点并拦截流量。让我们从[https://debugger.immunityinc.com/ID_register.py](https://debugger.immunityinc.com/ID_register.py)安装**Immunity
    Debugger**软件开始。安装过程相当简单。Immunity Debugger将获取浏览器进程的进程ID，并直接附加调试器到该PID。我们只需从文件 |
    附加菜单中选择要附加的Firefox进程列表中的进程即可。默认情况下，Immunity Debugger会解析进程ID并为我们附加。接下来的操作是指定DLL库和函数名称，即`nss3.dll`和`PR_Write`。为此，只需进入视图
    | 可执行模块，查看“名称”字段来搜索正确的DLL。右键单击高亮的DLL，然后选择查看名称。滚动查找直到找到`PR_Write`函数。
- en: So, at this point, we have accomplished the first four steps from our previous
    section on the *Firefox process*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，到这里，我们已经完成了前一部分关于*Firefox进程*的前四个步骤。
- en: Since we are doing the hooking manually using Immunity Debugger, we don't need
    to specify a `callback` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Immunity Debugger手动进行钩子操作，因此不需要指定`callback`函数。
- en: To set a breakpoint, you just need to press *F2* on your keyboard or right-click
    and specify a Toggle breakpoint. Once you do that, hit the Play button a couple
    of times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点，只需按键盘上的*F2*或右键点击并指定切换断点。完成后，点击播放按钮几次。
- en: Now bring up the Firefox window again. Notice that each time we get a breakpoint,
    we will be notified by the task manager located in the bottom of the Immunity
    Debugger screen. Also, the execution will be stopped. You can see the paused window.
    It'll be paused unless we manually hit the Play button once again. Now hit on
    the Log in button. To view the memory content, just right-click and go to Address
    | Relative to ESP register, which is the stack pointer. Then you just need to
    click on the Play button multiple times. Right-click on one of the ESP registers
    and select Follow in Dump so that we can see the memory dump here. Again we need
    to click on the Play button multiple times. Once again, right-click and select Follow
    in Dump. After a few clicks we will first copy the memory dump in the new text
    file and then we will terminate the debugger. You will see that there is the same
    username and password that we used for logging into the Twitter account. The username/email
    was `bigtasty@gmail.com`. We can see that we got some hexa characters, which we
    need to move back to ASCII. We can do this by checking with the ASCII code table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次打开Firefox窗口。注意，每当我们达到断点时，位于Immunity Debugger屏幕底部的任务管理器会通知我们。执行也会被暂停。你可以看到暂停的窗口，除非我们手动再次点击播放按钮，否则它将保持暂停状态。现在点击登录按钮。要查看内存内容，只需右键点击并选择地址
    | 相对于ESP寄存器，这就是堆栈指针。然后只需多次点击播放按钮。右键单击其中一个ESP寄存器并选择“跟踪转储”，以便我们可以在此看到内存转储。再次需要多次点击播放按钮。再次右键单击并选择“跟踪转储”。经过几次点击后，我们将首先将内存转储复制到新文本文件中，然后终止调试器。你会看到与我们登录Twitter账户时使用的相同的用户名和密码。用户名/邮箱是`bigtasty@gmail.com`。我们可以看到一些十六进制字符，我们需要将其转换回ASCII。我们可以通过查看ASCII码表来完成此操作。
- en: 'Let the following be the mail and password that we got above:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们获得的邮件和密码：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will start with the email address. Notice that `40` in hexa means `@` in
    ASCII. So we got `bigtasty` through `321@gmail`. For the password, the `58` is
    represented by a left bracket (`[`) and the `5D` is represented with a right bracket
    (`]`). So, our username and password will be set as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从电子邮件地址开始。注意，十六进制的`40`在ASCII中代表`@`。因此，我们得到了`bigtasty`通过`321@gmail`。对于密码，`58`代表左括号`[`，`5D`代表右括号`]`。因此，我们的用户名和密码将如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we will try to log in to the Twitter account using the information that
    we have just figured out here. So, go to the Twitter login page and copy the username
    and password, and you will see that you can log in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试使用我们刚刚弄清楚的信息登录 Twitter 帐号。访问 Twitter 登录页面，复制用户名和密码，你会看到你可以成功登录。
- en: Keep in mind that all that this is just a manual method, and it was just an
    introduction to the next section. In the next section, we will see how to get
    the same result using a Python script.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这一切只是手动方法的介绍，它只是为下一节做铺垫。在下一节中，我们将展示如何通过 Python 脚本得到相同的结果。
- en: Python in Firefox proof of concept (PoC)
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firefox 中的 Python 概念验证（PoC）
- en: In this section, we will write a Python script, that will automate the exact
    steps that we did using Immunity Debugger. For this purpose, we will be using
    a Python library called `winappdbg`, to automate the debugging of the Firefox
    process. So, let's start by installing this library. You can download the library
    from [http://winappdbg.sourceforge.net/](http://winappdbg.sourceforge.net/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个 Python 脚本，自动化我们使用 Immunity Debugger 所做的相同步骤。为此，我们将使用一个名为 `winappdbg`
    的 Python 库，来自动化调试 Firefox 进程。所以，让我们首先安装这个库。你可以从[http://winappdbg.sourceforge.net/](http://winappdbg.sourceforge.net/)下载这个库。
- en: 'The steps mentioned in the Firefox process section, which we explained earlier
    can be translated into code. Let''s do this step by step:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 Firefox 进程部分提到的步骤可以被转换为代码。我们来一步步实现：
- en: 'First, we need to get the process ID and then attach it to a debugger. The
    code in Python to do this is as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要获取进程 ID，然后将其附加到调试器。实现这一操作的 Python 代码如下：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, first we search for the Firefox process and then retrieve its
    process ID. We will then attach the process ID to the debugger and pass a class
    called `MyEventHandler` to the `debug` function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，首先我们搜索 Firefox 进程，然后检索其进程 ID。接着，我们将进程 ID 附加到调试器，并将一个名为 `MyEventHandler`
    的类传递给 `debug` 函数。
- en: 'In the `MyEventHandler` class, we specify the DLL library that we want to intercept
    as well as the function name, and we will resolve its memory address. Let''s look
    at the code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyEventHandler`类中，我们指定了要拦截的 DLL 库及其函数名，并将解析其内存地址。我们来看看代码：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see the DLL name `nss3.dll` and the function name `PR_Write`. We have
    resolved the memory address for the function. We then set the breakpoint, and
    register the `callback` function. Notice that we need to pass some mandatory information
    to the `callback` function, such as the process ID and the resolved memory address
    for the function. You can see the `pid` and the `address`. Notice that we have
    named the `callback` function `PR_Write`. When the breakpoint occurs, `3` parameters
    should be returned to the `callback` function. Now, the question is: what are
    these `3` parameters, and how could I know their number here? The answer to these
    questions comes from the Mozilla Firefox developers themselves.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 DLL 名称 `nss3.dll` 和函数名 `PR_Write`。我们已经解析了该函数的内存地址。然后我们设置了断点，并注册了 `callback`
    函数。注意，我们需要向 `callback` 函数传递一些强制信息，比如进程 ID 和解析出来的函数内存地址。你可以看到 `pid` 和 `address`。注意我们将
    `callback` 函数命名为 `PR_Write`。当断点发生时，应该将 `3` 个参数传递给 `callback` 函数。那么问题来了：这 `3` 个参数是什么？我如何知道它们的数量呢？这些问题的答案来自于
    Mozilla Firefox 的开发者。
- en: If we open the [https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write)
    link, we will get more details about the PR function parameters.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打开[https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write)链接，我们将获得更多关于
    PR 函数参数的详细信息。
- en: '`PR_Write` is the function name and the purpose of this function is to write
    a buffer of data to the file or socket. You can also see function parameters such
    as `*fd`, `*buf`, and `amount`. If you still remember, in Immunity Debugger, we
    were tracing the memory content each time we get a breakpoint to `PR_ function`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PR_Write` 是函数名，作用是将数据缓冲区写入文件或套接字。你还可以看到函数参数，如 `*fd`、`*buf` 和 `amount`。如果你还记得，在
    Immunity Debugger 中，每当我们得到断点并进入 `PR_ function` 时，我们都会追踪内存内容。'
- en: 'Here, a second parameter, `buf`, will give us a pointer to the memory address
    for the submitted data; in our case, we are looking for the username and password.
    So, all we need to do is resolve the memory address for this pointer. So, let''s
    reflect this in our code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第二个参数 `buf` 将给我们一个指向提交数据的内存地址的指针；在我们的例子中，我们正在寻找的是用户名和密码。因此，我们所需要做的就是解析该指针的内存地址。现在，让我们在代码中体现这一点：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that the three parameters are `arg1`, `arg2`, and `arg3`; we have
    already mentioned `paramCount=3`. We pass them to our `callback` function. As
    we said, our main interest is in the second parameter only, which is again the
    memory pointer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到三个参数分别是 `arg1`、`arg2` 和 `arg3`；我们已经提到过 `paramCount=3`。我们将它们传递给我们的 `callback`
    函数。如前所述，我们主要关注第二个参数，它是内存指针。
- en: 'The last step we need to do is read the first 1 KB of the memory address for
    that pointer, and this code will do the job for us:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一步是读取该指针内存地址的前 1 KB，这段代码将为我们完成此任务：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Argument 2 contains parameter 2, which is the memory pointer and we will read
    the first KB of that address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 2 包含参数 2，它是内存指针，我们将读取该地址的前 1 KB。
- en: So, at this point, we have completed the rest of the steps mentioned in the
    Firefox process section executing the `callback` function and printing the memory
    dump.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，此时我们已经完成了 Firefox 流程部分中提到的其余步骤，执行了 `callback` 函数并打印了内存转储。
- en: 'When will a debug take care of completing the normal flow? In the previous
    section, using Immunity Debugger, we tried doing that with a Twitter account.
    Let''s try with a PayPal account now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 调试何时会处理完成正常流程？在前一部分，我们使用 Immunity Debugger 进行了尝试，操作的是 Twitter 账户。现在让我们尝试使用 PayPal
    账户：
- en: Go to the PayPal login page and try to retrieve the login info.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 PayPal 登录页面并尝试获取登录信息。
- en: Run the script. Once I log in, notice the output we get.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。一旦我登录，注意观察我们得到的输出。
- en: If we enter the wrong credentials, we will get a regret message from PayPal.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输入错误的凭证，PayPal 会给我们发送一个错误信息。
- en: Interrupt the script and export the output into a text file here. To do this,
    go to File | Save As..., to save the file in text format. Search for the username in
    the text file. If you pay close attention, you will see that we got the login
    email ID as well as the login password, and both of them in clear text. Now, let's
    verify that these are the same credentials that were stored in LastPass.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断脚本并将输出导出到文本文件中。为此，请前往 文件 | 另存为...，以文本格式保存文件。在文本文件中搜索用户名。如果仔细观察，您将看到我们得到了登录的电子邮件
    ID 以及登录密码，而且这两个信息都是明文显示的。现在，让我们验证这些是否与 LastPass 中存储的凭证相同。
- en: Go to Sites | Finance | paypal.com then right-click and select Edit. If you
    click on the eye icon beside the Password option, you can see the password which
    will be the same as what we extracted from the Firefox process.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Sites | Finance | paypal.com，然后右键点击并选择编辑。如果点击密码选项旁边的眼睛图标，您将能看到密码，这个密码与我们从
    Firefox 进程中提取的密码相同。
- en: Before on moving to the next section, keep in mind that intercepting a function
    like `PR_Write` will badly affect the Firefox's process performance, since the
    function will be called frequently. Each time we intercept, this function, it
    will result in a delay and may crash the entire process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一部分之前，请记住，拦截像 `PR_Write` 这样的函数会严重影响 Firefox 进程的性能，因为该函数将被频繁调用。每次拦截该函数时，会导致延迟，甚至可能导致整个进程崩溃。
- en: Python in Firefox EXE
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Firefox EXE 中使用 Python。
- en: 'In this section, we will enhance our previous PoC script to match the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将增强之前的 PoC 脚本，以匹配以下内容：
- en: Once you get a pass in the memory, print out the memory dump and stop debugging
    to minimize performance issues
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您在内存中获得 pass，打印出内存转储并停止调试，以减少性能问题。
- en: Export your script into a standalone EXE file, so it can be used in the postexploitation
    phase (using `Py2exe`)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的脚本导出为独立的 EXE 文件，以便在后期利用阶段使用（使用 `Py2exe`）。
- en: Test it against antivirus
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针对杀毒软件进行测试。
- en: Try and make sure that it's fully functional by testing it while logging into
    Twitter, Gmail, PayPal, and Facebook accounts
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在登录 Twitter、Gmail、PayPal 和 Facebook 账户时进行测试，确保其功能正常。
- en: In the callback function, add a new `if` statement to terminate the debugging
    once we get a pass keyword. It's always a good thing before sending this script
    to your target, to test it locally first. To do so, you may need to change the
    setting in the `py2exe` setup file to the console mode.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，添加一个新的 `if` 语句，以便在获得 pass 关键字后终止调试。在将此脚本发送给目标之前，最好先在本地测试。为此，您可能需要更改 `py2exe`
    设置文件中的控制台模式。
- en: 'To test the script, we will log in to the Facebook account:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，我们将登录 Facebook 账户：
- en: Go to the login page of Facebook. As you will see, LastPass has entered our
    username and password for us.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 Facebook 的登录页面。你会看到，LastPass 已经为我们填入了用户名和密码。
- en: Run our script. You will get the Firefox process ID and the memory address for
    the function.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行我们的脚本。你将得到 Firefox 进程 ID 和该功能的内存地址。
- en: Once we click on the Log In button, notice the credentials that we extracted
    from the memory. You will see the email address and password.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们点击登录按钮，注意我们从内存中提取的凭证。你会看到电子邮件地址和密码。
- en: Now, let's check whether this was really the correct password stored on LastPass.
    To do this, first log out from Facebook and then go to Sites | Social; now, right-click
    on Facebook.com and select Edit.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下这个密码是否确实是 LastPass 中存储的正确密码。为此，首先从 Facebook 注销，然后进入 Sites | Social；现在，右键点击
    Facebook.com 并选择编辑。
- en: When you click on Edit, if you want to see the password value, you can see the
    same that we got from our script.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击编辑时，如果你想查看密码值，你会看到我们脚本提取的相同内容。
- en: Now, let's see whether the same tool and the same technique will work with other
    websites. For this, we will close the Facebook page and go to[ https://www.paypal.com/in/signin](https://www.paypal.com/in/signin) to
    login.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看相同的工具和技术是否可以在其他网站上使用。为此，我们将关闭 Facebook 页面，前往 [https://www.paypal.com/in/signin](https://www.paypal.com/in/signin)
    进行登录。
- en: Let's run our tool and go to the PayPal account. You will see that we get  the
    username and password that we used for the login.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行工具并进入 PayPal 账户。你会看到我们获得了用于登录的用户名和密码。
- en: Now, let's verify that this is the same password and username stored on LastPass.
    You just need to follow the same process as earlier.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证这是否是 LastPass 中存储的相同密码和用户名。你只需按照之前的步骤操作即可。
- en: We will try the same thing with Twitter by going to the Twitter log in page.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试用 Twitter 做相同的事情，进入 Twitter 的登录页面。
- en: Run the tool here as usual, and, once we hit on the Log In button, we can see
    the email ID and the password.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样运行工具，点击登录按钮后，我们可以看到电子邮件地址和密码。
- en: As we saw earlier, these values are in hexa format, and need to be converted
    into ASCII.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，这些值是十六进制格式的，需要转换为 ASCII 格式。
- en: A little reminder that neither the keylogger or  the clipboard hijacking techniques
    that we saw earlier, will work in a similar scenario, and this is because we are
    not typing or pasting any data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们之前看到的键盘记录器或剪贴板劫持技术，在类似的场景下是无法使用的，因为我们没有输入或粘贴任何数据。
- en: Dumping saved passwords out of Google Chrome
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Google Chrome 中提取保存的密码
- en: In this section, we will discuss another password-hacking technique. This technique
    was originally created to recover your password if you forget it. Here we will
    take advantage and hack the saved password remotely. For this attack to work successfully,
    your target should be using Google Chrome, and they should have previously saved
    the login password. Let's look at how this works. Log into your Facebook account.
    You will notice a prompt at the top-right corner of the screen, which asks you
    whether to save the password with a Save password button. If our target has clicked
    on Save password, then we will be able to grab that password remotely.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论另一种密码破解技术。这种技术最初是为了解决忘记密码时找回密码的问题。我们将利用这个技术，远程破解保存的密码。为了让这种攻击成功，目标必须使用
    Google Chrome，并且他们应该已经保存了登录密码。让我们来看看这是如何工作的。登录 Facebook 账户后，你会注意到屏幕右上角出现一个提示，询问你是否保存密码，旁边有一个“保存密码”按钮。如果我们的目标点击了保存密码，那么我们将能够远程获取该密码。
- en: We will now see how to do that. To do this, we will Log out from Facebook first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看一下如何操作。首先从 Facebook 注销。
- en: Acquiring the password remotely
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程获取密码
- en: 'Let''s get started by understanding how Google Chrome stores and recovers the
    saved password in the first place:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来了解 Google Chrome 是如何存储和恢复保存的密码的：
- en: '![](../images/00041.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: So, the first fact is, we should know that Google Chrome uses the Windows login
    password as a key to do both the encryption and decryption phases. The second
    thing we need to know is that encrypted passwords are stored in a SQLite database
    called Login Data DB and that database is located in the path `C:\Users\%USERNAME%\AppData\Local\Google\Chrome\User
    Data\Default`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，第一个事实是，我们应该知道 Google Chrome 使用 Windows 登录密码作为密钥来执行加密和解密过程。第二个我们需要知道的事情是，已加密的密码存储在一个名为
    Login Data DB 的 SQLite 数据库中，并且该数据库位于路径 `C:\Users\%USERNAME%\AppData\Local\Google\Chrome\User
    Data\Default`。
- en: Google Chrome calls a specific Windows API function called `CryptProtectData`,
    which utilizes the Windows login password as an encryption key. In reverse operation,
    a Windows API `CryptUnProtectData` is called to decrypt the password value back
    to clear text. Now let's summarize how Chrome works in saving passwords.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome调用一个特定的Windows API函数`CryptProtectData`，它使用Windows登录密码作为加密密钥。在反向操作中，调用Windows
    API `CryptUnProtectData`来解密密码值并还原为明文。现在让我们总结一下Chrome如何保存密码的过程。
- en: Let's assume that our target has logged into Facebook for the first time. Google
    Chrome will prompt them to save the password. If they click on Save password,
    then Google Chrome will take this password in a clear-text format and call the `CryptProtectData`
    API, which will encrypt this password using the Windows login password and save
    it in the login data database. Later on, when our target visits the Facebook page
    one more time, Google Chrome will retrieve the encrypted password and pass it
    to the `CryptUnProtectData` API function. After that, we will get the clear text
    password. Then, Google Chrome will submit it on your behalf.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标第一次登录Facebook时，Google Chrome会提示他们保存密码。如果他们点击保存密码，那么Google Chrome会将这个明文密码传递给`CryptProtectData`
    API，这个API会使用Windows登录密码加密该密码并将其保存在登录数据数据库中。之后，当目标再次访问Facebook页面时，Google Chrome会检索到加密的密码并将其传递给`CryptUnProtectData`
    API函数。之后，我们就会得到明文密码。然后，Google Chrome会代表你提交密码。
- en: Now technically, if we code a Python script to grab the encrypted password from
    the Chrome database and pass that value to `CryptUnprotectData` API function,
    then we should be able to see the saved password in a clear text format after
    that; that's exactly what we'll do here.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，如果我们编写一个Python脚本来从Chrome数据库中抓取加密的密码，并将该值传递给`CryptUnprotectData` API函数，那么我们应该能够看到保存的密码以明文格式显示；这正是我们在这里要做的。
- en: 'Before moving to the coding part, let''s have a look at the SQL database. Here,
    we will be using a free open source database browser for SQLite:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码部分之前，我们先看看SQL数据库。这里我们将使用一个免费的开源SQLite数据库浏览器：
- en: Navigate to SQLite, which gets created by Google Chrome. In my case, the path
    is `C:\Users\Hussam\AppData\Local\Google\Chrome\User Data\Default` that Chrome
    creates its database, and we will copy the `Login Data` file to the desktop.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Google Chrome创建的SQLite数据库。在我的例子中，路径是`C:\Users\Hussam\AppData\Local\Google\Chrome\User
    Data\Default`，Chrome在这里创建了它的数据库，我们将把`Login Data`文件复制到桌面。
- en: We have to change the extension to SQLite so that we can import it in the database
    browser.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将扩展名改为SQLite，这样才能在数据库浏览器中导入。
- en: So all we have to do right now is click on Open Database and go to the Desktop to
    open `Login Data.sqlite3`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以现在我们要做的就是点击“打开数据库”，然后前往桌面，打开`Login Data.sqlite3`。
- en: Once we import it, you can see that there is a table called `logins`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入后，你会看到有一个叫做`logins`的表。
- en: 'Once we click on Browse Data, we can see some interesting columns:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们点击“浏览数据”，我们就可以看到一些有趣的列：
- en: '![](../images/00042.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00042.jpeg)'
- en: '`action_url` is the URL that the user navigated to when submitting the login
    credentials, and in our case, it''s a Facebook URL. The value, or `username_value`
    and the `password_value` are the values of the username and the password that
    have been submitted.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`action_url`是用户在提交登录凭证时导航到的URL，在我们的例子中，它是Facebook的URL。`username_value`和`password_value`分别是已提交的用户名和密码的值。'
- en: We need to locate the SQLite database, as the `USERNAME` directory is a variable
    and will be different from one PC to another.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定位SQLite数据库，因为`USERNAME`目录是一个变量，在不同的电脑上会有所不同。
- en: We need to grab the values of `action_url` and `username_value` and the `password_value`
    columns from that database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从数据库中抓取`action_url`、`username_value`和`password_value`列的值。
- en: Finally, we pass `password_value` to the `CryptUnProtectData` function, or API
    function, to decrypt it back into clear text.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`password_value`传递给`CryptUnProtectData`函数或API函数，解密为明文。
- en: 'So, let''s start with the coding part:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始编写代码部分：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will start with importing the necessary libraries:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入必要的库开始：
- en: We will import `getenv`, to resolve the Windows environment variable and find
    out the Google Chrome SQL path.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入`getenv`，来解析Windows环境变量并找到Google Chrome的SQL路径。
- en: Next, we import SQLite3 to read the Chrome SQLite database and fetch its raw
    values.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入SQLite3来读取Chrome的SQLite数据库并获取其原始值。
- en: We import `win32crypt`, which provides a high-level library to call the Windows
    API `CryptUnProtectData`. Keep in mind that, in order to use this library, we
    need to first install the `pywin32` library from [http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了 `win32crypt`，它提供了一个高级库来调用 Windows API `CryptUnProtectData`。请记住，要使用这个库，我们首先需要从
    [http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/)
    安装 `pywin32` 库。
- en: '`LOCALAPPDATA` is a Windows environment variable, which points to `C:\Users`,
    then `username`, and then the `AppData\Local` path—and that is half of our full
    path. So, once we''ve got this part, all we have to do is append the second part
    of the path by adding `\Google\Chrome\User Data\Default\Login Data` to get the
    absolute path of the `Login Data` database.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCALAPPDATA` 是一个 Windows 环境变量，指向 `C:\Users`，然后是 `username`，接着是 `AppData\Local`
    路径——这就是我们完整路径的一半。所以，一旦我们得到了这一部分，接下来只需将路径的第二部分附加上，方法是添加 `\Google\Chrome\User Data\Default\Login
    Data`，以获得 `Login Data` 数据库的绝对路径。'
- en: If the target is logging into a site, which has an entry into the database,
    then sometimes reading the Chrome database will return an error that the database
    is locked; and you will get an exception called `database is locked`, once you
    run the Python script. In our example, if the target is logged into Facebook at
    the time that we want to read from the Chrome database, then we want to be able
    to do that. The workaround for this is to make a copy of the login database and
    pull the data out of the copied database. So here, the copied database has the
    name `Login2`, and it's located on the same directory as the original one. And,
    at this point, we have accomplished the first step of locating the database.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标用户正在登录某个网站，并且该网站在数据库中有条目，那么有时读取 Chrome 数据库时会返回一个错误，提示数据库被锁定；当你运行 Python
    脚本时，会遇到一个名为 `database is locked` 的异常。在我们的例子中，如果目标用户在我们要读取 Chrome 数据库时已经登录 Facebook，那么我们希望能够读取。解决方法是复制登录数据库并从复制的数据库中提取数据。因此，这里复制的数据库被命名为
    `Login2`，并且与原始数据库位于同一目录下。此时，我们已经完成了定位数据库的第一步。
- en: 'Since the original database can be locked, we will read data from the copied
    database. We''ll do this using the `sqlite3.connect` function, pointing to the
    copied database path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原始数据库可能被锁定，我们将从复制的数据库中读取数据。我们通过使用 `sqlite3.connect` 函数，指向复制的数据库路径来完成这项操作：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we create a cursor object so that we can execute the SQL queries to pull
    out the desired columns. If you remember, the table name was `login` and it has
    three important columns, which are `username` and `password_value`, along with
    the `action_url`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建一个游标对象，以便执行 SQL 查询来提取所需的列。如果你还记得，表名是 `login`，它有三列重要数据，分别是 `username`
    和 `password_value`，以及 `action_url`。
- en: 'So, we''ll select these columns and fetch their values using a `for` loop with
    a `fetchall` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将选择这些列，并使用带有 `fetchall` 函数的 `for` 循环来提取它们的值：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result will be a list stored in a raw variable. Then, we'll print the first
    two values in this list, which are `action_url` and `username_value`. So, by doing
    that at this point we have achieved the second step of our plan, and we grabbed
    the data out of a Chrome database.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将存储在一个原始变量中，然后我们将打印出列表中的前两个值，即 `action_url` 和 `username_value`。这样做之后，我们就完成了计划的第二步，从
    Chrome 数据库中提取数据。
- en: 'The last step would be to call the `CryptUnProtectData` API function and pass
    the encrypted password, which is by the way stored in the third element of our
    raw list. Finally we''ll print out the result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用 `CryptUnProtectData` API 函数，并传入加密的密码，这个密码存储在我们原始列表的第三个元素中。最终，我们将打印出结果：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, upon running the module you will see that we get three items: the URL,
    the username, and the clear-text password.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行模块时你会看到我们得到三个项：URL、用户名和明文密码。
- en: Try to double-check that these are the correct credentials to log into my Facebook
    account. Also try with other websites like Twitter, PayPal, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次确认这些是否是登录我 Facebook 账户的正确凭据。也可以尝试其他网站，比如 Twitter、PayPal 等。
- en: Submitting the recovered password over HTTP session
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 会话提交恢复的密码。
- en: In this section, we will modify our previous script to automate the submitting
    of the recovered or hacked password over the HTTP session. And then, we will send
    it back to the hacker machine, where the end result should be a standalone file,
    which can be used in post-exploitation or as a function integrated with a new
    Python shell.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改之前的脚本，以自动提交恢复或被攻击的密码通过 HTTP 会话。然后，我们将把它发送回黑客机器，最终结果应该是一个独立的文件，可以在后期利用或作为一个与新
    Python Shell 集成的功能。
- en: 'We will start our HTTP server on the Kali machine to receive the hacked password
    of the target site. We will simply double-click on the Chrome Dumper EXE file.
    You will see that we were able to have the saved password remotely out of a Chrome
    database. Here, we grabbed the Facebook email and password, and also the Twitter
    account. Now, if we move to the target machine, we will see that the following
    are the two sessions that are currently open on the target site:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Kali 机器上启动 HTTP 服务器，以接收目标网站的被黑密码。我们只需双击 Chrome Dumper EXE 文件。你会看到，我们成功地从
    Chrome 数据库中远程获取了保存的密码。在这里，我们抓取了 Facebook 的邮箱和密码，还有 Twitter 账户。现在，如果我们切换到目标机器上，我们会看到以下是当前在目标站点上打开的两个会话：
- en: '![](../images/00043.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00043.jpeg)'
- en: Testing the file against antivirus
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对防病毒软件进行文件测试
- en: We will be using the well-known website, VirusTotal, and will upload our Google
    Dumper file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用知名网站 VirusTotal，并上传我们的 Google Dumper 文件。
- en: For this, navigate to our `Chrome Dumper` file and Upload and scan file. Upload
    the `Chrome Dumper` file and scan the content.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，导航到我们的 `Chrome Dumper` 文件，并上传和扫描文件。上传 `Chrome Dumper` 文件并扫描其内容。
- en: You will see how many antivirus could raise a flag. Now, I would say that we
    got a fair result if the number of antivirus raised is few, and if anybody can
    try and compile the script using `PyInstaller` and test it, then they could have
    a different result.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到有多少防病毒软件会触发警告。现在，我想说，如果触发警告的防病毒软件不多，我们就得到了一个不错的结果。如果有人能够使用 `PyInstaller`
    尝试编译脚本并进行测试，他们可能会得到不同的结果。
- en: Password phishing – DNS poisoning
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码钓鱼 – DNS 劫持
- en: One of the easiest ways to manipulate the direction of the traffic remotely
    is to play with DNS records. Each operating system contains a host file in order
    to statically map hostnames to specific IP addresses. The host file is a plain
    text file, which can be easily rewritten as long as we have admin privileges.
    For now, let's have a quick look at the host file in the Windows operating system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 操控流量方向的一种最简单的方法是操作 DNS 记录。每个操作系统都包含一个主机文件，用于将主机名静态映射到特定的 IP 地址。主机文件是一个纯文本文件，只要我们拥有管理员权限，就可以轻松地重新写入它。现在，让我们快速浏览一下
    Windows 操作系统中的主机文件。
- en: 'In Windows, the file will be located under `C:\Windows\System32\drivers\etc`.
    Let''s have a look at the contents of the `host` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，该文件位于 `C:\Windows\System32\drivers\etc` 下。让我们看看 `host` 文件的内容：
- en: '![](../images/00044.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00044.jpeg)'
- en: If you read the description, you will see that each entry should be located
    on a separate line. Also, there is a sample of the record format, where the IP
    should be placed first. Then, after at least one space, the name follows. You
    will also see that each record's that the IP address begins first, then we get
    the hostname.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读描述，你会看到每个条目应该位于单独的一行上。此外，记录格式中有一个示例，其中 IP 地址应该放在前面。然后，至少有一个空格，后面跟着主机名。你还会看到每个记录中，IP
    地址是首先出现的，接着是主机名。
- en: 'Now, let''s see the traffic on the packet level:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看数据包级别的流量：
- en: Open Wireshark on our target machine and start the capture.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开目标机器上的 Wireshark 并开始抓包。
- en: 'Filter on the attacker IP address:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按攻击者的 IP 地址进行过滤：
- en: '![](../images/00045.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00045.jpeg)'
- en: We have an IP address of `10.10.10.100`, which is the IP address of our attacker.
    We can see the traffic before poisoning the DNS records. You need to click on
    Apply to complete the process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `10.10.10.100` 的 IP 地址，这是我们的攻击者的 IP 地址。我们可以看到在劫持 DNS 记录之前的流量。你需要点击应用来完成该过程。
- en: 'Open [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    Notice that once we ping the name from the command line, the operating system
    behind the scene will do a DNS lookup:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)。注意，一旦我们从命令行
    ping 该名称，操作系统会在后台进行 DNS 查找：
- en: '![](../images/00046.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00046.jpeg)'
- en: We will get the real IP address. Now, notice what happens after DNS poisoning.
    For this, close all the windows except the one where the Wireshark application
    is running.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取真实的IP地址。现在，注意在DNS投毒后会发生什么。为此，关闭所有窗口，除了运行Wireshark应用程序的那个窗口。
- en: Keep in mind that we should run as admin to be able to modify the host file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们应该以管理员身份运行，以便能够修改hosts文件。
- en: Now, even though we are running as an admin, when it comes to running an application
    you should explicitly do a right-click and then run as admin.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，即使我们以管理员身份运行，在运行应用程序时，仍然需要明确右键点击并选择“以管理员身份运行”。
- en: Navigate to the directory where the `hosts` file is located.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`hosts`文件所在的目录。
- en: Execute `dir` and you will get the `hosts` file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`dir`，你会看到`hosts`文件。
- en: Run `type hosts`. You can see the original host here.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`type hosts`。你可以看到这里是原始的host。
- en: 'Now, we will enter the command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将输入以下命令：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`10.10.100`, is the IP address of our Kali machine. So, once the target goes
    to `google.jo`, it should be redirected to the attacker machine.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`10.10.100`是我们Kali机器的IP地址。所以，一旦目标访问`google.jo`，它应该会被重定向到攻击者机器。'
- en: Once again verify the host by executing `type hosts`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次通过执行`type hosts`验证主机。
- en: 'Now, after doing a DNS modification, it''s always a good thing to flush the
    DNS cache, just to make sure that we will use the updated record. For this, enter
    the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改DNS后，刷新DNS缓存总是一个好主意，这样可以确保我们使用的是更新的记录。为此，请输入以下命令：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, watch what happens after DNS poisoning. For this, we will open our browser
    and navigate to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    Notice that on Wireshark the traffic is going to the Kali IP address instead of
    the real IP address of `google.jo`. This is because the DNS resolution for `google.jo`
    was `10.10.10.100`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看DNS投毒后会发生什么。为此，我们将打开浏览器并访问[https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)。请注意，在Wireshark中，流量正通过Kali的IP地址，而不是`google.jo`的真实IP地址。这是因为`google.jo`的DNS解析结果是`10.10.10.100`。
- en: We will stop the capturing and recover the original `hosts` file. We will then
    place that file in the `drivers\etc` folder.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将停止捕获并恢复原始的`hosts`文件。然后，我们将把这个文件放到`drivers\etc`文件夹中。
- en: 'Now, let''s flush the poisoned DNS cache first by running:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们先通过运行以下命令来刷新被污染的DNS缓存：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, open the browser again. We should go to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)
    right now. Now we are good to go!
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次打开浏览器。我们现在应该访问[https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)。现在我们可以开始了！
- en: Using Python script
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python脚本
- en: Now we'll automate the steps, but this time via a Python script.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将自动化这些步骤，但这次通过Python脚本来完成。
- en: 'Open the script and enter the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开脚本并输入以下代码：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first thing we will do is change our current working directory to be the
    same as the `hosts` file, and that will be done using the `OS` library. Then,
    using subprocesses, we will append a static DNS record, pointing Facebook to `10.10.10.100`:
    the Kali IP address. In the last step, we will flush the DNS record. We can now
    save the file and export the script into EXE.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将当前工作目录更改为与`hosts`文件相同的位置，这将通过`OS`库来完成。然后，使用子进程，我们将附加一个静态DNS记录，将Facebook指向`10.10.10.100`：Kali的IP地址。在最后一步，我们将刷新DNS记录。现在我们可以保存文件并将脚本导出为EXE。
- en: 'Remember that we need to make the target execute it as admin. To do that, in
    the setup file for the `py2exe`, we will add a new line, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们需要让目标以管理员身份执行它。为此，在`py2exe`的设置文件中，我们将添加一行，如下所示：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, we have added a new option, specifying that when the target executes the
    EXE file, we will ask to elevate our privilege into admin. To do this, we will
    require administrator privileges.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们添加了一个新选项，指定当目标执行EXE文件时，我们将要求提升我们的权限为管理员。为此，我们将需要管理员权限。
- en: Let's run the setup file and start a new capture. Now, I will copy our EXE file
    onto the desktop. Notice here that we got a little shield indicating that this
    file needs an admin privilege, which will give us the exact result for running
    as admin. Now, let's run the file. Verify that the file host gets modified. You
    will see that our line has been added.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行设置文件并开始新的捕获。现在，我将我们的EXE文件复制到桌面。注意这里，我们看到一个小盾牌，表示这个文件需要管理员权限，这将为我们提供运行管理员权限的确切结果。现在，让我们运行该文件。验证文件的host是否已被修改。你将看到我们的行已被添加。
- en: Now, open a new session and we will see whether we got the redirection. So,
    let's start a new capture, and we will add on the Firefox. As you will see, the
    DNS lookup for `google.jo` is pointing to our IP address, which is `10.10.10.100`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个新的会话，我们将看看是否获得了重定向。我们开始一个新的捕获，并将其添加到Firefox中。正如你所看到的，`google.jo`的DNS查找指向了我们的IP地址，即`10.10.10.100`。
- en: In the next section, we will see how we can take advantage of this for password
    phishing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到如何利用这一点进行密码钓鱼。
- en: Facebook password phishing
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facebook密码钓鱼
- en: In the previous section, we have seen that with a few lines of Python code we
    can redirect traffic to the attacker machine instead of going to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    This time, we will see how an attacker can take advantage of manipulating the
    DNS record for Facebook, redirect traffic to the phishing page, and grab the account
    password.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们看到只需要几行Python代码，就可以将流量重定向到攻击者的机器，而不是访问[https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)。这一次，我们将看到攻击者如何利用修改Facebook的DNS记录，重定向流量到钓鱼页面，并抓取账户密码。
- en: First, we need to set up a phishing page.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一个钓鱼页面。
- en: You need not be an expert in web programming. You can easily Google the steps
    for preparing a phishing account.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要成为网页编程的专家。你可以轻松地通过Google搜索准备钓鱼账户的步骤。
- en: To create a phishing page, first open your browser and navigate to the Facebook
    login page. Then, on the browser menu, click on File and then on Save page as....
    Then, make sure that you choose a complete page from the drop-down menu.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个钓鱼页面，首先打开你的浏览器并导航到Facebook登录页面。然后，在浏览器菜单中点击文件，再点击“另存为...”。然后，确保从下拉菜单中选择完整页面。
- en: The output should be an `.html` file.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应该是一个`.html`文件。
- en: Now let's extract some data here. Open the `Phishing` folder from the code files
    provided with this book. Rename the Facebook HTML page `index.html`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在这里提取一些数据。打开书中提供的代码文件中的`Phishing`文件夹。将Facebook的HTML页面重命名为`index.html`。
- en: Inside this HTML, we have to change the login form. If you search for `action=`,
    you will see it. Here, we change the login form to redirect the request into a
    custom PHP page called `login.php`. Also, we have to change the request method
    to `GET` instead of `POST`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个HTML中，我们必须更改登录表单。如果你搜索`action=`，你会看到它。在这里，我们将登录表单更改为将请求重定向到一个名为`login.php`的自定义PHP页面。此外，我们还必须将请求方法更改为`GET`，而不是`POST`。
- en: 'You will see that I have added a `login.php` page in the same `Phishing` directory.
    If you open the file, you will find the following script:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到我在同一个`Phishing`目录下添加了一个`login.php`页面。如果你打开文件，你会看到以下脚本：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As soon as our target clicks on the Log In button, we will send the data as
    a `GET` request to this `login.php` and we will store the submitted data in our
    `passwords.txt` file; then, we will close it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标点击“登录”按钮，我们将把数据作为`GET`请求发送到这个`login.php`，并将提交的数据存储在我们的`passwords.txt`文件中；然后，我们将关闭它。
- en: Next, we will create the `passwords.txt` file, where the target credentials
    will be stored.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`passwords.txt`文件，目标凭据将存储在其中。
- en: Now, we will copy all of these files into `\var\www` and start the Apache services.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把所有这些文件复制到`\var\www`，并启动Apache服务。
- en: If we open the `index.html` page locally, we will see that this is the phishing
    page that the target will see.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在本地打开`index.html`页面，我们将看到这是目标将看到的钓鱼页面。
- en: Let's recap really quickly what will happen when the target clicks on the Log
    In button? As soon as our target clicks on the Log In button, the target's credentials
    will be sent as `GET` requests to `login.php`. Remember that this will happen
    because we have modified the action parameter to send the credentials to `login.php`.
    After that, the `login.php` will eventually store the data into the `passwords.txt`
    file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下当目标点击“登录”按钮时会发生什么？一旦目标点击“登录”按钮，目标的凭据将作为`GET`请求发送到`login.php`。记住，这会发生是因为我们修改了`action`参数，将凭据发送到`login.php`。之后，`login.php`最终会将数据存储到`passwords.txt`文件中。
- en: Now, before we start the Apache services, let me make sure that we get an IP
    address.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们启动Apache服务之前，让我确保我们获得了一个IP地址。
- en: 'Enter the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see that we are running on `10.10.10.100` and we will also start the
    Apache service using:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在运行`10.10.10.100`，并且我们也会使用以下命令启动Apache服务：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s verify that we are listening on port `80`, and the service that is listening
    is Apache:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证一下我们是否在监听`80`端口，并且监听的服务是Apache：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's jump to the target side for a second.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到目标端看一眼。
- en: 'In our previous section, we have used `google.jo` in our script. Here, we have
    already modified our previous script to redirect the Facebook traffic to our attacker
    machine. So, all our target has to do is double-click on the EXE file. Now, to
    verify:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们在脚本中使用了`google.jo`。在这里，我们已经修改了之前的脚本，将 Facebook 流量重定向到我们的攻击者机器上。因此，我们的目标所需要做的就是双击
    EXE 文件。现在，为了验证：
- en: Let us start Wireshark and then start the capture.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动 Wireshark，然后开始抓包。
- en: 'We will filter on the attacker IP, which is `10.10.10.100`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将过滤攻击者 IP，即`10.10.10.100`：
- en: '![](../images/00047.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00047.jpeg)'
- en: 'Open the browser and navigate to [https://www.facebook.com/](https://www.facebook.com/):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 [https://www.facebook.com/](https://www.facebook.com/)：
- en: '![](../images/00048.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: Once we do this, we're taken to the phishing page instead. Here, you will see
    the destination IP, which is the Kali IP address. So, on the target side, once
    we are viewing or hitting [https://www.facebook.com/](https://www.facebook.com/),
    we are basically viewing `index.html`, which is set up on the Kali machine. Once
    the victim clicks on the login page, we will send the data as a `GET` request
    to `login.php`, and we will store it into `passwords.txt`, which is currently
    empty.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，就会跳转到钓鱼页面。在这里，你会看到目标 IP 地址，也就是 Kali 的 IP 地址。所以，在目标端，当我们访问或点击[https://www.facebook.com/](https://www.facebook.com/)时，我们实际上是在查看`index.html`，它设置在
    Kali 机器上。一旦受害者点击登录页面，我们将以`GET`请求的方式将数据发送到`login.php`，并将其存储到当前为空的`passwords.txt`中。
- en: 'Now, log into your Facebook account using your username and password. and jump
    on the Kali side and see if we get anything on the `passwords.txt` file. You can
    see it is still empty. This is because, by default, we have no permission to write
    data. Now, to fix this, we will give all files full privilege, that is, to read,
    write, and execute:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用你的用户名和密码登录 Facebook，并跳到 Kali 端查看 `passwords.txt` 文件是否有任何内容。你会看到它仍然是空的。这是因为默认情况下，我们没有写入数据的权限。现在，为了解决这个问题，我们将给予所有文件完全权限，即读、写和执行：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we made this, since we are running in a VirtualBox environment. If
    you have a web server exposed to the public, it's bad practice to give full permission
    to all of your files due to privilege escalation attacks, as an attacker may upload
    a malicious file or manipulate the files and then browse to the file location
    to execute a command on his own.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们之所以这样做，是因为我们正在虚拟机环境（VirtualBox）中运行。如果你有一个面向公众的 Web 服务器，给所有文件完全权限是一种不良实践，因为这可能导致权限提升攻击，攻击者可能上传恶意文件或篡改文件，然后浏览到文件位置执行自己的命令。
- en: 'Now, after giving the permission, we will `stop` and `start` the Apache server
    just in case:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在赋予权限后，我们将`停止`和`启动` Apache 服务器，以防万一：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After doing this modification, go to the target machine and try to log into
    Facebook one more time. Then, go to Kali and click on `passwords.txt`. You will
    see the submitted data from the target side, and we can see the username and the
    password.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此修改后，前往目标机器并再次尝试登录 Facebook。然后，去 Kali 机器，点击`passwords.txt`。你会看到来自目标端提交的数据，并且可以看到用户名和密码。
- en: In the end, a good sign for a phishing activity is missing the `https` sign.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，钓鱼活动的一个良好指示标志是缺少`https`标志。
- en: In the upcoming section, we will discuss how to protect yourself and secure
    your account from these attacks. Also, you need to make sure to turn off your
    Apache server once you're done with your assessment.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论如何保护自己并保障你的账户免受这些攻击。此外，你需要确保在完成评估后关闭 Apache 服务器。
- en: Countermeasures
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应对措施
- en: In this section, we will discuss four methods that you can use to secure your
    online account. Note that these are not the only available methods. However, following
    these steps should give your account a fair level of security.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论四种方法，帮助你保护在线账户。请注意，这些方法并不是唯一可用的方式。然而，按照这些步骤操作应该能为你的账户提供一个合理的安全水平。
- en: Securing the online account
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护在线账户
- en: So, let's start with using the security services provided by the vendor. I really
    recommend to enable Step 2 authentication (or sometimes called one-time password)
    on all of your accounts such as Gmail, LinkedIn, and PayPal whenever this option
    is available. And when you do so, once you decide to log in, it'll ask you for
    the username and password. And the second step is to enter the one-time password,
    which you will usually get via an SMS or application, or even by email. Now, this
    one-time password will be valid only for 30 seconds or less.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从使用供应商提供的安全服务开始。我强烈建议在所有账户上启用第二步身份验证（有时也叫一次性密码），比如 Gmail、LinkedIn 和 PayPal，任何时候这个选项可用时都应该启用。启用后，每次登录时，它会要求你输入用户名和密码，第二步是输入一次性密码，通常会通过短信、应用程序，甚至是电子邮件发送给你。现在，这个一次性密码通常只能在30秒内使用。
- en: 'Here are few links which guide you on how easy and powerful it is to enable
    this feature for some services such as Gmail, Twitter, and so on:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些链接，它们指导你如何轻松且有效地启用此功能，适用于一些服务，如 Gmail、Twitter 等：
- en: 'Gmail provides SMS and Gmail mobile app:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gmail 提供短信和 Gmail 移动应用：
- en: '[https://www.google.com/landing/2step/](https://www.google.com/landing/2step/)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.google.com/landing/2step/](https://www.google.com/landing/2step/)'
- en: '[https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en)'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en)'
- en: 'Twitter provides mobile app and SMS:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter 提供移动应用和短信服务：
- en: '[https://support.twitter.com/articles/20170388](https://support.twitter.com/articles/20170388)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://support.twitter.com/articles/20170388](https://support.twitter.com/articles/20170388)'
- en: Before moving to the next point, I need to mention that even after enabling
    Step 2 authentication, we're still vulnerable to session hijacking vulnerability,
    where an attacker can hijack the session or the cookies after Step 2 authentication,
    and reinject that session on his own. One more thing you want to pay attention
    to is the login. Each time a new device is logged in your account, you will get
    a notification message, by email most likely, to inform you with this strange
    access.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个步骤之前，我需要提到，即使启用了第二步身份验证，我们仍然容易受到会话劫持漏洞的攻击，攻击者可以在第二步身份验证后劫持会话或 cookies，然后将该会话重新注入到自己的系统中。你还需要注意每次登录时的安全性。每当有新设备登录你的账户时，你通常会通过电子邮件收到一条通知，告知你有陌生的登录行为。
- en: And it will give you some kind of information such as the operating system or
    the timestamp. The preceding screenshot shows the Windows operating system, that
    has newly signed to your account. Also, it will advise you what to do if this
    was a suspicious activity.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会向你提供一些信息，比如操作系统或时间戳。前面的截图显示了 Windows 操作系统，说明你已在新的设备上登录了你的账户。同时，它还会提示你如果这是一次可疑活动应该采取的措施。
- en: To avoid this, you need to make sure that your password itself should be complex
    enough, and try to avoid trivial and weak passwords.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，你需要确保密码足够复杂，并避免使用简单或弱的密码。
- en: Securing your computer
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的计算机安全
- en: 'We will now see how to secure your own device. When it comes to computers,
    the following are the steps you need to consider:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何保护你的设备安全。对于计算机，以下是你需要考虑的步骤：
- en: Use a nonadmin account all the time
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用非管理员账户
- en: Keep your browser and system updated
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持浏览器和系统更新
- en: Consider the countermeasures we discussed in the previous section
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑我们在上一节中讨论的应对措施
- en: Securing your network
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的网络安全
- en: Now, let's see how to secure your own network to protect your data in transit.
    If you have to use untrusted network, such as a cafe Wi-Fi, to access your sensitive
    data such as your bank account or PayPal account, then you should use a trusted
    VPN to establish a secure tunnel and prevent local LAN attacks. No doubt that
    VPN will add values such as authentication and encryption, which will be used
    to defeat local LAN attacks such as man-in-the-middle attacks.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看如何保护你的网络，以保护你的数据传输安全。如果你不得不使用不受信任的网络，如咖啡馆的 Wi-Fi，来访问你的敏感数据（如银行账户或 PayPal
    账户），那么你应该使用一个可信赖的 VPN 来建立一个安全的隧道，防止局域网攻击。毫无疑问，VPN 会提供身份验证和加密等功能，这将帮助防御局域网攻击，如中间人攻击。
- en: Keeping a watch on any suspicious activity
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控任何可疑活动
- en: Now, let's see how to keep your eyes open on anything abnormal on the login
    page, such as a missing https in the URL field is a good indicator for phishing
    activity, where the attacker can redirect your traffic to a malicious login page;
    or if the attacker is in between, like man-in-the-middle attack, he can use a
    tool such as SSL strip to strip off the SSL encryption and turn your data into
    clear text.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看如何在登录页面上注意任何异常情况，例如URL栏中缺少https就是一个很好的钓鱼活动指示，攻击者可能会将你的流量重定向到恶意登录页面；或者如果攻击者在中间（如中间人攻击），他可以使用像SSL
    strip这样的工具去除SSL加密，将你的数据转为明文。
- en: 'And if you are a security paranoid person, even if you see the `https` label
    in green, you can double-check the certificate status that you got from the website.
    For instance, this is a screenshot of a Facebook server certificate:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个对安全非常敏感的人，即使看到绿色的`https`标签，你也可以再次检查从网站获得的证书状态。例如，这是Facebook服务器证书的截图：
- en: '![](../images/00049.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00049.jpeg)'
- en: We can see that it's issued to all Facebook domain, and we can see that the
    issuer is DigiCert.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到证书是颁发给所有Facebook域的，并且颁发机构是DigiCert。
- en: Also, the certificate path will show us the health status for this certificate;
    and if there is any sub-CA or subcertificate authority and intermediate certificate
    in between.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，证书路径将显示该证书的健康状态；并且如果存在任何子CA（证书颁发机构）或中间证书，这些也会显示出来。
- en: Next, we should be really careful on sites that your browser shows a certificate
    error before showing the login page, as an attacker could set up a proxy server
    and provide you with a fake certificate to intercept the traffic during a man-in-the-middle
    attack. Each browser may show you a different notification for this certificate
    error.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该特别小心那些在浏览器显示证书错误后才显示登录页面的网站，因为攻击者可能会设置代理服务器并提供伪造的证书，在中间人攻击（Man-in-the-middle
    Attack）过程中拦截流量。不同浏览器可能会以不同的方式显示该证书错误的通知。
- en: For scam emails, keep in mind that no one should ask you about your password
    over email, or even post a login link to you by email.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诈骗邮件，请记住，没有人会通过电子邮件询问你的密码，或者通过电子邮件向你发送登录链接。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to configure a keylogger and also dealt with password
    manager to securely store the device credentials. We also learned about a new
    method—Man in the Browser. Further, we saw the process of Firefox API hooking
    with Immunity Debugger and performed the password phishing process.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何配置键盘记录器，并处理了密码管理器来安全存储设备凭证。我们还学习了一种新方法——浏览器中的中间人攻击（Man in the Browser）。此外，我们还看到了如何使用Immunity
    Debugger进行Firefox API钩取，并进行了密码钓鱼过程演示。
- en: In the end, we discussed the countermeasures on how to protect yourself and
    secure your account from the attacks.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何保护自己并确保账户安全的对策。
- en: In the next chapter, we will set up our own hacking environment in VirtualBox.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将设置自己的黑客环境，使用VirtualBox。
