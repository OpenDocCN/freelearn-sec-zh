- en: Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Cryptography is the practice of securing communications even when a third-party
    can view those communications. There are two-way symmetric and asymmetric encryption
    methods, as well as one-way hashing algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是保障通信安全的实践，即使第三方可以查看这些通信。它包括双向对称和非对称加密方法，以及单向哈希算法。
- en: Encryption is a critical part of the modern internet. With services such as [LetsEncrypt.com](http://www.LetsEncrypt.com),
    everyone has access to trusted SSL certificates. Our entire infrastructure relies
    on and trusts encryption to work to keep all our confidential data secret. It
    is important to properly encrypt and hash data correctly, and it is easy to misconfigure
    a service, leaving it vulnerable or exposed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是现代互联网的关键部分。借助像 [LetsEncrypt.com](http://www.LetsEncrypt.com) 这样的服务，所有人都能获得受信任的
    SSL 证书。我们的整个基础设施依赖并信任加密来确保所有机密数据的安全。正确地加密和哈希数据非常重要，且容易配置错误，导致服务漏洞或暴露。
- en: 'This chapter covers examples and use cases for the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容的示例和用例：
- en: Symmetric and asymmetric encryption
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称和非对称加密
- en: Signing and verifying messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名和验证消息
- en: Hashing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Storing passwords securely
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: Generating secure random numbers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成安全的随机数
- en: Creating and using TLS/SSL certificates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用 TLS/SSL 证书
- en: Hashing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: Hashing is when a variable length message is transformed into a unique fixed-length
    alphanumeric string. There are various hashing algorithms available, such as MD5
    and SHA1\. Hashes are one-way and non-invertible, unlike symmetric encryption
    functions, such as AES, which can recover the original message if you have the
    key. Because hashes cannot be reversed, most of them are cracked by brute force.
    Crackers will build power-sucking rigs with several GPUs to hash every possible
    character combination until they find a hash that matches. They will also generate
    rainbow tables or files containing all of the hash outputs generated for quick
    lookup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是将一个可变长度的消息转换为一个唯一的固定长度的字母数字字符串。有多种哈希算法可供选择，例如 MD5 和 SHA1。哈希是单向且不可逆的，不像对称加密函数（如
    AES），后者如果有密钥就可以恢复原始消息。因为哈希无法反转，大多数哈希会被暴力破解。攻击者会利用多个 GPU 构建高功耗的计算设备，通过暴力穷举每一种可能的字符组合，直到找到匹配的哈希值。他们还会生成彩虹表或包含所有哈希输出的文件，以便快速查找。
- en: Salting your hashes is important for this reason. Salting is the process of
    adding a random string to the end of the password, provided by a user, to add
    more randomness or entropy. Consider an application that stores user login information
    and hashed passwords for authentication. If two users had the same password, then
    their hash output would be identical. Without salts, a cracker might find multiple
    people who use the same password and would only need to crack the hash one time.
    By adding a unique salt to each user's password, you ensure that each user has
    a unique hash value. Salting reduces the effectiveness of rainbow tables because,
    even if they knew the salt that goes with each hash, they would have to generate
    a rainbow able to each salt, which is time consuming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为哈希添加盐值是很重要的原因。加盐是将一个随机字符串附加到用户提供的密码后面的过程，以增加更多的随机性或熵值。考虑一个存储用户登录信息和哈希密码以进行身份验证的应用程序。如果两个用户使用相同的密码，他们的哈希结果将是相同的。如果没有加盐，攻击者可能会发现多个使用相同密码的用户，并且只需要破解一次哈希值。通过为每个用户的密码添加唯一的盐值，你可以确保每个用户的哈希值都是唯一的。加盐减少了彩虹表的有效性，因为即使攻击者知道与每个哈希对应的盐值，他们也必须为每个盐值生成一个彩虹表，而这需要大量的时间。
- en: Hashes are commonly used to validate passwords. Another common use is for file
    integrity. Large downloads often come with an MD5 or SHA1 hash of the file. After
    downloading you can hash the file to make sure that it matches the expected value.
    If it doesn't match, then the download was modified in some way. Hashing is also
    used as a way of recording indicators of compromise or IOCs. Files that are known
    to be malicious or dangerous are hashed, and that hash is stored in a catalog.
    These are often shared publicly so people can check suspicious files against known
    risks. It is much more efficient to store and compare a hash than the entire file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希常用于验证密码。另一个常见的用途是文件完整性。大型下载通常会附带文件的 MD5 或 SHA1 哈希。下载后，你可以对文件进行哈希检查，确保它与预期值匹配。如果不匹配，那么下载的文件可能已被篡改。哈希还常用于记录妥协指标或
    IOC（Indicators of Compromise）。已知的恶意或危险文件会被哈希，并将该哈希值存储在目录中。这些通常会公开分享，以便人们将可疑文件与已知风险进行对比。存储并比较哈希值比存储整个文件更高效。
- en: Hashing small files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希小文件
- en: 'If a file is small enough to be contained in memory, the `ReadFile()` method
    works quickly. It loads the whole file into memory and then digests the data.
    The sum will be calculated with multiple different hash algorithms for demonstration:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件足够小，可以容纳在内存中，那么 `ReadFile()` 方法会很快工作。它将整个文件加载到内存中，然后进行数据摘要。为了演示，使用多种不同的哈希算法计算摘要值：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hashing large files
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希大文件
- en: 'In the previous hashing example, the entire file to be hashed was loaded into
    memory before hashing. This is not practical or even possible when files reach
    a certain size. Physical memory limitations will come into play. Because the hashes
    are implemented as a block cipher, it will operate on one chunk at a time without
    the need to load the entire file in memory at once:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的哈希示例中，整个待哈希的文件在哈希处理前被加载到内存中。当文件达到一定大小时，这种做法既不实际也不可能。物理内存的限制将发挥作用。因为哈希是作为块加密实现的，它将逐块处理，而不需要一次性加载整个文件到内存中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Storing passwords securely
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全存储密码
- en: Now that we know how to hash, we can talk about securely storing passwords.
    Hashing is an important factor when it comes to protecting passwords. Other important
    factors are salting, using a cryptographically strong hash function, and the optional
    use of **hash-based message authentication code** (**HMAC**), which all add an
    additional secret key into the hashing algorithm.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何进行哈希处理后，可以讨论如何安全地存储密码。哈希处理在保护密码时非常重要。其他重要因素包括加盐、使用加密强度高的哈希函数，以及可选使用
    **基于哈希的消息认证码**（**HMAC**），它们都会将额外的秘密密钥加入到哈希算法中。
- en: HMAC is an added layer that uses a secret key; so, even if an attacker got your
    database of hashed passwords with the salts, they would still have a difficult
    time cracking them without the secret key. The secret key should be stored in
    a separate location such as an environment variable rather than in the database
    with the hashed passwords and salts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC 是一个额外的层，它使用一个秘密密钥；因此，即使攻击者获得了包含盐值的哈希密码数据库，没有秘密密钥他们也会很难破解这些密码。秘密密钥应存储在单独的位置，例如环境变量，而不是与哈希密码和盐值一起存储在数据库中。
- en: This example application has limited use as it is. Use it as a reference for
    your own applications
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用本身用途有限。可以作为你自己应用的参考。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Encryption
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: Encryption is different from hashing because it is reversible and the original
    message can be recovered. There are symmetric encryption methods that use a password
    or a shared key to encrypt and decrypt. There are also asymmetric encryption algorithms
    that operate with a public and private key pair. AES is an example of symmetric
    encryption, and it is used to encrypt ZIP files, PDF files, or an entire filesystem.
    RSA is an example of asymmetric encryption and is used for SSL, SSH keys, and
    PGP.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 加密与哈希不同，因为加密是可逆的，原始消息可以被恢复。有些对称加密方法使用密码或共享密钥进行加密和解密。还有一些非对称加密算法使用公钥和私钥对来操作。AES
    是对称加密的一个例子，它用于加密 ZIP 文件、PDF 文件或整个文件系统。RSA 是非对称加密的一个例子，它用于 SSL、SSH 密钥和 PGP。
- en: Cryptographically secure pseudo-random number generator (CSPRNG)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密安全伪随机数生成器（CSPRNG）
- en: The `math` and `rand` packages do not provide the same amount of randomness
    that the `crypto/rand` package offers. Do not use `math/rand` for cryptographic
    applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 和 `rand` 包提供的随机性不如 `crypto/rand` 包。不要在加密应用中使用 `math/rand`。'
- en: Read more about Go's `crypto/rand` package at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 Go 的 `crypto/rand` 包的信息，请访问 [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/)。
- en: 'The following example will demonstrate how to generate random bytes, a random
    integer, or any other signed or unsigned type of integer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将演示如何生成随机字节、随机整数或任何其他带符号或无符号类型的整数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Symmetric encryption
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密
- en: Symmetric encryption is when the same key or password is used to encrypt and
    decrypt the data. Advanced Encryption Standard, also known as AES or Rijndael,
    is a symmetric encryption algorithm made standard by NIST in 2001.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密是指使用相同的密钥或密码来加密和解密数据。高级加密标准（AES），也称为 Rijndael，是由 NIST 于 2001 年标准化的对称加密算法。
- en: Data Encryption Standard, or DES, is another symmetric encryption algorithm
    that is older and less secure than AES. It should not be used over AES unless
    there is a specific requirement or specification to do so. Go standard library
    includes AES and DES packages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密标准（DES）是另一种对称加密算法，比AES更老且不那么安全。除非有特定的要求或规范，否则不应使用DES来替代AES。Go标准库包含AES和DES包。
- en: AES
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AES
- en: This program will encrypt and decrypt a file using a key, which is basically
    a 32-byte (256-bit) password.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将使用一个密钥对文件进行加密和解密，该密钥本质上是一个32字节（256位）的密码。
- en: When generating a key, encrypting, or decrypting, the output is sent to `STDOUT`
    or the Terminal typically. You can easily redirect the output to a file or another
    program using the `>` operator. Refer to the usage patterns for examples. If you
    need to store the key or the encrypted data as an ASCII encoded string, use base64
    encoding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成密钥、加密或解密时，输出通常会被发送到`STDOUT`或终端。你可以使用`>`运算符轻松地将输出重定向到文件或其他程序。参考使用模式以获取示例。如果你需要将密钥或加密后的数据存储为ASCII编码的字符串，可以使用base64编码。
- en: At some point in this example, you will see the message being split into two
    pieces, the IV, and the cipher text. The initialization vector, or IV, is a random
    value that gets prepended to the actual encrypted message. Every time a message
    is encrypted with AES, a random value is generated and used as part of the encryption.
    The random value is called a nonce, which means simply a number that is only used
    once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将看到信息被分成两个部分：初始化向量（IV）和密文。初始化向量（IV）是一个随机值，会被添加到实际的加密信息前面。每次使用AES加密信息时，都会生成一个随机值并作为加密的一部分。这个随机值被称为nonce，意味着它只是一个仅使用一次的数字。
- en: Why are these one time values created? Especially, if they aren't kept secret
    and are put right in front of the encrypted message, what purpose does it serve?
    The random IV is used in a similar fashion to a salt. It is used primarily so
    that when the same message is encrypted repeatedly, the cipher text is different
    each time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些一次性值会被创建？特别是，如果它们不是保密的，并且直接放在加密信息前面，这样做有什么意义？随机的初始化向量（IV）类似于盐值（salt）。它的主要作用是确保当相同的信息被反复加密时，每次生成的密文都不同。
- en: To use **Galois/Counter Mode** (**GCM**) instead of CFB, change the encrypt
    and decrypt methods. GCM has better performance and efficiency because it allows
    parallel processing. Read more about GCM at [https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**Galois/计数器模式**（**GCM**）代替CFB，请更改加密和解密方法。GCM具有更好的性能和效率，因为它支持并行处理。可以在[https://en.wikipedia.org/wiki/Galois/Counter_Mode](https://en.wikipedia.org/wiki/Galois/Counter_Mode)上了解更多关于GCM的信息。
- en: 'Start with an AES cipher and call `cipher.NewCFBEncrypter(block, iv)`. Then
    depending on whether you need to encrypt or decrypt, you will either call `.Seal()` with
    a nonce you generate, or call `.Open()` and pass it the separated nonce and cipher
    text:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从AES密码开始，调用`cipher.NewCFBEncrypter(block, iv)`。然后，根据你是需要加密还是解密，你将调用`.Seal()`并传入你生成的nonce，或者调用`.Open()`并传入分离的nonce和密文：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Asymmetric encryption
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Asymmetric is when there are two keys for each party. A public and private key
    pair is required on each side. Asymmetric encryption algorithms include RSA, DSA,
    and ECDSA. The Go standard library has packages for RSA, DSA, and ECDSA. Some
    applications that use asymmetric encryption include **Secure Shell** (**SSH**),
    **Secure Sockets Layer** (**SSL**), and **Pretty Good Privacy** (**PGP**).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密是指每一方都有两个密钥。每一方都需要一对公钥和私钥。非对称加密算法包括RSA、DSA和ECDSA。Go标准库提供了RSA、DSA和ECDSA的包。使用非对称加密的应用程序包括**安全外壳协议**（**SSH**）、**安全套接层**（**SSL**）和**非常好的隐私**（**PGP**）。
- en: SSL is the **Secure Sockets Layer** originally developed by Netscape, and version
    2 was publicly released in 1995\. It is used to encrypt communication between
    a server and a client providing confidentiality, integrity, and authentication.
    **TLS**, or **Transport Layer Security**, is the new version of SSL, with 1.2
    being defined in 2008 as RFC 5246\. The Go package for TLS does not completely
    implement the specification, but it implements the major parts. Read more about
    Go's `crypto/tls` package at [https://golang.org/pkg/crypto/tls/](https://golang.org/pkg/crypto/tls/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 是 **安全套接字层**，最初由 Netscape 开发，版本 2 于 1995 年公开发布。它用于加密服务器与客户端之间的通信，提供机密性、完整性和认证功能。**TLS**（传输层安全性）是
    SSL 的新版本，1.2 版本于 2008 年作为 RFC 5246 定义。Go 的 TLS 包并没有完全实现该规范，但它实现了主要部分。阅读更多关于 Go
    的 `crypto/tls` 包的信息，请访问 [https://golang.org/pkg/crypto/tls/](https://golang.org/pkg/crypto/tls/)。
- en: You can only encrypt things smaller than the key size, which is frequently 2048
    bits. Because of this size limitation, asymmetric RSA encryption is not practical
    for encrypting entire documents, which easily exceed 2048 bits or 256 bytes. On
    the other hand, symmetric encryption such as AES can encrypt large documents,
    but it requires a shared key by both parties. TLS/SSL uses a combination of asymmetric
    and symmetric encryption. The initial connection and handshake is done using asymmetric
    encryption with the public and private keys of each party. Once the connection
    is established, a shared key is generated and shared. Once the shared key is known
    by both parties, the asymmetric encryption is dropped, and the rest of the communication
    is done using symmetric encryption such as AES using the shared key.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能加密小于密钥大小的内容，通常为 2048 位。因此，由于这个大小限制，非对称 RSA 加密不适合加密整个文档，因为文档容易超过 2048 位或 256
    字节。另一方面，对称加密（如 AES）可以加密大文档，但它需要双方共享一个密钥。TLS/SSL 使用非对称加密和对称加密的结合。初始连接和握手使用非对称加密，涉及双方的公钥和私钥。一旦连接建立，就会生成并共享一个共享密钥。共享密钥一旦被双方知晓，非对称加密就会被弃用，接下来的通信将使用对称加密（如
    AES），并使用共享密钥进行加密。
- en: The examples here will use RSA keys. We will cover generating your own public
    and private keys and saving them as PEM encoded files, digitally signing messages
    and verifying signatures. In the next section, we will use the keys to create
    a self-signed certificate and establish secure TLS connections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例将使用 RSA 密钥。我们将介绍如何生成自己的公钥和私钥并将它们保存为 PEM 编码文件，数字签名消息并验证签名。在接下来的部分中，我们将使用这些密钥创建自签名证书并建立安全的
    TLS 连接。
- en: Generating a public and private key pair
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成公钥和私钥对
- en: Before using asymmetric encryption, you need a public and private key pair.
    The private key must be kept secure and not shared with anyone. The public key
    should be shared with others.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用非对称加密之前，你需要一个公钥和私钥对。私钥必须保密，不能与任何人共享。公钥应该与他人共享。
- en: '**RSA** (**Rivest-Shamir-Adleman**) and **ECDSA** (**Elliptic Curve Digital
    Signing Algorithm**) algorithms are available in the Go standard library. ECDSA
    is considered more secure, but RSA is the most common algorithm used in SSL certificates.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA**（**Rivest-Shamir-Adleman**）和 **ECDSA**（**椭圆曲线数字签名算法**）算法在 Go 标准库中可用。ECDSA
    被认为更安全，但 RSA 是 SSL 证书中最常用的算法。'
- en: You have the option to password protect your private key. You don't need to
    do it, but it is an extra layer of security. Because the private key is so sensitive,
    it is recommended that you use password protection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择为你的私钥设置密码保护。虽然不是必需的，但它提供了一层额外的安全保障。由于私钥非常敏感，建议使用密码保护。
- en: If you want to password protect your private key file using a symmetric encryption
    algorithm, such as AES, you can use some of the standard library functions. The
    primary functions you will need are `x509.EncryptPEMBlock()`, `x509.DecryptPEMBlock()`,
    and `x509.IsEncryptedPEMBlock()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用对称加密算法（如 AES）来为你的私钥文件设置密码保护，可以使用一些标准库函数。你需要使用的主要函数是 `x509.EncryptPEMBlock()`、`x509.DecryptPEMBlock()`
    和 `x509.IsEncryptedPEMBlock()`。
- en: 'To perform the equivalent operation of generating a private and public key
    file using OpenSSL, use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行相当于使用 OpenSSL 生成私钥和公钥文件的操作，请使用以下命令：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can learn more about PEM encoding with Go at [https://golang.org/pkg/encoding/pem/](https://golang.org/pkg/encoding/pem/).
    Refer to the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 [https://golang.org/pkg/encoding/pem/](https://golang.org/pkg/encoding/pem/)
    了解更多关于 Go 中 PEM 编码的内容。参考以下代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Digitally signing a message
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名消息
- en: The purpose of signing a message is to let the recipient know the message came
    from the correct person. To sign a message, first generate the hash of the message
    and then use your private key to encrypt the hash. The encrypted hash is your
    signature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 签名消息的目的是让收件人知道消息来自正确的人。要签名一条消息，首先生成消息的哈希值，然后使用你的私钥对哈希值进行加密。加密后的哈希值就是你的签名。
- en: The recipient will decrypt your signature to get the original hash you provided,
    then they will hash the message themselves and see if the hash they generated
    themselves from the message matches the decrypted value of the signature. If they
    match, the recipient knows that the signature is valid and it came from the correct
    sender.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 收件人会解密你的签名，得到你提供的原始哈希值，然后他们会对消息进行哈希处理，查看自己生成的哈希值是否与解密后的签名值匹配。如果匹配，收件人就知道签名是有效的，并且来自正确的发送者。
- en: Note that signing a message does not actually encrypt the message. You will
    still need to encrypt the message before sending it, if needed. You may not want
    to encrypt the message itself, if you want to post your message publicly. Others
    can still use the signature to verify who posted the message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，签名一条消息并不会真正加密该消息。如果需要，你仍然需要在发送消息之前对其进行加密。如果你希望公开发布消息，可能不需要加密消息本身。其他人仍然可以使用签名来验证消息的发布者。
- en: Only messages smaller than the RSA key size can be signed. Because the SHA-256
    hash always has the same output length, we can be sure that it is within the acceptable
    size limit. In this example, we are using the RSA PKCS#1 v1.5 standard signature
    with a SHA-256 hashing method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只有小于 RSA 密钥大小的消息才能被签名。由于 SHA-256 哈希始终具有相同的输出长度，我们可以确保它在可接受的大小限制内。在此示例中，我们使用的是
    RSA PKCS#1 v1.5 标准签名和 SHA-256 哈希方法。
- en: The Go programming language comes with functions in the core packages to handle
    signing and verifying. The primary function is `rsa.VerifyPKCS1v5`. This function
    takes care of hashing the message and then encrypting it with the private key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编程语言自带了用于处理签名和验证的核心包函数。主要的函数是`rsa.VerifyPKCS1v5`。该函数负责对消息进行哈希处理，然后使用私钥进行加密。
- en: 'The following program will take a message and a private key and create a signature
    output to `STDOUT`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将接收一条消息和一个私钥，并将签名输出到`STDOUT`：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Verifying a signature
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证签名
- en: In the previous example, we learned how to create a signature of a message for
    the recipient to verify. Now let's look at the process of verifying a signature.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何为收件人创建一条消息的签名以供验证。现在让我们看看验证签名的过程。
- en: If you receive a message and a signature, you must first decrypt the signature
    using the sender's public key. Then hash the original message and see if your
    hash matches the decrypted signature. If your hash matches the decrypted signature,
    then you can be sure that the sender is the person who owns the private key that
    is paired with the public key you used to verify.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一条消息和一个签名，你必须先使用发送方的公钥解密签名。然后对原始消息进行哈希，检查你的哈希值是否与解密后的签名匹配。如果你的哈希值与解密后的签名匹配，那么你可以确定发送方是拥有与你用来验证的公钥配对的私钥的那个人。
- en: To verify the signature, we are using the same algorithms (RSA PKCS#1 v1.5 with
    SHA-256) that were used to create the signature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证签名，我们使用与创建签名时相同的算法（RSA PKCS#1 v1.5 和 SHA-256）。
- en: This example requires two command-line arguments. The first argument is the
    public key of the person who created the signate and the second argument is the
    file with the signature. To create a signature file, use the sign program from
    the previous example and redirect the output to a file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要两个命令行参数。第一个参数是创建签名的人的公钥，第二个参数是包含签名的文件。要创建签名文件，可以使用之前示例中的 sign 程序并将输出重定向到一个文件。
- en: 'Similar to the previous section, Go has a function in the standard library
    for verifying a signature. We can use `rsa.VerifyPKCS1v5()` to compare the message
    hash to the decrypted value of the signature and see whether they match:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节类似，Go 的标准库中有一个用于验证签名的函数。我们可以使用`rsa.VerifyPKCS1v5()`来比较消息的哈希值与解密后的签名值，看看它们是否匹配：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TLS
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: We usually don't encrypt whole messages with RSA because it can only encrypt
    messages smaller than the key size. The solution to this is typically to begin
    the communication with small messages that use the RSA keys to encrypt. When they
    have established a secure channel, they can safely exchange a shared key that
    they can use to symmetrically encrypt the rest of their messages without the size
    limitations. This is the approach SSL and TLS take to establish a secure communication.
    The handshake takes cares of negotiating which encryption algorithms will be used
    when generating and sharing a symmetric key.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不使用 RSA 加密整个消息，因为它只能加密小于密钥大小的消息。解决方案通常是在通信开始时使用小消息，通过 RSA 密钥加密。当建立了安全通道后，它们可以安全地交换共享密钥，然后使用该密钥对其余消息进行对称加密，避免大小限制。这就是
    SSL 和 TLS 建立安全通信时所采取的方法。握手过程负责协商在生成和共享对称密钥时使用的加密算法。
- en: Generating a self-signed certificate
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成自签名证书
- en: To create a self-signed certificate with Go, you need a public and private key
    pair. The x509 package has a function for creating a certificate. It requires
    the public and private key along with a template certificate with all the information.
    Since we are self-signing, the template certificate is also going to be used as
    the parent certificate doing the signing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Go 创建自签名证书，你需要一对公私密钥。x509 包提供了一个用于创建证书的函数。它需要公钥和私钥，以及一个包含所有信息的证书模板。由于我们是自签名，因此证书模板也将作为根证书进行签名。
- en: Each application can treat self-signed certificates differently. Some applications
    will warn you if a certificate is self-signed, some will refuse to accept it,
    and others will happily use it without warning you. When you write your own applications,
    you will have to decide if you want to verify certificates or accept self-signed
    ones.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序可能对自签名证书有不同的处理方式。有些应用程序会在证书是自签名时给出警告，有些会拒绝接受，而另一些则会在不警告的情况下愉快地使用它。当你编写自己的应用程序时，你需要决定是否要验证证书或接受自签名证书。
- en: 'The important function is `x509.CreateCertificate()`, referenced at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
    Here is the function signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的功能是`x509.CreateCertificate()`，可以参考 [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate)。下面是函数签名：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will take a private key and generate a certificate signed by it.
    It will save it to a file in PEM format. Once you create a self-signed certificate,
    you can use that certificate along with the private key to run secure TLS socket
    listeners and web servers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将使用私钥生成一个由该私钥签名的证书，并将其以 PEM 格式保存到文件中。一旦创建了自签名证书，你可以将该证书与私钥一起使用来运行安全的 TLS
    套接字监听器和 Web 服务器。
- en: For the sake of brevity, this example hardcodes the certificate owner information
    and the hostname IP to be localhost. This is good enough for testing on your local
    machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，本示例将证书所有者信息和主机名 IP 硬编码为 localhost。这对于在本地机器上测试已经足够。
- en: 'Modify these to suit your needs, customize the values, have them input through
    command-line arguments, or use standard input to get the values from the user
    dynamically, as shown in the following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要修改这些内容，定制值，通过命令行参数输入，或使用标准输入动态获取用户的值，如以下代码块所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a certificate signing request
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建证书签名请求
- en: If you don't want to create a self-signed certificate, you have to create a
    certificate signing request and have it signed by a trusted certificate authority.
    You create a certificate request by calling `x509.CreateCertificateRequest()`
    and passing it an `x509.CertificateRequest` object with the private key.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想创建自签名证书，你必须创建证书签名请求，并让受信任的证书颁发机构对其进行签名。你可以通过调用 `x509.CreateCertificateRequest()`
    并传递一个包含私钥的 `x509.CertificateRequest` 对象来创建证书请求。
- en: 'The equivalent operation using OpenSSL is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 执行的等效操作如下：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example demonstrates how to create a certificate signing request:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示如何创建证书签名请求：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Signing a certificate request
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署证书请求
- en: In the previous example, when generating a self-signed certificate, we already
    demonstrated the process for creating a signed certificate. In the self-signed
    example, we just used the same certificate template as the signee and the signer.
    For this reason, there is not a separate code example. The only difference is
    that the parent certificate doing the signing or the template to be signed should
    be swapped out to a different certificate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，当生成自签名证书时，我们已经展示了创建签名证书的过程。在自签名示例中，我们只是使用了与签署者和被签署者相同的证书模板。因此没有单独的代码示例。唯一的不同是进行签名的父证书或待签署的证书模板应该替换为一个不同的证书。
- en: 'This is the function definition for `x509.CreateCertificate()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `x509.CreateCertificate()` 的函数定义：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the self-signed example, the template and parent certificates were the same
    object. To sign a certificate request, create a new certificate object and populate
    the fields with the information from the signing request. Pass the new certificate
    as the template, and use the signer's certificate as the parent. The `pub` parameter
    is the signee's public key and the `priv` parameter is the signer's private key.
    The signer is the certificate authority and the signee is the requester. You can
    read more about this function at [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在自签名示例中，模板和父证书是相同的对象。要签署证书请求，创建一个新的证书对象，并用签名请求中的信息填充字段。将新证书作为模板传递，并使用签署者的证书作为父证书。`pub`
    参数是被签署者的公钥，`priv` 参数是签署者的私钥。签署者是证书颁发机构，而被签署者是请求者。你可以在 [https://golang.org/pkg/crypto/x509/#CreateCertificate](https://golang.org/pkg/crypto/x509/#CreateCertificate)
    阅读更多关于此函数的内容。
- en: 'The  `X509.CreateCertificate()` parameters are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`X509.CreateCertificate()` 的参数如下：'
- en: '`rand`: This is the cryptographically secure pseudorandom number generator'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand`：这是一个加密安全的伪随机数生成器。'
- en: '`template`: This is the certificate template populated with info from CSR'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这是从 CSR 中填充信息的证书模板。'
- en: '`parent`: This is the certificate of the signer'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：这是签署者的证书。'
- en: '`pub`: This is the public key of the signee'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pub`：这是被签署者的公钥。'
- en: '`priv`: This is the private key of the signer'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priv`：这是签署者的私钥。'
- en: 'The equivalent operation using OpenSSL is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 执行相同操作如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: TLS server
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 服务器
- en: You can set up a listener just like a normal socket connection, but with encryption.
    Just call the TLS `Listen()` function, and provide it your certificate and private
    key. The certificate and key generated using the previous examples will work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像正常的套接字连接一样设置监听器，但带有加密。只需调用 TLS 的 `Listen()` 函数，并提供证书和私钥。之前示例中生成的证书和密钥将能正常工作。
- en: 'The following program will create a TLS server and echo back any data received,
    then close the connection. The server will not require or verify client certificates,
    but the code to do so is left commented out for reference in case you want to
    authenticate clients with certificates:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将创建一个 TLS 服务器，回显接收到的任何数据，然后关闭连接。该服务器不需要或验证客户端证书，但为了参考，如果你想使用证书进行客户端身份验证，相关代码已被注释掉：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: TLS client
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 客户端
- en: TCP sockets are a simple and common way of communicating over a network. Adding
    the TLS layer on top of a standard TCP socket is simple with Go's standard library.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 套接字是网络通信中一种简单且常见的方式。在标准 TCP 套接字上添加 TLS 层，在 Go 的标准库中非常简单。
- en: A client dials a TLS server just like a standard socket. Clients typically aren't
    required to have any sort of key or certificate, but a server could implement
    client-side authentication and only allow certain users to connect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端像标准套接字一样拨打 TLS 服务器。通常客户端不需要任何密钥或证书，但服务器可以实现客户端身份验证，并只允许特定的用户连接。
- en: This program will connect to a TLS server and send the contents of STDIN to
    the remote server and read the response. We can use this program to test our basic
    TLS echo server created in the previous section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将连接到一个 TLS 服务器，并将 STDIN 的内容发送到远程服务器，并读取响应。我们可以使用这个程序来测试我们在上一节中创建的基本 TLS
    回显服务器。
- en: Before running this program, make sure that the TLS server from the previous
    section is running so that you can connect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此程序之前，请确保上一节中的 TLS 服务器正在运行，以便您可以连接。
- en: Note that this is a raw socket-level server. It is not an HTTP server. In [Chapter
    9](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml), *Web Applications* there are examples
    of running an HTTPS TLS web server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个原始的套接字级别服务器。它不是一个 HTTP 服务器。在[第 9 章](f15910a1-239e-49a5-b4d9-3881a524bfa9.xhtml)
    *Web 应用程序* 中有运行 HTTPS TLS 网络服务器的示例。
- en: By default, the client verifies that the server's certificate is signed by a
    trusted authority. We have to override this default and tell the client not to
    verify the certificate because we signed it ourselves. The list of trusted certificate
    authorities is loaded from the system, but can be overridden by populating the
    RootCAs variable in `tls.Config`. This example will not verify the server certificate,
    but the code to provide a list of trusted RootCAs is provided, but commented out
    for reference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，客户端会验证服务器的证书是否由受信任的机构签署。我们需要覆盖这个默认设置，并告诉客户端不要验证证书，因为证书是我们自己签署的。受信任的证书机构列表是从系统加载的，但可以通过在
    `tls.Config` 中填充 RootCAs 变量来覆盖。这个示例将不验证服务器证书，但提供了受信任的 RootCAs 列表代码，并为参考注释掉。
- en: You can see how Go is loading the certificate pool for each system by looking
    through the `root_*.go` files in [https://golang.org/src/crypto/x509/](https://golang.org/src/crypto/x509/).
    For example, `root_windows.go` and `root_linux.go` load the system's default certificates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看 [https://golang.org/src/crypto/x509/](https://golang.org/src/crypto/x509/)
    中的 `root_*.go` 文件来了解 Go 如何为每个系统加载证书池。例如，`root_windows.go` 和 `root_linux.go` 加载系统的默认证书。
- en: 'If you wanted to connect to a server and inspect or store its certificate,
    you would connect and then inspect client''s `net.Conn.ConnectionState().PeerCertificates`.
    It comes in a standard `x509.Certificate` struct. To do so, refer to the following
    block of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想连接到服务器并检查或存储其证书，你可以连接后检查客户端的 `net.Conn.ConnectionState().PeerCertificates`。它以标准的
    `x509.Certificate` 结构体形式呈现。要做到这一点，请参考以下代码块：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other encryption packages
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他加密包
- en: There are no source code examples for the following sections, but they are worth
    mentioning. These packages provided by Go are built on top of the principles demonstrated
    in the previous examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分没有源代码示例，但值得一提。这些由 Go 提供的包是建立在前面示例中展示的原理之上的。
- en: OpenPGP
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenPGP
- en: PGP stands for **Pretty Good Privacy**, and OpenPGP is standard RFC 4880\. PGP
    is a convenient suite for encrypting text, files, directories, and disks. All
    the principles are the same as discussed in the previous section with SSL and
    TLS key/certificates. The encrypting, signing, and verification are all the same.
    Go provides an OpenPGP package. Read more about it at [https://godoc.org/golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PGP 代表 **Pretty Good Privacy**，而 OpenPGP 是标准 RFC 4880。PGP 是一套便捷的加密工具，适用于加密文本、文件、目录和磁盘。所有的原理与前一节讨论的
    SSL 和 TLS 密钥/证书相同。加密、签名和验证的方式都是一样的。Go 提供了一个 OpenPGP 包。阅读更多关于它的信息，访问 [https://godoc.org/golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp)。
- en: Off The Record (OTR) messaging
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**离线记录** (OTR) 消息传递'
- en: '**Off The Record** or **OTR** messaging is a form of end-to-end encryption
    for users to encrypt their communication over whatever message medium is being
    used. It is convenient because you can implement an encrypted layer over any protocol
    even if the protocol itself is unencrypted. For example, OTR messaging works over
    XMPP, IRC, and many other chat protocols. Many chat clients such as Pidgin, Adium,
    and Xabber have support for OTR either natively or via plugin. Go provides a package
    for implementing OTR messaging. Read more about Go''s OTR support at [https://godoc.org/golang.org/x/crypto/otr/](https://godoc.org/golang.org/x/crypto/otr/).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**离线记录** 或 **OTR** 消息传递是一种端到端加密的形式，允许用户通过任何消息媒介加密其通信。它很方便，因为你可以在任何协议上实现加密层，即使该协议本身没有加密。例如，OTR
    消息传递可以在 XMPP、IRC 和许多其他聊天协议上运行。许多聊天客户端如 Pidgin、Adium 和 Xabber 都支持 OTR，支持方式有原生支持或通过插件。Go
    提供了一个实现 OTR 消息传递的包。阅读更多有关 Go 的 OTR 支持信息，访问 [https://godoc.org/golang.org/x/crypto/otr/](https://godoc.org/golang.org/x/crypto/otr/)。'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: After reading this chapter, you should have a good understanding of what the
    Go cryptography packages are capable of. Using the examples given in this chapter
    as a reference, you should feel comfortable performing basic hash operations,
    encrypting, decrypting, generating keys, and using keys.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该对 Go 的加密包有一个清晰的了解。通过本章中的示例作为参考，你应该能够熟练进行基本的哈希操作、加密、解密、生成密钥以及使用密钥。
- en: Additionally, you should understand the difference between symmetric and asymmetric
    encryption, and how it is different from hashing. You should feel comfortable
    with the basics of running a TLS server and connecting with a TLS client.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还应该理解对称加密和非对称加密之间的区别，以及它们与哈希的不同。你应该对运行 TLS 服务器和连接 TLS 客户端的基本操作感到熟悉。
- en: Remember, the goal is not to memorize every detail, but to remember what options
    are available so that you can choose the best tool for the job.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标不是记住每个细节，而是记住有哪些选项可供选择，以便你能为任务选择最佳工具。
- en: In the next chapter, we will look at using secure shell, also known as SSH.
    Authenticating with public and private key pairs and passwords is covered first,
    along with how to verify the remote host's key. We will also look at how to execute
    commands on a remote server and how to create an interactive shell. Secure shell
    makes use of the encryption techniques discussed in this chapter. It is one of
    the most common and practical applications of encryption. Continue reading to
    learn more about using SSH in Go.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论如何使用安全外壳（SSH）。首先介绍如何使用公钥和私钥对以及密码进行身份验证，并讲解如何验证远程主机的密钥。我们还将探讨如何在远程服务器上执行命令以及如何创建交互式
    shell。安全外壳利用了本章中讨论的加密技术。它是加密技术最常见和最实用的应用之一。继续阅读以了解更多关于在 Go 中使用 SSH 的内容。
