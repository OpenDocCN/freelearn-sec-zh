- en: Chapter 12. Attacking CMS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章：攻击 CMS
- en: In this chapter, we will discuss attacking CMSs and WordPress in particular.
    It's hard to talk about web applications and not mention WordPress. WordPress
    is so common on the internet that you will likely come across many instances of
    it in your career. After all, almost a third of all websites are running on the
    platform and it is by far the most popular CMS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论攻击 CMS，特别是 WordPress。谈到 web 应用，几乎无法不提到 WordPress。WordPress 在互联网的普及程度如此之高，你可能在职业生涯中会遇到许多它的实例。毕竟，几乎三分之一的网站都在使用该平台，它无疑是最受欢迎的
    CMS。
- en: There are alternatives to WordPress, including Drupal, Joomla, and other more
    modern applications, such as Ghost. All of these frameworks aim to make content
    publishing on the web easy and hassle free. You don't need to know JavaScript,
    HTML, PHP, or any other technology to get going. CMSs are generally extensible
    through plugins and highly customizable through themes. What sets WordPress apart
    is the sheer volume of installs across the internet. You are far more likely to come
    across a WordPress blog than a Ghost blog, for example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 WordPress，还有 Drupal、Joomla 和其他一些更现代的应用程序，如 Ghost。所有这些框架的目标都是让在网上发布内容变得简单且无忧。你不需要知道
    JavaScript、HTML、PHP 或其他任何技术就能开始使用。CMS 通常可以通过插件扩展，并通过主题进行高度定制。WordPress 的特别之处在于，它在互联网上的安装量庞大。比如，你遇到一个
    WordPress 博客的几率，远高于遇到 Ghost 博客的几率。
- en: Attackers love WordPress because the very thing that sets it apart from the
    competition — a massive community — also makes it difficult to secure. The reason
    WordPress has the lion's share of the market is because users don't need technical
    expertise to operate a foodie blog, and therein lies the problem. Those same non-technical
    users are less likely to update plugins or apply core patches, let alone harden
    their WordPress instance, and will not stray from that baseline through the years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者喜欢 WordPress，因为正是它与竞争对手的区别——庞大的社区——使得它难以安全防护。WordPress 占据市场份额的原因在于，用户不需要技术专长就能运营一个美食博客，而这正是问题所在。那些同样没有技术背景的用户不太可能更新插件或应用核心补丁，更不可能强化他们的
    WordPress 实例，并且这些年下来，他们不会偏离这种基础设置。
- en: To be fair, auto-update has been added to WordPress as of version 3.7, but that
    is only effective if users actually update to version 3.7\. It should also be
    noted that even with auto-update functionality, for change management's sake,
    some companies may choose to opt out to maintain stability, at the expense of
    security.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，自动更新功能已经在 WordPress 3.7 版本中加入，但前提是用户实际上升级到 3.7 版本。还应该注意，即便有自动更新功能，出于变更管理的考虑，一些公司可能会选择关闭自动更新，以维持稳定性，牺牲安全性。
- en: Enterprises love WordPress and there are several companies that provide shared
    hosting and management as well. It's also not unusual to have someone in marketing
    set up a rogue instance that the security department is unaware of, and leave
    it running for years.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 企业喜欢 WordPress，许多公司提供共享托管和管理服务。也不罕见有市场部门的人设置了一个未经安全部门知晓的非法实例，并将其运行多年。
- en: It's easy to pick on WordPress, but Drupal and Joomla make great targets as
    well. They suffer from the same problems with vulnerable plugins and themes, and
    seldomly updated installations. WordPress is the Goliath and we will focus our
    attention on it, but the attack methodology will translate to any content management
    framework, albeit the tools may differ slightly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将 WordPress 作为攻击目标，但 Drupal 和 Joomla 也是不错的选择。它们同样面临着易受攻击的插件和主题问题，以及安装版本更新稀少的问题。WordPress
    是巨头，我们将重点关注它，但攻击方法同样适用于任何内容管理框架，尽管所用的工具可能略有不同。
- en: 'In the coming pages, we will look at WordPress attacks in depth and by the
    end, you should be comfortable with the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨 WordPress 攻击，最终你应该能掌握以下内容：
- en: Testing WordPress with various tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种工具测试 WordPress
- en: Setting up persistence within the WordPress code once you get access
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦获取访问权限，在 WordPress 代码中设置持久性
- en: Backdooring WordPress to harvest credentials and other interesting data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过后门进入 WordPress 以获取凭证和其他有价值的数据
- en: Application assessment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用评估
- en: 'Just as we''ve done with other applications, when we come across a WordPress
    or CMS instance, we have to do some reconnaissance: look for low-hanging fruit
    and try to understand what we''re up against. There are a few tools to get us
    going and we will look at a common scenario where they can help us to identify
    issues and exploit them.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对待其他应用程序一样，当我们遇到 WordPress 或 CMS 实例时，我们必须进行一些侦察：寻找低悬的果实，并试图理解我们面对的是什么。我们有一些工具可以帮助我们入门，我们将看一个常见的场景，了解它们如何帮助我们识别问题并进行利用。
- en: WPScan
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WPScan
- en: The first thing attackers reach for when they encounter a WordPress CMS application
    is usually WPScan. It is a well-built and frequently updated tool used to discover
    vulnerabilities and even guess credentials.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者遇到 WordPress CMS 应用程序时，通常首先会选择 WPScan。它是一个构建良好、经常更新的工具，用于发现漏洞甚至猜测凭证。
- en: 'WPScan has many useful features, including the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WPScan 具有许多有用的功能，包括以下内容：
- en: 'Plugin and theme enumeration:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件和主题枚举：
- en: Passive and active discovery
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动和主动发现
- en: Username enumeration
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名枚举
- en: Credential brute-forcing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭证暴力破解
- en: Vulnerability scanning
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞扫描
- en: A useful feature for assessments is the ability to pass all of its requests
    through a proxy, such as a local Burp Suite instance. This allows us to see the
    attack live and replay some of the payloads. During an engagement, this may be
    useful for recording activities and even passing in a polyglot or two.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于评估工作，一个有用的功能是可以将所有请求通过代理传递，例如通过本地的 Burp Suite 实例。这使我们能够实时查看攻击，并重放一些有效负载。在一次
    engagement 中，这对于记录活动，甚至传递一个或两个多用途的载荷可能非常有用。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using an upstream proxy with WPScan can generate a ton of data in Burp's proxy
    history, especially when performing a credential attack or active scan.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上游代理与 WPScan 配合使用时，可能会在 Burp 的代理历史中生成大量数据，特别是在进行凭证攻击或主动扫描时。
- en: 'Proxying our scan through Burp gives us some control over the outgoing connections:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Burp 代理我们的扫描可以让我们对外发出的连接有一些控制：
- en: '![WPScan](graphics/B09238_12_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![WPScan](graphics/B09238_12_01.jpg)'
- en: 'Figure 12.1: Burp capturing WPScan web requests'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：Burp 捕获 WPScan 网络请求
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default user agent (WPScan vX.X.X) can be changed with the `--user-agent`
    switch or randomized with `--random-agent`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的用户代理（WPScan vX.X.X）可以通过 `--user-agent` 开关进行更改，或通过 `--random-agent` 随机化。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'WPScan is available on Kali and most penetration testing distributions. It can
    also be found on [https://wpscan.org/](https://wpscan.org/) or cloned from GitHub:
    [https://github.com/wpscanteam/wpscan](https://github.com/wpscanteam/wpscan).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: WPScan 可以在 Kali 和大多数渗透测试发行版中找到。它还可以在[https://wpscan.org/](https://wpscan.org/)找到，或从
    GitHub 克隆：[https://github.com/wpscanteam/wpscan](https://github.com/wpscanteam/wpscan)。
- en: 'A typical engagement begins with a passive scan of the target using the `--url`
    parameter. The following command will launch a default scan on the `cookingwithfire.local`
    test blog:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一次典型的 engagement 从使用 `--url` 参数对目标进行被动扫描开始。以下命令将对 `cookingwithfire.local` 测试博客进行默认扫描：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At first glance, it appears there isn't much we can use for exploitation. There
    is a full-path disclosure vulnerability, which may come in handy if we need to
    find a place to drop a shell, for example. The **denial-of-service** (**DoS**)
    bug is not very interesting, as the majority of clients will not allow this type
    of exploitation, but it may be good to mention in the report as a possible route
    for disruption.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 初步看起来，似乎没有太多可用于利用的东西。存在一个完整路径泄露漏洞，如果我们需要找到一个放置 shell 的地方，这可能会派上用场。**拒绝服务**（**DoS**）漏洞不太有趣，因为大多数客户端不会允许这种类型的利用，但在报告中提到它作为一种可能的破坏路线可能是有益的。
- en: By default, WPScan performs a passive enumeration of plugins. This basically
    means that it will only detect a plugin if it is referenced somewhere on the site.
    If a plugin is disabled or more inconspicuous, we may need to execute an active
    enumeration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WPScan 会对插件进行被动枚举。这基本意味着它只会检测到在站点某处引用的插件。如果插件被禁用或更加隐蔽，可能需要执行主动枚举。
- en: Active scans will test whether known plugin files are present in the `wp-content`
    folder and alert on any existing vulnerabilities. This is done by sending a ton
    of URL requests to known paths and if there's a response, WPScan assumes the plugin
    is available.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主动扫描将测试是否已知的插件文件存在于 `wp-content` 文件夹中，并对任何已存在的漏洞发出警报。通过向已知路径发送大量 URL 请求来实现这一点，如果有响应，WPScan
    会假定插件是可用的。
- en: 'To specify the type of scan we want to conduct, the `--enumerate` (`-e` for
    short) switch accepts several parameters for active detection:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定我们要进行的扫描类型，`--enumerate`（简写为 `-e`）开关接受多个用于主动检测的参数：
- en: '`u` – Look for usernames with IDs from 1 to 10'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u` – 查找 ID 从 1 到 10 的用户名'
- en: '`u[10-20]` – Look for usernames with IDs from 10 to 20: `--enumerate u[15]`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u[10-20]` – 查找 ID 从 10 到 20 的用户名：`--enumerate u[15]`'
- en: '`p` – Look for popular plugins'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` – 查找流行的插件'
- en: '`vp` – Show me only vulnerable plugins'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vp` – 仅显示易受攻击的插件'
- en: '`ap` – Look for all known plugins'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ap` – 查找所有已知的插件'
- en: '`tt` – Search for timthumbs'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tt` – 搜索 timthumbs'
- en: '`t` – Enumerate popular themes'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` – 枚举流行的主题'
- en: '`vt` – Show me only vulnerable themes'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vt` – 仅显示易受攻击的主题'
- en: '`at` – Look for all known themes'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at` – 查找所有已知的主题'
- en: 'You can also provide multiple `--enumerate` (or `-e`) switches to enumerate
    themes, plugins, and usernames all in one shot. For example, this combination
    of switches will perform a fairly thorough scan:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供多个 `--enumerate`（或 `-e`）开关，一次枚举主题、插件和用户名。例如，以下开关组合将执行一次相当彻底的扫描：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s go ahead and start an active enumeration of available plugins on our
    target:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续开始对目标进行可用插件的主动枚举：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It appears **Google Document Embedder** was enumerated successfully and there
    are several critical vulnerabilities with proof of concept code publicly available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 **Google Document Embedder** 已经成功枚举，并且有几个具有公开可用概念验证代码的严重漏洞。
- en: The SQLi flaw tagged with `CVE-2014-9173` has a PoC on [https://www.exploit-db.com](https://www.exploit-db.com),
    which on Kali can be queried locally through `searchsploit`. This is a simple
    tool that searches the Kali local directory `/usr/share/exploitdb/`. This folder
    is frequently mirrored to the online database and it's useful in environments
    where maybe the internet is not easily accessible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为 `CVE-2014-9173` 的 SQLi 漏洞在 [https://www.exploit-db.com](https://www.exploit-db.com)
    上有 PoC，Kali 上可以通过 `searchsploit` 本地查询。这个简单的工具可以搜索 Kali 本地目录 `/usr/share/exploitdb/`，该文件夹经常被镜像到在线数据库，并且在互联网不易访问的环境中非常有用。
- en: 'We can invoke `searchsploit` from the command-line with a search query as the
    first parameter, as shown:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行调用 `searchsploit`，并将搜索查询作为第一个参数，如下所示：
- en: '![WPScan](graphics/B09238_12_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![WPScan](graphics/B09238_12_02.jpg)'
- en: 'Figure 12.2: searchsploit results for Google Document Embedder'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：Google Document Embedder 的 searchsploit 结果
- en: '`searchsploit` will list the `Exploit Title` and the associated `Path`, which
    is relative to `/usr/share/exploitdb/` on Kali distributions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchsploit` 将列出 `Exploit Title` 和相关的 `Path`，该路径相对于 Kali 发行版中的 `/usr/share/exploitdb/`。'
- en: In the PoC document `/usr/share/exploitdb/exploits/php/webapps/35371.txt`, researcher
    Kacper Szurek identifies the `gpid` URL parameter in the `wp-content/plugins/google-document-embedder/view.php`
    plugin file as the injection point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PoC 文档 `/usr/share/exploitdb/exploits/php/webapps/35371.txt` 中，研究员 Kacper
    Szurek 识别了 `wp-content/plugins/google-document-embedder/view.php` 插件文件中的 `gpid`
    URL 参数作为注入点。
- en: sqlmap
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sqlmap
- en: In order to confirm this vulnerability in our target, we can jump to sqlmap,
    the de facto SQLi exploitation tool. sqlmap will help us to quickly generate payloads
    to test for injection in all of the popular **Database Management Systems** (**DBMS**),
    such as MySQL, PostgreSQL, MS SQL, and even Microsoft Access. To launch a new
    sqlmap session, we pass our full target URL via the `-u` parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们目标中的此漏洞，我们可以转到 sqlmap，这是一款事实上的 SQL 注入（SQLi）利用工具。sqlmap 可以帮助我们快速生成有效载荷，以测试流行的**数据库管理系统**（**DBMS**），如
    MySQL、PostgreSQL、MS SQL 甚至 Microsoft Access。要启动新的 sqlmap 会话，我们通过 `-u` 参数传递完整的目标
    URL。
- en: Notice that the target URL includes the `GET` query parameters as well, with
    some dummy data. If we don't tell sqlmap to target `gpid`, it will check every
    other parameter for injection as well. It makes for a great SQLi discovery, not
    just exploitation. Thanks to our `searchsploit` query, we know `gpid` is the vulnerable
    parameter and we can focus our attack on it specifically, with the `-p` parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目标 URL 包含 `GET` 查询参数，并带有一些虚拟数据。如果我们不告诉 sqlmap 目标 `gpid`，它将检查其他所有参数的注入情况。这不仅对
    SQLi 漏洞发现很有帮助，对漏洞利用也是一个很好的工具。得益于我们的 `searchsploit` 查询，我们知道 `gpid` 是易受攻击的参数，因此可以专注于对其进行攻击，使用
    `-p` 参数。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After a few minutes, sqlmap detects the backend to be MySQL and we can tell
    it to only check MySQL payloads against our target. This will greatly improve
    our chances of confirming the vulnerability.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，sqlmap 检测到后端是 MySQL，我们可以指示它仅针对目标检查 MySQL 有效载荷。这将大大提高我们确认漏洞的机会。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the remaining tests, sqlmap will confirm the existence of the vulnerability
    and save the state locally. Subsequent attacks on the target will use the identified
    payload as a starting point to inject SQL statements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的测试，sqlmap将确认漏洞的存在并将状态保存到本地。对目标的后续攻击将使用已识别的有效载荷作为起点来注入SQL语句。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to test this vulnerable plugin in your own WordPress instance, you
    can download version 2.5 of the Google Document Embedder plugin from [https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1](https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在自己的WordPress实例中测试这个有漏洞的插件，可以从[https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1](https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1)下载版本2.5的Google
    Document Embedder插件。
- en: Droopescan
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Droopescan
- en: Although not as fully-featured as WPScan, droopescan does support more than
    just WordPress as a scanning target. It is ideal for Drupal instances and it can
    also do some basic scanning for Joomla.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有WPScan那样功能全面，droopescan的扫描目标不止是WordPress。它非常适合Drupal实例，也可以对Joomla做一些基本的扫描。
- en: 'Droopescan can be cloned from GitHub and quickly installed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Droopescan可以从GitHub克隆并快速安装：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once extracted, we can install the dependencies manually using `pip` and passing
    in the `requirements.txt` option to `-r`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提取，我们可以手动使用`pip`安装依赖项，并通过`-r`参数传入`requirements.txt`选项：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Droopescan can also be installed globally using the `setup.py` script and the
    `install` parameter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Droopescan还可以使用`setup.py`脚本和`install`参数进行全局安装：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To assess an application, droopescan can be launched with the `scan drupal`
    options and the target can be specified with the `-u` parameter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估一个应用程序，可以使用`scan drupal`选项启动droopescan，并使用`-u`参数指定目标：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This tool is a great start when looking at breaking into a Drupal, WordPress,
    or Joomla instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是入门了解Drupal、WordPress或Joomla实例时的好选择。
- en: Arachni web scanner
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arachni Web扫描器
- en: '**Arachni** is a bit different from the more specialized tools discussed earlier.
    It is a full-featured modular framework with the capability of distributing scans
    through remote agents. When it is properly configured, it can be a powerful first
    step in assessing applications.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arachni**与之前讨论的更专业的工具有所不同。它是一个功能齐全的模块化框架，具有通过远程代理分发扫描的能力。经过正确配置后，它可以成为评估应用程序的强大第一步。'
- en: Arachni is free and open-source, and easily installed. It can be controlled
    via an easy-to-use web user interface or via the command-line. The framework can
    also be used to find HTML5 and Document Object Model vulnerabilities, which traditional
    scanners may miss.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni是免费的开源软件，并且容易安装。它可以通过一个易于使用的Web用户界面或通过命令行进行控制。该框架还可以用于发现HTML5和文档对象模型漏洞，传统的扫描器可能会遗漏这些漏洞。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Arachni pre-compiled binaries can be found on [http://www.arachni-scanner.com/](http://www.arachni-scanner.com/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni的预编译二进制文件可以在[http://www.arachni-scanner.com/](http://www.arachni-scanner.com/)找到。
- en: Once extracted to disk, we have to create a user to be able to log onto the
    web interface. The `arachni_web_create_user` helper utility can be found in the
    `bin` folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提取到磁盘上，我们需要创建一个用户才能登录到Web界面。`arachni_web_create_user`辅助工具可以在`bin`文件夹中找到。
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take care to clear your shell history if this is a production installation of Arachni.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是Arachni的生产环境安装，请小心清除你的Shell历史记录。
- en: 'The web interface is launched using the `arachni_web` script in the same folder:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Web界面通过同一文件夹中的`arachni_web`脚本启动：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The web user interface runs on `http://localhost:9292` by default. Here we can
    initiate a new scan immediately or schedule it for later. We can also create a
    scan profile or interact with a remote agent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Web用户界面默认运行在`http://localhost:9292`。在这里，我们可以立即启动新的扫描，也可以将其安排在稍后进行。我们还可以创建扫描配置文件或与远程代理进行交互。
- en: 'Arachni comes with three scanning profiles by default:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni默认提供三个扫描配置文件：
- en: Default
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认
- en: Cross-Site Scripting (XSS)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）
- en: SQL injection
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入
- en: The Default profile performs a variety of checks and looks for interesting files
    and low-hanging fruit. XSS and SQL injection are more focused profiles for the
    two vulnerability types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置文件执行多种检查，并寻找有趣的文件和容易被发现的漏洞。XSS和SQL注入是针对这两种漏洞类型的更聚焦的配置文件。
- en: 'To launch a new scan using the web UI, select **New** under **Scans**, as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Web UI启动新的扫描，请在**扫描**下选择**新建**，如图所示：
- en: '![Arachni web scanner](graphics/B09238_12_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Arachni Web扫描器](graphics/B09238_12_03.jpg)'
- en: 'Figure 12.3: Starting a new Arachni scan'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：启动一个新的Arachni扫描
- en: 'We can also follow along as the scan is running by looking at the **Scans**
    page. The following figure shows a sample scan running against `jimsblog.local`,
    a WordPress installation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在扫描运行时查看 **扫描** 页面，跟踪进度。以下图示展示了一个针对 `jimsblog.local`，即一个 WordPress 安装的示例扫描：
- en: '![Arachni web scanner](graphics/B09238_12_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Arachni 网络扫描器](graphics/B09238_12_04.jpg)'
- en: 'Figure 12.4: Arachni scan running'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：Arachni 扫描正在运行
- en: 'Issues are listed below the scan status as they are found, but a more complete
    report is available once the scan completes. Under the **Issues** section, we
    can see what Arachni has discovered, as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 问题会在扫描状态下列出，随着它们的发现。但一旦扫描完成，完整的报告将提供。在 **问题** 部分，我们可以看到 Arachni 发现的内容，如下所示：
- en: '![Arachni web scanner](graphics/B09238_12_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Arachni 网络扫描器](graphics/B09238_12_05.jpg)'
- en: 'Figure 12.5: Issues identified by Arachni'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：Arachni 发现的问题
- en: The SQL injection scan profile in Arachni can also be used in a scan to verify
    the issue we found earlier with WPScan, in the `cookingwithfire.local` blog. This particular
    profile should complete much faster than the default scan.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni 中的 SQL 注入扫描配置文件也可以用于扫描，验证我们之前通过 WPScan 发现的问题，在 `cookingwithfire.local`
    博客中。这个特定的配置文件应该比默认扫描完成得更快。
- en: '![Arachni web scanner](graphics/B09238_12_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Arachni 网络扫描器](graphics/B09238_12_06.jpg)'
- en: 'Figure 12.6: SQL injection found by Arachni'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：Arachni 发现的 SQL 注入
- en: The keen eye will notice that Arachni found a time-based blind SQL injection
    where sqlmap was able to confirm the vulnerability using an error-based technique.
    Technically, both techniques can be used to exploit this particular application,
    but the error-based technique is preferred. Time-based injection attacks are inherently
    slow. If Arachni finds a time-based blind SQL injection vulnerability, it may
    be a good idea to aim sqlmap at the same URL and see whether anything more reliable
    can be identified.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到，Arachni 发现了一个基于时间的盲 SQL 注入，sqlmap 使用基于错误的技术确认了这个漏洞。从技术上讲，两种技术都可以用来利用这个特定应用程序，但基于错误的技术是首选。基于时间的注入攻击本身速度较慢。如果
    Arachni 发现了一个基于时间的盲 SQL 注入漏洞，可能是个好主意，将 sqlmap 定向到相同的 URL，看看是否能识别出更可靠的信息。
- en: Backdooring the code
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后门化代码
- en: Once we obtain some access to a CMS instance, such as WordPress, Drupal, or
    Joomla, there are a couple of ways to persist or even escalate privileges horizontally
    or vertically. We can inject malicious PHP code, which will allow us to gain shell
    access at will. Code execution is great, but in some scenarios, we don't necessarily
    need it. There are other ways to exploit the application. Alternatively, we can
    modify the CMS core files to capture credentials in cleartext as users and administrators
    log in.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了对 CMS 实例的访问权限，例如 WordPress、Drupal 或 Joomla，就有几种方式可以持续保持或甚至水平或垂直提升权限。我们可以注入恶意
    PHP 代码，这将允许我们随时获得 Shell 访问权限。代码执行非常强大，但在某些情况下，我们不一定需要它。还有其他方式可以利用该应用程序。或者，我们可以修改
    CMS 核心文件，以便在用户和管理员登录时捕获明文凭证。
- en: Both of these techniques require some kind of elevated privilege and that begs
    the question, why bother if we already have this type of access to the website?
    We'll look at a couple of situations where backdooring may help our engagement.
    If we have administrative access to the WordPress instance but no shell access,
    we can leverage the UI to spawn a reverse shell and persist access, should the
    password reset. If we have standard user shell access but not much else, capturing
    credentials in cleartext may be a great way to move laterally or escalate privileges.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都需要某种提升的权限，这就引出了一个问题：如果我们已经拥有这种类型的访问权限，为什么还要费力做这些呢？我们将探讨几种情况，在这些情况下，后门可能有助于我们的渗透测试。如果我们对
    WordPress 实例有管理员访问权限，但没有 Shell 访问权限，我们可以利用 UI 创建反向 Shell 并保持访问权限，以防密码被重置。如果我们有标准用户的
    Shell 访问权限，但没有其他权限，捕获明文凭证可能是横向移动或提升权限的好方法。
- en: Persistence
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: When attacking CMS installations, such as WordPress, we may find ourselves with
    administrative credentials in hand. Maybe we successfully enumerated users with
    WPScan and subsequently brute-forced credentials for a privileged user. This is
    more common than you'd expect, especially in environments where WordPress is either
    temporarily stood up for development purposes or just brought up and forgotten.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击 CMS 安装时，例如 WordPress，我们可能已经获得了管理员凭证。也许我们通过 WPScan 成功列出了用户，然后暴力破解了特权用户的凭证。这比你想象的要常见，尤其是在
    WordPress 临时搭建用于开发的环境中，或者只是被搭建起来后就被遗忘了。
- en: 'Let''s explore this scenario using the `--enumerate u` option for `wpscan`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `wpscan` 的 `--enumerate u` 选项来探讨这个场景：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The results show us at least two users that we can target for a login brute-force
    attack. WPScan can brute-force the credentials for a particular account using
    the `--usernames` switch and a wordlist provided by `--passwords`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示至少有两个我们可以针对其进行登录暴力破解攻击的用户。WPScan 可以通过 `--usernames` 参数和 `--passwords` 提供的字典文件进行某个账户的凭证暴力破解。
- en: For this attack, we will use SecLists' `rockyou-10.txt` wordlist and we'll target
    `mary`. As before, we can invoke `wpscan` with the `--url` parameter, then we
    will specify a username and point the `passwords` parameter to the `rockyou-10.txt`
    file from SecLists.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次攻击，我们将使用 SecLists 的 `rockyou-10.txt` 字典，并将目标设置为 `mary`。像之前一样，我们可以通过 `--url`
    参数调用 `wpscan`，然后指定一个用户名，并将 `passwords` 参数指向 SecLists 的 `rockyou-10.txt` 文件。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After a short while, the credentials for `mary` are confirmed and we are free
    to login as this user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻后，`mary` 的凭证得到确认，我们可以自由地以该用户身份登录。
- en: Logging in through the WordPress UI, we notice `mary` has elevated access to
    the blog. We can use this account to spawn a reverse shell, which will give us
    access to the underlying operating system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 WordPress UI 登录时，我们注意到 `mary` 对博客具有更高的访问权限。我们可以利用这个账户启动反向 shell，从而获得对底层操作系统的访问权限。
- en: We can accomplish this easily through either Metasploit or through the administrative
    panel itself. The Metasploit method is a bit noisy and if it fails, it may leave
    behind artifacts that could alert administrators if not cleaned up in time. In
    some situations, stealth is not paramount, however, and this module will work
    just fine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Metasploit 或通过管理员面板本身轻松实现这一点。Metasploit 方法稍显嘈杂，如果失败，它可能会留下遗留物，如果没有及时清理，可能会引起管理员警觉。然而，在某些情况下，隐蔽性并不是最重要的，这个模块仍然能够正常工作。
- en: The Metasploit module `wp_admin_shell_upload` will connect to the WordPress
    site and authenticate with the credentials we've just discovered. It will proceed
    to upload a malicious plugin, which will spawn a reverse Meterpreter shell to
    our attack machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 模块 `wp_admin_shell_upload` 将连接到 WordPress 网站，并使用我们刚刚发现的凭证进行身份验证。它将继续上传一个恶意插件，启动一个反向
    Meterpreter shell 并返回到我们的攻击机器。
- en: 'On our Kali instance, as before, we can launch the Metasploit interface using
    the `msfconsole` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Kali 实例上，像之前一样，我们可以通过 `msfconsole` 命令启动 Metasploit 界面：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s load the `wp_admin_shell_upload` exploit with the Metasploit `use` command,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Metasploit 的 `use` 命令加载 `wp_admin_shell_upload` 漏洞，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are a few options we need to fill in with the right information before
    we can launch the exploit and hopefully get a shell back.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够启动漏洞并希望能够拿到 shell 之前，有一些选项需要填入正确的信息。
- en: 'Let''s execute the `exploit` module using the `run` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `run` 命令执行 `exploit` 模块：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It appears the module ran successfully and spawned a Meterpreter session back
    to our attack machine. Metasploit has dropped in the `meterpreter` prompt and
    now we can issue commands on the target machine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来该模块成功运行并启动了一个反向 Meterpreter 会话返回到我们的攻击机器。Metasploit 已经显示了 `meterpreter` 提示符，现在我们可以在目标机器上执行命令。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we do have access, there is a problem with this shell. It does not persist.
    If the server is restarted, the Meterpreter session will drop. If `mary` changes
    their password, we will lose access to the application altogether.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们确实有访问权限，但这个 shell 存在一个问题。它不会保持持久性。如果服务器重启，Meterpreter 会话将会中断。如果 `mary` 更改了密码，我们将完全失去对应用程序的访问权限。
- en: We have to get a bit more creative to maintain our access to the site. Thankfully,
    since it is so customizable, WordPress provides a file editor for plugins and
    themes. If we can modify a theme file and inject reverse shell code, every time
    we call it via the web, we will have access. If the administrator password changes
    tomorrow, we can still get back on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更具创意地保持对站点的访问。幸运的是，由于 WordPress 是如此可定制，提供了插件和主题的文件编辑器。如果我们能够修改主题文件并注入反向
    shell 代码，每次通过 Web 调用它时，我们将拥有访问权限。如果管理员明天更改了密码，我们仍然可以重新登录。
- en: In the WordPress admin panel, the **Themes** section links to an **Editor**,
    which can be used to modify PHP files belonging to any themes installed. It's
    a good idea to pick a theme that is disabled, in case we modify a file that is
    frequently accessed and users notice something is wrong.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WordPress 管理面板中，**主题** 部分链接到 **编辑器**，可以用来修改任何已安装主题的 PHP 文件。最好选择一个已禁用的主题，以防我们修改的是一个频繁访问的文件，用户会注意到有问题。
- en: Twenty Seventeen is the default WordPress theme and in this installation, it
    is not the primary theme. We can modify the `404.php` page and inject our code
    in there without alerting anyone.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Twenty Seventeen 是 WordPress 的默认主题，在此安装中，它不是主要主题。我们可以修改 `404.php` 页面并在其中注入我们的代码，而不会引起任何人的注意。
- en: '![Persistence](graphics/B09238_12_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![持久化](graphics/B09238_12_07.jpg)'
- en: 'Figure 12.7: WordPress theme file editor'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：WordPress 主题文件编辑器
- en: We can generate a new PHP reverse shell using Metasploit by loading the `payload/php/meterpreter/reverse_tcp
    payload` module. The `LHOST` option should match our local hostname or IP, and
    the `LPORT` will be a local port for Metasploit to listen for incoming reverse
    shells. The target, once exploited, will connect back to us on this port.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过加载 `payload/php/meterpreter/reverse_tcp payload` 模块来使用 Metasploit 生成一个新的
    PHP 反向 shell。`LHOST` 选项应该与我们的本地主机名或 IP 匹配，而 `LPORT` 将是 Metasploit 用来监听传入反向 shell
    的本地端口。一旦目标被利用，它将通过这个端口回连给我们。
- en: 'In the Metasploit console, we can load it with the `use` command, as we did
    before:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Metasploit 控制台中，我们可以使用 `use` 命令加载它，就像之前一样：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The payload `php/meterpreter/reverse_tcp` is a Meterpreter stager written in
    PHP and while it's not ideal from a stability standpoint, it does provide us with
    most of the functionality of a typical Meterpreter reverse shell.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷 `php/meterpreter/reverse_tcp` 是一个用 PHP 编写的 Meterpreter 暂存器，尽管从稳定性角度来看它并不理想，但它确实提供了典型
    Meterpreter 反向 shell 的大部分功能。
- en: When loading a payload within Metasploit, as opposed to generating one with
    the MSFvenom tool, we have the `generate` command available to us. This command
    can show us all the options available for creating a new payload.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Metasploit 中加载有效载荷时，与使用 MSFvenom 工具生成有效载荷不同，我们可以使用`generate`命令。该命令可以显示创建新有效载荷的所有可用选项。
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For a PHP payload, not many of these switches will have an impact. We can generate
    the raw payload, which would be the PHP code for the stager. We don't have to
    write it to a file; it's typically fairly small and we can copy it straight from
    the terminal output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PHP 有效载荷，这些选项中的大多数不会产生影响。我们可以生成原始有效载荷，它就是暂存器的 PHP 代码。我们不需要将其写入文件；它通常非常小，我们可以直接从终端输出中复制。
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result of the `generate` command is a long, minified piece of PHP code,
    which we can further obfuscate by encoding it to Base64 using the `-E` switch:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate` 命令的结果是一个很长的、被压缩的 PHP 代码片段，我们可以通过使用 `-E` 选项将其编码为 Base64 进一步混淆：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It really depends on what the injection point allows. We may need to Base64-encode
    the staging PHP code in order to bypass some rudimentary intrusion detection system
    or antivirus agent. If anyone looks at the source, an encoded payload does look
    a bit more suspicious among properly formatted code, so we'd have to really consider
    how stealthy we want to be.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上取决于注入点的允许范围。我们可能需要对暂存的 PHP 代码进行 Base64 编码，以绕过一些基础的入侵检测系统或杀毒软件。如果有人查看源代码，编码后的有效载荷在格式正确的代码中确实看起来更可疑，因此我们需要仔细考虑我们想要多隐蔽。
- en: To make sure our code blends in more with the rest of the `404.php` page, we
    can use a source code beautifier like **CyberChef**. Let's take the non-Base64-encoded
    raw PHP code and run it through the CyberChef tool.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的代码更好地与 `404.php` 页面中的其他内容融合，我们可以使用源代码美化器，如**CyberChef**。我们将未进行 Base64
    编码的原始 PHP 代码输入并通过 CyberChef 工具处理。
- en: 'On the **Recipe** pane, we can add the **Generic Code Beautify** operation.
    Our raw PHP code will go in the **Input** section. To beautify our code, we simply
    have to click **Bake!** at the bottom of the screen, as shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Recipe** 面板中，我们可以添加 **Generic Code Beautify** 操作。我们的原始 PHP 代码将放入 **Input**
    部分。要美化代码，我们只需要点击屏幕底部的 **Bake!**，如图所示：
- en: '![Persistence](graphics/B09238_12_08.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![持久化](graphics/B09238_12_08.jpg)'
- en: 'Figure 12.8: CyberChef code beautifier'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8：CyberChef 代码美化器
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: CyberChef is a great tool with a ton of features. Code beautification is just
    scratching the surface of what it can do. CyberChef is developed by GCHQ and available
    for free to use online or to download at [https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CyberChef 是一款非常棒的工具，具有众多功能。代码美化只是它能做的事情的冰山一角。CyberChef 由 GCHQ 开发，并可免费在线使用或下载，网址为：[https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef)
- en: At this point, we can grab the beautified payload and paste it right into the
    WordPress theme editor. We need to add the code immediately before the `get_header()`
    function is called. This is because `404.php` was meant to be `include()`-d in
    another page that loads the definition for this function. When we call the `404`
    page directly, `get_header()` will not be defined and PHP will throw a fatal error.
    Our shell code will not be executed. We have to be aware of these types of issues
    when we are modifying anything on the target. Ideally, if time permits, we setup
    a similar test environment and check to see how the application handles our modifications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以获取美化后的负载并直接将其粘贴到WordPress主题编辑器中。我们需要将代码添加到`get_header()`函数调用之前。这是因为`404.php`本应在另一个页面中通过`include()`加载，而该页面加载了此函数的定义。当我们直接调用`404`页面时，`get_header()`将未定义，PHP将抛出致命错误。我们的Shell代码将无法执行。我们在修改目标内容时必须注意这些问题。理想情况下，如果时间允许，我们会设置一个类似的测试环境，检查应用程序如何处理我们的修改。
- en: 'The Meterpreter payload will fit nicely just above the `get_header()` function
    on line 12, as shown:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter负载将非常适合在第12行的`get_header()`函数上方，如下所示：
- en: '![Persistence](graphics/B09238_12_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![持久化](graphics/B09238_12_09.jpg)'
- en: 'Figure 12.9: 404.php page editor payload injection location'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：404.php页面编辑器负载注入位置
- en: Adding the code in this location should prevent any PHP errors from interfering
    with our malicious code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个位置添加代码应该可以防止任何PHP错误干扰我们的恶意代码。
- en: '![Persistence](graphics/B09238_12_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![持久化](graphics/B09238_12_10.jpg)'
- en: 'Figure 12.10: Our malicious payload blending in with the rest of 404.php'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10：我们的恶意负载与其他的404.php文件融为一体
- en: Before we execute the backdoor that we've just injected, we have to make sure
    we have a handler running on our attack machine to grab the incoming connections
    from the victim.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行我们刚刚注入的后门之前，我们必须确保在我们的攻击机器上运行处理程序，以便接收来自受害者的连接。
- en: 'To do this, we load the `exploit/multi/handler` module in the Metasploit console
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们在Metasploit控制台中加载`exploit/multi/handler`模块，如下所示：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to specify which payload type the handler should be configured for
    using the `set PAYLOAD` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`set PAYLOAD`命令指定处理程序应该为哪种负载类型进行配置：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have to make sure the payload options match what we chose when we generated
    the PHP code earlier. Both of these options can also be configured with the `set`
    command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保负载选项与我们之前生成PHP代码时选择的选项匹配。这两个选项也可以通过`set`命令配置：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can also configure the handler to accept multiple connections and run in
    the background. New sessions will be created automatically; we wouldn't have to
    run the handler every time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置处理程序以接受多个连接并在后台运行。新会话将自动创建；我们不需要每次都运行处理程序。
- en: 'The `ExitOnSession` options can be set to `false` as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExitOnSession`选项可以设置为`false`，如下所示：'
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now run the handler with the `-j` option, which will send it to the
    background, ready for incoming connections from our victim:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行带有`-j`选项的处理程序，这将把它发送到后台，准备接受来自受害者的连接：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The backdoored `404.php` file is located in the `wp-content/themes/twentyseventeen/`
    folder on the target application and can be called directly with `curl`. This
    will execute our backdoor and spawn a new Meterpreter session:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 被植入后门的`404.php`文件位于目标应用程序的`wp-content/themes/twentyseventeen/`文件夹中，可以直接通过`curl`调用。这将执行我们的后门并生成一个新的Meterpreter会话：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `cur`l command appears to hang, but a few seconds later, we have shell
    access. We can see the victim establishing a Meterpreter session, which we can
    interact with using the `sessions -i` command, as shown:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令似乎会挂起，但几秒钟后，我们获得了Shell访问权限。我们可以看到受害者建立了一个Meterpreter会话，我们可以使用`sessions
    -i`命令与之交互，如下所示：'
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once again, we can issue commands directly to the target through the Meterpreter
    session:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过Meterpreter会话直接向目标发出命令：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With shell access, we can attempt to escalate privileges, move laterally, or
    even extract more credentials.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Shell访问，我们可以尝试提升权限、横向移动，甚至提取更多的凭证。
- en: Credential exfiltration
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证外泄
- en: Consider another scenario where we have exploited a vulnerability in the website,
    granting us shell access to the server. Maybe the WordPress site itself is patched
    and user passwords are complex, but if the WordPress installation is hosted on
    a shared system, it is not uncommon for attackers to gain shell access through
    an unrelated component of the site. Perhaps we managed to upload a web shell or
    even force the web server to spawn a reverse shell back to our machine through
    a command injection flaw. In the earlier scenario, we had guessed the password
    of `mary`, but what if we wanted more? What if the blog owner `msmith` has access
    to other systems?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设想另一种情况，我们已经利用网站的一个漏洞，获得了对服务器的 shell 访问权限。也许 WordPress 网站本身已经打了补丁，且用户密码很复杂，但如果
    WordPress 安装在共享系统上，攻击者通过与网站无关的组件获得 shell 访问权限并不罕见。也许我们设法上传了一个 Web Shell，甚至通过命令注入漏洞迫使
    Web 服务器反向连接回我们的机器。在之前的场景中，我们猜到了 `mary` 的密码，但如果我们想要更多呢？如果博客管理员 `msmith` 有权限访问其他系统呢？
- en: Password reuse is a problem that likely will not go away anytime soon and there
    is value in grabbing the site administrator's password. The same password could
    work for VPN or OWA, or even the root user on the application server itself.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 密码重用是一个可能不会很快消失的问题，获取站点管理员的密码具有重要价值。相同的密码可能适用于 VPN 或 OWA，甚至是应用服务器上的 root 用户。
- en: Most modern web server software, such as Apache2, NGINX, and IIS, runs applications
    with a low-privileged user context and thus a PHP shell would have limited access
    to the underlying server. While the web user can't do much to the server itself,
    it can interact with the site source code, including that of the CMS instance.
    We may look for ways to escalate privilege using a local exploit, but if unsuccessful
    or strapped for time, it may make more sense to backdoor the site code and collect
    credentials.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代 Web 服务器软件，如 Apache2、NGINX 和 IIS，都以低权限用户身份运行应用程序，因此 PHP Shell 对底层服务器的访问权限有限。虽然
    Web 用户无法对服务器本身做太多操作，但它可以与站点源代码交互，包括 CMS 实例的源代码。我们可能会寻找使用本地漏洞提升权限的方法，但如果不成功或时间紧迫，可能更合理的做法是对站点代码后门并收集凭证。
- en: 'In the previous scenario, we have gained shell access through the user `mary`.
    Once inside, we can inspect the `wp-config.php` for potential locations for injection.
    We can see the database credentials that WordPress requires to function properly.
    This could be our first target, since all WordPress credentials are stored there,
    albeit hashed. If we can retrieve these hashed passwords, we may be able to crack
    them offline. Configuration files are common for CMSs and if we have read access
    to the application server, these should be one of the first things we harvest:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的场景中，我们通过用户 `mary` 获得了 shell 访问权限。进入后，我们可以检查 `wp-config.php` 文件，寻找可能的注入位置。我们可以看到
    WordPress 正常运行所需的数据库凭证。这可能是我们的第一个目标，因为所有 WordPress 凭证都存储在那里，尽管是哈希化的。如果我们能提取到这些哈希密码，可能可以离线破解它们。配置文件对于
    CMS 来说是常见的，如果我们有读取应用服务器的权限，这些文件应该是我们首批收集的目标：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We could grab these plaintext credentials and connect to the database using
    a MySQL client. We can then proceed to dump the user table and any hashes within.
    In your travels, you will likely come across more hardened MySQL instances, which
    typically will not allow login from just any remote host. The MySQL instance may
    also be firewalled or only listening on `127.0.0.1` and we may not be able to
    connect from the outside.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取这些明文凭证，并使用 MySQL 客户端连接到数据库。接下来，我们可以转储用户表和其中的任何哈希值。在你进行渗透测试时，你可能会遇到更多强化过的
    MySQL 实例，这些实例通常不允许来自任何远程主机的登录。MySQL 实例也可能被防火墙保护，或只监听 `127.0.0.1`，我们可能无法从外部进行连接。
- en: 'To get around these types of restrictions, we''d have to pivot the connection
    through our reverse shell session, which we''ve established earlier:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这些限制，我们必须通过先前建立的反向 Shell 会话来转发连接：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we need to add a route in Metasploit that will forward any connections
    through an active Meterpreter session. In this case, we want to connect to the
    MySQL instance listening on the server loopback: `127.0.0.1`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 Metasploit 中添加一个路由，通过一个活跃的 Meterpreter 会话转发所有连接。在这种情况下，我们想连接到在服务器回环地址
    `127.0.0.1` 上监听的 MySQL 实例。
- en: 'The Metasploit `route add` command requires we specify a network range and
    a Meterpreter session ID. In our case, we will be targeting only the `127.0.0.1`
    address, therefore a `/32` is in order. We also want to send all our packets through
    session `8`, in this case:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 的`route add`命令要求我们指定一个网络范围和 Meterpreter 会话 ID。在我们的例子中，我们只会针对`127.0.0.1`地址，因此需要使用`/32`。我们还希望通过会话`8`发送所有数据包：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To make use of this route, we need to launch a proxy server within Metasploit,
    which we can use together with ProxyChains to send packets through our Meterpreter
    session.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这个路径，我们需要在 Metasploit 中启动一个代理服务器，然后可以与 ProxyChains 一起使用，将数据包通过我们的 Meterpreter
    会话发送。
- en: The `auxiliary/server/socks4a` module will allow us to spawn a SOCKS4 server
    on the attack machine and using the previously added route, any traffic destined
    for `127.0.0.1` will be forwarded through our session.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`auxiliary/server/socks4a`模块将允许我们在攻击机器上启动一个 SOCKS4 服务器，并且使用先前添加的路由，任何发送到`127.0.0.1`的流量将通过我们的会话转发。'
- en: 'Let''s load the module and set the `SRVHOST` and `SRVPORT` as shown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载模块并设置`SRVHOST`和`SRVPORT`，如图所示：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should be able to see our SOCKS server running in the background by executing
    the Metasploit `jobs` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够通过执行 Metasploit 的`jobs`命令看到我们在后台运行的 SOCKS 服务器：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, the ProxyChains configuration file `/etc/proxychains.conf` should be
    modified to point to our newly spawned SOCKS server, as shown:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，ProxyChains 配置文件`/etc/proxychains.conf`应该修改为指向我们新创建的 SOCKS 服务器，如下所示：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we use the `proxychains` binary in our Kali terminal to wrap the MySQL
    client connection to the target''s MySQL instance using the credentials from `wp-config.php`,
    as shown:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 Kali 终端中使用`proxychains`二进制文件，通过`wp-config.php`中的凭据，将 MySQL 客户端连接包装到目标
    MySQL 实例，如下所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This WordPress database user will likely have limited access to the server
    as well, but it should be enough for our purposes. We can see the WordPress database
    and we can enumerate its tables and data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 WordPress 数据库用户可能对服务器的访问权限有限，但对我们的目的来说应该足够了。我们可以看到 WordPress 数据库，并且能够枚举其表和数据：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We need to grab the usernames and hashes stored in the `wp_users` table using
    a simple MySQL query:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用一个简单的 MySQL 查询，抓取存储在`wp_users`表中的用户名和哈希值：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the password hash of `msmith` in hand, we can launch John the Ripper on
    our Kali machine in an attempt to crack it. We can save the hash locally and run
    `john` against it, as shown:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到`msmith`的密码哈希后，我们可以在 Kali 机器上运行 John the Ripper 尝试破解它。我们可以将哈希保存到本地，并使用`john`进行破解，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Depending on your password cracking rig and the password complexity, this may
    take a while. It may not even be feasible during a typical engagement and you
    may need an alternative.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的密码破解设备和密码复杂度，这可能需要一些时间。在典型的渗透测试中，这可能并不可行，你可能需要考虑其他替代方案。
- en: A smarter way to get the plaintext credentials is to backdoor the CMS code for
    the login system and to capture the credentials in cleartext as the target user
    (or users) logs in to the application. This particular attack requires that the
    user we have control over can modify WordPress files on disk. Some installations
    will not allow the webserver user to write to the disk as a security precaution,
    but it is not uncommon for administrators to loosen this control during the lifetime
    of the application. This attack is also useful if we have full root access to
    the target server as well. As I mentioned before, there's value in capturing credentials
    in cleartext, especially when the goal is lateral movement or sensitive data access.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 获取明文凭据的一个更智能的方法是通过在 CMS 登录系统中植入后门，并在目标用户（或多个用户）登录应用程序时捕获明文凭据。这种攻击要求我们控制的用户能够修改
    WordPress 的文件。有些安装可能不允许 Web 服务器用户写入磁盘作为安全措施，但管理员在应用程序生命周期中放宽这一控制也并不罕见。如果我们对目标服务器拥有完整的
    root 权限，这个攻击方法也非常有效。正如我之前提到的，捕获明文凭据非常有价值，尤其是当目标是横向移动或敏感数据访问时。
- en: 'The function within WordPress that handles authentication is called `wp_signon()`
    and the WordPress Codex describes it in detail:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 处理身份验证的 WordPress 函数被称为`wp_signon()`，WordPress Codex 对其进行了详细描述：
- en: '![Credential exfiltration](graphics/B09238_12_11.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![凭据泄露](graphics/B09238_12_11.jpg)'
- en: 'Figure 12.11: WordPress Function Reference for wp_signon'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11：WordPress 函数参考：wp_signon
- en: The `signon` function is defined in the `wp-includes/user.php` WordPress core
    file. There are several lines of code that verify the credentials passed to the
    function from other modules, such as `wp-login.php`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`signon` 函数在 `wp-includes/user.php` 的 WordPress 核心文件中定义。代码中有几行用于验证从其他模块传递给该函数的凭证，例如
    `wp-login.php`。'
- en: We want to intercept the cleartext credentials and either exfiltrate them to
    our C2 server or store them somewhere on the website for later retrieval, or both.
    There are, of course, pros and cons to both methods of exfiltration. Sending the
    data over the wire can be picked up as unusual traffic by intrusion detection
    systems or egress proxies, but it ensures we get the credentials as soon as they're
    entered, provided the transmission is not blocked, of course. Storing the data
    locally would not trip up any network monitors but if server administrators look
    closely at the application file system, extra files on the server may raise some
    eyebrows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拦截明文凭证，并将其外泄到我们的 C2 服务器，或将其存储在网站的某个地方以便稍后检索，或两者兼有。当然，这两种外泄方法各有利弊。通过网络传输数据可能会被入侵检测系统或出站代理识别为异常流量，但它确保我们在凭证输入后立即获得它们，当然前提是传输没有被阻断。将数据存储在本地则不会引起任何网络监控的注意，但如果服务器管理员仔细查看应用文件系统，服务器上的额外文件可能会引起怀疑。
- en: Within the `wp_signon` function, credentials are either passed in through the
    `$credentials` variable or for new logins, through the PHP global `$_POST` variable.
    We can JSON-encode this incoming value, Base64-encode the results, and either
    write them to disk or send them over the wire. The double encoding is mostly for
    network transmission simplicity's sake and it also slightly obfuscates the data
    we are exfiltrating.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `wp_signon` 函数中，凭证要么通过 `$credentials` 变量传递，要么对于新的登录，通过 PHP 全局变量 `$_POST` 传递。我们可以对这个传入值进行
    JSON 编码，然后对结果进行 Base64 编码，最后将其写入磁盘或通过网络发送。这种双重编码主要是为了简化网络传输，同时也稍微混淆了我们外泄的数据。
- en: PHP provides two handy functions we can inject into the `wp_signon` function
    to exfiltrate the WordPress credentials quickly and easily.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了两个方便的函数，我们可以将它们注入到 `wp_signon` 函数中，以便快速轻松地外泄 WordPress 凭证。
- en: '`file_put_contents()` allows us to write to disk, anywhere the web user has
    access to write to. For WordPress specifically, since it allows the upload of
    data, `wp-content/uploads` is usually writeable by the webserver. Other CMSs will
    have similar access to other directories that we can use.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_put_contents()` 允许我们写入磁盘，写入位置是网页用户有权限访问的任何地方。对于 WordPress，特别是因为它允许上传数据，`wp-content/uploads`
    通常是可被 Web 服务器写入的。其他 CMS 也会有类似的目录访问权限，我们可以利用这些权限。'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: PHP's `file_get_contents()` function allows us to make web requests to our C2
    server and we can pass in the credentials via the URL. We'll be able to see the
    data in the C2 logs. For network exfiltration, we should prepend the function
    with the `@` character, so that PHP suppresses any errors, should there be any
    network issues. If the C2 goes down or is otherwise unreachable, we don't want
    to alert users of a potential security issue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 `file_get_contents()` 函数允许我们向 C2 服务器发出网页请求，我们可以通过 URL 将凭证传递过去。我们可以在 C2
    的日志中查看数据。对于网络外泄，我们应该在函数前添加 `@` 字符，这样 PHP 就会抑制任何错误，万一发生网络问题。如果 C2 服务器宕机或无法访问，我们不想引起用户对潜在安全问题的警觉。
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It should be noted that URL exfiltration could introduce noticeable delays in
    the site, which could alert users of a potential compromise. If stealth is paramount,
    it may be better to store the data locally, retrieve it through the web, and delete
    it after the engagement is over.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，URL 数据外泄可能会导致站点出现明显的延迟，这可能会提醒用户潜在的安全风险。如果隐蔽性至关重要，最好将数据存储在本地，通过网页检索，并在操作完成后删除。
- en: 'For our credential stealer, we can use either one (or both) of the following
    lines of code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的凭证窃取器，我们可以使用以下一行（或两行）代码：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To recap, during user login, our backdoor will:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在用户登录过程中，我们的后门将会：
- en: Grab the cleartext credentials stored in the `$_POST` global
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储在 `$_POST` 全局中的明文凭证
- en: Encode them in JSON and Base64 for easy transmission and obfuscation
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对凭证进行 JSON 和 Base64 编码，方便传输和混淆
- en: Store them on disk in the `wp-content/uploads/.index.php.swp` file
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将凭证存储在 `wp-content/uploads/.index.php.swp` 文件中
- en: Send them to our C2 via the URL `http://pingback.c2.spider.ml/ping.php`
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 URL `http://pingback.c2.spider.ml/ping.php` 将它们发送到我们的 C2。
- en: The backdoor code will be added just before the `wp_signon` function returns.
    This ensures we only capture valid credentials. The `wp_signon` function will
    return well before our code if the credentials supplied are invalid.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 后门代码将添加在`wp_signon`函数返回之前。这确保我们仅捕获有效的凭证。如果提供的凭证无效，`wp_signon`函数会比我们的代码更早返回。
- en: 'We have to inject our code in the appropriate spot in `wp-includes/user.php`.
    Credentials are checked by `wp_signon` and are considered valid towards the end of
    the function, before the last `return` statement. This is where we need to put our code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将代码注入到`wp-includes/user.php`中的合适位置。凭证通过`wp_signon`进行检查，并在函数的最后`return`语句之前被认为是有效的。我们需要在此处放置我们的代码：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once a user, or two or three users, successfully login, we can see the plaintext
    credentials in the `wp-content/uploads/.index.php.swp` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户，或者两个或三个用户成功登录，我们可以在`wp-content/uploads/.index.php.swp`文件中看到明文凭证：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The C2 has also recorded the same credentials in the connection log:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: C2服务器还在连接日志中记录了相同的凭证：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we decode the Base64 data, we can see the password of `msmith`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们解码Base64数据，可以看到`msmith`的密码：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Attempting to crack the hash we grabbed from the database would've likely been
    unsuccessful for `msmith`. Thankfully, we were able to modify the CMS code to
    capture credentials in cleartext, without disrupting the target and its users.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试破解我们从数据库中获取的哈希值对`msmith`来说可能会失败。幸运的是，我们能够修改CMS代码以捕获明文凭证，而不会干扰目标和其用户。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a closer look at attacking CMSs, in particular WordPress.
    While we did pick on WordPress quite heavily, it's important to note that similar
    issues and vulnerabilities can be found in its competitors' software as well.
    Drupal and Joomla usually come up in the CMS conversation and they're no strangers
    to poorly written plugins or badly configured instances.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了攻击CMS，特别是WordPress。虽然我们对WordPress进行了相当密集的攻击，但需要注意的是，类似的问题和漏洞也可以在其竞争对手的软件中找到。Drupal和Joomla通常在CMS讨论中提到，它们也不陌生于编写不当的插件或配置错误的实例。
- en: We were able to assess a target CMS using WPScan and Arachni, and even look
    at options for privilege escalation or lateral movement once some access was obtained.
    We also looked at backdooring code to persist our access and even modifying the
    CMS core source files to exfiltrate cleartext credentials to our C2 server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用WPScan和Arachni评估目标CMS，甚至在获取一些访问权限后，查看特权提升或横向移动的选项。我们还查看了后门代码，以保持我们的访问权限，甚至修改CMS核心源代码，将明文凭证导出到我们的C2服务器。
