- en: Chapter 3. Low-Hanging Fruit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 低 hanging fruit
- en: It is often the case that clients will approach security professionals with
    a request to perform an application penetration test. In many engagements, there
    is not a lot of information given to the tester, if any at all, prompting a black-box
    approach to testing. This can make testing more difficult, especially when open-source
    intelligence isn't of much help or the interface is not intuitive, or user friendly,
    which is sometimes the case with an API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 客户通常会请求安全专业人员进行应用程序渗透测试。在许多项目中，测试者几乎没有或根本没有获得任何信息，这促使了黑盒测试的方法。这可能会使测试变得更加困难，特别是当开放源情报并不能提供太多帮助，或者接口并不直观或用户友好时，这在
    API 中有时可能会发生。
- en: In the scenario presented in this chapter, we are faced with this exact problem,
    which is commonly encountered in the wild. Instead of deep diving into the inner
    workings of the API and attempting to reverse engineer its functionality without
    much prior knowledge, we can start by looking for low-hanging fruit. We hope that
    if we take the road less travelled by the security team, we can eventually reach
    the open back window and bypass the four-foot thick steel door protecting the
    entrance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节提出的场景中，我们面对的正是在现实中经常遇到的问题。与其深入探讨 API 的内部工作原理，并试图在没有太多先验知识的情况下反向工程其功能，我们可以先寻找那些低
    hanging fruit（易于获取的目标）。我们希望，通过选择安全团队少走的路，最终能够找到开放的后门，并绕过那扇四英尺厚的钢门，保护着入口。
- en: 'In this chapter, we will look at the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Assessing the application server's security posture for alternate routes to compromise
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估应用程序服务器的安全姿态，寻找替代路径来妥协
- en: Brute-force attacks on services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务进行暴力攻击
- en: Leveraging vulnerabilities in adjacent services to compromise the target
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用相邻服务中的漏洞来妥协目标
- en: Network assessment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络评估
- en: We've seen in previous chapters that Metasploit's workspace feature can be very
    useful. In the following engagement, we will make use of it as well. First, we
    have to launch the console from the terminal using the `msfconsole` command. Once
    Metasploit has finished loading, it will drop us into the familiar `msf >` prompt.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中看到，Metasploit 的工作区功能非常有用。在接下来的项目中，我们也会利用它。首先，我们必须使用 `msfconsole`
    命令从终端启动控制台。一旦 Metasploit 加载完成，它将把我们带到熟悉的 `msf >` 提示符下。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As with all engagements involving Metasploit, we start by creating a workspace
    specifically for the scope:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有涉及 Metasploit 的项目一样，我们首先为该范围创建一个工作空间：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For this scenario, our target is a black-box API application provided by E Corp.
    The target host will be `api.ecorp.local`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此场景，我们的目标是由 E Corp 提供的黑盒 API 应用程序。目标主机将是 `api.ecorp.local`。
- en: Before we hammer away at the web interface and try to exploit some obscure vulnerability,
    let's take a step back and see what other services are exposed on the API's server.
    The hope here is that while the API itself may have been closely scrutinized by
    developers, who may have taken security seriously during the development life
    cycle, mistakes may have been made when deploying the server itself. There are
    many aspects of system hardening that simply cannot be controlled within the source
    code repository. This is especially true when the server housing the target application
    is a shared resource. This increases the likelihood that the system security policy
    will loosen up over time as different teams with different requirements interact
    with it. There could be some development instance with less stringent controls
    running on a non-standard port, or a forgotten and vulnerable application that
    can give us (as an attacker) the required access, and we can easily compromise
    the target.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们猛攻 Web 接口并尝试利用某些隐蔽漏洞之前，让我们退一步，看看 API 服务器上暴露的其他服务。我们希望，尽管开发人员可能在开发生命周期中严格审查了
    API 本身并且认真对待了安全性，但在部署服务器本身时可能会犯错误。系统硬化的许多方面简直无法在源代码仓库内控制。特别是当托管目标应用程序的服务器是一个共享资源时。这增加了随着不同团队及其不同需求的互动，系统安全策略随时间放宽的可能性。可能存在一些开发实例，其控制不严格地运行在非标准端口上，或者是一个被遗忘且易受攻击的应用程序，可以为我们（作为攻击者）提供所需的访问权限，并轻松妥协目标。
- en: As always, Nmap is our network recon tool of choice and coupled with Metasploit's
    workspace, it becomes even more powerful. The Metasploit console wrapper command
    for Nmap is the `db_nmap` command. The Nmap switches that we will use for discovering
    open ports, and querying services for more information, are detailed in the following
    text.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，Nmap 是我们首选的网络侦察工具，结合 Metasploit 的工作空间，它变得更强大。Metasploit 控制台的 Nmap 包装命令是
    `db_nmap` 命令。我们将使用的 Nmap 切换选项，用于发现开放端口并查询服务以获取更多信息，详见以下内容。
- en: 'The `-sV` will instruct Nmap to perform a version scan of any identified services,
    and the `-A` will provide us with some host fingerprinting, attempting to detect
    the operating system. The `-T4` option is used to tell Nmap to be more aggressive
    when scanning the network. This improves scanning speed at the risk of being detected
    by intrusion detection systems. A lower number, such as `-T1`, will make scanning
    a bit more paranoid, and while it may take longer to complete, it could let us
    fly under the radar for a bit longer. The `-Pn` switch will prevent Nmap from
    performing a ping of the target. Pinging our target is not really required unless
    we scan a wide range of addresses and we''re only looking for hosts that are online.
    Finally, `-p1-` (lowercase) is a short form for `-p1-65535`, instructing Nmap
    to scan all possible ports on the target. The unnamed parameter is our target,
    `api.ecorp.local`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`-sV` 选项会指示 Nmap 执行版本扫描，识别到的任何服务都会进行版本探测，`-A` 选项会为我们提供一些主机指纹信息，并尝试检测操作系统。`-T4`
    选项用于告知 Nmap 在扫描网络时更具攻击性。这样可以提高扫描速度，但也有被入侵检测系统发现的风险。较低的数字（例如 `-T1`）会让扫描更为谨慎，虽然完成速度较慢，但可能会让我们在更长时间内保持隐蔽。`-Pn`
    选项会阻止 Nmap 对目标执行 ping 操作。除非我们扫描广泛的地址范围并且只关注在线的主机，否则 ping 操作通常不是必需的。最后，`-p1-`（小写）是
    `-p1-65535` 的简写，指示 Nmap 扫描目标上的所有端口。未命名的参数是我们的目标，`api.ecorp.local`：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we''ve wrapped the Nmap scan using the Metasploit `db_nmap` command,
    the results are automatically parsed and written to our workspace''s database.
    Once the scan is complete, we can review the entries in the database by issuing
    the `services` command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Metasploit 的 `db_nmap` 命令包装了 Nmap 扫描，结果会自动解析并写入到我们的工作空间数据库中。扫描完成后，我们可以通过执行
    `services` 命令查看数据库中的条目：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It appears that the MySQL instance is reachable, so gaining access to this would
    be very valuable. Nmap detected this as a **MariaDB** service, which is the community-developed
    fork for the MySQL software. If we're very lucky, this instance is outdated, with
    some easily exploitable vulnerability that will give us instant access. To figure
    this out, we can use the database software version number and run it by a list
    of public **Common Vulnerabilities and Exposures** (**CVEs**), and hopefully find
    some exploitable code in the wild for our service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 MySQL 实例是可访问的，因此获取对它的访问权限将非常有价值。Nmap 将其检测为 **MariaDB** 服务，MariaDB 是 MySQL
    软件的社区开发分支。如果我们运气好，实例可能是过时的，存在一些容易被利用的漏洞，能为我们提供即时访问。为了弄清楚这一点，我们可以使用数据库软件的版本号，并将其与公共
    **常见漏洞和暴露**（**CVE**）列表进行比对，希望能在互联网上找到一些可利用的代码。
- en: 'Instead of going at the application head on, over port `80`, we hope to attack
    it via the exposed MySQL (MariaDB) services, as this attack path figure shows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过暴露的 MySQL（MariaDB）服务攻击，而不是直接通过端口 `80` 进行应用程序攻击，如图所示的攻击路径所示：
- en: '![Network assessment](graphics/B09238_03_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![网络评估](graphics/B09238_03_01.jpg)'
- en: 'Figure 3.1: An alternate path to compromise'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：另一种攻击路径
- en: Looking for a way in
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找突破口
- en: Since the Nmap scan did not return a specific version, we can quickly issue
    a detailed version probe for the MySQL service, using a couple of Metasploit commands.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Nmap 扫描没有返回特定版本，我们可以快速执行一个详细的版本探测，针对 MySQL 服务使用几个 Metasploit 命令。
- en: 'First, we load the aptly named `mysql_version` auxiliary scanner module. The
    `use` command, followed by the path to the module `auxiliary/scanner/mysql/mysql_version`,
    will load the module in the current session. We can view more information on the
    `mysql_version` module by issuing the `show info` command, as shown in the following
    screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载名为 `mysql_version` 的辅助扫描模块。使用 `use` 命令，后跟模块路径 `auxiliary/scanner/mysql/mysql_version`，即可在当前会话中加载该模块。我们可以通过执行
    `show info` 命令查看关于 `mysql_version` 模块的更多信息，如下图所示：
- en: '![Looking for a way in](graphics/B09238_03_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![寻找突破口](graphics/B09238_03_02.jpg)'
- en: 'Figure 3.2: mysql_version module information'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：mysql_version 模块信息
- en: The `Basic options:` will list the variables we will need to update in order
    for the module to execute properly. The `RHOSTS`, `RPORT`, and `THREADS` parameters
    are required for this particular scanner. `RHOSTS`, or remote hosts, and `RPORT`,
    or remote port, should be self-explanatory. The `THREADS` option can be increased
    to a higher number to increase scan speed, but since we are only targeting one
    remote host, `api.ecorp.local`, we don't need more than one scanning thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`基本选项:` 会列出我们需要更新的变量，以确保模块能正常执行。对于这个特定的扫描器，`RHOSTS`、`RPORT` 和 `THREADS` 参数是必需的。`RHOSTS`，即远程主机，和
    `RPORT`，即远程端口，应该是显而易见的。`THREADS` 选项可以增加线程数以提高扫描速度，但由于我们只针对一个远程主机 `api.ecorp.local`，因此不需要超过一个扫描线程。'
- en: 'With the module loaded, we can set the required `RHOSTS` variable to the appropriate
    target. Since the target was already scanned by `db_nmap`, and the results are
    in the `ecorp` workspace, we can use the `services` command to set the `RHOSTS`
    variable automatically to all MySQL servers found, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载模块后，我们可以将所需的 `RHOSTS` 变量设置为适当的目标。由于目标已经被 `db_nmap` 扫描过，并且结果存储在 `ecorp` 工作区中，我们可以使用
    `services` 命令自动将 `RHOSTS` 变量设置为所有找到的 MySQL 服务器，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `services` command accepts a few switches to better filter and action the
    results. The `-R` option in the services command set the current module's `RHOSTS`
    variable to the values returned by the query. In this scenario, you could have
    just as easily typed in the host manually, but with broader sweeps, this particular
    switch will be very handy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`services` 命令接受一些开关，以更好地过滤和处理结果。`services` 命令中的 `-R` 选项将当前模块的 `RHOSTS` 变量设置为查询返回的值。在这种情况下，你也可以手动输入主机，但对于更广泛的扫描，这个开关将非常方便。'
- en: There are other ways to query the services in the workspace. For example, in
    the preceding command-line input, we used the `-s` option, which filters all hosts
    running MySQL as an identified service.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方式可以查询工作区中的服务。例如，在之前的命令行输入中，我们使用了 `-s` 选项，它过滤出所有运行 MySQL 服务的主机。
- en: 'If we know that we will be attacking the same host with other Metasploit modules,
    it''s a good idea to set the global `RHOSTS` variable to the same value. This
    will ensure that the `RHOSTS` value is automatically populated when switching
    modules. We can accomplish this by using the `setg` command as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道接下来会使用其他 Metasploit 模块攻击同一主机，最好将全局 `RHOSTS` 变量设置为相同的值。这将确保在切换模块时，`RHOSTS`
    值会自动填充。我们可以通过使用 `setg` 命令来实现，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All that''s left to do now is to run the `mysql_version` module and hopefully
    get back some useful information, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是运行 `mysql_version` 模块，希望能够返回一些有用的信息，如下图所示：
- en: '![Looking for a way in](graphics/B09238_03_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![寻找突破口](graphics/B09238_03_03.jpg)'
- en: 'Figure 3.3: mysql_version running on the target RHOSTS'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：在目标 RHOSTS 上运行的 mysql_version
- en: It appears that the module was able to identify the MySQL server version successfully.
    This will prove useful when looking for known vulnerabilities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来该模块成功识别了 MySQL 服务器版本。这在寻找已知漏洞时非常有用。
- en: 'If we issue another `services` query, you will notice that the info field for
    the `mysql` service has changed to the results of the `mysql_version` scan, as
    follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再执行一次 `services` 查询，你会注意到 `mysql` 服务的 info 字段已更改为 `mysql_version` 扫描的结果，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Where our Nmap scan fell short in identifying the version number, Metasploit
    succeeded and automatically changed the database to reflect this. After reviewing
    the public CVEs for MySQL, however, it doesn't appear that this instance has any
    unauthenticated vulnerabilities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Nmap 扫描未能识别版本号时，Metasploit 成功地识别并自动更新了数据库以反映这一点。然而，经过查看 MySQL 的公开 CVE 记录后，似乎该实例并没有任何未经认证的漏洞。
- en: 'Back in the Kali Linux terminal, we can use the `mysql` client command to attempt
    to authenticate as `root` (`-u`) to the `api.ecorp.local` host (`-h`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Kali Linux 终端，我们可以使用 `mysql` 客户端命令尝试以 `root`（`-u`）身份认证连接到 `api.ecorp.local`
    主机（`-h`）：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the lack of space between the `-u` and `-h` switches and their respective
    values. A quick check for an empty `root` password fails, but it proves that the
    MySQL server is accepting connections from remote addresses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `-u` 和 `-h` 开关及其对应值之间没有空格。快速检查空的 `root` 密码失败，但这证明 MySQL 服务器接受来自远程地址的连接。
- en: Credential guessing
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证猜测
- en: Since we were unable to uncover a working remote exploit for the MySQL instance,
    the next step is to attempt a credentialed brute-force attack against the default
    MySQL `root` user. We will use one of our curated commonly used password dictionaries
    and hope this instance was not properly secured during deployment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们未能找到一个有效的远程漏洞用于 MySQL 实例，下一步是尝试对默认 MySQL `root` 用户进行凭证暴力破解攻击。我们将使用我们整理过的常见密码字典之一，并希望这个实例在部署时没有得到妥善的安全保护。
- en: 'With Metasploit''s help, we can start a MySQL login password guessing attack
    fairly easily. We will use the `mysql_login` auxiliary scanner module, as seen
    in the following screenshot. This module has some additional available options
    for tuning:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Metasploit 的帮助下，我们可以相对容易地启动一个 MySQL 登录密码猜测攻击。我们将使用 `mysql_login` 辅助扫描模块，如下所示的截图所示。这个模块有一些额外的可用选项供调整：
- en: '![Credential guessing](graphics/B09238_03_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![凭证猜测](graphics/B09238_03_04.jpg)'
- en: 'Figure 3.4: The mysql_login auxiliary scanner module'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：mysql_login 辅助扫描模块
- en: 'Before continuing, we will set the following values to make the scan a bit
    more efficient and reduce some noise:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将设置以下值，以使扫描更加高效，并减少一些噪音：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Increasing the `THREADS` count will help you to get through the scan more quickly,
    although it can be more noticeable. More threads means more connections to the
    service. If this particular host is not very resilient, we may crash it, thereby
    alerting the defenders. If our goal is to be quieter, we can use only one thread
    but the scan will take much longer. The `VERBOSE` variable should be set to `false`,
    as you will be testing lots of passwords and the console output can get messy.
    An added bonus to non-verbose output is that it improves the scan time significantly,
    since Metasploit does not have to output something to the screen after every attempt.
    Finally, with `STOP_ON_SUCCESS` set to `true`, we will stop the attack if we have
    a successful login.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 `THREADS` 线程数将帮助你更快地完成扫描，尽管这样可能会更加显眼。更多线程意味着更多的服务连接。如果这个主机不够强健，我们可能会将其崩溃，从而引起防御者的警觉。如果我们的目标是保持低调，我们可以只使用一个线程，但扫描将需要更长时间。`VERBOSE`
    变量应设置为 `false`，因为你将测试大量密码，控制台输出可能会变得混乱。禁用冗余输出的一个额外好处是，它显著提高了扫描速度，因为 Metasploit
    不需要在每次尝试后将内容输出到屏幕上。最后，设置 `STOP_ON_SUCCESS` 为 `true`，如果成功登录，我们将停止攻击。
- en: 'The target `USERNAME` will be `root`, as it is common for MySQL installations
    have this user enabled by default:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目标 `USERNAME` 将设置为 `root`，因为默认情况下，MySQL 安装通常启用这个用户：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the wordlist, `PASS_FILE` will be set to the `SecLists` `10-million-password-list-top-500.txt`
    collection as follows. This is 500 of the most popular passwords from a larger
    10 million password list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字典文件，`PASS_FILE` 将设置为 `SecLists` 中的 `10-million-password-list-top-500.txt`
    文件，内容如下。这是从一个包含 1000 万个密码的大字典中提取的 500 个最常见的密码：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a good place to start. There are other top variations of the 10 million
    password list file, and if this one fails to produce a valid login, we can try
    the top 1,000, 10,000, or other wordlists.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的起点。还有其他不同的 1000 万密码列表文件变体，如果这个无法产生有效的登录，我们可以尝试前 1000 个、10000 个或其他字典。
- en: 'Much like every other module in Metasploit, the `run` command will begin execution:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Metasploit 中的其他模块一样，`run` 命令将开始执行：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a few minutes, we receive some good news:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们收到了一些好消息：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It appears that we have found a valid login for the MySQL instance running on
    the same machine as our target application. This may or may not be the database
    in use by the API itself. We will take a closer look and see if we can find a
    way to spawn a shell, and fully compromise the E Corp API server, and by extension
    our target as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经找到了一个有效的登录凭证，适用于与目标应用程序运行在同一台机器上的 MySQL 实例。这个数据库可能是 API 使用的数据库，也可能不是。我们将进一步检查，看看能否找到办法启动一个
    shell，完全入侵 E Corp API 服务器，并间接入侵我们的目标。
- en: We can connect directly from our Kali Linux instance using the `mysql` command
    once more. The `-u` switch will specify the username and the `-p` switch will
    let us pass the newly discovered password. There's no space between the switches
    and their values. If we omit a value for `-p`, the client will prompt us for a
    password.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次通过 `mysql` 命令从我们的 Kali Linux 实例直接连接。`-u` 选项指定用户名，`-p` 选项让我们传入新发现的密码。选项与其值之间没有空格。如果我们省略
    `-p` 的值，客户端将提示我们输入密码。
- en: 'The following screenshot shows a successful connection to the database service
    and the listing of the available databases using the `show databases;` SQL query:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了成功连接到数据库服务并使用 `show databases;` SQL 查询列出可用数据库的情况：
- en: '![Credential guessing](graphics/B09238_03_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![凭证猜测](graphics/B09238_03_05.jpg)'
- en: 'Figure 3.5: Successfully authenticated connection to the target database'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：成功认证连接到目标数据库
- en: Once connected, we've queried for the available databases, but there doesn't
    appear to be anything related to the API on this server. It's possible that the
    API is configured to use a different SQL database, and we've stumbled upon a development
    instance without much interesting data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，我们查询了可用的数据库，但似乎服务器上没有与 API 相关的内容。可能是该 API 配置为使用不同的 SQL 数据库，而我们碰巧发现了一个没有太多有趣数据的开发实例。
- en: Given that we are the database administrator, `root`, we should be able to do
    lots of interesting things, including writing arbitrary data to the disk. If we
    can do this, it means that we can potentially achieve remote code execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们是数据库管理员 `root`，我们应该能够做很多有趣的事情，包括将任意数据写入磁盘。如果我们能做到这一点，意味着我们可能会实现远程代码执行。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is a Metasploit module (surprise, surprise) that can deliver executables
    and initiate a reverse shell using known credentials. For Windows machines, `exploit/windows/mysql/mysql_payload`
    can upload a Meterpreter shell and execute it, although there are some drawbacks.
    A standard Metasploit payload will likely be picked up by **antivirus** (**AV**)
    software and alert the defenders to your activities. Bypassing AVs is possible
    with a **fully undetectable** (**FUD**) Metasploit payload, but for the scenario
    in this chapter, we will go with a simpler, less risky option.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 Metasploit 模块（惊讶吧）可以通过已知凭证上传可执行文件并启动反向 shell。对于 Windows 机器，`exploit/windows/mysql/mysql_payload`
    可以上传一个 Meterpreter shell 并执行它，尽管它有一些缺点。一个标准的 Metasploit 有效载荷可能会被 **杀毒软件** (**AV**)
    检测到，并向防守者发出警报。通过 **完全不可检测** (**FUD**) 的 Metasploit 有效载荷，可以绕过杀毒软件，但在本章的场景中，我们将选择一个更简单、风险较低的选项。
- en: While MySQL is able to write files to disk using SQL query statements, it is
    actually a bit more complicated to execute binaries. We can't easily write binary
    data to disk, but we can write application source code. The simplest way to achieve
    code execution is to write some PHP code inside the application directory that
    will let us execute shell commands through the application URL. With PHP's help,
    the web shell will accept commands through an HTTP `GET` request and pass them
    to the system shell.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MySQL 能通过 SQL 查询语句将文件写入磁盘，但执行二进制文件实际上要复杂一些。我们不能轻易地将二进制数据写入磁盘，但可以写应用程序源代码。实现代码执行的最简单方法是在应用程序目录中写一些
    PHP 代码，这样我们就能通过应用程序的 URL 执行 shell 命令。在 PHP 的帮助下，web shell 将通过 HTTP `GET` 请求接收命令并将其传递给系统
    shell。
- en: 'Now let''s find out where we are on the disk, so that we can write the payload
    to the appropriate web application directory. The `SHOW VARIABLES` SQL query lets
    us see configuration data and the `WHERE` clause limits the output to directory
    information only, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找出当前磁盘的位置，以便将有效载荷写入适当的 web 应用程序目录。`SHOW VARIABLES` SQL 查询可以让我们查看配置信息，而
    `WHERE` 子句将输出限制为仅目录信息，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This looks like a XAMPP installation and based on open-source documentation,
    the main website code should be located in `c:\xampp\htdocs\`. You can confirm
    this by a quick `curl` test. A typical XAMPP installation comes with a subdirectory
    in the `htdocs` folder called `xampp`. Among other things, it houses a `.version`
    file, which contains what you would expect, the XAMPP version:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是 XAMPP 安装，并且根据开源文档，主网站代码应位于 `c:\xampp\htdocs\`。你可以通过快速的 `curl` 测试来确认这一点。典型的
    XAMPP 安装在 `htdocs` 文件夹中有一个名为 `xampp` 的子目录。它包含一些文件，其中之一是 `.version` 文件，里面包含了你想要的内容，即
    XAMPP 版本：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Back to the MySQL command-line interface, and we can try to write to that directory
    using MySQL's `SELECT INTO OUTFILE` query. If we can put a PHP file somewhere
    inside `htdocs`, we should be able to call it from a web browser or `curl`, and
    we will have code execution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 MySQL 命令行界面，我们可以尝试使用 MySQL 的 `SELECT INTO OUTFILE` 查询将数据写入该目录。如果我们能把 PHP
    文件放到 `htdocs` 中的某个地方，我们应该能通过网页浏览器或 `curl` 来调用它，这样就能执行代码。
- en: 'The `SELECT` statement template we will use for this is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 `SELECT` 语句模板如下：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s plug in some test values and see if we can write to the target directory,
    and more importantly, if the application web server will process our PHP code
    correctly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们插入一些测试值，看看是否能写入目标目录，更重要的是，应用 Web 服务器是否能正确处理我们的 PHP 代码：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ECorpAppTest11251` flag is added as a comment, in case we are unable to
    clean up this shell after the test is complete, and have to report it to the client's
    blue team. It can also help the blue team to identify files that may have been
    missed as part of the incident response exercise. This is not always required,
    but it is good practice, especially with high-risk artifacts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ECorpAppTest11251` 标志作为注释添加，以防我们在测试完成后无法清理此 shell，需要向客户的蓝队报告。它还可以帮助蓝队识别可能在事件响应演练中被遗漏的文件。这并非总是必须的，但这是一个好的做法，特别是在处理高风险工件时。'
- en: 'This is good: the query was successful. We can check to see if the PHP interpreter
    works in this directory, and if the file is successfully executed, by calling
    it from the browser, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好的：查询成功。我们可以检查 PHP 解释器是否在此目录下工作，并通过从浏览器调用它来查看文件是否成功执行，如下图所示：
- en: '![Credential guessing](graphics/B09238_03_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![凭证猜测](graphics/B09238_03_06.jpg)'
- en: 'Figure 3.6: The PHP code executing successfully'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：PHP 代码成功执行
- en: 'At this point, we need to get shell access to the server, so that we can execute
    arbitrary commands and not just output PHP configuration data. Modifying the previous
    `SELECT INTO OUTFILE` payload will produce a rudimentary PHP shell. PHP has a
    built-in function that conveniently executes arbitrary shell commands. This is
    true for all server-side web programming languages: Python, Perl, ASP, Ruby, and
    so on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们需要获取服务器的 shell 访问权限，这样我们才能执行任意命令，而不仅仅是输出 PHP 配置数据。通过修改之前的`SELECT INTO
    OUTFILE`负载，可以生成一个初步的 PHP shell。PHP 有一个内置函数，方便执行任意的 shell 命令。所有服务器端的 Web 编程语言都具有此功能：如
    Python、Perl、ASP、Ruby 等等。
- en: If we pass data from the `GET` request into the PHP built-in `system()` function,
    we can execute arbitrary commands on the server itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将来自`GET`请求的数据传递给 PHP 内置的`system()`函数，我们就可以在服务器上执行任意命令。
- en: 'The following shows our web shell source code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的 Web shell 源代码：
- en: '![Credential guessing](graphics/B09238_03_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![凭证猜测](graphics/B09238_03_07.jpg)'
- en: 'Figure 3.7: Web shell source code'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：Web Shell 源代码
- en: The code is fairly straightforward. The `if` statement will check the MD5 hash
    value of the incoming `password` parameter matches `4fe7aa8a3013d07e292e5218c3db4944`.
    If there's a match, the command string in the `cmd` `GET` parameter will be passed
    to the PHP `system()` function, which will execute it as a system command, giving
    us shell access.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。`if`语句会检查传入的 `password` 参数的 MD5 哈希值是否与 `4fe7aa8a3013d07e292e5218c3db4944`
    匹配。如果匹配，`cmd` `GET` 参数中的命令字符串将传递给 PHP 的 `system()` 函数，这样它就会作为系统命令执行，从而为我们提供 shell
    访问权限。
- en: 'The MD5 value we''re looking for is the hash value of `ECorpAppTest11251`,
    as confirmed by the `md5sum` Linux command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要找的 MD5 值是 `ECorpAppTest11251` 的哈希值，已通过 `md5sum` Linux 命令确认：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To easily write the shell code to the disk using MySQL''s `SELECT INTO OUTFILE`
    statement, we can compress it down to one line. Thankfully, PHP is not very concerned
    with carriage returns, as long as the code is properly segregated by semicolons
    and curly braces. We can compress our web shell into the following line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便地通过 MySQL 的`SELECT INTO OUTFILE`语句将 shell 代码写入磁盘，我们可以将其压缩成一行。幸运的是，PHP 对回车符不太敏感，只要代码通过分号和大括号正确分隔即可。我们可以将我们的
    Web shell 压缩成以下一行：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we plug it into our `SELECT INTO OUTFILE` template, we should be able to
    write it to disk in the `xampp` subdirectory, which is accessible from the web:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它插入到我们的 `SELECT INTO OUTFILE` 模板中，我们应该能够将其写入 `xampp` 子目录中，该目录可以通过 Web 访问：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see the shell in action by executing the `tasklist` system command and
    passing the `ECorpAppTest11251` value as the password, as shown in the following
    screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `tasklist` 系统命令并传递 `ECorpAppTest11251` 作为密码，看到 shell 的实际操作，如下图所示：
- en: '![Credential guessing](graphics/B09238_03_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![凭证猜测](graphics/B09238_03_08.jpg)'
- en: 'Figure 3.8: A process listing on the application server'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：应用服务器上的进程列表
- en: That was easy. We now have arbitrary code execution on the application server.
    We can retrieve the target source code, find the database, dump passwords, backdoor
    the application, and much, much more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们现在可以在应用服务器上执行任意代码。我们可以获取目标源代码，找到数据库，导出密码，后门应用，等等。
- en: A better way to shell
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的方式来使用 shell
- en: While we have achieved the goal of executing code on the server and have effectively
    compromised the application (and more!), you may have an incentive to dig a bit
    deeper. Moreover, the web shell created so far is fairly dumb and it is difficult
    to execute commands in succession. If this test lasts for several days, or even
    weeks, it could be a burden. It is a bit clunky and difficult to work with as
    well. You may need to transfer files, upgrade to an interactive shell, navigate
    the filesystem, and so forth. For this and for many other reasons, you should
    upgrade to a more functional feature-full shell. This is where **Weevely** comes
    in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经实现了在服务器上执行代码，并有效地攻陷了应用程序（甚至更多！），但你可能有动力进一步深入挖掘。此外，到目前为止创建的Web shell相当简陋，执行命令时很难连续操作。如果这项测试持续数天，甚至数周，这将成为一种负担。它有点笨重，且难以操作。你可能需要传输文件、升级到交互式shell、浏览文件系统等等。为了这些原因，以及许多其他原因，你应该升级到一个功能更强的shell。这就是**Weevely**的作用。
- en: 'Weevely is a weaponized web shell installed on Kali Linux by default. It is
    very easy to use. It generates an obfuscated, password-protected PHP shell that
    can replace our earlier `system()` shell example. Weevely features some useful
    functionality that goes above and beyond the traditional system pass-through shell,
    including the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Weevely是一个默认安装在Kali Linux中的武器化Web Shell，使用起来非常简单。它生成一个混淆过的、密码保护的PHP shell，可以替代我们之前的`system()`
    shell示例。Weevely提供了一些超越传统系统传递shell的有用功能，包括以下内容：
- en: A familiar terminal interface
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个熟悉的终端界面
- en: Network pivots
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络转发
- en: File upload and download
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传与下载
- en: Reverse and direct TCP shell
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向和直接TCP shell
- en: Meterpreter support
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meterpreter支持
- en: 'First, we need to generate a new shell by issuing the `weevely generate` command.
    The syntax is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过执行`weevely generate`命令生成一个新的shell。语法如下：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Weevely will generate a password-protected, obfuscated PHP web shell in the
    specified path on our Kali machine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Weevely将在我们Kali机器上指定路径生成一个密码保护、混淆过的PHP Web shell：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To serve up the newly-generated web shell quickly, we can spawn a temporary
    web server on our Kali Linux instance using a one-line command. Python comes bundled
    with a `SimpleHTTPServer` module that can be called from the terminal to serve
    files over HTTP. There's no need to mess around with the Apache or NGINX settings.
    By default, the `SimpleHTTPServer` module serves the current directory contents
    to the web.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速提供新生成的Web shell，我们可以使用一行命令在Kali Linux实例上启动一个临时Web服务器。Python自带一个`SimpleHTTPServer`模块，可以从终端调用，来通过HTTP提供文件。不需要调整Apache或NGINX设置。默认情况下，`SimpleHTTPServer`模块会将当前目录的内容提供给Web。
- en: 'In the same directory as the Weevely-generated file `shell.php` (`/var/www/html`),
    we can execute python with the `-m` switch to load the `SimpleHTTPServer` module.
    The last parameter is the port on which the web server will listen, in this case
    port `80`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Weevely生成的文件`shell.php`（`/var/www/html`）相同的目录下，我们可以使用带有`-m`开关的python来加载`SimpleHTTPServer`模块。最后一个参数是Web服务器监听的端口，本例中为端口`80`：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The hard part is over. Now we just have to get `shell.php` onto the target server
    using the existing shell `xampp.php`. There are a couple of ways to do this. On
    Linux servers, `wget` is almost always available and simple to use. For Windows,
    you can leverage either the built-in `bitsadmin.exe` or a sexier `powershell.exe`
    one-liner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分已经过去。现在我们只需通过现有的shell `xampp.php`将`shell.php`传输到目标服务器。可以通过几种方式实现这一点。在Linux服务器上，`wget`几乎总是可用且易于使用。对于Windows，你可以利用内置的`bitsadmin.exe`或更炫酷的`powershell.exe`一行命令。
- en: 'We can leverage `curl` and the following template to execute PowerShell commands
    on the remote host and effectively download a more advanced Weevely shell. You
    just have to plugin the appropriate values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`curl`和以下模板，在远程主机上执行PowerShell命令，并有效地下载一个更高级的Weevely shell。你只需要插入合适的值：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The command to execute, in this case, will be the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行的命令，在本例中将是以下内容：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to execute the PowerShell file downloader quietly and successfully,
    a few switches are required. The `-w` switch sets the window style to `hidden`.
    This prevents any unwanted pop-ups from appearing during execution. The `-nop`
    and `-noni` switches will disable profile loading and user interactivity respectively,
    providing a bit more stealth while executing the downloader.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了悄无声息地成功执行PowerShell文件下载器，需要一些参数开关。`-w`开关将窗口样式设置为`hidden`，防止在执行过程中出现任何不必要的弹出窗口。`-nop`和`-noni`开关将分别禁用配置文件加载和用户交互，从而在执行下载器时提供更多的隐匿性。
- en: The `-c` switch takes an arbitrary PowerShell script block to execute. For our
    purposes, we will create a new `Net.Webclient` object and call its `DownloadFile`
    method with the source and destination as the parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c` 选项接收一个任意的 PowerShell 脚本块来执行。为了我们的目的，我们将创建一个新的 `Net.Webclient` 对象，并调用它的
    `DownloadFile` 方法，将源和目标作为参数传递。'
- en: 'The PowerShell one-liner example will grab the Weevely shell contents from
    the `SimpleHTTPServer` and drop them into the appropriate `htdocs` directory on
    the application server:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 PowerShell 一行命令示例将从 `SimpleHTTPServer` 获取 Weevely shell 内容，并将其放入应用服务器的相应
    `htdocs` 目录中：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Curl has a `--data-urlencode` option, which will, you guessed it, URL encode
    our command so that it passes through HTTP without causing any problems. The `-G`
    switch ensures that the encoded data is passed via a `GET` request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Curl 有一个 `--data-urlencode` 选项，它会将我们的命令进行 URL 编码，使其通过 HTTP 传输时不会引发任何问题。`-G`
    选项确保编码后的数据通过 `GET` 请求传递。
- en: Due to the fact that the PowerShell command is spawned in a separate process,
    the simple PHP shell `xampp.php` will not be able to return any success or failure
    messages. We can verify success by attempting to connect to the shell using the
    Weevely client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PowerShell 命令在一个独立的进程中运行，简单的 PHP shell `xampp.php` 将无法返回任何成功或失败的消息。我们可以通过尝试使用
    Weevely 客户端连接到该 shell 来验证成功与否。
- en: Although it would be unusual nowadays, it is possible that PowerShell is disabled
    or unavailable on the target Windows system. In this case, using `bitsadmin.exe`
    to download payloads works just fine. Plugging in the right values, we can grab
    our Weevely shell and put it in the `htdocs` folder.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在不太常见，但目标 Windows 系统上可能会禁用或无法使用 PowerShell。在这种情况下，使用 `bitsadmin.exe` 下载 payload
    完全可行。将正确的值插入后，我们可以抓取 Weevely shell 并将其放入 `htdocs` 文件夹。
- en: 'The `bitsadmin` command template we will use is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 `bitsadmin` 命令模板如下：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just as with the PowerShell downloader, you expand the variables in your command
    and plug them into the `curl` template as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 PowerShell 下载器一样，您需要在命令中展开变量，并将它们插入到 `curl` 模板中，如下所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As the `bitsadmin` output clearly states, the binary is deprecated. While it
    is still available in all Windows versions to date, this may not be the case going
    forward. However, enterprises are somewhat slow to adopt new versions of Windows,
    so you can probably rely on this tool for several years to come.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `bitsadmin` 输出中明确指出的，二进制文件已被弃用。尽管它在所有 Windows 版本中仍然可用，但将来可能不再如此。然而，企业通常更新
    Windows 版本较慢，因此您可能仍然可以依赖此工具多年。
- en: 'The Weevely client should now be able to connect to the `test.php` shell on
    the remote host. The syntax to do this is self-explanatory:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Weevely 客户端应该能够连接到远程主机上的 `test.php` shell。执行此操作的语法不言自明：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can issue commands in the Weevely shell that will be passed directly to
    the compromised host:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Weevely shell 中发出命令，这些命令将直接传递给被攻陷的主机：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first step after getting the Weevely shell would be to remove the system
    passthrough web shell `xampp.php` artifact, created earlier as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Weevely shell 后的第一步是删除之前创建的系统通行 Web shell `xampp.php` 文件，操作如下：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, we are free to move around the server and gather any information
    that could be used in later stages of an attack. We have full control of the server,
    and can run even better reverse shells, such as Meterpreter, if needed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以自由地在服务器上移动，收集任何可以在攻击后续阶段使用的信息。我们完全控制服务器，如果需要，可以运行更强大的反向 shell，例如 Meterpreter。
- en: Even if the compromised server is segregated from the rest of the network, we
    still have access to the application code. We can backdoor it in order to gather
    network credentials from authenticated users and subsequently attack the corporate
    network. It really depends on the scope of the engagement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 即使被攻陷的服务器与网络的其他部分隔离，我们仍然能够访问应用程序代码。我们可以通过后门方式收集经过身份验证用户的网络凭证，然后进一步攻击公司网络。这实际上取决于参与的范围。
- en: Cleaning up
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: As noted, once an engagement is complete, we have to make sure that we clean
    up any artifacts that may leave the client exposed. During this attack, we created
    three files that could be used to attack the client. Although it is unlikely that
    anyone would be able to use our Weevely shell, it is wise to remove anything left
    behind. The `phpinfo.php` test file that we've created should also be deleted.
    While it doesn't provide any kind of remote access, it does display information
    that could be used in an attack.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦任务完成，我们必须确保清除任何可能让客户暴露的遗留物。在此次攻击中，我们创建了三个文件，这些文件可能被用来攻击客户。尽管不太可能有人能利用我们的Weevely外壳，但删除任何遗留物是明智的。我们创建的`phpinfo.php`测试文件也应该被删除。虽然它不提供任何远程访问，但它显示的信息可能被用来进行攻击。
- en: 'In the same way that we queried the MySQL variables to find out where the application
    resides on disk, an attacker could use the `phpinfo()` output to improve the success
    of a local file inclusion attack, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们查询MySQL变量以找出应用程序在磁盘上的位置一样，攻击者可以利用`phpinfo()`的输出，改进本地文件包含攻击的成功率，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once we remove the `test.php` shell, the Weevely client loses connectivity,
    displaying the `404` error message in the preceding code block.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们移除了`test.php`外壳，Weevely客户端将失去连接，并显示前面代码块中的`404`错误信息。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good idea to finalize the report before destroying any persistence into
    the network.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在摧毁网络中的任何持久性之前，最好先完成报告。
- en: Resources
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Consult the following resources for more information on penetration testing
    tools and techniques:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下资源以获取有关渗透测试工具和技术的更多信息：
- en: 'Mitre provides a handy website with all the CVEs available: [http://cve.mitre.org/](http://cve.mitre.org/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mitre提供了一个方便的网站，列出了所有可用的CVE：[http://cve.mitre.org/](http://cve.mitre.org/)
- en: 'Weevely documentation and bleeding edge-code is available on GitHub: [https://github.com](https://github.com)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weevely文档和最新代码可以在GitHub上找到：[https://github.com](https://github.com)
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've continued to showcase how difficult it is to get security
    right all of the time. Unfortunately, this has been, and always will be, a reality
    for most companies. As professional attackers, however, we thrive on this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续展示了始终做好安全工作是多么困难。不幸的是，这一直是，也将永远是，大多数公司的现实。然而，作为专业攻击者，我们却在这一点上茁壮成长。
- en: In our scenario, we did not tackle the application head on, spending countless
    hours interacting with the API and looking for a way to compromise it. Instead,
    we assumed that the bulk of the security-hardening effort was spent on the application
    itself, and we banked on the fact that, understandably, securing a server or development
    environment, and keeping it secure, is a difficult task.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们没有直接攻克应用程序，而是花费了大量时间与API进行交互，寻找破坏它的方法。相反，我们假设大部分的安全加固工作都花在了应用程序本身上，并且我们依赖于这样一个事实：显然，保护服务器或开发环境并保持其安全是一项困难的任务。
- en: Often, the application development lifecycle tends to focus developers and administrators
    on the application code itself, while auxiliary systems controls are neglected.
    The operating system is not patched, the firewall is wide open, and development
    database instances expose the application to a slew of simple, yet effective,
    attacks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序开发生命周期倾向于将开发人员和管理员的注意力集中在应用程序代码本身，而忽视了辅助系统控制。操作系统没有打补丁，防火墙完全开放，开发数据库实例暴露了应用程序，容易遭受一系列简单但有效的攻击。
- en: In this chapter, we looked at alternate ways to compromise the target application.
    By scanning the application server with Nmap, we found an exposed database service
    that was configured with an easily guessable password. With access to the adjacent
    service, we were able to execute code on the server and ultimately access the
    target application and more.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了以其他方式攻克目标应用程序的方法。通过使用Nmap扫描应用程序服务器，我们发现一个暴露的数据库服务，其配置了一个容易猜测的密码。通过访问该相邻服务，我们能够在服务器上执行代码，最终访问目标应用程序及更多内容。
- en: In the next chapter, we will look at advanced brute-forcing techniques and how
    to fly under the radar during engagements where stealth is key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨高级暴力破解技术以及如何在隐蔽性至关重要的任务中保持低调。
