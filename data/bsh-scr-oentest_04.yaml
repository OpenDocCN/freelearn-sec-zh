- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Variables, Conditionals, Loops, and Arrays
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量、条件语句、循环和数组
- en: In previous chapters, we provided information that led up to the topics we’ll
    be covering here. We did this by walking you through the process of getting your
    system set up and common commands that are used for navigating the Linux filesystem
    using Bash commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们提供了与当前主题相关的信息。我们通过带领你完成系统设置和常用命令的讲解，帮助你了解如何使用 Bash 命令浏览 Linux 文件系统。
- en: 'In this chapter, we’ll dive into the essentials of programming that make your
    code smart and efficient: **variables** , **conditionals** , **loops** , and **arrays**
    . Think of variables as name tags referring to data, conditionals as crossroads
    that decide which path your program takes, and loops as the way you can keep doing
    something until a certain condition is met. These concepts are the building blocks
    for creating dynamic and responsive programs. Whether you’re just starting or
    brushing up on the basics, understanding these elements is critical for any coding
    journey.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨让代码智能高效的编程要素：**变量**、**条件语句**、**循环**和**数组**。可以把变量看作是指向数据的标签，条件语句是决定程序路径的交叉点，循环则是你可以不断执行某些操作，直到满足某个条件为止。这些概念是构建动态响应程序的基石。无论你是刚开始学习还是想复习基础，理解这些要素对任何编程之旅都是至关重要的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主要主题：
- en: Introducing variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍变量
- en: Branching with conditional statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句进行分支
- en: Repeating with loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环重复
- en: Using arrays for data containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组作为数据容器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you’ll need a Linux Bash Terminal to follow along. You can
    find this chapter’s code at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，你将需要一个 Linux Bash 终端来跟随教程。你可以在[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03)找到本章的代码。
- en: Introducing variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍变量
- en: Think of variables as name tags or containers that store data. You can assign
    any data, such as text, numbers, filenames, and more, to a short and memorable
    variable name. Throughout your script, you can repeatedly refer to the data by
    its given variable name and make decisions on the data or even change the data
    the variable refers to. Technically, a variable is a declaration that allocates
    memory storage space and assigns it a value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把变量看作是存储数据的标签或容器。你可以将任何数据（例如文本、数字、文件名等）分配给一个简短且易记的变量名。在脚本中，你可以多次引用这个数据，通过变量名来访问或修改其内容。从技术上讲，变量是一种声明，它分配了内存存储空间并给它赋予了一个值。
- en: In the following subsections, we’ll be breaking the subject of variables into
    bite-sized chunks to make it easier to digest.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将把变量这一主题分解成易于消化的小块，以便更好地理解。
- en: Declaring variables
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'To declare a variable in Bash, you simply assign a value to a variable name.
    The syntax for declaring a variable is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中声明变量时，只需将一个值赋给一个变量名。声明变量的语法如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, to declare a variable named **my_variable** with a value of **Hello,
    World!** , you would use the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要声明一个名为**my_variable**的变量，并赋值为**Hello, World!**，你可以使用以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There should be no spaces around the equals sign, **=** . Also, it’s good practice
    to enclose string values in double quotes, **"** , as it allows for proper handling
    of spaces and special characters. Use single quotes to prevent expansion; double
    quotes if you want variables or special characters to be expanded. If you must
    use special characters such as **$** in a double-quoted string, you can make them
    display as a literal character instead of being evaluated by escaping the character
    with a backslash – for example, **\$** .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 等号**=**两边不应有空格。此外，最好将字符串值用双引号**"**括起来，这样可以正确处理空格和特殊字符。使用单引号可以防止扩展；如果希望变量或特殊字符被扩展，则使用双引号。如果必须在双引号字符串中使用特殊字符（如**$**），可以通过在字符前加反斜杠来使它们作为字面字符显示，而不是被求值，例如：**\$**。
- en: 'One powerful feature of Bash variables is their ability to store the output
    of commands using **command substitution** . This can be achieved by enclosing
    the command within backticks **`** , or using the **$()** syntax. Here’s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 变量的一个强大特性是它们能够存储命令的输出，使用 **命令替换**。可以通过将命令括在反引号 **`** 中，或者使用 **$()** 语法来实现。以下是一个示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can use the following implementation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下实现：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both commands will store the current date and time in the **current_date** variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令将把当前日期和时间存储在 **current_date** 变量中。
- en: 'In Bash, you can pass arguments to a script when you run it from the command
    line. These arguments are stored in special variables, which you can then use
    inside your script. Here’s how it works:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，您可以在从命令行运行脚本时传递参数。这些参数被存储在特殊的变量中，您可以在脚本内使用它们。其工作原理如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the script, you can access these arguments using the following special
    variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，您可以使用以下特殊变量访问这些参数：
- en: '**$0** : The name of the script itself'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$0**：脚本本身的名称。'
- en: '**$n** : The n th argument passed to the script, **$1** through **$9** . Examples
    include **$1** , **$2** , and **$3**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$n**：传递给脚本的第n个参数，**$1** 到 **$9**。示例包括 **$1**，**$2** 和 **$3**。'
- en: '**${10}** : The tenth argument passed to the script (curly braces are required
    for arguments >= 10)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**${10}**：传递给脚本的第十个参数（对于大于等于10的参数，必须使用花括号）。'
- en: '**$#** : The number of parameters'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$#**：参数的数量。'
- en: '**$?** : The exit status of the last executed command'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$?**：上一个执行命令的退出状态。'
- en: '**$$** : The process ID of the current shell'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$$**：当前 shell 的进程 ID。'
- en: '**$@** : Contains the command-line arguments in an array'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$@**：包含命令行参数的数组。'
- en: '**$*** : Represents all the positional parameters (arguments) passed to the
    script or a function as a single string'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$***：表示传递给脚本或函数的所有位置参数（参数），作为一个单一的字符串。'
- en: Accessing variables
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问变量
- en: 'To access the value of a variable, you simply use the variable’s name preceded
    by a dollar sign, **$** :'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问变量的值，只需使用变量的名称，前面加上美元符号 **$**：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example code can be found in the **ch03_variables_01.sh** file in this
    chapter’s folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_variables_01.sh** 文件中找到。
- en: 'This will output the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following script shows how to access command-line arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了如何访问命令行参数：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example code can be found in the **ch03_variables_02.sh** file in this
    chapter’s folder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_variables_02.sh** 文件中找到。
- en: 'If we run this script, we’ll get the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个脚本，我们将得到以下输出：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What would happen if you entered your first and last name without enclosing
    them in double quotes? Give it a try.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入名字和姓氏时没有用双引号括起来，会发生什么？试试看。
- en: 'You can perform arithmetic operations on variables using the **$(())** syntax
    or the **let** command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **$(())** 语法或 **let** 命令对变量进行算术运算：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example code can be found in the **ch03_variables_03.sh** file in this
    chapter’s folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_variables_03.sh** 文件中找到。
- en: In the preceding code block, we assign a value of **5** to the **a** variable
    and **3** to the **b** variable. Next, we added **a** and **b** and assigned the
    sum to the **c** variable. The last two lines show addition and multiplication
    using the **let** command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我们将值 **5** 赋给了 **a** 变量，将值 **3** 赋给了 **b** 变量。接下来，我们将 **a** 和 **b**
    相加，并将结果赋给了 **c** 变量。最后两行展示了使用 **let** 命令进行加法和乘法运算。
- en: 'Here’s the output when we run the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行代码时的输出：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you understand how to create and access variables, we’ll move on to
    a special type of variable, the **environment variable** .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建和访问变量，我们将继续讲解一种特殊类型的变量 —— **环境变量**。
- en: Environment variables
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: '**Environment variables** are essentially named objects that store data used
    by operating system processes. These variables can influence the behavior of software
    on the system by providing context about the user’s environment, such as the current
    user’s home directory or the path to executable files.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境变量** 本质上是命名的对象，用于存储操作系统进程所需的数据。这些变量通过提供用户环境的信息（如当前用户的主目录或可执行文件的路径），可以影响系统上软件的行为。'
- en: 'By default, variables defined in a Bash script are local to that script. To
    make a variable available to other processes (such as subshells or child processes),
    you need to export it using the **export** command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Bash 脚本中定义的变量是局部的，仅对该脚本有效。要使变量对其他进程（如子 shell 或子进程）可用，需要使用 **export**
    命令导出它：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After exporting a variable, you can access its value in subshells or child processes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出一个变量后，你可以在子Shell或子进程中访问其值。
- en: The beauty of environment variables lies in their ability to streamline processes.
    Without them, every time you want to run a program or script, you might need to
    type out the full path to its location. With environment variables, Bash knows
    where to look for certain files or directories because these paths are stored
    in variables such as **PATH** .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的美妙之处在于它们能够简化流程。如果没有它们，每次你想运行一个程序或脚本时，你可能都需要输入它的完整路径。使用环境变量后，Bash 知道该去哪里查找某些文件或目录，因为这些路径被存储在像
    **PATH** 这样的变量中。
- en: Moreover, environment variables ensure that software behaves correctly in different
    user environments. For instance, the **HOME** variable tells applications where
    a user’s home directory is located, allowing programs to save files in the right
    place without needing explicit instructions every time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，环境变量确保软件在不同用户环境下的正常运行。例如，**HOME** 变量告诉应用程序用户的主目录位置，使程序能够在正确的位置保存文件，而不需要每次都明确指示。
- en: 'Let’s put this into perspective with some practical examples. Say you frequently
    access a directory that’s buried deep within your filesystem. Typing out the full
    path every time can be tedious. By creating a custom environment variable for
    this path, you can simplify the process significantly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实际的例子来理解这一点。假设你经常访问一个深藏在文件系统中的目录。每次都输入完整的路径可能会很麻烦。通过为这个路径创建一个自定义的环境变量，你可以大大简化这个过程：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, whenever you need to access this directory, you can simply type **cd $MY_DEEP_DIRECTORY**
    , and Bash will take you there instantly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你需要访问这个目录时，你只需要输入 **cd $MY_DEEP_DIRECTORY** ，Bash 会立即带你到那里。
- en: 'Another common use case is modifying the **PATH** variable. The **PATH** variable
    tells Bash where to look for executable files. If you’ve installed a program that’s
    not in your system’s default executable paths, you can add its location to your
    **PATH** :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见用例是修改 **PATH** 变量。**PATH** 变量告诉 Bash 去哪里查找可执行文件。如果你安装了一个不在系统默认可执行路径中的程序，你可以将其位置添加到你的
    **PATH** 中：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This addition allows you to run your program from anywhere in the Terminal without
    the need to specify its full path.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加功能允许你在终端中从任何地方运行程序，而无需指定其完整路径。
- en: Notice that the path to your program is preceded by **$PATH:** . What this does
    is append the new path to the existing path. Without this, you would be overwriting
    your **PATH** and you would have errors until you fix it or reboot your computer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的程序路径前面有 **$PATH:** 。这样做是将新路径附加到现有路径后面。如果没有这一部分，你将覆盖原有的 **PATH**，并且在修复或重启计算机之前会出现错误。
- en: Important note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want an environment variable to persist across reboots, put it in your
    **.bashrc** file. To make the change to **.bashrc** take effect, run the **source
    ~/.** **bashrc** command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望一个环境变量在重启后保持有效，可以将其放入 **.bashrc** 文件中。为了让对 **.bashrc** 的更改生效，运行 **source
    ~/.bashrc** 命令。
- en: Now that you have a firm grip on variables, it’s time to cement this knowledge
    with some practice by reviewing everything you’ve learned about them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经牢牢掌握了变量的概念，是时候通过一些实践来巩固所学的知识了。
- en: A review of variables
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量回顾
- en: 'Let’s examine a script that includes everything we’ve covered so far in this
    chapter. Take a look at the following script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个包含本章所涵盖内容的脚本。请看下面的脚本：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example code can be found in the **ch03_variables_04.sh** file in this
    chapter’s folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_variables_04.sh** 文件中找到。
- en: First, it’s important to point out that I’m introducing something new here.
    Comments in scripts start with **#** and continue through the end of the line.
    Anything that follows **#** on the same line isn’t printed, provided the symbol
    isn’t escaped. You may have noticed that on one line, we used **$#** to print
    the number of parameters provided to the script. The comment behavior doesn’t
    apply in this case since it’s inside double quotes, preceded by a **$** symbol,
    and is not escaped.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要指出我在这里介绍了一些新的内容。脚本中的注释以 **#** 开头，并持续到行尾。**#** 后面的任何内容都不会被打印，前提是该符号没有被转义。你可能注意到，在某一行中，我们使用了
    **$#** 来打印传递给脚本的参数个数。由于它在双引号内，并且前面有 **$** 符号，所以注释行为不适用，且没有被转义。
- en: You must document your scripts with comments. If you need to edit your script
    after some time, comments are helpful to remind you what you were trying to do
    and are also helpful to others if you share or publish your script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须用注释来记录你的脚本。如果在一段时间后需要编辑脚本，注释会帮助你回忆当时想做什么，如果你与他人共享或发布脚本，注释也能帮助他们理解。
- en: 'Now, let’s run the script. There are two ways we can run it. We can run it
    by entering **bash** followed by the script’s name, or we can make the script
    executable and prefix the path, as shown in the following examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本。有两种方法可以运行它。我们可以通过输入 **bash** 后跟脚本名称来运行它，或者我们可以使脚本可执行并加上路径前缀，以下是示例：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, let’s list the file permissions, as you learned to do in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    :'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们列出文件权限，正如你在 [*第二章*](B22229_02.xhtml#_idTextAnchor034) 中学到的那样：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding command, you can see that we used the **-l** option with the
    **ls** command to see the permissions. It’s readable and writable for the owner,
    and only readable by the group and others. Next, let’s use the **chmod** command
    to make it executable:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，你可以看到我们使用了 **ls** 命令的 **-l** 选项来查看权限。它对所有者可读可写，对组和其他人仅可读。接下来，让我们使用 **chmod**
    命令使其可执行：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can see that after entering the **chmod** command with the **+x**
    argument, the file is now executable by the owner, group, and others. And of course,
    you could make it executable only by the owner by using the **chmod 744 ch03_variables_04.sh**
    command instead. Please refer to [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    or run the **man chmod** command if you need a refresher.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在输入了带有 **+x** 参数的 **chmod** 命令后，文件现在可以被所有者、组和其他人执行。当然，你也可以通过使用 **chmod
    744 ch03_variables_04.sh** 命令，使其仅由所有者执行。如需复习，请参考 [*第二章*](B22229_02.xhtml#_idTextAnchor034)
    或运行 **man chmod** 命令。
- en: 'Now that the file is executable, you can run it by prepending the path before
    the filename. You can specify the absolute or relative path, as discussed in [*Chapter
    2*](B22229_02.xhtml#_idTextAnchor034) . Here’s how you can run it using a relative
    path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然文件已可执行，你可以在文件名之前加上路径来运行它。你可以指定绝对路径或相对路径，正如在 [*第二章*](B22229_02.xhtml#_idTextAnchor034)
    中所讨论的那样。以下是如何使用相对路径运行它：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **shebang** ( **#!** ) is the first line in a script that specifies the
    interpreter (program) to be used for executing the script. Using the **#!/usr/bin/env
    bash** shebang tells the shell to run the script using the Bash interpreter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**shebang**（**#!**）是脚本中的第一行，用于指定执行脚本时使用的解释器（程序）。使用 **#!/usr/bin/env bash**
    shebang 告诉 shell 使用 Bash 解释器来运行脚本。'
- en: Without the shebang, the following execution method may not work because the
    shell may not know what program to use to execute the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 shebang，以下执行方法可能无法工作，因为 shell 可能不知道使用哪个程序来执行代码。
- en: If you don’t include a shebang and make your script executable, you have to
    prefix your script name with **bash** to be able to run your script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不包括 shebang 并使脚本可执行，你必须在脚本名称前加上 **bash** 才能运行脚本。
- en: By now, you should have a good grasp of how variables work. In the next section,
    you’ll learn how to use conditionals to make decisions and branches in your scripts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经很好地掌握了变量的使用。在下一节中，你将学习如何使用条件语句来做出决策并在脚本中进行分支。
- en: Branching with conditional statements
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件语句进行分支
- en: At its core, a conditional statement in Bash is a way to tell your script, “Hey,
    if this specific thing is true, then go ahead and do this; otherwise, do that.”
    It’s the foundation of making decisions in your scripts. The most common conditional
    statements you’ll encounter in Bash are **if** , **else** , and **elif** .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Bash 中的条件语句是一种告诉脚本：“嘿，如果这个特定的事情是真的，那就执行这个；否则，执行那个。”它是脚本中做决策的基础。在 Bash
    中，你最常遇到的条件语句是 **if**、**else** 和 **elif**。
- en: The if statement
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The **if** statement is the simplest form of conditional statement. It checks
    for a condition, and if that condition is true, it executes a block of code. Here’s
    a straightforward example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**if** 语句是最简单的条件语句形式。它检查一个条件，如果条件为真，则执行一段代码。下面是一个简单的示例：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example code can be found in the **ch03_conditionals_01.sh** file in this
    chapter’s folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_conditionals_01.sh** 文件中找到。
- en: 'In this example, the script checks whether the current user is **steve** based
    on matching the first command-line argument. If it is, it greets Steve. Notice
    the syntax here: square brackets around the condition, double equals for comparison,
    and **then** indicate the start of what to do if the condition is true. The **fi**
    part at the end of the **if** block signifies to the shell that it’s closing out
    the **if** statement.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，脚本通过匹配第一个命令行参数来检查当前用户是否为**steve**。如果是，它会向Steve打招呼。注意这里的语法：条件周围使用方括号，使用双等号进行比较，**then**表示条件为真时应该执行的操作开始。**fi**部分则表示结束当前的**if**语句块。
- en: 'It’s important to point out that the semicolon ( **;** ) character has a special
    meaning as a command separator. Without it, this **if** statement block would
    break. Semicolons can also be used to put multiple commands on the same line.
    The preceding **if** statement can be rewritten using more semicolons, as shown
    here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，分号（**;**）字符在这里有特殊含义，用作命令分隔符。没有它，这个**if**语句块会出错。分号还可以用来将多个命令写在同一行。前面的**if**语句可以通过更多的分号重新编写，如下所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding else
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加else
- en: 'But what if you want to do something else when the condition isn’t met? That’s
    where **else** comes in handy. It allows you to specify an alternative action
    if the condition is false. Here’s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果条件不满足时你想做别的事情呢？这时**else**就派上用场了。它允许你在条件为假时指定其他的操作。这里是一个示例：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example code can be found in the **ch03_conditionals_02.sh** file in this
    chapter’s folder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_conditionals_02.sh**文件找到。
- en: 'Now, if the user isn’t **steve** , the script responds with **Access denied.**
    :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户不是**steve**，脚本会返回**访问被拒绝**：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The power of elif
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: elif 的强大
- en: 'Sometimes, you have more than two possibilities to consider. That’s where **elif**
    (short for **else if** ) becomes useful. It lets you check multiple conditions
    one by one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要考虑的不止两种可能性。这时**elif**（即**else if**的缩写）就变得非常有用。它让你可以逐一检查多个条件：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example code can be found in the **ch03_conditionals_03.sh** file in this
    chapter’s folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_conditionals_03.sh**文件找到。
- en: In the preceding script, the **USER** variable comes from the environment variable
    for the logged-in user. Change your code in the **if** or **elif** statements
    so that it matches your username as needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，**USER**变量来自于已登录用户的环境变量。根据需要，修改**if**或**elif**语句中的代码，以使其与你的用户名匹配。
- en: 'When you run it while logged in as **Steve** , you get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以**Steve**身份登录并运行它时，你将得到以下输出：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With **elif** , you can add as many additional conditions as you need, making
    your script capable of handling a wide range of scenarios.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**elif**，你可以根据需要添加任意多个附加条件，使脚本能够处理各种不同的情况。
- en: Now that you know how to use commonly used conditional statements, let’s dive
    into slightly more advanced examples that are commonly used in Bash scripting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何使用常见的条件语句，让我们深入探讨一些在Bash脚本中常用的稍微复杂一点的示例。
- en: Beyond simple comparisons
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越简单的比较
- en: 'Bash conditional statements aren’t limited to just checking whether one thing
    equals another. You can check for a variety of conditions, including the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Bash条件语句不仅限于检查一个值是否等于另一个值。你可以检查多种条件，包括以下内容：
- en: Whether a file exists
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件是否存在
- en: Whether a variable is greater than a certain value
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是否大于某个值
- en: Whether a file is writable
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件是否可写
- en: In Bash, **primaries** refer to the expressions that are used in conditional
    tests within **[** (single-bracket), **[[** (double-bracket), and test commands.
    These primaries are used to evaluate different types of conditions, such as file
    attributes, string comparisons, and arithmetic operations. Primaries are essential
    building blocks in conditional statements, allowing you to test files, strings,
    numbers, and logical conditions. They are typically used within **if** , **while**
    , or **until** constructs to determine the flow of the script based on these evaluations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，**primaries**指的是在条件测试中使用的表达式，这些表达式位于**[**（单括号）、**[[**（双括号）和test命令中。这些原语用于评估不同类型的条件，如文件属性、字符串比较和算术运算。原语是条件语句的基本构建块，允许你测试文件、字符串、数字和逻辑条件。它们通常用于**if**、**while**或**until**结构中，用于根据这些评估结果确定脚本的执行流程。
- en: '**File test primaries** are used to check properties of files, such as whether
    they exist, are readable, are directories, and so on. The following list specifies
    file test primaries:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件测试操作符** 用于检查文件的属性，例如是否存在、是否可读、是否为目录等。以下列表列出了文件测试操作符：'
- en: '**-e FILE** : True if the file exists'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-e 文件** : 如果文件存在，则为真'
- en: '**-f FILE** : True if the file exists and is a regular file'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-f 文件** : 如果文件存在并且是常规文件，则为真'
- en: '**-d FILE** : True if the file exists and is a directory'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d 文件** : 如果文件存在并且是一个目录，则为真'
- en: '**-r FILE** : True if the file exists and is readable'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r 文件** : 如果文件存在并且可读，则为真'
- en: '**-w FILE** : True if the file exists and is writable'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-w 文件** : 如果文件存在并且可写，则为真'
- en: '**-x FILE** : True if the file exists and is executable'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-x 文件** : 如果文件存在并且是可执行的，则为真'
- en: '**-s FILE** : True if the file exists and is not empty'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s 文件** : 如果文件存在并且不为空，则为真'
- en: '**-L FILE** : True if the file exists and is a symbolic link'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-L 文件** : 如果文件存在并且是符号链接，则为真'
- en: 'For instance, checking whether a file exists before trying to read from it
    can save your script from crashing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在尝试从文件中读取之前检查文件是否存在，可以防止脚本崩溃：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example code can be found in the **ch03_conditionals_04.sh** file in this
    chapter’s folder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_conditionals_04.sh** 文件中找到。
- en: The **-f** flag tests whether the provided filename exists and is a regular
    file. To test for directories instead, we can use the **-d** flag. To test for
    both files and directories, we can use the **-e** flag. If we hadn’t checked that
    the file exists first, our script would have crashed. Using an **if** statement
    allows us to handle the error gracefully.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**-f** 标志用于测试提供的文件名是否存在并且是常规文件。要测试目录，可以使用 **-d** 标志。要同时测试文件和目录，可以使用 **-e**
    标志。如果我们没有首先检查文件是否存在，脚本可能会崩溃。使用 **if** 语句可以优雅地处理这个错误。'
- en: 'To compare integer variables in Bash, you should use the **-eq** , **-ne**
    , **-lt** , **-le** , **-gt** , and **-** **ge** primaries:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Bash 中比较整数变量，你应该使用 **-eq** 、**-ne** 、**-lt** 、**-le** 、**-gt** 和 **-ge**
    操作符：
- en: '**-eq** : True if the numbers are equal'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-eq** : 如果两个数字相等，则为真'
- en: '**-ne** : True if the numbers are not equal'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-ne** : 如果两个数字不相等，则为真'
- en: '**-gt** : True if the first number is greater than the second'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-gt** : 如果第一个数字大于第二个数字，则为真'
- en: '**-ge** : True if the first number is greater than or equal to the second'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-ge** : 如果第一个数字大于或等于第二个数字，则为真'
- en: '**-lt** : True if the first number is less than the second'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-lt** : 如果第一个数字小于第二个数字，则为真'
- en: '**-le** : True if the first number is less than or equal to the second'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-le** : 如果第一个数字小于或等于第二个数字，则为真'
- en: 'Here are some examples demonstrating integer comparisons:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例演示整数比较：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example code can be found in the **ch03_conditionals_05.sh** file in this
    chapter’s folder.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_conditionals_05.sh** 文件中找到。
- en: 'Running this code should output the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码应输出以下内容：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, I declared two variables. Then, I used the **-eq** comparison
    operator inside an **if** - **else** block to print the result. You can also do
    this all on one line, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我声明了两个变量。然后，我在 **if** - **else** 块中使用了 **-eq** 比较操作符来打印结果。你也可以把它放在一行中，像下面这样：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, I declare two variables. Then, I put the comparison
    inside square brackets. The logical and ( **&&** ) operator means *if the previous
    command is successful (that is, returns true or 0), then execute the next command*
    . Otherwise, the logical or ( **||** ) operator means *if the previous command
    is not successful (that is, returns a non-zero exit code), then execute the next
    command* . Try running this code in your Terminal and check the output. You should
    see the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我声明了两个变量。然后，我将比较放在方括号中。逻辑与（**&&**）操作符表示 *如果前一个命令成功（即返回真或0），则执行下一个命令*。否则，逻辑或（**||**）操作符表示
    *如果前一个命令不成功（即返回非零退出代码），则执行下一个命令*。尝试在终端中运行此代码并查看输出。你应该会看到以下输出：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code demonstrates how to use the less than **-lt** operator to
    compare integers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示如何使用小于 **-lt** 操作符比较整数：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example code can be found in the **ch03_conditionals_06.sh** file in this
    chapter’s folder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_conditionals_06.sh** 文件中找到。
- en: 'Running the preceding code should output the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码应输出以下内容：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following code demonstrates how to use the greater-than or equal-to operator,
    **-ge** :'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示如何使用大于或等于操作符 **-ge**：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example code can be found in the **ch03_conditionals_07.sh** file in this
    chapter’s folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_conditionals_07.sh**文件找到。
- en: 'This code should output the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出应该是：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'String comparisons in Bash are done using **=** and **!=** for equality and
    inequality, and **<** and **>** for lexicographical comparisons. The following
    are string primaries in Bash:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中的字符串比较使用**=**和**!=**表示等于和不等于，使用**<**和**>**表示字典序比较。以下是Bash中的字符串基本操作：
- en: '**-z STRING** : True if the string is empty'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-z STRING** : 如果字符串为空，则为真'
- en: '**-n STRING** : True if the string is not empty'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-n STRING** : 如果字符串不为空，则为真'
- en: '**STRING1 == STRING2** : True if the strings are equal'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STRING1 == STRING2** : 如果字符串相等，则为真'
- en: '**STRING1 != STRING2** : True if the strings are not equal'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STRING1 != STRING2** : 如果字符串不相等，则为真'
- en: 'Here’s an example demonstrating string comparisons:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示字符串比较的示例：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example code can be found in the **ch03_conditionals_08.sh** file in this
    chapter’s folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_conditionals_08.sh**文件找到。
- en: 'Here’s the output of the script:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本的输出：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example shows how to compare bytes in a string. To extract the first character
    of a string, use **byte="${string:1:1}"** . Then, compare **byte** as you would
    any other string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何比较字符串中的字节。要提取字符串的第一个字符，可以使用**byte="${string:1:1}"**。然后像比较其他字符串一样比较**byte**。
- en: So far, we’ve been comparing simple text and integer numbers. Comparing **UTF-8**
    encoded strings is the same as comparing English characters. Bash itself doesn’t
    have built-in support for direct comparison of **UTF-16** encoded strings in a
    way that it’s aware of the encoding specifics. However, you can use external tools
    such as **iconv** to convert and compare these strings. However, that subject
    is beyond the scope of this book. I simply want you to be aware of this limitation
    and where to look should you ever need to compare UTF-16 encoded strings.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在比较简单的文本和整数。比较**UTF-8**编码的字符串与比较英文字符相同。Bash本身没有内置直接比较**UTF-16**编码字符串的功能，也没有意识到编码的具体细节。然而，你可以使用外部工具，如**iconv**，来转换并比较这些字符串。不过，这个主题超出了本书的范围。我只是希望你了解这个限制，并知道如果你需要比较UTF-16编码的字符串，应该去哪里查找。
- en: Having covered comparing conditionals in depth, next, we’ll take a look at combining
    conditions using logical operators.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论条件比较之后，接下来我们将学习如何使用逻辑运算符结合条件。
- en: Combining conditions
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合条件
- en: 'What if you need to check multiple conditions at once? Bash has you covered
    with logical operators such as **&&** (AND) and **||** (OR). These operators allow
    you to combine conditions, making your scripts even smarter. The following example
    shows how to use logical operators to check multiple conditions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要同时检查多个条件怎么办？Bash通过逻辑运算符如**&&**（与）和**||**（或）为你提供了便利。这些运算符允许你组合多个条件，使你的脚本更加智能。以下示例展示了如何使用逻辑运算符检查多个条件：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example code can be found in the **ch03_conditionals_09.sh** file in this
    chapter’s folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_conditionals_09.sh**文件找到。
- en: Here, we use an **if** condition, which evaluates to **TRUE** (returns **0**
    ) if both conditions are true. This part of the code uses a logical AND, **&&**
    . This means that only if the first condition and the second condition are both
    true, then the result is true.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用**if**条件，如果两个条件都为真，则评估结果为**TRUE**（返回**0**）。这段代码使用了逻辑与运算符**&&**。这意味着只有当第一个条件和第二个条件都为真时，结果才为真。
- en: In the **elif** condition, if either evaluation is true, the block returns **TRUE**
    . Think of **&&** as “If test1 AND test2 are true, return **TRUE** ” and **||**
    as “If test1 OR test2 is true, return **TRUE** , otherwise return **FALSE** (
    returns **1** ).”
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在**elif**条件中，如果任一评估结果为真，则该块返回**TRUE**。可以将**&&**理解为“如果test1和test2都为真，返回**TRUE**”，而**||**则是“如果test1或test2为真，返回**TRUE**，否则返回**FALSE**（返回**1**）”。
- en: Logical operators simplify comparisons and save us a lot of typing! Without
    them, we would have to write much longer and more complex code. Logical comparisons
    in Bash are like decision-making tools that help your script understand and react
    to different situations. Just as you might decide what to wear based on the weather,
    your Bash script uses logical comparisons to decide what actions to take based
    on the data it processes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符简化了比较操作，并为我们节省了大量的输入！没有它们，我们不得不编写更长且更复杂的代码。Bash中的逻辑比较就像决策工具，帮助脚本理解并根据不同情况做出反应。就像你可能根据天气决定穿什么一样，Bash脚本利用逻辑比较来决定根据它处理的数据采取什么操作。
- en: Case statements
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: case语句
- en: 'Let’s look at the **case** statement. It’s somewhat like the **switch** statement
    you might know from other programming languages. The **case** statement allows
    you to match a variable against a series of patterns and execute commands based
    on the match. It’s incredibly useful when you have multiple conditions to check
    against the same variable. Here’s a simple example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 **case** 语句。它有点像你在其他编程语言中可能知道的 **switch** 语句。**case** 语句允许你将一个变量与一系列模式进行匹配，并根据匹配的结果执行命令。当你需要对同一个变量进行多个条件检查时，它非常有用。下面是一个简单的例子：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example code can be found in the **ch03_conditionals_10.sh** file in this
    chapter’s folder.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章节文件夹中的 **ch03_conditionals_10.sh** 文件中找到。
- en: In this script, we use **read -p** to prompt the user for their favorite fruit,
    assign the input to the fruit variable, and use a **case** statement to respond
    with a custom message based on this variable. The ***)** pattern acts as a catch-all,
    similar to **else** in an **if** statement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用 **read -p** 提示用户输入他们最喜欢的水果，将输入赋值给水果变量，并使用 **case** 语句根据这个变量返回一个自定义的消息。***)**
    模式充当了一个通配符，类似于 **if** 语句中的 **else**。
- en: 'When we run it, we get the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，得到如下输出：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Having introduced the Bash **read** built-in, let’s review its parameters and
    their effects:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍完 Bash 内建的 **read** 命令后，让我们回顾一下它的参数及其效果：
- en: '**-p prompt** : Display a prompt before reading input'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p prompt** ：在读取输入前显示提示符'
- en: '**t timeout** : Set a timeout for input'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**t timeout** ：为输入设置超时'
- en: '**-s** : Silent mode; do not echo input'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s** ：静默模式；不回显输入'
- en: '**-r** : Raw input; do not allow backslashes to escape characters'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r** ：原始输入；不允许反斜杠转义字符'
- en: '**-a array** : Read input into an array'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-a array** ：将输入读入数组'
- en: '**-n nchars** : Read only **nchars** characters'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-n nchars** ：只读取 **nchars** 个字符'
- en: '**-d delimiter** : Read until the first occurrence of the delimiter instead
    of a newline'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d delimiter** ：读取直到遇到第一个定界符，而不是换行符'
- en: Bash conditional statements are a powerful tool in your scripting arsenal. They
    allow your scripts to make decisions and react to different situations intelligently.
    By understanding and using **if** , **else** , **elif** , and **case** , and combining
    conditions with logical operators such as **&&** and **||** , you can write more
    efficient and responsive Bash scripts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 条件语句是你脚本工具箱中的一项强大工具。它们使得你的脚本可以做出决策，并智能地应对不同的情况。通过理解和使用 **if**、**else**、**elif**
    和 **case**，并结合 **&&** 和 **||** 等逻辑运算符，你可以编写更高效、更灵活的 Bash 脚本。
- en: With conditionals added to our arsenal, we’ll explore loops in the next section.
    Loops, when combined with conditionals and variables, make our scripting so much
    more powerful!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了条件语句后，我们将在下一节探索循环。当循环与条件语句和变量结合时，它们使我们的脚本更强大！
- en: Repeating with loops
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复
- en: Bash loops are iteration statements, a repetition of a process. Imagine that
    you have the output of many lines of data from log files or vulnerability scans.
    Reviewing each line manually would be akin to climbing a mountain with your hands
    tied; possible, but unnecessarily challenging. Bash loops, with their simple syntax
    and versatile application, turn this mountain into a molehill. In this section,
    we’ll dive into the essence of Bash loops, exploring their types, how they work,
    and why they’re an indispensable part of scripting in Linux environments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 循环是迭代语句，是一个过程的重复。假设你有来自日志文件或漏洞扫描的多行数据的输出。手动检查每一行就像是用绑着的双手爬山；虽然可能做到，但不必要地具有挑战性。Bash
    循环以其简单的语法和多样的应用，将这座大山变成了小土堆。在这一节中，我们将深入探讨 Bash 循环的本质，了解它们的类型、如何工作，以及它们为何是 Linux
    环境中脚本编写不可或缺的一部分。
- en: The for loop
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for 循环
- en: 'The **for** loop is your go-to when you know how many times you want to repeat
    an action. It’s like saying, “For each item in this list, do this task.” Bash
    **for** loops iterate over a list of items or a range of values, executing commands
    for each item. Here’s the basic **for** loop syntax:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** 循环是你在知道需要重复多少次某个动作时的首选。它就像是在说：“对于列表中的每一项，做这件事。” Bash **for** 循环会遍历一个项列表或一个值的范围，并为每一项执行命令。下面是基本的
    **for** 循环语法：'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that the **for** loop starts with a syntax that looks like “for this
    one item in a list of items.” In the case of a file, this could be **for $line
    in lines** . This statement initializes the loop. Next, you have the **do** keyword,
    followed by the loop statements, ending finally with **done** .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**for**循环的语法通常是“在一组项目中对每个项目执行操作”。对于文件来说，这可能是**for $line in lines**。该语句初始化了循环。接下来是**do**关键字，后跟循环语句，最后以**done**结束。
- en: 'Imagine that you have a folder that contains some text files and you want to
    print their names:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含一些文本文件的文件夹，并且你想打印出它们的文件名：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This loop goes through each file with a **.txt** extension in the current directory,
    assigning the filename to the **file** variable before printing it out using the
    **echo** statement.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会遍历当前目录中每个以**.txt**扩展名结尾的文件，将文件名赋值给**file**变量，然后通过**echo**语句将其打印出来。
- en: 'When you’re writing a simple script such as the one shown here, it’s usually
    easier to make this a *one-liner* by separating each section using a semicolon,
    as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个简单的脚本，如这里所示时，通常通过使用分号将每个部分分隔开，可以更轻松地将其写成一个*单行脚本*，如下所示：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that **for** loops are sometimes used with a **sequence** . The Bash sequence
    expression generates a range of integers or characters. You define the start and
    end points of the range of integers or characters. A sequence consists of a range
    of values in curly brackets. This sequence takes the form of **{START..END[..INCREMENT]}**
    . If **INCREMENT** isn’t provided, it is **1** by default. A sequence is generally
    used in combination with **for** loops. Here’s a simple example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**for**循环有时会与**sequence**（序列）一起使用。Bash的序列表达式生成一个整数或字符的范围。你需要定义整数或字符范围的起始和结束点。一个序列由大括号中的值范围组成。这个序列的形式为**{START..END[..INCREMENT]}**。如果没有提供**INCREMENT**，则默认值为**1**。序列通常与**for**循环结合使用。这里有一个简单的示例：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that you’ve learned about **for** loops, let’s move on and explore **while**
    loops.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了**for**循环，让我们继续学习并探索**while**循环。
- en: The while loop
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while 循环
- en: 'Use a **while** loop when you want to repeat a task until a certain condition
    is no longer true. It’s like saying, “While this is true, keep going.” Here’s
    the basic syntax of a **while** loop:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想重复执行一个任务，直到某个条件不再为真时，使用**while**循环。这就像在说：“只要这个条件为真，就继续执行。”以下是**while**循环的基本语法：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here’s an example where we create a countdown from **5** :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建从**5**开始倒计时的例子：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example code can be found in the **ch03_loops_01.sh** file in this chapter’s
    folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_loops_01.sh**文件中找到。
- en: In this example, we initialize the **count** variable to **5** . Then, we check
    the value of **count** ; if it’s greater than **0** , we print the value and then
    decrement the value by **1** . The loop continues to run, so long as **count**
    is greater than **0** . Each iteration decreases **count** by **1** until it is
    **0** .
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将**count**变量初始化为**5**。然后，我们检查**count**的值；如果它大于**0**，我们打印该值，然后将其值减去**1**。只要**count**大于**0**，循环就会继续执行。每次迭代都会将**count**减去**1**，直到它变为**0**。
- en: 'Running this script results in the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本会得到以下输出：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The most common way I use **while** loops is to read host names or IP addresses
    from a file and perform some operation on them. Sometimes, pentesting tools perform
    some operation on a single host and I want to run them across a list of hosts.
    Here’s a quick example where I use a one-line script with a **while** loop to
    read IP addresses from a file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用**while**循环的最常见方式是从文件中读取主机名或IP地址，并对其执行一些操作。有时，渗透测试工具会对单个主机执行某些操作，而我希望对一组主机进行操作。以下是一个简单示例，我使用一行脚本和**while**循环从文件中读取IP地址：
- en: '![Figure 3.1 – Demonstrating a one-line while loop](image/B22229_03_1.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 演示一行的 while 循环](image/B22229_03_1.jpg)'
- en: Figure 3.1 – Demonstrating a one-line while loop
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 演示一行的 while 循环
- en: I’ll explain this in more detail shortly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会更详细地解释这一点。
- en: 'Another example is the **PetitPotam** tool, which is used for coercing password
    hashes from unpatched Windows hosts. You can find more information about this
    and download the tool from [https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)
    . This tool accepts only one target host. Here, I’ve run it against a file containing
    a list of hosts using the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是**PetitPotam**工具，它用于从未修补的Windows主机中强制获取密码哈希。你可以从[https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)获取更多信息并下载此工具。该工具只接受一个目标主机。在这里，我通过以下命令将其应用于包含主机列表的文件：
- en: '![Figure 3.2 – Demonstrating a one-line while loop with PetitPotam](image/B22229_03_2.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 演示使用 PetitPotam 的单行 while 循环](image/B22229_03_2.jpg)'
- en: Figure 3.2 – Demonstrating a one-line while loop with PetitPotam
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 演示使用 PetitPotam 的单行 while 循环
- en: 'The contents of the preceding screenshot can be explained as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图的内容可以解释如下：
- en: '**while read line** : The **while** keyword ensures that we continue performing
    the loop until the condition is no longer true. In this case, we continue looping
    until it has reached the end of the file. The **read** keyword reads one line
    up until the newline from standard input ( **stdin** ) and assigns the data read
    to a variable named **line** . The **read** command returns a non-zero ( **false**
    ) status when it reaches the end of the file, causing the loop to terminate.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while read line** : **while** 关键字确保我们会继续执行循环，直到条件不再成立。在这种情况下，我们会继续循环，直到文件结束。**read**
    关键字从标准输入 (**stdin**) 中读取一行，直到遇到换行符，并将读取到的数据赋值给名为 **line** 的变量。当 **read** 命令读取到文件末尾时，会返回一个非零（**false**）状态，导致循环终止。'
- en: In Bash scripting, semicolons ( **;** ) are used to separate multiple commands
    on the same line. This allows you to write concise, one-line scripts where multiple
    commands are executed sequentially.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bash 脚本中，分号（**;**）用于在同一行中分隔多个命令。这使得你可以编写简洁的单行脚本，按顺序执行多个命令。
- en: '**do python3 PetitPotam.py 10.2.10.99 $line** : In Bash scripting, the **do**
    keyword marks the beginning of the block of commands to be executed in each iteration
    of a loop. In this case, it’s running the **PetitPotam** command. The first IP
    address, **10.2.10.99** , is my Kali host IP address. The **$line** variable is
    the line of data that’s been read from the file. This becomes the target IP address
    for the **PetitPotam** command.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**do python3 PetitPotam.py 10.2.10.99 $line** : 在 Bash 脚本中，**do** 关键字标志着每次循环迭代中要执行的命令块的开始。在这种情况下，它运行的是
    **PetitPotam** 命令。第一个 IP 地址 **10.2.10.99** 是我的 Kali 主机的 IP 地址。**$line** 变量是从文件中读取的一行数据，它成为
    **PetitPotam** 命令的目标 IP 地址。'
- en: '**done** : In Bash scripting, the **done** keyword marks the end of the block
    of commands that are executed in each iteration of a loop.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**done** : 在 Bash 脚本中，**done** 关键字标志着每次循环迭代中执行的命令块的结束。'
- en: '**< ips.txt** : I’m redirecting the content of the **ips.txt** file to **stdin**
    to be read by the **read** command. This file contains a list of IP addresses,
    with one address on each line.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**< ips.txt** : 我将 **ips.txt** 文件的内容重定向到 **stdin**，以便被 **read** 命令读取。该文件包含一个
    IP 地址列表，每行一个地址。'
- en: 'Before running the **PetitPotam** command, I ran **Responder** in another Terminal
    tab using the **sudo responder -I eth0** command. Responder is a rogue server
    that’s designed to elicit authentication from victims. Make sure you replace the
    IP address with your own if you’re performing this exercise. In the Responder
    output, I found that I captured a password hash from a vulnerable system:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 **PetitPotam** 命令之前，我在另一个终端标签中使用 **sudo responder -I eth0** 命令运行了 **Responder**。Responder
    是一个恶意服务器，旨在从受害者处获取认证信息。如果你正在进行这个练习，请确保将 IP 地址替换为你自己的。在 Responder 输出中，我发现从一个易受攻击的系统捕获了密码哈希：
- en: '![Figure 3.3 – A password hash has been captured from the victim](image/B22229_03_3.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 捕获到来自受害者的密码哈希](image/B22229_03_3.jpg)'
- en: Figure 3.3 – A password hash has been captured from the victim
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 捕获到来自受害者的密码哈希
- en: Without the Bash **while** loop, I would have had to run the command manually
    for each host on the network. If I were testing a large network, this could be
    very tiring and I would have wasted a lot of time had I not harnessed the power
    of Bash!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 Bash **while** 循环，我就得为网络中的每个主机手动运行命令。如果我在测试一个大规模的网络，手动操作会非常疲惫，且如果没有利用 Bash
    的强大功能，我可能会浪费大量时间！
- en: Now that you’ve learned the power of **while** loops, let’s look at its alter-ego,
    the **until** loop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 **while** 循环的强大功能，让我们来看一下它的替代者，**until** 循环。
- en: The until loop
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: until 循环
- en: The **until** loop is the opposite of the **while** loop. It keeps running until
    a condition becomes true. Think of it as, “Until this happens, do that.”
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**until** 循环与 **while** 循环相反。它会一直运行，直到某个条件变为真。可以把它理解为：“直到发生这个，才做那个。”'
- en: 'The basic syntax of the **until** loop is shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**until** 循环的基本语法如下所示：'
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Suppose you’re waiting for a file named **done.txt** to appear in the current
    directory:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在等待一个名为 **done.txt** 的文件出现在当前目录中：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This example code can be found in the **ch03_loops_02.sh** file in this chapter’s
    folder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例代码可以在本章文件夹中的 **ch03_loops_02.sh** 文件中找到。
- en: This loop runs until done **.txt** exists, checking every second.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环将持续运行，直到**done.txt**文件存在，每秒检查一次。
- en: I rarely use the **until** loop; however, it is very particular in some circumstances
    when you want to do something until a condition is true.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少使用**until**循环；然而，在某些情况下，当你想要做某件事直到某个条件为真时，它非常适用。
- en: Next, we’ll explore how to use **select** to build interactive menus!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用**select**来构建交互式菜单！
- en: Select – interactive menus made easy
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**select** — 简化交互式菜单'
- en: 'Another lesser-known loop command is **select** . It’s perfect for creating
    simple interactive menus in your scripts. With **select** , users can choose from
    options presented to them, making it ideal for navigation or settings menus:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个较不为人知的循环命令是**select**。它非常适合在脚本中创建简单的交互式菜单。使用**select**，用户可以从呈现的选项中进行选择，非常适合用作导航或设置菜单：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This example code can be found in the **ch03_loops_03.sh** file in this chapter’s
    folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_loops_03.sh**文件中找到。
- en: This script presents a list of programming languages and executes commands based
    on the user’s selection. The **select** command automatically creates a numbered
    menu, and the user inputs the number corresponding to their choice. Notice that
    each option must end with two semicolon ( **;;** ) characters. The ***)** expression
    is a fall-through that catches anything that’s entered that doesn’t match the
    previous choices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本展示了一系列编程语言，并根据用户的选择执行相应命令。**select**命令会自动创建一个编号菜单，用户输入对应的数字来选择。请注意，每个选项后面必须加上两个分号（**;;**）。***)**表达式是一个“穿透”选项，用来捕获那些没有匹配前面选项的输入。
- en: 'Here’s what it looks like when you run it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时的效果如下：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that when you run it, it continues to loop forever until you enter **5**
    for **Quit** , which uses the **break** statement in the code. The **break** statement
    breaks out of the loop. The **break** statement can be used in any loop to exit
    the loop, regardless of the conditional statement return value.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你运行它时，它会持续循环，直到你输入**5**以退出，这时使用了代码中的**break**语句。**break**语句会跳出循环。**break**语句可以在任何循环中使用，以退出循环，无论条件语句的返回值是什么。
- en: Now that you have a firm grasp of using loops, let’s explore some advanced examples.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了使用循环的方法，让我们来探索一些高级示例。
- en: Advanced usage – nested loops
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级用法 —— 嵌套循环
- en: 'You can nest loops within each other and use the **break** and **continue**
    keywords to control the flow more precisely. Here’s an example that prints a simple
    pattern:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将循环嵌套在彼此之间，并使用**break**和**continue**关键字来更精确地控制流程。下面是一个打印简单图案的示例：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This example code can be found in the **ch03_loops_04.sh** file in this chapter’s
    folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_loops_04.sh**文件中找到。
- en: 'This script prints a 3x3 grid of numbers, showing how nested loops work:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本打印了一个3x3的数字网格，展示了嵌套循环的工作原理：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, let’s explore how the **break** and **continue** keywords can be used
    to help us use advanced logic in nested loops.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨如何使用**break**和**continue**关键字，帮助我们在嵌套循环中使用高级逻辑。
- en: Using break and continue
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用**break**和**continue**
- en: 'The **break** command completely exits the loop, while the **continue** command
    skips the rest of the current loop and starts the next iteration. The following
    example combines **break** and **continue** to demonstrate these concepts:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**break**命令会完全退出循环，而**continue**命令会跳过当前循环的其余部分，开始下一次迭代。以下示例结合了**break**和**continue**来演示这些概念：'
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example code can be found in the **ch03_loops_05.sh** file in this chapter’s
    folder.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_loops_05.sh**文件中找到。
- en: 'In the preceding example, a **for** loop iterates over a sequence of **1**
    to **20** . Next, I introduce the **modulus** operator, **%** , which results
    in the remainder of a division operation. If the remainder isn’t zero, it continues
    to the next iteration of the loop. If the value of **i** equals **10** , it breaks
    out of the loop. Otherwise, it prints the value of **i** . Here’s the result of
    running this code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，**for**循环遍历了从**1**到**20**的一个序列。接下来，我介绍了**取余**运算符**%**，它返回除法运算的余数。如果余数不为零，循环将继续执行下一次迭代。如果**i**的值等于**10**，则退出循环。否则，它会打印出**i**的值。运行该代码后的结果如下：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you would expect, it prints all even numbers and exits when it reaches **10**
    .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，它会打印出所有偶数，并在到达**10**时退出。
- en: Bash loops are a fundamental part of scripting that can simplify and automate
    repetitive tasks. Whether you’re iterating over files, waiting for conditions,
    or creating interactive menus, understanding these loops can significantly enhance
    your scripting prowess. Start small, experiment with examples, and soon you’ll
    be looping like a pro!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Bash循环是脚本编写的基础部分，可以简化和自动化重复任务。无论是迭代文件、等待条件，还是创建交互式菜单，理解这些循环可以显著提升你的脚本技巧。从小处开始，尝试示例，很快你就能像专家一样进行循环操作！
- en: 'In the next section, you’ll combine what you learned previously with a new
    concept: arrays.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将结合之前学到的内容和一个新概念：数组。
- en: Using arrays for data containers
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组作为数据容器
- en: One of the powerful features of Bash scripting is the use of arrays. Arrays
    allow you to store multiple values in a single variable, making your scripts more
    efficient and your code cleaner. Let’s dive into the basics of Bash arrays and
    explore how they can be utilized through practical examples.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Bash脚本的一个强大特性是数组的使用。数组允许你在一个变量中存储多个值，这使得你的脚本更加高效，代码更简洁。让我们深入了解Bash数组的基础知识，并通过实际示例探索如何利用它们。
- en: At its core, an array is a collection of elements that can be accessed by an
    index. Think of it as a row of mailboxes, each with a unique number. You can store
    different pieces of mail (data) in each mailbox (element) and retrieve them using
    their mailbox number (index).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，数组是一个可以通过索引访问的元素集合。可以把它想象成一排邮箱，每个邮箱都有一个唯一的号码。你可以在每个邮箱（元素）中存储不同的邮件（数据），并通过它们的邮箱号码（索引）来取出它们。
- en: In Bash, arrays are incredibly flexible. They don’t require you to declare a
    type, and they can grow or shrink as needed. This means you can add or remove
    elements without having to worry about the size of the array.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，数组非常灵活。它们不要求你声明类型，并且可以根据需要增长或缩小。这意味着你可以在不必担心数组大小的情况下添加或删除元素。
- en: 'Declaring an array in Bash is straightforward. You don’t need to explicitly
    declare a variable as an array; simply assigning values to it in an array context
    does the job. Here’s a simple example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中声明数组非常直接。你不需要显式地声明变量为数组；只需在数组上下文中为其赋值即可。以下是一个简单的示例：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This line creates an array named **my_array** with three elements: **apple**
    , **banana** , and **cherry** .'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个名为**my_array**的数组，其中包含三个元素：**apple**、**banana**和**cherry**。
- en: 'To access an element in an array, you must use the following syntax:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组中的元素，必须使用以下语法：
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember, array indices in Bash start at **0** . So, to access the first element
    (apple) in **my_array** , you would use the following syntax:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Bash中的数组索引从**0**开始。所以，要访问**my_array**中的第一个元素（apple），你可以使用以下语法：
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Adding elements to an array or modifying existing ones is just as simple. To
    add an element to the end of the array, you can use the following syntax:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组添加元素或修改现有元素同样简单。要将元素添加到数组的末尾，可以使用以下语法：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The **+=** operator is common to many programming languages. This operation
    says **my_array** is equal to the current value of **my_array** plus **date**
    .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**+=**操作符在许多编程语言中都很常见。这个操作表示**my_array**等于当前的**my_array**值加上**date**。'
- en: 'Now, **my_array** contains four elements: **apple** , **banana** , **cherry**
    , and **date** . To modify an existing element, you must directly assign a new
    value to it:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**my_array**包含四个元素：**apple**、**banana**、**cherry**和**date**。要修改现有元素，必须直接为其赋予新值：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command changes the second element from **banana** to **blueberry** .
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将第二个元素从**banana**更改为**blueberry**。
- en: Looping through arrays
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'Looping through arrays is a common task in scripting. Here’s how you can iterate
    over each element in **my_array** :'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组是脚本中常见的任务。以下是如何遍历**my_array**中的每个元素：
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This example code can be found in the **ch03_arrays_01.sh** file in this chapter’s
    folder.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_arrays_01.sh**文件中找到。
- en: 'This loop prints each element in the array on a new line, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会在新的一行打印数组中的每个元素，如下所示：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Bash also supports **associative arrays** (sometimes called **hash maps** or
    **dictionaries** ), where each element is identified by a key instead of a numeric
    index. To declare an associative array, use the **-A** flag with the **declare**
    keyword:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Bash还支持**关联数组**（有时称为**哈希映射**或**字典**），其中每个元素由一个键而不是数字索引来标识。要声明一个关联数组，使用**-A**标志与**declare**关键字：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example code can be found in the **ch03_arrays_02.sh** file in this chapter’s
    folder.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch03_arrays_02.sh**文件中找到。
- en: Accessing and modifying elements in an associative array works similarly to
    indexed arrays, but you use keys instead of numeric indices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和修改关联数组中的元素的方式类似于索引数组，但你使用的是键而非数字索引。
- en: In the preceding script, the associative array is declared by using **declare
    -A** and the array’s name. Then, key/value pairs are added to the associative
    array. Next, the **for** loop uses the **key** variable to access each loop in
    the array.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，关联数组是通过使用 **declare -A** 和数组名称来声明的。然后，将键值对添加到关联数组中。接下来，**for** 循环使用
    **key** 变量来访问数组中的每个循环。
- en: Important note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can refer to the whole associative array using **"${!my_assoc_array[@]}"**
    .
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 **"${!my_assoc_array[@]}"** 引用整个关联数组。
- en: 'Finally, during each iteration of the **for** loop, the current key/value pair
    is printed:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次 **for** 循环迭代中，当前的键值对将被打印出来：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You may have noticed that associative arrays in Bash don’t maintain order; they’re
    unordered collections of key/value pairs. This is why the key/value pairs were
    printed in a different order than the order they were added to the array.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 Bash 中的关联数组并不保持顺序；它们是无序的键值对集合。这就是为什么键值对被打印出来的顺序与它们添加到数组中的顺序不同。
- en: 'You can access the value of a specific associative array key/value pair using
    the following syntax:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法访问特定关联数组键值对的值：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following script shows the same code as the previous script with this concept
    added on the last line:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了与前一个脚本相同的代码，只是在最后一行添加了这个概念：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This example code can be found in the **ch03_arrays_03.sh** file in this chapter’s
    folder.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch03_arrays_03.sh** 文件中找到。
- en: 'The output of this script is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的输出如下：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Bash arrays are a powerful feature that can make your scripts more efficient
    and easier to read. Whether you’re storing a simple list of items or dealing with
    more complex data structures, such as associative arrays, understanding how to
    work with arrays will significantly enhance your scripting capabilities. Remember,
    practice is key to mastering Bash arrays, so don’t hesitate to experiment with
    the examples provided and explore further applications on your own.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 数组是一个强大的功能，可以使你的脚本更加高效且易于阅读。无论你是存储一个简单的项目列表，还是处理更复杂的数据结构，如关联数组，了解如何使用数组将显著提升你的脚本能力。记住，实践是掌握
    Bash 数组的关键，所以不要犹豫，尽管尝试提供的示例并自行探索更多应用。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes a closely related set of topics. Bash variables, conditionals,
    loops, and arrays are tools in Bash scripting for storing data, making decisions,
    repeating tasks, and handling lists of values, respectively.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了一组紧密相关的主题。Bash 变量、条件语句、循环和数组是 Bash 脚本中的工具，分别用于存储数据、做出决策、重复任务和处理值列表。
- en: The loop is the star of the show. Just like the cast of any show, they require
    a supporting cast. In the case of loops, they require variables to assign labels
    to data, conditionals to test equality, and arrays to store data. Together, they
    work as a team and make your Bash scripts much more powerful and flexible.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是整个过程的明星。就像任何节目的演员阵容一样，循环也需要配角。对于循环，它们需要变量来为数据分配标签，需要条件语句来测试相等性，还需要数组来存储数据。它们齐心协力，使你的
    Bash 脚本更加强大和灵活。
- en: In the next chapter, you’ll learn about Bash regular expressions, a valuable
    skill that you’ll need to master to search and match text effectively.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习 Bash 正则表达式，这是一项宝贵的技能，你需要掌握它才能有效地进行文本搜索和匹配。
