- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Advanced Attack Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级攻击技巧
- en: Welcome to [*Chapter 10*](B18829_10.xhtml#_idTextAnchor362), *Advanced Attack
    Techniques*. In this chapter, we will cover some advanced attacks, such as **XML
    external entity** (**XXE**) attacks and Java deserialization, where we will explain
    and demonstrate exploiting these vulnerabilities on the testing applications.
    We will also have fun brute-forcing the password change on one of the applications,
    conducting web cache poisoning, and working with JSON Web Tokens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [*第 10 章*](B18829_10.xhtml#_idTextAnchor362)，*高级攻击技巧*。在本章中，我们将介绍一些高级攻击技术，如
    **XML 外部实体**（**XXE**）攻击和 Java 反序列化，我们将解释并演示如何在测试应用程序中利用这些漏洞。我们还将有趣地进行密码更改的暴力破解、Web
    缓存中毒以及处理 JSON Web Tokens。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Performing XXE attacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 XXE 攻击
- en: Working with JSON Web Tokens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON Web Tokens
- en: Performing Java deserialization attacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 Java 反序列化攻击
- en: Password brute-force via password change
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码暴力破解通过密码更改
- en: Web cache poisoning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 缓存中毒
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to utilize a common browser such as Mozilla Firefox.
    You will also utilize your PortSwigger account for access to the PortSwigger Academy
    labs that will be used in this chapter’s recipes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你需要使用常见的浏览器，如 Mozilla Firefox。你还需要使用你的 PortSwigger 账户来访问将用于本章实验的 PortSwigger
    Academy 实验室。
- en: Performing XXE attacks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 XXE 攻击
- en: In an XXE attack, the attacker sends XML input that includes a reference to
    an external entity to an application. The XML input causes the application to
    behave in a manner that it was not intended to. Successful exploitation of an
    XXE attack can lead to an attacker viewing the content of files, exfiltrating
    data, **server-side request forgery** (**SSRF**), and remote code executions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XXE 攻击中，攻击者向应用程序发送包含外部实体引用的 XML 输入。此 XML 输入会导致应用程序表现出未预期的行为。成功利用 XXE 攻击可能导致攻击者查看文件内容、窃取数据、**服务器端请求伪造**（**SSRF**）以及远程代码执行。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to be able to intercept
    requests and responses from the server to your browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个 PortSwigger Academy 账户，并且需要 ZAP 来拦截来自服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this lab, we will walk through performing an XXE attack to retrieve the
    contents of the **passwd** file. Please follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将演示执行 XXE 攻击以检索 **passwd** 文件的内容。请按照以下说明操作：
- en: 'Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab. The lab we will work on in this section is
    *Exploiting XXE Using External Entities to Retrieve Files*. The link to the lab
    is accessed here: [https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代理到 ZAP 的浏览器导航到 URL，并登录到 PortSwigger Academy 网站以启动实验室。我们将在本节中进行的实验是 *利用外部实体的
    XXE 攻击来检索文件*。实验链接如下：[https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files)。
- en: Start the lab, add it to the context, and click on **Show only URLs** **in Scope**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动实验，将其添加到上下文中，并点击 **仅显示范围内的 URL**。
- en: On the lab home page, click on **View details** under any product. Then click
    on **Check stock**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实验室主页上，点击任意产品下方的 **查看详情**。然后点击 **检查库存**。
- en: Clicking on **Check stock** sends a **POST** request to the application. Let’s
    find the **POST** request. Right-click the request and select **Open/Resend with**
    **Request Editor**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **检查库存** 会向应用程序发送一个 **POST** 请求。让我们找到这个 **POST** 请求。右键点击请求并选择 **使用请求编辑器打开/重新发送**。
- en: 'Once the **Request Editor** window opens, add the following payload after the
    XML declaration and replace the product ID with the **xxe** external entity reference,
    as shown in *Figure 10**.1*. Then, click **Send**:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 **请求编辑器** 窗口打开，在 XML 声明后添加以下有效负载，并将产品 ID 替换为 **xxe** 外部实体引用，如 *图 10.1* 所示。然后，点击
    **发送**：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 10.1 – XXE attack](image/Figure_10.1_B18829.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – XXE 攻击](image/Figure_10.1_B18829.jpg)'
- en: Figure 10.1 – XXE attack
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – XXE 攻击
- en: 'As you can see in the **Response** tab, the content of the **passwd** file
    is listed in the returned response, as shown in *Figure 10**.2*:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你在 **响应** 标签页中看到的，**passwd** 文件的内容在返回的响应中列出，如 *图 10.2* 所示：
- en: '![Figure 10.2 – The passwd file](image/Figure_10.2_B18829.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – passwd 文件](image/Figure_10.2_B18829.jpg)'
- en: Figure 10.2 – The passwd file
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – passwd 文件
- en: This concludes this lab.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本实验的全部内容。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原理...
- en: An XXE attack is a type of vulnerability that can be found in applications that
    process XML input. This type of attack occurs when an attacker is able to inject
    malicious external entities into an XML document, which can then be used to compromise
    the security of the application or the underlying system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: XXE 攻击是一种可以在处理 XML 输入的应用程序中发现的漏洞。此类攻击发生在攻击者能够将恶意外部实体注入到 XML 文档中，然后这些外部实体可以用来危害应用程序或底层系统的安全性。
- en: In an XXE attack, the attacker first creates an XML document containing a reference
    to an external entity, typically a remote file or resource. The attacker then
    submits this malicious XML document to the vulnerable application, which attempts
    to process it and access the external entity. This can cause the application to
    either crash or disclose sensitive information, such as internal network addresses
    or system files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XXE 攻击中，攻击者首先创建一个包含外部实体引用的 XML 文档，通常是远程文件或资源。然后，攻击者将这个恶意的 XML 文档提交给易受攻击的应用程序，应用程序尝试处理并访问外部实体。这可能导致应用程序崩溃或泄露敏感信息，例如内部网络地址或系统文件。
- en: In this recipe, we viewed the content of the **/etc/passwd** file by performing
    an XXE injection attack. And to perform the XXE injection attack, we changed the
    XML input by adding the **DOCTYPE** element to add the external entity that includes
    the **passwd** file path. Then the external entity was used in the **productId**
    value, which caused the application to return the **passwd** file content in the
    response, which enabled us to gather more information about the accounts in the
    system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们通过执行 XXE 注入攻击查看了 **/etc/passwd** 文件的内容。为了执行 XXE 注入攻击，我们通过添加 **DOCTYPE**
    元素更改了 XML 输入，以便加入包含 **passwd** 文件路径的外部实体。然后，外部实体被用在 **productId** 值中，导致应用程序在响应中返回
    **passwd** 文件内容，这使我们能够收集更多关于系统账户的信息。
- en: Working with JSON Web Tokens
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作 JSON Web Tokens
- en: '**JSON Web Tokens** (**JWTs**) are used for authentication, session handling,
    and authorization of data between systems. JWT vulnerabilities are usually design
    flaws, misconfigurations, or the use of insecure libraries. When testing for JWT
    flaws, the tester attempts to bypass the signature verification process, which
    bypasses the authentication or authorization mechanism. The information sent in
    the JWTs are called claims and are cryptographically signed JSON objects. Each
    JWT is made out of three sections; the first is a header, the second is the payload,
    and the third is a signature. Each section is divided by a **.** (dot) and encoded
    using **base64** encoding. The header contains information about the token, the
    payload section includes the claims, and the signature is usually a hashed value
    of the header and the payload section combined and used for integrity checks.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens**（**JWTs**）用于身份验证、会话管理和系统间的数据授权。JWT 漏洞通常是设计缺陷、配置错误或使用不安全的库所导致的。在测试
    JWT 漏洞时，测试者尝试绕过签名验证过程，从而绕过身份验证或授权机制。JWT 中传递的信息称为声明（claims），并且是经过加密签名的 JSON 对象。每个
    JWT 由三部分组成：第一部分是头部，第二部分是负载，第三部分是签名。每个部分用 **.**（点）分隔，并使用 **base64** 编码。头部包含有关令牌的信息，负载部分包括声明，签名通常是头部和负载部分的哈希值，常用于完整性检查。'
- en: In this recipe, you will attack a misconfigured server that issues JWTs to accept
    unsigned tokens. To finish the lab, we will walk you through deactivating the
    user – Carlos – and change the session token so that you can access the admin
    panel.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将攻击一个配置错误的服务器，该服务器发放允许接受未签名令牌的 JWT。为了完成实验，我们将指导你停用用户 – Carlos – 并更改会话令牌，以便你可以访问管理员面板。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: This lab requires a PortSwigger Academy account, a **Base64** encoder/decoder,
    and ZAP should be able to intercept requests and responses from the server to
    your browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个 PortSwigger Academy 账户，一个 **Base64** 编码/解码器，并且 ZAP 应该能够拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, we will complete the PortSwigger Academy’s *JWT authentication
    bypass via flawed signature verification* lab to demonstrate how to change the
    values in the JWT payload to log in as the administrator and delete a user account.
    Take the following steps to start the lab:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将完成 PortSwigger Academy 的 *JWT 身份验证绕过通过签名验证漏洞* 实验，演示如何更改 JWT 负载中的值，以管理员身份登录并删除用户账户。按照以下步骤开始实验：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the *JWT authentication bypass via flawed signature
    verification* lab ([https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification)).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器代理到ZAP，导航到URL并登录PortSwigger Academy网站以启动*JWT认证绕过通过错误签名验证*实验室 ([https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification](https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-flawed-signature-verification))。
- en: Once you access the lab, click on **My account** and log in with the credentials
    provided in the lab description.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦访问实验室，点击**我的账户**，并使用实验室描述中提供的凭据登录。
- en: Open ZAP and find the **GET** request to **/my-account page**. Right-click the
    request and select **Open/Resend with** **Request Editor…**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开ZAP，找到**GET**请求到**/my-account页面**。右键点击请求并选择**使用请求编辑器打开/重发…**。
- en: 'You can see in the request that the cookie session is a JWT, as it is separated
    by a dot. The goal in this lab is to access the admin portal by manipulating the
    JWT cookie. We will need a **Base64** encoder/decoder; in this lab, I am using
    CyberChef ([https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef)).
    Copy the header from the token, which is the first part before the dot and after
    **session=**. Open your favorite Base64 decoder and encode the header. Change
    the **alg** value from **RS256** to **none** and encode it again, as seen in *Figure
    10**.3*. Copy the encoded value and save it so we can use it later in the lab:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在请求中看到cookie会话是一个JWT，因为它是通过一个点分隔的。这个实验的目标是通过操作JWT cookie来访问管理员门户。我们需要一个**Base64**编码/解码器；在这个实验中，我使用的是CyberChef
    ([https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef))。复制令牌中的头部，它是点之前和**session=**之后的第一部分。打开你最喜欢的Base64解码器并编码头部。将**alg**值从**RS256**更改为**none**，然后再次编码，如*图
    10**.3*所示。复制编码后的值并保存，以便稍后在实验中使用：
- en: '![Figure 10.3 – The none algorithm](image/Figure_10.3_B18829.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 无算法](image/Figure_10.3_B18829.jpg)'
- en: Figure 10.3 – The none algorithm
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 无算法
- en: 'Now, copy the payload from the JWT; it is the second part located between two
    dots in the token. Decode it in a Base64 decoder, and change the **sub** value
    from the username you used to **administrator**, as seen in *Figure 10**.4*. Encode
    the payload and copy and save the encoded payload to be used in the next step:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制JWT中的有效负载；它是位于两个点之间的第二部分。将其解码到Base64解码器中，并将**sub**值从你使用的用户名改为**administrator**，如*图
    10**.4*所示。对有效负载进行编码，并复制并保存编码后的有效负载，以便在下一步中使用：
- en: '![Figure 10.4 – Changing the user account](image/Figure_10.4_B18829.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 修改用户账户](image/Figure_10.4_B18829.jpg)'
- en: Figure 10.4 – Changing the user account
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 修改用户账户
- en: 'In the **Request Editor** in ZAP, change **/my-account** to **/admin**. Delete
    everything after **session=**, and add the encoded header value we created earlier.
    Add a dot, then add the encoded payload value we created earlier. Add a dot after
    the payload. *Figure 10**.5* shows the values added:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ZAP的**请求编辑器**中，将**/my-account**改为**/admin**。删除**session=**之后的所有内容，并添加我们之前创建的编码头值。添加一个点，然后添加我们之前创建的编码有效负载值。有效负载后再添加一个点。*图
    10**.5*显示了所添加的值：
- en: '![Figure 10.5 – Session cookie](image/Figure_10.5_B18829.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 会话cookie](image/Figure_10.5_B18829.jpg)'
- en: Figure 10.5 – Session cookie
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 会话cookie
- en: Click on **Send**; as you can see in the **Response** tab, the application responded
    with the Admin Panel code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**；如你所见，在**响应**标签中，应用程序返回了管理员面板的代码。
- en: Open your browser, and go to the **/admin** page, as you can see, you can’t
    view the Admin page. To view the Admin page, we will have to change the cookie
    value. I am using Chrome to change the cookie value. I have to open **Developer
    Tools**, navigate to the **Application** tab, and find the cookie under **Cookies**.
    In the **Value** column, I double-clicked the value and pasted the JWT we created.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，进入**/admin**页面，如你所见，你无法查看管理员页面。为了查看管理员页面，我们需要更改cookie值。我使用Chrome浏览器来更改cookie值。我必须打开**开发者工具**，导航到**应用程序**标签，找到**Cookies**下的cookie。在**值**栏中，我双击了该值并粘贴了我们创建的JWT。
- en: After adding the JWT we created, refresh the page. As you can see, we can view
    the admin page, as shown in *Figure 10**.6*. Let’s delete the user **carlos**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加我们创建的JWT后，刷新页面。如你所见，我们可以查看管理员页面，如*图 10**.6*所示。现在让我们删除用户**carlos**。
- en: '![Figure 10.6 – The Users page](image/Figure_10.6_B18829.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 用户页面](image/Figure_10.6_B18829.jpg)'
- en: Figure 10.6 – The Users page
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 用户页面
- en: This concludes the lab for this recipe. We have bypassed the authentication
    and authorization mechanism to view the admin page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本教程的实验部分。我们已经绕过了身份验证和授权机制，成功访问了管理员页面。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this lab, we decoded the header of the token and changed the value of the
    **alg** attribute to **none**. By changing the **alg** attribute to **none**,
    we can bypass the verification of the signature in the token. Then, we decoded
    the payload and changed the value of the **sub** attribute to **administrator**
    to be able to use the administrator account. After that, we encoded the header
    and the payload and used them as our session cookie value. By doing that, we were
    able to bypass the authentication and authorization mechanism of the website.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们解码了令牌的头部，并将**alg**属性的值改为**none**。通过将**alg**属性更改为**none**，我们可以绕过令牌中签名的验证。接着，我们解码了有效载荷并将**sub**属性的值改为**administrator**，以便能够使用管理员帐户。之后，我们重新编码了头部和有效载荷，并将其用作我们的会话
    cookie 值。通过这样做，我们成功绕过了网站的身份验证和授权机制。
- en: There’s more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using the **none** value for the **alg** attribute is not the only way to make
    the application server accept the JWT you create. Another method to bypass authentication
    and authorization is to find or brute force the secret key. **HS256** is another
    **alg** value that uses a secret key. If an attacker finds the secret key, they
    could sign any JWT they create and pass it to the server. Tools such as Hashcat
    can brute force the secret key using a wordlist.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**none**值作为**alg**属性的值并不是让应用服务器接受你创建的 JWT 的唯一方法。另一种绕过身份验证和授权的方法是找到或暴力破解密钥。**HS256**是另一种使用密钥的**alg**值。如果攻击者找到了密钥，他们就可以签署任何他们创建的
    JWT 并将其发送到服务器。像 Hashcat 这样的工具可以使用字典列表对密钥进行暴力破解。
- en: Performing Java deserialization attacks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 Java 反序列化攻击
- en: Java employs a process called **serialization** that turns an object into a
    byte stream. On the flip side, **deserialization** is the process of returning
    a serialized stream of bytes to an object in the machine’s memory. In this type
    of attack, the attacker introduces malicious data into the application code by
    modifying serialized objects. This attack is only possible if the website deserializes
    data provided by the user. If user-provided data or any data from sources you
    don’t trust must be deserialized, checks and safeguards must be implemented to
    prevent the untrusted sources from altering the data. Checks and safeguards must
    be done before the start of the deserialization process; otherwise, it will not
    be effective. Due to the difficulties in preventing deserialization attacks, data
    deserialization should only be used if it can’t be avoided.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java 使用一种名为**序列化**的过程，将对象转换为字节流。相反，**反序列化**是将序列化的字节流还原为机器内存中的对象。在这种类型的攻击中，攻击者通过修改序列化对象将恶意数据注入应用程序代码。此类攻击只有在网站反序列化用户提供的数据时才有可能。如果必须反序列化用户提供的数据或来自不可信源的任何数据，则必须实现检查和保护措施，以防止不可信的源篡改数据。检查和保护措施必须在开始反序列化过程之前进行，否则将不起作用。由于防止反序列化攻击的难度较大，只有在无法避免的情况下才应使用数据反序列化。
- en: Within this recipe, you will attack a susceptible serialization-based session
    mechanism that’s vulnerable to privilege escalation. To conduct this attack, you
    will edit the serialized object in the session cookie to take advantage of this
    flaw and gain administrator rights to remove Carlos’ account.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将攻击一个易受序列化基础会话机制的漏洞，该漏洞易受到权限提升攻击。进行此攻击时，你将编辑会话 cookie 中的序列化对象，利用此漏洞获得管理员权限，删除
    Carlos 的帐户。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个 PortSwigger Academy 账号和 ZAP 工具，以便拦截来自服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps walk you through solving the PortSwigger Academy *Modifying
    serialized objects* lab. In this lab, you will modify the session cookie’s serialized
    object to escalate your account privileges and be able to delete a user account.
    Please follow these instructions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成解决 PortSwigger Academy *修改序列化对象*实验的过程。在本实验中，你将修改会话 cookie 中的序列化对象，以提升你的帐户权限，并能够删除一个用户帐户。请按照以下说明操作：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects)).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中代理到 ZAP，导航到网址并登录 PortSwigger Academy 网站以启动实验室 ([https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects))。
- en: Open ZAP and go to **Manual Explorer**. Enter the lab URL in the Firefox launcher.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 ZAP 并转到 **Manual Explorer**。在 Firefox 启动器中输入实验室 URL。
- en: Log in to the lab application using the credentials provided by PortSwigger.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PortSwigger 提供的凭证登录实验室应用程序。
- en: Click the response after the login **GET /my-account** request, which contains
    a session cookie. This cookie appears to be URL and Base64-encoded.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击登录后的 **GET /my-account** 请求的响应，其中包含一个会话 cookie。这个 cookie 似乎是 URL 和 Base64
    编码的。
- en: 'To understand what data is in this string, send it over to the **Encode/Decode/Hash**
    tool by right-clicking the selected cookie value. Click the **Decode** tab and
    look at the **Base64 Decode** row. You’ll see the following values:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要理解该字符串中的数据，可以通过右键单击选定的 cookie 值，将其发送到 **Encode/Decode/Hash** 工具。点击 **Decode**
    标签并查看 **Base64 Decode** 行。你将看到以下值：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The cookie is actually a serialized PHP object. String values are always contained
    within double quotes. **s** is the size of the object followed by the object name
    in double quotes. At the end of the code string, the admin attribute contains
    **b:0**, indicating a Boolean value of **false**. Open this request in **Manual**
    **Request Editor**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 cookie 实际上是一个序列化的 PHP 对象。字符串值总是包含在双引号中。**s** 是对象的大小，后面跟着对象名称，且用双引号括起来。在代码字符串的末尾，admin
    属性包含 **b:0**，表示一个布尔值 **false**。在 **Manual** **Request Editor** 中打开此请求。
- en: 'In its decoded form, open CyberChef to change the value of **b:0** to **b:1**
    to equal **true** and re-encode in base64 as well as URL encoded **=**. Insert
    this encoded string back into the cookie and send the request. See *Figure 10**.7*:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解码后的形式中，打开 CyberChef，将 **b:0** 的值更改为 **b:1**，表示 **true**，然后再次进行 Base64 编码并进行
    URL 编码 **=**。将这个编码后的字符串重新插入到 cookie 中并发送请求。见 *图 10.7*：
- en: '![Figure 10.7 – CyberChef encoded session data](image/Figure_10.7_B18829.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – CyberChef 编码的会话数据](image/Figure_10.7_B18829.jpg)'
- en: Figure 10.7 – CyberChef encoded session data
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – CyberChef 编码的会话数据
- en: 'When you receive the response, scroll through the content of the HTML code,
    as shown in *Figure 10**.8*, to find a link that shows **/admin**. This shows
    that you accessed a page with admin privileges:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你收到响应时，滚动查看 HTML 代码的内容，如 *图 10.8* 所示，找到一个显示 **/admin** 的链接。这表明你访问了一个具有管理员权限的页面：
- en: '![Figure 10.8 – Response with the /admin path](image/Figure_10.8_B18829.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 带有 /admin 路径的响应](image/Figure_10.8_B18829.jpg)'
- en: Figure 10.8 – Response with the /admin path
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 带有 /admin 路径的响应
- en: 'In our next step, go back to the **Request** tab and update the **GET** request
    path to **/admin,** and hit **Send** again. You’ll receive a **200** HTTP status
    and then see a specific **href** to delete user accounts:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，返回到 **Request** 标签并更新 **GET** 请求路径为 **/admin**，然后再次点击 **Send**。你将收到 **200**
    HTTP 状态，然后看到一个特定的 **href** 用于删除用户账户：
- en: '![Figure 10.9 – /admin response](image/Figure_10.9_B18829.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – /admin 响应](image/Figure_10.9_B18829.jpg)'
- en: Figure 10.9 – /admin response
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – /admin 响应
- en: Update the path to include **/admin/delete?username=carlos** and send the request
    once more to complete this recipe. You may need to refresh the browser page to
    see the completion status of the lab.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路径以包含 **/admin/delete?username=carlos** 并再次发送请求以完成此步骤。你可能需要刷新浏览器页面以查看实验室的完成状态。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When using Java to build objects and these objects are no longer in use, they
    get saved in memory to be later deleted by the garbage collector. Java must convert
    these objects into a byte stream before transferring that data, storing it on
    a disk, or transmitting it over a network. The class of that object must implement
    the Serializable interface in order to do this. As was already said, serialization
    enables us to transform an object’s state into a stream of bytes. The actual code
    is not included in this byte stream.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Java 构建对象并且这些对象不再使用时，它们会被保存在内存中，稍后会被垃圾回收器删除。在传输数据、将数据存储在磁盘上或通过网络传输数据之前，Java
    必须将这些对象转换成字节流。该对象的类必须实现 Serializable 接口才能完成此操作。如前所述，序列化使我们能够将一个对象的状态转化为字节流。实际的代码不包含在该字节流中。
- en: A malicious user trying to introduce a changed serialized object into the system
    to compromise the system or its data results in a Java deserialization vulnerability.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意用户试图将修改过的序列化对象引入系统，以破坏系统或其数据，从而导致Java反序列化漏洞。
- en: There’s more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Java applications automatically manage their memory using a process known as
    **garbage collection**. Java applications can be executed on a **Java virtual
    machine** (**JVM**) by compiling to bytecode. Objects are produced on the heap,
    a section of memory reserved for the application when Java programs are launched
    on the JVM. Some objects will eventually become obsolete. To free up memory, the
    garbage collector discovers these useless objects and deletes them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序通过一种称为**垃圾回收**的过程自动管理其内存。Java应用程序可以通过编译为字节码在**Java虚拟机**（**JVM**）上执行。对象在堆内存中创建，堆是为Java程序在JVM上启动时保留的一块内存区域。一些对象最终会变得过时。为了释放内存，垃圾回收器会发现这些无用的对象并将其删除。
- en: As for the Serializable interface, this is contained within the **java.io**
    package. It is a marker interface that contains no methods or fields. Therefore,
    classes that incorporate it don’t need to define any methods. If classes wish
    to be able to serialize or deserialize their instances, they must implement it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 至于Serializable接口，它包含在**java.io**包中。它是一个标记接口，没有方法或字段。因此，实现该接口的类不需要定义任何方法。如果类希望能够序列化或反序列化其实例，必须实现该接口。
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information on PHP serialization, visit [https://www.php.net/manual/en/function.serialize.php](https://www.php.net/manual/en/function.serialize.php).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PHP序列化的更多信息，请访问[https://www.php.net/manual/en/function.serialize.php](https://www.php.net/manual/en/function.serialize.php)。
- en: For CyberChef, visit [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CyberChef，请访问[https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)。
- en: Password brute-force via password change
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码暴力破解通过密码更改
- en: A brute force attack is a cracking method that uses trial and error to compromise
    login information, encryption keys, and passwords. It is a simple yet effective
    method for gaining unauthorized access to user accounts, business systems, or
    networks. Until they discover the proper login details, a malicious user attempts
    a wide variety of usernames and password combinations to obtain the right authentication
    credentials.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解攻击是一种通过试错法来破解登录信息、加密密钥和密码的方式。这是一种简单但有效的方法，用于未经授权访问用户账户、商业系统或网络。直到恶意用户发现正确的登录信息为止，他们会尝试多种用户名和密码组合来获得正确的认证凭证。
- en: In this recipe, we will attack a vulnerable password change function within
    the application using brute-force attacks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将通过暴力破解攻击应用程序中的一个脆弱的密码更改功能。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验需要一个PortSwigger学院账户和ZAP来拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will demonstrate a brute-force attack by completing the
    PortSwigger Academy *Password brute-force via password change* lab to find the
    correct credentials. To start the lab, follow these instructions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将通过完成PortSwigger学院的*密码暴力破解通过密码更改*实验来演示暴力攻击，寻找正确的凭证。要开始实验，请按照以下说明操作：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change)).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过ZAP代理的浏览器中导航到URL，并登录到PortSwigger学院网站以启动实验([https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change](https://portswigger.net/web-security/authentication/other-mechanisms/lab-password-brute-force-via-password-change))。
- en: Download the Authentication lab passwords provided by PortSwigger to a text
    file on your computer. You will be using these specifically for the recipe ([https://portswigger.net/web-security/authentication/auth-lab-passwords](https://portswigger.net/web-security/authentication/auth-lab-passwords)).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载PortSwigger提供的认证实验室密码并保存到计算机上的文本文件中。您将专门使用这些密码来进行本教程([https://portswigger.net/web-security/authentication/auth-lab-passwords](https://portswigger.net/web-security/authentication/auth-lab-passwords))。
- en: With ZAP open, go to **Manual Explore**, open Firefox via the launcher, and
    resolve the PortSwigger lab URL. Continue to the PortSwigger Authentication lab.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开ZAP后，进入**手动探索**，通过启动器打开Firefox，并解析PortSwigger实验室URL。继续进入PortSwigger认证实验室。
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In ZAP, to view the request and response more easily, be sure to add the URL
    being tested to **Context** by right-clicking on the web URL in the **Sites**
    window and **Include Site in Context**, then click the bullseye to remove any
    other sites from view. This can be done in the **History** tab of the **Information**
    window and elsewhere that has a bullseye.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在ZAP中，为了更轻松地查看请求和响应，务必通过右键点击**站点**窗口中的网址，并选择**将站点包含到上下文中**，然后点击靶心图标以隐藏其他站点。这可以在**信息**窗口的**历史**选项卡中以及其他有靶心图标的地方完成。
- en: Log in to the lab application using the credentials provided and set the Breakpoint
    in the HUD.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的凭据登录实验室应用程序，并在HUD中设置断点。
- en: Once logged in, you will be at the web page where you can update your current
    password. Here, we’ll begin to test its functionality. Keep in mind that the username
    is provided in the request as a hidden input.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，你将进入可以更新当前密码的网页。在这里，我们将开始测试其功能。请记住，用户名是在请求中作为隐藏输入提供的。
- en: 'We’ll mess around with this feature to enumerate correct passwords but first,
    let’s look at varying ways to gain different responses:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过这个功能进行实验来枚举正确的密码，但首先，我们来看一下获取不同响应的几种方式：
- en: 'Enter an incorrect current password followed by two matching passwords. If
    you enter passwords like this twice, the account will log you out and lock. Then,
    when attempting to log back in, you’ll get an error of being locked out for one
    minute, as shown in *Figure 10**.10*:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入错误的当前密码，然后输入两个匹配的新密码。如果你这样输入密码两次，账户会退出并被锁定。然后，当尝试重新登录时，会收到被锁定一分钟的错误信息，如*图10.10*所示：
- en: '![Figure 10.10 – Locked account message](image/Figure_10.10_B18829.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 锁定账户信息](image/Figure_10.10_B18829.jpg)'
- en: Figure 10.10 – Locked account message
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 锁定账户信息
- en: But if you use an incorrect current password, but the new passwords do not match,
    you will not be logged out and locked out. A **Current password is incorrect**
    error will appear.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果你使用错误的当前密码，并且新密码不匹配，你将不会被登出或锁定。会出现**当前密码不正确**的错误信息。
- en: Lastly, if you use the correct, current password but you enter two different
    new passwords, you will get a **New passwords do not match** error message splashed
    on the web page.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果你使用正确的当前密码，但输入了两个不同的新密码，你将收到一个**新密码不匹配**的错误信息，显示在网页上。
- en: 'In the **History** tab, open the request where you entered the correct, current
    password and two different new passwords in **Fuzzer**, as shown in *Figure 10**.11*:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**历史**选项卡中，打开你在**Fuzzer**中输入了正确的当前密码和两个不同的新密码的请求，如*图10.11*所示：
- en: '![Figure 10.11 – The POST request change password](image/Figure_10.11_B18829.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 更改密码的POST请求](image/Figure_10.11_B18829.jpg)'
- en: Figure 10.11 – The POST request change password
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 更改密码的POST请求
- en: Click on **Edit** to change the username parameter to **carlos**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑**以将用户名参数更改为**carlos**。
- en: Next, select **password** in the **current-password** parameter and click **Add**,
    **Add** again, and then drop down the menu to **File**. This will add our password
    list to use for brute-forcing. Ensure the other two new **password** parameters
    are different values, as shown in the previous example, *Figure 10**.11*.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**password**在**current-password**参数中，并点击**添加**，再次点击**添加**，然后从下拉菜单中选择**文件**。这将添加我们的密码列表，用于暴力破解。确保其他两个新的**password**参数有不同的值，如前面的示例所示，*图10.11*。
- en: In the **File** payload, click on **Select...** to open your computer’s directory
    and navigate to where you saved the file.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件**有效负载中，点击**选择...**以打开计算机目录，导航到你保存文件的位置。
- en: Next, add a second payload, **strings**, in an empty space in the body just
    after the second password. Add the **New passwords do not match** line, check
    the **Multiline** box, click **Add**, then **OK**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在第二个密码后面空白的地方添加第二个有效负载，**strings**，添加**新密码不匹配**的行，勾选**多行**框，点击**添加**，然后点击**确定**。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Adding a Stings payload type helps you *grep match* on content in the body of
    the response.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Stings有效负载类型有助于你在响应体的内容中执行*grep匹配*。
- en: 'Yours should have two payloads, as shown in *Figure 10**.12*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的页面应该包含两个有效负载，如*图10.12*所示：
- en: '![Figure 10.12 – Fuzzer payloads](image/Figure_10.12_B18829.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – Fuzzer有效负载](image/Figure_10.12_B18829.jpg)'
- en: Figure 10.12 – Fuzzer payloads
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – Fuzzer有效负载
- en: Start Fuzzing.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始Fuzz测试。
- en: 'The attack will run for a little and once it stops, look for a response that
    contains the word **Reflected** in the **Fuzzer** tab of the **Information** window.
    Sort the **State** column, as shown in *Figure 10**.13*. When scrolling through
    the payloads, look at the body of the response for **<p class=is-warning>New passwords
    do not match**. This payload will be your password:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击会运行一段时间，停止后，查看包含**Reflected**一词的响应，这些响应可以在**信息**窗口的**Fuzzer**标签页中找到。排序**状态**栏，如*图
    10.13*所示。滚动浏览有效载荷时，查看响应的主体，寻找**<p class=is-warning>New passwords do not match**。此有效载荷将是你的密码：
- en: '![Figure 10.13 – Fuzzer history](image/Figure_10.13_B18829.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 模糊器历史](image/Figure_10.13_B18829.jpg)'
- en: Figure 10.13 – Fuzzer history
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 模糊器历史
- en: Go back to the application in the browser, log out of the current account you’re
    logged into, and then log back in using the **carlos** username and the newly
    found password.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回浏览器中的应用程序，登出当前登录的账户，然后使用**carlos**用户名和新发现的密码重新登录。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'Attackers look for areas within an application to forcefully attempt numerous
    usernames or passwords and conduct varying techniques to do so. The four most
    common are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者寻找应用程序中的区域，强行尝试多个用户名或密码，并采取不同的技术来实施攻击。最常见的四种方式如下：
- en: Simple brute force attacks are where attackers attempt to guess a user’s login
    by manually typing them in one at a time.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的暴力破解攻击是攻击者通过逐个手动输入来尝试猜测用户的登录信息。
- en: A dictionary attack is a type of password guessing attack that inputs a list
    of potential passwords, consisting of swapping some of the letters with symbols
    or numbers and comparing it to a username of the target. Typically, this attack
    takes much longer to succeed and thus has a decreased likelihood of working.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典攻击是一种密码猜测攻击，攻击者输入一系列可能的密码，这些密码由将字母与符号或数字互换组成，然后与目标用户名进行对比。通常，这种攻击需要更长的时间才能成功，因此成功的可能性较低。
- en: A rainbow table attack comprises a database that is made up of passwords and
    their hash values, which are then compared against the target hash for a match.
    This takes less time to crack.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彩虹表攻击包含一个由密码及其哈希值构成的数据库，然后将其与目标哈希进行比对。这个过程破解的时间较短。
- en: Hybrid attacks combine both dictionary and rainbow tables.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合攻击结合了字典攻击和彩虹表攻击。
- en: Many of these passwords and tables come from underground sources from previous
    breaches being sold or passed around the internet and help form more accurate
    attacks on networks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多密码和表格来自以前泄露的地下来源，这些密码和表格被出售或在互联网上传播，并帮助进行更精准的网络攻击。
- en: See also
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Other sources to help build lists can be searched for via search engines for
    default credentials for the technology being used, or utilize one of these links:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可帮助构建密码列表的资源可以通过搜索引擎搜索关于所用技术的默认凭据，或利用以下链接之一：
- en: 'Credentials:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 凭据：
- en: '[https://github.com/ihebski/DefaultCreds-cheat-sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/ihebski/DefaultCreds-cheat-sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)'
- en: '[http://www.vulnerabilityassessment.co.uk/passwordsC.htm](http://www.vulnerabilityassessment.co.uk/passwordsC.htm)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.vulnerabilityassessment.co.uk/passwordsC.htm](http://www.vulnerabilityassessment.co.uk/passwordsC.htm)'
- en: '[https://192-168-1-1ip.mobi/default-router-passwords-list/](https://192-168-1-1ip.mobi/default-router-passwords-list/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://192-168-1-1ip.mobi/default-router-passwords-list/](https://192-168-1-1ip.mobi/default-router-passwords-list/)'
- en: '[https://datarecovery.com/rd/default-passwords/](https://datarecovery.com/rd/default-passwords/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://datarecovery.com/rd/default-passwords/](https://datarecovery.com/rd/default-passwords/)'
- en: '[https://bizuns.com/default-passwords-list](https://bizuns.com/default-passwords-list)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bizuns.com/default-passwords-list](https://bizuns.com/default-passwords-list)'
- en: '[https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv)'
- en: '[https://www.cirt.net/passwords](https://www.cirt.net/passwords)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cirt.net/passwords](https://www.cirt.net/passwords)'
- en: '[https://www.passwordsdatabase.com/](https://www.passwordsdatabase.com/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.passwordsdatabase.com/](https://www.passwordsdatabase.com/)'
- en: '[https://many-passwords.github.io/](https://many-passwords.github.io/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://many-passwords.github.io/](https://many-passwords.github.io/)'
- en: 'Wordlists:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 字典：
- en: '[https://github.com/Dormidera/WordList-Compendium](https://github.com/Dormidera/WordList-Compendium)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Dormidera/WordList-Compendium](https://github.com/Dormidera/WordList-Compendium)'
- en: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
- en: '[https://github.com/kaonashi-passwords/Kaonashi](https://github.com/kaonashi-passwords/Kaonashi)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/kaonashi-passwords/Kaonashi](https://github.com/kaonashi-passwords/Kaonashi)'
- en: '[https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm](https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm](https://crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm)'
- en: Web cache poisoning
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 缓存中毒
- en: '**Web cache poisoning** is a sophisticated technique whereby an attacker manipulates
    a web server and its cache functionality to send other users a malicious HTTP
    response. In this recipe, we’ll exploit a vulnerable lab that does not properly
    validate input within an unkeyed header susceptible to web cache poisoning. This
    attack will take advantage of the web application’s home page, where unsuspecting
    visitors will be open to the attack. We’ll walk you through web cache poisoning
    in a response that causes the visitor’s browser to execute malicious JavaScript
    code.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 缓存中毒**是一种复杂的技术，攻击者通过操纵Web服务器及其缓存功能，向其他用户发送恶意HTTP响应。在本实验中，我们将利用一个脆弱的实验环境，该环境没有正确验证易受Web缓存中毒攻击的无密钥头部中的输入。此攻击将利用
    Web 应用程序的首页，毫无防备的访问者将成为攻击目标。我们将引导你完成Web缓存中毒的过程，该响应将导致访问者的浏览器执行恶意JavaScript代码。'
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验需要一个 PortSwigger Academy 帐号，并且需要 ZAP 来拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'In this section, we will lay out the steps you can take to complete the PortSwigger
    Academy *Web cache poisoning with an unkeyed header* lab and poison the cache
    to display the cookie. To start the lab, take the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出你可以采取的步骤，以完成 PortSwigger Academy *Web 缓存中毒与无密钥头部* 实验，并中毒缓存以显示 cookie。启动实验的步骤如下：
- en: 'Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器代理到 ZAP 的情况下，访问网址并登录 PortSwigger Academy 网站以启动实验：
- en: '[PRE2]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Capture the website’s home page. To reiterate this response, refresh the web
    page or click the home page button.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获网站的首页。为了重新获取此响应，可以刷新网页或点击首页按钮。
- en: 'Look for the **GET** request that is generated from the home page and open
    it in the **Manual Request Editor**, as shown in *Figure 10**.14*:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找从首页生成的**GET**请求，并在**手动请求编辑器**中打开，如*图 10.14*所示：
- en: '![Figure 10.14 – The GET request](image/Figure_10.14_B18829.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – GET 请求](image/Figure_10.14_B18829.jpg)'
- en: Figure 10.14 – The GET request
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – GET 请求
- en: Next, add a cache-buster query parameter after the URL (**/?cb=1337**).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在网址后添加缓存破坏查询参数（**/?cb=1337**）。
- en: A **cache-buster header** is a type of HTTP response header that is used to
    prevent web browsers from caching specific resources on a web page. This can be
    useful in situations where you want to ensure that users always see the latest
    version of a resource rather than a potentially outdated version that might have
    been stored in the browser’s cache. Cache-buster headers typically contain a unique
    identifier or timestamp that changes each time the resource is requested, which
    forces the browser to download the latest version of the resource rather than
    using a cached version. This can help to ensure that users always have access
    to the most up-to-date content on a website.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存破坏头**是一种HTTP响应头，用于防止网页浏览器缓存网页中的特定资源。在需要确保用户始终看到资源的最新版本，而不是可能已经存储在浏览器缓存中的过时版本时，这种方式非常有用。缓存破坏头通常包含一个唯一的标识符或时间戳，每次请求资源时都会发生变化，这迫使浏览器下载最新版本的资源，而不是使用缓存版本。这有助于确保用户始终可以访问网站上的最新内容。'
- en: Important note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The process to locate vulnerable parameters to web cache poison can be automated
    using an extension called **Parameter Digger**. Refer to the *See also* section
    for reference.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为**Parameter Digger**的扩展可以自动化定位可能导致 Web 缓存中毒的漏洞参数。更多信息，请参见*另见*部分。
- en: In addition, add the **X-Forwarded-Host** header with any random hostname, as
    shown in *Figure 10**.15*, such as **zaproxy.org**, and click **Send**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加 **X-Forwarded-Host** 头部，使用任何随机主机名，如 *图 10.15* 所示，诸如 **zaproxy.org**，然后点击
    **发送**。
- en: '![Figure 10.15 – Cache buster query and the X-Forwarded-Host header](image/Figure_10.15_B18829.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 缓存破坏查询和 X-Forwarded-Host 头](image/Figure_10.15_B18829.jpg)'
- en: Figure 10.15 – Cache buster query and the X-Forwarded-Host header
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 缓存清除查询和 X-Forwarded-Host 头部
- en: When the **X-Forwarded-Host** header is used, a dynamically generated reference
    is shown in the web app’s source code for importing a JavaScript file that’s stored
    at **/resources/js/tracking.js**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 **X-Forwarded-Host** 头部时，网页应用源代码中会显示一个动态生成的引用，用于导入存储在 **/resources/js/tracking.js**
    的 JavaScript 文件。
- en: 'All the details required to find a resource are in this absolute URL, as shown
    in *Figure 10**.16*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 查找资源所需的所有细节都包含在这个绝对 URL 中，如 *图 10**.16* 所示：
- en: '![Figure 10.16 – Dynamic URL in the web app source code](image/Figure_10.16_B18829.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 网页应用源代码中的动态 URL](image/Figure_10.16_B18829.jpg)'
- en: Figure 10.16 – Dynamic URL in the web app source code
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 网页应用源代码中的动态 URL
- en: 'In addition, when looking at the response, as in *Figure 10**.16*, the response
    contains the **X-Cache: hit** header. If you see the **X-Cache: miss** header,
    continue to click **Send** to get a hit:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '此外，在查看响应时，如 *图 10**.16* 所示，响应中包含 **X-Cache: hit** 头部。如果看到 **X-Cache: miss**
    头部，请继续点击 **发送**，直到获得命中结果：'
- en: '![Figure 10.17 – The X-Cache: miss response](image/Figure_10.17_B18829.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – X-Cache: miss 响应](image/Figure_10.17_B18829.jpg)'
- en: 'Figure 10.17 – The X-Cache: miss response'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10.17 – X-Cache: miss 响应'
- en: The **X-Cache** header is a type of HTTP response header that is used to indicate
    whether a resource was served from the cache of a web server or from the origin
    server itself. If the header contains the value **hit**, the resource was served
    from the cache, which can be faster and more efficient than serving the resource
    directly from the origin server. This can be useful for improving a website’s
    performance by reducing the amount of data that needs to be transferred between
    the server and the client.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**X-Cache** 头部是一个 HTTP 响应头部，用于指示资源是从网页服务器的缓存中提供的，还是直接从源服务器提供的。如果头部包含 **hit**
    的值，则表示资源是从缓存中提供的，这比直接从源服务器提供资源更快捷、更高效。这对于提高网站性能非常有用，因为它可以减少服务器与客户端之间传输的数据量。'
- en: 'With this information, click the link to go to the exploit server and update
    the filename to be the path to the JavaScript from the absolute URL:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些信息，点击链接前往攻击服务器并更新文件名为来自绝对 URL 的 JavaScript 路径：
- en: '[PRE3]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, enter a JavaScript XSS payload into the body and click **Store** to save
    the exploit:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入一个 JavaScript XSS 负载到请求体中，并点击 **保存** 以保存攻击：
- en: '[PRE4]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, open the **GET** request for the home page in **Manual Response Editor**
    and remove the cache buster parameter and then add the **X-Forwarded-Host** header
    that points to the exploit server (ensure to use your **EXPLOIT-SERVER-ID** that
    is provided in the URL on top of the exploit page):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开 **GET** 请求并在 **手动响应编辑器** 中删除缓存清除参数，然后添加指向攻击服务器的 **X-Forwarded-Host** 头部（确保使用攻击页面顶部提供的
    **EXPLOIT-SERVER-ID**）：
- en: '[PRE5]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Figure 10.18 – The GET request for web cache poisoning](image/Figure_10.18_B18829.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 网页缓存污染的 GET 请求](image/Figure_10.18_B18829.jpg)'
- en: Figure 10.18 – The GET request for web cache poisoning
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 网页缓存污染的 GET 请求
- en: Important note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When crafting the **GET** request, be sure to remove the cache-buster header,
    and when adding the exploit server URL, do not include **https://** or the trailing
    **/**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造 **GET** 请求时，务必移除缓存清除头部，并且在添加攻击服务器 URL 时，不要包括 **https://** 或尾部的 **/**。
- en: 'Click **Send**, and continue sending the request until the exploit server URL
    is reflected in the response along with **X-Cache: hit** in the headers, as shown
    in *Figure 10**.19*:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '点击 **发送**，并继续发送请求，直到攻击服务器 URL 在响应中显示，并且头部中包含 **X-Cache: hit**，如 *图 10**.19*
    所示：'
- en: '![Figure 10.19 – A successful exploit request](image/Figure_10.19_B18829.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 成功的攻击请求](image/Figure_10.19_B18829.jpg)'
- en: Figure 10.19 – A successful exploit request
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 成功的攻击请求
- en: Once you have a hit, go to the web app in the browser and refresh the page.
    This will load the web cache poisoned URL into the browser that triggers the **alert()**
    JavaScript payload, as shown in *Figure 10**.20*.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦获得命中结果，打开浏览器中的网页应用并刷新页面。这将把被污染的网页缓存 URL 加载到浏览器中，触发 **alert()** JavaScript
    负载，如 *图 10**.20* 所示。
- en: Important note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The web cache for this lab will expire every 30 seconds. It’s important to perform
    the test quickly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的网页缓存会在每 30 秒过期。务必迅速进行测试。
- en: 'You may need to continue sending the malicious **GET** request, followed by
    refreshing the web app browser page to get the web-poisoned page to load and execute
    the payload:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要继续发送恶意的 **GET** 请求，然后刷新 Web 应用浏览器页面，才能使网页中毒并加载执行载荷：
- en: '![Figure 10.20 – The XSS payload execution](image/Figure_10.20_B18829.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – XSS 载荷执行](image/Figure_10.20_B18829.jpg)'
- en: Figure 10.20 – The XSS payload execution
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – XSS 载荷执行
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Web cache poisoning typically involves manipulating the HTTP headers of a request
    to a web server in such a way that the server will cache a malicious or false
    version of the response. For example, an attacker might send a request with a
    forged **Last-Modified** header that indicates that the response should be considered
    fresh and cached by the server, even if it contains malicious or false content.
    When subsequent requests are made to the same resource, the server will serve
    the poisoned response from its cache instead of requesting a fresh copy from the
    origin server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Web 缓存中毒通常涉及通过篡改对 Web 服务器请求的 HTTP 头部，以使服务器缓存一个恶意或错误的响应版本。例如，攻击者可能会发送一个伪造的 **Last-Modified**
    头部，指示响应应该被视为新鲜的，并由服务器缓存，即使它包含恶意或错误的内容。当后续请求相同资源时，服务器将从缓存中提供被污染的响应，而不是从原始服务器请求新副本。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Parameter Digger, a tool for finding parameters, is called the **Param Digger**.
    It reveals obscure, unconnected, and hidden characteristics that can help broaden
    the attack surface and make it simpler to uncover vulnerabilities. It employs
    brute-force guessing techniques to find parameters using a seed URL that has been
    provided here: [https://www.zaproxy.org/docs/desktop/addons/parameter-digger/](https://www.zaproxy.org/docs/desktop/addons/parameter-digger/).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查找参数的工具被称为 **Param Digger**。它揭示了那些晦涩、不相关或隐藏的特征，这些特征有助于扩大攻击面，并使发现漏洞变得更加简单。它使用暴力破解技术，通过提供的种子
    URL 来查找参数：[https://www.zaproxy.org/docs/desktop/addons/parameter-digger/](https://www.zaproxy.org/docs/desktop/addons/parameter-digger/)。
