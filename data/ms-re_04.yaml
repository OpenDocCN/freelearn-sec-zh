- en: Static and Dynamic Reversing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态与动态逆向分析
- en: Like a patient in a hospital, a file needs to undergo some triage to determine
    the right allocation of resources. The result of the file assessment will tell
    us what tools need to be used, what kind of reversing steps need to be taken,
    and what resources will be used. The steps involved in carrying out reversing
    are categorized into static and dynamic analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像医院里的病人一样，文件需要经过一些初步评估，以确定资源的正确分配。文件评估的结果将告诉我们需要使用哪些工具，哪些逆向步骤需要执行，以及将使用哪些资源。进行逆向分析的步骤分为静态分析和动态分析。
- en: In this chapter, we will introduce the methods and tools used in assessing a
    file. We will be focusing on a 32-bit Windows operating system for our examples.
    This will be followed by an examination of tools we can use for static and dynamic
    analysis. This chapter can help you to generate a checklist that will serve as
    a guide for you to retrieve all information on a file in the least amount of time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍评估文件时使用的方法和工具。我们将以32位Windows操作系统为示例，接着检查我们可以用于静态和动态分析的工具。本章将帮助你生成一个检查清单，为你提供一个在最短时间内获取文件所有信息的指南。
- en: 'In this chapter, you will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将做以下内容：
- en: Gain an understanding of Target assessment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解目标评估
- en: Perform static analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行静态分析
- en: Perform dynamic analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行动态分析
- en: Assessment and static analysis
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估与静态分析
- en: 'A file needs to undergo an initial assessment in order for us to determine
    what tools and analysis methods will be required. This process also helps us to
    create a strategy for analyzing the file. Doing such an assessment requires carrying
    out a light static analysis. Here are some ideas for assessment that may serve
    as our guide:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件需要经过初步评估，以便我们确定所需的工具和分析方法。这个过程还帮助我们为分析文件制定策略。进行这样的评估需要进行轻量级的静态分析。以下是一些可能作为我们指南的评估思路：
- en: 'Where did it originate from:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的来源：
- en: One of the purposes of reverse engineering is to help network administrators
    prevent similar malware from infiltrating the network. Knowing where a file came
    from would be helpful in securing the channel used to transmit it. For example,
    if the file being analyzed was determined to have been an email attachment, network
    administrators should secure the email server.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向工程的一个目的就是帮助网络管理员防止类似的恶意软件渗透到网络中。了解文件的来源有助于确保用于传输文件的渠道。例如，如果分析的文件被确定为电子邮件附件，那么网络管理员应当加强电子邮件服务器的安全。
- en: 'Existing information:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有信息：
- en: Searching the internet for already existing information can be very helpful.
    There might be existing analyses that has been done on the file. We would be able
    to determine what behaviors to expect, which will help hasten the analysis.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上搜索已有的信息可以非常有帮助。可能已经对该文件进行了现有的分析。我们可以确定预计的行为，这将有助于加快分析过程。
- en: 'Viewing the file and extracting its text strings:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看文件并提取其文本字符串：
- en: Using tools to view the file help us to determine the type of file. Extracting
    readable text from the file also gives us hints of what messages, functions, and
    modules it will use when opened or executed.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具查看文件帮助我们确定文件类型。从文件中提取可读文本也能为我们提供提示，告诉我们文件在打开或执行时将使用哪些消息、函数和模块。
- en: 'File information:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件信息：
- en: What is the file type?
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型是什么？
- en: Header and type analysis
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部与类型分析
- en: Static analysis
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: Static analysis will help us make notes of what we will do during dynamic analysis.
    With knowledge of the `x86` assembly language, we should be able to understand
    a disassembled `Win32 PE` file and its branches. Doing so, we would be able to
    prepare the right tools to read, open, and debug the file based on its file type,
    and also understand the file's structure based on its file format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析将帮助我们记录在动态分析过程中需要做的事情。掌握`x86`汇编语言后，我们应该能够理解反汇编的`Win32 PE`文件及其分支。通过这样做，我们将能够根据文件类型准备适当的工具来读取、打开和调试文件，并根据文件格式理解文件的结构。
- en: We begin static analysis by determining the file type, then move on to understanding
    the file format. We can extract text strings that might help us instantly identify
    useful information, such as the API function used, which library modules it will
    use, what high level language the file was compiled from, registry keys it will
    try to access, and websites or IP addresses it might try to connect to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过确定文件类型开始静态分析，然后继续了解文件格式。我们可以提取文本字符串，这些字符串可能帮助我们立即识别有用信息，例如使用的API函数、将使用的库模块、文件从哪种高级语言编译而来、它将尝试访问的注册表项，以及它可能尝试连接的网页或IP地址。
- en: File types and header analysis
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型和头部分析
- en: The type of file is the most important piece of information that sets off the
    whole analysis. If the file type is a Windows executable, a preset of `PE` tools
    will be prepared. If the file type is a Word document, the sandbox environment
    we are going to use will have to be installed with Microsoft Office and analysis
    tools that can read the `OLE` file format. If the given target for analysis is
    a website, we may need to prepare browser tools that can read HTML and debug Java
    scripts or Visual Basic scripts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型是触发整个分析过程的最重要信息。如果文件类型是Windows可执行文件，则会准备一组预设的`PE`工具。如果文件类型是Word文档，那么我们将使用的沙箱环境必须安装Microsoft
    Office以及可以读取`OLE`文件格式的分析工具。如果给定的分析目标是一个网站，我们可能需要准备能够读取HTML并调试JavaScript或Visual
    Basic脚本的浏览器工具。
- en: Extracting useful information from file
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中提取有用信息
- en: It would be fun to manually parse each piece of information about a file using
    file viewing tools, such as HxD ([https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)).
    But, since searching for documentation about the file would take some time, there
    are existing tools that were developed for reverse engineers. These tools, readily
    available on the internet, can easily extract and display file information, and
    have features that can identify what type of file it is. This extracted information
    helps us determine what type of file we are dealing with.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件查看工具（如HxD（[https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)））手动解析文件的每一部分信息是非常有趣的。但由于查找文件文档需要一些时间，已有为逆向工程师开发的工具。这些工具在互联网上随时可用，可以轻松提取和显示文件信息，并具有识别文件类型的功能。这些提取的信息帮助我们确定我们正在处理的文件类型。
- en: PEid and TrID
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEid和TrID
- en: PEid and TrID are the tools that are able to detect the type of file, the compiler
    used, the encrypting tool, and the packer and protector used. Compressed executables
    are better known as packers. Some examples of these packers are UPX, PECompact,
    and Aspack. Protectors, on the other hand, are somewhat like packers, but rather
    more advanced in the sense that the original compiled code would be protected
    from being reversed easily. Examples of protectors include Themida, AsProtect,
    and Enigma Protector.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PEid和TrID是能够检测文件类型、使用的编译器、加密工具以及使用的打包器和保护器的工具。压缩的可执行文件更常被称为打包器。这些打包器的一些例子包括UPX、PECompact和Aspack。另一方面，保护器与打包器有些类似，但更先进，因为原始编译的代码会被保护，防止轻易被逆向。保护器的例子包括Themida、AsProtect和Enigma
    Protector。
- en: 'Protector software is usually commercial software. Neither tool is updated
    anymore but both still work very well. Here''s a screenshot of PEiD''s main interface:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 保护软件通常是商业软件。虽然这两个工具都没有再更新，但它们仍然运行得很好。下面是PEiD主界面的截图：
- en: '![](img/aa2462af-d655-4c28-9973-20df5425d1e0.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa2462af-d655-4c28-9973-20df5425d1e0.png)'
- en: 'Here''s a screenshot of how `TrID` can be used in a Linux Terminal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在 Linux 终端中使用`TrID`的截图：
- en: '![](img/4d832653-cf9c-485e-884f-ed62c20c50d4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d832653-cf9c-485e-884f-ed62c20c50d4.png)'
- en: 'At the time of writing, these tools could be downloaded at the following links:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这篇文章时，这些工具可以通过以下链接下载：
- en: PEid is available from [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml).
    [](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)
    TriD is available at [http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PEid可以从[http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)下载。[](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)
    TriD可以从[http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html)下载。
- en: python-magic
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: python-magic
- en: 'This is a Python module that is able to detect the file type. However, unlike
    PEiD and TrID, it also detects compilers and packers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个能够检测文件类型的 Python 模块。然而，与 PEiD 和 TrID 不同，它还可以检测编译器和加壳工具：
- en: '![](img/474f937f-639c-42b2-8565-c5b10878e1da.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/474f937f-639c-42b2-8565-c5b10878e1da.png)'
- en: It can be downloaded at [https://pypi.org/project/python-magic/](https://pypi.org/project/python-magic/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以从 [https://pypi.org/project/python-magic/](https://pypi.org/project/python-magic/)
    下载。
- en: file
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: 'Linux has a built-in command known as **file**. **file** is based on the `libmagic`
    library, and is able to determine file types of various file formats:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有一个内置的命令，称为 **file**。**file** 基于 `libmagic` 库，能够识别各种文件格式的文件类型：
- en: '![](img/8386d977-f4fa-40d7-a5b1-c960bc37b0fd.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8386d977-f4fa-40d7-a5b1-c960bc37b0fd.png)'
- en: MASTIFF
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MASTIFF
- en: MASTIFF is an static analyzer framework. It works on Linux and Mac. As a framework,
    the static analysis is based on plugins from the MASTIFF author and from the community.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MASTIFF 是一个静态分析框架。它可以在 Linux 和 Mac 上运行。作为一个框架，静态分析基于 MASTIFF 作者和社区提供的插件。
- en: 'These plugins include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件包括以下内容：
- en: '**trid** : This is used for identifying file types.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**trid**：这是一个用于识别文件类型的工具。'
- en: '**ssdeep** : `ssdeep` is a fuzzy hash calculator. A fuzzy hash, or context
    triggered piecewise hashes (`CTPH`), can be used to identify nearly identical
    files. This is useful for identifying variants of a malware family.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**ssdeep**：`ssdeep` 是一个模糊哈希计算器。模糊哈希，或称为上下文触发的分段哈希（`CTPH`），可用于识别几乎相同的文件。这对于识别恶意软件家族的变种非常有用。'
- en: '**pdftools** : A plugin by Didier Stevens. This extracts information about
    PDF files.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**pdftools**：这是 Didier Stevens 提供的插件，用于提取 PDF 文件的信息。'
- en: '**exiftool** : This shows info, from image files.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**exiftool**：显示图像文件的信息。'
- en: '**pefile** : This shows information about PE files.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**pefile**：显示 PE 文件的信息。'
- en: '**disitool** : This is another Python script from Didier Stevens. This is used
    to extract digital signatures from signed executables.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**disitool**：这是 Didier Stevens 的另一个 Python 脚本，用于从签名的可执行文件中提取数字签名。'
- en: '**pyOLEscanner** : This is a tool used to extract information from OLE file
    types, such as Word documents and Excel spreadsheets.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**pyOLEscanner**：这是一个用于从 OLE 文件类型（如 Word 文档和 Excel 表格）中提取信息的工具。'
- en: 'An example of MASTIFF at work can be seen in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下屏幕截图查看 MASTIFF 工作的示例：
- en: '![](img/6516bd44-c318-439c-b3a9-76a0f2082b52.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6516bd44-c318-439c-b3a9-76a0f2082b52.png)'
- en: MASTIFF can be downloaded from [https://github.com/KoreLogicSecurity/mastiff](https://github.com/KoreLogicSecurity/mastiff).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MASTIFF 可以从 [https://github.com/KoreLogicSecurity/mastiff](https://github.com/KoreLogicSecurity/mastiff)
    下载。
- en: Other information
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他信息
- en: As part of static information gathering, a file is given its own unique hash.
    These hashes are used to identify a file from a database of file information.
    Hash information generally helps analysts share information about the file, without
    transmitting the file itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为静态信息收集的一部分，文件会被分配一个唯一的哈希值。这些哈希值用于从文件信息数据库中识别文件。哈希信息通常有助于分析人员共享有关文件的信息，而无需传输文件本身。
- en: 'Here is an example of MASTIFF''s `file_info` result on a test file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 MASTIFF 在测试文件上的 `file_info` 结果示例：
- en: '![](img/f8f0d228-9306-49fe-b424-b70d53d1d97d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f0d228-9306-49fe-b424-b70d53d1d97d.png)'
- en: PE executables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE 可执行文件
- en: PE executables are programs that work on Windows. Executable files have the
    `.exe` extension. Dynamic link libraries uses the same PE file format and use
    the `.dll` file extension. Windows device driver programs, also in PE file format,
    use the `.sys` extension. There are also other extensions that use the PE file
    format, such as screensavers (`.scr`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PE 可执行文件是适用于 Windows 的程序。可执行文件的扩展名为 `.exe`。动态链接库使用相同的 PE 文件格式，并使用 `.dll` 扩展名。Windows
    设备驱动程序程序也采用 PE 文件格式，扩展名为 `.sys`。还有其他使用 PE 文件格式的扩展名，例如屏幕保护程序（`.scr`）。
- en: 'The PE file format has a header, which is divided into the MZ header, along
    with its DOS stub and the PE header, followed by the data directories and section
    tables, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PE 文件格式包含一个头部，分为 MZ 头部、DOS 存根和 PE 头部，随后是数据目录和节表，如下所示：
- en: '![](img/00d2f852-d39c-4aa4-b0fd-7d4b43e2c34a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00d2f852-d39c-4aa4-b0fd-7d4b43e2c34a.png)'
- en: The file format follows the original `MSDOS EXE` format, but was extended for
    Windows using the PE header. If a Windows program were run in an MSDOS environment,
    it would display this message: `This program cannot be run in DOS mode.`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式遵循原始的 `MSDOS EXE` 格式，但通过 PE 头扩展为 Windows 格式。如果在 MSDOS 环境下运行 Windows 程序，会显示以下消息：`This
    program cannot be run in DOS mode.`。
- en: The code that displays this message is part of the DOS stub.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显示此消息的代码是 DOS 存根的一部分。
- en: The PE header's section table contains all the information about where code
    and data are located in the file, and how it will be mapped into the memory when
    it gets loaded as a process. The PE header contains the address where the program
    begins to execute code—a location known as the entry point—and will be set in
    the EIP register.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PE头的段表包含了关于代码和数据在文件中位置的所有信息，以及它在作为进程加载到内存时如何映射。PE头包含程序开始执行代码的地址——一个称为入口点的位置——并且会被设置在EIP寄存器中。
- en: 'The data directories contain addresses of tables that, in turn, contain information
    such as the import table. The import table contains the libraries and APIs that
    will be used by the program. The table follows a structure that points to a set
    of addresses, pointing, in turn, to the names of libraries and their respective
    export functions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据目录包含指向表的地址，这些表进一步包含诸如导入表之类的信息。导入表包含程序将使用的库和API。该表遵循一个结构，指向一组地址，这些地址依次指向库的名称及其各自的导出函数：
- en: '![](img/1836364c-bd2e-4019-b0eb-b4d51b551935.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1836364c-bd2e-4019-b0eb-b4d51b551935.png)'
- en: 'The `peinfo` module used in `MASTIFF` is able to display the imported libraries
    and functions, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`MASTIFF`中使用的`peinfo`模块能够显示导入的库和函数，如下所示：'
- en: '![](img/fcd61863-d72d-48d5-8a49-d4329ba8f724.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcd61863-d72d-48d5-8a49-d4329ba8f724.png)'
- en: '`HxD` and `HIEW` are popular binary editors used in this chapter; `HxD`, being
    the more popular, is free, and can easily be used to make binary edits to a file.
    More information and a download link can be found at [https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/).
    If you try using `HxD`, you''ll see something similar to this screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`HxD`和`HIEW`是本章中使用的流行二进制编辑器；`HxD`更为流行，是免费的，可以轻松地用于对文件进行二进制编辑。更多信息和下载链接可以在[https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)找到。如果你尝试使用`HxD`，你会看到类似于此屏幕截图的内容：'
- en: '![](img/c242bbb6-783e-43a1-9ea4-b928a97d1e1d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c242bbb6-783e-43a1-9ea4-b928a97d1e1d.png)'
- en: 'Another useful hex-editing tool is `HIEW` (Hacker''s View). The demo and free
    versions are able to parse through a `PE` header. This tool can also show exports
    and imported API functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的十六进制编辑工具是`HIEW`（黑客视图）。演示版和免费版能够解析`PE`头。该工具还可以显示导出和导入的API函数：
- en: '![](img/a0506bee-48e2-45d9-a01b-459883d30afe.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0506bee-48e2-45d9-a01b-459883d30afe.png)'
- en: 'The statically imported modules, libraries, and functions are hints on what
    we can expect the program to access. Consider, for example, that if the `PE` file
    imports the `KERNEL32.DLL` library, then we should expect the file to contain
    core APIs that may access files, processes, and threads, or dynamically load other
    libraries and import functions. Here are some of the more common libraries that
    we should take note of:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入的模块、库和函数是我们可以预期程序访问的线索。例如，考虑到如果`PE`文件导入了`KERNEL32.DLL`库，那么我们应该预期文件包含核心API，这些API可能会访问文件、进程和线程，或者动态加载其他库并导入函数。以下是我们应当注意的一些常见库：
- en: '`ADVAPI32.DLL` : This library contains functions that will access the registry.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADVAPI32.DLL`：此库包含将访问注册表的函数。'
- en: '`MSVCRXX.DLL`  (where XX is a version number. Examples are the libraries `MSVCRT.DLL`
    and `MSVCR80.DLL`) – This contains Microsoft Visual C runtime functions. This
    tells us straight away that the program was compiled using Visual C.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSVCRXX.DLL`（其中XX是版本号。示例包括`MSVCRT.DLL`和`MSVCR80.DLL`）——此文件包含Microsoft Visual
    C运行时函数。这直接告诉我们该程序是使用Visual C编译的。'
- en: '`WININET.DLL` : This library contains functions that accesses the internet.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WININET.DLL`：此库包含访问互联网的函数。'
- en: '`USER32.DLL` : This contains window-control functions related to anything displayed
    on the monitor, such as dialog boxes, showing message boxes, and positioning window
    boxes where they should be.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER32.DLL`：此库包含与显示在显示器上的任何内容相关的窗口控制函数，如对话框、显示消息框和定位窗口框等。'
- en: '`NTDLL.DLL` : This library contains native functions that directly interact
    with the kernel system. `KERNEL32.DLL` and libraries like `USER32.DLL`, `WININET.DLL`,
    and `ADVAPI32.DLL`  have functions that are used to forward information to the
    native functions to perform actual system-level operations.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NTDLL.DLL`：此库包含直接与内核系统交互的原生函数。`KERNEL32.DLL`和像`USER32.DLL`、`WININET.DLL`、`ADVAPI32.DLL`这样的库具有将信息转发到原生函数以执行实际系统级操作的函数。'
- en: Deadlisting
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死列出
- en: Deadlisting is an analysis method where we get to analyze a file's disassembled
    or decompiled code, and map out the flow of events that will happen when it executes.
    The resulting illustrated flow will serve as a guide for dynamic analysis.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Deadlisting是一种分析方法，我们可以分析文件的反汇编或反编译代码，并绘制执行时将发生的事件流。结果呈现的流程图将作为动态分析的指南。
- en: IDA (Interactive Disassembler)
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA（交互式反汇编器）
- en: We previously introduced the IDA tool to show the disassembly of a given file.
    It has a graph-view feature that shows an overview of blocks of code and the branching
    of conditional flow. In deadlisting, we try to describe each block of code and
    what possible results it will give. This gives us an idea of what the program
    does.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍了IDA工具来显示给定文件的反汇编。它具有图形视图功能，显示代码块的概述和条件流的分支。在Deadlisting中，我们试图描述每个代码块及其可能产生的结果。这使我们了解程序的功能。
- en: Decompilers
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反编译器
- en: Some high-level programs are compiled using p-code, such as C# and Visual Basic
    (p-code version). On the contrary, a decompiler attempts to recreate the high-level
    source code based on the p-code. A high-level syntax usually has an equivalent
    block of p-code that can by identified by the decompiler.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级程序使用p-code编译，例如C#和Visual Basic（p-code版本）。相反，反编译器试图根据p-code重新创建高级源代码。高级语法通常有一个等效的p-code代码块，可以被反编译器识别。
- en: Programs compiled using the C language are laid to a file in plain assembly
    language. But since it is still a high-level language, some blocks of code can
    be identified back to their C syntax. The paid version of IDA Pro has an expensive,
    but very useful plugin, called Hex-Rays, that can identify these blocks of code
    and recreate the C source code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C语言编译的程序以纯汇编语言的形式保存在文件中。但由于它仍然是一种高级语言，一些代码块可以被识别并还原为它们的C语法。IDA Pro的付费版本有一个昂贵但非常有用的插件，称为Hex-Rays，可以识别这些代码块并重新创建C源代码。
- en: ILSpy – C# Decompiler
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ILSpy – C#反编译器
- en: A popular tool used to decompile a C# program is ILSpy. Some decompilers will
    leave the analyst with just the source being statically analyzed as is. But, in
    ILSpy, it is possible to save the decompiled source as a Visual Studio project.
    This enables the analyst to compile and debug it for dynamic analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用于反编译C#程序的流行工具是ILSpy。一些反编译器只会留下源代码供静态分析。但是，在ILSpy中，可以将反编译的源代码保存为Visual Studio项目。这使分析人员可以编译和调试以进行动态分析。
- en: Dynamic analysis
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析
- en: Dynamic analysis is a type of analysis that requires live execution of the code.
    In static analysis, the farthest we can go is with deadlisting. If, for example,
    we encounter a code that decrypts or decompresses to a huge amount of data, and
    if we want to see the contents of the decoded data, then the fastest option would
    be to do dynamic analysis. We can run a debug session and let that area of code
    run for us. Both static analysis and dynamic analysis work hand in hand. Static
    analysis helps us identify points in the code where we need a deeper understanding
    and some actual interaction with the system. By following static analysis with
    dynamic analysis, we can also see actual data, such as file handles, randomly
    generated numbers, network socket and packet data, and API function results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析是一种需要代码实时执行的分析类型。在静态分析中，我们最远可以到达的是Deadlisting。例如，如果我们遇到一个解密或解压缩大量数据的代码，并且想要查看解码数据的内容，那么最快的选择就是进行动态分析。我们可以运行调试会话，让该代码区域为我们运行。静态分析和动态分析相辅相成。静态分析帮助我们识别代码中需要更深入理解和与系统进行实际交互的点。通过静态分析后进行动态分析，我们还可以看到实际数据，如文件句柄、随机生成的数字、网络套接字和数据包数据以及API函数结果。
- en: 'There are existing tools that can carry out an automated analysis, which runs
    the program in a sandbox environment. These tools either log the changes during
    runtime, or in between snapshots:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些可以进行自动化分析的工具，这些工具在沙盒环境中运行程序。这些工具要么记录运行时的更改，要么在快照之间记录：
- en: Cuckoo (open source) – This tool is deployed locally. It requires a host and
    sandbox client(s). The host serves as a web console to which files are submitted
    for analysis. The files are executed in the sandbox, and all activities are logged
    and then sent back to the host server. The report can be viewed from the web console.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cuckoo（开源）– 这个工具在本地部署。它需要一个主机和沙盒客户端。主机充当Web控制台，文件被提交进行分析。文件在沙盒中执行，所有活动都被记录，然后发送回主机服务器。报告可以从Web控制台查看。
- en: RegShot (free) - This tool is used to take a snapshot of the registry and file
    system before and after running a program. The difference between the snapshots
    enables the analyst to determine what changes happened. The changes may include
    changes made by the operating system, and it is up to the analyst to identify
    which changes were caused by the program.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RegShot（免费） - 这个工具用于在运行程序之前和之后拍摄注册表和文件系统的快照。快照之间的差异使分析人员能够确定发生了哪些变化。这些变化可能包括操作系统所做的更改，分析人员需要识别哪些变化是由程序引起的。
- en: Sandboxie (freemium) - This tool is used in the environment where the program
    will be run. It is claimed that internally, it uses isolation technology. In essence,
    the isolation technology allocates disk space, to which disk writes will only
    happen at the time the program is executed by Sandboxie. This enables Sandboxie
    to determine changes by looking only at the isolated space. A download link and
    some more information about Sandboxie can be found at [https://www.sandboxie.com/HowItWorks](https://www.sandboxie.com/HowItWorks).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sandboxie（免费增值） - 这个工具用于程序运行的环境中。它声称内部使用了隔离技术。本质上，隔离技术分配磁盘空间，磁盘写入只会在程序通过Sandboxie执行时发生。这使得Sandboxie只通过查看隔离空间来确定变化。关于Sandboxie的下载链接和更多信息可以在[https://www.sandboxie.com/HowItWorks](https://www.sandboxie.com/HowItWorks)找到。
- en: Malwr (free) - This is a free online service that uses Cuckoo. Files can be
    submitted at [https://malwr.com/](https://malwr.com/).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Malwr（免费） - 这是一个免费在线服务，使用Cuckoo。文件可以提交到[https://malwr.com/](https://malwr.com/)。
- en: ThreatAnalyzer (paid) - Originally known as CWSandbox, this is the most popular
    sandboxing technology used in the security industry for automating the extraction
    of information from a piece of running malware. The technology has improved a
    lot, especially with its reporting. In addition, it reports descriptive behaviors
    found, including a cloud query about the submitted file. It can cater to customized
    rules and flexible Python plugins to bring up behaviors seen by the analyst.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ThreatAnalyzer（付费） - 最初称为CWSandbox，这是安全行业中最流行的沙箱技术，用于自动提取运行中恶意软件的信息。该技术得到了很大的改进，特别是在报告方面。此外，它报告了发现的描述性行为，包括关于提交文件的云查询。它可以支持定制规则和灵活的Python插件，展示分析人员看到的行为。
- en: Payload Security's Hybrid Analysis (free) - One of the most popular free online
    services, like Malwr, with report contents similar to that of ThreatAnalyzer.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Payload Security的Hybrid Analysis（免费） - 这是最受欢迎的免费在线服务之一，类似于Malwr，报告内容与ThreatAnalyzer相似。
- en: Submitting files to online services reduce the need to set up a host-sandbox
    environment. However, some would still prefer to set up their own, to avoid having
    files shared to the community or an online service.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提交文件到在线服务减少了设置主机沙箱环境的需求。然而，某些人仍然倾向于自己搭建环境，以避免文件被分享给社区或在线服务。
- en: For malware analysis, it is advisable to do automated analysis and network information
    gathering at the time the file was received. Sites from which malware retrieve
    further data might not be available if authorities act fast enough to take such
    sites down.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于恶意软件分析，建议在收到文件时进行自动化分析和网络信息收集。如果当局足够迅速地关闭这些网站，恶意软件获取更多数据的站点可能无法访问。
- en: Memory regions and the mapping of a process
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域和进程的映射
- en: In dynamic analysis, it is important to know what the memory looks like when
    a program gets loaded and then executed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分析中，了解程序加载并执行时内存的状态非常重要。
- en: Since Windows and Linux are capable of multitasking, every process has its own
    **Virtual Address Space (VAS)**. For a 32-bit operating system, the VAS has a
    size of 4 GB. Each VAS is mapped to the physical memory using its respective page
    table and is managed by the operating system's kernel. So how do multiple VASes
    fit in the physical memory? The operating system manages this using paging. The
    paging has a list of used and unused memory, including privilege flags. If the
    physical memory is not enough, then paging can use disk space as an form of extended
    physical memory. A process and its module dependencies don't use up the whole
    4 GB of space, and only these virtually allocated memory segments are listed as
    used in the page tables and mapped in the physical memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows 和 Linux 都支持多任务处理，每个进程都有自己的**虚拟地址空间（VAS）**。对于 32 位操作系统，VAS 的大小为 4
    GB。每个 VAS 都通过其相应的页表映射到物理内存，并由操作系统的内核进行管理。那么，多个 VAS 如何适应物理内存呢？操作系统通过分页管理这一过程。分页有一个使用和未使用的内存列表，包括特权标志。如果物理内存不足，分页可以使用磁盘空间作为扩展物理内存的形式。一个进程及其模块依赖项并不会占用整个
    4 GB 的空间，只有这些虚拟分配的内存段在页表中标记为已使用，并映射到物理内存中。
- en: 'A VAS is divided into two regions: user space and kernel space, with the kernel
    space located in the higher address region. The division of virtual space differs
    between Windows and Linux:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: VAS 被分为两个区域：用户空间和内核空间，其中内核空间位于较高的地址区域。虚拟空间的划分在 Windows 和 Linux 之间有所不同：
- en: '![](img/664a936f-51f3-4213-880c-ffc38bc1db71.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/664a936f-51f3-4213-880c-ffc38bc1db71.png)'
- en: Every VAS has a kernel space listed in the page tables as a space that has exclusive
    privileges. Generally, these privileges are called kernel mode and user mode.
    These are specifically identified as protection rings. The kernel has a privilege
    of ring 0, while the applications that we use are run on ring 3 privilege. Device
    drivers are in the ring 1 or ring 2 layers, and are also identified as having
    kernel-mode privileges. If user-mode programs try to directly access the kernel
    space in kernel mode, a page fault is triggered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 VAS 都有一个内核空间，在页表中列为具有独占权限的空间。通常，这些权限被称为内核模式和用户模式。它们特定地被标识为保护环。内核具有环 0 的特权，而我们使用的应用程序则在环
    3 特权上运行。设备驱动程序位于环 1 或环 2 层，也被认为具有内核模式权限。如果用户模式程序尝试直接访问内核模式的内核空间，则会触发页故障。
- en: 'Once a VAS is enabled, the user space is initially allocated for the stack,
    heap, the program, and the dynamic libraries. Further allocations are caused by
    the program at runtime by requesting memory using APIs, such as `malloc` and `VirtualAlloc`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 VAS 被启用，用户空间最初会为栈、堆、程序和动态库分配空间。进一步的分配会在程序运行时通过调用内存请求 API（如 `malloc` 和 `VirtualAlloc`）进行：
- en: '![](img/7cc17c91-e137-4106-b08f-5ca519ba4904.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cc17c91-e137-4106-b08f-5ca519ba4904.png)'
- en: 'The preceding screenshot is a mapped view when `jbtest.exe` had just been loaded
    in 32-bit Windows. Here is a more descriptive standard layout of a program in
    a virtual allocated space under Windows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图是 `jbtest.exe` 刚刚在 32 位 Windows 中加载时的映射视图。这里是一个更具描述性的标准布局，展示了程序在 Windows
    中虚拟分配空间中的结构：
- en: '![](img/800ba473-2d11-42de-8307-5c592c009d67.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/800ba473-2d11-42de-8307-5c592c009d67.png)'
- en: Process and thread monitoring
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程监控
- en: Monitoring the processes and threads, especially those that were created by
    the file we are analyzing, tells us that there are more behaviors occurring than
    is obvious. A process can create multiple threads, which tells us that it might
    be doing several behaviors at the same time. A created process tells us that a
    new program was just executed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 监控进程和线程，尤其是那些由我们分析的文件创建的线程，告诉我们比表面上看起来的更多行为。一个进程可以创建多个线程，这意味着它可能在同时执行多个行为。一个创建的进程意味着一个新程序刚刚被执行。
- en: In Windows, the termination, creation, and opening of a process can be monitored
    by third-party tools such as Process Monitor. Though there are built-in tools,
    such as Task Manager, that can show information about processes, some third-party
    tools can give more detail about the processes and the threads tied to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，进程的终止、创建和打开可以通过第三方工具（如 Process Monitor）进行监控。尽管有内置的工具，如任务管理器，能够显示进程信息，但一些第三方工具可以提供更详细的关于进程及其线程的信息。
- en: Network traffic
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络流量
- en: The communicated data between a server and a client computer can only be seen
    during dynamic analysis. The packet captured during transmission will help the
    analyst understand what the program is sending to a server and how it will respond
    to any such data received.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端计算机之间传输的数据只有在动态分析过程中才能看到。在传输过程中捕获的数据包将帮助分析员了解程序向服务器发送了什么数据，以及服务器如何响应接收到的任何数据。
- en: Popular tools, such as Wireshark and Fiddler, are used to capture packets of
    data and store them as `pcap` files. In Linux, the `tcpdump` tool is commonly
    used to do the same thing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的工具，如 Wireshark 和 Fiddler，用于捕获数据包并将其存储为 `pcap` 文件。在 Linux 中，`tcpdump` 工具通常用于执行相同的操作。
- en: Monitoring system changes
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控系统变化
- en: 'For Windows, there are three aspects we need to monitor: memory, disk, and
    registry. File monitoring tools look at created, modified, or deleted files and
    directories. On the other hand, registry monitoring tools look at created, updated,
    or deleted registry keys, values, and data. We can use tools such as `FileMon`
    and `RegMon` to do this job.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，我们需要监控三个方面：内存、磁盘和注册表。文件监控工具会监视创建、修改或删除的文件和目录。另一方面，注册表监控工具会监视创建、更新或删除的注册表键、值和数据。我们可以使用诸如
    `FileMon` 和 `RegMon` 的工具来完成这项工作。
- en: Post-execution differences
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行后的差异
- en: Comparing differences between snapshots taken before and after running the executable
    shows all the system changes that happened. For this type of analysis, any events
    that happened in between are not identified. This is useful for finding out how
    a software installer installed a program. And as a result, the difference comes
    in handy, especially when manually uninstalling a piece of software. The tool
    used here is RegShot.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 比较在执行文件之前和之后拍摄的快照之间的差异，能够显示所有系统变化。这种分析方法无法识别发生在两者之间的任何事件。它对于找出软件安装程序如何安装程序非常有用。因此，差异结果在手动卸载软件时尤其有用。这里使用的工具是
    RegShot。
- en: Debugging
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Deadlisting gives us most of the information we need, including the program's
    branching flow. Now, we have an opportunity to validate the path that the program
    will follow when doing debugging. We get to see the data that are temporarily
    stored in the registers and memory. And instead of manually trying to understand
    a decryption code, debugging it would easily show the resulting decrypted data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 死列表提供了我们需要的大部分信息，包括程序的分支流程。现在，我们有机会验证程序在调试时将遵循的路径。我们可以看到暂时存储在寄存器和内存中的数据。而且，不必手动尝试理解解密代码，调试它会直接显示解密后的数据。
- en: 'Tools used for debugging in Windows include the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Windows 调试的工具包括以下几种：
- en: '`OllyDebug`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OllyDebug`'
- en: '`x86dbg`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x86dbg`'
- en: '`IDA Pro`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDA Pro`'
- en: 'Tools used for debugging Linux include the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调试 Linux 的工具包括以下几种：
- en: '`gdb`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdb`'
- en: '`radare2`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radare2`'
- en: Try it yourself
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲自试试看
- en: 'To try out the tools we have learned about, let''s try doing some static analysis
    on `ch4_2.exe`. To help out, here''s a list of what we need to find:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试我们学到的工具，让我们对 `ch4_2.exe` 进行一些静态分析。为了帮助，以下是我们需要找到的内容：
- en: 'File information:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件信息：
- en: file type
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型
- en: imported DLLs and APIs
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的 DLL 和 API
- en: text strings
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串
- en: file hash
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希
- en: What the file does
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的作用
- en: 'Jumping right into getting file information, we will use TrID ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))
    to identify the file type. Execute the following line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 直接获取文件信息，我们将使用 TrID（[http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html)）来识别文件类型。执行以下命令：
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The TrID result tells us that we have here a Windows 32-bit executable file
    that is UPX packed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: TrID 结果告诉我们，我们这里有一个 Windows 32 位可执行文件，且经过 UPX 压缩：
- en: '![](img/449c55a6-ab9c-408d-9d76-3b7762093a72.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/449c55a6-ab9c-408d-9d76-3b7762093a72.png)'
- en: 'Knowing that this is a UPX packed file, we can try the UPX ([https://upx.github.io/](https://upx.github.io/))
    tool''s decompress feature to help us restore the file back to its original form
    before it was packed. A packed file is a compressed executable file that decompresses
    and then executes the program during runtime. The primary purpose of a packed
    file is to reduce the file size of executables while retaining the program''s
    original  behavior. We will be discussing more about packers in [*Chapter 10*](1dd193b9-0d30-425a-b593-f3b6bcce3414.xhtml),
    *Packing and Encryption*, of this book. For now, let''s just unpack this file
    with the UPX tool using the `-d` parameter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这是一个UPX压缩文件后，我们可以尝试使用UPX ([https://upx.github.io/](https://upx.github.io/))工具的解压功能来帮助我们将文件恢复到压缩前的原始状态。压缩文件是一个在运行时会先解压再执行程序的可执行文件。压缩文件的主要目的是在保持程序原有行为的同时，减小可执行文件的大小。我们将在本书的[*第10章*](1dd193b9-0d30-425a-b593-f3b6bcce3414.xhtml)，*压缩与加密*，中详细讨论更多关于打包工具的内容。现在，我们只需使用UPX工具并加上`-d`参数来解压这个文件：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results to the file being expanded back to its original form:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致文件被恢复到其原始形态：
- en: '![](img/4f903d05-ec27-4bdf-9b12-15b10a665c15.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f903d05-ec27-4bdf-9b12-15b10a665c15.png)'
- en: 'And if we use `TrID` this time, we should get a different result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这次使用`TrID`，我们应该得到不同的结果：
- en: '![](img/18765e82-1a78-42e9-b239-18a8920c4aa9.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18765e82-1a78-42e9-b239-18a8920c4aa9.png)'
- en: 'It is still a Windows executable file, so we can use CFF Explorer to check
    for more information:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然是一个Windows可执行文件，因此我们可以使用CFF Explorer来查看更多信息：
- en: '![](img/e2d58160-cafa-4741-bb25-c7a05186361d.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2d58160-cafa-4741-bb25-c7a05186361d.png)'
- en: 'On the left pane, if we select Import Directory, we should see a list of imported
    library files and API functions it will use, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板中，如果我们选择导入目录，我们应该看到它将使用的导入库文件和API函数列表，如下所示：
- en: '![](img/6dba3eaa-2f0c-4272-9f40-4aabf5f35faa.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dba3eaa-2f0c-4272-9f40-4aabf5f35faa.png)'
- en: Clicking on `USER32.dll`, we see that the `MessageBoxA` API is going to be used
    by the program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`USER32.dll`，我们看到程序将使用`MessageBoxA` API。
- en: 'Using the bintext ([http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip](http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip))
    tool, we can see a list of text strings found in the file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bintext ([http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip](http://b2b-download.mcafee.com/products/tools/foundstone/bintext303.zip))工具，我们可以看到文件中发现的文本字符串列表：
- en: '![](img/473e0328-74e1-4037-9036-11ca8411be2c.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/473e0328-74e1-4037-9036-11ca8411be2c.png)'
- en: 'These appear to be the notable text strings, which suggest that the program
    checks for the time and displays various greetings. It will probably retrieve
    a file from the internet. It may do something about the `File.txt` file. But all
    these are just educated guesses, which makes good practice for reversing, as it
    helps use to build an overview of the relationship between each aspect of our
    analysis:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些似乎是显著的文本字符串，暗示程序会检查时间并显示各种问候语。它可能会从互联网下载一个文件。它可能对`File.txt`文件执行某些操作。但所有这些都只是有根据的猜测，这对逆向工程来说是一个很好的练习，因为它帮助我们构建分析中各个方面之间关系的概览：
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The hash (MD5, SHA1, SHA256) of a file will help as a reference to every file
    we analyze. There are a lot of file hash-generating tools available in the internet.
    To generate the hashes of this file, we chose a tool called HashMyFiles. This
    is a tool compiled for Windows OS and can be added to the context menu (right-click)
    of the Windows Explorer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的哈希值（MD5、SHA1、SHA256）将作为我们分析每个文件的参考。互联网上有很多生成文件哈希的工具。为了生成这个文件的哈希值，我们选择了一个名为HashMyFiles的工具。这是一个为Windows操作系统编译的工具，并且可以添加到Windows资源管理器的右键菜单中：
- en: '![](img/3ba6a73b-d820-4195-805e-daa71edd8dcb.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ba6a73b-d820-4195-805e-daa71edd8dcb.png)'
- en: 'It can display the file''s `CRC`, `MD5`, `SHA1`, `SHA-256`, `SHA-512`, and
    `SHA-384`, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以显示文件的`CRC`、`MD5`、`SHA1`、`SHA-256`、`SHA-512`和`SHA-384`，如下所示：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usually, we only take either `MD5`, `SHA1`, or `SHA256`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只会使用`MD5`、`SHA1`或`SHA256`。
- en: 'We should not forget the file size and the creation time using a simple file
    property check:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应忘记通过简单的文件属性检查查看文件的大小和创建时间：
- en: '![](img/acf21dd1-2b1d-4a96-a749-223e79541616.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acf21dd1-2b1d-4a96-a749-223e79541616.png)'
- en: The Modified date is more relevant in terms of when the file was actually compiled.
    The Created date is when the file was written or copied to the directory where
    it is now. That means that the first time the file was built, both the Created
    and Modified dates were the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 修改日期在文件实际编译时更为相关。创建日期是文件写入或复制到现在目录时的日期。这意味着当文件首次创建时，创建日期和修改日期是相同的。
- en: To statically analyze the file's behavior, we will be using a disassembly tool
    known as IDA Pro. A freeware version of IDA Pro can be found at [https://www.hex-rays.com/products/ida/support/download_freeware.shtml](https://www.hex-rays.com/products/ida/support/download_freeware.shtml).
    But, if you can afford the luxury of its paid version, which we highly recommend,
    please do purchase it. We find the features and supported architectures of the
    paid version way better. But for this book, we will be using every available tool
    that does not require purchasing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了静态分析文件的行为，我们将使用一个叫做 IDA Pro 的反汇编工具。IDA Pro 的免费版本可以在[https://www.hex-rays.com/products/ida/support/download_freeware.shtml](https://www.hex-rays.com/products/ida/support/download_freeware.shtml)找到。但是，如果你能够负担它的付费版本（我们强烈推荐），请务必购买。我们发现付费版的功能和支持的架构要好得多。但对于本书，我们将使用所有不需要购买的工具。
- en: There are currently two known free versions of IDA Pro. We have made backups
    of the tool available at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools).
    And since we are dealing with a 32-bit Windows executable file, select the 32-bit
    version.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前已知有两个免费的 IDA Pro 版本。我们已将该工具的备份上传至[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/tools/Disassembler%20Tools)。由于我们处理的是一个
    32 位的 Windows 可执行文件，请选择 32 位版本。
- en: 'Once IDA Pro is installed, open up `cha4_2.exe` inside. Wait for the auto-analysis
    to complete and it will redirct the disassembly to the `WinMain` function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 IDA Pro 后，打开其中的 `cha4_2.exe`。等待自动分析完成，它将把反汇编重定向到 `WinMain` 函数：
- en: '![](img/fc46e48f-ae83-437a-89db-68b7e6102919.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc46e48f-ae83-437a-89db-68b7e6102919.png)'
- en: 'Scrolling down will show more disassembly code that we learned in [*Chapter
    3*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml), *The Low-Level Language*. For
    deadlisting behaviors, we usually look for instructions that call APIs. The very
    first API we encounter is a call to `GetSystemTime`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动将显示我们在[*第3章*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml)《低级语言》中学到的更多反汇编代码。对于死链行为，我们通常寻找调用
    API 的指令。我们遇到的第一个 API 调用是 `GetSystemTime`：
- en: '![](img/af6fa114-88dc-46b1-8ce9-fb62405eeba4.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af6fa114-88dc-46b1-8ce9-fb62405eeba4.png)'
- en: 'Following the code, we encounter these API functions in this sequence:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照代码的顺序，我们依次遇到了以下 API 函数：
- en: '`vsprintf_s`'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vsprintf_s`'
- en: '`MessageBoxA`'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MessageBoxA`'
- en: '`InternetOpenA`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InternetOpenA`'
- en: '`InternetConnectW`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InternetConnectW`'
- en: '`InternetOpenUrlA`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InternetOpenUrlA`'
- en: '`memset`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`memset`'
- en: '`InternetReadFile`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InternetReadFile`'
- en: '`InternetCloseHandle`'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InternetCloseHandle`'
- en: '`strcpy_s`'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`strcpy_s`'
- en: '`CreateFileA`'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateFileA`'
- en: '`WriteFile`'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriteFile`'
- en: '`CloseHandle`'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CloseHandle`'
- en: '`RegCreateKeyExW`'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegCreateKeyExW`'
- en: '`RegSetValueExA`'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegSetValueExA`'
- en: 'With what we learned in [*Chapter 3*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml),
    *The Low Level Language*, try to follow the code and deduce what the file will
    do without executing it. To help out, here are the expected behaviors of the program:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们在[*第3章*](c296c377-99c9-422d-b021-ce72b3d731dc.xhtml)《低级语言》中学到的知识，试着跟踪代码并推测文件在不执行的情况下会做什么。为了帮助你，这里是程序的预期行为：
- en: 'Displaying a message depending on the current system time. The messages can
    be one of the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前系统时间显示不同的消息。消息可能为以下之一：
- en: '`Good Morning`'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Good Morning`'
- en: '`Good Afternoon`'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Good Afternoon`'
- en: '`Good Evening`'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Good Evening`'
- en: '`` `Nice Night` ``'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `Nice Night` ``'
- en: Reading the contents of a file from the internet, decrypting the contents, and
    saving it to a file named `File.txt`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网读取文件内容，解密内容，并将其保存到名为 `File.txt` 的文件中。
- en: Making a registry key, `HKEY_CURRENT_USER\Software\Packt`, and storing the same
    decrypted data in the `Reversing` registry value.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个注册表键 `HKEY_CURRENT_USER\Software\Packt`，并将相同的解密数据存储在 `Reversing` 注册表值中。
- en: This may take a long time for beginners, but with continuous practice, analysis
    will be done at a fast pace.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，这可能需要较长时间，但通过持续的练习，分析速度会逐渐加快。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Both approaches to analysis, static and dynamic, have their means to extract
    information and are required to properly analyze a file. Before doing dynamic
    analysis, it is recommended to start with static analysis first. We stick to our
    goal of generating an analysis report from the information we get. The analyst
    is not limited to using just the tools and resources outlined here to conduct
    an analysis—any information from the internet is useful, but validating it with
    your own analysis will stand as proof. Taking all items from the file, such as
    notable text strings, imported API functions, system changes, code flows, and
    possible blocks of behaviors are important, as these may be useful when building
    an overview of the file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析和动态分析这两种方法都有各自提取信息的手段，并且在正确分析文件时都是必要的。在进行动态分析之前，建议先从静态分析开始。我们坚持从我们获得的信息中生成分析报告的目标。分析师不仅仅局限于使用这里列出的工具和资源来进行分析——互联网中的任何信息都是有用的，但通过自己的分析来验证这些信息将作为证据。提取文件中的所有项目，如显著的文本字符串、导入的
    API 函数、系统变化、代码流程以及可能的行为块都很重要，因为这些在构建文件概述时可能会有帮助。
- en: The result of the static analysis draws together the approach and resources
    that need to be prepared for dynamic analysis. For example, if the static analysis
    identified the file as a `Win32` PE file executable, then tools for analyzing
    PE files will need to be prepared.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的结果总结了动态分析所需的准备工作和资源。例如，如果静态分析将文件识别为 `Win32` PE 可执行文件，那么就需要准备分析 PE 文件的工具。
- en: As part of dynamic analysis, we discussed about **Virtual Allocated Space (VAS)**
    and how a program is mapped in memory along with its library dependencies. This
    information comes in handy when attempting reversing in further chapters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为动态分析的一部分，我们讨论了**虚拟分配空间（VAS）**以及一个程序如何在内存中映射及其库依赖关系。当尝试进一步反向工程时，这些信息非常有用。
- en: We also introduced a few tools that we can use to engage in both static and
    dynamic approaches, and ended this chapter with a brief exercise on a 32-bit Windows
    PE executable file. In the next chapter, we will show more use of some of these
    tools as we reverse-engineer files.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了几种可以用于静态和动态分析的方法，并以对一个 32 位 Windows PE 可执行文件的简短练习结束了本章。在下一章中，我们将展示如何在反向工程文件时更多地使用这些工具。
- en: References
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: The files used in this chapter can be downloaded from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering](https://github.com/PacktPublishing/Mastering-Reverse-Engineering).
    [](https://github.com/PacktPublishing/Mastering-Reverse-Engineering)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的文件可以从[https://github.com/PacktPublishing/Mastering-Reverse-Engineering](https://github.com/PacktPublishing/Mastering-Reverse-Engineering)下载。
    [](https://github.com/PacktPublishing/Mastering-Reverse-Engineering)
