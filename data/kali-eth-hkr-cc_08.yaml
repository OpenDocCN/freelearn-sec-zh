- en: Have Shell Now What?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在有Shell了，怎么办？
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下教程：
- en: Spawning a TTY shell
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成TTY shell
- en: Looking for weakness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找弱点
- en: Horizontal escalation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平升级
- en: Vertical escalation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直升级
- en: 'Node hopping: pivoting'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点跳跃：转向
- en: Privilege escalation on Windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的特权升级
- en: PowerSploit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerSploit
- en: Pulling plaintext passes with mimikatz
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mimikatz提取明文密码
- en: Dumping other saved passwords from the machine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从机器中转储其他保存的密码
- en: Pivoting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向
- en: Backdooring executables for persistence
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了持久性而给可执行文件加后门
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This is privilege escalation, as described on Wikipedia, **privilege escalation**
    is the act of exploiting a bug, design flaw, or configuration oversight in an
    operating system or software application to gain elevated access to resources
    that are normally protected from an application or user. This results in unauthorized
    access to resources. Two types of privilege escalation are possible:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是特权升级，正如维基百科所述，**特权升级**是利用操作系统或软件应用程序中的漏洞、设计缺陷或配置疏忽来获取对通常受到应用程序或用户保护的资源的提升访问权限的行为。这导致对资源的未经授权访问。可能存在两种特权升级：
- en: '**Horizontal**: This occurs in conditions where we are able to execute commands
    or functions that were not originally intended for the user access we currently
    have'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平**：这种情况发生在我们能够执行原本不是为当前用户访问而设计的命令或函数的条件下'
- en: '**Vertical**: This kind of exploitation occurs when we are able to escalate
    our privileges to a higher user level, for example, getting root on the system'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直**：这种利用发生在我们能够将我们的特权提升到更高的用户级别时，例如，在系统上获取root权限'
- en: In this chapter, you will learn the different ways of escalating our privileges
    on Linux and Windows systems as well as gaining access to the internal network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习在Linux和Windows系统上提升特权的不同方法，以及访问内部网络的方法。
- en: Spawning a TTY Shell
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成TTY Shell
- en: We have covered different types of privilege escalation. Now let's look at some
    examples on how to get a TTY shell on this system. A TTY showcases a simple text
    output environment, that allows us to type commands and get the output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了不同类型的特权升级。现在让我们看一些关于如何在这个系统上获取TTY shell的例子。TTY展示了一个简单的文本输出环境，允许我们输入命令并获取输出。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look at the following example, where we have a web application running
    zenPHOTO:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们有一个运行zenPHOTO的Web应用程序：
- en: '![](img/1df99474-bae8-444e-8ce4-f6499ccf736c.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1df99474-bae8-444e-8ce4-f6499ccf736c.png)'
- en: 'The zenPHOTO already has a public exploit running, which we get access to via
    a limited shell:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: zenPHOTO已经有一个公开的漏洞正在运行，我们通过有限的shell获得了对它的访问：
- en: '![](img/71dccab9-1325-45e2-a316-cfc79f2add44.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71dccab9-1325-45e2-a316-cfc79f2add44.png)'
- en: 'Since this is a limited shell, we try to escape it and get a reverse connection
    by first uploading `netcat` on the system and then using `netcat` to gain a backconnect:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个有限的shell，我们尝试逃离它，并通过首先在系统上上传`netcat`，然后使用`netcat`来获取反向连接。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/97b42970-b8ee-49ba-b65b-0227a40cc547.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97b42970-b8ee-49ba-b65b-0227a40cc547.png)'
- en: 'Now we can backconnect using the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令进行反向连接：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/0a0a6460-ac7c-438d-a887-d2fa62a4247a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a0a6460-ac7c-438d-a887-d2fa62a4247a.png)'
- en: 'Looking at our Terminal window, where we had our listener setup, we will see
    a successful connection:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看着我们的终端窗口，在那里我们设置了监听器，我们会看到一个成功的连接：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/bc9d7e89-ab1b-4d7a-9621-957fb743e7e3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc9d7e89-ab1b-4d7a-9621-957fb743e7e3.png)'
- en: 'Let''s get a more stable TTY shell; assuming it''s a Linux system, we already
    have Python installed on it and we can get a shell using this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取一个更稳定的TTY shell；假设这是一个Linux系统，我们已经在上面安装了Python，并且我们可以使用这个命令获取一个shell：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/8c23665a-29d9-4849-a7ec-802f1bf37808.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c23665a-29d9-4849-a7ec-802f1bf37808.png)'
- en: We now have a much better way to execute commands. Sometimes, we may find ourselves
    in a situation in which the shell we gain access to via ssh or another method
    is a limited shell.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个更好的执行命令的方式。有时，我们可能会发现自己处于这样一种情况：我们通过ssh或其他方法获得的shell是一个有限的shell。
- en: 'One very famous limited shell is `lshell`, which allows us to run only a few
    commands, such as `echo`, `ls`, `help`, and so on. Escaping `lshell` is easy as
    all we have to do is type this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常著名的有限shell是`lshell`，它只允许我们运行一些命令，比如`echo`、`ls`、`help`等。逃离`lshell`很容易，因为我们只需要输入这个：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And we have access to a command shell with no more limits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就可以访问一个没有更多限制的命令shell。
- en: '![](img/65dfc583-757e-412e-a60a-a1183fa69944.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65dfc583-757e-412e-a60a-a1183fa69944.png)'
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are various other ways to spawn a TTY shell using Ruby, Perl, and so on.
    This can be seen at [http://netsec.ws/?p=337](http://netsec.ws/?p=337).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他各种方式可以使用Ruby、Perl等生成TTY shell。这可以在[http://netsec.ws/?p=337](http://netsec.ws/?p=337)上看到。
- en: Looking for weakness
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找弱点
- en: Now that we have a stable shell, we need to look for vulnerabilities, misconfigurations,
    or anything that will help us in escalating privileges on the system. In this
    recipe, we will look at some of the ways in which privileges can be escalated
    to get the root of the system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个稳定的shell，我们需要寻找漏洞、错误配置或任何能帮助我们在系统上提升特权的东西。在这个教程中，我们将看一些提升特权以获取系统根目录的方法。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The basic step I would recommend to all of you after we have a shell on a server
    is to do as much enumeration as possible: the more we know, the better we have
    a chance of escalating privileges on the system.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议大家在服务器上有了shell之后，尽可能多地进行枚举：我们知道的越多，我们就有更好的机会在系统上提升特权。
- en: 'The key steps to escalating privileges, as mentioned on `g0tmi1k`, on a system
    are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如`g0tmi1k`所述，提升特权的关键步骤在系统上是：
- en: '**Collect**: Enumeration, more enumeration, and some more enumeration.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集**：枚举，更多的枚举，还有更多的枚举。'
- en: '**Process**: Sort through data, analyze, and prioritize.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：整理数据，分析和排序。'
- en: '**Search**: Know what to search for and where to find the exploit code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：知道要搜索什么以及在哪里找到利用代码。'
- en: '**Adapt**: Customize the exploit so it fits. Not every exploit works for every
    system **out of the box**.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应**：自定义漏洞以适应。并非每个漏洞都可以直接在每个系统上使用。'
- en: '**Try**: Get ready for (lots of) trial and error.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尝试**：准备好（很多）试错。'
- en: We will look at some of the most common scripts available on the internet, which
    makes our job easier by printing out whatever we need in a formatted manner.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些在互联网上常见的脚本，这些脚本通过格式化的方式打印出我们需要的任何信息，从而使我们的工作更加轻松。
- en: 'The first one is `LinEnum`, which is a shell script created by the reboot user.
    It performs over 65 checks and shows us everything we need to start with:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`LinEnum`，这是一个由reboot用户创建的shell脚本。它执行了65多项检查，并显示了我们需要开始的一切：
- en: '![](img/d29200d8-3f51-4a14-b4dc-db057accc486.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d29200d8-3f51-4a14-b4dc-db057accc486.png)'
- en: 'Seeing the source code, we will see that it will display information such as
    kernel version, user info, world-writable directories, and so on:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码，我们将看到它将显示内核版本、用户信息、可写目录等信息：
- en: '![](img/08dce2a5-5474-409e-b68c-18bfd4255676.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08dce2a5-5474-409e-b68c-18bfd4255676.png)'
- en: 'The next script we can use is `LinuxPrivChecker`. It is made in Python. This
    script also suggests privilege escalation exploits that can be used on the system:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的下一个脚本是`LinuxPrivChecker`。它是用Python制作的。这个脚本还建议可以在系统上使用的特权升级漏洞：
- en: '![](img/d03ff64c-e5ae-4e94-b522-4c1fd0a70475.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d03ff64c-e5ae-4e94-b522-4c1fd0a70475.png)'
- en: These scripts are easy to find on Google; however, more information about this
    or the manual commands we can use to do the job ourselves can be found at [http://netsec.ws/?p=309](http://netsec.ws/?p=309)
    and G0tmilk's blog [https://blog.g0tmi1k.com/](https://blog.g0tmi1k.com/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本很容易在Google上找到；但是，关于这个或者我们可以使用手动命令自己完成工作的更多信息可以在[http://netsec.ws/?p=309](http://netsec.ws/?p=309)和G0tmilk的博客[https://blog.g0tmi1k.com/](https://blog.g0tmi1k.com/)找到。
- en: 'One more great script was created by `Arr0way` ([https://twitter.com/Arr0way](https://twitter.com/Arr0way)).
    He made it available on his blog, [https://highon.coffee/blog/linux-local-enumeration-script](https://highon.coffee/blog/linux-local-enumeration-script).
    We can read the source code available on the blog to check everything the script
    does:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的脚本是由`Arr0way`（[https://twitter.com/Arr0way](https://twitter.com/Arr0way)）创建的。他在他的博客[https://highon.coffee/blog/linux-local-enumeration-script](https://highon.coffee/blog/linux-local-enumeration-script)上提供了源代码。我们可以阅读博客上提供的源代码，以检查脚本的所有功能：
- en: '![](img/327c2d7c-9460-4a11-887a-608870ebaa09.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/327c2d7c-9460-4a11-887a-608870ebaa09.png)'
- en: Horizontal escalation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平升级
- en: You have already learned how to spawn a TTY shell and perform enumeration. In
    this recipe, we will look at some of the methods where horizontal escalation can
    be done to gain more privileges on the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何生成TTY shell并执行枚举。在这个教程中，我们将看一些可以进行水平升级以获得更多系统特权的方法。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Here, we have a situation where we have got a reverse shell as `www-data`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个情况，我们已经以`www-data`的身份获得了一个反向shell。
- en: 'Running `sudo –-list`, we find that the user is allowed to open a configuration
    file as another user, `waldo`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`sudo –-list`，我们发现用户被允许以另一个用户`waldo`的身份打开配置文件：
- en: '![](img/6c5959ab-2e97-4ca8-b4fb-2be36f170a12.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c5959ab-2e97-4ca8-b4fb-2be36f170a12.png)'
- en: 'So, we open up the config file in VI Editor, and to get a shell in VI, we type
    this in the VI’s command line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在VI编辑器中打开配置文件，并在VI的命令行中输入以下内容以在VI中获取shell：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/b33d99b3-60fb-4f4f-850e-8b208272bdda.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b33d99b3-60fb-4f4f-850e-8b208272bdda.png)'
- en: We now have a shell with the user `waldo`. So, our escalation was successful.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个以用户`waldo`身份的shell。所以，我们的升级是成功的。
- en: In some cases, we may also find authorized keys in the `ssh` directory or saved
    passwords, that help us perform horizontal escalation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们还可能在`ssh`目录中找到授权密钥或保存的密码，这有助于我们进行水平升级。
- en: Vertical escalation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直升级
- en: In this recipe, we will look at some examples using which we can gain access
    to a root account on a comprised box. The key to a successful escalation is to
    gather as much information as possible about the system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看一些例子，通过这些例子我们可以访问受损系统上的root账户。成功升级的关键是尽可能多地收集有关系统的信息。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step of rooting any box would be to check whether there are any publically
    available local root exploits:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何盒子进行root的第一步是检查是否有任何公开可用的本地root漏洞：
- en: 'We can use scripts such as **Linux Exploit Suggester**. It is a script built
    in Perl where we can specify the kernel version and it will show us the possible
    publicly-available exploits we can use to gain root privileges. The script can
    be downloaded from [https://github.com/PenturaLabs/Linux_Exploit_Suggester](https://github.com/PenturaLabs/Linux_Exploit_Suggester):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用诸如**Linux Exploit Suggester**之类的脚本。这是一个用Perl构建的脚本，我们可以指定内核版本，它将显示可能公开可用的漏洞利用，我们可以使用它来获得root权限。该脚本可以从[https://github.com/PenturaLabs/Linux_Exploit_Suggester](https://github.com/PenturaLabs/Linux_Exploit_Suggester)下载：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/6688998f-d1ca-4c5b-940d-20901bbaeb2f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6688998f-d1ca-4c5b-940d-20901bbaeb2f.png)'
- en: 'Now we go to the directory using the `cd` command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`cd`命令进入目录：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is simple to use, and we can find the kernel version by command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它很容易使用，我们可以通过命令找到内核版本：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also use the enumeration scripts that we saw in the previous recipe.
    Once we have the version, we can use it with our script with the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用我们在上一个教程中看到的枚举脚本。一旦我们有了版本，我们可以使用以下命令将其与我们的脚本一起使用：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/aa614691-c993-4446-9340-45bbc2d8d136.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa614691-c993-4446-9340-45bbc2d8d136.png)'
- en: Let's us try using one of the exploits; we will be using the latest one that
    came out, that is, **dirty cow**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用其中一个漏洞利用；我们将使用最新的一个，即**dirty cow**。
- en: 'This is the definition of dirty cow as explained by RedHat: a race condition
    was found in the way the Linux kernel''s memory subsystem handled the **copy-on-write**
    (**COW**) breakage of private read-only memory mappings. An unprivileged local
    user could use this flaw to gain write access to otherwise read-only memory mappings
    and thus increase their privileges on the system.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RedHat解释的dirty cow的定义：在Linux内核的内存子系统处理**写时复制**（**COW**）破坏私有只读内存映射的方式中发现了竞争条件。非特权本地用户可以利用这个缺陷来获得对否则只读内存映射的写访问权限，从而增加他们在系统上的权限。
- en: 'The exploit code can be seen on exploit DB at [https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/).
    This particular exploit adds a new user to `etc/passwd` with root privileges:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在exploit DB上看到这个漏洞代码[https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/)。这个特定的漏洞利用程序向`etc/passwd`添加了一个具有根权限的新用户：
- en: '![](img/d6238552-2c9f-40e2-8261-4c1a6da7fb62.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6238552-2c9f-40e2-8261-4c1a6da7fb62.png)'
- en: 'We download the exploit and save it on the server''s `/tmp` directory. It''s
    written in C language, so we can compile it using `gcc` on the server itself using
    the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下载漏洞并将其保存在服务器的`/tmp`目录中。它是用C语言编写的，所以我们可以使用服务器上的`gcc`编译它，使用以下命令：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/eeea674d-3c1d-42ff-9815-f2baa6145502.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eeea674d-3c1d-42ff-9815-f2baa6145502.png)'
- en: 'We `chmod` (change file permissions) the file using this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令`chmod`（更改文件权限）文件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And then we run it using `./dirty`. We will lose our backconnect access, but
    if everything goes well, we can now `ssh` into the machine as the root with the
    username `firefart` and password `firefart`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`./dirty`运行它。我们将失去我们的反向连接访问权限，但如果一切顺利，我们现在可以使用用户名`firefart`和密码`firefart`作为根用户`ssh`到机器上。
- en: 'We try the `ssh` using this command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令尝试`ssh`：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/f5371878-fc1d-4a48-b4d2-925e4c4a0021.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5371878-fc1d-4a48-b4d2-925e4c4a0021.png)'
- en: 'Now, dirty cow is a bit unstable, but we can use this workaround to make it
    stable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，dirty cow有点不稳定，但我们可以使用这个解决方法来使其稳定：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's execute the command ID; we will see that we are now root on the system!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行命令ID；我们将看到我们现在是系统的根用户！
- en: '![](img/8eb13a53-9176-429a-9cf2-217c4ec14cb3.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8eb13a53-9176-429a-9cf2-217c4ec14cb3.png)'
- en: Now let's look at another method to achieve the root. In this situation, we
    will assume that we have a shell on system and the enumeration scripts we ran
    showed us that MySQL process is running as the root on the system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看另一种实现根权限的方法。在这种情况下，我们将假设我们在系统上有一个shell，并且我们运行的枚举脚本向我们显示MySQL进程正在作为系统根用户运行。
- en: '![](img/21e973d7-e52a-4aef-8722-b3765333bfc7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21e973d7-e52a-4aef-8722-b3765333bfc7.png)'
- en: 'MySQL has a feature called **User Defined Functions** (**UDF**); let''s look
    at a way to get root via UDF injection. Now we have two options: either download
    the code and compile on the compromised system or download a precompiled code
    from [https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.so](https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.so).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有一个名为**用户定义函数**（**UDF**）的功能；让我们看一种通过UDF注入获得根权限的方法。现在我们有两个选择：要么在受损系统上下载代码并进行编译，要么从[https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.so](https://github.com/mysqludf/lib_mysqludf_sys/blob/master/lib_mysqludf_sys.so)下载预编译代码。
- en: '![](img/9d3ff962-4dc2-4858-b2a6-1caa42393401.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3ff962-4dc2-4858-b2a6-1caa42393401.png)'
- en: Once it has been downloaded, we log in to the database. Usually, people leave
    the default root password blank; or, we can get one from the config files of the
    web application running on the server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它被下载，我们就登录到数据库。通常，人们会将默认的root密码留空；或者，我们可以从运行在服务器上的web应用程序的配置文件中获取一个。
- en: 'Now, we create a table and insert our file into the table using these commands:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个表，并使用这些命令将我们的文件插入到表中：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/1b701a67-b90d-4d76-bc93-cb5affcf3b9a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b701a67-b90d-4d76-bc93-cb5affcf3b9a.png)'
- en: For Windows systems, the commands are the same; only the path to MySQL would
    be different.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows系统，命令是一样的；只是到MySQL的路径会有所不同。
- en: 'Next, we create a `sys_eval` function, that will allow us to run system commands
    as the root user. For Windows, we run this command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`sys_eval`函数，它将允许我们以根用户身份运行系统命令。对于Windows，我们运行这个命令：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For Linux, we run this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，我们运行这个命令：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can use `sys_eval` for anything we want; for example, to backconnect,
    we can use this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`sys_eval`来做任何我们想做的事情；例如，要进行反向连接，我们可以使用这个：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/61944af5-d653-46a7-9f81-e8248a267d63.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61944af5-d653-46a7-9f81-e8248a267d63.png)'
- en: 'This will give us a reverse shell as the root on the system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个作为系统根用户的反向shell：
- en: '![](img/f4775e23-2507-4246-846b-476e26bb1e4b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4775e23-2507-4246-846b-476e26bb1e4b.png)'
- en: There are other ways too, such as adding our current user to the sudoers file.
    It's all up to our imagination.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法，比如将我们当前的用户添加到sudoers文件中。这完全取决于我们的想象力。
- en: Node hopping – pivoting
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点跳跃 - 枢纽
- en: Once we are in one system on the network, we need to now look for other machines
    on the network. Information gathering is the same as what we learned in the previous
    chapters. We can start by installing and using nmap to look for other hosts and
    the application or services running. In this recipe, you will learn about a few
    tricks to get access to the port in the network.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在网络上的一个系统中，我们现在需要寻找网络上的其他机器。信息收集与我们在前几章中学到的内容是一样的。我们可以开始安装和使用nmap来查找其他主机以及正在运行的应用程序或服务。在这个示例中，您将学习一些获取网络中端口访问权限的技巧。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s assume we have shell access to a machine. We run `ipconfig` and find
    that the machine is connected to two other networks internally:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经可以访问一台机器的shell。我们运行`ipconfig`并发现该机器内部连接到其他两个网络：
- en: '![](img/fb14066b-f091-45eb-9d44-af27a6ddd740.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb14066b-f091-45eb-9d44-af27a6ddd740.png)'
- en: Now we nmap scan the network and find some machines with a couple of ports open.
    You learned about a cool way of pivoting into the networks so that we can access
    the applications running behind other network on our machine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们扫描网络并发现一些机器有一些端口是开放的。您学习了一种很酷的方法，可以将网络枢纽化，以便我们可以访问我们机器上其他网络后面运行的应用程序。
- en: 'We will do a `ssh` port forward using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令进行`ssh`端口转发：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/2617ef3b-2b5b-449a-85a1-41035e7fae03.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2617ef3b-2b5b-449a-85a1-41035e7fae03.png)'
- en: 'Once this is done, we open the browser and go to the port number we used:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们打开浏览器并转到我们使用的端口号：
- en: '![](img/c6cf79ba-cab5-4f8b-824f-69386eb625b0.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6cf79ba-cab5-4f8b-824f-69386eb625b0.png)'
- en: We will have access to the application running on the remote host.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问远程主机上运行的应用程序。
- en: There's more…
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are other ways to port forward; for example, using proxychains will help
    you dynamically forward the ports running on a server inside a different network
    subnet. Some of the techniques can be found at [https://highon.coffee/blog/ssh-meterpreter-pivoting-techniques/](https://highon.coffee/blog/ssh-meterpreter-pivoting-techniques/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他端口转发的方法；例如，使用proxychains将帮助您动态转发运行在不同网络子网内的服务器上的端口。一些技术可以在[https://highon.coffee/blog/ssh-meterpreter-pivoting-techniques/](https://highon.coffee/blog/ssh-meterpreter-pivoting-techniques/)找到。
- en: Privilege escalation on Windows
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows特权升级
- en: In this recipe, you will learn a few ways to get the administrator account on
    the Windows Server. There are multiple ways to get administrator rights on a Windows
    system. Let's look at a few ways in which this can be done.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习在Windows Server上获取管理员帐户的几种方法。有多种方法可以在Windows系统上获得管理员权限。让我们看看可以完成这个任务的几种方法。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Once we have meterpreter on the system, Metasploit has an inbuilt module to
    try three different methods to get admin access. First, we will see the infamous
    `getsystem` of Metasploit. To view the help, we type this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在系统上有了meterpreter，Metasploit有一个内置模块，可以尝试三种不同的方法来获得管理员访问权限。首先，我们将看到Metasploit的臭名昭著的`getsystem`。要查看帮助，我们输入：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/e92de5f2-c7e9-4472-8afb-11e88200294f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e92de5f2-c7e9-4472-8afb-11e88200294f.png)'
- en: 'To try and get admin, we type the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试获取管理员权限，我们输入以下命令：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/2e094e87-7be3-4f53-a2d8-8b35b8723e0f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e094e87-7be3-4f53-a2d8-8b35b8723e0f.png)'
- en: We can see we are now `NT AUTHORITY\SYSTEM`. Sometimes, this technique may not
    work, so we try another way to get the system on the machine. We will look at
    some ways to reconfigure Windows services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们现在是`NT AUTHORITY\SYSTEM`。有时，这种技术可能不起作用，所以我们尝试另一种方法来在机器上获取系统。我们将看一些重新配置Windows服务的方法。
- en: We will use **sc** ( known as **service configuration**) to configure Windows
    services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**sc**（也称为**服务配置**）来配置Windows服务。
- en: 'Let''s look at the `upnphost` service:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`upnphost`服务：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/fa564bc4-6c7b-405c-9bd2-8aa28218926f.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa564bc4-6c7b-405c-9bd2-8aa28218926f.png)'
- en: 'First, we upload our `netcat` binary on the system. Once that''s done, we can
    change the binary path of a running service with our binary:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的`netcat`二进制文件上传到系统上。一旦完成，我们可以使用我们的二进制文件更改正在运行的服务的二进制路径：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/b59a25ff-43c7-4173-a313-82648ff44bad.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59a25ff-43c7-4173-a313-82648ff44bad.png)'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/9ddf4f36-b113-4963-8ed5-102aed8ec42c.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ddf4f36-b113-4963-8ed5-102aed8ec42c.png)'
- en: 'We confirm whether the changes have been made:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确认更改是否已经生效：
- en: '![](img/3a822e9e-5c54-4991-9127-ac454fa66dcd.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a822e9e-5c54-4991-9127-ac454fa66dcd.png)'
- en: 'Now we need to restart the service, and once that''s done, we should have a
    back connection with admin privileges:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重新启动服务，一旦完成，我们应该有一个带有管理员权限的后向连接：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of `netcat`, we can also use the `net user add` command to add a new
    admin user to the system, among other things.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`net user add`命令来添加一个新的管理员用户到系统中，而不是使用`netcat`等其他方法。
- en: 'Now let''s try another method: Metasploit has a lot of different local exploits
    for Windows exploitation. To view them, we type in `msfconsole` use `exploit/windows/local
    <tab>`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试另一种方法：Metasploit有许多不同的用于Windows利用的本地漏洞。要查看它们，我们输入`msfconsole`使用`exploit/windows/local
    <tab>`。
- en: '![](img/dc312fcc-7799-46e1-a741-911fb28187b1.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc312fcc-7799-46e1-a741-911fb28187b1.png)'
- en: 'We will use `kitrap0d` to exploit. Use `exploit/windows/local/ms10_015_kitrap0d`.
    We set our meterpreter session and payload:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`kitrap0d`进行利用。使用`exploit/windows/local/ms10_015_kitrap0d`。我们设置我们的meterpreter会话和有效载荷：
- en: '![](img/8e3e7c94-a9ec-41e6-8a1f-96e33ded9024.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e3e7c94-a9ec-41e6-8a1f-96e33ded9024.png)'
- en: 'We then run the exploit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行利用程序：
- en: '![](img/d28ad678-55b4-4171-9343-b2217ac25924.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d28ad678-55b4-4171-9343-b2217ac25924.png)'
- en: 'We have the admin. Let''s use one more exploit: the infamous `bypassuac`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有管理员权限。让我们再使用一个利用程序：臭名昭著的`bypassuac`：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now set the session of our current meterpreter, which we have on the system:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在设置我们在系统上拥有的当前meterpreter会话：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We run and see a second meterpreter with admin privileges open for us:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行并看到第二个具有管理员权限的meterpreter已经为我们打开：
- en: '![](img/ac14da81-870b-4d29-8768-f508439e0996.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac14da81-870b-4d29-8768-f508439e0996.png)'
- en: Using PowerSploit
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PowerSploit
- en: With the launch of PowerShell, new ways to exploit Windows machine also came
    in. As described by Wikipedia, PowerShell (including Windows PowerShell and PowerShell
    Core) is a task automation and configuration management framework from Microsoft,
    consisting of a command-line shell and associated scripting language built on
    the .NET Framework.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随着PowerShell的推出，也出现了新的利用Windows机器的方法。正如维基百科所描述的，PowerShell（包括Windows PowerShell和PowerShell
    Core）是微软的任务自动化和配置管理框架，由基于.NET Framework的命令行shell和相关脚本语言组成。
- en: In this recipe, we will use PowerSploit, which is a PowerShell-based post exploitation
    framework to gain access to meterpreter on a system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用PowerSploit，这是一个基于PowerShell的后渗透框架，用于在系统上获得meterpreter访问权限。
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Following are the steps to use PowerSploit:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用PowerSploit的步骤：
- en: We will now assume a situation in which we have a Windows-based environment
    in which we have managed to gain shell access. We do not have admin rights on
    the system.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们有一个基于Windows的环境，在这个环境中我们已经成功获得了shell访问权限。我们在系统上没有管理员权限。
- en: Let's look at a cool way of getting a meterpreter without actually downloading
    a file on the system using PowerSploit. It comes inbuilt with Kali in Menu.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一种很酷的方法，使用PowerSploit在不实际下载文件到系统上的情况下获取meterpreter。它在Kali菜单中内置。
- en: '![](img/f6b724c1-e4f8-4097-916e-51b3db0773bd.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6b724c1-e4f8-4097-916e-51b3db0773bd.png)'
- en: The trick here will be to download a PowerShell script and load it into memory,
    and as it is never saved on HDD, the antivirus will not detect it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的技巧是下载一个PowerShell脚本并将其加载到内存中，因为它从未保存在硬盘上，所以杀毒软件不会检测到它。
- en: 'We first check whether PowerShell is installed by running `powershell`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查PowerShell是否已安装，运行`powershell`：
- en: '![](img/b53aad5b-05ae-465e-a69a-5f0ce4a0fed5.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53aad5b-05ae-465e-a69a-5f0ce4a0fed5.png)'
- en: 'We will use the command. Using single quotes is important; else, we may get
    a missing parenthesis error:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用这个命令。使用单引号很重要；否则，我们可能会得到一个缺少括号的错误：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/4d7c0558-ad8f-413e-b3ff-cfcea063b805.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d7c0558-ad8f-413e-b3ff-cfcea063b805.png)'
- en: 'We should not see any error. Now that our script is all set, we invoke the
    module and see help with the following command:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不应该看到任何错误。现在我们的脚本已经准备好了，我们调用模块并使用以下命令查看帮助：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/2757b763-17ef-4760-abee-66ab407f67ca.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2757b763-17ef-4760-abee-66ab407f67ca.png)'
- en: 'Now we run the module:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行该模块：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/116bd076-38a2-4350-9eca-30768454a207.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/116bd076-38a2-4350-9eca-30768454a207.png)'
- en: Before we run the preceding script, we start our handler.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行上述脚本之前，我们启动我们的处理程序。
- en: '![](img/9913d29d-37d8-420b-841c-f5dfca462aca.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9913d29d-37d8-420b-841c-f5dfca462aca.png)'
- en: We should have a meterpreter now.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该有一个meterpreter。
- en: '![](img/7fdfd3d3-ef51-4d81-ae8c-b6f921f9cdc7.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fdfd3d3-ef51-4d81-ae8c-b6f921f9cdc7.png)'
- en: Now since we have meterpreter, we can use any of the recipes mentioned earlier
    to get system rights.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了meterpreter，我们可以使用之前提到的任何方法来获取系统权限。
- en: There's more…
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: PowerSploit has lots of PowerShell modules that can be used for further exploitation,
    such as gaining privileges, bypassing antivirus, and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: PowerSploit有很多可以用于进一步利用的PowerShell模块，比如获取权限、绕过杀毒软件等等。
- en: 'We can read all about this at:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里阅读更多信息：
- en: '[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)'
- en: '[https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-powersploit-part-1-evading-antivirus-software-0165535/](https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-powersploit-part-1-evading-antivirus-software-0165535/)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-powersploit-part-1-evading-antivirus-software-0165535/](https://null-byte.wonderhowto.com/how-to/hack-like-pro-use-powersploit-part-1-evading-antivirus-software-0165535/)'
- en: Pulling plaintext passwords with mimikatz
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mimikatz提取纯文本密码
- en: Now that we have a meterpreter, we can use it to dump passwords from the memory.
    Mimikatz is a great tool for this. It tries and dumps the password from the memory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了meterpreter，我们可以使用它从内存中转储密码。Mimikatz是一个很好的工具。它尝试从内存中转储密码。
- en: 'As defined by the creator of mimikatz himself:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如mimikatz的创造者所定义的：
- en: '"It is made in C and considered as some experiments with Windows security"
    It''s now well known to extract plaintexts passwords, hash, and PIN code and kerberos
    tickets from memory. Mimikatz can also perform pass-the-hash, pass-the-ticket
    or build Golden tickets."'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: “它是用C语言制作的，并被认为是一些与Windows安全性的实验”现在已经广为人知，可以从内存中提取纯文本密码、哈希值和PIN码以及kerberos票证。Mimikatz还可以执行传递哈希、传递票证或构建Golden票证。
- en: How to do it…
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Following are the steps to use mimikatz:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用mimikatz的步骤：
- en: 'Once we have the meterpreter and system privileges, we load up mimikatz using
    this command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了meterpreter和系统权限，我们使用这个命令加载mimikatz：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/7ba7c432-17a8-4279-9f90-4cef0716354e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ba7c432-17a8-4279-9f90-4cef0716354e.png)'
- en: 'To view all the options, we type this command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看所有选项，我们输入这个命令：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now in order to retrieve passwords from the memory, we use the built-in command
    of Metasploit:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为了从内存中检索密码，我们使用Metasploit的内置命令：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/87681445-ca9e-4233-9c80-ba146c5f044b.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87681445-ca9e-4233-9c80-ba146c5f044b.png)'
- en: 'We can see that the NTLM hashes are shown on the screen. To view Kerberos credentials,
    we type this:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到NTLM哈希值显示在屏幕上。要查看Kerberos凭据，我们输入这个：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](img/d70e780e-2227-4730-957c-cfaaf24b1324.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d70e780e-2227-4730-957c-cfaaf24b1324.png)'
- en: If there were any credentials, they would have been shown here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何凭据，它们将在这里显示。
- en: Dumping other saved passwords from the machine
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从机器中转储其他保存的密码
- en: You have already learned about dumping and saving plaintext passwords from the
    memory. However, sometimes, not all passwords are dumped. Not to worry; Metasploit
    has other post-exploitation modules, using which we can gather saved passwords
    of different applications and services running on the server we compromised.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何从内存中转储和保存纯文本密码。然而，有时并非所有密码都被转储。不用担心；Metasploit有其他后期利用模块，我们可以使用这些模块来收集在我们入侵的服务器上运行的不同应用程序和服务的保存密码。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, let''s check what applications are running on the machine. We use this
    command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查一下机器上正在运行的应用程序。我们使用这个命令：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/ff6942b5-241e-46c5-917e-fe396078b127.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff6942b5-241e-46c5-917e-fe396078b127.png)'
- en: 'We see the options; now all we need is our session, using the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了选项；现在我们只需要我们的会话，使用以下命令：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run it and we will see the list of applications installed on the system:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，我们将看到系统上安装的应用程序列表：
- en: '![](img/234124c9-8966-4486-8fa9-a031062c78c6.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/234124c9-8966-4486-8fa9-a031062c78c6.png)'
- en: Now that we know what applications are running, let's try to collect more information.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了正在运行的应用程序，让我们试着收集更多信息。
- en: We will use use `post/windows/gather/enum_chrome`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`post/windows/gather/enum_chrome`。
- en: 'It will gather all the browsing history, saved passwords, bookmarks, and so
    on. Again, we set our session and run this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它将收集所有的浏览历史、保存的密码、书签等。再次，我们设置我们的会话并运行这个：
- en: '![](img/2f4b85ab-ab5b-42e7-8600-578df6489795.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f4b85ab-ab5b-42e7-8600-578df6489795.png)'
- en: 'We will see that all the gathered data has been saved in a txt:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到所有收集到的数据都已保存在一个txt文件中：
- en: '![](img/7c057e89-cc1e-42ac-a26a-f9b8b7fad9e4.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c057e89-cc1e-42ac-a26a-f9b8b7fad9e4.png)'
- en: 'Now we will try to gather the stored configuration and credentials of the FileZilla
    server (the FTP server that can be used to transfer files) that is installed on
    the machine. We will use the module:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试收集安装在机器上的FileZilla服务器（可用于传输文件的FTP服务器）的存储配置和凭据。我们将使用该模块：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/aff3af56-4a31-4124-9421-b5564b25a1a5.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aff3af56-4a31-4124-9421-b5564b25a1a5.png)'
- en: 'We set the session and run it, and we should see the saved credentials:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置会话并运行它，然后我们应该看到保存的凭据：
- en: '![](img/ef4538d4-e0d0-4caf-bd74-dee2e44610f5.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef4538d4-e0d0-4caf-bd74-dee2e44610f5.png)'
- en: 'Let''s use another post-exploitation module to dump the database passwords.
    We will use this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用另一个后渗透模块来转储数据库密码。我们将使用这个：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](img/a8b33af3-02bd-47b5-a2d7-b2afbb83d4f5.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8b33af3-02bd-47b5-a2d7-b2afbb83d4f5.png)'
- en: 'We set the session and run this using `run -j`. We will see the credentials
    on the screen:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置会话并使用`run -j`运行此命令。我们将在屏幕上看到凭据：
- en: '![](img/373ecab6-9bf2-41ae-ab91-97b88b5d5d5e.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/373ecab6-9bf2-41ae-ab91-97b88b5d5d5e.png)'
- en: Pivoting into the network
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入网络枢纽
- en: Once we have complete control over a computer in the system, our next step should
    be to pivot into the network and try exploiting and getting access to as many
    machines as possible. In this recipe, you will learn the easy way to do that with
    Metasploit.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完全控制了系统中的一台计算机，我们的下一步应该是进入网络并尝试利用和访问尽可能多的机器。在这个示例中，您将学习使用Metasploit轻松实现这一点的方法。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Metasploit has an inbuilt meterpreter script, that allows us to add a route
    and enables us to attack other machines in the network using the current one.
    The concept is really simple; all we have to do is execute this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit有一个内置的meterpreter脚本，允许我们添加路由并使我们能够使用当前机器攻击网络中的其他机器。这个概念非常简单；我们所要做的就是执行这个命令：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](img/bc51fae7-726a-4ce6-8e27-ef366d72e28b.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc51fae7-726a-4ce6-8e27-ef366d72e28b.png)'
- en: Once this is done, we can simply exploit the machines using the same methods
    that we covered in the previous recipes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以简单地利用与我们在之前示例中介绍的相同方法来攻击机器。
- en: Backdooring for persistence
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性的后门
- en: An important part of successful exploitation is to be able to keep access to
    the compromised machine. In this recipe, you will learn about an amazing tool
    known as the Backdoor Factory. The main goal of Backdoor Factory is to patch Windows/Linux
    binaries with our shell code so that the executable runs normally, along with
    executing our shell code every time it executes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 成功利用的一个重要部分是能够保持对受损机器的访问。在这个示例中，您将了解一个称为后门工厂的神奇工具。后门工厂的主要目标是使用我们的shell代码修补Windows/Linux二进制文件，以便可执行文件正常运行，并在每次执行时执行我们的shell代码。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Backdoor Factory comes installed with Kali. And it can be run using `backdoor-factory`.
    To view all the features of this tool, we will use the help command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Backdoor Factory已经安装在Kali中。可以使用`backdoor-factory`来运行。要查看此工具的所有功能，我们将使用帮助命令：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/f2bb2db5-4ffb-4402-a66b-ee117982ed5a.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2bb2db5-4ffb-4402-a66b-ee117982ed5a.png)'
- en: Usage of this tool is not too hard; however, it is recommended that the binaries
    be tested before being deployed on the target system.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具并不太难；但是，建议在部署到目标系统之前对二进制文件进行测试。
- en: 'To view what options are available for a particular binary we choose to backdoor,
    we use the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看要对其进行后门处理的特定二进制文件的可用选项，我们使用以下命令：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will then use `iat_reverse_tcp_stager_threaded`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用`iat_reverse_tcp_stager_threaded`：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/a65a4970-36ad-4ef9-b3b5-61f1cfb336c9.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a65a4970-36ad-4ef9-b3b5-61f1cfb336c9.png)'
- en: 'Next, we choose the cave we want to use for injecting our payload:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择要用于注入有效载荷的洞穴：
- en: '![](img/a944b432-52de-461f-95fb-32b4f38b2a4c.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a944b432-52de-461f-95fb-32b4f38b2a4c.png)'
- en: Our binary has been created and is ready to be deployed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的二进制文件已经创建并准备部署。
- en: 'Now all we need to do is to run a handler that will accept the reverse connection
    from our payload:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是运行一个处理程序，它将接受来自我们有效载荷的反向连接：
- en: '![](img/d3b2866d-9401-481b-b5ab-72826746f7f8.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3b2866d-9401-481b-b5ab-72826746f7f8.png)'
- en: 'Now when the `.exe` is executed on the victim machine, we will have our meterpreter
    connected:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当在受害者机器上执行`.exe`时，我们将连接到我们的meterpreter：
- en: '![](img/3a28c4ee-e63c-4c2b-bd73-875bad8e59bf.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a28c4ee-e63c-4c2b-bd73-875bad8e59bf.png)'
