- en: '*Chapter 12*: Analyzing Processor Modules'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：分析处理器模块'
- en: In this chapter, we will address how to incorporate new processor modules in
    Ghidra. This is an advanced topic that involves learning the **Specification Language
    for Encoding and Decoding for Ghidra** (**SLEIGH**) so that we can specify the
    language, disassembling the code, performing function identification via prologue
    and epilogue byte pattern matching, stack frame creation, and function cross-references
    generation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何在 Ghidra 中集成新的处理器模块。这是一个涉及学习**Ghidra 编码和解码规范语言**（**SLEIGH**）的高级主题，以便我们可以指定语言、反汇编代码、通过序言和尾声字节模式匹配执行函数识别、创建堆栈帧以及生成函数交叉引用。
- en: During this chapter, you will acquire extremely useful skills for breaking down
    advanced reverse engineering protections. You will do this by implementing a virtual
    machine so that the adversary (you) will have to apply reverse engineering to
    the virtual machine before reverse engineering the original binary. There are
    several examples of malware (such as ZeusVM, KINS, and so on) and powerful software
    protection that's mostly based on virtualization (such as VMProtect, Denuvo, and
    more).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习到分解高级逆向工程保护所需的极其有用的技能。您将通过实现一个虚拟机来实现这一点，以便对手（即您）在逆向工程原始二进制文件之前必须先对虚拟机应用逆向工程。本章涉及多个恶意软件示例（例如
    ZeusVM、KINS 等）和基于虚拟化的强大软件保护（例如 VMProtect、Denuvo 等）。
- en: SLEIGH and SLED
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**SLEIGH** 和 **SLED**'
- en: 'SLEIGH, the Ghidra processor specification language, has its origins in the
    **Specification Language for Encoding and Decoding** (**SLED**), which describes
    abstract, binary, and assembly language representations of machine instructions.
    If you want to learn more about SLEIGH, which is a broad topic, check out the
    following link: [https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html).
    If you want to learn more about SLED, check out the following link: [https://www.cs.tufts.edu/~nr/pubs/specifying.html](https://www.cs.tufts.edu/~nr/pubs/specifying.html).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**SLEIGH**，Ghidra 处理器规范语言，其起源于**编码和解码规范语言**（**SLED**），描述了机器指令的抽象、二进制和汇编语言表示。如果您想了解更多关于
    SLEIGH 的内容，这是一个广泛的主题，请查看以下链接：[https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html)。如果您想了解更多关于
    SLED 的内容，请查看以下链接：[https://www.cs.tufts.edu/~nr/pubs/specifying.html](https://www.cs.tufts.edu/~nr/pubs/specifying.html)。'
- en: We will start by providing an overview of the extensive list of existing Ghidra
    processor modules and how they are used by Ghidra. Finally, we will analyze the
    **x86 processor module** from a Ghidra developer perspective. The loader under
    analysis is responsible for enabling Ghidra so that we can understand its x86
    architecture and variants (for example, 16-bit real mode). As we did in the previous
    chapter, we will look at a real-world example to help us with this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先概述现有的广泛的 Ghidra 处理器模块列表及其在 Ghidra 中的使用方式。最后，我们将从 Ghidra 开发者的角度分析**x86 处理器模块**。正在分析的加载程序负责启用
    Ghidra，以便我们可以理解其 x86 架构及其变体（例如，16 位实模式）。与前一章节一样，我们将查看一个真实世界的例子来帮助我们理解。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the existing Ghidra processor modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现有的 Ghidra 处理器模块
- en: The Ghidra processor module skeleton
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghidra 处理器模块的框架
- en: Developing Ghidra processors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Ghidra 处理器
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: 'Java JDK 11 for x86_64 (available here): [https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot](https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java JDK 11（适用于 x86_64，可在此处获取）：[https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot](https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot)
- en: 'Eclipse IDE for Java developers (any version supporting JDK 11 available here:
    [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)) since
    it is the IDE that''s officially integrated and supported by Ghidra.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Java 开发者的 Eclipse IDE（任何支持 JDK 11 的版本都可在此处获取：[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)），因为它是
    Ghidra 官方集成和支持的 IDE。
- en: This book's GitHub repository, which contains all the necessary code for this
    chapter ([https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的 GitHub 仓库，包含了本章所需的所有代码（[https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter12)）。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2VQjNFt](https://bit.ly/2VQjNFt)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/2VQjNFt](https://bit.ly/2VQjNFt)
- en: Understanding the existing Ghidra processor modules
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解现有的 Ghidra 处理器模块
- en: 'In this section, we will provide an overview of Ghidra''s processor modules
    from a user perspective. Ghidra provides support for a lot of processor architectures.
    You can find a list of supported architectures by listing the directories included
    in the `Ghidra/Processors/` directory of both the Ghidra distribution and Ghidra''s
    GitHub repository (https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors),
    as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将从用户的角度提供 Ghidra 处理器模块的概述。Ghidra 支持许多处理器架构。您可以通过列出 `Ghidra/Processors/` 目录中包含的目录，来查看支持的架构列表，该目录位于
    Ghidra 的发行版和 Ghidra 的 GitHub 仓库（https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Processors）中，如下图所示：
- en: '![Figure 12.1 – Listing Ghidra''s processor modules (partial list)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 列出 Ghidra 的处理器模块（部分列表）'
- en: '](img/B16207_12_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_001.jpg)'
- en: Figure 12.1 – Listing Ghidra's processor modules (partial list)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 列出 Ghidra 的处理器模块（部分列表）
- en: At the time of writing this book, Ghidra supports the following list of processors:`6502`,
    `68000`, `6805`, `8048`, `8051`, `8085`, `AARCH64`, `ARM`, `Atmel`, `CP1600`,
    `CR16`, `DATA`, `Dalvik`, `HCS08`, `HCS12`, `JVM`, `M8C`, `MCS96`, `MIPS`, `PA-RISC`,
    `PIC`, `PowerPC`, `RISCV`, `Sparc`, `SuperH`, `SuperH4`, `TI_MSP430`, `Toy`, `V850`,
    `Z80`, `tricore`, and `x86`.If we compare this list with IDA Professional Edition
    processor support, we'll notice that IDA supports more processors, even though
    it doesn't provide Ghidra support. But if we compare Ghidra with IDA Home Edition,
    then we'll notice that Ghidra supports more architectures, including very common
    architectures such as Dalvik (the discontinued virtual machine used by Android)
    and **Java Virtual Machine** (**JVM**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Ghidra 支持以下处理器列表：`6502`、`68000`、`6805`、`8048`、`8051`、`8085`、`AARCH64`、`ARM`、`Atmel`、`CP1600`、`CR16`、`DATA`、`Dalvik`、`HCS08`、`HCS12`、`JVM`、`M8C`、`MCS96`、`MIPS`、`PA-RISC`、`PIC`、`PowerPC`、`RISCV`、`Sparc`、`SuperH`、`SuperH4`、`TI_MSP430`、`Toy`、`V850`、`Z80`、`tricore`
    和 `x86`。如果我们将这个列表与 IDA 专业版的处理器支持进行比较，我们会发现 IDA 支持更多的处理器，尽管它没有提供 Ghidra 支持。但如果将
    Ghidra 与 IDA 家庭版进行比较，我们会注意到 Ghidra 支持更多的架构，包括一些非常常见的架构，例如 Dalvik（Android 使用的已停用虚拟机）和
    **Java 虚拟机** (**JVM**)。
- en: 'Using loading a binary for the x86 architecture as an example, you will probably
    remember from [*Chapter 11*](B16207_11_Final_SK_ePub.xhtml#_idTextAnchor194),
    *Incorporating New Binary Formats*, that, when loading a file, you can choose
    what language it will appear in by clicking on the ellipses button (**…**) next
    to **Language**, as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以加载 x86 架构的二进制文件为例，您可能还记得 [*第 11 章*](B16207_11_Final_SK_ePub.xhtml#_idTextAnchor194)，*融合新的二进制格式*，当加载文件时，您可以通过点击**语言**旁边的省略号按钮
    (**…**)，来选择文件的显示语言，如下图所示：
- en: '![Figure 12.2 – Default language variant when importing a PE file'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 导入 PE 文件时的默认语言变体'
- en: '](img/B16207_12_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_002.jpg)'
- en: Figure 12.2 – Default language variant when importing a PE file
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 导入 PE 文件时的默认语言变体
- en: 'Once I''d done this, I unchecked **Show Only Recommended Language/Compiler
    Specs** to show all the languages and compilers that are available. By doing this,
    I can see that the x86 processor module implements eight variants:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个后，我取消选中了**仅显示推荐的语言/编译器规格**，以便显示所有可用的语言和编译器。通过这样做，我可以看到 x86 处理器模块实现了八个变体：
- en: '![Figure 12.3 – Choosing the appropriate language variant when importing a
    file'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – 导入文件时选择适当的语言变体'
- en: '](img/B16207_12_003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_003.jpg)'
- en: Figure 12.3 – Choosing the appropriate language variant when importing a file
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 导入文件时选择适当的语言变体
- en: Let's analyze the structure of a processor module to understand how these variants
    are relevant to the `tree` command to provide an overview of the directory structure
    of the x86 processor and analyzer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析处理器模块的结构，以了解这些变体如何与 `tree` 命令相关，以提供 x86 处理器和分析器的目录结构概览。
- en: 'The `data` directory contains the x86 processor module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 目录包含了 x86 处理器模块：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, there are three children folders implementing it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有三个子文件夹在实现它：
- en: '`languages`: This is responsible for implementing the x86 processor using different
    kinds of files, all of which will be explained later (`*.sinc`, `*.pspec`, `*.gdis`,
    `*.dwarf`, `*.opinion`, `*.slaspec`, `*.spec`, and `*.ldefs`).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`languages`：这个负责使用不同类型的文件实现 x86 处理器，所有这些文件稍后都会解释 (`*.sinc`, `*.pspec`, `*.gdis`,
    `*.dwarf`, `*.opinion`, `*.slaspec`, `*.spec`, 和 `*.ldefs`)。'
- en: '`manuals`: The processor''s manual documentation is stored here using the `*.idx`
    Ghidra format. This indexes the original PDF''s information, thus allowing you
    to query the documentation.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manuals`：处理器的手册文档存储在这里，使用 `*.idx` Ghidra 格式。这个索引了原始 PDF 的信息，因此允许你查询文档。'
- en: '`patterns`: Byte patterns are stored in XML files and used to determine whether
    the importing file was developed for the x86 architecture.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patterns`：字节模式存储在 XML 文件中，用于确定导入文件是否是为 x86 架构开发的。'
- en: 'The `src` directory contains the x86 analyzer. You probably remember analyzer
    extensions from the *The Ghidra Extension Module Skeleton* section of [*Chapter
    4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)*, Using Ghidra Extensions*.
    These kinds of extensions allow us to extend Ghidra''s code analysis functionality:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 目录包含了 x86 分析器。你可能还记得分析器扩展是从 *The Ghidra Extension Module Skeleton* 章节中的
    [*第 4 章*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)*，使用 Ghidra 扩展* 中介绍的。这些扩展允许我们扩展
    Ghidra 的代码分析功能：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The main file of the analyzer extension is the `X86Analyzer` Java class file
    (full path: `Ghidra\Processors\x86\src\main\java\ghidra\app\plugin\core\analysis\X86Analyzer.java`).
    This class extends from `ConstantPropagationAnalyzer` (full path: `Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java`),
    which itself extends from `AbstractAnalyzer` (the class you must directly or indirectly
    extend from when writing analyzer extensions).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器扩展的主文件是 `X86Analyzer` Java 类文件（完整路径：`Ghidra\Processors\x86\src\main\java\ghidra\app\plugin\core\analysis\X86Analyzer.java`）。这个类扩展自
    `ConstantPropagationAnalyzer`（完整路径：`Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/ConstantPropagationAnalyzer.java`），它本身扩展自
    `AbstractAnalyzer`（在编写分析器扩展时必须直接或间接扩展的类）。
- en: In this section, you learned about existing processors and analyzers and how
    their source code is structured. In the next section, we will explore how to create
    a new processor module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你了解了现有处理器和分析器以及它们的源代码结构。在下一部分中，我们将探讨如何创建一个新的处理器模块。
- en: Overviewing the Ghidra processor module skeleton
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 Ghidra 处理器模块的框架
- en: In this section, we will look at the Ghidra processor module skeleton. This
    skeleton will be a little bit different because processor modules are not written
    in Java. Instead, the processor modules are written in SLEIGH, which is the Ghidra
    processor specification language.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下 Ghidra 处理器模块的框架。这个框架会有一点不同，因为处理器模块不是用 Java 编写的。相反，处理器模块是用 SLEIGH
    编写的，这是 Ghidra 处理器规范语言。
- en: Setting up the processor module development environment
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置处理器模块开发环境
- en: 'Before you can create a new processor module, you will need to set up an environment:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的处理器模块之前，你需要设置一个环境：
- en: Install the Java JDK for x86_64, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing Java JDK* section.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 x86_64 的 Java JDK，如 [*第 3 章*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041)
    中所述，*Ghidra 调试模式*，在 *安装 Java JDK* 部分。
- en: Install the Eclipse IDE for Java developers, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing Eclipse IDE* section.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Java 开发人员的 Eclipse IDE，如 [*第 3 章*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041)
    中所述，*Ghidra 调试模式*，在 *安装 Eclipse IDE* 部分。
- en: Install the `GhidraDev` plugin for Eclipse, as explained in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*, in the *Installing GhidraDev* section.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `GhidraDev` 插件到 Eclipse，如 [*第 3 章*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041)
    中所述，*Ghidra 调试模式*，在 *安装 GhidraDev* 部分。
- en: Additionally, in the same way you installed `GhidraDev`, since you will need
    to work with SLEIGH to develop the processor's specifications, it is highly recommended
    that you also install `GhidraSleighEditor`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，与安装`GhidraDev`的方式相同，因为你需要使用 SLEIGH 来开发处理器的规格，强烈建议你也安装`GhidraSleighEditor`。
- en: 'The `GhidraSleighEditor` installation process is the same as for `GhidraDev`
    since both are Eclipse plugins. It is a ZIP file that can be installed from the
    Eclipse IDE, and both the straightforward installation guide (`GhidraSleighEditor_README.html`)
    and the plugin installer (`GhidraSleighEditor-1.0.0.zip`) are available in the
    `Extensions\Eclipse\GhidraSleighEditor` directory of your Ghidra installation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`GhidraSleighEditor`的安装过程与`GhidraDev`相同，因为两者都是 Eclipse 插件。它是一个可以从 Eclipse IDE
    安装的 ZIP 文件，你可以在 Ghidra 安装的`Extensions\Eclipse\GhidraSleighEditor`目录中找到简单的安装指南（`GhidraSleighEditor_README.html`）和插件安装程序（`GhidraSleighEditor-1.0.0.zip`）：'
- en: '![Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4 – Eclipse IDE 的 GhidraSleighEditor 插件'
- en: '](img/B16207_12_004.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_004.jpg)'
- en: Figure 12.4 – GhidraSleighEditor plugin for the Eclipse IDE
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Eclipse IDE 的 GhidraSleighEditor 插件
- en: In the next section, we will learn how to create a processor module skeleton.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何创建处理器模块骨架。
- en: Creating a processor module skeleton
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建处理器模块骨架
- en: 'As you probably remember from [*Chapter 4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063),
    *Using Ghidra Extensions*, to create a processor module, you must click on `ProcessorModuleProject`,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得的[*第 4 章*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)，*使用 Ghidra
    扩展*，要创建处理器模块，你必须点击`ProcessorModuleProject`，如下面的截图所示：
- en: '![Figure 12.5 – Creating a Ghidra project'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – 创建 Ghidra 项目'
- en: '](img/B16207_12_005.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_005.jpg)'
- en: Figure 12.5 – Creating a Ghidra project
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 创建 Ghidra 项目
- en: 'After clicking on **Next >**, only check the last option – **Processor – Enables
    disassembly/decompilation of a processor/architecture** – in order to create a
    processor module skeleton:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步 >**后，只需勾选最后一个选项 – **处理器 – 启用处理器/架构的反汇编/反编译** – 以创建处理器模块骨架：
- en: '![Figure 12.6 – Configuring the Ghidra project so that it includes the processor
    module skeleton'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 配置 Ghidra 项目以包含处理器模块骨架'
- en: '](img/B16207_12_006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_006.jpg)'
- en: Figure 12.6 – Configuring the Ghidra project so that it includes the processor
    module skeleton
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 配置 Ghidra 项目以包含处理器模块骨架
- en: 'After clicking on **Finish**, you will see the processor skeleton in the **Package
    Explorer** section of Eclipse:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**完成**后，你将在 Eclipse 的**包资源管理器**部分看到处理器骨架：
- en: '![Figure 12.7 – The processor module skeleton'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 处理器模块骨架'
- en: '](img/B16207_12_007.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_007.jpg)'
- en: Figure 12.7 – The processor module skeleton
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 处理器模块骨架
- en: 'All the files that compose the skeleton are stored in the `data\languages`
    directory. Since each file has its own specification goal, let''s look at them
    in more detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 组成骨架的所有文件都存储在`data\languages`目录中。由于每个文件都有自己的规格目标，让我们更详细地看一下它们：
- en: '`skel.cspec`: As its name suggests, this is a compiler specification file.
    It allows us to encode information that is specific to the compiler that''s necessary
    when dissembling and analyzing a binary. You can find out more by going to [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.cspec`：顾名思义，这是一个编译器规格文件。它允许我们编码特定于编译器的信息，在反汇编和分析二进制文件时是必要的。你可以通过访问[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/main/doc/cspec.xml)了解更多信息。'
- en: '`skel.ldefs`: According to the extension, this is the definition of the processor
    language.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.ldefs`：根据扩展名，这是处理器语言的定义。'
- en: '`skel.opinion`: As you probably remember from the previous chapter, opinion
    files contain constraints that allow us to determine whether the file can be loaded
    or not by the importer. You can find out more by going to [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.opinion`: 正如你可能还记得上一章所述，意见文件包含约束条件，允许我们确定导入器是否可以加载文件。您可以通过访问[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt)了解更多信息。'
- en: '`skel.pspec`: As its name suggests, this file is a processor specification
    file.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.pspec`: 正如其名称所示，这个文件是一个处理器规范文件。'
- en: '`skel.sinc`: As its name suggests, this is a SLEIGH file that specifies the
    language instructions of a processor (for example, the `mov` assembly language
    instruction if x86 must be defined here).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.sinc`: 正如其名称所示，这是一个指定处理器语言指令的 SLEIGH 文件（例如，如果要定义 x86 的`mov`汇编语言指令，必须在此处定义）。'
- en: '`skel.slaspec`: This is the SLEIGH language specification and allows us to
    specify the processor (for example, registers, flags, and so on).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skel.slaspec`: 这是 SLEIGH 语言规范，允许我们指定处理器（例如，寄存器、标志等）。'
- en: As we mentioned previously, SLEIGH is a broad topic, so if you want to learn
    more, please read the documentation available in your Ghidra distribution (`docs\languages\html\sleigh.html`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，SLEIGH 是一个广泛的主题，所以如果您想了解更多，请阅读您的 Ghidra 发行版中提供的文档（`docs\languages\html\sleigh.html`）。
- en: 'Now that you have installed the SLEIGH editor, you can edit all the aforementioned
    files by right-clicking the target file, choosing **Open With** | **Other…**,
    and then choosing **Sleigh Editor**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了 SLEIGH 编辑器，您可以通过右键单击目标文件，选择**打开方式** | **其他…**，然后选择**Sleigh 编辑器**来编辑所有上述文件：
- en: '![Figure 12.8 – Opening a file in Eclipse using the Other… editor'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 在 Eclipse 中使用其他编辑器打开文件'
- en: '](img/B16207_12_008.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_008.jpg)'
- en: Figure 12.8 – Opening a file in Eclipse using the Other… editor
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 在 Eclipse 中使用其他编辑器打开文件
- en: 'If you want, you can also take this as an opportunity to associate the `*.cspec`
    files by checking the **Use it for all ''*.cspec'' files** option before clicking
    **OK**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您还可以将此作为一个机会，通过在单击**确定**之前选中**用于所有'*.cspec'文件**选项来关联`*.cspec`文件：
- en: '![Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 – 选择 Sleigh 编辑器在 Eclipse 中打开文件'
- en: '](img/B16207_12_009.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_009.jpg)'
- en: Figure 12.9 – Choosing Sleigh Editor for opening a file in Eclipse
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 选择 Sleigh 编辑器在 Eclipse 中打开文件
- en: 'Choose **No** when you''re asked to convert the project into an Xtext project.
    Also, take this opportunity to make your computer remember this decision by checking
    the **Remember my decision** checkbox, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您被要求将项目转换为 Xtext 项目时，请选择**否**。同时，通过选中**记住我的决定**复选框，使计算机记住这个决定，如下截图所示：
- en: '![Figure 12.10 – Converting the project into an Xtext project dialog'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 – 将项目转换为 Xtext 项目对话框'
- en: '](img/B16207_12_010.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_010.jpg)'
- en: Figure 12.10 – Converting the project into an Xtext project dialog
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 将项目转换为 Xtext 项目对话框
- en: We started this section by providing an overview of an existing processor module
    (x86 processor) and analyzing it from a Ghidra user perspective. You superficially
    explored the code files that comprise it in order to understand the big picture
    of processor modules. After that, you learned how to set up a processor module
    development environment and a processor module skeleton so that you can start
    developing a new one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提供现有处理器模块（x86 处理器）的概述并从 Ghidra 用户的角度进行分析来开始本节。您浅显地探索了组成它的代码文件，以便理解处理器模块的整体情况。之后，您学会了如何设置处理器模块开发环境和处理器模块骨架，以便开始开发新的处理器模块。
- en: In the next section, we will explore how the x86 processor we looked at in the
    first section of this chapter, *Existing processor modules*, was implemented to
    zoom into the details of its implementation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨第一节中查看的 x86 处理器是如何实现的，*现有处理器模块*，以便深入了解其实现细节。
- en: Developing Ghidra processors
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Ghidra 处理器
- en: 'As you know, Ghidra processor module development involves many different files
    that are located in the `data` directory of the module. These files are listed
    in the manifest ([https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest)):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Ghidra处理器模块的开发涉及许多不同的文件，这些文件位于模块的`data`目录中。这些文件在清单中列出（[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/certification.manifest)）：
- en: '![Figure 12.11 – Partial dump of certification.manifest'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11 – certification.manifest的部分内容转储'
- en: '](img/B16207_12_011.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_12_011.jpg)'
- en: Figure 12.11 – Partial dump of certification.manifest
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – certification.manifest的部分内容转储
- en: In the next section, we will look at Ghidra's processor documentation files
    and their relationship to the official processor documentation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看Ghidra的处理器文档文件及其与官方处理器文档的关系。
- en: Documenting processors
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器文档
- en: 'The `manuals` directory of the x86 processor stores the `x86.idx` file ([https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx)),
    which contains an indexed version of the official instruction set reference for
    such an architecture ([https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf](https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf)).
    This indexed version allows Ghidra to access such information when retrieving
    instruction information from Ghidra''s GUI during reversing. The following code
    snippet is of a few lines that can be found at the beginning of the `x86.idx`
    file. They relate to processor instructions and their documentation pages (for
    example, line `01` relates to the `AAA` processor instruction, which can be found
    on page `120` of the official documentation):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: x86处理器的`manuals`目录存储着`x86.idx`文件（[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/manuals/x86.idx)），该文件包含了该架构的官方指令集参考的索引版本（[https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf](https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf)）。这个索引版本使得Ghidra在逆向过程中从Ghidra的图形用户界面中检索指令信息时能够访问这些信息。以下代码片段是`x86.idx`文件开头的一些行。它们与处理器指令及其文档页有关（例如，`01`行与`AAA`处理器指令相关，这可以在官方文档的`120`页找到）：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next section, we will learn how to write signatures so that Ghidra can
    identify functions and code snippets for this architecture.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何编写签名，以便Ghidra能够识别此架构的函数和代码片段。
- en: Identifying functions and code using patterns
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模式识别函数和代码
- en: 'There is also a `patterns` directory where patterns specified in XML language
    are used for function and code identification. The directory does this by taking
    different compilers into account. The format of a file of patterns (for example,
    [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml))
    is an XML file that starts and ends with the `patternlist` tag:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`patterns`目录，在该目录中，使用XML语言指定的模式用于函数和代码的识别。该目录通过考虑不同的编译器来实现这一点。模式文件的格式（例如，[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/patterns/x86gcc_patterns.xml)）是一个以`patternlist`标签开始和结束的XML文件：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can add patterns that allow the analyzer to identify functions and code.
    In the following example, which has been taken from the x86 GCC patterns file
    (`x86gcc_patterns.xml`), we can see that a pattern was included using the `pattern`
    tag. The pattern itself is written as a hexadecimal byte representation. To aid
    in your understanding of this, a comment has been added to the right of this,
    indicating what those bytes mean (in this case, this is the prologue of a function).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加模式，允许分析器识别函数和代码。在以下示例中，来自x86 GCC模式文件（`x86gcc_patterns.xml`），我们可以看到一个使用`pattern`标签的模式。该模式本身以十六进制字节表示。为了帮助你理解，右侧添加了一个注释，指示这些字节的含义（在这种情况下，这是一个函数的前奏）。
- en: 'After the `data` section, we have two tags: `codeboundary` and `possiblefuncstart`.
    The position of these tags is important because, since they are located after
    the `data` section, the meanings of `codeboundary` and `possiblefuncstart` must
    be understood from the pattern indicated in the `data` section onward. `codeboundary`
    indicates that the code starts or ends (it is a boundary), while `possiblefuncstart`
    indicates that the bytes matching the pattern may be at the start of a function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `data` 部分之后，我们有两个标签：`codeboundary` 和 `possiblefuncstart`。这些标签的位置很重要，因为它们位于
    `data` 部分之后，`codeboundary` 和 `possiblefuncstart` 的含义必须从 `data` 部分指示的模式开始理解。`codeboundary`
    表示代码的开始或结束（它是一个边界），而 `possiblefuncstart` 表示匹配模式的字节可能位于函数的开头：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also use `patternpairs` to define two patterns that are usually found
    together, one preceding the other. These patterns are called `prepatterns` and
    `postpatterns`, respectively. For instance, it is quite common for the end of
    a function (`prepattern`, specified on line `03`) to precede the start of another
    function (`postpattern`, specified on line `09`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `patternpairs` 来定义通常一起出现的两个模式，一个在另一个之前。这些模式分别称为 `prepatterns` 和 `postpatterns`。例如，函数结束时的模式（在第
    `03` 行指定的 `prepattern`）通常在另一个函数的开始之前（在第 `09` 行指定的 `postpattern`）：
- en: '[PRE51]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the next section, we will learn how to specify the assembly language for
    such a processor using **Debugging With Attributed Record Formats** (**DWARF**).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何为这样一个处理器指定汇编语言，使用**带有属性记录格式的调试**（**DWARF**）。
- en: Specifying the language and its variants
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定语言及其变体
- en: Inside the `languages` directory, we have a bunch of files with different names
    (every name implements a variant of the language) and different extensions (every
    extension if responsible for specifying the language at hand). Let's analyze the
    x86 files that implement the x86 variant of the processor (there are other variants
    as well, such as x86-64 and x86-16).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `languages` 目录中，我们有许多不同名称的文件（每个名称实现语言的一个变体）和不同的扩展名（每个扩展名负责指定当前语言）。让我们分析实现处理器
    x86 变体的 x86 文件（还有其他变体，如 x86-64 和 x86-16）。
- en: x86.dwarf
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86.dwarf
- en: 'This file describes the registers of the architecture using mappings between
    Ghidra names and DWARF register numberings. DWARF is a standardized debugging
    data format. DWARF mappings are described by the **Application Binary Interface**
    (**ABI**) of the architecture (available here: [https://www.uclibc.org/docs/psABI-i386.pdf](https://www.uclibc.org/docs/psABI-i386.pdf)).
    The Ghidra DWARF file looks as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件描述了使用 Ghidra 名称和 DWARF 寄存器编号之间的映射来描述架构的寄存器。DWARF 是一种标准化的调试数据格式。DWARF 映射由架构的**应用二进制接口**（**ABI**）描述（可在此处找到：[https://www.uclibc.org/docs/psABI-i386.pdf](https://www.uclibc.org/docs/psABI-i386.pdf)）。Ghidra
    DWARF 文件如下所示：
- en: '[PRE65]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Of course, apart from matching the Ghidra register names with DWARF numbers,
    attributes are also used to specify the ESP register''s purpose in the x86 architecture
    as a stack pointer (the `stackpointer` attribute):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了将 Ghidra 寄存器名称与 DWARF 编号匹配之外，属性还用于指定 x86 架构中 ESP 寄存器作为堆栈指针的用途（`stackpointer`
    属性）：
- en: '[PRE71]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Attributes can also be used to abbreviate code. For instance, they can be used
    to declare eight registers at a time. Registers `XMM0` to `XMM7` are declared
    using a single line of code via the `auto_count` attribute:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以用来缩写代码。例如，它们可以用来一次性声明八个寄存器。通过 `auto_count` 属性，可以使用一行代码声明寄存器 `XMM0` 到 `XMM7`：
- en: '[PRE72]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This XML consists of mapping registers. In the next section, we will learn how
    to define the x86 processor language.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 XML 包含了映射寄存器。在下一节中，我们将学习如何定义 x86 处理器语言。
- en: DWARF Debugging Format
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DWARF 调试格式
- en: 'If you want to learn more about DWARF, go to the official website: [http://dwarfstd.org/](http://dwarfstd.org/).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 DWARF 的信息，请访问官方网站：[http://dwarfstd.org/](http://dwarfstd.org/)。
- en: x86.ldefs
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86.ldefs
- en: This file defines the x86 processor language and its variants. All languages
    are specified inside `language_definitions` tags (lines `00` and `19`). For instance,
    the default variant of the x86 language (line `04`) that corresponds to the x86
    architecture (line `01`) for 32-bit machines (line `03`) using little endian (line
    `02`) and shown to the user as `x86:LE:32:default` (line `09`) is fully specified
    between lines `01` and `18` (the language tags). Its specification can also include
    the name of the processor variant in external tools (lines `12`-`16`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了x86处理器语言及其变种。所有语言都在`language_definitions`标签内指定（`00`和`19`行）。例如，x86语言的默认变种（`04`行）对应于x86架构（`01`行）用于32位机器（`03`行）并采用小端模式（`02`行），对用户显示为`x86:LE:32:default`（`09`行），其定义在`01`到`18`行（语言标签）之间。它的规范还可以包括外部工具中处理器变种的名称（`12`到`16`行）。
- en: 'It also references some external files: `x86.sla` (SLEIGH language specification
    file) on line `06`), `x86.pspec` (processor specification file) on line `07`,
    `x86.idx` (x86 architecture indexed manual) on line `08`, and `x86.dwarf` (DWARF
    registry mapping file) on line `16`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它还引用了一些外部文件：`x86.sla`（SLEIGH语言规范文件）在`06`行，`x86.pspec`（处理器规范文件）在`07`行，`x86.idx`（x86架构索引手册）在`08`行，`x86.dwarf`（DWARF注册表映射文件）在`16`行：
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the next section, we will learn about the processor specifications that are
    relevant when importing a file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习与导入文件相关的处理器规范。
- en: x86.opinion
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86.opinion
- en: 'This file contains constraints that allow us to determine whether the file
    can be loaded by the importer. For instance, the constraints for `PE` files (line
    `01`) in the case of the `windows` compiler (line `02`) are the constraints that
    are specified between lines `03`-`10`. Each has its own primary value that can
    be queried using the `opinion` query service when you''re loading a file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含一些约束条件，允许我们确定文件是否可以被导入程序加载。例如，对于`windows`编译器（`02`行）中的`PE`文件（`01`行）的约束条件是在`03`到`10`行之间指定的。每个约束都有其主值，当你加载文件时，可以使用`opinion`查询服务来查询这些值：
- en: '[PRE94]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the next section, we will learn how to specify some necessary information
    about compilers targeting the architecture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何指定有关目标架构的编译器的必要信息。
- en: x86.pspec
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86.pspec
- en: 'The compiler specification file allows us to encode information that is specific
    to the compiler and is necessary when dissembling and analyzing a binary (for
    example, the program counter on line `08`):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器规范文件允许我们编码与编译器相关的信息，这是在反汇编和分析二进制文件时必需的（例如，`08`行上的程序计数器）：
- en: '[PRE106]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the next section, we will learn how to specify the processor architecture
    using the SLEIGH language.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用SLEIGH语言指定处理器架构。
- en: x86.slaspec
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: x86.slaspec
- en: 'The SLEIGH language specification allows us to specify the processor. In this
    case, the implementation is split into many files that are included in `x86.slapec`.
    In this case, we are interested in `ia.sinc`, which implements an x86 32-bit variant
    of this language:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: SLEIGH语言规范允许我们指定处理器。在这种情况下，实现被拆分成许多包含在`x86.slapec`中的文件。在这里，我们关注的是`ia.sinc`，它实现了此语言的x86
    32位变种：
- en: '[PRE133]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'If you want to write your own language, then you will need to learn more about
    SLEIGH (https://ghidra.re/courses/languages/html/sleigh.html). The following is
    a snippet of `ia.sinc` that allows us to implement matching between the x86 32-bit
    swap instruction and the PCode swap operation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写自己的语言，那么你需要了解更多关于SLEIGH的信息（https://ghidra.re/courses/languages/html/sleigh.html）。以下是`ia.sinc`的一个片段，它允许我们实现x86
    32位交换指令与PCode交换操作之间的匹配：
- en: '[PRE134]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: In this section, you learned how Ghidra's x86 processor module is structured
    and some of the details of its implementation. These can be useful if you're planning
    to develop your own Ghidra processor module. It is up to you if you wish to continue
    learning about SLEIGH, which is a broad and interesting topic.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了Ghidra的x86处理器模块的结构以及一些实现细节。如果你计划开发自己的Ghidra处理器模块，这些信息将非常有用。如果你愿意，继续学习SLEIGH也是一个广泛且有趣的主题。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the built-in Ghidra processors and their
    variants. You also learned what these processors look like when you're importing
    files using Ghidra.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了内置的Ghidra处理器及其变种。你还了解了使用Ghidra导入文件时这些处理器的表现。
- en: You also learned about the skills you need to use for Ghidra processor module
    development and the SLEIGH language, which is used more for specifying than programming.
    By learning about this, you learned why processor modules are special. You were
    then introduced to processor module development by getting hands-on and analyzing
    the 32-bit processor variant of the x86 architecture.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了在Ghidra处理器模块开发中需要使用的技能以及SLEIGH语言，SLEIGH语言更多的是用于指定而不是编程。通过学习这一点，你了解了处理器模块为何与众不同。随后，你通过动手实践并分析x86架构的32位处理器变体，了解了处理器模块的开发。
- en: Finally, you learned about the URL resources that you can use if you want to
    learn more about the SLEIGH specification language and write your own processor
    modules.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了如果想要进一步学习SLEIGH规范语言并编写自己的处理器模块，可以使用的URL资源。
- en: In the next chapter, we will learn how to contribute to the Ghidra project via
    collaborating and how to be part of the community.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过协作参与Ghidra项目，并成为社区的一部分。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a processor module and an analyzer module?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器模块和分析器模块有什么区别？
- en: When writing patterns, is the tag's position important?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写模式时，标签的位置重要吗？
- en: What is the difference between language and language variants?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言和语言变体有什么区别？
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Please refer to the following links to find out more about the topics that
    were covered in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下链接，了解本章中涵盖的更多内容：
- en: 'SLEIGH documentation:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLEIGH文档：
- en: '[https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html)'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://ghidra.re/courses/languages/html/sleigh.html](https://ghidra.re/courses/languages/html/sleigh.html)'
- en: 'Ghidra decompiler documentation:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghidra反编译器文档：
- en: '[https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/main/doc)'
