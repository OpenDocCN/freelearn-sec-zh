- en: '*Chapter 4*: Network Scanning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：网络扫描'
- en: 'This chapter deals with the first phase of ethical hacking: information gathering
    and reconnaissance. Information gathering is one of the most important aspects
    of ethical hacking. Without having proper access to the required information,
    it is extremely hard to carry out a successful attack. We will learn what network
    scanning is and how it can be used to carry out attacks in a network. We will
    go through the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了道德黑客的第一阶段：信息收集与侦察。信息收集是道德黑客中最重要的方面之一。如果没有适当获取所需的信息，进行成功攻击几乎是不可能的。我们将学习什么是网络扫描以及如何利用它在网络中实施攻击。我们将通过以下主题：
- en: Introduction to networking
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络概述
- en: Data encapsulation in TCP/IP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP 中的数据封装
- en: Introduction to Scapy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scapy 简介
- en: Introduction to ARP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP 简介
- en: Network scanner using Scapy based on ARP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 ARP 的 Scapy 网络扫描器
- en: Introduction to networking
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络概述
- en: In [*Chapter 3*](B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070), *Reconnaissance
    and Information Gathering*, we learned about the basics of networking from a very
    high perspective. We learned about the different components and devices present
    in a network and what the role of each component is. In this section, we will
    learn a bit more about the actual packets and data that are delivered over a network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 3 章*](B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070)《侦察与信息收集》中，我们从一个非常宏观的角度学习了网络的基础知识。我们了解了网络中存在的不同组件和设备，以及每个组件的作用。在本节中，我们将更深入了解通过网络传输的实际数据包和信息。
- en: Data representation in digital systems
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字系统中的数据表示
- en: 'Let''s first understand how your computer system manages to transmit data over
    a network. Every part of data in a computer system is defined by **binary logic
    levels**. These levels are defined as *low* or *high*. Every image, file, video,
    voice recording, or anything else that is stored in a modern-day computing system
    is represented by these logic levels. In physical hardware, these levels are mapped
    to either voltage levels or switch statuses. For example, a voltage of 5 V in
    a digital system might represent high logic and a voltage of 0 V will represent
    low logic. You might be wondering how these different types of data are represented
    by logic levels. Let''s see how that works. Let''s say you want to send the message
    **Hello** to a friend. For the sake of simplicity, let''s consider that your friend
    is present in the same network. For now, we will assume that the underlying communication
    works. Now, in order to send this **Hello** message, we need to convert this message
    into a form that is understandable by the computers. We just learned that computers
    only understand the low and high logic levels, so we will have to *encode* our
    message into these logic levels. Now, as we can see, **Hello** contains five letters
    and we only have two logic levels, so it is not possible to encode the complete
    message with just one *instance* of just two levels. This instance is called a
    **bit**. In order to achieve this encoding, a system was developed called **American
    Standard Code for Information Interchange** (**ASCII**). Using this coding scheme,
    we can represent English letters easily along with a few other symbols and letters.
    Every single letter of the English alphabet is represented by a sequence of 8
    bits called a *byte*. To represent the letter **H** of our **Hello** message,
    we can encode it as the following sequence of bits. **H** is **01001000** in ASCII
    format. This value is predefined in an ASCII code table; similarly, other characters
    are also defined in the same format:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解一下计算机系统是如何通过网络传输数据的。计算机系统中的每一部分数据都是由**二进制逻辑电平**定义的。这些电平被定义为*低*或*高*。计算机系统中存储的每一张图像、文件、视频、语音录音或其他任何东西，都是通过这些逻辑电平来表示的。在物理硬件中，这些电平会映射到电压电平或开关状态。例如，在数字系统中，5伏的电压可能代表高逻辑电平，而0伏的电压则代表低逻辑电平。你可能会想知道这些不同类型的数据是如何通过逻辑电平来表示的。让我们来看一下是如何工作的。假设你想把信息**Hello**发送给一个朋友。为了简单起见，我们假设你的朋友就在同一个网络中。现在，我们假设底层的通信工作正常。为了发送这个**Hello**消息，我们需要将其转换为计算机能够理解的形式。我们刚刚了解到计算机只理解低和高逻辑电平，因此我们必须将我们的消息*编码*为这些逻辑电平。现在，如我们所见，**Hello**包含五个字母，而我们只有两个逻辑电平，所以仅凭两个电平的*实例*是不可能编码完整的消息的。这个实例被称为**位（bit）**。为了实现这种编码，开发了一个名为**美国信息交换标准代码**（**ASCII**）的系统。使用这个编码方案，我们可以轻松地表示英文字母以及一些其他符号和字母。英语字母的每个字母都由8位的二进制序列表示，称为*字节*。为了表示我们**Hello**消息中的字母**H**，我们可以将其编码为以下的二进制序列：**H**在ASCII格式中是**01001000**。这个值在ASCII代码表中是预定义的；类似地，其他字符也以相同的格式定义：
- en: '**H** = **01001000**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**H** = **01001000**'
- en: '**e** = **01000101**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**e** = **01000101**'
- en: '**l** = **01101100**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**l** = **01101100**'
- en: '**l** = **01101100**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**l** = **01101100**'
- en: '**o** = **01101111**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**o** = **01101111**'
- en: Now we have a stream of data that can we send using any digital system. Note
    that this is a very simplified explanation of data representation. Real systems
    also use other encodings, such as Unicode and byte representation, to send complex
    data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一串可以通过任何数字系统发送的数据流。请注意，这是数据表示的一个非常简化的解释。实际系统还使用其他编码方式，如Unicode和字节表示法，来发送复杂的数据。
- en: Data encapsulation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据封装
- en: 'Now that we understand the data representation, let''s turn our focus back
    to our original topic on how to send this data. We''ve already learned about different
    layers in a TCP/IP stack and how they are used to send data. In the preceding
    section, we said that we want to send a **Hello** message to someone in our local
    network. Let''s call this message our *data*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了数据表示，让我们把注意力重新集中在我们最初的话题上：如何发送这些数据。我们已经了解了TCP/IP协议栈中的不同层以及它们如何用来发送数据。在前面的部分中，我们提到我们想要将**Hello**消息发送给本地网络中的某个人。我们将这条消息称为我们的*数据*：
- en: '![Figure 4.1 – Data representation'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 数据表示'
- en: '](image/B14788_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_01.jpg)'
- en: Figure 4.1 – Data representation
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 数据表示
- en: Now, in order for it to successfully reach the other computer, the packet must
    know its exact destination, similar to how a postal delivery system works. You
    have a country, city, postal code, street, and house number. In digital systems,
    you have IP addresses, MAC addresses, and source and destination ports. Let's
    say you write your message in your browser application and your friend is also
    waiting for your message in their browser. In order to successfully send the message
    to the exact same *process* in the destination computer, the IP protocol will
    add a new *header* to your message.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使数据包成功到达另一台计算机，它必须知道其准确的目标，就像邮政投递系统一样。你有国家、城市、邮政编码、街道和门牌号。在数字系统中，你有IP地址、MAC地址以及源端口和目标端口。假设你在浏览器应用中写下你的消息，你的朋友也在浏览器中等待你的消息。为了将消息准确无误地发送到目标计算机中的同一个*进程*，IP协议会在你的消息中添加一个新的*头部*。
- en: 'From the topmost layer, the **application header** is added. Similarly, each
    layer below the application layer adds its own header. The overall process looks
    as in *Figure 4.2*. *Figure 4.2* shows how data is encapsulated in the TCP/IP
    stack before it is sent over the network. We will learn about what each of these
    segments contains and how this helps the packet to go to its destination:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从最顶层开始，**应用层头部**被添加。同样，应用层下方的每一层也会添加自己的头部。整体过程如*图4.2*所示。*图4.2*展示了数据在通过网络发送之前如何在TCP/IP栈中被封装。我们将了解这些段包含了什么内容，以及这些内容如何帮助数据包到达目的地：
- en: '![Figure 4.2 – Data encapsulation'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 数据封装'
- en: '](image/B14788_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_02.jpg)'
- en: Figure 4.2 – Data encapsulation
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 数据封装
- en: We will talk about these segments in detail in the following section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讲解这些段。
- en: The packet delivery process
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包传递过程
- en: The packet delivery process depends on whether the destination device is located
    in the same local network or not. If the device is located in the same subnet,
    we can directly use the Ethernet addresses to send the data. There is a lot of
    information present in these headers and for the scope of this book, you will
    not be concerned with most of them, I will only explain the fields that are relevant
    to this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的传递过程取决于目标设备是否位于同一局域网内。如果设备位于同一子网内，我们可以直接使用以太网地址发送数据。这些头部包含了很多信息，对于本书的内容，你无需关心大部分内容，我将只解释与本书相关的字段。
- en: TCP header
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP头部
- en: 'The TCP header has the fields shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部包含下图所示的字段：
- en: '![Figure 4.3 – TCP header'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – TCP头部'
- en: '](image/B14788_04_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_03.jpg)'
- en: Figure 4.3 – TCP header
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – TCP头部
- en: In this header, we are only concerned with the source and destination ports.
    The source port relates to the process in your local machine associated with the
    message you want to send. The destination port is where the packet should go.
    The source port is usually randomly generated from the sending side while the
    receiving port is defined by the message. For example, when you request an HTTPS
    website, your PC generates request packets with the destination port number set
    to **443**. Some services have fixed port numbers. For example, *FTP* works on
    port **21** and *HTTP* on port **80**. In our case, if we are sending the **Hello**
    message to a browser application working on HTTPS, the source port field in the
    sending packet will be randomly selected (you can also set it manually as well;
    for example, the SSH default port is **22**, but if we changed SSH to work on
    a different port and **22** has become available, it can be used as source port
    in packets) and the destination would be **443**. Note that some ports are reserved,
    as seen previously, so your PC will assign a source port number between **10000**
    and **65355**. Once the TCP header is added to the data, it is called the *TCP
    segment*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头部中，我们只关心源端口和目标端口。源端口与本地计算机中与要发送的信息相关的进程有关。目标端口是数据包应发送到的位置。源端口通常由发送方随机生成，而接收端口则由消息定义。例如，当你请求一个HTTPS网站时，你的PC会生成请求数据包，并将目标端口号设置为**443**。某些服务有固定的端口号。例如，*FTP*使用端口**21**，*HTTP*使用端口**80**。在我们的例子中，如果我们将**Hello**消息发送给一个在HTTPS上工作的浏览器应用程序，发送数据包中的源端口字段将随机选择（你也可以手动设置；例如，SSH的默认端口是**22**，但如果我们将SSH配置为使用其他端口，而**22**可用，它就可以作为数据包中的源端口），目标端口则是**443**。请注意，某些端口是保留的，正如前面所见，你的PC会分配一个**10000**到**65355**之间的源端口号。一旦TCP头部被添加到数据中，它就被称为*TCP段*。
- en: IP header
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP头部
- en: 'Next, an IP header is added that looks as shown in *Figure 4.4*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个IP头部，如*图4.4*所示：
- en: '![Figure 4.4 – IP header'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – IP头部'
- en: '](image/B14788_04_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_04.jpg)'
- en: Figure 4.4 – IP header
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – IP头部
- en: Here, the fields that we are interested in are the source IP and destination
    IP. This defines where your packet will go and where it is originating from. Once
    the IP header is added, it is called an *IP datagram*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们关心的字段是源IP和目标IP。它定义了数据包的去向和来源。添加IP头部后，它就被称为*IP数据报*。
- en: Ethernet header
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太网头部
- en: 'The Ethernet header helps the data to navigate in the local network. The most
    important fields here are the source and destination MAC addresses. As the name
    implies, the source MAC address will be your MAC address and the destination will
    be the MAC address of the recipient in the local network:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网头部帮助数据在本地网络中进行导航。这里最重要的字段是源MAC地址和目标MAC地址。顾名思义，源MAC地址是你的MAC地址，目标MAC地址是本地网络中接收者的MAC地址：
- en: '![Figure 4.5 – Ethernet header'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 以太网头部'
- en: '](image/B14788_04_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_05.jpg)'
- en: Figure 4.5 – Ethernet header
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 以太网头部
- en: Once an Ethernet header is added, it is now called an *Ethernet frame*. We have
    learned about the most important fields in the packets being sent over the network.
    We have also learned how data is encapsulated and which fields it uses to route
    it over the network. In the next section, we will learn about creating our network
    scanner using the information we have just learned.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了以太网头部，它就被称为*以太网帧*。我们已经了解了在网络上传输的数据包中最重要的字段。我们也了解了数据如何被封装，以及它使用哪些字段来在网络中路由数据。在下一部分，我们将学习如何利用我们刚刚学到的信息创建网络扫描器。
- en: Introduction to Scapy
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy简介
- en: 'In order to create a network scanner, we will use a Python networking library
    called Scapy. This library is designed to send, sniff, dissect, and edit network
    packets. Scapy is a very powerful network packet manipulation tool. To read more
    about the tool, you can go to the following link: [https://scapy.readthedocs.io/en/latest/introduction.html](https://scapy.readthedocs.io/en/latest/introduction.html).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个网络扫描器，我们将使用一个名为Scapy的Python网络库。这个库旨在发送、嗅探、解析和编辑网络数据包。Scapy是一个非常强大的网络数据包操作工具。要了解更多关于该工具的信息，可以访问以下链接：[https://scapy.readthedocs.io/en/latest/introduction.html](https://scapy.readthedocs.io/en/latest/introduction.html)。
- en: Installing Scapy
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Scapy
- en: 'To install Scapy, first open the terminal. Let''s understand a few things first.
    In Linux, there are two user privileges, user and root, and the environment for
    both users is different. Higher privileges are required for system-level commands.
    To send and receive packets, we will need to install Scapy as a root user as well
    as a normal user. We will write our program as a normal user and when we run it,
    we will run it as root as sending packets requires higher privileges in Linux
    (you can think of it as the *Run as Administrator* equivalent in Windows). You
    will see what I mean in a moment. To install Scapy as a root user, write the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Scapy，首先打开终端。让我们先了解一些基本概念。在Linux中，有两种用户权限，普通用户和root用户，它们的环境是不同的。系统级命令需要更高的权限。为了发送和接收数据包，我们需要以root用户以及普通用户的身份安装Scapy。我们将作为普通用户编写程序，运行时会以root身份运行，因为在Linux中发送数据包需要更高的权限（你可以把它想象成Windows中的*以管理员身份运行*）。稍后你会明白我的意思。要以root用户安装Scapy，请输入以下命令：
- en: sudo pip3 install scapy
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: sudo pip3 install scapy
- en: This will install Scapy with administrator privileges. Once this is done, open
    your Visual Studio Code and create a new folder for the new project. We will call
    this **example2-introduction-scapy**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以管理员权限安装Scapy。完成后，打开你的Visual Studio Code并为新项目创建一个文件夹。我们将这个文件夹命名为**example2-introduction-scapy**。
- en: 'Note that if you face some problems, you will need to update your system''s
    Python with the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你遇到一些问题，你需要通过以下命令更新系统的Python：
- en: sudo apt-get update && sudo apt-get upgrade && sudo apt-get install python3-virtualenv
    -y
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get update && sudo apt-get upgrade && sudo apt-get install python3-virtualenv
    -y
- en: 'Now, we will create a new virtual environment for this specific project. To
    create a new virtual environment, navigate to the folder directory just created
    and write the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为这个特定项目创建一个新的虚拟环境。要创建新的虚拟环境，请导航到刚刚创建的文件夹目录，并输入以下命令：
- en: python3 -m venv venv
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m venv venv
- en: Now, if everything is done properly, you will see a folder created named **venv**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一切顺利，你将看到一个名为**venv**的文件夹被创建。
- en: 'Next, activate the virtual environment by running the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过运行以下命令激活虚拟环境：
- en: source venv/bin/activate
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: source venv/bin/activate
- en: 'Now, your virtual environment should be activated. Once it is activated, you
    can see the installed packages in the environment by typing the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的虚拟环境应该已被激活。一旦激活，你可以通过输入以下命令查看环境中已安装的软件包：
- en: pip freeze
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: pip freeze
- en: 'If you have any packages already installed in the environment, they will be
    listed down; otherwise, you will have nothing showing. Now, to install Scapy,
    write the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的环境中已经安装了任何软件包，它们会被列出来；否则，你将看不到任何内容。现在，为了安装 Scapy，输入以下命令：
- en: pip3 install scapy
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: pip3 install scapy
- en: 'This should take some time to install. Once done, you can write the **pip freeze**
    command again to see the installed packages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程可能需要一些时间。完成后，你可以再次输入 **pip freeze** 命令查看已安装的软件包：
- en: '![Figure 4.6 – Installed packages in a virtual environment'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 虚拟环境中的已安装软件包](image/B14788_04_06.jpg)'
- en: '](image/B14788_04_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_06.jpg)'
- en: Figure 4.6 – Installed packages in a virtual environment
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 虚拟环境中的已安装软件包
- en: In this section, we have learned how we can install Scapy in our virtual environment
    and how to see whether it has been installed properly. Note that some functionalities
    of Scapy require the program to be run with higher privileges, otherwise they
    won't work. In the next section, we will learn more about how Scapy is used and
    how we can manipulate network packets with Scapy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在虚拟环境中安装 Scapy，以及如何查看它是否安装正确。请注意，Scapy 的一些功能需要以更高的权限运行程序，否则它们将无法正常工作。在下一节中，我们将进一步了解
    Scapy 的使用方法，以及如何利用 Scapy 操作网络数据包。
- en: Understanding how Scapy works
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Scapy 的工作原理
- en: 'In this part, we will learn about how Scapy works and how we can use it to
    create our own network manipulation tools. Let''s create a new file called **main.py**
    and open it. Once the file is open, we can import any Scapy module inside the
    file. In this section, we will create a small ping request to any website. Ping
    requests are usually used to test whether a device is available or not. A ping
    request (also called an *echo request*) uses an underlying ICMP application layer
    protocol. To import a package inside your program, write the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解 Scapy 是如何工作的，以及如何利用它创建自己的网络操作工具。让我们创建一个名为 **main.py** 的新文件并打开它。一旦文件打开，我们就可以在文件中导入任何
    Scapy 模块。在本节中，我们将创建一个简单的 ping 请求，发送到任何网站。Ping 请求通常用于测试设备是否可用。Ping 请求（也叫做 *回声请求*）使用的是底层的
    ICMP 应用层协议。要在程序中导入一个包，请写下以下代码：
- en: from scapy.all import scapy
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import scapy
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Note that in the latest version of Kali Linux, some dependencies have been
    changed and you may see an error related to missing files. To correct this issue,
    you can write the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Kali Linux 的最新版本中，一些依赖项已被更改，可能会出现与缺少文件相关的错误。为了解决这个问题，你可以输入以下命令：
- en: '**cd /usr/lib/x86_64-linux-gnu/sudo ln -s -f libc.a liblibc.a**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**cd /usr/lib/x86_64-linux-gnu/sudo ln -s -f libc.a liblibc.a**'
- en: 'To send a ping request, you will need to create an IP layer packet, which will
    help you set the source and destination IP addresses. To import the IP layer,
    we can write the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送一个 ping 请求，你需要创建一个 IP 层数据包，这将帮助你设置源 IP 和目的地 IP 地址。要导入 IP 层，我们可以写下以下命令：
- en: from scapy.all import IP
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import IP
- en: 'And lastly, to send and receive packets, we can use a function called **sr**.
    To import this function, use the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了发送和接收数据包，我们可以使用一个名为 **sr** 的函数。要导入这个函数，使用以下命令：
- en: from scapy.all import sr
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import sr
- en: This IP will be different for you depending on your system. You can find this
    IP using the **sudo ifconfig** command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IP 地址会根据你的系统不同而有所不同。你可以使用 **sudo ifconfig** 命令找到这个 IP 地址。
- en: 'Then, we will define our source and destination IP:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义源 IP 和目的地 IP：
- en: src_ip = "192.168.74.128"
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: src_ip = "192.168.74.128"
- en: Then, we will define the destination IP. We want to create a ping request to
    a **google.com** server. You can either manually write the IP address of this
    server, which you can find by writing **ping www.google.com** in your terminal,
    or you can simply give **www.google.com**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义目的地 IP。我们希望创建一个针对 **google.com** 服务器的 ping 请求。你可以手动输入该服务器的 IP 地址，通过在终端输入
    **ping www.google.com** 找到，或者你可以直接使用 **www.google.com**。
- en: 'Scapy will automatically translate this address:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 会自动转换这个地址：
- en: dest_ip = "www.google.com"
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: dest_ip = "www.google.com"
- en: 'Now, we will create an **ip_layer** packet and print it out to see what it
    contains:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个**ip_layer**数据包，并打印它，看看它包含了什么：
- en: from scapy.all import ICMP
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import ICMP
- en: from scapy.all import IP
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import IP
- en: from scapy.all import sr
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import sr
- en: 'if __name__ == "__main__":'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == "__main__":'
- en: src_ip = "192.168.74.128"
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: src_ip = "192.168.74.128"
- en: dest_ip = "www.google.com"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: dest_ip = "www.google.com"
- en: ip_layer = IP(
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ip_layer = IP(
- en: src = src_ip,
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: src = src_ip,
- en: dst = dest_ip
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: dst = dest_ip
- en: )
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(ip_layer.show())
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: print(ip_layer.show())
- en: This will create an IP layer packet and display the content of the created packet.
    Note that the packet has not been sent yet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 IP 层数据包，并显示已创建数据包的内容。注意数据包还没有被发送。
- en: 'The output of this program looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下所示：
- en: '![Figure 4.7 – IP layer packet creation'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – IP 层数据包创建'
- en: '](image/B14788_04_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_07.jpg)'
- en: Figure 4.7 – IP layer packet creation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – IP 层数据包创建
- en: Take a look at the **src** and **dst** fields. The destination is an instance
    of **Net**, which means that Scapy will take care of translating it into an actual
    IP address. Now, if you check the fields displayed here and compare them with
    *Figure 4.4*, you will see that these are the same fields.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**src**和**dst**字段。目标是**Net**的实例，这意味着 Scapy 将负责将其转换为实际的 IP 地址。现在，如果你检查这里显示的字段并将它们与*图
    4.4*进行比较，你会看到这些字段是相同的。
- en: 'Next, to send an ICMP request, you can call the class to create an instance
    like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要发送一个 ICMP 请求，你可以像这样调用类来创建一个实例：
- en: icmp_req = ICMP(id=100)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: icmp_req = ICMP(id=100)
- en: '**id=100** helps the protocol to trace packets. To see what fields are present
    inside this request, you can write the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**id=100**帮助协议跟踪数据包。要查看此请求中包含哪些字段，你可以输入以下命令：'
- en: print(icmp_req.show())
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: print(icmp_req.show())
- en: 'The result will look something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下内容：
- en: '![Figure 4.8 – ICMP packet contents'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – ICMP 数据包内容'
- en: '](image/B14788_04_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_08.jpg)'
- en: Figure 4.8 – ICMP packet contents
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – ICMP 数据包内容
- en: From here, you can see that the packet type is an echo request, which is used
    for testing the connection availability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到数据包类型是回显请求，用于测试连接的可用性。
- en: 'From our previous discussion, we know that the application layer resides on
    top of the IP layer, and we have created two layers up until now. Now, the next
    goal would be to combine these two layers into a single packet that can be sent
    over the network. To do this, we can write the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的讨论，我们知道应用层位于 IP 层之上，到目前为止我们已经创建了两个层。现在，下一步是将这两个层合并成一个可以通过网络发送的数据包。为此，我们可以编写以下代码：
- en: packet = ip_layer / icmp_req
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: packet = ip_layer / icmp_req
- en: print(packet.show())
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: print(packet.show())
- en: 'This will list out the combined packet. Note the **/** operator. This operator
    is used to combine different layers in Scapy. You start with the lower layer and
    keep on adding new layers with this **/** operator. The **print** result will
    show the result of the packet with the previous layers combined into one:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出合并后的数据包。注意**/**运算符。此运算符用于在 Scapy 中合并不同的层。你从底层开始，并通过这个**/**运算符不断添加新的层。**print**结果将显示将先前的层合并为一个的数据包结果：
- en: '![Figure 4.9 – Combined layers'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – 合并层'
- en: '](image/B14788_04_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_09.jpg)'
- en: Figure 4.9 – Combined layers
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 合并层
- en: 'Now, our request is ready to be sent. To send it, we can use the **sr1** method
    we already imported:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的请求已经准备好发送了。为了发送它，我们可以使用我们已经导入的**sr1**方法：
- en: response = sr1(packet, iface="eth0")
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: response = sr1(packet, iface="eth0")
- en: 'if response:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有响应：
- en: print(response.show())
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: print(response.show())
- en: 'The response will look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将类似于以下内容：
- en: '![Figure 4.10 – ICMP reply'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – ICMP 回复'
- en: '](image/B14788_04_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_10.jpg)'
- en: Figure 4.10 – ICMP reply
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – ICMP 回复
- en: You can see the type of response is **echo-reply** and the **src** field in
    the reply is the IP address of the server that replied to this ping request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到响应类型是**echo-reply**，回复中的**src**字段是回复此 ping 请求的服务器的 IP 地址。
- en: Now you have learned how to craft and send packets using Python. Theoretically,
    you can create any network application with Scapy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何使用 Python 构建和发送数据包。理论上，你可以使用 Scapy 创建任何网络应用程序。
- en: 'The complete code mentioned previously to send a packet is shown next:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的完整代码来发送数据包如下所示：
- en: from scapy.all import ICMP
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import ICMP
- en: from scapy.all import IP
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import IP
- en: from scapy.all import sr,
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import sr,
- en: 'if __name__ == "__main__":'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == "__main__":'
- en: src_ip = "192.168.74.128"
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: src_ip = "192.168.74.128"
- en: dest_ip = "www.google.com"
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: dest_ip = "www.google.com"
- en: ip_layer = IP(src = src_ip, dst = dest_ip)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ip_layer = IP(src = src_ip, dst = dest_ip)
- en: icmp_req = ICMP(id=100)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: icmp_req = ICMP(id=100)
- en: packet = ip_layer / icmp_req
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: packet = ip_layer / icmp_req
- en: response = sr(packet, iface="eth0")
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: response = sr(packet, iface="eth0")
- en: // to see available interfaces, write ifconfig command in
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: // 若要查看可用接口，请在终端中输入 ifconfig 命令
- en: // terminal
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: // terminal
- en: 'if response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'if response:'
- en: print(response.show())
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: print(response.show())
- en: The good thing about Scapy is that it lets you create **raw_packets**, which
    means that even packets with false information (malformed packets) can be created
    and there is no mechanism for checking whether the packet has correct values or
    not. You can change the **src ip** field from your computer and put the value
    of some other packet, and in some cases, the destination will have no way of knowing
    which PC actually generated these packets (idle scan). This way, you can *spoof*
    packets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 的一个优点是它允许你创建**原始数据包**，这意味着即使是包含错误信息（格式不正确的数据包）也可以创建，并且没有机制来检查数据包的值是否正确。你可以从你的计算机更改**src
    ip**字段，并将其他数据包的值放入其中，在某些情况下，目标将无法知道哪个计算机实际上生成了这些数据包（空闲扫描）。这样，你就可以进行*伪造*数据包。
- en: So, until now, we have learned about IP stack and header fields. We also learned
    about how to install Scapy and use it to create raw packets that can be sent over
    the network. Let's now take a look at few more helpful functions that will help
    us understand the workings of Scapy in a bit more detail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 IP 协议栈和头字段。我们还学习了如何安装 Scapy 并使用它创建可以通过网络发送的原始数据包。现在，让我们看一下更多有助于我们深入理解
    Scapy 工作原理的有用函数。
- en: 'If you want to see more details about a certain layer in Scapy and what options
    are available in the layer to modify, you can use the **ls** function in Scapy.
    To import this function, you can use this command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看 Scapy 中某一层的更多细节以及该层可以修改的选项，你可以使用 Scapy 中的**ls**函数。要导入此函数，你可以使用以下命令：
- en: from scapy.all import ls, IP
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import ls, IP
- en: 'To get information about **ip_layer**, we can print **ls** like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于**ip_layer**的信息，我们可以像这样打印**ls**：
- en: dest_ip = "www.google.com"
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: dest_ip = "www.google.com"
- en: ip_layer = IP(dst = dest_ip)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ip_layer = IP(dst = dest_ip)
- en: print(ls(ip_layer))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: print(ls(ip_layer))
- en: 'In the next screenshot, you will see the execution of the previously mentioned
    code. The screenshot shows the list of fields in the IP packet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张截图中，你将看到之前提到的代码的执行。截图显示了 IP 数据包中的字段列表：
- en: '![Figure 4.11 – The ls function'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – ls 函数'
- en: '](image/B14788_04_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_11.jpg)'
- en: Figure 4.11 – The ls function
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – ls 函数
- en: 'If you want to access the individual field of any layer, you can simply use
    the dot (**.**) operator. For example, if you want to print **dst** in **ip_layer**,
    you can write the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问某一层的单独字段，你可以直接使用点号（**.**）操作符。例如，如果你想打印**ip_layer**中的**dst**字段，你可以写如下代码：
- en: ip_layer = IP(dst = dest_ip)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ip_layer = IP(dst = dest_ip)
- en: print("Destination  = ", ip_layer.dst)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: print("Destination = ", ip_layer.dst)
- en: 'The result is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 4.12 – Accessing individual fields'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 访问单独字段'
- en: '](image/B14788_04_12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_12.jpg)'
- en: Figure 4.12 – Accessing individual fields
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 访问单独字段
- en: 'If you want to see a quick summary of the layer, you can call the **summary**
    method on the layer:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看该层的快速概述，可以在该层上调用**summary**方法：
- en: print("Summary  = ",ip_layer.summary())
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: print("Summary = ", ip_layer.summary())
- en: 'The summary result will be as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 概述结果如下：
- en: '![Figure 4.13 – Layer summary'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 层概述'
- en: '](image/B14788_04_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_13.jpg)'
- en: Figure 4.13 – Layer summary
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 层概述
- en: So now, we have familiarized ourselves with Scapy and how it works. We learned
    about creating basic packets and how to manipulate these packets. In the next
    section, we will move toward how to use Scapy for information gathering.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了 Scapy 及其工作原理。我们学习了如何创建基本的包以及如何操作这些包。在下一节中，我们将探讨如何使用 Scapy 进行信息收集。
- en: Network scanner using Scapy
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scapy 创建网络扫描器
- en: In this section, we will create a simple scanner, scan hosts in our local network,
    and find their MAC addresses. In order to create the scanner, we need to first
    understand what the **Address Resolution Protocol** (**ARP**) is and how it can
    be used for creating a network scanner.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的扫描器，扫描本地网络中的主机，并找到它们的 MAC 地址。为了创建这个扫描器，我们需要首先了解什么是**地址解析协议**（**ARP**），以及如何利用它来创建网络扫描器。
- en: Address Resolution Protocol
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址解析协议
- en: ARP in its simplest form is a translation tool that helps us to translate IP
    addresses into MAC addresses. Whenever a device needs to communicate with a device
    within the same local network, it needs the device's MAC address. IP addresses
    are not used for local communication.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ARP 在最简单的形式下是一个翻译工具，帮助我们将 IP 地址转换为 MAC 地址。每当一个设备需要与同一本地网络中的其他设备进行通信时，它需要该设备的
    MAC 地址。IP 地址不用于本地通信。
- en: Let's say that device A wants to communicate with device B in a local network.
    In order to find the MAC address of device B, computer A will first look inside
    an internal list maintained by it called the ARP cache to see whether computer
    B's IP addresses are mapped to a physical MAC address inside its table. This is
    called an ARP table as well. You can check the ARP table on your PC by typing
    the **arp -a** command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设设备 A 想要与本地网络中的设备 B 进行通信。为了找到设备 B 的 MAC 地址，计算机 A 会首先查看它内部维护的一个列表，称为 ARP 缓存，查看计算机
    B 的 IP 地址是否已映射到物理 MAC 地址。如果已经映射，这个列表就被称为 ARP 表。你可以通过输入 **arp -a** 命令查看你电脑的 ARP
    表。
- en: 'Here is the result of running the **arp -a** command on Kali Linux:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Kali Linux 上运行 **arp -a** 命令的结果：
- en: '![Figure 4.14 – ARP table'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14 – ARP 表'
- en: '](image/B14788_04_14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_14.jpg)'
- en: Figure 4.14 – ARP table
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – ARP 表
- en: You can see that it lists out the IP addresses and corresponding MAC addresses
    associated with them. You can use the same command in Windows as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，它列出了与这些 IP 地址相关的 MAC 地址。你也可以在 Windows 中使用相同的命令。
- en: 'If the corresponding MAC address of the requested device is not present locally,
    device A will send out a broadcast request to the whole network to ask which device
    has the respective IP. In our case, it will be device B. Those devices that are
    not device B will ignore this request while device B will give out a reply with
    the corresponding MAC address of device B. This way, device A will get to know
    the MAC address of device B. Once both devices get to know each other, the communication
    between them can follow. Once device A gets the MAC address of device B, it will
    update its ARP table. *Figure 4.15* shows how an ARP request is generated by the
    source device and how the destination device replies with the correct MAC address:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的设备的对应 MAC 地址在本地没有找到，设备 A 会向整个网络发送广播请求，询问哪个设备拥有对应的 IP 地址。在我们的例子中，这将是设备 B。非设备
    B 的设备会忽略此请求，而设备 B 会回复设备 B 的相应 MAC 地址。这样，设备 A 就能得知设备 B 的 MAC 地址。两个设备互相认识后，它们之间的通信可以继续。设备
    A 一旦获得设备 B 的 MAC 地址，它就会更新其 ARP 表。*图4.15* 展示了源设备如何生成 ARP 请求以及目标设备如何用正确的 MAC 地址进行回复：
- en: '![Figure 4.15 – ARP request'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15 – ARP 请求'
- en: '](image/B14788_04_15.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_15.jpg)'
- en: Figure 4.15 – ARP request
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – ARP 请求
- en: Now that we understand how ARP works, we can start working on creating our own
    ARP scanner with Scapy to find out the MAC address of these devices. You might
    be wondering why we need an ARP scanner. Well, knowing the MAC addresses of a
    device can help us perform a **man-in-the-middle attack**, which we will perform
    in [*Chapter 5*](B14788_05_Final_JC_ePub.xhtml#_idTextAnchor116), *Man in the
    Middle Attacks*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了 ARP 的工作原理，我们可以开始使用 Scapy 创建我们自己的 ARP 扫描器，以找出这些设备的 MAC 地址。你可能会想，为什么我们需要一个
    ARP 扫描器呢？嗯，知道设备的 MAC 地址可以帮助我们进行 **中间人攻击**，我们将在 [*第5章*](B14788_05_Final_JC_ePub.xhtml#_idTextAnchor116)
    中进行 *中间人攻击*。
- en: ARP scanner using Scapy
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scapy 的 ARP 扫描器
- en: 'The ARP protocol works on the Ethernet layer, so using Scapy, we will import
    the Ethernet layer. Let''s import the layers and functions we will use:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ARP 协议工作在以太网层，因此在使用 Scapy 时，我们需要导入以太网层。让我们导入我们将使用的层和功能：
- en: from scapy.all import Ether, ARP, srp
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import Ether, ARP, srp
- en: 'If all the bits of a MAC address are set to **1**, it means that the packet
    is a broadcast and it should go to every device in the network. Scapy uses hexadecimal
    representation, so we will create the following variable to denote the broadcast
    address:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 MAC 地址的所有位都设置为 **1**，那么这意味着该数据包是广播包，应该发送到网络中的每个设备。Scapy 使用十六进制表示法，因此我们将创建以下变量来表示广播地址：
- en: broadcast = "FF:FF:FF:FF:FF:FF"
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 广播 = "FF:FF:FF:FF:FF:FF"
- en: Then, we can create an Ethernet layer packet and put the destination as **broadcast**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个以太网层的数据包，并将目的地设置为 **广播**。
- en: 'We will also need to define the **ip** range we want to scan. In my case, I
    want to scan my local network:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义我们想要扫描的 **IP** 范围。在我的例子中，我想扫描我的本地网络：
- en: ip_range = "192.168.74.1/24"
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ip_range = "192.168.74.1/24"
- en: This represents that we want to scan all the devices starting with IP address
    **192.168.74.1** up to **192.168.74.255**. The last 8 bits are called a bitmask
    and represent the number of hosts we want to scan. Remember that an IP address
    is 32 bits, and we say here that we want to mask 24 bits, so the remaining **32-24
    = 8** bits are addressable only, which means that we are only scanning the last
    256 hosts in the network.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们想要扫描所有从 IP 地址 **192.168.74.1** 到 **192.168.74.255** 的设备。最后 8 位被称为子网掩码，表示我们要扫描的主机数量。记住，IP
    地址是 32 位的，我们这里说我们想要屏蔽 24 位，因此剩下的 **32-24 = 8** 位是可寻址的，这意味着我们只扫描网络中的最后 256 个主机。
- en: 'Now, to create an ARP layer packet, use these commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个 ARP 层包，使用以下命令：
- en: ip_range = "192.168.74.1/24"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ip_range = "192.168.74.1/24"
- en: arp_layer = ARP(pdst = ip_range)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: arp_layer = ARP(pdst = ip_range)
- en: 'Now we have created two layers, **Ether** and **ARP**. Next, we will create
    a packet with both these layers:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了两个层，**Ether** 和 **ARP**。接下来，我们将创建一个包含这两个层的包：
- en: packet = ether_layer / arp_layer
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: packet = ether_layer / arp_layer
- en: 'Next, we will send this packet as a broadcast. To do this, we can use the following
    **srp** function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以广播的方式发送这个包。为此，我们可以使用以下的 **srp** 函数：
- en: ans, unans = srp(packet, iface = "eth0", timeout=2)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ans, unans = srp(packet, iface = "eth0", timeout=2)
- en: '**packet** is the name of the packet we want to send, **iface** is the network
    interface card we want to use to send this packet, and **timeout** is to make
    sure that if we don''t get a reply in 2 seconds this means that the device is
    most probably offline.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**packet** 是我们想要发送的包，**iface** 是我们希望用来发送该包的网络接口卡，**timeout** 用来确保如果 2 秒内没有收到回复，则表示该设备很可能处于离线状态。'
- en: '**srp** returns both answered and unanswered packets. We are interested in
    answered packets from online devices only. Now, to get the IP addresses and MAC
    addresses of the online devices, we can write the following code. We can iterate
    over the answer to see the IP and corresponding MAC addresses:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**srp** 返回已经回答和未回答的包。我们只关心在线设备返回的已回答包。现在，为了获取在线设备的 IP 地址和 MAC 地址，我们可以写出以下代码。我们可以遍历返回结果，查看
    IP 和对应的 MAC 地址：'
- en: 'for snd, rcv in ans:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'for snd, rcv in ans:'
- en: ip = rcv[ARP].psrc
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ip = rcv[ARP].psrc
- en: mac = rcv[Ether].src
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: mac = rcv[Ether].src
- en: print("IP = ", ip, " MAC = ", mac)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: print("IP = ", ip, " MAC = ", mac)
- en: '**rcv** represents the packets that have been received by the sender. To get
    the IP address, we can use the ARP layer, and to get the MAC address, we can use
    the **Ether** layer. Remember the fields set in packets correspond to the respective
    layer.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**rcv** 代表发送者已接收到的包。为了获取 IP 地址，我们可以使用 ARP 层，而为了获取 MAC 地址，我们可以使用 **Ether** 层。记住，包中设置的字段对应各自的层。'
- en: 'The complete code will look something like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码如下所示：
- en: from scapy.all import Ether, ARP, srp
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: from scapy.all import Ether, ARP, srp
- en: 'if __name__ == "__main__":'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: broadcast = "FF:FF:FF:FF:FF:FF"
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: broadcast = "FF:FF:FF:FF:FF:FF"
- en: ether_layer = Ether(dst = broadcast)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ether_layer = Ether(dst = broadcast)
- en: ip_range = "192.168.74.1/24"
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ip_range = "192.168.74.1/24"
- en: arp_layer = ARP(pdst = ip_range)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: arp_layer = ARP(pdst = ip_range)
- en: packet = ether_layer / arp_layer
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: packet = ether_layer / arp_layer
- en: ans, unans = srp(packet, iface = "eth0", timeout=2)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ans, unans = srp(packet, iface = "eth0", timeout=2)
- en: 'for snd, rcv in ans:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'for snd, rcv in ans:'
- en: ip = rcv[ARP].psrc
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ip = rcv[ARP].psrc
- en: mac = rcv[Ether].src
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: mac = rcv[Ether].src
- en: print("IP = ", ip, " MAC = ", mac)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: print("IP = ", ip, " MAC = ", mac)
- en: 'The output of the program looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '![Figure 4.16 – ARP scan result'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – ARP 扫描结果'
- en: '](image/B14788_04_16.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_16.jpg)'
- en: Figure 4.16 – ARP scan result
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – ARP 扫描结果
- en: 'Now you can see the MAC and IP addresses of all the devices available in the
    network. The third one, **IP = 192.168.72.129** is my Windows machine, which I
    will use as a victim/target machine in later chapters. To verify that the result
    we obtained in our program is correct, we can check these fields manually from
    the network connection settings:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到网络中所有设备的 MAC 和 IP 地址。第三个设备，**IP = 192.168.72.129** 是我的 Windows 机器，我将在后面的章节中将其作为受害者/目标机器。为了验证我们程序中得到的结果是否正确，我们可以手动从网络连接设置中检查这些字段：
- en: '![Figure 4.17 – Victim''s IP configuration'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – 受害者的 IP 配置'
- en: '](image/B14788_04_17.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_04_17.jpg)'
- en: Figure 4.17 – Victim's IP configuration
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 受害者的 IP 配置
- en: Here, you can see that the results obtained in our scan match these values.
    Take a look at the MAC address as well. The other devices can also be seen.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们扫描得到的结果与这些值相匹配。再看看 MAC 地址。其他设备也可以看到。
- en: '**192.168.74.254** represents the DHCP server. DHCP servers assign IP addresses
    to devices in a network when the devices are configured to automatic IP assignment.
    **192.168.72.2** represents the default gateway in the network.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**192.168.74.254** 代表DHCP服务器。DHCP服务器在设备配置为自动分配IP时，会向网络中的设备分配IP地址。**192.168.72.2**
    代表网络中的默认网关。'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how data is sent from one device to another over
    the network. We learned about how data is encapsulated in the TCP/IP protocol
    and what fields are added to each header. Next, we learned about a very important
    network manipulation and packet crafting tool called Scapy. We also learned how
    to craft packets using Scapy and how these packets can be sent over the network.
    We then learned about the ARP protocol and finally, we created an ARP scanner
    to get the IP and mac addresses of live devices in a network. In the next chapter,
    we will learn how to use this scanner to create a man-in-the-middle attack to
    intercept network traffic from a victim machine.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了数据是如何通过网络从一个设备传输到另一个设备的。我们了解了数据是如何在TCP/IP协议中封装的，以及每个报文头中添加了哪些字段。接下来，我们学习了一个非常重要的网络操作和数据包构造工具——Scapy。我们还学习了如何使用Scapy构造数据包，以及如何将这些数据包发送到网络中。然后，我们学习了ARP协议，最后，我们创建了一个ARP扫描器，用于获取网络中在线设备的IP地址和MAC地址。在下一章中，我们将学习如何使用这个扫描器创建一个中间人攻击，以拦截来自受害者机器的网络流量。
