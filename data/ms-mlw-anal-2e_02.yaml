- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: A Crash Course in Assembly and Programming Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编与编程基础速成课程
- en: Before diving deeper into the malware world, we need to have a complete understanding
    of the core of the machines we are analyzing malware on. For reverse engineering
    purposes, it makes sense to focus largely on the architecture and the **operating
    system** (**OS**) it supports. Of course, multiple devices and modules comprise
    a system, but it is mainly these two that define a set of tools and approaches
    that are used during the analysis. The physical representation of any architecture
    is a processor. A processor is like the heart of any smart device or computer
    in that it keeps it alive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解恶意软件世界之前，我们需要对分析恶意软件的机器核心有一个完整的了解。出于逆向工程的目的，重点关注架构及其支持的**操作系统**（**OS**）是非常有意义的。当然，多个设备和模块构成了一个系统，但主要是这两个因素定义了一套在分析过程中使用的工具和方法。任何架构的物理表现形式就是处理器。处理器就像任何智能设备或计算机的心脏，它使得设备保持运行。
- en: In this chapter, we will cover the basics of the most widely used architectures,
    from the well-known x86 and x64 **Instruction Set Architectures** (**ISAs**) to
    solutions that power multiple mobile and **Internet of Things** (**IoT**) devices,
    which are often misused by malware families, such as Mirai. This will set the
    tone for your journey into malware analysis, as static analysis is impossible
    without understanding assembly instructions. Although modern decompilers are becoming
    better and better, they don’t exist for all platforms that are targeted by malware.
    Besides, they will probably never be able to handle obfuscated code. Don’t be
    daunted by the complexity of assembly; it just takes time to get used to it, and
    after a while, it becomes possible to read it like any other programming language.
    While this chapter provides a starting point, it always makes sense to deepen
    your knowledge by practicing and exploring further.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖最广泛使用的架构的基础知识，从广为人知的x86和x64 **指令集架构**（**ISAs**）到支持多个移动设备和**物联网**（**IoT**）设备的解决方案，这些设备经常被恶意软件家族（如Mirai）滥用。这将为你进入恶意软件分析的旅程奠定基调，因为没有理解汇编指令，静态分析是不可能的。尽管现代反编译器变得越来越强大，但它们并不是针对所有恶意软件攻击的平台都能使用。而且，它们可能永远无法处理混淆代码。不要被汇编的复杂性吓倒；只需要时间去适应，过一段时间后，它就能像任何其他编程语言一样被理解。虽然本章提供了一个起点，但通过实践和进一步探索来加深理解总是有意义的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Basics of informatics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息学基础
- en: Architectures and their assembly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构及其汇编
- en: Becoming familiar with x86 (IA-32 and x64)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉x86（IA-32和x64）
- en: Exploring ARM assembly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索ARM汇编
- en: Basics of MIPS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIPS基础
- en: Covering the SuperH assembly
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖SuperH汇编
- en: Working with SPARC
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SPARC一起工作
- en: Moving from assembly to high-level programming languages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从汇编语言过渡到高级编程语言
- en: Basics of informatics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息学基础
- en: Before we dive deeper into the internals of the various architectures, now is
    a good time to revise the numeral systems, which will lay a foundation for understanding
    both data types and bitwise operations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解各种架构的内部结构之前，现在是复习数字系统的好时机，这将为理解数据类型和位运算奠定基础。
- en: Numeral systems
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字系统
- en: In our daily life, we use the decimal system with digits from 0 to 9, which
    gives us 10 different 1-digit options in total. There is a good reason for that
    – most of us as human beings have 10 fingers on our hands in total, which are
    always in front of us and are great tools for counting. However, from a data science
    point of view, there is nothing particular about the number 10\. Using another
    base would allow us to store information much more efficiently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，我们使用从0到9的十进制系统，这给了我们总共10个不同的1位选项。这是有充分理由的——因为我们人类总共有10根手指，而这些手指总是出现在我们眼前，是很好的计数工具。然而，从数据科学的角度来看，数字10并没有什么特别之处。使用其他进制将使我们能够更高效地存储信息。
- en: 'The absolute minimum required to store some information is two different values:
    yes or no, true or false, and so on. This lays a foundation for the binary numeral
    system that uses only two digits: 0 and 1\. The way we use it is the same as in
    the case of decimal: every time we reach the maximum digit on the right, we drop
    it to 0 and increment the next digit to the left from it while following the same
    logic. Therefore, *0, 1, 2, 3, 4, ... 9, 10, 11, ...* becomes *0, 1, 10, 11, 100,
    ..., 1001, 1010, 1011, ...* and so on. This approach makes it possible to efficiently
    encode big amounts of information to be read automatically by machines. Examples
    include magnetic tapes and floppy disks (lack or presence of magnetization), CD/DVD/BD
    (lack or presence of the indentation read by a laser), and flash memory (lack
    or presence of the electric charge). To not mix up binary values with decimals,
    it is common to use the “b” suffix for binary values (for example, 1010b).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 存储某些信息的绝对最小要求是两个不同的值：是或否，真或假等。这为只使用两个数字0和1的二进制数制奠定了基础。我们使用它的方式与十进制的情况相同：每次我们到达右侧的最大数字时，我们将其降到0，并且增加左侧的下一个数字，按照相同的逻辑。因此，*0,
    1, 2, 3, 4, ... 9, 10, 11, ...*变成*0, 1, 10, 11, 100, ..., 1001, 1010, 1011, ...*等等。这种方法使得能够有效地编码大量信息，以便由机器自动读取。例如包括磁带和软盘（有无磁化），CD/DVD/BD（由激光读取的缺口有无）和闪存（有无电荷）。为了不混淆二进制值和十进制数，通常对二进制值使用“b”后缀（例如，1010b）。
- en: 'Now, if we want to work with groups of binary digits, we need to choose the
    size of the group. The group of 3 (from 000 to 111) would give 2^3 = 8 possible
    combinations of 0 and 1, allowing us to encode eight different numbers. Similarly,
    the group of 4 (from 0000 to 1111) would give 2^4 = 16 possible combinations.
    This is why octal and hexadecimal systems started to be used: they allow you to
    efficiently convert binary numbers. The octal system uses the base of 8, which
    means it can use digits from 0 to 7\. The hexadecimal system supports 16 digits,
    which were encoded using digits 0 to 9, followed by the first six letters of the
    English alphabet: A to F. Here, hexadecimal A stands for decimal 10, B stands
    for 11, and so on up to the maximum possible value of F, which stands for decimal
    15\. The way we use them is the same as for decimal and binary numeral systems:
    once the maximum digit on the right is reached, the next value would have dropped
    back to 0 and the digit to the left from it incremented while following the same
    logic. In this case, a decimal sequence such as *14, 15, 16, 17* will be represented
    as *E, F, 10, 11* in hexadecimal. To not confuse hexadecimal numbers with decimals,
    you can use the “0x” and “\x” prefixes or the “h” suffix to mark hexadecimal numbers
    (for example, 0x33, \x73, and 70h).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要处理二进制位组，我们需要选择组的大小。三个位组（从000到111）将给出2^3 = 8种可能的0和1的组合，允许我们编码八个不同的数字。类似地，四个位组（从0000到1111）将给出2^4
    = 16种可能的组合。这就是为什么开始使用八进制和十六进制系统：它们允许您有效地转换二进制数。八进制系统使用8为基数，这意味着它可以使用从0到7的数字。十六进制系统支持16个数字，使用数字0到9，然后是英语字母表的前六个字母：A到F。在这里，十六进制A代表十进制10，B代表11，依此类推，一直到F代表十进制15。我们使用它们的方式与十进制和二进制数制相同：一旦达到右侧的最大数字，下一个值将会回到0，并且左侧的数字按照相同的逻辑递增。在这种情况下，十进制序列如*14,
    15, 16, 17*将被表示为*E, F, 10, 11*的十六进制。为了不混淆十六进制数和十进制数，您可以使用“0x”和“\x”前缀或“h”后缀来标记十六进制数（例如，0x33,
    \x73 和 70h）。
- en: Converting binary values into hexadecimal is extremely easy. The whole binary
    value should be split into groups of four digits, where each group will represent
    a single hexadecimal digit. For example, 0001b = 1h and 00110001b comprising 0011b
    = 3h and 0001b = 1h gives us 31h.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制值转换为十六进制非常容易。整个二进制值应该分成四位一组，每组代表一个单独的十六进制数字。例如，0001b = 1h 和 00110001b 由0011b
    = 3h 和 0001b = 1h 组成，得到31h。
- en: Now, it is time to learn how different data types are encoded using this approach.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习如何使用这种方法编码不同的数据类型了。
- en: Basic data units and data types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数据单元和数据类型
- en: As we know, the smallest data storage unit should be able to store two different
    values – a 0 or a 1; that is, a single digit in the binary numeral system. This
    unit is called a **bit**. A group of 8 bits comprises a **byte**. A single byte
    can be used to encode all possible combinations of zeroes and ones from 00000000b
    to 11111111b, which gives us 2^8 = 256 different variants in total, from 0x0 to
    0xFF. Other widely used data units are **word** (2 bytes), **dword** (4 bytes),
    and **qword** (8 bytes).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，最小的数据存储单元应该能够存储两个不同的值——0或1；即二进制数字系统中的一个数字。这个单元叫做**比特**。8个比特组成一个**字节**。一个字节可以用来编码所有可能的零和一的组合，从00000000b到11111111b，总共可以有2^8
    = 256种不同的变体，从0x0到0xFF。其他常用的数据单元有**字**（2字节）、**双字**（4字节）和**四字**（8字节）。
- en: 'Now, let’s talk about how we can encode the data that’s stored using these
    data units. Here are some of the most common primitive data types found in various
    programming languages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈如何对使用这些数据单元存储的数据进行编码。以下是各种编程语言中常见的一些基本数据类型：
- en: '**Boolean**: A binary data type that can only store two possible values: true
    or false.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔型**：一种二进制数据类型，只能存储两个可能的值：真或假。'
- en: '**Integer**: This stores whole numbers. The size varies. In some cases, it
    can be specified as a suffix defining the number of bits (int16, int32, and so
    on).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：用于存储整数。大小各不相同。在某些情况下，可以通过后缀来指定位数（如int16、int32等）。'
- en: '**Unsigned**: All bits are dedicated to storing the numeric value.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无符号**：所有比特都用于存储数值。'
- en: '**Signed**: The most significant bit (the top left) is dedicated to storing
    the sign, 0 for plus and 1 for minus. So 0xFFFFFFFF = -1.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有符号**：最重要的比特（最左边的那个）用于存储符号，0表示正数，1表示负数。所以0xFFFFFFFF = -1。'
- en: '**Short** and **long**: These data types are integers that are smaller or bigger
    than the standard integer, respectively. The size is 2 bytes for short and 4 or
    8 bytes for long.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短整数**和**长整数**：这些数据类型是比标准整数小或大的整数。short的大小为2字节，long的大小为4或8字节。'
- en: '**Float** and **double**: These data types are designed to store floating-point
    numbers (values that can have fractions). They are pretty much never used in malware.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**和**双精度浮点数**：这些数据类型用于存储浮动点数（可以有小数的数值）。它们在恶意软件中几乎从不使用。'
- en: '**Char**: Generally used to store characters of strings, each value has a size
    of 1 byte.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符**：通常用于存储字符串中的字符，每个值的大小为1字节。'
- en: '**String**: A group of bytes that defines human-readable strings. It can utilize
    one or multiple bytes per character, depending on the encoding.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：由字节组成，定义了可读的字符串。根据编码方式，它可以使用每个字符一个或多个字节。'
- en: '**ASCII**: Defines the mappings between characters (letters, numbers, punctuation
    signs, and so on) and the byte values. It uses 7 bits per character:![Figure 2.1
    – ASCII table'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASCII**：定义了字符（字母、数字、标点符号等）与字节值之间的映射关系。每个字符使用7位：![图2.1 – ASCII表'
- en: '](img/Figure_2.1_B18500.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B18500.jpg)'
- en: Figure 2.1 – ASCII table
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – ASCII表
- en: Figure 2.1 – ASCII table
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – ASCII表
- en: '**Extended ASCII**: Utilizes 8 bits per character, where the first half (0x0-0x7F)
    is equal to the ASCII table and the rest depend on the code page (for example,
    Windows-1252 encoding).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展ASCII**：每个字符使用8位，其中前半部分（0x0-0x7F）与ASCII表相同，其余部分取决于代码页（例如Windows-1252编码）。'
- en: '**UTF8**: This is a Unicode encoding that uses 1 to 4 bytes per character.
    It’s commonly used in the *nix world. The beginning matches the ASCII table.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTF8**：这是一种Unicode编码，每个字符使用1到4个字节。它在*nix系统中常用。其起始部分与ASCII表匹配。'
- en: '**UTF16**: This is a Unicode encoding that uses 2 or 4 bytes per character.
    The order of the bytes depends on the endianness.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTF16**：这是一种Unicode编码，每个字符使用2或4个字节。字节的顺序取决于字节序（Endian）。'
- en: '**Little Endian**: The least significant byte goes to the lowest address (UTF16-LE,
    the default Unicode encoding used by the Windows OS; the corresponding strings
    are known as Wide strings there).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小端序**：最不重要的字节存放在最低地址（UTF16-LE，是Windows操作系统使用的默认Unicode编码；在该系统中，相关字符串称为宽字符字符串）。'
- en: '**Big Endian**: The most significant byte goes to the lowest address (UTF16-BE):'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大端序**：最重要的字节存放在最低地址（UTF16-BE）：'
- en: '![Figure 2.2 – Example of a UTF16-LE string'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – UTF16-LE字符串示例'
- en: '](img/Figure_2.2_B18500.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B18500.jpg)'
- en: Figure 2.2 – Example of a UTF16-LE string
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – UTF16-LE字符串示例
- en: Apart from knowing how the data can be stored using bits, it is also important
    to understand bitwise operations as they have multiple applications in assembly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了知道如何使用比特存储数据外，还需要理解按位操作，因为它们在汇编语言中有很多应用。
- en: Bitwise operations
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位操作
- en: Bitwise operations operate at the bit level and can be unary, which means they
    only require one operand, and binary, which means they work with two operands
    and apply the corresponding logic to each pair of the aligned bits. Because they
    are fast to perform, bitwise operations have found multiple applications in machine
    code. Let’s look at the most important ones.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按位操作在位级别上进行，可以是单目操作，这意味着它只需要一个操作数，也可以是双目操作，这意味着它需要两个操作数并将相应的逻辑应用于每一对对齐的位。由于它们执行起来非常快速，按位操作在机器代码中找到了多种应用。让我们看看最重要的一些应用。
- en: AND (&)
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与（AND，&）
- en: Here, the result bit will only be set (become equal to 1) if both corresponding
    operand bits are equal to 1\.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果位只有在两个对应操作数的位都为 1 时才会被设置（变为 1）。
- en: 'The following is an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '*10110111b*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*10110111b*'
- en: '*AND*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*与（AND）*'
- en: '*11001001b*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*11001001b*'
- en: '*=*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*=*'
- en: '*10000001b*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*10000001b*'
- en: 'The most common application of this operation in assembly is to separate part
    of the provided hexadecimal value (operand #1) by using a mask (operand #2) and
    nullify the rest. It is based on two features of this operation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '这种操作在汇编语言中最常见的应用是通过使用掩码（操作数 #2）来分离提供的十六进制值（操作数 #1）的一部分，并将其余部分置为零。它基于此操作的两个特性：'
- en: If one operand’s bit is set to 0, the result will always be 0
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数的位设置为 0，结果将始终为 0
- en: If one operand’s bit is set to 1, the result will be equal to another operand’s
    bit
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数的位设置为 1，结果将等于另一个操作数的位
- en: Therefore, *0x12345678 & 0x000000FF = 0x00000078* (as 0xFF = 11111111b).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*0x12345678 & 0x000000FF = 0x00000078*（因为 0xFF = 11111111b）。
- en: OR (|)
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或（OR，|）
- en: In this case, the result bit will be equal to 1 if any of the corresponding
    operand bits are equal to 1.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果位将为 1，只要任何对应的操作数位为 1。
- en: 'The following is an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '*10100101b*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*10100101b*'
- en: '*OR*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*或（OR）*'
- en: '*10001001b*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*10001001b*'
- en: '*=*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*=*'
- en: '*10101101b*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*10101101b*'
- en: 'Here, the common application of this operation is setting bits by mask while
    preserving the rest of the value. It is based on the following features of this
    operation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作的常见应用是通过掩码设置位，同时保留其余的值。它基于此操作的以下特性：
- en: If one operand’s bit is set to 0, the result will be equal to another operand’s
    bit
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数的位设置为 0，结果将等于另一个操作数的位
- en: If one operand’s bit is set to 1, the result will always be 1
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个操作数的位设置为 1，结果将始终为 1
- en: This way, *0x12345678 & 0x000000FF = 0x123456FF* (again, as *0xFF = 11111111b*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，*0x12345678 & 0x000000FF = 0x123456FF*（同样，*0xFF = 11111111b*）。
- en: XOR (^)
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异或（XOR，^）
- en: Here, the result bit will only be 1 if the corresponding operands’ bits are
    different. Otherwise, the result is 0.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果位只有在对应操作数的位不同的情况下才会为 1，否则结果为 0。
- en: 'The following is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '*11101001b*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*11101001b*'
- en: '*XOR*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*异或（XOR）*'
- en: '*10011100b*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*10011100b*'
- en: '*=*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*=*'
- en: '*01110101b*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*01110101b*'
- en: 'There are two very common applications of this operation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作有两个非常常见的应用：
- en: '**Nullification**: This is based on the principle that if we use the same value
    for both operands, all its bits will meet equal bits, so the whole result will
    be 0.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清零**：这一点基于以下原则，如果我们为两个操作数使用相同的值，那么它的所有位都会相等，因此整个结果将为 0。'
- en: '**Encryption**: This is based on the fact that applying this operation twice
    with the same key as one of the operands restores the original value. The actual
    property it is based on is that if one of the operands is 0, the result will be
    equal to another operand, and this is exactly what happens in the end:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：这一点基于这样的事实，即如果对同一个密钥的操作数应用两次此操作，将恢复原始值。它所基于的实际性质是，如果一个操作数是 0，结果将等于另一个操作数，这正是最终发生的情况：'
- en: '*plain_text ^ key = encrypted_text*'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*plain_text ^ key = encrypted_text*'
- en: '*encrypted_text ^ key = (plain_text ^ key) ^ key = plain_text ^ (key ^ key)
    = plain_text ^ 0 = plain_text*'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*encrypted_text ^ key = (plain_text ^ key) ^ key = plain_text ^ (key ^ key)
    = plain_text ^ 0 = plain_text*'
- en: Now let’s look at the NOT (~) operation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 NOT (~) 操作。
- en: NOT (~)
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非（NOT，~）
- en: Unlike the previous operations, this operation is unary and requires only one
    operand, flipping all its bits to the opposite ones.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的操作不同，这个操作是单目操作，只需要一个操作数，将其所有位反转为相反的值。
- en: 'The following is an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '*NOT*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*非（NOT）*'
- en: '*11001010b*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*11001010b*'
- en: '*=*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*=*'
- en: '*00110101b*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*00110101b*'
- en: The common application of this operation is to change the sign of signed integer
    values to the opposite one (for example, -3 to 3 or 5 to -5). The formula, in
    this case, will be *~value + 1*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作的常见应用是将有符号整数值的符号改变为相反的符号（例如，将 -3 转为 3，或者将 5 转为 -5）。在这种情况下，公式将是 *~value +
    1*。
- en: Now, let’s take a look at bit shifts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下位移操作。
- en: Logical shift (<< or >>)
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑移位（<< 或 >>）
- en: This operation requires the direction (left or right) to be specified, along
    with the actual value to change and the number of shift positions. During the
    shift, each bit of the original value will move to the left or right on the number
    of positions specified; the empty spaces on the opposite side are filled in with
    zeroes. All bits shifted outside of the data unit are lost.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作需要指定方向（左或右），以及实际的值要改变的数量和移位位置的数量。在移位过程中，原始值的每一位会根据指定的位数向左或向右移动；相对方向的空位则会用零填充。所有移出数据单元的位都将丢失。
- en: 'The following are some examples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '*10010011b >> 1 = 01001001b*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*10010011b >> 1 = 01001001b*'
- en: '*10010011b << 2 = 01001100b*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*10010011b << 2 = 01001100b*'
- en: 'There are two common applications of this operation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作有两个常见应用：
- en: Moving the data to a particular part of the register (as you’ll see shortly)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据移到寄存器的特定位置（如你稍后将看到的）
- en: Multiplication (shift left) or division (shift right) by a power of two for
    every shift position
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每移位一个位置时，乘以（左移）或除以（右移）二的幂
- en: Circular shift (Rotate)
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环移位（Rotate）
- en: This bitwise shift is very similar to the logical shift with one important difference
    – all the bits shifted out on one side of the data unit will appear on the opposite
    side.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种按位移位与逻辑移位非常相似，但有一个重要的区别——所有移出数据单元一侧的位将出现在对面一侧。
- en: 'The following are some examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '*10010011b ROR 1 = 11001001b*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*10010011b ROR 1 = 11001001b*'
- en: '*10010011b ROL 2 = 01001110b*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*10010011b ROL 2 = 01001110b*'
- en: Because, unlike logical shift, the operation is reversible and the data is not
    lost, it can be used in cryptography algorithms.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为与逻辑移位不同，该操作是可逆的，数据不会丢失，所以它可以在加密算法中使用。
- en: Other types of shifts, such as arithmetic shift or rotate with carrying, are
    present much more rarely in the assembly in general and in malware in particular,
    so they are outside the scope of this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的移位，如算术移位或带进位的旋转，在汇编中一般较少见，尤其是在恶意软件中，因此它们超出了本书的讨论范围。
- en: Now, it is finally time to start learning more about various architectures and
    their assembly instructions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于到了学习更多关于各种架构及其汇编指令的时机。
- en: Architectures and their assembly
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构及其汇编
- en: 'Simply put, the processor, also known as the **central processing unit** (**CPU**),
    is quite similar to a calculator. If you look at the instructions (whatever the
    assembly language is), you will find many of them dealing with numbers and doing
    some calculations. However, multiple features differentiate processors from usual
    calculators. Let’s look at some examples:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，处理器，也就是**中央处理单元**（**CPU**），与计算器非常相似。如果你查看指令（无论是哪种汇编语言），你会发现许多指令涉及数字并进行计算。然而，多个特性使得处理器与普通计算器有所不同。让我们来看一些示例：
- en: Modern processors support a much bigger memory space compared to traditional
    calculators. This memory space allows them to store billions of values, which
    makes it possible to perform more complex operations. Additionally, they have
    multiple fast and small memory storage units embedded inside the processors’ chips
    called registers.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代处理器相较于传统计算器支持更大的内存空间。这个内存空间允许它们存储数十亿个值，从而使得执行更复杂的操作成为可能。此外，处理器内部嵌入了多个快速且小型的内存存储单元，称为寄存器。
- en: Processors support many instruction types other than arithmetic instructions,
    such as changing the execution flow based on certain conditions.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器支持多种除算术指令外的其他指令类型，如根据特定条件更改执行流程。
- en: Processors can work in conjunction with other peripheral devices such as speakers,
    microphones, hard disks, graphics cards, and others.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器可以与其他外部设备如扬声器、麦克风、硬盘、显卡等一起工作。
- en: Armed with such features and coupled with great flexibility, processors became
    the go-to universal machines to power various advanced modern technologies such
    as machine learning. In the following sections, we will explore these features
    before diving deeper into different assembly languages and how these features
    are manifested in these languages’ instruction sets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些功能和极大的灵活性，处理器成为了支撑各种先进现代技术（如机器学习）的通用机器。在接下来的部分中，我们将探索这些特性，并进一步深入了解不同的汇编语言以及这些特性如何在这些语言的指令集中体现。
- en: Registers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器
- en: Even though processors have access to a huge memory space that can store billions
    of values, this storage is provided by separate RAM devices, which makes it longer
    for the processors to access the data. So, to speed up the processor operations,
    they contain small and fast internal memory storage units called registers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管处理器能够访问巨大的内存空间，可以存储数十亿个值，但这些存储是由独立的RAM设备提供的，这使得处理器访问数据的速度较慢。因此，为了加速处理器操作，处理器内部含有小而快速的内存存储单元，称为寄存器。
- en: Registers are built into the processor chip and can store the immediate values
    that are needed while performing calculations and data transfers from one place
    to another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器内置于处理器芯片中，可以存储在执行计算和数据传输时所需的即时值。
- en: 'Registers may have different names, sizes, and functions, depending on the
    architecture. Here are some of the types that are widely used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器可能有不同的名称、大小和功能，具体取决于架构。以下是一些广泛使用的类型：
- en: '**General-purpose registers**: These are registers that are used to temporarily
    store arguments and results for various arithmetic, bitwise, and data transfer
    operations.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用寄存器**：这些寄存器用于临时存储各种算术、按位和数据传输操作的参数和结果。'
- en: '**Stack and frame pointers**: These point to the top and a certain fixed point
    of the stack (as you’ll see shortly).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈和帧指针**：这些指向栈的顶部和某个固定点（稍后会看到）。'
- en: '**Instruction pointer/program counter**: The instruction pointer is used to
    point to the next instruction to be executed by the processor.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令指针/程序计数器**：指令指针用于指向处理器将要执行的下一条指令。'
- en: Memory
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: Memory plays an important role in the development of all the smart devices that
    we use nowadays. The ability to manage lots of values, text, images, and videos
    on a fast and volatile memory allows CPUs to process more information and, eventually,
    perform more complicated operations, such as displaying graphical interfaces in
    3D and virtual reality.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内存在我们今天使用的所有智能设备的开发中扮演着重要角色。在快速且易失的内存上管理大量的值、文本、图像和视频的能力，使得CPU能够处理更多信息，最终执行更复杂的操作，如显示3D图形界面和虚拟现实。
- en: Virtual memory
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟内存
- en: In modern OSs, whether they are 32-bit or 64-bit based, the OS creates an isolated
    virtual memory (in which its pages are mapped to the physical memory pages) for
    each process. Applications are only supposed to have the ability to access their
    virtual memory. They can read and write code and data and execute instructions
    located in virtual memory. Each memory range that comprises virtual memory pages
    has a set of permissions, also known as protection flags, assigned to it, which
    represents the types of operations the application is allowed to perform on it.
    Some of the most important of them are READ, WRITE, and EXECUTE, as well as their
    combinations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代操作系统中，无论是基于32位还是64位，操作系统都会为每个进程创建一个隔离的虚拟内存（其页面会映射到物理内存页面）。应用程序只能访问它们的虚拟内存。它们可以读取和写入代码和数据，并执行位于虚拟内存中的指令。每个包含虚拟内存页面的内存范围都有一组权限，也称为保护标志，表示应用程序可以在其上执行的操作类型。其中最重要的一些权限包括READ、WRITE和EXECUTE，以及它们的组合。
- en: 'For an application to attempt to access a value stored in memory, it needs
    its virtual address. Behind the scenes, the **Memory Management Unit** (**MMU**)
    and the OS are transparently mapping these virtual addresses to physical addresses
    that define where the values are stored in hardware:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让应用程序尝试访问存储在内存中的值，它需要其虚拟地址。在幕后，**内存管理单元**（**MMU**）和操作系统透明地将这些虚拟地址映射到定义值在硬件中存储位置的物理地址：
- en: '![Figure 2.3 – Virtual memory addresses'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 虚拟内存地址'
- en: '](img/Figure_2.3_B18500.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B18500.jpg)'
- en: Figure 2.3 – Virtual memory addresses
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 虚拟内存地址
- en: To save the space that’s required to store and use addresses of values, the
    concept of the stack has been developed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省存储和使用值地址所需的空间，开发了栈的概念。
- en: Stack
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is a pile of objects. In computer science, the stack is a data structure
    that helps save different values of the same size in memory in a pile structure
    using the principle of **Last In First Out** (**LIFO**).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个堆叠的对象。在计算机科学中，栈是一种数据结构，它利用**后进先出**（**LIFO**）原则，将不同大小的值按堆叠结构保存在内存中。
- en: The top of the stack (where the next element will be placed) is pointed to by
    a dedicated stack pointer, which will be discussed in greater detail shortly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的顶部（下一个元素将被放置的位置）由专用的栈指针指向，稍后会对其进行更详细的讨论。
- en: A stack is common among many assembly languages and it may serve multiple purposes.
    For example, it may help in solving mathematical equations, such as *X = 5*6 +
    6*2 + 7(4 + 6)*, by temporarily storing each calculated value and later pulling
    them back to calculate the sum of all of them and saving them in a variable, *X*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在许多汇编语言中是常见的，它可以服务于多个目的。例如，它可以通过临时存储每个计算结果，然后将它们提取出来以计算所有结果的总和，并将其保存在变量*X*中，来帮助解决数学方程式，如
    *X = 5*6 + 6*2 + 7(4 + 6)*。
- en: Another application for the stack is to pass arguments to functions and store
    local variables. Finally, on some architectures, a stack can also be used to save
    the address of the next instruction before calling a function. This way, once
    this function finishes executing, it is possible to pop this return address back
    from the top of the stack and transfer control to where it was called from to
    continue the execution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的另一个应用是传递参数给函数并存储局部变量。最后，在某些架构上，栈还可以用来在调用函数之前保存下一条指令的地址。这样，一旦该函数执行完毕，就可以从栈顶弹出该返回地址，并将控制权转移回调用它的地方，继续执行。
- en: While the stack pointer is always pointing to the current top of the stack,
    the frame pointer is storing the address of the top of the stack at the beginning
    of the function to make it possible to access passed arguments and local variables,
    and also restore the stack pointer value at the end of the routine. We will cover
    this in greater detail when we talk about calling conventions for different architectures.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然栈指针始终指向当前栈顶，但帧指针则存储函数开始时栈顶的地址，以便能够访问传递的参数和局部变量，并在例程结束时恢复栈指针的值。我们将在讨论不同架构的调用约定时更详细地介绍这一点。
- en: Instructions (CISC and RISC)
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令（CISC 和 RISC）
- en: Instructions are machine code represented in the form of bytes that CPUs can
    understand and execute. For us humans, reading bytes is extremely problematic,
    which is why we developed assemblers to convert assembly code into instructions
    and disassemblers to be able to read it back.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是以字节形式表示的机器码，CPU 可以理解并执行它们。对于我们人类来说，读取字节非常困难，这就是为什么我们开发了汇编器来将汇编代码转换为指令，并开发了解析器以便能够将其读回。
- en: 'Two big groups of architectures define assembly languages that we will cover
    in this section: **Complex Instruction Set Computer** (**CISC**) and **Reduced
    Instruction Set Computer** (**RISC**).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍定义汇编语言的两大类架构：**复杂指令集计算机**（**CISC**）和**简化指令集计算机**（**RISC**）。
- en: Without going into too many details, the main difference between CISC assemblies,
    such as Intel IA-32 and x64, and RISC assembly languages associated with architectures
    such as ARM is the complexity of their instructions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，CISC 汇编语言（如 Intel IA-32 和 x64）与与 ARM 等架构相关的 RISC 汇编语言之间的主要区别在于其指令的复杂性。
- en: CISC assembly languages have more complex instructions. They generally focus
    on completing tasks using as few lines of assembly instructions as possible. To
    do that, CISC assembly languages include instructions that can perform multiple
    operations, such as *mul* in Intel assembly, which performs data access, multiplication,
    and data store operations in one go.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CISC 汇编语言的指令更为复杂。它们通常侧重于使用尽可能少的汇编指令完成任务。为了做到这一点，CISC 汇编语言包括可以执行多个操作的指令，例如 Intel
    汇编中的 *mul* 指令，它可以同时执行数据访问、乘法和数据存储操作。
- en: In the RISC assembly language, assembly instructions are simple and generally
    perform only one operation each. This may lead to more lines of code to complete
    a specific task. However, it may also be more efficient, as this omits the execution
    of any unnecessary operations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RISC 汇编语言中，汇编指令通常很简单，一般只执行一个操作。这可能导致为完成特定任务需要更多的代码行。然而，这也可能更加高效，因为它省略了任何不必要的操作。
- en: 'Overall, we can split all the instructions, regardless of the architecture,
    into several groups:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们可以将所有指令（无论架构如何）分为几组：
- en: '**Data manipulation**: This comprises arithmetic and bitwise operations.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据操作**：包括算术和按位操作。'
- en: '**Data transfer**: Allows data that may involve registers, memory, and immediate
    values to be moved.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输**：允许涉及寄存器、内存和立即数值的数据进行移动。'
- en: '**Control flow**: This makes it possible to change the order the instructions
    are executed in. In every assembly language, there are multiple comparison and
    control flow instructions, which can be divided into the following categories:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制流**：这使得可以改变指令执行的顺序。在每种汇编语言中，都有多种比较和控制流指令，通常可以分为以下几类：'
- en: '**Unconditional**: This type of instruction forcefully changes the flow of
    the execution to another address (without any given condition).'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无条件**：这种类型的指令会强制改变执行流转到另一个地址（没有任何给定条件）。'
- en: '**Conditional**: This is like a logical gate that switches to another branch
    based on a given condition (such as equal to zero, greater than, or less than),
    as shown in the following diagram:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：这就像一个逻辑门，根据给定的条件（如等于零、大于或小于）切换到另一个分支，如下图所示：'
- en: '![Figure 2.4 – An example of a conditional jump'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 条件跳转的示例'
- en: '](img/Figure_2.4_B18500.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B18500.jpg)'
- en: Figure 2.4 – An example of a conditional jump
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 条件跳转的示例
- en: '**Subroutine call**: These instructions change the execution to another function
    and save the return address to be restored later when necessary.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子程序调用**：这些指令会将执行转移到另一个函数，并保存返回地址，以便在必要时恢复。'
- en: Now, it is time to learn about the most common instructions that you may see
    when performing reverse engineering. Becoming able to read them fluently and understand
    the meaning of groups of them is an important step in the journey of becoming
    a professional malware analyst.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习在进行逆向工程时常见的指令了。能够流利地阅读这些指令并理解它们组合的含义，是成为专业恶意软件分析师的一个重要步骤。
- en: Becoming familiar with x86 (IA-32 and x64)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 x86（IA-32 和 x64）
- en: Intel x86 (including both 32 and 64-bit versions) is the most common architecture
    used in PCs. It powers various types of workstations and servers, so it comes
    as no surprise that most of the malware samples we have at the moment support
    it. The 32-bit version of it, IA-32, is also commonly referred to as i386 (succeeded
    by i686) or even simply x86, while the 64-bit version, x64, is also known as x86-64
    or AMD64\. x86 is a CISC architecture, and it includes multiple complex instructions
    in addition to simple ones. In this section, we will introduce the most common
    of them and cover how the functions are organized.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Intel x86（包括 32 位和 64 位版本）是 PC 中最常见的架构。它为各种类型的工作站和服务器提供支持，因此我们目前看到的大多数恶意软件样本都支持该架构。其
    32 位版本 IA-32 也通常被称为 i386（由 i686 替代）或简单地称为 x86，而 64 位版本 x64 也被称为 x86-64 或 AMD64。x86
    是一个 CISC 架构，除了简单指令外，还包含多个复杂指令。在这一部分，我们将介绍其中最常见的指令，并介绍函数是如何组织的。
- en: Registers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器
- en: 'The following table shows the relationship between the registers in the IA-32
    and x64 architectures:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 IA-32 和 x64 架构中寄存器之间的关系：
- en: '![Figure 2.5 – IA-32 and x64 architectures'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – IA-32 和 x64 架构'
- en: '](img/Figure_2.5_B18500.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B18500.jpg)'
- en: Figure 2.5 – IA-32 and x64 architectures
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – IA-32 和 x64 架构
- en: The registers that are used in the x86 architectures (the 8 to r15 registers)
    are only available in x64, not IA-32, and the spl, bpl, sil, and dil registers
    can only be accessed in x64.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86 架构中使用的寄存器（从 8 到 r15 的寄存器）仅在 x64 中可用，而在 IA-32 中不可用，且 spl、bpl、sil 和 dil
    寄存器只能在 x64 中访问。
- en: The first thing to mention is that there may be multiple interpretations of
    what registers should be called **general-purpose registers** (**GPRs**) and which
    are not since most of them may serve some particular purpose.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要提到的是，关于哪些寄存器应该称为**通用寄存器**（**GPRs**）以及哪些不应如此，可能有多种解释，因为它们中的大多数可能用于某些特定目的。
- en: 'The first four registers (**rax/eax**, **rbx/ebx**, **rcx/ecx**, and **rdx/edx**)
    are GPRs. Some of them have special use cases for certain instructions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个寄存器（**rax/eax**、**rbx/ebx**、**rcx/ecx**、和 **rdx/edx**）是 GPRs。它们中的一些寄存器在特定指令中有特殊的用途：
- en: '**rax/eax**: This is commonly used to store the result of some operations and
    the return values of functions.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rax/eax**：这通常用于存储某些操作的结果以及函数的返回值。'
- en: '**rcx/ecx**: This is used as a counter register in instructions that’s responsible
    for repeating actions.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rcx/ecx**：这是在需要重复操作的指令中用作计数寄存器的。'
- en: '**rdx/edx**: This is used in multiplication and division to extend the result
    or the dividend, respectively.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rdx/edx**：这是在乘法和除法中使用的，分别用来扩展结果或被除数。'
- en: In x64, the registers from r8 to r15 were added to the list of available GPRs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x64 中，r8 到 r15 的寄存器被添加到可用的 GPRs 列表中。
- en: '**rsi/esi** and **rdi/edi** are mostly used to define addresses when copying
    groups of bytes in memory. The rsi/esi register always plays the role of the source,
    while the rdi/edi register plays the role of the destination. Both registers are
    non-volatile and are also GPRs.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**rsi/esi** 和 **rdi/edi** 主要用于定义在内存中复制字节组的地址。rsi/esi 寄存器始终充当源寄存器，而 rdi/edi
    寄存器充当目标寄存器。这两个寄存器都是非易失性的，并且也是 GPR 寄存器。'
- en: The **rsp/esp** register is used as a stack pointer, which means it always points
    to the top of the stack. Its value decreases when a value is getting pushed to
    the stack, and increases when a value is getting pulled out from the stack.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**rsp/esp** 寄存器作为栈指针使用，这意味着它始终指向栈顶。当一个值被推送到栈时，它的值会减小，而当一个值被从栈中取出时，它的值会增大。'
- en: The **rbp/ebp** register is mainly used as a base pointer that indicates a fixed
    place within the stack. It helps access the function’s local variables and arguments,
    as we will see later in this section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**rbp/ebp** 寄存器主要作为基指针使用，指示栈中的一个固定位置。它帮助访问函数的局部变量和参数，稍后在本节中我们会看到。'
- en: Special registers
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊寄存器
- en: 'There are two special registers in the x86 assembly, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: x86 汇编中有两个特殊的寄存器，如下所示：
- en: '**rip/eip**: This is an instruction pointer that points to the next instruction
    to be executed. It cannot be accessed directly but there are special instructions
    that work with it.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rip/eip**：这是一个指令指针，指向下一个将要执行的指令。它不能直接访问，但有一些特殊的指令可以与其一起使用。'
- en: '**rflags/eflags/flags**: This register contains the current state of the processor.
    Its flags are affected by the arithmetic and logical instructions, including comparison
    instructions such as *cmp* and *test*, and it’s used with conditional jumps and
    other instructions as well. Here are some of its flags:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rflags/eflags/flags**：该寄存器包含处理器的当前状态。其标志位会受到算术和逻辑指令的影响，包括比较指令，如 *cmp* 和 *test*，并且它也用于条件跳转和其他指令。以下是其中的一些标志：'
- en: '**Carry flag** (**CF**): This flag is set when an arithmetic operation goes
    out of bounds, as follows:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进位标志**（**CF**）：当算术操作超出范围时，设置该标志，如下所示：'
- en: '`mov al, FFh ; al = 0xFF & CF = 0`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov al, FFh ; al = 0xFF & CF = 0`'
- en: '`add al, 1 ; al = 0 & CF = 1`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`add al, 1 ; al = 0 & CF = 1`'
- en: '**Zero flag** (**ZF**): This flag is set when the arithmetic or a logical operation’s
    result is zero. This can also be set by comparison instructions.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零标志**（**ZF**）：当算术或逻辑操作的结果为零时，设置该标志。比较指令也可以设置此标志。'
- en: '**Direction flag** (**DF**): This indicates whether certain instructions such
    as *lods*, *stos*, *scas*, and *movs* (as you’ll see shortly) should go to higher
    addresses (when not set) or to lower addresses (when set).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向标志**（**DF**）：该标志指示某些指令，如 *lods*，*stos*，*scas* 和 *movs*（稍后将看到），应当访问更高地址（当未设置时）还是更低地址（当设置时）。'
- en: '**Sign flag** (**SF**): This flag indicates that the result of the operation
    is negative.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号标志**（**SF**）：该标志指示操作结果为负值。'
- en: '**Overflow flag** (**OF**): This flag indicates that an overflow occurred in
    an operation, leading to a change in the sign (only for signed numbers), as follows:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**溢出标志**（**OF**）：该标志指示操作中发生了溢出，导致符号发生变化（仅对有符号数有效），如下所示：'
- en: '`mov cl, 7Fh ; cl = 0x7F (127) & OF = 0`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov cl, 7Fh ; cl = 0x7F (127) & OF = 0`'
- en: '`inc cl ; cl = 0x80 (-128) & OF = 1`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc cl ; cl = 0x80 (-128) & OF = 1`'
- en: There are other registers as well, such as the MMX and FPU registers (and instructions
    to work with them), but they are rarely used in malware, so they are outside the
    scope of this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他寄存器，例如 MMX 和 FPU 寄存器（以及与之配套的指令），但它们在恶意软件中很少使用，因此它们不在本书的讨论范围内。
- en: The instruction structure
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令结构
- en: Many x86 assemblers, such as MASM and NASM, as well as disassemblers, use Intel
    syntax. In this case, the common structure of its instructions is *opcode*, *dest*,
    *src*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 x86 汇编器，如 MASM 和 NASM，以及反汇编器，都使用 Intel 语法。在这种情况下，其指令的常见结构是 *opcode*，*dest*，*src*。
- en: '*dest* and *src* are commonly referred to as **operands**. Their numbers can
    vary from 0 to 3, depending on the instruction. Another option would be **GNU
    Assembler** (**GAS**), which uses the AT&T syntax and swaps *dest* and *src* for
    representation. Throughout this book, we will use Intel syntax.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*dest* 和 *src* 通常被称为 **操作数**。它们的数量可以根据指令的不同从 0 到 3 不等。另一种选择是 **GNU 汇编器**（**GAS**），它使用
    AT&T 语法，并交换 *dest* 和 *src* 来表示。本文中，我们将使用 Intel 语法。'
- en: Now, let’s dive deeper into the meaning of each part of the instruction.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解每个指令部分的含义。
- en: opcode
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: opcode
- en: '`n``op`, `pushad`, `popad`, and `movsb`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`n``op`，`pushad`，`popad` 和 `movsb`。'
- en: Important Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`pushad` and `popad` are not available in x64.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushad`和`popad`在x64架构中不可用。'
- en: dest
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dest
- en: '*dest* represents the destination, or where the result of the operation will
    be saved, and can also become part of the calculations themselves, like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*dest*表示目标，即操作结果将被保存的位置，也可以成为计算的一部分，如下所示：'
- en: '`add eax, ecx ; eax = (eax + ecx)`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`add eax, ecx ; eax = (eax + ecx)`'
- en: '`sub rdx, rcx ; rdx = (rdx - rcx)`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub rdx, rcx ; rdx = (rdx - rcx)`'
- en: '*dest* could look as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*dest*可能如下所示：'
- en: '**REG**: A register, such as eax or edx.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REG**：一个寄存器，例如eax或edx。'
- en: '**r/m**: A place in memory, such as the following:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r/m**：内存中的一个位置，例如以下所示：'
- en: '*DWORD PTR [00401000h]*'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DWORD PTR [00401000h]*'
- en: '*BYTE PTR [EAX + 00401000h]*'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BYTE PTR [EAX + 00401000h]*'
- en: '*WORD PTR [EDX*4 + EAX+ 30]*'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WORD PTR [EDX*4 + EAX+ 30]*'
- en: 'The stack is also a place in memory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 栈也是内存中的一个地方：
- en: '*DWORD PTR [ESP+4]*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DWORD PTR [ESP+4]*'
- en: '*DWORD PTR [EBP-8]*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DWORD PTR [EBP-8]*'
- en: src
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: src
- en: '*src* represents the source or another value in the calculations, but it is
    not used to save the results there afterward. It may look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*src*表示计算中的源值或其他值，但它不会用于保存结果。它可能如下所示：'
- en: '`add rcx, r8`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add rcx, r8`'
- en: '`add ecx, DWORD PTR [00401000h]`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add ecx, DWORD PTR [00401000h]`'
- en: Here, we are adding the value of the size of DWORD located at the 00401000h
    address to ecx.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们将位于00401000h地址的DWORD的大小值加到ecx寄存器中。
- en: '`mov eax, 00100000h`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mov eax, 00100000h`'
- en: 'For instructions with a single operand, it may play a role of both a source
    and a destination:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有一个操作数的指令，它可能同时充当源和目标：
- en: '`inc eax`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc eax`'
- en: '`dec ecx`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`dec ecx`'
- en: 'Or, it could be only the source or the destination. This is the case for the
    following instructions, which save the value on the stack and then pull it back:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可能只是源或目标。这适用于以下指令，这些指令将值保存到栈中，然后再将其取回：
- en: '`push rdx`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`push rdx`'
- en: '`pop rcx`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop rcx`'
- en: The instruction set
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: In this section, we will cover the most important instructions required to start
    reading the assembly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍开始阅读汇编所需的最重要指令。
- en: Data manipulation instructions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据操作指令
- en: 'Some of the most common arithmetic instructions are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常见的算术指令如下所示：
- en: '![](img/Table_2.1_B18500.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.1_B18500.jpg)'
- en: Important Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For multiplication and division, which treat operands as signed integers, the
    corresponding instructions will be `imul` and `idiv`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将操作数视为有符号整数的乘法和除法，相应的指令将是`imul`和`idiv`。
- en: 'The following instructions represent logical/bitwise operations:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令表示逻辑/位操作：
- en: '![](img/Table_2.2_B18500.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.2_B18500.jpg)'
- en: 'Lastly, the following instructions represent bitwise shifts and rotations:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下指令表示位移和旋转操作：
- en: '![](img/Table_2.3_B18500.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.3_B18500.jpg)'
- en: To learn more about the potential applications of bitwise operations, please
    read [*Chapter 1*](B18500_01.xhtml#_idTextAnchor014), *Cybercrime, APT Attacks,
    and Research Strategies*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于位运算的潜在应用，请阅读[*第一章*](B18500_01.xhtml#_idTextAnchor014)，*网络犯罪、APT攻击与研究策略*。
- en: Data transfer instructions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据传输指令
- en: 'The most basic instruction for moving the data is `mov`, which copies a value
    from *src* to *dest*. This instruction has multiple forms, as shown in the following
    table:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 移动数据的最基本指令是`mov`，它将*src*的值复制到*dest*。该指令有多种形式，如下表所示：
- en: '![](img/Table_2.4_B18500.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.4_B18500.jpg)'
- en: 'Here are the instructions related to the stack:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与栈相关的指令：
- en: '![](img/Table_2.5_B18500.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.5_B18500.jpg)'
- en: 'Here are the string manipulation instructions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是字符串操作指令：
- en: '![](img/Table_2.6_B18500.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.6_B18500.jpg)'
- en: Important Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If the DF bit in the EFLAGS register is 0, these instructions will increase
    the value of the rdi/edi or rsi/esi register by the number of bytes used (1, 2,
    4, or 8) and decrease if the DF bit is set (equals 1).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果EFLAGS寄存器中的DF位为0，这些指令将根据使用的字节数（1, 2, 4或8）增加rdi/edi或rsi/esi寄存器的值，如果DF位被设置（等于1），则会减少该值。
- en: Control flow instructions
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流指令
- en: 'These instructions change the value of the rip/eip register so that the instructions
    to be executed next may not be the next ones sequentially. The most important
    unconditional redirections are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令会改变rip/eip寄存器的值，因此接下来要执行的指令可能不是顺序上的下一条。最重要的无条件跳转指令如下：
- en: '![](img/Table_2.7_B18500.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.7_B18500.jpg)'
- en: 'To implement the condition, some form of comparison needs to be used. There
    are dedicated instructions for that:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现条件，需要使用某种形式的比较。有专门的指令来实现这一点：
- en: '![](img/Table_2.8_B18500.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.8_B18500.jpg)'
- en: 'The following table shows some of the most important conditional redirections
    based on the result of this comparison:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了基于此比较结果的一些最重要的条件重定向：
- en: '![](img/Table_2.9_B18500.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.9_B18500.jpg)'
- en: Now, let’s talk about how values can be passed to functions and accessed there.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈如何将值传递给函数并在函数中访问它们。
- en: Arguments, local variables, and calling conventions (in x86 and x64)
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数、局部变量和调用约定（在x86和x64中）
- en: Arguments can be passed to functions in various ways. These ways are called
    **calling conventions**. In this section, we will cover the most common ones.
    We will start with the **standard call** (**stdcall**) convention, which is commonly
    used in IA-32, and then cover the differences between it and other conventions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过多种方式传递给函数。这些方式被称为**调用约定**。在本节中，我们将介绍最常见的调用约定。我们将从**标准调用**（**stdcall**）约定开始，它通常用于IA-32架构，然后介绍它与其他约定之间的差异。
- en: stdcall
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stdcall
- en: The stack, together with the rsp/esp and rbp/ebp registers, does most of the
    work when it comes to arguments and local variables. The `call` instruction saves
    the return address at the top of the stack before transferring the execution to
    the new function, while the `ret` instruction at the end of the function returns
    the execution to the caller function using the return address saved in the stack.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈，以及rsp/esp和rbp/ebp寄存器，在处理参数和局部变量时承担了大部分工作。`call`指令在将执行转移到新函数之前，将返回地址保存到堆栈的顶部，而`ret`指令在函数结束时通过堆栈中保存的返回地址将执行返回给调用者函数。
- en: Arguments
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: 'In stdcall, the arguments are pushed in the stack from the last argument to
    the first *(right to left)*, like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在stdcall中，参数从最后一个到第一个（*从右到左*）被压入堆栈，如下所示：
- en: '[PRE0]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `Func01` function, the arguments could be accessed by `esp`, but it
    would be hard to always adjust the offset with every next value that’s pushed
    or pulled:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Func01`函数中，参数可以通过`esp`访问，但每次有新值被推入或弹出时，始终调整偏移量会很困难：
- en: '[PRE1]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fortunately, modern static analysis tools, such as `ebp`. First, the called
    function needs to save the current `esp` in the `ebp` register and then access
    it, like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现代静态分析工具，如`ebp`。首先，被调用的函数需要将当前的`esp`保存在`ebp`寄存器中，然后再访问它，如下所示：
- en: '[PRE2]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the end of the called function, it returns the original values of `ebp`
    and `esp`, like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在被调用函数的末尾，它会返回原始的`ebp`和`esp`值，如下所示：
- en: '[PRE3]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As it’s a common function epilogue, Intel created a special instruction for
    it, called
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是常见的函数尾部处理，Intel为此创建了一个特殊的指令，称为
- en: '`leave`, so it became as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`leave`，因此变成如下：'
- en: '[PRE4]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Local variables
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'For local variables, the called function allocates space for them by decreasing
    the value of the `esp` register. To allocate space for two variables of four bytes
    each, use the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部变量，被调用的函数通过减小`esp`寄存器的值来为它们分配空间。要为两个每个4字节的变量分配空间，可以使用以下代码：
- en: '[PRE5]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, the end of the function will look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，函数的结尾将如下所示：
- en: '[PRE6]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following figure exemplifies how the stack change looks at the beginning
    and the end of the function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示例展示了函数开始和结束时堆栈变化的样子：
- en: '![Figure 2.6 – An example of a stack change at the beginning and the end of
    the function'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 函数开始和结束时堆栈变化的示例'
- en: '](img/Figure_2.6_B18500.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Figure_2.6_B18500.jpg)'
- en: Figure 2.6 – An example of a stack change at the beginning and the end of the
    function
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 函数开始和结束时堆栈变化的示例
- en: 'Additionally, if there are arguments, the `ret` instruction cleans the stack,
    given the number of bytes to pull out from the top of the stack, like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果有参数，`ret`指令会根据需要从堆栈顶部弹出相应的字节，从而清理堆栈，如下所示：
- en: '[PRE7]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: cdecl
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cdecl
- en: '*cdecl* (which stands for C declaration) is another calling convention that
    was used by many C compilers in x86\. It’s very similar to stdcall, with the only
    difference being that the caller cleans the stack after the callee function (the
    called function) returns, like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*cdecl*（代表C声明）是另一种调用约定，许多C编译器在x86中使用过它。它与stdcall非常相似，唯一的区别是调用者在被调用函数（即被调用的函数）返回后清理堆栈，如下所示：'
- en: '[PRE8]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: fastcall
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fastcall
- en: The *fastcall* calling convention is also widely used by different compilers,
    including the Microsoft C++ compiler and GCC. This calling convention passes the
    first two arguments in ecx and edx and passes the remaining arguments through
    the stack. Again, it is only used in the 32-bit version of x86.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*fastcall*调用约定也被不同的编译器广泛使用，包括Microsoft C++编译器和GCC。此调用约定将前两个参数传递给ecx和edx，将其余的参数通过堆栈传递。同样，它仅在x86的32位版本中使用。'
- en: thiscall
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: thiscall
- en: For object-oriented programming and non-static member functions (such as the
    classes’ functions), the C compiler needs to pass the address of the object whose
    attribute will be accessed or manipulated using it as an argument.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象编程和非静态成员函数（例如类的函数），C编译器需要将将要访问或操作其属性的对象的地址作为参数传递。
- en: In the GCC compiler, *thiscall* is almost identical to the cdecl calling convention
    and it passes the current object’s address (that is, *this*) as the first argument.
    But in the Microsoft C++ compiler, it’s similar to stdcall and passes the object’s
    address in ecx. It’s common to see such patterns in some object-oriented malware
    families.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCC编译器中，*thiscall*几乎与cdecl调用约定相同，并且将当前对象的地址（即，*this*）作为第一个参数传递。但在Microsoft
    C++编译器中，它类似于stdcall，并将对象的地址传递给ecx。这样的模式在某些面向对象的恶意软件家族中很常见。
- en: Borland register
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Borland寄存器
- en: This convention can be commonly seen in malware written in the Delphi programming
    language. The first three arguments are passed through the eax, edx, and ecx registers
    while the rest go through the stack. However, unlike other conventions, they are
    passed in the opposite order – *from left to right*. If necessary, it will be
    the callee (called function) who cleans up the stack.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定通常出现在使用Delphi编程语言编写的恶意软件中。前三个参数通过eax、edx和ecx寄存器传递，而其余参数通过堆栈传递。然而，与其他约定不同的是，它们按相反的顺序传递——*从左到右*。如果有必要，堆栈清理工作将由被调用函数（callee）来完成。
- en: Microsoft x64 calling convention
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft x64调用约定
- en: 'In x64, the calling conventions are more dependent on the registers. For Windows,
    the caller function passes the first four arguments to the registers in the following
    order: rcx, rdx, r8, r9\. The rest are passed through the stack. The calling function
    (caller) cleans the stack in the end (if necessary).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在x64中，调用约定更加依赖于寄存器。对于Windows，调用函数按照以下顺序将前四个参数传递给寄存器：rcx、rdx、r8、r9。其余的通过堆栈传递。调用函数（caller）最终清理堆栈（如果有必要）。
- en: System V AMD64 ABI
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: System V AMD64 ABI
- en: 'For other 64-bit OSs such as Linux, FreeBSD, or macOS, the first six arguments
    are passed to the registers in this order: rdi, rsi, rdx, rcx, r8, r9\. The remaining
    get passed through the stack. Again, it is the caller who cleans the stack in
    the end, if necessary. This is the only way to do this on 64-bit OSs.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他64位操作系统，如Linux、FreeBSD或macOS，前六个参数按以下顺序传递给寄存器：rdi、rsi、rdx、rcx、r8、r9。其余的通过堆栈传递。同样，如果有必要，最终由调用者清理堆栈。这是64位操作系统上唯一的处理方式。
- en: Exploring ARM assembly
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索ARM汇编
- en: Most of you are probably more familiar with the x86 architecture, which implements
    the CISC design. So, you may be wondering, *why do we need something else?* The
    main advantage of RISC architectures is that the processors that implement them
    generally require fewer transistors, which eventually makes them more energy and
    heat-efficient and reduces the associated manufacturing costs, making them a better
    choice for portable devices. We have started our introduction to RISC architectures
    with ARM for a good reason – at the time of writing, this is the most widely used
    architecture in the world.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你们大多数人可能对x86架构更为熟悉，它实现了CISC设计。所以你们可能会想，*为什么我们需要别的东西？* RISC架构的主要优势在于，实施它们的处理器通常需要较少的晶体管，最终使得它们在能效和热效率方面表现更好，并且降低了相关的制造成本，使其成为便携设备的更好选择。我们选择从ARM开始介绍RISC架构是有充分理由的——在撰写本文时，它是全球使用最广泛的架构。
- en: 'The explanation is simple – processors that implement it can be found on multiple
    mobile devices and appliances such as phones, video game consoles, or digital
    cameras, heavily outnumbering PCs. For this reason, multiple IoT malware families
    and mobile malware that target Android and iOS platforms have payloads for the
    ARM architecture; an example can be seen in the following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很简单——实现它的处理器可以在多种移动设备和家电中找到，如手机、视频游戏控制台或数码相机，远远超过了PC。因此，针对Android和iOS平台的多种物联网恶意软件家族和移动恶意软件，具有针对ARM架构的有效载荷；一个例子可以在以下截图中看到：
- en: '![Figure 2.7 – Disassembled IoT malware targeting ARM-based devices'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 反汇编的针对ARM架构设备的物联网恶意软件](img/Figure_2.7_B18500.jpg)'
- en: '](img/Figure_2.7_B18500.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.7_B18500.jpg)'
- en: Figure 2.7 – Disassembled IoT malware targeting ARM-based devices
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 反汇编的针对ARM架构设备的物联网恶意软件
- en: Thus, to analyze them, it is necessary to understand how ARM works.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要分析它们，必须了解ARM是如何工作的。
- en: ARM originally stood for Acorn RISC Machine, and later for Advanced RISC Machine.
    Acorn was a British company considered by many as the British Apple, producing
    some of the most powerful PCs of that time. It was later split into several independent
    entities, with Arm Holdings (currently owned by SoftBank Group) supporting and
    extending the current standard.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ARM最初代表Acorn RISC机器，后来代表高级RISC机器。Acorn是一家英国公司，被许多人认为是英国的苹果公司，生产了当时一些最强大的个人电脑。后来，Acorn被拆分成多个独立实体，其中Arm
    Holdings（目前由软银集团拥有）支持并扩展了当前的标准。
- en: Multiple OSs support it, including Windows, Android, iOS, various Unix/Linux
    distributions, and many other lesser-known embedded OSs. The support for a 64-bit
    address space was added in 2011 with the release of the ARMv8 standard.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 它被多个操作系统支持，包括Windows、Android、iOS、各种Unix/Linux发行版以及许多其他较不知名的嵌入式操作系统。64位地址空间的支持在2011年通过ARMv8标准的发布得以增加。
- en: 'Overall, the following ARM architecture profiles are available:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，以下ARM架构配置文件是可用的：
- en: '**Application profiles (suffix A, for example, the Cortex-A family**): These
    profiles implement a traditional ARM architecture and support a virtual memory
    system architecture based on am MMU. These profiles support both ARM and Thumb
    instruction sets (as discussed later).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序配置文件（后缀A，例如Cortex-A系列）**：这些配置文件实现了传统的ARM架构，并支持基于MMU的虚拟内存系统架构。这些配置文件支持ARM和Thumb指令集（稍后会讨论）。'
- en: '**Real-time profiles (suffix R, for example, the Cortex-R family):** These
    profiles implement a traditional ARM architecture and support a protected memory
    system architecture based on a **Memory Protection Unit** (**MPU**).'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时配置文件（后缀R，例如Cortex-R系列）**：这些配置文件实现了传统的ARM架构，并支持基于**内存保护单元**（**MPU**）的受保护内存系统架构。'
- en: '**Microcontroller profiles (suffix M, for example, the Cortex-M family)**:
    The profiles implement a programmers’ model and are designed to be integrated
    into **Field Programmable Gate Arrays** (**FPGAs**).'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微控制器配置文件（后缀M，例如Cortex-M系列）**：这些配置文件实现了一种程序员模型，并且设计为能够集成到**现场可编程门阵列**（**FPGAs**）中。'
- en: Each family has its corresponding set of associated architectures (for example,
    the Cortex-A 32-bit family incorporates the ARMv7-A and ARMv8-A architectures),
    which, in turn, incorporates several cores (for example, the ARMv7-R architecture
    incorporates Cortex-R4, Cortex-R5, and so on).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系列都有其对应的体系结构集（例如，Cortex-A 32位系列包括ARMv7-A和ARMv8-A架构），而这些架构又包含多个核心（例如，ARMv7-R架构包括Cortex-R4、Cortex-R5等）。
- en: Basics
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: In this section, we will cover both the original 32-bit and the newer 64-bit
    architectures. Multiple versions were released over time, starting from the ARMv1\.
    In this book, we will focus on the recent versions of them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将涵盖原始的32位架构和更新的64位架构。随着时间的推移，发布了多个版本，从ARMv1开始。在本书中，我们将重点讨论它们的最新版本。
- en: 'ARM is a load-store architecture; it divides all instructions into the following
    two categories:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ARM是一种加载-存储架构；它将所有指令分为以下两类：
- en: '**Memory access**: Move data between memory and registers'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问**：在内存和寄存器之间移动数据'
- en: '**Arithmetic Logic Unit (ALU) operations**: Do computations involving registers'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术逻辑单元（ALU）操作**：执行涉及寄存器的计算'
- en: ARM supports the addition, subtraction, and multiplication arithmetic operations,
    though some new versions, starting from ARMv7, also support division. It also
    supports big-endian order but uses little-endian order by default.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ARM支持加法、减法和乘法运算，尽管从ARMv7开始，一些新版本也支持除法。它还支持大端序，但默认使用小端序。
- en: '16 registers are visible at any time on the 32-bit ARM: R0-R15\. This number
    is convenient as it only takes 4 bits to define which register is going to be
    used. Out of them, 13 (sometimes referred to as 14, including R14 or 15, also
    including R13) are general-purpose registers: R13 and R15 each have a special
    function, while R14 can take it occasionally. Let’s have a look at them in greater
    detail:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位ARM中，始终可见16个寄存器：R0-R15。这个数字很方便，因为只需要4位就能定义将要使用哪个寄存器。其中13个（有时称为14个，包括R14或15，也包括R13）是通用寄存器：R13和R15各自具有特殊功能，而R14有时也可以使用。让我们更详细地了解它们：
- en: '**R0-R7**: Low registers are the same in all CPU modes.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R0-R7**：低寄存器在所有CPU模式中都是相同的。'
- en: '**R8-R12**: High registers are the same in all CPU modes except the **Fast
    Interrupt Request** (**FIQ**) mode, which is not accessible by 16-bit instructions.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R8-R12**：高寄存器在所有CPU模式中都是相同的，除了**快速中断请求**（**FIQ**）模式，该模式无法通过16位指令访问。'
- en: '**R13 (also known as SP**): This is a stack pointer that points to the top
    of the stack. Each CPU mode has a version of it. It is discouraged to use it as
    a GPR.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R13（也称为SP）**：这是一个栈指针，指向栈顶。每个CPU模式都有一个版本。建议不要将其用作通用寄存器。'
- en: '`BL` (Branch with Link) or `BLX` (Branch with Link and eXchange) instructions
    are executed. It can also be used as a GPR if the return address is stored on
    the stack. Each CPU mode has a version of it.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`BL`（带链接分支）或`BLX`（带链接分支并交换）指令时。如果返回地址存储在堆栈上，它也可以用作通用寄存器。每个CPU模式都有一个版本。
- en: '**R15 (also known as PC)**: This is a program counter that points to the currently
    executed command. It’s not a GPR.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R15（也称为PC）**：这是一个程序计数器，指向当前执行的指令。它不是一个通用寄存器。'
- en: Altogether, there are 30 general-purpose 32-bit registers on most of the ARM
    architectures overall, including the same name instances in different CPU modes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在大多数ARM架构中，通常有30个通用的32位寄存器，包括不同CPU模式下具有相同名称的实例。
- en: 'Apart from these, there are several other important registers, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些其他重要的寄存器，如下所示：
- en: '**Application Program Status Register** (**APSR**): This stores copies of the
    ALU status flags, also known as condition code flags. On later architectures,
    it also holds the Q (saturation) and the greater than or equal to (GE) flags.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序状态寄存器**（**APSR**）：该寄存器存储ALU状态标志的副本，也称为条件码标志。在后来的架构中，它还保存Q（饱和）标志和大于或等于（GE）标志。'
- en: '**Current Program Status Register** (**CPSR**): This contains APSR as well
    as bits that describe a current processor mode, state, endianness, and some other
    values.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前程序状态寄存器**（**CPSR**）：该寄存器包含APSR以及描述当前处理器模式、状态、字节序和其他一些值的位。'
- en: '**Saved Program Status Registers** (**SPSR**): This stores the value of CPSR
    when the exception is taken so that it can be restored later. Each CPU mode has
    a version of it, except the user and system modes, as they are not exception-handling
    modes.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存的程序状态寄存器**（**SPSR**）：该寄存器在发生异常时存储CPSR的值，以便稍后恢复。每个CPU模式都有一个版本，除了用户模式和系统模式，因为它们不是异常处理模式。'
- en: The number of **Floating-Point Registers** (**FPRs**) for a 32-bit architecture
    may vary, depending on the core. There can be up to 32 in total.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**浮点寄存器**（**FPRs**）的数量在32位架构中可能有所不同，具体取决于核心。最多可以有32个。'
- en: ARMv8 (64-bit) has 31 general-purpose X0-X30 (the R0-R30 notation can also be
    found) and 32 FPRs accessible at all times. The lower part of each register has
    the W prefix and can be accessed as W0-W30.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv8（64位）有31个通用X0-X30寄存器（也可以看到R0-R30符号）和32个始终可访问的FPR。每个寄存器的低部分带有W前缀，可以作为W0-W30进行访问。
- en: 'Several registers have a particular purpose, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一些寄存器具有特定的用途，如下所示：
- en: '![](img/Table_2.10_B18500.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.10_B18500.jpg)'
- en: ARMv8 defines four exception levels (EL0-EL3), and each of the last three registers
    gets a copy of each; ELR and SPSR don’t have a separate copy of EL0.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv8定义了四个异常级别（EL0-EL3），最后三个寄存器每个都保存一份副本；ELR和SPSR没有EL0的单独副本。
- en: There is no register called X31 or W31; the number 31 in many instructions represents
    either the zero register, ZR (WZR/XZR), or SP (for stack-related operations).
    X29 can be used as a frame pointer (which stores the original stack position),
    while X30 can be used as a link register (which stores a return value from the
    functions).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 没有名为X31或W31的寄存器；在许多指令中，数字31代表零寄存器ZR（WZR/XZR）或SP（用于栈相关操作）。X29可以用作帧指针（存储原始栈位置），而X30可以用作链接寄存器（存储来自函数的返回值）。
- en: Regarding the calling convention, R0-R3 on the 32-bit ARM and X0-X7 on the 64-bit
    ARM are used to store argument values passed to functions with the remaining arguments
    passed through the stack – if necessary, R0-R1 and X0-X7 (and X8, also known as
    XR indirectly) to hold return results. If the type of the returned value is too
    big to fit them, then space needs to be allocated and returned as a pointer. Apart
    from this, R12 (32-bit) and X16- X17 (64-bit) can be used as intra-procedure-call
    scratch registers (by so-called veneers and procedure linkage table code) and
    R9 (32-bit) and X18 (64-bit) can be used as platform registers (for OS-specific
    purposes) if needed; otherwise, they are used the same way as other temporaries.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 关于调用约定，32位ARM的R0-R3和64位ARM的X0-X7用于存储传递给函数的参数值，剩余的参数通过堆栈传递——如果需要，R0-R1和X0-X7（以及X8，也称为XR间接）用于保存返回结果。如果返回值的类型太大，无法适配它们，那么需要分配空间并以指针的形式返回。除此之外，R12（32位）和X16-X17（64位）可用作过程调用中的临时寄存器（通过所谓的外壳程序和过程链接表代码），R9（32位）和X18（64位）可用作平台寄存器（用于操作系统特定的目的），如果需要；否则，它们与其他临时寄存器的使用方式相同。
- en: 'As mentioned previously, several CPU modes are implemented according to the
    official documentation, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，几种CPU模式是根据官方文档实现的，如下所示：
- en: '![](img/Table_2.11_B18500.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.11_B18500.jpg)'
- en: Instruction sets
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: 'Several instruction sets are available for ARM processors: ARM and Thumb. A
    processor that is executing ARM instructions is said to be operating in the ARM
    state and vice versa. ARM processors always start in the ARM state; then, a program
    can switch to the Thumb state by using a BX instruction. **Thumb Execution Environment**
    (**ThumbEE**) was introduced relatively recently in ARMv7 and is based on Thumb,
    with some changes and additions to facilitate dynamically generated code.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ARM处理器有几种指令集：ARM和Thumb。当处理器执行ARM指令时，称其处于ARM状态，反之亦然。ARM处理器通常从ARM状态开始；然后，程序可以通过使用BX指令切换到Thumb状态。**Thumb执行环境**
    (**ThumbEE**) 是在ARMv7中相对较新引入的，基于Thumb，并进行了某些更改和添加，以便于动态生成代码。
- en: ARM instructions are 32 bits long (for both AArch32 and AArch64), while Thumb
    and ThumbEE instructions are either 16 or 32 bits long (originally, almost all
    Thumb instructions were 16-bit, while Thumb-2 introduced a mix of 16 and 32-bit
    instructions).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ARM指令的长度为32位（对于AArch32和AArch64都是如此），而Thumb和ThumbEE指令的长度为16位或32位（最初，几乎所有Thumb指令都是16位的，而Thumb-2引入了16位和32位指令的混合）。
- en: 'All instructions can be split into the following categories according to the
    official documentation:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指令都可以根据官方文档分为以下几类：
- en: '![](img/Table_2.12_B18500.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.12_B18500.jpg)'
- en: To interact with the OS, *syscalls* can be accessed using the `SWI`) instruction,
    which was later renamed the `SVC`) instruction.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要与操作系统交互，可以通过使用`SWI`指令访问*系统调用*，该指令后来被重命名为`SVC`指令。
- en: 'See the official ARM documentation to get the exact syntax for any instruction.
    Here is an example of how it may look:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方ARM文档，以获取任何指令的准确语法。下面是一个示例：
- en: '[PRE9]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the *{cond}* code will be a condition code. Several condition
    codes are supported by ARM, as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*{cond}*代码将是一个条件码。ARM支持几种条件码，如下所示：
- en: '**EQ**: Equal to'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EQ**: 等于'
- en: '**NE**: Not equal to'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NE**: 不等于'
- en: '**CS/HS**: Carry set or unsigned higher or both'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CS/HS**: 有进位或无符号较高或两者'
- en: '**CC/LO**: Carry clear or unsigned lower'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CC/LO**: 无进位或无符号较低'
- en: '**MI**: Negative'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MI**: 负数'
- en: '**PL**: Positive or zero'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PL**: 正数或零'
- en: '**VS**: Overflow'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS**: 溢出'
- en: '**VC**: No overflow'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VC**: 无溢出'
- en: '**HI**: Unsigned higher'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HI**: 无符号大于'
- en: '**LS**: Unsigned lower or both'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LS**: 无符号较低或两者'
- en: '**GE**: Signed greater than or equal to'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GE**: 大于或等于'
- en: '**LT**: Signed less than'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LT**: 小于'
- en: '**GT**: Signed greater than'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GT**: 大于'
- en: '**LE**: Signed less than or equal to'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LE**: 小于或等于'
- en: '**AL**: Always (normally omitted)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AL**: 始终（通常省略）'
- en: '**imm:** It stands for the immediate value'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**imm:** 表示立即数值'
- en: Now, let's look at the basics of MIPS.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看MIPS的基础知识。
- en: Basics of MIPS
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MIPS基础
- en: '**Microprocessor without Interlocked Pipelined Stages** (**MIPS**) was developed
    by MIPS Technologies (formerly MIPS computer systems). Similar to ARM, at first,
    it was a 32-bit architecture with 64-bit functionality added later. Taking advantage
    of the RISC ISA, MIPS processors are characterized by their low power and heat
    consumption. They can often be found in multiple embedded systems, such as routers
    and gateways. Several video game consoles such as Sony PlayStation also incorporated
    them. Unfortunately, due to the popularity of this architecture, the systems that
    implement it became a target of multiple IoT malware families. An example can
    be seen in the following screenshot:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**无互锁流水线阶段的微处理器**（**MIPS**）由MIPS技术公司（前身为MIPS计算机系统）开发。与ARM类似，最初它是一个32位架构，后来增加了64位功能。利用RISC指令集架构（ISA）的优势，MIPS处理器的特点是低功耗和低热量消耗。它们通常可以在多种嵌入式系统中找到，如路由器和网关。像索尼PlayStation这样的多个游戏主机也采用了它们。不幸的是，由于这一架构的普及，实施它的系统成为了多个物联网恶意软件家族的攻击目标。一个例子可以在以下截图中看到：'
- en: '![Figure 2.8 – IoT malware targeting MIPS-based systems'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 针对MIPS架构系统的物联网恶意软件'
- en: '](img/Figure_2.8_B18500.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.8_B18500.jpg)'
- en: Figure 2.8 – IoT malware targeting MIPS-based systems
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 针对MIPS架构系统的物联网恶意软件
- en: As the architecture evolved, there were several versions of it, starting from
    MIPS I and going up to V, and then several releases of the more recent MIPS32/MIPS64\.
    MIPS64 remains backward compatible with MIPS32\. These base architectures can
    be further supplemented with optional architectural extensions, called **Application-Specific
    Extensions** (**ASEs**), and modules to improve performance for certain tasks
    that are generally not used by the malicious code much. MicroMIPS32/64 are supersets
    of the MIPS32 and MIPS64 architectures, respectively, with almost the same 32-bit
    instruction set and additional 16-bit instructions to reduce the code size. They
    are used where code compression is required and are designed for microcontrollers
    and other small embedded devices.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 随着架构的演变，出现了多个版本，从MIPS I开始，一直到V版，然后是多个更新的MIPS32/MIPS64版本。MIPS64与MIPS32向后兼容。这些基础架构可以通过可选的架构扩展（称为**应用特定扩展**，**ASEs**）进一步补充，增加某些任务的性能，这些任务通常不被恶意代码广泛使用。MicroMIPS32/64是MIPS32和MIPS64架构的超集，几乎具有相同的32位指令集，并增加了16位指令以减少代码大小。它们用于需要代码压缩的场景，专为微控制器和其他小型嵌入式设备设计。
- en: Basics
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'MIPS supports bi-endianness. The following registers are available:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS支持双字节序。以下寄存器可用：
- en: 32 GPRs r0-r31 – 32-bit in size on MIPS32 and 64-bit in size on MIPS64.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32个GPR寄存器r0-r31 – 在MIPS32中为32位大小，在MIPS64中为64位大小。
- en: A special-purpose PC register that can be affected only indirectly by some instructions.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特殊用途的PC寄存器，仅能通过某些指令间接影响。
- en: Two special-purpose registers to hold the results of integer multiplication
    and division (HI and LO). These registers and their related instructions were
    removed from the base instruction set in the release of 6 and now exist in the
    **Digital Signal Processor** (**DSP**) module.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个专用寄存器用于存储整数乘法和除法的结果（HI和LO）。这些寄存器及其相关指令在第6版的基础指令集中被移除，现在存在于**数字信号处理器**（**DSP**）模块中。
- en: 'The reason behind 32 GPRs is simple – MIPS uses 5 bits to specify the register,
    so this way, we can have a maximum of 2^5 = 32 different values. Two of the GPRs
    have a particular purpose, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 32个GPR的原因很简单 – MIPS使用5位来指定寄存器，因此可以有最多2^5 = 32个不同的值。两个GPR具有特定的用途，如下所示：
- en: Register r0 (sometimes referred to as $0 or $zero) is a constant register and
    always stores zero, and provides read-only access. It can be used as a /dev/null
    analog to discard the output of some operation, or as a fast source of a zero
    value.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器r0（有时称为$0或$zero）是一个常量寄存器，始终存储零，并提供只读访问。它可以用作/dev/null的类似物来丢弃某些操作的输出，或者作为零值的快速源。
- en: r31 (also known as $ra) stores the return address during the procedure call
    branch/jump and link instructions.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: r31（也称为$ra）在过程调用分支/跳转和链接指令期间存储返回地址。
- en: 'Other registers are generally used for particular purposes, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 其他寄存器通常用于特定的目的，如下所示：
- en: '**r1 (also known as $at)**: Assembler temporary – used when resolving pseudo-
    instructions'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r1（也称为$at）**：汇编临时寄存器 – 在解决伪指令时使用'
- en: '**r2-r3 (also known as $v0 and $v1)**: Values – hold return function values.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r2-r3（也称为$v0和$v1）**：值 – 存储返回函数值。'
- en: '**r4-r7 (also known as $a0-$a3)**: Arguments – used to deliver function arguments.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r4-r7（也叫做 $a0-$a3）**：参数寄存器 – 用于传递函数参数。'
- en: '**r8-r15 (also known as $t0-$t7/$a4-$a7 and $t4-$t7)**: Temporaries – the first
    four can also be used to provide function arguments in N32 and N64 calling conventions
    (another O32 calling convention only uses r4-r7 registers; subsequent arguments
    are passed on the stack).'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r8-r15（也叫做 $t0-$t7/$a4-$a7 和 $t4-$t7）**：临时寄存器 – 前四个寄存器在 N32 和 N64 调用约定中也可以用来传递函数参数（另一个
    O32 调用约定仅使用 r4-r7 寄存器；后续参数通过栈传递）。'
- en: '**r16-r23 (also known as $s0-$s7)**: Saved temporaries – preserved across function
    calls.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r16-r23（也叫做 $s0-$s7）**：保存的临时寄存器 – 跨函数调用时保持不变。'
- en: '**r24-r25 (also known as $t8-$t9)**: Temporaries.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r24-r25（也叫做 $t8-$t9）**：临时寄存器。'
- en: '**r26-r27 (also known as $k0-$k1)**: Generally reserved for the OS kernel.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r26-r27（也叫做 $k0-$k1）**：通常保留给操作系统内核使用。'
- en: '**r28 (also known as $gp)**: Global pointer – points to the global area (data
    segment).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r28（也叫做 $gp）**：全局指针 – 指向全局区域（数据段）。'
- en: '**r29 (also known as $sp)**: Stack pointer.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r29（也叫做 $sp）**：栈指针。'
- en: '**r30 (also known as $s8 or $fp)**: Saved value/frame pointer – stores the
    original stack pointer (before the function was called).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r30（也叫做 $s8 或 $fp）**：保存的值/帧指针 – 存储原始栈指针（函数调用前的值）。'
- en: 'MIPS also has the following co-processors available:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS 还提供以下协处理器：
- en: '**CP0**: System control'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CP0**：系统控制'
- en: '**CP1**: FPU'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CP1**：FPU'
- en: '**CP2**: Implementation-specific'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CP2**：特定实现'
- en: '**CP3**: FPU (has dedicated COP1X opcode type instructions)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CP3**：FPU（具有专用的 COP1X 操作码类型指令）'
- en: The instruction set
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: 'The majority of the main instructions were introduced in MIPS I and II. MIPS
    III introduced 64-bit integers and addresses, and MIPS IV and V improved floating-point
    operations and added a new set to boost the overall efficacy. Every instruction
    there has the same length – that is, 32 bits (4 bytes) – and all instructions
    start with an opcode that takes 6 bits. The three major instruction formats that
    are supported are R, I, and J:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主要指令在 MIPS I 和 II 中引入。MIPS III 引入了 64 位整数和地址，而 MIPS IV 和 V 改进了浮点运算，并增加了一组新的指令以提高整体效率。每条指令的长度都是固定的
    – 即 32 位（4 字节） – 所有指令都以一个占 6 位的操作码开始。支持的三种主要指令格式是 R、I 和 J：
- en: '![](img/Table_2.13_B18500.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_2.13_B18500.jpg)'
- en: For the FPU-related operations, the analogous FR and FI types exist.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 FPU 相关的操作，存在类似的 FR 和 FI 类型。
- en: Apart from this, several other less common formats exist, mainly coprocessors
    and extension-related formats.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还存在一些其他不常见的格式，主要是协处理器和扩展相关的格式。
- en: 'In the documentation, registers usually have the following suffixes:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中，寄存器通常会带有以下后缀：
- en: Source (s)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源（s）
- en: Target (t)
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标（t）
- en: Destination (d)
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标（d）
- en: 'All instructions can be split into the following groups, depending on the functionality
    type:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指令都可以根据功能类型分为以下几组：
- en: '`JR`: Jump register (J format)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JR`：跳转寄存器（J 格式）'
- en: '`BLTZ`: Branch on less than zero (I format)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLTZ`：小于零时分支（I 格式）'
- en: '`LB`: Load byte (I format)*   `SW`: Store word (I format)*   `ADDU`: Add unsigned
    (R format)*   `XOR`: Exclusive or (R format)*   `SLL`: Shift left logical (R format)*   `SYSCALL`:
    System call (custom format)*   `BREAK`: Breakpoint (custom format)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LB`：加载字节（I 格式）*   `SW`：存储字（I 格式）*   `ADDU`：无符号加法（R 格式）*   `XOR`：异或（R 格式）*   `SLL`：逻辑左移（R
    格式）*   `SYSCALL`：系统调用（自定义格式）*   `BREAK`：断点（自定义格式）'
- en: Floating-point instructions will have similar names for the same types of operations
    in most cases, such as `ADD.S`. Some instructions are more unique, such as Check
    for Equal (`C.EQ.D`).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点指令通常会有类似名称来表示相同类型的操作，比如 `ADD.S`。一些指令则较为独特，例如“检查是否相等”（`C.EQ.D`）。
- en: As we can see here and later, the same basic groups can be applied to virtually
    any architecture, and the only difference will be in their implementation. Some
    common operations may get instructions to benefit from optimizations and, in this
    way, reduce the size of the code and improve performance.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这些基本组可以适用于几乎任何架构，唯一的区别在于它们的实现。一些常见的操作可能会获得指令以利用优化，从而减少代码大小并提高性能。
- en: 'As the MIPS instruction set is pretty minimalistic, the assembler macros, known
    as pseudo instructions, also exist. Here are some of the most commonly used:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MIPS 指令集较为简洁，因此也存在汇编宏，称为伪指令。以下是一些常用的伪指令：
- en: '`ABS`: Absolute value – translates into a combination of `ADDU`, `BGEZ`, and
    `SUB`'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABS`：绝对值 – 转换为 `ADDU`、`BGEZ` 和 `SUB` 的组合'
- en: '`BLT`: Branch on less than – translates into a combination of `SLT` and `BNE`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLT`：小于分支——相当于`SLT`和`BNE`的组合'
- en: '`BGT/BGE/BLE`: Similar to `BLT`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BGT/BGE/BLE`：类似于`BLT`'
- en: '`LI/LA`: Load immediate/address – translates into a combination of `LUI` and
    `ORI` or `ADDIU` for a 16-bit LI'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LI/LA`：加载立即数/地址——相当于`LUI`和`ORI`的组合，或者用于16位LI的`ADDIU`'
- en: '`MOVE`: Moves the content of one register into another – translates into `ADD/ADDIU`
    with a zero value'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOVE`：将一个寄存器的内容移动到另一个寄存器——相当于用零值的`ADD/ADDIU`指令'
- en: '`NOP`: No operation – translates into `SLL` with zero values'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOP`：无操作——相当于用零值的`SLL`指令'
- en: '`NOT`: Logical NOT – translates into `NOR`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT`：逻辑非——相当于`NOR`'
- en: Diving deep into PowerPC
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨PowerPC
- en: '**PowerPC** stands for **Performance Optimization With Enhanced RISC—Performance
    Computing** and is sometimes spelled as PPC. It was created in the early 1990s
    by the alliance of Apple, IBM, and Motorola (commonly abbreviated as AIM). It
    was originally intended to be used in PCs and powered Apple products, including
    PowerBooks and iMacs, up until 2006\. The CPUs that implement it can also be found
    in game consoles such as Sony PlayStation 3, XBOX 360, and Wii, as well as in
    IBM servers and multiple embedded devices, such as car and plane controllers,
    and even in the famous ASIMO robot. Later, the administrative responsibilities
    were transferred to an open standards body, Power.org, where some of the former
    creators remained members, such as IBM and Freescale. The latter was separated
    from Motorola and later acquired by NXP Semiconductors. The OpenPOWER Foundation
    is a newer initiative by IBM, Google, NVIDIA, Mellanox, and Tyan that aims to
    facilitate collaboration in the development of this technology.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**PowerPC**代表**优化性能的增强型RISC—性能计算**，有时也简称为PPC。它是由苹果、IBM和摩托罗拉（常缩写为AIM）在1990年代初创建的。最初旨在用于PC，并为苹果产品提供动力，包括PowerBook和iMac，直到2006年。实现这一架构的CPU还出现在游戏机中，如索尼PlayStation
    3、XBOX 360和Wii，以及IBM服务器和多种嵌入式设备，如汽车和飞机控制器，甚至是著名的ASIMO机器人。后来，管理责任转交给了一个开放标准机构Power.org，一些前创始公司仍然是成员，如IBM和Freescale。后者脱离摩托罗拉并被NXP半导体收购。OpenPOWER基金会是IBM、谷歌、NVIDIA、Mellanox和Tyan的新兴合作项目，旨在促进这一技术的协作开发。'
- en: PowerPC was mainly based on IBM POWER ISA. Later, a unified Power ISA was released,
    which combined POWER and PowerPC into a single ISA that is now used in multiple
    products under the Power Architecture umbrella term.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: PowerPC主要基于IBM的POWER ISA。后来，发布了一个统一的Power ISA，将POWER和PowerPC合并为一个单一的ISA，现在在多个Power架构下的产品中使用。
- en: There are plenty of IoT malware families that have payloads for this architecture.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多面向该架构的物联网恶意软件家族。
- en: Basics
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础
- en: The Power ISA is divided into several categories; each category can be found
    in a certain part of the specification or book. CPUs implement a set of these
    categories, depending on their class; only the base category is an obligatory
    one.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Power ISA被分为多个类别，每个类别可以在规范或书籍的特定部分找到。CPU根据其类别实现这些类别的集合；只有基础类别是强制性的。
- en: 'Here is a list of the main categories and their definitions in the latest second
    standard:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最新第二版标准中主要类别及其定义的列表：
- en: '**Base**: Covered in Book I *(Power ISA User Instruction Set Architecture*)
    and Book II (*Power ISA Virtual Environment Architecture*)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Base**：在第一册（*Power ISA 用户指令集架构*）和第二册（*Power ISA 虚拟环境架构*）中有介绍'
- en: '**Server**: Covered in Book III-S (*Power ISA Operating Environment Architecture
    –Server Environment*)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Server**：在第三册-S（*Power ISA 操作环境架构—服务器环境*）中有介绍'
- en: '**Embedded**: Covered in Book III-E (*Power ISA Operating Environment Architecture
    – Embedded Environment*)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Embedded**：在第三册-E（*Power ISA 操作环境架构—嵌入式环境*）中有介绍'
- en: There are many more granular categories that cover aspects such as floating-point
    operations and caching for certain instructions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多更为细化的类别，涵盖了诸如浮点操作和某些指令的缓存等方面。
- en: Another book, Book VLE (*Power ISA Operating Environment Architecture – Variable
    Length Encoding (VLE) Instructions Architecture*), defines alternative instructions
    and definitions intended to increase the density of the code by using 16-bit instructions
    as opposed to the more common 32-bit ones.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 另一本书，Book VLE（*Power ISA 操作环境架构—可变长度编码（VLE）指令架构*），定义了替代指令和定义，旨在通过使用16位指令而非常见的32位指令来提高代码的密度。
- en: Power ISA version 3 consists of three books with the same names as Books I to
    III of the previous standards, without distinctions between environments.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Power ISA版本3由三本书组成，名称与先前标准的第一至第三本书相同，环境间没有区别。
- en: The processor starts in big-endian mode but can switch it by changing a bit
    in the **Machine State Register** (**MSR**) so that bi-endianness is supported.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器以大端模式启动，但可以通过改变**机器状态寄存器**（**MSR**）中的一个位来切换，从而支持双端模式。
- en: 'Many sets of registers are documented in Power ISA, mainly grouped around either
    an associated facility or a category. Here is a basic summary of the most commonly
    used ones:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 许多寄存器组在Power ISA中有文档记录，主要围绕相关设施或类别进行分组。以下是最常用的一些基本总结：
- en: 32 GPRs for integer operations, generally used by their number only (64-bit)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32个GPR用于整数操作，通常仅通过它们的编号使用（64位）
- en: '64 **Vector Scalar Registers** (**VSRs**) for vector operations and floating-point
    operations:'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64个**向量标量寄存器**（**VSRs**）用于向量操作和浮点操作：
- en: 32 **Vector Registers** (**VRs**) as part of the VSRs for vector operations
    (128-bit)
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为VSR的一部分，32个**向量寄存器**（**VRs**），用于向量操作（128位）
- en: 32 FPRs as part of the VSRs for floating-point operations (64-bit)
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为VSR的一部分，32个FPR用于浮点操作（64位）
- en: 'Special purpose fixed-point facility registers, such as the following:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用定点设施寄存器，例如以下内容：
- en: Fixed-point **exception register** (**XER**), which contains multiple status
    bits (64-bit)
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定点**异常寄存器**（**XER**），包含多个状态位（64位）
- en: 'Branch facility registers:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支设施寄存器：
- en: '**Condition Register (CR)**: Consists of eight 4-bit fields, CR0-CR7, involving
    things such as control flow and comparison (32-bit)'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件寄存器 (CR)**：由八个4位字段组成，CR0-CR7，涉及控制流和比较等内容（32位）'
- en: '**Link Register (LR)**: Provides the branch target address (64-bit)'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接寄存器（LR）**：提供分支目标地址（64位）'
- en: '**Count Register (CTR)**: Holds a loop count (64-bit)'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数寄存器（CTR）**：保存循环计数（64位）'
- en: '**Target Access Register (TAR)**: Specifies the branch target address (64-bit)'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标访问寄存器（TAR）**：指定分支目标地址（64位）'
- en: 'Timer facility registers:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器设施寄存器：
- en: '**Time Base (TB)**: This is incremented periodically with the defined frequency
    (64-bit)'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间基准（TB）**：以定义的频率周期性增加（64位）'
- en: 'Other special-purpose registers from a particular category, including the following:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自特定类别的其他专用寄存器，包括以下内容：
- en: '**Accumulator** (**ACC**) (64-bit): The **Signal Processing Engine** (**SPE**)
    category'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**累加器**（**ACC**）（64位）：**信号处理引擎**（**SPE**）类别'
- en: Generally, functions can pass all arguments in registers for non-recursive calls;
    additional arguments are passed on the stack.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数可以通过寄存器传递所有参数，用于非递归调用；额外的参数通过栈传递。
- en: The instruction set
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: 'Most of the instructions are 32-bit; only the VLE group is smaller to provide
    a higher code density for embedded applications. All instructions are split into
    the following three categories:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数指令为32位；只有VLE组的指令较小，以提供更高的代码密度，适用于嵌入式应用。所有指令分为以下三类：
- en: '**Defined**: All of the instructions are defined in the Power ISA books.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已定义**：所有指令都在Power ISA文档中定义。'
- en: '**Illegal**: Available for future extensions of the Power ISA. Attempting to
    execute them will invoke the illegal instruction error handler.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非法**：用于Power ISA的未来扩展。尝试执行它们将会调用非法指令错误处理程序。'
- en: '**Reserved**: Allocated to specific purposes that are outside the scope of
    the Power ISA. Attempting to execute them will either result in an implemented
    action or invoke the illegal instruction error handler if the implementation is
    not available.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留**：分配给Power ISA范围之外的特定用途。尝试执行这些指令将会导致执行已实现的操作，或在实现不可用时调用非法指令错误处理程序。'
- en: 'Bits 0 to 5 always specify the opcode, and many instructions also have an extended
    opcode. A large number of instruction formats are supported; here are some examples:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 位0到5始终指定操作码，许多指令也具有扩展操作码。支持大量的指令格式；以下是一些示例：
- en: I-FORM [OPCD+LI+AA+LK]
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I-FORM [OPCD+LI+AA+LK]
- en: B-FORM [OPCD+BO+BI+BD+AA+LK]
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B-FORM [OPCD+BO+BI+BD+AA+LK]
- en: 'Each instruction field has an abbreviation and meaning; it makes sense to consult
    the official Power ISA document to get a full list of them and their corresponding
    formats. In terms of I-FORM, they are as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令字段都有缩写和含义；参考官方Power ISA文档获取完整的指令和它们相应格式的列表是有意义的。就I-FORM而言，它们如下：
- en: '**OPCD**: Opcode'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPCD**：操作码'
- en: '**LI**: Immediate field used to specify a 24-bit signed two’s complement integer'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LI**：立即数字段，用于指定一个24位有符号的二进制补码整数'
- en: '**AA**: Absolute address bit'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AA**：绝对地址位'
- en: '**LK**: Link bit affecting the link register'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LK**: 链接位，影响链接寄存器'
- en: 'Instructions are also split into groups according to the associated facility
    and category, making them very similar to registers:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 指令也根据相关设施和类别分为不同组，因此它们与寄存器非常相似：
- en: 'Branch instructions:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支指令：
- en: '`b/ba/bl/bla`: Branch'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b/ba/bl/bla`: 分支'
- en: '`bc/bca/bcl/bcla`: Branch conditional'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bc/bca/bcl/bcla`: 分支条件'
- en: '`sc`: System call'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sc`: 系统调用'
- en: 'Fixed-point instructions:'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定点指令：
- en: '`lbz`: Load byte and zero'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lbz`: 加载字节并清零'
- en: '`stb`: Store byte'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stb`: 存储字节'
- en: '`addi`: Add immediate'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addi`: 加法立即数'
- en: '`ori`: OR immediate'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ori`: 或操作立即数'
- en: 'Floating-point instructions:'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点指令：
- en: '`fmr`: Floating move register'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmr`: 浮点寄存器移动'
- en: '`lfs`: Load floating-point single'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lfs`: 加载单精度浮点数'
- en: '`stfd`: Store floating-point double'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stfd`: 存储双精度浮点数'
- en: 'SPE instructions:'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPE 指令：
- en: '`brinc`: Bit-reversed increment'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brinc`: 位反转递增'
- en: Covering the SuperH assembly
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖了 SuperH 汇编语言
- en: 'SuperH, often abbreviated as SH, is a RISC ISA developed by Hitachi. SuperH
    went through several iterations, starting from SH-1 and moving up to SH-4\. The
    more recent SH-5 has two modes of operation, one of which is identical to the
    user-mode instructions of SH-4, while another, SHmedia, is quite different. Each
    family has a market niche:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: SuperH，通常缩写为 SH，是由日立开发的 RISC 指令集架构（ISA）。SuperH 经历了多个版本，从 SH-1 开始，发展到 SH-4。较新的
    SH-5 有两种操作模式，其中一种与 SH-4 的用户模式指令相同，而另一种 SHmedia 则大相径庭。每个系列都有其市场定位：
- en: '**SH-1**: Home appliances'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SH-1**: 家用电器'
- en: '**SH-2**: Car controllers and video game consoles such as Sega Saturn'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SH-2**: 汽车控制器和视频游戏控制台，如 Sega Saturn'
- en: '**SH-3**: Mobile applications such as car navigators'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SH-3**: 移动应用，如车载导航系统'
- en: '**SH-4**: Car multimedia terminals and video game consoles such as Sega Dreamcast'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SH-4**: 汽车多媒体终端和视频游戏控制台，如 Sega Dreamcast'
- en: '**SH-5**: High-end multimedia applications'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SH-5**: 高端多媒体应用'
- en: Microcontrollers and CPUs that implement it are currently produced by Renesas
    Electronics, a joint venture of the Hitachi and Mitsubishi Semiconductor groups.
    As IoT malware mainly targets SH-4-based systems, we will focus on this SuperH
    family.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此架构的微控制器和 CPU 目前由瑞萨电子生产，瑞萨是日立和三菱半导体集团的合资企业。由于 IoT 恶意软件主要针对基于 SH-4 的系统，因此我们将重点关注此
    SuperH 系列。
- en: Basics
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本概念
- en: 'In terms of registers, SH-4 offers the following:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器方面，SH-4 提供了以下功能：
- en: 16 general registers R0-R15 (32-bit)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16 个通用寄存器 R0-R15（32 位）
- en: 'Seven control registers (32-bit):'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个控制寄存器（32 位）：
- en: '**Global Base Register** (**GBR**)'
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局基址寄存器** (**GBR**)'
- en: '**Status Register** (**SR**)'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态寄存器** (**SR**)'
- en: '**Saved Status Register** (**SSR**)'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存状态寄存器** (**SSR**)'
- en: '**Saved Program Counter** (**SPC**)'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存程序计数器** (**SPC**)'
- en: '**Vector Base Counter** (**VBR**)'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量基址计数器** (**VBR**)'
- en: '**Saved General Register 15** (**SGR**)'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存通用寄存器 15** (**SGR**)'
- en: '**Debug Base Register** (**DBR**) (only from the privileged mode)'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试基址寄存器** (**DBR**)（仅限特权模式）'
- en: 'Four system registers (32-bit):'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个系统寄存器（32 位）：
- en: '**MACH/MACL**: Multiply-and-accumulate registers'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MACH/MACL**: 乘法累加寄存器'
- en: '**PR**: Procedure register'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PR**: 程序寄存器'
- en: '**PC**: Program counter'
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PC**: 程序计数器'
- en: '**FPSCR**: Floating-point status/control register'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FPSCR**: 浮点状态/控制寄存器'
- en: 32 FPU registers – that is, FR0-FR15 (also known as DR0/2/4/... or FV0/4/...)
    and XF0-XF15 (also known as XD0/2/4/... or XMTRX); two banks of either 16 single-precision
    (32-bit) or eight double-precision (64-bit) FPRs and **FPULs** (**floating-point
    communication registers**) (32-bit)
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32 个 FPU 寄存器——即 FR0-FR15（也称为 DR0/2/4/... 或 FV0/4/...）和 XF0-XF15（也称为 XD0/2/4/...
    或 XMTRX）；两个银行，每个银行包含 16 个单精度（32 位）或 8 个双精度（64 位）浮点寄存器和 **FPULs** (**浮点通信寄存器**)（32
    位）
- en: Usually, R4-R7 are used to pass arguments to a function with the result returned
    in R0\. R8-R13 are saved across multiple function calls. R14 serves as the frame
    pointer, while R15 serves as the stack pointer.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，R4-R7 用于传递函数参数，结果则保存在 R0 中。R8-R13 在多次函数调用之间保存。R14 作为帧指针，R15 作为栈指针。
- en: Regarding the data formats, in SH-4, a word takes 16 bits, a long word takes
    32 bits, and a quadword takes 64 bits.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据格式，在 SH-4 中，一个字占 16 位，一个长字占 32 位，一个四字占 64 位。
- en: 'Two processor modes are supported: user mode and privileged mode. SH-4 generally
    operates in user mode and switches to privileged mode in case of an exception
    or an interrupt.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 支持两种处理器模式：用户模式和特权模式。SH-4 通常在用户模式下操作，并在发生异常或中断时切换到特权模式。
- en: The instruction set
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: SH-4 features an instruction set that is upward-compatible with the SH-1, SH-2,
    and SH-3 families. It uses 16-bit fixed-length instructions to reduce the program
    code’s size. Except for `BF` and `BT`, all branch instructions and `RTE` (the
    return from exception instruction) implement so-called delayed branches, where
    the instruction following the branch is executed before the branch destination
    instruction.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: SH-4具有向后兼容SH-1、SH-2和SH-3系列的指令集。它使用16位固定长度指令来减少程序代码的大小。除了`BF`和`BT`外，所有分支指令和`RTE`（异常返回指令）都实现了所谓的延迟分支，其中分支后面的指令在分支目标指令之前执行。
- en: 'All instructions are split into the following categories (with some examples):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指令分为以下类别（包含一些示例）：
- en: 'Fixed-point transfer instructions:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定点传输指令：
- en: '`MOV`: Move data (or particular data types specified)'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOV`: 移动数据（或指定的特定数据类型）'
- en: '`SWAP`: Swap register halves'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SWAP`: 交换寄存器的半部分'
- en: 'Arithmetic operation instructions:'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算指令：
- en: '`SUB`: Subtract binary numbers'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUB`: 减去二进制数'
- en: '`CMP/EQ`: Compare conditionally (in this case, on equal to)'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMP/EQ`: 有条件比较（在这种情况下，比较相等）'
- en: 'Logic operation instructions:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算指令：
- en: '`AND`: Logical AND'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AND`: 逻辑与'
- en: '`XOR`: Exclusive logical OR'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XOR`: 排他性逻辑或'
- en: 'Shift/rotate instructions:'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位/旋转指令：
- en: '`ROTL`: Rotate left'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROTL`: 左旋转'
- en: '`SHLL`: Shift logical left'
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHLL`: 逻辑左移'
- en: 'Branch instructions:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支指令：
- en: '`BF`: Branch if false'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BF`: 如果为假则跳转'
- en: '`JMP`: Jump (unconditional branch)'
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JMP`: 跳转（无条件分支）'
- en: 'System control instructions:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统控制指令：
- en: '`LDC`: Load to control register'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDC`: 加载到控制寄存器'
- en: '`STS`: Store system register'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STS`: 存储系统寄存器'
- en: 'Floating-point single-precision instructions:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点单精度指令：
- en: '`FMOV`: Floating-point move'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMOV`: 浮点移动'
- en: 'Floating-point double-precision instructions:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点双精度指令：
- en: '`FABS`: Floating-point absolute value'
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FABS`: 浮点绝对值'
- en: 'Floating-point control instructions:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点控制指令：
- en: '`LDS`: Load to FPU system register'
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDS`: 加载到FPU系统寄存器'
- en: Floating-point graphics acceleration instructions
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点图形加速指令
- en: '`FIPR`: Floating-point inner product'
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIPR`: 浮点内积'
- en: Working with SPARC
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPARC
- en: '**Scalable Processor Architecture** (**SPARC**) is a RISC ISA that was originally
    developed by Sun Microsystems (now part of the Oracle corporation). The first
    implementation was used in Sun’s own workstation and server systems. Later, it
    was licensed to multiple other manufacturers, one of them being Fujitsu. As Oracle
    terminated SPARC Design in 2017, all future development continued with Fujitsu
    as the main provider of SPARC servers.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展处理器架构** (**SPARC**) 是一种RISC指令集架构，最初由Sun Microsystems（现为Oracle公司的一部分）开发。首个实现被用于Sun自家的工作站和服务器系统。之后，它被授权给多个其他制造商，其中之一是富士通。随着Oracle在2017年终止了SPARC设计，未来的开发由富士通继续，成为SPARC服务器的主要供应商。'
- en: Several fully open source implementations of the SPARC architecture exist. Multiple
    OSs currently support it, including Oracle Solaris, Linux, and BSD systems, and
    multiple IoT malware families have dedicated modules for it as well.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种完全开源的SPARC架构实现。多个操作系统目前支持它，包括Oracle Solaris、Linux和BSD系统，同时多种物联网恶意软件家族也为其提供了专门的模块。
- en: Basics
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本知识
- en: 'According to the Oracle SPARC architecture documentation, the implementation
    may contain between 72 and 640 general-purpose 64-bit R registers. However, only
    31/32 GPRs are immediately visible at any one time; eight are global registers,
    R[0] to R[7] (also known as g0-g7), with the first register, g0, hardwired to
    0; 24 are associated with the following register windows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Oracle SPARC架构文档，实施可能包含72到640个通用64位R寄存器。然而，在任何时刻，只有31/32个GPR是立即可见的；其中八个是全局寄存器，R[0]至R[7]（也称为g0-g7），第一个寄存器g0是硬连接到0的；24个与以下寄存器窗口相关：
- en: '**Eight in registers in[0]-in[7] (R[24]-R[31])**: For passing arguments and
    returning results'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**八个输入寄存器 in[0]-in[7] (R[24]-R[31])**: 用于传递参数和返回结果'
- en: '**Eight local registers local[0]-local[7] (R[16]-R[23])**: For retaining local
    variables'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**八个本地寄存器 local[0]-local[7] (R[16]-R[23])**: 用于保留局部变量'
- en: '**Eight out registers out[0]-out[7] (R[8]-R[15])**: For passing arguments and
    returning results'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**八个输出寄存器 out[0]-out[7] (R[8]-R[15])**: 用于传递参数和返回结果'
- en: The `CALL` instruction writes its address into the out[7] (R[15]) register.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`CALL` 指令将其地址写入 out[7] (R[15]) 寄存器。'
- en: To pass arguments to the function, they must be placed in the out registers.
    When the function gains control, it will access them in its registers. Additional
    arguments can be provided through the stack. The result is placed in the first
    register, which then becomes the first out register when the function returns.
    The `SAVE` and `RESTORE` instructions are used in this switch to allocate a new
    register window and restore the previous one, respectively.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要将参数传递给函数，必须将它们放入输出寄存器中。当函数获得控制权时，它将访问这些寄存器。额外的参数可以通过栈传递。结果将放入第一个寄存器中，返回时该寄存器将变为第一个输出寄存器。`SAVE`和`RESTORE`指令在此切换中用于分别分配新的寄存器窗口并恢复先前的窗口。
- en: SPARC also has 32 single-precision FPRs (32-bit), 32 double-precision FPRs (64-bit),
    and 16 quad-precision FPRs (128- bit), some of which overlap.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: SPARC还具有32个单精度FPR（32位）、32个双精度FPR（64位）和16个四倍精度FPR（128位），其中一些是重叠的。
- en: 'Apart from that, many other registers serve specific purposes, including the
    following:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他寄存器用于特定目的，包括以下内容：
- en: '**FPRS**: Contains the FPU mode and status information'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FPRS**：包含FPU模式和状态信息'
- en: '**Ancillary state registers (ASR 0, ASR 2-6, ASR 19-22, and ASR 24-28 are not
    reserved)**: These serve multiple purposes, including the following:'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加状态寄存器（ASR 0、ASR 2-6、ASR 19-22和ASR 24-28不是保留的）**：这些寄存器有多个用途，包括以下内容：'
- en: '**ASR 2**: **Condition Codes Register (CCR)**'
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASR 2**：**条件代码寄存器（CCR）**'
- en: '**ASR 5**: PC'
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASR 5**：PC'
- en: '**ASR 6**: FPRS'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASR 6**：FPRS'
- en: '**ASR 19**: **General Status Register** (**GSR**)'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASR 19**：**通用状态寄存器**（**GSR**）'
- en: '**Register-Window PR state registers** (**PR 9-14**): These determine the state
    of the register windows, including the following:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器窗口PR状态寄存器**（**PR 9-14**）：这些寄存器决定寄存器窗口的状态，包括以下内容：'
- en: '**PR 9**: Current Window Pointer (CWP)'
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PR 9**：当前窗口指针（CWP）'
- en: '**PR 14**: Window State (WSTATE)'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PR 14**：窗口状态（WSTATE）'
- en: '**Non-register-Window PR state registers (PR 0-3, PR 5-8, and PR 16)**: Visible
    only to software running in privileged mode'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非寄存器窗口PR状态寄存器（PR 0-3、PR 5-8和PR 16）**：仅对在特权模式下运行的软件可见'
- en: 32-bit SPARC uses big-endianness, while 64-bit SPARC uses big-endian instructions
    but can access data in any order. SPARC also uses the notion of traps, which implement
    a transfer of control to privileged software using a dedicated table that may
    contain the first eight instructions (32 for some frequently used traps) of each
    trap handler. The base address of the table is set by software in a **Trap Base
    Address** (**TBA**) register.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 32位SPARC使用大端序，而64位SPARC使用大端指令，但可以以任何顺序访问数据。SPARC还使用陷阱的概念，利用一个专用表将控制转移到特权软件，该表可能包含每个陷阱处理程序的前八条指令（某些常用陷阱有32条）。该表的基地址由软件在**陷阱基地址**（**TBA**）寄存器中设置。
- en: The instruction set
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令集
- en: The instruction from the memory location, which is specified by the PC, is fetched
    and executed. Then, new values are assigned to the PC and the **Next Program Counter**
    (**NPC**), which is a pseudo-register.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存位置获取由PC指定的指令并执行。然后，新的值被分配给PC和**下一个程序计数器**（**NPC**），NPC是一个伪寄存器。
- en: 'Detailed instruction formats can be found in the individual instruction descriptions.
    Here are the basic categories of instructions supported, with examples:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的指令格式可以在各个指令描述中找到。以下是支持的基本指令类别及示例：
- en: 'Memory access:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存访问：
- en: '`LDUB`: Load unsigned byte'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDUB`：加载无符号字节'
- en: '`ST`: Store'
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST`：存储'
- en: 'Arithmetic/logical/shift integers:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术/逻辑/移位整数：
- en: '`ADD`: Add'
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：加法'
- en: '`SLL`: Shift left logical'
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLL`：逻辑左移'
- en: 'Control transfer:'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制转移：
- en: '`BE`: Branch on equal'
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BE`：等于时跳转'
- en: '`JMPL`: Jump and link'
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JMPL`：跳转并链接'
- en: '`CALL`: Call and link'
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CALL`：调用并链接'
- en: '`RETURN`: Return from the function'
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETURN`：从函数返回'
- en: 'State register access:'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态寄存器访问：
- en: '`WRCCR`: Write CCR'
  id: totrans-563
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WRCCR`：写入CCR'
- en: 'Floating-point operations:'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点运算：
- en: '`FOR`: Logical OR for F registers'
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FOR`：F寄存器的逻辑或'
- en: 'Conditional move:'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件移动：
- en: '`MOVcc`: Move if the condition is true for the selected condition code (cc)'
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOVcc`：当选择的条件代码（cc）条件为真时移动'
- en: 'Register window management:'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器窗口管理：
- en: '`SAVE`: Save the caller’s window'
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAVE`：保存调用者的窗口'
- en: '`FLUSHW`: Flush register windows'
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLUSHW`：刷新寄存器窗口'
- en: '`FPSUB`: Partitioned integer subtraction for F registers'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FPSUB`：F寄存器的分区整数减法'
- en: Moving from assembly to high-level programming languages
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从汇编语言到高级编程语言的转变
- en: Developers mostly don’t write in assembly. Instead, they write in higher-level
    languages, such as C or C++, and the compiler converts this high-level code into
    a low-level representation in assembly language. In this section, we will look
    at different code blocks represented in the assembly.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常不会直接编写汇编代码，而是使用更高级的语言，如 C 或 C++，然后编译器将这些高级代码转换为汇编语言中的低级表示。在本节中，我们将查看不同的汇编代码块。
- en: Arithmetic statements
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术语句
- en: 'Let’s look at different C statements and how they are represented in the assembly.
    We will use Intel IA-32 for this example. The same concept applies to other assembly
    languages as well:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下不同的 C 语句以及它们在汇编中的表示方式。我们将使用 Intel IA-32 作为示例。相同的概念也适用于其他汇编语言：
- en: 'X = 50 (assuming 0x00010000 is the address of the X variable in memory):'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X = 50 （假设 0x00010000 是 X 变量在内存中的地址）：
- en: '[PRE10]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'X = Y + 50 (assuming 0x00010000 represents X and 0x00020000 represents Y):'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X = Y + 50 （假设 0x00010000 表示 X，0x00020000 表示 Y）：
- en: '[PRE11]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'X = Y + (50 * 2):'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X = Y + (50 * 2)：
- en: '[PRE12]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'X = Y + (50 / 2):'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X = Y + (50 / 2)：
- en: '[PRE13]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'X = Y + (50 % 2) (% represents the modulo):'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X = Y + (50 % 2) （% 表示取余运算）：
- en: '[PRE14]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hopefully, this explains how the compiler converts these arithmetic statements
    into assembly language.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能解释编译器是如何将这些算术语句转换成汇编语言的。
- en: If conditions
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果条件
- en: 'Basic *if* statements may look like this:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 *if* 语句可能像这样：
- en: 'If (X == 50) (assuming 0x0001000 represents the X variable):'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: If (X == 50) （假设 0x0001000 表示 X 变量）：
- en: '[PRE15]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If (X & 00001000b) (| represents the logical AND):'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: If (X & 00001000b) （| 表示逻辑与运算）：
- en: '[PRE16]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To understand the branching and flow redirection, let’s look at the following
    diagram, which shows how it’s manifested in pseudocode:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解分支和流向重定向，我们来看一下下面的图表，它展示了在伪代码中的表现形式：
- en: '![Figure 2.9 – Conditional ﬂow redirection'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 条件流向重定向](img/Figure_2.9_B18500.jpg)'
- en: '](img/Figure_2.9_B18500.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.9_B18500.jpg)'
- en: Figure 2.9 – Conditional ﬂow redirection
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 条件流向重定向
- en: 'To apply this branching sequence in assembly, the compiler uses a mix of conditional
    and unconditional jumps, as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 要在汇编中应用此分支序列，编译器使用条件跳转和无条件跳转的混合方式，具体如下：
- en: 'IF.. THEN.. ENDIF:'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IF.. THEN.. ENDIF：
- en: '[PRE17]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'IF.. THEN.. ELSE.. ENDIF:'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IF.. THEN.. ELSE.. ENDIF：
- en: '[PRE18]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While loop conditions
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: While 循环条件
- en: 'The *while* loop conditions are quite similar to *if* conditions in terms of
    how they are represented in assembly:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '*while* 循环条件与 *if* 条件在汇编中的表示方式非常相似：'
- en: '| While (X == 50) {…} | `1st_Block:``cmp dword ptr [00010000h], 50``jnz 2nd_Block
    ; if not true``…``jmp 1st_Block``2nd_Block:``…` |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| While (X == 50) {…} | `1st_Block:``cmp dword ptr [00010000h], 50``jnz 2nd_Block
    ; 如果不成立``…``jmp 1st_Block``2nd_Block:``…` |'
- en: '| Do {} While(X == 50) | `1st_Block:``…``cmp dword ptr [00010000h], 50``jz
    1st_Block ; if true` |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| Do {} While(X == 50) | `1st_Block:``…``cmp dword ptr [00010000h], 50``jz
    1st_Block ; 如果成立` |'
- en: Summary
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the essentials of computer programming and described
    the universal elements that are shared between multiple CISC and RISC architectures.
    Then, we went through multiple assembly languages, including the ones behind Intel
    x86, ARM, MIPS, and others, and understood their application areas, which eventually
    shaped their design and structure. We also covered the fundamental basics of each
    of them, learned about the most important notions (such as the registers used
    and CPU modes supported), got an idea of how the instruction sets look, discovered
    what opcode formats are supported there, and explored what calling conventions
    are used. Finally, we went from the low-level assembly languages to their high-level
    representations in C or other similar languages and became familiar with a set
    of examples for universal blocks, such as if conditions and loops.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了计算机编程的基本知识，描述了多个 CISC 和 RISC 架构之间共享的通用元素。接着，我们详细讲解了多种汇编语言，包括 Intel
    x86、ARM、MIPS 等，并了解了它们的应用领域，这些都影响了它们的设计和结构。我们还讨论了每种语言的基本概念，学习了最重要的术语（例如使用的寄存器和支持的
    CPU 模式），了解了指令集的结构，发现了支持的操作码格式，并探索了使用的调用约定。最后，我们从低级汇编语言讲解到它们在 C 或其他类似语言中的高级表示，并熟悉了一些通用代码块的例子，如
    if 条件和循环。
- en: After reading this chapter, you should be able to read the disassembled code
    of different assembly languages and understand what high-level code it could represent.
    While not aiming to be completely comprehensive, the main goal of this chapter
    is to provide a strong foundation, as well as a direction that you can follow
    to deepen your knowledge before you analyze actual malicious code. It should be
    your starting point for learning how to perform static code analysis on different
    platforms and devices.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这一章后，你应该能够阅读不同汇编语言的反汇编代码，并理解它可能代表的高级代码。虽然本章并不旨在全面覆盖所有内容，但其主要目标是为你提供一个坚实的基础，并指引你如何在分析实际恶意代码之前进一步加深知识。这应该是你开始学习如何对不同平台和设备进行静态代码分析的起点。
- en: In [*Chapter 3*](B18500_03.xhtml#_idTextAnchor084), *Basic Static and Dynamic
    Analysis for x86/x64*, we will start analyzing the actual malware for particular
    platforms. The instruction sets we have become familiar with will be used as languages
    that describe their functionality.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18500_03.xhtml#_idTextAnchor084)，*x86/x64的基本静态与动态分析*中，我们将开始针对特定平台分析实际的恶意软件。我们已熟悉的指令集将作为描述其功能的语言。
- en: Part 2 Diving Deep into Windows Malware
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：深入解析Windows恶意软件
- en: With Windows remaining the most prevalent operating system for the PC, it is
    no surprise that the vast majority of existing malware families are focused on
    this platform. Moreover, the amount of attention and the high number of high-profile
    actors has led to Windows malware featuring multiple diverse and sophisticated
    techniques not common to other systems. Here, we will cover them in great detail
    and teach you how to analyze them using multiple real-world examples.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: Windows仍然是最普遍的个人电脑操作系统，因此，现有大多数恶意软件家族都集中在这个平台上也不足为奇。此外，由于高度关注和众多知名攻击者的参与，Windows恶意软件采用了许多多样化和复杂的技术，这些技术在其他系统中并不常见。在这里，我们将详细讲解这些技术，并通过多个真实世界的示例教你如何进行分析。
- en: 'In this section are the following chapters:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 3*](B18500_03.xhtml#_idTextAnchor084)*, Basic Static and Dynamic
    Analysis for x86/x64*'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B18500_03.xhtml#_idTextAnchor084)*，x86/x64的基本静态与动态分析*'
- en: '[*Chapter 4*](B18500_04.xhtml#_idTextAnchor238)*, Unpacking, Decryption, and
    Deobfuscation*'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18500_04.xhtml#_idTextAnchor238)*，解包、解密与去混淆*'
- en: '[*Chapter 5*](B18500_05.xhtml#_idTextAnchor446)*, Inspecting Process Injection
    and API Hooking*'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18500_05.xhtml#_idTextAnchor446)*，检查进程注入和API钩子*'
- en: '[*Chapter 6*](B18500_06.xhtml#_idTextAnchor554)*, Bypassing Anti-Reverse Engineering
    Techniques*'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18500_06.xhtml#_idTextAnchor554)*，绕过反向工程技术*'
- en: '[*Chapter 7*](B18500_07.xhtml#_idTextAnchor669)*, Understanding Kernel-Mode
    Rootkits*'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18500_07.xhtml#_idTextAnchor669)*，理解内核模式Rootkit*'
