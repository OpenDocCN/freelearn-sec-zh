- en: '*Chapter 8*: Python Fundamentals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：Python 基础'
- en: 'It’s said that computers are actually very dumb; they crunch numbers and move
    things around in memory. Despite this oversimplification, how they think can seem
    mysterious. There is no better way to get acquainted with how computers actually
    think than through programming. Elsewhere in this book, we’ll see programming
    languages at different scales—assembly language, the machine code made up of mnemonic
    **operation code** (**opcode**) one up from the bottom; C language, the lowest
    of the high-level languages; and even Python, the high-level interpreted language.
    Python has a tremendous number of modules in its standard library that allow a
    **penetration tester** (**pen tester**) to accomplish just about any task. In
    [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Bypassing Network
    Access Control*, we showed how easy it is to use Scapy’s functionality in our
    own Python script to inject specially crafted packets into the network. One way
    we can advance as pen testers is by learning how to leverage this power in our
    own custom programs. In this chapter, we’re going to review using Python in a
    security assessment context. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传说计算机其实非常笨拙；它们只是在进行数字计算和在内存中移动东西。尽管这一说法有些过于简化，但它们如何“思考”仍然显得神秘莫测。没有比编程更好的方式来了解计算机实际如何思考了。本书的其他地方，我们将看到不同层次的编程语言——汇编语言，最底层的机器代码，由助记符**操作码**（**opcode**）构成；C
    语言，最基础的高级语言；甚至 Python，作为一种高级解释型语言。Python 拥有庞大的标准库模块，可以帮助**渗透测试员**（**pen tester**）完成几乎所有任务。在[*第
    2 章*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)，*绕过网络访问控制*中，我们展示了如何在自己的
    Python 脚本中使用 Scapy 的功能，将特制的数据包注入网络。作为渗透测试员，我们可以通过学习如何在自己的自定义程序中利用这些功能来进一步提升自己的技能。本章将回顾如何在安全评估的背景下使用
    Python，我们将讨论以下主题：
- en: Incorporating Python into your work
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Python 融入你的工作
- en: Introducing Vim with Python awareness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 环境下介绍 Vim
- en: Network analysis with Python modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 模块进行网络分析
- en: Antimalware evasion in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中进行反恶意软件逃逸
- en: Python and Scapy—a classy pair
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 和 Scapy——一对经典搭档
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the exercises in this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你将需要以下内容：
- en: Kali Linux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A Windows host with Python installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Python 的 Windows 主机
- en: '**Pip Installs Python** (**pip**) and PyInstaller on Windows (part of the Python
    installation)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pip 安装 Python**（**pip**）和 PyInstaller 在 Windows 上的安装（Python 安装的一部分）'
- en: Incorporating Python into your work
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Python 融入你的工作
- en: 'I’ve been asked by many people: *Do you need to be a programmer to be a pen
    tester?* This is one of those questions that will spawn a variety of passionate
    answers from purists of all kinds. Some people say that you can’t be a true hacker
    without being a skilled programmer. My view is that the definition is less about
    a specific skill than about comprehension and mentality; hacking is a problem-solving
    personality and a lifestyle. That said, let’s be honest—your progress will be
    hampered by a lack of working knowledge in some programming and scripting. Being
    a pen tester is being a jack of all trades, so we need to have some exposure to
    a variety of languages, as opposed to a developer who specializes. If we were
    to pick a minimum requirement on the subject of programming and pen testing, I
    would tell you to pick up a scripting language. If I had to pick just one scripting
    language for the security practitioner, I’d pick Python.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人问过我：*做渗透测试员需要是程序员吗？* 这是一个会引发各种激烈争论的问题，纯粹主义者们会给出不同的回答。有些人说，如果没有成为一名熟练的程序员，就不能算真正的黑客。我的观点是，黑客的定义与具体技能关系不大，而更关乎理解力和心态；黑客是一种解决问题的个性和生活方式。话虽如此，我们得承认——如果没有一定的编程和脚本知识，进步将会受到阻碍。做渗透测试员就像是一个万事通，我们需要接触多种语言，而不是专注于一种语言的开发者。如果要在编程与渗透测试这方面选择一个最低要求，我会建议你学习一门脚本语言。如果只能选一门脚本语言来作为安全从业人员的入门，我会选择
    Python。
- en: What’s the difference between a programming language and a scripting language?
    To be clear, a scripting language is a programming language, so the difference
    between them is in the steps taken between coding and execution. A scripting language
    doesn’t require the compilation step; a script is interpreted by instruction at
    the time of execution—hence the proper term for such a language is interpreted
    language. C is an example of a traditional programming language that requires
    compilation before execution. However, these lines are increasingly blurred. For
    example, there’s no reason why a C interpreter isn’t possible. Using one would
    allow you to write C scripts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言和脚本语言有什么区别？为了明确起见，脚本语言也是一种编程语言，它们之间的区别在于从编码到执行之间所采取的步骤。脚本语言不需要编译步骤；脚本在执行时按指令进行解释——因此，这类语言的正确术语应该是解释型语言。C
    语言是传统编程语言的一个例子，它在执行之前需要编译。然而，这些界限正变得越来越模糊。例如，完全可以有一个 C 解释器的存在，使用它可以让你编写 C 脚本。
- en: Why Python?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Python？
- en: Python is an ideal choice for many reasons, but two elements of its design philosophy
    make it ideal for our goal of becoming an advanced pen tester—its power (it was
    originally designed to appeal to Unix/C hackers) coupled with its emphasis on
    readability and reusability. As a professional, you’ll be working with others
    (don’t plan on the black-hat lone-wolf mentality in this field); Python is one
    of the few languages where sharing your handy tool with a colleague will likely
    not result in follow-up *what the heck were you thinking?* emails to understand
    your constructs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一个理想的选择，原因有很多，但它的设计哲学中的两个元素使其特别适合我们的目标——成为一个高级渗透测试人员——它的强大（它最初设计是为了吸引
    Unix/C 黑客）和它对可读性与可重用性的强调。作为专业人士，你将和其他人一起工作（不要指望在这个领域能够像黑帽孤狼那样独自作战）；Python 是少数几种语言之一，与你的同事分享你得心应手的工具，很可能不会收到后续的*你到底在想什么？*邮件来了解你的构建思路。
- en: Perhaps most importantly, Python is one of those things that you may find on
    a target embedded well behind the perimeter of your client’s network. You’ve pivoted
    your way in, and you find yourself on a juicy internal network, but the hosts
    you land on don’t have the tools you need. It’s surprising how often you’ll find
    Python installed in such environments. On top of that, you’ll always find a Python-aware
    text editor on any compromised Linux box. We’ll discuss editors next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的一点是，Python 是你可能会在客户网络外围后面发现的目标之一。你已经通过某种方式进入了网络，发现自己处于一个丰富的内部网络中，但你登陆的主机上没有你需要的工具。令人惊讶的是，你会发现
    Python 在这样的环境中已经安装得相当普遍。更重要的是，你总能在任何被攻陷的 Linux 主机上找到一个 Python-aware 的文本编辑器。接下来我们将讨论编辑器。
- en: A core concept in Python that makes it the number one choice of hackers is **modules**.
    A module is a simple concept, but with powerful implications for the Python programmer.
    A module is nothing more than a file that contains Python code whose functionality
    can be brought into your code with the **import** statement. With this functionality,
    all attributes (or perhaps a specific attribute) of the module become referenceable
    in your code. You can also use **from [module] import** to pick and choose the
    attributes you need. There is a tremendous number of modules written by clever
    people from around the world, all ready for you to place in the **import** search
    path so that you can bring in any attribute you desire to do some work in your
    code. The end result? A compact and highly readable chunk of Python that does
    some tremendous things.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的一个核心概念使其成为黑客首选的编程语言，那就是**模块**。模块是一个简单的概念，但对于 Python 程序员来说却具有强大的影响力。模块不过是一个包含
    Python 代码的文件，其功能可以通过**import**语句引入到你的代码中。通过这个功能，模块的所有属性（或者说是某个特定属性）都可以在你的代码中被引用。你也可以使用**from
    [module] import**来挑选并引入你需要的属性。全球有许多聪明的人编写了大量的模块，随时准备供你放入**import**搜索路径中，这样你就能引入任何你想要的属性来在代码中完成某些工作。最终结果？一块紧凑且高度可读的
    Python 代码，能够完成一些非常棒的事情。
- en: At the time of writing this chapter, Python 3 is the latest and greatest, and
    anyone still using Python 2 for production tasks is being strongly encouraged
    to get familiar with Python 3\. A handy Python tool called **2to3** will translate
    your Python 2 into Python 3\. We’ll explore configuring your global installation
    to a specific version for backwards compatibility in [*Chapter 12*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224),
    *Shellcoding - Evading Antivirus*. Now that we’re familiar with the basics, let’s
    get familiar with the Python editor on Kali.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在写本章时，Python 3 是最新最强大的版本，任何仍然在生产环境中使用 Python 2 的人，都被强烈鼓励熟悉 Python 3。一个实用的 Python
    工具 **2to3** 可以将你的 Python 2 代码转换为 Python 3。我们将在[*第 12 章*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224)，*Shellcoding
    - Evading Antivirus* 中探讨如何配置全局安装以实现向后兼容性。既然我们已经熟悉了基础知识，那么让我们熟悉一下 Kali 中的 Python
    编辑器吧。
- en: Getting cozy with Python in your Kali environment
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Kali 环境中舒适地使用 Python
- en: 'There are two primary components you’ll use during Python development—the interactive
    interpreter and the editor. The interpreter is called up with the following simple
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 开发过程中，你将使用两个主要组件——交互式解释器和编辑器。你可以通过以下简单命令调用解释器：
- en: python3
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: python3
- en: The interpreter is exactly what it sounds like—it will interpret Python code
    on the fly. This is a real time-saver when you’re coding, as you can—for instance—check
    your formula without closing out the editor and running the code, looking for
    the line in question.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器正如其名称所示——它会即时解释 Python 代码。当你在编写代码时，这能够节省大量时间，因为你可以——例如——检查你的公式，而无需关闭编辑器并运行代码，寻找相关行。
- en: 'In this example, we issued **print("Hello, world!")** and the interpreter simply
    printed the string. I then tried a formula and messed around with using **int()**
    to round the result to the nearest integer. Thus, I experimented with my formula
    and learned a little about Python without needing to write this out and run it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们输入了 **print("Hello, world!")**，解释器简单地打印了这个字符串。我随后尝试了一个公式，并玩弄了 **int()**
    函数来将结果四舍五入到最接近的整数。因此，我在没有编写和运行代码的情况下，实验了我的公式，并了解了一些关于 Python 的知识：
- en: '![Figure 8.1 – Playing with Python 3 in Kali ](image/Figure_8.1_B17616.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 在 Kali 中玩转 Python 3](image/Figure_8.1_B17616.jpg)'
- en: Figure 8.1 – Playing with Python 3 in Kali
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 在 Kali 中玩转 Python 3
- en: It should come as no surprise to learn that most Python coders work on their
    projects with two screens open—the interpreter and the editor. The interpreter
    is built into the Python installation; what you get when you punch in **python3**
    and hit *Return* is what people will use. The editor, on the other hand, can be
    a personal choice—and once again, opinions in this arena can be passionate!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 Python 开发者来说，使用两个屏幕同时打开——一个是解释器，另一个是编辑器——这并不是什么惊讶的事。解释器是 Python 安装的一部分；你输入
    **python3** 并按下 *回车* 键时，所得到的就是人们将要使用的解释器。而编辑器则可以根据个人喜好选择——再次强调，这个领域的观点通常会非常激烈！
- en: The editor is just a text editor; technically, a Python file is text. I could
    write up a Python script with Windows Notepad and it would work fine—but I wouldn’t
    recommend it (telling people that’s how you code would be a fun way to get weird
    looks). If it’s just a text editor, what’s the big deal? The main feature you’re
    looking for in an editor is syntax awareness—the editor understands the language
    you’re typing in and displays the syntax in a distinctive way for you. It turns
    text that just happens to be Python into a living piece of code, and it makes
    your life a lot easier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器只是一个文本编辑器；从技术上讲，Python 文件也是文本。我可以用 Windows 记事本写 Python 脚本，它也能正常工作——但我并不推荐这么做（告诉别人你就是这么写代码的，那一定会引来奇怪的目光）。如果它只是一个文本编辑器，那又有什么大不了的呢？你在选择编辑器时最重要的特性是语法意识——编辑器能够理解你正在输入的语言，并以独特的方式展示语法。它将原本只是
    Python 的文本，变成一个活生生的代码片段，让你的生活变得更加轻松。
- en: The tiniest of errors—such as forgetting a single closing quotation mark—stick
    out like a sore thumb as the editor tries to understand your syntax. There are
    several great options for syntax-aware editors; some popular ones are Notepad++,
    gedit, nano, Kate, and Vim. Now, the more serious developer will probably use
    an **integrated development environment** (**IDE**), which is a more comprehensive
    solution for understanding what your code is doing, and it also assists in writing
    the code. An IDE may have a debugger and a class browser, for example, whereas
    an editor will not. There are many IDEs to choose from, most of them free with
    commercial versions and supporting a variety of operating systems; a couple of
    good ones are *Wing IDE* and *PyCharm*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哪怕是最小的错误——例如忘记了一个闭合的引号——都会在编辑器试图理解你的语法时突出得像一个明显的伤口。市面上有几款很好的语法感知编辑器；一些流行的包括Notepad++、gedit、nano、Kate和Vim。现在，更为严谨的开发者可能会使用**集成开发环境**（**IDE**），它是一个更全面的解决方案，帮助你理解代码的执行，并协助编写代码。IDE可能有调试器和类浏览器等功能，而编辑器则没有。市面上有很多IDE可供选择，大多数都是免费的，且有商业版，支持各种操作系统；其中一些好的IDE包括*Wing
    IDE*和*PyCharm*。
- en: IDEs are cool, but please note that we won’t be working in one for our purposes
    here. It’s recommended you get familiar with your favorite IDE, but our objective
    here is minimalism and flexibility. Having a cozy IDE setup is the kind of thing
    you have on a designated machine, which will be fantastic for writing up a new
    toolset to carry around with you on your assignments. The context of our discussion
    here, on the other hand, is writing up Python scripts on a bare-bones machine
    where having your favorite IDE may not be practical. Being able to get by with
    just a plain Python install plus an editor is more important than learning an
    IDE, so I encourage you to master one outside of this book. For now, we’re going
    to proceed with an editor that’s ready to go on just about any Linux box and should
    natively understand Python syntax. My choice of editor may cause some readers
    to literally burn this book with fire, and other readers will cheer. Yes—I’m going
    to work with Vim.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IDE很酷，但请注意，我们在这里的目的并不是使用它。建议你熟悉你最喜欢的IDE，但我们的目标是追求简约和灵活性。拥有一个舒适的IDE设置是你在专用机器上使用的东西，这对于编写一个新的工具集并在你的任务中携带会非常棒。而我们这里讨论的背景是，在一个基本的机器上编写Python脚本，在这种情况下，使用你最喜欢的IDE可能不太实际。能够仅靠一个普通的Python安装加上一个编辑器就能应付，远比学习一个IDE更为重要，所以我鼓励你在这本书外掌握一个IDE。现在，我们将继续使用一个几乎任何Linux机器上都能启动的编辑器，并且应该能够原生理解Python语法。我选择的编辑器可能会让一些读者直接把这本书当火把烧掉，而其他读者则会为此欢呼。没错——我要使用Vim。
- en: Introducing Vim with Python syntax awareness
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍具有Python语法感知的Vim
- en: 'To get an idea of Vim’s notoriety as an editor, just type this into your favorite
    search engine: **how do I quit Vim?**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Vim作为编辑器的声名狼藉，只需在你最喜欢的搜索引擎中输入：**如何退出Vim？**
- en: 'Vim stands for **Vi IMproved** because it’s a clone of the original vi editor,
    but with some changes touted as improvements. To be fair, they are improvements,
    and it has many—we won’t cover them all here. But there is one key improvement—its
    native support for scripting languages such as Python. Another improvement comes
    in handy for those who are just not ready for Vim’s sitting-in-the-cockpit-of-a-space-shuttle
    feel: the graphical interface version of Vim, known as gVim. The graphical version
    is still Vim at its core, so feel free to play around with it.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Vim代表**Vi IMproved**，因为它是原始vi编辑器的克隆，但做了一些被称为改进的变化。公平地说，这些确实是改进，而且它有很多——我们这里不会一一讲解。但有一个关键的改进——它对脚本语言（如Python）的原生支持。另一个改进对于那些还没准备好适应Vim那种“坐在航天飞机驾驶舱”的感觉的人来说非常实用：Vim的图形界面版本，称为gVim。图形版本本质上还是Vim，所以可以随意尝试。
- en: I should probably mention the long and bloody editor war between Emacs and vi/Vim.
    My choosing Vim for this chapter’s purpose isn’t a statement in this regard. I
    prefer it as a fast and lightweight tool where text editing with Python syntax
    discrimination is our primary focus. My favorite description of Emacs is an operating
    system within an operating system—I think it’s too much editor for our needs here.
    I encourage the reader to dabble in both of them outside of these pages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我或许应该提一下Emacs和vi/Vim之间那场漫长且血腥的编辑器战争。我选择Vim作为本章的工具并不是对这场战争的表态。我更倾向于将其作为一个快速且轻量的工具，在这里，我们的主要关注点是带有Python语法区分的文本编辑。对Emacs的最喜欢的描述是它是一个操作系统内的操作系统——我认为它对于我们在这里的需求来说有点过于复杂。我鼓励读者在本章之外也尝试使用这两者。
- en: 'Fire up Vim with this simple command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的命令启动Vim：
- en: vim
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vim
- en: 'You will see an editor with a splash screen that lets you know how to get right
    into the help file, as illustrated here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个编辑器启动屏幕，告诉你如何快速进入帮助文件，如下所示：
- en: '![Figure 8.2 – The Vim splash screen ](image/Figure_8.2_B17616.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Vim 启动屏幕](image/Figure_8.2_B17616.jpg)'
- en: Figure 8.2 – The Vim splash screen
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Vim 启动屏幕
- en: When you open up any document in Vim (or just start a fresh session), you’re
    reviewing, not editing. To actually type into a document is called **insert mode**,
    which you enable with the *i* key. You’ll see the word **INSERT** at the bottom
    of the screen. Use *Esc* to exit insert mode. Issuing a command to Vim is done
    with a colon followed by the specific command—for example, exiting Vim is done
    with **:q** followed by *Enter*. Don’t worry about too much detail at the moment;
    we’ll step through the basics as we write up our scripts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Vim 中打开任何文档（或开始一个新会话）时，你是在浏览文件，而不是编辑。要真正输入文档内容，我们称之为 **插入模式**，可以通过按 *i*
    键启用。你会在屏幕底部看到 **INSERT** 字样。使用 *Esc* 键退出插入模式。向 Vim 输入命令时，用冒号（:）加上具体的命令——例如，退出
    Vim 就是输入 **:q** 后按 *Enter*。暂时不用担心太多细节，我们在编写脚本时会一步一步讲解基础操作。
- en: 'Before we write our first handy-for-hacking Python script, let’s get the syntax
    highlighting turned on and write a quick **hello_world** program. In Kali, Vim
    is already able to understand Python syntax; we just have to tell Vim that we’re
    working with a specific file type. First, start with **vim** followed by a filename,
    and then hit **:** to enter command mode, as illustrated here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写第一个有用的 Python 脚本之前，先开启语法高亮并编写一个简单的 **hello_world** 程序。在 Kali 中，Vim 已经能够识别
    Python 语法；我们只需要告诉 Vim 我们正在处理特定类型的文件。首先，输入 **vim** 和文件名，然后按 **:** 进入命令模式，如下所示：
- en: vim hello_world.py
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vim hello_world.py
- en: 'Then, issue this command, followed by *Enter*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令并按 *Enter*：
- en: :set filetype=python
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: :set filetype=python
- en: 'When you’re ready, hit the *i* key to enter insert mode. As you type a Python
    script, the syntax will be highlighted accordingly. Write your **Hello, World**
    script, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，按 *i* 键进入插入模式。当你输入 Python 脚本时，语法会自动高亮显示。写下你的 **Hello, World** 脚本，像这样：
- en: print("Hello, World!")
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello, World!")
- en: Hit *Esc* to leave insert mode. Then, use **:wq!** to save your changes and
    exit Vim in one fell swoop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Esc* 退出插入模式。然后，使用 **:wq!** 保存更改并一键退出 Vim。
- en: 'Run your program and marvel at your masterpiece. Here it is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序，惊叹于你的杰作吧。它就是这样：
- en: '![Figure 8.3 – Hello, World! in Python ](image/Figure_8.3_B17616.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – Python 中的 Hello, World!](image/Figure_8.3_B17616.jpg)'
- en: Figure 8.3 – Hello, World! in Python
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Python 中的 Hello, World!
- en: Okay—enough messing around. Let’s do some networking.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，别再浪费时间了。让我们开始做一些网络编程吧。
- en: Network analysis with Python modules
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 模块进行网络分析
- en: A Python script with the right modules can be a mature and powerful network
    technician. Python has a place in every layer of abstraction you can think of.
    Do you need just a quick and dirty service to be the frontend for some task such
    as downloading files? Python has your back. Do you need to get nitty-gritty with
    low-level protocols, scripting out specific packet manipulation activities nested
    in conditional logic, chatting with the network at layer 3, and even down to the
    data-link layer? Python makes this fun and easy. The best part is the portability
    of any project you can imagine; as I mentioned, you will be functioning on a team
    as a pen tester, and there are few situations in which you will function all alone.
    Even if you are on a project where you’re working as a lone wolf, white hats are
    there to inform the client, and there are no trade secrets or magician’s code,
    so you may be asked to lay out in understandable terms how the bad guys can get
    away with your win. Sending some code to someone—whether a skilled colleague or
    a knowledgeable administrator representing your client—can put a bit of a demand
    on the recipient when the **proof of concept** (**POC**) requires environmental
    dependencies and lengthy work to put it together in a lab. A Python script, on
    the other hand, is just a breeze to work with. The most you may need to provide
    are special modules that aren’t already part of the vast Python community. An
    area where Python shines is with networking, which is appropriate considering
    the importance of network tasks for just about any assessment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的模块的Python脚本可以成为一个成熟和强大的网络技术员。Python在你能想到的每一个抽象层面都有它的位置。你只需要一个快速而粗糙的服务作为一些任务的前端，比如下载文件？Python来帮忙。你需要深入了解低级协议，通过条件逻辑嵌套脚本化特定数据包操作，与第3层的网络交流，甚至下到数据链路层？Python让这一切变得有趣而容易。最棒的部分是你可以想象到的任何项目的可移植性；正如我提到的，你将作为一个渗透测试人员在一个团队中工作，很少有你会独自工作的情况。即使你是一个独行侠项目，白帽黑客都会通知客户，没有商业机密或魔术师的代码，所以你可能会被要求用可理解的术语解释坏人如何逃脱你的胜利。向某人发送一些代码——无论是熟练的同事还是代表你客户的知识渊博的管理员——当**概念验证**（**POC**）需要环境依赖和长时间的实验室组装时，这可能会对接收者提出一些要求。另一方面，Python脚本则非常易于使用。你可能需要提供的最多是并未包含在庞大的Python社区中的特殊模块。Python在网络编程方面表现突出，考虑到网络任务在任何评估中的重要性，这是合适的。
- en: Python modules for networking
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络编程的Python模块
- en: Our fun little **hello_world** program needed nothing more than Python to interpret
    your sophisticated code. However, you’ve no doubt realized that **hello_world**
    doesn’t really serve the pen tester too well. For one, all it does is display
    an overused cliché. But even if it were handier, there are no imports. In terms
    of capability, what you see is what you get. Truly unleashing Python happens when
    we expose capability with modules. If I were to guess what kind of task you’ll
    be employing the most, I’d guess networking.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有趣的小**hello_world**程序只需要Python来解释你复杂的代码。然而，你毫无疑问已经意识到，**hello_world**对于渗透测试人员来说并不太有用。首先，它只是展示一个过度使用的陈词滥调。但即使它更方便，也没有导入。就功能而言，你看到的就是你得到的。真正释放Python的能力是当我们用模块展示能力时。如果我要猜测你最常使用的任务类型，我会猜测是网络编程。
- en: 'There are many options available to the Python coder to make their script chatty
    with the network. The key to understanding modules in general is by organizing
    them in terms of layers or levels. Lower-layer modules give you the most power,
    but they can be difficult to use properly; higher-layer modules allow you to write
    code that’s more Pythonic by taking care of lower constructs behind the scenes.
    Anything that works at a higher layer of abstraction can be coded with lower layers,
    but typically with more lines of code. Take, for example, the **socket** module.
    The **socket** module is a low-level networking module: it exposes the **Berkeley
    Software Distribution** (**BSD**) **sockets** **application programming interface**
    (**API**). A single import of **socket** combined with the right code will allow
    your Python program to do just about anything on the network. If you’re the ambitious
    type who is hoping to replace—say—**Network Mapper** (**Nmap**) with your own
    Python magic, then I bet the very first line of your code is simply **import socket**.
    On the high-level side of things, you have modules such as **requests**, which
    allows for highly intuitive **HyperText Transfer Protocol** (**HTTP**) interaction.
    A single line of code with **requests** imported will put an entire web page into
    a single manipulable Python object. Not too shabby.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员有很多选项可以让他们的脚本与网络进行交互。理解模块的关键是通过层级或级别来组织它们。低层模块给你最大的控制权，但它们可能难以正确使用；高级模块通过在幕后处理低级构造，让你编写更具Python风格的代码。任何在更高抽象层次上工作的东西，都可以通过低层代码实现，但通常需要更多的代码行。以**socket**模块为例，**socket**是一个低级网络模块：它暴露了**伯克利软件分发**（**BSD**）**套接字**应用程序接口（**API**）。通过导入**socket**并配合正确的代码，你的Python程序几乎可以在网络上做任何事情。如果你是那种有雄心的人，想用Python的魔力替代——比如——**网络映射器**（**Nmap**），那么我敢打赌你代码的第一行就是**import
    socket**。在高级层面上，你有像**requests**这样的模块，它允许你进行直观的**超文本传输协议**（**HTTP**）交互。只需一行代码，导入**requests**就能把整个网页转换为一个可以操作的Python对象。不错吧。
- en: Remember—anything that works at a high level can be built with low-level code
    and modules; you can’t use high-level modules to do low-level tasks. So, let’s
    take an example. Using Python in pen testing contexts will make heavy use of **socket**,
    so let’s throw together a quick and dirty client. With only 11 lines of code,
    we can connect and talk to a service, and store its response.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——任何在高级别上工作的东西都可以通过低级别代码和模块来构建；你不能用高级模块来完成低级任务。所以，让我们举个例子。在渗透测试中使用Python将大量依赖于**socket**，因此让我们快速构建一个简单粗暴的客户端。仅用11行代码，我们就可以连接并与服务进行交互，并存储其响应。
- en: Keep in mind that **socket**, being low-level, makes calls to socket APIs of
    the operating system. This may make your script platform-dependent! Now, let’s
    jump into building our client skeleton.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**socket**作为低级模块，会调用操作系统的套接字API。这可能会使你的脚本依赖于平台！现在，让我们开始构建我们的客户端骨架。
- en: Building a Python client
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Python客户端
- en: In our example, I’ve set up an HTTP server in my lab at **192.168.108.229**
    over the standard port **80**. I’m writing up a client that will establish a TCP
    connection with the target IP address and port, send a specially crafted request,
    receive a maximum of 4,096 bytes of response, store it in a local variable, and
    then simply display that variable to the user. I leave it to your imagination
    to figure out where you could go from here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我已经在我的实验室中通过标准端口**80**设置了一个HTTP服务器，IP地址为**192.168.108.229**。我正在编写一个客户端，它将与目标IP地址和端口建立TCP连接，发送一个特定格式的请求，接收最多4,096字节的响应，将其存储在本地变量中，然后简单地将该变量显示给用户。我将其余部分留给你自己想象，看看你能从这里出发去做些什么。
- en: 'The very first line you’ll see in our examples for this chapter is **#!/usr/bin/python3**.
    When we used Python scripts earlier in the book, you’ll recall that we used **chmod**
    to make the script executable in Linux, and then executed it with **./** (which
    tells the operating system that the executable is in the current directory instead
    of in the user’s **$PATH**). **#!** is called a shebang (yes—I’m serious), and
    it tells the script where to find the interpreter. By including that line, you
    can treat the script as an executable because the interpreter can be found thanks
    to your shebang line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的例子中，你会看到的第一行是**#!/usr/bin/python3**。回想一下我们在书中早些时候使用 Python 脚本的部分，你会记得我们用**chmod**命令让脚本在
    Linux 中可执行，然后使用**./**执行它（这告诉操作系统可执行文件位于当前目录，而不是在用户的**$PATH**中）。**#!**被称为 shebang（没错，我是认真的），它告诉脚本在哪里找到解释器。通过包含这一行，你可以将脚本视为可执行文件，因为解释器可以通过你的
    shebang 行找到：
- en: '![Figure 8.4 – The bare-bones client ](image/Figure_8.4_B17616.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 最基本的客户端 ](image/Figure_8.4_B17616.jpg)'
- en: Figure 8.4 – The bare-bones client
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 最基本的客户端
- en: 'Let’s take a look at this simple code piece by piece, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步查看这段简单的代码：
- en: With **webhost** and **webport**, we define the target IP address and port.
    In our case, we’re defining it within the script, but you could also take input
    from the user.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**webhost**和**webport**，我们定义了目标的 IP 地址和端口。在我们的例子中，我们在脚本中定义它们，但你也可以从用户那里获取输入。
- en: 'We’re already familiar with **print()**, but in this case, we can see how variables
    are displayed within the printed text. Keep in mind that IP addresses are strings,
    and ports are ordinary integers: look at how we assigned **webport** without the
    single quotes. We’ll ask Python to unpack our sequence with an asterisk (*****)
    and **print()** will take care of our type casting for us.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经熟悉了**print()**，但在这个例子中，我们可以看到变量是如何在打印文本中显示的。请记住，IP 地址是字符串，端口是普通整数：看看我们是如何分配**webport**的，而没有使用单引号。我们将使用星号（*****）让
    Python 解包我们的序列，而**print()**会为我们处理类型转换。
- en: 'And now, the fun part. Calling **socket.socket()** creates a Python object
    of your choosing; it looks like a variable, and it is the Pythonic representation
    of the created socket. In our example, we create a socket called **webclient**.
    From this point forward, we use **webclient** to work through the socket. The
    socket is low-level enough that we need to let it know which address family we’re
    using, as Unix systems can support a pile of them. This is where **AF_INET** comes
    in: **AF** designates an address family, and **INET** refers to **IP version 4**
    (**IPv4**). (**AF_INET6** will work with IPv6 for when you’re feeling saucy.)
    **SOCK_STREAM** means we’re using a stream socket as opposed to a datagram socket.
    To put it simply, a stream socket is where we have well-defined TCP conversations.
    Datagrams are the fire-and-forget variety. A combination of **AF_INET** and **SOCK_SOCKET**
    is what you’ll use almost every time.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。调用**socket.socket()**创建一个你选择的 Python 对象；它看起来像一个变量，并且是创建的套接字的 Python
    表示。在我们的例子中，我们创建了一个名为**webclient**的套接字。从现在起，我们使用**webclient**来操作这个套接字。由于套接字是低级别的，我们需要告诉它我们使用的是哪种地址族，因为
    Unix 系统可以支持多种地址族。这时，**AF_INET**就派上用场了：**AF**表示地址族，**INET**表示**IP version 4**（**IPv4**）。(**AF_INET6**适用于IPv6，当你需要更复杂的操作时可以使用。)
    **SOCK_STREAM**表示我们使用的是流套接字，而不是数据报套接字。简单来说，流套接字用于进行有明确约定的 TCP 会话，而数据报则是“发了就算”的类型。**AF_INET**和**SOCK_STREAM**的组合是你几乎每次都会使用的。
- en: Now, we work with our socket by separating the object name and the task with
    a period. As you can imagine, you could set up a whole mess of **sockets** with
    unique names and manage connections through them with your code. **webclient.connect()**
    establishes a TCP connection with the target IP and port. Follow that up with
    **webclient.send()** to send data to that established connection. Keep in mind
    that **send()** needs its argument as bytes, so a simple string won’t work—we
    put **b** before the string to accomplish that.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们通过用句点分隔对象名称和任务来操作我们的套接字。如你所料，你可以设置一堆具有唯一名称的**sockets**，并通过它们管理代码中的连接。**webclient.connect()**建立与目标
    IP 和端口的 TCP 连接。接着使用**webclient.send()**将数据发送到已建立的连接。请记住，**send()**需要将其参数作为字节传递，因此简单的字符串不起作用——我们在字符串前加上**b**来实现这一点。
- en: Just as in any healthy relationship, we send a nice message, and we expect a
    response. **webclient.recv()** prepares some space for this response; the argument
    taken is the size of this prepared space, and the prepared space is given a name
    so that it becomes an object in our code—I’m calling it the boring-but-logical
    **reply** in this case.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像在任何健康的关系中一样，我们发送一个友好的消息，并期望得到回应。**webclient.recv()** 为这个回应准备了一些空间；它接受的参数是这个准备空间的大小，且准备空间被命名，使其成为我们代码中的一个对象——在这个例子中，我称它为枯燥但合逻辑的**reply**。
- en: We wrap it up by just displaying the **reply** object—the response from the
    contacted server—but you could do whatever you want to the reply. Also, note that
    the script ends here, so we don’t see the implications of using **sockets**—they
    are typically short-lived entities meant for short conversations, so at this point,
    the socket would be torn down. Keep this in mind when you work with **sockets**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过显示**reply**对象——与被联系服务器的响应——来结束，但你可以对回复做任何你想做的事情。此外，请注意，脚本到此为止，因此我们没有看到使用**sockets**的影响——它们通常是短暂存在的实体，专门用于短暂的对话，因此此时套接字将被拆除。在处理**sockets**时请记住这一点。
- en: Building a Python server
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个 Python 服务器
- en: 'Now, we’re going to set up a simple server. I say *simple* server, which may
    make you think *something such as an HTTP server with just basic functionality*—no;
    I mean simple. This will simply listen for connections and take an action upon
    receipt of data. Let’s take a look at the code here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个简单的服务器。我说的是*简单*服务器，这可能会让你想象成*只是具有基本功能的 HTTP 服务器*——不，我指的是真正简单的。这将仅仅监听连接，并在接收到数据后采取行动。让我们看看这里的代码：
- en: '![Figure 8.5 – The bare-bones server ](image/Figure_8.5_B17616.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 基础服务器](image/Figure_8.5_B17616.jpg)'
- en: Figure 8.5 – The bare-bones server
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 基础服务器
- en: 'Note that I’ve brought in a new module: **threading**. This module is itself
    a high-level module for interfacing to the **thread** module (called **_thread**
    in Python 3). I recommend that you just import **threading** if you want to build
    threading interfaces. I know someone is asking: *What''s a thread?* A thread is
    just a fancy term for things we’re all familiar with in programming: particular
    function calls or tasks. When we learn programming, we work with function calls
    one at a time so that we can understand their structure and function. The concept
    of threading comes into play when we have some task at work that involves a little
    waiting—for example, waiting for someone to connect, or perhaps waiting for someone
    to send us some data. If we’re running a service, we’re waiting to handle connections.
    But what if everyone went to bed? I might get connections within a second or may
    be lucky to see a hit after days of waiting. The latter is a familiar scenario
    for us hackers in lurking: we’ve set a trap and we just need our target to click
    the link or execute some payload. Threading allows us to manage multiple tasks—threads—at
    once. Let’s see it in action with our simple server script, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我引入了一个新模块：**threading**。这个模块本身是一个用于与**thread**模块（在 Python 3 中称为**_thread**）进行接口的高级模块。如果你想构建线程接口，我建议你只导入**threading**。我知道有人会问：*什么是线程？*
    线程只是编程中我们都熟悉的一个花哨的术语：特定的函数调用或任务。当我们学习编程时，我们一次处理一个函数调用，以便理解它们的结构和功能。线程的概念在我们工作中有一些需要稍等的任务时就会派上用场——例如，等待某人连接，或者等待某人向我们发送数据。如果我们在运行一个服务，我们在等待处理连接。但如果每个人都去睡觉了呢？我可能在一秒内就收到连接，或者也许在几天的等待后才幸运地看到一次连接。后者是我们黑客潜伏时常见的场景：我们设置了一个陷阱，只需要目标点击链接或执行某个负载。线程允许我们一次管理多个任务——线程。让我们通过下面的简单服务器脚本来看它是如何工作的：
- en: We start with the usual by declaring the IP address and port number, which in
    this case will be used to set up a local listener. We then create a socket called
    **server** and define it as a stream socket with IPv4 addressing.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从声明 IP 地址和端口号开始，这些将在此用于设置本地监听器。然后我们创建一个名为**server**的套接字，并将其定义为带有 IPv4 地址的流套接字。
- en: Now, we use **server.bind()** to bind our socket to the local port. Note that
    the IP address is declared, but we put **0.0.0.0**. From a networking perspective,
    if a packet hits our socket then it was already routed appropriately, and the
    source had defined our IP address properly. This means that, if our system has
    multiple interfaces with multiple IP addresses, this listener is reachable to
    any client who can talk to any of our interfaces!
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们使用**server.bind()**将套接字绑定到本地端口。请注意，IP 地址已经声明，但我们设置为**0.0.0.0**。从网络角度来看，如果一个数据包到达我们的套接字，那么它已经被正确地路由，并且源主机已经正确地定义了我们的
    IP 地址。这意味着，如果我们的系统有多个接口并且有多个 IP 地址，这个监听器对于任何能与我们接口通信的客户端来说都是可达的！
- en: Binding doesn’t exactly tell the socket what to do once bound. So, we use **server.listen()**
    to open up that port; an inbound **synchronize** (**SYN**) packet will automatically
    be handled with a **SYN-acknowledge** (**SYN-ACK**) and a final ACK. The argument
    passed to **listen** is the maximum number of connections. We’ve arbitrarily set
    **4**; your needs will vary. The user is advised with **print** that we’re up
    and running.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定并不会告诉套接字绑定后要做什么。因此，我们使用**server.listen()**打开该端口；一个传入的**同步**（**SYN**）数据包会自动被处理为**SYN-acknowledge**（**SYN-ACK**）以及最终的
    ACK。传递给**listen**的参数是最大连接数。我们随便设置了**4**；你的需求可能不同。通过**print**，用户会得到提示，表示我们已经启动并运行。
- en: We tried the “unpacking my sequence” method of printing text to the screen;
    here, we’ll do something different. With the percentage symbol (**%**), we can
    put little placeholders for working with different data types. Using **d** means
    decimal; **s** means string.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们尝试过“解包我的序列”方法来将文本打印到屏幕；在这里，我们将做一些不同的事情。使用百分号符号（**%**），我们可以放置小的占位符来处理不同的数据类型。使用**d**表示十进制；**s**表示字符串。
- en: 'Now for some more wild and crazy action—defining a **connect** function. This
    function is what our client connection handler will call; that is, the **connect**
    function doesn’t handle connections but decides what to do once a connection is
    established. The code is self-explanatory: it sets aside a **kilobyte** (**KB**)
    of space for the received data and calls it **received**, replies with a message,
    then closes the connection.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在进入一些更疯狂的操作——定义一个**connect**函数。这个函数是我们的客户端连接处理器调用的；也就是说，**connect**函数并不直接处理连接，而是决定在连接建立后做什么。代码不言自明：它为接收的数据预留了一个**千字节**（**KB**）的空间，并称之为**received**，然后回复一条消息，最后关闭连接。
- en: 'Our **while** loop statement keeps our server up and running. A **while** loop
    statement is yet another basic programming concept: it’s a conditional loop that
    executes as long as a given condition is true. Suppose we have an integer variable
    called **loop**. We could create a **while** loop that starts with **while loop
    < 15**, and any code we put there will execute as long as **loop** is less than
    **15**. We can control the flow with **break** and **continue** nested conditions.
    I know what the programmer in you is saying, though: *It says execute the loop
    while true, but no condition is defined*. Too true, my friends. I like to call
    this the *existential loop statement*—kind of the programmer’s version of *I think,
    therefore I am*. A loop that starts with **while True** will just go on forever.
    What’s the point of such a loop? This is the compact and clean way to leave a
    program running until we meet a certain condition somewhere in the code, either
    in a called function or perhaps in a nested conditional test, at which point we
    use **break**.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的**while**循环语句使我们的服务器保持运行状态。**while**循环语句是另一个基本的编程概念：它是一个条件循环，只要给定的条件为真，它就会继续执行。假设我们有一个名为**loop**的整数变量。我们可以创建一个**while**循环，从**while
    loop < 15**开始，只要**loop**小于**15**，我们放入的任何代码都会执行。我们可以通过**break**和**continue**控制流的嵌套条件。不过，我知道你们程序员的想法：*它说在条件为真时执行循环，但没有定义条件*。没错，朋友们。我喜欢称这个为*存在性循环语句*——有点像程序员版的*我思故我在*。一个以**while
    True**开始的循环将会永远执行下去。这样的循环有什么意义呢？这是一种紧凑而简洁的方式，保持程序运行直到代码中的某个条件满足，无论是在调用的函数中还是在嵌套的条件测试中，这时我们会使用**break**。
- en: '**server.accept()** sits in our never-ending **while** loop, ready to grab
    the address array of a connecting client. Arrays in Python start with **0**, so
    keep this in mind: the first value in an array is thus **[0]**, the fifth value
    is **[4]**, and so on. The address array has the IP address as the first value
    and the port as the second value, so we can display to the user the details of
    our connecting client.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**server.accept()**处于我们永不结束的**while**循环中，准备抓取连接客户端的地址数组。Python 中的数组是从**0**开始的，所以请记住：数组中的第一个值是**[0]**，第五个值是**[4]**，以此类推。地址数组的第一个值是
    IP 地址，第二个值是端口，因此我们可以向用户显示连接客户端的详细信息。'
- en: 'We create a thread with **threading.Thread()** and call it **client_handler**.
    We move right on to starting it with **client_handler.start()**, but in your programs,
    you could create some condition to start the thread. Note that the target argument
    passed to **threading.Thread()** calls the **connect** function. When the **connect**
    function is done, we fall back to our endless loop, as illustrated here:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**threading.Thread()**创建一个线程，并命名为**client_handler**。接着直接调用**client_handler.start()**来启动它，不过在你的程序中，你可以创建一些条件来启动该线程。请注意，传递给**threading.Thread()**的目标参数会调用**connect**函数。当**connect**函数完成后，我们会进入一个无限循环，正如这里所示：
- en: '![Figure 8.6 – Running our Python server ](image/Figure_8.6_B17616.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 运行我们的 Python 服务器](image/Figure_8.6_B17616.jpg)'
- en: Figure 8.6 – Running our Python server
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 运行我们的 Python 服务器
- en: Here, we see the script in action, handling a connection from a **Secure Shell**
    (**SSH**) client (which identified itself) and then from a netcat-like connection
    that sent **Hello**. A **Listening on** message is displayed right before we fall
    back into our **while True** loop, so there’s no fancy way of killing this program
    outside of *Ctrl* + *C*. This program is a skeleton of server functionality. Just
    throw in your Pythonic magic here and there, and the possibilities are endless.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到脚本的实际操作，处理来自**安全外壳**（**SSH**）客户端（其已自我标识）的连接，然后是一个类似 netcat 的连接，它发送了**Hello**。在我们重新进入**while
    True**循环之前，会显示一条**Listening on**的消息，因此除了使用*Ctrl* + *C*，没有其他简单的方法来终止这个程序。这个程序是服务器功能的框架。只需在其中加入你自己的
    Python 魔法，可能性是无穷无尽的。
- en: Building a Python reverse-shell script
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个 Python 反向 shell 脚本
- en: 'Okay—so, you’re working your way through a post-exploitation phase. You find
    yourself on a Linux box with Python installed but nothing else, and you’d like
    to create a script to be called in certain scenarios that will automatically kick
    back a shell. Or, perhaps you’re writing a malicious script and you want to return
    a shell from a Linux target. Whatever the scenario, let’s take a quick look at
    a Python reverse-shell skeleton, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——所以，你正在进行后期利用阶段。你发现自己在一台安装了 Python 但没有其他工具的 Linux 主机上，并且你希望创建一个脚本，在特定场景下调用它，从而自动返回一个
    shell。或者，也许你正在编写一个恶意脚本，希望从一个 Linux 目标返回一个 shell。无论是哪种情况，我们先快速看一下一个 Python 反向 shell
    的框架，内容如下：
- en: '![Figure 8.7 – The Python reverse shell ](image/Figure_8.7_B17616.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – Python 反向 shell](image/Figure_8.7_B17616.jpg)'
- en: Figure 8.7 – The Python reverse shell
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – Python 反向 shell
- en: 'Now, we’re pulling in two new modules: **os** and **subprocess**. This is where
    Python’s ability to talk to the operating system shines. The **os** module is
    a multipurpose operating system interfacing module. It’s a one-stop shop, even
    with the peculiarities of a particular operating system—of course, if portability
    between systems is a concern, be careful with this. The **os** module is very
    powerful and is well beyond our discussion here; I encourage you to research it
    on your own. The **subprocess** module very commonly goes hand in hand with the
    **os** module. It allows your script to spawn processes, grab their return codes
    for use in your main script, and interact with their input, output, and error
    pipes. Let’s look at the specifics here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们引入了两个新模块：**os** 和 **subprocess**。这正是 Python 与操作系统交互能力的体现。**os**模块是一个多功能的操作系统接口模块，它是一个一站式解决方案，即使是在某些操作系统的特性下—当然，如果系统之间的可移植性是一个问题，使用时要小心。**os**模块非常强大，超出了我们在这里讨论的范围；我鼓励你自己去研究它。**subprocess**模块通常与**os**模块一起使用，它允许你的脚本生成进程，获取它们的返回码以供主脚本使用，并与它们的输入、输出和错误管道进行交互。让我们在这里看一下具体的内容：
- en: We’re creating a new IPv4 stream socket and calling it **sock**.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的 IPv4 流式套接字，并命名为**sock**。
- en: We use **sock.connect()** to use our new socket to connect to a host at the
    specified IP address and port (we’re just playing around locally in our example—
    this works for any reachable address).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**sock.connect()**用新的套接字连接到指定IP地址和端口的主机（在我们的示例中，我们只是进行本地测试——这对任何可达的地址都有效）。
- en: Firing off **/bin/sh** is all well and good, but we need the input, output,
    and error pipes to talk to our socket. We accomplish this with **os.dup2(sock.fileno())**,
    with the values **0** through **2** representing **stdin**, **stdout**, and **stderr**.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动**/bin/sh**当然是很好的，但是我们需要输入、输出和错误管道与我们的套接字进行通信。我们通过**os.dup2(sock.fileno())**来实现这一点，其中**0**到**2**分别代表**stdin**、**stdout**和**stderr**。
- en: 'We call **/bin/sh -i** with **subprocess.call()**. Note that this creates an
    object we’re calling **proc**, but we don’t need to do anything with it. The process
    is spawned, and its standard streams are already established through our socket.
    The shell is popping up on our remote screen and doesn’t know it, as illustrated
    here:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过**subprocess.call()**调用**/bin/sh -i**。请注意，这会创建一个我们称之为**proc**的对象，但我们不需要做任何操作。该进程已经被生成，并且其标准流已经通过我们的套接字建立。Shell已经在我们的远程屏幕上弹出，而它并不知道，就像这里所示的那样：
- en: '![Figure 8.8 – Connecting to our reverse-shell listener ](image/Figure_8.8_B17616.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 连接到我们的反向 shell 监听器](image/Figure_8.8_B17616.jpg)'
- en: Figure 8.8 – Connecting to our reverse-shell listener
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 连接到我们的反向 shell 监听器
- en: Now, we kick off our reverse-shell script. Obviously, there needs to be a listener
    ready to take the connection from our script, so I just fire up **nc -l** and
    specify the port we’ve declared in the script. The familiar prompt appears, and
    I verify that I have the permission of the user who executed our script.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们启动我们的反向 shell 脚本。显然，需要有一个监听器准备好接收来自我们脚本的连接，因此我只需启动**nc -l**并指定我们在脚本中声明的端口。熟悉的提示符出现，我确认我已获得执行我们脚本的用户的许可。
- en: Speaking of smuggling the goods with Python helpers, let’s take a look at evading
    antimalware software by delivering our malicious code directly into memory from
    across the network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 说到用Python助手走私货物，我们来看看如何通过直接将恶意代码从网络传输到内存中来规避抗恶意软件软件。
- en: Antimalware evasion in Python
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的抗恶意软件规避
- en: We explored antimalware evasion in [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124),
    *Advanced Exploitation with Metasploit*. The technique we reviewed involved embedding
    our payload into the natural flow of execution of an innocuous executable. We
    also covered encoding techniques to reduce detection signatures. However, there’s
    more than one way to skin a cat. (Whoever thought of that horrible expression?)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)中探讨了抗恶意软件规避，*利用Metasploit进行高级利用*。我们回顾的技术涉及将我们的负载嵌入到一个无害可执行文件的自然执行流程中。我们还介绍了编码技术，以减少检测签名。然而，解决问题的方法不止一种。（是谁想出了那个可怕的表达方式？）
- en: If you’ve ever played defense against real-world attacks, you’ve likely seen
    a variety of evasion techniques. The techniques often used to be lower-level (for
    instance, our demonstration with Shellter in [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124),
    *Advanced Exploitation with Metasploit*), but detection has improved so much.
    It’s a lot harder to create a truly undetectable threat that doesn’t at least
    trigger a suspicious file intercept.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经防御过现实世界中的攻击，你可能见过各种规避技巧。过去常用的技巧往往是低级的（例如我们在[*第7章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)中用Shellter演示的，*利用Metasploit进行高级利用*），但是检测技术已经有了很大改进。如今，创造一个完全不可检测的威胁变得更加困难，它至少会触发一个可疑文件拦截。
- en: 'Therefore, modern attacks tend to be a blend of low-level and high-level—using
    social engineering and technical tactics to get the malware onto the target host
    through some other channel. I’ve worked on cases where the payload sneaking in
    via phishing techniques is nothing more than a script that uses local resources
    to fetch files from the internet. Those files, once retrieved, then put together
    the malware locally. We’re going to examine such an attack using Python to create
    a single **.exe** file with two important tasks, as outlined here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代攻击往往是低级和高级的结合——利用社交工程和技术手段通过其他渠道将恶意软件传递到目标主机上。我曾经处理过一些案例，其中通过钓鱼技术偷偷进入的负载，仅仅是一个脚本，它利用本地资源从互联网上获取文件。一旦这些文件被获取，它们就在本地组装恶意软件。我们将使用Python来创建一个单一的**.exe**文件，该文件具有两个重要任务，如下所示：
- en: Fetching the payload from the network
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络获取负载
- en: Loading the raw payload into memory and executing it
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始负载加载到内存并执行
- en: The Python script itself does very little and, without a malicious payload,
    it doesn’t have a malicious signature. The payload itself won’t be coming in as
    a compiled executable as normally expected, but as raw shellcode bytes encoded
    in **base64**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本本身几乎没有做什么，且没有恶意有效负载时，它并没有恶意签名。有效负载本身将不会像通常预期那样作为已编译的可执行文件到来，而是作为 **base64**
    编码的原始 shellcode 字节。
- en: So, in an attack scenario, we’ll have a target Windows box where we put our
    executable file for execution. Meanwhile, we set up an HTTP server in Kali ready
    to serve the raw payload to a properly worded request (which will be encoded in
    the Python script). The script then decodes the payload and plops it into memory.
    But first, we need to be able to create EXEs out of Python scripts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在攻击场景中，我们将有一个目标 Windows 计算机，我们将把我们的可执行文件放在其中进行执行。同时，我们在 Kali 中设置一个 HTTP 服务器，准备好根据适当格式的请求提供原始有效负载（该请求将在
    Python 脚本中进行编码）。脚本接着解码有效负载并将其放入内存中。但首先，我们需要能够将 Python 脚本转换为 EXE 文件。
- en: Creating Windows executables of your Python scripts
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Python 脚本的 Windows 可执行文件
- en: There are two components that we need for this—**pip**, a Python package management
    utility, and PyInstaller, an awesome utility that reads your Python code, determines
    exactly what its dependencies are (and that you might take for granted by running
    it in the Python environment), and generates an EXE file from your script. There
    is an important limitation to PyInstaller, though—you need to generate an EXE
    file on the target platform. So, you will need a Windows box to fire this up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的有两个组件——**pip**，一个 Python 包管理工具，以及 PyInstaller，一个很棒的工具，它读取你的 Python 代码，确定它的所有依赖项（你可能通过在
    Python 环境中运行它而理所当然地使用了这些依赖），并从你的脚本生成一个 EXE 文件。不过，PyInstaller 有一个重要的限制——你需要在目标平台上生成
    EXE 文件。所以，你需要一台 Windows 计算机来启动这个过程。
- en: Go Commando with your Windows Box
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的 Windows 计算机进入 Commando 模式
- en: One of my favorite toys is a Windows PC-turned-offensive platform thanks to
    the excellent Commando **virtual machine** (**VM**) from Mandiant. The simplest
    way to think of it is Kali for Windows—a pen testing load of the ubiquitous operating
    system. Instead of a preloaded distribution, it’s essentially a fancy installer
    that will convert your ordinary Windows machine, downloading everything it needs
    and tweaking settings for you. You don’t need it for the exercise here, but I
    will be using it as my offensive Windows environment. I don’t think any pen testing
    lab is complete without it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的玩具之一是通过 Mandiant 的优秀 **虚拟机**（**VM**）将一台 Windows 电脑转变为攻击平台。最简单的理解方式是 Kali
    for Windows——一个渗透测试的通用操作系统载荷。它并不是一个预装的发行版，而是一个精致的安装程序，能够将你的普通 Windows 机器转换为攻击平台，下载所需的所有内容并为你调整设置。你在本次练习中并不需要它，但我会将它用作我的进攻性
    Windows 环境。我认为没有它的渗透测试实验室是不完整的！
- en: 'Over at our trusty Windows machine, we have Python installed and ready to go.
    (You have Python installed and ready to go, right?) So, I pass along this command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Windows 机器上，已经安装并准备好 Python。（你也已经安装并准备好 Python 了，对吧？）所以，我执行了这个命令：
- en: C:\> python –m pip install pyinstaller
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C:\> python –m pip install pyinstaller
- en: This will fetch PyInstaller and get it ready for us. It’s a standalone command-line
    program, not a module, so you can run it from the same prompt with the **pyinstaller**
    command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取 PyInstaller 并为我们准备好。它是一个独立的命令行程序，不是一个模块，因此你可以从相同的命令提示符运行 **pyinstaller**
    命令。
- en: Preparing your raw payload
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备你的原始有效负载
- en: 'Once again, we’re revisiting the ever-gorgeous **msfvenom**. We’re not doing
    anything new here, but if you’re not coming here from [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124),
    *Advanced Exploitation with Metasploit*, I recommend checking out the coverage
    of **msfvenom** first. Let’s get started. Have a look at the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到那个永远美丽的 **msfvenom**。我们这里没有做什么新鲜事，但如果你不是从 [*第 7 章*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124)（*Metasploit
    高级利用*）过来的，建议先查看 **msfvenom** 的相关内容。让我们开始吧。看看下面的截图：
- en: '![Figure 8.9 – Generating a raw payload with msfvenom ](image/Figure_8.9_B17616.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 使用 msfvenom 生成原始有效负载](image/Figure_8.9_B17616.jpg)'
- en: Figure 8.9 – Generating a raw payload with msfvenom
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 使用 msfvenom 生成原始有效负载
- en: 'Here, we have a quick and simple bind payload; this time, the target will be
    listening for our connection to spawn a shell. Note that I specified that null
    bytes should be avoided with **--bad-chars**, and that instead of generating an
    EXE file or any other special formatting, the **-f raw** parameter makes the output
    format raw: pure machine code in hexadecimal. The end result is 355 bytes, but
    since I’m not compiling or converting this into anything else, the newly created
    **shellcode.raw** file is 355 bytes.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个快速简单的绑定有效负载；这一次，目标将会监听我们的连接以生成一个shell。请注意，我指定了应避免使用空字节（**--bad-chars**），而且不需要生成EXE文件或任何其他特殊格式，**-f
    raw** 参数使得输出格式为原始格式：纯机器码（十六进制）。最终结果是355字节，但因为我没有将其编译或转换成其他任何形式，新的 **shellcode.raw**
    文件就是355字节。
- en: Finally, the last step is creating a payload that will be staged from across
    the network. We’ll encode the file with **base64**, for one main reason and a
    possible side benefit. The main reason is that **base64** was designed to allow
    for easy representation of binary data, and thus it’s not likely to be mangled
    by some library function that tries to check for corruption or even prevent injection.
    The possible side benefit, depending on the defenses in place, is rendering the
    code so that it is harder to detect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个将通过网络分阶段传输的有效负载。我们将对文件进行 **base64** 编码，主要有一个原因以及一个可能的副作用。主要原因是 **base64**
    设计用于便于表示二进制数据，因此它不太可能被一些库函数篡改，这些函数可能试图检查损坏或者甚至防止注入。根据防御措施的不同，可能的副作用是让代码变得更难以检测。
- en: '**base64** encoding and decoding are built into Kali and available as a module
    in Python, so we can easily encode **base64** on our end and then write our script
    to quickly decode it before stuffing it into memory, as illustrated here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**base64** 编码和解码已经内建于 Kali 中，并且作为一个模块在 Python 中提供，因此我们可以轻松地在我们这端进行 **base64**
    编码，然后编写脚本在将其加载到内存之前快速解码，如此处所示：'
- en: '![Figure 8.10 – Shellcode in base64, ready for download ](image/Figure_8.10_B17616.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – Base64编码的Shellcode，准备下载](image/Figure_8.10_B17616.jpg)'
- en: Figure 8.10 – Shellcode in base64, ready for download
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – Base64编码的Shellcode，准备下载
- en: 'A side note about **base64**: though **base64** encoding is fairly popular
    in some systems as a means of hiding data, it’s merely a different base system
    and not encryption. Defenders should know to never rely on **base64** for confidentiality.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **base64** 的附注：虽然 **base64** 编码在一些系统中很流行，作为隐藏数据的一种手段，但它仅仅是一个不同的基数系统，而不是加密。防御者应该知道永远不能依赖
    **base64** 来确保机密性。
- en: We’ve got our surprise waiting to be opened, but we still need the fetching
    code—let’s take a look.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好打开我们的惊喜，但我们仍然需要获取代码——让我们来看一下。
- en: Writing your payload retrieval and delivery in Python
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中编写你的有效负载获取与交付代码
- en: Now, let’s get back to Python and write the second phase of our attack. Keep
    in mind that we’re going to eventually end up with a Windows-specific EXE file,
    so this script will need to get to your Windows PyInstaller box. You could write
    it up on Kali and transfer it over, or just write it in Python on Windows to save
    a step.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 Python，编写攻击的第二阶段。记住，最终我们将得到一个特定于 Windows 的 EXE 文件，因此这个脚本需要在你的 Windows
    PyInstaller 主机上运行。你可以在 Kali 上编写然后传输过来，或者直接在 Windows 上用 Python 编写，这样可以省去一步。
- en: 'Nine lines of code and a 355-byte payload are to be imported. Not too shabby,
    and a nice demonstration of how lightweight Python can be, as we can see here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导入九行代码和一个355字节的有效负载。还不错，这是一个很好的示范，展示了Python的轻量级特性，正如我们在这里看到的：
- en: '![Figure 8.11 – The shellcode fetcher ](image/Figure_8.11_B17616.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – Shellcode获取器](image/Figure_8.11_B17616.jpg)'
- en: Figure 8.11 – The shellcode fetcher
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – Shellcode获取器
- en: 'Let’s examine this code step by step, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码，具体如下：
- en: We have three new **import** statements to look at. Notice that the first statement
    is **from ... import**, which means we’re being picky about which component of
    the source module (or, in this case, a package of modules) we’re going to use.
    In our case, we don’t need the entirety of **Uniform Resource Locator** (**URL**)
    handling; we’re only opening a single defined URL, so we pull in **urlopen**.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要查看三个新的 **import** 语句。请注意，第一个语句是 **from ... import**，这意味着我们正在精确选择要使用的源模块（或在本例中，是一个模块包）中的组件。在我们的案例中，我们不需要全部的
    **统一资源定位符**（**URL**）处理；我们只需打开一个已定义的 URL，因此我们只引入 **urlopen**。
- en: The **ctypes** import is a foreign function library; that is, it enables function
    calls in shared libraries (including **dynamic-link libraries** (**DLLs**)).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ctypes** 导入是一个外部函数库；也就是说，它使得在共享库（包括 **动态链接库**（**DLLs**））中进行函数调用成为可能。'
- en: '**urlopen()** accesses the defined URL (which we have set up on our end by
    simply executing **python -m SimpleHTTPServer** in the directory where our **base64**-encoded
    payload is waiting) and stores the capture as **pullhttp**.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**urlopen()** 访问定义的 URL（我们通过在包含 **base64** 编码的有效载荷的目录中执行 **python -m SimpleHTTPServer**
    来设置该 URL），并将捕获内容存储为 **pullhttp**。'
- en: We use **base64.b64decode()** and pass as an argument **pullhttp.read()**, storing
    our raw shellcode as **shellcode**.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 **base64.b64decode()** 并传递 **pullhttp.read()** 作为参数，将我们的原始 shellcode 存储为
    **shellcode**。
- en: Now, we use some **ctypes** magic. **ctypes** is sophisticated enough for its
    own chapter, so I encourage further research on it; for now, we’re allocating
    some buffer space for our payload, using **len()** to allocate space of the same
    size as our payload itself. Then, we use **ctypes.cast()** to cast (make a type
    conversion of) our buffer space as a function pointer. The moment we do this,
    we now have **exploit_func()**—effectively, a Python function that we can call
    like any ordinary function. When we call it, our payload executes.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们使用一些 **ctypes** 魔法。**ctypes** 足够复杂，可以作为一章独立讨论，所以我鼓励大家进一步研究；目前，我们为我们的有效载荷分配了一些缓冲区空间，使用
    **len()** 为我们的有效载荷分配与其大小相同的空间。然后，我们使用 **ctypes.cast()** 将我们的缓冲区空间转换为函数指针。当我们这么做时，我们就得到了
    **exploit_func()**——实际上，这是一个 Python 函数，我们可以像调用任何普通函数一样调用它。当我们调用它时，我们的有效载荷就会执行。
- en: What else is there to do, then? We call our **exploit_func()** exploit function.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，还有什么可以做的呢？我们调用我们的 **exploit_func()** 漏洞利用函数。
- en: 'In my example, I typed this up in Vim and stored it as **backdoor.py**. I copy
    it over to my Windows box and execute PyInstaller, using **--onefile** to specify
    that I want a single executable, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，我在 Vim 中编写了这个代码，并将其存储为 **backdoor.py**。我将它复制到我的 Windows 机器上，并执行 PyInstaller，使用
    **--onefile** 参数指定我要生成一个单一的可执行文件，如下所示：
- en: pyinstaller --onefile backdoor.py
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: pyinstaller --onefile backdoor.py
- en: 'PyInstaller spits out **backdoor.exe**. Now, I just send this file as part
    of a social engineering campaign to encourage execution. Don’t forget to set up
    your HTTP server so that target instances of this script can grab the payload!
    In this screenshot, we can see **backdoor.exe** grabbing the payload as expected:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller 输出 **backdoor.exe**。现在，我只需将这个文件作为社交工程活动的一部分发送出去，鼓励目标执行。别忘了设置你的 HTTP
    服务器，这样目标机器就可以抓取有效载荷！在这个截图中，我们可以看到 **backdoor.exe** 正如预期那样抓取有效载荷：
- en: '![Figure 8.12 – The fetching code grabs the shellcode from SimpleHTTPServer
    ](image/Figure_8.12_B17616.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 获取代码从 SimpleHTTPServer 获取 shellcode](image/Figure_8.12_B17616.jpg)'
- en: Figure 8.12 – The fetching code grabs the shellcode from SimpleHTTPServer
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 获取代码从 SimpleHTTPServer 获取 shellcode
- en: Finally, let’s take a look at evasion using this technique. The payload itself
    set off no alarms during the import. Our executable itself, which is what an endpoint
    would see and thus is likely to be scanned, was only detected by 7% of antivirus
    products at the time of writing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看使用这种技术进行规避。在导入过程中，载荷本身并没有触发任何警报。我们的可执行文件本身，终端会看到它，因此可能会被扫描，在编写本文时，它仅被
    7% 的杀毒软件检测到。
- en: It’s time to take our Python networking to the next level. Let’s review some
    of our **local area network** (**LAN**) antics and get a feel for the low-level
    possibilities with Scapy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的 Python 网络技术提升到下一个级别了。让我们回顾一下我们的一些 **局域网**（**LAN**）恶作剧，并感受一下使用 Scapy
    进行低级别操作的可能性。
- en: Python and Scapy – a classy pair
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 和 Scapy – 一对经典组合
- en: The romance between Python and Scapy was introduced in the second chapter—hey,
    I couldn’t wait. As a reminder, Scapy is a packet manipulation tool. We often
    see especially handy tools described as the Swiss Army knife of a certain task;
    if that’s the case, then Scapy is a surgical scalpel. It’s also, specifically,
    a Python program, so we can import its power into our scripts. You could write
    your own network pen testing tool in Python, and I mean any tool; you could replace
    Nmap, netcat, p0f, hping, and even something such as arpspoof. Let’s take a look
    at what it takes to create an **Address Resolution Protocol** (**ARP**) poisoning
    attack tool with Python and Scapy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和 Scapy 之间的缘分在第二章中已介绍——嘿，我等不及了。提醒一下，Scapy 是一个数据包操作工具。我们经常看到一些特别方便的工具被描述为某项任务的瑞士军刀；如果真是这样，那么
    Scapy 就是外科手术刀。它也特别是一个 Python 程序，所以我们可以将它的功能导入到我们的脚本中。你可以用 Python 编写自己的网络渗透测试工具，任何工具都行；你可以替代
    Nmap、netcat、p0f、hping，甚至像 arpspoof 这样的工具。让我们来看看使用 Python 和 Scapy 创建一个**地址解析协议**（**ARP**）欺骗攻击工具需要什么。
- en: Revisiting ARP poisoning with Python and Scapy
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 和 Scapy 重温 ARP 欺骗
- en: 'Let’s take a look at constructing a layer 2 ARP poisoning attack from the bottom
    up. As before, the code here is a skeleton; with some clever Python wrapped around
    it, you have the potential to add a powerful tool to your arsenal. First, we bring
    in our imports and make some declarations, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从底层开始构建一个第 2 层 ARP 欺骗攻击。如前所述，代码这里是一个框架；通过一些巧妙的 Python 编写，你有潜力将其转化为强大的工具。首先，我们导入库并进行一些声明，具体如下：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Check out those **import** statements—all of Scapy’s power. We’re familiar with
    **os** and **threading**, so let’s look at **sys** and **signal**. The **sys**
    module is always available to us when we’re Pythoning and it allows us to interact
    with the interpreter—in this case, we’re just using it to exit Python. The **signal**
    module lets your script work with signals (in an **inter-process communication**
    (**IPC**) context). Signals are messages sent to processes or threads about an
    event—an exception or something such as divide by zero. This gives our script
    the ability to handle signals.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些**import**语句——Scapy 所有的力量。我们熟悉 **os** 和 **threading**，那么让我们来看看 **sys** 和
    **signal**。**sys** 模块是我们在使用 Python 时始终可以访问的，它允许我们与解释器交互——在这个例子中，我们只是用它来退出 Python。**signal**
    模块让你的脚本可以处理信号（在**进程间通信**（**IPC**）上下文中）。信号是发送给进程或线程的消息，告知某个事件——比如异常或除零错误。这使得我们的脚本可以处理这些信号。
- en: Next, we define our interface, target IP, and gateway IP as strings. The number
    of packets to be sniffed is declared as an integer. **conf** belongs to Scapy;
    we’re setting the interface with the **interface** variable we just declared,
    and we’re setting verbosity to **0**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将界面、目标 IP 和网关 IP 定义为字符串。要嗅探的数据包数量声明为整数。**conf** 属于 Scapy；我们使用刚才声明的 **interface**
    变量来设置界面，并将冗余级别设置为 **0**。
- en: 'Now, let’s dive into some functions, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解一些函数，具体如下：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There’s a lot of information here, so let’s examine these functions more closely,
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息，所以让我们更详细地检查这些函数，具体如下：
- en: '**def restore()** isn’t how we attack the network—it’s how we clean up our
    mess. Remember that ARP poisoning manipulates layer 2-layer 3 mappings on other
    nodes on the network. If you do this and disconnect, those tables stay the same
    until ARP messages dictate something else. We’re using Scapy’s **send(ARP())**
    function to restore healthy tables.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**def restore()** 不是我们攻击网络的方式——它是用来清理我们的“烂摊子”。记住，ARP 欺骗会修改网络上其他节点的第 2 层到第 3
    层的映射。如果你这么做然后断开连接，那些表会保持不变，直到 ARP 消息指示其他内容。我们使用 Scapy 的 **send(ARP())** 函数来恢复健康的表。'
- en: '**def macgrab()** will take an IP address as an argument, then use Scapy’s
    **srp()** function to create ARP messages and record the response. **macgrab()**
    reads the **media access control** (**MAC**) address with **[Ether]** and returns
    the value.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**def macgrab()** 会接受一个 IP 地址作为参数，然后使用 Scapy 的 **srp()** 函数创建 ARP 消息并记录响应。**macgrab()**
    使用 **[Ether]** 读取**媒体访问控制**（**MAC**）地址，并返回该值。'
- en: '**def poison_target()** is the function where our deception is laid out. We
    prepare the parameters for a Scapy **send()** function for both ends of the **man-in-the-middle**
    (**MITM**) attack: **poison_gateway** and **poison_target**. Although the multiple
    lines take up more space on the page, our script is highly readable, and we can
    see the structure of the packets being constructed: **poison_target** and **poison_gateway**
    are both set as **ARP()** with **op = 2**—in other words, we’re sending unsolicited
    ARP replies. The bait-and-switch is visible when the target’s **psrc setting**
    is set to **gateway**, and the gateway’s **psrc** setting is set to **target**
    (and the opposite for **pdst**). Our familiar **while True** loop is where the
    sending takes place. We see where signal handling comes in with **except KeyboardInterrupt**,
    which calls **restore()** so that we can get cleaned up.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**def poison_target()**是我们实施欺骗的函数。我们为**man-in-the-middle**（**MITM**）攻击的两个端点：**poison_gateway**和**poison_target**准备了Scapy的**send()**函数参数。尽管这些多行代码占用了更多页面空间，但我们的脚本非常易读，我们可以看到构建的数据包的结构：**poison_target**和**poison_gateway**都被设置为**ARP()**，且**op
    = 2**—换句话说，我们正在发送无请求的ARP回复。当目标的**psrc设置**被设为**gateway**时，诱饵交换就显现出来，网关的**psrc**设置则设为**target**（**pdst**设置相反）。我们熟悉的**while
    True**循环就是发送数据包的地方。我们看到信号处理出现在**except KeyboardInterrupt**，它会调用**restore()**，以便清理工作。'
- en: 'This is exciting, but we haven’t even started; we’ve defined these functions,
    but nothing calls them yet. Let’s get to work with the heavy lifting, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这很激动人心，但我们甚至还没有开始；我们已经定义了这些函数，但还没有任何地方调用它们。接下来让我们进行一些繁重的工作，具体如下：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here’s what happens:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: We start out by calling **macgrab()** for the gateway and target IP addresses.
    Recall that **macgrab()** returns MAC addresses, which are then stored as **gwmac_addr**
    and **targetmac_addr**, respectively.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先通过调用**macgrab()**来获取网关和目标IP地址。回想一下，**macgrab()**返回的是MAC地址，然后分别存储为**gwmac_addr**和**targetmac_addr**。
- en: 'A possible return is **None**, so our **if...else** statement takes care of
    that: the value is printed to the screen unless it’s **None**, in which case the
    user is warned, and we call **sys.exit()**.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的返回值是**None**，所以我们的**if...else**语句会处理这种情况：如果返回值不是**None**，则将值打印到屏幕上，否则会发出警告，并调用**sys.exit()**。
- en: The **threading.Thread()** class defines **poison_target()** as our target function
    and passes the target and gateway information as arguments.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**threading.Thread()**类将**poison_target()**定义为我们的目标函数，并将目标和网关信息作为参数传递。'
- en: '**mitm_thread.start()** gets the attack rolling but as a thread. The program
    continues with a **try** statement.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mitm_thread.start()** 启动了攻击，但它是作为一个线程运行的。程序继续执行**try**语句。'
- en: This is where we set up our sniffer. This is an interesting use case for using
    Scapy from within Python; note that we construct a filter as a string variable
    called **bpf**. **sniff()** is called with returned data popping up in memory
    as **cap_packets**. **wrpcap()** creates a packet capture file in **pcap** format.
    Note that **sniff()** also passed the packet count as an argument, so what happens
    when this number is depleted? The code moves on to a **restore()** call. If a
    *Ctrl* + *C* input is received before that time, **restore()** is still called.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是我们设置嗅探器的地方。这是一个有趣的用例，展示了如何在Python中使用Scapy；请注意，我们将过滤器构造为一个名为**bpf**的字符串变量。调用**sniff()**时，返回的数据会以**cap_packets**的形式存储在内存中。**wrpcap()**会创建一个**pcap**格式的数据包捕获文件。注意，**sniff()**也传递了数据包数量作为参数，那么当这个数字用完时会发生什么？代码会继续调用**restore()**。如果在此之前收到*Ctrl*
    + *C*的输入，**restore()**仍然会被调用。
- en: As you can see, the **print** statements written in this demonstration are basic.
    I encourage you to make it prettier to look at.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个演示中写的**print**语句是基础的。我鼓励你让它看起来更漂亮一些。
- en: Don’t Forget to Route
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了进行路由
- en: Make sure your system is set up for forwarding packets with **sysctl net.ipv4.ip_forward=1**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的系统已经设置为转发数据包，使用命令**sysctl net.ipv4.ip_forward=1**。
- en: Use Wireshark or any packet sniffer to verify success. You wrote this from the
    bottom up, so knowing the targets’ layer 2 and layer 3 addresses is just half
    the battle—you want to make sure your code is handling them correctly. With ARP,
    it would be easy to swap a source and destination!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Wireshark或任何数据包嗅探器来验证成功。你是从底层写这段代码的，因此知道目标的第2层和第3层地址只是战斗的一部分——你还需要确保代码正确地处理了这些地址。对于ARP来说，交换源和目的地址是很容易的！
- en: 'Once I’m done with my session, I can quickly verify that my packet capture
    was saved as expected. Better yet, open it up in Wireshark and see what your sniffer
    picked up. Here’s what it found:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我的会话完成，我可以快速验证我的数据包捕获是否按预期保存。更好的是，打开Wireshark查看你的嗅探器捕获了什么。这是它找到的内容：
- en: '![Figure 8.13 – Our pcap file ready for review ](image/Figure_8.13_B17616.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 我们准备好的pcap文件，待复查](image/Figure_8.13_B17616.jpg)'
- en: Figure 8.13 – Our pcap file ready for review
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 我们准备好的pcap文件，待复查
- en: It’s so easy, the packet capture writes itself! I leave it to you to figure
    out how to incorporate these pieces into your own custom toolset.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，数据包捕获自己就完成了！我把如何将这些片段融入你自己的定制工具集交给你去探索。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we ran through a crash course in Python for pen testers. We
    started with some basics about Python and picking your editor environment. Building
    on past programming experience and coverage in this book, we laid out code line
    by line for a few tools that could benefit a pen tester—a simple client, a simple
    server, and even a payload downloader that was almost completely undetectable
    by traditional antivirus programs. To wrap up the chapter, we explored low-level
    network manipulation with Scapy imported as a source library for our program.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进行了一个针对渗透测试人员的Python速成课程。我们从一些Python基础知识和选择编辑器环境开始。基于过去的编程经验和本书中的内容，我们逐行编写了几个有助于渗透测试人员的工具——一个简单的客户端、一个简单的服务器，甚至一个几乎完全无法被传统杀毒软件检测到的有效载荷下载器。为了结束本章，我们探索了使用Scapy进行低级网络操作，将其作为我们的程序的源库导入。
- en: 'Now that we have a solid foundation in Python, we’ll spend the next chapter
    taking a look at the Windows side of powerful automation and scripting: PowerShell.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打下了Python的坚实基础，接下来的章节将重点介绍Windows平台下强大自动化和脚本编写的工具：PowerShell。
- en: Questions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的理解：
- en: How are Python modules brought in to be used in your code?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将Python模块导入到你的代码中使用？
- en: How does the use of **socket** risk affect the portability of your script?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Socket**的使用风险如何影响你脚本的可移植性？'
- en: It’s impossible to run a Python script without **#!/usr/bin/python3** as the
    first line of code. (True | False)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有**#!/usr/bin/python3**作为代码的第一行，无法运行Python脚本。（正确 | 错误）
- en: What are two ways you could stop a **while True** loop?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些两种方法可以停止**while True**循环？
- en: PyInstaller can be run on any platform to generate Windows EXEs. (True | False)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyInstaller可以在任何平台上运行以生成Windows EXE文件。（正确 | 错误）
- en: In Python 3, **thread** became _________.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python 3中，**线程**变成了_________。
- en: An ARP attack will fail completely without defining the **restore()** function.
    (True | False)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有定义**restore()**函数，ARP攻击将完全失败。（正确 | 错误）
- en: Further reading
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章所涉及的主题的更多信息，请查看以下资源：
- en: 'More information on Python IDEs: [https://wiki.python.org/moin/IntegratedDevelopmentEnvironments](https://wiki.python.org/moin/IntegratedDevelopmentEnvironments)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Python IDE的信息：[https://wiki.python.org/moin/IntegratedDevelopmentEnvironments](https://wiki.python.org/moin/IntegratedDevelopmentEnvironments)
- en: 'Installing Python on Windows (for access to **pip** and PyInstaller): [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装Python（以访问**pip**和PyInstaller）：[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)
- en: 'More information on the Mandiant Commando VM: [https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution](https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Mandiant Commando VM的信息：[https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution](https://www.mandiant.com/resources/commando-vm-windows-offensive-distribution)
