- en: RE in Linux Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 平台上的逆向工程
- en: A lot of our tools work great in Linux. In the previous chapter, we introduced
    a few Linux command-line tools that are already built-in by default. Linux already
    has Python scripting installed, as well. In this chapter, we are going to discuss
    a good setup for analyzing Linux files and hosting Windows sandbox clients.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很多我们的工具在 Linux 中都运行得很好。在上一章中，我们介绍了一些已经默认内置的 Linux 命令行工具。Linux 也已经安装了 Python
    脚本语言。在本章中，我们将讨论一个用于分析 Linux 文件和托管 Windows 沙箱客户端的良好设置。
- en: We are going to learn how to reverse an ELF file by exploring the reversing
    tools. We will end this chapter by setting up a Windows sandbox client, running
    a program in it, and monitoring the network traffic coming from the sandbox.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过探索逆向工具学习如何逆向一个 ELF 文件。我们将通过设置一个 Windows 沙箱客户端、在其中运行程序并监控来自沙箱的网络流量来结束本章。
- en: Not all of us are fond of using Linux. Linux is an open source system. It is
    a technology that will stick with us. As a reverse engineer, no technology should
    be an obstacle, and it is never too late to learn this technology. The basics
    of using Linux systems can easily be found on the internet. As much as possible,
    this chapter tries to detail the steps required to install and execute what is
    needed in a way that you can follow.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有人都喜欢使用 Linux。Linux 是一个开源系统。它是一项将伴随我们的技术。作为逆向工程师，任何技术都不应该成为障碍，学会这项技术永远不会太晚。关于
    Linux 系统的基础知识可以轻松地在互联网上找到。本章尽可能详细地描述了安装和执行所需内容的步骤，确保你能跟上。
- en: In this chapter, you will look at the following
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下内容：
- en: Understanding of linux executables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 可执行文件
- en: Reversing an ELF file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向一个 ELF 文件
- en: Virtualization in Linux – an analysis of a Windows executable under a Linux
    host
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中的虚拟化 – 在 Linux 主机下分析 Windows 可执行文件
- en: Network traffic monitoring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络流量监控
- en: Setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: This chapter discusses Linux reverse engineering, so we need to have a Linux
    setup. For reverse engineering, it is recommended to deploy Linux on a bare-metal
    machine. And since most of the analysis tools that have been developed are Debian-based,
    let's use 32-bit Ubuntu Desktop. I chose Ubuntu because it has a strong community.
    Because of that, most of the issues may already have a resolution or solutions
    may be readily available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 Linux 逆向工程，因此我们需要进行 Linux 设置。对于逆向工程，建议在裸机上部署 Linux。由于大多数已开发的分析工具基于 Debian，因此我们使用
    32 位 Ubuntu Desktop。 我选择 Ubuntu 是因为它有一个强大的社区。正因如此，大多数问题可能已经有了解决方案，或者解决方案很容易获得。
- en: Why build our setup on a bare-metal machine? It is a better host for our sandbox
    clients, especially when monitoring network traffic. It also has an advantage
    in proper handling of Windows malware, preventing compromise due to accidental
    malware execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在裸机上构建我们的设置？它是我们沙箱客户端的更好主机，尤其是在监控网络流量时。它还在正确处理 Windows 恶意软件方面具有优势，可以防止由于恶意软件执行而导致的安全问题。
- en: You can go to [https://www.ubuntu.com/](https://www.ubuntu.com/) to obtain an
    ISO for the Ubuntu installer. The site includes an installation guide. For additional
    help, you can visit the community forum at [https://ubuntuforums.org/](https://ubuntuforums.org/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 [https://www.ubuntu.com/](https://www.ubuntu.com/) 获取 Ubuntu 安装程序的 ISO
    文件。该网站包含了安装指南。如需更多帮助，可以访问社区论坛 [https://ubuntuforums.org/](https://ubuntuforums.org/)。
- en: '"Bare-metal machines" refers to computers that execute code directly on the
    hardware. It is usually a term used to refer to hardware, as opposed to virtual
    machines.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “裸机”是指直接在硬件上执行代码的计算机。它通常用来指代硬件，而不是虚拟机。
- en: Linux executable – hello world
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 可执行文件 – hello world
- en: 'To begin with, let''s create a hello world program. Before anything else, we
    need to make sure that the tools required to build it are installed. Open a Terminal
    (the Terminal is Linux''s version of Windows'' Command Prompt) and enter the following
    command. This may require you to enter your super user password:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 hello world 程序。在此之前，我们需要确保已经安装了构建该程序所需的工具。打开一个终端（终端是 Linux 中类似于 Windows
    命令提示符的工具），并输入以下命令。这可能需要你输入超级用户密码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The C program compiler,***`gcc`,** *is usually pre-installed in Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序编译器，***`gcc`,** *通常预装在 Linux 中。
- en: 'Open any text editor and type the lines of following code, saving it as `*hello.c*`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打开任何文本编辑器，输入以下代码，并将其保存为 `*hello.c*`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use `vim` as your text editor by running `vi` from the Terminal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端中运行 `vi` 来使用 `vim` 作为文本编辑器。
- en: 'To compile and run the program, use the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译并运行程序，请使用以下命令：
- en: '![](img/67c70dee-c611-4097-b882-594d24c572df.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67c70dee-c611-4097-b882-594d24c572df.png)'
- en: The `hello` file is our Linux executable that displays a message in the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 文件是我们用于显示控制台消息的 Linux 可执行文件。'
- en: Now, on to reversing this program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始对这个程序进行逆向分析。
- en: dlroW olleH
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dlroW olleH
- en: 'As an example of good practice, the process of reversing a program first needs
    to start with proper identification. Let''s start with `file`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好实践，逆向分析程序的过程应从正确的识别开始。让我们从 `file` 命令开始：
- en: '![](img/687cf65a-6c09-4214-8afd-95e1ef643c80.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/687cf65a-6c09-4214-8afd-95e1ef643c80.png)'
- en: It is a 32-bit ELF file-type. ELF files are native executables on Linux platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个 32 位 ELF 文件类型。ELF 文件是 Linux 平台的原生可执行文件。
- en: 'Next stop, let''s take a quick look at text strings with the `strings` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一站，让我们快速查看文本字符串，使用 `strings` 命令：
- en: '![](img/5dff269d-cc7b-4222-a998-22af556eadd9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dff269d-cc7b-4222-a998-22af556eadd9.png)'
- en: 'This command will produce something like the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将产生类似以下的输出：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The strings are listed in order from the start of the file. The first portion
    of the list contained our message and the compiler information. The first two
    lines also show what libraries are used by the program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串按文件开头的顺序列出。列表的前两部分包含了我们的消息和编译器信息。前两行还显示了程序使用的库：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last portion of the list contains names of sections of the file. We only
    know of a few bits of text that we placed in our C code. The rest are placed there
    by the compiler itself, as part of its code that prepares and ends the graceful
    execution of our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的最后部分包含了文件各个区段的名称。我们只知道一些文本片段，它们被放入我们的 C 代码中。其余的则是由编译器本身放入的，作为其准备并结束代码优雅执行的一部分。
- en: 'Disassembly in Linux is just a command line away. Using the `-d` parameter
    of the `objdump` command, we should be able to show the disassembly of the executable
    code. You might need to pipe the output to a file using this command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，反汇编只是一个命令行的事情。使用 `objdump` 命令的 `-d` 参数，我们应该能够显示可执行代码的反汇编。你可能需要通过以下命令将输出结果写入文件：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output file, `disassembly.asm`, should contain the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件 `disassembly.asm` 应包含以下代码：
- en: '![](img/78a86ecf-24e4-4065-8b4f-4ba81794b322.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78a86ecf-24e4-4065-8b4f-4ba81794b322.png)'
- en: 'If you notice, the disassembly syntax is different from the format of the Intel
    assembly language that we learned. What we see here is the AT&T disassembly syntax.
    To get an Intel syntax, we need to use the `-M intel` parameter, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，反汇编语法与我们学过的 Intel 汇编语言格式不同。我们在这里看到的是 AT&T 反汇编语法。要获取 Intel 语法，我们需要使用 `-M
    intel` 参数，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should give us this disassembly result:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该给我们以下的反汇编结果：
- en: '![](img/d8d0f3ad-cda8-4b14-a64c-2b4be26bfc9d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8d0f3ad-cda8-4b14-a64c-2b4be26bfc9d.png)'
- en: 'The result shows the disassembly code of each function. In summary, there were
    a total of 15 functions from executable sections:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了每个函数的反汇编代码。总的来说，从可执行部分有 15 个函数：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The disassembly of our code is usually at the `.text` section. And, since this
    is a GCC-compiled program, we can skip all the initialization code and head straight
    to the `main` function where our code is at:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的反汇编通常位于 `.text` 区段。由于这是一个由 GCC 编译的程序，我们可以跳过所有初始化代码，直接进入 `main` 函数，那里存放着我们的代码：
- en: '![](img/2e9ffcb2-40e0-4559-9e20-2f62b1077a57.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e9ffcb2-40e0-4559-9e20-2f62b1077a57.png)'
- en: I have highlighted the API call on `puts`. The `puts` API is also a version
    of `printf`. GCC was smart enough to choose `puts` over `printf` for the reason
    that the string was not interpreted as a **C-style** **formatting string**. A
    formatting string, or `formatter`, contains control characters, which are denoted
    with the `%` sign, such as `%d` for integer and `%s` for string. Essentially,
    *puts* is used for non-formatted strings, while `printf` is used for formatted
    strings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经标出了 `puts` 的 API 调用。`puts` API 也是 `printf` 的一个变种。GCC 足够聪明，选择了 `puts` 而不是
    `printf`，原因是该字符串没有被解释为 **C 风格的** **格式化字符串**。格式化字符串或 `formatter` 包含控制字符，这些字符用 `%`
    符号表示，例如 `%d` 表示整数，`%s` 表示字符串。实际上，*puts* 用于非格式化字符串，而 `printf` 用于格式化字符串。
- en: What have we gathered so far?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止，我们收集了什么信息？
- en: 'Assuming we don''t have any idea of the source code, this is the information
    we have gathered so far:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对源代码没有任何了解，这是我们迄今为止收集到的信息：
- en: The file is a 32-bit ELF executable.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件是一个 32 位 ELF 可执行文件。
- en: It was compiled using `GCC`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是使用 `GCC` 编译的。
- en: It has 15 executable functions, including the `main()` function.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有 15 个可执行函数，包括 `main()` 函数。
- en: The code uses common Linux libraries: `libc.so` and `ld-linux.so`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码使用了常见的Linux库：`libc.so`和`ld-linux.so`。
- en: Based on the disassembly code, the program is expected to simply show a message.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据反汇编代码，预计该程序只是显示一条消息。
- en: The program is expected to display the message using *puts*.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序预计会使用*puts*显示消息。
- en: Dynamic analysis
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析
- en: Now let's do some dynamic analysis. Remember that dynamic analysis should be
    done in a sandbox environment. There are a few tools that are usually pre-installed
    in Linux that can be used to display more detailed information. We're introducing
    `ltrace`, `strace`, and `gdb` for this reversing activity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行一些动态分析。请记住，动态分析应在沙箱环境中进行。Linux中通常预安装了一些可以用来显示更详细信息的工具。在这次逆向工程中，我们将介绍`ltrace`、`strace`和`gdb`。
- en: 'Here''s how `ltrace` is used:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ltrace`的使用方法：
- en: '![](img/53bee7c4-3d63-4cb3-888f-a7b5fedcb4b9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53bee7c4-3d63-4cb3-888f-a7b5fedcb4b9.png)'
- en: The output of `ltrace` shows a readable code of what the program did. `ltrace`
    logged library functions that the program called and received. It called *puts*
    to display a message. It also received an exit status of `*13*` when the program
    terminated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ltrace`的输出显示了程序执行的可读代码。`ltrace`记录了程序调用和接收的库函数。它调用了*puts*来显示一条消息。当程序终止时，它还收到了一个退出状态`*13*`。'
- en: The address `*0x804840b*` is also the address of the `main` function listed
    in the disassembly results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 地址`*0x804840b*`也是反汇编结果中列出的`main`函数的地址。
- en: '`strace` is another tool we can use, but this logs system calls. Here''s the
    result of running `strace` on our hello world program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`是我们可以使用的另一种工具，但它会记录系统调用。下面是我们在hello world程序上运行`strace`的结果：'
- en: '![](img/f0cfce27-6903-438e-b9a7-485048822f4e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0cfce27-6903-438e-b9a7-485048822f4e.png)'
- en: '`strace` logged every system call that happened, starting from when it was
    being executed by the system. `execve` is the first system call that was logged.
    Calling *execve* runs a program pointed to by the filename in its function argument.
    open and read are system calls that are used here to read files. `mmap2`, `mprotect`,
    and `brk` are responsible for memory activities such as allocation, permissions,
    and segment boundary setting.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace`记录了所有发生的系统调用，从程序被系统执行开始。`execve`是记录的第一个系统调用。调用*execve*会运行由其函数参数中的文件名指向的程序。`open`和`read`是用来读取文件的系统调用。`mmap2`、`mprotect`和`brk`负责内存活动，如分配、权限和段边界设置。'
- en: Deep inside the code of `puts`, it eventually executes a `write` system call. *write*,
    in general, writes data to the object it was pointed to. Usually, it is used to
    write to a file. In this case, *write*'s first parameter has a value of `1`. The
    value of `1` denotes `STDOUT`, which is the handle for the console output. The
    second parameter is the message, thus, it writes the message to `STDOUT`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`puts`的代码内部，它最终会执行一个`write`系统调用。*write*通常会将数据写入它所指向的对象。通常，它用于写入文件。在这个例子中，*write*的第一个参数值为`1`。`1`的值表示`STDOUT`，这是控制台输出的句柄。第二个参数是消息，因此它将消息写入`STDOUT`。
- en: Going further with debugging
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步调试
- en: 'First, we need to install `gdb` by running the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过运行以下命令安装`gdb`：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The installation should look something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应该是这样的：
- en: '![](img/b981eea0-bf56-42d4-a2c8-2ada69dc77a8.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b981eea0-bf56-42d4-a2c8-2ada69dc77a8.png)'
- en: 'Then, use `gdb` to debug the `hello` program, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`gdb`来调试`hello`程序，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`gdb` can be controlled using commands. The commands are fully listed in online
    documentation, but simply entering *help* can aid us with the basics.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`可以通过命令进行控制。这些命令在在线文档中有详细列出，但只需输入*help*就可以帮助我们掌握基础。'
- en: 'You can also use `gdb` to show the disassembly of specified functions, using
    the `disass` command. For example, let''s see what happens if we use the `disass
    main` command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`gdb`显示指定函数的反汇编，通过`disass`命令。例如，让我们看看如果我们使用`disass main`命令会发生什么：
- en: '![](img/70b5fff3-cc33-4560-8105-6fc97af05e6c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70b5fff3-cc33-4560-8105-6fc97af05e6c.png)'
- en: 'Then, again we have been given the disassembly in AT&T sytnax. To set `gdb`
    to use Intel syntax, use the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次获得了以AT&T语法表示的反汇编。要将`gdb`设置为使用Intel语法，请使用以下命令：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should give us the Intel assembly language syntax, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给我们Intel汇编语言语法，如下所示：
- en: '![](img/dae5d1c8-b452-4953-9a17-408ebba42b02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dae5d1c8-b452-4953-9a17-408ebba42b02.png)'
- en: To place a breakpoint at the *main* function, the command would be `b *main`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在*main*函数处设置断点，命令是`b *main`。
- en: Take note that the asterisk (***) specifies an address location in the program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，星号 (***) 指定了程序中的地址位置。
- en: 'After placing a breakpoint, we can run the program using the `run` command.
    We should end up at the address of the `main` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，我们可以使用 `run` 命令运行程序。我们应该最终到达 `main` 函数的地址：
- en: '![](img/ca8df952-7c77-4d62-b292-cd6b31fe5ae1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8df952-7c77-4d62-b292-cd6b31fe5ae1.png)'
- en: To get the current values of the registers, enter `info registers`. Since we
    are in a 32-bit environment, the extended registers (that is, EAX, ECX, EDX, EBX,
    and EIP) are used. A 64-bit environment would show the registers with the R-prefix
    (that is, RAX, RCX, RDX, RBX, and RIP).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前寄存器的值，请输入 `info registers`。由于我们处于 32 位环境中，因此会使用扩展寄存器（即 EAX、ECX、EDX、EBX
    和 EIP）。如果是 64 位环境，寄存器会以 R 为前缀（即 RAX、RCX、RDX、RBX 和 RIP）。
- en: Now that we are at the main function, we can run each instruction with step
    into (the `stepi` command) and step over (the `nexti` command). Usually, we follow
    this with the `info registers` command to see what values changed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了主函数，我们可以逐步执行每条指令（使用 `stepi` 命令）并跳过指令（使用 `nexti` 命令）。通常，我们会跟随 `info
    registers` 命令，查看哪些值发生了变化。
- en: The abbreviated command equivalent of `stepi` and `nexti` are `si` and `ni` respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`stepi` 和 `nexti` 的简写命令分别是 `si` 和 `ni`。'
- en: 'Keep on entering `si` and `disass main` until you reach the line containing `call 
     0x80482e0 <puts@plt>`. You should end up with these `disass` and `info registers`
    result:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 继续输入 `si` 和 `disass main`，直到你看到包含 `call   0x80482e0 <puts@plt>` 的行。你应该会得到以下
    `disass` 和 `info registers` 的结果：
- en: '![](img/715fa4b8-b7b4-4a89-9cfe-f83f3f2fcb90.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/715fa4b8-b7b4-4a89-9cfe-f83f3f2fcb90.png)'
- en: 'The `=>` found at the left side indicates where the instruction pointer is
    located. The registers should look similar to this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的 `=>` 指示了指令指针所在的位置。寄存器应如下所示：
- en: '![](img/fe08f099-3f30-41bb-b635-d513eba128c8.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe08f099-3f30-41bb-b635-d513eba128c8.png)'
- en: 'Before the *puts* function gets called, we can inspect what values were pushed
    into the stack. We can view that with `x/8x $esp`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *puts* 函数被调用之前，我们可以检查栈中推入的值。我们可以通过 `x/8x $esp` 查看：
- en: '![](img/7d9e3ec2-7058-4fdc-b797-5ca2a81da2b0.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d9e3ec2-7058-4fdc-b797-5ca2a81da2b0.png)'
- en: 'The `x` command is used to show a memory dump of the specified address. The
    syntax is x/FMT ADDRESS. FMT has 3 parts: the repeat count, the format letter,
    and the size letter. You should be able to see more information about the `x`
    command with `help x`. `x/8x $esp` shows 8 DWORD hexadecimal values from the address
    pointed by the `esp` register. Since the address space is in 32 bits, the default
    size letter was shown in `DWORD` size.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 命令用于显示指定地址的内存转储。语法为 `x/FMT ADDRESS`。FMT 有三个部分：重复次数、格式字母和大小字母。你可以通过 `help
    x` 查看更多关于 `x` 命令的信息。`x/8x $esp` 会从 `esp` 寄存器指向的地址处显示 8 个 DWORD 十六进制值。由于地址空间是 32
    位的，因此默认的大小字母是 `DWORD`。'
- en: '`puts` expects a single parameter. Thus, we are only interested in the first
    value pushed at the `0x080484c0` stack location. We expect that the parameter
    should be an address to where the message should be. So, entering the `x/s` command should
    give us the contents of the message, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`puts` 期望一个单一的参数。因此，我们只关注在 `0x080484c0` 栈位置推送的第一个值。我们预计该参数应该是一个消息存放的地址。因此，输入
    `x/s` 命令应该给出消息的内容，如下所示：'
- en: '![](img/3340ddc8-a942-4f2b-881b-22c9873765c0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3340ddc8-a942-4f2b-881b-22c9873765c0.png)'
- en: 'Next, we need to do a step over (`ni`) the call instruction line. This should
    display the following message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对调用指令行进行跳过（`ni`）。这应该会显示以下消息：
- en: '![](img/1d363b89-6fa1-48bc-81f0-383c6c0188b8.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d363b89-6fa1-48bc-81f0-383c6c0188b8.png)'
- en: 'But if you used `si`, the instruction pointer will be in the *puts* wrapper
    code. We can still go back to where we left off using the `until` command, abbreviated
    as `u`. Simply using the `until` command steps in one instruction. You''ll have
    to indicate the address location where it will stop. It is like a temporary breakpoint.
    Remember to place an asterisk before the address:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你使用了 `si`，指令指针将位于 *puts* 包装代码中。我们仍然可以使用 `until` 命令回到我们离开的地方，简写为 `u`。只使用
    `until` 命令将步进一条指令。你需要指定停止的位置地址。这就像是一个临时的断点。记得在地址前加上星号：
- en: '![](img/791b767d-655f-44aa-a05e-7b05b8dba256.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/791b767d-655f-44aa-a05e-7b05b8dba256.png)'
- en: The remaining `6` lines of code restore the values of *ebp* and *esp* right
    after entering the main function, then returning with *ret*. Remember that a call
    instruction would store the return address at the top of the stack, before actually
    jumping to the function address. The `ret` instruction will read the return value
    pointed to by the *esp* register.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的 `6` 行代码会在进入 main 函数后恢复 *ebp* 和 *esp* 的值，然后通过 *ret* 返回。记住，调用指令会在跳转到函数地址之前，将返回地址存储在栈顶。`ret`
    指令将读取 *esp* 寄存器指向的返回值。
- en: The values of `esp` and `ebp`, right after entering the main function, should
    be restored before the *ret* instruction. Generally, a function begins by setting
    up its own stack frame for use with the function's local variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`esp` 和 `ebp` 的值应在执行 *ret* 指令之前恢复。通常，函数开始时会设置自己的栈帧，以便与函数的局部变量一起使用。'
- en: Here's a table showing the changes in the values of the `esp`, `ebp`, and `ecx` registers
    after the instruction at the given address.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是展示给定地址指令执行后 `esp`、`ebp` 和 `ecx` 寄存器值变化的表格。
- en: Note that the stack, denoted by the *esp* register, starts from a high address
    and goes down to lower addresses as it is used to store data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，栈由 *esp* 寄存器表示，栈从高地址开始，随着数据的存储，地址逐渐下降。
- en: '| **Address** | **Instruction** | **esp** | **ebp** | **ecx** | **Remarks**
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **指令** | **esp** | **ebp** | **ecx** | **备注** |'
- en: '| `0x0804840b` | `lea ecx,[esp+0x04]` | `0xbffff08c` | `0` | `0xbffff090` |
    Initial values after entering main. [0xbffff08c] = 0xb7e21637This is the return
    address.  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804840b` | `lea ecx,[esp+0x04]` | `0xbffff08c` | `0` | `0xbffff090` |
    进入 main 后的初始值。[0xbffff08c] = 0xb7e21637，这是返回地址。 |'
- en: '| `0x0804840f` | `and esp,0xfffffff0` | `0xbffff080` | `0` | `0xbffff090` |
    Aligns the stack in 16-byte paragraphs. In effect, this subtracts 0xc from esp.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804840f` | `and esp,0xfffffff0` | `0xbffff080` | `0` | `0xbffff090` |
    将栈对齐到 16 字节边界。实际上，这将 esp 减去 0xc。 |'
- en: '| `0x08048412` | `push DWORD PTR [ecx-0x4]` | `0xbffff07c` | `0` | `0xbffff090`
    | [0xbffff07c] = 0xb7e21637ecx - 4 = 0xbffff08c points to the return address.The
    return address is now placed in two stack addresses. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048412` | `push DWORD PTR [ecx-0x4]` | `0xbffff07c` | `0` | `0xbffff090`
    | [0xbffff07c] = 0xb7e21637，ecx - 4 = 0xbffff08c 指向返回地址。现在返回地址被放置在两个栈地址中。 |'
- en: '| `0x08048415` | `push ebp` | `0xbffff078` | `0` | `0xbffff090` | Begins stack
    frame setup.[0xbffff078] = 0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048415` | `push ebp` | `0xbffff078` | `0` | `0xbffff090` | 开始设置栈帧。[0xbffff078]
    = 0 |'
- en: '| `0x08048416` | `mov ebp,esp` | `0xbffff078` | `0xbffff078` | `0xbffff090`
    | Saves esp. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048416` | `mov ebp,esp` | `0xbffff078` | `0xbffff078` | `0xbffff090`
    | 保存 esp。 |'
- en: '| `0x08048418` | `push ecx` | `0xbffff074` | `0xbffff078` | `0xbffff090` |
    Saves ecx.[0xbffff074] = 0xbffff090 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048418` | `push ecx` | `0xbffff074` | `0xbffff078` | `0xbffff090` |
    保存 ecx。[0xbffff074] = 0xbffff090。 |'
- en: '| `0x08048419` | `sub esp,0x4` | `0xbffff070` | `0xbffff078` | `0xbffff090`
    | Allocates 4 bytes for stack frame. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048419` | `sub esp,0x4` | `0xbffff070` | `0xbffff078` | `0xbffff090`
    | 为栈帧分配 4 字节空间。 |'
- en: '| `0x0804841c` | `sub esp,0xc` | `0xbffff064` | `0xbffff078` | `0xbffff090`
    | Allocates another 12 bytes for stack frame. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804841c` | `sub esp,0xc` | `0xbffff064` | `0xbffff078` | `0xbffff090`
    | 为栈帧分配额外的 12 字节空间。 |'
- en: '| `0x0804841f` | `push 0x80484c0` | `0xbffff060` | `0xbffff078` | `0xbffff090`
    | [0xbffff060] = 0x080484c0[0x080484c0] = "hello world!" |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804841f` | `push 0x80484c0` | `0xbffff060` | `0xbffff078` | `0xbffff090`
    | [0xbffff060] = 0x080484c0，[0x080484c0] = "hello world!" |'
- en: '| `0x08048424` | `call 0x80482e0 <puts@plt>` | `0xbffff060` | `0xbffff078`
    | `0xffffffff` | Stack is still the same after the call. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048424` | `call 0x80482e0 <puts@plt>` | `0xbffff060` | `0xbffff078`
    | `0xffffffff` | 调用后栈没有变化。 |'
- en: '| `0x08048429` | `add esp,0x10` | `0xbffff070` | `0xbffff078` | `0xffffffff`
    | Adds 0x10 to esp reducing the stack frame. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048429` | `add esp,0x10` | `0xbffff070` | `0xbffff078` | `0xffffffff`
    | 将 0x10 加到 esp，减少栈帧大小。 |'
- en: '| `0x0804842c` | `nop` | `0xbffff070` | `0xbffff078` | `0xffffffff` | No operation
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804842c` | `nop` | `0xbffff070` | `0xbffff078` | `0xffffffff` | 无操作 |'
- en: '| `0x0804842d` | `mov ecx,DWORD PTR [ebp-0x4]` | `0xbffff070` | `0xbffff078`
    | `0xbffff090` | Restores the value of ecx before call. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `0x0804842d` | `mov ecx,DWORD PTR [ebp-0x4]` | `0xbffff070` | `0xbffff078`
    | `0xbffff090` | 恢复调用前的 ecx 值。 |'
- en: '| `0x08048430` | `leave` | `0xbffff07c` | `0` | `0xbffff090` | `leave` is the
    equivalent of `mov esp, ebp`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '| `0x08048430` | `leave` | `0xbffff07c` | `0` | `0xbffff090` | `leave` 相当于
    `mov esp, ebp`。 |'
- en: '`pop ebp` |'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop ebp` |'
- en: '| `0x08048431` | `lea esp,[ecx-0x4]` | `0xbffff08c` | `0` | `0xbffff090` |
    ecx - 4 = 0xbffff08c[0xbffff08c] = 0xb7e21637The address of esp is restored back.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048431` | `lea esp,[ecx-0x4]` | `0xbffff08c` | `0` | `0xbffff090` |
    ecx - 4 = 0xbffff08c，[0xbffff08c] = 0xb7e21637，恢复了 esp 的地址。 |'
- en: '| `0x08048434` | `ret` | `-` | `-` | `-` | Returns to 0xb7e21637 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `0x08048434` | `ret` | `-` | `-` | `-` | 返回到 0xb7e21637。 |'
- en: 'You can either continue exploring the cleanup code after `ret`, or just make
    the program eventually end by using `continue` or its abbreviation, `c`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续探索`ret`后的清理代码，或者通过使用`continue`或它的缩写`c`让程序最终结束，如下所示：
- en: '![](img/200c3f96-d71a-4a65-a6a0-b17b8f627d33.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/200c3f96-d71a-4a65-a6a0-b17b8f627d33.png)'
- en: A better debugger
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更好的调试器
- en: Before moving to more Linux executable-reversing activities, let's explore more
    tools. `gdb` seems fine, but it would have been better if we were able to debug
    it interactively, using visual tools for debugging. In [Chapter 5](d07cbca0-a1cf-4ad3-9c69-39c1359f0209.xhtml),* Tools
    of Trade*, we introduced the Radare, under the *Disassemblers* and *Debuggers*
    sections, as a tool that is capable of doing both disassembly and debugging. So,
    let's get a feel for using Radare.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更多Linux可执行文件逆向操作之前，让我们先探索更多工具。`gdb`看起来可以，但如果我们能使用可视化调试工具进行交互式调试会更好。在[第五章](d07cbca0-a1cf-4ad3-9c69-39c1359f0209.xhtml)，*工具的使用*部分，我们介绍了Radare，作为一个既能进行反汇编也能进行调试的工具。所以，让我们感受一下使用Radare的体验。
- en: Setup
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Radare is in its second version. To install it, you''ll need ***git*** to install
    from the GitHub repository, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Radare已经是第二个版本。要安装它，你需要***git***从GitHub仓库进行安装，步骤如下：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The instructions for installing it are written in the `README` file. As of the
    time of writing, it is suggested that `Radare2` is installed by running the `sys/install.sh`
    or `sys/user.sh` shell scripts from the Terminal.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明写在`README`文件中。根据写作时的建议，可以通过运行`sys/install.sh`或`sys/user.sh`的shell脚本在终端中安装`Radare2`。
- en: Hello World in Radare2
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Radare2中的Hello World
- en: Besides its disassembler and debugger, `Radare2` is also packed with a bunch
    of tools . Most of these are static analysis tools.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反汇编器和调试器，`Radare2`还包含了一堆工具。大多数都是静态分析工具。
- en: 'To get the `MD5` hash of the hello world binary file, we can use `rabin2`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取hello world二进制文件的`MD5`哈希值，可以使用`rabin2`：
- en: '![](img/14d9938f-1db4-4264-ba60-11170b3493bf.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14d9938f-1db4-4264-ba60-11170b3493bf.png)'
- en: 'With the use of the `ls` command and `rahash2`, we are able to determine these
    pieces of information:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ls`命令和`rahash2`，我们能够确定以下信息：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`rabin2` is another tool that can extract static information from a file, such
    as the type of file, header information, sections, and strings.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`rabin2`是另一个可以从文件中提取静态信息的工具，例如文件类型、头信息、部分内容和字符串。'
- en: 'Let''s get the type of file first by using the `rabin2 -I hello` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过使用`rabin2 -I hello`命令获取文件类型：
- en: '![](img/19e3d518-6902-40e0-a205-8c73953b44d4.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19e3d518-6902-40e0-a205-8c73953b44d4.png)'
- en: The *bintype*, *class,* *hascode,* and *os* fields indicate that the file is
    an executable 32-bit ELF file that runs in Linux. *arch*, *bits*, *endian,* and
    *machine* suggest that the file was built with an x86 code. In addition, the *lang*
    field indicates that the file was compiled from C language. This information will
    definitely help us prepare for what to expect during disassembly and debugging.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*bintype*、*class*、*hascode* 和 *os* 字段表明该文件是一个可执行的32位ELF文件，并且可以在Linux上运行。*arch*、*bits*、*endian*
    和 *machine* 表示该文件是用x86代码构建的。此外，*lang*字段表明该文件是从C语言编译而来的。这些信息无疑将帮助我们在反汇编和调试时做好准备。'
- en: 'To list imported functions, we use `rabin2 -i hello`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出导入的函数，我们使用`rabin2 -i hello`：
- en: '![](img/b69f875d-034f-4218-8bee-0a5f90d1d9f5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69f875d-034f-4218-8bee-0a5f90d1d9f5.png)'
- en: There are two global functions we are interested in: `puts` and `__libc_start_main. puts`,
    as we discussed, is used to print a message. __libc_start_main is a function that
    initializes the stack frame, sets up the registers and some data structures, sets
    up error handling, and then calls the `main()` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的有两个全局函数：`puts`和`__libc_start_main`。如我们所讨论，`puts`用于打印消息。`__libc_start_main`是一个初始化堆栈帧、设置寄存器和一些数据结构、设置错误处理并最终调用`main()`函数的函数。
- en: 'To get the ELF header info, use `rabin2 -H hello`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取ELF头信息，可以使用`rabin2 -H hello`：
- en: '![](img/57482507-87b8-4d5a-bf71-ff97abe09293.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57482507-87b8-4d5a-bf71-ff97abe09293.png)'
- en: 'If we are only interested with the strings we can find from the data section,
    use the `rabin2 -z hello` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只对从数据段中找到的字符串感兴趣，可以使用`rabin2 -z hello`命令：
- en: '![](img/1fa0a014-2c46-40a1-be5f-baba6946c0ab.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fa0a014-2c46-40a1-be5f-baba6946c0ab.png)'
- en: 'With `rabin2`, we got additional information about the file, shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rabin2`，我们获得了关于文件的额外信息，如下所示：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s try the `radare2` debugger itself. From the Terminal console, you can
    either use `radare2`''s abbreviation `r2`, or `radare2` itself, with the `-d <file>`
    as its argument:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用`radare2`调试器。从终端控制台，你可以使用`radare2`的缩写`r2`，或者直接使用`radare2`，并将`-d <file>`作为参数：
- en: '![](img/7f4d2f8b-088d-4dac-a561-9102bee56749.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f4d2f8b-088d-4dac-a561-9102bee56749.png)'
- en: 'This takes you to the `radare2` console. Enclosed in square brackets, the address
    indicates where the current `eip` is. It is not the entry point of the hello program,
    but rather an address in the dynamic loader. As with `gdb`, you''ll have to enter
    commands. To bring up help, just use ***?*** and it will show you a list of commands
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带你进入`radare2`控制台。在方括号中，地址表示当前`eip`的位置。这不是hello程序的入口点，而是动态加载器中的一个地址。与`gdb`类似，你需要输入命令。要调出帮助，只需使用***?***，它将显示如下命令列表：
- en: '![](img/c9fcbae6-12b8-4e7a-9003-c55da31a5eda.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9fcbae6-12b8-4e7a-9003-c55da31a5eda.png)'
- en: 'We start off by using the `aaa` command. This analyzes the code for function
    calls, flags, references and tries to generate constructive function names:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`aaa`命令。此命令分析代码中的函数调用、标志、引用，并尝试生成有意义的函数名称：
- en: '![](img/5b9d3a96-9da9-43c2-a57c-2c1f30d810d0.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b9d3a96-9da9-43c2-a57c-2c1f30d810d0.png)'
- en: 'Using the `V!` command sets the console to visual mode. In this mode, we should
    be able to debug the program while having an interactive view of the registry
    and the stack. Entering `:` should show a command console. Pressing *Enter* should
    bring us back to visual mode. Type `V?` to show more visual mode commands. It
    is also best to maximize the Terminal window to get a better view of the debugger:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`V!`命令将控制台设置为可视模式。在此模式下，我们应该能够在交互式查看寄存器和栈的同时调试程序。输入`:`应该会显示命令控制台。按*Enter*键将使我们返回可视模式。输入`V?`以显示更多可视模式命令。最好将终端窗口最大化，以便更好地查看调试器：
- en: '![](img/5a6d0096-31f5-48dc-bc6f-fb42273bd2bc.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a6d0096-31f5-48dc-bc6f-fb42273bd2bc.png)'
- en: In the command console, enter `db entry0`. This should set a breakpoint at the
    entry point address of our program. But, since we also know that this program
    has a main function, you can also enter `db sym.entry` to set a breakpoint at
    the main function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令控制台中，输入`db entry0`。这将设置一个断点，位于我们程序的入口地址。但由于我们也知道该程序有一个主函数，你还可以输入`db sym.entry`，在主函数处设置断点。
- en: 'In visual mode, you can start the actual debugging using these keys that are
    available by default:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视模式中，你可以使用默认提供的这些按键开始实际的调试：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the entry point and main function set with a breakpoint, press *F9* to
    run the program. We should end up in the entry point address.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置入口点和主函数的断点，按*F9*运行程序。我们应该会到达入口点地址。
- en: You'll need to refresh radare2's visual mode by reopening it to see the changes.
    To do that, just press `q` twice to quit visual mode. But before running `V!`
    again, you'll need to seek the current *eip* by using the `s eip` command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过重新打开`radare2`的可视模式来刷新它，以查看更改。为此，只需按`q`两次退出可视模式。但在再次运行`V!`之前，你需要通过使用`s eip`命令来查找当前的*eip*。
- en: 'Pressing *F9* again should bring you to the main function of our program. Remember
    to refresh the visual mode:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次按*F9*应该将你带到程序的主函数。记得刷新可视模式：
- en: '![](img/1bfd154d-269a-43cc-8ba7-73e7b9e793f5.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bfd154d-269a-43cc-8ba7-73e7b9e793f5.png)'
- en: Press *F7* or *F8* to trace the program while seeing the stack and registers
    change. The letter **b** at the left of the address at line `0x0804840b` indicates
    that the address is set with a breakpoint.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按*F7*或*F8*可以跟踪程序的执行，同时查看栈和寄存器的变化。在`0x0804840b`这一行地址左侧的字母**b**表示该地址已设置断点。
- en: So far, we have learned about the basic commands and keys. Feel free to explore
    the other commands and you'll definitely get more information and learn some easy
    ways to work around analyzing files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了基本的命令和按键。随时探索其他命令，你肯定能获取更多信息，并学到一些简单的技巧来分析文件。
- en: What is the password?
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码是什么？
- en: So now that we know how to debug "`Unix style`", let's try the passcode program.
    You can download the passcode program from [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/passcode](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/passcode).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何进行“`Unix 风格`”调试，让我们尝试密码程序。你可以从[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/passcode](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/passcode)下载密码程序。
- en: 'Try to get some static information. Here''s a list of commands you can use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试获取一些静态信息。以下是你可以使用的命令列表：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, the information we''re after is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们正在寻找的信息如下：
- en: 'File size: 7,520 bytes'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小：7,520字节
- en: 'MD5 hash: `b365e87a6e532d68909fb19494168bed`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MD5哈希：`b365e87a6e532d68909fb19494168bed`
- en: 'SHA256 hash: `68d6db63b69a7a55948e9d25065350c8e1ace9cd81e55a102bd42cc7fc527d8f`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA256哈希：`68d6db63b69a7a55948e9d25065350c8e1ace9cd81e55a102bd42cc7fc527d8f`
- en: 'The type of file: ELF'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型：ELF
- en: 32-bit x86 Intel
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位 x86 Intel
- en: Compiled C code that has notable imported functions: `printf`, `puts`, `strlen`
    and `__isoc99_scanf`
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的C代码中有一些显著的导入函数：`printf`、`puts`、`strlen` 和 `__isoc99_scanf`
- en: 'Notable strings are as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的字符串如下：
- en: 'Enter password:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入密码：
- en: Correct password!
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的密码！
- en: Incorrect password!
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码错误！
- en: 'Now, for a quick dynamic analysis, let''s use `ltrace ./passcode`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了进行快速动态分析，让我们使用`ltrace ./passcode`：
- en: '![](img/add36a4b-6311-4548-b3b3-94e565a8b4e0.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/add36a4b-6311-4548-b3b3-94e565a8b4e0.png)'
- en: 'We tried a few passwords but none returned "Correct password!" The file doesn''t
    even have a hint in the list of strings for us to use. Let''s try `strace`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了几个密码，但没有一个返回“正确密码！”该文件甚至没有字符串列表中的任何提示供我们使用。让我们尝试`strace`：
- en: '![](img/17b71727-34bd-41a3-af90-0d30fb47d235.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17b71727-34bd-41a3-af90-0d30fb47d235.png)'
- en: 'The line with `read(0, asdf123` is where the password was manually entered.
    The code after this goes to the exit door. Let''s do a deadlisting activity based
    on the disassembly, but this time, we''ll use `radare2`''s graphical view. Go
    ahead and open up `radare2` with the `radare2 -d passcode` command. In the `radare2`
    console, use this sequence of commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`read(0, asdf123`的那一行是密码被手动输入的地方。之后的代码进入退出流程。让我们基于反汇编代码做一个死名单活动，但这次我们将使用`radare2`的图形视图。请打开`radare2`，并使用`radare2
    -d passcode`命令。在`radare2`控制台中，使用以下命令序列：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These should open up a graphical representation of the disassembly code blocks
    from the *main* function. Scroll down and you should see conditional branching
    where the green line denotes a `true`, while the red line denotes a `false` flow.
    Keep scrolling down until you see the `Correct password!` text string. We''ll
    work backwards from there:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该打开来自*main*函数的反汇编代码块的图形表示。向下滚动，你应该能看到条件分支，其中绿色线条表示`true`，红色线条表示`false`流程。继续向下滚动，直到看到`Correct
    password!`文本字符串。我们将从这里向后工作：
- en: '![](img/cd9fdf03-bf07-43d5-9959-1bc333c8ae06.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd9fdf03-bf07-43d5-9959-1bc333c8ae06.png)'
- en: 'In the `0x80485d3` block, where the `Correct password!` string is, we see that
    the message was displayed using *puts*. Going to that block is a red line from
    the `0x80485c7` block. In the `0x80485c7` block, the value in `local_418h` was
    compared to `0x2de` (or 734 in decimal format). The value should be equal to 734
    to make it go to the `Correct password!` block. If we were to try to decompile
    the C code, it would look something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0x80485d3`块中，显示`Correct password!`字符串，我们看到该消息是通过*puts*函数显示的。进入该块的是来自`0x80485c7`块的红线。在`0x80485c7`块中，`local_418h`的值与`0x2de`（即十进制的734）进行了比较。为了跳转到`Correct
    password!`块，值应该等于734。如果我们尝试反编译C代码，它应该类似于下面这样：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Scroll up to see where the red line came from:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 向上滚动查看红线的来源：
- en: '![](img/3baf70f4-e296-4bff-b5e7-9d8e2cf172d4.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3baf70f4-e296-4bff-b5e7-9d8e2cf172d4.png)'
- en: By the way this graph looks, there is a loop, and to exit the loop, it would
    require the value at `local_414h` to be greater than or equal to the value at
    `local_410h`. The loop exits to the `0x80485c7` block. At the `0x8048582` block,
    both values at `local_418h` and `local_414h` are initialized to 0\. These values
    are compared in the `0x80485b9` block.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图形来看，存在一个循环，退出循环需要`local_414h`的值大于或等于`local_410h`的值。循环会跳转到`0x80485c7`块。在`0x8048582`块中，`local_418h`和`local_414h`的值都被初始化为0。这些值在`0x80485b9`块中进行比较。
- en: 'Inspecting the `0x8048598` block, there are three variables of concern: `local_40ch`,
    `local_414h`, and `local_418h`. If we were to make a pseudo code of this block,
    it would look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`0x8048598`块时，有三个需要关注的变量：`local_40ch`、`local_414h` 和 `local_418h`。如果我们为这个块编写伪代码，它应该是这样的：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`local_414h` seem to be a pointer of the data pointed to by `local_40c`. `local_418`
    starts from 0, and each byte from `local_40ch` is added. Looking at an overview,
    a checksum algorithm seems to be happening here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_414h`似乎是指向`local_40c`指向的数据的指针。`local_418`从0开始，每次添加`local_40ch`中的一个字节。从概览来看，这里似乎发生了一个校验和算法：'
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s move further up and identify what `local_40ch` and `local_410h` should
    be:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步向上滚动，找出`local_40ch`和`local_410h`应该是什么：
- en: '![](img/cda0a10d-bf1d-4487-ae47-a4aee0d4533f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda0a10d-bf1d-4487-ae47-a4aee0d4533f.png)'
- en: 'This is the main block. There are three named functions here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主块。这里有三个命名的函数：
- en: '`printf()`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf()`'
- en: '`scanf()`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanf()`'
- en: '`strlen()`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strlen()`'
- en: '`local_40ch` and `local_410h` here were used. `local_40ch` is the second parameter
    for `scanf`, while the data at the `0x80486b1` address should contain the format
    expected. `local_40ch` contains the buffer typed in. To retrieve the data at `0x80486b1`,
    just enter a colon (`:`), enter `s 0x80486b1`, then return back to the visual
    mode. Press `q` again to view the data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了`local_40ch`和`local_410h`。`local_40ch`是`scanf`的第二个参数，而`0x80486b1`地址中的数据应该包含期望的格式。`local_40ch`包含输入的缓冲区内容。要检索`0x80486b1`处的数据，只需输入冒号（`:`），输入`s
    0x80486b1`，然后返回可视模式。再次按`q`查看数据：
- en: '![](img/a3bb1b71-9c1c-4250-aa97-77185aa8c6ae.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3bb1b71-9c1c-4250-aa97-77185aa8c6ae.png)'
- en: The length of the data in `local_40ch` is identified and stored in `local_410h`.
    The value at `local_410h` is compared to 7\. If equal, it follows the red line
    going to the `0x8048582` block, or the start of the checksum loop. If not, it
    follows the green line going to the `0x80485e5` block that contains code that
    will display Incorrect password!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_40ch`中数据的长度被识别并存储在`local_410h`中。`local_410h`中的值与7进行比较。如果相等，程序会沿着红线进入`0x8048582`块，即校验和循环的开始。如果不相等，程序会沿着绿线进入`0x80485e5`块，其中包含显示“密码错误！”的代码。'
- en: 'In summary, the code would most likely look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，代码可能是这样的：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The entered password should have a **size of 7 characters** and the sum of all
    characters in the password should be **equal to 734**. Therefore, the password
    can be anything, as long as it satisfies the given conditions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的密码应该有**7个字符**，并且密码中所有字符的总和应该**等于734**。因此，密码可以是任何内容，只要满足给定的条件即可。
- en: 'Using the ASCII table, we can determine the equivalent value of each character.
    If the sum is 734 from a total of 7 characters, we simply divide 734 by 7\. This
    gives us a value of 104, or 0x68 with a remainder of 6\. We can distribute the
    remainder, 6, to 6 of the characters, giving us this set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ASCII表，我们可以确定每个字符的等效值。如果7个字符的总和为734，我们只需将734除以7，这样得到的结果是104，或者0x68，余数为6。我们可以将余数6分配给6个字符，得到如下字符集：
- en: '| **Decimal** | **Hex** | **ASCII character** |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | **十六进制** | **ASCII字符** |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `105` | `0x69` | `i` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `105` | `0x69` | `i` |'
- en: '| `104` | `0x68` | `h` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `104` | `0x68` | `h` |'
- en: 'Let''s try the password `*iiiiiih*` or `*hiiiiii*`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试密码`*iiiiiih*`或`*hiiiiii*`，如下面所示：
- en: '![](img/9662b666-050d-4866-aae5-afaa040eb512.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9662b666-050d-4866-aae5-afaa040eb512.png)'
- en: Network traffic analysis
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络流量分析
- en: 'This time, we''ll work on a program that receives a network connection and
    sends back some data. We will be using the file available at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/server](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/server).
    Once you have it downloaded, execute it from the Terminal as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将编写一个接收网络连接并返回一些数据的程序。我们将使用可在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/server](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/raw/master/ch6/server)下载的文件。下载完成后，通过终端执行该文件，命令如下：
- en: '![](img/f0923c75-f968-4b69-a0ee-b31f029798c8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0923c75-f968-4b69-a0ee-b31f029798c8.png)'
- en: 'The program is a server program that waits for connections to port `9999`.
    To test this out, open a browser, then use the IP address of the machine where
    the server is running, plus the port. For example, use `127.0.0.1:9999` if you''re
    trying this from your own machine. You might see something like the following
    output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序是一个等待连接到端口`9999`的服务器程序。要进行测试，请打开浏览器，使用服务器运行机器的IP地址和端口。例如，如果您在自己的机器上尝试，可以使用`127.0.0.1:9999`。您可能会看到如下输出：
- en: '![](img/9bb98eba-3bda-459c-b49a-6c759f743deb.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bb98eba-3bda-459c-b49a-6c759f743deb.png)'
- en: 'To understand network traffic, we need to capture some network packets by using
    tools such as `tcpdump`. `tcpdump` is usually pre-installed in Linux distributions.
    Open another Terminal and use the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解网络流量，我们需要使用诸如`tcpdump`之类的工具来捕获一些网络数据包。`tcpdump`通常在Linux发行版中预安装。打开另一个终端并使用以下命令：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s a brief explanation of the parameters used:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所用参数的简要解释：
- en: '`-i lo` uses the `loopback` network interface. We have used it here since we
    plan on accessing the server locally.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i lo` 使用 `loopback` 网络接口。我们在这里使用它，因为我们计划在本地访问该服务器。'
- en: '`''port 9999''`, with the single quotes, filters only packets that are using
    port 9999.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`''port 9999''`，带单引号的部分，仅筛选使用端口9999的报文。'
- en: '`-w captured.pcap` writes data packets to a PCAP file named `captured.pcap`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w captured.pcap`将数据包写入名为`captured.pcap`的PCAP文件中。'
- en: Once `tcpdump` listens for data, try connecting to the server by visiting `127.0.0.1:9999`
    from the browser. If you wish to connect from outside the machine which holds
    the server, then re-run `tcpdump` without the `-i lo` parameter. This uses the
    default network interface instead. And instead of visiting using `127.0.0.1`,
    you'll have to use the IP address used by the default network interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`tcpdump`开始监听数据，尝试通过浏览器访问`127.0.0.1:9999`来连接服务器。如果你希望从服务器所在机器外部连接，则重新运行`tcpdump`，不要加上`-i
    lo`参数。这样会使用默认的网络接口。而且，你需要使用默认网络接口的IP地址，而不是`127.0.0.1`来进行访问。
- en: To stop `tcpdump`, just break it using *Ctrl* + *C*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止`tcpdump`，只需通过*Ctrl* + *C*中断它。
- en: 'To view the contents of `captured.pcap` in human readable form, use the following
    command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要以人类可读的形式查看`captured.pcap`文件的内容，可以使用以下命令：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command should redirect the the `tcpdump` output to `captured.log`. The `-X`
    parameter shows the packet data in hexadecimal and ASCII. `-r captured.pcap` means
    read from the `PCAP` file `captured.pcap`. Opening the `captured.log` file should
    look something like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应将`tcpdump`的输出重定向到`captured.log`。`-X`参数以十六进制和ASCII形式显示数据包的内容。`-r captured.pcap`表示从`PCAP`文件`captured.pcap`中读取数据。打开`captured.log`文件时，应该类似以下内容：
- en: '![](img/ca234b8d-421e-479d-9ce2-eafb8c3b3965.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca234b8d-421e-479d-9ce2-eafb8c3b3965.png)'
- en: Before we proceed, let's examine some basics on the two most popular network
    protocols, **Transmission Control Protocol **(**TCP**) and **User Datagram Protocol**
    (**UDP**). TCP is a network transmission in which a communication between a sender
    and a receiver is established. The communication begins with a 3-way handshake,
    where the sender sends a SYN flag to the receiver, then the receiver sends back
    SYN and ACK flags to the sender, and finally, the sender sends an ACK flag to
    the receiver, opening the start of a communication. Further exchange of data between
    the sender and receiver are done in segments. Every segment has a 20-byte TCP
    header that contains the IP address of the sender and the receiver and any current
    status flags. This is followed by the size of the data being transmitted and the
    data itself. UDP uses a shorter header, since it only sends data and doesn't require
    acknowledgement from the receiver. It is not required, via UDP, to do a 3-way
    handshake. The primary purpose of UDP is to keep sending data to the receiver.
    TCP seems to be more reliable in terms of exchanging data, however. For UDP, sending
    data is much faster, as there are no overheads required. UDP is commonly used
    to transmit huge amounts of data via file transmission protocols, while TCP is
    used to communicate data that requires integrity.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先了解一下两种最常见的网络协议，**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。TCP是一种网络传输协议，它建立了发送方和接收方之间的通信。通信开始时进行三次握手，发送方向接收方发送SYN标志，接收方再向发送方发送SYN和ACK标志，最后发送方再发送ACK标志给接收方，从而开启通信。发送方和接收方之间的进一步数据交换是以分段的方式进行的。每个段都有一个20字节的TCP头部，包含了发送方和接收方的IP地址以及当前的状态标志。接下来是数据的大小和数据本身。UDP使用较短的头部，因为它只发送数据，并不需要接收方的确认。UDP不需要进行三次握手。UDP的主要目的是持续不断地将数据发送给接收方。虽然TCP在数据交换方面更可靠，但UDP的数据发送速度更快，因为没有必要的开销。UDP通常用于通过文件传输协议传输大量数据，而TCP则用于需要数据完整性的通信。
- en: In the preceding screenshot, lines 1 to 15 show a TCP 3-way handshake. The first
    connection from the localhost port at `55704` (client) to the localhost port at `9999` (server)
    is a SYN, denoted in the flags as `S`. This was responded to by an `S.` flag,
    which means SYN and ACK. The last is an ACK denoted by `.` in the flags. The client
    port at 55704 is an ephemeral port. An ephemeral port is a system generated port
    for client connections. The server port at `9999` is fixed in the server program.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，第1行到第15行显示了一个TCP三次握手。第一次从本地主机端口`55704`（客户端）到本地主机端口`9999`（服务器）的连接是一个SYN，标志位为`S`。然后，服务器响应了一个`S.`标志，表示SYN和ACK。最后是一个ACK，用`
    .`表示。这时，客户端端口55704是一个临时端口。临时端口是系统为客户端连接生成的端口。服务器端口`9999`在服务器程序中是固定的。
- en: In lines 16 to 23, we can see the actual response data from the server to the
    client. The server sends back a data containing a 55 character data containing
    the string "*You have connected to the Genie. Nothing to see here.*" and 2 new
    line (`0x0A`) characters to the client. The data before the 55 character string
    is the packet's header containing information about the packet. The packet header,
    when parsed, is the information described in line 16\. The TCP flags are `P.`,
    which means PUSH and ACK. The information in the packet header structure is documented
    in the TCP and UDP specifications. You can start to look for these specifications
    at `RFC 675`, available at [https://tools.ietf.org/html/rfc675](https://tools.ietf.org/html/rfc675), and
    `RFC 768`, available at [https://tools.ietf.org/html/rfc768](https://tools.ietf.org/html/rfc768).
    To fast-track the process, we can use Wireshark, which will be discussed later,
    to help us parse through the packet information.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16行到第23行，我们可以看到服务器到客户端的实际响应数据。服务器返回一个包含55个字符的数据，包含字符串"*You have connected
    to the Genie. Nothing to see here.*"和2个换行（`0x0A`）字符。55个字符字符串前的数据是数据包的头部，包含有关数据包的信息。解析后的数据包头部内容在第16行中描述。TCP标志为`P.`，表示PUSH和ACK。数据包头部结构中的信息已在TCP和UDP规范中进行了文档化。你可以从`RFC
    675`（[https://tools.ietf.org/html/rfc675](https://tools.ietf.org/html/rfc675)）和`RFC
    768`（[https://tools.ietf.org/html/rfc768](https://tools.ietf.org/html/rfc768)）开始查找这些规范。为了加速处理过程，我们可以使用Wireshark，稍后会讨论它，来帮助我们解析数据包信息。
- en: In lines `24` to `28`, FIN and ACK flags, formatted as `F.`, are sent from the
    server to the client, saying that the server is closing the connection. Lines
    29 to 33 is an ACK response, `.`, that acknowledges the connection is being closed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`24`行到第`28`行，FIN和ACK标志，格式为`F.`，从服务器发送到客户端，表示服务器正在关闭连接。第29行到第33行是一个ACK响应，`.`，确认连接正在关闭。
- en: 'A better tool for capturing and viewing this graphically is ***Wireshark***.
    Previously known as *Ethereal*, Wireshark has the same capabilities as `tcpdump`.
    Wireshark can be manually downloaded and installed from [https://www.wireshark.org/](https://www.wireshark.org/).
    It can also be installed using the following `apt` command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获和查看图形化信息的更好工具是***Wireshark***。之前称为*Ethereal*，Wireshark具有与`tcpdump`相同的功能。Wireshark可以从[https://www.wireshark.org/](https://www.wireshark.org/)手动下载和安装。也可以通过以下`apt`命令进行安装：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Capturing network packets requires root privileges in order to access the network
    interfaces. This is the reason for our use of `sudo` when running ***tcpdump***.
    The same goes when using ***Wireshark***. So, to execute ***Wireshark*** in Linux,
    we use the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获网络数据包需要root权限才能访问网络接口。这也是我们在运行***tcpdump***时使用`sudo`的原因。使用***Wireshark***时也是如此。因此，要在Linux中执行***Wireshark***，我们使用以下命令：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Besides capturing traffic and showing it in real time, you can also open and
    view PCAP files in ***Wireshark***:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了捕获流量并实时显示外，您还可以在***Wireshark***中打开并查看PCAP文件：
- en: '![](img/792d9e60-f28f-40cb-a2ce-4729c1a44b4b.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/792d9e60-f28f-40cb-a2ce-4729c1a44b4b.png)'
- en: 'To start capturing, double-click on `any` from the list of interfaces. This
    essentially captures from both the default network interface and the loopback
    interface *lo*. What you''ll see are continuous lines of network traffic packets.
    Wireshark has a display filter to minimize all the noise we see. For our exercise,
    in the filter field, enter the following display filter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始捕获，双击接口列表中的`any`。这基本上会同时捕获默认网络接口和回环接口*lo*的流量。你将看到连续的网络流量数据包行。Wireshark有一个显示过滤器，可以最小化我们看到的所有噪音。对于我们的练习，在过滤器字段中输入以下显示过滤器：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should only show packets that use the TCP port at `9999`. There are more
    filters you can experiment on. These are documented in Wireshark's manual pages.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该只显示使用`9999`端口的TCP数据包。你还可以尝试其他过滤器。更多内容请参考Wireshark的手册页面。
- en: 'Clicking on a packet shows parsed information that gives you a better understanding
    of the packet fields, as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 点击数据包后，可以查看解析的信息，这将帮助你更好地理解数据包字段，如下图所示：
- en: '![](img/49370842-9097-4ffc-b20c-ddf9612b3ef4.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49370842-9097-4ffc-b20c-ddf9612b3ef4.png)'
- en: Wireshark has a wide-knowledge of standard packets. This makes Wireshark a must-have
    tool for every analyst.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark对标准数据包有广泛的知识。这使得Wireshark成为每个分析师必备的工具。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, our discussions revolved around reverse engineering tools that
    are already built into Linux systems. Debian-based operating systems, such as
    Ubuntu, are popular for reverse engineering purposes because of the wide community
    and tools available. We have focused more on how to analyze Linux' native executable,
    the ELF file. We started off by using GCC to compile a C program source into an
    ELF executable. We proceeded to analyze the executable using static info-gathering
    tools, including `ls`, `file`, `strings`, and `objdump`. Then we used `ltrace`
    and `strace` to carry out a dynamic analysis. Then we used `gdb` to debug the
    program, showing us Intel assembly language syntax.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了已经内置在Linux系统中的逆向工程工具。基于Debian的操作系统，如Ubuntu，由于广泛的社区支持和可用的工具，常被用于逆向工程目的。我们更多地关注了如何分析Linux原生可执行文件——ELF文件。我们首先使用GCC将一个C程序源代码编译成ELF可执行文件。接着，我们使用静态信息收集工具，包括`ls`、`file`、`strings`和`objdump`，对可执行文件进行了分析。然后我们使用`ltrace`和`strace`进行动态分析。之后我们使用`gdb`调试程序，展示了Intel汇编语言的语法。
- en: We also introduced and explored the `radare2` toolkit. We used `rahash2` and
    `rabin2` to gather static information, and used `radare2` for disassembly and
    debugging in an interactive view. Network analysis tools were not left behind
    either, as we used `tcpdump` and `Wireshark`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍并探讨了`radare2`工具包。我们使用了`rahash2`和`rabin2`来收集静态信息，并使用`radare2`在交互式视图中进行反汇编和调试。网络分析工具也没有被忽视，我们使用了`tcpdump`和`Wireshark`。
- en: In the information security world, most files to be analyzed are executables
    based on Microsoft Windows, which we're going to discuss in the next chapter.
    We may not encounter much analysis of Linux files in the industry, but knowing
    how to do it will definitely come in handy when the task requires it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息安全领域，待分析的大多数文件都是基于微软Windows的可执行文件，我们将在下一章进行讨论。虽然在行业中我们可能不会遇到太多Linux文件的分析，但了解如何进行分析一定会在任务需要时派上用场。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: The files and sources used in this chapter can be found at [https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch6](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch6)[.](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch6)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的文件和源代码可以在[https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch6](https://github.com/PacktPublishing/Mastering-Reverse-Engineering/tree/master/ch6)找到。
