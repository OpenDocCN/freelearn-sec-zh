- en: Unsanitized Data &#x2013; An XSS Case Study
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未经过滤的数据 &#x2013; 一个 XSS 案例研究
- en: '**Cross-Site Scripting** (**XSS**) is a vulnerability caused by exceptions
    built into the browser''s same-origin policy restricting how assets (images, style
    sheets, and JavaScript) are loaded from external sources.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击** (**XSS**) 是由浏览器的同源策略中的异常导致的漏洞，该策略限制了如何从外部来源加载资产（图片、样式表和 JavaScript）。'
- en: Consistently appearing in the OWASP Top-10 survey of web-application vulnerabilities,
    XSS has the potential to be a very damaging, persistent exploit that affects large
    sections of the target site's user base. It can also be difficult to stamp out,
    especially in sites that have large attack surfaces, with many form inputs, logins,
    discussion threads, and so on, to secure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 一直出现在 OWASP 十大网络应用程序漏洞调查中，有潜力成为影响目标站点大部分用户群体的非常破坏性的持久性利用漏洞。特别是在具有许多表单输入、登录、讨论线程等需要保护的站点中，它可能很难消除。
- en: This chapter will cover the browser mechanisms that create the opportunity for
    XSS, the different varieties of XSS (persistent, reflected, DOM-based, and so
    on), how to test for it, and a full example of an XSS vulnerability – from discovering
    the bug to submitting a report about it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖创建 XSS 机会的浏览器机制，XSS 的不同类型（持久性、反射性、基于 DOM 等），如何测试以及一个完整的 XSS 漏洞示例 – 从发现漏洞到提交报告。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of XSS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XSS 概述
- en: Testing for XSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XSS 测试
- en: An end-to-end example of XSS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XSS 的端到端示例
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, we'll continue to configure and use tools from our macOS Terminal
    command line. We'll also be using Burp Suite, the Burp extension XSS Validator,
    and information from the SecLists GitHub repository ([https://github.com/SecLists](https://github.com/SecLists))
    to power our malicious XSS snippet submissions. When we use a browser normally
    or in conjunction with Burp, we'll continue to use Chrome (`66.0.3359.139`). Using
    the XSS Validator extension will require us to install Phantomjs, a scriptable
    headless browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续配置和使用来自我们的 macOS 终端命令行的工具。我们还将使用 Burp Suite，Burp 扩展 XSS 验证器，并从 SecLists
    GitHub 仓库 ([https://github.com/SecLists](https://github.com/SecLists)) 获取信息来支持我们恶意的
    XSS 代码片段提交。当我们正常使用浏览器或与 Burp 结合使用时，我们将继续使用 Chrome (`66.0.3359.139`)。使用 XSS 验证器扩展程序将需要我们安装
    Phantomjs，一个可编程的无头浏览器。
- en: 'Please download Phantomjs from the official Phantomjs download page: [http://phantomjs.org/download.html](http://phantomjs.org/download.html).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请从官方 Phantomjs 下载页面下载 Phantomjs：[http://phantomjs.org/download.html](http://phantomjs.org/download.html)。
- en: A Quick Overview of XSS – The Many Varieties of XSS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速了解 XSS – XSS 的多种形式
- en: XSS is a weakness inherent in the single-origin policy. The single-origin policy
    is a security mechanism that's been adopted by every modern browser and only allows
    pages to load from the same domain as the page doing the loading. But there are
    exceptions to allow for pages to load third-party assets – most web pages load
    external JavaScript, CSS, or images – and this is the vector through which XSS
    occurs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 是单一来源策略固有的弱点。单一来源策略是现代浏览器采用的安全机制，只允许页面从执行加载的页面的同一域加载。但是有一些例外允许页面加载第三方资产
    – 大多数网页加载外部 JavaScript、CSS 或图像 – 这就是 XSS 发生的途径。
- en: When a browser is loading the `src` attribute on an HTML tag, it's executing
    the code that attribute is pointing to. It doesn't have to be a file – it can
    just be code included in the attribute string. And it's not just the `src` attribute
    that can execute JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器加载 HTML 标签上的 `src` 属性时，它会执行该属性指向的代码。它不必是一个文件 – 它可以是包含在属性字符串中的代码。而且不仅仅是 `src`
    属性可以执行 JavaScript。
- en: 'The following is an example of an XSS testing snippet. It uses the `onmouseover`
    attribute to execute a JavaScript `alert()` as a classic XSS canary:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 XSS 测试片段示例。它使用 `onmouseover` 属性执行经典的 XSS 钓鱼攻击 `alert()` JavaScript：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`document.location` is included as a way of easily referencing the exact URL
    where the XSS is occurring.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.location` 包含了引用 XSS 发生位置的确切 URL 的方法。'
- en: The snippet we just referenced is an example of stored or persistent XSS because
    the `<a>` tag with malicious JavaScript would be inserted via a form input as
    part of a comment or general text field, and then stored in the web app's database,
    where it could be retrieved and viewed by other users looking at that page. Then,
    when someone hovered over that element, its `onmouseover` event would trigger
    the execution of the malicious XSS code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的代码片段是存储型或持久型 XSS 的一个例子，因为含有恶意 JavaScript 的 `<a>` 标签会通过表单输入作为评论或普通文本字段的一部分被插入，然后存储在
    Web 应用的数据库中，其他用户查看该页面时可以检索并查看。然后，当某人将鼠标悬停在该元素上时，其 `onmouseover` 事件会触发执行恶意的 XSS
    代码。
- en: Reflected XSS is when the injected script is reflected off of the target server
    through a page of search results, an error message, or an other message made up
    in part by the user's input. Reflected XSS can be very damaging because it leverages
    the trust of the server the code is being reflected from.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 反射型 XSS 是指注入的脚本通过搜索结果页面、错误信息或由用户输入部分构成的其他消息从目标服务器反射回去。反射型 XSS 可以非常具有破坏性，因为它利用了反射代码所在服务器的信任。
- en: There's also DOM-based XSS, a more specialized type of the attack that relies
    on a user being supplied a hacker-generated link containing an XSS payload, which
    will prompt the user's browser to open the link, echoing back the payload as it
    constructs the DOM, and executes the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有基于 DOM 的 XSS，这是一种更为专业的攻击类型，依赖于用户接收到一个包含 XSS 负载的黑客生成链接，促使用户的浏览器打开该链接，在构建 DOM
    的过程中回显负载，并执行代码。
- en: 'Although stored/persistent XSS, reflected XSS, and DOM-based XSS are all possible
    groupings of XSS varieties, another way of thinking about the different types
    of XSS is dividing the bug into client XSS and server XSS. In this framework,
    there are both stored and reflected types for both the client and server variations:
    Server XSS occurs when unverified user data is supplied by the server, either
    through a request (reflected XSS) or stored locations (stored XSS), while client
    XSS is just the execution of unverified code in the client, from the same locations.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存储型/持久型 XSS、反射型 XSS 和基于 DOM 的 XSS 都可以归为 XSS 类型的不同分类，但另一种思考 XSS 类型的方法是将其分为客户端
    XSS 和服务器端 XSS。在这种框架下，客户端和服务器端的变种都有存储型和反射型两种类型：服务器端 XSS 发生在服务器提供未经验证的用户数据时，无论是通过请求（反射型
    XSS）还是存储位置（存储型 XSS），而客户端 XSS 则是指在客户端执行未经验证的代码，来自相同的位置。
- en: We'll cover a mix of techniques for detecting XSS, some of which will apply
    only to specific types, others to a wider variety of attacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一些检测 XSS 的技术，其中有些仅适用于特定类型的 XSS，而有些则适用于更广泛的攻击类型。
- en: Testing for XSS – Where to Find It, How to Verify It
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 XSS – 哪里可以找到它，如何验证它
- en: There are several great methods for discovering XSS. We'll start with a tool
    we've already begun using in preparing for an engagement, diving into some new
    parts of Burp and an XSS-related Burp extension.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种很好的方法可以发现 XSS。我们将从一个我们在准备进行渗透测试时已经开始使用的工具开始，深入了解 Burp 中的一些新部分以及与 XSS 相关的
    Burp 扩展。
- en: Burp Suite and XSS Validator
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Burp Suite 和 XSS Validator
- en: One problem with automated and semi-automated solutions for XSS is distinguishing
    signal from noise. To do that, a useful Burp plugin, XSS Validator, runs a PhantomJS-powered
    web server to receive the results of Burp queries and looks for a string injected
    into the `alert()` call embedded within the applied XSS snippets. It provides
    a clean way of culling the results of your XSS submissions to absolute confirmed
    vulnerabilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化和半自动化的 XSS 解决方案存在一个问题，那就是区分信号和噪声。为了解决这个问题，XSS Validator 这一有用的 Burp 插件运行一个由
    PhantomJS 驱动的 Web 服务器，用于接收 Burp 查询的结果，并寻找注入到 `alert()` 调用中的字符串，该调用嵌入在应用的 XSS 代码片段中。它提供了一种清晰的方法来筛选出
    XSS 提交的结果，确保只保留绝对确认的漏洞。
- en: The easiest way to download the XSS Validator Burp extension is through the
    Bapp store. Just navigate to the store from the Extension tab within Burp Suite
    and select the extension from the marketplace (needless to say, it's free). You
    can also install the extension manually by following the instructions in the XSS
    Validator GitHub documentation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 XSS Validator Burp 扩展的最简单方法是通过 Bapp 商店。从 Burp Suite 的扩展选项卡中进入商店，选择市场中的扩展（不用说，这是免费的）。你也可以通过参考
    XSS Validator GitHub 文档中的说明手动安装该扩展。
- en: 'In addition to installing the extension, during your actual testing, you''ll
    need to run the server parsing incoming Burp requests. If you clone the XSS Validator
    git repo, you can navigate to the `xss-validator` directory and start the `xss.js`
    script. You can then bootstrap the server and set it to run as a detached background
    process in one easy line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装扩展外，在实际测试过程中，你还需要运行服务器来解析传入的 Burp 请求。如果你克隆了 XSS Validator 的 git 仓库，你可以进入
    `xss-validator` 目录并启动 `xss.js` 脚本。然后你可以启动服务器，并将其设置为作为一个独立的后台进程运行，只需一行命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the XSS Validator server and Burp Suite running (`boostrap_burp`), navigate
    to the specific form input you''d like to test for XSS. As a way of demonstrating
    the tool on a proven testing ground, we''re going to test a form input on the
    Web Scanner Test Site (`webscantest.com`) that''s been designed to be susceptible
    to XSS:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XSS Validator 服务器和 Burp Suite 启动（`boostrap_burp`）的情况下，前往你想要测试 XSS 的特定表单输入。作为在经过验证的测试环境上演示工具，我们将测试一个
    Web 扫描测试站点（`webscantest.com`）上的表单输入，该站点设计为容易受到 XSS 攻击：
- en: '![](assets/883eb253-141e-4399-a9ca-f5ba32540414.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/883eb253-141e-4399-a9ca-f5ba32540414.png)'
- en: 'After arriving on the page – with our Burp Proxy Intercept feature turned off
    so that we don''t have to manually forward all the traffic on the way there –
    we enter something recognizable into the form fields we''re testing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到达页面后——由于我们已关闭 Burp Proxy 的 Intercept 功能，因此不需要手动转发所有流量——我们在要测试的表单字段中输入一些可识别的内容：
- en: '![](assets/47a734fd-eafa-46d2-8ef0-8c899d4cf34e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47a734fd-eafa-46d2-8ef0-8c899d4cf34e.png)'
- en: 'Now we want to navigate back to our Burp Suite GUI and turn Intercept back
    on before we submit:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要返回 Burp Suite GUI，并在提交之前重新打开 Intercept：
- en: '![](assets/1e61c0a5-2bb6-4fed-9622-e6ddbce1d8e2.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1e61c0a5-2bb6-4fed-9622-e6ddbce1d8e2.png)'
- en: 'Now when we submit, you should see the browser favicon indicate a submission
    without anything changing on the form. If you go back to Burp, you''ll see you''ve
    intercepted the form''s `POST` request (note that if you have other tabs open,
    you might see that the Burp proxy has intercepted requests from those pages, and
    has to forward them):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们提交时，你应该看到浏览器的 favicon 表示已提交，但表单上没有任何变化。如果你返回 Burp，你会看到你已经拦截了表单的 `POST`
    请求（注意，如果你打开了其他标签页，你可能会看到 Burp 代理已经拦截了那些页面的请求，并且需要将它们转发）：
- en: '![](assets/17130b62-b3cd-4c61-b8d4-d81cda0b497c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/17130b62-b3cd-4c61-b8d4-d81cda0b497c.png)'
- en: 'We want to send this request over to the Burp intruder feature, where we can
    do more to manipulate the `POST` data. To do that, right-click on the request
    and click Send to Intruder:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将此请求发送到 Burp Intruder 功能，在那里我们可以进一步操作 `POST` 数据。为此，右键点击请求并选择 Send to Intruder：
- en: '![](assets/5b6c5325-133d-40d2-a1c9-2ff7d96f79e4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b6c5325-133d-40d2-a1c9-2ff7d96f79e4.png)'
- en: 'Once you''re at the Intruder window, go to the Positions tab where you can
    see the `POST` request parameters and cookie IDs already selected as Payload Positions.
    Let''s go ahead and leave these defaults and move over to the Payloads tab to
    choose what we''ll be filling these input with. In order to integrate with the
    XSS Validator extension, we need to make changes to these first three payload-related
    settings, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入 Intruder 窗口，前往 Positions 标签页，你可以看到已经选择为 Payload Positions 的 `POST` 请求参数和
    cookie ID。我们可以保留这些默认设置，然后转到 Payloads 标签页，选择我们将要填充这些输入的内容。为了与 XSS Validator 扩展集成，我们需要对这前三个与
    Payload 相关的设置进行如下更改：
- en: Payload Sets
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Payload 集合
- en: For the second drop-down, Payload Type, select the Extension-generated option.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个下拉框，Payload 类型，选择扩展生成的选项。
- en: Payload Options
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Payload 选项
- en: When you click Select generator..., you'll open a modal where you can select
    XSS Validator Payloads as your selected generator.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 Select generator... 时，你将打开一个模态框，在其中你可以选择 XSS Validator Payloads 作为你选择的生成器。
- en: Payload Processing
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Payload 处理
- en: 'Here you''ll want to add a rule, choosing Invoke Burp extension as the rule
    type and then XSS Validator as the processor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你需要添加一个规则，选择 Invoke Burp extension 作为规则类型，然后选择 XSS Validator 作为处理器：
- en: '![](assets/14f52966-e892-4a81-8d76-abb9069d9860.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14f52966-e892-4a81-8d76-abb9069d9860.png)'
- en: 'After you''ve made all these selections, your app''s GUI should look like the
    following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些选择后，你的应用 GUI 应该如下所示：
- en: '![](assets/1623ec0d-c8fa-4f6b-9289-20a792bc4317.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1623ec0d-c8fa-4f6b-9289-20a792bc4317.png)'
- en: 'We need to make one more setting change before we can start our attack. If
    you head over to the xssValidator tab, you''ll see a random string generated in
    the Grep Phrase field, and you might also spot the bullet point explaining that
    Successful attacks will be denoted by the presence of the *Grep Phrase*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始攻击之前，还需要做一个设置更改。如果你进入 xssValidator 标签页，你会看到 Grep Phrase 字段中生成了一个随机字符串，并且可能还会看到解释说明，成功的攻击将通过存在
    *Grep Phrase* 来表示：
- en: '![](assets/269239c1-2bbf-482d-8b1d-7091eab35aa9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/269239c1-2bbf-482d-8b1d-7091eab35aa9.png)'
- en: 'We want to add that grep phrase into the Grep - Match section in the Options
    tab so that, when we''re viewing our attack results, we can see a checkbox indicating
    whether our phrase turned up in an attack response:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将这个 grep 短语添加到选项标签页的 Grep - Match 部分，以便在查看我们的攻击结果时，我们可以看到一个复选框，指示我们的短语是否出现在攻击响应中：
- en: '![](assets/c84b0785-1734-4bfd-ab95-ba08fd45a838.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c84b0785-1734-4bfd-ab95-ba08fd45a838.png)'
- en: Once that phrase has been added, we're ready to start our attack. Click the
    start attack button in the top-right of the Options (and every other) view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了该短语，我们就准备开始攻击了。点击选项视图右上角的“开始攻击”按钮（以及其他任何视图）。
- en: 'After clicking the button, you should see an attack window pop up and start
    to self-populate with the results of the XSS snippet submissions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，你应该会看到一个攻击窗口弹出，并开始自动填充 XSS 片段提交的结果：
- en: '![](assets/64e3a8d5-d639-40f1-b54e-b4eb4d7f2fbb.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/64e3a8d5-d639-40f1-b54e-b4eb4d7f2fbb.png)'
- en: And voila! We can see the presence of our grep phrase, meaning that our submissions
    have been a success, for several of the tag/attribute combinations generated by
    the XSS Validator submissions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们可以看到我们所用的 grep 短语，这意味着我们的提交已经成功，对于通过 XSS Validator 提交的多种标签/属性组合来说都有效。
- en: XSS – An End-To-End Example
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XSS – 一例完整的攻击示范
- en: Throughout this book, we look at bugs on deliberately-vulnerable teaching sites
    as well as live applications belonging to real companies – that way, we can see
    vulnerabilities as they exist in the wild while also having sections where you
    can follow along at home.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将研究故意设定漏洞的教学网站上的错误，以及真实公司拥有的在线应用程序——通过这种方式，我们可以看到在真实环境中存在的漏洞，同时还会有一些章节，让你可以在家进行实践。
- en: XSS in Google Gruyere
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Gruyere 中的 XSS
- en: 'This next part takes place on **Google Gruyere**, an XSS laboratory operated
    by Google that explains different aspects of XSS alongside appropriately vulnerable
    form input:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分发生在**Google Gruyere**，这是一个由 Google 运营的 XSS 实验室，解释了 XSS 的不同方面，并提供了适当易受攻击的表单输入：
- en: '![](assets/ae7435df-8fe7-4cae-b7bb-ff75dfdf5f01.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae7435df-8fe7-4cae-b7bb-ff75dfdf5f01.png)'
- en: Google Gruyere is based loosely on a social network, such as Instagram or Twitter,
    where different users can share public snippets just like the former site's 280-word
    text blocks. Beyond the obvious, advertising of the service as being susceptible
    to XSS, there are small pieces of text, similar to what you'd find in real applications,
    hinting at areas of vulnerability. Some or limited support of HTML in a specific
    form is always a chance that the filters put in place by the site's developers
    to allow formatting markup, such as `<p></p>`, `<b></b>`, and `<br/>`, while keeping
    out scary stuff, such as `<script></script>`, will fail to sanitize your specially-crafted
    snippet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Google Gruyere 基于一个类似社交网络的模型，类似于 Instagram 或 Twitter，用户可以分享公开的片段，就像前者网站的 280
    字文本块。除了显而易见的将服务宣传为容易遭受 XSS 攻击外，还有一些小段文字，类似于你在真实应用中会发现的内容，暗示了潜在的漏洞。一些 HTML 支持形式在特定情况下总会存在机会，即使站点开发人员为允许格式化标记（如
    `<p></p>`、`<b></b>`、`<br/>`）而设置了过滤器，试图排除诸如 `<script></script>` 之类的危险内容，但这些过滤器仍有可能未能清除你精心构造的片段。
- en: 'Going through the submission form to create a New Snippet (after setting up
    an account), we can try to probe at the outer edges of the sanitizing process.
    Let''s try using a script that even the most naive filter should capture:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提交表单来创建一个新片段（设置好账户后），我们可以尝试探测清理过程的外部边缘。让我们尝试使用一个即使是最简单的过滤器也应该捕捉到的脚本：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A plain script tag, without any obfuscation, escape characters, or exotic attributes,
    is a pretty slow pitch, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的脚本标签，没有任何混淆、转义字符或特殊属性，是一个相当简单的攻击方式，如下所示：
- en: '![](assets/db1457db-d2ee-453a-a0af-eb5fdba48344.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db1457db-d2ee-453a-a0af-eb5fdba48344.png)'
- en: 'When we look at the result of the submission, no `alert()` window is displayed
    and there''s nothing to else to trigger the execution of the code, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看提交结果时，没有显示 `alert()` 窗口，也没有其他任何东西触发代码的执行，如下所示：
- en: '![](assets/a205c796-133c-4571-9f3b-4bd5857d97b1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a205c796-133c-4571-9f3b-4bd5857d97b1.png)'
- en: 'The filter undoubtedly has some holes in it, but it does function at the most
    basic level by stripping out the `<script>` tags. Going through the XSS snippet
    lists we have in our `Seclists` repository, we find another one to try, ensuring
    the HTML tag is likely to be included in a form input meant to allow formatting
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器无疑有一些漏洞，但它在最基本的层面上还是能起作用，能够剥离 `<script>` 标签。我们在 `Seclists` 仓库中的 XSS 代码片段列表中找到另一个来试，确保该
    HTML 标签很可能会被包含在一个旨在允许格式化代码的表单输入中：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`document.cookie` is a glimpse of our proposed attack scenario and a simple
    piece of data to surface via `alert()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.cookie` 是我们提出的攻击场景的一个示例，也是一个简单的通过 `alert()` 展示的数据：'
- en: '![](assets/c981488e-7fc0-43fb-95ac-9079d0aff2a3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c981488e-7fc0-43fb-95ac-9079d0aff2a3.png)'
- en: 'Going through the submission process again, we receive a different response.
    Success! Our strategy, using a boring formatting tag to Trojan-horse a malicious
    payload contained in its attribute, worked, and we now have a confirmed vulnerability
    to report:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进行提交过程时，我们收到了不同的回应。成功了！我们的策略，利用一个无聊的格式化标签来伪装恶意负载（包含在它的属性中），成功了，现在我们有了一个确认的漏洞来报告：
- en: '![](assets/c6441d53-db6e-4469-981e-8c9949664ce5.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6441d53-db6e-4469-981e-8c9949664ce5.png)'
- en: Gathering Report Information
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集报告信息
- en: There's a lot of information that we'll need about the vulnerability we've discovered,
    info that will be necessary or useful across submission platforms and styles.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们发现的漏洞，需要收集大量信息，这些信息在各个提交平台和格式中都可能是必要的或有用的。
- en: Category
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别
- en: Very simply, this is the category the bug falls into. In our case, it is Persistent
    XSS.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，这是漏洞所属的类别。在我们这个例子中，它是持久性 XSS。
- en: Timestamps
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳
- en: If you're using an automated or just code-based solution to touch the target,
    taking timestamps is a must – the more accurate the better. If, like us just now,
    you manually entered a malicious snippet, simply the time after the discovery
    will suffice. Giving the time of discovery in UTC will save the developer who
    is fielding the report from doing a mental timezone conversion before analyzing
    logs, usages charts, and other monitoring tools.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是自动化或仅基于代码的解决方案来接触目标，记录时间戳是必须的——时间越准确越好。如果像我们刚才那样手动输入恶意代码片段，那么发现之后的时间就足够了。提供
    UTC 时间戳可以帮助接收报告的开发者在分析日志、使用图表和其他监控工具时避免进行时区转换。
- en: URL
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL
- en: This is the URL of the vulnerability. When executing test, code such as `alert()`,
    sometimes it can be useful to alert a location (for example, `alert(document.location)`).
    This way, in a single screenshot, you can convey both preliminary proof of the
    bug and its location in the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是漏洞的 URL。在执行测试时，像 `alert()` 这样的代码有时可以用来显示位置（例如，`alert(document.location)`）。这样，在一张截图中，你可以同时展示漏洞的初步证据和它在应用中的位置。
- en: Payload
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载
- en: 'The XSS snippet we used to successfully execute JavaScript will go here. In
    the case of SQLi, a successful password attack, or any number of other payload-based
    attacks, that data would be required as well. If you trip on multiple payload
    types in one discovery, you should mention however many illustrate the general
    sanitation rules being misapplied:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来成功执行 JavaScript 的 XSS 代码片段将在这里展示。如果是 SQL 注入、成功的密码攻击，或者其他基于负载的攻击，这些数据也是必须的。如果在一次发现中碰到了多种负载类型，应该提到所有能够说明通用清理规则被误应用的情况：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Methodology
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法论
- en: If you discovered the bug using a particular tool, tell them (and don't use
    a scanner if they explicitly said not to!). It can help the team fielding your
    report validate your finding if they use something similar and can incorporate
    that into reproducing the issue. In this case, we would just say that we submitted
    the snippet and verified the bug manually.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是使用某个特定工具发现了这个漏洞，要告诉他们（如果他们明确表示不要使用扫描器，就不要使用！）。如果他们使用类似的工具，这可以帮助处理你报告的团队验证你的发现，并将其纳入重现问题的过程。在这种情况下，我们只需要说我们提交了代码片段，并手动验证了漏洞。
- en: 'It''s also useful to list some basic info about the environment in which the
    vulnerability was discovered: your operating system, browser type and version
    (plus any add-ons or extensions if they''re relevant), and any miscellaneous information
    you think is relevant (for example, was it discovered in an incognito window?
    If using `curl`, Postman, or another tool, did you use any particular headers?).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要列出一些关于发现漏洞的环境的基本信息：你的操作系统、浏览器类型和版本（如果相关的话，还包括任何插件或扩展），以及你认为相关的任何其他信息（例如，是在隐身窗口中发现的吗？如果使用
    `curl`、Postman 或其他工具时，是否使用了特定的头信息？）。
- en: Instructions to Reproduce
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现步骤
- en: Making sure your instructions are clear enough for the person that evaluated
    your report is, along with the actual payload, the most important information
    you can provide. A screenshot of the vulnerability (for example, the alert window)
    is great evidence, but could easily fall short of winning you a payout if the
    issue can't be reproduced.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的指令足够清晰，以便评估人员能理解，是你提供的最重要信息之一，和实际的有效载荷一起。漏洞的截图（例如，警报窗口）是很好的证据，但如果漏洞无法复现，可能无法获得奖励。
- en: Attack Scenario
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击场景
- en: Coming up with a good attack scenario isn't as necessary as the previous data
    points, but can be a great method for increasing the bug's severity and boosting
    your payout.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个好的攻击场景不像之前的数据点那样必要，但它可以是一个提高漏洞严重性和增加奖励的好方法。
- en: For this attack, we'll highlight the extent of the damage beyond just the Gruyere
    app. If an attacker could execute arbitrary JavaScript from a stored XSS bug,
    they could exfiltrate sensitive cookies, such as those for authenticating financial
    apps (banks, brokers, and crypto traders) or social networks (Twitter, Facebook,
    Instagram), which could in turn be used for identity theft, credit card fraud,
    and other cyber crimes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个攻击，我们将展示损害的范围，不仅仅是 Gruyere 应用。如果攻击者能够通过存储型 XSS 漏洞执行任意的 JavaScript，他们可以窃取敏感的
    Cookie 信息，例如用于身份验证的金融应用程序（银行、经纪商、加密货币交易员）或社交网络（Twitter、Facebook、Instagram）的 Cookie，这些信息可能被用于身份盗窃、信用卡欺诈和其他网络犯罪。
- en: 'Here''s how our report will look:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们报告的样子：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered the different types of XSS attacks, understanding the anatomy
    of an XSS snippet, and extending Burp Suite with XSS Validator to confirm successful
    injection attempts. We also look at using Google Gruyere as a teaching aide and
    testing ground, and reported an XSS vulnerability from start to finish, including
    how to document your report and a sample submission.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了不同类型的 XSS 攻击，理解 XSS 片段的结构，并通过扩展 Burp Suite 与 XSS Validator 来确认注入尝试是否成功。我们还讨论了如何使用
    Google Gruyere 作为教学辅助工具和测试平台，并从头到尾报告了一个 XSS 漏洞，包括如何撰写报告和示例提交。
- en: Questions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the different principle types of XSS?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XSS 的不同基本类型有哪些？
- en: Which XSS varieties are most dangerous/impactful?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些 XSS 变种最具危险性/影响力？
- en: What's the value of XSS Validator as an extension?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XSS Validator 作为扩展的价值是什么？
- en: What does the `phantomjs` server do?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`phantomjs` 服务器的作用是什么？'
- en: How do you select payloads for fuzzing in Burp Intruder?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Burp Intruder 中选择用于模糊测试的有效载荷？
- en: What are the most important things to include about XSS in your submission report?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XSS 提交报告中最重要的内容是什么？
- en: What's a worst-case attack scenario for a hacker who's found an XSS bug to exploit?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于发现 XSS 漏洞并准备利用它的黑客来说，最糟糕的攻击场景是什么？
- en: Why is including an attack scenario in your report submission important?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在报告提交中包含攻击场景很重要？
- en: Further Reading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到更多关于本章讨论的主题：
- en: '**XSS Filter Evasion Cheat Sheet**: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSS 过滤规避备忘单**: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
- en: '**XSS Challenges**: [https://xss-quiz.int21h.jp/](https://xss-quiz.int21h.jp/)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSS 挑战**: [https://xss-quiz.int21h.jp/](https://xss-quiz.int21h.jp/)'
- en: '**XSS Game**: [https://xss-game.appspot.com](https://xss-game.appspot.com)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSS 游戏**: [https://xss-game.appspot.com](https://xss-game.appspot.com)'
