- en: Authentication and Session Management Flaws
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和会话管理漏洞
- en: 'The main purpose of web applications is to allow users to access and process
    information that is stored in a remote place. Sometimes this information is public,
    while at other times it may be user-specific or even confidential. Such applications
    require the users to prove their identity before being allowed access to such
    information. This identity verification process is called **authentication**,
    and it requires the user to provide a proof of identity that may be one or more
    of the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的主要目的是允许用户访问和处理存储在远程位置的信息。有时，这些信息是公开的，而其他时候可能是特定于用户甚至是机密的。这些应用程序要求用户在被允许访问此类信息之前证明其身份。这个身份验证过程称为**身份验证**，它要求用户提供一个身份证明，可以是以下一个或多个：
- en: 'Something the user *knows*: Such as a username and secret password'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户所知道的东西：例如用户名和秘密密码
- en: 'Something the user *has*: Like a smart card or a special code sent to the user''s
    phone'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户拥有的东西：如智能卡或发送到用户手机的特殊代码
- en: 'Something the user *is*: Voice, facial, fingerprint, or any other biometric
    mechanism'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的特征：声音、面部、指纹或任何其他生物识别机制
- en: The first alternative is the most common in web applications. There are some
    cases, such as banking or internal corporate applications, which may use one or
    more of the remaining methods.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是Web应用程序中最常见的。还有一些情况，例如银行或内部企业应用程序，可能使用剩余方法中的一个或多个。
- en: HTTP is a stateless and connectionless protocol. This means that every request
    that a client sends to the server is treated by the server as unrelated to any
    previous or future requests sent by that or any other client. Thus, after a user
    logs in to a web application, the next request will be treated by the server as
    if it was the first one. Hence, the client would need to send their credentials
    on every request. This adds unnecessary exposure for that sensitive information
    and needless effort to the communications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种无状态和无连接的协议。这意味着服务器将客户端发送的每个请求视为与该客户端或任何其他客户端发送的先前或将来的请求无关。因此，用户登录到Web应用程序后，下一个请求将被服务器视为第一个请求。因此，客户端需要在每个请求中发送他们的凭据。这为敏感信息增加了不必要的暴露和通信的不必要努力。
- en: A number of techniques have been developed to allow web applications to track
    the activities of users and maintain the state of the application according to
    the changes they make to their own environment, and to separate them from the
    ones of other users without asking them to log in for every action they take.
    This is called **session management**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发了许多技术，允许Web应用程序跟踪用户的活动并根据他们对自己环境的更改来维护应用程序的状态，并将其与其他用户的活动分开，而无需要求他们在每个操作中都登录。这被称为**会话管理**。
- en: In this chapter, we will review how authentication and session management are
    usually performed in modern web applications, and you will learn how to identify
    and exploit some of the most common security flaws in such mechanisms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾现代Web应用程序通常如何执行身份验证和会话管理，并学习如何识别和利用这些机制中最常见的一些安全漏洞。
- en: Authentication schemes in web applications
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序中的身份验证方案
- en: Before getting into the specific penetration testing concepts, let's review
    how authentication is done in modern web applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入具体的渗透测试概念之前，让我们回顾一下现代Web应用程序中的身份验证是如何进行的。
- en: Platform authentication
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台认证
- en: When using **platform authentication**, users send their credentials in every
    request's header, using the `Authorization` variable. Even when they have to submit
    their credentials only once, the browser or the system stores them and uses them
    when required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**平台认证**时，用户在每个请求的头部中发送他们的凭据，使用`Authorization`变量。即使他们只需要提交一次凭据，浏览器或系统也会存储它们并在需要时使用。
- en: There are several different types of platform authentication. The most common
    ones are discussed in the following subsections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的平台认证。最常见的几种将在以下小节中讨论。
- en: Basic
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本认证
- en: With this type of platform authentication, the username and password are sent
    attached to the `Authorization` header and encoded using base64\. This means that
    anybody who sees the request's header is able to decode the credentials to cleartext,
    as base64 encoding is not a cryptographic format.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型的平台认证，用户名和密码会附加在`Authorization`头部中，并使用base64进行编码。这意味着任何看到请求头的人都能够将凭据解码为明文，因为base64编码不是一种加密格式。
- en: 'The following screenshots show how login information is sent in base64 and
    how it can be decoded:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何以base64形式发送登录信息以及如何解码它：
- en: '![](img/00072.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: 'You can use Burp Suite''s Decoder to convert from base64 to ASCII text:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Burp Suite的解码器将base64转换为ASCII文本：
- en: '![](img/00073.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: Digest
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '**Digest authentication** is significantly more secure than basic authentication.
    When a client wants to access a protected resource, the server sends a random
    string, called a **nonce**, as a challenge. The client then uses this nonce together
    with the username and password to calculate an MD5 hash and sends it back to the
    server for verification.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要认证**比基本认证安全得多。当客户端想要访问受保护的资源时，服务器会发送一个随机字符串，称为**nonce**，作为挑战。然后，客户端使用此nonce与用户名和密码一起计算MD5哈希并将其发送回服务器进行验证。'
- en: NTLM
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NTLM
- en: '**NTLM** is a variant of digest authentication, where Windows credentials and
    an NTLM hashing algorithm are used to transform the challenge of an application''s
    username and password. This scheme requires multiple request-response exchanges,
    and the server and any intervening proxies must support persistent connections.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLM**是摘要认证的一种变体，其中使用Windows凭据和NTLM哈希算法来转换应用程序的用户名和密码的挑战。此方案需要多个请求-响应交换，并且服务器和任何中间代理必须支持持久连接。'
- en: Kerberos
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kerberos
- en: 'This authentication scheme makes use of the **Kerberos** protocol to authenticate
    to a server. As with NTLM, it doesn''t ask for a username and password, but it
    uses Windows credentials to log in. This protocol uses an **Authentication Server**
    (**AS**) apart from the web server, and it involves a series of negotiation steps
    in order to authenticate. These steps are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此认证方案使用**Kerberos**协议对服务器进行身份验证。与NTLM一样，它不要求用户名和密码，而是使用Windows凭据登录。该协议使用与Web服务器分开的**认证服务器**（**AS**），并涉及一系列的协商步骤以进行身份验证。这些步骤如下：
- en: The client sends the username (ID) to the AS.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将用户名（ID）发送给AS。
- en: The AS looks for the ID in the database and uses the hashed password to encrypt
    a session key.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AS在数据库中查找ID，并使用哈希密码加密会话密钥。
- en: The AS sends the encrypted session key and a ticket (TGT) containing the user
    ID, session key, session expiration, and other data, encrypted with the server's
    secret key to the client. If the password is incorrect, the client will be unable
    to decrypt its session key.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AS将加密的会话密钥和包含用户ID、会话密钥、会话过期和其他数据的票证（TGT），使用服务器的秘密密钥加密后发送给客户端。如果密码不正确，客户端将无法解密其会话密钥。
- en: The client decrypts the session key.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端解密会话密钥。
- en: When the client wants to access a protected resource on the web server, it will
    need to send the TGT and resource ID in one message and client ID and timestamp
    encrypted with the session key in another message.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端想要访问Web服务器上的受保护资源时，它需要在一条消息中发送TGT和资源ID，并在另一条消息中使用会话密钥加密客户端ID和时间戳。
- en: If the server is able to decrypt the received information, it responds with
    a client-to-server ticket, encrypted using AS's secret key and a client/server
    session key, further encrypted using the client's session key.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器能够解密接收到的信息，它将使用AS的秘密密钥和客户端/服务器会话密钥进行加密，进一步使用客户端的会话密钥进行加密，并以客户端到服务器的票证形式进行响应。
- en: With this information from the AS, the client can now request the resource from
    the web server.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了AS提供的这些信息，客户端现在可以向Web服务器请求资源。
- en: 'In the following diagram, you can see the process graphically:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以以图形方式看到该过程：
- en: '![](img/00074.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: HTTP Negotiate
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP Negotiate
- en: Also called *Windows Authentication*, the **HTTP Negotiate** scheme uses Windows
    credentials and selects between Kerberos and NTLM authentication, depending on
    whether Kerberos is available or not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*Windows身份验证*，**HTTP Negotiate**方案使用Windows凭据，并根据Kerberos是否可用来选择Kerberos或NTLM身份验证。
- en: Drawbacks of platform authentication
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台认证的缺点
- en: 'While the Kerberos and NTLM schemes are considered secure, and even digest
    or basic authentication can be used over TLS with a low risk of a malicious actor
    intercepting the communication and stealing the credentials, platform authentication
    still has some inherent disadvantages in terms of security. They are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kerberos和NTLM方案被认为是安全的，即使在TLS上使用摘要或基本认证也可以降低恶意参与者拦截通信并窃取凭据的风险，但是在安全方面，平台认证仍然具有一些固有的缺点。它们如下：
- en: Credentials are sent more often, hence their exposure and the risk of being
    captured in a **Man-in-the-Middle** (**MITM**) attack are higher, especially for
    the basic, digest, and NTLM schemes.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭据更频繁地发送，因此它们的暴露和在**中间人攻击**（**MITM**）中被捕获的风险更高，特别是对于基本、摘要和NTLM方案。
- en: Platform authentication does not have the log out or session expiration options.
    As **Single Sign On** (**SSO**) is in place when using Windows Authentication,
    the session starts as soon as the user opens the application's main page without
    asking for username and password, and it gets renewed automatically if it expires.
    An attacker who gains access to the user's machine or Windows account will gain
    instant access to the application.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台认证没有注销或会话过期选项。当使用Windows身份验证时，由于**单点登录**（**SSO**）已经启用，用户打开应用程序的主页面时会立即开始会话，而不需要用户名和密码，并且如果会话过期，它会自动续订。如果攻击者能够访问用户的计算机或Windows帐户，他们将立即获得对应用程序的访问权限。
- en: Platform authentication is not suitable for public applications, as they require
    a higher technological and administrative effort to set up and manage than the
    most popular form-based authentication.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台认证不适用于公共应用程序，因为与最流行的基于表单的认证相比，它们需要更高的技术和管理工作量来设置和管理。
- en: Form-based authentication
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于表单的认证
- en: 'This is the kind of authentication with which we are more familiar: an HTML
    form that contains username and password fields and a submit button:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更熟悉的一种认证方式：一个包含用户名和密码字段以及提交按钮的HTML表单：
- en: '![](img/00075.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: 'This authentication may vary from case to case, as its implementation is completely
    application dependent. Nevertheless, the most common approach follows these steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此认证可能因情况而异，因为其实现完全依赖于应用程序。尽管如此，最常见的方法遵循以下步骤：
- en: The user fills in the authentication form and clicks on the Submit button. The
    client (web browser) then sends the request containing username and password to
    the server in cleartext, unless the client-side encryption is done by the application.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户填写认证表单并点击提交按钮。然后，客户端（Web浏览器）将包含用户名和密码的请求以明文形式发送到服务器，除非应用程序进行了客户端加密。
- en: The server receives the information and checks for the existence of the user
    in its database and compares the stored and submitted passwords (or password hashes).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收信息并检查用户在其数据库中的存在，并比较存储的密码（或密码哈希）与提交的密码。
- en: If the user exists and the password is correct, the server responds with an
    affirmative message that may include a redirection to the user's home page and
    a session identifier (usually as a cookie) so that the user doesn't need to send
    their credentials again.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户存在且密码正确，服务器将以肯定的消息作出回应，该消息可能包括重定向到用户的主页和会话标识符（通常作为cookie），以便用户无需再次发送凭据。
- en: The client receives the response, stores the session identifier, and redirects
    to the home page.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端接收响应，存储会话标识符，并重定向到主页。
- en: This is by far the most interesting authentication method from a penetration
    testing perspective, as there is no standard way to do it (even when there are
    best practices), and it is usually a source for a good number of vulnerabilities
    and security risks due to improper implementations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从渗透测试的角度来看，这无疑是最有趣的身份验证方法，因为没有标准的方法来执行它（即使有最佳实践），通常会导致许多漏洞和安全风险，因为实现不当。
- en: Two-factor Authentication
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双因素身份验证
- en: As stated before, to prove your identity to an application, you must provide
    something you know, something you have, or something you are. Each of these identifiers
    are called a **factor**. **Multi-factor Authentication** (**MFA**) comes from
    the need to provide an extra layer of security to certain applications and prevent
    unauthorized access in case, for example, a password is guessed or stolen by an
    attacker.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了向应用程序证明您的身份，您必须提供您所知道的东西、您所拥有的东西或您所是的东西。这些标识符中的每一个都被称为**因素**。**多因素身份验证**（**MFA**）源于为某些应用程序提供额外的安全层，以防止未经授权的访问，例如密码被攻击者猜测或窃取的情况。
- en: '**Two-factor** **Authentication** (**2FA**) in most web applications means
    that the user must provide the username and password (first factor) and a special
    code or **One-Time Password** (**OTP**), which is temporary and randomly generated
    by a device that the user has or is sent to them through SMS or email by the server.
    The user then submits the OTP back to the application. More sophisticated applications
    may implement the use of a smartcard or some form of biometrics, such as a fingerprint,
    in addition to the password. As this requires the user to have extra hardware
    or a specialized device, these types of applications are much less common.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Web应用程序中，**双因素身份验证**（**2FA**）意味着用户必须提供用户名和密码（第一个因素）以及一个特殊的代码或**一次性密码**（**OTP**），该代码是由用户拥有的设备临时随机生成的，或者通过服务器通过短信或电子邮件发送给他们。然后用户将OTP提交给应用程序。更复杂的应用程序可能会在密码之外实现使用智能卡或某种生物识别技术，例如指纹。由于这需要用户拥有额外的硬件或专用设备，这些类型的应用程序要少得多。
- en: Most banking applications implement a form of MFA, and recently, public email
    services and social media have started to promote and enforce the use of 2FA among
    their users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数银行应用程序实施了一种MFA形式，最近，公共电子邮件服务和社交媒体开始推广并强制用户使用2FA。
- en: OAuth
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth
- en: '**OAuth** is an open standard for access delegation. When Facebook or Google
    users allow third-party applications to access their accounts, they don''t share
    their credentials with such applications. Instead, service providers (Google,
    Twitter, or Facebook) share a special access token that allows such applications
    to retrieve specific information about the user''s account or access certain functionality
    according to the permission given by the user.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**是一种用于访问委派的开放标准。当Facebook或Google用户允许第三方应用程序访问他们的帐户时，他们不会与这些应用程序共享他们的凭据。相反，服务提供商（Google、Twitter或Facebook）共享一个特殊的访问令牌，允许这些应用程序检索有关用户帐户的特定信息或根据用户授权的权限访问某些功能。'
- en: Session management mechanisms
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理机制
- en: '**Session management** involves the creation or definition of session identifiers
    on login, the setting of inactivity timeouts, session expiration, and session
    invalidation on logout; also, it may extend to authorization checks depending
    on the user''s privileges, as the session ID must be linked to the user.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话管理**涉及在登录时创建或定义会话标识符，设置不活动超时时间，会话过期以及在注销时使会话无效；此外，根据用户的权限，它可能扩展到授权检查，因为会话ID必须与用户关联起来。'
- en: Sessions based on platform authentication
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于平台身份验证的会话
- en: When platform authentication is used, the most common approach used is to work
    with the header that is already included, containing the credentials, or challenge
    the response as the identifier for a user's session, and to manage session expiration
    and logout through the application's logic; although, as stated previously, it's
    common to find that there is no session timeout, expiration, or logout when platform
    authentication is in place.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用平台身份验证时，最常用的方法是使用已经包含的标头来处理凭据，或者将响应作为用户会话的标识符，并通过应用程序的逻辑来管理会话过期和注销；尽管如前所述，当使用平台身份验证时，通常会发现没有会话超时、过期或注销。
- en: If Kerberos is used, the tokens emitted by the AS already include session information
    and are used to managing such session.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Kerberos，AS发出的令牌已经包含会话信息，并用于管理此类会话。
- en: Session identifiers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话标识符
- en: Session identifiers are more common in form authentication, but they may also
    be present when we use platform authentication. A **session identifier**, or a **session
    ID**, is a unique number or value assigned to every user every time they initiate
    a session within an application. This value must be different from the user's
    ID and password. It must be different every time a user logs in, and it must be
    sent with every request to the server so that it can distinguish between requests
    from different sessions/users.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 会话标识符在表单身份验证中更常见，但在使用平台身份验证时也可能存在。**会话标识符**或**会话ID**是在每次用户在应用程序中启动会话时分配给每个用户的唯一数字或值。该值必须与用户的ID和密码不同。每次用户登录时，它必须是不同的，并且必须随每个请求一起发送到服务器，以便它可以区分来自不同会话/用户的请求。
- en: The most common way to send session IDs between a client and server is through
    cookies. Once the server receives a set of valid usernames and passwords, it associates
    that login information with a session ID and responds to the client, sending such
    IDs as the value of a cookie.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间发送会话ID的最常见方法是通过cookie。一旦服务器接收到一组有效的用户名和密码，它将该登录信息与会话ID关联起来，并向客户端响应，将这些ID作为cookie的值发送。
- en: 'In the following screenshots, you will see some examples of server responses
    that include session cookies:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将看到一些包含会话cookie的服务器响应的示例：
- en: '![](img/00076.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: In the preceding example, a PHP application sets a session cookie called `PHPSESSID`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，一个PHP应用程序设置了一个名为`PHPSESSID`的会话cookie。
- en: '![](img/00077.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: In the preceding example, a Java application sets a session cookie called `JSESSIONID`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，一个Java应用程序设置了一个名为`JSESSIONID`的会话cookie。
- en: '![](img/00078.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: In the preceding example, an ASP.NET application sets a session cookie called
    `ASP.NET_SessionId`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，一个ASP.NET应用程序设置了一个名为`ASP.NET_SessionId`的会话cookie。
- en: Common authentication flaws in web applications
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序中的常见身份验证缺陷
- en: We have spent some time discussing how different authentication mechanisms work
    in web applications. In this section, you will learn how to identify and exploit
    some of the most common security failures in them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间讨论了Web应用程序中不同身份验证机制的工作原理。在本节中，您将学习如何识别和利用其中一些最常见的安全故障。
- en: Lack of authentication or incorrect authorization verification
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺乏身份验证或错误的授权验证
- en: In the previous chapter, you saw how to use DIRB and other tools to find directories
    and files that may not be referenced by any page on the web server or that may
    contain privileged functionality, such as `/admin` and `/user/profile`. If you
    are able to browse directly to those directories and use the functionality within
    them without having to authenticate, or if being authenticated as a standard user,
    you can browse to the application's administrative area or modify other user's
    profiles just by browsing to them, then that application has a major security
    issue with regard to its authentication and/or authorization mechanisms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您了解到如何使用DIRB和其他工具来查找可能没有在Web服务器上的任何页面中引用的目录和文件，或者可能包含特权功能，例如`/admin`和`/user/profile`。如果您能够直接浏览到这些目录并在其中使用功能，而无需进行身份验证，或者作为标准用户进行身份验证后，您可以通过浏览到这些目录来浏览到应用程序的管理区域或修改其他用户的配置文件，那么该应用程序在身份验证和/或授权机制方面存在重大安全问题。
- en: Username enumeration
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户名枚举
- en: In black box and gray box penetration testing scenarios, discovering a list
    of valid users for an application may be one of the first steps, especially if
    such an application is not commercial so that you can look for default users online.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑盒和灰盒渗透测试场景中，发现应用程序的有效用户列表可能是第一步之一，特别是如果这样的应用程序不是商业应用，以便您可以在线查找默认用户。
- en: 'Enumerating users in web applications is done by analyzing the responses when
    usernames are submitted in places such as login, registration, and password recovery
    pages. Some common error messages follow, which you can find when submitting forms
    to such pages that tell you that you can enumerate users:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析在登录、注册和密码恢复页面等地方提交用户名时的响应，可以对Web应用程序中的用户进行枚举。以下是一些常见的错误消息，当提交表单到这些页面时，您可以找到告诉您可以枚举用户的消息：
- en: '`"User foo: invalid password"`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “用户foo：无效密码”
- en: '`"invalid user ID"`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “无效用户ID”
- en: '`"account disabled"`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “帐户已禁用”
- en: '`"this user is not active"`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “此用户未激活”
- en: '`"invalid user"`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “无效用户”
- en: Let's review a very simple example on how to discover valid usernames from a
    web application that gives excessive information when an incorrect username is
    provided. Use OWASP WebGoat from the **Broken Web Applications** (**BWA**) virtual
    machine with IP address, `10.7.7.5`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常简单的例子，如何从一个Web应用程序中发现有效的用户名，当提供错误的用户名时，该应用程序会提供过多的信息。使用IP地址为`10.7.7.5`的**Broken
    Web Applications**（**BWA**）虚拟机中的OWASP WebGoat。
- en: 'First run Burp Suite and configure your browser to use it as proxy (in Firefox,
    navigate to Preferences | Advanced | Network | Connection | Settings):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行Burp Suite并配置您的浏览器以使用它作为代理（在Firefox中，导航到首选项 | 高级 | 网络 | 连接 | 设置）：
- en: '![](img/00079.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: 'Next, log in to WebGoat using the `webgoat` default user with the `webgoat` password and
    go to Authentication Flaws | Forgot Password:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`webgoat`默认用户和`webgoat`密码登录WebGoat，并转到Authentication Flaws | Forgot Password：
- en: '![](img/00080.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: 'This is a password recovery form that requires a username to continue the recovery
    process. You can input a nonexistent username, such as `nonexistentuser`, and
    submit it to see the result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要用户名才能继续恢复过程的密码恢复表单。您可以输入一个不存在的用户名，例如`nonexistentuser`，并提交以查看结果：
- en: '![](img/00081.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: The username is not valid, and you will not be able to proceed with password
    recovery. You can assume that when the user is valid, you will have a different
    response.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名无效，您将无法继续进行密码恢复。您可以假设当用户有效时，您将获得不同的响应。
- en: 'Now let''s use Burp Suite''s Intruder to try to find a valid name. First, you
    look for the request in Burp Proxy''s history and send it to Intruder (press *Ctrl*
    + *I* or right-click and select Send to Intruder):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Burp Suite的Intruder来尝试找到一个有效的用户名。首先，在Burp Proxy的历史记录中查找请求，并将其发送到Intruder（按下*Ctrl*
    + *I*或右键单击并选择发送到Intruder）：
- en: '![](img/00082.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'Next, change to the Intruder tab, then to the number of your request, and last
    to Positions. You can see that all client modifiable parameters are selected by
    default. Click on Clear to unselect them, and then select only the username value
    and click on Add:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到入侵者标签，然后切换到您的请求编号，最后切换到位置。您可以看到所有可由客户端修改的参数默认都被选中。点击清除以取消选择它们，然后只选择用户名值并点击添加：
- en: '![](img/00083.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: Intruder automates the sending of multiple requests to the server, replacing
    the selected values with user-provided inputs, and it records all responses so
    that you can analyze them. Now add a list of usernames to try, instead of the
    one already submitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵者自动发送多个请求到服务器，用用户提供的输入替换选定的值，并记录所有响应以供分析。现在添加一个要尝试的用户名列表，而不是已提交的用户名。
- en: 'Burp Intruder has four different attack types that describe how the inputs
    will be filled with the payloads:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Intruder有四种不同的攻击类型，描述了如何使用有效负载填充输入：
- en: '**Sniper**: This uses a single payload set, and selects each input position,
    one at a time, for every value within this payload set. The number of requests
    will be the length of the payload set multiplied by the number of input positions.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sniper**：这使用单个有效负载集，并逐个选择每个输入位置的值。请求的数量将是有效负载集的长度乘以输入位置的数量。'
- en: '**Battering ram**: This uses a single payload set, and selects all input positions
    simultaneously for every value within this payload set. The number of requests
    will be the length of the payload set.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撞击锤**：这个方法使用一个单一的有效负载集，并同时选择所有输入位置上的每个值。请求数量将等于有效负载集的长度。'
- en: '**Pitchfork**: This uses multiple input positions, and it requires a payload
    set for each position. It submits one value for each payload set in its corresponding
    input at a time. The number of requests made will be the length of the shortest
    payload set.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**草叉**：这个方法使用多个输入位置，并且每个位置都需要一个有效负载集。它一次在对应的输入中提交一个有效负载集的值。请求数量将等于最短有效负载集的长度。'
- en: '**Cluster bomb**: When using multiple inputs, all of the elements in the payload
    set 1 will be paired with all of the elements of the payload set 2 and so on until
    the payload set *n*. The number of requests made in the attack is determined by
    multiplying all payload sets'' sizes.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集束炸弹**：当使用多个输入时，有效负载集1中的所有元素将与有效负载集2中的所有元素配对，依此类推，直到有效负载集*n*。攻击中的请求数量由所有有效负载集的大小相乘确定。'
- en: Next, change to the Payloads tab inside Intruder. Leave Payload set unchanged,
    and click on Load... in the Payload Options [Simple List] section; this is designed
    to load a file containing the names that you want to try. Luckily, Kali Linux
    includes an extensive collection of dictionaries and wordlists in the `/usr/share/wordlists`
    directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Intruder中切换到Payloads选项卡。保持有效负载集不变，点击有效负载选项[简单列表]部分的“加载...”按钮；这是为了加载包含你想尝试的名称的文件。幸运的是，Kali
    Linux在`/usr/share/wordlists`目录中包含了大量的字典和单词列表。
- en: 'In this example, you will use `/usr/share/wordlists/metasploit/http_default_users.txt`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将使用`/usr/share/wordlists/metasploit/http_default_users.txt`：
- en: '![](img/00084.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: 'Now that you have the request with the input positions defined and the payload
    list ready, click on Start Attack:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经定义了带有输入位置的请求，并准备好了有效负载列表，请点击“开始攻击”：
- en: '![](img/00085.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: As you can see in the results, all of the names tried had an identical response;
    that is, all but one. You'll notice that `admin` had a response with a different
    length, and if you go through the response's body, you will see that it is asking
    the password recovery question. So, `admin` is a valid username.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，所有尝试的名称都有相同的响应，除了一个。你会注意到`admin`有一个不同长度的响应，如果你查看响应的正文，你会看到它在询问密码恢复问题。所以，`admin`是一个有效的用户名。
- en: Username enumeration can be done every time that an application shows different
    responses for valid and invalid usernames. Also, some applications include a validation
    when registering a new user, so that the name is not duplicated. If this validation
    is done before the form is submitted, there is a web service preforming such validations
    and you can use it for enumeration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名枚举可以在应用程序对有效和无效用户名显示不同响应时进行。此外，一些应用程序在注册新用户时会进行验证，以确保名称不重复。如果此验证在提交表单之前完成，那么有一个执行此类验证的网络服务，你可以用它进行枚举。
- en: Discovering passwords by brute force and dictionary attacks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过暴力破解和字典攻击来发现密码
- en: Once you have identified valid users in the application, the natural next step
    is to attempt to find the passwords for these users. There are plenty of methods
    to obtain valid passwords from users, from mimicking the original site in a different
    server and using social engineering to trick users into submitting their information,
    to taking advantage of insecure password recovery mechanisms, to guessing the
    password, if it is a common one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在应用程序中确定了有效的用户，下一个自然步骤就是尝试找到这些用户的密码。有很多方法可以从用户那里获取有效密码，从模仿原始网站在不同服务器上并使用社交工程来欺骗用户提交他们的信息，到利用不安全的密码恢复机制，再到猜测密码（如果是常见密码）。
- en: '**Brute force** is a method that attempts all possible character combinations
    to discover a valid password. This can work well when the application allows passwords
    of one to three or even four characters. If such passwords are allowed, chances
    are that at least one user is using them.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**暴力破解**是一种尝试所有可能的字符组合来发现有效密码的方法。当应用程序允许使用一到三个甚至四个字符的密码时，这种方法可能很有效。如果允许使用这样的密码，很有可能至少有一个用户在使用它们。'
- en: For longer passwords, a brute force attack is completely impractical, as you
    would need to send millions (or billions) of requests to the application before
    you discover one valid password. Adding to this, the time required to perform
    such an attack is much longer (extremely longer) than the standard one or two
    weeks scheduled for penetration testing. For this situation, we rely on the predictability
    of the human element—even when, for practical purposes, possible combinations
    of eight or more character passwords are almost infinite, we humans tend to use
    only a small subset of those combinations as passwords and the most common ones
    are very common.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较长的密码，暴力破解攻击是完全不切实际的，因为在发现一个有效密码之前，你需要向应用程序发送数百万（甚至数十亿）个请求。此外，执行这种攻击所需的时间比标准的一两周的渗透测试计划要长得多（非常长）。在这种情况下，我们依靠人为因素的可预测性——即使对于实际目的来说，八个或更多字符密码的可能组合几乎是无限的，但我们人类倾向于只使用其中一小部分组合作为密码，而且最常见的密码非常常见。
- en: To take advantage of this fact, there are dictionaries that contain common or
    default passwords, or the ones known to be leaked in previous attacks on popular
    sites. Using these dictionaries, you can reduce the number of attempts that you
    need to make for discovering a valid password and increasing the chances of finding
    it as a word in the dictionary, which has already been used by a number of people
    as a password.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个事实，有一些包含常见或默认密码的字典，或者是已知在以前对流行网站的攻击中泄露的密码。使用这些字典，你可以减少需要尝试的次数，增加在字典中找到有效密码的机会，因为已经有很多人将其作为密码使用过。
- en: 'Since 2012, SplashData has released a list of the most used passwords in the
    world, according to an analysis made on collections of hacked and leaked passwords.
    The 2017 and 2016 results can be checked at [https://www.teamsid.com/worst-passwords-2017-full-list/](https://www.teamsid.com/worst-passwords-2017-full-list/)
    and [https://www.teamsid.com/worst-passwords-2016/](https://www.teamsid.com/worst-passwords-2016/).
    Another list that gets published on a yearly basis is the one from the Keeper
    password manager: [https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/](https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自2012年以来，SplashData每年发布一份根据被黑客和泄露密码集合进行分析得出的最常用密码列表。可以在以下链接查看2017年和2016年的结果：[https://www.teamsid.com/worst-passwords-2017-full-list/](https://www.teamsid.com/worst-passwords-2017-full-list/)和[https://www.teamsid.com/worst-passwords-2016/](https://www.teamsid.com/worst-passwords-2016/)。另一个每年发布的列表是来自Keeper密码管理器的列表：[https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/](https://blog.keepersecurity.com/2017/01/13/most-common-passwords-of-2016-research-study/)。
- en: Attacking basic authentication with THC Hydra
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用THC Hydra攻击基本身份验证
- en: '**THC Hydra** is a long-time favorite online password cracking tool among hackers
    and penetration testers.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**THC Hydra**是黑客和渗透测试人员中长期以来最受欢迎的在线密码破解工具。'
- en: Online cracking means that login attempts to the service are actually made.
    This may generate a lot of traffic and raise alerts on the server when security
    and monitoring tools are in place. For this reason, you should be especially careful
    when attempting an online brute force or dictionary attack over an application
    or server, and tune the parameters so that you have the best possible speed without
    overwhelming the server, raising alerts, or locking out user accounts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在线破解意味着实际进行了对服务的登录尝试。当存在安全和监控工具时，这可能会产生大量流量并在服务器上引发警报。因此，在尝试在线暴力破解或字典攻击应用程序或服务器时，你应该特别小心，并调整参数以获得最佳速度，而不会使服务器过载、引发警报或锁定用户账户。
- en: A good approach for conducting online attacks when there is monitoring in place
    or an account lockout after a certain number of failed attempts is to start with
    three or four passwords per user, or an amount less than the lockout threshold.
    Take the most obvious or common passwords (for example, `password`, `admin`, or
    `12345678`), and if no results are obtained, go back to the reconnaissance stage
    to get a better set of passwords and try again after several minutes or a couple
    of hours.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在监控或在一定次数的失败尝试后账户被锁定时，进行在线攻击的一个好方法是为每个用户使用三到四个密码，或者少于锁定阈值的数量。选择最明显或最常见的密码（例如`password`、`admin`或`12345678`），如果没有结果，返回侦察阶段获取更好的密码集，并在几分钟或几个小时后再次尝试。
- en: THC Hydra has the ability to connect to a wide range of services, such as FTP,
    SSH, Telnet, and RDP. We will use it to do a dictionary attack on an HTTP server
    that uses basic authentication.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: THC Hydra具有连接到各种服务的能力，如FTP、SSH、Telnet和RDP。我们将使用它对使用基本身份验证的HTTP服务器进行字典攻击。
- en: 'First, you need to know the URL that actually processes the login credentials.
    Pop up your *Kali machine*, open Burp Suite, and configure the browser to use
    it as a proxy. You will use the vulnerable virtual machine and the WebGoat application.
    When you try to access WebGoat, you get a dialog asking for login information.
    If you submit any random name and password, you get the same dialog again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要知道实际处理登录凭据的URL。打开你的*Kali机器*，打开Burp Suite，并配置浏览器使用它作为代理。你将使用易受攻击的虚拟机和WebGoat应用程序。当你尝试访问WebGoat时，会弹出一个对话框要求输入登录信息。如果你提交任意随机的用户名和密码，会再次出现相同的对话框：
- en: '![](img/00086.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'Even when an attempt wasn''t successful, the request is already registered
    in Burp. Next, look for one that has the `Authorization: Basic` header in it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '即使尝试不成功，请求已经在Burp中注册。接下来，寻找其中一个具有`Authorization: Basic`头的请求：'
- en: '![](img/00087.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'Now you know that the URL processing the login is `http://10.7.7.5/WebGoat/attack`.
    This is enough information to run Hydra, but first you need to have a list of
    possible usernames and another one for passwords. In a real-world scenario, possible
    usernames and passwords will depend on the organization, the application, and
    the knowledge you have about its users. For this test, you can use the following
    list of probable users for an application called WebGoat, and designate it to
    be a target of security testing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道处理登录的URL是`http://10.7.7.5/WebGoat/attack`。这已经足够运行Hydra了，但首先你需要有一个可能的用户名列表和一个密码列表。在实际情况下，可能的用户名和密码将取决于组织、应用程序以及你对其用户的了解。对于这个测试，你可以使用以下可能的用户列表，用于名为WebGoat的应用程序，并将其指定为安全测试的目标：
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As for passwords, you can try some of the most common ones and add variations
    of the application''s name:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 至于密码，你可以尝试一些最常见的密码，并添加应用程序名称的变体：
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the usernames'' list as `users.txt` and the passwords'' list as `passwords.txt`.
    First, run `hydra` without any parameters to look at the help and execution information:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户名列表保存为`users.txt`，将密码列表保存为`passwords.txt`。首先，运行`hydra`命令，不带任何参数查看帮助和执行信息：
- en: '![](img/00088.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: 'You can see that it requires the `-L` option to add a user list file, `-P`
    to add a password list file, and the protocol, server, port, and optional information
    in this form: `protocol://server:port/optional`. Run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它需要使用`-L`选项添加一个用户列表文件，`-P`选项添加一个密码列表文件，以及协议、服务器、端口和可选信息，形式如：`protocol://server:port/optional`。运行以下命令：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/00089.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: You'll find that the combination of the `webgoat` user and the `webgoat` password is
    accepted by the server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`webgoat`用户和`webgoat`密码的组合被服务器接受。
- en: A useful option when using Hydra is `-e` with the `n`, `s`, or `r` modifiers that
    can process login inputs, sending an empty password (`n`), username as password
    (`s`), reverse the username and use it as password (`r`), and `-u`, which loops
    users first. This means that it tries all users with a single password and then
    moves on to the next password. This may prevent you from being locked out by some
    defensive mechanisms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Hydra时，一个有用的选项是使用`-e`和`n`、`s`或`r`修饰符，可以处理登录输入，发送空密码（`n`），将用户名作为密码（`s`），反转用户名并将其用作密码（`r`），以及`-u`，它首先循环用户。这意味着它尝试所有用户与单个密码，然后继续下一个密码。这可以防止您被某些防御机制锁定。
- en: Attacking form-based authentication
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击基于表单的身份验证
- en: 'Because there is no standard implementation, and web applications are much
    more flexible in terms of validation and attack prevention, login forms pose some
    special challenges when it comes to brute forcing them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有标准的实现，并且Web应用程序在验证和攻击预防方面更加灵活，因此登录表单在暴力破解时面临一些特殊的挑战：
- en: There is no standard name, position, or format in the username and password
    parameters
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名和密码参数中没有标准的名称、位置或格式
- en: There is no standard negative or positive response to a login attempt
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录尝试没有标准的负面或正面响应
- en: The client-side and server-side validations may prevent certain types of attacks
    or repeated submission of requests
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器端的验证可能会阻止某些类型的攻击或重复提交请求
- en: Authentication may be done in more than one step; that is, asking the username
    in one page and the password in the next page
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证可能分为多个步骤，即在一个页面中询问用户名，在下一个页面中询问密码
- en: Fortunately for penetration testers, most applications use the basic pattern
    of HTML form, sent through a `POST` request including the username and password
    as parameters and getting a redirect to the user's home page on successful login,
    and an error or redirection to the login page if failed. You will now examine
    two methods used to execute a dictionary attack on this kind of form. The same
    principle applies to almost all form-based authentication, with some modifications
    on how the responses are interpreted and the required parameters for submission.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渗透测试人员来说，幸运的是，大多数应用程序使用HTML表单的基本模式，通过POST请求发送用户名和密码作为参数，并在成功登录时重定向到用户的主页，如果失败，则重定向到登录页面或显示错误。现在，您将研究两种用于对此类表单执行字典攻击的方法。几乎所有基于表单的身份验证都适用相同的原则，只是在如何解释响应和所需的提交参数方面有一些修改。
- en: Using Burp Suite Intruder
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Suite Intruder
- en: As in a basic authentication attack, you first need to identify the request
    that performs the actual authentication and its parameters in order to attack
    the correct ones.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本身份验证攻击一样，您首先需要识别执行实际身份验证的请求及其参数，以便攻击正确的请求。
- en: 'In the following screenshot, on the left-hand side, you''ll see OWASP Bricks
    in the authentication form (in the Vulnerable Virtual system main menu, go to
    Bricks | Login pages | Login #3), and on the right-hand side, you can see the
    request via the `POST` method. You''ll observe that the `username` and `passwd`
    parameters are sent in the body, while there is no `Authorization` header:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将在左侧看到OWASP Bricks中的身份验证表单（在易受攻击的虚拟系统主菜单中，转到Bricks | 登录页面 | 登录#3），在右侧，您可以看到通过POST方法发送的请求。您会观察到用户名和密码参数发送到正文中，而没有授权头：
- en: '![](img/00090.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: 'To do a dictionary attack on this login page, you first need to analyze the
    response to identify what distinguishes a failed login from a successful one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要对此登录页面进行字典攻击，您首先需要分析响应，以确定失败的登录与成功的登录有何区别：
- en: '![](img/00091.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: In the screenshot, you may observe that a failed response contains the `"Wrong
    user name or password."` text. For sure, this won't be in a successful login.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，您可以观察到失败的响应包含“用户名或密码错误”的文本。当然，这不会出现在成功登录中。
- en: 'Next, send the request to Intruder, and select the `username` and `passwd`
    parameters as inputs. Then, select Cluster bomb as the attack type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将请求发送到Intruder，并选择用户名和密码参数作为输入。然后，选择Cluster bomb作为攻击类型：
- en: '![](img/00092.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: 'Next, go to the Payloads tab, select the payload set `1`, and load the file
    containing the usernames that we used before:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到有效负载选项卡，选择有效负载集“1”，并加载包含之前使用的用户名的文件：
- en: '![](img/00093.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: 'For payload set `2`, we will also use the passwords file used in the previous
    exercise:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有效负载集“2”，我们还将使用之前练习中使用的密码文件：
- en: '![](img/00094.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: 'As you can see in this screenshot, `60` requests are made to the server, as
    you have 6 usernames and 10 possible passwords:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此屏幕截图中所见，服务器发送了60个请求，因为您有6个用户名和10个可能的密码：
- en: '![](img/00095.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: 'You can launch your attack at this point, then analyze the responses, and learn
    whether some login combination was successful. However, Burp Intruder has some
    features that can make your life easier, not only with simple examples like this,
    but when attacking complex real-world applications. Go to the Options tab and
    then to Grep - Match to make Intruder look for some specific text in the responses,
    so that you can easily identify the one that is successful. Click on the Flag
    result items with responses matching these expressions box, clear the current
    list, and enter the following in the Enter a new item box:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此时发起攻击，然后分析响应，并了解是否有某个登录组合成功。然而，Burp Intruder具有一些功能，可以使您的生活更轻松，不仅适用于像这样的简单示例，还适用于攻击复杂的真实应用程序。转到选项选项卡，然后转到Grep
    - Match，使Intruder在响应中查找某些特定的文本，以便您可以轻松识别成功的文本。点击“标记与这些表达式匹配的结果项”框，清除当前列表，并在“输入新项目”框中输入以下内容：
- en: '[PRE3]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Press *Enter* or click on Add. Intruder will mark all responses that contain
    this message; thus the ones that are not marked may represent a successful login.
    If you knew the correct login message, you look for that message and directly
    identify a correct set of credentials:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*或点击“添加”。Intruder将标记所有包含此消息的响应；因此，未标记的响应可能表示成功登录。如果您知道正确的登录消息，您可以寻找该消息并直接识别出一组正确的凭据：
- en: '![](img/00096.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: 'Start the attack, and wait for the results:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 开始攻击，并等待结果：
- en: '![](img/00097.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: It looks like you have found at least one valid username and its password.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来您已经找到了至少一个有效的用户名及其密码。
- en: Using THC Hydra
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用THC Hydra
- en: 'Among the many protocols that Hydra supports, there are `http-get-form`, `http-post-form`,
    `https-get-form`, and `https-post-form`, which are the HTTP and HTTPS login forms
    sent by the `GET` and `POST` method respectively. Using the same information from
    the previous exercise, you can run a dictionary attack with Hydra using the following
    command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hydra支持的众多协议中，有`http-get-form`、`http-post-form`、`https-get-form`和`https-post-form`，它们分别是通过`GET`和`POST`方法发送的HTTP和HTTPS登录表单。使用前面练习中的相同信息，您可以使用以下命令在Hydra中运行字典攻击：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/00098.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'You may notice that the syntax in this case is slightly different than your
    previous use of Hydra. Let''s check it out together:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这种情况下的语法与您之前使用Hydra的语法略有不同。让我们一起来看看：
- en: First, you have the `hydra` command and the target host (`hydra 10.7.7.5`).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要`hydra`命令和目标主机（`hydra 10.7.7.5`）。
- en: Then the protocol or service that you want to test (`http-form-post`).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是您要测试的协议或服务（`http-form-post`）。
- en: 'Next comes the protocol-specific parameters in quotes (`""`) and separated
    with colons:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是用引号（`""`）括起来的协议特定参数，用冒号分隔：
- en: URL (`/owaspbricks/login-3/index.php`)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL（`/owaspbricks/login-3/index.php`）
- en: The body of the request, indicated by `^USER^`, where Hydra should put the usernames
    and `^PASS^` for the place where the passwords should go
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的主体由`^USER^`指示，Hydra应该将用户名放在这里，`^PASS^`指示密码应该放在哪里
- en: The failed login message (`Wrong user name or password.`)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录失败的消息（“用户名或密码错误。”）
- en: Last comes the username and password lists indicated by `-L` and `-P`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后是由`-L`和`-P`指示的用户名和密码列表
- en: The password reset functionality
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码重置功能
- en: Another common weak spot in web applications is the implementation of the password
    recovery and reset functionalities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中的另一个常见弱点是密码恢复和重置功能的实现。
- en: Since applications need to be user friendly, and some users forget their passwords,
    applications need to incorporate a way to allow these users to reset or recover
    their passwords. Coming up with a secure solution for this problem is not an easy
    task, and many developers may leave some weak link that a penetration tester or
    attacker can exploit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序需要用户友好，并且一些用户会忘记密码，因此应用程序需要提供一种允许这些用户重置或恢复密码的方式。为此问题提供一个安全的解决方案并不是一件容易的事情，许多开发人员可能会留下一些弱点，供渗透测试人员或攻击者利用。
- en: Recovery instead of reset
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复而不是重置
- en: 'When facing the question of what to do when a user forgets their password,
    you can choose between two main options:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临用户忘记密码时该怎么办的问题时，您可以在两个主要选项之间选择：
- en: Allow them to recover the old password
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许他们恢复旧密码
- en: Allow them to reset it
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许他们重置密码
- en: 'The fact that an application allows a user to recover their old password presumes
    some security flaws in the application''s design:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序允许用户恢复旧密码，这意味着应用程序设计中存在一些安全漏洞：
- en: Passwords are stored in a recoverable manner in the database instead of using
    a one-way hashing algorithm, which is the best practice for storing passwords.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码以可恢复的方式存储在数据库中，而不是使用单向哈希算法，这是存储密码的最佳实践。
- en: In the server-side code, a customer service agent or the system administrator
    can recover the password. An attacker may also be able to do this through social
    engineering or technical exploitation.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端代码中，客户服务代理或系统管理员可以恢复密码。攻击者也可以通过社会工程或技术利用来做到这一点。
- en: The password is put at risk when communicated back to the user, either by email,
    telephone, or by being displayed on a web page. There are many ways in which an
    intermediary or a bystander can capture such information.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当密码通过电子邮件、电话或在网页上显示时，密码就会面临风险。中间人或旁观者可以以许多方式捕获这些信息。
- en: Common password reset flaws
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的密码重置缺陷
- en: A very common method that applications employ to allow users to recover or reset
    their passwords is to ask one or more questions, where only the legitimate user
    should know the answer. This includes place of birth, first school, name of first
    pet, and mother's maiden name. The problems begin when the questions asked by
    the application are not that secret to a prospective attacker, and this problem
    increases if the user is a high-profile person, such as a celebrity or politician,
    when so many details of their lives are publicly available.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序常用的一种允许用户恢复或重置密码的方法是询问一个或多个问题，只有合法用户才应该知道答案。这些问题包括出生地、第一所学校、第一只宠物的名字和母亲的娘家姓。问题在于，如果应用程序提出的问题对于潜在攻击者来说并不那么机密，那么这个问题会增加，如果用户是高知名度的人物，比如名人或政治家，那么他们生活的许多细节都是公开的，这个问题就会增加。
- en: A second layer of protection is in not giving direct access to the password
    reset functionality, but sending an email or SMS with a password reset link. If
    this email or phone number is requested while trying to reset the password, chances
    are that you can spoof this information, replace the user's number by yours, and
    get any user's password reset.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层保护是不直接提供密码重置功能的访问权限，而是通过电子邮件或短信发送密码重置链接。如果在尝试重置密码时请求了此电子邮件或电话号码，那么您可以伪造此信息，将用户的号码替换为您的号码，并获取任何用户的密码重置。
- en: If the email or phone number are correctly verified, and it's not possible to
    spoof them, there is still the chance that the reset link is not correctly implemented.
    Sometimes these links include a parameter indicating the ID, such as the number
    or name of the user whose password is going to be reset. In this case, all that
    you need to do is to generate a link using a user that you control and change
    that parameter to one of the user whose password you want to reset.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电子邮件或电话号码经过正确验证，并且无法伪造它们，仍然存在重置链接没有正确实现的可能性。有时这些链接包含一个参数，指示ID，比如要重置密码的用户的号码或姓名。在这种情况下，你只需要使用一个你控制的用户生成一个链接，并将该参数更改为你想要重置密码的用户之一。
- en: Another possible fail is that such a reset link is not invalidated after the
    first, legitimate use. In this case, if an attacker gains access to such a link,
    by any means, they can access it again and reset the user's password.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的失败是，这样的重置链接在第一次合法使用后没有失效。在这种情况下，如果攻击者以任何方式获得了这样的链接，他们可以再次访问它并重置用户的密码。
- en: Vulnerabilities in 2FA implementations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2FA实施中的漏洞
- en: The most common form of MFA in web applications is the use of a randomly generated
    number (four to eight digits) used as OTP that the user gets from a special device,
    a mobile app (such as Google Authenticator, Authy, 1Password, or LastPass Authenticator),
    or through an SMS or email sent by the server on request.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中最常见的MFA形式是使用随机生成的数字（四到八位数）作为OTP，用户可以从特殊设备、移动应用程序（如Google Authenticator、Authy、1Password或LastPass
    Authenticator）或通过服务器根据请求发送的短信或电子邮件中获取。
- en: 'You can detect and take advantage of some implementation flaws in this process
    during a penetration test when the following conditions exist:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，当存在以下条件时，你可以检测和利用这个过程中的一些实施缺陷：
- en: OTP numbers are not completely random and can be predicted.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTP号码不是完全随机的，可以被预测。
- en: OTPs are not linked to the user to whom they are assigned. This means that you
    can generate an OTP for one user and use it with another.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTP与其分配的用户没有关联。这意味着你可以为一个用户生成一个OTP，并将其用于另一个用户。
- en: The same password or token can be used multiple times.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个密码或令牌可以多次使用。
- en: There is no limit for OTP submission attempts. This opens up the possibility
    of brute force attacks, which are more likely to be successful as OTPs are normally
    short strings of numbers.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTP提交尝试没有限制。这打开了暴力破解攻击的可能性，因为OTP通常是短数字字符串，更容易成功。
- en: User information is not validated when sending the OTP by email or SMS, allowing
    an attacker to spoof the email address or phone number.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送OTP（一次性密码）的时候，用户信息没有经过验证，这使得攻击者可以伪造电子邮件地址或电话号码。
- en: The expiration time of the OTP is too long for the purposes of the application.
    This expands the time window for an attacker to get a valid, unused token.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OTP的过期时间对于应用程序的目的来说太长了。这扩大了攻击者获取有效未使用令牌的时间窗口。
- en: Newly generated OTPs don't invalidate previous ones, so for example, if a user
    requests a token or password multiple times for the same operation because the
    network failed on the first attempt(s), an attacker may use the earlier attempt
    to replicate the operation or perform another one that accepts the same token,
    even after the legitimate operation was already executed.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新生成的OTP不会使之前的OTP失效，所以例如，如果一个用户因为网络故障而多次请求同一操作的令牌或密码（第一次尝试失败），攻击者可以使用之前的尝试来复制该操作或执行另一个接受相同令牌的操作，即使合法操作已经执行过了。
- en: Reliance on the device from where the application is accessed. Nowadays, people
    have banking applications, personal email, social networks, work email, and many
    other applications on their phones. Thus, you should think twice about using email,
    SMS, or mobile apps as a second factor of authentication.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖访问应用程序的设备。现在，人们在手机上有银行应用程序、个人电子邮件、社交网络、工作电子邮件和许多其他应用程序。因此，你应该三思而后行，是否将电子邮件、短信或移动应用作为第二因素认证。
- en: Detecting and exploiting improper session management
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和利用不正确的会话管理
- en: As stated previously, session management allows the application to track user
    activity and validate authorization conditions without requiring the user to submit
    their credentials every time a request is made. This means that if session management
    is not properly done, a user may be able to access other users' information or
    execute actions beyond their privilege level, or an external attacker may gain
    access to a users' information and functionality.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，会话管理允许应用程序跟踪用户活动并验证授权条件，而无需用户每次请求时都提交凭据。这意味着如果会话管理没有正确执行，用户可能能够访问其他用户的信息或执行超出其权限级别的操作，或者外部攻击者可能会获取用户的信息和功能。
- en: Using Burp Sequencer to evaluate the quality of session IDs
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Sequencer评估会话ID的质量
- en: '**Burp Sequencer** is a statistical analysis tool that lets you collect a large
    amount of values, such as session IDs, and perform calculations on them to evaluate
    if they are being randomly generated, or maybe just obfuscated or encoded. This
    is useful when dealing with complex session cookies, as it gives you an idea of
    how the cookies are being generated and if there is some way of attacking or predicting
    them.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Burp Sequencer**是一种统计分析工具，可以让你收集大量的值，如会话ID，并对它们进行计算，以评估它们是否是随机生成的，或者只是混淆或编码。这在处理复杂的会话cookie时非常有用，因为它可以让你了解cookie是如何生成的，以及是否有攻击或预测的方法。'
- en: 'To use Burp Sequencer, you first need to find the response that sets the session
    cookie. It''s usually the response to a successful login with a `Set-Cookie` header.
    In the following screenshot, you can see the response that sets a session cookie
    (`WEAKID`) for the WebGoat''s session hijacking exercise (go to WebGoat | Session
    Management Flaws | Hijack a Session):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Burp Sequencer，首先需要找到设置会话cookie的响应。通常是成功登录的响应，带有`Set-Cookie`头。在下面的截图中，你可以看到设置WebGoat会话劫持练习的会话cookie（`WEAKID`）的响应（转到WebGoat
    | 会话管理缺陷 | 劫持会话）：
- en: '![](img/00099.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: At first sight, the value of the response may seem unique and difficult enough
    to guess. The first part looks like an ID, and the second part appears to be a
    timestamp, maybe the expiration time in nanoseconds. It should be very difficult
    to guess at which precise nanosecond a session is ending, right? Well, as you'll
    see, it's not the best approach.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，响应的值可能看起来是独特且足够难以猜测的。第一部分看起来像是一个ID，第二部分似乎是一个时间戳，可能是以纳秒为单位的过期时间。很难猜测会话何时精确地结束在哪个纳秒，对吧？嗯，正如您将看到的，这不是最好的方法。
- en: 'Find that response in the Burp Proxy''s history, and right-click on it. You''ll
    then see the Send to Sequencer option. Once in Sequencer, you need to choose which
    part of the response it is focused on:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在Burp Proxy的历史记录中找到该响应，右键单击它。然后，您将看到“发送到Sequencer”选项。进入Sequencer后，您需要选择它所关注的响应部分：
- en: '![](img/00100.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'You have the option to analyze a cookie, a form field, or a custom portion
    of the response. In this case, select the `WEAKID` cookie and click on Start live
    capture. It will start making requests to the server to capture as many different
    cookie values as possible. When finished, click on Analyze now to execute the
    analysis. In the result, Sequencer will indicate if the analyzed value is random
    enough and a good choice as a session ID. As you can see, `WEAKID` is weak and
    easily predictable:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择分析cookie、表单字段或响应的自定义部分。在这种情况下，选择“WEAKID” cookie并点击“开始实时捕获”。它将开始向服务器发送请求，以捕获尽可能多的不同cookie值。完成后，点击“立即分析”执行分析。在结果中，Sequencer将指示分析的值是否足够随机，并且作为会话ID的良好选择。正如您所看到的，“WEAKID”是弱的并且容易预测：
- en: '![](img/00101.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: '**Entropy** is a measure of the level of randomness in a piece of information.
    The result shows that `WEAKID` has zero randomness, which means that it''s totally
    predictable and not a good option as a session ID. Sequencer also provides more
    detailed information about the distribution and significance of each byte and
    bit in the strings.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**熵**是信息中随机性水平的度量。结果显示`WEAKID`的随机性为零，这意味着它是完全可预测的，不适合作为会话ID的好选择。Sequencer还提供有关字符串中每个字节和位的分布和重要性的更详细信息。'
- en: 'In the following screenshot, you''ll see the character analysis chart. You
    can see that the characters in positions `3`, `4`, `15`, `16`, and `18` change
    much more than the characters in positions 0 or 5 to 13, which don''t seem to
    change at all. Also, characters 0 to 4 suggest a counter or an increasing number,
    as the last character changes more than the previous one, and that character more
    than the one previous to it, and so on. We will verify this in the next section:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您将看到字符分析图表。您可以看到在位置3、4、15、16和18的字符变化要比位置0或5到13的字符更多，后者似乎根本不变。此外，字符0到4表明是一个计数器或递增的数字，因为最后一个字符的变化比前一个字符更多，而该字符比前一个字符更多，依此类推。我们将在下一节中验证这一点：
- en: '![](img/00102.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: Predicting session IDs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测会话ID
- en: 'We have identified a session ID that seems to be predictable. Now let''s try
    to find a valid session. To do this, you''ll take the same request that receives
    the cookie and send it to Intruder. In this case, you just want to repeat the
    same request several times. However, Intruder needs to have insertion points for
    it to run, so add a header (`Test: 1`) to the request and set the insertion position
    in its value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经确定了一个似乎是可预测的会话ID。现在让我们试着找到一个有效的会话。为此，您将使用接收到cookie的相同请求并将其发送到Intruder。在这种情况下，您只需要重复相同的请求几次。但是，Intruder需要有插入点才能运行，因此在请求中添加一个头部（`Test:
    1`），并在其值中设置插入位置：'
- en: '![](img/00103.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: 'You will send `101` requests in this test, so set the payload to be of the Numbers type,
    with a sequential increase from 0 to 100:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，您将发送101个请求，因此将有效负载设置为“数字”类型，从0递增到100：
- en: '![](img/00104.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Now go to the Options tab, and in the Grep-Extract section, add one item. Be
    sure that the Update config based on selection below checkbox is checked, and
    select only the cookie''s value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到“选项”选项卡，在“Grep-Extract”部分添加一个项目。确保选中“根据下面的选择更新配置”复选框，并仅选择cookie的值：
- en: '![](img/00105.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: Click on OK and then on Start attack.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”，然后点击“开始攻击”。
- en: 'Now you can see the `WEAKID` value in the Intruder''s result table, and you
    can verify that the first part of the cookie''s value is a sequential number and
    the second part is also always increasing. This depends on the time that the request
    was received by the server. If you look at the following screenshot, you can see
    that there are some gaps in the sequence:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在Intruder的结果表中看到`WEAKID`值，并且可以验证cookie值的第一部分是一个递增的顺序号，第二部分也总是递增的。这取决于请求被服务器接收的时间。如果您查看以下屏幕截图，您会发现序列中存在一些间隙：
- en: '![](img/00106.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'The first half of a currently active session is `18299`. We know that because
    the server didn''t give us that value, and we know that it is increasing with
    each request. We also know that the second part is a timestamp and that it also
    depends on the time the session cookie was assigned. Thus, the second part of
    the value we seek must be in between the two values that we already know: `1509154565768`
    and `1509154566190`. As the difference between those two numbers is small (422),
    we can easily use Intruder to brute force the value.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当前活动会话的前半部分是`18299`。我们之所以知道这一点，是因为服务器没有给我们该值，并且我们知道它随着每个请求而增加。我们还知道第二部分是一个时间戳，并且它还取决于会话cookie分配的时间。因此，我们要寻找的值的第二部分必须在我们已知的两个值之间：`1509154565768`和`1509154566190`。由于这两个数字之间的差异很小（422），我们可以很容易地使用Intruder来暴力破解该值。
- en: 'Now take the same original request and send it once again to Intruder. This
    time, add a cookie to it. After the value of `JSESSIONID`, add the following (remember
    to adjust the values to your results):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次将相同的原始请求发送到Intruder。这次，在其后添加一个cookie。在`JSESSIONID`的值之后，添加以下内容（记得根据您的结果调整值）：
- en: '[PRE5]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Select the last four characters, and add a position marker there:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最后四个字符，并在那里添加一个位置标记：
- en: '![](img/00107.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'Now, in the Payloads tab, the attack will try the numbers from 5768 to 6190:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在有效负载选项卡中，攻击将尝试从5768到6190的数字：
- en: '![](img/00108.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: 'Last, add an expression to match so that you will clearly know when you have
    a successful result. At this point, you only know the message that an unauthenticated
    user should have. You would assume that an authenticated one (with a valid session
    cookie) won''t be requested to sign in:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个匹配表达式，以便您清楚地知道何时获得了成功的结果。此时，您只知道未经身份验证的用户应该有的消息。您会假设经过身份验证的用户（具有有效的会话cookie）不会被要求登录：
- en: '![](img/00109.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: 'Start the attack, and wait until Intruder finds something:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 开始攻击，并等待Intruder找到一些东西。
- en: '![](img/00110.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: You now have a valid session ID. To use it, all that you need to do is to replace
    the value of your session cookie with the one that you just found and visit the
    page to hijack someone else's session. I'll leave this for you to test.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个有效的会话ID。要使用它，您只需要将会话cookie的值替换为您刚刚找到的值，并访问页面以劫持其他人的会话。我会留给您来测试。
- en: Session Fixation
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话固定
- en: Sometimes, the user-provided information is used to generate the session ID,
    or worse, the user-provided information *becomes* the session ID. When this happens,
    an attacker can force a user to use a predefined identifier and then monitor the
    application for when this user starts a session. This is called **Session Fixation**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用户提供的信息用于生成会话ID，或者更糟糕的是，用户提供的信息成为会话ID。当发生这种情况时，攻击者可以强制用户使用预定义的标识符，然后监视应用程序，以便在用户启动会话时进行操作。这被称为**会话固定**。
- en: WebGoat has a somewhat simplistic, yet very illustrative demonstration of this
    vulnerability (go to WebGoat | Session Management Flaws | Session Fixation). We
    will use it to illustrate how this attack can be executed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: WebGoat有一个相对简单但非常具有说明性的演示，展示了这种漏洞（转到WebGoat | 会话管理缺陷 | 会话固定）。我们将使用它来说明如何执行这种攻击。
- en: 'The first step sets you up as the attacker. You need to craft an email to include
    a session ID (`SID`) value in the link that you are sending to the victim, so
    add that parameter with any value, for example, `&SID=123`, to the link to Goat
    Hills Financial:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将您设置为攻击者。您需要编写一封电子邮件，其中包含一个会话ID（`SID`）值，该值将包含在您发送给受害者的链接中，因此请将该参数添加到链接中，例如`&SID=123`，以链接到Goat
    Hills Financial：
- en: '![](img/00111.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: An attacker has discovered that the Goat Hills Financial site uses a GET parameter
    to define session identifiers and is sending a phishing email to a client of that
    institution.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者发现Goat Hills Financial网站使用GET参数来定义会话标识符，并向该机构的客户发送钓鱼邮件。
- en: 'In this step of the exercise, you act as the victim, receiving the email from
    the attacker:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习的这一步中，您扮演受害者的角色，接收来自攻击者的电子邮件：
- en: '![](img/00112.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: As the email seems legitimate because it comes from `admin@webgoatfinancial.com`,
    you click on the link, which sends you to the login page and you log in accordingly.
    Now there is a valid session that uses the parameter that the attacker sent.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电子邮件看起来合法，因为它来自`admin@webgoatfinancial.com`，所以您点击链接，它会将您发送到登录页面，然后您相应地登录。现在有一个使用攻击者发送的参数的有效会话。
- en: 'The next stage requires the attacker to log in to the same site as the victim:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一阶段需要攻击者登录与受害者相同的网站：
- en: '![](img/00113.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: 'You intercept the request with Burp Proxy and edit it to include the `SID`
    parameter the victim has used to log in:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用Burp Proxy拦截请求并编辑它以包含受害者用于登录的`SID`参数：
- en: '![](img/00114.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: 'You have now gained access to the victim''s profile:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经获得了对受害者个人资料的访问权限：
- en: '![](img/00115.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: 'There are two major flaws in how session IDs are managed in this example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，会话ID的管理存在两个主要缺陷：
- en: First, session IDs are generated by means of the user-provided information,
    which makes it easier for an attacker to identify valid values and relate them
    to existing users.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，会话ID是通过用户提供的信息生成的，这使得攻击者更容易识别有效值并将其与现有用户关联起来。
- en: Second, the identifier doesn't change once an authenticated session is started
    (for example, after the victim logs in) and here is the origin of the term, Session
    Fixation, as the attacker is able to preset the value that the session ID will
    have for the victim, making it possible to use that same value to hijack the victim's
    authenticated session.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，一旦启动了经过身份验证的会话（例如，受害者登录后），标识符就不会更改，这就是术语“会话固定”的起源，因为攻击者能够预设会话ID对于受害者将具有的值，从而使其能够使用相同的值劫持受害者的经过身份验证的会话。
- en: Preventing authentication and session attacks
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防身份验证和会话攻击
- en: Authentication in web applications is a difficult problem to solve, and no universal
    solution has been found to date. Because of this, preventing vulnerabilities in
    this area of applications is to a great extent case specific, and developers need
    to find a balance between usability and security according to the particular use
    cases and user profiles with which they are dealing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中的身份验证是一个难以解决的问题，迄今为止还没有找到普遍适用的解决方案。因此，在应用程序的这个领域预防漏洞在很大程度上是具体情况特定的，开发人员需要根据特定的用例和用户配置文件找到可用性和安全性之间的平衡。
- en: We can say this even about session management, as current methods still represent
    workarounds of the deficiencies of the HTTP protocol. Probably with the advent
    of HTML5 and WebSockets or similar technologies, you will have some better alternatives
    to work with in the future.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，即使是会话管理，当前的方法仍然是HTTP协议缺陷的变通方法。也许随着HTML5和WebSockets或类似技术的出现，您将来会有一些更好的替代方案可供使用。
- en: Nevertheless, it is possible to define some generic guidelines for both authentication
    and session management, which would help developers raise the security bar to
    attackers, and we can use these as a reference when looking for defects and making
    recommendations to clients.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然可以为身份验证和会话管理定义一些通用准则，这将帮助开发人员提高对抗攻击者的安全性，并且我们可以在寻找缺陷并向客户提出建议时将其用作参考。
- en: Authentication guidelines
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证准则
- en: 'The following is a list of authentication guidelines:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是身份验证指南的列表：
- en: Usernames or user identifiers must be unique for each user and be case insensitive
    (`user` is the same as `User`).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名或用户标识符必须对每个用户是唯一的，并且不区分大小写（`user`与`User`相同）。
- en: 'Enforce a strong password policy that prevents the use of the following as
    passwords:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行强密码策略，禁止使用以下密码：
- en: Username as password
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名作为密码
- en: Short (that is, less than eight characters) passwords
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短密码（即少于八个字符）
- en: Single case passwords, that is, all lowercase or all uppercase
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个大小写密码，即全部小写或全部大写
- en: Single character set, such as all numbers, all letters, and no use of special
    characters
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个字符集，例如所有数字、所有字母，不使用特殊字符
- en: Number sequences (123456, 9876543210)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字序列（123456，9876543210）
- en: Celebrities, TV shows, movies, or fictional characters (Superman, Batman, Star
    Wars)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名人、电视节目、电影或虚构人物（超人、蝙蝠侠、星球大战）
- en: Passwords in public dictionaries, such as the top-25 most common passwords
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共字典中的密码，例如前25个最常见的密码
- en: Always use secure protocols, such as TLS, to submit login information.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用安全协议（如TLS）提交登录信息。
- en: Do not disclose information about the existence or validity of a username in
    error messages or response codes (for example, do not respond with a 404 code
    when a user is not found).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在错误消息或响应代码中透露有关用户名的存在或有效性的信息（例如，当找不到用户时不要响应404代码）。
- en: 'To prevent brute-force attacks, implement a temporary lockout after a certain
    number of failed attempts: five is a well-balanced number, so that a user who
    fails to log in five consecutive times is locked out for a certain amount of time,
    say twenty or thirty minutes.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止暴力破解攻击，在一定数量的失败尝试后实施临时锁定：五次是一个平衡的数字，这样一个连续五次登录失败的用户将被锁定一段时间，比如二十或三十分钟。
- en: If the password reset feature is implemented, ask for the username or email
    and the security question, if available. Then, send a one-time reset link to the
    user's registered email or to their mobile phone through SMS. This link must be
    disabled after the user resets their password or after a certain amount of time,
    perhaps a couple of hours, if that doesn't happen.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实现了密码重置功能，请要求提供用户名或电子邮件以及安全问题（如果有）。然后，通过注册的电子邮件或通过短信将一次性重置链接发送给用户的注册电子邮件或他们的手机。如果用户没有重置密码或在一定时间内没有重置密码，此链接必须被禁用，可能是几个小时。
- en: When implementing MFA, favor the use of third-party and widely tested frameworks,
    such as Google Authenticator or Authy, if using mobile applications or RSA, or
    Gemalto devices, if a physical token or smartcard is required.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实施多因素身份验证时，如果使用移动应用程序，则优先使用第三方和经过广泛测试的框架，例如Google Authenticator或Authy；如果需要物理令牌或智能卡，则使用RSA或Gemalto设备。
- en: Avoid implementing custom or home-made cryptography and random generation modules,
    and favor standard algorithms from well-known libraries and frameworks.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免实施自定义或自制的加密和随机生成模块，优先选择来自知名库和框架的标准算法。
- en: Ask for re-authentication on sensitive tasks, such as privilege changes on users,
    sensitive data deletion, or modification of global configuration changes.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在敏感任务上要求重新验证身份，例如对用户的特权更改、敏感数据删除或全局配置更改的修改。
- en: OWASP has a quick guide on best practices for implementing authentication on
    web applications at [https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP在其网站上有一个关于在Web应用程序上实施身份验证的最佳实践快速指南：[https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet)。
- en: Session management guidelines
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理指南
- en: 'The following is a list of session management guidelines:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是会话管理指南的列表：
- en: No matter the authentication mechanism used, always implement session management
    and validate the session on every page and/or request.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论使用何种身份验证机制，始终实施会话管理并在每个页面和/或请求上验证会话。
- en: Use long, random, and unique session identifiers. Favor the mechanisms already
    implemented in major web development languages such as ASP.NET, PHP, and J2EE.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用长、随机和唯一的会话标识符。优先使用已在主要Web开发语言（如ASP.NET、PHP和J2EE）中实现的机制。
- en: Generate new session IDs for users on log in and log out. Permanently invalidate
    the used ones.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在登录和注销时为用户生成新的会话ID。永久使已使用的会话ID失效。
- en: Invalidate sessions and log users out after a reasonable time of inactivity—15
    to 20 minutes. Provide a good balance between security and usability.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一段合理的不活动时间（15到20分钟）后，使会话失效并注销用户。在安全性和可用性之间提供良好的平衡。
- en: Always give a user the explicit option to log out; that is, having a log out
    button/option.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终给用户明确的注销选项，即具有注销按钮/选项。
- en: 'When using session cookies, make sure that all security flags are set:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话cookie时，请确保设置了所有安全标志：
- en: The `Secure` attribute is used to prevent the use of the session cookie over
    non-encrypted communication.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Secure`属性来防止在非加密通信中使用会话cookie。
- en: The `HttpOnly` attribute is used to prevent access to the cookie value through
    scripting languages. This reduces the impact in **Cross-Site Scripting** (**XSS**)
    attacks.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpOnly`属性用于防止通过脚本语言访问cookie值。这减少了**跨站脚本**（**XSS**）攻击的影响。'
- en: Use nonpersistent session cookies, without the `Expires` or `Max-Age` attributes.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非持久性会话cookie，不使用`Expires`或`Max-Age`属性。
- en: Restrict the `Path` attribute to the server's root (`/`) or the specific directory
    where the application is hosted.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Path`属性限制为服务器的根目录（`/`）或托管应用程序的特定目录。
- en: The `SameSite` attribute is currently only supported by Chrome and Opera web
    browsers. This provides extra protection against information leakage and **Cross-Site
    Request Forgery** (**CSRF**), by preventing the cookie from being sent to the
    server by external sites.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SameSite`属性目前仅受Chrome和Opera Web浏览器支持。这提供了额外的保护，防止外部站点将cookie发送到服务器，以防止信息泄露和**跨站请求伪造**（**CSRF**）。'
- en: Link the session ID with the user's role and privileges, and use it to verify
    authorization on every request.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将会话ID与用户的角色和权限关联，并在每个请求上使用它来验证授权。
- en: More in-depth advice about this topic can be found in the *Session Management
    Cheat Sheet* of OWASP at [https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的更深入的建议可以在OWASP的“会话管理备忘单”中找到，网址为[https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet)。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed different ways in which web applications perform
    user authentication to restrict access to privileged resources or sensitive information
    and looked at how the session is maintained, given that HTTP doesn't have a built-in
    session management functionality. The most common approaches for doing this in
    today's web applications are form-based authentication and session IDs sent in
    cookies.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Web应用程序执行用户身份验证以限制对特权资源或敏感信息的访问的不同方式，并研究了会话的维护方式，考虑到HTTP没有内置的会话管理功能。在当今的Web应用程序中，最常用的方法是基于表单的身份验证和通过cookie发送会话ID。
- en: We also examined the most common security failure points in authentication and
    session management, how attackers can exploit them using built-in browser tools,
    or through other tools included in Kali Linux, such as Burp Suite, OWASP ZAP,
    and THC Hydra.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了身份验证和会话管理中最常见的安全故障点，攻击者如何利用内置的浏览器工具或Kali Linux中包含的其他工具（如Burp Suite、OWASP
    ZAP和THC Hydra）来利用它们。
- en: In the last section, we discussed some best practices that may prevent or mitigate
    authentication and session management flaws by requiring authentication for all
    privileged components of the application using complex, random session IDs and
    enforcing a strong password policy. These are some of the most important preventative
    and mitigation techniques for such flaws.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们讨论了一些最佳实践，通过要求对应用程序的所有特权组件进行身份验证，使用复杂的随机会话ID，并强制执行强密码策略，可以预防或减轻身份验证和会话管理缺陷。这些是防止此类缺陷的一些最重要的预防和减轻技术。
- en: In the next chapter we will cover the most common kinds of injection vulnerabilities,
    how to detect and exploit them in a penetration test and also the measures required
    to take in order to fix the applications and prevent attacks through these techniques
    from being successful.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍最常见的注入漏洞类型，如何在渗透测试中检测和利用它们，以及修复应用程序和防止通过这些技术进行的攻击所需的措施。
