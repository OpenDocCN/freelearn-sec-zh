- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: API Reconnaissance and Information Gathering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 侦察与信息收集
- en: Knowing the terrain before committing to attacking it is a military maxim. Sun
    Tzu, the famous author of the bestseller *The Art of War* wrote that “*you should
    have a strong sense of the surrounding terrain.*” Getting to know the target API
    is as important as deleting the intrusion evidence of the attack. So, know before
    you go!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在进攻之前了解地形是一条军事格言。著名的《孙子兵法》作者**孙子**写道：“*你应该对周围的地形有强烈的认识。*”了解目标 API 的情况与删除攻击痕迹一样重要。因此，了解再出发！
- en: API reconnaissance and information gathering is the process of collecting information
    about an API, such as its endpoints, methods, parameters, authentication mechanisms,
    and business purpose. This information can then be used to identify security weaknesses,
    test the API’s functionality, or develop new applications that interact with the
    API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: API 侦察与信息收集是收集关于 API 的信息的过程，例如其端点、方法、参数、认证机制和业务目的。这些信息可以用来识别安全漏洞、测试 API 的功能，或者开发与
    API 交互的新应用程序。
- en: In this chapter, you will learn reconnaissance and information-gathering techniques
    that will become part of the planning activities of a penetration test. As a matter
    of fact, after correctly setting up your toolbelt, as you did in the previous
    chapter, uniting information about the target is the next step.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习侦察与信息收集技术，这些技术将成为渗透测试规划活动的一部分。实际上，在前一章中正确设置好你的工具箱后，下一步就是收集关于目标的信息。
- en: You will learn important concepts, such as enumeration, API documentation, **Open
    Source Intelligence** (**OSINT**), and API schemas. All of these are related to
    basically any modern API available on the Internet. We will use OWASP’s crAPI
    and WebGoat projects as our playground.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习重要的概念，如枚举、API 文档、**开源情报** (**OSINT**) 和 API 模式。所有这些概念基本上都与互联网上的任何现代 API
    相关。我们将使用 OWASP 的 crAPI 和 WebGoat 项目作为我们的练习场。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要内容：
- en: Identifying and enumerating APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和列举 API
- en: Analyzing API documentation and endpoints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 API 文档和端点
- en: Leveraging OSINT
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用开源情报（OSINT）
- en: Identifying data and schema structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别数据和模式结构
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Ideally, you should have already created your pentesting environment, as pointed
    out in [*Chapter 2*](B19657_02.xhtml#_idTextAnchor028). However, if you haven’t,
    this is not a big deal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该已经按照 [*第 2 章*](B19657_02.xhtml#_idTextAnchor028)中的指导建立了你的渗透测试环境。然而，如果你还没有建立，也没关系。
- en: 'You can use the tools that follow to go through this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下工具来完成本章内容：
- en: A hypervisor such as Oracle VirtualBox is needed.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个像 Oracle VirtualBox 这样的虚拟机管理程序。
- en: A Linux **Virtual Machine** (**VM**); I recommend selecting either Ubuntu or
    Fedora distros because of the vast number of utilities on both.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Linux **虚拟机** (**VM**)，我推荐选择 Ubuntu 或 Fedora 发行版，因为这两者有大量的实用工具。
- en: Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/)).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/))。
- en: OWASP **Completely Ridiculous API** (**crAPI**) ([https://github.com/OWASP/crAPI/](https://github.com/OWASP/crAPI/)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP **完全荒谬的 API** (**crAPI**) ([https://github.com/OWASP/crAPI/](https://github.com/OWASP/crAPI/))。
- en: OWASP WebGoat ([https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP WebGoat ([https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/))。
- en: OWASP ZAP ([https://www.zaproxy.org/](https://www.zaproxy.org/)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP ZAP ([https://www.zaproxy.org/](https://www.zaproxy.org/))。
- en: In terms of container engines, use either Docker or Podman, which is a superset
    of Docker.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器引擎方面，使用 Docker 或 Podman，后者是 Docker 的超集。
- en: If you are going for the standalone version of WebGoat, you will need a Java
    runtime environment. I suggest selecting OpenJDK. Both Ubuntu and Fedora have
    packages for it. Other distros might have it as well.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你选择使用 WebGoat 的独立版本，你将需要一个 Java 运行时环境。我建议选择 OpenJDK，Ubuntu 和 Fedora 都有其包。其他发行版也可能有。
- en: You will need at least 30 GB of disk space, 2 vCPUs, and 4 GB of RAM on your
    host to accommodate the VM. The recommendation is 50 GB, 4 vCPUs, and 8 GB, respectively.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要至少 30 GB 的磁盘空间、2 个 vCPU 和 4 GB 的内存来容纳虚拟机。推荐配置为 50 GB、4 个 vCPU 和 8 GB。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When this book was being written, there was no stable version of VirtualBox
    for computers with Apple Silicon chips. The beta versions available were unable
    to launch ARM VMs. If this is your scenario, I recommend using UTM ([https://mac.getutm.app/](https://mac.getutm.app/))
    instead. There are a few ways to install it, including via Homebrew. This chapter
    uses an Ubuntu 22.04 LTS server as a VM on top of UTM.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书写作时，还没有适用于Apple Silicon芯片电脑的稳定版本的VirtualBox。可用的测试版本无法启动ARM虚拟机。如果这是你的情况，建议改用UTM（[https://mac.getutm.app/](https://mac.getutm.app/)）。有几种安装方法，包括通过Homebrew。本章使用Ubuntu
    22.04 LTS服务器作为UTM上的虚拟机。
- en: Identifying and enumerating APIs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和枚举API
- en: 'Identification and enumeration of targets can be done passively or actively
    and this is not exclusive to APIs. Passive recon involves gathering information
    about an API without directly interacting with it. This can be done through a
    variety of methods, such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目标的识别和枚举可以是被动的或主动的，这不仅仅限于API。被动侦查涉及在不直接与API交互的情况下收集API的信息。这可以通过多种方法完成，例如：
- en: '**Searching public documentation**: Many API providers publish documentation
    that describes the API’s endpoints, methods, parameters, and authentication mechanisms.
    This documentation can be found on the provider’s website, in online forums, or
    in code repositories.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索公共文档**：许多API提供者发布描述API端点、方法、参数和身份验证机制的文档。这些文档可以在提供者的网站、在线论坛或代码仓库中找到。'
- en: '**Analyzing public traffic**: If the API is publicly accessible, it is possible
    to analyze traffic to the API to learn more about how it is used. This can be
    done using tools such as Wireshark or Fiddler.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析公共流量**：如果API是公开可访问的，可以分析API的流量，以了解它是如何使用的。可以使用如Wireshark或Fiddler等工具来完成此操作。'
- en: '**Searching for exposed information**: API providers may accidentally expose
    sensitive information, such as API keys or passwords, in public forums or code
    repositories. It is possible to find this information using search engines or
    tools such as Shodan.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索暴露的信息**：API提供者可能会在公共论坛或代码仓库中不小心暴露敏感信息，如API密钥或密码。可以使用搜索引擎或如Shodan等工具找到这些信息。'
- en: '**Passive reconnaissance** is about getting information about an API without
    necessarily talking to it. In other words, you need to search for the required
    information by using other sources such as public documentation, analyzing public
    traffic, or searching for exposed information. Many API providers release documentation
    about their API’s methods, verbs, and parameters, as well as how authentication
    and authorization work. This can eventually reveal weak control mechanisms, such
    as a simple pair of username/password credentials. If the API is publicly accessible,
    you can analyze its traffic by capturing it with the help of tools such as Wireshark
    and Fiddler. Additionally, sensitive data, such as keys, tokens, passwords, or
    special configuration parameters, might have been inadvertently leaked in code
    repositories or forums. With the use of a web search engine or a tool such as
    Shodan, you can easily find them.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**被动侦查**是指在不与API直接交互的情况下获取API的信息。换句话说，你需要通过使用其他来源（如公共文档、分析公共流量或搜索暴露的信息）来寻找所需的信息。许多API提供者发布关于其API方法、动词和参数的文档，以及身份验证和授权的工作原理。这最终可能会揭示出控制机制的弱点，例如简单的用户名/密码组合。如果API是公开可访问的，你可以通过捕获其流量来分析它，借助Wireshark和Fiddler等工具。此外，敏感数据，如密钥、令牌、密码或特殊配置参数，可能在代码仓库或论坛中不小心泄露。通过使用网页搜索引擎或如Shodan等工具，你可以轻松找到它们。'
- en: '**Active enumeration**, on the other hand, will require you to interact with
    the API. As is the case for all activate phases of a pentest, bear in mind that
    your actions might be logged by the API provider. Regardless of that, active recon
    usually follows this sequence:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**主动枚举**，另一方面，要求你与API进行交互。就像渗透测试中的所有主动阶段一样，请记住，你的操作可能会被API提供者记录。不管怎样，主动侦查通常遵循以下顺序：'
- en: 'You start by discovering the API’s endpoints (that is, the URLs it’s waiting
    for) and answering requests. With a spider, such as Sitebulb or Screaming Frog
    SEO Spider, you can enumerate all the API’s endpoints:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先通过发现API的端点（即它等待的URL）并回答请求来开始。使用蜘蛛工具，如Sitebulb或Screaming Frog SEO Spider，你可以枚举所有API的端点：
- en: '![Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)](img/B19657_03_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Sitebulb的界面（图片来源：Sitebulb）](img/B19657_03_01.jpg)'
- en: 'Figure 3.1 – Sitebulb’s interface (image credit: Sitebulb)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Sitebulb 的界面（图片来源：Sitebulb）
- en: 'You can then send requests to them via the `curl` utility or utilities such
    as Postman. In fact, one very interesting feature of Postman is translating the
    request you graphically build in a `curl` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过 `curl` 工具或像 Postman 这样的工具向它们发送请求。事实上，Postman 的一个非常有趣的功能是将你在图形界面中构建的请求转换为
    `curl` 命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some API endpoints accept parameters that can be used to control the API’s behavior.
    By probing such parameters, you can learn more about them, including which values
    are acceptable and how they can affect the API’s operation.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些 API 端点接受可以用来控制 API 行为的参数。通过探测这些参数，你可以了解更多关于它们的信息，包括哪些值是可接受的，以及它们如何影响 API
    的操作。
- en: You can also choose to test the API’s authentication mechanism. Some APIs return
    data when you send a read-only request even without a prior authentication. However,
    if an API requires some type of authentication control, you can test it to understand
    its robustness, for example, by crafting special or fuzzed credentials.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以选择测试 API 的认证机制。有些 API 在你发送只读请求时，即使没有事先认证，也会返回数据。然而，如果 API 需要某种类型的认证控制，你可以测试它来了解其健壮性，例如，通过构造特殊或模糊的凭证。
- en: We are now going to cover a few tools that are quite useful for pentesting purposes,
    including crAPI, which you will use throughout the rest of the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍一些非常适用于渗透测试的工具，包括 crAPI，你将在本书的其余部分使用它。
- en: Analyzing WebGoat
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析 WebGoat
- en: Let’s start playing with our lab. Docker is installed along with crAPI and WebGoat,
    both using Docker images. crAPI is distributed with a Docker Compose multi-container
    definition file. You are more than free to pick any other combination of distributions
    and ways to install WebGoat and WebWolf (the accompanying application to test
    some features of WebGoat). Both can be installed with the same Docker image or
    directly executed using separate Java Archive files. Wireshark is also installed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始玩转我们的实验室吧。Docker 已安装，并且包含 crAPI 和 WebGoat，两者都使用 Docker 镜像。crAPI 配有一个 Docker
    Compose 多容器定义文件。你完全可以选择任何其他分发版和安装 WebGoat 和 WebWolf（WebGoat 的附带应用，用于测试一些功能）的方法。两者可以使用相同的
    Docker 镜像安装，或者直接使用单独的 Java Archive 文件执行。Wireshark 也已安装。
- en: '![Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)](img/B19657_03_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – WebGoat 的登录页面 (http://localhost:8080/WebGoat/login)](img/B19657_03_02.jpg)'
- en: Figure 3.2 – WebGoat’s login page (http://localhost:8080/WebGoat/login)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – WebGoat 的登录页面 (http://localhost:8080/WebGoat/login)
- en: 'The following screenshot shows the login page for WebWolf:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 WebWolf 的登录页面：
- en: '![Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)](img/B19657_03_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – WebWolf 的初始页面 (http://localhost:9090/home)](img/B19657_03_03.jpg)'
- en: Figure 3.3 – WebWolf’s initial page (http://localhost:9090/home)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – WebWolf 的初始页面 (http://localhost:9090/home)
- en: Since our target APIs are crAPI and WebGoat, there’s no API documentation to
    be searched, which reduces our passive reconnaissance options. We can still simulate
    some traffic capture to understand how it works. Start Wireshark and start the
    capture on the loopback interface (`127.0.0.1`). To avoid getting overwhelmed
    with other traffic that your system generates, put a filter to restrict capturing
    HTTP packets on TCP port `8080` only (`tcp.port == 8080 and http`). With a simple
    load of WebGoat’s login page, you’ll see capture lines popping up. To facilitate
    identifying when the packets were captured, you may change the way Wireshark shows
    them by clicking on **View** | **Time** **Display Format**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标 API 是 crAPI 和 WebGoat，因此没有 API 文档可供查询，这减少了我们的被动侦察选项。但我们仍然可以模拟一些流量捕获来理解它是如何工作的。启动
    Wireshark，并在回环接口（`127.0.0.1`）上开始捕获。为了避免被系统生成的其他流量淹没，可以设置过滤器，仅捕获 TCP 端口 `8080`
    上的 HTTP 包（`tcp.port == 8080 and http`）。通过简单加载 WebGoat 的登录页面，你会看到捕获的数据行不断出现。为了方便识别数据包的捕获时间，你可以通过点击**视图**
    | **时间** **显示格式**来改变 Wireshark 显示的方式。
- en: 'You need to register an account before start using the tool. The examples in
    this book use `pentest`/`pentest` as a pair of credentials. Register an account
    and launch Wireshark. Observe one of the captured packets. Obviously, we can see
    the password because WebGoat does not apply a digital certificate in the communication:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要先注册一个账户才能开始使用该工具。本书中的示例使用 `pentest`/`pentest` 作为一对凭证。注册账户并启动 Wireshark。观察捕获的一个数据包。显然，我们可以看到密码，因为
    WebGoat 在通信中没有应用数字证书：
- en: '![Figure 3.4 – The output of a Wireshark packet capture showing a clear text
    password](img/B19657_03_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Wireshark 数据包捕获的输出，显示明文密码](img/B19657_03_04.jpg)'
- en: Figure 3.4 – The output of a Wireshark packet capture showing a clear text password
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Wireshark 数据包捕获的输出，显示明文密码
- en: From that packet, you can verify that the element that created the credentials
    is called `/WebGoat/register.mvc`, which was called by `/WebGoat/registration`.
    Try to call it individually via `curl` to see whether there’s anything useful.
    If you do a `curl -vslk http://localhost:8080/WebGoat/register.mvc`, you’ll see
    something like the following. Part of the output was omitted for brevity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从该数据包中，你可以验证创建凭证的元素叫做`/WebGoat/register.mvc`，它是由`/WebGoat/registration`调用的。尝试通过`curl`单独调用它，看看是否有有用的信息。如果你运行`curl
    -vslk http://localhost:8080/WebGoat/register.mvc`，你将看到类似以下的内容。为了简洁起见，部分输出已被省略。
- en: '![Figure 3.5 – WebGoat’s register.mvc element throwing an error message](img/B19657_03_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – WebGoat 的 register.mvc 元素抛出错误信息](img/B19657_03_05.jpg)'
- en: Figure 3.5 – WebGoat’s register.mvc element throwing an error message
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – WebGoat 的 register.mvc 元素抛出错误信息
- en: 'The `curl` utility uses the `GET` HTTP verb by default. We just discovered
    that this element does not support the `GET` verb and it simply threw a very informative
    error message, saying (for example) that the application runs with the Spring
    framework. Even one of the affected source code files and its line are provided:
    `RequestMappingInfoHandler.java`, line `253`! You could have acquired this information
    via a web browser too, but getting used to `curl` is important. That was nice
    for a start, but WebGoat is not exactly the best tool to help us dive into an
    API’s internals. crAPI is a better candidate.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 工具默认使用 `GET` HTTP 动词。我们刚刚发现，这个元素不支持 `GET` 动词，它只是抛出了一个非常有信息量的错误信息，提示（例如）应用程序使用了
    Spring 框架。甚至还提供了其中一个受影响的源代码文件及其行号：`RequestMappingInfoHandler.java`，第`253`行！你也可以通过浏览器获取这些信息，但熟悉使用
    `curl` 非常重要。虽然这是一个不错的开始，但 WebGoat 并不是一个特别适合我们深入了解 API 内部的工具。crAPI 是更好的选择。'
- en: Looking at crAPI
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 crAPI
- en: crAPI is an intentionally vulnerable application with a RESTful API that was
    created to facilitate exploring OWASP’s API Security Top 10 threats ([https://owasp.org/API-Security/](https://owasp.org/API-Security/)).
    The year when this book was being written coincided with the latest release of
    the API Security Top 10 project. Another tool like crAPI is Juice Shop ([https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)),
    written in JavaScript.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: crAPI 是一个有意设计为易受攻击的应用程序，提供 RESTful API，旨在帮助探索 OWASP 的 API 安全十大威胁（[https://owasp.org/API-Security/](https://owasp.org/API-Security/)）。在编写本书的同时，恰逢
    API 安全十大项目的最新发布。另一个像 crAPI 的工具是 Juice Shop（[https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)），它是用
    JavaScript 编写的。
- en: 'As soon as you finish running crAPI’s Docker Compose file, you can open the
    application by accessing `http://localhost:8888/`. You will be redirected to the
    `/login` path. This doesn’t necessarily mean at first that you are dealing with
    a RESTful API. Being redirected to another path simply means that the application
    either recognized that you are not authenticated yet or sent you to the correct
    page in case you have tried to open an obsolete component. The command is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成运行 crAPI 的 Docker Compose 文件后，可以通过访问`http://localhost:8888/`来打开应用程序。你将被重定向到`/login`路径。这并不一定意味着你正在处理一个
    RESTful API。被重定向到另一个路径仅仅意味着应用程序识别到你尚未认证，或者在你尝试打开一个过时的组件时，将你重定向到正确的页面。命令如下：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The backward compatibility flag was implemented with the new version of Docker
    Compose. Support for the previous version was ended in June 2023\. More information
    can be found at [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容标志已在新版 Docker Compose 中实现。对先前版本的支持已于2023年6月结束。更多信息请参考[https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/)。
- en: 'As it is a container-based application, you will leverage the advantage of
    not having to manually download all the components. When Compose finishes downloading
    images, creating volumes and environment variables, and defining limits, you will
    have the following containers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是基于容器的应用程序，你将利用无需手动下载所有组件的优势。当 Compose 完成下载镜像、创建卷和环境变量以及定义限制后，你将看到以下容器：
- en: '| **Container name** | **Container image** | **Purpose** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **容器名称** | **容器镜像** | **用途** |'
- en: '| `api.mypremiumdealership.com` | gateway-service | The vulnerable API |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `api.mypremiumdealership.com` | gateway-service | 脆弱的 API |'
- en: '| `crapi-community` | Same name | Community blogs |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `crapi-community` | 同名 | 社区博客 |'
- en: '| `crapi-identity` | Same name | Authentication endpoint |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `crapi-identity` | 同名 | 身份验证端点 |'
- en: '| `crapi-web` | Same name | The web UI |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `crapi-web` | 同名 | Web UI |'
- en: '| `crapi-workshop` | Same name | Car workshop |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `crapi-workshop` | 同名 | 汽车维修车间 |'
- en: '| `mailhog` | Same name | Mail service |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `mailhog` | 同名 | 邮件服务 |'
- en: '| `mongodb` | mongo | Self-explanatory |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `mongodb` | mongo | 不言自明 |'
- en: '| `postgresdb` | postgres | Self-explanatory |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `postgresdb` | postgres | 不言自明 |'
- en: Table 3.1 – crAPI’s containers and images and their purposes
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – crAPI 的容器和镜像及其用途
- en: 'crAPI implements a website for vehicle owners to search, find, and request
    maintenance for their cars, while also exposing a RESTful API to facilitate such
    tasks. I’m assuming that you have already installed either ZAP or Burp Suite,
    as per the previous chapter. We will use ZAP here. The first crAPI page is a sign
    in/sign up dialog box:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: crAPI 实现了一个网站，供车辆所有者搜索、查找并请求汽车维修，同时暴露了一个 RESTful API 以便完成这些任务。我假设你已经按照前一章节的内容安装了
    ZAP 或 Burp Suite。我们这里将使用 ZAP。第一个 crAPI 页面是一个登录/注册对话框：
- en: '![Figure 3.6 – crAPI’s login page](img/B19657_03_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – crAPI 的登录页面](img/B19657_03_06.jpg)'
- en: Figure 3.6 – crAPI’s login page
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – crAPI 的登录页面
- en: 'You can play with the signup page a bit by providing special characters in
    the username or email address fields. You can even provide an invalid phone number
    (the frontend logic only checks whether the contents are not null), which I did,
    and see the results on ZAP. I left the phone number empty and tried to sign up.
    The response is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在用户名或邮箱地址字段中输入特殊字符来稍微测试一下注册页面。你甚至可以输入一个无效的电话号码（前端逻辑仅检查内容是否非空），我就这么做了，并在
    ZAP 上查看结果。我将电话号码留空并尝试注册，响应如下：
- en: '![Figure 3.7 – An invalid sign-up page revealing details on the app’s backend](img/B19657_03_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 无效的注册页面，揭示应用后端的详细信息](img/B19657_03_07.jpg)'
- en: Figure 3.7 – An invalid sign-up page revealing details on the app’s backend
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 无效的注册页面，揭示应用后端的详细信息
- en: 'On the very first interaction with the web application, without even crafting
    a special request, we discovered that it runs the Spring Framework, which means
    that we are dealing with a backend running on top of Java. Cool! Now let’s fill
    in the form as a car owner and log in. The response provides a bearer token:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Web 应用程序的首次互动中，甚至没有构造特殊请求，我们就发现它运行在 Spring 框架上，这意味着我们正在处理一个基于 Java 的后端。太酷了！现在让我们填写表单，作为车主登录。响应提供了一个持有者令牌：
- en: '![Figure 3.8 – The response of a valid login action, providing the corresponding
    bearer token](img/B19657_03_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 有效登录操作的响应，提供相应的持有者令牌](img/B19657_03_08.jpg)'
- en: Figure 3.8 – The response of a valid login action, providing the corresponding
    bearer token
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 有效登录操作的响应，提供相应的持有者令牌
- en: Let’s proceed by adding a dummy vehicle. We will verify that more information
    about the application and the API endpoints will be revealed. When adding a vehicle,
    you need the PIN and the VIN, which are provided in an email sent to the address
    you entered when signing up. Simply open another browser tab and go to `http://localhost:8025`
    to access the Mailhog service. You will find the message there. The simple fact
    of logging in and clicking the corresponding button to add a vehicle reveals more
    API endpoints. Observe the series of figures that follows to know more. In the
    first one, you can see the response to a successful login.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加一辆虚拟车辆。我们将验证更多关于应用程序和 API 端点的信息将被揭示。当添加车辆时，你需要输入 PIN 和 VIN，这些信息会通过你注册时输入的邮箱地址发送到你的邮箱。只需打开另一个浏览器标签页并访问
    `http://localhost:8025` 来访问 Mailhog 服务。你会在那儿找到邮件。仅仅登录并点击相应的按钮添加车辆就能揭示更多 API 端点。观察接下来的一系列图像，了解更多信息。在第一个图像中，你可以看到成功登录后的响应。
- en: '![Figure 3.9 – The /api/v2/user endpoint after logging in](img/B19657_03_09.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 登录后 /api/v2/user 端点](img/B19657_03_09.jpg)'
- en: Figure 3.9 – The /api/v2/user endpoint after logging in
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 登录后 /api/v2/user 端点
- en: The following is the sort of response you will get after adding a vehicle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是添加车辆后你将收到的响应类型。
- en: '![Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add
    a vehicle](img/B19657_03_10.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 点击添加车辆按钮后的 /api/v2/vehicle 端点](img/B19657_03_10.jpg)'
- en: Figure 3.10 – The /api/v2/vehicle endpoint after clicking the button to add
    a vehicle
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 点击添加车辆按钮后的 /api/v2/vehicle 端点
- en: Finally, after correctly adding a vehicle, you will receive a screen like this
    one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在成功添加车辆后，你将看到如下屏幕。
- en: '![Figure 3.11 – The random vehicle has been added](img/B19657_03_11.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 随机车辆已被添加](img/B19657_03_11.jpg)'
- en: Figure 3.11 – The random vehicle has been added
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 随机车辆已被添加
- en: 'When a vehicle is added, the application assigns an UUID to it, as we can confirm
    by checking the response of the `/``api/v2/vehicle/vehicles` invocation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当一辆车被添加时，应用会为其分配一个UUID，我们可以通过检查 `/api/v2/vehicle/vehicles` 调用的响应来确认这一点：
- en: '![Figure 3.12 – The UUID generated as part of adding a vehicle](img/B19657_03_12.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 添加车辆时生成的UUID](img/B19657_03_12.jpg)'
- en: Figure 3.12 – The UUID generated as part of adding a vehicle
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 添加车辆时生成的UUID
- en: Location data is also informed. Pay attention to this fact as it will be quite
    useful. You can play with the web UI a bit but check what happens with the response
    when you enter the **Community** section. This represents a sort of forum where
    vehicle owners can comment on or ask for help. The problem is that *all* owners’
    posts have their corresponding vehicle IDs! It’s obviously not advisable to disclose
    data when it’s not strictly necessary, which is the case here. Why would some
    well-intentioned person want to know the vehicle ID of another person?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 位置数据也已提供。请注意这一点，它将非常有用。你可以稍微操作一下网页 UI，但在进入**社区**部分时，观察一下响应发生了什么变化。这部分类似于一个论坛，车主们可以在这里发表评论或寻求帮助。问题在于，*所有*车主的帖子都包含他们相应的车辆ID！显然，除非绝对必要，否则不建议公开这些数据，而这里正是如此。那么，为什么有些好心的人会想知道其他人的车辆ID呢？
- en: '![Figure 3.13 – Other vehicle IDs are disclosed in the Community section of
    the application](img/B19657_03_13.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 其他车辆ID在应用的社区部分被公开](img/B19657_03_13.jpg)'
- en: Figure 3.13 – Other vehicle IDs are disclosed in the Community section of the
    application
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 其他车辆ID在应用的社区部分被公开
- en: 'The `/api/v2/vehicle` endpoint has an option to provide the vehicle’s UUID
    and then specify the `location` keyword to obtain the car’s latitude and longitude.
    What if we leverage the output in the preceding screenshot and try to do this
    with a vehicle that’s not ours? You can do this however you prefer, such as via
    ZAP itself, Postman, or even the command line with the help of `curl`, for example.
    However, remember to log in first, as all subsequent requests will require the
    authorization token that you can only get after successfully authenticating. Observe
    in *Figure 3**.13* that my vehicle’s ID ends with `5b0a`. I will try to get the
    location of a vehicle whose ID ends with `8e3f`. Using `curl`, the command would
    be (this is a single command line):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`/api/v2/vehicle` 端点提供了一个选项，可以提供车辆的UUID，并通过指定 `location` 关键字来获取车辆的经纬度。如果我们利用前面截图中的输出，尝试获取不是自己车辆的数据会怎样呢？你可以使用你喜欢的方式来实现，比如通过
    ZAP、Postman，甚至通过命令行配合 `curl`。不过，记得先登录，因为之后所有的请求都需要授权令牌，而该令牌只有在成功认证后才能获得。在*图 3.13*中可以看到，我的车辆ID以
    `5b0a` 结尾。我将尝试获取一辆ID以 `8e3f` 结尾的车辆的位置。使用 `curl` 时，命令将是（这是一个单行命令）：'
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bingo! Observe the following screenshot. This demonstrates the fragility of
    the API provided by crAPI. By simply providing a valid token, I can see the details
    of an asset belonging to a different username!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Bingo！观察以下截图。这展示了crAPI提供的API的脆弱性。只需提供有效的令牌，我就能查看属于不同用户名的资产的详细信息！
- en: '![Figure 3.14 – Obtaining another vehicle’s data](img/B19657_03_14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 获取另一辆车的数据](img/B19657_03_14.jpg)'
- en: Figure 3.14 – Obtaining another vehicle’s data
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 获取另一辆车的数据
- en: 'Congratulations! You just inadvertently accessed another user’s vehicle data,
    which corresponds to the first crAPI challenge: **Broken Object Level Authorization**
    (**BOLA**). Let’s see how else we can get information about APIs.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚不小心访问了另一个用户的车辆数据，这对应于第一个crAPI挑战：**破损的对象级别授权**（**BOLA**）。让我们看看如何通过其他方式获取API信息。
- en: Analyzing API documentation and endpoints
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析API文档和端点
- en: You can also acquire important information about APIs by carefully analyzing
    their documentation and the endpoints they expose. Even nowadays, some API endpoints
    are made available without **Transport Layer Security** (**TLS**), which shouldn’t
    at all be a habit that is adopted. For the sake of keeping backward compatibility,
    some vendors and application owners choose to leave such insecure connection points
    open. They are sometimes used by lower-performance devices, such as **Internet
    of Things** (**IoT**) Raspberry Pis, Arduino controllers, or even regular clients
    with not much computing power. That’s because TLS offloading might demand substantial
    processing depending on the number of needed simultaneous or subsequent connections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过仔细分析API的文档及其暴露的端点来获取重要信息。即使在今天，一些API端点仍未使用**传输层安全性**（**TLS**），这绝不应成为一种习惯。为了保持向后兼容性，一些供应商和应用程序所有者选择保持这些不安全的连接点开放。它们有时被低性能设备使用，例如**物联网**（**IoT**）树莓派、Arduino控制器，甚至是计算能力较弱的普通客户端。这是因为TLS卸载可能需要大量的处理能力，具体取决于所需的同时或后续连接数量。
- en: Aside from that, by analyzing documentation and endpoints, you can spot other
    potential attack vectors such as weak or no authentication and/or authorization
    mechanisms. For the purposes of analyzing API documentation, you can make use
    of some decent utilities, such as SwaggerUI ([https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui))
    and ReDoc ([https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)).
    Although originally conceived to build documentation for APIs that follow the
    OpenAPI specification ([https://www.openapis.org/](https://www.openapis.org/)),
    they can also be applied to analyze written docs. Considering the file that follows,
    replace the `<<<Put OpenAPI Link here>>>` placeholder with a link hosting an OpenAPI-like
    documentation YAML file. You can find websites on the APIs Guru’s website ([https://apis.guru/](https://apis.guru/));
    see *Figures 3.15* and *3.16*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，通过分析文档和端点，你还可以发现其他潜在的攻击向量，比如弱或没有身份验证和/或授权机制。为了分析API文档，你可以使用一些不错的工具，如SwaggerUI（[https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)）和ReDoc（[https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)）。尽管它们最初是为了构建遵循OpenAPI规范的API文档（[https://www.openapis.org/](https://www.openapis.org/)）而设计的，但它们也可以用于分析书面文档。考虑到后续的文件，将`<<<Put
    OpenAPI Link here>>>`占位符替换为托管OpenAPI类似文档YAML文件的链接。你可以在APIs Guru的网站上找到相关网站（[https://apis.guru/](https://apis.guru/)）；见*图3.15*和*图3.16*。
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can find part of the Fitbit’s API documentation here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到部分Fitbit的API文档：
- en: '![Figure 3.15 – Fitbit’s API documentation](img/B19657_03_15.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – Fitbit的API文档](img/B19657_03_15.jpg)'
- en: Figure 3.15 – Fitbit’s API documentation
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – Fitbit的API文档
- en: Here you can see the same but for Forex’s API. It is a screenshot of the documentation
    screen showing the response to a request.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到与外汇API相同的内容。这是文档屏幕的截图，显示了对请求的响应。
- en: '![Figure 3.16 – 1Forge Finance’s API documentation](img/B19657_03_16.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 1Forge Finance的API文档](img/B19657_03_16.jpg)'
- en: Figure 3.16 – 1Forge Finance’s API documentation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 1Forge Finance的API文档
- en: Observe that one of the first Fitbit items covers authentication, making use
    of the OAuth2 protocol. On the other hand, at first sight, 1Forge’s API does not
    provide any authentication whatsoever, at least not for those exposed services.
    As a matter of fact, it does provide this, but this is only correctly mentioned
    on their website. 1Forge also exposes pure HTTP endpoints. Leveraging that we
    just mentioned “exposed”, when you expand an item in the right pane of ReDoc,
    more information is given. In this case, we can see the websites we can leverage
    to interact with the API.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Fitbit的第一个条目涉及认证，使用了OAuth2协议。另一方面，乍一看，1Forge的API根本没有提供任何认证，至少对于那些暴露的服务是这样。事实上，它确实提供了认证，但这仅在他们的网站上得到了正确提及。1Forge还暴露了纯HTTP端点。利用我们刚刚提到的“暴露”，当你展开ReDoc右侧窗格中的一个条目时，会提供更多信息。在这种情况下，我们可以看到我们可以利用的网站来与API交互。
- en: 'Alternatively, to locally see a dummy OpenAPI specification, you can install
    ReDoc – or better yet, you can use its Docker version. I loaded the Docker version
    and set it to listen on the `8085` port (the default `8080` port was already being
    used either by ZAP or by another utility). This makes the dummy PetStore API documentation
    available for reading:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，要在本地查看一个虚拟的OpenAPI规范，你可以安装ReDoc——或者更好的是，使用它的Docker版本。我加载了Docker版本并设置监听`8085`端口（默认的`8080`端口已被ZAP或其他工具占用）。这样就可以访问虚拟的PetStore
    API文档进行阅读：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another purpose of verifying an API’s documentation is to check its request
    and response structures. By analyzing how they need to be crafted or how they
    are sent back to you, it’s possible to infer some more details about the API.
    For example, that leak of other vehicle owners’ data would possibly go unnoticed
    if you didn’t use a proxy or your browser’s inspector tool. Another example concerns
    user IDs. Some applications may be vulnerable to user ID profiling. If an API
    allows you to create a user, you can build a simple script to make two or three
    requests in sequence to create a small list of users. If the API gives back to
    you the users’ IDs as part of the response, and if such IDs are sequential, you
    know the API is vulnerable to this threat. With pure HTTP endpoints, the game
    is even better since you can capture all other users’ data (on a local network)
    by faking a proxy server.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 验证API文档的另一个目的，是检查其请求和响应的结构。通过分析它们需要如何构造，或如何发送回你，你可以推测出API的更多细节。例如，如果你没有使用代理或浏览器的检查工具，其他车辆所有者的数据泄露可能会被忽视。另一个例子是用户ID。一些应用程序可能容易受到用户ID剖析攻击。如果一个API允许你创建用户，你可以编写一个简单的脚本，连续发出两三次请求，创建一个小型用户列表。如果API在响应中返回了用户ID，并且这些ID是连续的，那么你就知道该API容易受到这种威胁。对于纯HTTP端点来说，情况更好，因为你可以通过伪造代理服务器在本地网络中捕获所有其他用户的数据。
- en: Recalling the HTTP RFC (link on the reference), we know that an HTTP request
    has headers and a body. A web application developer can use any or both when implementing
    the API. By double checking the RFC, we can reach the consensus that if the data
    being sent in a request *is* metadata, then the *header* is the best place to
    put them. If the data *is not* metadata, then the *body* should be used instead.
    Why am I telling you that? Public cloud providers log pretty much everything that
    comes and goes to their networks. However, web requests’ bodies may not be fully
    logged since they can contain customers’ sensitive data and allowing an unauthorized
    person (such as a cloud provider’s engineer) to have access to such logs would
    cause failure in security compliance and no providers want this for sure. Hence,
    when interacting with any API, pay very close attention to the API’s response
    bodies, as they may hold very valuable data that can be used later when preparing
    for an attack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾HTTP RFC（参考链接），我们知道HTTP请求有头部和正文。Web应用开发者在实现API时可以使用其中任何一个或两个部分。通过再次检查RFC，我们可以达成共识：如果请求中发送的数据*是*元数据，那么*头部*是存放这些数据的最佳位置。如果数据*不是*元数据，那么应该使用*正文*。我为什么要告诉你这些？公共云服务提供商几乎会记录所有进出其网络的数据。然而，Web请求的正文可能不会被完全记录，因为它们可能包含客户的敏感数据，允许未授权人员（如云服务提供商的工程师）访问这些日志会导致安全合规性失败，而没有任何提供商会愿意发生这种情况。因此，在与任何API交互时，要非常注意API的响应正文，因为它们可能包含在准备攻击时可以使用的非常宝贵的数据。
- en: Leveraging OSINT
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用OSINT
- en: OSINT is a market that has substantially grown in the last few years and has
    a continuous tendency to keep growing. According to a publicly available report,
    in 2022 the market size was 4.2 billion USD. It’s expected to reach 7.32 billion
    USD in 2031, which represents a 73.43% increase with a **Compound Annual Growth
    Rate** (**CAGR**) of about 6.31% in a nine-year period. That’s something that
    can’t go unnoticed. This market is comprised mostly of companies that build software
    and/or training to explore the corresponding research techniques.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: OSINT是近年来快速增长的一个市场，并且有持续增长的趋势。根据一份公开的报告，2022年该市场的规模为42亿美元，预计到2031年将达到73.2亿美元，增幅为73.43%，年复合增长率（**CAGR**）约为6.31%，为期九年。这是一个不可忽视的趋势。这个市场主要由构建软件和/或培训以探索相关研究技术的公司组成。
- en: 'If you have never heard about OSINT, I will summarize it for you. OSINT comprises
    a series of techniques for collecting and analyzing information that is publicly
    available. OSINT can be used to gather information about APIs in a variety of
    ways. For example, you can use OSINT to do the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未听说过OSINT，我来为你简要总结一下。OSINT包括一系列收集和分析公开信息的技术。OSINT可以用来通过多种方式收集关于API的信息。例如，你可以使用OSINT来做以下事情：
- en: Find information about APIs that are not documented by the provider.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找那些提供商未公开文档化的API信息。
- en: Identify new API endpoints that have been released.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别已发布的新API端点。
- en: Discover changes to existing API endpoints.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现现有API端点的变化。
- en: Find information about security vulnerabilities in APIs.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找关于API安全漏洞的信息。
- en: 'Some common OSINT resources for gathering information about APIs include the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的OSINT资源，用于收集关于API的信息，包括以下内容：
- en: '**Search engines**: Search engines can be used to find information about APIs
    that are not documented by the provider.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎**：搜索引擎可以用来查找那些提供商未公开文档化的API信息。'
- en: '**Social media**: Social media platforms such as X (previously known as Twitter)
    and GitHub can be used to find information about new API endpoints, changes to
    existing API endpoints, and security vulnerabilities in APIs.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体**：像X（前身为Twitter）和GitHub这样的社交媒体平台可以用来查找有关新API端点、现有API端点的变化以及API的安全漏洞信息。'
- en: '**Online forums**: Online forums such as Stack Overflow and Reddit can be used
    to find information about how to use APIs and to troubleshoot problems with APIs.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线论坛**：像Stack Overflow和Reddit这样的在线论坛可以用来查找如何使用API的信息，以及排除API问题。'
- en: 'OSINT can also be used for several other activities, such as watching or tracking
    individuals or companies, discovering information about assets besides API endpoints,
    such as servers, applications, externally available systems, locating buildings
    or facilities among others. I know that it looks scary, but as with most things
    in life, there are good and evil uses for this technology. There is a decent amount
    of free content about OSINT available on the internet, including lists of resources
    and tools. Among everything, I would not forget to mention the following ones:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: OSINT还可以用于其他几种活动，例如监视或跟踪个人或公司，发现关于API端点以外的资产信息，例如服务器、应用程序、外部可用系统，定位建筑物或设施等。我知道这看起来有些可怕，但就像生活中的大多数事情一样，这项技术有好的用途，也有不那么好的用途。互联网上有相当多免费的OSINT内容，包括资源和工具的列表。在所有资源中，我不会忘记提到以下几个：
- en: '**The OSINT framework** ([https://osintframework.com/](https://osintframework.com/)):
    This is an online catalog with a curated list of online resources categorized
    by type. Some of those are free, others allow you to test them, and still others
    are commercial.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OSINT框架** ([https://osintframework.com/](https://osintframework.com/)): 这是一个在线目录，列出了按类型分类的在线资源。一些资源是免费的，其他的允许你进行测试，还有一些是商业性质的。'
- en: '**Shodan** ([https://www.shodan.io/](https://www.shodan.io/)): This is a search
    service with a huge database of IoT devices, such as cameras, routers, and micro-controllers.
    Although it’s a paid service, it’s not rare to find good discounts on some dates,
    such as Black Friday.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shodan** ([https://www.shodan.io/](https://www.shodan.io/)): 这是一个搜索服务，拥有一个庞大的IoT设备数据库，例如摄像头、路由器和微控制器。虽然这是一个付费服务，但在一些日期（如黑色星期五）经常能找到不错的折扣。'
- en: '**The Google Hacking Database** ([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)):
    This is a compendium of Google dorks (specially crafted Google queries) that you
    can filter to show only the desired types of targets, including APIs.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google黑客数据库** ([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)):
    这是一个Google dorks（特别定制的Google查询）合集，你可以通过筛选只显示所需类型的目标，包括API。'
- en: '*Figures 3.17* and *3.18* show examples of what you can find when looking for
    API endpoints on Shodan. The service can disclose whether the endpoint has vulnerabilities,
    as well as what they are. Practical, right? They are usually related to the operating
    systems that support the servers, but the web service can also be listed as vulnerable,
    which would help with your pentesting tasks. The screenshots were captured after
    logging in to the service. The first one shows an API endpoint. The screenshots
    have been anonymized on purpose.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.17* 和 *图 3.18* 显示了在 Shodan 上查找 API 端点时可以找到的示例。该服务可以透露该端点是否存在漏洞，以及漏洞的类型。实用吧？这些漏洞通常与支持服务器的操作系统相关，但网页服务本身也可能列出为有漏洞，这有助于你的渗透测试任务。这些截图是在登录服务后截取的。第一张显示了一个
    API 端点。截图已故意匿名化。'
- en: '![Figure 3.17 – An Indonesian university with a potentially vulnerable API
    endpoint](img/B19657_03_17.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 一个可能存在漏洞的印尼大学 API 端点](img/B19657_03_17.jpg)'
- en: Figure 3.17 – An Indonesian university with a potentially vulnerable API endpoint
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 一个可能存在漏洞的印尼大学 API 端点
- en: The second one shows an Oracle server with an endpoint that is open to the world.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张显示了一个开放给全世界的 Oracle 服务器端点。
- en: '![Figure 3.18 – Simple API queries on Shodan](img/B19657_03_18.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – Shodan 上的简单 API 查询](img/B19657_03_18.jpg)'
- en: Figure 3.18 – Simple API queries on Shodan
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Shodan 上的简单 API 查询
- en: 'The service has a fair number of queries you can explore. Some of the most
    used ones follow:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务提供了很多查询供你探索。以下是一些最常用的查询：
- en: '`hostname:targetdomain.com`: This directs all queries to the target domain,
    which can also result in a hostname if the target uses an APEX domain name.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname:targetdomain.com`：将所有查询指向目标域名，如果目标使用 APEX 域名，也会返回主机名。'
- en: '`content-type:application/json` (or `xml`): The majority of APIs accept and
    return data either in JSON or in XML. When combined with a hostname, this keyword
    filters the results to contain the desired content type.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-type:application/json`（或 `xml`）：大多数 API 接受并返回 JSON 或 XML 格式的数据。结合主机名使用时，此关键词会将结果过滤为包含所需内容类型的项。'
- en: '`200 OK`: This corresponds to the successful HTTP status code. You can add
    this combined with other queries to return only the successful requests. If the
    target API does not accept Shodan queries, it may return HTTP codes of 300 or
    400.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`：这是成功的 HTTP 状态码。你可以将其与其他查询组合，返回仅包含成功请求的结果。如果目标 API 不接受 Shodan 查询，它可能会返回
    300 或 400 的 HTTP 状态码。'
- en: '`wp-json`: When querying target **Content Management Systems** (**CMSs**),
    such as Joomla or Drupal, this type of query may reveal the presence of one of
    them. This, in particular, corresponds to the WordPress REST API.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wp-json`：当查询目标 **内容管理系统**（**CMSs**），如 Joomla 或 Drupal 时，这种查询可能会揭示它们的存在。特别是，这与
    WordPress REST API 相关。'
- en: 'Let’s see what we can get with ExploitDB. If you search for the `API` term,
    the service will return a reasonable amount of Google dorks, a fair amount being
    `allintext`, `intitle`, and `inurl`. These represent searches for occurrences
    in the whole page’s content, in its title only, and in the URL’s name respectively.
    There are a few that deserve your attention:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过 ExploitDB 可以获得什么。如果你搜索 `API` 这个关键词，服务将返回相当数量的 Google dorks，其中包括 `allintext`、`intitle`
    和 `inurl` 等查询。这些分别表示在整页内容中、仅在标题中和在 URL 名称中查找出现的结果。以下是几个值得关注的例子：
- en: '`allintext:"API_SECRET*" ext:env | ext:yml`: Look for the string beginning
    with `API_SECRET` inside files whose extensions are either `.env` or `.yml`. This
    is useful since many configurations of applications store sensitive data, such
    as API keys, inside files with these extensions. An inattentive developer might
    have pushed them to a public repository. You can also get to know about versions
    of the implemented API. Old ones may have vulnerabilities.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allintext:"API_SECRET*" ext:env | ext:yml`：查找以 `API_SECRET` 开头的字符串，文件扩展名为
    `.env` 或 `.yml`。这非常有用，因为许多应用程序的配置文件会将敏感数据（如 API 密钥）存储在这些扩展名的文件中。一个不小心的开发者可能会将其推送到公共代码库。你还可以了解到实现的
    API 版本，旧版本可能存在漏洞。'
- en: '`intitle:"Index of /api/"`: You will find websites that list all the files
    inside their `/api` web directories. You can find very useful information here
    for websites that you wouldn’t even imagine were disclosing this.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intitle:"Index of /api/"`：你会找到列出其 `/api` 网页目录中所有文件的网站。在这里你可以找到非常有用的信息，甚至是一些你未曾想过会披露此类信息的网站。'
- en: '`inurl:execute-api site:amazonaws.com`: This lists all sites that have `execute-api`
    as part of their URLs. Sites like those are implemented by Amazon API Gateway,
    a public cloud service that exposes a layer before your actual web background.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inurl:execute-api site:amazonaws.com`：列出所有 URL 中包含 `execute-api` 的站点。此类站点由
    Amazon API Gateway 实现，这是一个公共云服务，在实际 Web 后台之前暴露一层。'
- en: We are not restricted to the Google search engine. Nowadays, we have online
    generative AI services that can give us a hand with OSINT as well. Once you build
    good prompts, I mean, good questions, you can acquire pretty much all of the desired
    information. These services are being optimized over time and receiving additional
    guardrails to protect companies and individuals against inadvertent data exposure
    or leakage. Nevertheless, I can’t guarantee that all data will be fully protected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不局限于 Google 搜索引擎。如今，我们有了在线生成式 AI 服务，也能帮助我们进行 OSINT。一旦你构建了好的提示，也就是好的问题，你几乎可以获得所有想要的信息。这些服务随着时间的推移不断优化，并加入了额外的保护措施，以防止公司和个人的无意数据暴露或泄露。然而，我不能保证所有数据都会得到完全保护。
- en: 'GitHub also has its dorks. Focused on specific file names, you can find relevant
    information about the API you are inspecting. The following is a small list of
    dorks that I got after asking such a generative AI service, organized by categories.
    You can mix and match them at will. The service didn’t want to give them to me
    at first, but as I said before, with the right prompts and some patience, you
    will make it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 也有它的 dorks。专注于特定的文件名，你可以找到关于你正在检查的 API 的相关信息。以下是我通过向某个生成式 AI 服务询问后得到的一些
    dorks，按类别组织。你可以随意混合和匹配它们。该服务最初不愿意给我这些，但正如我之前所说，通过正确的提示和一些耐心，你一定能够得到：
- en: 'Path-based dorks:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的 dorks：
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Language-specific dorks:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于语言的 dorks：
- en: '[PRE6]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Extension-based dorks:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于扩展名的 dorks：
- en: '[PRE7]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'User or organization-based dorks:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户或组织的 dorks：
- en: '[PRE8]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Size-based dorks:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于大小的 dorks：
- en: '[PRE9]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fork and stars dorks:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fork 和 stars dorks：
- en: '[PRE10]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Date-range dorks:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于日期范围的 dorks：
- en: '[PRE11]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'License-based dorks:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于许可证的 dorks：
- en: '[PRE12]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Text content dorks:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文本内容的 dorks：
- en: '[PRE13]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wildcard dorks:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符 dorks：
- en: '[PRE14]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some good keywords to reveal the presence of APIs’ sensitive data include the
    following:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些可以揭示 API 敏感数据存在的好关键词包括：
- en: '[PRE15]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Moving forward, we are going to learn more about the internal details of APIs
    by learning their data and schema structures.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过学习 API 的数据和架构结构，了解 API 的内部细节。
- en: Identifying data and schema structures
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别数据和架构结构
- en: We will end our chapter about API reconnaissance and enumeration by covering
    a subject as important as all the others. By successfully identifying an API’s
    data and schema structures, you can acquire even more information about the target.
    Once you have analyzed the API documentation and endpoints, you need to identify
    the data and schema structures that are used by the API. This information can
    be used to understand how the API works and to develop applications that interact
    with the API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结束关于 API 侦察和枚举的章节，讲解一个和其他所有内容一样重要的话题。通过成功识别 API 的数据和架构结构，你可以获得更多关于目标的信息。一旦你分析了
    API 文档和端点，你需要识别 API 使用的数据和架构结构。这些信息可以帮助你理解 API 如何工作，并开发与 API 交互的应用程序。
- en: The API documentation should provide information about the data and schema structures
    that are used by the API. However, you may need to analyze the API responses to
    get a complete understanding of the data and schema structures.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档应提供关于 API 使用的数据和架构结构的信息。然而，你可能需要分析 API 的响应，才能完整理解数据和架构结构。
- en: Some APIs return JSON structures, whereas others prefer to encode responses
    in XML before sending them to the requester. As a matter of fact, XML was the
    preferred data transport format for some years because of its flexibility and
    power. However, the drawback was derived from such advantages as well. The more
    complex an XML structure is, the more prone to attacks it is as well. Badly written
    XML interpreters may lead to unexpected application failures and worse, to data
    exposure or leakage.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 返回 JSON 结构，而其他的则倾向于在发送响应给请求者之前，将响应编码为 XML。事实上，XML 曾经是多年内首选的数据传输格式，因为它具有灵活性和强大功能。然而，这些优势也带来了缺点。XML
    结构越复杂，越容易受到攻击。写得不好的 XML 解析器可能导致应用程序意外崩溃，甚至更糟，导致数据暴露或泄漏。
- en: 'However, first, what are schemas? Like their counterpart in databases, API
    schemas are metadata used to define how data is structured inside the API. In
    other words, when requesting and receiving the responses of such requests, you
    can know in advance which components are expected and which data types they use.
    This is especially important for one operation in particular: *fuzzing*.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是首先，什么是架构？就像数据库中的架构一样，API架构是用于定义API内数据结构的元数据。换句话说，当请求和接收这些请求的响应时，你可以提前知道期望哪些组件，以及它们使用的数据类型。这对于某些操作特别重要：*模糊测试*。
- en: We haven’t talked about this up to this point yet, but in general terms, fuzzing
    consists of generating random sequences of characters that are used as input for
    different interactions with a system. In our case, the system is an API endpoint.
    After knowing its schema and data structures, you can test the API by sending,
    for example, symbols to a field that’s expecting a date, or letters to a field
    that carries quantity. Alternatively, you can refer to a structure, such as a
    list or array, that does not belong to the data structure, and they check the
    endpoint behavior. When it is well written, a fuzzing-proof application simply
    ignores the data and optionally throws warning or error messages stating that
    a corrupted entry was provided.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们还没有讨论过这个问题，但从一般意义上来说，模糊测试（fuzzing）是通过生成随机字符序列作为输入，进行不同的系统交互。在我们的例子中，系统是一个API端点。在了解其架构和数据结构后，你可以通过发送例如符号到期望日期的字段，或者字母到承载数量的字段来测试API。或者，你可以参考一个不属于数据结构的结构，比如列表或数组，然后检查端点的行为。当应用程序写得很好时，抗模糊测试的应用会简单地忽略这些数据，并可选择性地抛出警告或错误信息，说明提供了一个损坏的输入。
- en: 'Let’s do some exercises. Leveraging our crAPI deployment and Postman, let’s
    make a few requests and verify their responses. crAPI expects JSON as input and
    returns a JSON structure as a response. crAPI already provides a handy collection
    of Postman requests in its repository. Let’s see what happens when we send something
    different from JSON. First, we need to log in to get an authorization token. This
    is our initial test. Let’s replace the JSON portion with, let’s say, an XML format:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做些练习。利用我们的crAPI部署和Postman，发送几个请求并验证其响应。crAPI期望输入为JSON，并返回一个JSON结构的响应。crAPI已经在其仓库中提供了一个方便的Postman请求集合。让我们看看当我们发送与JSON不同的内容时会发生什么。首先，我们需要登录以获取授权令牌。这是我们的初步测试。让我们把JSON部分换成，比如说，XML格式：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `{{email}}` and `{{password}}` annotations are conventions Postman uses
    to refer to variables. I have created variables in my Postman collection to store
    my login and password, so I don’t have to type them every time I need to log in.
    I did the same with the authorization token. Well, in this initial test, crAPI
    returned nothing at all. Let’s move on and log in the right way, with a JSON data
    structure as input. We just received the token.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{email}}` 和 `{{password}}` 注释是Postman用来表示变量的约定。我在我的Postman集合中创建了变量来存储我的登录名和密码，这样每次需要登录时就不必重新输入。我对授权令牌做了同样的处理。那么，在这个初步测试中，crAPI根本没有返回任何内容。让我们继续进行，并以正确的方式登录，输入一个JSON数据结构。我们刚刚收到了令牌。'
- en: 'There’s another endpoint that is accessed with a POST verb. It’s called `Signup
    example.com`. It expects the following as the request body:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个端点是通过POST方法访问的。它叫做 `Signup example.com`。它期望请求体包含以下内容：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you send the expected formats, such as the email address and a numeric
    sequence as the phone number, the API responds with the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发送期望的格式，比如电子邮件地址和作为电话号码的数字序列时，API会做出如下响应：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, what if we send something slightly different, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们发送一些稍微不同的内容，比如这样：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It seems that crAPI does validate the input somehow, but not exactly in a good
    way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来crAPI确实在某种程度上验证了输入，但不是以一种很好的方式：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We discovered a few things with this simple test:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的测试，我们发现了几件事：
- en: crAPI definitely uses some flavor of Java as its backend.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: crAPI肯定使用了一些Java的变种作为其后端。
- en: Email and phone are somehow validated, but errors look like exceptions.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱和电话在某种程度上是经过验证的，但错误看起来像是异常。
- en: The maximum length of the phone number is 15 characters.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码的最大长度为15个字符。
- en: 'When you verify the log of the identity container, you’ll find the following
    exceptions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你验证身份容器的日志时，你会发现以下异常：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we have finished our chapter on API reconnaissance and information
    gathering.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经完成了关于API侦察和信息收集的章节。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered important topics on your journey toward pentesting APIs.
    You learned that you must begin by gathering information about the target and
    reconning it. After correctly identifying and enumerating the API, you learned
    that you must read its documentation carefully and find out which endpoints it
    exposes. This may reveal valuable information, as you learned. Additionally, you
    learned that you can make use of an extremely useful set of techniques called
    OSINT, which are extensively applied everywhere by forensic investigators and
    enthusiasts. The chapter finished with a complementary section about how API data
    and schema structures are important in this phase.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了你在进行 API 渗透测试过程中必须了解的重要主题。你学到的第一步是必须从收集目标的信息和进行侦查开始。在正确识别并枚举 API 后，你学会了必须仔细阅读其文档，找出它公开的端点。这可能会揭示出有价值的信息，正如你所学到的。此外，你还学会了可以利用一组非常有用的技术，称为
    OSINT，这些技术被法医调查人员和爱好者广泛应用。章节最后有一部分补充内容，介绍了 API 数据和架构结构在这一阶段的重要性。
- en: In the next chapter, you will learn how to explore the authentication and authorization
    stages more while pentesting an API. This chapter included some introduction to
    that topic, but we’ll go into greater depth in the next one with analysis and
    more tests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何在进行 API 渗透测试时，更深入地探索身份验证和授权阶段。本章简要介绍了这一话题，但我们将在下一章深入分析并进行更多测试。
- en: Further reading
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The VirtualBox type 2 hypervisor: [https://www.virtualbox.org/](https://www.virtualbox.org/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'VirtualBox 类型 2 虚拟机管理程序: [https://www.virtualbox.org/](https://www.virtualbox.org/)'
- en: 'The UTM type 2 hypervisor: [https://mac.getutm.app/](https://mac.getutm.app/)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'UTM 类型 2 虚拟机管理程序: [https://mac.getutm.app/](https://mac.getutm.app/)'
- en: 'Podman, a superset of Docker: [https://podman.io/](https://podman.io/)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Podman，Docker 的超集: [https://podman.io/](https://podman.io/)'
- en: 'The OWASP WebGoat vulnerable web app: [https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OWASP WebGoat 漏洞 Web 应用程序: [https://owasp.org/www-project-webgoat/](https://owasp.org/www-project-webgoat/)'
- en: 'The OWASP crAPI vulnerable API: [https://owasp.org/www-project-crapi/](https://owasp.org/www-project-crapi/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OWASP crAPI 漏洞 API: [https://owasp.org/www-project-crapi/](https://owasp.org/www-project-crapi/)'
- en: 'The Zed Attack Proxy scanner: [https://www.zaproxy.org/](https://www.zaproxy.org/)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zed Attack Proxy 扫描器: [https://www.zaproxy.org/](https://www.zaproxy.org/)'
- en: 'Shodan, an IoT vulnerability search engine: [https://www.shodan.io/](https://www.shodan.io/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Shodan，一个物联网漏洞搜索引擎: [https://www.shodan.io/](https://www.shodan.io/)'
- en: 'Fiddler, a network analysis tool: [https://www.telerik.com/fiddler/fiddler-everywhere](https://www.telerik.com/fiddler/fiddler-everywhere)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fiddler，一个网络分析工具: [https://www.telerik.com/fiddler/fiddler-everywhere](https://www.telerik.com/fiddler/fiddler-everywhere)'
- en: 'Wireshark, one of the most famous network packet capture tools: [https://www.wireshark.org/](https://www.wireshark.org/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Wireshark，最著名的网络数据包捕获工具之一: [https://www.wireshark.org/](https://www.wireshark.org/)'
- en: 'APIs Guru, a decent list of APIs’ documentation: [https://apis.guru/](https://apis.guru/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'APIs Guru，一个不错的 API 文档列表: [https://apis.guru/](https://apis.guru/)'
- en: 'ReDoc, utility to build and read API documentation: [https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ReDoc，构建和阅读 API 文档的工具: [https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)'
- en: 'Swagger UI, utility to build and read API documentation: [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Swagger UI，构建和阅读 API 文档的工具: [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)'
- en: 'The RFC establishing the HTTP Specification: [https://datatracker.ietf.org/doc/html/rfc2616#page-31](https://datatracker.ietf.org/doc/html/rfc2616#page-31)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '建立 HTTP 规范的 RFC: [https://datatracker.ietf.org/doc/html/rfc2616#page-31](https://datatracker.ietf.org/doc/html/rfc2616#page-31)'
- en: 'A report discussing the OSINT growing market: [https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546](https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '讨论 OSINT 市场增长的报告: [https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546](https://www.businessresearchinsights.com/market-reports/open-source-intelligence-market-109546)'
- en: 'ExploitDB Google Dorks, a list with OSINT cheat sheets: [https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ExploitDB Google Dorks，一个包含 OSINT 小抄的列表: [https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)'
- en: 'The OSINT Framework, a vast list of tools and resources about OSINT: [https://osintframework.com/](https://osintframework.com/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OSINT 框架，一个关于 OSINT 的工具和资源广泛列表: [https://osintframework.com/](https://osintframework.com/)'
- en: 'Google dork cheat sheet, more resources on OSINT: [https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055](https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Dork备忘单，更多关于OSINT的资源：[https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055](https://gist.github.com/ikuamike/c2611b171d64b823c1c1956129cbc055)
- en: 'crAPI Postman collections to help automate crAPI requests: [https://github.com/OWASP/crAPI/tree/develop/postman_collections](https://github.com/OWASP/crAPI/tree/develop/postman_collections)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于自动化crAPI请求的crAPI Postman集合：[https://github.com/OWASP/crAPI/tree/develop/postman_collections](https://github.com/OWASP/crAPI/tree/develop/postman_collections)
