- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Inspecting Process Injection and API Hooking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查进程注入和 API 挂钩
- en: In this chapter, we are going to explore more advanced techniques that are used
    by malware authors for various reasons, including bypassing firewalls, tricking
    reverse engineers, and monitoring and collecting user information in order to
    steal credit card data and for other purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索恶意软件作者为多种目的使用的更高级技术，包括绕过防火墙、欺骗逆向工程师、以及监视和收集用户信息以窃取信用卡数据等。
- en: We will be diving into various process injection techniques, including DLL injection
    and process hollowing (an advanced technique that was introduced by Stuxnet),
    and explain how to deal with them. Later, we will look at API hooking, IAT hooking,
    and other hooking techniques that are used by malware authors and how to handle
    them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨各种进程注入技术，包括 DLL 注入和进程空洞（由 Stuxnet 引入的高级技术），并解释如何处理这些技术。随后，我们将了解 API 挂钩、IAT
    挂钩以及恶意软件作者使用的其他挂钩技术，并讲解如何应对它们。
- en: By the end of this chapter, you will have extended your knowledge of the Windows
    platform and be able to analyze more complex malware. You will learn how to analyze
    injected code inside other processes, detect it through memory forensics, detect
    different types of API hooking techniques, and analyze them to detect **Man-in-the-Browser**
    (**MiTB**) attacks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拓展你对 Windows 平台的知识，并能够分析更复杂的恶意软件。你将学习如何分析其他进程中的注入代码，通过内存取证检测它，检测不同类型的
    API 挂钩技术，并分析它们以检测**浏览器中人攻击**（**MiTB**）。
- en: 'To make the learning process seamless, this chapter is divided into the following
    main sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使学习过程更加顺利，本章分为以下几个主要部分：
- en: Understanding process injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进程注入
- en: DLL injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DLL 注入
- en: Diving deeper into process injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入地了解进程注入
- en: A dynamic analysis of code injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码注入的动态分析
- en: Memory forensics techniques for process injection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程注入的内存取证技术
- en: Understanding API hooking
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 API 挂钩
- en: Exploring IAT hooking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 IAT 挂钩
- en: Understanding process injection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程注入
- en: Process injection is one of the most well-known techniques malware authors use
    to bypass firewalls, perform memory forensics techniques, and slow down inexperienced
    reverse engineers by adding malicious functionality into legitimate processes
    and hiding it this way. In this section, we will cover the theory behind process
    injection and why it is commonly used in various **Advanced Persistent Threat**
    (**APT**) attacks nowadays.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 进程注入是恶意软件作者用来绕过防火墙、执行内存取证技术、以及通过将恶意功能添加到合法进程中并以此方式隐藏来拖慢经验不足的逆向工程师的其中一种最著名的技术。在本节中，我们将介绍进程注入背后的原理，以及为什么它在如今的**高级持续性威胁**（**APT**）攻击中被广泛使用。
- en: What’s process injection?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是进程注入？
- en: In the Windows OS, processes are allowed to allocate memory, read and write
    in another process’s virtual address space, as well as create new threads, suspend
    threads, and change these threads’ registers, including the `explorer.exe` or
    into other users’ processes. However, it’s still OK to inject code into the current
    user’s browsers and other processes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统中，进程被允许在另一个进程的虚拟地址空间中分配内存、读取和写入数据，还可以创建新线程、挂起线程并更改这些线程的寄存器，包括`explorer.exe`或其他用户的进程。然而，将代码注入到当前用户的浏览器和其他进程中仍然是可以的。
- en: This technique is legitimately used by multiple endpoint security products to
    monitor applications and for sandboxing purposes (as we will see in the *Understanding
    API hooking* section), but it’s also commonly misused by malware authors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术被多个终端安全产品合法使用，用于监控应用程序和沙盒目的（正如我们将在*理解 API 挂钩*一节中看到的那样），但也常常被恶意软件作者滥用。
- en: Why process injection?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用进程注入？
- en: 'For malware authors, process injection helps them to do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于恶意软件作者而言，进程注入有助于他们实现以下目标：
- en: Bypass trivial firewalls that block internet connections from all applications
    except browsers or other allowed apps. By injecting code into one of these applications,
    malware can communicate with the **Command and Control** (**C&C**) server without
    any warning or being blocked by the firewall.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过简单的防火墙，这些防火墙只允许浏览器或其他允许的应用程序连接互联网。通过将代码注入这些应用程序之一，恶意软件可以在没有任何警告或被防火墙阻止的情况下与**指挥与控制**（**C&C**）服务器进行通信。
- en: Evade debuggers and other dynamic analysis or monitoring tools by running the
    malicious code inside another unmonitored and not debugged process.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在另一个未监控且未调试的进程中运行恶意代码，避开调试器和其他动态分析或监控工具。
- en: Hook APIs in the legitimate process that the malware injected its code into,
    which can give unique control over the victim process’s behavior.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恶意软件将代码注入的合法进程中钩取 API，这可以对受害者进程的行为进行独特控制。
- en: Maintain persistence for fileless malware. By injecting its code into a background
    process, malware can maintain persistence on a server that rarely gets rebooted
    without leaving its executable on a hard disk.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为无文件恶意软件维持持久性。通过将代码注入到后台进程中，恶意软件可以在几乎不重启的服务器上保持持久性，而不在硬盘上留下可执行文件。
- en: 'Now, we will dive deeper into various process injection techniques, how they
    work, and how to deal with them. We will start with the most simple, straightforward
    technique: DLL injection.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨各种进程注入技术，了解它们的工作原理以及如何应对这些技术。我们将从最简单、最直接的技术开始：DLL 注入。
- en: DLL injection
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DLL 注入
- en: The Windows OS allows processes to load DLLs into other processes for security
    reasons, sandboxing, or even graphics. In this section, we will explore the legitimate,
    straightforward ways to inject a DLL into a process, as well as the other techniques
    that allow attackers to inject code into a process using Windows APIs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统允许进程将 DLL 加载到其他进程中，出于安全原因、沙箱隔离或甚至图形处理。在本节中，我们将探讨合法的、直接的将 DLL 注入进程的方法，以及其他允许攻击者使用
    Windows API 将代码注入进程的技术。
- en: Windows-supported DLL injection
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 支持的 DLL 注入
- en: 'Windows has provided special registry entries for DLLs to be loaded within
    every process that meets certain criteria. Many of them allow the malware DLL
    to be injected into multiple processes at the same time, including browsers and
    other legitimate processes. There are many of these registry entries available,
    but we will explore the most common ones here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 为符合特定条件的每个进程提供了特殊的注册表项，以便加载 DLL。许多注册表项允许恶意软件 DLL 同时注入到多个进程中，包括浏览器和其他合法进程。这些注册表项有很多，我们将在这里探讨最常见的几个：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This registry entry was among the most misused registry entries by malware to
    inject DLL code into other processes and maintain persistence. The libraries specified
    here are loaded together with every process that loads `user32.dll` (the system
    library used mainly for the UI).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是恶意软件最常误用的注册表项之一，用来将 DLL 代码注入到其他进程中并维持持久性。此处指定的库与每个加载 `user32.dll`（主要用于 UI
    的系统库）的进程一起加载。
- en: 'In Windows 7, DLLs are required to be signed, and this logic is disabled by
    default for Windows 8 and beyond. However, it still can be misused by setting
    the `RequireSignedAppInit_DLLs` value to `False` and the `LoadAppInit_DLLs` value
    to `True` (see the following screenshot). Attackers require administrative privileges
    to be able to set these entries, which can be resolved, for example, with the
    help of social engineering:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 7 中，DLL 必须签名，默认情况下此逻辑在 Windows 8 及更高版本中被禁用。然而，攻击者仍然可以通过将 `RequireSignedAppInit_DLLs`
    设置为 `False`，并将 `LoadAppInit_DLLs` 设置为 `True` 来滥用这一点（请参见下面的截图）。攻击者需要管理员权限才能设置这些条目，可以通过社交工程等手段解决这一问题：
- en: '![Figure 5.1 – Using the AppInit_DLLs registry entry to inject the malware
    library into diﬀerent browsers'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 使用 AppInit_DLLs 注册表项将恶意软件库注入不同的浏览器'
- en: '](img/Figure_5.1_B18500.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B18500.jpg)'
- en: Figure 5.1 – Using the AppInit_DLLs registry entry to inject the malware library
    into diﬀerent browsers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用 AppInit_DLLs 注册表项将恶意软件库注入不同的浏览器
- en: 'Now, let’s move to the next commonly misused registry key:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '现在， let’s move to the next commonly misused registry key:'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The libraries listed in this registry entry are loaded into each process that
    uses at least one of the following functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该注册表项中列出的库会被加载到使用以下任一函数的每个进程中：
- en: '`CreateProcess`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateProcess`'
- en: '`CreateProcessAsUser`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateProcessAsUser`'
- en: '`CreateProcessWithLogonW`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateProcessWithLogonW`'
- en: '`CreateProcessWithTokenW`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateProcessWithTokenW`'
- en: '`WinExec`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WinExec`'
- en: 'This allows the malware to be injected into most browsers (as many of them
    create child processes to manage different tabs) and other applications as well.
    It still requires administrative privileges since `HKEY_LOCAL_MACHINE` is not
    writable for normal users on a Windows machine (Vista and above):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得恶意软件可以注入到大多数浏览器中（因为许多浏览器会创建子进程来管理不同的标签页）以及其他应用程序。它仍然需要管理员权限，因为 `HKEY_LOCAL_MACHINE`
    对普通用户在 Windows 系统上是不可写的（Vista 及更高版本）：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This path loads a shell extension (a DLL file) in order to add additional features
    to the main Windows shell (`explorer.exe`). Basically, it can be misused to load
    the malware library as an extension to `explorer.exe`. This path can be easily
    created and modified without any administrative privileges.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该路径加载一个 shell 扩展（一个 DLL 文件），以便为主 Windows shell（`explorer.exe`）添加附加功能。基本上，它可以被滥用来将恶意库加载为
    `explorer.exe` 的扩展。此路径可以轻松创建和修改，而无需任何管理员权限。
- en: 'There are other registry entries available that can inject the malware library
    into other processes, as well as multiple software solutions, such as **Autoruns**
    by Sysinternals, which allow you to see whether any of these registry entries
    have been exploited for malicious use on the current system:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他注册表项可以将恶意库注入到其他进程中，以及多个软件解决方案，例如 Sysinternals 的 **Autoruns**，可以让你查看是否有任何这些注册表项被用于当前系统的恶意用途：
- en: '![Figure 5.2 – The Autoruns application in the Sysinternals Suite'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – Sysinternals 套件中的 Autoruns 应用程序'
- en: '](img/Figure_5.2_B18500.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B18500.jpg)'
- en: Figure 5.2 – The Autoruns application in the Sysinternals Suite
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Sysinternals 套件中的 Autoruns 应用程序
- en: These are some of the most common legitimate ways that malware can inject its
    DLLs into different processes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是恶意软件最常用的合法方式，用来将 DLL 注入到不同的进程中。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: It is worth mentioning that many resources call this technique DLL hijacking
    and track it separately from classic process injection, as in this case attackers
    rely on the OS to perform the actual injection, rather than doing it themselves.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，许多资源称这种技术为 DLL 劫持，并将其与经典的进程注入分开追踪，因为在这种情况下，攻击者依赖操作系统来执行实际的注入，而不是自己进行注入。
- en: Now, we will explore the more advanced techniques that require the use of different
    Windows APIs to allocate, write, and execute malicious code inside other processes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探索更高级的技术，这些技术需要使用不同的 Windows API 来分配、写入并执行恶意代码在其他进程中。
- en: A simple DLL injection technique
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种简单的 DLL 注入技术
- en: 'This technique uses the `LoadLibraryA` API (or its other flavors) as a way
    to load a malicious library using the Windows PE loader and execute its entry
    point. The main goal is to inject the path of the malicious DLL into the process,
    then transfer control into that process with the address of the `LoadLibraryA`
    API as the start address. When passing the DLL path as an argument to that thread
    (which is passed to the `LoadLibraryA` API), the Windows PE loader will load that
    DLL into the process and execute its code flawlessly. Here is how the result memory
    will look:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术使用 `LoadLibraryA` API（或其其他变体）作为通过 Windows PE 加载器加载恶意库并执行其入口点的方式。主要目标是将恶意
    DLL 的路径注入到进程中，然后将控制权转交给该进程，启动地址为 `LoadLibraryA` API 的地址。当将 DLL 路径作为参数传递给该线程（该参数传递给
    `LoadLibraryA` API）时，Windows PE 加载器会将 DLL 加载到进程中并无误地执行其代码。以下是结果内存的样子：
- en: '![Figure 5.3 – A simple DLL injection mechanism'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 一个简单的 DLL 注入机制'
- en: '](img/Figure_5.3_B18500.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B18500.jpg)'
- en: Figure 5.3 – A simple DLL injection mechanism
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 一个简单的 DLL 注入机制
- en: 'The exact steps the malware generally follows are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常遵循的确切步骤如下：
- en: Find the victim process among other processes (more details in the following
    section).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他进程中找到目标进程（更多细节见下节）。
- en: Get this process’s handle using the `OpenProcess` API as an identifier to pass
    to other APIs.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OpenProcess` API 获取该进程的句柄，作为标识符传递给其他 API。
- en: Allocate a space in that process’s virtual memory using `VirtualAllocEx`, `VirtualAllocExNuma`,
    `NtAllocateVirtualMemory`, or similar APIs. This space will be used to write the
    full path of the malicious DLL file. Another option would be to use `CreateFileMapping`
    -> `MapViewOfFile` or `CreateSectionEx` -> `NtCreateSection` APIs to prepare the
    space.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `VirtualAllocEx`、`VirtualAllocExNuma`、`NtAllocateVirtualMemory` 或类似的 API，在该进程的虚拟内存中分配一个空间。这个空间将用于写入恶意
    DLL 文件的完整路径。另一种选择是使用 `CreateFileMapping` -> `MapViewOfFile` 或 `CreateSectionEx`
    -> `NtCreateSection` API 来准备该空间。
- en: Write a path of the malware DLL to the process using APIs such as `WriteProcessMemory`,
    `NtWriteVirtualMemory`, `NtWow64WriteVirtualMemory64`, or with the help of `NtMapViewOfSection`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `WriteProcessMemory`、`NtWriteVirtualMemory`、`NtWow64WriteVirtualMemory64`
    等 API，或者借助 `NtMapViewOfSection`，将恶意 DLL 的路径写入进程中。
- en: Load and execute this DLL using APIs such as `CreateRemoteThread` / `NtCreateThreadEx`,
    `SuspendThread` -> `SetThreadContext` -> `ResumeThread`, `QueueUserAPC` / `NtQueueApcThread`,
    or even `SetWindowHookEx`, providing the `LoadLibraryA` address as the start address,
    and the address of the DLL path as an argument.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用诸如`CreateRemoteThread` / `NtCreateThreadEx`、`SuspendThread` -> `SetThreadContext`
    -> `ResumeThread`、`QueueUserAPC` / `NtQueueApcThread`，甚至`SetWindowHookEx`等 API
    加载并执行此 DLL，提供`LoadLibraryA`地址作为起始地址，DLL 路径的地址作为参数。
- en: Alternative APIs with similar functionality can also be used, for example, the
    undocumented `RtlCreateUserThread` API instead of `CreateRemoteThread`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用具有类似功能的替代 API，例如，使用未记录的`RtlCreateUserThread` API替代`CreateRemoteThread`。
- en: This technique is simple compared to the techniques that we will cover in the
    following sections. However, this technique leaves traces of the malicious DLL
    in the process information. Any simple tool such as `LoadLibraryA`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将在接下来的章节中介绍的技术相比，这种技术相对简单。然而，该技术会在进程信息中留下恶意 DLL 的痕迹。任何简单的工具，例如`LoadLibraryA`，都可以检测到这一点。
- en: In the next section, we will dig deeper and cover more advanced techniques.
    They still rely on the APIs we described earlier, but they include more steps
    to make process injection successful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨并介绍更多高级技术。它们仍然依赖于我们之前描述的 API，但包括更多步骤，以确保进程注入的成功。
- en: Diving deeper into process injection
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究进程注入
- en: In this section, we will cover the intermediate to advanced techniques of process
    injection. These techniques leave no trace on a disk and can enable fileless malware
    to maintain persistence. Before we cover these techniques, let’s talk about how
    the malware finds the process that it wants to inject into – in particular, how
    it gets the list of the running processes with their names and **Process IDs**
    (**PIDs**).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍进程注入的中级到高级技术。这些技术不会在磁盘上留下痕迹，可以使无文件恶意软件保持持久性。在介绍这些技术之前，我们先讨论恶意软件如何找到它想要注入的进程——特别是，它是如何获取正在运行的进程列表，包括它们的名称和**进程
    ID**（**PID**）。
- en: Finding the victim process
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找目标进程
- en: 'For malware to get a list of the running processes, the following steps are
    generally followed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让恶意软件获取正在运行的进程列表，通常会执行以下步骤：
- en: Create a snapshot of all the processes running at that moment. This snapshot
    contains information about all running processes, their names, PIDs, and other
    important information. It can be acquired using the `CreateToolhelp32Snapshot`
    API. Usually, it is executed when `TH32CS_SNAPPROCESS` is given as an argument
    (to take a snapshot of the running processes, not threads or loaded libraries).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建当前所有正在运行的进程快照。该快照包含关于所有运行进程的信息，包括它们的名称、PID 和其他重要信息。可以通过`CreateToolhelp32Snapshot`
    API获取此快照。通常，当`TH32CS_SNAPPROCESS`作为参数传递时（用于获取正在运行的进程的快照，而不是线程或已加载的库）。
- en: Get the first process in this list using the `Process32First` API. This API
    gets the first process in the snapshot and starts the iteration over the list
    of processes.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Process32First` API获取列表中的第一个进程。此 API 获取快照中的第一个进程，并开始对进程列表进行迭代。
- en: 'Loop on the `Process32Next` API to get each process in the list, one by one,
    with its name and PID, as shown in the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环调用`Process32Next` API，依次获取列表中的每个进程，包括其名称和 PID，如下图所示：
- en: '![Figure 5.4 – Process searching using CreateToolhelp32Snapshot'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 使用CreateToolhelp32Snapshot进行进程搜索'
- en: '](img/Figure_5.4_B18500.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B18500.jpg)'
- en: Figure 5.4 – Process searching using CreateToolhelp32Snapshot
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 使用CreateToolhelp32Snapshot进行进程搜索
- en: Once the desired process has been found, the malware then goes to the next phase
    by executing the `OpenProcess` API with the process’s PID, as we learned in the
    previous section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到目标进程，恶意软件就进入下一阶段，通过执行`OpenProcess` API，并传入进程的 PID，就像我们在上一节中学到的那样。
- en: Code block injection
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码块注入
- en: This technique is quite similar to DLL injection. The difference here is actually
    in the executed code inside the target process. In this technique, the malware
    injects a piece of assembly code (as an array of bytes) and transfers control
    to it directly. This piece of code is position-independent. It has the ability
    to load its own import table, access its own data, and execute all of the malicious
    activities inside the targeted process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术与 DLL 注入非常相似。这里的区别实际上在于目标进程内部执行的代码。在这种技术中，恶意软件注入一段汇编代码（作为字节数组），并直接将控制权转交给它。这段代码是位置无关的。它具有加载自己的导入表、访问自己的数据，并在目标进程内执行所有恶意活动的能力。
- en: 'The steps that the malware follows for these code injection techniques are
    pretty much the same as the previous ones:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件执行这些代码注入技术的步骤与前面的步骤几乎相同：
- en: Search for the targeted process (in *Figure 5.4*, malware skips other processes
    by their PIDs).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索目标进程（在*图 5.4*中，恶意软件通过 PID 跳过其他进程）。
- en: Get this process’s handle or some other identifier.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取该进程的句柄或其他标识符。
- en: Prepare the memory inside this process for the size of the whole piece of the
    malicious code to be injected (see the `VirtualAllocEx` call in *Figure 5.5*).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个进程的内存准备好足够的空间，以容纳将要注入的整个恶意代码（请参见*图 5.5*中的`VirtualAllocEx`调用）。
- en: Copy that code into the targeted process (see the `WriteIntoProcessMemory` function
    in *Figure 5.5*).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这段代码复制到目标进程中（请参见*图 5.5*中的`WriteIntoProcessMemory`函数）。
- en: Transfer control to this code in the victim process’s address space (see the
    `CreateRemoteThreadFunc` routine in *Figure 5.5*).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制权转移到受害进程地址空间中的这段代码（请参见*图 5.5*中的`CreateRemoteThreadFunc`例程）。
- en: Some malware gives the name or the PID of the malware process to this injected
    code so that it can terminate the malware (and possibly delete its file and all
    of its traces) to ensure there’s no clear evidence of the malware’s existence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件会将恶意软件进程的名称或 PID 传递给这段注入的代码，以便它能终止恶意软件（并可能删除其文件及所有痕迹），以确保没有恶意软件存在的明确证据。
- en: 'In the following screenshot, we can see an example of a typical code injection:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们可以看到典型的代码注入示例：
- en: '![Figure 5.5 – A code injection example'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 代码注入示例'
- en: '](img/Figure_5.5_B18500.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B18500.jpg)'
- en: Figure 5.5 – A code injection example
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 代码注入示例
- en: It’s very similar to the DLL injection with regards to the steps that were used
    for process injection, but most of the hard work is in this piece of the assembly
    code. We will dive deeper into this type of position-independent, PE-independent
    code (that is, shellcode) in [*Chapter 8*](B18500_08.xhtml#_idTextAnchor811),
    *Handling Exploits and Shellcode*. We will explain how it finds its own place
    in memory, how it accesses the APIs, and how it performs malicious tasks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 DLL 注入在进程注入步骤上非常相似，但大部分繁重的工作都在这一段汇编代码中。我们将在[*第 8 章*](B18500_08.xhtml#_idTextAnchor811)
    *处理漏洞和 Shellcode* 中深入探讨这种位置独立、PE 独立的代码（即 Shellcode）。我们将解释它如何找到自己在内存中的位置，如何访问 API，以及如何执行恶意任务。
- en: Reflective DLL injection
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射式 DLL 注入
- en: In this case, instead of injecting a code block, malware injects the whole DLL
    into the targeted process’s memory, but this time, reading it directly from its
    memory rather than from a disk. In this case, the loader will be responsible for
    loading this payload, manually doing the job of the Windows loader.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，恶意软件不是注入代码块，而是将整个 DLL 注入到目标进程的内存中，但这次是直接从内存中读取，而不是从磁盘中读取。在这种情况下，加载程序将负责加载此负载，手动完成
    Windows 加载程序的工作。
- en: 'First, malware prepares memory with the size of `ImageBase` and follows the
    PE loading steps, including importing table loading and fixing the relocation
    entries (in the relocation table, as we learned about in [*Chapter 3*](B18500_03.xhtml#_idTextAnchor084),
    *Basic Static and Dynamic Analysis for x86/x64*), as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件准备与 `ImageBase` 大小相同的内存，并按照 PE 加载步骤执行，包括导入表加载和修复重定位条目（在重定位表中，如我们在[*第
    3 章*](B18500_03.xhtml#_idTextAnchor084) *x86/x64 基本静态与动态分析* 中所学到的），如以下截图所示：
- en: '![Figure 5.6 – The PE loading process in shellcode'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – Shellcode 中的 PE 加载过程'
- en: '](img/Figure_5.6_B18500.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B18500.jpg)'
- en: Figure 5.6 – The PE loading process in shellcode
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Shellcode 中的 PE 加载过程
- en: As we can see here, each section is copied individually in the `LoopOnSections`
    loop with the help of the `memcpy` function. This technique looks similar in terms
    of results to DLL injection, but it doesn’t require the malicious DLL to be stored
    on the hard disk and it doesn’t leave the usual traces of this DLL inside the
    **Process Environment Block** (**PEB**). So, memory forensics applications that
    only rely on PEB to detect DLLs wouldn’t be able to detect this loaded DLL in
    the memory. More details can be found in the *Memory forensics techniques for
    process injection* section later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，利用`memcpy`函数的帮助，每个部分在`LoopOnSections`循环中被单独复制。这个技术在结果上与 DLL 注入类似，但它不需要恶意
    DLL 存储在硬盘上，也不会在**进程环境块**（**PEB**）中留下 DLL 的常见痕迹。因此，只依赖 PEB 来检测 DLL 的内存取证应用程序将无法检测到加载在内存中的这个
    DLL。更多细节可以在后面*内存取证技术与进程注入*部分中找到。
- en: Stuxnet secret technique – process hollowing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stuxnet 秘密技术 – 进程空洞化
- en: '**Hollow process injection** (**process hollowing**) is an advanced technique
    that was introduced in Stuxnet malware before it became popular in the APT attacks
    domain. Process hollowing is simply a matter of removing the targeted process’s
    PE memory image from its virtual memory and replacing it with the malware executable
    file.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**空心进程注入**（**process hollowing**）是一种高级技术，它在Stuxnet恶意软件中首次出现，然后在APT攻击领域广泛传播。空心进程注入的基本原理是将目标进程的PE内存镜像从其虚拟内存中移除，并用恶意软件的可执行文件替换它。'
- en: For example, the malware creates a new process of, let’s say, `svchost.exe`.
    After the process is created and the PE file of `svchost` is loaded, the malware
    removes the loaded `svchost` PE file from its memory and then loads the malware-executable
    PE file in the same place and continues execution. See the following code examples
    for more information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，恶意软件创建了一个新的进程，比如`svchost.exe`。在进程创建并加载了`svchost`的PE文件之后，恶意软件从内存中移除已加载的`svchost`
    PE文件，然后在相同的位置加载恶意软件可执行文件的PE文件并继续执行。更多信息请参见以下代码示例。
- en: This mechanism completely disguises the malware executable in a legitimate coat
    as the PEB and the equivalent `EPROCESS` object still holds information about
    the legitimate process. This helps malware to bypass firewalls and memory forensics
    tools.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制完全将恶意软件可执行文件伪装成一个合法的外衣，因为PEB和等同的`EPROCESS`对象仍然保存有关合法进程的信息。这有助于恶意软件绕过防火墙和内存取证工具。
- en: 'The process of this form of code injection is quite different from the previous
    ones. Here are the steps that the malware has to take in order to do this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的代码注入过程与之前的有所不同。以下是恶意软件为了实现这一点所需执行的步骤：
- en: 'Create a legitimate process in the suspended mode, which creates the process
    and its first thread, but doesn’t start it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在挂起模式下创建一个合法进程，该进程创建进程及其第一个线程，但不会启动它：
- en: '![Figure 5.7 – Creating a process in suspended mode'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 在挂起模式下创建进程'
- en: '](img/Figure_5.7_B18500.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B18500.jpg)'
- en: Figure 5.7 – Creating a process in suspended mode
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 在挂起模式下创建进程
- en: Unload the legitimate application’s memory image using `VirtualFreeEx` (hollowing
    out the process).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VirtualFreeEx`卸载合法应用程序的内存镜像（实现进程空心化）。
- en: Allocate the same space in memory (the same as the unloaded PE image) for the
    malware PE image (APIs such as `VirtualAllocEx` allow the malware to choose the
    preferred address to be allocated if it’s free).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内存中分配与卸载的PE镜像相同的空间（例如，使用`VirtualAllocEx`等API允许恶意软件选择一个空闲的首选地址进行分配）。
- en: Inject the malware executable into that space by loading the PE file and fixing
    its import table (resolving its relocation table if needed).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过加载PE文件并修复其导入表（如果需要，解决其重定位表），将恶意软件可执行文件注入该空间。
- en: 'Change the thread’s starting point to the malware’s entry point using the `SetThreadContext`
    API. The `GetThreadContext` API allows the malware to get all the registers’ values,
    thread state, and all of the necessary information for the thread to be resumed
    after this, whereas the `SetThreadContext` API allows the malware to change these
    values, including the EIP/RIP register (instruction pointer), so that it can set
    it to the new entry point. The last step is to resume this suspended thread to
    execute the malware from that point:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetThreadContext` API将线程的起始点更改为恶意软件的入口点。`GetThreadContext` API允许恶意软件获取所有寄存器的值、线程状态以及恢复线程所需的所有信息，而`SetThreadContext`
    API允许恶意软件更改这些值，包括EIP/RIP寄存器（指令指针），使其指向新的入口点。最后一步是恢复该挂起线程，从该点执行恶意软件：
- en: '![Figure 5.8 – SetThreadContext and ResumeThread'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – `SetThreadContext` 和 `ResumeThread`'
- en: '](img/Figure_5.8_B18500.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B18500.jpg)'
- en: Figure 5.8 – SetThreadContext and ResumeThread
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – `SetThreadContext` 和 `ResumeThread`
- en: This is the most well-known technique of process hollowing. There are also similar
    techniques that don’t unload the actual process and include both the malware and
    the legitimate application executables together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最著名的空心进程注入技术。还有类似的技术，它们不卸载实际进程，而是将恶意软件和合法应用程序的可执行文件一起包括在内。
- en: Now, we will have a look at how we can extract the injected code and analyze
    it in our dynamic analysis process or in our memory forensics process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何在我们的动态分析过程或内存取证过程中提取注入的代码并进行分析。
- en: A dynamic analysis of code injection
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码注入的动态分析
- en: The dynamic analysis of process injection is quite tricky. The malware escapes
    the debugged process into another one in order to run the shellcode or load the
    DLL. Here are some tricks that may help you to debug the injected code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 进程注入的动态分析相当棘手。恶意软件会从调试的进程中逃逸，转而在另一个进程中运行 shellcode 或加载 DLL。以下是一些可能帮助你调试注入代码的技巧。
- en: Technique 1 – Debug it where it is
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧 1 – 在当前位置调试
- en: The first technique, which is preferred by many engineers, is not to allow the
    malware to inject the shellcode but rather to debug the shellcode in the malware’s
    memory as if it were already injected. Generally, the malware injects its shellcode
    inside another process and executes it from a specific point in that shellcode.
    We can locate that shellcode inside the malware’s binary (or memory if it gets
    decrypted) and just set the EIP/RIP register (**New origin here** in **OllyDbg**)
    to this shellcode’s entry point and continue the execution from there. This allows
    us to execute the shellcode inside a debugged process and even bypass some checks
    for the name of the process that this shellcode is supposed to run in.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个技巧，许多工程师首选的技巧，是不允许恶意软件注入 shellcode，而是将 shellcode 在恶意软件的内存中调试，仿佛它已经被注入。通常，恶意软件会将其
    shellcode 注入另一个进程并从该 shellcode 的特定位置执行。我们可以在恶意软件的二进制文件中（或者如果被解密，可以在内存中）找到该 shellcode，并将
    EIP/RIP 寄存器 (**OllyDbg 中的 New origin here**) 设置为该 shellcode 的入口点，然后从那里继续执行。这使得我们能够在调试的进程中执行
    shellcode，甚至绕过一些检查，这些检查是用于检查该 shellcode 应该在哪个进程中运行的。
- en: 'The steps to perform this technique are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此技术的步骤如下：
- en: Once the malware calls APIs such as `VirtualAllocEx` to prepare space for the
    shellcode in the targeted process memory, save the returned address of that allocated
    space (let’s say the returned address was `0x300000`).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦恶意软件调用诸如 `VirtualAllocEx` 等 API 为目标进程的内存准备 shellcode 空间，保存该分配空间的返回地址（假设返回地址为
    `0x300000`）。
- en: Set a breakpoint on memory writing APIs such as `WriteProcessMemory` and, once
    it triggers, save the source and the destination addresses. The source address
    is the address of that shellcode inside the malware process’s memory (let’s say
    `0x450000`) and the destination will probably be the returned address from `VirtualAllocEx`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内存写入 API 上设置断点，如 `WriteProcessMemory`，一旦触发，保存源地址和目标地址。源地址是恶意进程内 shellcode 在内存中的地址（假设是
    `0x450000`），目标地址可能是 `VirtualAllocEx` 返回的地址。
- en: Now, set a breakpoint on the control transfer APIs such as `CreateRemoteThread`
    and get the entry point (and the arguments, if there are any) of that shellcode
    in the targeted process (let’s say it will be `0x30012F`).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在控制转移 API 上设置一个断点，比如 `CreateRemoteThread`，并获取目标进程中该 shellcode 的入口点（如果有参数，也要获取参数）（假设入口点是
    `0x30012F`）。
- en: Now, calculate the entry point’s address inside the malware process’s memory,
    which will be `0x30012F` - `0x300000` + `0x450000` = `0x45012F` in this case.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算恶意进程内 shellcode 入口点的地址，假设在此案例中为 `0x30012F` - `0x300000` + `0x450000` =
    `0x45012F`。
- en: If a virtual machine is used for debugging (which is definitely recommended),
    save a snapshot and then set the EIP value to the shellcode’s entry point (`0x45012F`),
    set any necessary arguments, and continue debugging from there.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用虚拟机进行调试（强烈推荐），首先保存一个快照，然后将 EIP 值设置为 shellcode 的入口点（`0x45012F`），设置任何必要的参数，并从那里继续调试。
- en: This technique is very simple and easy to debug and handle. However, it only
    works with simple shellcodes and doesn’t work properly with multiple injections
    (multiple calls of `WriteProcessMemory`), process hollowing, or with complicated
    arguments. It needs cautious debugging afterward in order to not receive bugs
    or errors from having this shellcode running in a process that’s different from
    what it was intended to be executed in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧非常简单，调试和处理起来也很容易。然而，它仅适用于简单的 shellcode，且不适用于多重注入（多次调用 `WriteProcessMemory`）、进程空洞技术或复杂参数。之后需要小心调试，以避免由于
    shellcode 在与预期不同的进程中运行而导致错误或漏洞。
- en: Technique 2 – Attach to the targeted process
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧 2 – 附加到目标进程
- en: 'Another simple solution is to attach to the targeted process before the malware
    executes `CreateRemoteThread` or to modify the `CreateRemoteThread` creation flags
    to `CREATE_SUSPENDED`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的解决方案是在恶意软件执行 `CreateRemoteThread` 之前附加到目标进程，或者修改 `CreateRemoteThread`
    的创建标志为 `CREATE_SUSPENDED`，如以下所示：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To be able to do so, we need to know the targeted process that the malware will
    inject into. This means that we need to set breakpoints on the `Process32First`
    and `Process32Next` APIs and analyze the code in between searching for the APIs,
    such as `strcmp` or equivalent code, to find the required process to inject into.
    Not all calls are just for process injection; for example, they can also be used
    as an anti-reverse engineering trick, as we will see in [*Chapter 6*](B18500_06.xhtml#_idTextAnchor554),
    *Bypassing Anti-Reverse Engineering Techniques*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够做到这一点，我们需要知道恶意软件将注入的目标进程。这意味着我们需要在`Process32First`和`Process32Next`这两个API上设置断点，并分析搜索API的代码，如`strcmp`或等效代码，以找到要注入的目标进程。并非所有的调用都是为了进程注入；例如，它们也可以作为反逆向工程的技巧，正如我们将在[*第6章*](B18500_06.xhtml#_idTextAnchor554)中看到的那样，*绕过反逆向工程技术*。
- en: Technique 3 – Dealing with process hollowing
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术 3 – 处理进程空洞化
- en: Unfortunately, the previous two techniques don’t work with process hollowing.
    In process hollowing, the malware creates a new process in a suspended state,
    which makes it unseen by OllyDbg and similar debuggers. Therefore, it’s hard to
    attach to them before the malware resumes the process and the malicious code gets
    executed, undebugged, and unmonitored.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前两种技术在进程空洞化（process hollowing）中不起作用。在进程空洞化中，恶意软件创建了一个处于挂起状态的新进程，这使得OllyDbg和类似的调试器无法检测到它。因此，在恶意软件恢复进程并执行恶意代码之前，很难附加到它们，因为此时恶意代码已经未调试且未监控地执行了。
- en: 'As we already mentioned, in process hollowing, the malware hollows out the
    legitimate application PE image and loads the malicious PE image inside the targeted
    process memory. The simplest way to deal with this is to set a breakpoint on memory
    writing APIs, such as `WriteProcessMemory`, and dump the PE file before it’s loaded
    into the targeted process memory. Once the breakpoint is triggered, follow the
    source argument of `WriteProcessMemory`, and scroll up until the start of the
    PE file is found (usually, it can be recognized by the `MZ` signature and common
    `This program cannot run in DOS mode` text, which is shown in the following screenshot):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在进程空洞化中，恶意软件将合法的应用程序PE镜像空洞化，并将恶意PE镜像加载到目标进程内存中。处理此问题的最简单方法是设置在内存写入API（如`WriteProcessMemory`）上的断点，在PE文件加载到目标进程内存之前将其转储。一旦断点触发，跟踪`WriteProcessMemory`的源参数，并向上滚动直到找到PE文件的起始位置（通常可以通过`MZ`签名和常见的`This
    program cannot run in DOS mode`文本识别，如以下屏幕截图所示）：
- en: '![Figure 5.9 – A PE ﬁle in a hex dump in OllyDbg'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9 – 在OllyDbg中的PE文件十六进制转储'
- en: '](img/Figure_5.9_B18500.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B18500.jpg)'
- en: Figure 5.9 – A PE ﬁle in a hex dump in OllyDbg
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 在OllyDbg中的PE文件十六进制转储
- en: Some malware families use `CreateSection` and `MapViewOfSection` instead of
    `WriteProcessMemory`. These two APIs, as we described earlier, create a memory
    object that we can write the malicious executable into. This memory object can
    also be mapped to another process as well. So, after the malware writes the malicious
    PE image to the memory object, it maps it into the targeted process and then uses
    APIs such as `CreateRemoteThread` to start the execution from its entry point.
    In this case, we can set a breakpoint on `MapViewOfSection` to get the returned
    address of the mapped memory object (before the malware writes any data to this
    memory object).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件家族使用`CreateSection`和`MapViewOfSection`代替`WriteProcessMemory`。正如我们之前描述的，这两个API创建了一个内存对象，恶意可执行文件可以写入其中。这个内存对象也可以映射到另一个进程中。所以，在恶意软件将恶意PE镜像写入内存对象后，它将其映射到目标进程中，然后使用如`CreateRemoteThread`等API从其入口点开始执行。在这种情况下，我们可以在`MapViewOfSection`上设置断点，以获取映射内存对象的返回地址（在恶意软件写入任何数据之前）。
- en: Now, it is possible to set a breakpoint-on-write to this returned address in
    order to catch any writing operation to this memory object (writing to this memory
    object is equivalent to `WriteProcessMemory`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以设置一个写入断点，监视写入到此返回地址的任何操作（写入此内存对象等同于`WriteProcessMemory`）。
- en: Once your breakpoint-on-write hits, we can find what data is getting written
    to this memory object (most probably a PE file in the case of process hollowing)
    and the source of the data that contains all the PE files that are unloaded, so
    that we can easily dump it to the disk and load it into the debugger as if it
    were injected into another process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的断点触发，我们就能找出写入到该内存对象的数据（在进程空洞化的情况下，这很可能是一个PE文件）以及数据的来源，它包含了所有已卸载的PE文件，这样我们就可以轻松地将其转储到磁盘，并将其加载到调试器中，就像它被注入到另一个进程一样。
- en: This technique, in brief, is all about finding the PE file before it gets loaded
    and dumping it as a normal executable file. Once we get it, we get the second
    stage payload. Now, all we need to do is debug it in the debugger or analyze it
    statically.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这项技术就是在文件加载之前找到 PE 文件并将其作为普通可执行文件转储。一旦获取到文件，我们就得到了第二阶段的有效载荷。现在，我们只需要在调试器中调试它或对其进行静态分析。
- en: Now, we will take a look at how to detect and dump the injected code (or injected
    PE file) from a memory dump using a memory forensics tool called **Volatility**,
    which may get even more complicated than dealing with process injection using
    dynamic analysis.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用一款名为 **Volatility** 的内存取证工具，从内存转储中检测和转储注入的代码（或注入的 PE 文件）。这可能比使用动态分析处理进程注入更加复杂。
- en: Memory forensics techniques for process injection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程注入的内存取证技术
- en: Since one of the main reasons to use process injection is to hide malware presence
    from memory forensics tools, it gets quite tricky to detect it using them. In
    this section, we will take a look at different techniques that we can use to detect
    different types of process injections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用进程注入的主要原因之一是为了隐藏恶意软件在内存取证工具中的存在，使用这些工具进行检测变得相当棘手。在本节中，我们将看看可以使用哪些不同的技术来检测不同类型的进程注入。
- en: Here, we will be using a tool called **Volatility**. This tool is a free, open
    source program for memory forensics that can analyze memory dumps from infected
    machines. So, let’s get started.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一个名为 **Volatility** 的工具。这个工具是一个免费的开源内存取证程序，能够分析受感染机器的内存转储。那么，让我们开始吧。
- en: Technique 1 – Detecting code injection and reflective DLL injection
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧 1 – 检测代码注入和反射式 DLL 注入
- en: 'The main red flag that helps us to detect injected code inside a process is
    that the allocated memory that contains the shellcode or the loaded DLL always
    has the `EXECUTE` permission and doesn’t represent a mapped file. When a module
    (an executable file) gets loaded using the Windows PE loader, it gets loaded with
    an `IMAGE` flag to represent that it’s a memory map of an executable file. But
    when this memory page is allocated normally using `VirtualAlloc`, it gets allocated
    with a `PRIVATE` flag to show that it is allocated for data:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检测进程中注入代码的主要红旗是，包含 shellcode 或加载的 DLL 的分配内存总是具有 `EXECUTE` 权限，并且不代表映射文件。当一个模块（可执行文件）通过
    Windows PE 加载器加载时，它会被加载并带有 `IMAGE` 标志，以表示它是一个可执行文件的内存映射。但是，当这个内存页面正常通过 `VirtualAlloc`
    分配时，它会被分配为 `PRIVATE` 标志，以表示它是为数据分配的：
- en: '![Figure 5.10 – An OllyDbg memory map window (the loaded image memory chunk
    and private memory chunk)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10 – 一个 OllyDbg 内存映射窗口（加载的映像内存块和私有内存块）'
- en: '](img/Figure_5.10_B18500.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B18500.jpg)'
- en: Figure 5.10 – An OllyDbg memory map window (the loaded image memory chunk and
    private memory chunk)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 一个 OllyDbg 内存映射窗口（加载的映像内存块和私有内存块）
- en: It’s not common to see private allocated memory with the `EXECUTE` permission,
    and it’s also not common (as most shellcode injections do) to have the `WRITE`
    permission with the `EXECUTE` permission (`READ_WRITE_EXECUTE`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 私有分配内存具有 `EXECUTE` 权限并不常见，通常也不常见（如大多数 shellcode 注入所做的那样）拥有 `WRITE` 权限和 `EXECUTE`
    权限（`READ_WRITE_EXECUTE`）。
- en: 'In Volatility, there is a command called `malfind`. This command finds hidden
    and injected code inside a process (or an entire system). This command can be
    executed (given the image name and the OS version) with a PID as an argument if
    the scan for a specific process is required, or without a PID in order to scan
    an entire system, as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Volatility 中，有一个名为 `malfind` 的命令。该命令可以在进程（或整个系统）中查找隐藏的和注入的代码。执行该命令时（给定镜像名称和操作系统版本），如果需要扫描特定进程，可以使用
    PID 作为参数；如果不指定 PID，则会扫描整个系统，如下图所示：
- en: '![Figure 5.11 – The malﬁnd command in Volatility detects a PE ﬁle (by the MZ
    header)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – Volatility 中的 malfind 命令检测到一个 PE 文件（通过 MZ 头部）'
- en: '](img/Figure_5.11_B18500.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B18500.jpg)'
- en: Figure 5.11 – The malﬁnd command in Volatility detects a PE ﬁle (by the MZ header)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – Volatility 中的 malfind 命令检测到一个 PE 文件（通过 MZ 头部）
- en: As we can see, the `malfind` command detected an injected PE file (by the MZ
    header) inside an Adobe Reader process at the address `0x003d0000`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`malfind` 命令在 Adobe Reader 进程中通过 MZ 头部检测到了一个注入的 PE 文件，地址为 `0x003d0000`。
- en: 'Now, we can dump all memory images inside this process using the `vaddump`
    command. This command dumps all the memory regions inside the process, following
    the `EPROCESS` kernel object for that process and its virtual memory map (and
    its equivalent physical memory pages), using what are called `vaddump` will dump
    all of the memory regions into a separate file, as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `vaddump` 命令转储此进程中的所有内存镜像。该命令会转储进程内部的所有内存区域，遵循该进程的 `EPROCESS` 内核对象及其虚拟内存映射（以及等效的物理内存页）。`vaddump`
    将把所有内存区域转储到一个单独的文件中，如下图所示：
- en: '![Figure 5.12 – Dumping the 0x003d000 address using the vaddump command in
    Volatility'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 使用 Volatility 中的 `vaddump` 命令转储 0x003d000 地址'
- en: '](img/Figure_5.12_B18500.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B18500.jpg)'
- en: Figure 5.12 – Dumping the 0x003d000 address using the vaddump command in Volatility
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用 Volatility 中的 `vaddump` 命令转储 0x003d000 地址
- en: 'For injected PE files, we can dump them to the disk (and reconstruct their
    headers and sections back, but not import the tables) using `dlldump` instead
    of `vaddump`, as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注入的 PE 文件，我们可以使用 `dlldump` 而不是 `vaddump` 将其转储到磁盘（并重建其头部和节，但不重建导入表），如下图所示：
- en: '![Figure 5.13 – Using dlldump given the PID and ImageBase of the DLL as --base'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – 使用 `dlldump` 给定 PID 和 DLL 的 ImageBase 作为 --base'
- en: '](img/Figure_5.13_B18500.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B18500.jpg)'
- en: Figure 5.13 – Using dlldump given the PID and ImageBase of the DLL as --base
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 使用 `dlldump` 给定 PID 和 DLL 的 ImageBase 作为 --base
- en: After that, we will have a memory dump of the malware PE file (or shellcode)
    to scan and analyze. It’s not a perfect dump, but we can scan it with the `strings`
    tool or perform static analysis on it. We may need to fix the addresses of the
    import table manually by patching these addresses in the debugger and dumping
    them again or directly debugging them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将获得恶意软件 PE 文件（或 shellcode）的内存转储，用于扫描和分析。这个转储不是完美的，但我们可以使用 `strings` 工具扫描它，或对其进行静态分析。我们可能需要通过在调试器中修复导入表的地址，并重新转储，或直接调试它来手动修复这些地址。
- en: Technique 2 – Detecting process hollowing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧 2 – 检测进程空洞化
- en: When the malware hollows out the application PE image from its process, Windows
    removes any connections between this memory space and the PE file of that application.
    So, any allocation at that address becomes private and doesn’t represent any loaded
    image (or PE file).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件从其进程中将应用程序 PE 镜像挖空时，Windows 会删除该内存空间与应用程序 PE 文件之间的任何连接。因此，在该地址上的任何分配都变成私有的，并且不代表任何已加载的镜像（或
    PE 文件）。
- en: 'However, this detachment only happens in the `EPROCESS` kernel object and not
    in the `PEB` information that is accessible inside the process memory. In Volatility,
    there are two commands that you can use to get a list of all of the loaded modules
    inside a process. One command lists the loaded modules from the `PEB` information
    (from user mode), which is `dlllist`, and the other one lists all loaded modules
    from the `EPROCESS` kernel object information (kernel mode), which is `ldrmodules`.
    Any mismatch in the results between both commands could represent a hollow process
    injection, as shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种脱离仅发生在 `EPROCESS` 内核对象中，而不会发生在进程内存中可以访问的 `PEB` 信息中。在 Volatility 中，有两个命令可以列出进程中所有加载的模块。一个命令列出来自
    `PEB` 信息（用户模式）的加载模块，即 `dlllist`，另一个列出来自 `EPROCESS` 内核对象信息（内核模式）的所有加载模块，即 `ldrmodules`。这两个命令的结果之间的任何不匹配都可能表示进程注入空洞化，如下图所示：
- en: '![Figure 5.14 – lsass.exe at the 0x01000000 address is not linked to its PE
    ﬁle in ldrmodules'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – 0x01000000 地址上的 lsass.exe 在 ldrmodules 中未链接到其 PE 文件'
- en: '](img/Figure_5.14_B18500.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B18500.jpg)'
- en: Figure 5.14 – lsass.exe at the 0x01000000 address is not linked to its PE ﬁle
    in ldrmodules
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 0x01000000 地址上的 lsass.exe 在 ldrmodules 中未链接到其 PE 文件
- en: 'There are multiple types of mismatches, and they represent different types
    of process hollowing, such as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的不匹配，它们代表不同类型的进程空洞化，如下所示：
- en: When the application module is not linked to its PE file, as in *Figure 5.14*,
    it represents that the process is hollowed out and that the malware has been loaded
    in the same place.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序模块未链接到其 PE 文件时，如*图 5.14*所示，表示该进程已被空洞化，并且恶意软件已加载到同一位置。
- en: When the application module appears in the `dlllist` results and not at all
    in the `ldrmodules` results, it represents that the process is hollowed out and
    that the malware is possibly loaded at another address. The `malfind` command
    could help us to find the new address or dump all the memory regions in that process
    using `vaddump` and scan them for PE files (search for **MZ magic**).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序模块出现在 `dlllist` 结果中，但在 `ldrmodules` 结果中完全没有时，这表示进程已被空洞化，且恶意软件可能已加载到另一个地址。`malfind`
    命令可以帮助我们找到新地址，或者使用 `vaddump` 导出该进程中的所有内存区域，并扫描它们以查找 PE 文件（搜索 **MZ 魔术字**）。
- en: When the application appears in the results of both commands and is linked with
    the PE filename of the application, but there’s a mismatch of the module address
    in both results, it represents that the application is not hollowed out, but that
    the malware has been injected and PEB information has been tampered with to link
    to the malware instead of the legitimate application PE image.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序出现在两个命令的结果中，并且与应用程序的 PE 文件名相关联，但在两个结果中模块地址不匹配时，这表示该应用程序并未被空洞化，而是恶意软件已被注入，且
    PEB 信息已被篡改，以链接到恶意软件而不是合法应用程序的 PE 镜像。
- en: In all of these cases, it shows that the malware has injected itself inside
    this process using the process hollowing technique, and `vaddump` or `procdump`
    will help to dump the malware’s PE image.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，显示恶意软件使用进程空洞技术注入到该进程内部，`vaddump` 或 `procdump` 将帮助导出恶意软件的 PE 镜像。
- en: Technique 3 – Detecting process hollowing using the HollowFind plugin
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术 3 – 使用 HollowFind 插件检测进程空洞化
- en: 'There is a plugin called `HollowFind` that combines all of these commands.
    It finds a suspicious memory space or evidence of a hollowed-out process and returns
    these results, as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `HollowFind` 的插件，它将所有这些命令结合起来。它可以找到可疑的内存空间或空洞进程的证据，并返回这些结果，如下图所示：
- en: '![Figure 5.15 – The HollowFind plugin for detecting hollow process injection'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – HollowFind 插件用于检测空洞进程注入'
- en: '](img/Figure_5.15_B18500.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B18500.jpg)'
- en: Figure 5.15 – The HollowFind plugin for detecting hollow process injection
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – HollowFind 插件用于检测空洞进程注入
- en: 'This plugin can also dump the memory image into a chosen directory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件还可以将内存镜像转储到指定目录：
- en: '![Figure 5.16 – The HollowFind plugin for dumping the malware’s PE image'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – HollowFind 插件用于导出恶意软件的 PE 镜像'
- en: '](img/Figure_5.16_B18500.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B18500.jpg)'
- en: Figure 5.16 – The HollowFind plugin for dumping the malware’s PE image
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – HollowFind 插件用于导出恶意软件的 PE 镜像
- en: So, that’s it for process injection and how to analyze it dynamically using
    OllyDbg (or any other debugger), as well as how to detect it in a memory dump
    using Volatility.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是关于进程注入的内容，以及如何使用 OllyDbg（或任何其他调试器）动态分析它，另外如何使用 Volatility 在内存转储中检测它。
- en: In the following section, we will cover another important technique that’s used
    by malware authors, known as API hooking. It’s usually used in combination with
    process injection for MITM attacks or for hiding malware presence using user-mode
    rootkits techniques.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍恶意软件作者使用的另一种重要技术，称为 API hooking。它通常与进程注入结合使用，用于中间人攻击（MITM）或使用用户模式根套件技术隐藏恶意软件的存在。
- en: Understanding API hooking
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 API hooking
- en: API hooking is a common technique that’s used by malware authors to intercept
    calls to Windows APIs in order to change the input or output of these commands.
    It is based on the process injection technique that we described earlier.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API hooking 是恶意软件作者常用的技术，用来拦截对 Windows API 的调用，以便更改这些命令的输入或输出。它是基于我们之前描述的进程注入技术。
- en: This technique allows malware authors to have full control over the target process
    and therefore the user experience from their interaction with that process, including
    browsers and website pages, antivirus applications and their scanned files, and
    so on. By controlling the Windows APIs, the malware authors can also capture sensitive
    information from the process memory and the API arguments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使恶意软件作者能够完全控制目标进程，因此可以控制用户与该进程交互时的体验，包括浏览器和网页、杀毒软件及其扫描的文件等。通过控制 Windows
    API，恶意软件作者还可以从进程内存和 API 参数中捕获敏感信息。
- en: Since API hooking is used by malware authors, it has different legitimate reasons
    to be used, such as malware sandboxing and backward compatibility for old applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API hooking 被恶意软件作者使用，它也有不同的合法用途，例如恶意软件沙箱化和旧应用程序的向后兼容性。
- en: Therefore, Windows officially supports API hooking, as we will see later in
    this chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Windows 正式支持 API 钩取，正如我们在本章后续部分将看到的那样。
- en: Why API hooking?
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要 API 钩取？
- en: 'There are multiple reasons why malware would incorporate API hooking in its
    arsenal. Let’s go into the details of this process and cover the APIs that malware
    authors generally hook in order to achieve their goals:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件采用 API 钩取的原因有多个。让我们详细了解这一过程，并涵盖恶意软件作者通常钩取的 API，以实现他们的目的：
- en: '`Process32First` and `Process32Next`, so that it can remove the malware process
    from the results'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process32First` 和 `Process32Next`，这样可以将恶意软件进程从结果中移除'
- en: File listing APIs such as `FindFirstFileA` and `FindNextFileA`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件列举 API，如 `FindFirstFileA` 和 `FindNextFileA`
- en: Registry enumeration APIs such as `RegQueryInfoKey` and `RegEnumKeyEx`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表枚举 API，如 `RegQueryInfoKey` 和 `RegEnumKeyEx`
- en: '`InternetConnectA`, `HttpSendRequestA`, `InternetReadFile`, and other `wininet.dll`
    APIs. `WSARecv` and `WSASend` from `ws2_32.dll` are other possibilities here.*   Firefox
    APIs such as `PR_Read`, `PR_Write`, and `PR_Close`.*   `CreateProcessA`, `CreateProcessAsUserA`,
    and similar APIs to inject into child processes or prevent some processes from
    starting. Hooking `LoadLibraryA` and `LoadLibraryExA` is also possible.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InternetConnectA`、`HttpSendRequestA`、`InternetReadFile` 等 `wininet.dll` API。`ws2_32.dll`
    中的 `WSARecv` 和 `WSASend` 也是可能的选择。*   Firefox API，如 `PR_Read`、`PR_Write` 和 `PR_Close`。*   `CreateProcessA`、`CreateProcessAsUserA`
    和类似的 API，用于注入到子进程或阻止某些进程启动。钩取 `LoadLibraryA` 和 `LoadLibraryExA` 也是可能的。'
- en: Both the `A` and `W` versions of WinAPIs (for ANSI and Unicode, respectively)
    can be hooked in the same way.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: WinAPI 的 `A` 和 `W` 版本（分别用于 ANSI 和 Unicode）可以通过相同的方式进行钩取。
- en: Working with API hooking
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 API 钩取
- en: In this section, we will look at different techniques for API hooking, from
    the simple methods that can only alter API arguments to more complex ones that
    were used in different banking Trojans, including Vawtrak.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同的 API 钩取技术，从仅能更改 API 参数的简单方法，到用于不同银行木马（包括 Vawtrak）的更复杂方法。
- en: Inline API hooking
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联 API 钩取
- en: 'To hook an API, the malware generally prefers to modify the first few bytes
    (typically, this is 5 bytes) of the API assembly code and replace them with `jmp
    <hooking_function>` so that it can change the API arguments and maybe skip the
    call to this API and return a fake result (as an error or just `NULL`). The code
    change generally looks as follows before hooking:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要钩取 API，恶意软件通常会修改 API 汇编代码的前几个字节（通常是 5 个字节），并用 `jmp <hooking_function>` 替换它们，从而改变
    API 的参数，甚至跳过对该 API 的调用，返回一个假结果（如错误或 `NULL`）。在钩取之前，代码变化通常如下：
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, after hooking, it looks as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，钩取后的代码如下所示：
- en: '[PRE5]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, the malware replaces the first 5 bytes (which, in this case, are three instructions)
    with one instruction, which is `jmp` to the hooked function. Windows supports
    API hooking and has added an extra instruction, `mov edi, edi`, which takes 2
    bytes of space, which makes the function prologue 5 bytes in size. This makes
    API hooking a much easier task to perform.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，恶意软件将前 5 个字节（在本例中是三条指令）替换为一条指令，即 `jmp` 跳转到钩取函数。Windows 支持 API 钩取，并且添加了一条额外的指令
    `mov edi, edi`，该指令占用 2 个字节，使得函数前导代码的大小为 5 个字节。这使得 API 钩取变得更加容易执行。
- en: 'The `hooking_function` routine saves the replaced 5 bytes at the beginning
    of the API and uses them to call the API back, for example, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`hooking_function` 例程保存了替换的前 5 个字节，并使用它们来回调 API，例如，代码如下：'
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This way, `hooking_function` can work seamlessly without affecting the program
    flow. It can alter the arguments of the API and therefore control the results,
    and it can directly execute `ret` to the program without actually calling the
    API.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，`hooking_function` 可以无缝运行而不影响程序流。它可以改变 API 的参数，从而控制结果，并且可以直接执行 `ret`
    返回程序，而不实际调用 API。
- en: Inline API hooking with a trampoline
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有跳板的内联 API 钩取
- en: 'In the previous simple hooking function, the malware can alter the arguments
    of the API. But when you’re using trampolines, the malware can also alter the
    return value of the API and any data associated with it. The trampoline is simply
    a small function that only executes `jmp` to the API and includes the first missing
    5 bytes (or three instructions, in the previous case), as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的简单钩取函数中，恶意软件可以更改 API 的参数。但是当使用跳板时，恶意软件还可以更改 API 的返回值及其相关数据。跳板只是一个小函数，它只执行
    `jmp` 跳转到 API，并包含前 5 个缺失的字节（或三条指令，如前面的例子所示），如下所示：
- en: '[PRE7]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rather than jumping back to the API, which returns control to the program in
    the end, the hooking function calls the trampoline as a replacement of the API.
    This trampoline transfers control to the actual API, but when it finishes execution,
    the control will be transferred back to the hooking function with the return value
    of the API to be altered by the hooking function before returning control back
    to the program, as shown in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子函数不会跳回 API（因为这会最终将控制权交还给程序），而是将跳板作为 API 的替代调用。这个跳板将控制权转交给实际的 API，但当它完成执行后，控制权会被传回给钩子函数，API
    的返回值会在返回控制权给程序之前由钩子函数进行修改，如下图所示：
- en: '![Figure 5.17 – A hooking function with a trampoline'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17 – 带有跳板的钩子函数'
- en: '](img/Figure_5.17_B18500.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.17_B18500.jpg)'
- en: Figure 5.17 – A hooking function with a trampoline
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 带有跳板的钩子函数
- en: 'The code of the hooking function looks more complex:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子函数的代码看起来更加复杂：
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This added step gives the malware more control over the API and its output,
    which makes it possible, for example, to inject JavaScript code into the output
    of `InternetReadFile`, `PR_Read`, or other APIs to steal credentials or transfer
    money to a different bank account.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤使恶意软件能够更好地控制 API 及其输出，例如，它可以将 JavaScript 代码注入到 `InternetReadFile`、`PR_Read`
    或其他 API 的输出中，从而窃取凭据或将钱转入其他银行账户。
- en: Inline API hooking with a length disassembler
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用长度反汇编器的内联 API 钩子
- en: As we have seen in the previous techniques, API hooking is quite simple when
    you use the `mov edi, edi` instruction at the beginning of each API, which makes
    the first 5 bytes predictable for API hooking functionality. Unfortunately, this
    can’t be the case with all Windows APIs, so sometimes malware families have to
    disassemble the first few instructions to avoid breaking the API.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的技术中看到的，API 钩子在你在每个 API 开始使用 `mov edi, edi` 指令时是非常简单的，这使得前 5 个字节在 API
    钩子功能中是可预测的。不幸的是，并非所有 Windows API 都是这样，因此有时恶意软件家族不得不反汇编前几个指令，以避免破坏 API。
- en: 'Some malware families such as Vawtrak use a length disassembler to replace
    a few instructions (with a size equal to or greater than 5 bytes) with the `jmp`
    instruction to the hooking function, as shown in the following screenshot. Then,
    they copy these instructions to the trampoline and add a `jmp` instruction to
    the API:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件家族，如 Vawtrak，使用长度反汇编器将一些指令（大小等于或大于 5 字节）替换为跳转指令（`jmp`），跳转到钩子函数，如下图所示。然后，它们将这些指令复制到跳板中，并向
    API 添加一个 `jmp` 指令：
- en: '![Figure 5.18 – The Vawtrak API hooking with a disassembler'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.18 – 使用反汇编器的 Vawtrak API 钩子'
- en: '](img/Figure_5.18_B18500.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B18500.jpg)'
- en: F
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: F
- en: Figure 5.18 – The Vawtrak API hooking with a disassembler
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 使用反汇编器的 Vawtrak API 钩子
- en: The main goal of this is to ensure that the trampoline doesn’t jump back to
    the API in the middle of the instruction and to make the API hooking work seamlessly
    without any unpredictable effects on the hooked process behavior.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要目的是确保跳板函数不会在指令中途跳回 API，并使 API 钩子能够无缝工作，不会对钩住的进程行为产生不可预测的影响。
- en: Detecting API hooking using memory forensics
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存取证检测 API 钩子
- en: 'As we already know, API hooking is generally used together with process injection,
    and dealing with API hooking in dynamic analysis and memory forensics is very
    similar to dealing with process injections. Adding to the previous techniques
    of detecting process injection (using `malfind` or `hollowfind`), we can use a
    Volatility command called `apihooks`. This command scans the process’s libraries,
    searching for hooked APIs (starting with `jmp` or a `call`), and shows the name
    of the hooked API and the address of the hooking function, as shown in the following
    screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，API 钩子通常与进程注入一起使用，在动态分析和内存取证中处理 API 钩子与处理进程注入非常相似。在之前的进程注入检测技术（使用
    `malfind` 或 `hollowfind`）的基础上，我们可以使用一个叫做 `apihooks` 的 Volatility 命令。这个命令扫描进程的库，搜索钩住的
    API（以 `jmp` 或 `call` 开头），并显示钩住的 API 名称以及钩子函数的地址，如下图所示：
- en: '![Figure 5.19 – The Volatility command, apihooks, for detecting API hooking'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 用于检测 API 钩子的 Volatility 命令 apihooks'
- en: '](img/Figure_5.19_B18500.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.19_B18500.jpg)'
- en: Figure 5.19 – The Volatility command, apihooks, for detecting API hooking
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 用于检测 API 钩子的 Volatility 命令 apihooks
- en: We can then use `vaddump` (as we described earlier in this chapter) to dump
    this memory address and use IDA Pro or any other static analysis tool to disassemble
    the shellcode and understand the motivation behind this API hooking.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`vaddump`（如本章前面所描述）转储该内存地址，并使用IDA Pro或任何其他静态分析工具对Shellcode进行反汇编，从而理解该API钩子的动机。
- en: Finally, let’s talk about IAT hooking.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来讨论IAT钩子。
- en: Exploring IAT hooking
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索IAT钩子
- en: '`jmp` on the actual API address (or the call after pushing the API arguments
    to the stack), and then returns to the actual program, as shown in the following
    diagram:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际API地址上执行`jmp`（或在将API参数推送到堆栈后执行调用），然后返回到实际程序，如下图所示：
- en: '![Figure 5.20 – The IAT hooking mechanism'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20 – IAT钩子机制'
- en: '](img/Figure_5.20_B18500.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.20_B18500.jpg)'
- en: Figure 5.20 – The IAT hooking mechanism
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – IAT钩子机制
- en: This hooking is not effective against the dynamic loading of APIs (using `GetProcAddress`
    and `LoadLibrary`), but it’s still effective against many legitimate applications
    that have most of their required APIs in the import table.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种钩子方法对于API的动态加载（使用`GetProcAddress`和`LoadLibrary`）并不有效，但对于许多合法应用程序仍然有效，这些应用程序的大部分所需API都在导入表中。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered two very well-known techniques that are used
    by many malware families: process injection and API hooking. These techniques
    are used for many reasons, including disguising the malware, bypassing firewalls,
    maintaining persistence for fileless malware, MITB attacks, among others.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们已经介绍了许多恶意软件家族使用的两种非常著名的技术：进程注入和API钩子。这些技术用于多种目的，包括伪装恶意软件、绕过防火墙、维持无文件恶意软件的持久性、MITB攻击等。
- en: We have covered how to deal with code injection using dynamic analysis, as well
    as how to detect code injection and API hooking and how to analyze them using
    memory forensics.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用动态分析处理代码注入，以及如何检测代码注入和API钩子，并如何通过内存取证分析它们。
- en: After reading this chapter, you will now have a greater understanding of complex
    malware and how it can be injected into legitimate processes. This will help you
    to analyze cyberattacks incorporating various techniques and protect your organization
    from future threats more effectively.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将对复杂的恶意软件以及它如何注入到合法进程中有更深入的了解。这将帮助您分析包含各种技术的网络攻击，并更有效地保护您的组织免受未来威胁。
- en: In [*Chapter 6*](B18500_06.xhtml#_idTextAnchor554), *Bypassing Anti-Reverse
    Engineering Techniques*, we will cover other techniques that are used by malware
    authors to make it harder for reverse engineers to analyze samples and understand
    their behavior.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18500_06.xhtml#_idTextAnchor554)，《绕过反调试技术》中，我们将介绍恶意软件作者使用的其他技术，这些技术使逆向工程师更难分析样本并理解其行为。
