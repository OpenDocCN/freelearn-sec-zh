- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Python for Security Professionals – Beyond the Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 用于安全专业人士——超越基础知识
- en: This chapter looks into complex Python applications designed exclusively for
    security professionals, pushing you beyond the fundamentals and into the field
    of cutting-edge cybersecurity practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了专为安全专业人士设计的复杂 Python 应用，带您超越基础知识，进入前沿的网络安全实践领域。
- en: By the end of this chapter, you will not only have a thorough understanding
    of Python’s role in cybersecurity, but you will also have firsthand experience
    designing a comprehensive security tool. You will obtain the expertise required
    to effectively address real-world security concerns through practical examples
    and in-depth explanations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您不仅将彻底了解 Python 在网络安全中的作用，还将亲身体验设计一个全面的安全工具。通过实际案例和深入讲解，您将获得有效解决实际安全问题所需的专业知识。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要主题：
- en: Utilizing essential security libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键的安全库
- en: Harnessing advanced Python techniques for security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用高级 Python 技术进行安全防护
- en: Compiling a Python library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Python 库
- en: Advanced Python features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Python 特性
- en: Utilizing essential security libraries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关键的安全库
- en: At the heart of network analysis is the practice of network scanning. **Network
    scanning** is a technique used to discover devices on a network, determine open
    ports, identify available services, and uncover vulnerabilities. This information
    is invaluable for security assessments and maintaining the overall security of
    a network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络分析的核心是网络扫描实践。**网络扫描**是一种用于发现网络设备、确定开放端口、识别可用服务并发现漏洞的技术。这些信息对安全评估和维护网络的整体安全性至关重要。
- en: Without further ado, let us write a network scanner. **Scapy** will be our library
    of choice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事不宜迟，让我们编写一个网络扫描器。**Scapy** 将是我们首选的库。
- en: Scapy is a powerful packet manipulation tool that allows users to capture, analyze,
    and forge network packets. It can be used for network discovery, security testing,
    and forensic analysis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 是一个强大的数据包处理工具，允许用户捕获、分析和伪造网络数据包。它可用于网络发现、安全测试和取证分析。
- en: How can I determine that Scapy is the preferred library for our tool?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何确认 Scapy 是我们工具的首选库？
- en: You’ll need to do some Google searches, and you can also use [https://pypi.org/](https://pypi.org/)
    to find modules that suit your needs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要进行一些 Google 搜索，您还可以使用 [https://pypi.org/](https://pypi.org/) 查找适合您需求的模块。
- en: So, now that we have our library, how can I find the modules from Scapy that
    are needed for our tool? For that, you can make use of the documentation that
    is available either at [https://pypi.org/](https://pypi.org/) or the GitHub repository
    for the library ([https://github.com/secdev/scapy](https://github.com/secdev/scapy)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，既然我们已经有了库，如何找到 Scapy 中我们工具所需的模块呢？为此，您可以使用可在 [https://pypi.org/](https://pypi.org/)
    或库的 GitHub 仓库（[https://github.com/secdev/scapy](https://github.com/secdev/scapy)）上找到的文档。
- en: One effective method for network discovery is utilizing an **Address Resolution
    Protocol** (**ARP**) scan to query devices on the local network, gathering their
    IP and MAC addresses. With Scapy, a powerful packet manipulation library, we can
    create a simple yet efficient script to perform this task. Scapy’s flexibility
    allows for detailed customization of packets, enabling precise control over the
    ARP requests we send out. This not only increases the efficacy of the scanning
    process but also minimizes any potential network disturbance. The following is
    an optimized script that demonstrates this process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有效的网络发现方法是利用**地址解析协议**（**ARP**）扫描来查询本地网络上的设备，收集它们的 IP 和 MAC 地址。使用 Scapy 这一强大的数据包处理库，我们可以创建一个简单而高效的脚本来执行此任务。Scapy
    的灵活性允许对数据包进行详细定制，从而精确控制我们发送的 ARP 请求。这不仅提高了扫描过程的效率，还最小化了潜在的网络干扰。以下是一个优化过的脚本，展示了这一过程。
- en: The first step in any Python script involves loading the necessary modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Python 脚本的第一步是加载必要的模块。
- en: 'Import the necessary modules from Scapy, including `ARP`, `Ether` (`srp` (**send
    and** **receive packets**):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Scapy 导入必要的模块，包括 `ARP`、`Ether`（`srp`（**发送和接收数据包**））：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can start by creating the function to perform an ARP scan. The `arp_scan`
    function takes a target IP range as input and creates an ARP request packet for
    each IP address in the specified range. It sends the packets, receives responses,
    and extracts IP and MAC addresses, storing them in a list called `devices_list`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从创建执行 ARP 扫描的函数开始。`arp_scan` 函数接受一个目标 IP 范围作为输入，并为指定范围内的每个 IP 地址创建 ARP 请求包。它发送数据包、接收响应，并提取
    IP 和 MAC 地址，将其存储在一个名为 `devices_list` 的列表中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another task is displaying the scan result in the input-output stream. The
    `print_scan_results` function takes the `devices_list` as input and prints the
    discovered IP and MAC addresses in a formatted manner:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务是将扫描结果显示在输入输出流中。`print_scan_results` 函数接受 `devices_list` 作为输入，并以格式化的方式打印出发现的
    IP 和 MAC 地址：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `main` function, the primary function to initiate the script, takes the
    target IP range as input, initiates the ARP scan, and prints the scan results:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数是启动脚本的主要函数，它接受目标 IP 范围作为输入，启动 ARP 扫描并打印扫描结果：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `if __name__ == "__main__":` block makes the script executable in a command
    line and capable of accepting parameters. The script prompts the user to enter
    the target IP range, such as `192.168.1.1/24`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == "__main__":` 代码块使脚本可以在命令行中执行，并能够接受参数。脚本会提示用户输入目标 IP 范围，例如 `192.168.1.1/24`：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To run the script, ensure you are in the virtual environment, have the Scapy
    library installed (`pip install scapy`), and execute it with elevated privilege.
    It will perform an ARP scan on the specified IP range and print the discovered
    devices’ IP and MAC addresses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，确保你已经进入虚拟环境，安装了 Scapy 库（`pip install scapy`），并以管理员权限执行它。它将对指定的 IP 范围执行
    ARP 扫描，并打印出发现的设备的 IP 和 MAC 地址。
- en: 'The result should look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应如下所示：
- en: '![Figure 2.1 – Output of the executed ARP scanner script](img/B21287_01_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 执行 ARP 扫描脚本的输出](img/B21287_01_1.jpg)'
- en: Figure 2.1 – Output of the executed ARP scanner script
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 执行 ARP 扫描脚本的输出
- en: The preceding is a simple example of how powerful Python libraries are. In addition
    to Scapy, I have listed some of the most common libraries that we can utilize
    in our security operations in the previous chapter. The given libraries are just
    a few; there are many more that you can utilize for different needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容是一个简单的例子，展示了 Python 库的强大功能。除了 Scapy，我在上一章中列出了我们可以在安全操作中使用的一些常见库。所列出的库只是其中的一部分，还有许多其他库可以根据不同的需求使用。
- en: Let us now deep dive into harnessing advanced Python techniques, utilizing our
    newfound knowledge to navigate complex security terrains with utmost precision,
    innovation, and resilience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探索如何利用先进的 Python 技术，利用我们新学到的知识，以最大的精准度、创新性和韧性在复杂的安全领域中导航。
- en: Harnessing advanced Python techniques for security
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用先进的 Python 技术进行安全防护
- en: Using the IP addresses obtained from our network scan, we will create a Python
    module, import it into our program, and perform a port scan on these IPs. Along
    the way, we will also cover some advanced Python concepts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从网络扫描中获得的 IP 地址，我们将创建一个 Python 模块，将其导入到我们的程序中，并对这些 IP 进行端口扫描。在此过程中，我们还将涉及一些高级
    Python 概念。
- en: In this section, we will delve into the intricacies of complex Python concepts,
    starting with basic elements such as **object-oriented programming** and **list
    comprehensions**. We will break down these advanced aspects of Python, making
    them easy to understand, and discuss how they can be utilized in the realm of
    technical security testing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨复杂的 Python 概念，从基本元素开始，如 **面向对象编程** 和 **列表推导式**。我们将分解这些高级 Python
    方面的内容，使其易于理解，并讨论如何在技术安全测试领域中应用它们。
- en: Before starting the port scanner, we need to import the necessary modules in
    Python, in this case, the `socket` module. The `socket` module is a key tool used
    to create networking interfaces in Python. It is important to do so because the
    `socket` module provides us with the ability to connect with other computers over
    a network. This connection with other computers is a crucial starting point for
    any port scanning procedure. Hence, importing the `socket` module is the first
    step in setting up the port scanner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始端口扫描器之前，我们需要在 Python 中导入必要的模块，这里是 `socket` 模块。`socket` 模块是用于在 Python 中创建网络接口的关键工具。导入它非常重要，因为
    `socket` 模块提供了与其他计算机通过网络连接的能力。这种与其他计算机的连接是任何端口扫描过程的关键起点。因此，导入 `socket` 模块是设置端口扫描器的第一步。
- en: 'In this initial stage, we will be importing the necessary modules as usual:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始阶段，我们将照常导入必要的模块：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will initiate the creation of a `PortScanner` class. In the realm of Python,
    a class serves as a blueprint for creating objects that encapsulate a set of variables
    and functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建一个`PortScanner`类。在 Python 中，类充当创建对象的蓝图，这些对象封装了一组变量和函数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first method that one encounters within a class is the `__init__` method.
    This method is crucial as it is used to initialize the instances of a class or
    to set the default values. The `__init__` method is a special method in Python
    classes. It acts as a constructor and is automatically called when a new instance
    of the class is created. In this method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中遇到的第一个方法是`__init__`方法。这个方法至关重要，因为它用于初始化类的实例或设置默认值。`__init__`方法是 Python 类中的特殊方法，充当构造函数，并在创建类的新实例时自动调用。在这个方法中：
- en: '**self**: This refers to the instance of the class being created. It allows
    you to access the instance’s attributes and methods.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**self**：指的是正在创建的类的实例。它允许你访问实例的属性和方法。'
- en: '**target_host**: A parameter representing the target host (e.g., a website
    or IP address) that the port scanner will scan.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target_host**：表示目标主机（例如网站或 IP 地址）的参数，端口扫描器将对其进行扫描。'
- en: '**start_port** and **end_port** are parameters representing the range of ports
    to be scanned, from **start_port** to **end_port**.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**start_port**和**end_port**是表示要扫描的端口范围的参数，从**start_port**到**end_port**。'
- en: '**open_ports**: An empty list that will store the list of open ports found
    during the scanning process. This list is specific to each instance of the **PortScanner**
    class:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**open_ports**：一个空列表，用于存储在扫描过程中找到的开放端口列表。此列表对于每个**PortScanner**类的实例都是特定的：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method named `is_port_open` is thoroughly discussed next. This procedure
    is designed to check if certain network ports are open, which is crucial for identifying
    potential vulnerabilities in a network’s security system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`is_port_open`的方法接下来将被详细讨论。此过程旨在检查某些网络端口是否开放，这对于识别网络安全系统中的潜在漏洞至关重要。
- en: 'The following are the parameters for the method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该方法的参数：
- en: '**self**: This represents the instance of the class on which the method is
    called.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**self**：表示调用该方法的类的实例。'
- en: '**port**: This is a parameter representing the port number to be checked for
    openness.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**port**：表示要检查是否开放的端口号的参数。'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are the principles outlined in the preceding code block elaborated
    on in detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码块中概述的原则的详细阐述：
- en: '**with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:**: This line
    creates a new socket object:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:**：这一行创建了一个新的套接字对象：'
- en: '**socket.AF_INET**: This indicates that the socket will use IPv4 addressing.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**socket.AF_INET**：表示套接字将使用 IPv4 地址。'
- en: '**socket.SOCK_STREAM**: This indicates that the socket is a TCP socket, used
    for streaming data.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**socket.SOCK_STREAM**：表示套接字是一个 TCP 套接字，用于流式传输数据。'
- en: '**s.settimeout(1)**: This sets a timeout of **1** second for the socket. connection
    attempt. If the connection does not succeed within **1** second, a **socket.timeout**
    exception will be raised.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s.settimeout(1)**：为套接字连接尝试设置 **1** 秒的超时时间。如果连接在 **1** 秒内未成功，将引发**socket.timeout**异常。'
- en: '**s.connect((self.target_host, port))**: This attempts to establish a connection
    to the target host (**self.target_host**) on the specified port (**port**).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s.connect((self.target_host, port))**：尝试建立与目标主机（**self.target_host**）在指定端口（**port**）上的连接。'
- en: '**Handling a connection result**: If the connection attempt is successful (i.e.,
    the port is open and accepts connections), the code inside the **try** block is
    executed without errors. In this case, the method immediately returns **True**,
    indicating that the port is open.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理连接结果**：如果连接尝试成功（即端口开放并接受连接），则会执行**try**块中的代码且没有错误。在这种情况下，方法会立即返回**True**，表示端口已打开。'
- en: '**Handling exceptions**: If the connection attempt results in a timeout (**socket.timeout**)
    or **ConnectionRefusedError**, it means the port is closed or unreachable. These
    exceptions are caught in the **except** block, and the method returns **False**,
    indicating that the port is closed.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理异常**：如果连接尝试结果为超时（**socket.timeout**）或**ConnectionRefusedError**，则表示端口关闭或无法访问。这些异常将在**except**块中捕获，并且方法返回**False**，表示端口已关闭。'
- en: The `is_port_open` method is used internally within the `PortScanner` class.
    It provides a simple and reusable way to check whether a specific port on the
    target host is open or closed. By encapsulating this logic into a separate method,
    the code becomes more modular and easier to maintain. The method allows the `PortScanner`
    class to efficiently determine the status of ports during the scanning process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_port_open` 方法在 `PortScanner` 类内部使用。它提供了一种简单且可复用的方式来检查目标主机上的特定端口是开放还是关闭。通过将此逻辑封装到一个独立的方法中，代码变得更加模块化，易于维护。该方法允许
    `PortScanner` 类在扫描过程中高效地确定端口的状态。'
- en: Next, we discuss the `scan_ports` method. This method is an intricate process
    that systematically scans and analyzes network ports.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论 `scan_ports` 方法。这个方法是一个复杂的过程，它系统地扫描和分析网络端口。
- en: 'The following is the parameter for the method (`self`); it represents the instance
    of the class on which the method is called:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是方法的参数（`self`）；它表示调用该方法的类实例：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the principles outlined in the preceding code block elaborated
    on in detail:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码块中概述的原则的详细解释：
- en: '`iterable` and optionally filtering the items based on a condition.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterable` 并可以根据条件选择性地过滤项目。'
- en: 'The syntax for the list comprehension will be as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表推导式的语法如下：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constituents of the structure can be elucidated as follows:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该结构的组成部分可以解释如下：
- en: '`[port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]`
    line in the `scan_ports` method, it is a list comprehension. Its components can
    be dissected and expounded upon as follows:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[port for port in range(self.start_port, self.end_port + 1) if self.is_port_open(port)]`
    行在 `scan_ports` 方法中，它是一个列表推导式。其组成部分可以被拆解并详细阐述如下：'
- en: '`iterable`. They are a fundamental part of Python’s expressive syntax, enabling
    developers to write efficient and readable code.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterable`。它们是 Python 表达式语法的基础部分，使得开发者能够编写高效且易读的代码。'
- en: '`start_port` and `end_port`.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_port` 和 `end_port`。'
- en: '`is_port_open` method to check whether the port is open (using the `is_port_open`
    helper method explained earlier).'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `is_port_open` 方法来检查端口是否开放（使用之前解释过的 `is_port_open` 辅助方法）。
- en: '`is_port_open(port)` returns `True`. This list comprehensively identifies and
    captures all open ports within the specified range.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_port_open(port)` 返回 `True`。这个列表全面识别并捕获指定范围内的所有开放端口。'
- en: '`scan_ports` method provides a concise way to scan a range of ports and collect
    the list of open ports. It utilizes list comprehension, a powerful feature in
    Python, to create the `open_ports` list in a single line. By using this method,
    the `PortScanner` class can easily and efficiently identify open ports within
    a specified range on the target host. This method is integral to the functionality
    of the `PortScanner` class, as it encapsulates the logic of scanning and identifying
    open ports.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_ports` 方法提供了一种简洁的方式来扫描端口范围并收集开放端口的列表。它利用列表推导式，Python 中的一个强大功能，在一行代码中创建
    `open_ports` 列表。通过使用此方法，`PortScanner` 类可以轻松且高效地识别目标主机上指定范围内的开放端口。该方法对于 `PortScanner`
    类的功能至关重要，因为它封装了扫描和识别开放端口的逻辑。'
- en: 'Now, we will focus on the `main()` function. The following are its features:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将关注 `main()` 函数。以下是它的特点：
- en: '**target_host = input("Enter target host: ")**: This prompts the user to input
    the target host (e.g., a website domain or IP address) and stores the input in
    the **target_host** variable.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target_host = input("请输入目标主机：")**：这会提示用户输入目标主机（例如，网站域名或 IP 地址），并将输入存储到 **target_host**
    变量中。'
- en: '**start_port = int(input("Enter starting port: "))**: This prompts the user
    to input the starting port number and stores the input after converting it to
    an integer in the **start_port** variable.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**start_port = int(input("请输入起始端口："))**：这会提示用户输入起始端口号，并在将输入转换为整数后存储到 **start_port**
    变量中。'
- en: '**end_port = int(input("Enter ending port: "))**: This prompts the user to
    input the ending port number and stores the input after converting it to an integer
    in the **end_port** variable.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**end_port = int(input("请输入结束端口："))**：这会提示用户输入结束端口号，并在将输入转换为整数后存储到 **end_port**
    变量中。'
- en: 'The following is the `main()` function code section:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是 `main()` 函数的代码部分：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the code execution steps explained in depth:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码执行步骤的详细解释：
- en: '`PortScanner` class, passing the `target_host`, `start_port`, and `end_port`
    as parameters. This instance will be used to scan ports.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `PortScanner` 类的实例，并将 `target_host`、`start_port` 和 `end_port` 作为参数传递。此实例将用于扫描端口。
- en: '`scan_ports` method of the `PortScanner` instance to scan ports. This method
    returns a list of open ports using list comprehension, as explained in previous
    discussions.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PortScanner` 实例的 `scan_ports` 方法扫描端口。这个方法使用列表推导返回一个开放端口的列表，正如之前讨论的那样。
- en: '`scan_ports` method using list comprehension.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表推导的 `scan_ports` 方法。
- en: 'Finally, add the following code block to call the `main` method when the file
    is executed as a script, but not when it is utilized as an import module:'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，添加以下代码块，以便在文件作为脚本执行时调用 `main` 方法，但当它作为模块导入时不调用：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `if __name__ == "__main__":` line checks whether the script is being run
    directly (not imported as a module). When you execute the script directly, this
    condition evaluates to `True`. If the script is being run directly, it calls the
    `main()` function, initiating the process of input gathering, port scanning, and
    displaying the results.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if __name__ == "__main__":` 这一行检查脚本是否直接运行（而不是作为模块导入）。当你直接执行脚本时，这个条件会评估为 `True`。如果脚本是直接运行的，它会调用
    `main()` 函数，启动输入收集、端口扫描和显示结果的过程。'
- en: In summary, this script prompts the user for a target host, starting port, and
    ending port. It then creates an instance of the `PortScanner` class and uses list
    comprehension to scan ports within the specified range. The open ports are displayed
    to the user. The script is structured to be run directly as a standalone program,
    allowing users to interactively scan ports based on their input.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结来说，这个脚本会提示用户输入目标主机、起始端口和结束端口。然后它会创建一个 `PortScanner` 类的实例，并使用列表推导扫描指定范围内的端口。开放的端口将显示给用户。这个脚本被设计为可以直接作为独立程序运行，允许用户根据输入交互式地扫描端口。
- en: Now, let us convert our code into a Python library, so we can install and use
    this library in any of our Python scripts.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们将代码转换成 Python 库，这样我们就可以在任何 Python 脚本中安装并使用这个库。
- en: Compiling a Python library
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Python 库
- en: 'Creating a Python library involves packaging your code in a way that allows
    others to easily install, import, and use it in their projects. To convert your
    code into a Python library, follow these steps:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个 Python 库涉及以一种方便他人安装、导入和使用的方式打包你的代码。要将你的代码转换为 Python 库，请按照以下步骤操作：
- en: '**Organize your code**: Ensure our code is well-organized and follows the package
    structure:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整理你的代码**：确保我们的代码结构合理，遵循包结构：'
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The components of a Python library are as follows:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 库的组件如下：
- en: '**portscanner/**: The main folder containing your package'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**portscanner/**：包含你包的主要文件夹'
- en: '**portscanner/__init__.py**: An empty file indicating that **portscanner**
    is a Python package'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**portscanner/__init__.py**：一个空文件，表示 **portscanner** 是一个 Python 包'
- en: '**portscanner/scanner.py**: Your **PortScanner** class and related functions'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**portscanner/scanner.py**：你的 **PortScanner** 类和相关函数'
- en: '**setup.py**: The script for packaging and distributing your library'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setup.py**：用于打包和分发你的库的脚本'
- en: '**README.md**: Documentation explaining how to use your library'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**README.md**：文档，说明如何使用你的库'
- en: '**Update setup.py**:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新 setup.py**：'
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this file, you specify the package name (`portscanner`), version number,
    and the packages to include (use `find_packages()` to automatically discover packages).
    Add any dependencies your library requires to the `install_requires` list.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个文件中，你需要指定包名（`portscanner`）、版本号，以及要包含的包（使用 `find_packages()` 来自动发现包）。将任何库的依赖项添加到
    `install_requires` 列表中。
- en: '**Package your code**: In your terminal, navigate to the directory containing
    your **setup.py** file and run the following command to create a source distribution
    package:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打包你的代码**：在终端中，进入包含 **setup.py** 文件的目录，并运行以下命令来创建源分发包：'
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Publish your library (optional)**: If you want to make your library publicly
    available, you can publish it on the **Python Package Index** (**PyPI**). You
    will need to create an account on PyPI and install **twine** if you have not already:'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发布你的库（可选）**：如果你想让你的库公开可用，你可以将它发布到 **Python Package Index**（**PyPI**）。你需要在
    PyPI 上创建一个账户，并安装 **twine**，如果你还没有安装的话：'
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: twine upload dist/*
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: twine 上传 dist/*
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Install and use your library**: To test your library, you can install it
    locally using **pip**. In the same directory as your **setup.py**, run the following
    command:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装并使用你的库**：要测试你的库，你可以使用 **pip** 在本地安装它。在和 **setup.py** 同一目录下，运行以下命令：'
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 1\. from portscanner.portscanner import PortScanner
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 从 portscanner.portscanner 导入 PortScanner
- en: '2.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2.'
- en: 3\. scanner = PortScanner(target_host, start_port, end_port)
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3\. scanner = PortScanner(target_host, start_port, end_port)
- en: 4\. open_ports = scanner.scan_ports()
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4\. open_ports = scanner.scan_ports()
- en: '5\. print("Open ports: ", open_ports)'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5. print("开放端口: ", open_ports)'
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we bring our discussion on compiling a Python library to a close, we turn
    toward the exploration of advanced Python features to further enhance our knowledge
    and skills in cybersecurity. The following section will delve deeper into these
    sophisticated components of Python.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们结束关于编译 Python 库的讨论时，我们将转向探索更高级的 Python 特性，以进一步提升我们在网络安全领域的知识和技能。接下来的部分将更深入地探讨这些
    Python 的复杂组件。
- en: Advanced Python features
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Python 特性
- en: We can combine our library created in the earlier section into our network mapping
    tool and transform our code, which does a network scan and a port scan of the
    discovered IP addresses. Let us keep it there and talk about some more advanced
    Python features, starting with **decorators**.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将之前部分创建的库与我们的网络映射工具结合起来，并改造我们的代码，使其对发现的 IP 地址进行网络扫描和端口扫描。我们就停在这里，接下来讨论一些更高级的
    Python 特性，从**装饰器**开始。
- en: Decorators
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are a powerful aspect of Python’s syntax, allowing you to modify
    or enhance the behavior of functions or methods without changing their source
    code.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 装饰器是 Python 语法中一个强大的方面，使你能够在不改变源代码的情况下修改或增强函数或方法的行为。
- en: 'For an improved understanding of Python decorators, we will delve into the
    examination of the following code:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更好地理解 Python 装饰器，我们将深入分析以下代码：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the code execution steps explained in depth:'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是详细解释的代码执行步骤：
- en: '**timing_decorator(func)**: This decorator function, known as **timing_decorator(func)**,
    operates by accepting a function (**func**) as a parameter, and then producing
    a new function (**wrapper**). **wrapper** fundamentally functions as a housing
    for the original function, offering an extra layer of operation.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timing_decorator(func)**：这个装饰器函数，称为**timing_decorator(func)**，通过接受一个函数（**func**）作为参数，然后生成一个新的函数（**wrapper**）。**wrapper**本质上是原始函数的一个载体，提供额外的操作层。'
- en: '**wrapper(*args, **kwargs)**: This is the **wrapper** function returned by
    the decorator. It captures the arguments and keyword arguments passed to the original
    function, records the start time, calls the original function, records the end
    time, calculates the time taken, prints the duration, and finally returns the
    result of the original function.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wrapper(*args, **kwargs)**：这是装饰器返回的**wrapper**函数。它捕获传递给原始函数的参数和关键字参数，记录开始时间，调用原始函数，记录结束时间，计算所花费的时间，打印持续时间，并最终返回原始函数的结果。'
- en: 'Let us examine how to utilize this decorator in the code:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看一下如何在代码中使用这个装饰器：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `@timing_decorator` decorates the `scan_ports` method using `timing_decorator`.
    It is equivalent to writing `scan_ports =` `timing_decorator(scan_ports)`.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`@timing_decorator` 使用 `timing_decorator` 装饰了 `scan_ports` 方法。它等同于写 `scan_ports
    =` `timing_decorator(scan_ports)`。
- en: '`timing_decorator` measures the time taken for the `scan_ports` method to execute
    and prints the duration. This is a common use case for decorators, showcasing
    how they can enhance the functionality of methods in a clean and reusable way.
    Decorators provide a flexible and elegant approach to modifying or extending the
    behavior of functions and methods in Python.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`timing_decorator` 测量 `scan_ports` 方法执行的时间并打印持续时间。这是装饰器的一个常见用例，展示了它们如何以简洁和可重用的方式增强方法的功能。装饰器为修改或扩展
    Python 中函数和方法的行为提供了一种灵活优雅的方式。'
- en: Next, we will explore various scenarios where decorators can be effectively
    employed for enhancing code functionality in an uncomplicated manner. We will
    highlight the benefits of using decorators in improving code maintainability,
    readability, and reusability, ultimately contributing to a more secure and optimized
    code base.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨装饰器在提升代码功能方面如何轻松地被有效运用。我们将强调装饰器在改善代码的可维护性、可读性和可重用性方面的好处，最终有助于构建更安全和优化的代码库。
- en: 'The following are the use cases and benefits of decorators:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是装饰器的使用场景和优点：
- en: '**Code reusability**: Decorators allow you to encapsulate reusable functionality
    and apply it to multiple functions or methods without duplicating code.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用性**：装饰器允许你将可重用的功能封装，并将其应用于多个函数或方法，而无需复制代码。'
- en: '**Logging and timing**: Decorators are often used for logging, timing, and
    profiling functions to monitor their behavior and performance.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录和计时**：装饰器通常用于日志记录、计时和性能分析函数，以监控它们的行为和表现。'
- en: '**Authentication and authorization**: Decorators can enforce authentication
    and authorization checks, ensuring that only authorized users can access certain
    functions or methods.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证和授权**：装饰器可以执行身份验证和授权检查，确保只有授权用户才能访问某些函数或方法。'
- en: '**Error handling**: Decorators can handle exceptions raised by functions, providing
    consistent error handling across different parts of the code.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：装饰器可以处理函数抛出的异常，在代码的不同部分提供一致的错误处理。'
- en: '**Aspect-oriented programming (AOP)**: Decorators enable AOP, allowing you
    to separate cross-cutting concerns (e.g., logging, security) from the core logic
    of functions or methods.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向切面编程（AOP）**：装饰器支持AOP，允许你将跨越多个功能或方法的关注点（例如，日志记录、安全性）与核心逻辑分离。'
- en: '**Method chaining and modification**: Decorators can modify the output or behavior
    of functions, enabling method chaining or transforming return values.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法链式调用和修改**：装饰器可以修改函数的输出或行为，从而实现方法链式调用或转换返回值。'
- en: This previous code usage appears to be almost complete, however, it appears
    that our port scanner tool we started at the beginning of this chapter utilizes
    a list to store the open ports and then return them, which makes the code not
    so memory efficient, so let’s introduce **generators**, another Python concept.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码使用看似接近完成，但似乎我们在本章开始时编写的端口扫描工具使用列表来存储开放端口并返回它们，这使得代码的内存效率较低，因此让我们引入**生成器**，这一
    Python 概念。
- en: Generators
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: Generators in Python are special types of functions that return a sequence of
    results. They allow you to declare a function that behaves like an iterator, iterating
    over it in a for-loop or explicitly with the next function, while also maintaining
    the program’s internal state and pausing execution between values, thus optimizing
    memory use.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python中的生成器是特殊类型的函数，它返回一系列结果。它们允许你声明一个类似迭代器的函数，在 for 循环中迭代，或者通过 next 函数显式调用，同时维护程序的内部状态，并在生成值之间暂停执行，从而优化内存使用。
- en: 'The characteristics of the generator are detailed and explained more thoroughly
    as follows:'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器的特性在以下内容中进行了更详细的解释：
- en: '**Lazy evaluation**: Generators use lazy evaluation, meaning they produce values
    on the fly and only when requested. This makes them memory efficient, especially
    when dealing with large datasets or potentially infinite sequences.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性求值**：生成器采用惰性求值，意味着它们按需生成值，仅在请求时生成。这使得它们在处理大数据集或潜在无限序列时内存效率非常高。'
- en: '**Memory efficiency**: Generators do not store all values in memory at once.
    They generate each value one at a time, consuming minimal memory. This is particularly
    beneficial for working with large data streams.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存效率**：生成器不会一次性将所有值存储在内存中。它们一次生成一个值，消耗最小的内存。这对于处理大数据流特别有利。'
- en: '**Efficient iteration**: Generators are **iterable** objects, allowing them
    to be used in loops and comprehensions just like lists. However, they generate
    values efficiently, processing each item as it is needed.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效迭代**：生成器是**可迭代**对象，可以像列表一样在循环和推导式中使用。然而，它们以高效的方式生成值，在需要时逐个处理每个项目。'
- en: '**Infinite sequences**: Generators can represent infinite sequences. Since
    they produce values on demand, you can create a generator that theoretically generates
    values forever.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限序列**：生成器可以表示无限序列。由于它们按需生成值，可以创建一个理论上永远生成值的生成器。'
- en: 'We will enhance our understanding of Python generators by thoroughly analyzing
    the following code:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将通过深入分析以下代码，增强对 Python 生成器的理解：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following are the code execution steps explained in depth to understand the
    generator function behavior:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码执行步骤的详细解释，帮助理解生成器函数的行为：
- en: '**for port in range(self.start_port, self.end_port + 1)**: This loop iterates
    over each port number in the specified range (**self.start_port** to **self.end_port**),
    inclusive of both **start_port** and **end_port**.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for port in range(self.start_port, self.end_port + 1)**：此循环遍历指定范围内的每个端口号（**self.start_port**
    到 **self.end_port**），包括**start_port**和**end_port**。'
- en: '**if self.is_port_open(port)**: For each port in the range, it calls the **is_port_open**
    method to check whether the port is open (using the **is_port_open** helper method
    explained earlier).'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if self.is_port_open(port)**：对于范围内的每个端口，调用**is_port_open**方法检查端口是否开放（使用前面解释过的**is_port_open**辅助方法）。'
- en: '**yield port**: If the port is open, the **yield** keyword is used to produce
    a value (**port**) from the generator. The **generator** function maintains its
    state, allowing it to resume execution from where it left off when the next value
    is requested.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**yield port**：如果端口开放，**yield** 关键字用于从生成器中返回一个值（**port**）。**generator** 函数保持其状态，使得在请求下一个值时可以从上次中断的地方恢复执行。'
- en: 'The use cases of the generator are detailed and explained further as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器的使用案例进行了详细讲解，并进一步解释如下：
- en: '**Processing large files**: Reading large files line-by-line without loading
    the entire file into memory'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理大文件**：逐行读取大文件而不将整个文件加载到内存中'
- en: '**Stream processing**: Analyzing real-time data streams where data is continuously
    generated'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流处理**：分析实时数据流，其中数据不断生成'
- en: '**Efficient filtering**: Generating filtered sequences without creating intermediate
    lists'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效过滤**：生成过滤后的序列而不创建中间列表'
- en: '**Mathematical calculations**: Generating sequences such as Fibonacci numbers
    or prime numbers on the fly'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学计算**：动态生成诸如斐波那契数列或质数等序列'
- en: Generators are a powerful concept in Python, enabling the creation of memory-efficient
    and scalable code, especially when working with large datasets or sequences. They
    are a fundamental feature of Python’s expressive syntax and are widely used in
    various programming scenarios.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成器是 Python 中一个强大的概念，它能够创建内存高效且可扩展的代码，尤其在处理大数据集或序列时非常有用。它们是 Python 表达式语法中的基础特性，在各种编程场景中被广泛使用。
- en: 'Upon utilizing advanced features such as decorators and generators, our code
    will take on a certain form. This is how the code should appear in its final iteration:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在利用了如装饰器和生成器等高级特性后，我们的代码将呈现出一定的形式。以下是代码在最终版本中的样子：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Having explored the intricacies of a port scanner script, its modularization,
    and the use of advanced features such as decorators and generators, our next task
    is to delve into the subsequent steps. This translates into a hands-on activity,
    allowing readers an opportunity to further analyze and comprehend coding practices.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在探索了端口扫描脚本的复杂性、模块化以及如何使用装饰器和生成器等高级特性后，我们的下一个任务是深入了解接下来的步骤。这意味着进行一项动手活动，让读者进一步分析和理解编码实践。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Python to create a network mapper and
    a port scanner. We covered several complex Python topics along the road, such
    as object-oriented programming, comprehensions, decorators, generators, and how
    to package a Python program into a library.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Python 创建网络映射器和端口扫描器。在过程中，我们涉及了多个复杂的 Python 主题，如面向对象编程、推导式、装饰器、生成器以及如何将
    Python 程序打包成库。
- en: You will be able to build more elegant Python code that stands out from the
    crowd with these. The presented concepts are difficult to execute at first, but
    once you get the feel of it, you will never consider coding in any other way.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些特性，你将能够编写更优雅的 Python 代码，脱颖而出。所呈现的概念起初可能较为复杂，但一旦掌握，你将永远不会再以其他方式进行编码。
- en: The next chapter will dive into the exciting and paramount field of web security
    through the usage of Python. It will explore various strategies, tools, and techniques
    that Python offers to identify and neutralize security threats, alongside understanding
    the fundamentals of web security itself. This knowledge is imperative in today’s
    digital age, where security breaches can come at a high cost.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一章将深入探讨 Python 在网络安全领域中的应用。它将探索 Python 提供的各种策略、工具和技术，帮助识别和消除安全威胁，同时理解网络安全的基本原理。在今天这个数字时代，这种知识至关重要，因为安全漏洞可能带来高昂的代价。
- en: Activity
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动
- en: Now, I will leave it up to you to package both the network scanner and the port
    scanner into a library and use the libraries to write a more compact script that
    does a network scan and scan for open ports for each IP that is found.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我将把任务交给你，你需要将网络扫描器和端口扫描器打包成库，并利用这些库编写一个更加简洁的脚本，扫描每个找到的 IP 的开放端口。
- en: 'Readers are recommended to follow the outlined steps to reinforce the concepts
    presented in this chapter. Every task designed within this activity aims to test
    and solidify the reader’s comprehension effectively:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议读者按照章节中列出的步骤来巩固所介绍的概念。每个任务都旨在有效测试和加深读者的理解：
- en: Package both code snippets into the library.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个代码片段打包成库。
- en: Name your new Python file **network-and-port-scanner.py**.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的新 Python 文件命名为 **network-and-port-scanner.py**。
- en: Import both libraries into the new program.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入两个库到新程序中。
- en: Use argument parsing to obtain the IP and port ranges for scanning.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数解析获取扫描的 IP 和端口范围。
- en: Pass the IP address range to the network mapper for ARP scanning and write the
    IPs to a file.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 IP 地址范围传递给网络映射程序进行 ARP 扫描，并将 IP 写入文件。
- en: Read the IPs from the file and provide the discovered IP addresses with the
    port range to the port scanner.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取 IP，并将发现的 IP 地址及其端口范围提供给端口扫描程序。
- en: Print the IPs and ports into a table in a more visually appealing manner.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以更具视觉吸引力的方式将 IP 和端口打印成表格。
