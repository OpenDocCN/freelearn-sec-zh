- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Functions and Script Organization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数与脚本组织
- en: In the previous chapter, you learned about regular expressions and how to apply
    them in practical applications. This chapter builds on this by teaching you how
    to apply everything you’ve learned in previous chapters to organize your code
    into functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了正则表达式以及如何将其应用到实际应用中。本章将在此基础上，教你如何将之前学到的内容应用到组织代码成函数中。
- en: Functions are a fundamental concept in Bash scripting that allow you to organize
    your code into reusable and modular units. By mastering functions, you can write
    more efficient, maintainable, and readable scripts. This chapter will dive deep
    into the world of **Bash functions** , exploring their syntax, usage, and advanced
    techniques. We’ll also discuss how functions can help you structure your scripts
    and simplify common pentesting tasks. Lastly, we will compare and contrast functions
    and aliases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Bash 脚本编写中的一个基础概念，它使你能够将代码组织成可重用和模块化的单元。通过掌握函数，你可以编写更高效、易于维护和更具可读性的脚本。本章将深入探讨**Bash
    函数**的世界，探索它们的语法、用法和高级技巧。我们还将讨论函数如何帮助你组织脚本结构，并简化常见的渗透测试任务。最后，我们将比较和对比函数与别名。
- en: By the end of this chapter, you’ll have a solid understanding of how to define
    and use functions in your Bash scripts. You’ll learn how to pass arguments to
    functions, understand variable scope and lifetime within functions, and explore
    advanced techniques such as recursion and callbacks. Most importantly, you’ll
    see how functions can help you write cleaner, more organized scripts that are
    easier to maintain and extend, ultimately streamlining your pentesting workflow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将对如何在 Bash 脚本中定义和使用函数有一个扎实的理解。你将学习如何向函数传递参数，理解函数内变量的作用域和生命周期，并探索递归和回调等高级技巧。最重要的是，你将看到函数如何帮助你编写更简洁、更有组织的脚本，这些脚本更容易维护和扩展，最终简化你的渗透测试工作流。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to Bash functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 函数简介
- en: Passing arguments to functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: The scope and lifetime of variables in functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中变量的作用域和生命周期
- en: Advanced function techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级函数技巧
- en: Functions versus aliases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数与别名
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05)找到。
- en: Introduction to Bash functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 函数简介
- en: Bash functions are an essential tool for anyone who works with the Bash shell
    on Linux systems. They allow you to encapsulate reusable pieces of code into named,
    parameterized units that can be called from anywhere in your Bash scripts or interactive
    shell sessions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 函数是任何在 Linux 系统上使用 Bash shell 的人的基本工具。它们允许你将可重用的代码块封装成命名的、带有参数的单元，可以在 Bash
    脚本或交互式 shell 会话的任何地方调用。
- en: Let’s explore some of the key reasons why Bash functions are so important and
    useful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下 Bash 函数为何如此重要和有用的几个关键原因。
- en: Code reuse
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重用
- en: One of the biggest benefits of Bash functions is that they promote code reuse.
    If you find yourself writing the same or very similar code over and over in your
    Bash scripts, that’s a good sign that you should extract that code into a reusable
    function!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 函数的最大好处之一是它们促进了代码重用。如果你发现自己在 Bash 脚本中反复编写相同或非常相似的代码，这通常是一个信号，提示你应该将这些代码提取成一个可重用的函数！
- en: 'For example, let’s say many of your scripts need to parse command-line arguments
    in a consistent way. Rather than copying and pasting the argument parsing logic
    into each script, you could define a **parse_args** function (the code can be
    found in this chapter’s folder in the book’s GitHub repository as **ch05_parse_args.sh**
    ):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的许多脚本都需要以一致的方式解析命令行参数。与其将参数解析逻辑复制粘贴到每个脚本中，不如定义一个**parse_args**函数（代码可以在本章文件夹中的书籍
    GitHub 仓库中的**ch05_parse_args.sh**找到）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, any script that needs to parse arguments in this way can simply call the
    **parse_args** function. This makes your code more concise, readable, and maintainable.
    If you ever need to update the argument parsing logic, you only have to do it
    in one place.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何需要以这种方式解析参数的脚本都可以简单地调用**parse_args**函数。这使得你的代码更加简洁、易读且易于维护。如果你需要更新参数解析逻辑，只需在一个地方进行更改。
- en: Don’t worry if you don’t understand what the preceding function is doing. You’ll
    understand it soon enough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解前面的函数在做什么，不用担心，你很快就会理解的。
- en: Modularity
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: Bash functions allow you to break your scripts down into smaller, self-contained,
    and more manageable pieces. Each function should ideally do one specific task
    and do it well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 函数使你可以将脚本拆解成更小、更独立、更易管理的部分。每个函数理想情况下应执行一个特定任务，并且能够做到这一点。
- en: By decomposing your scripts into modular functions, your code becomes easier
    to understand, debug, and maintain. It’s much simpler to troubleshoot a specific
    function than a monolithic script with hundreds or thousands of lines.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将脚本分解为模块化的函数，代码变得更易于理解、调试和维护。与包含数百行甚至数千行的单体脚本相比，排查一个特定函数的错误要简单得多。
- en: Well-designed functions also make your scripts more readable by giving semantic
    names to chunks of code. For example, a script full of calls such as **fetch_data**
    , **parse_response** , and **update_database** is much easier to follow than a
    script with all those operations intermixed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的函数还通过为代码块赋予语义化的名称，使脚本更具可读性。例如，一个充满 **fetch_data**、**parse_response** 和
    **update_database** 调用的脚本，比一个将所有操作混杂在一起的脚本更容易理解。
- en: Encapsulation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Functions provide **encapsulation** , meaning they create a separate scope for
    variables and other resources. Any variables defined inside a function are local
    to that function by default. They don’t pollute the global namespace or conflict
    with variables in other parts of your script.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数提供了 **封装**，即它们为变量和其他资源创建了一个独立的作用域。默认情况下，在函数内部定义的任何变量都是局部变量。它们不会污染全局命名空间，也不会与脚本其他部分的变量发生冲突。
- en: This encapsulation makes functions safer and less error-prone than just using
    global variables everywhere. It prevents accidental naming collisions and makes
    it clear which variables are used where.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种封装使得函数比到处使用全局变量更加安全，错误率也更低。它可以防止意外的命名冲突，并清晰地表明哪些变量在何处使用。
- en: Of course, sometimes you do want to share variables between functions or with
    the main script. Bash allows this by declaring variables with the **global** keyword
    or by using **upvar-style** references. But these techniques should be used sparingly.
    In general, it’s best to keep functions as independent and self-contained as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时你确实需要在函数之间或与主脚本共享变量。Bash 通过使用 **global** 关键字或 **upvar-style** 引用来允许这种做法。但这些技术应该谨慎使用。一般来说，最好保持函数的独立性和自包含性。
- en: Testability
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性
- en: Another major benefit of Bash functions is that they make your code more testable.
    It’s much easier to write unit tests for individual functions than for a whole
    script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 函数的另一个主要好处是，它们使得代码更易于测试。为单个函数编写单元测试比为整个脚本编写测试要容易得多。
- en: You can write test cases that call your functions with different arguments and
    verify that they produce the expected output or side effects. This gives you more
    confidence that your code is correct and helps prevent regressions when you make
    changes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写测试用例，使用不同的参数调用函数，并验证它们是否产生预期的输出或副作用。这能让你更加确信代码是正确的，并且在做修改时帮助防止回归问题。
- en: There are several popular frameworks for unit testing Bash code, such as **Bats**
    and **shUnit2** . These allow you to write concise, readable test cases in a familiar
    **xUnit** style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个流行的框架可以用于单元测试 Bash 代码，例如 **Bats** 和 **shUnit2**。这些框架允许你以熟悉的 **xUnit** 风格编写简洁、易读的测试用例。
- en: Without functions, your Bash code is much harder to test in an automated fashion.
    You might have to resort to clunky end-to-end tests that invoke your whole script
    with different arguments. These tests are slower, more brittle, and harder to
    maintain.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有函数，你的 Bash 代码将很难以自动化的方式进行测试。你可能不得不采用笨拙的端到端测试，使用不同的参数调用整个脚本。这些测试较慢、更加脆弱，且更难维护。
- en: Performance
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Finally, using Bash functions can also improve the performance of your scripts,
    especially if you’re calling the same code multiple times.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Bash 函数还可以提高脚本的性能，尤其是当你多次调用相同的代码时。
- en: When you call a function, Bash doesn’t have to spawn a new process or reparse
    the function definition each time. The function code is already loaded in memory,
    so the overhead of calling a function is very low.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，Bash 不需要每次都生成一个新进程或重新解析函数定义。函数的代码已经加载到内存中，因此调用函数的开销非常低。
- en: In contrast, if you put the same code in a separate script and invoke it with
    **bash myscript.sh** , Bash has to fork a new process and parse the script from
    disk each time. For code that’s called in a tight loop, this overhead can really
    add up.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果你将相同的代码放在一个单独的脚本中，并使用**bash myscript.sh**来调用它，Bash每次都需要创建一个新进程并从磁盘解析该脚本。对于在紧密循环中调用的代码，这种开销会累积起来。
- en: Of course, the performance gains of functions are usually pretty small in absolute
    terms. Spawning processes in Bash are already fast. But in scripts that prioritize
    performance, using functions instead of separate scripts can give you a little
    extra boost.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数的性能提升在绝对意义上通常是非常小的。Bash中产生进程的速度已经很快。但是在优先考虑性能的脚本中，使用函数代替单独的脚本可以为你提供一点额外的提升。
- en: Now that you have an understanding of why functions are useful, let’s explore
    how to define and call a function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了函数的用途，让我们来探讨如何定义和调用一个函数。
- en: Defining and calling a function
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和调用函数
- en: 'To define a function in Bash, you use the following syntax (the code can be
    found in this chapter’s folder in the book’s GitHub repository as **ch05_function_
    definition.sh** ):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中定义一个函数，你可以使用以下语法（代码可以在本章的GitHub仓库文件夹中找到，名为**ch05_function_definition.sh**）：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use the **function** keyword before the function name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在函数名之前使用**function**关键字：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the components of a function definition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下函数定义的组件：
- en: '**function_name** : This is the name you give to your function. It should be
    descriptive and follow the same naming conventions as variables (alphanumeric
    characters and underscores, starting with a letter or underscore).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**function_name**：这是你给函数起的名字。它应该具有描述性，并遵循与变量相同的命名规则（字母数字字符和下划线，以字母或下划线开头）。'
- en: '**()** : The parentheses after the function name are required.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**()**：函数名后的圆括号是必需的。'
- en: '**{** and **}** : The curly braces enclose the body of the function, where
    you put the commands that make up the function.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**{** 和 **}**：花括号包围了函数体，你在其中放置构成函数的命令。'
- en: 'Here’s a simple example of a function that prints a greeting:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例函数，它打印问候语：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following provides an explanation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释：
- en: '**greet** is the name of the function. The function name must be followed by
    parentheses.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**greet**是函数的名称。函数名后面必须跟圆括号。'
- en: The curly braces, **{}** , enclose the body of the function.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号**{}**包围了函数体。
- en: The **echo** command inside the function body prints the string **Hello, world!**
    to the console.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体内的**echo**命令将字符串**Hello, world!**打印到控制台。
- en: 'Once you’ve defined a function, you can call it by simply using its name followed
    by any arguments (if required). Here’s an example with a function definition for
    th e **greet** function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了函数，你可以通过简单地使用其名称并加上任何参数（如果需要）来调用它。以下是一个**greet**函数的定义示例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is how we call the function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何调用该函数：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code can be found in the book’s GitHub repository as **ch05_greet.sh**
    , and we can explain it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在书本的GitHub仓库中找到，名为**ch05_greet.sh**，我们可以如下解释：
- en: The **greet** function is defined with the **echo** command, which prints **Hello,
    world!** .
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**greet**函数是通过**echo**命令定义的，它将**Hello, world!**打印出来。'
- en: To call the function, we simply use its name, **greet** , on a new line.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数时，我们只需在新的一行中使用它的名称**greet**。
- en: When the script is executed, the **greet** function is called, and the output
    **Hello, world!** is printed to the console.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当脚本执行时，**greet**函数被调用，输出**Hello, world!**被打印到控制台。
- en: You can call a function multiple times within your script.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中多次调用一个函数。
- en: Having learned how to declare and call functions, let’s move on to the next
    section where you’ll learn all about passing arguments to functions and how to
    apply this to practical applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了如何声明和调用函数后，让我们进入下一部分，在这里你将学习如何将参数传递给函数以及如何将其应用于实际应用中。
- en: Passing arguments to functions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: Bash functions are a powerful tool for automating repetitive tasks and creating
    reusable code blocks. They allow you to encapsulate a series of commands into
    a single, named unit that can be called from anywhere in your script. However,
    functions become even more versatile and flexible when you can pass arguments
    to them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Bash函数是自动化重复任务和创建可重用代码块的强大工具。它们允许你将一系列命令封装成一个单一的、命名的单元，可以从脚本中的任何地方调用。然而，当你能够向它们传递参数时，函数会变得更加多功能和灵活。
- en: Passing arguments to Bash functions is a technique that enables you to provide
    dynamic input to your functions, making them more adaptable and reusable across
    different scenarios. By accepting arguments, functions can perform actions based
    on the specific values passed to them, rather than relying on hardcoded or predefined
    values within the function itself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Bash 函数传递参数是一种技术，可以让你为函数提供动态输入，使它们在不同场景中更具适应性和可重用性。通过接受参数，函数可以根据传递给它们的特定值执行操作，而不是依赖于函数内部的硬编码或预定义值。
- en: 'Here are a few reasons why passing arguments to Bash functions is beneficial:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是向 Bash 函数传递参数的一些好处：
- en: '**Flexibility** : Functions that accept arguments can be used in a variety
    of contexts. Instead of creating multiple functions with slight variations, you
    can create a single function that adapts its behavior based on the arguments provided.
    This promotes code reuse and reduces duplication.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：接受参数的函数可以在多种上下文中使用。你可以创建一个单一的函数，根据传递的参数调整其行为，而不是创建多个略有不同的函数。这促进了代码的重用并减少了重复。'
- en: '**Parameterization** : Arguments allow you to parameterize your functions,
    meaning you can pass different values to the function to control its behavior.
    This enables you to customize the function’s actions based on specific requirements
    or inputs, making it more versatile and applicable to different situations.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化**：参数允许你对函数进行参数化，这意味着你可以传递不同的值来控制函数的行为。这使你能够根据特定的需求或输入自定义函数的操作，使其更加多才多艺，适用于不同的场景。'
- en: '**Modularity** : By accepting arguments, functions become self-contained modules
    that can operate independently of the surrounding code. They can be easily moved
    or reused in other scripts without requiring significant modifications. This modularity
    enhances code organization and maintainability.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：通过接受参数，函数变成了自包含的模块，可以独立于周围的代码运行。它们可以轻松地移动或在其他脚本中重用，而无需进行重大修改。这种模块化提升了代码组织和可维护性。'
- en: '**Readability** : When functions accept arguments, it makes the code more readable
    and self-explanatory. The arguments provide a clear indication of what values
    the function expects and how it will use them. This improves code comprehension
    and makes it easier for other developers to understand and maintain the script.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：当函数接受参数时，它使代码更加易读和自解释。参数清楚地指示了函数期望的值以及如何使用它们。这提高了代码的可理解性，并使其他开发人员更容易理解和维护脚本。'
- en: '**Efficiency** : Passing arguments to functions can help optimize your code
    by avoiding the need for global variables or complex logic within the function.
    Instead of relying on external variables, the function can receive the necessary
    data directly through its arguments, making the code more efficient and focused.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：向函数传递参数可以通过避免在函数内部使用全局变量或复杂逻辑来帮助优化代码。函数可以直接通过其参数接收所需的数据，而不依赖于外部变量，从而使代码更加高效和专注。'
- en: Throughout this tutorial, we will explore the different ways to pass arguments
    to Bash functions and demonstrate how to effectively utilize this technique in
    your scripts. By mastering the art of passing arguments, you’ll be able to create
    more flexible, reusable, and maintainable Bash functions that can greatly enhance
    your scripting capabilities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探索传递参数给 Bash 函数的不同方式，并展示如何在脚本中有效利用这一技术。通过掌握传递参数的技巧，你将能够创建更加灵活、可重用且易于维护的
    Bash 函数，从而大大增强你的脚本能力。
- en: So, let’s dive in and learn how to harness the power of passing arguments to
    Bash functions!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们深入学习如何利用向 Bash 函数传递参数的强大功能吧！
- en: 'Let’s start with a basic example of a Bash function that accepts arguments:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个基本的 Bash 函数示例开始，该函数接受参数：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you run this script and call the **greet** function, it will output the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本并调用 **greet** 函数时，它将输出以下内容：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Bash functions can accept multiple arguments. Let’s modify the previous example
    to handle multiple arguments (this code can be found in the book’s GitHub repository
    as **ch05_greet_args.sh** ):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 函数可以接受多个参数。让我们修改之前的示例，以处理多个参数（这段代码可以在书籍的 GitHub 仓库中找到，文件名为 **ch05_greet_args.sh**
    ）：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following provides an explanation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关解释：
- en: The **greet** function now expects two arguments.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**greet** 函数现在期望两个参数。'
- en: Inside the function, **$1** refers to the first argument, and **$2** refers
    to the second argument.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，**$1** 代表第一个参数，**$2** 代表第二个参数。
- en: The **echo** command is updated to include both arguments in the greeting message.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新后的 **echo** 命令将两个参数都包括在问候消息中。
- en: 'We call the **greet** function with two arguments: **John** and **Doe** .'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用 **greet** 函数并传入两个参数：**John** 和 **Doe**。
- en: 'The output will be as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Having learned the basics of passing arguments, let’s move on to learn more
    advanced use cases for passing arguments to functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了基本的参数传递方式后，让我们继续学习一些更高级的参数传递用法。
- en: Handling a variable number of arguments
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理可变数量的参数
- en: 'Sometimes, you may want to create a function that can handle a variable number
    of arguments. Bash provides a special variable, **$@** , that represents all the
    arguments passed to the function. Here’s an example where we use this concept
    to loop through usernames (this code can be found in the book’s GitHub repository
    a s **ch05_variable_args.sh** ):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望创建一个可以处理可变数量参数的函数。Bash 提供了一个特殊的变量 **$@**，它表示传递给函数的所有参数。这里有一个示例，展示如何使用这个概念循环处理用户名（这段代码可以在本书的
    GitHub 仓库中找到，文件名为 **ch05_variable_args.sh**）：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following provides an explanation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个解释：
- en: The **print_arguments** function is defined to handle a variable number of arguments.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**print_arguments** 函数定义为处理可变数量的参数。'
- en: Inside the function, a **for** loop is used to iterate over all the arguments
    passed to the function using **$@** , which represents the array of arguments.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，使用 **for** 循环迭代通过 **$@** 传递给函数的所有参数，**$@** 表示参数数组。
- en: The **echo** command is used to print each argument on a separate line.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **echo** 命令将每个参数打印在单独的一行。
- en: 'We call the **print_arguments** function with three arguments: **apple** ,
    **banana** , and **cherry** .'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用 **print_arguments** 函数并传入三个参数：**apple**、**banana** 和 **cherry**。
- en: 'The output will be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the **$@** variable represents the array of arguments passed to a script
    or function, it’s also helpful to know about the **$#** variable, which represents
    the count of arguments. You should always ensure that the user has entered the
    correct number of arguments if the script or function requires them. This is shown
    in the following code, and it can also be found in the book’s GitHub reposit ory
    as **ch05_count_args.sh** :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **$@** 变量表示传递给脚本或函数的参数数组，但了解 **$#** 变量也很有用，**$#** 代表参数的个数。如果脚本或函数要求一定数量的参数，您应该始终确保用户输入了正确的参数数量。以下代码展示了这一点，您也可以在本书的
    GitHub 仓库中找到它，文件名为 **ch05_count_args.sh**：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This **if** statement checks that the number of arguments is not equal to **2**
    . If the test is true, it prints a helpful usage statement and exits. The **$0**
    variable represents the name of the script.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 **if** 语句检查参数的数量是否不等于 **2**。如果条件为真，它将打印一个有用的使用说明并退出。**$0** 变量表示脚本的名称。
- en: Default values for arguments
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数的默认值
- en: 'You can assign default values to function arguments in case they are not provided
    when calling the function. Here’s an example (this code can be found in the book’s
    GitHub repositor y as **ch05_default_args.sh** ):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为函数参数分配默认值，以防在调用函数时未提供这些参数。以下是一个示例（这段代码可以在本书的 GitHub 仓库中找到，文件名为 **ch05_default_args.sh**）：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following provides an explanation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个解释：
- en: The **greet** function is defined with one argument.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**greet** 函数定义了一个参数。'
- en: 'Inside the function, a local variable, **name** , is assigned the value of
    the first argument using **${1:-"Guest"}** . If the first argument is not provided,
    it defaults to **Guest** . This is broken down further here:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，使用 **${1:-"Guest"}** 将第一个参数赋值给局部变量 **name**。如果没有提供第一个参数，它将默认值为 **Guest**。这里有进一步的解释：
- en: Local variables will be explained later in this chapter. Basically, a variable
    declared as local is valid only while the function is executing. Once the local
    variable returns control back to the main script or function that called it, the
    local variable can no longer be referenced.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量将在本章稍后解释。基本上，声明为局部的变量只在函数执行时有效。当局部变量将控制权交还给调用它的主脚本或函数时，局部变量将不再可用。
- en: '**1** refers to the first argument ( **$1** ). The second argument ( **$2**
    ) would be referred to as **2** .'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 表示第一个参数（**$1**）。第二个参数（**$2**）将被称为 **2**。'
- en: '**:-** is the default value operator.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**:-** 是默认值操作符。'
- en: '**Guest** is the default value.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Guest** 是默认值。'
- en: The **echo** command is used to print the greeting message with the **name**
    variable.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **echo** 命令打印带有 **name** 变量的问候消息。
- en: 'We call the **greet** function twice: once without an argument and once with
    the argument **John** .'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用了**greet**函数两次：一次没有参数，另一次传入了参数**John**。
- en: 'The output will be as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By including a default value for a function variable, you can write less code
    to cover cases when no parameter is passed to your function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为函数变量设置默认值，你可以编写更少的代码来处理没有传入参数的情况。
- en: This wraps up a thorough review of passing arguments to functions. In the next
    section, you’ll discover why it’s important to understand the scope and lifetime
    of variables in your Bash code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容全面回顾了如何向函数传递参数。在下一节中，你将了解为什么理解Bash代码中变量的作用域和生命周期如此重要。
- en: The scope and lifetime of variables in functions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数中的变量作用域和生命周期
- en: When writing Bash scripts, it’s important to understand how variable scope and
    lifetime work, especially when dealing with functions. Properly managing variables
    can help avoid bugs, make your code more maintainable, and prevent unintended
    side effects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Bash脚本时，理解变量的作用域和生命周期是非常重要的，尤其是在处理函数时。合理管理变量有助于避免错误，使代码更具可维护性，并防止意外的副作用。
- en: '**Variable scope** refers to the visibility and accessibility of a variable
    within a script. It determines where a variable can be accessed and modified.
    Understanding variable scope is crucial for writing clean, modular, and reusable
    code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量作用域**指的是变量在脚本中的可见性和可访问性。它决定了变量在哪些地方可以被访问和修改。理解变量作用域对于编写简洁、模块化和可重用的代码至关重要。'
- en: '**Lifetime** , on the other hand, refers to how long a variable exists and
    retains its value during the execution of a script. Variables with different lifetimes
    can have different implications on resource usage and data persistence.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期**指的是变量在脚本执行过程中存在并保持其值的时间长短。不同生命周期的变量可能对资源使用和数据持久性产生不同的影响。'
- en: Properly managing variable scope and lifetime becomes particularly important
    when working with functions. Functions allow you to encapsulate reusable code
    blocks, but they also introduce their own scope. Understanding how variables behave
    within and across functions is essential for writing robust and maintainable Bash
    scripts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正确管理变量的作用域和生命周期在处理函数时尤其重要。函数允许你封装可重用的代码块，但它们也引入了自己的作用域。理解变量在函数内外的行为对于编写稳健且可维护的Bash脚本至关重要。
- en: In this tutorial, we’ll explore Bash variable scope and lifetime within functions,
    using examples to illustrate variable lifetime.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将通过示例探讨Bash中函数内变量的作用域和生命周期。
- en: Global variables
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: By default, variables declared in a Bash script have global scope, meaning they
    can be accessed and modified from anywhere within the script, including inside
    functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在Bash脚本中声明的变量具有全局作用域，这意味着它们可以在脚本的任何地方被访问和修改，包括函数内部。
- en: 'Here’s an example (this code can be found in the book’s GitHub repository as
    **ch05_global_var.sh** ):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例（该代码可以在本书的GitHub仓库中找到，文件名为**ch05_global_var.sh**）：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following provides an explanation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释内容：
- en: '**Line 3** : We declare a global variable, **name** , and assign it the value
    **John** .'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3行**：我们声明了一个全局变量**name**，并为其赋值**John**。'
- en: '**Lines 5-7** : We define a function called **greet** that prints a greeting
    message using the **name** variable.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5-7行**：我们定义了一个名为**greet**的函数，使用**name**变量打印问候信息。'
- en: '**Line 9** : We call the **greet** function, which accesses the global **name**
    variable and prints **Hello, John!** .'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9行**：我们调用了**greet**函数，它访问了全局的**name**变量并打印了**Hello, John!**。'
- en: '**Line 10** : We print the value of the **name** variable, which is still accessible
    outside the function.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行**：我们打印了**name**变量的值，它仍然可以在函数外部访问。'
- en: In this example, the **name** variable is global and can be accessed both inside
    the **greet** function and in the main script.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，**name**变量是全局的，可以在**greet**函数内和主脚本中访问。
- en: Local variables
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'To limit the scope of a variable to a specific function, you can declare it
    as a local variable using the **local** keyword. Local variables are only accessible
    within the function where they are declared. If the **local** keyword is not used,
    then the variable is global. Here’s an example (this code is found in the book’s
    Gi tHub repository as **ch05_local_var.sh** ):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将变量的作用域限制在特定函数内，可以使用**local**关键字将其声明为局部变量。局部变量仅在声明它的函数内可访问。如果未使用**local**关键字，那么该变量就是全局的。以下是一个示例（该代码可以在书籍的GitHub仓库中找到，文件名为**ch05_local_var.sh**）：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following provides an explanation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释：
- en: '**Lines 3-6** : We define a function called **greet** that declares a local
    variable, **name** , using the **local** keyword, and assigns it the value **Alice**
    . The **name** variable is only accessible within the **greet** function.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3-6行**：我们定义了一个名为**greet**的函数，该函数声明了一个局部变量**name**，使用**local**关键字，并赋值为**Alice**。**name**变量仅在**greet**函数内可访问。'
- en: '**Line 5** : We print a greeting message using the local **name** variable.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5行**：我们使用局部**name**变量打印了问候信息。'
- en: '**Line 8** : We call the **greet** function, which prints **Hello, Alice!**
    .'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第8行**：我们调用了**greet**函数，它打印了**Hello, Alice!**。'
- en: '**Line 9** : We attempt to print the value of the **name** variable outside
    the function, but it is not accessible, resulting in an empty output.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9行**：我们尝试在函数外打印**name**变量的值，但它不可访问，因此输出为空。'
- en: In this example, the **name** variable is local to the **greet** function and
    cannot be accessed outside of it. Attempting to use **$name** outside the function
    results in an empty value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，**name**变量是**greet**函数的局部变量，无法在函数外访问。试图在函数外使用**$name**会导致空值。
- en: Variable lifetime
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量生命周期
- en: The lifetime of a variable depends on its scope. Global variables have a lifetime
    that spans the entire script execution, while local variables have a lifetime
    limited to the function in which they are declared.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的生命周期取决于其作用域。全局变量的生命周期贯穿整个脚本执行，而局部变量的生命周期仅限于声明它们的函数。
- en: 'Here’s an example that demonstrates variable lifetime (this code is found in
    the book’s GitH ub repository as **ch05_var_lifetime.sh** ):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个展示变量生命周期的示例（该代码可以在书籍的GitHub仓库中找到，文件名为**ch05_var_lifetime.sh**）：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following provides an explanation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释：
- en: '**Line 3** : We declare a global variable, **global_var** , and assign it the
    value **I''m global** .'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3行**：我们声明了一个全局变量**global_var**，并赋值为**I''m global**。'
- en: '**Lines 5-10** : We define a function called **my_function** that declares
    a local variable, **local_var** , and assigns it the value **I''m local** . Inside
    the function, we print the values of both the global and local variables.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5-10行**：我们定义了一个名为**my_function**的函数，该函数声明了一个局部变量**local_var**，并赋值为**I''m
    local**。在函数内，我们打印了全局变量和局部变量的值。'
- en: '**Line 12** : We call the **my_function** function.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第12行**：我们调用了**my_function**函数。'
- en: '**Lines 14-16** : Outside the function, we print the values of the global and
    local variables.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14-16行**：在函数外，我们打印全局变量和局部变量的值。'
- en: In this example, the global variable, **global_var** , is accessible both inside
    and outside the function, demonstrating its lifetime throughout the script. On
    the other hand, the local variable, **local_var** , is only accessible within
    the **my_function** function and has no value outside of it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，全局变量**global_var**在函数内外都可以访问，展示了它的生命周期贯穿整个脚本。而局部变量**local_var**仅在**my_function**函数内可访问，函数外没有值。
- en: Modifying global variables inside functions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改全局变量
- en: If you need to modify a global variable inside a function, you can do so by
    referencing the variable without any special declaration. Because Bash lacks a
    **global** keyword, any variable that lacks the **local** keyword is effectively
    global. It’s generally recommended to minimize the modification of global variables
    inside functions to avoid unexpected side effects and maintain code clarity.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在函数内修改全局变量，可以通过直接引用该变量而无需任何特殊声明来实现。由于Bash没有**global**关键字，任何没有使用**local**关键字的变量实际上都是全局变量。通常建议尽量避免在函数内修改全局变量，以避免意外的副作用并保持代码的清晰性。
- en: 'Here’s an example that modifies a global variable inside a function (this code
    can be found in the book’s GitHub repository as **ch05_modify_global_var.sh**
    ):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在函数内修改全局变量的示例（该代码可以在书籍的GitHub仓库中找到，文件名为**ch05_modify_global_var.sh**）：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following provides an explanation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释：
- en: '**Line 3** : We declare a global variable, **count** , and initialize it to
    **0** .'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3行**：我们声明一个全局变量，**count**，并将其初始化为**0**。'
- en: '**Lines 5-7** : We define a function called **increment** that modifies the
    global **count** variable by incrementing its value by **1** .'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5-7行**：我们定义了一个名为**increment**的函数，该函数通过将全局**count**变量的值增加**1**来修改它。'
- en: '**Line 9** : We print the value of **count** before calling the **increment**
    function.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9行**：我们在调用**increment**函数之前打印**count**的值。'
- en: '**Line 10** : We call the **increment** function, which modifies the global
    **count** variable.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10行**：我们调用**increment**函数，它修改了全局的**count**变量。'
- en: '**Line 11** : We print the value of **count** after calling the **increment**
    function.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行**：我们在调用**increment**函数后打印**count**的值。'
- en: In this example, the **increment** function directly modifies the global **count**
    variable, incrementing its value by **1** . The modification is reflected outside
    the function, as evidenced by the output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，**increment**函数直接修改了全局的**count**变量，将它的值增加了**1**。这种修改在函数外部得以反映，从输出结果中可以看到这一点。
- en: Understanding variable scope and lifetime is crucial for writing clean, maintainable,
    and bug-free Bash scripts. Global variables have a scope that spans the entire
    script, while local variables are limited to the function in which they are declared.
    The lifetime of a variable depends on its scope, with global variables existing
    throughout the script execution and local variables existing only within their
    respective functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理解变量的作用域和生命周期对于编写清晰、可维护和无错误的 Bash 脚本至关重要。全局变量的作用域覆盖整个脚本，而局部变量仅限于声明它们的函数。变量的生命周期取决于它的作用域，全球变量在整个脚本执行过程中都存在，而局部变量仅在其所属的函数内存在。
- en: By properly managing variable scope and lifetime, you can create modular and
    reusable code, avoid naming conflicts, and maintain better control over your script’s
    behavior. It’s generally recommended to use local variables within functions to
    encapsulate data and prevent unintended side effects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确管理变量的作用域和生命周期，你可以创建模块化和可重用的代码，避免命名冲突，并更好地控制脚本的行为。通常建议在函数中使用局部变量来封装数据，并防止意外副作用。
- en: Remember to be cautious when modifying global variables inside functions, as
    it can lead to unexpected behavior and make your code harder to reason about.
    Whenever possible, aim for a clear separation of concerns and minimize the reliance
    on global variables.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 修改全局变量时要小心，因为这可能导致意外行为，并使得代码难以推理。尽可能实现关注点的清晰分离，并减少对全局变量的依赖。
- en: With a solid understanding of Bash variable scope and lifetime, you’ll be well
    equipped to write more robust and maintainable scripts, making your Bash programming
    experience more enjoyable and productive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在充分理解 Bash 变量作用域和生命周期后，你将能够编写更健壮、更易维护的脚本，使你的 Bash 编程体验更加愉快和高效。
- en: Having gained a thorough understanding of functions, in the next section, we’ll
    build on that knowledge to explore advanced function techniques that I’m confident
    you’ll find useful in your Bash scripting.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解函数之后，在接下来的章节中，我们将基于这些知识，探索一些我确信你会在 Bash 脚本中找到有用的高级函数技巧。
- en: Advanced function techniques
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级函数技巧
- en: In this section, we’ll explore some advanced techniques for working with Bash
    functions, including return values and recursive functions. We’ll provide code
    examples and thorough explanations to help you master these concepts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索一些用于处理 Bash 函数的高级技巧，包括返回值和递归函数。我们将提供代码示例和详细解释，帮助你掌握这些概念。
- en: Function return values
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数返回值
- en: In Bash, functions don’t return values in the same way that functions in most
    programming languages do. Instead, they return an exit status, also known as a
    **return code** , which is an integer where **0** typically indicates success
    and any non-zero value indicates an error or some type of failure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，函数的返回值与大多数编程语言中的函数不同。它们返回的是退出状态，也称为**返回码**，这是一个整数，其中**0**通常表示成功，任何非零值表示错误或某种类型的失败。
- en: Returning an exit status
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回退出状态
- en: 'A Bash function returns an exit status using the **return** command. By default,
    a Bash function will return the exit status of the last command executed within
    the function. Here’s a basic example (this code is provided in the book’s GitHub
    repository as **ch05_exit_status.sh** ):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Bash函数使用**return**命令返回退出状态。默认情况下，Bash函数将返回函数内最后执行命令的退出状态。以下是一个基本示例（此代码在本书的GitHub仓库中作为**ch05_exit_status.sh**提供）：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the **check_file** function attempts to list a file provided
    as an argument to the function. The **$?** special variable captures the exit
    status of the last command executed, which in this case is **ls** . After the
    function is called, **$?** will contain the return status of the function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**check_file**函数尝试列出作为函数参数提供的文件。**$?**特殊变量捕获最后执行命令的退出状态，在本例中是**ls**。函数调用后，**$?**将包含函数的返回状态。
- en: 'You can explicitly set a return value from a function using the **return**
    command followed by an integer. Here’s an example (this code is provided in the
    book’s G itHub repository as **ch05_explicit_exit_status.sh** ):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**return**命令后跟一个整数来显式设置函数的返回值。以下是一个例子（此代码在本书的GitHub仓库中作为**ch05_explicit_exit_status.sh**提供）：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding script, **is_even** checks whether a number is even. If the
    number is even, it returns **0** ; otherwise, it returns **1** . The result of
    the function call is then checked to print whether the number is even or odd.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的脚本中，**is_even**检查一个数字是否是偶数。如果数字是偶数，它返回**0**；否则返回**1**。然后检查函数调用的结果，打印该数字是偶数还是奇数。
- en: Using output instead of return codes
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用输出代替返回码
- en: 'If you need to capture output from a function rather than just an exit status,
    you can use command substitution. Here’s an example of setting a return value
    by using both a variable and the **echo** command (this code is provided in the
    book’s GitHub repository as **ch05_command_substitution.sh** ):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要捕获函数的输出而不仅仅是退出状态，你可以使用命令替换。以下是通过同时使用变量和**echo**命令设置返回值的示例（此代码在本书的GitHub仓库中作为**ch05_command_substitution.sh**提供）：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following provides an explanation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了一个解释：
- en: In this example, we define a function called **square** that takes one argument
    and calculates its square.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个名为**square**的函数，它接受一个参数并计算它的平方。
- en: Inside the function, we perform the calculation **$1 * $1** and assign the result
    to a local variable called **result** .
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，我们执行计算**$1 * $1**并将结果赋值给一个名为**result**的局部变量。
- en: The math expression **$1 * $1** is enclosed in Bash shell arithmetic expansion
    by enclosing the factors as **$(($1 * $** **1))** .
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学表达式**$1 * $1**通过将因子括起来，用Bash shell算术扩展**$(($1 * $1))**进行封装。
- en: We then use **echo** to output the value of **result** .
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们使用**echo**输出**result**的值。
- en: To capture the return value of the function, we use command substitution, **$()**
    , when calling the function.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了捕获函数的返回值，我们在调用函数时使用命令替换**$()**。
- en: We assign the output of **square 5** to a variable called **squared** .
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将**square 5**的输出赋值给一个名为**squared**的变量。
- en: Finally, we print a message that includes the value of **squared** , which is
    **25** .
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们打印一条包含**squared**值的消息，值为**25**。
- en: 'For what you have learned, it’s important that you remember the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所学的内容，记住以下几点是非常重要的：
- en: '**Exit status range** : The exit status should be an integer from 0 to 255.
    Any value outside this range might wrap around (e.g., 256 becomes 0).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出状态范围**：退出状态应该是0到255之间的整数，任何超出此范围的值可能会绕回（例如，256变为0）。'
- en: '**Using output** : Functions can output data to **stdout** , which can be captured
    with command substitution.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用输出**：函数可以将数据输出到**stdout**，并通过命令替换捕获该输出。'
- en: '**Return early** : You can use multiple return statements in a function to
    exit the function under different conditions early.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前返回**：你可以在函数中使用多个返回语句，在不同条件下提前退出函数。'
- en: Having gained a thorough knowledge of using functions in Bash code, let’s take
    a brief look at how to use them recursively in your code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解如何在Bash代码中使用函数后，让我们简要了解如何在代码中递归地使用它们。
- en: Recursive functions
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'Bash supports **recursive functions** , which are functions that call themselves.
    Recursive functions are useful for solving problems that can be divided into smaller
    subproblems. Here’s an example that calculates the factorial of a number using
    recursion (this code is provided in the bo ok’s GitHub repository as **ch05_recursive_function.sh**
    ):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 支持**递归函数**，即调用自身的函数。递归函数对于解决可以分解成更小子问题的问题非常有用。这里有一个示例，使用递归计算一个数的阶乘（此代码已在书籍的
    GitHub 仓库中提供，文件名为**ch05_recursive_function.sh**）：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following provides an explanation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解释：
- en: In this example, we define a function called **factorial** that takes one argument,
    the number for which we want to calculate the factorial. The function uses an
    **if** statement to check whether the argument is equal to **0** . If it is, the
    function returns **1** , which is the base case of the recursion.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个名为**factorial**的函数，它接受一个参数，即我们要计算阶乘的数字。该函数使用**if**语句检查参数是否等于**0**。如果是，函数返回**1**，这是递归的基本情况。
- en: If the argument is not **0** , the function calls itself with the argument decremented
    by **1** . This recursive call continues until the base case is reached. The result
    of each recursive call is stored in a local variable called **prev** . Finally,
    the function multiplies the current argument by the result of the previous recursive
    call and returns the product using **echo** .
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数不是**0**，该函数会以参数减去**1**的值递归调用自身。这个递归调用将持续进行，直到达到基本情况。每次递归调用的结果会存储在一个名为**prev**的局部变量中。最后，函数将当前参数与上一次递归调用的结果相乘，并使用**echo**返回乘积。
- en: To use the **factorial** function, we call it with an argument of **5** and
    capture the result using command substitution. We assign the result to a variable
    called **result** and print a message that includes the factorial of **5** , which
    is **120** .
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用**阶乘**函数，我们用**5**作为参数调用它，并通过命令替换捕获结果。我们将结果赋值给一个名为**result**的变量，并打印一条消息，显示**5**的阶乘结果，即**120**。
- en: One example of a good use case for a recursive function is when performing file
    and directory enumeration in a web application. You would want to create an array
    of discovered directories and begin anew inside each directory to discover files.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的一个典型应用场景是在 Web 应用中进行文件和目录枚举。你会希望创建一个已发现目录的数组，并在每个目录内重新开始，发现文件。
- en: Recursive functions can be powerful, but they can also be difficult to understand
    and debug. It’s important to ensure that the recursive function has a well-defined
    base case to prevent infinite recursion and to carefully consider the termination
    condition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数可能非常强大，但它们也可能难以理解和调试。确保递归函数有一个明确的基本情况非常重要，以防止出现无限递归，并且需要仔细考虑终止条件。
- en: In the next section, we’ll continue building on everything you’ve learned in
    this chapter by learning how to import functions to reduce the amount of code
    you write and reuse code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将继续在本章中学到的内容，学习如何导入函数，以减少你编写的代码量并重用代码。
- en: Importing functions
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入函数
- en: I previously stated that one of the nice features of Bash functions is code
    reuse. You can solve a problem once by writing a function and calling that function
    repeatedly. In programmer lingo, that’s referred to as **don’t repeat yourself**
    , or **DRY** . Now, let’s take that a step further.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，Bash 函数的一个优点是代码重用。你可以通过编写一个函数解决一个问题，并多次调用该函数。在程序员的术语中，这被称为**不要重复自己**，或**DRY**（Don't
    Repeat Yourself）。现在，我们将进一步探讨这一点。
- en: Let’s imagine for a moment that you previously solved a problem by implementing
    a function that you can call as many times as you need. What happens when you
    find the need to use that function in a new Bash script? Do you go searching through
    your scripts to find that function and copy and paste it into your new script?
    This is really not necessary.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想一下，你之前通过实现一个函数解决了一个问题，而这个函数可以根据需要多次调用。那么，当你需要在一个新的 Bash 脚本中使用这个函数时，会发生什么呢？你会去翻找你的脚本，找到那个函数然后复制粘贴到新脚本中吗？其实完全不需要这样做。
- en: Make it a habit to start putting your functions into one script, such as a library
    or module. When you need to use a function that you’ve previously defined, simply
    *source* it before you call that function in your new script.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 养成将函数放入一个脚本中的习惯，比如库或模块。当你需要在新脚本中使用一个你之前定义过的函数时，只需在调用该函数之前*source*它即可。
- en: 'The following example code can be found in this chapter’s folder in the book’s
    GitHub repository as **ch05_importing_funcs_1.sh** :'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码可以在本章文件夹中的 GitHub 仓库中找到，文件名为**ch05_importing_funcs_1.sh**：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, source the script from another script before you call the function (
    **ch05_importing_funcs_2.sh** ):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从另一个脚本中调用函数之前，先加载脚本（**ch05_importing_funcs_2.sh**）：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You should be aware that sourcing a file may add a very small amount of time
    to the startup of the script that sources another script since it has to load
    the sourced script into memory. It has to do this one time only. If you use more
    than one function from a function library file, you source it only one time since
    the whole script is loaded into memory when it’s sourced.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意，加载一个文件可能会稍微增加启动脚本的时间，因为它必须将被加载的脚本载入内存。这个过程只会进行一次。如果你从一个函数库文件中使用多个函数，那么只需加载一次该文件，因为整个脚本会在加载时一次性载入内存。
- en: Having learned how to use functions, from basics through to advanced usage,
    I want to briefly discuss the differences and use cases to help you choose between
    functions and aliases, in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了如何使用函数，从基础到高级应用后，我想简要讨论函数与别名的区别和使用场景，以帮助你在下一部分选择使用函数还是别名。
- en: Functions versus aliases
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数与别名
- en: Functions are essential building blocks in programming that allow developers
    to encapsulate a set of instructions into a reusable block of code. By defining
    functions, programmers can streamline their code, improve readability, and promote
    code reusability. Functions are designed to perform specific tasks when called
    upon, making it easier to manage and maintain code bases. They are a fundamental
    concept in programming languages such as Python, JavaScript, and Java, enabling
    developers to break down complex problems into smaller, more manageable components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中的基本构建块，它允许开发人员将一组指令封装成一个可重用的代码块。通过定义函数，程序员可以简化代码，提高可读性，并促进代码的可重用性。函数在被调用时会执行特定的任务，从而使得管理和维护代码变得更加容易。它们是编程语言（如
    Python、JavaScript 和 Java）中的一个基本概念，使开发人员能够将复杂问题分解成更小、更易管理的组件。
- en: '**Aliases** , on the other hand, serve a different purpose in programming.
    An alias is a symbolic name given to an entity, such as a variable, function,
    or command. Aliases provide a way to create shortcuts or alternative names for
    existing elements in a program. They can help simplify the syntax of commands
    or make code more concise and easier to understand. In Unix-based systems, aliases
    are commonly used to define custom commands or shorten lengthy commands for convenience.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名**在编程中有着不同的用途。别名是给实体（如变量、函数或命令）指定的符号名称。别名提供了一种为程序中现有元素创建快捷方式或替代名称的方法。它们可以帮助简化命令的语法，或者使代码更加简洁、易于理解。在基于
    Unix 的系统中，别名通常用于定义自定义命令或缩短冗长的命令，以便于使用。'
- en: While functions and aliases both play important roles in programming, they serve
    distinct purposes and have different applications. Functions are primarily used
    to encapsulate a set of instructions into a reusable block of code, promoting
    modularity and code organization. On the other hand, aliases are used to create
    symbolic names for entities, providing shortcuts or alternative names for convenience.
    Understanding the differences between functions and aliases can help you leverage
    these programming concepts to improve code quality and efficiency.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数和别名在编程中都扮演着重要角色，但它们服务于不同的目的，并具有不同的应用。函数主要用于将一组指令封装成一个可重用的代码块，促进模块化和代码组织。而别名则用于为实体创建符号名称，为了方便起见，提供快捷方式或替代名称。了解函数和别名之间的区别，可以帮助你利用这些编程概念来提高代码质量和效率。
- en: Now that we’ve explored functions in depth, I want to introduce you to how you
    can use functions outside of scripts to simplify your pentesting workflow. Aliases
    are great for simplifying a workflow because they allow you to create a named
    command you can enter to replace more complicated commands.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入探讨了函数的使用，我想向你介绍如何在脚本外部使用函数，以简化你的渗透测试工作流程。别名非常适合简化工作流程，因为它们允许你创建一个命名命令，可以输入该命令来替代更复杂的命令。
- en: 'For example, I have an alias in my **~/.bashrc** file that simplifies a very
    long, complex command to run a Docker container that provides information about
    a web application. I run this command at the beginning of every web application
    pentest to give me information related to the frameworks in use by the application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在我的**~/.bashrc**文件中有一个别名，它简化了一个非常长且复杂的命令，用来运行一个提供有关Web应用程序信息的Docker容器。我在每次进行Web应用渗透测试时运行这个命令，以便获取与应用程序使用的框架相关的信息：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s a lot to remember, isn’t it?! Thankfully, we have aliases for this purpose.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要记住很多内容，不是吗？！幸运的是，我们有别名来解决这个问题。
- en: While aliases are very handy, they lack one crucial feature that we need; they
    don’t accept parameters such as **$1 $2 $3** . In the preceding alias, when we
    enter the alias in our terminal, anything appended after the alias name is included
    with the command when Bash expands the alias to the full command and executes
    it in the shell.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管别名非常方便，但它们缺少我们所需的一个关键特性；它们不接受像**$1 $2 $3**这样的参数。在前面的别名中，当我们在终端中输入别名时，别名名称后附加的任何内容都会被包含在命令中，当Bash将别名扩展为完整的命令并在Shell中执行时。
- en: Essentially, Bash expands the **zapit www.example.com** command to the **Docker**
    **run** command shown previously with **www.example.com** appended to it. What
    if we wanted to run a command that requires multiple parameters in a particular
    order, so we can’t simply append them after the alias name? This is where functions
    are helpful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Bash将**zapit www.example.com**命令扩展为之前显示的**Docker** **run**命令，并附加了**www.example.com**。如果我们想运行一个需要多个参数并按特定顺序排列的命令，那么我们不能简单地在别名名称后追加参数？这时，函数就显得非常有用。
- en: 'Let’s use generating shellcode with **msfvenom** as an example. **msfvenom**
    is a command that’s included with the **Metasploit Framework** to generate shellcode
    in various formats. This tool is used frequently in pentesting and exploit development:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以使用**msfvenom**生成shellcode为例。**msfvenom**是一个与**Metasploit框架**一起包含的命令，用于生成各种格式的shellcode。这个工具在渗透测试和漏洞开发中非常常用：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This code is provided in the book’s GitHub repository as **ch05_gen_shellcode.sh**
    . We can explain it as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在本书的GitHub仓库中提供，名为**ch05_gen_shellcode.sh**。我们可以如下解释：
- en: We declare a function named **gen_shellcode** .
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为**gen_shellcode**的函数。
- en: If the number of arguments equals **0** , print the usage and exit.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数的数量等于**0**，则打印用法并退出。
- en: In the **msfvenom** command, the first argument, **$1** , is inserted as the
    payload, after **-p** .
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**msfvenom**命令中，第一个参数**$1**被插入为有效载荷，位于**-p**之后。
- en: The **LHOST=$(ip -o -4 a show tun0 | awk '{print $4}'** code gets your IP address
    for the **tun0** network interface and inserts it in place of **$()** .
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LHOST=$(ip -o -4 a show tun0 | awk ''{print $4}'')**代码获取**tun0**网络接口的IP地址，并将其插入到**$()**的位置。'
- en: The second argument, **$2** , is assigned to the **LPORT** variable.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数**$2**被分配给**LPORT**变量。
- en: The third argument, **$3** , is for the output format **-** **f** argument.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数**$3**用于输出格式的**-f**参数。
- en: Finally, add this code at the end of your **~/.bashrc** file and you will be
    able to use this function any time you need to generate shellcode with **msfvenom**
    . If you forget which options are required, simply enter **gen_shellcode** without
    arguments and press the Enter key and it will print the usage example for you.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这段代码添加到你的**~/.bashrc**文件的末尾，你就可以在需要使用**msfvenom**生成shellcode时随时调用这个函数。如果你忘记了需要哪些选项，只需输入**gen_shellcode**而不加任何参数，然后按回车键，它将为你打印用法示例。
- en: In summary, aliases are expanded to represent the command inside the quotes,
    but you’re limited to appending extra arguments after the alias name. With functions,
    there are no limitations. In addition to the great value you get from using functions
    in your scripts, any valid Bash function code can be placed in your **.bashrc**
    file to call on the command line with arguments that are interpolated in the function
    code on execution. Imagine the possibilities for creating automation for your
    pentesting workflow! We’ll be diving into that topic in later chapters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，别名会展开以表示引号中的命令，但你只能在别名名称后追加额外的参数。使用函数时，没有这种限制。除了在脚本中使用函数的巨大价值外，任何有效的Bash函数代码都可以放在你的**.bashrc**文件中，以便在命令行中调用，参数将在执行时插入到函数代码中。想象一下为你的渗透测试工作流程创建自动化的可能性！我们将在后面的章节中深入探讨这个话题。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dove deep into the world of Bash functions and how they
    can revolutionize your scripting game. By mastering functions, you’ll write cleaner,
    more organized, and more efficient scripts that save you time and headaches.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Bash函数的世界，以及它们如何彻底改变你的脚本编写方式。通过掌握函数，你将编写出更简洁、更有组织、更加高效的脚本，从而节省时间并避免头痛。
- en: We started with the basics, understanding what functions are and why they’re
    so helpful. Then we got into the nitty-gritty of passing arguments to functions,
    making them flexible and reusable. We explored the scope and lifetime of variables
    inside functions, so you know exactly what’s happening under the hood.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基础开始，了解了什么是函数以及它们为何如此有用。接着，我们深入探讨了如何向函数传递参数，使其更加灵活和可重用。我们还研究了函数内部变量的作用域和生命周期，让你完全了解函数内部发生的事情。
- en: Things got really exciting when we hit the advanced techniques. You learned
    how to use recursion to elegantly solve complex problems and how to use callbacks
    to make your functions even more powerful. Finally, we compared functions to aliases
    and showed how functions are the clear winner for pentesting workflows.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入高级技巧时，事情变得非常激动人心。你学会了如何使用递归优雅地解决复杂问题，如何使用回调函数让你的函数变得更强大。最后，我们将函数与别名进行了对比，并展示了函数在渗透测试工作流中的明显优势。
- en: Now, you have some serious tools in your scripting toolbox. You can now write
    modular, organized scripts that are easy to read, debug, and maintain. And, most
    importantly, you can use functions to streamline your pentesting process, saving
    you valuable time and effort. So, go forth and script like a pro!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的脚本工具箱里有了一些强大的工具。你现在可以编写模块化、结构化的脚本，这些脚本易于阅读、调试和维护。最重要的是，你可以利用函数来简化渗透测试流程，节省宝贵的时间和精力。所以，去吧，像专家一样编写脚本吧！
- en: In the next chapter, we’ll explore using Bash commands for networking.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索如何使用Bash命令进行网络操作。
