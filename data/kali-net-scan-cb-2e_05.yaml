- en: Fingerprinting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指纹识别
- en: 'After identifying live systems in the target range and enumerating open ports
    on those systems, it is important to start gathering information about them and
    the services that are associated with the open ports. In this chapter, we will
    discuss different techniques used to fingerprint systems and services with Kali
    Linux. These techniques will include banner grabbing, service probe identification,
    operating system identification, SNMP information gathering, and firewall identification.
    Specific recipes in this chapter include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别目标范围内的活动系统并枚举这些系统的开放端口后，接下来需要开始收集有关它们及其与开放端口相关的服务的信息。在本章中，我们将讨论使用 Kali Linux
    对系统和服务进行指纹识别的不同技术。这些技术将包括横幅获取、服务探测识别、操作系统识别、SNMP 信息收集以及防火墙识别。本章中的具体方法包括以下内容：
- en: Banner grabbing with Netcat
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Netcat 获取横幅
- en: Banner grabbing with Python sockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 套接字获取横幅
- en: Banner grabbing with DMitry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DMitry 获取横幅
- en: Banner grabbing with Nmap NSE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap NSE 获取横幅
- en: Banner grabbing with Amap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amap 获取横幅
- en: Service identification with Nmap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行服务识别
- en: Service identification with Amap
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amap 进行服务识别
- en: Operating system identification with Scapy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scapy 进行操作系统识别
- en: Operating system identification with Nmap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行操作系统识别
- en: Operating system identification with xprobe2
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 xprobe2 进行操作系统识别
- en: Passive operating system identification with p0f
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 p0f 进行被动操作系统识别
- en: SNMP analysis with Onesixtyone
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Onesixtyone 进行 SNMP 分析
- en: SNMP analysis with SNMPwalk
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SNMPwalk 进行 SNMP 分析
- en: Firewall identification with Scapy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scapy 进行防火墙识别
- en: Firewall identification with Nmap
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行防火墙识别
- en: Firewall identification with Metasploit
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Metasploit 进行防火墙识别
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Prior to addressing the specific recipes mentioned in the list, we should address
    some of the underlying principles that will be discussed throughout the remainder
    of the chapter. Each of the recipes in this chapter will address tools that can
    be used to perform a few specific tasks. These tasks include banner grabbing,
    service identification, operating system identification, SNMP analysis, and firewall
    identification. Each of these tasks serves the common objective of gathering as
    much information about a target system as possible in order to be able to attack
    that system quickly and efficiently.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理列表中提到的具体方法之前，我们应当先探讨一些本章其余部分中会讨论的基本原理。本章中的每一个方法都会介绍可用于执行一些特定任务的工具。这些任务包括横幅获取、服务识别、操作系统识别、SNMP
    分析和防火墙识别。每一项任务都服务于一个共同的目标，那就是尽可能多地收集目标系统的信息，以便能够迅速高效地对该系统进行攻击。
- en: Before dedicating a large amount of time and resources to attempting to identify
    a remote service, we should determine whether that remote service will identify
    itself to us. Service banners consist of output text that is returned immediately
    when a connection is established with a remote service. It has historically been
    a very common practice for network services to disclose the manufacturer, software
    name, type of service, and even version number in service banners. Fortunately,
    for penetration testers, this information can be extremely useful in identifying
    known weaknesses, flaws, and vulnerabilities in the software. A service banner
    can easily be read by merely connecting to a remote Terminal service. However,
    for this to be an effective information-gathering tool, it should be automated
    so that we do not have to manually connect to each individual service on a remote
    host. The tools that will be addressed in the banner-grabbing recipes in this
    chapter will accomplish the task of automating banner-grabbing to identify as
    many open services as possible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在投入大量时间和资源尝试识别远程服务之前，我们应当判断该远程服务是否会主动向我们揭示自身信息。服务横幅包含在与远程服务建立连接时立即返回的输出文本。历史上，网络服务通常会在服务横幅中披露制造商、软件名称、服务类型，甚至版本号。幸运的是，对于渗透测试人员而言，这些信息在识别软件中的已知弱点、缺陷和漏洞时非常有用。服务横幅可以通过简单地连接到远程终端服务来读取。然而，为了使这成为一个有效的信息收集工具，它应该实现自动化，这样我们就不必手动连接到远程主机上的每个服务。本章中将讨论的横幅获取工具将自动化横幅获取任务，以识别尽可能多的开放服务。
- en: In the event that a remote service does not willingly disclose the software
    and/or version that is running on it, we will need to go to much greater lengths
    to identify the service. It is frequently possible to identify unique behaviors
    or to solicit unique responses that can be used to positively identify a service.
    It is usually even possible to identify specific versions of a particular service
    due to subtle variations in response or behavior. However, knowledge of all these
    unique signatures would be difficult for any human to retain. Fortunately, there
    are numerous tools that have been created to send large numbers of probes to remote
    services to analyze the responses and behavior of those target services. Similarly,
    response variation can also be used to identify the underlying operating system
    running on a remote server or workstation. These tools will be discussed in the
    recipes that address service identification and operating system identification.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程服务未主动披露其运行的软件和/或版本，我们将需要付出更多努力来识别该服务。通常可以通过识别独特的行为或请求独特的响应来确定服务。由于响应或行为上的细微差异，通常还可以识别特定服务的版本。然而，了解所有这些独特的特征对于任何人来说都很难记住。幸运的是，已经创建了许多工具，用于向远程服务发送大量探测，分析目标服务的响应和行为。类似地，响应的变化也可以用来识别远程服务器或工作站上运行的操作系统。这些工具将在涉及服务识别和操作系统识别的食谱中进行讨论。
- en: '**Simple Network Management Protocol** (**SNMP**) is a protocol that is designed
    to provide remote administrative services for various types of network devices.
    Management with SNMP is performed using community strings for authentication.
    It is very common for devices to be deployed with the default community strings.
    When this happens, it is often possible for an attacker to remotely gather large
    amounts of information about a target device''s configuration and, in some cases,
    even reconfigure the devices. Techniques that leverage the use of SNMP for information
    gathering will be discussed in the recipes addressing SNMP analysis.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单网络管理协议** (**SNMP**) 是一种旨在为各种类型的网络设备提供远程管理服务的协议。使用 SNMP 进行管理时，通过社区字符串进行身份验证。设备通常会使用默认的社区字符串进行部署。当发生这种情况时，攻击者通常可以远程收集大量目标设备的配置信息，在某些情况下，甚至可以重新配置设备。利用
    SNMP 进行信息收集的技术将在涉及 SNMP 分析的食谱中讨论。'
- en: While gathering information about potential targets, it is important to also
    understand any obstacles that could impact successful reconnaissance or attacks.
    Firewalls are network devices or software that selectively restrict the flow of
    network traffic going to or coming from a particular destination or source. Firewalls
    are often configured to prevent remote access to particular services. The awareness
    of a firewall, which is modifying the flow of traffic between your attacking system
    and the target destination, can be instrumental in attempting to identify ways
    to either evade or bypass its filters. The techniques to identify firewall devices
    and services will be discussed in the recipes that address firewall identification.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集潜在目标信息的同时，了解可能影响成功侦察或攻击的障碍也很重要。防火墙是网络设备或软件，用于有选择性地限制网络流量的流向，通常是流入或流出特定目标或来源的流量。防火墙通常被配置为防止远程访问特定服务。了解防火墙对攻击系统与目标之间的流量进行修改的情况，对于试图识别规避或绕过其过滤器的方式至关重要。识别防火墙设备和服务的技术将在涉及防火墙识别的食谱中进行讨论。
- en: Banner grabbing with Netcat
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Netcat 获取横幅
- en: Netcat is a multipurpose networking tool that can be used to perform multiple
    information-gathering and scanning tasks with Kali Linux. This recipe will demonstrate
    how to use Netcat to acquire service banners in order to identify the services
    associated with open ports on a target system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 是一个多功能的网络工具，可以在 Kali Linux 上执行多种信息收集和扫描任务。本食谱将演示如何使用 Netcat 获取服务横幅，从而识别与目标系统开放端口相关的服务。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Netcat to gather service banners, you will need to have a remote system
    running network services that discloses information when a client device connects
    to them. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on setting up Metasploitable2, refer to the *Installing
    Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Netcat收集服务横幅，你需要有一个远程系统运行网络服务，并且在客户端设备连接时自动披露信息。在提供的示例中，使用了Metasploitable2实例来执行此任务。有关如何设置Metasploitable2的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*配方，*入门*部分。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Follow along to gather banner information using Netcat:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随步骤使用Netcat收集横幅信息：
- en: 'To use Netcat to grab service banners, one must establish a socket connection
    to the intended port on the remote system. To quickly understand the usage of
    Netcat and how it can be used for this purpose, one can call upon the usage output.
    This can be done using the `-h` option:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Netcat抓取服务横幅，必须建立与远程系统上目标端口的套接字连接。为了快速了解Netcat的使用方式以及如何用它完成此任务，可以查看其使用帮助。这可以通过使用`-h`选项来完成：
- en: '![](../images/00501.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00501.jpeg)'
- en: 'By reviewing the various options available for this tool, we can determine
    that a connection can be made to the desired port by specifying the options, followed
    by the IP address and then the port number:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看此工具提供的各种选项，我们可以确定，通过指定选项，后跟IP地址和端口号，可以连接到所需的端口：
- en: '![](../images/00515.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00515.jpeg)'
- en: 'In the example provided, a connection has been made to port `22` of the Metasploitable2
    system at `172.16.69.128`. The `-v` option was used to provide verbose output,
    and the `-n` option was used to connect with the IP address without DNS resolution.
    Here, we can see that the banner returned by the remote host identifies the service
    as SSH, the vendor as OpenSSH, and even the exact version as 4.7\. Netcat maintains
    an open connection, so after reading the banner, you can force to close the connection
    with *Ctrl* + *C*:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，已连接到`172.16.69.128`上的Metasploitable2系统的`22`端口。使用了`-v`选项来提供详细输出，并且使用了`-n`选项通过IP地址连接，而不进行DNS解析。在这里，我们可以看到远程主机返回的横幅标识了该服务为SSH，供应商为OpenSSH，甚至明确标识了版本为4.7。Netcat保持一个打开的连接，因此在读取横幅后，你可以通过*Ctrl*
    + *C*强制关闭连接：
- en: '![](../images/00196.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00196.jpeg)'
- en: By performing a similar scan on port `21` of the same system, we can easily
    acquire service and version information of the running FTP service. In each of
    these cases, a lot of useful information is divulged. Knowledge of the services
    and versions running on a system can often be a key indicator of vulnerabilities,
    which can be used to exploit and compromise the system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对同一系统的`21`端口执行类似的扫描，我们可以轻松获取运行中的FTP服务的服务和版本信息。在这些情况下，很多有用的信息都会被披露。了解系统上运行的服务和版本常常是漏洞的一个关键指示，可以用来利用并攻破系统。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Netcat is able to grab the banners from these services because the services
    are configured to self-disclose this information when a client service connects
    to them. The practice of self-disclosing services and versions was commonly used
    in the past to assure connecting clients that they were connecting to their intended
    destination. As developers are becoming more security conscious, this practice
    is becoming less common. Nonetheless, it is still not uncommon to stumble upon
    poorly developed or older, legacy services that provide too much information in
    the form of service banners.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat能够从这些服务中抓取横幅，因为这些服务被配置为在客户端连接时自动披露此信息。过去，服务和版本的自我披露做法常常被用来确保连接的客户端正连接到其预定的目标。随着开发者安全意识的提高，这种做法逐渐不再常见。然而，仍然有不少开发不成熟或较旧的遗留服务，提供过多的信息作为服务横幅。
- en: Banner grabbing with Python sockets
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python套接字抓取横幅
- en: The `socket` module in Python can be used to connect to network services running
    on remote ports. This recipe will demonstrate how to use Python sockets to acquire
    service banners in order to identify the services associated with open ports on
    a target system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`socket`模块可用于连接远程端口上运行的网络服务。本节将演示如何使用Python套接字获取服务横幅，以便识别目标系统上开放端口所关联的服务。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Python to gather service banners, you will need to have a remote system
    running network services that discloses information when a client device connects
    to them. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on setting up Metasploitable2, refer to the *Installing
    Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*. Additionally, this recipe will require a script to be written
    to the filesystem using a text editor such as Vim or GNU nano. For more information
    on writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Python 收集服务横幅，你需要一个运行网络服务的远程系统，当客户端设备连接到它们时会披露信息。在提供的示例中，使用了 Metasploitable2
    实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参考 [第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中
    *安装 Metasploitable2* 的相关内容，*入门*。此外，本食谱还需要使用文本编辑器（如 Vim 或 GNU nano）编写一个脚本并保存到文件系统。有关编写脚本的更多信息，请参考
    [第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中 *使用文本编辑器（Vim 和 GNU
    nano）* 的相关内容，*入门*。
- en: How to do it….
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s use Python the collect banner information:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 来收集横幅信息：
- en: 'You can interact directly with remote network services using the Python interactive
    interpreter. You can begin using the Python interpreter by calling it directly.
    Here, you can import any specific modules that you wish to use. In this case,
    we will import the `socket` module:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 Python 交互式解释器直接与远程网络服务进行交互。你可以通过直接调用 Python 解释器来开始使用它。在这里，你可以导入任何你希望使用的特定模块。在这个例子中，我们将导入
    `socket` 模块：
- en: '![](../images/00541.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00541.jpeg)'
- en: In the example provided, a new socket is created with the name `bangrab`. The
    `AF_INET` argument is used to indicate that the socket will employ an IPv4 address,
    and the `SOCK_STREAM` argument is used to indicate that TCP transport will be
    used. Once the socket is created, the `connect()` function can be used to initialize
    a connection. In the example, the `bangrab` socket is connected the to port `21`
    on the Metasploitable2 remote host at `172.16.69.128`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，创建了一个名为 `bangrab` 的新套接字。`AF_INET` 参数用于指示套接字将使用 IPv4 地址，`SOCK_STREAM`
    参数用于指示将使用 TCP 协议。一旦创建了套接字，就可以使用 `connect()` 函数来初始化连接。在这个示例中，`bangrab` 套接字连接到 Metasploitable2
    远程主机 `172.16.69.128` 上的端口 `21`。
- en: 'After connecting, the `recv()` function can be used to receive content from
    the service to which the socket is connected. Assuming there is information available,
    it will be printed as output. Here, we can see the banner provided by the FTP
    service running on the Metasploitable2 server. Finally, the `close()` function
    can be used to gracefully end the connection with the remote service. If we attempt
    to connect with a service that is not accepting connections, an error will be
    returned by the Python interpreter:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接后，可以使用 `recv()` 函数从套接字连接的服务中接收内容。如果有可用的信息，它将作为输出打印出来。在这里，我们可以看到由 Metasploitable2
    服务器上运行的 FTP 服务提供的横幅。最后，`close()` 函数可以用于优雅地结束与远程服务的连接。如果我们尝试连接到一个不接受连接的服务，Python
    解释器将返回一个错误：
- en: '![](../images/00552.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00552.jpeg)'
- en: 'If an attempt is made to connect to the TCP port `443` on the Metasploitable2
    system, an error will be returned indicating that the connection was refused.
    This is because there is no service running on this remote port. However, even
    when there are services running on a destination port, it does not mean that a
    service banner will necessarily be available. This can be seen by establishing
    a connection with the TCP port `80` on the Metasploitable2 system:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尝试连接到 Metasploitable2 系统上的 TCP 端口 `443`，将返回一个错误，指示连接被拒绝。这是因为该远程端口没有运行任何服务。然而，即使目标端口上有服务运行，也不意味着一定会有服务横幅可用。通过与
    Metasploitable2 系统上的 TCP 端口 `80` 建立连接可以看到这一点：
- en: '![](../images/00566.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00566.jpeg)'
- en: 'The service running on the port `80` of this system is accepting connections,
    but does not provide a service banner to connecting clients. If the `recv()` function
    is used but no data is available to be received, the function will hang open.
    To automate the practice of collecting banners in Python, an alternative solution
    must be used to identify whether any banner is available to grab prior to calling
    this function. The `select()` function provides a convenient solution to this
    problem:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本系统的端口 `80` 上运行的服务正在接受连接，但未向连接客户端提供服务横幅。如果使用 `recv()` 函数，但没有可接收的数据，函数将会阻塞。为了自动化在
    Python 中收集横幅的操作，必须使用替代方案来识别是否有横幅可以抓取，然后再调用该函数。`select()` 函数为此问题提供了一个便捷的解决方案：
- en: '![](../images/00581.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00581.jpeg)'
- en: A `select` object is created and set to the variable named `ready`. This object
    is passed four arguments to include a read list, a write list, an exception list,
    and an integer value defining the number of seconds until timeout. In this case,
    we only need to identify when the socket is ready to be read from, so the second
    and third arguments are empty. An array is returned with values that correspond
    to each of these three lists.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `select` 对象并将其设置为名为 `ready` 的变量。该对象传递四个参数，包括读取列表、写入列表、异常列表和定义超时时间的整数值。在此情况下，我们只关心套接字是否准备好进行读取，因此第二和第三个参数为空。返回一个数组，数组中的值对应于这三种列表的每个项。
- en: 'We are only interested in whether the `bangrab` socket has any content to read.
    To determine whether this is the case, we can test the first value in the array,
    and if a value exists, we can receive the content from the socket. This entire
    process can then be automated in an executable Python script:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只关心 `bangrab` 套接字是否有内容可以读取。为了确定是否有内容，我们可以测试数组中的第一个值，如果该值存在，则可以从套接字中接收内容。整个过程可以自动化为一个可执行的
    Python 脚本：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the script provided here, three arguments are accepted as input:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此脚本中，接受三个参数作为输入：
- en: The first argument consists of an IP address to test for service banners
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是用于测试服务横幅的 IP 地址
- en: The second argument indicates the first port number in a range of port numbers
    to be scanned
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数表示要扫描的端口范围中的第一个端口号
- en: The third and final argument indicates the last port number in a range of port
    numbers to be scanned
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个也是最后一个参数表示要扫描的端口范围中的最后一个端口号
- en: 'When executed, this script will use Python sockets to connect to all in-range
    port values of the remote system indicated and will collect and print all the
    service banners identified. This script can be executed by modifying the file
    permissions and then calling it directly from the directory in which it was written:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此脚本时，它将使用 Python 套接字连接到远程系统中所有在范围内的端口，并收集并打印所有识别出的服务横幅。通过修改文件权限并直接从编写脚本所在的目录中调用它，可以执行此脚本：
- en: '![](../images/00594.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00594.jpeg)'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The Python script that is introduced in this recipe works by utilizing the `socket`
    library. The script loops through each of the specified target port addresses
    and attempts to initialize a TCP connection with that particular port. If a connection
    is established and a banner is received from the target service, the banner will
    then be printed in the output of the script. If a connection cannot be established
    with the remote port, the script will then move to the next port address value
    in the loop. Similarly, if a connection is established but no banner is returned,
    the connection will be closed and the script will continue to the next value in
    the loop.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中介绍的 Python 脚本通过利用 `socket` 库来工作。脚本循环遍历每个指定的目标端口地址，并尝试与该端口建立 TCP 连接。如果连接成功并且从目标服务接收到横幅信息，该横幅将被打印到脚本的输出中。如果无法与远程端口建立连接，脚本将继续尝试循环中的下一个端口地址。同样，如果连接成功但没有返回横幅，连接将被关闭，脚本将继续执行循环中的下一个端口。
- en: Banner grabbing with DMitry
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DMitry 获取服务横幅
- en: DMitry is a simple yet streamlined tool that can be used to connect to network
    services running on remote ports. This recipe will demonstrate how to use DMitry
    scanning to acquire service banners in order to identify the services associated
    with open ports on a target system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DMitry 是一个简单且高效的工具，可以用来连接到远程端口上运行的网络服务。本食谱将演示如何使用 DMitry 扫描获取服务横幅，以识别目标系统上开放端口所关联的服务。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use DMitry to gather service banners, you will need to have a remote system
    running network services that discloses information when a client device connects
    to them. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on setting up Metasploitable2, refer to the *Installing
    Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 DMitry 收集服务横幅，您需要有一个远程系统，该系统运行网络服务，当客户端设备连接到这些服务时，会披露相关信息。在所提供的示例中，使用了 Metasploitable2
    实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 配方，*入门* 部分。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Perform following steps to get banner information using DMitry:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用 DMitry 获取横幅信息：
- en: 'As was previously discussed in the port scanning recipes of this book, DMitry
    can be used to run a quick TCP port scan on 150 of the most commonly used services.
    This can be done using the `-p` option:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如本书中先前讨论的端口扫描教程，DMitry 可用于快速扫描 150 个最常用的 TCP 端口。这可以通过使用 `-p` 选项来完成：
- en: '![](../images/00606.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00606.jpeg)'
- en: 'This port scan option is required in order to perform banner grabbing with
    DMitry. It is possible to also have DMitry grab any available banners when connections
    are attempted with each of these 150 ports. This can be done using the `-b` option
    in conjunction with the `-p` option:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该端口扫描选项是执行 DMitry 横幅抓取所必需的。还可以在尝试连接这 150 个端口时，使用 DMitry 抓取任何可用的横幅。这可以通过将 `-b`
    选项与 `-p` 选项结合使用来完成：
- en: '![](../images/00214.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00214.jpeg)'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: DMitry is a very simple command-line tool that can perform the task of banner
    grabbing with minimal overhead. Rather than having to specify the ports that banner
    grabbing should be attempted on, DMitry can streamline the process by only attempting
    banner grabbing on a small selection of predefined and commonly used ports. Banners
    received from services running on those port addresses are then returned in the
    Terminal output of the script.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DMitry 是一个非常简单的命令行工具，可以以最小的开销执行横幅抓取任务。与其指定应该尝试抓取横幅的端口，DMitry 可以通过仅在少量预定义的常用端口上进行横幅抓取来简化过程。来自这些端口地址上运行的服务的横幅将返回并显示在脚本的终端输出中。
- en: Banner grabbing with Nmap NSE
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nmap NSE 进行横幅抓取
- en: Nmap has an integrated **Nmap Scripting Engine** (**NSE**) script that can be
    used to read banners from network services running on remote ports. This recipe
    will demonstrate how to use Nmap NSE to acquire service banners in order to identify
    the services associated with open ports on a target system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 有一个集成的 **Nmap 脚本引擎**（**NSE**）脚本，可以用来读取远程端口上运行的网络服务的横幅。这个教程将展示如何使用 Nmap
    NSE 获取服务横幅，从而识别目标系统上开放端口所关联的服务。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To use Nmap NSE to gather service banners, you will need to have a remote system
    running network services that discloses information when a client device connects
    to them. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on setting up Metasploitable2, refer to the *Installing
    Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Nmap NSE 收集服务横幅，您需要有一个远程系统，该系统运行网络服务，当客户端设备连接到这些服务时，会披露相关信息。在所提供的示例中，使用了
    Metasploitable2 实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 配方，*入门* 部分。
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s use Nmap NSE to get the banner information:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Nmap NSE 获取横幅信息：
- en: 'Nmap NSE scripts can be called using the `--script` option in Nmap and then
    specifying the name of the desired script. For this particular script, a `-sT`
    full-connect scan should be used, as service banners can only be collected when
    a full TCP connection is established. The script will be applied to the same ports
    that are scanned by the Nmap request:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nmap NSE 脚本可以通过在 Nmap 中使用 `--script` 选项并指定所需脚本的名称来调用。对于这个特定的脚本，应该使用 `-sT` 完全连接扫描，因为只有在建立完全的
    TCP 连接时，才能收集服务横幅。该脚本将应用于与 Nmap 请求扫描的相同端口：
- en: '![](../images/00216.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00216.jpeg)'
- en: 'In the example provided, the TCP port `22` of the Metasploitable2 system was
    scanned. In addition to indicating that the port is open, Nmap also used the banner
    script to collect the service banner associated with that port. This same technique
    can be applied to a sequential range of ports using the `--` notation:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，扫描了 Metasploitable2 系统的 TCP 端口 `22`。除了指示该端口开放外，Nmap 还使用横幅脚本收集了与该端口相关的服务横幅。此技术也可以通过
    `--` 符号应用于端口的连续范围：
- en: '![](../images/00639.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00639.jpeg)'
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Another excellent option for performing banner-grabbing reconnaissance is to
    use the Nmap NSE script. This can be an effective option for streamlining the
    information-gathering process in two ways: first, because Nmap is already likely
    going to be among your arsenal of tools that will be used for target and service
    discovery, and second, because the process of banner grabbing can be run in conjunction
    with these scans. A TCP connect scan with the additional `--script` option and
    the `banner` argument can accomplish the task of both service enumeration and
    banner grabbing.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 执行横幅抓取侦察的另一个优秀选项是使用 Nmap NSE 脚本。这可以通过两种方式有效地简化信息收集过程：首先，因为 Nmap 很可能已经是你工具库中的一部分，用于目标和服务发现；其次，因为横幅抓取过程可以与这些扫描一起运行。使用额外的`--script`选项和`banner`参数的
    TCP 连接扫描可以完成服务枚举和横幅抓取的任务。
- en: Banner grabbing with Amap
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amap 进行横幅抓取
- en: Amap is an application-mapping tool that can be used to read banners from network
    services running on remote ports. This recipe will demonstrate how to use Amap
    to acquire service banners in order to identify the services associated with open
    ports on a target system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Amap 是一个应用映射工具，可以用于读取来自远程端口上运行的网络服务的横幅。本教程将演示如何使用 Amap 获取服务横幅，以识别目标系统上开放端口关联的服务。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Amap to gather service banners, you will need to have a remote system
    running network services that discloses information when a client device connects
    to them. In the examples provided, an instance of Metasploitable2 is used to perform
    this task. For more information on setting up Metasploitable2, refer to the *Installing
    Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Amap 收集服务横幅，你需要有一个远程系统在运行网络服务，当客户端设备连接到这些服务时会披露信息。在提供的示例中，使用了 Metasploitable2
    实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参考 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 教程，*开始使用*。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行……
- en: 'The following steps will guide you to gather service banner information using
    Amap:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导你使用 Amap 收集服务横幅信息：
- en: 'The `-B` option in Amap can be used to run the application in banner mode.
    This will have it collect banners for the specified IP address and service port(s).
    Amap can be used to collect the banner from a single service by specifying the
    remote IP address and service number:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Amap 中的 `-B` 选项可以用于以横幅模式运行应用程序。这将使其收集指定 IP 地址和服务端口的横幅。通过指定远程 IP 地址和服务号，可以使用
    Amap 收集来自单个服务的横幅：
- en: '![](../images/00648.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00648.jpeg)'
- en: In the example provided, Amap has grabbed the service banner from port `21`
    on the Metasploitable2 system at `172.16.69.128`. This command can also be modified
    to scan a sequential range of ports. To perform a scan of all the possible TCP
    ports, all the possible port address values must be scanned. The portions of the
    TCP header that define the source and destination port addresses are both 16 bits
    in length, and each bit can retain a value of `1` or `0`. As such, there are 2^(16),
    or 65,536, possible TCP port addresses.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，Amap 已从 Metasploitable2 系统的端口 `21` 上抓取了服务横幅（系统地址为 `172.16.69.128`）。此命令也可以修改为扫描端口的连续范围。要扫描所有可能的
    TCP 端口，必须扫描所有可能的端口地址值。定义源端口和目标端口地址的 TCP 头部分别为 16 位长度，每个位可以保持 `1` 或 `0` 的值。因此，可能的
    TCP 端口地址总共有 2^(16)，即 65,536 个。
- en: 'To scan the total possible address space, a port range of `1-65535` must be
    supplied:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描整个可能的地址空间，必须提供端口范围 `1-65535`：
- en: '![](../images/00655.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00655.jpeg)'
- en: 'The standard output produced by Amap provides some unnecessary and redundant
    information that can be extracted from the output. Specifically, it might be helpful
    to remove the scanned metadata, the `Banner on` phrase, and the IP address that
    remains the same throughout the entire scan. To remove the scan metadata, we must
    use the `grep` command to output for a phrase that is unique to the specific output
    entries and does not exist in the scan''s metadata description. To do this, we
    can use the `grep` command for the word `on`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Amap 输出的标准结果提供了一些不必要和冗余的信息，这些信息可以从输出中提取出来。具体来说，移除扫描元数据、`Banner on` 短语以及整个扫描过程中保持不变的
    IP 地址可能会很有帮助。为了移除扫描元数据，我们必须使用 `grep` 命令输出特定于某个输出条目的短语，这个短语在扫描元数据描述中不存在。为此，我们可以使用
    `grep` 命令查找单词 `on`：
- en: '![](../images/00665.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00665.jpeg)'
- en: 'We can then extract the `Banner on` phrase and the redundant IP address from
    the output by cutting each line of the output with a colon delimiter and then
    only retrieving fields `2-5`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过使用冒号分隔符切割每一行输出，并只提取 `2-5` 字段，来从输出中提取 `Banner on` 短语和冗余的 IP 地址：
- en: '![](../images/00228.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00228.jpeg)'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The underlying principle that defines how Amap can accomplish the task of banner
    grabbing is the same as the other tools discussed previously. Amap cycles through
    the list of destination port addresses, attempts to establish a connection with
    each port, and then receives any returned banner that is sent upon connection
    to the service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Amap 如何完成横幅抓取任务的基本原理与之前讨论的其他工具相同。Amap 会遍历目标端口地址列表，尝试与每个端口建立连接，然后在连接到服务时接收任何返回的横幅信息。
- en: Service identification with Nmap
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行服务识别
- en: Although banner grabbing can be an extremely lucrative source of information
    at times, version disclosure in service banners is becoming less common. Nmap
    has a service-identification function that goes far beyond simple banner-grabbing
    techniques. This recipe will demonstrate how to use Nmap to perform service identification
    based on probe-response analysis.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管横幅抓取有时可以成为非常有价值的信息来源，但服务横幅中版本泄露的情况越来越少见。Nmap 提供了一个远超简单横幅抓取技术的服务识别功能。本食谱将演示如何使用
    Nmap 基于探测响应分析来执行服务识别。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Nmap to perform service identification, you will need to have a remote
    system that is running network services that can be probed and inspected. In the
    examples provided, an instance of Metasploitable2 is used to perform this task.
    For more information on setting up Metasploitable2, refer to the *Installing Metasploitable2*
    recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Nmap 执行服务识别，您需要一个远程系统，该系统正在运行可以进行探测和检查的网络服务。在提供的示例中，使用了 Metasploitable2
    实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 食谱，*入门* 部分。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We have the service banner information, now let''s perform the service identification
    using Nmap:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了服务横幅信息，现在让我们使用 Nmap 执行服务识别：
- en: 'To understand the effectiveness of Nmap''s service-identification function,
    we should consider a service that does not provide a self-disclosed service banner.
    By using Netcat to connect to the TCP port `80` on the Metasploitable2 system
    (a technique discussed in the *Banner grabbing with Netcat* recipe of this chapter),
    we can see that no service banner is presented by merely establishing a TCP connection:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了理解 Nmap 服务识别功能的有效性，我们应该考虑一个没有提供自我披露服务横幅的服务。通过使用 Netcat 连接到 Metasploitable2
    系统的 TCP 端口 `80`（这是本章 *使用 Netcat 进行横幅抓取* 食谱中讨论的技术），我们可以看到仅通过建立 TCP 连接并没有呈现任何服务横幅：
- en: '![](../images/00010.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: 'Then, to execute an Nmap service scan on the same port, we can use the `-sV`
    option in conjunction with the IP and port specification:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要在相同端口上执行 Nmap 服务扫描，我们可以使用 `-sV` 选项并结合 IP 和端口指定：
- en: '![](../images/00024.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: 'As you can see in the demonstration provided, Nmap was able to identify the
    service, the vendor, and the specific version of the product. This service-identification
    function can also be used against a specified sequential series of ports. This
    can alternatively be done using Nmap without a port specification; the 1,000 common
    ports will be scanned, and identification attempts will be made for all listening
    services that are identified:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如示范中所示，Nmap 能够识别服务、厂商以及产品的具体版本。这个服务识别功能也可以用于指定的端口序列。也可以不指定端口号，使用 Nmap 扫描 1,000
    个常见端口，并尝试识别所有已识别的监听服务：
- en: '![](../images/00037.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Nmap service identification sends a comprehensive series of probing requests
    and then analyzes the responses to those requests in an attempt to identify services
    based on service-unique signatures and expected behavior. Additionally, you can
    see at the bottom of the service-identification output that Nmap relies on feedback
    from users in order to ensure the continued reliability of their service signatures.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 服务识别会发送一系列全面的探测请求，然后分析这些请求的响应，试图根据服务特有的签名和预期行为来识别服务。此外，你可以在服务识别的输出底部看到，Nmap
    依赖用户的反馈以确保其服务签名的持续可靠性。
- en: Service identification with Amap
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amap 进行服务识别
- en: Amap is a cousin of Nmap, and was designed specifically for the purpose of identifying
    network services. In this recipe, we will explain how to use Amap to perform service
    identification.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Amap 是 Nmap 的一个“表亲”，专门设计用于识别网络服务。在本节中，我们将解释如何使用 Amap 执行服务识别。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Amap to perform service identification, you will need to have a remote
    system running network services that can be probed and inspected. In the examples
    provided, an instance of Metasploitable2 is used to perform this task. For more
    information on setting up Metasploitable2, refer to the *Installing Metasploitable2* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Amap 执行服务识别，你需要有一个远程系统在运行可以被探测和检查的网络服务。在提供的示例中，使用 Metasploitable2 实例来执行此任务。有关设置
    Metasploitable2 的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中
    *安装 Metasploitable2* 的内容，*入门* 部分。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The Amap is designed for service identification, let''s perform the service
    identification using Amap by the help of these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Amap 是专门为服务识别设计的，下面我们将通过这些步骤使用 Amap 执行服务识别：
- en: 'To perform service identification on a single port, run Amap with the IP address
    and port number specifications:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在单个端口上执行服务识别，运行 Amap 并指定 IP 地址和端口号：
- en: '![](../images/00050.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00050.jpeg)'
- en: 'Amap can also be used to scan a sequential series of port numbers using dash
    notation. To do this, execute the `amap` command with the IP address specification
    and range of ports indicated by the first port number in the range, a dash (`-`),
    and then the last port number in the range:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Amap 也可以使用破折号表示法扫描一系列连续的端口号。为此，请执行 `amap` 命令，指定 IP 地址，并通过第一个端口号、破折号（`-`）以及范围中的最后一个端口号来表示端口范围：
- en: '![](../images/00063.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00063.jpeg)'
- en: 'In addition to identifying any services that it can, it also generates a list
    at the end of the output indicating any unidentified ports. This list not only
    includes open ports that are running services that could not be identified, but
    also all closed ports that are scanned. Although the output is manageable when
    only 10 ports are scanned, it becomes very annoying when larger port ranges are
    scanned. To suppress information about unidentified ports, the `-q` option can
    be used:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了识别它能够识别的任何服务外，Amap 还会在输出末尾生成一个列表，指示任何未识别的端口。这个列表不仅包括运行着无法识别的服务的开放端口，还包括所有已扫描的关闭端口。虽然仅扫描
    10 个端口时，输出结果还算可管理，但扫描更大范围的端口时就会变得非常烦人。为了抑制未识别端口的信息，可以使用 `-q` 选项：
- en: '![](../images/00076.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: 'Notice that Amap will indicate matches for general and more specific signatures.
    In the example provided, the service running on the port `22` is identified as
    matching the SSH signature, but also as matching the more specific `openssh` signature.
    It can also be helpful to have the signature matches and service banners displayed
    side by side for additional confirmation. The banners can be appended to the output
    associated with each port using the `-b` option:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，Amap 会显示一般性和更具体签名的匹配情况。在提供的示例中，运行在端口`22`上的服务被识别为匹配 SSH 签名，同时也匹配了更具体的 `openssh`
    签名。将签名匹配结果与服务横幅并排显示也有助于进一步确认。可以使用 `-b` 选项将横幅附加到与每个端口相关联的输出中：
- en: '![](../images/00092.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00092.jpeg)'
- en: 'Service-identification scans on a large number of ports or comprehensive scans
    on all 65,536 ports can take an exceptionally long time if every possible signature
    probe is used on every service. To increase the speed of the service-identification
    scan, the `-1` argument can be used to discontinue the analysis of a particular
    service after it is matched to a signature:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对大量端口进行服务识别扫描，或对所有 65,536 个端口进行全面扫描时，如果对每个服务使用每个可能的签名探测，可能会花费异常长的时间。为了提高服务识别扫描的速度，可以使用
    `-1` 参数，在服务匹配到签名后停止分析该服务：
- en: '![](../images/00244.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00244.jpeg)'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The underlying principle that defines how Amap performs service identification
    is similar to the principle employed by Nmap. A series of probe requests is injected
    in an attempt to solicit unique responses that can be used to identify the software
    and version of the service running on a particular port. It should be noted, however,
    that while Amap is an alternative option for service identification, it is not
    as frequently updated and well maintained as Nmap. As such, Amap is less likely
    to produce reliable results.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Amap 执行服务识别的基本原理与 Nmap 使用的原理相似。通过注入一系列探测请求，试图获取独特的响应，以便识别运行在特定端口上的服务的软件和版本。然而，需要注意的是，尽管
    Amap 是服务识别的一个备选方案，它不像 Nmap 那样频繁更新和维护。因此，Amap 产生可靠结果的可能性较小。
- en: Operating system identification with Scapy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scapy 进行操作系统识别
- en: There is a wide range of techniques that can be used to attempt to fingerprint
    the operating system of a device you are communicating with. Truly effective operating
    system identification utilities are robust and employ a large number of techniques
    to factor into their analysis. However, Scapy can be used to analyze any of these
    factors individually. This recipe will demonstrate how to perform operating system
    identification with Scapy by examining the returned TTL values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以用来尝试识别你正在与之通信的设备的操作系统。真正有效的操作系统识别工具是强大的，并且使用大量技术来分析其结果。然而，Scapy 可以单独分析这些因素。本教程将展示如何通过检查返回的
    TTL 值，使用 Scapy 进行操作系统识别。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Scapy to identify discrepancies in TTL responses, you will need to have
    both a remote system that is running a Linux/Unix operating system and a remote
    system that is running a Windows operating system available for analysis. In the
    examples provided, an installation of Metasploitable2 and an installation of Windows
    XP are used. For more information on setting up systems in a local lab environment,
    refer to the *Installing Metasploitable2* and *Installing Windows Server* recipes
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*. Additionally, this section will require a script to be written to the
    filesystem using a text editor such as Vim or GNU nano. For more information on
    writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe in
    [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Scapy 识别 TTL 响应中的差异，你需要有一个远程系统，运行 Linux/Unix 操作系统，并且有一个远程系统，运行 Windows 操作系统，以供分析。在提供的示例中，使用了
    Metasploitable2 和 Windows XP 的安装版本。有关在本地实验室环境中设置系统的更多信息，请参阅[第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 和 *安装 Windows Server* 章节，*入门指南*。此外，本节还需要使用文本编辑器（如 Vim 或 GNU
    nano）编写脚本到文件系统中。有关编写脚本的更多信息，请参阅[第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *使用文本编辑器（Vim 和 GNU nano）* 章节，*入门指南*。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The following steps will help you for the OS identification using Scapy:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你使用 Scapy 进行操作系统识别：
- en: 'Windows and Linux/Unix operating systems have different TTL starting values
    that are used by default. This factor can be used to attempt to fingerprint the
    type of operating system with which you are communicating. These values are summarized
    in the following table:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows和Linux/Unix操作系统的默认TTL起始值不同。这个因素可以用来尝试识别你正在与之通信的操作系统类型。以下表格总结了这些值：
- en: '| **Operating system** | **Standard TTL value** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **标准TTL值** |'
- en: '| Microsoft Windows OS | 128 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 微软Windows操作系统 | 128 |'
- en: '| Linux/Unix OS | 64 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Linux/Unix操作系统 | 64 |'
- en: 'Some Unix-based systems will start with a default TTL value of `255`; however,
    for simplicity in this exercise, we will use the provided values as the premise
    for the tasks addressed within this recipe. To analyze the TTL values of a response
    from the remote system, we first need to build a request. In this example, we
    will use an **Internet Control Message Protocol** (**ICMP**) echo request. To
    send the ICMP request, we must first build the layers of that request. The first
    layer we will need to construct is the IP layer:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些基于Unix的系统会从默认TTL值`255`开始；然而，为了简化这个练习，我们将使用提供的值作为本食谱中任务的前提。为了分析来自远程系统的响应中的TTL值，我们首先需要构建一个请求。在这个例子中，我们将使用**互联网控制消息协议**（**ICMP**）回显请求。为了发送ICMP请求，我们必须首先构建该请求的各个层。我们需要构建的第一层是IP层：
- en: '![](../images/00247.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00247.jpeg)'
- en: To build the IP layer of our request, we should assign the `IP` object to the
    `i` variable. By calling the `display()` function, we can identify the attribute
    configurations for the object. By default, both the sending and receiving addresses
    are set to the loopback address of `127.0.0.1`. These values can be modified by
    changing the destination address, setting `i.dst` equal to the string value of
    the address we wish to scan.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建请求的IP层，我们应该将`IP`对象分配给`i`变量。通过调用`display()`函数，我们可以识别该对象的属性配置。默认情况下，发送和接收地址都设置为回环地址`127.0.0.1`。这些值可以通过更改目标地址来修改，将`i.dst`设置为我们希望扫描的地址的字符串值。
- en: 'By calling the `display()` function again, we can see that not only has the
    destination address been updated, but Scapy will also automatically update the
    source IP address to the address associated with the default interface. Now that
    we have constructed the IP layer of the request, we should proceed to the ICMP
    layer:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次调用`display()`函数，我们可以看到，不仅目标地址已更新，Scapy还会自动将源IP地址更新为与默认接口关联的地址。现在，我们已经构建了请求的IP层，接下来应该构建ICMP层：
- en: '![](../images/00250.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00250.jpeg)'
- en: 'To build the ICMP layer of our request, we will use the same technique we used for
    the IP layer. In the example provided, the ICMP object was assigned to the `ping`
    variable. As discussed previously, the default configurations can be identified
    by calling the `display()` function. By default, the ICMP type is already set
    to `echo-request`. Now that we have created both the IP and ICMP layers, we need
    to construct the request by stacking those layers:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建我们请求的ICMP层，我们将使用与构建IP层时相同的技术。在提供的示例中，ICMP对象被分配给了`ping`变量。如前所述，可以通过调用`display()`函数来识别默认配置。默认情况下，ICMP类型已设置为`echo-request`。现在，我们已经创建了IP和ICMP层，我们需要通过堆叠这些层来构建请求：
- en: '![](../images/00142.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00142.jpeg)'
- en: 'The IP and ICMP layers can be stacked by separating the variables with a forward
    slash. These layers can then be set equal to a new variable that will represent
    the entire request. The `display()` function can then be called to view the configurations
    for the request. Once the request has been built, this can then be passed to the
    `sr1()` function so that we can analyze the response:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IP和ICMP层可以通过用斜杠分隔变量来堆叠。然后，这些层可以设置为一个新的变量，代表整个请求。接着，可以调用`display()`函数来查看请求的配置。一旦请求构建完成，就可以将其传递给`sr1()`函数以分析响应：
- en: '![](../images/00156.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00156.jpeg)'
- en: 'This same request can be performed without independently building and stacking
    each layer. Instead, a single one-line command can be used by calling the functions
    directly and passing the appropriate arguments to them:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个请求可以在不独立构建和堆叠每一层的情况下执行。相反，可以通过直接调用函数并传递适当的参数来使用一个单行命令：
- en: '![](../images/00084.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00084.jpeg)'
- en: 'Notice that the TTL value of the response from the Linux system had a value
    of `64`. This same test can be performed against the IP address of the Windows
    system, and the difference in TTL value of the response should be noted:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，来自 Linux 系统的响应的 TTL 值为 `64`。可以对 Windows 系统的 IP 地址执行相同的测试，并注意 TTL 值响应的差异：
- en: '![](../images/00086.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00086.jpeg)'
- en: 'Notice that the response returned by the Windows system had a TTL value of
    `128`. This variation of response can easily be tested in Python:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，Windows 系统返回的响应的 TTL 值为 `128`。这种响应的变化可以很容易地在 Python 中进行测试：
- en: '![](../images/00090.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.jpeg)'
- en: 'By sending the same requests, the integer equivalent of the TTL value can be
    tested to determine whether it is less than or equal to `64`, in which case, we
    can assume that the device probably has a Linux/Unix operating system. Otherwise,
    if the value is not less than or equal to `64`, we can assume that the device
    most likely has a Windows operating system. This entire process can be automated
    using an executable Python script:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过发送相同的请求，可以测试 TTL 值的整数等效值，以确定其是否小于或等于 `64`，如果是这种情况，我们可以假设该设备很可能运行 Linux/Unix
    操作系统。否则，如果值大于 64，则可以假设该设备很可能运行 Windows 操作系统。可以使用可执行的 Python 脚本自动化整个过程：
- en: '[PRE1]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The provided Python script will accept a single argument, consisting of the
    IP address that should be scanned. Based on the TTL value of the response returned,
    the script will then make its best guess of the remote operating system. This
    script can be executed by changing the file permissions with `chmod` and then
    calling it directly from the directory to which it was written:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的 Python 脚本将接受一个参数，该参数为需要扫描的 IP 地址。根据返回响应的 TTL 值，脚本将尽最大努力猜测远程操作系统。可以通过使用 `chmod`
    命令更改文件权限，并直接从脚本所在的目录调用该脚本来执行：
- en: '![](../images/00272.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00272.jpeg)'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Windows operating systems have traditionally transmitted network traffic with
    a starting TTL value of `128`, whereas Linux/Unix operating systems have traditionally
    transmitted network traffic with a starting TTL value of `64`. By assuming that
    no more than 64 hops should be made to get from one device to another, it can
    be safely assumed that Windows systems will transmit replies with a range of TTL
    values between 65 and 128 and that Linux/Unix systems will transmit replies with
    a range of TTL values between 1 and 64\. This identification method can become
    less useful when devices exist between the scanning system and the remote destination
    that intercept requests and then repacks them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统传统上将网络流量的起始 TTL 值设置为 `128`，而 Linux/Unix 操作系统传统上将网络流量的起始 TTL 值设置为
    `64`。假设从一个设备到另一个设备的跳数不超过 64 次，可以安全地假设 Windows 系统会以 TTL 值在 65 到 128 之间的范围内传输响应，而
    Linux/Unix 系统会以 TTL 值在 1 到 64 之间的范围内传输响应。当扫描系统与远程目标之间存在设备拦截请求并重新打包时，这种识别方法可能会变得不太有用。
- en: Operating system identification with Nmap
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行操作系统识别
- en: Although TTL analysis can be helpful in identifying remote operating systems,
    more comprehensive solutions are ideal. Nmap has an operating system identification
    function that goes far beyond simple TTL analysis. This recipe will demonstrate
    how to use Nmap to perform operating system identification based on probe-response
    analysis.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 TTL 分析在识别远程操作系统时有帮助，但更全面的解决方案更为理想。Nmap 具有一个操作系统识别功能，远远超出了简单的 TTL 分析。本教程将演示如何使用
    Nmap 基于探针响应分析进行操作系统识别。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Nmap to perform operating system identification, you will need to have
    a remote system running network services that can be probed and inspected. In
    the examples provided, an installation of Windows XP is used to perform this task.
    For more information on setting up a Windows system, refer to the *Installing
    Windows Server* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Nmap 执行操作系统识别，您需要有一个远程系统运行可以进行探测和检查的网络服务。在提供的示例中，使用 Windows XP 安装来执行此任务。有关设置
    Windows 系统的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Windows 服务器* 配方，*入门指南*。
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s perform OS identification using Nmap:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Nmap 进行操作系统识别：
- en: 'To perform an Nmap operating system identification scan, Nmap should be called
    with the IP address specification and the `-O` option:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行 Nmap 操作系统识别扫描，应该使用 IP 地址和 `-O` 选项调用 Nmap：
- en: '![](../images/00095.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00095.jpeg)'
- en: In the output provided, Nmap will indicate the operating system running or might
    provide a list of a few possible operating systems. In this case, Nmap has indicated
    that the remote system is either running Windows XP or Windows Server 2003.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的输出中，Nmap 会指示运行的操作系统，或者可能提供几个可能的操作系统列表。在这种情况下，Nmap 已经指示远程系统正在运行 Windows XP
    或 Windows Server 2003。
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The Nmap operating system identification sends a comprehensive series of probing
    requests and then analyzes the responses to those requests in attempt to identify
    the underlying operating system based on operating system-specific signatures
    and expected behavior. Additionally, you can see at the bottom of the operating
    system identification output that Nmap relies on feedback from users in order
    to ensure the continued reliability of their service signatures.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 的操作系统识别通过发送一系列综合的探测请求，并分析这些请求的响应，试图基于操作系统特定的特征和预期行为来识别底层的操作系统。此外，您可以看到在操作系统识别输出的底部，Nmap
    依赖于用户反馈来确保其服务特征的持续可靠性。
- en: Operating system identification with xprobe2
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 xprobe2 进行操作系统识别
- en: The **xprobe2** tool is a comprehensive tool that is built for the purpose of
    identifying remote operating systems. This recipe will demonstrate how to use
    the `xprobe2` command to perform operating system identification based on probe-response
    analysis.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**xprobe2** 工具是一个综合性工具，旨在识别远程操作系统。此配方将演示如何使用 `xprobe2` 命令，基于探测响应分析来执行操作系统识别。'
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use the `xprobe2` command to perform operating system identification, you
    will need to have a remote system running network services that can be probed
    and inspected. In the examples provided, an instance of Metasploitable2 is used
    to perform this task. For more information on setting up Metasploitable2, refer
    to the *Installing Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `xprobe2` 命令进行操作系统识别，您需要一个远程系统，且该系统正在运行可以被探测和检查的网络服务。在提供的示例中，使用了一个 Metasploitable2
    实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 配方，*开始使用* 部分。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'These steps will guide you to perform OS identification using the `xprobe2`
    command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您使用 `xprobe2` 命令进行操作系统识别：
- en: 'To execute an operating system identification scan on a remote system with
    the `xprobe2` command, the program needs to be passed a single argument that consists
    of the IP address of the system to be scanned:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在远程系统上执行操作系统识别扫描，您需要使用 `xprobe2` 命令，并向程序传递一个包含要扫描系统的 IP 地址的单一参数：
- en: '![](../images/00097.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00097.jpeg)'
- en: The output of this tool can be somewhat misleading. There are several different
    Linux kernels that indicate a 100% probability for that particular operating system.
    Obviously, that cannot be correct.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此工具的输出可能有些误导。有几种不同的 Linux 内核，表示该操作系统的 100% 可能性。显然，这不可能是正确的。
- en: The xprobe2 tool actually bases this percentage on the number of possible signatures
    associated with that operating system that were confirmed on the target system.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: xprobe2 工具实际上是根据与目标系统确认的与该操作系统相关的可能签名的数量来计算这个百分比的。
- en: Unfortunately, as can be seen with this output, the signatures are not granular
    enough to distinguish between minor versions. Nonetheless, this tool can be a
    helpful additional resource in identifying a target operating system.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，正如从该输出中可以看到的那样，签名并不够细致，无法区分次要版本。尽管如此，这个工具仍然可以作为识别目标操作系统的有用附加资源。
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The underlying principle that defines how xprobe2 identifies remote operating
    systems is the same as the principle used by Nmap. The xprobe2 operating system
    identification sends a comprehensive series of probing requests and then analyzes
    the responses to those requests in an attempt to identify the underlying operating
    system based on operating system-specific signatures and expected behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: xprobe2 识别远程操作系统的基本原理与 Nmap 使用的原理相同。xprobe2 的操作系统识别通过发送一系列综合的探测请求，并分析这些请求的响应，试图基于操作系统特定的特征和预期行为来识别底层的操作系统。
- en: Passive operating system identification with p0f
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 p0f 进行被动操作系统识别
- en: The **p0f** tool is a comprehensive tool that was developed for the purpose
    of identifying remote operating systems. This tool is different from the other
    tools discussed here because it is built to perform operating system identification
    passively and without directly interacting with the target system. This recipe
    will demonstrate how to use the `p0f` command to perform passive operating system
    identification.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**p0f** 工具是一款综合性的工具，旨在识别远程操作系统。与这里讨论的其他工具不同，它被设计为被动地进行操作系统识别，而不直接与目标系统进行交互。本教程将展示如何使用
    `p0f` 命令执行被动操作系统识别。'
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use the `p0f` command to perform operating system identification, you will
    need to have a remote system that is running network services. In the examples
    provided, an instance of Metasploitable2 is used to perform this task. For more
    information on setting up Metasploitable2, refer to the *Installing Metasploitable2*
    recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `p0f` 命令进行操作系统识别，你需要一个正在运行网络服务的远程系统。在提供的示例中，使用了 Metasploitable2 实例来执行此任务。有关如何设置
    Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 配方，*入门* 部分。
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The following steps will help you to perform passive OS identification using the `p0f`
    command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你使用 `p0f` 命令执行被动操作系统识别：
- en: 'If you execute the `p0f` command directly from the command line without any
    prior environmental setup, you will notice that it will not provide much information
    unless you are directly interacting with some of the systems on your network:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你直接从命令行执行 `p0f` 命令，而没有任何先前的环境设置，你会注意到它不会提供太多信息，除非你直接与网络上的某些系统交互：
- en: '![](../images/00100.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00100.jpeg)'
- en: This lack of information is evidence of the fact that unlike the other tools
    we have discussed, `p0f` will not go out and actively probe devices in an attempt
    to determine their operating system. Instead, it just quietly listens.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种信息的缺乏表明，与我们讨论的其他工具不同，`p0f` 并不会主动探测设备以尝试确定其操作系统。相反，它只是安静地监听。
- en: We could generate traffic here by running an Nmap scan in a separate Terminal,
    but that defeats the entire purpose of a passive operating system identifier.
    Instead, we need to determine a way to route traffic through our local interface
    for analysis so that we can passively analyze it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在一个独立的终端中运行 Nmap 扫描来生成流量，但那样就违背了被动操作系统识别工具的初衷。相反，我们需要找到一种方式，将流量通过我们的本地接口进行路由，以便我们可以被动地分析它。
- en: 'Ettercap provides an excellent solution for this by offering the capability
    to poison ARP caches and create a **man-in-the-middle** (**MITM**) scenario. To
    have the traffic traveling between two systems rerouted through your local interface,
    you need to ARP poison both of those systems:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ettercap 提供了一个优秀的解决方案，能够通过提供中毒 ARP 缓存的功能来创建一个**中间人攻击**（**MITM**）场景。为了使两个系统之间的流量通过你的本地接口重新路由，你需要对这两个系统进行
    ARP 中毒：
- en: '![](../images/00102.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00102.jpeg)'
- en: In the example provided, the `ettercap` command is executed at the command line.
    The `-M` option defines the mode specified by the `arp:remote` arguments. This
    indicates that ARP poisoning will be performed and that traffic from remote systems
    will be sniffed. The IP addresses contained within the opening and closing forward
    slashes indicate the systems to be poisoned. The `-T` option indicates that operations
    will be conducted entirely in the text interface, and the `-w` option is used
    to designate the file to dump the traffic capture.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，`ettercap` 命令在命令行中执行。`-M` 选项定义了由 `arp:remote` 参数指定的模式。这表示将执行 ARP 中毒，并且将嗅探来自远程系统的流量。开头和结尾的斜杠中的
    IP 地址表示要中毒的系统。`-T` 选项表示操作将在纯文本界面中执行，`-w` 选项用于指定将流量捕获保存到的文件。
- en: 'Once you have established your MITM, you can execute `p0f` once again in a
    separate Terminal. Assuming the two poisoned hosts are engaged in communication,
    you should see the following traffic:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你建立了 MITM，你可以在一个独立的终端中再次执行 `p0f`。假设这两个被攻击的主机正在进行通信，你应该能看到以下流量：
- en: '![](../images/00104.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00104.jpeg)'
- en: 'All packets that cross the `p0f` listener are flagged as either unknown or
    are associated with a specific operating system signature. Once adequate analysis
    has been performed, you should gracefully close the Ettercap text interface by
    entering `q`. This will re-ARP the victims so that no disruption of service occurs:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有通过`p0f`监听器的包都会被标记为未知，或者与特定的操作系统签名相关联。完成足够的分析后，您应该通过输入`q`优雅地关闭Ettercap文本界面。这将重新ARP受害者，以确保不会发生服务中断：
- en: '![](../images/00011.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: ARP poisoning involves the use of gratuitous ARP responses to trick victim systems
    into associating an intended destination IP address with the MAC address of the
    MITM system. The MITM system will receive traffic from both poisoned systems and
    will forward the traffic on to the intended recipient. This will allow the MITM
    system to sniff all traffic off the wire. By analyzing this traffic for unique
    behavior and signatures, p0f can identify the operating system of devices on the
    network without directly probing them for responses.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ARP欺骗通过使用虚假的ARP响应，欺骗受害系统将目标IP地址与MITM系统的MAC地址关联。MITM系统将接收来自两个中毒系统的流量，并将流量转发给目标接收方。这将允许MITM系统从网络中嗅探所有流量。通过分析这些流量中的独特行为和签名，p0f可以在不直接探测设备响应的情况下识别网络中设备的操作系统。
- en: SNMP analysis with Onesixtyone
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Onesixtyone进行SNMP分析
- en: '**Onesixtyone** is an SNMP analysis tool that is named for the UDP port upon
    which SNMP operates. It is a very simple SNMP scanner that only requests the system
    description value for any specified IP address(es).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Onesixtyone** 是一个SNMP分析工具，其名称来源于SNMP操作的UDP端口。它是一个非常简单的SNMP扫描器，只请求任何指定IP地址的系统描述值。'
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Onesixtyone to perform SNMP analysis, you will need devices that have
    SNMP enabled and can be probed and inspected. In the examples provided, an installation
    of Windows XP is used to perform this task. For more information on setting up
    a Windows system, refer to the *Installing Windows Server* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Onesixtyone进行SNMP分析，您需要具备启用SNMP并能够被探测和检查的设备。在提供的示例中，使用了Windows XP安装进行此任务。如需了解更多关于设置Windows系统的信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Windows
    Server*配方，*入门指南*。
- en: How to do it…
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s perform the SNMP analysis using the `onesixtyone` command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`onesixtyone`命令进行SNMP分析：
- en: 'To use the `onesixtyone` command, you can pass the target IP address and the
    community string as arguments:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`onesixtyone`命令，您可以将目标IP地址和社区字符串作为参数传递：
- en: '![](../images/00107.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00107.jpeg)'
- en: In the example provided, the community string `public` is used to query the
    device at `172.16.69.129` for its system description. This is one of the most
    common default community strings used by various network devices. As indicated
    by the output, the remote host replied to the query with a description string
    that identifies itself.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，使用了社区字符串`public`来查询`172.16.69.129`设备的系统描述。这是各种网络设备使用的最常见的默认社区字符串之一。根据输出，远程主机用描述字符串回应了查询，标识了自身。
- en: How it works…
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: SNMP is a protocol that can be used to manage networked devices and facilitate
    the sharing of information across those devices. The usage of this protocol is
    often necessary in enterprise network environments; however, system administrators
    frequently fail to modify the default community strings that are used to share
    information across SNMP devices. In situations where this is the case, information
    can be gathered about network devices by correctly guessing the default community
    strings used by those devices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是一种协议，用于管理联网设备并促进这些设备之间的信息共享。在企业网络环境中，通常需要使用此协议；然而，系统管理员经常未修改用于跨SNMP设备共享信息的默认社区字符串。在这种情况下，可以通过正确猜测这些设备使用的默认社区字符串来收集关于网络设备的信息。
- en: SNMP analysis with SNMPwalk
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SNMPwalk进行SNMP分析
- en: '**SNMPwalk** is a more complex SNMP scanner that can be used to gather a wealth
    of information from devices with guessable SNMP community strings. SNMPwalk cycles
    through a series of requests to gather as much information as possible from the
    service.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMPwalk** 是一个更复杂的SNMP扫描器，可用于从具有可猜测的SNMP社区字符串的设备收集大量信息。SNMPwalk会循环执行一系列请求，以尽可能多地收集该服务的信息。'
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use SNMPwalk to perform SNMP analysis, you will need devices that have SNMP
    enabled and can be probed and inspected. In the examples provided, an installation
    of Windows XP is used to perform this task. For more information on setting up
    a Windows system, refer to the *Installing Windows Server* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SNMPwalk 执行 SNMP 分析，您需要启用 SNMP 并且可以被探测和检查的设备。在提供的示例中，使用 Windows XP 的安装来执行此任务。有关如何设置
    Windows 系统的更多信息，请参见 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Windows Server* 章节， *入门*。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps will guide you to perform SNMP analysis using the `snmpwalk`
    command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您使用 `snmpwalk` 命令执行 SNMP 分析：
- en: 'To execute the `snmpwalk` command, the tool should be passed a series of arguments
    to include the IP address of the system to be analyzed, the community string to
    be used, and the version of SNMP employed by the system:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行 `snmpwalk` 命令，工具应传递一系列参数，包括要分析的系统的 IP 地址、要使用的社区字符串以及系统采用的 SNMP 版本：
- en: '![](../images/00110.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00110.jpeg)'
- en: To use SNMPwalk against the SNMP-enabled Windows XP system, the default community
    string of `public` is used and the version is `2c`. This generates a large amount
    of output that has been truncated in the demonstration displayed here.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要针对启用了 SNMP 的 Windows XP 系统使用 SNMPwalk，使用默认的社区字符串 `public`，版本为 `2c`。这会生成大量的输出，示范中已进行了截断。
- en: 'Notice that by default, all identified information is preceded by the queried
    OID values. This output can be cleaned up by piping it over to a `cut` function
    to remove these identifiers:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，默认情况下，所有识别的信息前面都有查询的 OID 值。可以通过将输出传递给 `cut` 函数来清理这些标识符：
- en: '![](../images/00222.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00222.jpeg)'
- en: 'Notice that far more than just the system identifier is provided in the output
    from SNMPwalk. In examining the output, some pieces of information may seem obvious
    while others might seem more cryptic. However, by analyzing it thoroughly, you
    can gather a lot of information about the target system:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，SNMPwalk 的输出不仅提供了系统标识符。通过检查输出，有些信息可能看起来显而易见，而有些则可能看起来更为晦涩。然而，通过彻底分析，您可以收集到关于目标系统的大量信息：
- en: '![](../images/00114.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00114.jpeg)'
- en: 'In one segment of the output, a series of hexadecimal values and IP addresses
    can be seen in a list. By referencing the network interfaces of known systems
    on the network, it becomes apparent that these are the contents of the ARP cache.
    It identifies the IP address and MAC address associations stored on the device:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出的一个片段中，可以看到一系列的十六进制值和 IP 地址以列表形式展示。通过参考网络上已知系统的网络接口，可以明显看出这些是 ARP 缓存的内容。它标识了设备上存储的
    IP 地址和 MAC 地址关联：
- en: '![](../images/00116.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00116.jpeg)'
- en: Additionally, a list of running processes and installed applications can be
    located in the output as well. This information can be extremely useful in enumerating
    services running on the target system and in identifying potential vulnerabilities
    that could be exploited.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，输出中还可以找到正在运行的进程列表和已安装的应用程序。这些信息在枚举目标系统上运行的服务和识别潜在的漏洞方面非常有用，这些漏洞可能被利用。
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Unlike Onesixtyone, SNMPwalk is able to not only identify the usage of common
    or default SNMP community strings, but is also able to leverage this configuration
    to gather large amounts of information from the target system. This is accomplished
    through the use of a series of SNMP `GETNEXT` requests to essentially brute-force
    requests for all information made available by a system through SNMP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Onesixtyone 不同，SNMPwalk 不仅能够识别常见或默认的 SNMP 社区字符串的使用情况，还能够利用这些配置通过 SNMP 从目标系统收集大量信息。这是通过一系列
    SNMP `GETNEXT` 请求来实现的，本质上是暴力请求系统通过 SNMP 提供的所有信息。
- en: Firewall identification with Scapy
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scapy 进行防火墙识别
- en: By evaluating the responses that are returned from select packet injections,
    it is possible to determine whether remote ports are filtered by a firewall device.
    In order to develop a thorough understanding of how this process works, we can
    perform this task at the packet level using Scapy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估从选择的分组注入返回的响应，可以确定远程端口是否被防火墙设备过滤。为了深入理解这个过程是如何工作的，我们可以通过 Scapy 在数据包级别执行此任务。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Scapy to perform firewall identification, you will need a remote system
    running network services. Additionally, you will need to implement some type of
    filtering mechanism. This can be done with an independent firewall device or with
    host-based filtering such as Windows Firewall. By manipulating the filtering settings
    on the firewall device, you should be able to modify the responses for injected
    packets.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Scapy进行防火墙识别，您需要一个运行网络服务的远程系统。此外，您还需要实现某种类型的过滤机制。这可以通过独立的防火墙设备或主机上的过滤机制（如Windows防火墙）来完成。通过操作防火墙设备上的过滤设置，您应该能够修改注入数据包的响应。
- en: How to do it…
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Let''s use Scapy to perform firewall identification:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Scapy进行防火墙识别：
- en: 'To effectively determine whether a TCP port is filtered or not, both a TCP
    SYN packet and a TCP ACK packet need to be sent to the destination port. Based
    on the packets that are returned in response to these injections, we can determine
    whether the ports are filtered. Most likely, the injection of these two packets
    will result in one of the four different combinations of responses. We will discuss
    each of these scenarios, what they indicate about filtering associated with the
    destination port, and how to test for each. These four possible combinations of
    responses include the following:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有效确定TCP端口是否被过滤，必须同时发送TCP SYN数据包和TCP ACK数据包到目标端口。根据这些数据包的响应情况，我们可以判断端口是否被过滤。最有可能的是，注入这两个数据包会导致四种不同响应组合中的一种。我们将讨论每种情况，它们表明目标端口的过滤状态，以及如何测试每种情况。这四种可能的响应组合包括：
- en: SYN solicits no response, and ACK solicits an RST response
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN请求没有响应，ACK请求RST响应
- en: SYN solicits a SYN+ACK or SYN+RST response, and ACK solicits no response
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN请求SYN+ACK或SYN+RST响应，ACK请求没有响应
- en: SYN solicits a SYN+ACK or SYN+RST response, and ACK solicits an RST response
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN请求SYN+ACK或SYN+RST响应，ACK请求RST响应
- en: SYN solicits no response and ACK solicits no response
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN请求没有响应，ACK请求没有响应
- en: 'In the first scenario, we should consider a configuration in which an injected
    SYN packet solicits no response and an ACK packet solicits an RST response. To
    test this, we should first send a TCP ACK packet to the destination port. To send
    the TCP ACK packet to any given port, we must first build the layers of the request.
    The first layer we will need to construct is the IP layer:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个场景中，我们应该考虑一种配置，其中注入的SYN数据包没有响应，而ACK数据包则会收到RST响应。为了测试这一点，我们应该先向目标端口发送一个TCP
    ACK数据包。要将TCP ACK数据包发送到任何给定端口，首先必须构建请求的各个层。我们需要构建的第一层是IP层：
- en: '![](../images/00048.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: To build the IP layer of our request, we should assign the `IP` object to the
    `i` variable. By calling the `display()` function, we can identify the attribute
    configurations for the object. By default, both the sending and receiving addresses
    are set to the `127.0.0.1` loopback address. These values can be modified by changing
    the destination address, setting `i.dst` equal to the string value of the address
    we wish to scan.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建请求的IP层，我们应该将`IP`对象赋值给`i`变量。通过调用`display()`函数，我们可以识别该对象的属性配置。默认情况下，发送和接收地址都设置为`127.0.0.1`回环地址。可以通过修改目标地址来改变这些值，将`i.dst`设置为我们希望扫描的地址的字符串值。
- en: 'By calling the `display()` function again, we can see that not only has the
    destination address been updated, but Scapy will also automatically update the
    source IP address to the address associated with the default interface. Now that
    we have constructed the IP layer of the request, we should proceed to the TCP
    layer:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次调用`display()`函数，我们可以看到，不仅目标地址已经更新，Scapy还会自动更新源IP地址为与默认接口相关联的地址。现在我们已经构建了请求的IP层，接下来应该进入TCP层：
- en: '![](../images/00429.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00429.jpeg)'
- en: To build the TCP layer of our request, we will use the same technique we used
    for the IP layer. In the example provided, the `TCP` object was assigned to the
    `t` variable. As discussed previously, the default configurations can be identified
    by calling the `display()` function. Here, we can see that the default value for
    the source port is set to the port `21` (FTP), and the default value of the destination
    port is set to the port `80` (HTTP).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了构建请求的TCP层，我们将使用与IP层相同的技术。在提供的示例中，`TCP`对象被赋值给`t`变量。如前所述，可以通过调用`display()`函数来识别默认配置。在这里，我们可以看到源端口的默认值设置为端口`21`（FTP），目标端口的默认值设置为端口`80`（HTTP）。
- en: 'The destination port value can be modified by setting it equal to the new port
    destination value, and the `flags` value should be set to `A` to indicate that
    the ACK flag bit should be activated. Now that we have created both the IP and
    TCP layers, we need to construct the request by stacking those layers:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标端口值可以通过将其设置为新的端口目标值来修改，`flags` 值应该设置为 `A`，以表示 ACK 标志位应该被激活。现在我们已经创建了 IP 和
    TCP 层，我们需要通过堆叠这些层来构建请求：
- en: '![](../images/00123.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00123.jpeg)'
- en: 'The IP and TCP layers can be stacked by separating the variables with a forward
    slash. These layers can then be set as equal to a new variable that will represent
    the entire request. The `display()` function can then be called to view the configurations
    for the request. Once the request has been built, this can then be passed to the
    `sr1()` function so that we can analyze the response:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IP 和 TCP 层可以通过用斜杠分隔变量来堆叠。这些层可以设置为等于一个新的变量，表示整个请求。然后可以调用 `display()` 函数来查看请求的配置。一旦请求构建完成，就可以将其传递给
    `sr1()` 函数，以便分析响应：
- en: '![](../images/00126.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00126.jpeg)'
- en: 'This same request can be performed without independently building and stacking
    each layer. Instead, a single one-line command can be used by calling the functions
    directly and passing the appropriate arguments to them:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过直接调用函数并传递适当的参数来执行相同的请求，而无需独立构建和堆叠每一层。这样可以使用一个单行命令来完成：
- en: '![](../images/00127.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00127.jpeg)'
- en: 'Notice that in this particular scenario, an RST packet is received in response
    to the injected ACK packet. The next step in testing is to inject a SYN packet
    in the same manner:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在这个特定场景中，接收到一个 RST 数据包作为对注入的 ACK 数据包的响应。测试的下一步是以相同的方式注入一个 SYN 数据包：
- en: '![](../images/00128.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00128.jpeg)'
- en: 'Upon sending the SYN request in the same manner, no response is received and
    the function is discontinued when the timeout value is exceeded. This combination
    of responses indicates that stateful filtering is in place. The socket is rejecting
    all inbound connections by dropping SYN requests, but ACK packets are not filtered
    to ensure that outbound connections and sustained communication remains possible.
    This combination of responses can be tested in Python to identify statefully filtered
    ports:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同方式发送 SYN 请求后，未收到响应，并且当超时值被超出时，函数停止执行。这种响应组合表明启用了状态检测过滤。该套接字拒绝所有传入连接，通过丢弃
    SYN 请求来实现，但 ACK 数据包不会被过滤，以确保外向连接和持续通信仍然可行。这种响应组合可以在 Python 中进行测试，以识别状态过滤的端口：
- en: '![](../images/00162.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00162.jpeg)'
- en: After formulating each of the requests with Scapy, the test that can be used
    to evaluate these responses determines whether a response is received from either
    the ACK or the SYN injection, but not both. This test is effective for identifying
    both this scenario and the next scenario in which a reply will be received from
    the SYN injection but not the ACK injection. A scenario in which a SYN+ACK or
    RST+ACK response is solicited by the SYN injection, but no response is solicited
    from the ACK injection, is also an indication of stateful filtering. The testing
    for this remains the same.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 Scapy 构建每个请求后，用于评估这些响应的测试是确定是否从 ACK 或 SYN 注入中接收到响应，但不会同时从两者中接收到响应。这个测试有效地用于识别当前场景和下一个场景，其中
    SYN 注入会收到回复，而 ACK 注入则不会。一个 SYN+ACK 或 RST+ACK 响应由 SYN 注入引发，但 ACK 注入没有响应的场景，也是状态检测过滤的一个标志。该测试方法保持不变。
- en: 'First, an ACK packet should be sent to the destination port:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该向目标端口发送一个 ACK 数据包：
- en: '![](../images/00131.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00131.jpeg)'
- en: 'Notice that in the example provided, no response is solicited by this injection.
    Alternatively, if a SYN packet is injected, a response is received with the SYN+ACK
    flag bits activated if the port is open and the RST+ACK flag bits activated if
    the port is closed:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在提供的示例中，这次注入没有引发响应。或者，如果注入 SYN 数据包，则如果端口开放，将收到带有 SYN+ACK 标志位激活的响应；如果端口关闭，则会收到带有
    RST+ACK 标志位激活的响应：
- en: '![](../images/00133.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00133.jpeg)'
- en: 'The exact same test can be performed in the event of this scenario, since the
    test identifies that stateful filtering is in place by determining whether one
    of the two injections solicits a response, but not both:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下可以执行完全相同的测试，因为该测试通过确定是否有两个注入请求中的任何一个引发响应（而不是两个都引发响应）来识别是否存在状态检测过滤：
- en: '![](../images/00397.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00397.jpeg)'
- en: 'This combination of responses indicates that stateful filtering is being performed
    on ACK packets, and any ACK packets sent outside the context of a proper session
    are dropped. However, the port is not totally filtered, as evidenced by the responses
    to the inbound connection attempt. Another possible scenario would be if both
    the SYN and ACK injections solicited their expected responses. In such a scenario,
    there is no indication of any sort of filtering. To perform the testing for this
    scenario, an ACK injection should be performed and the response should be analyzed:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种响应组合表明正在对 ACK 数据包执行有状态过滤，任何在正确会话上下文之外发送的 ACK 数据包都将被丢弃。然而，端口并没有完全被过滤，从对入站连接尝试的响应可以看出这一点。另一种可能的情况是，如果
    SYN 和 ACK 注入都得到了预期的响应。在这种情况下，没有任何过滤的迹象。为了测试这种情况，应该进行 ACK 注入并分析响应：
- en: '![](../images/00138.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00138.jpeg)'
- en: 'In the event that the port is unfiltered, an unsolicited ACK packet sent to
    the destination port should result in a returned RST packet. This RST packet indicates
    that the ACK packet was sent out of context and is intended to discontinue the
    communication. Upon sending the ACK injection, a SYN injection should also be
    sent to the same port:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果端口未过滤，发送一个未经请求的 ACK 数据包到目标端口应会导致返回一个 RST 数据包。这个 RST 数据包表明 ACK 数据包是超出上下文发送的，旨在终止通信。发送
    ACK 注入后，还应该向同一端口发送一个 SYN 注入：
- en: '![](../images/00140.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00140.jpeg)'
- en: 'In the event that the port is unfiltered and is open, a SYN+ACK response will
    be returned. Notice that the actual value of the TCP `flags` attribute is a long
    variable with the value of `18`. This value can easily be converted to an integer
    using the `int` function. This value of `18` is the decimal value of the TCP flag
    bit sequence. The SYN flag bit carries a decimal value of `2`, and the ACK flag
    bit carries a decimal value of `16`. Assuming there is no indication of stateful
    filtering, we can test in Python whether the port is unfiltered and open by evaluating
    the integer conversion of the TCP `flags` value:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果端口未过滤且处于打开状态，将返回一个 SYN+ACK 响应。注意，TCP `flags` 属性的实际值是一个值为 `18` 的长变量。这个值可以通过
    `int` 函数轻松转换为整数。`18` 是 TCP 标志位序列的十进制值。SYN 标志位的十进制值为 `2`，ACK 标志位的十进制值为 `16`。假设没有有状态过滤的迹象，我们可以通过评估
    TCP `flags` 值的整数转换，在 Python 中测试端口是否未过滤且已打开：
- en: '![](../images/00613.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00613.jpeg)'
- en: 'A similar test can be performed to determine whether a port is unfiltered and
    closed. An unfiltered closed port will have the RST and ACK flag bits activated.
    As discussed previously, the ACK flag bit carries a decimal value of `16`, and
    the RST flag bit carries a decimal value of `4`. So, the expected integer conversion
    of the TCP `flags` value for an unfiltered and closed port should be `20`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以执行类似的测试，以确定端口是否未过滤且已关闭。一个未过滤且已关闭的端口将激活 RST 和 ACK 标志位。如前所述，ACK 标志位的十进制值为 `16`，RST
    标志位的十进制值为 `4`。因此，未过滤且关闭端口的 TCP `flags` 值的预期整数转换应为 `20`：
- en: '![](../images/00144.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00144.jpeg)'
- en: 'Finally, we should consider a scenario in which no response is received from
    the SYN or ACK injections. In this scenario, both instances of the `sr1()` function
    will be discontinued when the supplied timeout value is exceeded:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该考虑一种没有收到 SYN 或 ACK 注入响应的情况。在这种情况下，当提供的超时值超过时，`sr1()` 函数的两个实例将被中止：
- en: '![](../images/00147.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00147.jpeg)'
- en: 'This lack of response from either of the injections is likely an indication
    that the port is unstatefully filtered and is just dropping all incoming traffic
    regardless of the state, or it could be an indication that the remote host is
    down. One''s first thought might be that this could be tested for in Python by
    appending an execution flow for `else` at the end of the previously developed
    testing sequence. This `else` operation would, in theory, be executed if a response
    were not received by one or both injections. In short, the `else` operation would
    be executed if no response were received:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个注入都没有响应，很可能表明端口是无状态过滤的，并且无论状态如何都会丢弃所有入站流量，或者可能是远程主机宕机的迹象。人们可能会首先想到，可以通过在先前开发的测试序列末尾附加一个
    `else` 执行流程，在 Python 中测试这一点。如果没有收到一个或两个注入的响应，理论上应该执行这个 `else` 操作。简而言之，如果没有收到响应，`else`
    操作会被执行：
- en: '![](../images/00149.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00149.jpeg)'
- en: 'While this may seem like it would work in theory; it is less effective in practice.
    Python will actually return an error if value testing is performed on a variable
    that has no value. To avoid this problem, the first conditional that should be
    examined will be whether or not any reply is received at all:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然理论上它似乎可行，但在实践中效果较差。如果对没有值的变量进行值测试，Python 实际上会返回一个错误。为了避免这个问题，首先应该检查的条件是是否收到了任何回复：
- en: '![](../images/00151.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00151.jpeg)'
- en: This entire sequence of testing can then be integrated into a single functional
    script. The script will accept two arguments to include the destination IP address
    and the port to be tested. An ACK and SYN packet will then be injected and the
    responses, if any, will be stored for evaluation.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，整个测试序列可以集成到一个功能脚本中。该脚本将接受两个参数，包括目标 IP 地址和待测试端口。然后将注入 ACK 和 SYN 数据包，并存储任何收到的响应以供评估。
- en: Then, a series of four tests will be performed to determine whether filtering
    exists on the port. Initially, a test will be performed to determine whether any
    response is received at all. If no response is received, the output will indicate
    that the remote host is down or the port is unstatefully filtered and discarding
    all traffic. If any response is received, a test will be performed to determine
    whether it was a response to one injection but not both. If such is the case,
    the output will indicate that the port is statefully filtered.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将执行一系列四个测试，以确定端口是否存在过滤。首先，将执行一个测试，以确定是否收到了任何响应。如果没有收到响应，则输出将指示远程主机已关闭或端口处于无状态过滤状态并丢弃所有流量。如果收到任何响应，将执行一个测试，以确定它是对一个注入的响应而非两个。如果是这种情况，输出将指示该端口是有状态过滤的。
- en: 'Finally, if responses are received from both injections, the port will be identified
    as unfiltered, and the TCP `flags` value will be assessed to determine whether
    the port is open or closed:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果从两个注入中都收到了响应，则该端口将被识别为未过滤，并且会评估 TCP `flags` 值，以确定该端口是开放还是关闭：
- en: '[PRE2]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon creating the script in the local filesystem, the file permissions will
    need to be updated to allow execution of the script. The `chmod` command can be
    used to update these permissions, and the script can then be executed by calling
    it directly and passing the expected arguments to it:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地文件系统中创建脚本后，需要更新文件权限以允许执行该脚本。可以使用 `chmod` 命令来更新这些权限，然后可以通过直接调用该脚本并传递预期的参数来执行它：
- en: '![](../images/00155.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00155.jpeg)'
- en: How it works…
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Both SYN and ACK TCP flags play an important role in stateful network communications.
    SYN requests allow the establishment of new TCP sessions, while ACK responses
    are used to sustain a session until it is closed. A port that responds to one
    of these types of packets, but not the other, is most likely subject to filters
    that restrict traffic based on the session state. By identifying cases such as
    this, it is possible to infer that stateful filtering exists on the port in question.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: SYN 和 ACK TCP 标志在有状态网络通信中扮演重要角色。SYN 请求允许建立新的 TCP 会话，而 ACK 响应用于维持会话直到关闭。一个端口如果仅响应其中一种类型的数据包，而非另一种，极有可能受到基于会话状态的流量限制过滤。通过识别这种情况，可以推断该端口存在有状态过滤。
- en: Firewall identification with Nmap
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nmap 进行防火墙识别
- en: Nmap has a streamlined firewall filtering identification function that can be
    used to identify filtering on ports based on ACK probe responses. This function
    can be used to test a single port or multiple ports in sequence to determine filtering
    status.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 拥有简化的防火墙过滤识别功能，可以基于 ACK 探测响应来识别端口上的过滤。此功能可以用于测试单个端口或多个端口的过滤状态。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Nmap to perform firewall identification, you will need to have a remote
    system that is running network services. Additionally, you will need to implement
    some type of filtering mechanism. This can be done with an independent firewall
    device or with host-based filtering such as Windows Firewall. By manipulating
    the filtering settings on the firewall device, you should be able to modify the
    results of the scans.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Nmap 执行防火墙识别，你需要有一个远程系统正在运行网络服务。此外，你还需要实现某种类型的过滤机制。这可以通过独立的防火墙设备或基于主机的过滤（如
    Windows 防火墙）来完成。通过操作防火墙设备上的过滤设置，你应该能够修改扫描结果。
- en: How to do it…
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何实现的…
- en: 'These steps will help you to identify firewall using the Nmap:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你使用 Nmap 来识别防火墙：
- en: 'To perform an Nmap firewall ACK scan, `nmap` should be called with the IP address
    specification, the destination port, and the `-sA` option:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行 Nmap 防火墙 ACK 扫描，应该使用 `nmap` 调用，指定 IP 地址、目标端口和 `-sA` 选项：
- en: '![](../images/00333.jpeg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00333.jpeg)'
- en: 'On performing this scan on the Metasploitable2 system in my local network without
    routing the traffic through a firewall, the response indicates that the TCP port
    `22` (SSH) is unfiltered. A port-filtering assessment can be made on Nmap''s 1,000
    common ports by performing the same scan without providing a port specification:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有通过防火墙路由流量的情况下，对我的本地网络中的 Metasploitable2 系统执行此扫描时，响应表明 TCP 端口 `22`（SSH）是未过滤的。可以通过执行相同的扫描而不提供端口规格来对
    Nmap 的 1,000 个常见端口进行端口过滤评估：
- en: '![](../images/00158.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00158.jpeg)'
- en: When performed against the Metasploitable2 system on the local network that
    is not sitting behind any firewall, the results indicate that all scanned ports
    are unfiltered. If the same scan is performed against a target sitting behind
    a packet-filtering firewall, all ports are identified to be filtered except for ports
    where the firewall does not restrict traffic. When scanning a range of ports,
    the output only includes unfiltered ports.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对本地网络中的 Metasploitable2 系统进行扫描时，该系统没有位于任何防火墙之后，结果显示所有扫描的端口都未被过滤。如果相同的扫描针对一个位于包过滤防火墙之后的目标进行，则所有端口都会被识别为已过滤，除了防火墙不限制流量的端口。当扫描端口范围时，输出只包含未过滤的端口。
- en: 'To perform a scan of all possible TCP ports, all possible port address values
    must be scanned. The portions of the TCP header that define the source and destination
    port addresses are both 16 bits in length, and each bit can retain a value of
    `1` or `0`. As such, there are 2^(16), or 65,536, possible TCP port addresses.
    To scan the total possible address space, a port range of `1-65535` must be supplied:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要扫描所有可能的 TCP 端口，必须扫描所有可能的端口地址值。定义源和目标端口地址的 TCP 头部部分都是 16 位长，每一位可以保持 `1` 或 `0`
    的值。因此，可能的 TCP 端口地址有 2^(16)，即 65,536 个。要扫描所有可能的地址空间，必须提供端口范围 `1-65535`：
- en: '![](../images/00163.jpeg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00163.jpeg)'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In addition to the many other functions that Nmap provides, it also can be used
    to identify firewall filtering. The means Nmap performs this type of firewall
    identification largely by using the same techniques that were previously discussed
    in the Scapy recipe. A combination of SYN and unsolicited ACK packets are sent
    to the destination port, and the responses are analyzed to determine the state
    of filtering.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Nmap 提供的许多其他功能外，它还可以用来识别防火墙过滤。Nmap 执行此类防火墙识别的方式，主要通过使用在 Scapy 例子中讨论的相同技术。向目标端口发送
    SYN 和未经请求的 ACK 数据包组合，并分析响应以确定过滤的状态。
- en: Firewall identification with Metasploit
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Metasploit 进行防火墙识别
- en: Metasploit has a scanning `auxiliary` module that can be used to perform multithreaded
    analysis of network ports to determine whether those ports are filtered, based
    on SYN/ACK probe-response analysis.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 有一个扫描 `auxiliary` 模块，可以用来执行多线程的网络端口分析，以确定这些端口是否被过滤，这基于 SYN/ACK 探针响应分析。
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Metasploit to perform firewall identification, you will need to have
    a remote system that is running network services. Additionally, you will need
    to implement some type of filtering mechanism. This can be done with an independent
    firewall device or with host-based filtering such as Windows Firewall. By manipulating
    the filtering settings on the firewall device, you should be able to modify the
    results of the scans.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Metasploit 执行防火墙识别，您需要有一台运行网络服务的远程系统。此外，您还需要实施某种类型的过滤机制。这可以通过独立的防火墙设备或基于主机的过滤，如
    Windows 防火墙来完成。通过操作防火墙设备上的过滤设置，您应该能够修改扫描结果。
- en: How to do it…
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s use Metasploit to perform firewall identification:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Metasploit 来执行防火墙识别：
- en: 'To use the Metasploit ACK scan module to perform firewall and filtering identification,
    you must first launch the MSF console from a Terminal in Kali Linux and then select
    the desired `auxiliary` module with the `use` command:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Metasploit 的 ACK 扫描模块进行防火墙和过滤器识别，首先必须在 Kali Linux 的终端中启动 MSF 控制台，然后使用 `use`
    命令选择所需的 `auxiliary` 模块：
- en: '![](../images/00081.jpeg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00081.jpeg)'
- en: 'Once the module has been selected, the `show options` command can be used to
    identify and/or modify scan configurations. This command will display four column
    headers to include: `Name`, `Current Setting`, `Required`, and `Description`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模块后，可以使用`show options`命令来识别和/或修改扫描配置。该命令将显示四个列标题，包括：`Name`、`Current Setting`、`Required`和`Description`：
- en: The `Name` column identifies the name of each configurable variable
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`列标识每个可配置变量的名称。'
- en: The `Current Setting` column lists the existing configuration for any given
    variable
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Current Setting`列列出了任何给定变量的现有配置。'
- en: The `Required` column identifies whether a value is required for any given variable
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Required`列标识某个给定变量是否需要值。'
- en: The `Description` column describes the function of each variable
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`列描述了每个变量的功能。'
- en: 'The value for any given variable can be changed using the `set` command and
    providing the new value as an argument:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何给定变量的值都可以使用`set`命令进行更改，并提供新值作为参数：
- en: '![](../images/00146.jpeg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00146.jpeg)'
- en: In the example provided, the `RHOSTS` value was changed to the IP address of
    the remote system that we wish to scan. Additionally, the number of threads is
    changed to `25`. The `THREADS` value defines the number of concurrent tasks that
    will be performed in the background. Determining thread values consists of finding
    a good balance that will noticeably improve the speed of the task without overly
    depleting system resources. For most systems, `25` threads is a fast and reasonably
    safe number of concurrent processes.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，`RHOSTS`值被更改为我们希望扫描的远程系统的IP地址。此外，线程数被更改为`25`。`THREADS`值定义了在后台执行的并发任务数量。确定线程值的过程是找到一个良好的平衡点，既能显著提高任务的速度，又不会过度消耗系统资源。对于大多数系统来说，`25`个线程是一个快速且相对安全的并发进程数。
- en: 'After updating the necessary variables, the configurations can be verified
    using the `show options` command again. Once the desired configurations have been
    verified, the scan can be launched:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新必要的变量后，可以再次使用`show options`命令验证配置。确认所需的配置后，可以启动扫描：
- en: '![](../images/00402.jpeg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00402.jpeg)'
- en: 'Results have been truncated for space. The following is the conclusion of our
    scan:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 结果已被截断以节省空间。以下是我们扫描的结论：
- en: '![](../images/00296.jpeg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00296.jpeg)'
- en: In this instance, the only output provided is the metadata about the scan to
    indicate the number of systems scanned and that the module execution has completed.
    This lack of output is due to the fact that the responses associated with the
    SYN and ACK injections were exactly the same from port to port because the Metasploitable2
    system that was being scanned is not behind any firewall.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，唯一提供的输出是关于扫描的元数据，用于指示扫描的系统数量以及模块执行已经完成。由于被扫描的Metasploitable2系统没有处于任何防火墙后面，因此SYN和ACK注入的响应在端口之间完全相同，所以没有输出。
- en: How it works…
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Metasploit offers an `auxiliary` module that performs firewall identification
    through many of the same techniques that have been discussed in the previous recipes.
    However, Metasploit also offers the capability to perform this analysis within
    the context of a framework that can be used for other information gathering, and
    even exploitation.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit提供了一个`auxiliary`模块，通过许多在前述教程中讨论过的相同技术来执行防火墙识别。然而，Metasploit还提供了在框架的上下文中执行此分析的能力，这个框架也可以用于其他信息收集，甚至是利用攻击。
