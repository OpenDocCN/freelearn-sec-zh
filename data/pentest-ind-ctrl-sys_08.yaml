- en: '*Chapter 8*: Protocols 202'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：协议 202'
- en: We are now over halfway through the book, and we have covered a lot of material.
    We installed an ESXi server and multiple VMs, and set up our PLC to communicate
    with the VMs. We also installed a light tower and wired the I/O to the PLC. We
    installed Ignition SCADA and connected it to our PLC in the lab, and used various
    tools to scan our install and detect open ports and paths that a developer may
    have left open on the web-based SCADA system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走过了本书的一半，涵盖了大量内容。我们安装了一个ESXi服务器和多个虚拟机，并设置了我们的PLC与虚拟机进行通信。我们还安装了一个灯塔，并将I/O接入到PLC。我们安装了Ignition
    SCADA，并将其连接到实验室中的PLC，使用各种工具扫描我们的安装，检测开发人员可能在基于Web的SCADA系统上留下的开放端口和路径。
- en: In this chapter, we are going to explore some of the main protocols used by
    **Industrial Control Systems** (**ICS**). We will be utilizing the VMs that we
    created in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*,
    to generate protocol-specific traffic and we will then make use of Wireshark and
    TShark to analyze the protocol in further detail, much like we did in [*Chapter
    6*](B16321_06_Epub_AM.xhtml#_idTextAnchor063), *Packet Deep Dive*. As you read
    through this book, you should get the feeling that every chapter is building on
    the previous chapter, helping to reinforce the skills that you have learned, and
    then we want to add on a new skill or nugget of knowledge that we will expand
    on later.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些**工业控制系统**（**ICS**）中使用的主要协议。我们将利用在[*第1章*](B16321_01_Epub_AM.xhtml#_idTextAnchor013)
    *使用虚拟化*中创建的虚拟机（VM）来生成特定协议的流量，接着我们将使用Wireshark和TShark来进一步分析协议，就像我们在[*第6章*](B16321_06_Epub_AM.xhtml#_idTextAnchor063)
    *数据包深度分析*中所做的那样。当你阅读本书时，你应该会感觉到每一章都在前一章的基础上构建，帮助强化你所学的技能，然后我们会添加一个新技能或知识点，并在后面进行扩展。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Industry protocols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行业协议
- en: Modbus crash course
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modbus速成课程
- en: Turning lights on with Ethernet/IP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ethernet/IP打开灯光
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将需要以下内容：
- en: A PLC VM running and having the **pymodbus** package installed on it
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行并安装了**pymodbus**包的PLC虚拟机
- en: A PLC VM running and having the **cpppo** package installed on it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行并安装了**cpppo**包的PLC虚拟机
- en: A SCADA VM running and having the **mbtget** tool installed on it
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行并安装了**mbtget**工具的SCADA虚拟机
- en: A SCADA VM running and having the **cpppo** package installed on it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行并安装了**cpppo**包的SCADA虚拟机
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3BCyMWV](https://bit.ly/3BCyMWV)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此查看本章代码的实际操作：[https://bit.ly/3BCyMWV](https://bit.ly/3BCyMWV)
- en: Industry protocols
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业协议
- en: 'After much thought and outside suggestions, I have added this preliminary section
    to talk about industry protocols. I specifically narrow in on Modbus and Ethernet/IP
    since our Koyo CLICK PLC has the ability to leverage both of these protocols.
    However, I feel that it would have been almost an injustice to not at least touch
    on the width and breadth of the industrial protocol space. Every industry and
    region that I have come across has tended to gravitate toward one specific vendor
    or another. On some continents, I have seen products, vendors, and protocols of
    equipment uniquely specific to that region of the world. With that said, I am
    going to quickly cover some of the major industry protocols that you will encounter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经过深思熟虑和外部建议后，我新增了这一初步部分，讨论行业协议。我特别关注Modbus和Ethernet/IP，因为我们的Koyo CLICK PLC能够利用这两种协议。然而，我觉得如果不至少触及工业协议领域的广度和深度，那几乎是一种不公。每个行业和我接触过的地区，似乎都会倾向于选择一个特定的供应商。在一些大陆，我看到的设备、供应商和协议是该地区特有的。话虽如此，我将快速概述一些你可能会遇到的主要行业协议：
- en: '**Modbus**: One of the oldest and most universally adopted protocols, most
    control applications are engineered in **Modbus** first and then ported to a different
    protocol and tested side by side to ensure that the process control strategy functions
    as intended. Modicon published the Modbus standard and Schneider Electric acquired
    Modicon through a series of acquisitions and mergers. This means, when you discover
    a piece of SE equipment on the network, there is a high probability that it will
    be using Modbus to communicate.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Modbus**：这是最古老且被广泛采用的协议之一，大多数控制应用程序首先在**Modbus**中设计，然后移植到其他协议，并并行测试以确保过程控制策略按预期功能运行。Modicon发布了Modbus标准，施耐德电气通过一系列并购收购了Modicon。这意味着，当你在网络上发现一台施耐德电气设备时，它很有可能使用Modbus进行通信。'
- en: Typical ports used are **502**, **5020**, and **7701**.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用端口是**502**、**5020**和**7701**。
- en: '**Ethernet/IP**: This is a protocol with a wide global presence typically found
    in Rockwell equipment but adopted by a multitude of control automation vendors.
    It was originally designed by the **Control International** (**CI**) working group
    to deliver control message objects while leveraging the robustness of the TCP/IP
    stack. **Ethernet/IP** is the delivery system for the **Common Industrial Protocol**
    (**CIP**), which we discuss in more detail later in this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ethernet/IP**：这是一种在全球范围内广泛应用的协议，通常出现在Rockwell设备中，但也被众多控制自动化供应商采用。它最初由**Control
    International**（**CI**）工作组设计，旨在提供控制消息对象，同时利用TCP/IP协议栈的强大功能。**Ethernet/IP**是**Common
    Industrial Protocol**（**CIP**）的传输系统，我们将在本章稍后部分详细讨论该协议。'
- en: Typical ports used are **44818** and **2222**.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用端口是**44818**和**2222**。
- en: '**DNP3**: This is a protocol used by SCADA systems to interconnect process
    equipment utilized in the power and water industries. It is an open standard that
    has gained international traction; however, you will find it most commonly used
    in the North American market.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DNP3**：这是一个由SCADA系统使用的协议，用于连接电力和水务行业中使用的过程设备。它是一个开放标准，已获得国际认可；然而，你会发现它最常用于北美市场。'
- en: The typical port used is **20000**.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用端口是**20000**。
- en: '**S7 /S7+**: Step 7 was designed by Siemens to be a closed protocol (but based
    on ISO 8073 Class 0) that would uniquely link Siemens equipment. Predominantly
    Europe-based, Siemens products could be found in almost every country and every
    process vertical. It was the control automation industry leader for a time and
    dominated everywhere, with the exceptions of North America and Japan. It is most
    famous for being the equipment and protocol that was leveraged in the Stuxnet
    attack, which involved the Iranian nuclear program. **S7+** was introduced to
    provide more secure and rich features to address the security risks of replay
    attacks.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S7 /S7+**：Step 7是由西门子设计的一种封闭协议（但基于ISO 8073 Class 0），旨在唯一地连接西门子设备。主要应用于欧洲，西门子产品几乎遍布每个国家和每个过程行业。它曾是控制自动化行业的领导者，并在全球范围内占据主导地位，北美和日本除外。它最著名的是作为在Stuxnet攻击中使用的设备和协议，该攻击涉及伊朗的核项目。**S7+**的推出是为了提供更多的安全性和丰富的功能，以应对重放攻击的安全风险。'
- en: Typical ports used are **102** and **1099**.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用端口是**102**和**1099**。
- en: '**Melsec**: This is a protocol developed by Mitsubishi Electric and has made
    this list as it is widely used in Japan across all industries.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Melsec**：这是三菱电机开发的一种协议，由于在日本各行各业广泛应用，因此进入了此列表。'
- en: Typical ports used are **1025**, **1026**, and **1027**.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常用端口是**1025**、**1026**和**1027**。
- en: 'Notable protocols are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要协议如下：
- en: Bristol's **Bristol Standard Asynchronous Protocol** (**BSAP**), used in the
    oil and gas industry.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布里斯托尔的**布里斯托尔标准异步协议**（**BSAP**），广泛用于石油和天然气行业。
- en: The GE **Service Request Transport Protocol** (**SRTP**), used by almost all
    General Electric equipment.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用电气**服务请求传输协议**（**SRTP**），几乎所有通用电气设备都在使用该协议。
- en: '**Building Automation and Control Network** (**BACnet**), used widely to control
    heating, ventilation, and air conditioning in the building management industry.
    It''s important to note that the Target breach of 2013 occurred through an HVAC
    company that had remote access to monitor environmental sensors.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建筑自动化和控制网络**（**BACnet**），广泛用于建筑管理行业控制供暖、通风和空调。值得注意的是，2013年Target的网络泄露就是通过一家HVAC公司发生的，该公司具有远程访问权限来监控环境传感器。'
- en: '**Control Area Network** (**CANBus**), developed by Bosch in the 80s, it has
    now become the de facto standard in transportation, automobiles, ships, planes,
    farm equipment, and more. This is a very interesting protocol as it is the backbone
    of autonomous vehicles.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制区域网络**（**CANBus**），由博世在80年代开发，现在已成为运输、汽车、船只、飞机、农用设备等领域的事实标准。这是一个非常有趣的协议，因为它是自动驾驶汽车的骨干。'
- en: The list grows from here and as we see **Internet of Things** (**IOT**) and
    **Industrial Internet of Things** (**IIOT**) being introduced into the industrial
    world more, you will encounter protocols such as **Message Queuing Telemetry Transport**
    (**MQTT**), ZigBee, **Advanced Message Queuing Protocol** (**AMQP**), and others.
    In the next section, we will be doing a deep dive into the Modbus protocol.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**物联网**（**IOT**）和**工业物联网**（**IIOT**）在工业界的引入，您将遇到如**消息队列遥测传输协议**（**MQTT**）、ZigBee、**高级消息队列协议**（**AMQP**）等协议。在下一节中，我们将深入探讨Modbus协议。
- en: Modbus crash course
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Modbus速成课程
- en: 'Modbus was a serial protocol that was published in the 1970s as a means of
    connecting equipment in an industrial process over a common bus. Since Modbus''s
    publication, there have been many evolutions of the protocol and variants. This
    is largely due to the openness and flexibility of the protocol standard. As this
    protocol is the most broadly used for connecting industrial equipment, you can
    imagine there have been many books and papers written on the subject. We are going
    to focus specifically on Modbus TCP and the various commands and functions that
    can be used. I strongly recommend reading up on the history and evolution of Modbus,
    as you will gain a deeper insight into how industry has adapted this protocol
    to suite their process and specific operational needs. Follow this link to get
    a brief history of Modbus: [https://www.youtube.com/watch?v=OuM28tp5wXc](https://www.youtube.com/watch?v=OuM28tp5wXc).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Modbus是一个串行协议，发布于1970年代，作为连接工业过程中的设备的共同总线的手段。自Modbus发布以来，协议和变体经历了许多演变。这主要归功于该协议标准的开放性和灵活性。由于此协议是连接工业设备最广泛使用的协议，您可以想象，已经有许多书籍和论文讨论了这一主题。我们将专门关注Modbus
    TCP及其可用的各种命令和功能。我强烈建议您阅读有关Modbus历史和演变的资料，因为这将帮助您深入了解工业如何将此协议调整以适应其过程和特定的操作需求。点击此链接，了解Modbus的简短历史：[https://www.youtube.com/watch?v=OuM28tp5wXc](https://www.youtube.com/watch?v=OuM28tp5wXc)。
- en: 'Modbus TCP encapsulates Modbus RTU packets inside of a TCP packet, allowing
    data to be exchanged via an IP address, which is a drastic change from the previous
    RS-232 or RS-485 forms of serial communication. It is structured in a client-server
    model, allowing a client to communicate with multiple servers and transmit operational
    and control data back and forth. Operational and control inputs and outputs utilize
    various registers depending on the implementation and content of the data. Following
    is a table of registers and the bit sizes as defined in the Modbus standard:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Modbus TCP将Modbus RTU数据包封装在TCP数据包内，使得数据可以通过IP地址进行交换，这与以前的RS-232或RS-485串行通信形式相比是一次巨大的变化。它采用客户端-服务器模型，允许客户端与多个服务器通信，并双向传输操作和控制数据。操作和控制输入输出根据数据的实现和内容使用不同的寄存器。以下是Modbus标准中定义的寄存器及其位大小的表格：
- en: '![](image/B16321_08_Table_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16321_08_Table_01.jpg)'
- en: 'If you remember back in [*Chapter 3*](B16321_03_Epub_AM.xhtml#_idTextAnchor033),
    *I Love My Bits – Lab Setup*, when we configured a program and downloaded it onto
    the Koyo CLICK, we used contacts and coils in our ladder logic to turn on and
    off the lights. As you can see in the preceding table, those coils and discrete
    inputs are 1 bit in size. We used the GUI to directly toggle the lights ON and
    OFF by overriding and forcing the I/O. The engineering software sends a packet
    that contains a bundle of data and inside that bundle, there is function code
    and a register or list of registers. The function code defines the action expected
    for the PLC and what to do to the following registers. In the case of our light
    scenario, we are sending a packet that ships a 1-bit count with the value of 1
    to coil 1 using function code 5, which is the function code for writing a single
    coil. Here is a table of standard function codes used in the Modbus protocol:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得在[*第3章*](B16321_03_Epub_AM.xhtml#_idTextAnchor033)，*我爱我的位 – 实验室设置*中，当我们配置一个程序并将其下载到Koyo
    CLICK时，我们在梯形逻辑中使用接点和线圈来打开和关闭灯。正如前面的表格所示，这些线圈和离散输入的大小是1位。我们使用GUI直接切换灯的开关状态，通过覆盖并强制I/O。工程软件发送一个包含一捆数据的包，在这捆数据中，有功能代码和寄存器或寄存器列表。功能代码定义了PLC所期望的操作及其对后续寄存器的处理方式。在我们的灯光场景中，我们发送一个数据包，使用功能代码5（用于写单个线圈的功能代码）将值为1的1位计数发送到线圈1。以下是Modbus协议中常用的标准功能代码表：
- en: '![](image/B16321_08_Table_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16321_08_Table_02.jpg)'
- en: Establishing a Modbus server
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立一个Modbus服务器
- en: The best way to learn is by example. Remember back in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, when we installed two different programs on both the PLC
    and SCADA VMs, which were **pymodbus** and **mbtget**? We are going to set up
    a server and client and then write some simple communication between the two and
    use Wireshark to eavesdrop on the network and analyze the traffic that we are
    sending.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的学习方法是通过示例。还记得在[*第1章*](B16321_01_Epub_AM.xhtml#_idTextAnchor013)，*使用虚拟化*中，当我们在PLC和SCADA虚拟机上安装了两个不同的程序，分别是**pymodbus**和**mbtget**吗？我们将设置一个服务器和客户端，然后在它们之间编写一些简单的通信，并使用Wireshark监听网络，分析我们发送的流量。
- en: 'We will start by using an example from the following link: [https://github.com/riptideio/pymodbus](https://github.com/riptideio/pymodbus).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下链接的示例开始：[https://github.com/riptideio/pymodbus](https://github.com/riptideio/pymodbus)。
- en: 'To make it easier, I will include the following source code so that you can
    copy and paste it into your PLC VM:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我将包括以下源代码，供你复制并粘贴到你的PLC虚拟机中：
- en: '#!/usr/bin/env python'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/env python'
- en: from pymodbus.device import ModbusDeviceIdentification
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 来自pymodbus.device的导入ModbusDeviceIdentification
- en: from pymodbus.datastore import ModbusSequentialDataBlock
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来自pymodbus.datastore的导入Modbus顺序数据块
- en: from pymodbus.datastore import ModbusSlaveContext, ModbusServerContext
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 来自pymodbus.datastore的导入ModbusSlaveContext, ModbusServerContext
- en: from pymodbus.transaction import (ModbusRtuFramer,
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 来自pymodbus.transaction的导入(ModbusRtuFramer,
- en: ModbusAsciiFramer,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ModbusAsciiFramer,
- en: ModbusBinaryFramer)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ModbusBinaryFramer)
- en: import logging
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 导入日志记录
- en: FORMAT = ('%(asctime)-15s %(threadName)-15s'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FORMAT = ('%(asctime)-15s %(threadName)-15s'
- en: '''%(levelname)-8s %(module)-15s:%(lineno)-8s %(message)s'')'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '''%(levelname)-8s %(module)-15s:%(lineno)-8s %(message)s'')'
- en: logging.basicConfig(format=FORMAT)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: logging.basicConfig(format=FORMAT)
- en: log = logging.getLogger()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: log = logging.getLogger()
- en: log.setLevel(logging.DEBUG)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: log.setLevel(logging.DEBUG)
- en: 'def run_async_server():'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run_async_server():'
- en: store = ModbusSlaveContext(
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: store = ModbusSlaveContext(
- en: di=ModbusSequentialDataBlock(0, [17]*100),
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: di=Modbus顺序数据块(0, [17]*100),
- en: co=ModbusSequentialDataBlock(0, [17]*100),
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: co=Modbus顺序数据块(0, [17]*100),
- en: hr=ModbusSequentialDataBlock(0, [17]*100),
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: hr=Modbus顺序数据块(0, [17]*100),
- en: ir=ModbusSequentialDataBlock(0, [17]*100))
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ir=Modbus顺序数据块(0, [17]*100))
- en: context = ModbusServerContext(slaves=store, single=True)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: context = ModbusServerContext(slaves=store, single=True)
- en: identity = ModbusDeviceIdentification()
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: identity = Modbus设备识别()
- en: identity.VendorName = 'Pymodbus'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: identity.VendorName = 'Pymodbus'
- en: identity.ProductCode = 'PM'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: identity.ProductCode = 'PM'
- en: identity.VendorUrl = 'http://github.com/riptideio/pymodbus/'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: identity.VendorUrl = 'http://github.com/riptideio/pymodbus/'
- en: identity.ProductName = 'Pymodbus Server'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: identity.ProductName = 'Pymodbus 服务器'
- en: identity.ModelName = 'Pymodbus Server'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: identity.ModelName = 'Pymodbus 服务器'
- en: identity.MajorMinorRevision = version.short()
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: identity.MajorMinorRevision = version.short()
- en: StartTcpServer(context, identity=identity, address=("0.0.0.0", 5020))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 启动TcpServer(context, identity=identity, address=("0.0.0.0", 5020))
- en: 'if __name__ == "__main__":'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: run_async_server()
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: run_async_server()
- en: We are going to place this code into a file called **server.py**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这段代码放入一个名为**server.py**的文件中。
- en: 'We will then proceed to run the server file by typing the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过输入以下命令来运行服务器文件：
- en: python3 server.py
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: python3 server.py
- en: 'If everything worked out correctly, you should see the following screen:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到以下屏幕：
- en: '![Figure 8.1 – pymodbus server'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – pymodbus 服务器'
- en: '](image/B16321_08_001.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_001.jpg)'
- en: Figure 8.1 – pymodbus server
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – pymodbus 服务器
- en: 'Once we have the server running on the PLC, we will navigate to our SCADA VM
    and run the **mbtget** command as a client to query the register on the virtual
    PLC. Run the command **mbtget -r1** (read bit function 1), **-a 1** (address number
    1), **-n 10** (get the next 10 registers), **192.168.1.10** (the IP address of
    the virtual PLC), and -**p 5020** (port number). This is the breakdown of the
    command and you can learn more by running **mbtget -h**:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 PLC 上运行了服务器，我们将导航到 SCADA 虚拟机，并作为客户端运行 **mbtget** 命令以查询虚拟 PLC 上的寄存器。运行命令
    **mbtget -r1**（读取位功能 1）、**-a 1**（地址号 1）、**-n 10**（获取接下来的 10 个寄存器）、**192.168.1.10**（虚拟
    PLC 的 IP 地址）、**-p 5020**（端口号）。这是该命令的拆解，您可以通过运行 **mbtget -h** 了解更多：
- en: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
- en: 'If the command is run correctly and the server side is listening for a connection,
    you will receive the following response:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行正确，并且服务器端正在监听连接，您将收到以下响应：
- en: '![Figure 8.2 – 10 Modbus registers'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 10 个 Modbus 寄存器'
- en: '](image/B16321_08_002.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_002.jpg)'
- en: Figure 8.2 – 10 Modbus registers
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 10 个 Modbus 寄存器
- en: Next, we want to run Wireshark on the network segment, and detect the Modbus
    communication by using the Modbus display filter in Wireshark. First, we need
    to make sure that the ESXi virtual switch is allowing promiscuous mode, giving
    us the ability to sniff the switch and view it in Wireshark.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在网络段上运行 Wireshark，并通过 Wireshark 中的 Modbus 显示过滤器检测 Modbus 通信。首先，我们需要确保
    ESXi 虚拟交换机允许混杂模式，从而使我们能够嗅探交换机并在 Wireshark 中查看。
- en: 'Open your ESXi web management console, navigate to **Networking**, and select
    **vSwitch1** from the left-hand menu:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 ESXi Web 管理控制台，导航到 **网络**，并从左侧菜单中选择 **vSwitch1**：
- en: '![Figure 8.3 – vSwitch1 ESXi'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – vSwitch1 ESXi'
- en: '](image/B16321_08_003.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_003.jpg)'
- en: Figure 8.3 – vSwitch1 ESXi
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – vSwitch1 ESXi
- en: 'Once selected, you should verify that your security policy allows promiscuous
    mode as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，您应该验证您的安全策略是否允许混杂模式，如下图所示：
- en: '![Figure 8.4 – Promiscuous mode'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 混杂模式'
- en: '](image/B16321_08_004.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_004.jpg)'
- en: Figure 8.4 – Promiscuous mode
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 混杂模式
- en: 'If **Allow promiscuous mode** is off, then click the **Settings** button and,
    under the **Security** tab, adjust it to **Yes** by selecting the **Accept** option,
    as seen in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **允许混杂模式** 被禁用，则点击 **设置** 按钮，然后在 **安全性** 标签下，选择 **接受** 选项，将其调整为 **是**，如以下截图所示：
- en: '![Figure 8.5 – Edit switch settings'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 编辑交换机设置'
- en: '](image/B16321_08_005.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_005.jpg)'
- en: Figure 8.5 – Edit switch settings
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 编辑交换机设置
- en: 'Now that we have **Allow promiscuous mode** enabled, open either your Kali
    Linux VM or Windows VM and run Wireshark. Enable the interface that is in the
    same segment as the PLC and SCADA. As a recap, when we configured our lab in [*Chapter
    1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*, we set
    up our PLC and connected it to **Level 1: Process**, and with our SCADA, we connected
    it to **Level 2: Local Control**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已启用 **允许混杂模式**，请打开 Kali Linux 虚拟机或 Windows 虚拟机并运行 Wireshark。启用与 PLC 和 SCADA
    位于同一网络段的接口。回顾一下，当我们在[*第一章*](B16321_01_Epub_AM.xhtml#_idTextAnchor013)《使用虚拟化》中配置实验室时，我们将
    PLC 设置并连接到 **Level 1: Process**，并将 SCADA 连接到 **Level 2: Local Control**。'
- en: 'Once you have Wireshark up and running and listening to the interface that
    is attached to the network segment that the PLC and SCADA are communicating across,
    go ahead and rerun the command on the client that will read the 10 registers from
    the server. You should see the following output in Wireshark:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动并运行 Wireshark，并监听连接到 PLC 和 SCADA 通信的网络段的接口，接下来在客户端重新运行命令，以从服务器读取 10 个寄存器。您应该在
    Wireshark 中看到以下输出：
- en: '![Figure 8.6 – Modbus capture'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – Modbus 捕获'
- en: '](image/B16321_08_006.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_006.jpg)'
- en: Figure 8.6 – Modbus capture
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – Modbus 捕获
- en: 'Now, you might be wondering why there is a difference between my output and
    yours. The main reason is that we are running Modbus TCP over port **5020** and
    the Wireshark dissector is set for port **502** as the default. To fix this, we
    need to right-click on the packet and select **Decode As…** as you will see on
    the following screen:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能在想为什么我的输出和你的不同。主要原因是我们正在通过端口**5020**运行Modbus TCP，而Wireshark的解码器默认设置为端口**502**。为了解决这个问题，我们需要右键点击数据包并选择**解码为…**，如下图所示：
- en: '![Figure 8.7 – Decode As...'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 解码为…'
- en: '](image/B16321_08_007.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_007.jpg)'
- en: Figure 8.7 – Decode As...
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 解码为…
- en: 'That will then pop up a window similar to the following screen:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会弹出一个类似以下截图的窗口：
- en: '![Figure 8.8 – Modbus TCP port 5020'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8 – Modbus TCP端口5020'
- en: '](image/B16321_08_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_008.jpg)'
- en: Figure 8.8 – Modbus TCP port 5020
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – Modbus TCP端口5020
- en: From here, select the port value of **5020** and then select the **Current**
    dissector to be **Modbus/TCP**. You should see that your TCP packets are now decoded
    as Modbus.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，选择端口值**5020**，然后选择**当前**解码器为**Modbus/TCP**。你应该看到你的TCP数据包现在已被解码为Modbus。
- en: 'From here, if you click into the first packet and drill down into the dissector
    layers for Modbus/TCP and Modbus, you should see something similar to the following
    screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果你点击第一个数据包，并深入查看Modbus/TCP和Modbus的解码器层，你应该会看到类似以下截图的内容：
- en: '![Figure 8.9 – Modbus request'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9 – Modbus请求'
- en: '](image/B16321_08_009.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_009.jpg)'
- en: Figure 8.9 – Modbus request
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – Modbus请求
- en: 'As mentioned previously, we are sending a bit count and a function code. Here,
    we see that the bit count is **10**, as expected, from our command and that **Function
    Code** is **Read Coils (1)**. Now examine the packet seen in this screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在发送位计数和功能代码。在这里，我们看到位计数为**10**，符合我们命令的预期，并且**功能代码**为**读取线圈（1）**。现在检查此截图中的数据包：
- en: '![Figure 8.10 – Modbus response'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – Modbus响应'
- en: '](image/B16321_08_010.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_010.jpg)'
- en: Figure 8.10 – Modbus response
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – Modbus响应
- en: 'This is the response packet sent from the server. As you can see, it is the
    same information that we saw inside the SCADA client where we used the **mbtget**
    command. We have 10 coils, starting at address 1, all displaying that they are
    toggled on or reading a true value. Next, we want to look at manually toggling
    these coils using **mbtget**. Run the **mbtget -w5** (function code 5 write coil),
    **0** being the bit value (off) and 1 being the bit value (on), **192.168.1.10**
    (IP address), **-p 5020** (finally, this is the port being used) command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从服务器发送的响应数据包。如你所见，这和我们在SCADA客户端中看到的相同内容，那里我们使用了**mbtget**命令。我们有10个线圈，从地址1开始，全部显示为已切换开启或读取为真值。接下来，我们要查看如何使用**mbtget**手动切换这些线圈。运行**mbtget
    -w5**（功能代码5写单个线圈），**0**表示位值（关闭），**1**表示位值（开启），**192.168.1.10**（IP地址），**-p 5020**（最后，这是使用的端口）命令：
- en: mbtget -w5 0 -a 1 192.168.1.10 -p 5020
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -w5 0 -a 1 192.168.1.10 -p 5020
- en: 'If everything worked and you have communication between the PLC and SCADA client,
    you should see the following screen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，并且PLC与SCADA客户端之间有通信，你应该看到以下屏幕：
- en: '![Figure 8.11 – bit write ok'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – 位写入成功'
- en: '](image/B16321_08_011.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_011.jpg)'
- en: Figure 8.11 – bit write ok
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 位写入成功
- en: 'Compare the output to the Wireshark capture. You should see the following Modbus
    layer information:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出与Wireshark捕获进行比较。你应该看到以下Modbus层的信息：
- en: '**Function Code** of **5** for **Write Single Coil**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能代码**为**5**，用于**写单个线圈**'
- en: '**Reference Number**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考编号**'
- en: And finally, **Data** of **0**
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**数据**为**0**
- en: 'This is all shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容如以下截图所示：
- en: '![Figure 8.12 – Write Single Coil'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – 写单个线圈'
- en: '](image/B16321_08_012.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_012.jpg)'
- en: Figure 8.12 – Write Single Coil
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 写单个线圈
- en: 'Now use **mbtget** to query the server registers again by running the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用**mbtget**再次查询服务器寄存器，运行以下命令：
- en: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
- en: 'You should see that your coil at address 1 is now off:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到地址1的线圈现在已关闭：
- en: '![Figure 8.13 – Address 1 is off'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.13 – 地址1为关闭状态'
- en: '](image/B16321_08_013.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_013.jpg)'
- en: Figure 8.13 – Address 1 is off
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 地址1为关闭状态
- en: 'Compare this to your Wireshark capture Modbus response packet, as shown in
    the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与您的Wireshark捕获的Modbus响应数据包进行比较，如以下截图所示：
- en: '![Figure 8.14 – Modbus response address 1 is 0'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – Modbus响应地址1为0'
- en: '](image/B16321_08_014.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_014.jpg)'
- en: Figure 8.14 – Modbus response address 1 is 0
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – Modbus响应地址1为0
- en: 'Finally, using the same steps and functions that we ran against the virtual
    PLC, now run the commands against your Koyo CLICK or the PLC that you have set
    up in your lab, running Modbus. Use this command to turn your top light, the red
    light, ON:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用我们在虚拟PLC上运行的相同步骤和功能，现在在你的Koyo CLICK或你在实验室中设置的运行Modbus的PLC上运行命令，打开顶部的红灯：
- en: mbtget -w5 1 -a 0 192.168.1.20
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -w5 1 -a 0 192.168.1.20
- en: 'You should see your red light turn on. Next, we want to run the **mbtget**
    command to read the coils. Run the following command to see the response from
    the PLC and the coils that are enabled/disabled:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到红灯亮起。接下来，我们需要运行**mbtget**命令来读取线圈。运行以下命令查看PLC的响应以及启用/禁用的线圈：
- en: mbtget -r1 -a 0 -n 4 192.168.1.20
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -r1 -a 0 -n 4 192.168.1.20
- en: 'You should get the following output from running both commands:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在运行两个命令后获得以下输出：
- en: '![Figure 8.15 – mbtget read Koyo CLICK'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – mbtget读取Koyo CLICK](image/B16321_08_015.jpg)'
- en: '](image/B16321_08_015.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_015.jpg)'
- en: Figure 8.15 – mbtget read Koyo CLICK
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – mbtget读取Koyo CLICK
- en: You might have noticed by now, it is rather easy to interact with the I/O on
    a PLC, RTU, flow computer, GC, controller, or any other technology that is running
    Modbus as the primary control or operational protocol. This plays a very important
    role while pentesting. If you gather enough information, you will have the ability
    to piece together how the control data can manipulate the real-world process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经注意到，与PLC、RTU、流量计算机、气相色谱仪（GC）、控制器或任何其他使用Modbus作为主要控制或操作协议的技术进行I/O交互是相当容易的。这在渗透测试中起着非常重要的作用。如果你收集到足够的信息，你将能够拼凑出控制数据如何操控现实世界中的过程。
- en: Caution
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When working on your engagement with the customer, have well-defined **Rules
    of Engagement** (**ROE**) and always err on the side of caution when working at
    this level in a facility. If you have access and the ability to write to coils
    or registers, unless it has been blessed and signed off on in the ROE do not,
    I repeat do not push random data to coils, inputs, or registers. You may inadvertently
    shut down production lines or process trains, and this could have the adverse
    effect of creating a massive loss of revenue for your customer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在与客户互动时，确保有明确的**互动规则**（**ROE**），并且在设施中工作时，始终采取谨慎的态度。如果你有访问权限并能够对线圈或寄存器进行写入操作，除非在ROE中已经获得批准并签字，否则请不要，我重复一遍，千万不要随便向线圈、输入或寄存器发送随机数据。你可能会无意中关闭生产线或工艺列车，这可能会对客户造成巨大的收入损失。
- en: I am going to leave you here with Modbus and let you go on and do further research
    on the protocol and the capabilities of it. I would recommend getting familiar
    with **mbtget** and playing with the package as it is a powerful tool written
    in Perl. We quickly spun up **pymodbus** as a server; however, there are more
    examples where you can run **pymodbus** in client mode as well. From here, we
    will look at Ethernet/IP. It is a widely used protocol, not because of a mass-adopted
    standard but more because of a sales team that did a great job of getting their
    technology out there and into many different industries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里结束Modbus部分，让你继续深入研究该协议及其功能。我建议你熟悉**mbtget**并尝试使用它，因为它是一个用Perl编写的强大工具。我们快速启动了**pymodbus**作为服务器；然而，也有更多示例可以将**pymodbus**作为客户端模式运行。从这里开始，我们将研究Ethernet/IP协议。它是一种广泛使用的协议，不是因为它是一个被广泛接受的标准，而是因为他们的销售团队做得非常出色，成功将技术推广到许多不同的行业。
- en: Turning lights on with Ethernet/IP
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ethernet/IP打开灯
- en: This protocol has been widely adopted in the North American market. I feel it
    was due to the fact that it became the foundational protocol utilized and baked
    into Rockwell Automation products. It started popping up in the control engineering
    space in the late 90s, almost two decades after Modbus. **Common Industrial Protocol**
    (**CIP**) messages are the core element that powers Ethernet/IP. It is the object-oriented
    and open nature of CIP that has allowed quick adoption in the market. An interesting
    stat that I came across was that Ethernet/IP was estimated to have had 30% utilization
    in the industrial global market share. This is quite substantial and the reason
    why it makes it worth discussing and reviewing in this book. For a more in-depth
    and detailed read on the Ethernet/IP protocol, use the link [https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf](https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf)
    and read through the material that is provided by **Open DeviceNet Vendors Association**
    (**ODVA**). I am going to run through some high-level details that can be useful
    when you are performing a pentest on a client's network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议在北美市场得到广泛应用。我认为这与它成为了罗克韦尔自动化产品中基础协议并被嵌入其中有关。它大约在 90 年代末期，几乎是在 Modbus 发布近二十年后，开始在控制工程领域得到应用。**通用工业协议**（**CIP**）消息是驱动
    Ethernet/IP 的核心元素。正是由于 CIP 面向对象和开放的特性，才使得它能够迅速在市场上得到采用。我看到的一个有趣的统计数据是，Ethernet/IP
    被估计在全球工业市场的使用率为 30%。这一比例相当可观，也正是为什么这本书值得讨论和回顾它的原因。若要深入阅读有关 Ethernet/IP 协议的更多详细信息，请使用链接
    [https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf](https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf)
    并阅读 **开放设备网络供应商协会**（**ODVA**）提供的材料。我将简要介绍一些在进行客户网络渗透测试时可能有用的高级细节。
- en: 'Ethernet/IP sends CIP messages between equipment on the network for operating
    process equipment. These CIP messages are a collection of objects and these objects
    have three specific categories:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ethernet/IP 在网络上的设备之间发送 CIP 消息，以操作过程设备。这些 CIP 消息是多个对象的集合，这些对象有三个特定类别：
- en: General-use objects
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用对象
- en: Application-specific objects
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用特定对象
- en: Network-specific objects
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络特定对象
- en: General-use objects are the most common items that you will find in industry.
    Most devices utilize this object to pass useful information between controllers
    and servers. Application- and network-specific objects, as the names suggest,
    will only be found in applications or networks utilizing these objects. We are
    going to focus on general-use objects in this next section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通用对象是工业中最常见的项目。大多数设备利用这个对象在控制器和服务器之间传递有用的信息。应用特定对象和网络特定对象，如其名称所示，只会出现在使用这些对象的应用程序或网络中。在接下来的部分，我们将专注于通用对象。
- en: 'Following is a table of general-use objects:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通用对象的表格：
- en: '![](image/B16321_08_Table_03.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16321_08_Table_03.jpg)'
- en: 'If we take a closer look at the general-use identity object (**0x01**), we
    discover that there are two groups of attributes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看通用身份对象（**0x01**），会发现它包含两组属性：
- en: Mandatory attributes
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需属性
- en: Optional attributes
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选属性
- en: 'A list of mandatory attributes can be found in the following table:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了必需的属性：
- en: '![](image/B16321_08_Table_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16321_08_Table_04.jpg)'
- en: 'A list of optional attributes can be found in the following table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了可选属性：
- en: '![](image/B16321_08_Table_05.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B16321_08_Table_05.png)'
- en: 'These attributes that have been listed out are passed in the **Identity CIP**
    object via the Ethernet/IP protocol. We are focusing on this specific object for
    a few reasons:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列出的属性通过 Ethernet/IP 协议传递到**身份 CIP**对象。我们之所以专注于这个特定对象，有几个原因：
- en: All IDS vendors typically start with this protocol and specific packet to start
    building out their asset detection engine.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 IDS 供应商通常都会从此协议和特定数据包开始，构建他们的资产检测引擎。
- en: Understanding how this object is constructed will allow us to reproduce it as
    a **Honey Pot**.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解这个对象的构造方式将使我们能够将其复现为**蜜罐**。
- en: We are going to use the CPPPO package that we installed in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, to demonstrate how Ethernet/IP works, and we will start
    with the **Identity** object.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用在 [*第一章*](B16321_01_Epub_AM.xhtml#_idTextAnchor013) 中安装的 CPPPO 包，*使用虚拟化*，来演示
    Ethernet/IP 如何工作，我们将从 **身份** 对象开始。
- en: Establishing the EthernetIP server
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立 EthernetIP 服务器
- en: 'Make sure that on your PLC, you have installed the **cpppo** package by running
    the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的 PLC 上安装了**cpppo**包，方法是运行以下命令：
- en: pip3 install cpppo
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: pip3 install cpppo
- en: 'After verifying that you have the **cpppo** package installed, we are going
    to create a directory called **enip** under your **Documents** folder:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认您已安装**cpppo**包后，我们将在**文档**文件夹下创建一个名为**enip**的目录：
- en: '![Figure 8.16 – enip folder'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – enip 文件夹'
- en: '](image/B16321_08_016.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_016.jpg)'
- en: Figure 8.16 – enip folder
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – enip 文件夹
- en: 'Inside this **enip** folder, we want to create a new file called **cpppo.cfg**
    and place the following configuration inside the file. Notice that the identity
    object attributes are listed as follows with definitions included. You have the
    ability to configure this to your own specifications; however, we will run the
    initial demo with this default configuration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个**enip**文件夹中，我们想要创建一个名为**cpppo.cfg**的新文件，并将以下配置放入文件中。请注意，标识对象属性如下列出，并包含定义。您可以根据自己的规格进行配置；但是，我们将使用此默认配置运行初始演示：
- en: '[Identity]'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[标识]'
- en: Generally, strings are not quoted
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通常，字符串不用引号括起来
- en: Vendor ID                   = 1
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 厂商 ID                   = 1
- en: Device Type                 = 14
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 设备类型                 = 14
- en: Product Code Number         = 51
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 产品代码编号         = 51
- en: Product Revision            = 16
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 产品修订版本            = 16
- en: Status Word                 = 12656
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 状态字                 = 12656
- en: Serial Number               = 1360281
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号               = 1360281
- en: Product Name                = 1756-L55/A 1756-M12/A LOGIX5555
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 产品名称                = 1756-L55/A 1756-M12/A LOGIX5555
- en: State                       = 255
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 状态                       = 255
- en: '[TCPIP]'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[TCPIP]'
- en: 'However, some complex structures require JSON configuration:'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然而，一些复杂的结构需要 JSON 配置：
- en: Interface Configuration     = {
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接口配置     = {
- en: '"ip_address":             "192.168.1.30",'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"ip_address":             "192.168.1.30",'
- en: '"network_mask":           "255.255.255.0",'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '"network_mask":           "255.255.255.0",'
- en: '"dns_primary":            "8.8.8.8",'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '"dns_primary":            "8.8.8.8",'
- en: '"dns_secondary":          "8.8.4.4",'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '"dns_secondary":          "8.8.4.4",'
- en: '"domain_name":            "industrial.pentest.lab"'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"domain_name":            "industrial.pentest.lab"'
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Host Name                   = controller
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名                   = 控制器
- en: 'Once you have the file configured and saved, run the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并保存文件后，运行以下命令：
- en: python3 -m cpppo.server.enip -v -a 0.0.0.0
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip -v -a 0.0.0.0
- en: 'If everything works without any errors, you should see the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常且没有任何错误，您应该看到以下输出：
- en: '![Figure 8.17 – cpppo server running'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – cpppo 服务器运行中'
- en: '](image/B16321_08_017.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_017.jpg)'
- en: Figure 8.17 – cpppo server running
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – cpppo 服务器运行中
- en: 'Now we have a running Ethernet/IP server on PLC. Open a session on the SCADA
    VM and run the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 PLC 上运行了一个以太网/IP 服务器。在 SCADA VM 上打开一个会话，并运行以下命令：
- en: python3 -m cpppo.server.enip.poll -v TCPIP Identity -a 192.168.1.10
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.poll -v TCPIP Identity -a 192.168.1.10
- en: 'Once again, if everything is installed and communicating correctly, you should
    get the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果一切都安装并正确通信，您应该得到以下输出：
- en: '![Figure 8.18 – cpppo response'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – cpppo 响应'
- en: '](image/B16321_08_018.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_018.jpg)'
- en: Figure 8.18 – cpppo response
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – cpppo 响应
- en: 'Now open up either Kali or the Windows VM and run Wireshark. We want to listen
    in on the communication, as we did in the Modbus section. Once you have Wireshark
    open, make sure that SCADA VM is still polling the PLC VM and you should see the
    following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Kali 或 Windows VM 并运行 Wireshark。我们想监听通信，就像在 Modbus 部分所做的那样。一旦打开 Wireshark，请确保
    SCADA VM 仍在轮询 PLC VM，您应该看到以下输出：
- en: '![Figure 8.19 – Identity object'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.19 – 标识对象'
- en: '](image/B16321_08_019.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_019.jpg)'
- en: Figure 8.19 – Identity object
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 标识对象
- en: 'Expand the packet **Success: Identity – Get Attributes All**, seen in the following
    screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 展开数据包**成功：标识 – 获取所有属性**，如下截图所示：
- en: '![Figure 8.20 – Success: Identity – Get Attributes All'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.20 – 成功：标识 – 获取所有属性'
- en: '](image/B16321_08_020.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_020.jpg)'
- en: 'Figure 8.20 – Success: Identity – Get Attributes All'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 成功：标识 – 获取所有属性
- en: 'You will see under the CIP layer that we have **Service: Get Attributes All
    (Response)**. Expanding this, you will see the details that we configured in the
    **cpppo.cfg** file under the **Documents/enip/** folder on the PLC VM. Examine
    the following screenshot and compare it to your configuration file. Try changing
    some of the parameters and restart the Ethernet/IP server:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到在CIP层下有**服务：获取所有属性（响应）**。展开此项，你将看到在PLC虚拟机的**Documents/enip/**文件夹下我们在**cpppo.cfg**文件中配置的详细信息。请查看以下截图并将其与配置文件进行对比。尝试更改一些参数并重启Ethernet/IP服务器：
- en: '![Figure 8.21 – Identity details'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 身份详细信息'
- en: '](image/B16321_08_021.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_021.jpg)'
- en: Figure 8.21 – Identity details
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 身份详细信息
- en: As you can see, inside this object, all the useful information for identifying
    the controller exists. This is why IDS vendors typically tackle this protocol
    first as it is an easy win to identify assets on the network. For us, using **Wireshark**
    or **tcpdump** as discussed in [*Chapter 5*](B16321_05_Epub_AM.xhtml#_idTextAnchor049),
    *Span Me If You Can*, allows us to identify potential targets and detect whether
    those devices contain any known vulnerabilities, allowing us to pivot deeper into
    the environment. Next, we are going to turn on the Ethernet/IP adapter on our
    Koyo CLICK in our lab. We will then use our **cpppo** tool to interrogate our
    PLC.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在此对象中，所有用于识别控制器的有用信息都在这里。这就是为什么IDS供应商通常会首先处理这个协议，因为它是一个简单的办法来识别网络中的资产。对我们来说，使用**Wireshark**或**tcpdump**（如在[*第5章*](B16321_05_Epub_AM.xhtml#_idTextAnchor049)《*你能捕捉我吗*》中讨论的）可以帮助我们识别潜在目标，并检测这些设备是否包含已知漏洞，从而使我们能够深入探查环境。接下来，我们将打开实验室中Koyo
    CLICK的Ethernet/IP适配器，然后使用**cpppo**工具来审问我们的PLC。
- en: 'Take the following quick steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下快速步骤：
- en: Open the CLICK programming software.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开CLICK编程软件。
- en: Click the **Connect to PLC** button.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接到PLC**按钮。
- en: Select the PLC with IP address **192.168.1.20** and click **Connect**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择IP地址为**192.168.1.20**的PLC并点击**连接**。
- en: Select **Read the project** from the PLC options and click the **OK** button.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PLC选项中选择**读取项目**并点击**确定**按钮。
- en: These steps are a simple recap from previous chapters in order to get us to
    the starting point for Ethernet/IP setup.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤是前面章节的简要回顾，目的是让我们准备好进行Ethernet/IP设置的起始工作。
- en: 'Now we should be looking at our ladder logic program that controls our four
    lights. From here, we want to click the **Setup** menu option as shown in the
    following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该查看控制四个灯的梯形图程序。从这里，我们希望点击**设置**菜单选项，如下截图所示：
- en: '![Figure 8.22 – Koyo CLICK Setup'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – Koyo CLICK设置'
- en: '](image/B16321_08_022.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_022.jpg)'
- en: Figure 8.22 – Koyo CLICK Setup
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – Koyo CLICK设置
- en: 'Select the **EtherNet/IP Setup…** menu option and this will bring up the following
    window:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**EtherNet/IP设置…**菜单选项，这将弹出以下窗口：
- en: '![Figure 8.23 – EtherNet/IP Adapter setup'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – EtherNet/IP适配器设置'
- en: '](image/B16321_08_023.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_023.jpg)'
- en: Figure 8.23 – EtherNet/IP Adapter setup
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – EtherNet/IP适配器设置
- en: 'Select the **Enable EtherNet/IP Adapter** checkbox in the window. This will
    enable the selection and editing of options in the window. You will notice in
    the right-hand corner that you have the ability to change the number of connections,
    the port number, and the timeout. Keeping those options as the defaults, we''ll
    focus on the **Input(to Scanner)** data blocks shown in the following screenshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中选择**启用EtherNet/IP适配器**复选框。这将启用窗口中选项的选择和编辑。你会注意到在右上角，你可以更改连接数、端口号和超时时间。保持默认选项不变，我们将重点关注以下截图中显示的**输入（到扫描仪）**数据块：
- en: '![Figure 8.24 – Input data blocks'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 – 输入数据块'
- en: '](image/B16321_08_024.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_024.jpg)'
- en: Figure 8.24 – Input data blocks
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 输入数据块
- en: 'Input blocks are what can be read by the Ethernet/IP master. We want to select
    block 1 under the **Start** column and you will see that it allows you to click
    a button that brings up the **Address Picker** window. Select the **XD** button
    on the left-hand side to filter out the addresses that we will not use. You should
    see the following screen:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据块是Ethernet/IP主站可以读取的数据块。我们希望选择**开始**列下的块1，你会看到它允许你点击一个按钮来打开**地址选择器**窗口。选择左侧的**XD**按钮来筛选我们不会使用的地址。你应该看到以下屏幕：
- en: '![Figure 8.25 – XD address selection'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – XD地址选择'
- en: '](image/B16321_08_025.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_025.jpg)'
- en: Figure 8.25 – XD address selection
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – XD地址选择
- en: 'Select **XD0** for the start of block 1 and do the same for the end address
    of block 1 but select **XD8**. Your addressing should look like the following
    screen:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**XD0**作为块 1 的起始地址，并对块 1 的结束地址进行相同设置，选择**XD8**。你的地址设置应如下所示：
- en: '![Figure 8.26 – Input XD block 1 address set'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.26 – 输入 XD 块 1 地址设置'
- en: '](image/B16321_08_026.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_026.jpg)'
- en: Figure 8.26 – Input XD block 1 address set
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – 输入 XD 块 1 地址设置
- en: 'Next, we want to set the same for our **Out (from Scanner)** block addressing,
    but instead of using **XD** addresses for **Start** and **End**, we will use **YD**
    addresses. Your addressing, once finished, should look like the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为**Out (来自扫描仪)**块的寻址设置相同的内容，但我们将使用**YD**地址，而不是使用**XD**地址来设置**Start**和**End**。设置完成后，你的地址应该如下所示：
- en: '![Figure 8.27 – Output YD block 1 address set'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.27 – 输出 YD 块 1 地址设置'
- en: '](image/B16321_08_027.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_027.jpg)'
- en: Figure 8.27 – Output YD block 1 address set
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 输出 YD 块 1 地址设置
- en: 'Once set, you want to write your project to your Koyo CLICK PLC. Once your
    project has been written to the PLC, hop back over to the terminal window on the
    SCADA VM where we were running the **cpppo** package commands. Now we want to
    run the following command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，你需要将你的项目写入Koyo CLICK PLC。当你的项目被写入PLC后，返回到我们之前运行**cpppo**包命令的SCADA虚拟机的终端窗口。现在我们要运行以下命令：
- en: python3 -m cpppo.server.enip.list_services -vv -a 192.168.1.20 –list-identity
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.list_services -vv -a 192.168.1.20 –list-identity
- en: 'If everything is connected and working, you should get a long output of information
    similar to the following snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切连接正常，你应该会得到类似下面这段长输出的信息：
- en: '![Figure 8.28 – Koyo CLICK Ethernet/IP identity'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.28 – Koyo CLICK Ethernet/IP 身份'
- en: '](image/B16321_08_028.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_028.jpg)'
- en: Figure 8.28 – Koyo CLICK Ethernet/IP identity
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 – Koyo CLICK Ethernet/IP 身份
- en: 'As you can see, we were able to discover the identity of the Koyo CLICK PLC
    by running that simple command. We are going to open Wireshark and analyze the
    communication again as we rerun the commands. You should get the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过运行那个简单的命令，我们能够发现Koyo CLICK PLC的身份。接下来，我们将打开Wireshark并再次分析通信，重新运行命令时，你应该会得到以下输出：
- en: '![Figure 8.29 – Koyo CLICK ENIP Wireshark capture'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.29 – Koyo CLICK ENIP Wireshark 捕获'
- en: '](image/B16321_08_029.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_029.jpg)'
- en: Figure 8.29 – Koyo CLICK ENIP Wireshark capture
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 – Koyo CLICK ENIP Wireshark 捕获
- en: Now you may have remembered that the communication routes out of the ESXi server
    and to the physical PLC interface, so you will have to use the SPAN port that
    we set up in [*Chapter 5*](B16321_05_Epub_AM.xhtml#_idTextAnchor049), *Span Me
    If You Can*, to capture the above communication. This is all neat stuff, but you
    are probably asking *where is the main course?* Listening to traffic and interrogating
    PLCs for their identity is interesting but what about actually changing values,
    turning lights on and off, opening and closing valves, and all that fun stuff?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，通信是从ESXi服务器通过物理PLC接口路由出去的，所以你需要使用我们在[*第5章*](B16321_05_Epub_AM.xhtml#_idTextAnchor049)中设置的SPAN端口，*Span
    Me If You Can*，来捕获上述通信。这一切都很有趣，但你可能会问，*主菜在哪儿？* 听听流量，查询PLC的身份倒是有意思，但实际的操作呢？比如改变值、开关灯、开关阀门，所有这些有趣的操作呢？
- en: 'Well, buckle up. We are going to navigate back to the PLC VM and make a command-line
    change to test our **Get**/**Set** attribute requests. Before we start up our
    virtual Ethernet/IP PLC, we need to quickly discuss how we are going to interact
    and send messages to our PLC. We will be using unconnected explicit messaging.
    The reasoning being that we do not need to set up a previous connection, nor do
    we need to reserve resources to maintain the communication. Unconnected explicit
    messaging allows us to send ad hoc communication and have the PLC digest and process
    the commands. Explicit messaging uses a format called **Lpacket** and inside of
    **Lpacket**, there reside service fields and these service fields are as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，系好安全带。我们将返回到PLC虚拟机，并通过命令行进行更改来测试我们的**Get**/**Set**属性请求。在启动虚拟的Ethernet/IP
    PLC之前，我们需要简要讨论一下如何与PLC进行交互并发送消息。我们将使用无连接显式消息传递。之所以这么做，是因为我们不需要事先建立连接，也不需要为维护通信而预留资源。无连接显式消息传递允许我们发送临时通信，让PLC接收并处理命令。显式消息传递使用一种名为**Lpacket**的格式，而在**Lpacket**中，包含了服务字段，以下是这些服务字段：
- en: '**Class**: Up to now, we have only really talked about class **0x01**, the
    identity class, but I did mention that there are application-specific object IDs,
    which ultimately are class IDs. There are a series of publicly defined class IDs
    but because of the openness of the protocol, users can take advantage of the custom
    range that falls between 100 and 199\.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：到目前为止，我们只讨论了类别**0x01**，即身份类别，但我提到过有些应用特定的对象 ID，最终它们是类别 ID。虽然有一系列公开定义的类别
    ID，但由于协议的开放性，用户可以利用位于 100 到 199 之间的自定义范围。'
- en: '**Instance**: This helps distinguish unique messages if you have the same class
    with multiple instances.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例**：如果你有相同类别的多个实例，这有助于区分不同的消息。'
- en: '**Attribute**: Similar to instance IDs, the attribute ID allows you to distinguish
    multiple attributes for a given instance.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：类似于实例 ID，属性 ID 使您能够区分给定实例的多个属性。'
- en: 'There is a lot of information that can be conveyed using the object model,
    and I strongly encourage you to do your own research on this protocol by reading
    the published standards. For our needs, we simply need to understand this syntax:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象模型可以传递大量信息，我强烈建议你通过阅读已发布的标准，自己做一些关于该协议的研究。对于我们的需求，我们只需要理解这个语法：
- en: class/instance/attribute
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 类/实例/属性
- en: 'This is what defines a tag in the system. Now back to the hands-on example.
    Run the following command in your PLC VM terminal:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了系统中的标签。现在回到实际操作示例。在你的 PLC 虚拟机终端中运行以下命令：
- en: python3 -m cpppo.server.enip -v -a 0.0.0.0 'Compressor_StationA@8/1/1'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip -v -a 0.0.0.0 'Compressor_StationA@8/1/1'
- en: 'With this command, we are telling the system to build a tag named **Compressor_StationA**
    with the object containing a class ID of **0x08**, which is a publicly defined
    class ID for a discrete input point, and then we are giving it an instance ID
    of 1 with an attribute ID of 1\. If everything worked correctly, you should have
    something similar to the following output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们告诉系统构建一个名为**Compressor_StationA**的标签，其中包含类别 ID **0x08**，这是一个公开定义的类别
    ID，用于离散输入点，然后我们给它分配一个实例 ID 为 1，属性 ID 为 1。如果一切正常，您应该会看到类似以下的输出：
- en: '![Figure 8.30 – Compressor_StationA tag'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.30 – Compressor_StationA 标签'
- en: '](image/B16321_08_030.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_030.jpg)'
- en: Figure 8.30 – Compressor_StationA tag
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.30 – Compressor_StationA 标签
- en: 'Now move back to your SCADA VM and type the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到你的 SCADA 虚拟机，并输入以下命令：
- en: python3 -m cpppo.server.enip.get_attribute '@8/1/1' -S -a 192.168.1.10
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.get_attribute '@8/1/1' -S -a 192.168.1.10
- en: 'Running this command requests the attribute located at **8/1/1** using **-S**
    (simple mode) from **-a** (address) **192.168.1.10**. Having run this command,
    you should get the following response:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会请求位于**8/1/1**的属性，使用**-S**（简单模式）从**-a**（地址）**192.168.1.10**。执行此命令后，您应该会收到如下响应：
- en: '![Figure 8.31 – Single attribute value'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.31 – 单一属性值'
- en: '](image/B16321_08_031.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_031.jpg)'
- en: Figure 8.31 – Single attribute value
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.31 – 单一属性值
- en: 'This response tells us that there is a **0** value in that attribute. This
    was an example of simply reading the attribute. Now we want to write to this *tag*.
    Run this command to set the attribute value to **1**:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应告诉我们该属性中有一个**0**的值。这是一个简单读取属性的例子。现在我们想向这个*标签*写入数据。运行此命令将属性值设置为**1**：
- en: python3 -m cpppo.server.enip.get_attribute '@8/1/1=(INT)1' '@8/1/1' -S -a 192.168.1.10
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.get_attribute '@8/1/1=(INT)1' '@8/1/1' -S -a 192.168.1.10
- en: 'If you compare the two commands, all we did was add a new argument that tells
    the system to make the object **@8/1/1=(INT)1** equal an integer of 1\. You should
    see two outputs now, as shown:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较这两个命令，我们所做的只是添加了一个新参数，告诉系统将对象**@8/1/1=(INT)1**设置为整数 1。现在你应该会看到两个输出，如下所示：
- en: '![Figure 8.32 – Setting attribute'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.32 – 设置属性'
- en: '](image/B16321_08_032.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_032.jpg)'
- en: Figure 8.32 – Setting attribute
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.32 – 设置属性
- en: 'You can see the command responses **S_A_S** and **G_A_S**, which stand for
    the **setting** attribute and **getting** attribute. The first command indicates
    setting the attribute equal to **True** and **getting** returns the value as being
    **1**. Finally, remembering the tag name that we gave the object was **Compressor_StationA**,
    we can use the tag name to get and set the value as it has been aliased in the
    system. Run the following command as an example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到命令响应**S_A_S**和**G_A_S**，分别代表**设置**属性和**获取**属性。第一个命令表示将属性设置为**True**，而**获取**命令则返回值为**1**。最后，记住我们给对象命名的标签是**Compressor_StationA**，我们可以使用该标签名来获取和设置值，因为它已经在系统中被别名化。以下命令作为示例：
- en: python3 -m cpppo.server.enip.client –print Compressor_StationA Compressor_StationA=1
    Compressor_StationA -a 192.168.1.10
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.client –print Compressor_StationA Compressor_StationA=1
    Compressor_StationA -a 192.168.1.10
- en: 'You should get the following output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到以下输出：
- en: '![Figure 8.33 – Tag alias Get/Set attribute'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.33 – 标签别名 获取/设置属性'
- en: '](image/B16321_08_033.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_033.jpg)'
- en: Figure 8.33 – Tag alias Get/Set attribute
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 – 标签别名 获取/设置属性
- en: With the command, we requested a **Get** of the attribute and then the **Set**
    command to set the value to **1**, and finally, the **Get** command again to check
    whether the value did update inside the virtual PLC. You can see how easy it is
    to simply toggle values ON and OFF inside a remote controller. All you need to
    know is the specific object mapping class/instance/attribute.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们请求**获取**属性，然后使用**设置**命令将值设置为**1**，最后再次使用**获取**命令检查值是否已经在虚拟 PLC 中更新。你可以看到，只需轻松地切换开关值，就能在远程控制器中操作。你所需要知道的只是特定对象的映射类/实例/属性。
- en: 'Now we can test the same command methods against the Koyo CLICK PLC in our
    lab. Open up the CLICK programming software, navigate to the **Setup** menu, and
    select **EtherNet/IP Setup…** and you will be presented with the configuration
    screen we saw before in the configuration steps we did earlier. We want to focus
    specifically on two sections, the first being under the **Input(to Scanner)**
    tab as shown:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在实验室中针对 Koyo CLICK PLC 测试相同的命令方法。打开 CLICK 编程软件，导航到**设置**菜单，选择**EtherNet/IP
    设置...**，你将看到我们之前在配置步骤中看到的配置屏幕。我们要特别关注两个部分，第一个是在**输入（到扫描仪）**标签页下，如下所示：
- en: '![Figure 8.34 – Input Class/Instance/Attribute'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.34 – 输入 类/实例/属性'
- en: '](image/B16321_08_034.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_034.jpg)'
- en: Figure 8.34 – Input Class/Instance/Attribute
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34 – 输入 类/实例/属性
- en: Notice the (**Explicit**) labeled items of **Class**/**Instance**/**Attribute**.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意标有(**Explicit**)标签的**类**/**实例**/**属性**项目。
- en: '**Class**: **4**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：**4**'
- en: '**Instance**: **101**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例**：**101**'
- en: '**Attribute**: **3**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：**3**'
- en: 'Now navigate to the **Output(from Scanner)** tab, and you should see the following
    screen:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到**输出（来自扫描仪）**标签页，你应该能看到以下屏幕：
- en: '![Figure 8.35 – Output Class/Instance/Attribute'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.35 – 输出 类/实例/属性'
- en: '](image/B16321_08_035.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_035.jpg)'
- en: Figure 8.35 – Output Class/Instance/Attribute
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.35 – 输出 类/实例/属性
- en: 'The **Class**/**Instance**/**Attribute** is nearly the same and if you remember
    the description of what an instance ID is used for, then you know why it is different
    by 1:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**/**实例**/**属性**几乎是相同的，如果你记得实例 ID 的作用描述，那么你就知道它为何相差 1：'
- en: '**Class**: **4**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：**4**'
- en: '**Instance**: **102**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例**：**102**'
- en: '**Attribute**: **3**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：**3**'
- en: 'We now have enough information to interact with our program running on our
    PLC. As a way to monitor how commands are interacting with the PLC, we want to
    add a little configuration to the **Data View** screen in our Koyo CLICK programming
    software. See the following screenshot, and we will quickly step through the actions
    that should be taken to set this up for monitoring:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的信息来与在 PLC 上运行的程序进行交互。作为监控命令与 PLC 交互的一种方式，我们想在 Koyo CLICK 编程软件中的**数据视图**屏幕上添加一些配置。请参见以下截图，我们将快速通过需要采取的步骤来为监控设置该配置：
- en: '![Figure 8.36 – Data View'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.36 – 数据视图'
- en: '](image/B16321_08_036.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_036.jpg)'
- en: Figure 8.36 – Data View
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36 – 数据视图
- en: As a recap, you select the **Monitor** menu item and select the **Data View**
    option.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回顾，你选择**监控**菜单项并选择**数据视图**选项。
- en: Here, you can see that we have added some more registers to **Data View** and
    turned on the **Override** function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们向**数据视图**添加了一些更多的寄存器，并启用了**覆盖**功能。
- en: 'Here are the quick steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是快速步骤：
- en: Select the **address cell**.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**地址单元格**。
- en: Click **address picker**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**地址选择器**。
- en: Select the address that you want to view and click **OK**.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你要查看的地址并点击**确定**。
- en: Continue this process until your **Data View** looks like mine.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续这个过程，直到你的**数据视图**看起来和我的一样。
- en: 'Once you have the registers displayed in your **Data View** and it matches
    the preceding screenshot, go to your SCADA VM terminal and type in the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的寄存器在**数据视图**中显示，并且与之前的截图相匹配，进入你的 SCADA 虚拟机终端并输入以下命令：
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
- en: 'This command, as we saw before, uses the simple mode to get the attributes
    located in these objects. If all your inputs and outputs are off, you should get
    the following response:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令，如我们之前所看到的，使用简单模式来获取这些对象中的属性。如果所有输入和输出都关闭，你应该得到以下响应：
- en: '![Figure 8.37 – Get attributes from Koyo CLICK'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.37 – 从 Koyo CLICK 获取属性'
- en: '](image/B16321_08_037.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_037.jpg)'
- en: Figure 8.37 – Get attributes from Koyo CLICK
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.37 – 从 Koyo CLICK 获取属性
- en: Note
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I should point out that in the documentation, as we were going through setting
    up Ethernet/IP, on the Koyo CLICK PLC, **XD** registers were read only, and **YD**
    registers were read/write, and this has to do with control philosophy and is beyond
    the scope of this book. All you really need to know is that if you want to interact
    with the lights directly, you bypass the input I/O on the PLC with Ethernet/IP
    and energize the coils directly with the **YD** registers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要指出的是，在文档中，正如我们在设置 Ethernet/IP 时所讲的，在 Koyo CLICK PLC 上，**XD**寄存器是只读的，而**YD**寄存器是读/写的，这与控制哲学有关，超出了本书的范围。你真正需要知道的是，如果你想直接与灯互动，你可以通过
    Ethernet/IP 绕过 PLC 的输入/输出，并直接使用**YD**寄存器来激活线圈。
- en: 'Now the next task would be to manually force **X001** and **X002** on from
    the **Data View** screen. You will notice a little binary math going on, which
    should bring you back to your early computer science days. **0001 + 0010 == 0011
    == 0x03**, as you can see in the following screenshot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，任务是手动从**数据视图**屏幕上强制开启**X001**和**X002**。你会注意到一些二进制运算，这应该能让你回忆起早期的计算机科学日子。**0001
    + 0010 == 0011 == 0x03**，如下图所示：
- en: '![Figure 8.38 – X001 and X002 forced on'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.38 – 强制开启 X001 和 X002'
- en: '](image/B16321_08_038.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_038.jpg)'
- en: Figure 8.38 – X001 and X002 forced on
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.38 – 强制开启 X001 和 X002
- en: 'The result is **XD0** ending up with a **Hex** value of **0003h**, as shown:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是**XD0**的十六进制值为**0003h**，如所示：
- en: '![Figure 8.39 – XD0 equals 3'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.39 – XD0 等于 3'
- en: '](image/B16321_08_039.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_039.jpg)'
- en: Figure 8.39 – XD0 equals 3
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.39 – XD0 等于 3
- en: 'Now double-check to make sure that your **Data View** screen looks like the
    following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次检查，确保你的**数据视图**屏幕看起来如下：
- en: '![Figure 8.40 – Data View X001 and X002 forced on'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.40 – 强制开启数据视图中的 X001 和 X002'
- en: '](image/B16321_08_040.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_040.jpg)'
- en: Figure 8.40 – Data View X001 and X002 forced on
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.40 – 强制开启数据视图中的 X001 和 X002
- en: 'We want to rerun the **Get** attribute command to make sure that we are seeing
    the correct attributes. As a quick refresher, here is the command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望重新运行**Get**属性命令，以确保看到正确的属性。作为快速回顾，以下是命令：
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
- en: 'If everything is configured correctly, you should get the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切配置正确，你应该看到以下输出：
- en: '![Figure 8.41 – Input hex value 3'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.41 – 输入十六进制值 3'
- en: '](image/B16321_08_041.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_041.jpg)'
- en: Figure 8.41 – Input hex value 3
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 – 输入十六进制值 3
- en: 'Now we know that we are definitely hitting the correct address, let''s start
    to turn lights ON and OFF. If you remember back to your virtual PLC, we simply
    added the value type and the actual value to the **read** command. In this case,
    we would want to duplicate the **@4/102/3** object and add the type of (**INT**)
    and the hex equivalent to the light combination that we want to turn on. Jumping
    into the deep end, run the following command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们确实访问了正确的地址，接下来我们开始开关灯。如果你还记得虚拟 PLC 的操作，我们只是将值类型和实际值添加到**read**命令中。在这种情况下，我们希望复制**@4/102/3**对象，并添加类型（**INT**）和我们想要开启的灯组合的十六进制等效值。直接跳入深水区，运行以下命令：
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3=(INT)15 '@4/102/3'
    -S -a 192.168.1.20
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3=(INT)15 '@4/102/3'
    -S -a 192.168.1.20
- en: 'You should see the following results:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Figure 8.42 – All lights are ON'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.42 – 所有灯都亮着'
- en: '](image/B16321_08_042.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_042.jpg)'
- en: Figure 8.42 – All lights are ON
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.42 – 所有灯都亮着
- en: 'Double-check the **Data View** screen and you should see that all the outputs
    have been set to ON, as shown in the following screenshot:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次检查**数据视图**屏幕，你应该会看到所有输出都已设置为开启，如下图所示：
- en: '![Figure 8.43 – Y001-Y004 all On'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.43 – Y001-Y004 全部开启'
- en: '](image/B16321_08_043.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_043.jpg)'
- en: Figure 8.43 – Y001-Y004 all On
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.43 – Y001-Y004 全部开启
- en: 'Finally, let''s capture the **Set** attribute packet by sniffing the SPAN interface
    with Wireshark. Under the **Info** column on Wireshark, you should see the following
    details relating to the three commands sent:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过使用Wireshark嗅探SPAN接口来捕获**Set**属性数据包。在Wireshark的**信息**栏下，你应该能看到以下与发送的三条命令相关的详细信息：
- en: '![Figure 8.44 – Wireshark detection'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.44 – Wireshark 检测'
- en: '](image/B16321_08_044.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_044.jpg)'
- en: Figure 8.44 – Wireshark detection
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.44 – Wireshark 检测
- en: You can see that we detect the first command, the **Get** attribute **@4/101/3**,
    then we see the **Set** attribute of **@4/102/3=(INT)15**, and lastly, the third
    command where we are getting the results of our **Set** command.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们检测到了第一条命令，即**获取**属性**@4/101/3**，然后是**设置**属性**@4/102/3=(INT)15**，最后是第三条命令，我们正在获取**设置**命令的结果。
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you did any research to find more application class IDs as discussed previously,
    you will have found that the **0x04** class ID is a publicly recognized standard
    for assembly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了研究并找到了更多应用类ID，如前面所讨论的，你应该会发现**0x04**类ID是公认的组装标准。
- en: 'If you expand the **Assembly – Set Attribute Single** packet and look under
    the CIP layer of the protocol, you will find a data value of **0F00**, which is
    hex for **15**, as shown:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开**Assembly – Set Attribute Single**数据包并查看协议的CIP层，你会发现一个数据值**0F00**，这是**15**的十六进制表示，如下所示：
- en: '![Figure 8.45 – Data: 0f00 CIP details'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.45 – 数据：0f00 CIP 详情'
- en: '](image/B16321_08_045.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B16321_08_045.jpg)'
- en: 'Figure 8.45 – Data: 0f00 CIP details'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.45 – 数据：0f00 CIP 详情
- en: There we have it. We were able to turn the lights ON and OFF by simply sending
    unconnected explicit messages to the PLC. At first glance, the protocol structure
    looks complex and tedious as compared to Modbus, but after a bit of research and
    trial and error, we discover that the class/instance/attribute structure of the
    address makes it rather simple to send and receive commands with. This is important.
    As we stated in the introduction, 30%+ of global industrial equipment utilizes
    this protocol to operate processes. Whether it be operating conveyer belts at
    an Amazon fulfillment center or starting and stopping a mainline compressor station
    for Colonial Pipeline, you will certainly find this protocol during your adventures
    in your industrial pentesting career.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们通过简单地向PLC发送未连接的显式消息，成功实现了控制灯光的开关。乍一看，协议结构似乎比Modbus复杂且繁琐，但经过一番研究和反复试验后，我们发现地址的类/实例/属性结构使得发送和接收指令变得相当简单。这一点非常重要。正如我们在引言中所述，全球超过30%的工业设备都使用此协议来操作流程。无论是在亚马逊配送中心操作输送带，还是在殖民管道公司启动或停止主干压缩机站，你肯定会在你的工业渗透测试职业生涯中遇到这种协议。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I understand if you have hit a wall, that was a lot of information to go through
    and digest. However, I hope that you can see how valuable it is to understand
    the capabilities and extensibility of the protocols that we encountered in this
    chapter. The biggest takeaway you should have noticed is that we didn't have to
    do anything regarding security to simply send ModbusTCP and Ethernet/IP commands
    to our virtual controller and hardware controller.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我理解如果你感到有些迷茫，因为这些信息比较复杂且难以消化。然而，我希望你能明白，理解我们在本章中遇到的协议的功能和可扩展性是多么重要。你应该注意到的最大收获是，我们不需要做任何关于安全的事情，就能轻松地向我们的虚拟控制器和硬件控制器发送ModbusTCP和Ethernet/IP命令。
- en: Comprehending what the I/O does from a protocol level will add the validity
    you need when turning in a final discovery report to your customer. Many times
    in my career, I have seen a report that simply documents assets discovered on
    a network utilizing an *insecure* protocol. When pressed for details of what impact
    an asset using an *insecure* protocol could have on the organization, the response
    typically has little to no substance. Having exposure at the packet level allows
    you to supply richer assessment findings than simply saying *insecure* protocol.
    Here is a quick example from our findings.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从协议层面理解输入输出操作的功能，将为你在提交最终发现报告时提供必要的有效性。在我的职业生涯中，我多次见过这样的报告：仅仅列出了通过*不安全*协议在网络上发现的资产。当被问及使用*不安全*协议的资产对组织可能产生的影响时，回应通常毫无实质内容。通过数据包层面的接触，你能够提供比单纯说*不安全*协议更丰富的评估发现。以下是我们发现的一个快速示例。
- en: We discovered through the Ethernet/IP's identity get-all attributes request
    that a Koyo Click C0-10ARE-D is running in the network and is vulnerable to unconnected
    explicit messaging at address **0x04/102/3**. This address, when manipulated,
    will allow us to turn OFF and ON the lights in the lab.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以太网/IP的身份获取所有属性请求发现，网络中运行着一台Koyo Click C0-10ARE-D，并且在地址**0x04/102/3**处存在未连接的显式消息传输漏洞。这个地址一旦被操控，我们就能打开和关闭实验室的灯光。
- en: Going forward, you should have a better understanding of what to look for in
    the network when you come across various industrial protocols, and specifically
    ModbusTCP and Ethernet/IP.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，你应该能更好地理解在网络中遇到各种工业协议时，尤其是ModbusTCP和以太网/IP时，应该寻找什么。
- en: In the next chapter, we are going to dive deeper and touch on using Burp Suite
    to pentest a web-based SCADA interface.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨并介绍如何使用Burp Suite对基于Web的SCADA界面进行渗透测试。
