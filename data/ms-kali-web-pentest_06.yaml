- en: Chapter 7. Injection and Overflow Testing
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。注入和溢出测试
- en: All websites in this day and age provide dynamic responses to users that are
    informed by some external database or inferred from a process external to the
    HTMLÂ itself. On the clients, this is typically cordoned off and restricted to
    the **Domain Object Model** (**DOM**) space of the browser, but on the servers
    the variety and scope of these intertwined processes become exceedingly hard to
    manage. With all of a typical enterprise's defences tuned to permit application-bound
    traffic into the web tier, and the web tier, in turn, trusted to access the application
    and database tiers, hackers have learned to web tier into their stooge. The web
    tier unwittingly becomes an insider threat, and with it comes all privileged access
    and trust relationships.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个时代，所有网站都会对用户提供动态响应，这些响应受到一些外部数据库的影响或从HTML本身外部的过程推断出来。在客户端，这通常被隔离并限制在浏览器的DOM空间中，但在服务器上，这些交织在一起的过程的种类和范围变得异常难以管理。典型企业的所有防御都被调整为允许应用程序绑定流量进入Web层，反过来，Web层被信任访问应用程序和数据库层，黑客已经学会了将Web层变成他们的替身。Web层无意中成为内部威胁，随之而来的是所有特权访问和信任关系。
- en: Injections are a powerful and common form of compromising the client-server
    connection and can be used to both expose unintended information as well as to
    impact the performance of the application itself. Where XSSÂ attacks focus on
    injecting scripts to coax clients into doing the attacker's bidding, other injection
    types focus on going directly after the backend data. When we're testing or attacking
    a web application, compromising a user's host is useful, but a slew of server-side
    injections can entice the web application to do a hacker's bidding directly. These
    **injection attacks** vary in application but exploit weaknesses in the web application's
    ability to validate user input and mask error handling. Attackers are motivated
    by a number of outcomes, but in addition to stealing the data or intellectual
    property behind the application come more destructive outcomes â�� destruction
    or corruption of the data, ruining the application's usability and undermining
    its trusted status amongst the users and company it serves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注入是一种强大且常见的客户端-服务器连接的妥协形式，既可以用来暴露意外信息，也可以影响应用程序本身的性能。XSS攻击侧重于注入脚本以诱使客户端执行攻击者的命令，而其他注入类型则直接针对后端数据。当我们测试或攻击Web应用程序时，妥协用户主机是有用的，但一系列服务器端注入可以诱使Web应用程序直接执行黑客的命令。这些注入攻击在应用中各不相同，但利用了Web应用程序验证用户输入和掩盖错误处理的弱点。攻击者的动机有很多，但除了窃取应用程序背后的数据或知识产权之外，还有更具破坏性的结果——破坏或损坏数据，破坏应用程序的可用性，破坏其在用户和公司中的信任地位。
- en: The most concerning aspect of injections is that they are easy to implement
    and that a ton of websites are vulnerable. A quick look at the **Google Hacking
    DB** (**GHDB**) or **Shodan.io** can readily expose millions of servers that lack
    in protection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注入最令人担忧的一点是它们很容易实施，而且很多网站都容易受到攻击。快速查看Google Hacking DB（GHDB）或Shodan.io可以很容易地暴露出数百万缺乏保护的服务器。
- en: We should certainly include a cursory look at these **Open Source Intelligence**
    (**OSINT**) repositories as black hat hackers certainly are using them. Focused
    scanning using **Burp Suite**, **Zed Access Proxy** (**ZAP**), **Arachni**, and
    other tools can help us uncover a wider array of potential issues in our specific
    targets, as can some smart hands-on with the portals themselves. **Structured
    Query Language** (**SQL**), **eXtensible Markup Language** (**XML**) **Path Language**
    (**XPath**), **Lightweight Directory Access Protocol** (**LDAP**), command/executable,
    and **Hyper Text Transport Protocol** (**HTTP**) injections present the most commonly
    seen threats, but vary in their impact and location.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然应该对这些开源情报（OSINT）库进行粗略查看，因为黑帽骇客肯定在使用它们。使用Burp Suite、Zed Access Proxy（ZAP）、Arachni和其他工具进行重点扫描可以帮助我们发现特定目标中更广泛的潜在问题，以及一些与门户网站本身的智能互动。结构化查询语言（SQL）、可扩展标记语言（XML）路径语言（XPath）、轻量级目录访问协议（LDAP）、命令/可执行文件和超文本传输协议（HTTP）注入是最常见的威胁，但在影响和位置上有所不同。
- en: In this chapter, we'll learn about and implement each of the major categories
    of injection and input manipulation attacks and learn how to use several tools
    to both identify the vulnerabilities and exploit their weakness.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习并实施注入和输入操纵攻击的主要类别，并学习如何使用几种工具来识别漏洞并利用它们的弱点。
- en: 'This chapter will help us:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助我们：
- en: Uncover and test against various forms of injection (blind, classic, compound)
    against various databases including SQL, Oracle, and LDAP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现并针对各种注入形式（盲目、经典、复合）进行测试，包括针对SQL、Oracle和LDAP等各种数据库
- en: Understand the need for performing code injection to result in stack, buffer,
    and heap overflows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解执行代码注入以导致堆栈、缓冲区和堆溢出的需要
- en: Learn to conduct HTTP verb tampering and parameter pollution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会进行HTTP动词篡改和参数污染
- en: Learn how to use select and use the correct tool from a list including recon-ng,
    BBQSQL, SQLMap, SQLninja, and others
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会如何从recon-ng、BBQSQL、SQLMap、SQLninja等工具列表中选择并使用正确的工具
- en: Injecting some fun into your testing
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试中注入一些乐趣
- en: '* * *'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Injection attacks are numerous, but because they all insert code that they
    know will be transported into the application or database tiers for execution,
    they have an impact that earns injections a #1 ranking from the OWASP Top 10\.
    We''ll cover the big ones here, but know that the scanning and testing approaches
    are very similar, in that we''ll leverage automation to both probe each portal
    for signs of weakness and to pass best-practice based strings against any potential
    flaws to test against them. Before we get into the varieties of injection, it
    helps to step back and look at how OWASP characterizes them. The following screenshot
    comes from their latest release candidateÂ of the **OWASP 2017 Top 10**Â **List**
    ([https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf](https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击很多，但因为它们都插入代码，而且知道这些代码将被传输到应用程序或数据库层进行执行，所以它们的影响使得注入在OWASP十大中排名第一。我们将在这里介绍一些主要的攻击方式，但要知道扫描和测试方法非常相似，我们将利用自动化来探测每个门户的弱点迹象，并传递基于最佳实践的字符串来测试潜在的缺陷。在我们深入了解注入的各种类型之前，了解OWASP是如何对它们进行分类的会有所帮助。以下截图来自他们最新的发布候选版的**OWASP
    2017十大**列表([https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf](https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf))：
- en: '![](img/B03918_07_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_01.png)'
- en: OWASP's Injection Attack Characterization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP的注入攻击特征。
- en: 'OWASP''s concerns with these attacks are many, but their ease of use by hackers
    and their potential impact make them a grave concern for application developers.
    Web technologies rely heavily on dynamic content and this puts that reliance in
    the cross-hairs of hackers who understand that that dynamic aspect makes them
    ripe for injection. The following table can help us understand the basic scopes
    of each attack, their relative difficulty, and the typical weak spots in which
    they are found:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP对这些攻击的关注点很多，但黑客的使用便利性和潜在影响使它们成为应用程序开发人员的严重关注点。Web技术在很大程度上依赖于动态内容，这使得黑客将其视为注入的目标。以下表格可以帮助我们了解每种攻击的基本范围、相对难度以及它们通常被发现的弱点：
- en: '| **Injection type** | **Detection difficulty** | **Exploit difficulty** |
    **Potential impact** | **End Goal/Affected Components** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **注入类型** | **检测难度** | **利用难度** | **潜在影响** | **最终目标/受影响组件** |'
- en: '| **SQL injection** | Hard â�� BlindEasy - Classic | Medium | Very serious
    | Database enumerationSQL-backed frameworksOracle applications |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **SQL注入** | 困难 - 盲注易 - 经典 | 中等 | 非常严重 | 数据库枚举SQL支持的框架Oracle应用程序 |'
- en: '| **XML (XPath) injection** | Moderate | Easy | Serious | XML-stored data Enumeration,
    corruption, destruction of data |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **XML（XPath）注入** | 中等 | 简单 | 严重 | XML存储的数据枚举、破坏、销毁 |'
- en: '| **LDAP injection** | Very easy | Easy | Moderate (varies) | Credentials,
    usually for escalation or new account generation |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **LDAP注入** | 非常简单 | 简单 | 中等（各不相同） | 凭证，通常用于升级或生成新账户 |'
- en: '| **Command injection** | Hard | Medium | Very serious | Application tierSlip
    in command to run malicious code for destructive means or lateral movement |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **命令注入** | 困难 | 中等 | 非常严重 | 应用程序层插入命令以运行恶意代码，用于破坏或横向移动 |'
- en: '| **Buffer overflow** | Medium | Medium | Very serious | Application tierRepoint
    instructions to execute malicious code for destructive means or lateral movement
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **缓冲区溢出** | 中等 | 中等 | 非常严重 | 应用程序层重新指向指令以执行恶意代码，用于破坏或横向移动 |'
- en: '| **HTTP injection** | Easy | Very Easy | Low | Web or application tiers Force
    execution of functions inside web server or application |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP注入** | 简单 | 非常简单 | 低 | Web或应用程序层强制在Web服务器或应用程序内执行功能 |'
- en: Is SQL any good?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL有用吗？
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: As injections go, **SQL Injection** (**SQLI**) is the belle of the ball. While
    differences exist between SQL database technologies, most subscribe to a common
    foundation of syntax (defined by the **American National Standards Institute**
    (**ANSI**), vocabulary and organization, which makes learning and adapting to
    a new one straightforward and efficient.Â  Used in relational databases, it is
    the workhorse in modern database operations, responsible for storing, manipulating,
    and querying databases from adjacent applications or interfaces. There are a lot
    of free resources that are worth digging into to better understand SQL, and the
    **World Wide Web Consortium**'s site ([https://www.w3schools.com/sql/](https://www.w3schools.com/sql/))Â 
    is a fantastic start â�� we won't go into any depth on the underlying language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就注入而言，**SQL注入**（SQLI）是最受欢迎的。尽管SQL数据库技术之间存在差异，但大多数都遵循**美国国家标准学会**（**ANSI**）定义的共同基础语法、词汇和组织，这使得学习和适应新技术变得简单高效。它是关系数据库中的工作马，负责从相邻的应用程序或接口存储、操作和查询数据库。有很多免费资源值得深入了解SQL，**万维网联盟**的网站([https://www.w3schools.com/sql/](https://www.w3schools.com/sql/))是一个很好的起点，我们不会深入讨论底层语言。
- en: Statistically speaking, over 98% of web applications are backed by databases
    containing the information users are after. Of these, SQL variants are by far
    the most popular. These same aspects make it very easy for hackers to detect and
    exploit these databases using common libraries of queries and tricks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 统计数据显示，超过98%的Web应用程序都由包含用户所需信息的数据库支持。其中，SQL变体是最受欢迎的。这些相同的特点使得黑客很容易使用常见的查询和技巧来检测和利用这些数据库。
- en: 'Don''t let these statistics and the potential impact fool you though: SQLI
    attacks are rampant and increasing in number each year, despite the attention
    they garner and the fundamental precautions that can be taken to eliminate or
    drastically reduce their potential to an application. As we''ll see here, revealing
    and exploiting SQL injection vulnerabilities is a relatively easy task.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，不要被这些统计数据和潜在影响所迷惑：SQLI攻击每年都在激增，尽管它们受到了关注，而且可以采取基本预防措施来消除或大大减少对应用程序的潜在影响。正如我们将在这里看到的，揭示和利用SQL注入漏洞是一个相对容易的任务。
- en: A crash course in DBs gone bad
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库崩溃课程
- en: Relational databases provide a table-like framework within which data is stored.
    SQL is the syntax by which we read and write to these tables, and websites can
    allow their users to render useful data by building a query and subsequently presenting
    the results. What could ever go wrong?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库提供了一个类似表格的框架，用于存储数据。 SQL是我们读取和写入这些表的语法，网站可以允许他们的用户通过构建查询并随后呈现结果来呈现有用的数据。会出什么问题呢？
- en: Well, many databases are instantiated by system administrators or engineers
    without a background in the particular database technology. Chances are your technophobe
    relatives have even installed a database as the underlying component of an application
    on their own personal computer. And chances are just as high that whoever embedded
    the database in a larger application did so without delving too far into the detailed
    hardening of the database.Â  Simple things such as default administrator accounts,
    ports, and so on aren't always cleaned up prior to being embedded within the parent
    application. These same issues arise with web application databases in organizations
    without database-focused personnel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，许多数据库是由没有特定数据库技术背景的系统管理员或工程师实例化的。很可能你的技术恐惧症亲戚甚至在自己的个人电脑上安装了数据库作为应用程序的基础组件。同样有可能的是，将数据库嵌入到更大的应用程序中的人并没有深入研究数据库的详细硬化。简单的事情，比如默认管理员帐户、端口等在嵌入到父应用程序之前并不总是被清理干净。这些问题在没有专注于数据库的人员的组织中的Web应用程序数据库中也会出现。
- en: Web applications vary in the way they solicit queries from the users and pass
    them along to the database. Many using **PHP Hypertext Preprocessor** (**PHP**)
    for their dynamic content pass the queries along via the **Uniform Request Locator**
    (**URL**) string and thus are very easy to modify for our own purposes while avoiding
    meaningful validation. Other sites strongly enforce and sanitize underlying SQL
    queries by restricting users to building their searches through pre-canned components
    in drop-down lists, radio buttons, and check boxes. These restrictive query building
    approaches are much harder to exploit, and recommended for safe application development
    wherever possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序在征求用户查询和将其传递到数据库的方式上有所不同。许多使用**PHP超文本预处理器**（**PHP**）进行动态内容的网站通过**统一请求定位器**（**URL**）字符串传递查询，因此非常容易修改以符合我们自己的目的，同时避免有意义的验证。其他网站通过限制用户通过预先制作的下拉列表、单选按钮和复选框构建搜索来强制执行和清理底层SQL查询。这些限制性的查询构建方法更难以利用，并且在可能的情况下建议用于安全的应用程序开发。
- en: A high-level view of how that happens is shown in the following screenshot.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了这种情况发生的高层视图。
- en: '![](img/B03918_07_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_02.png)'
- en: The anatomy of a SQL injection attack
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击的解剖
- en: Types of SQLI
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLI的类型
- en: 'Given how diverse SQL is and how many ways there are to implement it, it stands
    to reason there will be some different ways to implement SQLI. Like XSS, there
    are a couple of ways we can look at this, but SQLI can vary greatly, and thus
    can be characterized in different ways.Â  Rather than looking at their persistence
    and location, as in XSS, we can differentiate SQLI by looking at a few *tells*
    or characteristics:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到SQL的多样性和实现它的方式有很多种，很有道理会有一些不同的实现SQLI的方式。与XSS一样，我们可以从几个方面来看待这个问题，但SQLI可能会有很大的变化，因此可以用不同的方式来描述。与XSS不同，我们可以通过观察一些*提示*或特征来区分SQLI：
- en: The way in which the SQLI is delivered (via forms, drop-downs, cookie manipulation,
    URL mods, and so on)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLI的交付方式（通过表单、下拉列表、cookie操作、URL修改等）
- en: The type of input we submit in the first place (strings versus values)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先提交的输入类型（字符串与值）
- en: How we receive the data back (also called the data extraction channel)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何接收数据（也称为数据提取通道）
- en: How the response is crafted (returning an error or otherwise hiding any faults)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的构建方式（返回错误或隐藏任何故障）
- en: The number of queries needed to influence the application or database to arrive
    at a result
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响应用程序或数据库产生结果所需的查询数量
- en: We won't cover all of these categories exhaustively, but we'll discuss the go-to
    types and how they fit into the categories above. In addition, I'll show some
    examples using our trusty OWASP **Broken Web Application** (**BWA**) **Virtual
    Machine** (**VM**) and we'll see how we approach each of the categories in turn,
    both in the actual injection technique as well as with a tool that can automate
    its use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详尽地涵盖所有这些类别，但我们将讨论常用的类型以及它们如何适用于上述类别。此外，我将使用我们信赖的OWASP **破损Web应用程序**（**BWA**）**虚拟机**（**VM**）来展示一些示例，并且我们将看到我们如何依次处理每个类别，包括实际的注入技术以及可以自动化使用的工具。
- en: In-band or classic SQLI
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: In-band或经典SQLI
- en: '**In-band SQLIÂ **is the easiest and most common mode of SQLI, often referred
    to as the **classic SQLI** type. In-band better describes the way the attack is
    carried out. In-band SQLI involves both launching the attack (nefarious SQL queries)
    and receiving the response (that query''s results) via the same channel. Hackers
    can use these attacks in a couple of ways.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**In-band SQLI**是SQLI的最简单和最常见的模式，通常称为**经典SQLI**类型。 In-band更好地描述了攻击的进行方式。 In-band
    SQLI涉及通过相同的通道发起攻击（恶意SQL查询）和接收响应（该查询的结果）。黑客可以以几种方式使用这些攻击。'
- en: '**Error-based SQLI**: Hackers can probe an application with strings that are
    meant to error out of the responses that reveal much about the structure and policies
    of the website but help map out and enumerate the database that the application
    is using. The example from Mutillidae below shows a statement that when injected
    in a request will induce a detailed error, which can in effect tell us what information
    lies beneath:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于错误的SQLI**：黑客可以使用意图使响应出错的字符串来探测应用程序，这些响应可以揭示网站的结构和策略，但有助于绘制和枚举应用程序正在使用的数据库。下面的Mutillidae示例显示了一个语句，当注入请求时，将引发详细错误，实际上可以告诉我们底层的信息：'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Union-based SQLI**: In a more surgical approach, hackers (us) may have already
    scoped out the database and now will be looking to combine separate statements
    (using a *union* statement) into a single request to coax unanticipated results
    from the application. In doing this, they can piggyback a probing query with something
    more expected by the application and, in returning the result, actually give up
    the goods!'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于联合的SQLI**：在更精确的方法中，黑客（我们）可能已经勘察了数据库，现在将试图将单独的语句（使用*union*语句）合并为一个请求，以从应用程序中引出意想不到的结果。通过这样做，他们可以利用一个探测性查询和应用程序期望的内容结合起来，在返回结果时实际上泄露信息！'
- en: Blind SQLI
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 盲注入
- en: '**Blind SQLI** is like the database version of the childhood game *hot or cold*.
    If you''ve never played it, the kid who hid the toy provides hints to the searcher
    by saying *hot* with varying levels of enthusiasm as the searcher gets closer,
    and *cold* when they are trending away from the hidden objective. So it goes with
    Blind SQLI: when a database won''t just spell it out for you, and the application
    developer is hiding error details, you can sometimes get all of your information
    by inferring the answers and asking the right *true or false* questions. Sure,
    it will be easier to obtain the data outright via one of the classic SQLI modes
    but, by using queries as a sort of true/false probe, hackers can systematically
    enumerate a database without so much as returning a single piece of data. That
    being said, there are two main types of blind SQLI.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**盲注入**就像是数据库版本的童年游戏*热或冷*。如果你从未玩过，藏玩具的孩子通过说*热*来提供给搜索者提示，随着搜索者的接近程度，热度的程度也会有所不同，当他们离隐藏的目标越来越远时则说*冷*。盲注入也是如此：当数据库不直接告诉你，应用程序开发人员又隐藏错误细节时，有时你可以通过推断答案并提出正确的*真或假*问题来获取所有信息。当然，通过经典的SQLI模式之一直接获取数据会更容易，但是通过查询作为真/假探测，黑客可以系统地枚举数据库，甚至不需要返回任何数据。也就是说，盲注入有两种主要类型。'
- en: '**Content-based blind SQLI**: In this type of SQLI, the hacker is trying to
    use queries to infer the existence of a data type, entry, or structure in the
    database by seeing whether the application kicks back an error or not, or different
    errors based on a true or false condition. A MySQL example from the Mutillidae
    application is shown below:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的盲注入**：在这种类型的SQLI中，黑客试图使用查询来推断数据库中的数据类型、条目或结构的存在，通过观察应用程序是否返回错误，或者基于真或假条件返回不同的错误。下面是Mutillidae应用程序中的一个MySQL示例：'
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Time-based blind SQLI**: An alternative form of blind SQLI helps overcome
    any error screening that the web tier does by manipulating timing-based commands
    in the query. When we marry a time-based command to a boolean (also known as conditional)
    query and notice that the error is kicked back after observing the time specified,
    this now becomes our true/false litmus test. SQL has some wait and sleep statements
    that are sometimes accepted; when coupled with a query that the database might
    not want to return the outright answer on, the delay can be all of the answers
    we need to enumerate the contents. An example is shown following:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的盲注入**：盲注入的另一种形式帮助克服了Web层的任何错误筛选，通过操纵查询中的基于时间的命令。当我们将基于时间的命令与布尔（也称为条件）查询结合在一起，并观察到在指定时间后出现错误时，这就成为我们的真/假试金石测试。SQL有一些等待和休眠语句，有时会被接受；当与数据库可能不想直接返回答案的查询结合时，延迟可能就是我们需要枚举内容的所有答案。以下是一个示例：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: No matter how you approach blind SQLI, it is pretty labor-intensive, and not
    something you want to do manually in the real world; finding each letter in a
    table using true/false tests and stepping through an entire alphabet is good work
    for high-performance computing, not a human. As such, it is recommended that you
    only attempt blind SQLI when other options are not present. Tools such as SQLMap
    and SQLninja can assist in automating this, but as we'll see shortly, blind SQLI
    scanning can be a long and drawn out process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何处理盲注入，它都是相当费力的，不是你在现实世界中想要手动完成的事情；使用真/假测试在表中找到每个字母并逐个浏览整个字母表是高性能计算的工作，而不是人类的工作。因此，建议您只在没有其他选择时尝试盲注入。诸如SQLMap和SQLninja之类的工具可以帮助自动化这一过程，但正如我们将很快看到的，盲注入扫描可能是一个漫长而冗长的过程。
- en: Stacked or compound SQLI
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆叠或复合SQLI
- en: Once you understand the classic and blind SQLI methods, it doesn't take a huge
    leap to understand how you can make compound statements and stack multiple requests
    together to not only map our targets' databases, but to also manipulate, corrupt,
    or destroy stored data and eventually run code on the databases. You can pair
    data extraction union-based SQLI, for instance, with a command immediately following
    it to remove the data from the source table. **Netsparker** ([https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/))
    and **PenTestMonkey** ([http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet))
    both offer cheat sheets that do a wonderful job of introducing the many ways Stacked
    SQLI can be used for good (or evil) across multiple database types. The potential
    to do harm here is huge, and so using standard Kali-provided tools (or other **Dynamic
    Application Security Test** or **DAST** suites) to scan and test is preferred
    over engineering your own exploits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了经典和盲注入的方法，就不难理解如何制作复合语句，并将多个请求堆叠在一起，不仅可以映射我们的目标数据库，还可以操纵、破坏或销毁存储的数据，并最终在数据库上运行代码。例如，你可以将基于联合的SQLI的数据提取与紧随其后的命令配对，从源表中删除数据。**Netsparker**（[https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/)）和**PenTestMonkey**（[http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)）都提供了一份很好地介绍了堆叠SQLI可以在多种数据库类型上用于正面（或负面）的作用的备忘单。在这里造成伤害的潜力是巨大的，因此最好使用标准的Kali提供的工具（或其他**动态应用安全测试**或**DAST**套件）进行扫描和测试，而不是自己设计漏洞利用。
- en: SQLI tool school
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLI工具学校
- en: Now that we know how to tell what each SQLI injection type is doing to its targets
    and how it is helping the hacker, we need to have some methods to actually detect
    and exploit these vulnerabilities. Injection attacks, as we're seeing, have a
    pretty broad spectrum of implementations and impacts, and as you might expect
    there are a plethora of tools out there to answer the needs of pen testers and
    hackers. My goal, however, is to get you a solid foundation of tools that can
    provide coverage everywhere and buy you time while you learn and specialize as
    needed. In this section, we'll see how to carry identify and exploit SQLI vulns
    using SQLMap, BBQSQL, SQLNinja, and some good old fashioned browser magic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何判断每种SQLI注入类型对目标的影响以及它如何帮助黑客，我们需要一些方法来实际检测和利用这些漏洞。正如我们所看到的，注入攻击有各种各样的实施和影响，正如您所期望的那样，有大量工具可以满足渗透测试人员和黑客的需求。然而，我的目标是为您提供一套可以在各个方面提供覆盖并为您节省时间的工具基础，同时在需要时学习和专门化。在本节中，我们将看到如何使用SQLMap、BBQSQL、SQLNinja和一些老式的浏览器魔术来识别和利用SQLI漏洞。
- en: Old-school SQLI via browsers
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过浏览器进行老式SQLI
- en: 'All joking aside, experienced hackers will write scripts to spider applications
    for all potential page hosting forms, later visiting each to tinker with them
    and get some idea as to whether SQLI is possible. Scanning tools are fun and all,
    but nothing demonstrates how serious an attack is to a customer better than using
    nothing more than a browser to gain access, escalate privileges, or render sensitive
    data. As an example, if we wanted to try and coax a page to reveal its query syntax,
    we might force an error, as shown in following screenshot,Â in which the database
    tries to tell us how to correct it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 开玩笑的时候到此为止，有经验的黑客会编写脚本来爬取应用程序的所有潜在页面，然后访问每个页面进行调试，以了解是否可能进行SQLI。扫描工具很有趣，但没有什么比仅使用浏览器来获取访问权限、提升权限或渲染敏感数据更能向客户展示攻击的严重性。举个例子，如果我们想试图诱使页面透露其查询语法，我们可能会强制出现错误，如下截图所示，数据库试图告诉我们如何纠正它：
- en: '![](img/B03918_07_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_03.png)'
- en: Forcing a SQL Error
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 强制SQL错误
- en: 'When we click on the **`Login`** button, our helpful database spills the beans
    and we realize exactly what the query we are trying to attack is, as shown in
    following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**`登录`**按钮时，我们有帮助的数据库泄露了秘密，我们意识到我们要攻击的查询到底是什么，如下截图所示：
- en: '![](img/B03918_07_04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_04.png)'
- en: Â The SQL error is so helpful!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SQL错误真是太有帮助了！
- en: 'Close up, the query we''re dealing with is simply going after a field called
    `username` in a table called `accounts`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，我们要处理的查询只是在一个名为`accounts`的表中寻找一个名为`username`的字段：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking at this simple query, and applying some SQL knowledge gleaned from
    a SQLI cheat sheet or from actual academic knowledge of the syntax, it is apparent
    that this query managed to break us out of a query and as a next step we should
    try to both spoof a valid username and attempt to skip the password. We can do
    this by entering in a new string, where `'' or 1=1 --Â ` will use the logical
    operation to ensure that the username exists, and the double hyphen with a trailing
    space tells SQL to skip the following field; in this case, it conveniently skips
    our pesky password field. The new query looks like this when we enter that string
    into the username field:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个简单的查询，并应用从SQLI作弊表或实际学术知识中获得的一些SQL知识，显然这个查询成功地使我们脱离了查询，下一步我们应该尝试欺骗一个有效的用户名，并尝试跳过密码。我们可以通过输入一个新的字符串来实现这一点，其中`'
    or 1=1 --`将使用逻辑操作来确保用户名存在，双破折号和尾随空格告诉SQL跳过接下来的字段；在这种情况下，它方便地跳过了我们讨厌的密码字段。当我们将该字符串输入到用户名字段时，新的查询看起来是这样的：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This little bit of SQL knowledge provided us with a pretty crucial victory
    this time: we are now logged in as admin, as seen in following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这点SQL知识为我们赢得了一次相当关键的胜利：我们现在以管理员身份登录，如下截图所示：
- en: '![](img/B03918_07_05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_05.png)'
- en: The reason SQLI is so feared.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SQLI如此令人畏惧的原因。
- en: I think we can both agree that this is pretty convenient â�� the intentionally
    vulnerable Mutillidae application was a pushover. Admin was returned because,
    as is the case with most databases that haven't been hardened, the admin user
    was the first entry in the user database. Real-world SQLI, however, can be just
    this simple assuming the hacker has the in-depth SQL knowledge and a willingness
    to tinker around and interpret the errors the web application kicks back. A tool
    that can be very helpful in this is the Firebug Firefox browser plugin ([https://addons.mozilla.org/en-US/firefox/addon/firebug/](https://addons.mozilla.org/en-US/firefox/addon/firebug/)),
    which can help you unveil password fields and assist in injecting SQL queries
    even in fields that are normally obscured. If you have a lot of other tasks to
    tackle and cannot bear the hands-on time, there are some helpful tools that iterate
    those queries and interpret the responses for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们都可以同意这相当方便——有意漏洞的Mutillidae应用程序很容易攻破。管理员被还原，因为大多数未经加固的数据库都是如此，管理员用户是用户数据库中的第一个条目。然而，现实世界中的SQLI可能就是这么简单，只要黑客具有深入的SQL知识并愿意尝试和解释Web应用程序返回的错误。在这方面非常有帮助的工具是Firebug
    Firefox浏览器插件（[https://addons.mozilla.org/en-US/firefox/addon/firebug/](https://addons.mozilla.org/en-US/firefox/addon/firebug/)），它可以帮助您揭示密码字段，并在通常被隐藏的字段中注入SQL查询。如果您有很多其他任务要处理，无法忍受亲自操作的时间，还有一些有用的工具可以迭代这些查询并为我们解释响应。
- en: Stepping it up with SQLMap
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SQLMap加强
- en: Let's take a look at how a tool we've already gotten familiar with, Burp Suite,
    can be used to feed one of Kali's most venerable tools in SQLI, **SQLMap**, to
    assist inÂ checking for all sorts of SQLI. Just a warning â�� while Burp is about
    as quick and versatile as tools get, SQLMap takes a long time to get through its
    many tests. The test run for this chapter took well over 10 hours on a souped
    up VM (4 cores, 8 GB of RAM) but it is well worth the wait.Â  Lets check out how
    this process works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们已经熟悉的工具Burp Suite如何被用于向Kali最古老的工具之一SQLI，**SQLMap**，以帮助检查各种SQLI。警告一下-虽然Burp的速度和多功能性都很快，但SQLMap需要很长时间来完成其许多测试。本章的测试运行在一个性能强大的虚拟机上花了超过10个小时（4核，8GB的RAM），但是等待是值得的。让我们看看这个过程是如何工作的。
- en: 'First of all, we''ll need to dust off the cobwebs and start up Burp Suite,
    making it our proxy and allowing it to intercept our requests. Having done that,
    we can surf to the same login page we''ve been picking on, enter in some guest
    credentials, and capture the request in our **`Proxy`** tab and **`Intercept`**
    sub-tab (as shown in following screenshot). Notice that this picks up our false
    credentials in the last line, as well as other important formatting and syntax
    details that SQLMap will likely need to do its work:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要拂去灰尘，启动Burp Suite，将其设置为我们的代理，并允许其拦截我们的请求。做到这一点后，我们可以浏览到我们一直在攻击的相同登录页面，输入一些访客凭据，并在我们的**`Proxy`**选项卡和**`Intercept`**子选项卡中捕获请求（如下图所示）。请注意，这在最后一行捕捉到了我们的虚假凭据，以及SQLMap可能需要执行其工作的其他重要格式和语法细节：
- en: '![](img/B03918_07_06.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_06.png)'
- en: Capturing our request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获我们的请求。
- en: 'Conveniently, Burp Suite allows us to directly save it into a file for SQLMap
    to use (as shown in following screenshot):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，Burp Suite允许我们直接将其保存到文件供SQLMap使用（如下图所示）：
- en: '![](img/B03918_07_07.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_07.png)'
- en: Saving our request for SQLMap to use.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们的请求供SQLMap使用。
- en: 'Using your favorite editor (**nano** in my case) you can change the credential
    fields to two single quotes each, as seen in following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器（在我的情况下是**nano**），您可以将凭据字段更改为两个单引号，如下图所示：
- en: '![](img/B03918_07_08.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_08.png)'
- en: Â Editing the request before passing it to SQLMap.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑请求后再传递给SQLMap。
- en: 'Now you can execute `SQLMap` and pass your response file to it, as well as
    set up any other options you are interested in, using the `SQLMap` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以执行`SQLMap`并将您的响应文件传递给它，以及设置您感兴趣的任何其他选项，使用`SQLMap`命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we should see `SQLMap` do its thing as we see in following screenshot, testing
    for all sorts of vulnerabilities and footprinting our target for us from a SQL
    perspective.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该看到`SQLMap`正在进行测试，如下图所示，测试各种漏洞并从SQL角度为我们勾画我们的目标。
- en: '![](img/B03918_07_09.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_09.png)'
- en: Â SQLMap testing in process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap测试进行中。
- en: 'We''ll need to respond to some of the questions that come up, but in these
    practice scenarios it is usually fine to answer yes to everything. After a long
    and intense scanning period, `SQLMap` will respond with a summary of the injections
    it seems to think the application is potentially susceptible to, and then a characterization
    of the database and web application itself, as seen in following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回答一些问题，但在这些练习场景中，通常可以对所有问题回答是。经过长时间而紧张的扫描后，`SQLMap`将以潜在易受应用程序影响的注入摘要回应，并对数据库和Web应用程序本身进行表征，如下图所示：
- en: '![](img/B03918_07_10.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_10.png)'
- en: SQLMap's output reveals the SQLI types and server info.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap的输出显示了SQLI类型和服务器信息。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may recognize the preceding injection points I provided them as examples
    to some of the types earlier in this chapter. These can be directly inserted into
    requests via Burp or ZAP and immediately verified.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认出我之前提供的注入点，我将它们作为本章前面一些类型的示例。这些可以直接通过Burp或ZAP插入到请求中，并立即验证。
- en: Cooking up some menu-driven SQLI with BBQSQL
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用BBQSQL制作一些菜单驱动的SQLI
- en: SQLMap is a great tool for exhaustive discovery, but sometimes you yearn for
    a menu-driven approach to actually exploit something in particular, especially
    around Blind SQLI. If you aren't a SQL expert but know you need a specific exploit
    mocked up from a certain host, you can customize a Blind SQLI exploit using **BBQSQL**([https://github.com/Neohapsis/bbqsql](https://github.com/Neohapsis/bbqsql))
    a tool developed by Neohapsis (now a part of Cisco). If you are a big fan of the
    **Social Engineering Toolkit** (**SET**), and you want to exploit Blind SQLI fast,
    then BBQSQL is for you! Let's take a quick look at how to configure it and use
    it for your own purposes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap是一个用于详尽发现的好工具，但有时您渴望一种菜单驱动的方法来实际利用特定的东西，特别是在盲SQLI周围。如果您不是SQL专家，但知道您需要从某个主机定制一个特定的利用程序，您可以使用**BBQSQL**（[https://github.com/Neohapsis/bbqsql](https://github.com/Neohapsis/bbqsql)）来定制一个盲SQLI利用程序，这是由Neohapsis（现在是思科的一部分）开发的工具。如果您是**社会工程工具包**（**SET**）的忠实粉丝，并且想要快速利用盲SQLI，那么BBQSQL就是为您量身定制的！让我们快速看一下如何配置它并将其用于您自己的目的。
- en: 'To start up BBQSQL, we don''t need to capture a request for an effective analysis,
    but it helps to have a test request copied to help structure the attack.Â  We
    can just start it up via the GUI shortcut or at the CLI using `bbqsql`. The start
    page (shown in the following screenshot) is very familiar to SET users, and this
    helps get us up and rolling a lot easier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动BBQSQL，我们不需要捕获请求进行有效分析，但复制一个测试请求以帮助构建攻击是有帮助的。我们可以通过GUI快捷方式启动它，或者在CLI中使用`bbqsql`启动。起始页面（如下图所示）对SET用户来说非常熟悉，这有助于我们更轻松地开始：
- en: '![](img/B03918_07_11.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_11.png)'
- en: BBQSQL Start-up menu (outlined in blue).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: BBQSQL启动菜单（用蓝色标出）。
- en: Stepping through each of the menus (see following screenshot), most of the basic
    parameters are in the HTTP options. This is where we can enter in the URL, any
    input fields, and the custom agents and any proxy information we may want to use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个浏览每个菜单（见下图），大多数基本参数都在HTTP选项中。这是我们可以输入URL、任何输入字段以及自定义代理和任何代理信息的地方。
- en: '![](img/B03918_07_12.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_12.png)'
- en: BBQSQL HTTP Menu.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: BBQSQL HTTP菜单。
- en: 'BBQSQL-specific parameters are the heart of BBQSQL''s engine. The important
    or most essential options are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: BBQSQL特定参数是BBQSQL引擎的核心。以下是重要或最基本的选项：
- en: '**Technique**: Defines whether this is a true/false test (`binary_search`)
    or a frequency/time based test that counts occurrences (`frequency_search`).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术**：定义这是一个真/假测试（`binary_search`）还是基于频率/时间的测试，计算出现次数（`frequency_search`）。'
- en: '**Comparison attribute**: This is what we are telling BBQSQL to look for and
    that it will use to differentiate true and false. Size, text strings, values,
    and many other types of comparison are available.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较属性**：这是我们告诉BBQSQL要寻找的内容，并且它将用于区分真假的内容。大小、文本字符串、值和许多其他类型的比较都是可用的。'
- en: '**Concurrency**: BBQSQL''s speed is a direct result of the concurrency it supports,
    which allows it to uncover database contents at a blistering rate as compared
    to other methods.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**：BBQSQL的速度是其支持的并发性的直接结果，这使其能够以比其他方法更快的速度发现数据库内容。'
- en: '**Hooks file**: You can decorate your attacks with hooks, a game-changing Python-defined
    feature not seen in other tools, in that they allow for all sorts of manipulation
    that may need to happen in the process of sending injection requests, such as
    encryption, looping, encoding, or masking.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hooks文件**：您可以使用hooks来装饰您的攻击，这是其他工具中没有的一项改变游戏规则的Python定义功能，因为它们允许进行各种可能需要在发送注入请求过程中发生的操作，比如加密、循环、编码或掩码。'
- en: '**Query**: While other SQLI tools deal in specifics per database platform,
    BBQSQL instead opts for pseudocode to allow you to craft exploits that work across
    SQL types, even Oracle. These queries can be used in either the URL, cookies,
    or the data itself (see the following screenshot).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：虽然其他SQLI工具针对特定数据库平台进行处理，但BBQSQL选择伪代码，允许您创建可跨SQL类型工作的利用程序，甚至是Oracle。这些查询可以在URL、cookies或数据本身中使用（请参见以下屏幕截图）。'
- en: '![](img/B03918_07_13.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_13.png)'
- en: BBQSQL Options menu.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: BBQSQL选项菜单。
- en: I highly recommend practicing not only against the Mutillidae app, but the rest
    of the apps offered on the OWASP BWA VM such as the **Damn Vulnerable Web Application**
    (**DVWA**) or from newly posted applications from [http://www.vulnhub.com](http://www.vulnhub.com).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议不仅针对Mutillidae应用程序进行练习，还要针对OWASP BWA VM上提供的其他应用程序进行练习，比如**Damn Vulnerable
    Web Application**（**DVWA**），或者从[http://www.vulnhub.com](http://www.vulnhub.com)上新发布的应用程序。
- en: Another tool worth looking into for Microsoft SQL-based projects is **SQLninja**
    ([http://sqlninja.sourceforge.net/index.html](http://sqlninja.sourceforge.net/index.html)
    ), a Perl-based tool that is available in Kali Linux. SQLninja does a wonderful
    job exploiting and injecting into that specific subset of databases based on detection
    results from other tools. We did not cover that tool here due to its narrower
    scope, but for those efforts where the target's database is Microsoft-based, it
    can be invaluable!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的工具是**SQLninja**（[http://sqlninja.sourceforge.net/index.html](http://sqlninja.sourceforge.net/index.html)），它适用于基于Microsoft
    SQL的项目，是一个基于Perl的工具，可在Kali Linux中使用。 SQLninja在利用和注入基于检测结果的其他工具的特定数据库子集方面做得非常出色。由于其范围较窄，我们在这里没有涵盖该工具，但对于那些目标数据库是基于Microsoft的情况，它可能非常有价值！
- en: SQLI goes high-class with Oracle
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLI与Oracle高端化
- en: If SQL injections are most common and easily implemented, Oracle injections
    are their rich and exclusive cousin. Oracle databases demand a licensing cost
    and premium knowledge over their more common and widespread SQL relatives.Â  This
    relegates them to more expensive web application solutions, so they are encountered
    most often in larger enterprises or those willing to pay for the greater innate
    scalability and enterprise-class support.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQL注入是最常见且易于实施的，那么Oracle注入就是它们富有和独特的表亲。Oracle数据库需要付费许可和对其更常见和广泛的SQL表亲的高级知识。这使它们更适用于更昂贵的Web应用解决方案，因此它们在更大的企业或愿意为更大的内在可扩展性和企业级支持付费的企业中最常遇到。
- en: 'It stands to reason that Oracle injection attacks are worth knowing or having
    in your tool box. Why is that? Scans returning a result identifying Oracle as
    the underlying DB framework might as well advertise the higher value of their
    contents. The expense in establishing and maintaining them is usually justified
    given the value of what they are holding: Oracle DBs are trusted with some pretty
    sensitive and valuable information. So while we''ll see SQL injections more commonly,
    it takes minimal effort to learn the Oracle flavor and ensure we''re ready when
    the opportunity presents itself. Rest assured, our black hat adversaries are looking
    for these same paths into the applications, so we''d better beat them to it!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说Oracle注入攻击是值得了解或在您的工具箱中拥有的。为什么呢？扫描结果返回识别Oracle作为底层DB框架的结果，实际上也在宣传其内容的更高价值。建立和维护它们的费用通常是合理的，考虑到它们所持有的价值：Oracle数据库被信任保存一些非常敏感和有价值的信息。因此，虽然我们更常见地看到SQL注入，但学习Oracle的方法并确保我们在机会出现时做好准备只需要很少的努力。请放心，我们的黑帽对手也在寻找这些进入应用程序的路径，所以我们最好先于他们找到！
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BBQSQL, SQLMap, and others all offer Oracle modules or extensions to ensure
    that they are covered as well.Â  The same processes used in hacking MySQL, PostgreSQL,
    and others are available in Oracle. Oracle also uses most of the ANSI instruction
    set, so while the differences in structure are worth noting, the tools should
    be able to assist.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: BBQSQL、SQLMap和其他工具都提供了Oracle模块或扩展，以确保它们也受到覆盖。在Oracle中也可以使用在黑客MySQL、PostgreSQL和其他数据库中使用的大部分ANSI指令集，因此尽管结构上的差异值得注意，但这些工具应该能够提供帮助。
- en: The X-factor - XML and XPath injections
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X因子 - XML和XPath注入
- en: '* * *'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Some app developers are eschewing SQL for new, open-standards-based data structures
    written in XML. Why will someone choose this? Relational databases composed with
    SQL are certainly leveraging a very stable, mature technology, but sometimes data
    that has multiple indices of relationships is more compact when rendered and stored
    in XML. This needs to be balanced against the performance in the database tier.Â 
    Relational databases differentiate between variable types, which means they can
    provide optimized treatment of those based on whether they are a string, integer,
    Boolean, or others. XML treats everything like a string of text, so the burden
    is on the Application Tier to comb over the stored data and make manipulations
    with more complex logic and processing overhead. There is no 100% right answer
    â�� these factors will be weighed to determine the mix needed for each application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序开发人员正在摒弃SQL，转而使用基于XML编写的新的、开放标准的数据结构。为什么会有人选择这样做呢？使用SQL构建的关系数据库无疑是利用了非常稳定、成熟的技术，但有时具有多个关系索引的数据在呈现和存储为XML时更加紧凑。这需要在数据库层面的性能方面进行权衡。关系数据库区分不同的变量类型，这意味着它们可以根据字符串、整数、布尔值或其他类型进行优化处理。XML将所有内容都视为文本字符串，因此应用层需要对存储的数据进行检查，并使用更复杂的逻辑和处理开销进行操作。没有100%正确的答案-这些因素将被权衡，以确定每个应用程序所需的混合方式。
- en: When it comes to interacting with that data, one can use XML itself, or use
    **XML Path Lanuage** (**XPath**) to deliver SQL-like commands, requests, and operations
    to the stored data. XML was never really meant to be a data storage technology,
    but more a transmission/delivery standard. If the web application we are targeting
    will spend most of its time using SQL to extract or manipulate data that it just
    has to turn around and create an XML representation of, then just using XML throughout
    could be a huge help.Â  The good knews is that we have plenty of tools available
    for XML as well.Â  Burp Suite and OWASP ZAP will detect some XML injection flaws,
    and as with SQLI a browser or XML viewer can go a long way towards assisting with
    this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在与数据交互时，可以使用XML本身，也可以使用**XML Path Language**（**XPath**）来向存储的数据传递类似SQL的命令、请求和操作。XML实际上并不是一种数据存储技术，而更多地是一种传输/交付标准。如果我们正在针对的Web应用程序将大部分时间用于使用SQL来提取或操作数据，然后必须将其转换并创建XML表示，那么只使用XML可能会大有帮助。好消息是我们也有很多可用于XML的工具。Burp
    Suite和OWASP ZAP将检测一些XML注入漏洞，就像SQLI一样，浏览器或XML查看器可以在这方面提供很大的帮助。
- en: XML injection
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML注入
- en: 'XMLÂ injections typically look to shim data into an XML element, whether it
    be in its **Node Attribute**, **Node Value**, or **CDATA** fields. In the following
    snippet, we see a simple entry for something I might be shopping for, but will
    love to get cheaper (this is a simulated scenario, I always pay fair prices for
    my beverages):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: XML注入通常是将数据插入到XML元素中，无论是在其**节点属性**，**节点值**还是**CDATA**字段中。在下面的片段中，我们看到了一个简单的条目，用于我可能正在购物的东西，但希望能以更便宜的价格得到（这是一个模拟的场景，我总是以公平的价格购买饮料）：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now if I am not excited about paying for that, or will like to make it free,
    I could deliver a payload via XML that alters the game just a little bit.Â  Here
    is the payload I might shim into the server''s XML file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我对支付不感兴奋，或者希望免费获得它，我可以通过XML传递有效负载，稍微改变游戏规则。这是我可能插入到服务器的XML文件中的有效负载：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Which gives me the resulting code, surely:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我带来了如下的代码：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, getting this sort of access via plain-old XML to a production server
    is highly unlikely.Â  This also means that not many Kali-hosted tools that in
    XML injection, but the foundation is solid for understanding what is a much more
    real possibility, the server using XPath to manipulate XML on the backend.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通过普通的XML获得对生产服务器的这种访问几乎是不可能的。这也意味着Kali托管的工具中没有多少XML注入，但是这奠定了理解后端服务器使用XPath操纵XML的更真实可能性的基础。
- en: XPath injection
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XPath注入
- en: '**XPath** is what happens when XML guys get jealous of SQL and invent their
    own query language too.Â  The good news (for hackers) is that XPath has an all-or-nothing
    connotation, if you get some access, you get it all! Sorry XML people, this is
    what happens when you try to make a standard do too much. XPath, unlike SQL, lacks
    granular access control, so there are no tiers of privilege to navigate between,
    and if you can enumerate one character, you know you are able to capture all of
    them. Hopefully these tradeoffs are understood by our target''s developers, and
    protection via other means is put into place to prevent access or validate all
    transactions.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**XPath**是XML人员嫉妒SQL并发明自己的查询语言时发生的事情。好消息（对于黑客来说）是XPath具有全有或全无的含义，如果你获得了一些访问权限，你就能获得全部！抱歉，XML人，当你试图让一个标准做太多事情时，就会发生这种情况。与SQL不同，XPath缺乏细粒度的访问控制，因此没有特权层级可供导航，如果你可以枚举一个字符，你就知道你能够捕获所有字符。希望我们的目标开发人员能理解这些权衡，并通过其他方式进行保护，以防止访问或验证所有交易。'
- en: XPath injections are pretty straightforward once you have that basis in SQLI.
    We're looking for escape characters that either expose the logic or, better yet,
    give us full up access. Â Let's first head into the **Broken Web App**'s (**BWAPP**)
    **`XML/XPath Injection (Login Form)`** bug page and bring up our portal, which
    I show how to find in following screenshot. This VM is included in the same OWASP
    BWA we've been using all along. You have probably noticed as much, but to state
    the obvious, the OWASP BWA VM is the single, most important training tool outside
    of Kali itself, and it is free!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: XPath注入一旦掌握了SQLI的基础，就变得非常简单。我们正在寻找暴露逻辑或更好地说，给予我们完全访问权限的转义字符。首先，让我们进入**Broken
    Web App**（**BWAPP**）的**`XML/XPath Injection (Login Form)`**漏洞页面，并打开我们的门户，我将在下面的截图中展示如何找到它。这个虚拟机包含在我们一直在使用的OWASP
    BWA中。你可能已经注意到了，但显而易见的是，OWASP BWA虚拟机是除了Kali本身之外最重要的培训工具，而且是免费的！
- en: '![](img/B03918_07_14.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_14.png)'
- en: Finding the Broken Web App XPath Injection Page
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查找Broken Web App XPath注入页面
- en: 'We can test for a lack of input validation for potential XPath injection if
    we just use our single quote character again and observe any errors (as shown
    in the following screenshot):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次使用我们的单引号字符，观察任何错误，我们可以测试潜在的XPath注入的输入验证不足（如下截图所示）：
- en: '![](img/B03918_07_15.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_15.png)'
- en: Error indicating XPath Injection possible
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 指示可能存在XPath注入的错误
- en: 'Instead of the `'' or 1=1 -â��` string we saw in SQL, we''re going to use the
    XPath variant of `'' or ''1''=''1` in both the **`Login`** and **`Password`**
    fields, which tells the XPath query *please look for this escape character, because
    1 equals 1 and so we are legit!*Â  We''d hope validation is being done to sanitize
    these inputs, but it is mind-boggling how many servers will kick back a login
    success like the one followingÂ when using this string in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在SQL中看到的`' or 1=1 -â��`字符串不同，我们将在**`Login`**和**`Password`**字段中使用XPath变体的`'
    or '1'='1`，告诉XPath查询*请查找这个转义字符，因为1等于1，所以我们是合法的！*我们希望进行验证以清理这些输入，但令人费解的是，有多少服务器将使用这个字符串返回登录成功，如下截图所示：
- en: '![](img/B03918_07_16.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_16.png)'
- en: Logged in using XPath Injection
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XPath注入登录
- en: 'This process is great to understand using just a browser, but you can also
    do so much more when you let a tool help. **Recon-ng** is a fantastic CLI tool
    that provides a menu structure similar to Metasploit or Websploit that, together
    with the `xpath_bruter` module (wonderfully managed by Tim Tomes), helps automate
    the delivery of **Blind XPath injection** payloads for enumeration of a host.
    We''ll buddy up with Burp Suite too, so that we can harvest the inputs we''ll
    need. So enable proxies, strap in, and prepare to dominate the BWAPP! Let''s look
    first at what `recon-ng` needs from us in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器理解这个过程很棒，但是当您让工具帮助时，您还可以做更多。**Recon-ng**是一个出色的CLI工具，提供了类似于Metasploit或Websploit的菜单结构，与`xpath_bruter`模块（由Tim
    Tomes精心管理）一起，帮助自动传递**Blind XPath注入**有效负载以列举主机。我们还将与Burp Suite合作，以便我们可以收集我们需要的输入。因此，启用代理，准备好支配BWAPP！让我们首先看看`recon-ng`从我们这里需要什么，如下截图所示：
- en: '![](img/B03918_07_17.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_17.png)'
- en: Recon-ng's XPath_Bruter Module
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Recon-ng的XPath_Bruter模块
- en: Let's assume we are OSINT ninjas, and maybe we did a little social engineering
    and found out that Thor is a user and he has the rather naÃ¯ve password of Asgard.
    We can use this single set of credentials to set up our Blind XPath injection.
    From the `show options` command's output preceding, you can see we'll need a couple
    of things to get started. The following screenshotÂ highlights most of the required
    fields for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是OSINT忍者，也许我们进行了一些社会工程学，发现Thor是一个用户，他的密码相当天真，是Asgard。我们可以使用这一组凭据来设置我们的盲目XPath注入。从前面的`show
    options`命令的输出中，您可以看到我们需要一些东西来开始。以下截图突出显示了我们大部分需要的字段。
- en: '![](img/B03918_07_18.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_18.png)'
- en: Our Burp Suite Capture to seed Recon-NG
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Burp Suite捕获以供Recon-NG使用
- en: First of all, we'll grab the **BASE_URL** (in red). Then you'll need the parametersÂ field,
    which is the piece of a URL string we're going to brute-force to enumerate the
    data (in green). We'll use the login parameter to toggle between true and false.
    Assuming you are able to intercept all of the requests now, you should see that
    this portal uses an HTTP GET message to submit queries (as seen in blue), which
    consequently means that the query is embedded within the URL sent to the server.
    Lastly, this particular portal uses cookies, so we can paste in the entire string
    (in purple) for that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将获取**BASE_URL**（红色）。然后您需要参数字段，这是我们将要暴力破解以列举数据的URL字符串的一部分（绿色）。我们将使用登录参数在true和false之间切换。假设您现在能拦截所有请求，您应该看到该门户网站使用HTTP
    GET消息提交查询（如蓝色所示），这意味着查询嵌入在发送到服务器的URL中。最后，这个特定的门户网站使用cookies，所以我们可以粘贴整个字符串（紫色）。
- en: Recon-ng's `XPath-Bruter` module is going to want to know all of this, and it
    is also going to want to know how we tell a true and false apart (the `string`Â variable).
    So if I type what I know to be true credentials (our true condition) I get back
    Thor's secret message, so I can use the word `Earth` as my string. If I do a boolean
    `and` condition with a known false (1 most certainly doesn't equal 2 at the time
    of this book's writing), that string will not show up.Â
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Recon-ng的`XPath-Bruter`模块将要知道所有这些，它还将要知道我们如何区分真假（`string`变量）。因此，如果我输入我知道是真实凭据（我们的真实条件），我会收到Thor的秘密消息，所以我可以使用单词`Earth`作为我的字符串。如果我使用已知的假条件进行布尔`and`条件（在撰写本书时，1肯定不等于2），那个字符串将不会出现。
- en: 'So let''s input those variables, take Burp and our proxy configuration out
    of the loop, and execute our Brute-Force attack! What we''ll see enumerated within
    minutes is seen in the following screenshot: the entire contents of the `heroes.xml`
    file containing all user accounts:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们输入这些变量，将Burp和我们的代理配置排除在外，执行我们的暴力攻击！我们将在几分钟内看到的是下面截图中列举的：包含所有用户帐户的`heroes.xml`文件的整个内容：
- en: '![](img/B03918_07_19.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_19.png)'
- en: Enumerated XML from recon-ng's xpath_bruter module
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从recon-ng的xpath_bruter模块列举的XML
- en: You will find that other injection tools very much follow a similar approach.
    Detection techniques center around the trial-and-error process of finding strings
    that can help expose the flaws, while exploits (in ethical hacking) are usually
    focused on enumeration. Black hat hackers may use some of these tools for actual
    corruption, manipulation, or destruction of the data, but they are normally using
    custom Python or Ruby scripts to execute these malicious attacks, or leveraging
    frameworks offered on the Dark Web. One of the better tools for more advanced
    CLI-based injection testing is Wapiti ([http://wapiti.sourceforge.net/](http://wapiti.sourceforge.net/))
    as it can help in both SQL and XPath injection with a massive number of command
    line switches, options, and use cases supported.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现其他注入工具非常遵循类似的方法。检测技术集中在试错过程中寻找可以帮助暴露缺陷的字符串，而利用（在道德黑客中）通常专注于枚举。黑客可能使用其中一些工具来实际损坏、操纵或破坏数据，但他们通常使用自定义的Python或Ruby脚本来执行这些恶意攻击，或者利用暗网上提供的框架。用于更高级基于CLI的注入测试的更好的工具之一是Wapiti（[http://wapiti.sourceforge.net/](http://wapiti.sourceforge.net/)），因为它可以帮助进行SQL和XPath注入，并支持大量的命令行开关、选项和用例。
- en: Credential Jedi mind tricks
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证Jedi心灵技巧
- en: '* * *'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Database administrators, analytics experts, and data scientists get paid big
    bucks to help structure, manage, and provide access to data in various database
    types, and rightfully so. But even if an application doesn't use this technology,
    or an enterprise doesn't invest in these database types outright, I'd wager that
    they all have a database installed that is arguably more important to their inner
    workings right under their noses--credential databases. Anytime a customer is
    using **Microsoft Active Directory** (**AD**), one of the many flavors of **Lightweight
    Directory Application Protocol** (**LDAP**), or another **identity management
    system** (**IMS**), there is an underlying database that is just begging to be
    tested.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理员、分析专家和数据科学家因帮助构建、管理和提供各种数据库类型的数据而获得高额报酬，这是理所当然的。但即使一个应用程序不使用这项技术，或者一个企业不直接投资这些数据库类型，我敢打赌他们都安装了一个数据库，这个数据库对他们的内部运作来说可能更重要--凭证数据库。每当客户使用**Microsoft
    Active Directory**（**AD**）、**轻量级目录访问协议**（**LDAP**）的许多变种，或者另一个**身份管理系统**（**IMS**）时，都存在一个潜在的数据库等待测试。
- en: 'Credential database hacks can have varying objectives. The most straightforward
    ones look to find a legitimate user''s account to allow the hacker to impersonate
    users and access sensitive information. Others will look for default accounts
    that may not have been disabled or hidden and can then be used with impunity to
    carry out privileged access, administrative functions, or even create new shadow
    accounts that can be used as backdoors and protect the originally compromised
    account for later attempts. LDAP queries, like SQL and XPath, have a syntax of
    their own; like those other injection types, vulnerable queries that fail to sanitize
    data are subject to escape characters that can force logins or quickly escalate
    privileges.Â  Luckily for us, LDAP is much more specific in it''s use, so it has
    a much easier set of manual testing techniques than other types of injections
    might.Â  The flip side to that is that there are no widely used tools on the Kali
    distribution that focus specifically on LDAP Injection scanning or exploits. Burp
    Suite can provide some detection and general injection assistance, but for more
    information please refer to the OWASP guidance on LDAP injection: [https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)](https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证数据库黑客可能有不同的目标。最直接的目标是寻找合法用户的帐户，以允许黑客冒充用户并访问敏感信息。其他人将寻找可能尚未被禁用或隐藏的默认帐户，然后可以毫无顾忌地使用这些帐户进行特权访问、管理功能，甚至创建新的影子帐户，这些帐户可以用作后门，并保护最初被损害的帐户以供以后尝试。与SQL和XPath一样，LDAP查询有自己的语法；与其他注入类型一样，未能对数据进行消毒的易受攻击的查询可能受到转义字符的影响，这些字符可以强制登录或快速提升权限。幸运的是，LDAP在使用上更加具体，因此它比其他类型的注入更容易进行手动测试。另一方面，没有广泛使用的工具专门用于LDAP注入扫描或利用。Burp
    Suite可以提供一些检测和一般的注入帮助，但更多信息请参考OWASP关于LDAP注入的指导：[https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006)](https://www.owasp.org/index.php/Testing_for_LDAP_Injection_(OTG-INPVAL-006))。
- en: Going beyond persuasion â�� Injecting for execution
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越说服 - 注入以执行
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Ok, so we're done playing nice. Maybe an attacker has decided a website has
    nothing of value to them, but they want to deny its functions to legitimate users
    nonetheless. Maybe they are after this application and want to bring it down and
    render the application owner helpless.Â  Or worse yet, maybe they are just using
    this site to get to another one, and in compromising the application they hope
    to impact or laterally move to another. Whatever the motives, one class of injection
    attacks looks beyond convincing the application to cough up its secrets; they
    instead look to convince the server to run new code or execute commands that the
    application's developers had no intention of using or allowing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们不再玩得很好了。也许攻击者已经决定一个网站对他们没有价值，但他们仍然想要否认其功能对合法用户的使用。也许他们正在寻找这个应用程序，并希望将其关闭并使应用程序所有者无助。或者更糟糕的是，也许他们只是使用这个网站来到达另一个网站，通过损害应用程序，他们希望影响或横向移动到另一个网站。无论动机是什么，一类注入攻击超越了说服应用程序吐露其秘密；它们反而试图说服服务器运行新代码或执行应用程序开发人员根本没有意图使用或允许的命令。
- en: We need to be able to find these attacks before the bad guys do. Data leakage
    is a huge concern, no doubt, but a complete crash or long-term compromise of the
    servers themselves threatens the very existence of the application and the company
    relying on it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在坏人之前找到这些攻击。数据泄漏无疑是一个巨大的问题，但服务器的完全崩溃或长期受到威胁会威胁应用程序的存在以及依赖它的公司。
- en: Code injections
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码注入
- en: 'A code injection is used to implement what are known as buffer overflow attacks.
    Rather than pop-up messages to demonstrate that the vulnerability exists, these
    attacks focus on using these cracks in the application''s security validation
    to execute arbitrary code that allows the attacker to take over their target,
    or use the compromised server as a pivot into the environment. Simply put, if
    a website is running on PHP or ASP and passes information via URL query, you can
    look for a code injection flaw by simply identifying the tell-tale string, showing
    that page redirection is accepted, in the source for our page:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注入用于实施所谓的缓冲区溢出攻击。这些攻击不是通过弹出消息来展示漏洞的存在，而是专注于利用应用程序安全验证中的这些漏洞来执行允许攻击者接管目标或使用受损服务器作为进入环境的枢纽的任意代码。简而言之，如果一个网站在PHP或ASP上运行，并通过URL查询传递信息，您可以通过简单地识别特征字符串来寻找代码注入漏洞，从而显示页面重定向被接受，从而找到漏洞所在。
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While this is a pretty benign test path (we're not looking to do harm) we can
    exploit the vulnerability by altering the message and capturing the result for
    our customer. If it is possible to alter the behavior of the web server with a
    simple message, black hat hackers will attempt to run something truly malicious
    on that server using standard PHP functions in an effort to subvert or take over
    the web server itself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相当温和的测试路径（我们不打算造成伤害），但我们可以通过改变消息并捕获结果来利用这个漏洞为我们的客户。如果可以通过一个简单的消息来改变Web服务器的行为，黑客将尝试使用标准的PHP函数在服务器上运行真正恶意的东西，以试图颠覆或接管Web服务器本身。
- en: 'I modified the message to show the customer who is in charge using the following
    string, with the results shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我修改了消息以展示谁掌控着，使用以下字符串，结果显示在以下截图中：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/B03918_07_20.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_20.png)'
- en: Successful code injection
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的代码注入
- en: Overflowing fun
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 溢出的乐趣
- en: There are several forms of code injection that cause buffer overflows,Â each
    focused on attacking a different service in the underlying web or Application
    Tier servers or in the application itself. Â Well-known overflow attacks are often
    unnoticed by the developers who are managing extensive reuse of libraries and
    therefore may not understand that the vulnerability is there. Â Even with this
    potential for issues, more is known about these, and so we must encourage our
    customers to be hyper vigilant in their patching and configuration management.
    Their own custom code and the programming languages they choose, however, lack
    that degree of scrutiny, and so without us helping test their application, they
    are going to be susceptible to the same types of attacks but through unique vectors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种代码注入形式会导致缓冲区溢出，每一种都专注于攻击底层Web或应用程序层服务器中的不同服务，或者是应用程序本身。开发人员通常不会注意到这些知名的溢出攻击，因为他们在管理大量库的复用，可能并不了解存在漏洞。尽管存在这些潜在问题，我们对这些问题了解更多，因此我们必须鼓励客户在修补和配置管理方面保持高度警惕。然而，他们自己的自定义代码和所选择的编程语言缺乏这种程度的审查，因此如果没有我们帮助测试他们的应用程序，他们将容易受到相同类型的攻击，但通过独特的向量。
- en: The common categories we'll discuss in web pen test circles are the Stack, Heap,
    Format String, Unicode, and Integer types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Web渗透测试领域讨论的常见类别包括堆栈、堆、格式字符串、Unicode和整数类型。
- en: '**Stack overflows** are one of the more commonly exploited forms, and result
    when a loosely typed language such as C++ or ASP.NET are used and the developer
    fails to implement at leaseÂ input validation and/or stack integrity checking
    (also known as canary values) in their code.Â Because there is no validation of
    the type or size ofÂ user input, the attacker uses this to inject much longer
    strings into the stack, where the execution stack then overwrites adjacent memory
    space and thus allows the malicious code to find a home; the function that was
    called now points to the top of the malicious code''s memory space.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈溢出**是比较常见的一种被利用的形式，当使用松散类型的语言如C++或ASP.NET时，开发人员未能在他们的代码中实施至少输入验证和/或堆栈完整性检查（也称为canary值）。由于没有对用户输入的类型或大小进行验证，攻击者利用这一点将更长的字符串注入到堆栈中，执行堆栈然后覆盖相邻的内存空间，从而允许恶意代码找到家园；被调用的函数现在指向恶意代码的内存空间顶部。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some CPUs are capable of aiding in defense of these overflows, as they are more
    modern operating systems. It is well worth ensuring that web application teams
    are specifying hardware requirements and considering them within the Software
    Development Life Cycles specification and design phases.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一些CPU能够帮助防御这些溢出，因为它们是更现代的操作系统。确保Web应用程序团队在软件开发生命周期规范和设计阶段中指定硬件要求并考虑它们是非常值得的。
- en: '**Heap overflows** are similar to stack overflows except that they are focused
    on space that is normally not protected by the hardware platform''s CPU. Heaps
    are dynamically allocated as a program is invoked, and the attacker takes advantage
    of this by using those loose rules to force an overflow that overwrites pointers
    and thus allows the hacker to redirect the CPU, pointing to malicious code of
    their own. These are pretty rare given their being addressed in the early 2000''s
    by Microsoft and Linux, but they are well worth checking for given their potential
    impact.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆溢出**与堆栈溢出类似，只是它们专注于通常不受硬件平台CPU保护的空间。堆是在程序调用时动态分配的，攻击者利用这一点通过使用这些宽松的规则来强制溢出，覆盖指针，从而允许黑客重定向CPU，指向他们自己的恶意代码。鉴于它们在2000年代早期就被微软和Linux解决了，这些情况相当罕见，但鉴于它们的潜在影响，它们是非常值得检查的。'
- en: '**Format string overflows** take advantage of poorly crafted system calls and
    functions used in code. Â C and C++ are notorious for having functions that can
    pass multiple variables of various types without being validated. These same function
    attributes may contain control instructions to the underlying function, so it
    is common to see format string injections exploit previously unused portions of
    those calls to force unanticipated behavior.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式字符串溢出**利用了代码中使用的系统调用和函数的不当设计。C和C++以可以传递多种类型的多个变量而不进行验证而臭名昭著。这些相同的函数属性可能包含对底层函数的控制指令，因此通常会看到格式字符串注入利用先前未使用的那些调用的部分来强制产生意外行为。'
- en: '**Unicode overflows** exploit the use of characters not in the standard alphabet
    of the programming language to trigger potential overflows. Not as common as the
    Heap and Stack types, they can be prevented using similar precautions.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unicode溢出**利用了编程语言标准字母表中不存在的字符来触发潜在的溢出。虽然不像堆和栈类型那样常见，但可以使用类似的预防措施来防止它们。'
- en: '**Integer overflows** merely take advantage of poor validation in the integer
    inputs to an operation, such that they load the two variables with numbers they
    know will result in an answer that exceeds the allotted space, thus creating the
    overflow. Like Unicode, protection against the first three overflow types should
    prevent Integer Overflows.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数溢出**仅仅是利用了对操作中整数输入的不良验证，使得它们加载了两个变量，这些变量包含了他们知道会导致答案超出分配空间的数字，从而创建了溢出。与Unicode一样，对前三种溢出类型的保护应该可以防止整数溢出。'
- en: Testing for the various forms of buffer overflow can be included in scans byÂ tools
    such as Burp Suite,Â w3af ([http://w3af.org](http://w3af.org)) and other full-featured
    DAST suites, but Metasploit can help craft all sorts of custom scripts to take
    advantage of them. A fantastic tutorial on this is covered at **Primal Security**
    ([http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/](http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/))
    and as you can see, there is a lot that goes into making a suitable buffer overflow
    attack happen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对各种形式的缓冲区溢出进行测试可以包括在工具如Burp Suite、w3af（[http://w3af.org](http://w3af.org)）和其他功能齐全的DAST套件的扫描中，但Metasploit可以帮助制作各种自定义脚本来利用它们。在**Primal
    Security**（[http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/](http://www.primalsecurity.net/0x0-exploit-tutorial-buffer-overflow-vanilla-eip-overwrite-2/)）上有一个很棒的教程，正如您所看到的，要使合适的缓冲区溢出攻击发生，需要做很多工作。
- en: Commix - Not-so-funny command injectionsÂ
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Commix - 不那么有趣的命令注入
- en: Command injection, on the other hand, does not look to inject code, reflect
    back to hosts, and alter the application's behavior. Command injection finds a
    window through an injectable command used in normal operation of the application
    that gives us some visibility or reach into the back end Web or Application Tier
    servers. The objective is to inject additional commands into the variable strings
    to run local commands on the host operating system, such as a `copy` command,
    reconfiguration of an interface, or worst case scenarios such asÂ `fdisk`. This
    is not your typical fun-loving hijinks â�� this is cruel stuff. A great discussion
    of this occurs in the OWASP OTG ([https://www.owasp.org/index.php/Command_Injection](https://www.owasp.org/index.php/Command_Injection)
    ) and the tool **Commix**Â (**Comm**and **I**njection E**x**ploiter) is included
    with Kali Linux just to be sure we're covered.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命令注入并不是为了注入代码，反射回主机，并改变应用程序的行为。命令注入通过应用程序正常操作中使用的可注入命令找到一个窗口，从而使我们能够看到或接触到后端Web或应用程序层服务器。其目标是将额外的命令注入到变量字符串中，以在主机操作系统上运行本地命令，例如`copy`命令，重新配置接口，或者最坏的情况，如`fdisk`。这不是你典型的喜闹行为
    - 这是残酷的事情。在OWASP OTG（[https://www.owasp.org/index.php/Command_Injection](https://www.owasp.org/index.php/Command_Injection)）中有一个很好的讨论，而工具**Commix**（**Comm**and
    **I**njection E**x**ploiter）已经包含在Kali Linux中，以确保我们得到了覆盖。
- en: To use Commix, you will need the URL (we're using DVWA for this one), the cookie
    associated with your session (I again used Burp with the Intercept On), and the
    field you are fuzzing (IP in this case), and away you go; I got shell access in
    a hurry (as shown in the following screenshot)!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Commix，您需要URL（我们在这里使用DVWA），与您会话相关的cookie（我再次使用了拦截开启的Burp），以及您要模糊处理的字段（在本例中是IP），然后就可以开始了；我很快就获得了shell访问权限（如下面的截图所示）！
- en: '![](img/B03918_07_21.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B03918_07_21.png)'
- en: Shell access through CommixÂ Code Injection
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Commix获得shell访问权限的代码注入
- en: Down with HTTP?
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP完蛋了？
- en: '* * *'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: All of the attacks we've discussed so far in this chapter involve placing strings
    in form fields that we know can cause havoc on back end databases. Many web services
    now create dynamic headers based on user input and session state, and a new class
    of attacks has surfaced to take advantage of the holes this can potentially open
    up. When attackers put their mind to it, they can inject information into headers
    that are actually akin to XSS in many cases.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章讨论的所有攻击都涉及将字符串放置在我们知道可能对后端数据库造成严重破坏的表单字段中。许多网络服务现在根据用户输入和会话状态创建动态标头，并出现了一种新的攻击类型，以利用这可能打开的漏洞。当攻击者下定决心时，他们可以将信息注入到实际上在许多情况下类似于XSS的标头中。
- en: As an example, HTTP is very rigorously mapped in its syntax, such that it treats
    carriage returns and line feeds as special delineation points between fields.
    An attacker might slip some of those in to inject their own arbitrary fields and
    deliver their payloads if the web server is not properly rejecting or sanitizing
    those inputs. This form of attack is called **HTTP response splitting**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，HTTP在其语法上非常严格，它将回车和换行视为字段之间的特殊分隔点。如果Web服务器没有适当地拒绝或对这些输入进行消毒，攻击者可能会在其中插入一些内容，以注入他们自己的任意字段并传递他们的有效负载。这种攻击形式称为**HTTP响应拆分**。
- en: Another form of attack in this class involves **HTTP session fixing**, which
    is a means by which an attacker senses that a website authenticates users and
    uses a session ID, but fails to validate who is sending the session ID and thus
    treats anyone, both the attacker and the victim client, as legitimate participants
    (the web server is unable to differentiate between the two). Through social engineering,
    the attacker can then jump the gun and coerce the victim in to clicking on a link
    where the session ID is already chosen by the attacker. The victim then authenticates,
    basically telling the web server that this session ID is valid. The attacker has
    basically planted their own cookie and had the victim vouch for it.Â
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这类攻击的另一种形式涉及**HTTP会话固定**，这是攻击者感知网站对用户进行身份验证并使用会话ID的一种方式，但未验证发送会话ID的人是谁，因此将任何人，包括攻击者和受害者客户端，都视为合法参与者（Web服务器无法区分两者）。通过社会工程学，攻击者可以趁机强迫受害者点击一个链接，其中会话ID已经被攻击者选择。受害者然后进行身份验证，基本上告诉Web服务器这个会话ID是有效的。攻击者基本上种下了自己的cookie，并让受害者为其背书。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**HTTP Verb Tampering** is another concern, in that it takes advantage of a
    lack of input validation on HTTP requests and uses verbs (POST,Â HEAD, GET, TRACE,
    TRACK, PUT, DELETE, and so on, covered rather well by [http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html)).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP动词篡改**是另一个问题，它利用HTTP请求中输入验证的缺乏，并使用动词（POST、HEAD、GET、TRACE、TRACK、PUT、DELETE等，[http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html)中有很好的介绍）。'
- en: These attack methods are very new and upcoming; outside suites such as Burp
    and Wapati, there are no specialized tools in Kali to specifically cover HTTP
    injection attacks. For more information, please visit the whitepaper produced
    by **Watchfire** ([http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf](http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击方法非常新颖和即将到来；除了Burp和Wapati等套件之外，Kali中没有专门用于覆盖HTTP注入攻击的专用工具。有关更多信息，请访问**Watchfire**制作的白皮书（[http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf](http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf)）。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Injection attacks are numerous and lethal. Given the sheer number of categories,
    methods, and objectives that attackers have to take advantage of these vulnerabilities,
    it is so wonderful that dynamic content is able to be secured. This class of attack
    can only be prevented through vigilant and best-practice-based segmentation, sanitization,
    and continuous penetration testing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击种类繁多且致命。鉴于攻击者必须利用这些漏洞的种类、方法和目标的数量之多，动态内容能够得到保护是非常美妙的。这类攻击只能通过警惕和基于最佳实践的分割、净化和持续的渗透测试来预防。
- en: In this chapter, we looked at the various classes of injection attack, with
    SQL Injection, most likely the star of the show. Given the widespread use of SQL
    in modern application frameworks, it is understandable that more tools and attention
    are given to this form of injection. We'll see how long that lasts, however, as
    XML and XPath are seeing increased use with the explosion in processing capabilities
    and the need for streamlined access and portability. Additionally, more specialized
    injection techniques should not be omitted, as LDAP, command, and code injection
    flaws, while less frequently encountered, are potential nightmares to a company
    whose servers are found lacking in protection. All told, injection attacks can
    be time-consuming and tedious to test for, but adversaries only need one crack
    in the armor to get lucky.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了各种注入攻击类别，其中SQL注入很可能是主角。鉴于现代应用框架中广泛使用SQL，可以理解为什么更多的工具和关注被给予这种注入形式。然而，我们将看到这种情况能持续多久，因为随着处理能力的爆炸和对简化访问和可移植性的需求增加，XML和XPath的使用也在增加。此外，不应忽略更专门的注入技术，因为LDAP、命令和代码注入缺陷，虽然遇到频率较低，但对于服务器保护不足的公司来说可能是潜在的噩梦。总之，注入攻击可能是耗时和乏味的测试，但对手只需要找到一处漏洞就有可能得手。
- en: In the next chapter, we'll take a look at a more technically focused attack
    vector â�� cryptographic flaws and vulnerabilities. The web has been growing at
    an incredible rate at precisely the time when the general public has become aware
    of this dependence and insisted on privacy and confidentiality. Hackers are ahead
    of them in many ways, lying in wait with defeat mechanisms that can allow them
    to intercept, modify, or expose the contents of data flows and betray the trust
    web applications and clients need to have in each other to function properly.
    If you are ready for some spooky stuff, then follow me into [Chapter 8](000.html#),
    *Exploiting Trust ThroughÂ Cryptography Testing*!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更加专注于技术攻击向量——加密缺陷和漏洞。正是在公众意识到这种依赖并坚持隐私和保密的时候，网络正以令人难以置信的速度增长。黑客在许多方面都领先于他们，等待着可以允许他们拦截、修改或暴露数据流内容并背叛网络应用程序和客户之间必须相互信任以正常运行的信任机制。如果你准备好接受一些可怕的东西，那就跟我进入[第8章](000.html#)，*通过密码学测试来利用信任*！
