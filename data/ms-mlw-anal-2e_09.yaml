- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Reversing Bytecode Languages – .NET, Java, and More
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向字节码语言 – .NET、Java及更多
- en: The beauty of cross-platform compiled programs is in their flexibility as you
    don’t need to spend lots of effort porting each program to different systems.
    In this chapter, we will learn how malware authors are trying to leverage these
    advantages for malicious purposes. In addition, you will be provided with an arsenal
    of techniques and tools whose aim is to make analysis quick and efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台编译程序的美妙之处在于它们的灵活性，因为你无需花费大量精力将每个程序移植到不同的系统上。在本章中，我们将学习恶意软件作者如何利用这些优势进行恶意用途。此外，你将获得一系列旨在使分析快速高效的技术和工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic theory of bytecode languages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节码语言的基本理论
- en: .NET explained
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET解释
- en: .NET malware analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET恶意软件分析
- en: The essentials of Visual Basic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic的基本要点
- en: Dissecting Visual Basic samples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析Visual Basic示例
- en: The internals of Java samples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java示例的内部
- en: Analyzing compiled Python threats
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析编译的Python威胁
- en: The basic theory of bytecode languages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节码语言的基本理论
- en: .NET, Java, Python, and many other languages are designed to be cross-platform.
    The corresponding source code doesn’t get compiled into an assembly language (such
    as Intel, ARM, and so on), but gets compiled into an intermediate language that
    is called bytecode language. Bytecode language is a type of language that’s close
    to assembly languages, but it can easily be executed by an interpreter or compiled
    on the fly into a native language (this depends on the CPU and operating system
    it is getting executed in) in what’s called **Just-in-Time** (**JIT**) compiling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET、Java、Python等许多语言设计为跨平台。相应的源代码不会被编译成汇编语言（如Intel、ARM等），而是被编译成一种称为字节码语言的中间语言。字节码语言类似于汇编语言，但可以轻松地由解释器执行或即时编译成本地语言（这取决于CPU和操作系统）。这种编译方式称为**即时编译**（**JIT**）。
- en: Object-oriented programming
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Most of these bytecode languages follow state-of-the-art technologies in the
    programming and development fields. They implement what’s called **object-oriented
    programming** (**OOP**). If you’ve never heard of it, OOP is based on the concept
    of **objects**. These objects contain properties (sometimes called fields or attributes)
    and contain procedures (sometimes called functions or methods). These objects
    can interact with each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些字节码语言遵循编程和开发领域的最新技术。它们实现了所谓的**面向对象编程**（**OOP**）。如果你以前没听说过，OOP基于**对象**的概念。这些对象包含属性（有时称为字段或属性）和包含过程（有时称为函数或方法）。这些对象可以相互交互。
- en: 'Objects can be different instances of the same design or blueprint, which is
    known as a **class**. The following diagram shows a class for a car and different
    instances or objects of that class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以是相同设计或蓝图的不同实例，这称为**类**。下图显示了汽车类及其不同的实例或对象：
- en: '![Figure 9.1 – A car class and three diﬀerent objects'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 一个汽车类和三个不同的对象'
- en: '](img/Figure_9.1_B18500.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B18500.jpg)'
- en: Figure 9.1 – A car class and three diﬀerent objects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 一个汽车类和三个不同的对象
- en: In this class, there are attributes such as fuel and speed, as well as methods
    such as `accelerate()` and `stop()`. Some objects could interact with each other
    and call these methods or directly modify the attributes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，有诸如燃料和速度之类的属性，以及诸如`accelerate()`和`stop()`之类的方法。一些对象可以相互交互并调用这些方法或直接修改这些属性。
- en: Inheritance
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Another important concept to understand is inheritance. Inheritance allows a
    subclass to inherit (or include) all the attributes and methods that are included
    in the parent class (with the code inside). This subclass can have more attributes
    or methods, and it can even reimplement a method included in the parent class
    (sometimes called a super or superclass).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是继承。继承允许子类继承（或包含）父类中包含的所有属性和方法（包括内部的代码）。这个子类可以拥有更多的属性或方法，甚至可以重新实现父类中包含的方法（有时称为超类或父类）。
- en: Polymorphism
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: Inheritance allows one class to represent many different types of objects in
    what’s called polymorphism. A `Shape` class can represent different subclasses,
    such as `Line`, `Circle`, `Square`, and others. A drawing application can loop
    through all `Shape` objects (regardless of their subclasses) and execute a `paint()`
    method to paint them on the screen or the program canvas without having to deal
    with each class separately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使得一个类能够在所谓的多态中表示多种不同类型的对象。一个`Shape`类可以表示不同的子类，例如`Line`、`Circle`、`Square`等。一个绘图应用程序可以遍历所有`Shape`对象（无论它们的子类是什么），并执行`paint()`方法，将它们绘制到屏幕或程序画布上，而无需单独处理每个类。
- en: Since the `Shape` class has the `paint()` method and each of its subclasses
    has an implementation of it, it becomes much easier for the application to just
    execute the `paint()` method, regardless of its implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Shape`类具有`paint()`方法，并且它的每个子类都有该方法的实现，因此应用程序只需执行`paint()`方法，而无需关心其具体实现，这样就变得更加简单。
- en: .NET explained
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 解释
- en: .NET languages (mainly C# and VB.NET) are languages that were designed by Microsoft
    to be cross-platform. The corresponding source code is compiled into a bytecode
    language, originally named **Microsoft Intermediate Language** (**MSIL**), which
    is now known as **Common Intermediate Language** (**CIL**). This language gets
    executed by the **Common Language Runtime** (**CLR**), which is an application
    virtual machine that provides memory management and exception handling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: .NET语言（主要是C#和VB.NET）是微软设计的跨平台语言。相应的源代码被编译成字节码语言，最初命名为**Microsoft Intermediate
    Language**（**MSIL**），现在被称为**Common Intermediate Language**（**CIL**）。此语言由**Common
    Language Runtime**（**CLR**）执行，CLR是一个应用程序虚拟机，提供内存管理和异常处理。
- en: .NET file structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET文件结构
- en: The .NET file structure is based on the PE structure that we described in [*Chapter
    3*](B18500_03.xhtml#_idTextAnchor084), *Basic Static and Dynamic Analysis for
    x86/x64*. The .NET structure starts with a PE header that contains the last but
    one entry in the data directory pointing to .NET’s special **CLR header** (**COR20
    header**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: .NET文件结构基于我们在[*第3章*](B18500_03.xhtml#_idTextAnchor084)中描述的PE结构，*x86/x64的基本静态和动态分析*。
    .NET结构以PE头开始，包含数据目录中的倒数第二个条目，指向.NET的特殊**CLR头**（**COR20头**）。
- en: .NET COR20 header
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET COR20头
- en: 'The `.text` section and contains basic information about the .NET file, as
    shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text`部分，包含有关.NET文件的基本信息，如以下截图所示：'
- en: '![Figure 9.2 – CLR header (COR20 header) and CLR streams'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – CLR头（COR20头）和CLR流'
- en: '](img/Figure_9.2_B18500.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B18500.jpg)'
- en: Figure 9.2 – CLR header (COR20 header) and CLR streams
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – CLR头（COR20头）和CLR流
- en: 'Some of the values of this structure are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的一些值如下：
- en: '**cb**: Represents the size of the header (always 0x48)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cb**：表示头的大小（始终为0x48）'
- en: '**MajorRuntimeVersion** and **MinorRuntimeVersion**: Always with values of
    2 and 5 (even with runtime 4)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MajorRuntimeVersion**和**MinorRuntimeVersion**：始终为2和5（即使是运行时4）'
- en: '**Metadata address and size**: This contains all the CLR streams, which will
    be described later'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据地址和大小**：包含所有CLR流，稍后将详细描述'
- en: '`0x6000012` value, we have the following:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x6000012`值，我们得到了以下内容：'
- en: '`#~` stream (we will talk about streams in detail later). In the following
    screenshot, we can see that it corresponds to the `Methods` table.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#~`流（我们稍后会详细讨论流）。在以下截图中，我们可以看到它对应于`Methods`表。'
- en: '`Main`:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`：'
- en: '![Figure 9.3 – The entry point method in the methods table in the ﬁrst stream,
    #~'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 第一流中的方法表中的入口点方法，#~'
- en: '](img/Figure_9.3_B18500.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B18500.jpg)'
- en: 'Figure 9.3 – The entry point method in the methods table in the ﬁrst stream,
    #~'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 第一流中的方法表中的入口点方法，#~
- en: Now, let’s talk about streams.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈流。
- en: Metadata streams
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据流
- en: 'Metadata contains five sections that are similar to the PE file sections, but
    they are called streams. The streams’ names start with `#` and are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据包含五个部分，它们类似于PE文件的部分，但称为流。流的名称以`#`开头，具体如下：
- en: '`Methods` table has an ID of 0x6).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Methods`表的ID是0x6）。'
- en: '`#~` stream. This includes the methods’ names, classes’ names, and so on. Here,
    each item starts with its length, followed by the string, and then the next item’s
    length followed by the string, and so on.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#~`流。此流包括方法名称、类名称等。每个条目以其长度开始，接着是字符串，然后是下一个条目的长度，再接着是字符串，依此类推。'
- en: '`#Strings` stream, but it contains the strings that are used by the application
    itself, as shown in the following screenshot (with the same structure of item
    length followed by the string):'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#Strings` 流，但它包含了应用程序本身使用的字符串，如下图所示（结构与项长度后跟字符串相同）：'
- en: '![Figure 9.4 – The #US Unicode string started with the length and was followed
    by the actual string'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – #US Unicode 字符串以长度开头，后跟实际的字符串'
- en: '](img/Figure_9.4_B18500.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B18500.jpg)'
- en: 'Figure 9.4 – The #US Unicode string started with the length and was followed
    by the actual string'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9.4 – #US Unicode 字符串以长度开头，后跟实际的字符串'
- en: '**#GUID**: Stores the unique identifiers (GUIDs).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**#GUID**：存储唯一标识符（GUID）。'
- en: '`#US` and `#Strings`, but it contains all Binary data related to the application.
    It has the same format as the item length, followed by the data blob.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#US` 和 `#Strings`，但它包含了与应用程序相关的所有二进制数据。它的格式与项长度相同，后面跟着数据块。'
- en: So, this is the structure of the .NET application. Now, let’s look at how to
    distinguish the .NET application from other executable files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是 .NET 应用程序的结构。现在，让我们来看看如何将 .NET 应用程序与其他可执行文件区分开来。
- en: How to identify a .NET application from PE characteristics
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何通过 PE 特征识别 .NET 应用程序
- en: 'The first way that a .NET PE file can be identified is by using a **PEiD**
    or **CFF Explorer** that includes signatures that cover .NET applications, as
    shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 识别 .NET PE 文件的第一种方法是使用 **PEiD** 或 **CFF Explorer**，这些工具包含了覆盖 .NET 应用程序的签名，如下图所示：
- en: '![Figure 9.5 – PEiD detecting that malware is a .NET application'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – PEiD 检测到恶意软件是一个 .NET 应用程序'
- en: '](img/Figure_9.5_B18500.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B18500.jpg)'
- en: Figure 9.5 – PEiD detecting that malware is a .NET application
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – PEiD 检测到恶意软件是一个 .NET 应用程序
- en: 'The second way is to check the import table inside the data directory. .NET
    applications always import only one API, which is `_CorExeMain` from `mscoree.dll`,
    as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是检查数据目录中的导入表。.NET 应用程序总是只导入一个 API，即来自 `mscoree.dll` 的`_CorExeMain`，如下所示：
- en: '![Figure 9.6 – .NET application import table'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – .NET 应用程序导入表'
- en: '](img/Figure_9.6_B18500.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B18500.jpg)'
- en: Figure 9.6 – .NET application import table
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – .NET 应用程序导入表
- en: Finally, you can check the last but one (15th) entry in the data directory,
    which represents the CLR header. If it’s populated (that is, contains values other
    than `NULL`), then it’s a .NET application, and this should be a CLR header (you
    can use CFF Explorer to check that).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以检查数据目录中的倒数第二个（第15个）条目，这代表了 CLR 头。如果它被填充了（即包含非 `NULL` 的值），那么它就是一个 .NET
    应用程序，并且这应该是一个 CLR 头（你可以使用 CFF Explorer 来检查）。
- en: The CIL language instruction set
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIL语言指令集
- en: The CIL (also known as MSIL) language is quite similar to **Reduced Instruction
    Set Computer** (**RISC**) assembly languages. However, it doesn’t include any
    registers, and all the variables, classes, fields, methods, and so on are accessed
    through their ID in the streams and their tables. Local variables are also accessed
    through their ID in methods. Most of the code is based on loading variables and
    constants into the stack, performing an operation (whose result is stored on the
    stack), and popping this result back into a local variable or field in an object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CIL（也称为 MSIL）语言与**简化指令集计算机**（**RISC**）汇编语言非常相似。然而，它不包含任何寄存器，所有的变量、类、字段、方法等都是通过它们在流和表中的ID进行访问。局部变量也通过它们在方法中的ID进行访问。大部分代码基于将变量和常量加载到栈中，执行操作（其结果存储在栈中），然后将这个结果弹出并存入局部变量或对象中的字段。
- en: This language consists of a set of opcodes and arguments for these opcodes (if
    necessary). Most of the opcodes take up 1 byte. Let’s take a look at the instructions
    in this language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言由一组操作码和这些操作码的参数（如果需要的话）组成。大多数操作码占用1个字节。让我们来看看这门语言中的指令。
- en: Pushing into stack instructions
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送到栈中的指令
- en: 'There are many instructions for storing values or IDs in the stack. These can
    be accessed later by an operation or stored in another variable. Here are some
    examples of them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多指令用于将值或ID存储到栈中。这些可以通过操作后续访问，或者存储在其他变量中。以下是一些示例：
- en: '![](img/B18500_09_Table1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table1.jpg)'
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For all the instructions that take an ID, they take an ID in a 2-byte form.
    There is a shorter version of them that has the `.s` suffix added to them, which
    takes an ID in a 1-byte form.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有需要ID的指令，它们都以2字节的形式接收ID。它们有一个简化版，后缀为`.s`，它们以1字节的形式接收ID。
- en: 'The instructions that deal with the constants or elements of an array (`ldc`
    and `ldelem`) take a suffix that describes the type of that value. Here are the
    used types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理常量或数组元素的指令（`ldc` 和 `ldelem`）带有描述该值类型的后缀。这里是使用的类型：
- en: '![](img/B18500_09_Table2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table2.jpg)'
- en: Now, let’s learn how to pull a value from the stack out into another variable
    or field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将栈中的值提取到另一个变量或字段中。
- en: Pulling out a value from the stack
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从栈中取出一个值
- en: 'Here are the instructions that let you pull out (pop) a value or a reference
    from the stack into another variable or field:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些指令，让你从栈中提取（弹出）一个值或引用到另一个变量或字段：
- en: '![](img/B18500_09_Table3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table3.jpg)'
- en: Important Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The instructions that take IDs also have a shorter version with the `.s` suffix.
    Some instructions, such as `stind` and `stelem`, may have a value type suffix
    as well (such as `.i4` or `.r8`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 ID 的指令也有带 `.s` 后缀的简化版本。某些指令，如 `stind` 和 `stelem`，可能还有值类型后缀（如 `.i4` 或 `.r8`）。
- en: Mathematical and logical operations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学和逻辑操作
- en: The CIL language implements the same operations that you will see in any assembly
    language, such as `add`, `sub`, `shl`, `shr`, `xor`, `or`, `and`, `mul`, `div`,
    `not`, `neg`, `rem` (the remainder from a division), and `nop` (for no operation).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CIL 语言实现了你将在任何汇编语言中看到的相同操作，例如 `add`、`sub`、`shl`、`shr`、`xor`、`or`、`and`、`mul`、`div`、`not`、`neg`、`rem`（除法余数）和
    `nop`（无操作）。
- en: These instructions take their arguments from the stack and save the result back
    into the stack. These can be stored in a variable using any store instruction
    (such as `stloc`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令从栈中获取参数，并将结果保存回栈中。可以使用任何存储指令（如 `stloc`）将它们存储在变量中。
- en: Branching instructions
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支指令
- en: 'This is the last important set of instructions to learn. These instructions
    are related to branching and conditional jumps. These instructions are not so
    different from the assembly languages either, but they depend on the stack values
    for comparing and branching:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学习的最后一组重要指令。这些指令与分支和条件跳转有关。这些指令与汇编语言的区别不大，但它们依赖栈中的值来进行比较和分支：
- en: '![](img/B18500_09_Table4.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table4.jpg)'
- en: Now, let’s put this knowledge into practice and learn how the source code would
    translate into these instructions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这些知识应用到实践中，学习源代码如何转换为这些指令。
- en: CIL language into higher-level languages
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIL 语言转换为高级语言
- en: So far, we’ve discussed the various IL language instructions and the key differentiating
    factors of a .NET application, as well as its file structure. In this section,
    we will take a look at how these higher-level languages (VB.NET, C#, and others),
    as well as their statements, branches, and loops, get converted into CIL language.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了各种 IL 语言指令以及 .NET 应用程序的主要区别因素和文件结构。在本节中，我们将查看这些高级语言（VB.NET、C# 等）以及它们的语句、分支和循环是如何转换为
    CIL 语言的。
- en: Local variable assignments
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量赋值
- en: 'Here is an example of setting a local variable value with a constant value
    of `10`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用常量值 `10` 设置局部变量值的例子：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will be converted into the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换为以下内容：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Easy peasy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 轻松简单。
- en: Local variable assignment with a method return value
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用方法返回值进行局部变量赋值
- en: 'Here is another more complicated example that shows you how to call a method,
    push its arguments to the stack, and store the return value in a local variable
    (here, it’s calling a static method from a class directly and not a virtual method
    from an object):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个更复杂的例子，展示了如何调用方法，将其参数推送到栈中，并将返回值存储在局部变量中（这里，调用的是类中的静态方法，而不是对象的虚方法）：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The intermediate code looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 中间代码如下所示：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Basic branching statements
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的分支语句
- en: 'For `if` statements, the C# code looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `if` 语句，C# 代码如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The corresponding IL code will look like this (here, we are adding the line
    numbers for branching instructions):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 IL 代码如下所示（这里，我们为分支指令添加了行号）：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These instructions will also help us understand the next topic – loops.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令还将帮助我们理解下一个主题——循环。
- en: Loops statements
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环语句
- en: 'The last example we will cover in this section is the `for` loop. This statement
    is more complicated than `if` statements and even more complicated than the `while`
    statement for loops. However, it’s more widely used in C#, and understanding it
    will help you understand other complicated statements in the IL language. The
    C# code looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中讲解的最后一个示例是`for`循环。这个语句比`if`语句复杂，甚至比`while`语句的循环还要复杂。然而，它在C#中使用广泛，理解它将有助于你理解IL语言中的其他复杂语句。C#代码如下：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The equivalent IL code will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的IL代码如下：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s it for the .NET file structure and IL language. Now, let’s learn how
    to analyze .NET malware.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是.NET文件结构和IL语言的介绍。现在，让我们学习如何分析.NET恶意软件。
- en: .NET malware analysis
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET恶意软件分析
- en: As you may know, .NET applications are easy to disassemble and decompile so
    that they become as close to the original source code as possible. This leaves
    malware more exposed to reverse engineering. We will describe multiple obfuscation
    techniques in this section, together with the deobfuscation process. First, let’s
    explore the available tools for .NET reverse engineering.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，.NET应用程序很容易被反汇编和反编译，以尽可能接近原始源代码。这使得恶意软件更容易受到逆向工程的攻击。我们将在本节中描述多种混淆技术，并介绍去混淆过程。首先，让我们探索用于.NET逆向工程的工具。
- en: .NET analysis tools
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET分析工具
- en: 'Here are the most well-known tools for decompiling and analysis:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些最知名的反编译和分析工具：
- en: '**ILSpy**: This is a good decompiler for static analysis, but it can’t debug
    malware.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ILSpy**：这是一个很好的静态分析反编译工具，但它不能调试恶意软件。'
- en: '**dnSpy**: Based on ILSpy and dnlib, it’s a disassembler and decompiler that
    also allows you to debug and patch code.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dnSpy**：基于ILSpy和dnlib，它是一个反汇编器和反编译器，还可以让你调试和修补代码。'
- en: '**.NET reflector**: A commercial decompiler tool for static analysis and debugging
    in Visual Studio.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET reflector**：一款用于静态分析和Visual Studio调试的商业反编译工具。'
- en: '**.NET IL Editor (DILE)**: Another powerful tool that allows you to disassemble
    and debug .NET applications.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET IL Editor (DILE)**：另一个强大的工具，允许你反汇编和调试.NET应用程序。'
- en: '**dotPeek**: A tool that’s used to decompile malware into C# code. It’s good
    for static analysis and for recompiling and debugging with the help of Visual
    Studio.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dotPeek**：一款用于将恶意软件反编译为C#代码的工具。它适用于静态分析，并且在Visual Studio的帮助下可以重新编译和调试。'
- en: '**Visual Studio**: Visual Studio is the main IDE for .NET languages. It allows
    you to compile the source code and debug .NET applications.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**：Visual Studio是.NET语言的主要IDE。它允许你编译源代码并调试.NET应用程序。'
- en: '**SOSEX**: A plugin for WinDbg that simplifies .NET debugging.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOSEX**：一个用于WinDbg的插件，可以简化.NET调试。'
- en: 'Here are the most well-known deobfuscation tools:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最著名的去混淆工具：
- en: '**de4dot**: Based on dnlib as well, it is very useful for deobfuscating samples
    that have been obfuscated by known obfuscation tools'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**de4dot**：同样基于dnlib，它非常适用于去除已知混淆工具混淆的样本。'
- en: '**NoFuserEx**: A deobfuscator for the ConfuserEx obfuscator'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NoFuserEx**：一个用于ConfuserEx混淆器的去混淆工具'
- en: '**Detect It Easy (DiE)**: A good tool for detecting.NET obfuscators'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Detect It Easy (DiE)**：一款用于检测.NET混淆器的优秀工具。'
- en: In the following examples, we are going to mainly use the dnSpy tool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将主要使用dnSpy工具。
- en: Static and dynamic analysis
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和动态分析
- en: Now, we will learn how to perform static analysis and dynamic analysis, and
    then patch the sample to delete or modify the obfuscator code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何进行静态分析和动态分析，然后对样本进行修补，以删除或修改混淆代码。
- en: .NET static analysis
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET静态分析
- en: 'Multiple tools can help you disassemble and decompile a sample, and even convert
    it completely into C# or VB.NET source code. For example, you can use **dnSpy**
    to decompile a sample by just dragging and dropping it into the application interface.
    This is what this application looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多种工具可以帮助你反汇编和反编译样本，甚至将其完全转换为C#或VB.NET源代码。例如，你可以通过将样本拖放到应用程序界面中，使用**dnSpy**进行反编译。以下是该应用程序的界面：
- en: '![Figure 9.7 – Static analysis of a malicious sample with dnSpy'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 使用dnSpy对恶意样本进行静态分析'
- en: '](img/Figure_9.7_B18500.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B18500.jpg)'
- en: Figure 9.7 – Static analysis of a malicious sample with dnSpy
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 使用dnSpy对恶意样本进行静态分析
- en: You can click on **File** | **Export To Project** to export the decompiled source
    code into a Visual Studio project. Now, you can read the source code, modify it,
    write comments on it, or modify the names of the functions for better analysis.
    dnSpy can show the actual IL language of the sample if you right-click and choose
    **Edit IL Language** from the menu.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击**文件** | **导出为项目**将反编译的源代码导出为Visual Studio项目。现在，你可以阅读源代码、修改代码、写注释，或者修改函数名称以便更好的分析。如果你右键点击并从菜单中选择**编辑IL语言**，dnSpy还可以显示样本的实际IL语言。
- en: To go to the main function, you can right-click on the program (from the sidebar)
    and choose `OnRun`, `OnStartup`, or `OnCreateMainForm`, as well as in forms. When
    analyzing code associated with forms, start from their constructor (`.ctor`) and
    pay attention to what function is being added to `base.Load`, as well as what
    functions are called after this. Some methods, such as the form’s `OnLoad` method,
    may be overridden as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳转到主函数，你可以右键点击程序（从侧边栏），选择`OnRun`、`OnStartup`或`OnCreateMainForm`，以及在表单中进行选择。当分析与表单相关的代码时，从它们的构造函数（`.ctor`）开始，并注意哪些函数被添加到`base.Load`中，以及在此之后调用了哪些函数。一些方法，例如表单的`OnLoad`方法，可能也会被重写。
- en: Another tool that you could use is **dotPeek**. It’s a free tool that can also
    decompile a sample and export it to C# source code. It has a very similar interface
    to Visual Studio. You can also analyze the CIL language using IDA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用另一个工具——**dotPeek**。它是一个免费的工具，也可以将样本反编译并导出为C#源代码。它的界面与Visual Studio非常相似。你还可以使用IDA分析CIL语言。
- en: 'Finally, a standard `ildasm.exe` tool can disassemble and export the IL code
    of a sample:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标准的`ildasm.exe`工具可以反汇编并导出样本的IL代码：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: .NET dynamic analysis
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET动态分析
- en: For debugging, there are fewer tools to use. dnSpy is a complete solution when
    it comes to static and dynamic analysis. It allows you to set breakpoints and
    step into and step over for debugging. It also shows the variables’ values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，可用的工具较少。dnSpy是一个完整的解决方案，适用于静态和动态分析。它允许你设置断点，并进行单步调试。它还会显示变量的值。
- en: To start debugging, you need to set a breakpoint on the entry point of the sample.
    Another option is to export the source code to C#, and then recompile and debug
    the program in Visual Studio, which will give you full control over the execution.
    Visual Studio also shows the variables’ values and has lots of features to facilitate
    debugging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，你需要在样本的入口点设置一个断点。另一种选择是将源代码导出为C#，然后在Visual Studio中重新编译并调试程序，这样你将完全控制程序的执行。Visual
    Studio还会显示变量的值，并具有许多有助于调试的功能。
- en: 'If the sample is too obfuscated to debug or export to C# code by dotPeek or
    Dnspy, you can rely on `ildasm.exe` to export the sample code in IL language and
    use `ilasm.exe` to compile it again with debug information. Here is how to recompile
    it with `ilasm.exe`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本经过了过度混淆，无法通过dotPeek或Dnspy进行调试或导出为C#代码，可以依赖`ildasm.exe`将样本代码导出为IL语言，并使用`ilasm.exe`重新编译并包含调试信息。下面是使用`ilasm.exe`重新编译的步骤：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the `/debug` argument, a `.pdb` file for the sample has been created, which
    includes its debug information.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`/debug`参数，已经为该样本创建了一个`.pdb`文件，其中包含了调试信息。
- en: Patching a .NET sample
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET样本的修补
- en: There are multiple ways to modify the sample code for deobfuscating, simplifying
    the code, or forcing the execution to go through a specific path. The first option
    is to use the dnSpy patching capability. In dnSpy, you can edit any method or
    class by right-clicking, selecting **Edit Method (C#)**, modifying the code, and
    recompiling. You can also export the whole project, modify the source code, go
    to **Edit Method (C#)**, and click on the C# icon to import a source code file
    to be compiled by replacing the original code of that class. You can also modify
    the malware source code (after exporting) in Visual Studio and recompile it for
    debugging.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以修改样本代码，用于去混淆、简化代码或强制执行特定路径。第一种选择是使用dnSpy的修补功能。在dnSpy中，你可以通过右键点击任何方法或类，选择**编辑方法（C#）**，修改代码后重新编译。你也可以导出整个项目，修改源代码，进入**编辑方法（C#）**，点击C#图标导入源代码文件，并替换该类的原始代码进行编译。你还可以在Visual
    Studio中修改恶意代码源（导出后），并重新编译以便调试。
- en: 'In dnSpy, you can modify the local variables’ names by selecting **Edit IL
    Instruction** from the menu and selecting **Locals** to modify them by their local
    variable names, as shown in the following screenshot. Concerning the classes and
    methods, you can modify their names just by updating them using the **Edit Method
    (C#)** or **Edit Class (C#)** options:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 dnSpy 中，你可以通过从菜单中选择 **Edit IL Instruction**（编辑 IL 指令）并选择 **Locals**（本地变量）来修改本地变量的名称，如下截图所示。对于类和方法，你可以通过更新它们来修改名称，方法是使用
    **Edit Method (C#)**（编辑方法）或 **Edit Class (C#)**（编辑类）选项：
- en: '![Figure 9.8 – Editing local variables in dnSpy'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 在 dnSpy 中编辑本地变量'
- en: '](img/Figure_9.8_B18500.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_B18500.jpg)'
- en: Figure 9.8 – Editing local variables in dnSpy
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 在 dnSpy 中编辑本地变量
- en: You can also edit the IL code directly by selecting **Edit IL Instruction**
    and modifying the instructions. This allows you to choose the instruction and
    the field or variable you want to access.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过选择 **Edit IL Instruction**（编辑 IL 指令）直接编辑 IL 代码，并修改指令。这使你可以选择指令以及你想要访问的字段或变量。
- en: Dealing with obfuscation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理混淆
- en: In this section, we will look at different common obfuscation techniques for
    .NET samples and learn how to deobfuscate them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究不同的常见混淆技术，并学习如何解混淆 .NET 样本。
- en: Obfuscated names for classes, methods, and others
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆的类、方法等名称
- en: One of the most common obfuscation techniques is to obfuscate the names of the
    classes, methods, variables, fields, and so on – basically everything that has
    a name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的混淆技术之一是混淆类、方法、变量、字段等的名称——基本上是所有有名称的内容。
- en: Obfuscation can get even harder if you obfuscate the names into other alphabets
    or other symbols (since the names are in Unicode), such as Chinese or Japanese.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将名称混淆为其他字母表或其他符号（因为名称是 Unicode 格式），例如中文或日文，混淆的难度会更大。
- en: 'You can try to deobfuscate such samples automatically by running the **de4dot**
    deobfuscator from the command line, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令行运行 **de4dot** 解混淆工具，尝试自动解混淆此类样本，如下所示：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will rename all the obfuscated names, as shown in the following screenshot
    (the HammerDuke sample is shown here):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重命名所有混淆的名称，如下截图所示（这里展示的是 HammerDuke 样本）：
- en: '![Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate
    the names'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 在运行 de4dot 解混淆名称前后的 Hammerduke 恶意软件'
- en: '](img/Figure_9.9_B18500.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_B18500.jpg)'
- en: Figure 9.9 – The Hammerduke malware before and after running de4dot to deobfuscate
    the names
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 在运行 de4dot 解混淆名称前后的 Hammerduke 恶意软件
- en: You can also rename the methods manually to add more meaningful names by right-clicking
    on the method and then selecting **Edit Method** or clicking *Alt* + *Enter* and
    changing the name of the method. After that, you need to save the module and reload
    it for the changes to be put into effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以手动重命名方法，为其添加更有意义的名称，方法是右键点击方法，选择 **Edit Method**（编辑方法），或点击 *Alt* + *Enter*
    并修改方法名称。之后，你需要保存模块并重新加载，以使更改生效。
- en: You can also edit local variable names by right-clicking on the method and choosing
    **Edit Method Body** or **Edit IL Instructions** and choosing **Locals**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过右键点击方法并选择 **Edit Method Body**（编辑方法体）或 **Edit IL Instructions**（编辑 IL
    指令）并选择 **Locals**（本地变量）来编辑本地变量名称。
- en: Encrypted strings inside the Binary
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制中的加密字符串
- en: 'Another common technique used by .NET malware is encrypting its strings. This
    approach hides these strings from signature-based tools, as well as from less
    experienced malware analysts. Working with encrypted strings requires finding
    the decryption function and setting a breakpoint on each of its calls, as shown
    in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 恶意软件使用的另一种常见技术是加密其字符串。这种方法可以将这些字符串隐藏在基于签名的工具以及经验较少的恶意软件分析师面前。处理加密字符串需要找到解密函数，并在每次调用时设置断点，如下截图所示：
- en: '![Figure 9.10 – The Samsam ransomware encrypted strings getting decrypted in
    memory'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – Samsam 勒索病毒加密的字符串在内存中被解密'
- en: '](img/Figure_9.10_B18500.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B18500.jpg)'
- en: Figure 9.10 – The Samsam ransomware encrypted strings getting decrypted in memory
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – Samsam 勒索病毒加密的字符串在内存中被解密
- en: 'Sometimes, there are hard-to-reach encrypted strings, so you may not see them
    decrypted in the default execution of the malware – for example, because the C&C
    is down, or maybe there are additional C&C addresses that won’t get decrypted
    if the first C&C is working. In these cases, you can do any of the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，会有难以访问的加密字符串，因此你可能不会在恶意软件的默认执行过程中看到它们被解密——例如，因为 C&C 服务器无法连接，或者可能存在额外的 C&C
    地址，在第一个 C&C 正常工作的情况下这些地址不会被解密。在这些情况下，你可以执行以下操作：
- en: 'You can try to use de4dot to decrypt the encrypted strings by giving it the
    method ID. You can find the method ID by checking the `Methods` table in the `#~`
    stream, as shown in the following screenshot:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试使用 de4dot 通过提供方法 ID 来解密加密字符串。你可以通过检查 `#~` 流中的 `Methods` 表来找到方法 ID，如下图所示：
- en: '![Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – Samsam 勒索病毒 myﬀ11() 解密函数，ID 0x0600000C'
- en: '](img/Figure_9.11_B18500.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B18500.jpg)'
- en: Figure 9.11 – The Samsam ransomware myﬀ11() decryption function, ID 0x0600000C
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – Samsam 勒索病毒 myﬀ11() 解密函数，ID 0x0600000C
- en: 'Then, you can decrypt the strings dynamically using the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令动态解密字符串：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can modify the entry point code and add a call to the decryption function
    to decrypt the strings. The preceding screenshot is created by repointing calls
    to the decryption functions, including the encrypted strings. For dnSpy to process
    this code, you must use these strings by changing an object field or calling `System.Console.Writeline()`
    to print that string to the console. You will need to save the module after modifying
    it and reopen it for the changes to be put into effect.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改入口点代码并添加调用解密函数的代码来解密字符串。前面的截图是通过重新指向对解密函数的调用，包括加密字符串，生成的。为了让 dnSpy 处理此代码，你必须通过更改对象字段或调用
    `System.Console.Writeline()` 将字符串打印到控制台来使用这些字符串。你需要在修改后保存模块，并重新打开它以使更改生效。
- en: Another option is to export the whole malware source code from dnSpy by clicking
    on **File** | **Export To Project** (other tools may have similar functionality),
    modifying it, and then recompiling it with Visual Studio before debugging it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是通过点击 **文件** | **导出到项目**（其他工具也可能有类似功能）将整个恶意软件源代码从 dnSpy 导出，进行修改，然后在 Visual
    Studio 中重新编译并调试它。
- en: The sample is obfuscated using an obfuscator
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本使用混淆器进行混淆
- en: 'There are many .NET obfuscators publicly available. They are generally supposed
    to be used for protecting intellectual property, but they are also commonly used
    by malware authors to protect their samples from reverse engineering. There are
    multiple tools for detecting known packers, such as **Detect It Easy** (**DiE**),
    as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多公开可用的 .NET 混淆器。它们通常用于保护知识产权，但也常被恶意软件作者用来保护他们的样本免受逆向工程。有多种工具可以检测已知的打包器，如 **Detect
    It Easy**（**DiE**），如下图所示：
- en: '![Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to
    protect against malware'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 使用 **Detect It Easy** 检测保护恶意软件的混淆器（ConfuserEx）'
- en: '](img/Figure_9.12_B18500.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B18500.jpg)'
- en: Figure 9.12 – Detect it Easy detecting the obfuscator (ConfuserEx) used to protect
    against malware
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 使用 **Detect It Easy** 检测保护恶意软件的混淆器（ConfuserEx）
- en: You can also use the de4dot tool to detect the obfuscator by only running the
    `de4dot.exe -d <sample>` command or deobfuscate the sample using the `de4dot.exe
    <sample>` command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 de4dot 工具通过运行 `de4dot.exe -d <sample>` 命令来检测混淆器，或者使用 `de4dot.exe <sample>`
    命令解混淆样本。
- en: For custom and unknown obfuscators, you will need to go through debugging and
    patching processes to deal with them. Before doing so, check different sources,
    if there are solutions or deobfuscators for it. If the obfuscator is shareware,
    you may be able to communicate with the authors and get their aid to deobfuscate
    the sample (as these obfuscators are not designed to help malware authors protect
    their samples).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义和未知的混淆器，你需要通过调试和修补过程来处理它们。在此之前，请检查不同的资源，看是否有相关的解决方案或解混淆工具。如果该混淆器是共享软件，你可能可以与作者联系并获得他们的帮助来解混淆样本（因为这些混淆器并非为了帮助恶意软件作者保护他们的样本而设计的）。
- en: Compile after delivery and proxy code execution
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译后交付并代理代码执行
- en: Instead of distributing malicious .NET binaries directly, attackers may also
    attempt to dynamically compile the malicious payload on the victim’s machine using
    the standard `csc.exe` utility. This approach is commonly used with the help of
    scripts, which we will cover in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能还会尝试使用标准的`csc.exe`工具，在受害者的机器上动态编译恶意有效负载，而不是直接分发恶意.NET二进制文件。这种方法通常通过脚本来实现，我们将在下一章中讨论这些脚本。
- en: In addition, attackers may use the standard `InstallUtil.exe` tool to load malicious
    .NET samples instead of executing them directly. The main advantage of this approach
    for attackers is the fact that in this case, all the associated activity will
    be done on behalf of the signed legitimate application. It is important to know
    that in this case, the execution of the loaded module will start from the class
    inherited from the standard `System.Configuration.Install.Installer` class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，攻击者可能会使用标准的`InstallUtil.exe`工具加载恶意.NET样本，而不是直接执行它们。对于攻击者来说，这种方法的主要优势在于，在这种情况下，所有相关活动都会以签名合法应用程序的名义进行。需要知道的是，在这种情况下，加载的模块执行将从继承自标准`System.Configuration.Install.Installer`类的类开始。
- en: Dynamically loaded code blocks
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态加载的代码块
- en: 'Sometimes, malware may decrypt or decode the next block of code and load it
    dynamically using, for instance, the standard `AppDomain.CurrentDomain.Load` method.
    In this case, it is possible to reach the first instruction of this payload in
    dnSpy by stepping into this method and tracing the code until the `UnsafeInvokeInternal`
    -> `RuntimeMethodHandle.InvokeMethod` control transfer point is reached. Here
    is an example from the AgentTesla malware:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，恶意软件可能会解密或解码下一个代码块，并使用例如标准的`AppDomain.CurrentDomain.Load`方法动态加载它。在这种情况下，可以通过进入此方法并跟踪代码，直到达到`UnsafeInvokeInternal`
    -> `RuntimeMethodHandle.InvokeMethod`控制转移点，在dnSpy中到达该有效负载的第一条指令。以下是来自AgentTesla恶意软件的一个示例：
- en: '![Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.13 – 将控制权转移到AppDomain.CurrentDomain.Load中的有效负载'
- en: '](img/Figure_9.13_B18500.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B18500.jpg)'
- en: Figure 9.13 – Transferring control to the payload inside AppDomain.CurrentDomain.Load
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 将控制权转移到AppDomain.CurrentDomain.Load中的有效负载
- en: Once the first line of the embedded payload is reached, dnSpy will handle the
    rest, decompiling this newly introduced block of code and adding it to the **Assembly
    Explorer** panel to be used for static analysis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达嵌入式有效负载的第一行，dnSpy将处理剩下的部分，反编译这个新引入的代码块，并将其添加到**程序集浏览器**面板中，用于静态分析。
- en: That’s it for .NET-based malware; we have learned everything we need to know
    to start analyzing the corresponding samples efficiently. Now, let’s talk about
    threats written in Visual Basic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于.NET的恶意软件分析；我们已经学会了开始高效分析相应样本所需的所有知识。现在，让我们来谈谈用Visual Basic编写的威胁。
- en: The essentials of Visual Basic
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Basic的基本知识
- en: Visual Basic is a high-level programming language developed by Microsoft and
    based on the BASIC family of languages. Initially, its main feature was its ability
    to quickly create graphical interfaces and good integration with the COM model,
    which fostered easy access to **ActiveX Data Objects** (**ADOs**).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic是一种由Microsoft开发的高级编程语言，基于BASIC系列语言。最初，它的主要特点是能够快速创建图形化界面，并与COM模型良好集成，这促进了对**ActiveX数据对象**（**ADO**）的便捷访问。
- en: The last version of it was released in 1998 and the extended support for it
    ended in 2008\. However, all modern Windows operating systems keep supporting
    it and, while it is rarely used by APT actors, many mass malware families are
    still written on it. In addition, many malicious packers use this programming
    language, often detected as Vbcrypt/VBKrypt or something similar. Finally, **Visual
    Basic for Applications** (**VBA**), which is still widely used in Microsoft Office
    applications and was even upgraded to version 7 in 2010, is largely the same language
    as VB6 and uses the same runtime library.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它的最后一个版本发布于1998年，扩展支持于2008年结束。然而，所有现代Windows操作系统仍然支持它，尽管APT攻击者很少使用它，但许多大规模恶意软件家族仍然使用它。此外，许多恶意打包工具也使用这种编程语言，通常被检测为Vbcrypt/VBKrypt或类似的名称。最后，**Visual
    Basic for Applications**（**VBA**）仍广泛用于Microsoft Office应用程序，并且在2010年甚至升级到了第7版，它与VB6语言大致相同，并使用相同的运行时库。
- en: In this section, we will dive into two different compilation modes supported
    by the latest version of Visual Basic (which is 6.0 at the time of writing) and
    provide recommendations on how to analyze samples using them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨最新版本Visual Basic（截至本文编写时为6.0）支持的两种不同编译模式，并提供关于如何分析使用这些模式的样本的建议。
- en: File structure
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: 'The compiled Visual Basic samples look like standard MZ-PE executables. They
    can easily be recognized by a unique imported DLL, `MSVBVM60.DLL` (`MSVBVM50.DLL`
    was used for the older version). PEiD tool is generally very good at identifying
    this programming language (when the sample is not packed, obviously):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的Visual Basic样本看起来像标准的MZ-PE可执行文件。它们可以通过一个独特的导入DLL `MSVBVM60.DLL`轻松识别出来（旧版本使用的是`MSVBVM50.DLL`）。PEiD工具通常非常擅长识别这种编程语言（显然，前提是样本没有被打包）：
- en: '![Figure 9.14 – PEiD identifying Visual Basic'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – PEiD识别Visual Basic'
- en: '](img/Figure_9.14_B18500.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B18500.jpg)'
- en: Figure 9.14 – PEiD identifying Visual Basic
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – PEiD识别Visual Basic
- en: 'At the entry point of the sample, we can expect to see a call to the `ThunRTMain`
    (`MSVBVM60.100`) runtime function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在样本的入口点，我们可以看到调用`ThunRTMain`（`MSVBVM60.100`）运行时函数：
- en: '![Figure 9.15 – Entry point of the Visual Basic sample'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 – Visual Basic样本的入口点'
- en: '](img/Figure_9.15_B18500.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.15_B18500.jpg)'
- en: Figure 9.15 – Entry point of the Visual Basic sample
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – Visual Basic样本的入口点
- en: 'The `Thun` prefix here is a reference to the original project’s name, **BASIC
    Thunder**. This function receives a pointer to the following structure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Thun`前缀是对原始项目名称**BASIC Thunder**的引用。此函数接收一个指向以下结构的指针：
- en: '![](img/B18500_09_Table5.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table5.jpg)'
- en: 'Now, let’s take a look at the `ProjectInfo` structure:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`ProjectInfo`结构：
- en: '![](img/B18500_09_Table6.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table6.jpg)'
- en: Here, one of the most interesting fields is `NativeCode`. This field can be
    used to figure out whether the sample has been compiled as p-code or native code.
    Now, let’s see why this information is important.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最有趣的字段之一是`NativeCode`。这个字段可以用来判断样本是作为p-code还是本地代码编译的。现在，让我们看看为什么这些信息很重要。
- en: P-code versus native code
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: P-code与本地代码
- en: 'Starting from Visual Basic 5, the language supports two compilation modes:
    p-code and native code (before p-code was the only option). To understand the
    differences between them, we need to understand what p-code is.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Basic 5开始，该语言支持两种编译模式：p-code和本地代码（在此之前，p-code是唯一的选项）。要理解它们之间的区别，我们需要了解什么是p-code。
- en: '`P-code`, which stands for packed code or pseudocode, is an intermediate language
    with an instruction format similar to machine code. In other words, it is a form
    of bytecode. The main reason behind introducing it is to reduce the program’s
    size at the expense of execution speed. When the sample is compiled as p-code,
    the bytecode is interpreted by the language runtime. In contrast, the native code
    option allows developers to compile a sample into the usual machine code, which
    generally works faster but takes up more space because of multiple overhead instructions
    being used.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`P-code`，即打包代码或伪代码，是一种中间语言，其指令格式类似于机器代码。换句话说，它是一种字节码。引入它的主要原因是通过牺牲执行速度来减小程序的大小。当样本被编译为p-code时，字节码将由语言运行时解释执行。与此相对，本地代码选项允许开发者将样本编译成通常的机器代码，这通常运行得更快，但由于使用了多个开销指令，因此占用更多的空间。'
- en: It is important to know which mode the analyzed sample is compiled in as it
    defines what static and dynamic analysis tools should be used. As for how to distinguish
    them, the easiest way would be to look at the `NativeCode` field we mentioned
    previously. If it is set to `0`, this means that the p-code compilation mode is
    being used. Another indicator here is that the difference between the `CodeEnd`
    and `CodeStart` values will only be a few bytes maximum as there will be no native
    code functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 知道分析的样本是在哪种模式下编译的非常重要，因为它决定了应使用哪些静态和动态分析工具。至于如何区分它们，最简单的方法是查看我们之前提到的`NativeCode`字段。如果它被设置为`0`，这意味着使用的是p-code编译模式。另一个指示器是，`CodeEnd`和`CodeStart`值之间的差异通常只有几个字节，因为没有本地代码函数。
- en: 'One more (less reliable) approach is to look at the import table:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种（不太可靠）的方法是查看导入表：
- en: '`MSVBVM60.DLL`, which provides access to all the necessary VB functions:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSVBVM60.DLL`，它提供对所有必要的VB函数的访问：'
- en: '![Figure 9.16 – The import table of the Visual Basic sample compiled in p-code
    mode'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 – 以p-code模式编译的Visual Basic样本的导入表'
- en: '](img/Figure_9.16_B18500.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.16_B18500.jpg)'
- en: Figure 9.16 – The import table of the Visual Basic sample compiled in p-code
    mode
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 以 P-code 模式编译的 Visual Basic 示例的导入表
- en: '`MSVBVM60.DLL`, there will also be the typical system DLLs such as `kernel32.dll`
    and the corresponding import functions:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSVBVM60.DLL`，还有典型的系统 DLL，如 `kernel32.dll`，以及相应的导入函数：'
- en: '![Figure 9.17 – The import table of the Visual Basic sample compiled in native
    code mode'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17 – 以本地代码模式编译的 Visual Basic 示例的导入表'
- en: '](img/Figure_9.17_B18500.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.17_B18500.jpg)'
- en: Figure 9.17 – The import table of the Visual Basic sample compiled in native
    code mode
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 以本地代码模式编译的 Visual Basic 示例的导入表
- en: 'A quick way to distinguish between these modes is to load a sample into a free
    **VB Decompiler Lite** program and take a look at the code compilation type (marked
    in bold) and the functions themselves. If the instructions there are typical x86
    instructions, then the sample has been compiled as native code; otherwise, p-code
    mode has been used:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这些模式的一种快速方法是将一个示例加载到免费的 **VB Decompiler Lite** 程序中，查看代码编译类型（加粗标记）以及函数本身。如果那里显示的是典型的
    x86 指令，那么该示例是以本地代码编译的；否则，使用的是 P-code 模式：
- en: '![Figure 9.18 – P-code versus native code samples in VB Decompiler Lite'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18 – P-code 与本地代码示例在 VB Decompiler Lite 中的对比'
- en: '](img/Figure_9.18_B18500.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.18_B18500.jpg)'
- en: Figure 9.18 – P-code versus native code samples in VB Decompiler Lite
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 在 VB Decompiler Lite 中，P-code 与本地代码示例的对比
- en: We will cover this tool in greater detail in the next section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地介绍这个工具。
- en: Common p-code instructions
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 P-code 指令
- en: 'Multiple basic opcodes take up 1 byte (`0x00-0xFA`); the bigger 2-byte opcodes
    that start with a prefix byte from the `0xFB`-`0xFF` range are used less frequently.
    Here are some examples of the most common p-code instructions that are generally
    seen when exploring VB disassembly:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 多个基本操作码占用 1 个字节（`0x00-0xFA`）；较大的 2 字节操作码以 `0xFB-0xFF` 范围内的前缀字节开头，使用频率较低。以下是一些常见的
    P-code 指令示例，通常在探索 VB 反汇编时会看到：
- en: 'Data storage and movement:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储和移动：
- en: '`LitStr/LitVarStr`: Initializes a string'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LitStr/LitVarStr`：初始化字符串'
- en: '`LitI2/LitI4/...`: Pushes an integer value to the stack (often used to pass
    arguments)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LitI2/LitI4/...`：将整数值推入栈中（通常用于传递参数）'
- en: '`FMemLdI2/FMemLdRf/...`: Loads values of a particular type (memory)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FMemLdI2/FMemLdRf/...`：加载特定类型的值（内存）'
- en: '`Ary1StI2/Ary1StI4/...`: Puts values of a particular type into an array'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ary1StI2/Ary1StI4/...`：将特定类型的值压入数组'
- en: '`Ary1LdI2/Ary1LdI4/...`: Loads values of a particular type from an array'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ary1LdI2/Ary1LdI4/...`：从数组中加载特定类型的值'
- en: '`FStI2/FStI4/...`: Puts a variable value into the stack'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FStI2/FStI4/...`：将变量值压入栈中'
- en: '`FLdI2/FLdI4/...`: Loads a value into a variable from the stack'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLdI2/FLdI4/...`：从栈中将值加载到变量中'
- en: '`FFreeStr`: Frees a string'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FFreeStr`：释放字符串'
- en: '`ConcatStr`: Concatenates a string'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcatStr`：连接字符串'
- en: '`NewIfNullPr`: Allocates space if null'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewIfNullPr`：如果为空则分配空间'
- en: 'Arithmetic operations:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算：
- en: '`AddI2/AddI4/...`: Adding operation'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddI2/AddI4/...`：加法运算'
- en: '`SubI2/SubI4/...`: Subtraction operation'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubI2/SubI4/...`：减法运算'
- en: '`MulI2/MulI4/...`: Multiplication operation'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MulI2/MulI4/...`：乘法运算'
- en: '`DivR8`: Division operation'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DivR8`：除法运算'
- en: '`OrI4/XorI4/AndI4/NotI4/...`: Logical operations'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrI4/XorI4/AndI4/NotI4/...`：逻辑运算'
- en: 'Comparison:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较：
- en: '`EqI2/EqI4/EqStr/...`: Check if equal'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EqI2/EqI4/EqStr/...`：检查是否相等'
- en: '`NeI2/NeI4/NeStr/...`: Check if not equal'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NeI2/NeI4/NeStr/...`：检查是否不等'
- en: '`GtI2/GtI4/...`: Check if greater than'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GtI2/GtI4/...`：检查是否大于'
- en: '`LeI2/LeI4/...`: Check if less than or equal to'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeI2/LeI4/...`：检查是否小于或等于'
- en: 'Control flow:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流：
- en: '`VCallHresult/VCallAd(VCallI4)/...`: Calls a function'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VCallHresult/VCallAd(VCallI4)/...`：调用一个函数'
- en: '`ImpAdCallI2/ImpAdCallI4/...`: Calls an import function (API)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImpAdCallI2/ImpAdCallI4/...`：调用导入函数（API）'
- en: '`Branch/BranchF`: Branches when the condition is met'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Branch/BranchF`：条件满足时跳转'
- en: There are many more of these. If some new opcode is not clear to you and you
    need to understand its functionality, it can be found in the unofficial documentation
    (not very detailed) or explored in the debugger.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多类似的指令。如果某个新的操作码对你来说不清楚，且你需要理解其功能，可以在非官方文档中找到（尽管不够详细），或者在调试器中进行探索。
- en: 'Here are the most common abbreviations used in opcode names:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是操作码名称中最常用的缩写：
- en: '`Ad`: Address'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ad`：地址'
- en: '`Rf`: Reference'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rf`：引用'
- en: '`Lit`: Literal'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lit`：字面量'
- en: '`Pr`: Pointer'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pr`：指针'
- en: '`Imp`: Import'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Imp`：导入'
- en: '`Ld`: Load'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ld`：加载'
- en: '`St`: Store'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`St`：存储'
- en: '`C`: Cast'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`：类型转换'
- en: '`DOC`: Duplicate opcode'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOC`：重复操作码'
- en: 'All the common data type abbreviations that are used are pretty much self-explanatory:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常见的数据类型缩写几乎都可以自我解释：
- en: '`I`: Integer (`UI1` – byte, `I2` – integer, `I4` – long)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I`: 整数（`UI1` – 字节，`I2` – 整数，`I4` – 长整型）'
- en: '`R`: Real (`R4` – single, `R8` – double)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`: 实数（`R4` – 单精度，`R8` – 双精度）'
- en: '`Bool`: Boolean'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool`: 布尔值'
- en: '`Var`: Variant'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Var`: 变体'
- en: '`Str`: String'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Str`: 字符串'
- en: '`Cy`: Currency'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cy`: 货币'
- en: While it may take some time to get used to their notations, there aren’t that
    many variations, so after a while, it becomes pretty straightforward to understand
    the core logic. Another option would be to invest in a proper decompiler and avoid
    dealing with p-code instructions. We will cover this later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能需要一些时间来习惯它们的符号，但其实变种并不多，所以过一段时间后，理解核心逻辑变得相对直接。另一个选择是投资一个合适的反编译器，避免直接处理
    p-code 指令。我们稍后会讲到这个。
- en: Dissecting Visual Basic samples
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剖析 Visual Basic 样本
- en: Now that we have gained some knowledge of the essentials of Visual Basic, it’s
    time to shift our focus and learn how to dissect Visual Basic samples. In this
    section, we are going to perform a detailed static and dynamic analysis.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Visual Basic 的一些基本知识，是时候转移焦点，学习如何剖析 Visual Basic 样本了。在这一部分，我们将进行详细的静态和动态分析。
- en: Static analysis
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: The common part of VB malware is that the code generally gets executed as part
    of the `SubMain` routine and event handlers, where timer and form load events
    are particularly typical.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: VB 恶意软件的共性是代码通常作为 `SubMain` 程序和事件处理程序的一部分执行，其中定时器和表单加载事件特别典型。
- en: As we have already mentioned, the choice of tools will be defined by the compilation
    mode that’s used when creating a malware sample.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，工具的选择将由创建恶意软件样本时使用的编译模式来决定。
- en: P-code
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P-code
- en: 'For p-code samples, **VB Decompiler** can be used to get access to its internals.
    The Lite version is free and provides access to the p-code disassembly, which
    may be enough for most cases. If the engineer doesn’t have enough expertise or
    time to deal with the p-code syntax, then the paid full version provides a powerful
    decompiler that produces more readable Visual Basic source code as output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 p-code 样本，可以使用 **VB Decompiler** 来访问其内部结构。Lite 版本是免费的，提供 p-code 反汇编访问，这对于大多数情况来说可能已经足够。如果工程师没有足够的专业知识或时间来处理
    p-code 语法，那么付费的完整版提供了强大的反编译器，能够输出更易读的 Visual Basic 源代码：
- en: '![Figure 9.19 – The same p-code function in VB Decompiler disassembled and
    decompiled'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.19 – 在 VB 反编译器中拆解和反编译的相同 p-code 函数'
- en: '](img/Figure_9.19_B18500.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.19_B18500.jpg)'
- en: Figure 9.19 – The same p-code function in VB Decompiler disassembled and decompiled
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 在 VB 反编译器中拆解和反编译的相同 p-code 函数
- en: 'Another popular option is the **P32Dasm** tool, which allows you to obtain
    p-code listings in a few clicks:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的选择是 **P32Dasm** 工具，它允许你通过几次点击获得 p-code 列表：
- en: '![Figure 9.20 – P32Dasm in action'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.20 – P32Dasm 在操作中'
- en: '](img/Figure_9.20_B18500.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.20_B18500.jpg)'
- en: Figure 9.20 – P32Dasm in action
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – P32Dasm 在操作中
- en: One of its useful features is its ability to produce MAP files that can later
    be loaded into OllyDbg or IDA using dedicated plugins. Its documentation also
    mentions the Visual Basic debugger plugin for IDA, but it doesn’t seem to be available
    to the general public.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个有用特点是能够生成 MAP 文件，这些文件可以通过专用插件加载到 OllyDbg 或 IDA 中。文档中还提到了用于 IDA 的 Visual
    Basic 调试插件，但似乎并未公开提供给大众使用。
- en: Important Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A hint for first-time users – if necessary, put all requested `.ocx` files (can
    be downloaded separately if not available) into the P32Dasm’s root directory to
    make it work.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 给首次使用者的提示 – 如果需要，可以将所有请求的 `.ocx` 文件（如果不可用，可以单独下载）放入 P32Dasm 的根目录，以使其正常工作。
- en: Native code
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生代码
- en: 'For samples compiled as native code, any Windows static analysis tool we’ve
    already discussed will do the trick. In this case, the solutions that can effectively
    apply structures (such as IDA, Binary Ninja, or radare2) can save time:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译为原生代码的样本，我们已经讨论过的任何 Windows 静态分析工具都可以胜任。在这种情况下，能够有效应用结构的解决方案（如 IDA、Binary
    Ninja 或 radare2）可以节省时间：
- en: '![Figure 9.21 – The beginning of the native code after applying the ProjectInfo
    structure'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.21 – 在应用 ProjectInfo 结构后原生代码的开始部分'
- en: '](img/Figure_9.21_B18500.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.21_B18500.jpg)'
- en: Figure 9.21 – The beginning of the native code after applying the ProjectInfo
    structure
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 在应用 ProjectInfo 结构后原生代码的开始部分
- en: 'VB Decompiler can be used to quickly access the names of procedures without
    digging into VB structures. For IDA, a free `SubMain` function by taking the address
    of the VB header (as we know, it is passed to the `ThunRTMain` function in the
    first instruction at the sample’s entry point) and get the address of `SubMain`
    by its offset (`0x2C`). For example, in radare2, you would do the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: VB 反编译器可以快速访问程序名称，而无需深入挖掘 VB 结构。对于 IDA，通过获取 VB 头的地址（如我们所知，它会传递给样本入口点处的 `ThunRTMain`
    函数），然后通过偏移量（`0x2C`）获取 `SubMain` 地址。例如，在 radare2 中，你可以执行以下操作：
- en: '![Figure 9.22 – Finding the SubMain address for the VB sample in radare2'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.22 – 在 radare2 中查找 VB 示例的 SubMain 地址](img/Figure_9.22_B18500.jpg)'
- en: '](img/Figure_9.22_B18500.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 9.22 – Finding the SubMain address for the VB sample in radare2
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 在 radare2 中查找 VB 示例的 SubMain 地址
- en: Now, let’s talk about the dynamic analysis of Visual Basic samples.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 Visual Basic 示例的动态分析。
- en: Dynamic analysis
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分析
- en: Just like static analysis, a dynamic analysis will be different for p-code and
    native code samples.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态分析一样，动态分析在 p-code 和本地代码样本之间是不同的。
- en: P-code
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P-code
- en: 'When there is a need to debug p-code compiled code, generally, there are two
    options available: debug the p-code instructions themselves or debug the restored
    source code.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要调试 p-code 编译的代码时，通常有两种可用的选项：调试 p-code 指令本身或调试恢复的源代码。
- en: The second option requires a high-quality decompiler that can produce something
    close to the original source code. Usually, VB Decompiler does this job pretty
    well. In this case, its output can be loaded into an IDE of your choice and after
    some minor modifications, it can be used to debug any usual source code. Often,
    it isn’t necessary to restore the whole project as only certain parts of the code
    need to be traced.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择需要一个高质量的反编译器，它能够生成接近原始源代码的内容。通常，VB 反编译器能很好地完成这项工作。在这种情况下，它的输出可以加载到你选择的
    IDE 中，并经过一些小的修改后，可以用于调试任何常见的源代码。通常，不需要恢复整个项目，因为只需要追踪代码的某些部分。
- en: While this approach is more user-friendly in general, sometimes, debugging actual
    p-code may be the only option available, for example, when a decompiler doesn’t
    work properly or just isn’t available. In this case, the **WKTVBDE** project becomes
    extremely handy as it allows you to debug p-code compiled applications. It requires
    a malicious sample to be placed in its root directory to be loaded properly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法通常更用户友好，但有时调试实际的 p-code 可能是唯一可用的选项，例如，当反编译器无法正常工作或根本无法使用时。在这种情况下，**WKTVBDE**
    项目非常有用，它允许你调试 p-code 编译的应用程序。它要求恶意样本被放置在其根目录中，以便正确加载。
- en: Native code
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地代码
- en: For native code samples, just like for static analysis, dynamic analysis tools
    for Windows can be used. The choice mainly depends on the analyst’s preferences
    and available budget.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地代码样本，与静态分析类似，可以使用 Windows 的动态分析工具。选择工具主要取决于分析人员的偏好和预算。
- en: At this stage, we have learned enough about VB to start analyzing the first
    few samples. Now, let’s talk about Java-based threats.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到此阶段，我们已经足够了解 VB，可以开始分析前几个样本了。现在，让我们谈谈基于 Java 的威胁。
- en: The internals of Java samples
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 示例的内部结构
- en: Java is a cross-platform programming language that is commonly used to create
    both local and web applications. Its syntax was influenced by another object-oriented
    language called Smalltalk. Originally developed by Sun Microsystems and first
    released in 1995, it later became a part of the Oracle Corporation portfolio.
    At the time of writing, it is considered to be one of the most popular programming
    languages in use.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种跨平台编程语言，常用于创建本地应用程序和网页应用程序。其语法受另一种面向对象语言 Smalltalk 的影响。最初由 Sun Microsystems
    开发，并于 1995 年首次发布，后来成为甲骨文公司的一部分。本文写作时，它被认为是最流行的编程语言之一。
- en: Java applications are compiled into the bytecode that’s executed by **Java Virtual
    Machines** (**JVMs**). The idea here is to let applications that have been compiled
    once be used across all supported platforms without any changes required. There
    are multiple JVM implementations available on the market and at the time of writing
    (starting from Java 1.3), HotSpot JVM is the default official option. Its distinctive
    feature is its combination of the interpreter and the JIT compiler, which can
    compile bytecode into native machine instructions based on the profiler output
    to speed up the execution of slower parts of the code. Most PC users get it by
    installing the **Java Runtime Environment** (**JRE**), which is a software distribution
    that includes the standalone JVM (HotSpot), the standard libraries, and a configuration
    toolset. The **Java Development Kit** (**JDK**), which also contains JRE, is another
    popular option since it is a development environment for building applications,
    applets, and components using the Java language. For mobile devices, the process
    is quite different. We will cover it in [*Chapter 13*](B18500_13.xhtml#_idTextAnchor1503),
    *Analyzing Android Malware Samples*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Java 应用程序被编译成字节码，然后由**Java 虚拟机**（**JVM**）执行。这里的思想是，让经过一次编译的应用程序能够在所有支持的平台上使用，而无需做任何更改。市面上有多个
    JVM 实现，且在本文撰写时（从 Java 1.3 开始），HotSpot JVM 是默认的官方选项。它的特点是结合了解释器和 JIT 编译器，能够根据分析器的输出将字节码编译成本地机器指令，以加速代码中较慢部分的执行。大多数
    PC 用户通过安装**Java 运行环境**（**JRE**）来获取它，JRE 是一个软件发行包，包含独立的 JVM（HotSpot）、标准库和配置工具集。**Java
    开发工具包**（**JDK**）是另一个流行选项，因为它是一个开发环境，用于使用 Java 语言构建应用程序、小程序和组件。对于移动设备，过程则截然不同。我们将在[*第13章*](B18500_13.xhtml#_idTextAnchor1503)中讨论，*分析
    Android 恶意软件样本*。
- en: In terms of malware, Java is quite popular among **Remote Access Tool** (**RAT**)
    developers. Examples include jRAT or the Frutas/Adwind families distributed as
    JAR files. Exploits used to be another big problem for users until recent changes
    were introduced by the industry. In this section, we will explore the internals
    of the compiled Java files and learn how to analyze malware while leveraging it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件方面，Java 在**远程访问工具**（**RAT**）开发者中相当受欢迎。例如 jRAT 或者作为 JAR 文件分发的 Frutas/Adwind
    家族。利用漏洞曾经是用户面临的另一个大问题，直到行业近期引入了相关变更。在本节中，我们将探讨已编译 Java 文件的内部结构，并学习如何在分析恶意软件时利用它。
- en: File structure
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: Once compiled, text `.java` files become `.class` files and can be executed
    by the JVM straight away.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，`.java` 文件会变成 `.class` 文件，可以直接由 JVM 执行。
- en: 'Here is their structure according to the official documentation:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据官方文档提供的结构：
- en: '[PRE12]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The magic value that’s used in this case is a hexadecimal DWORD, `0xCAFEBABE`.
    The other fields are self-explanatory.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用的魔法值是一个十六进制 DWORD，`0xCAFEBABE`。其他字段是显而易见的。
- en: The most common way to release a more complex project is to build a JAR file
    that contains multiple compiled modules, as well as auxiliary metadata files such
    as `MANIFEST.MF`. JAR files follow the usual ZIP archive format and can be extracted
    using any unpacking software that supports it.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 发布一个更复杂项目的最常见方式是构建一个包含多个已编译模块以及辅助元数据文件（如 `MANIFEST.MF`）的 JAR 文件。JAR 文件遵循常规的
    ZIP 压缩格式，可以使用任何支持的解压软件进行提取。
- en: Finally, the `<jar>` field, which is a reference to the actual JAR file, and
    the `<applet-desc>` field, which, among other things, specifies the name of the
    main Java class to be loaded.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`<jar>` 字段是对实际 JAR 文件的引用，而 `<applet-desc>` 字段则指定了要加载的主 Java 类的名称等信息。
- en: There are numerous ways that Java-based samples can be analyzed. In this section,
    we are going to explore multiple options available for both static and dynamic
    analysis.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Java 基于的样本有多种分析方式。在本节中，我们将探讨静态和动态分析的多种选择。
- en: JVM instructions
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM 指令
- en: The list of supported instructions is very well-documented, so generally, it
    isn’t a problem to find information about any bytecode of interest. Let’s look
    at some examples of what they look like.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的指令列表有很好的文档记录，所以通常来说，查找任何感兴趣的字节码信息都不成问题。我们来看一些示例，看看它们的样子。
- en: 'Data transfer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输：
- en: '![](img/B18500_09_Table7.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table7.jpg)'
- en: 'Arithmetic and logical operations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑运算：
- en: '![](img/B18500_09_Table8.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table8.jpg)'
- en: 'Control flow:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流程：
- en: '![](img/B18500_09_Table9.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table9.jpg)'
- en: Interestingly enough, other projects can produce Java bytecode, such as JPython,
    which aims to compile Python files into Java-style bytecode. However, in reality,
    in the absolute majority of cases, working with them is not necessary as modern
    decompilers are doing their job extremely well.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，其他项目也可以生成 Java 字节码，例如 JPython，它旨在将 Python 文件编译成 Java 风格的字节码。然而，实际上，在绝大多数情况下，不需要处理它们，因为现代的反编译器已经做得非常出色。
- en: Static analysis
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'Since the Java bytecode remains the same across all platforms, it speeds up
    the process of creating high-quality decompilers as developers don’t have to spend
    much time supporting different architectures and operating systems. Here are some
    of the most popular tools available to the general public:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 字节码在所有平台上保持一致，它加快了高质量反编译器的创建过程，因为开发人员不必花费大量时间支持不同的架构和操作系统。以下是一些公众常用的工具：
- en: '`rt.jar` file from your Java folder via the `-path` argument when using it.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用时，通过`-path`参数指定来自 Java 文件夹的`rt.jar`文件。
- en: '**Procyon**: Another powerful decompiler, this can process both Java files
    and raw bytecode.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Procyon**：另一个强大的反编译器，可以处理 Java 文件和原始字节码。'
- en: '**FernFlower**: A Java decompiler that’s maintained as a plugin for IntelliJ
    IDEA. It has a command-line version as well.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FernFlower**：一个作为 IntelliJ IDEA 插件维护的 Java 反编译器。它也有命令行版本。'
- en: '**CFR**: A JVM bytecode decompiler written in Java that can process individual
    classes and entire JAR files as well.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CFR**：一个用 Java 编写的 JVM 字节码反编译器，可以处理单个类和整个 JAR 文件。'
- en: '**d4j**: A Java decompiler built on top of the Procyon project.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d4j**：一个建立在 Procyon 项目基础上的 Java 反编译器。'
- en: '**Ghidra**: This reverse-engineering toolkit supports multiple file formats
    and instruction sets, including Java bytecode:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ghidra**：这个逆向工程工具包支持多种文件格式和指令集，包括 Java 字节码：'
- en: '![Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.23 – 在 Ghidra 中反汇编和反编译的 Java 字节码'
- en: '](img/Figure_9.23_B18500.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.23_B18500.jpg)'
- en: Figure 9.23 – Disassembled and decompiled Java bytecode in Ghidra
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 在 Ghidra 中反汇编和反编译的 Java 字节码
- en: '**JD Project**: A venerable Java decompiler project, this provides a set of
    tools for analyzing Java bytecode. It includes a library called **JD-Core**, a
    standalone tool called **JD-GUI**, and several plugins for major IDEs.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JD Project**：一个久负盛名的 Java 反编译项目，它提供了一组用于分析 Java 字节码的工具。包括一个名为**JD-Core**的库，一个名为**JD-GUI**的独立工具，以及多个主要
    IDE 的插件。'
- en: '**JAD**: A classic decompiler that has assisted generations of reverse engineers
    with Java malware analysis. It’s now discontinued:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAD**：一个经典的反编译器，曾帮助几代逆向工程师进行 Java 恶意软件分析。现已停用：'
- en: '![Figure 9.24 – Decompiled code of the Adwind RAT malware written in Java'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.24 – 反编译的 Adwind RAT 恶意软件的 Java 代码'
- en: '](img/Figure_9.24_B18500.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.24_B18500.jpg)'
- en: Figure 9.24 – Decompiled code of the Adwind RAT malware written in Java
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 反编译的 Adwind RAT 恶意软件的 Java 代码
- en: It always makes sense to try several different projects and compare their output
    since all of them implement different techniques, so the quality may vary, depending
    on the input sample.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多个不同的项目并比较它们的输出是有意义的，因为它们实现了不同的技术，因此质量可能有所不同，具体取决于输入的样本。
- en: To know where to start the analysis, look inside the `MANIFEST.MF` file as it
    will indicate from which class of the corresponding JAR sample the execution will
    start (the `Main-Class` field).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道从哪里开始分析，可以查看`MANIFEST.MF`文件，它将指示从相应 JAR 样本中的哪个类开始执行（`Main-Class`字段）。
- en: Finally, if necessary, Java bytecode disassembly can be obtained using a standard
    `-c` argument.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要，可以使用标准的`-c`参数获取 Java 字节码的反汇编。
- en: Dynamic analysis
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分析
- en: 'Modern decompilers generally produce a reasonably high-quality output, which,
    after minor modifications, can be read and debugged as any usual Java source code.
    Multiple IDEs support Java that provide debugging options for this purpose: Eclipse,
    NetBeans, IntelliJ IDEA, and others.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现代反编译器通常能生成相当高质量的输出，经过少量修改后，可以像普通的 Java 源代码一样读取和调试。多个 IDE 支持 Java，并提供调试选项：Eclipse、NetBeans、IntelliJ
    IDEA 等。
- en: If the original bytecode tracing is required, it is possible to achieve this
    with the `-XX:+TraceBytecodes` option, which is available for debug builds of
    the HotSpot JVM. If step-by-step bytecode debugging is required, then Dr. Garbage’s
    **Bytecode Visualizer** plugin for Eclipse IDE appears to be extremely handy.
    It allows you to not only see the disassembly of the compiled modules inside the
    JAR but also debug them.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要原始字节码追踪，可以使用 `-XX:+TraceBytecodes` 选项，这对于 HotSpot JVM 的调试版本是可用的。如果需要逐步调试字节码，Dr.
    Garbage 的 **Bytecode Visualizer** 插件在 Eclipse IDE 中显得非常有用。它不仅可以查看 JAR 内部编译模块的反汇编代码，还能进行调试。
- en: Dealing with anti-reverse engineering solutions
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理反逆向工程解决方案
- en: At the time of writing, there is an impressive number of commercial obfuscators
    for Java available on the market. As for malware developers, many of them use
    either cracked versions or demos and leaked licenses. An example is Allatori Obfuscator,
    which is misused by Adwind RAT.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，市场上有大量商业化的 Java 混淆器可用。至于恶意软件开发者，他们中的许多人使用的是破解版本、演示版或泄露的许可证。例如，Allatori
    Obfuscator 被 Adwind RAT 恶意软件滥用。
- en: 'When the obfuscator’s name is confirmed (for example, by unique strings), it
    generally makes sense to check whether any of the existing deobfuscation tools
    support it. Here are some of them:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当确认了混淆器的名称（例如，通过唯一的字符串），通常需要检查是否有现成的去混淆工具支持它。以下是一些常见的工具：
- en: '**Java Deobfuscator**: A versatile project that supports a decent amount of
    commercial protectors'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Deobfuscator**：一个多功能项目，支持大量商业保护器。'
- en: '**JMD**: A Java bytecode analysis and deobfuscation tool that can remove obfuscation
    implemented by multiple well-known protectors'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JMD**：一个 Java 字节码分析与去混淆工具，能够去除多种知名保护器实施的混淆。'
- en: '**Java DeObfuscator** (**JDO**): A general-purpose deobfuscator that implements
    several universal techniques, such as renaming obfuscated values to be unique
    and indicative of their data type'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java DeObfuscator** (**JDO**)：一款通用去混淆工具，实施多种通用技术，比如将混淆后的值重命名为唯一且能表示其数据类型的名称。'
- en: '**jrename**: Another universal deobfuscator that specializes in renaming values
    to make the code more readable'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jrename**：另一种通用的去混淆工具，专门用于重命名变量，以提高代码的可读性。'
- en: If nothing ready-to-use has been found, it makes sense to search for articles
    covering this particular obfuscator as they may give you valuable insight into
    how it works and what approach is worth trying.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有现成可用的工具，建议寻找相关文章，了解该混淆器的工作原理以及哪些方法值得尝试，它们可能会提供宝贵的见解。
- en: If no information has been found, then it is time to explore the logic behind
    the obfuscator from scratch, trying to get the most valuable information first,
    such as strings and then the bytecode. The more information that can be collected
    about the obfuscator, the less time will be spent on the analysis itself later.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到相关信息，则需要从头开始探索混淆器的逻辑，尽量先获取最有价值的信息，如字符串，然后是字节码。收集到的关于混淆器的信息越多，后续分析时花费的时间就越少。
- en: That’s it for Java-based threats. Now, let’s talk about malware written in Python.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以上就是关于 Java 基础的威胁分析，现在，让我们来讨论用 Python 编写的恶意软件。
- en: Analyzing compiled Python threats
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析编译后的 Python 威胁
- en: Python is a high-level general-purpose language that debuted in 1990 and since
    that time has gone through several development iterations. At the time of writing,
    there are two branches actively used by the public, Python 2 and Python 3, which
    are not fully compatible. The language itself is extremely robust and easy to
    learn, which eventually lets engineers prototype and develop ideas rapidly.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种高级通用编程语言，首次亮相于 1990 年，自那时以来经历了多个开发迭代。截止本文撰写时，公众常用的有两个分支，Python 2 和
    Python 3，它们并不完全兼容。该语言本身非常强大且易于学习，这使得工程师能够快速原型化并开发出创意。
- en: As for why compiled Python is used by malware authors when there are so many
    other languages, this language is cross-platform, which allows an existing application
    to be easily ported to multiple platforms. It is also possible to create executables
    from Python scripts using tools such as **py2exe** and **PyInstaller**.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 至于为什么恶意软件作者使用编译过的 Python，尽管有许多其他语言，这主要是因为该语言跨平台，允许现有应用程序轻松移植到多个平台。通过使用 **py2exe**
    和 **PyInstaller** 等工具，还可以将 Python 脚本转换为可执行文件。
- en: You may be wondering, why is Python being covered in this chapter when it is
    a scripting language? The truth is, whether the programming language uses bytecode
    or not depends on the actual implementation and not on the language itself. Active
    Python users may notice files with the `.pyc` extension appearing, for example,
    when the Python modules get imported. These files contain the code that’s been
    compiled into Python’s bytecode language and can be used for various purposes,
    including malicious ones. In addition, the executables that are generated from
    Python projects can generally be reverted to these bytecode modules first.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么本章要涉及 Python，毕竟它是一个脚本语言？事实上，是否使用字节码取决于实际实现，而不是语言本身。活跃的 Python 用户可能会注意到，当
    Python 模块被导入时，出现了带有 `.pyc` 扩展名的文件。这些文件包含了已经编译为 Python 字节码语言的代码，可以用于各种目的，包括恶意目的。此外，从
    Python 项目生成的可执行文件通常可以先还原为这些字节码模块。
- en: In this section, we will explain how such samples can be analyzed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何分析这些示例。
- en: File structure
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: 'There are three types of compiled files associated with Python: `.pyc`, `.pyo`,
    and `.pyd`. Let’s go through the differences between them:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 相关的已编译文件有三种类型：`.pyc`、`.pyo` 和 `.pyd`。让我们来了解它们之间的区别：
- en: '`.pyc`: These are standard compiled bytecode files that can be used to make
    future module importing easier and faster'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pyc`：这些是标准的已编译字节码文件，可用于加快将来模块的导入速度。'
- en: '`.pyo`: These are compiled bytecode files that are built with the `-O` (or
    `-OO`) option, which is responsible for introducing optimizations that affect
    the speed they will be loaded (not executed)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pyo`：这些是使用 `-O`（或 `-OO`）选项构建的已编译字节码文件，负责引入影响加载速度的优化（不是执行速度）。'
- en: '`.pyd`: These are traditional Windows DLL files that implement the MZ-PE structure
    (for Linux, it will be `.so`)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pyd`：这些是实现 MZ-PE 结构的传统 Windows DLL 文件（对于 Linux，则是 `.so` 文件）。'
- en: Since MZ-PE files have been covered multiple times throughout this book, we
    won’t talk about them too much, nor spend much time on `.pyd` files. Their main
    feature is having a specific name for the initialization routine that should match
    the name of the module.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MZ-PE 文件在本书中已多次提及，我们不会详细讨论它们，也不会花太多时间讲解 `.pyd` 文件。它们的主要特点是具有一个特定名称的初始化例程，该名称应与模块的名称匹配。
- en: Particularly, if you have a module named `foo.pyd`, it should export a function
    called `initfoo` so that later, when imported using the `import foo` statement,
    Python can search for the module with such a name and know the name of the initialization
    function to be loaded.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果你有一个名为 `foo.pyd` 的模块，它应该导出一个名为 `initfoo` 的函数，这样当使用 `import foo` 语句导入时，Python
    就能搜索到具有此名称的模块，并知道要加载的初始化函数的名称。
- en: 'Now, let’s focus on the compiled bytecode files. Here is the structure of the
    `.pyc` file:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注已编译的字节码文件。以下是 `.pyc` 文件的结构：
- en: '![](img/B18500_09_Table10.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18500_09_Table10.jpg)'
- en: Interestingly enough, the `.pyc` modules are platform independent, but at the
    same time Python version-dependent. Thus, `.pyc` files can easily be transferred
    between systems with the same Python version installed, but files that are compiled
    using one version of Python generally can’t be used by another version of Python,
    even on the same system.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`.pyc` 模块是平台独立的，但同时依赖于 Python 版本。因此，`.pyc` 文件可以轻松地在安装了相同 Python 版本的系统之间传输，但使用一个版本的
    Python 编译的文件通常不能在另一个版本的 Python 上使用，即使是在同一系统上。
- en: Bytecode instructions
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码指令
- en: The official Python documentation describes the bytecode that’s used in both
    versions 2 and 3\. In addition, since it is open source software, all bytecode
    instructions for a particular Python version can be also found in the corresponding
    source code files, mainly `ceval.c`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Python 文档描述了 Python 2 和 3 中使用的字节码。此外，由于它是开源软件，特定 Python 版本的所有字节码指令也可以在相应的源代码文件中找到，主要是
    `ceval.c`。
- en: 'The differences between the bytecode that’s used in Python 2 and 3 aren’t that
    drastic, but still noticeable. For example, some instructions that were implemented
    for version 2 are gone in version 3 (such as `STOP_CODE`, `ROT_FOUR`, `PRINT_ITEM`,
    `PRINT_NEWLINE/PRINT_NEWLINE_TO`, and so on):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2 和 3 使用的字节码之间的差异并不显著，但仍然可以察觉。例如，一些为版本 2 实现的指令在版本 3 中消失了（如 `STOP_CODE`、`ROT_FOUR`、`PRINT_ITEM`、`PRINT_NEWLINE/PRINT_NEWLINE_TO`
    等）：
- en: '![Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by
    Python 2 and 3'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.25 – 由 Python 2 和 3 生成的相同 HelloWorld 脚本的不同字节码]'
- en: '](img/Figure_9.25_B18500.png)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.25_B18500.png)'
- en: Figure 9.25 – Diﬀerent bytecode for the same HelloWorld script produced by Python
    2 and 3
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 由 Python 2 和 3 生成的相同 HelloWorld 脚本的不同字节码
- en: 'Here are the groups of instructions that are used in the official documentation
    for Python 3, along with some examples:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是官方文档中使用的 Python 3 指令组，并附带一些示例：
- en: '`NOP`: Do nothing (generally used as a placeholder)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOP`：什么也不做（通常作为占位符使用）'
- en: '`POP_TOP`: Removes the top value from the stack'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POP_TOP`：移除栈顶的值'
- en: '`ROT_TWO`: Swaps the top items on the stack'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROT_TWO`：交换栈顶的两个项'
- en: '`UNARY_POSITIVE`: Increment*   `UNARY_NOT`: Logical `NOT` operation*   `UNARY_INVERT`:
    Inversion*   `BINARY_MULTIPLY`: Multiplication*   `BINARY_ADD`: Addition*   `BINARY_XOR`:
    XOR operation*   `INPLACE_MULTIPLY`: Multiplication*   `INPLACE_SUBTRACT`: Subtraction*   `INPLACE_RSHIFT`:
    Right shift operation*   `GET_AITER`: Call the `get_awaitable` function for the
    output of the `__aiter__()` method of the top item on the stack*   `SETUP_ASYNC_WITH`:
    Create a new frame object*   `BREAK_LOOP`: Terminate a loop*   `SET_ADD`: Add
    the top item on the stack to the set specified by the second item*   `MAKE_FUNCTION`:
    Push a new function object to the stack'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNARY_POSITIVE`：增量*   `UNARY_NOT`：逻辑 `NOT` 操作*   `UNARY_INVERT`：反转*   `BINARY_MULTIPLY`：乘法*   `BINARY_ADD`：加法*   `BINARY_XOR`：异或操作*   `INPLACE_MULTIPLY`：乘法*   `INPLACE_SUBTRACT`：减法*   `INPLACE_RSHIFT`：右移操作*   `GET_AITER`：调用
    `get_awaitable` 函数，获取栈顶项的 `__aiter__()` 方法的输出*   `SETUP_ASYNC_WITH`：创建一个新的帧对象*   `BREAK_LOOP`：终止循环*   `SET_ADD`：将栈顶项添加到由第二项指定的集合中*   `MAKE_FUNCTION`：将一个新的函数对象推入栈中'
- en: The bytecode instruction names are quite self-explanatory. For the exact syntax,
    please consult the official documentation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码指令名称是非常直观的。有关准确的语法，请查阅官方文档。
- en: After discussing the various aspects of Python as a scripting language, we will
    now pay attention to how to analyze compiled Python code. In this section, we
    will go through the practical analysis techniques from a Python perspective.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 Python 作为脚本语言的各个方面之后，我们将重点介绍如何分析编译过的 Python 代码。在这一部分，我们将从 Python 的角度介绍一些实际的分析技巧。
- en: Static analysis
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'In many cases, the analysts don’t get the compiled Python modules straight
    away. Instead, they get a sample, which is a set of Python scripts that’s been
    converted into an executable using either py2exe or PyInstaller solutions. So,
    before digging into bytecode modules themselves, we need to obtain bytecode modules.
    Luckily, several projects can perform this task:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，分析人员并不会直接获得编译后的 Python 模块。相反，他们会得到一个样本，这个样本是一组 Python 脚本，通过 py2exe 或
    PyInstaller 工具被转换成了可执行文件。所以，在深入研究字节码模块之前，我们需要先获取这些字节码模块。幸运的是，有几个项目可以执行这个任务：
- en: '**unpy2exe.py**: This script can handle samples built using py2exe'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unpy2exe.py**：这个脚本可以处理使用 py2exe 构建的样本。'
- en: '**pyinstxtractor.py**: As the name suggests, this tool can be used to extract
    Python modules from the executables built using the PyInstaller solution'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pyinstxtractor.py**：顾名思义，这个工具可以用来从使用 PyInstaller 构建的可执行文件中提取 Python 模块。'
- en: An open source project called **python-exe-unpacker** combines both of these
    tools and can be run against the executable sample without any extra checks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **python-exe-unpacker** 的开源项目结合了这两个工具，可以直接对可执行文件样本进行处理，无需额外检查。
- en: After extracting the files that were packed using **PyInstaller**, there is
    one moment that can be quite frustrating for anybody who just started analyzing
    compiled Python files. In particular, the main extracted module may be missing
    the first few bytes preceding the marshaled code (see the preceding table for
    the exact number that depends on the Python version), so it can’t be processed
    by other tools straight away. The easiest way to handle this is to take them from
    any compiled file on the current machine and then add them there using any hex
    editor. Such a file can be created by importing (not executing) a simple Hello
    World script.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取使用 **PyInstaller** 打包的文件后，对于刚开始分析编译过的 Python 文件的人来说，有一个步骤可能会让人感到非常沮丧。特别是，主要的提取模块可能缺失了编译代码前面的一些字节（具体数量取决于
    Python 版本，请参见前面的表格），因此不能直接被其他工具处理。处理这个问题的最简单方法是从当前机器上的任何编译文件中获取这些字节，然后使用十六进制编辑器将它们添加到提取的文件中。可以通过导入（而不是执行）一个简单的
    Hello World 脚本来创建这样的文件。
- en: 'Since analyzing Python source code is pretty straightforward, it makes sense
    to stick to this option where possible. In this case, the decompilers, which can
    restore the original code, appear to be extremely useful. At the time of writing,
    multiple options are available:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析Python源代码相对简单，因此在可能的情况下坚持这种方式是有意义的。在这种情况下，能够恢复原始代码的反编译器显得特别有用。本文写作时，已有多个选项可供选择：
- en: '**uncompyle6**: An open source native Python decompiler that supports multiple
    versions of it. It does exactly what it promises – translates bytecode back into
    equivalent source code. There were several older projects preceding it (decompyle,
    uncompyle, and uncompyle2).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uncompyle6**：一个开源的本地Python反编译器，支持多个版本的Python。它正如其承诺的那样——将字节码转换回等效的源代码。它之前有几个较旧的项目（decompyle、uncompyle和uncompyle2）。'
- en: '**decompyle3**: A reworking of the uncompyle6 project that supports Python
    versions 3.7+'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**decompyle3**：uncompyle6项目的改进版，支持Python 3.7及以上版本。'
- en: '**Decompyle++ (also known as pycdc)**: A disassembler and decompiler written
    in C++, it seeks to support bytecode from any version of Python.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Decompyle++（也称为pycdc）**：一个用C++编写的反汇编器和反编译器，旨在支持任何版本Python的字节码。'
- en: '**Meta**: A Python framework that allows you to analyze Python bytecode and
    syntax trees.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Meta**：一个Python框架，允许你分析Python字节码和语法树。'
- en: '**UnPYC**: A versatile GUI tool for Python decompiling that relies on other
    projects to do the actual code restoration.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UnPYC**：一个多功能的Python反编译GUI工具，依赖其他项目来进行实际的代码恢复。'
- en: After obtaining the source code, it can be reviewed in any text editor with
    convenient syntax highlighting or an IDE of your choice.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 获取源代码后，可以在任何文本编辑器中进行查看，该编辑器具备便捷的语法高亮功能，或者使用您选择的IDE。
- en: However, in certain cases, the decompiling process is not possible straight
    away. For example, when the module was built using the newest version of Python,
    it became corrupted during a transfer, partial decoding/decryption, or maybe due
    to some anti-reverse engineering technique. Such tasks can also be found in some
    CTF competitions. In this case, the engineer has to stick to analyzing the bytecode.
    Apart from the tools we mentioned previously, the `marshal.load` and `dis.disassemble`
    methods can be used to translate the bytecode into a readable format.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，反编译过程无法立即进行。例如，当模块是使用最新版本的Python构建时，它可能在传输过程中损坏，或部分解码/解密，亦或由于某些反逆向工程技术的影响。这类任务也常见于一些CTF竞赛中。在这种情况下，工程师必须坚持分析字节码。除了我们之前提到的工具，`marshal.load`和`dis.disassemble`方法也可以用来将字节码转换成可读格式。
- en: Dynamic analysis
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分析
- en: In terms of dynamic analysis, usually, the output of decompilers can be executed
    straight away. Step-by-step execution is supported by any major IDE that supports
    the Python language. In addition, step-by-step debugging is possible with the
    **trepan2/trepan3k** debugger (for recent versions of Python 2 and 3, respectively),
    which automatically uses uncompyle6 if there is no source code available. For
    Python before 2.6, the older packages, **pydbgr** and **pydb**, can be used.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分析方面，通常，反编译器的输出可以直接执行。任何支持Python语言的主要IDE都支持逐步执行。此外，通过**trepan2/trepan3k**调试器（分别适用于Python
    2和3的最新版本），可以进行逐步调试。如果没有源代码可用，它会自动使用uncompyle6。对于Python 2.6之前的版本，可以使用较旧的工具包，**pydbgr**和**pydb**。
- en: 'If there is a necessity to trace the bytecode, there are several ways it can
    be handled, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要跟踪字节码，可以通过以下几种方式进行处理：
- en: '`ceval.c` file is amended to process (for example, print) executed instructions.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceval.c`文件被修改以处理（例如，打印）已执行的指令。'
- en: '**Amending the .pyc file itself**: Here, the source code line numbers are replaced
    with the index of each byte, which eventually allows you to trace executed bytecode.
    Ned Batchelder covered this technique in his *Wicked hack: Python bytecode tracing*
    article.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改.pyc文件本身**：在这里，源代码行号被替换为每个字节的索引，这最终允许你跟踪已执行的字节码。Ned Batchelder在他的文章*《恶意黑客：Python字节码追踪》*中介绍了这一技术。'
- en: There are also existing projects such as `.pyc` files with a header format that’s
    generated by the current version of Python 2, so update it if necessary).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些现有的项目，例如 `.pyc` 文件，具有由当前版本的Python 2生成的头文件格式，因此如果有必要，请进行更新。
- en: 'Some examples of common anti-reverse engineering techniques include doing the
    following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的反逆向工程技术示例包括：
- en: Manipulating non-existing values on the stack
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操控堆栈上不存在的值
- en: Setting up a custom exception handler (for this purpose, the `SETUP_EXCEPT`
    instruction can be used)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自定义异常处理程序（为此，可以使用`SETUP_EXCEPT`指令）
- en: When editing the bytecode (for example, to get rid of anti-debugging or anti-decompiling
    techniques or to restore a corrupted code block), the `dis.opmap` mapping appears
    to be extremely useful to find the binary values of opcodes and later replace
    them, and the `bytecode_graph` module can be used to seamlessly remove unwanted
    values.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑字节码时（例如，去除反调试或反反编译技术，或恢复损坏的代码块），`dis.opmap`映射在查找操作码的二进制值并替换它们时非常有用，`bytecode_graph`模块可以无缝地移除不需要的值。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamental theory of bytecode languages. We
    learned what their use cases are and how they work from the inside. Then, we dived
    deep into the most popular bytecode languages used by modern malware families,
    explained how they operate, and looked at their unique specifics that need to
    be paid attention to. Finally, we provided detailed guidelines on how such malware
    can be analyzed and the tools that can facilitate this process.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了字节码语言的基本理论。我们了解了它们的使用场景以及它们如何从内部工作。然后，我们深入探讨了现代恶意软件家族中使用的最流行的字节码语言，解释了它们的工作原理，并分析了它们的独特细节，指出了需要特别关注的方面。最后，我们提供了关于如何分析此类恶意软件的详细指南，以及可以帮助这一过程的工具。
- en: Equipped with this knowledge, you can analyze malware of this kind and get an
    invaluable insight into how it may affect victims’ systems.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你可以分析这种类型的恶意软件，并深入了解它可能如何影响受害者的系统。
- en: In [*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106), *Scripts and Macros –
    Reversing, Deobfuscation, and Debugging*, we are going to cover various script
    and macros languages, explore the malware that misuses them, and find interesting
    links between them, as well as already covered technologies.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18500_10.xhtml#_idTextAnchor1106)，《脚本与宏 - 逆向工程、去混淆与调试》中，我们将涵盖各种脚本和宏语言，探索恶意软件如何滥用它们，并找出它们之间以及与已讲解技术之间的有趣联系。
