- en: Network Penetration Testing - Gaining Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络渗透测试 - 获取访问权限
- en: So far in this book, we haven't needed to connect to a network for anything.
    In this chapter, as we take a step toward learning network penetration testing,
    we will connect to a network. This will allow us to launch more powerful attacks
    and get more accurate information. If a network doesn't use encryption (in other
    words, if it's an open wireless network), we can connect to it and sniff out unencrypted
    data. If a network is wired, we can still try to connect to it, perhaps through
    changing our MAC address. The main issue we might encounter is a network using
    encryption (such as WEP, WPA, or WPA2). If we do encounter encrypted data, we
    need to know the key to decrypt it, that's the main purpose of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们并不需要连接到网络进行任何操作。在这一章中，随着我们迈出学习网络渗透测试的步伐，我们将连接到网络。这将使我们能够发起更强大的攻击并获得更准确的信息。如果一个网络没有加密（换句话说，它是一个开放的无线网络），我们可以连接到它并嗅探未加密的数据。如果是有线网络，我们仍然可以尝试连接它，可能通过更改我们的
    MAC 地址。我们可能遇到的主要问题是网络使用了加密（例如 WEP、WPA 或 WPA2）。如果我们遇到加密数据，我们需要知道密钥来解密它，这也是本章的主要目的。
- en: If your target network uses some sort of encryption, you can't really get anywhere
    unless you decrypt it. In this chapter, we will discuss how to decrypt WEP, WPA,
    and WPA2 encryptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标网络使用某种加密方式，你无法进行任何操作，除非解密它。在这一章中，我们将讨论如何解密 WEP、WPA 和 WPA2 加密。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: WEP theory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WEP 理论
- en: Basic web cracking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础网页破解
- en: Fake authentication attack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假认证攻击
- en: ARP request replay
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARP 请求重放
- en: WPA introduction
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPA 介绍
- en: WPA cracking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPA 破解
- en: Handshake theory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 握手理论
- en: Capturing handshakes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获握手
- en: Creating wordlists
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字典
- en: Wordlist cracking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典破解
- en: Securing network from attacks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护网络免受攻击
- en: WEP theory
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WEP 理论
- en: The first encryption that we will discuss is **Wired Equivalent Privacy** (**WEP**)
    encryption, because it's the oldest one, and also the easiest one to break. WEP
    encryption uses an algorithm called RC4; each packet is encrypted at the **Access
    Point** (**AP**), and then sent out into the air. Once the client receives it,
    the client will be able to decrypt the packet and read the information inside
    of it, since the client has the key. In short, the APencrypts the packet and sends
    it, and the client receives and decrypts it. In the same way, when the client
    itself sends the packet, the client encrypts it and then sends it out, and the
    AP receives and decrypts it with a key.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个加密方式是**有线等效隐私**（**WEP**）加密，因为它是最古老的加密方式，也是最容易破解的。WEP 加密使用一种叫做 RC4 的算法；每个数据包都在**接入点**（**AP**）加密，然后发送到空中。一旦客户端接收到数据包，客户端就能解密数据包并读取其中的信息，因为客户端拥有密钥。简而言之，AP
    加密数据包并发送出去，客户端接收并解密它。同样，当客户端自身发送数据包时，客户端加密数据包然后发送出去，AP 接收并使用密钥解密它。
- en: Each packet that is sent out has a unique key stream. WEP ensures that the key
    stream is unique by using a 24-bit **Initialization Vector** (**IV**). The IV
    is a random number that is sent into each packet in plain text, which is not encrypted.
    If we read the packet, we will be able to read a part of it in plain text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发送的数据包都有一个唯一的密钥流。WEP 通过使用 24 位**初始化向量**（**IV**）来确保密钥流的唯一性。IV 是一个随机数，它以明文形式发送到每个数据包中，未加密。如果我们读取该数据包，就能以明文方式读取其中的一部分。
- en: The problem with the IV is that it's very short (24-bits, which is not that
    long). In a busy network, there will be a very large number of packets sent, the
    possibilities of random IVs will be exhausted, and we will end up with two packets
    that have the same IV. If this happens, we can employ `aircrack-ng`, which uses
    statistical attacks to determine key streams; it will be able to determine the
    WEP key.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: IV 的问题在于它非常短（24位，长度不算长）。在一个繁忙的网络中，会发送大量的数据包，随机 IV 的可能性会被耗尽，最终会出现两个数据包具有相同的 IV。如果发生这种情况，我们可以使用
    `aircrack-ng`，它通过统计攻击来确定密钥流；它能够确定 WEP 密钥。
- en: From the preceding information, we know that the more IVs we collect, the more
    likely we'll be to successfully crack the WEP key. Our main goal, when we try
    to crack WEP, is to collect as many IVs as we can—because when we have a large
    number of IVs, we will end up with two packets that use the same IV, and `aircrack-ng`
    will be likely to determine the key stream and the WEP key for the target network.
    In the next part of this chapter, we will see how this actually works, and it
    should be easier to understand.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的信息中，我们知道，收集的IV数量越多，我们破解WEP密钥成功的可能性就越大。我们尝试破解WEP的主要目标是尽可能多地收集IV，因为当我们收集到大量的IV时，就会出现两个使用相同IV的包，`aircrack-ng`就能通过这些包确定密钥流和目标网络的WEP密钥。在本章的下一部分，我们将看到这个过程如何实际工作，应该会更容易理解。
- en: Basic web cracking
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的WEP破解
- en: Through the previous section, we know that to crack a WEP key, all we have to
    do is sniff packets from the target network and gather as many IVs as possible.
    Once we have done that, `aircrack-ng` will be able to use statistical attacks
    to determine the key stream and the WEP key for the target network. Obviously,
    when we have more than two packets, the method is going to work better, and our
    chances of breaking the key will be higher—we're going to try to gather as many
    IVs as possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的部分，我们知道，破解WEP密钥所要做的就是嗅探目标网络的数据包并尽可能多地收集IV。一旦完成这些操作，`aircrack-ng`就能利用统计攻击来确定目标网络的密钥流和WEP密钥。显然，当我们拥有超过两个数据包时，这种方法会更有效，我们破解密钥的成功几率会更高——我们将尽量收集尽可能多的IV。
- en: 'Let''s look at the most basic case of cracking a WEP key. Wi-Fi card must be
    in monitor mode, and the first thing we''re going to try to do is see all of the
    networks that are within our Wi-Fi range; then, we''re going to target one of
    those networks. We''re going to run `airodump-ng wlan0`, very basic command, where
    `wlan0` stands for the interface. Following will be displayed as a output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最基本的破解WEP密钥的案例。Wi-Fi卡必须处于监控模式，我们要做的第一件事是查看所有在我们Wi-Fi范围内的网络；然后，我们将选定其中一个网络作为目标。我们将运行`airodump-ng
    wlan0`，这是一个非常基础的命令，其中`wlan0`代表接口。以下将作为输出显示：
- en: '![](assets/9b5bbad8-bb43-45ec-a170-496480a5f541.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9b5bbad8-bb43-45ec-a170-496480a5f541.png)'
- en: 'The first network that has come up is `Test`; this is the network that we''re
    going to perform our attacks on. We''re going to launch `airodump` against `Test`
    network by using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个出现的网络是`Test`；这是我们将要进行攻击的网络。我们将使用以下命令对`Test`网络启动`airodump`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we enter the `--bssid` and launch an `airodump` against `Test` AP. We
    include the `--channel`, number `11`, and we add `--write` to store all of the
    packets that we capture into a file, which is `basic-test-ap`. As we run the preceding
    command, we will be able to see the output in the following screenshot, the target
    network that we have as the data we gathered it is quite a busy one, also the
    data and the frames are going:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们输入`--bssid`并对`Test`接入点启动`airodump`。我们包括`--channel`频道号`11`，并添加`--write`来将我们捕获到的所有数据包存储到一个名为`basic-test-ap`的文件中。当我们运行上述命令时，我们将能够看到以下屏幕截图中的输出，我们收集到的数据很繁忙，而且数据和帧正在传输：
- en: '![](assets/73eeae7a-5cf4-4f43-ba26-0dafe7066869.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/73eeae7a-5cf4-4f43-ba26-0dafe7066869.png)'
- en: 'It is a busy network; the following is the section where we can see the clients:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个繁忙的网络；以下是我们可以看到客户端的部分：
- en: '![](assets/7739e539-c2ea-4ad4-a3c9-eb52bd096a68.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7739e539-c2ea-4ad4-a3c9-eb52bd096a68.png)'
- en: 'All we have to do now is launch `aircrack-ng`, which is part of the `aircrack`
    suite, against the file that `airodump` has created for us. We can launch `aircrack`
    against it even if we didn''t stop `airodump`; it will keep reading the file,
    and it will read the new packets that `airodump` is capturing. The command to
    use is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的就是启动`aircrack-ng`，这是`aircrack`套件的一部分，针对`airodump`为我们创建的文件进行攻击。即使我们没有停止`airodump`，也可以对该文件启动`aircrack`；它会继续读取文件，并读取`airodump`正在捕获的新数据包。使用的命令如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we use `aircrack-ng`, we will put in the filename `basic-test-ap-01.cap`. While
    the file is still being created, getting larger and larger with the inclusion
    of new packets, we can run `aircrack-ng`, and it will keep getting updated, eventually
    giving us the password we need for cracking. If `aircrack` fails to determine
    the key, `aircrack` waits until it reaches 5,000 IVs, and then tries again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `aircrack-ng` 时，我们将输入文件名 `basic-test-ap-01.cap`。在文件仍在创建中，随着新数据包的不断加入文件越来越大时，我们可以运行
    `aircrack-ng`，它会不断更新，最终给出我们破解所需的密码。如果 `aircrack` 未能确定密钥，它会等待直到达到 5000 个 IV，然后再试一次。
- en: 'The number of IVs actually depends on the type of WEP encryption. There are
    two types of WEP encryption: 128-bit and 64-bit. The only difference is the length
    of the key; obviously, 64-bit requires a lower number of IVs than 128-bit. Remember
    that when we discussed `aircrack`, we indicated that the more packets we get without
    unique IVs, the higher our chances of cracking the WEP key are.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IV 的数量实际上取决于 WEP 加密的类型。WEP 加密有两种类型：128 位和 64 位。唯一的区别是密钥的长度；显然，64 位需要的 IV 数量低于
    128 位。记住我们在讨论 `aircrack` 时曾指出，获得的无唯一 IV 的数据包越多，我们破解 WEP 密钥的机会就越大。
- en: 'Now, we basically wait until `aircrack` can successfully crack the WEP key.
    Once it decrypts the key, we can press *Ctrl + C*. As we can see in the following
    screenshot, `aircrack` has successfully managed to get the key within data packets;
    this is because the target AP uses a 64-bit key:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基本上在等待 `aircrack` 成功破解 WEP 密钥。一旦它解密了密钥，我们可以按 *Ctrl + C*。如以下截图所示，`aircrack`
    已成功在数据包中找到了密钥；这是因为目标 AP 使用的是 64 位密钥：
- en: '![](assets/b7ac1328-df6d-44dc-8178-9c5eb08589d8.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7ac1328-df6d-44dc-8178-9c5eb08589d8.png)'
- en: 'Let''s look at how we can use this key to connect to the network. We are going
    to copy the key and use the key too connect. We can then connect to the target
    network:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个密钥连接到网络。我们将复制密钥并使用该密钥进行连接。然后我们就可以连接到目标网络：
- en: '![](assets/169fc046-5bc5-4a90-9079-a626f556d06a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/169fc046-5bc5-4a90-9079-a626f556d06a.png)'
- en: 'As you can see, our connection has been established; we successfully recovered
    the WEP key from the target network. We can go ahead and confirm by pinging Google:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的连接已经建立；我们成功地从目标网络恢复了 WEP 密钥。我们可以通过 ping Google 来确认：
- en: '![](assets/2daa0386-1c60-4ddf-ae43-c38798733b7a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2daa0386-1c60-4ddf-ae43-c38798733b7a.png)'
- en: Fake authentication attack
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假身份认证攻击
- en: In the previous section, we saw how easy it is to crack a WEP key on a busy
    network. In a busy network, the data increases very quickly. The problem is that
    we're now going to fake as an AP that doesn't have any clients connected to it,
    or an AP that has a client connected to it, but the client is not using the network
    as heavily as the client in the previous section (perhaps the client is just reading
    articles or going on Facebook, not using as much data as we saw last time).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们看到在繁忙的网络中破解 WEP 密钥是多么容易。在繁忙的网络中，数据增长非常迅速。问题是，我们现在要伪装成一个没有任何客户端连接的 AP，或者一个虽然有客户端连接，但该客户端使用网络的频率比上一部分的客户端低（可能该客户端只是在阅读文章或浏览
    Facebook，并没有像上次那样使用大量数据）的 AP。
- en: Let's look at an example. We will run `airodump` against the target AP, `Test`,
    to take a look at an idle AP. We now have `Test`, the same AP that we used before,
    but the difference is that we've disconnected the device that was connected. As
    we can see, in the second area (the client area), there are no clients connected.
    Also, we can see that the `#Data` is `0`—it didn't even go to `1`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个例子。我们将对目标 AP `Test` 运行 `airodump`，来查看一个空闲的 AP。现在我们有了 `Test`，就是之前使用过的那个 AP，但不同的是我们已经断开了之前连接的设备。如我们所见，在第二个区域（客户端区域），没有客户端连接。同时，我们还可以看到
    `#Data` 是 `0`——它甚至没有到达 `1`。
- en: 'This will be the problem that we''ll face—we want to be able to crack a key
    like this, with `0` data:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们面临的问题——我们希望能够破解像这样具有 `0` 数据的密钥：
- en: '![](assets/a4433ed4-b74a-4348-bc14-83fcd653a4be.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a4433ed4-b74a-4348-bc14-83fcd653a4be.png)'
- en: What we can do is inject packets into the traffic. When we inject packets into
    the traffic, we can force the AP to create new packets with new IVs in them, then
    capture the IVs. But before we can inject packets, we have to authenticate our
    device with the target AP. APs have lists of all of the devices that are connected
    to them, and they ignore any packets that come from a device that is not connected.
    If a device doesn't have the key and it tries to send a packet to the router,
    the router will just ignore it; it won't even try to read it, or to see what's
    inside. Before we can inject packets into a router, we have to authenticate ourselves
    with the router. We're going to use a method called fake authentication; it's
    very simple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是向流量中注入数据包。当我们向流量中注入数据包时，我们可以强制AP生成带有新IV的数据包，然后捕获这些IV。但是在注入数据包之前，我们必须先将设备认证到目标AP。AP会记录所有已连接到它的设备，并会忽略任何来自未连接设备的数据包。如果设备没有密钥并尝试向路由器发送数据包，路由器会直接忽略它；它甚至不会尝试读取数据包内容或查看里面是什么。在我们向路由器注入数据包之前，必须先通过认证。我们将使用一种称为伪认证的方法，它非常简单。
- en: 'We already executed `airodump` in the previous section. Let''s see how we can
    use fake authentication. In the previous screenshot, we can see that there is
    no value under `AUTH`. Once we have done fake authentication, we will see an `OPN`
    show up there, which will mean that we have successfully falsely authenticated
    our device with the target AP. To do that, we will use the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经执行了`airodump`。现在让我们看看如何使用伪认证。在前面的截图中，我们可以看到`AUTH`下没有任何值。一旦我们完成伪认证，我们会看到`OPN`显示在这里，这意味着我们已经成功地将设备伪认证到目标AP上。为此，我们将使用以下命令：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `aireplay-ng`, we're going to use a `--fakeauth` attack; we include the
    type of attack and the number of packets that we want to send, which is `--fakeauth
    0`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aireplay-ng`时，我们将使用`--fakeauth`攻击；我们包括了攻击类型以及我们希望发送的数据包数量，即`--fakeauth 0`。
- en: We are just going to put `0`; some use a large number, when they're carrying
    out an attack that will take 5 or 10 minutes, but for us, we will just use `0`,
    and maybe change it later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会输入`0`；有些人会使用一个较大的数字，当他们进行一个需要5到10分钟的攻击时，但对于我们来说，我们只会使用`0`，之后可能会再更改。
- en: 'We''re going to use the `-a` option and the target MAC address (that is, `54:B8:0A:9E:54:2D`).
    Then we''re going to use `-h` to include our MAC address, so that our MAC address
    which gets authenticated with the target network. To get our MAC address, we''re
    going to run the `ifconfig wlan0` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`-a`选项并指定目标MAC地址（即`54:B8:0A:9E:54:2D`）。接着我们将使用`-h`来包含我们的MAC地址，这样我们就可以将自己的MAC地址与目标网络进行认证。为了获取我们的MAC地址，我们将运行`ifconfig
    wlan0`命令：
- en: '![](assets/0f32a84b-85f6-4cb7-8080-15ccdf1764ae.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f32a84b-85f6-4cb7-8080-15ccdf1764ae.png)'
- en: 'The name of our Wi-Fi card is `wlan0`. With `aireplay-ng`, the type of attack
    that we''re trying to do, we''re trying to perform a fake authentication attack,
    to authenticate our MAC address so that we can inject packets into the target
    network. We''re going to send `0` (which means do it once), then `-a` (with the
    MAC address of the AP), then `-h` (where we put the MAC address of the device
    that we want to perform a fake authentication to), and then `wlan0`, the name
    of the Wi-Fi card; now we hit *Enter*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Wi-Fi卡的名称是`wlan0`。使用`aireplay-ng`时，我们尝试执行的攻击类型是伪认证攻击，用于将我们的MAC地址认证到目标网络，以便我们可以向目标网络注入数据包。我们将发送`0`（表示只执行一次），然后是`-a`（后跟AP的MAC地址），接着是`-h`（这里我们填入需要进行伪认证的设备的MAC地址），最后是`wlan0`，即Wi-Fi卡的名称；现在按下*Enter*键：
- en: '![](assets/f5b381a2-e28e-48da-ae11-6c65a19d48c9.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5b381a2-e28e-48da-ae11-6c65a19d48c9.png)'
- en: 'As you can see in the preceding screenshot, `-a` sent an authentication request,
    and it was successful. The network became an open network, and our client (that
    is, my attacking device) showed up as if it was a client connected to the network.
    We''re not actually connected, but we are authenticated with the network and have
    an association with it, so that we can inject packets into the AP—it will now
    receive any request that we send to it. Following is the output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，`-a`发送了一个认证请求，并且认证成功。网络变成了开放网络，我们的客户端（即我的攻击设备）看起来像是一个已连接到网络的客户端。我们实际上并没有连接，但我们已与网络完成认证并建立了关联，这样我们就可以向AP注入数据包——它现在会接收我们发送的任何请求。以下是输出结果：
- en: '![](assets/b55addb5-d9ac-4a59-b538-389206982c68.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b55addb5-d9ac-4a59-b538-389206982c68.png)'
- en: In the next section, we will see how we can inject packets and how to make the
    data increase very quickly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何注入数据包，以及如何使数据快速增长。
- en: ARP request replay
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARP请求重放
- en: The AP now accepts packets that we send to it, because it's not going to ignore
    us now that we've successfully associated ourselves with it by using a fake authentication
    attack. We are now ready to inject packets into the AP and make the data increase
    very quickly, in order to decrypt the WEP key.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接入点接受我们发送的数据包，因为在成功通过伪认证攻击与接入点关联后，它不会再忽视我们。我们现在已经准备好向接入点注入数据包，并迅速增加数据量，以便解密WEP密钥。
- en: The first method of packet injection that we're going to talk about is ARP request
    replay. In this method, we're going to wait for an ARP packet, capture the packet,
    and inject it into the traffic. When we do this, the AP will be forced to create
    a new packet with a new IV; we'll capture the new packet, inject it back into
    the traffic again, and force the AP to create another packet with another IV.
    We will keep doing this until the amount of data is high enough to crack the WEP
    key.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的第一个数据包注入方法是ARP请求重放。在这个方法中，我们会等待一个ARP数据包，捕获这个数据包，然后将其注入到流量中。这样做时，接入点会被迫生成一个带有新IV的新数据包；我们捕获这个新数据包后，再将它注入到流量中，强迫接入点生成另一个带有新IV的数据包。我们将不断重复这个过程，直到数据量足够大，能够破解WEP密钥。
- en: 'Let''s do this in Kali Linux. The first thing we''re going to do is launch
    `airodump-ng` with the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Kali Linux中进行操作。我们要做的第一件事是使用以下命令启动`airodump-ng`：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're going to add a `--write` option to the command; let's call it `arp-request-reply-test`.
    When it runs, we will see that the target network has `0` data, it has no clients
    associated with it, and there is no traffic going through as no client is connected,
    which means that it's not useful; we can't crack its key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向命令中添加`--write`选项；我们将其命名为`arp-request-reply-test`。运行后，我们会看到目标网络的`0`数据，它没有任何客户端与之关联，也没有流量通过，因为没有客户端连接，这意味着它没有用，我们无法破解其密钥。
- en: The first thing that we're going to do is fake authentication attack as shown
    in the *Fake authentication* section, so that we can start injecting packets into
    the network, and it will accept them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是进行伪认证攻击，如*伪认证*部分所示，以便我们可以开始向网络注入数据包，并且它会接受这些数据包。
- en: 'That leads us to our next step, which is the ARP request reply step, where
    we will inject packets into the target network, forcing it to create new packets
    with new IVs. The command is going to be the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了我们的下一步，即ARP请求响应步骤，在这一阶段我们将向目标网络注入数据包，迫使它生成带有新IV的数据包。命令如下：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is very similar to the previous command, but instead of `--fakeauth`,
    we''re going to use `--arpreplay`. We will also include `-b`, for BSSID. With
    this command, we are going to wait for an ARP packet, capture it, and then reinject
    it out into the air. We can then see that we''ve captured an ARP packet, injected
    it, captured another, injected it into the traffic, and so on; the AP then creates
    new packets with new IVs, we receive them, we inject them again, and this happens
    over and over:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与之前的命令非常相似，但我们不使用`--fakeauth`，而是使用`--arpreplay`。我们还将包括`-b`，用于BSSID。使用这个命令，我们将等待一个ARP数据包，捕获它，然后将其重新注入到空中。接着我们可以看到，我们已经捕获到一个ARP数据包，注入后又捕获到另一个，注入到流量中，依此类推；接入点（AP）会生成新的数据包，带有新的IV，我们接收到这些数据包后再将它们注入，这个过程会不断重复：
- en: '![](assets/7e64c800-3bc2-4e8c-a674-50a181f65986.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e64c800-3bc2-4e8c-a674-50a181f65986.png)'
- en: 'When the amount of `Data` reaches 9,000, or above we can launch `aircrack-ng`.
    When we use `aircrack-ng` and the filename, sure enough, we can see the WEP key,
    and we are able to crack it after `15012` IVs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Data`的数量达到9000或以上时，我们可以启动`aircrack-ng`。当我们使用`aircrack-ng`和文件名时，果然可以看到WEP密钥，并且我们能够在`15012`个IV之后破解它。
- en: '![](assets/7ded7457-9f50-4c4d-8f96-9351381a4188.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ded7457-9f50-4c4d-8f96-9351381a4188.png)'
- en: WPA introduction
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WPA介绍
- en: In the upcoming parts of this chapter, we're going to discuss **Wi-Fi Protected
    Access** (**WPA**) encryption. This encryption was designed after WEP, to address
    all of the issues that made WEP very easy to crack. The main issue with WEP is
    the short IV, which is sent in each packet as plain text. The short IV means that
    the possibility of having a unique IV in each packet can be exhausted in active
    networks, so that when we are injecting packets (or in natural, active networks),
    we will end up with more than one packet that has the same IV. When it happens,
    `aircrack-ng` can use statistical attacks to determine the key stream and the
    WEP key for the network.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的部分中，我们将讨论**Wi-Fi 受保护访问** (**WPA**) 加密。这种加密是在 WEP 后设计的，目的是解决 WEP 很容易被破解的问题。WEP
    的主要问题是 IV （初始化向量）太短，它以明文形式在每个数据包中发送。短 IV 意味着在活跃的网络中，数据包中每个包都能有唯一 IV 的可能性会被耗尽，因此当我们注入数据包（或者在自然的活跃网络中）时，我们会遇到多个数据包具有相同的
    IV。当这种情况发生时，`aircrack-ng` 可以利用统计攻击来确定密钥流和网络的 WEP 密钥。
- en: In WPA, however, each packet is encrypted using a unique, temporary key. It
    means that the number of data packets that we collect is irrelevant; even if we
    are able to collect one million packets, these packets are not useful, because
    they do not contain any information that can help us crack the WPA key. WPA2 is
    the same; it works with the same method, and it can be cracked using the same
    method. The only difference between WPA and WPA2 is that WPA2 uses an algorithm
    called **Counter-Mode Cipher Block Chaining Message Authentication Code Protocol**
    (**CCMP**) for encryption.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 WPA 中，每个数据包都是使用唯一的临时密钥加密的。这意味着我们收集的数据包数量并不重要；即使我们能够收集到一百万个数据包，这些数据包也没用，因为它们不包含任何有助于我们破解
    WPA 密钥的信息。WPA2 也是如此；它采用相同的方法，并且可以通过相同的方法进行破解。WPA 和 WPA2 之间的唯一区别是 WPA2 使用了一种叫做**计数模式密码块链消息认证码协议**
    (**CCMP**) 的加密算法。
- en: WPS cracking
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WPS 破解
- en: Cracking WPA or WPA2 encrypted networks isn't simple, especially since all of
    the packets that are sent out are not useful for us, as they do not contain any
    information that can help us to determine the WPA key. Before we get into cracking
    WPA and WPA2, we will look at a feature called WPS; it allows users and clients
    to connect to the network by the push of a button. On Windows 8, if you look on
    some Wi-Fi printers, they have a WPS button; if you press the WPS button and go
    to your router and press the WPS button as well, or if you go to the configuration
    page and press the WPS button, the client, printer, or Windows device will connect
    to the network without having to enter the key. WPS is a feature that allows clients
    to connect to a network easily, without having to enter the WPA key manually;
    it's just a feature in routers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 破解 WPA 或 WPA2 加密的网络并不简单，特别是因为所有发送出去的数据包对我们并没有什么用处，因为它们不包含任何有助于我们确定 WPA 密钥的信息。在我们开始破解
    WPA 和 WPA2 之前，我们将先了解一个叫做 WPS 的功能；它允许用户和客户端通过按下一个按钮连接到网络。在 Windows 8 上，如果你查看一些
    Wi-Fi 打印机，它们有一个 WPS 按钮；如果你按下 WPS 按钮，然后去你的路由器按下 WPS 按钮，或者如果你进入配置页面并按下 WPS 按钮，那么客户端、打印机或
    Windows 设备将无需输入密钥即可连接到网络。WPS 是一种允许客户端轻松连接到网络的功能，无需手动输入 WPA 密钥；它只是路由器中的一个功能。
- en: This feature authenticates the client using an 8-digit PIN, it doesn't use the
    actual WPA key. WPS only includes digits, there aren't too many possibilities
    for it. If we use a brute-force attack, we are guaranteed to guess the PIN. If
    we successfully guess the PIN, we can use a tool called `reaver`, which will calculate
    the WPA key from the PIN. We're going to brute-force the PIN; because it's only
    9 digits long, we will be successful. Once we do that, we can calculate the WPA
    key using `reaver`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能通过 8 位数字 PIN 验证客户端， 它并不使用实际的 WPA 密钥。WPS 仅包含数字，其可能性并不多。如果我们使用暴力破解攻击，必定能够猜出
    PIN。如果我们成功猜出了 PIN，我们可以使用一个叫做`reaver`的工具，它将根据 PIN 计算出 WPA 密钥。我们将对 PIN 进行暴力破解；因为它只有
    9 位数，所以我们一定能成功。一旦破解成功，我们可以使用`reaver`来计算 WPA 密钥。
- en: 'To look for APs that have WPS enabled, we''re going to use a tool called `wash`.
    We will use the `wash -i wlan0` command . We have our `Test` AP showing up in
    the following screenshot—that''s the AP that we''re going to crack, it is actually
    running on WPA now, not using WEP, like we saw previously:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了寻找启用了 WPS 的接入点，我们将使用一个叫做 `wash` 的工具。我们将使用 `wash -i wlan0` 命令。我们在以下截图中看到我们的`Test`接入点——这就是我们要破解的接入点，实际上它现在正在使用
    WPA，而不是像我们之前看到的使用 WEP：
- en: '![](assets/f83fd94e-acd9-4ad4-be4a-3606362e5aaf.png)In order to check whether AP
    is actually using WPA encryption, run `airodump-ng wlan0`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f83fd94e-acd9-4ad4-be4a-3606362e5aaf.png)为了检查 AP 是否实际使用了 WPA 加密，可以运行
    `airodump-ng wlan0`。'
- en: The preceding is the lists of APs that have WPS enabled. We can see `Ch`, `dBm` (which
    is the distance between us and the AP), `WPS` shown the WPS version, and `Lck` shown
    whether its locked. Now, some routers, when we try to brute-force the WPS PIN,
    lock after a few failed attempts. If we try, for example, four wrong PINs, they're
    going to lock, and will not accept any PINs for a certain amount of time. If `Lck`
    says `Yes`, we can't actually use the attack anymore; we need to wait for a little
    bit, and then come back to the AP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是启用了 WPS 的 AP 列表。我们可以看到 `Ch`、`dBm`（即我们与 AP 之间的距离）、`WPS` 显示了 WPS 版本，`Lck` 显示其是否被锁定。现在，一些路由器在我们尝试暴力破解
    WPS PIN 时，会在几次失败后被锁定。例如，如果我们输入四个错误的 PIN，它们会被锁定，并且在一段时间内不再接受任何 PIN。如果 `Lck` 显示
    `Yes`，我们将无法继续使用攻击；需要稍等一段时间，然后再连接到 AP。
- en: We will run `reaver` now, it is going to brute-force the WPS PIN, and, once
    it's able to find the WPS PIN, it's going to work out the WPA key. The `reaver`
    supports pause and resume, for example, if we reach, through brute-force, 30%
    of the possibilities, and then cancel the attack, when we come back, we will start
    again from 30 not from 0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在运行 `reaver`，它将暴力破解 WPS PIN，一旦找到 WPS PIN，它就会计算出 WPA 密钥。`reaver` 支持暂停和恢复。例如，如果我们通过暴力破解已经尝试了
    30% 的可能性，然后取消了攻击，当我们回来时，它将从 30% 继续，而不是从 0% 开始。
- en: 'Let''s launch `reaver`; we''re going to put `-b` to choose the BSSID, or the
    MAC address, of the target AP, and then `-c` to choose the channel, which is `11`,
    then, we can choose the Wi-Fi card `-i` with monitor mode, and that''s `wlan0`.
    The command is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 `reaver`；我们将使用 `-b` 选项选择目标 AP 的 BSSID（即 MAC 地址），然后使用 `-c` 选项选择频道，这里是 `11`，接着，我们可以选择
    Wi-Fi 卡 `-i`，并启用监控模式，这里是 `wlan0`。命令如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We hit *Enter*, and `reaver` will be associated with the target AP; it will
    try to determine the WPS PIN. In the screenshot, we can see that we have an easy
    PIN, which is `12345670`; from that, `reaver` was able to calculate the WPA key,
    `UAURWSXR`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按下 *Enter*，`reaver` 会与目标 AP 进行关联；它将尝试确定 WPS PIN。在截图中，我们可以看到一个简单的 PIN，即 `12345670`；通过这个，`reaver`
    能够计算出 WPA 密钥 `UAURWSXR`：
- en: '![](assets/a6358f8a-70d5-46a9-9a7f-95f37a358e31.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a6358f8a-70d5-46a9-9a7f-95f37a358e31.png)'
- en: Now, we can just connect to the network; if we put in the key that we just found,
    we can use the password, `UAURWSXR`, and connect it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接连接到网络；如果输入我们刚刚找到的密钥 `UAURWSXR`，就可以连接了。
- en: Now, there are a few options for `reaver`. We launch `reaver --help`, and we
    can see all of the options that we can use with `reaver`. As mentioned earlier,
    some routers will lock after a few failed attempts; therefore, we can use some
    of these advanced options to get `reaver` to work against these APs. For example,
    we can use the `--delay` option to specify the amount of time, in seconds, that
    `reaver` should wait between each brute-force attempt, or each PIN attempt. We
    can also use the `--lock-delay` to tell `reaver` to wait, for example, 60 seconds,
    if the AP gets locked, before continuing the brute-force attempt. We can use `--fail-wait`,
    as well, to set the time that `reaver` should wait after 10 failed attempts. Also,
    we can use the `-r` option to tell `reaver` to sleep for a certain amount of seconds
    after a certain number of tries. We can set up the `--timeout` option, we can
    play with these options, the `--delay` options, and the `--fail-wait` if the AP
    was locking or was ignoring some of our brute-force attempts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`reaver` 有一些选项。我们可以运行 `reaver --help` 来查看所有可以与 `reaver` 一起使用的选项。如前所述，一些路由器在几次失败后会锁定；因此，我们可以使用这些高级选项来让
    `reaver` 针对这些 AP 进行工作。例如，我们可以使用 `--delay` 选项来指定每次暴力破解尝试或每次 PIN 尝试之间 `reaver` 应等待的时间（单位：秒）。我们还可以使用
    `--lock-delay` 告诉 `reaver` 在 AP 被锁定后，例如 60 秒，再继续暴力破解尝试。我们还可以使用 `--fail-wait` 选项来设置在
    10 次失败尝试后 `reaver` 应该等待的时间。此外，我们可以使用 `-r` 选项来告诉 `reaver` 在一定次数的尝试后休眠若干秒。我们可以设置
    `--timeout` 选项，调整这些选项、`--delay` 选项和 `--fail-wait`，如果 AP 被锁定或忽略了我们的一些暴力破解尝试。
- en: Handshake theory
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 握手理论
- en: In the previous section, we saw how we can use the WPS feature in routers to
    crack the WPA key. This process is guaranteed to work on every WPS-enabled network;
    therefore, if your target uses WPA or WPA2 encryption and has WPS enabled, that
    should be the first method you try to crack the password with. If WPS is not enabled,
    however, we have to crack the actual WPA key. As we explained in the section on
    *WPS cracking*, in WPA, each packet is encrypted using a unique, temporary key,
    it's not like WEP, where IVs are repeated and we collect a large number of data
    packets with the same IVs. In each WPA packet, there is a temporary unique IV,
    even if we collect one million packets, these packets will not be useful for us—they
    do not contain any information that can help us determine the actual WPA key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到如何利用路由器的WPS功能来破解WPA密钥。这个过程在每个启用WPS的网络上都能保证有效；因此，如果你的目标使用WPA或WPA2加密并且启用了WPS，那么应该首先尝试使用WPS破解密码。然而，如果WPS没有启用，我们就得破解实际的WPA密钥。如我们在*WPS破解*部分中所解释的，WPA中每个数据包都是使用一个独特的临时密钥加密的，这不同于WEP，其中IV是重复的，我们会收集大量具有相同IV的数据包。在每个WPA数据包中，都会有一个临时的唯一IV，即使我们收集了一百万个数据包，这些数据包对我们也没有用——它们不包含任何能帮助我们确定实际WPA密钥的信息。
- en: 'The only packets that contain information that can help us determine the key
    are the handshake packets. These are four packets, sent when a new device or a
    new client connects to the target network. For example, when we are at home and
    our device connects to the network, we have the password, and a process called
    a four-way handshake happens between the device and the AP. In this process, four
    packets, called the handshake packets, get transferred between the two devices,
    to authenticate the device connection. Using `aircrack-ng`, we can use a wordlist,
    testing each password in the wordlist by using the handshake. To crack WPA encrypted
    networks, we need two things: we need to capture the handshake, and we need a
    wordlist that contains passwords.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一包含可以帮助我们确定密钥信息的数据包是握手数据包。这些是四个数据包，在一个新设备或新客户端连接到目标网络时发送。例如，当我们在家时，我们的设备连接到网络，已知密码，并且一个被称为四次握手的过程会在设备与AP之间发生。在这个过程中，四个数据包（称为握手数据包）在两个设备之间传输，用于验证设备的连接。通过使用`aircrack-ng`，我们可以利用字典列表，通过握手测试字典中的每一个密码。要破解WPA加密网络，我们需要两样东西：我们需要捕获握手，并且需要一个包含密码的字典列表。
- en: Capturing the handshake
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获握手
- en: 'To crack a WPA key, the first thing we''re going to need to do is capture the
    handshake. We''re going to capture the handshake by using `airodump-ng`, the same
    way that we used it with WEP-encrypted networks. We will use `airodump-ng --bssid`,
    the same way we used it to run it against WEP networks; at the end of the day,
    we''re only capturing packets using `airodump-ng`, it''s doing the same job. We
    will include the channel, and then we will write to a file, calling the file `test-handshake`;
    we will also include the wireless card in monitor mode. We use the same command
    we used when we were capturing packets for WEP networks, `airodump-ng --bssid`.
    We put the target AP, `--channel`; the target channel, `--write`; the name of
    the file that we''re going to store stuff in; and `wlan0`, our Wi-Fi card, with
    monitor mode. The command is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解WPA密钥，我们首先需要做的是捕获握手。我们将使用`airodump-ng`来捕获握手，方式与我们在WEP加密网络中使用的方法相同。我们将使用`airodump-ng
    --bssid`，就像我们对WEP网络运行时一样；归根结底，我们只是使用`airodump-ng`来捕获数据包，它执行的工作是一样的。我们将包括频道信息，然后将数据写入一个文件，文件名为`test-handshake`；同时还会包括无线网卡的监控模式。我们使用与捕获WEP网络数据包时相同的命令`airodump-ng
    --bssid`。我们指定目标AP，`--channel`；目标频道，`--write`；存储文件的名称；以及`wlan0`，我们的Wi-Fi卡，处于监控模式。命令如下：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we launch this command, we will have our network, a WPA-encrypted network,
    we will have a client connected to the network. To capture the handshake, we can
    just sit down and wait for a device to connect to the network. Once a device connects
    to the network, we can capture the handshake, or we can use something that we
    learned in the previous chapter ([Chapter 5](bc4346fc-ed68-40d5-b1c7-7f3dd0f5af76.xhtml), *Pre-Connection
    Attacks*), which is a deauthentication attack.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动此命令，我们将拥有一个WPA加密的网络，并且会有一个客户端连接到该网络。为了捕获握手，我们可以坐下来等待一个设备连接到网络。一旦设备连接上网络，我们就可以捕获握手，或者我们也可以使用在上一章中学到的一种方法（[第5章](bc4346fc-ed68-40d5-b1c7-7f3dd0f5af76.xhtml)，*预连接攻击*），即去认证攻击。
- en: In a deauthentication attack, we disassociate, or disconnect, any device from
    a network that is within our Wi-Fi range. If we do that for a very short period
    of time, we can disassociate the device from the network for a second; the device
    will try to connect back to the network automatically, and even the person using
    the device will not notice that his device is disconnected and reconnected. We
    will then be able to capture the handshake packets. Again, we said that the handshake
    gets sent every time a device connects to a target network.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在去认证攻击中，我们将会断开任何在我们Wi-Fi范围内的设备与网络的连接。如果我们只断开很短的时间，我们可以让设备从网络断开一秒钟；设备会自动尝试重新连接网络，甚至使用设备的人也不会注意到他的设备已经断开并重新连接。我们就能够捕获握手数据包。再说一次，每当设备连接到目标网络时，握手信息都会发送。
- en: 'Now we''re just going to run a basic authentication attack, using `aireplay-ng`.
    We studied it in [Chapter 4](c3f79613-de23-4825-9b88-b2f5dc16479c.xhtml), *Network
    Penetration Testing*, and, in this section we put a very large number of packets
    when we were disconnecting our target. Now we are only going to put a small number:
    four deauthentication packets. Then, we''re going to put `-a`, the MAC address
    of the target AP, and `-c`, to specify the client MAC address (the MAC address
    of the client that we want to disconnect). Then we are going to put the Wi-Fi
    card name, which is `wlan0`. We use `aireplay-ng --deauth`, the name of the attack,
    and `4` authentication packets to the AP, and disconnect the device from it. The
    command is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要运行一个基本的认证攻击，使用`aireplay-ng`。我们在[第4章](c3f79613-de23-4825-9b88-b2f5dc16479c.xhtml)中研究过它，*网络渗透测试*，在这一节我们使用了大量的数据包来断开目标设备的连接。现在我们只会发送少量数据包：四个去认证数据包。接下来，我们会指定`-a`，即目标AP的MAC地址，`-c`，指定要断开连接的客户端的MAC地址。然后我们会指定Wi-Fi网卡名称，即`wlan0`。我们使用`aireplay-ng
    --deauth`，攻击类型，以及`4`个认证数据包来断开设备与AP的连接。命令如下：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in the following screenshot, we captured the WPA handshake,
    and our target device didn''t even change, nor was it disconnected:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，我们成功捕获了WPA握手，目标设备甚至没有改变，或者没有断开连接：
- en: '![](assets/c067830a-b9fc-4642-b3d0-faacb2a8115c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c067830a-b9fc-4642-b3d0-faacb2a8115c.png)'
- en: We didn't get any messages about being disconnected, because we were disconnected
    for a very short period of time; as a result, even the person using the device
    didn't notice, and we were able to capture the handshake. Now we can use a wordlist
    and run it against the handshake to try to determine the main WPA key.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有收到任何关于断开连接的消息，因为我们只断开了很短的时间；结果，甚至使用设备的人都没有注意到，我们也成功捕获了握手信息。现在我们可以使用词表，并将其与握手进行比对，尝试确定主要的WPA密钥。
- en: Creating a wordlist
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建词表
- en: Now that we've captured the handshake, all we need to do is crack the WPA key
    by creating a wordlist. A wordlist is just a list of words that `aircrack-ng`
    is going to go through, trying each one against the handshake until it successfully
    determines the WPA key. The better your wordlist is, the higher your chances of
    cracking the WPA key will be. If the password isn't in your wordlist file, you
    will not be able to determine the WPA key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了握手信息，接下来只需要通过创建一个词表来破解WPA密钥。词表只是一个单词列表，`aircrack-ng`会逐个尝试这些单词与握手信息进行比对，直到成功确定WPA密钥。词表越好，破解WPA密钥的成功几率就越高。如果密码不在你的词表文件中，你将无法确定WPA密钥。
- en: We're going to use a tool called `crunch`. It's basically just a script; we
    specify the characters that we want in the passwords, and it creates all possible
    combinations of these passwords. The format of the command for using `crunch`
    is `crunch [min] [max]`. The `[min]` is the minimum number of characters of the
    password that we want to create, we can say that we want a minimum of four, five,
    six, and so on. The `[max]` is the maximum number of characters in the password.
    We can specify the characters that we want to use in the passwords, so that we
    can specify `abcdefg`, all of the lower letters, and then we can write the capital
    letters; we can put numbers and symbols.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`crunch`的工具。它实际上只是一个脚本；我们指定希望出现在密码中的字符，它就会创建这些密码的所有可能组合。使用`crunch`的命令格式是`crunch
    [min] [max]`。`[min]`是我们希望创建的密码的最小字符数，可以设置为四、五、六等；`[max]`是密码的最大字符数。我们可以指定密码中使用的字符，例如可以指定`abcdefg`，所有小写字母，然后可以加入大写字母，数字和符号。
- en: The `-t` option is very useful if we know part of the password; it's a pattern.
    For example, if we are trying to guess a password and we have seen someone typing
    the password, we know that it starts with an `a` and ends with a `b`, we can use
    the pattern option and tell `crunch` to create passwords that always start with
    `a` and end with `b`, and it will put all possible combinations of the characters
    that we put in the command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 选项非常有用，如果我们知道密码的一部分；它是一个模式。例如，如果我们试图猜测密码，并且我们看到有人输入密码，我们知道它以`a`开头，以`b`结尾，我们可以使用模式选项，并告诉`crunch`创建始终以`a`开头，以`b`结尾的密码，并且它会将我们在命令中指定的字符的所有可能组合放在一起。'
- en: Suppose that we're going to create passwords of a minimum of six characters
    and a maximum of eight characters, and the passwords are going to be combinations
    of the characters 1, 2, 3, 4, 5, and 6, and symbols. It's going to be stored in
    a file called `wordlist`, and the pattern is `wordlist` file passwords are always
    going to start with an `a`, and they're always going to end with a `b`. All of
    the passwords that we're going to see in the file are going to start with `a`
    and end with `b`, and they'll have all of the possible combinations of the characters
    that we specified between the `a` and the `b`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要创建最少六个字符和最多八个字符的密码，并且密码将是由字符`1, 2, 3, 4, 5`和符号组合而成。它将存储在名为`wordlist`的文件中，模式是`wordlist`文件中密码始终以`a`开头，且始终以`b`结尾。我们将在文件中看到的所有密码都将以`a`开头，以`b`结尾，并且它们将具有我们在`a`和`b`之间指定的字符的所有可能组合。
- en: 'Let''s just run `crunch` and create a sample wordlist. We''re going to use `crunch`,
    and then we''re going to make a minimum of `4` and a maximum of `6`. We''re just
    going to put `123ab`, and store it in `sample-wordlist`. The `crunch` is going
    to create a combination of passwords (a minimum of four characters, a maximum
    of six characters), and it''s going to create all possible combinations of `123ab`.
    It''s going to store the combinations in a file called `sample-wordlist`. The
    command will be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只运行`crunch`并创建一个示例单词表。我们将使用`crunch`，然后设置最小为`4`，最大为`6`。我们只需放入`123ab`，并将其存储在`sample-wordlist`中。`crunch`将创建密码组合（至少四个字符，至多六个字符），并将创建`123ab`的所有可能组合。它将把组合存储在名为`sample-wordlist`的文件中。命令如下：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Following is the output of the preceding:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述内容的输出：
- en: '![](assets/f1ea8948-d274-48e6-8a70-710791af93f1.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1ea8948-d274-48e6-8a70-710791af93f1.png)'
- en: 'We can read by running `cat sample-wordlist`, and we can see all of the passwords
    that are stored in the file as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`cat sample-wordlist`来读取，并且我们可以看到文件中存储的所有密码，如下面的截图所示：
- en: '![](assets/53206de1-9e35-422a-8cf3-d651a03130ef.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/53206de1-9e35-422a-8cf3-d651a03130ef.png)'
- en: We can see all of the passwords that `crunch` created for us. The bigger the
    password that we put and the more characters that we include, the more passwords
    we can make, and the more space they're going to take up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`crunch`为我们创建的所有密码。我们在命令中放入的密码越大且包含的字符越多，我们可以制作的密码就越多，它们会占用更多的空间。
- en: 'Let''s take a look at the pattern option. We''ll go to `crunch`, using a minimum
    of `5` and a maximum of `5`, so all passwords will be five characters long, and
    then we will put the characters, which are `123ab` (like before), and we will
    add the `-t` option, which is the pattern option. Then, we will say that the password
    starts with an `a` and ends with a `b`, and we want all possible combinations
    of the characters between `a` and `b`. Then, we''re going to specify the output
    file `-o`; let''s call it `pattern-wordlist`. Following is the command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看模式选项。我们将使用`crunch`，最小为`5`，最大为`5`，因此所有密码都将是五个字符长，然后我们将放入字符`123ab`（如前所述），然后我们将添加`-t`选项，即模式选项。然后，我们将说明密码以`a`开头，以`b`结尾，并且我们希望在`a`和`b`之间的字符的所有可能组合。然后，我们将指定输出文件`-o`；让我们称之为`pattern-wordlist`。以下是命令：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will be as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](assets/eed03f51-1fd6-4d77-be1d-80ad5dd950d8.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eed03f51-1fd6-4d77-be1d-80ad5dd950d8.png)'
- en: 'It creates `125` passwords; let''s take a look at them. As we can see in the
    following screenshot, they always start with an `a` and always end with a `b`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了`125`个密码；让我们看看它们。正如我们在下面的截图中所见，它们始终以`a`开头，始终以`b`结尾：
- en: '![](assets/2899b037-5cf6-4482-ac92-c21506642772.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2899b037-5cf6-4482-ac92-c21506642772.png)'
- en: We can use `crunch` to create your wordlist, and in the next section, we're
    going to use the wordlist and the handshake file to determine the actual WPA key.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`crunch`来创建您的单词列表，在下一节中，我们将使用单词列表和握手文件来确定实际的WPA密钥。
- en: Wordlist cracking
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单词列表破解
- en: Now that we've captured the handshake from our target AP and we have a wordlist
    ready to use, we can use `aircrack-ng` to crack the key for the target AP. The `aircrack-ng`
    is going to go through the wordlist file, combine each password with the name
    of our target AP, and create a **Pairwise Master Key** (**PMK**). The PMK is created
    by using an algorithm called the PBKDF2, it's not like just combining the password
    and the BSSID; it's encrypting them in a certain way, and it compares the PMK
    to the handshake. If the PMK was valid, then the password that was used is the
    password for the target AP; if it wasn't valid, then `aircrack-ng` tries the next
    password.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从目标AP捕获了握手，我们准备好使用单词列表，我们可以使用`aircrack-ng`来破解目标AP的密钥。`aircrack-ng`将遍历单词列表文件，将每个密码与我们目标AP的名称结合起来，并创建一个**Pairwise
    Master Key**（**PMK**）。 PMK是通过使用称为PBKDF2的算法创建的，它不像只是将密码和BSSID组合在一起；它以一定的方式对它们进行加密，并将PMK与握手进行比较。如果PMK有效，则使用的密码是目标AP的密码；如果无效，则`aircrack-ng`尝试下一个密码。
- en: 'We use `aircrack-ng`, the name of the file that contains the handshake, `test-handshake-01.cap`,
    and `-w` and the name of the wordlist, `wordlist`. The command is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`aircrack-ng`，包含握手的文件名`test-handshake-01.cap`，以及`-w`和单词列表的名称`wordlist`。命令如下：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we are going to hit *Enter*, and `aircrack-ng` is going to go through the
    list; it will try all of the passwords, and will combine each password with the
    name of the target AP to create a PMK, then compare the PMK to the handshake.
    If the PMK is valid, then the password that was used to create the PMK is the
    password for the target AP; if the PMK is not valid, then it's just going to try
    the next password.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要按下*Enter*，`aircrack-ng`将遍历列表；它将尝试所有密码，并将每个密码与目标AP的名称结合以创建一个PMK，然后将PMK与握手进行比较。如果PMK有效，则用于创建PMK的密码是目标AP的密码；如果PMK无效，则它将尝试下一个密码。
- en: 'As we can see, in the following screenshot, the key was found:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，密钥已找到：
- en: '![](assets/e8c27ec0-92d8-4a2a-a56b-53e704e29da8.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e8c27ec0-92d8-4a2a-a56b-53e704e29da8.png)'
- en: 'It is the most basic way of using a wordlist: it took `42 seconds` to crack
    the password. The speed depends on how quick the processor is, and whether we
    have any processes running that are making our computer a bit slower.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用单词列表的最基本方法：破解密码只需`42秒`。速度取决于处理器的快慢，以及我们是否有任何正在运行的进程使我们的计算机变慢。
- en: Securing network from attacks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从攻击中保护网络
- en: 'In order to prevent our network from preceding cracking methods explained throughout
    the chapter, we''ll need to access the settings page for your router. Each router
    has a web page where user can modify the settings for the router, and it''s usually
    at the IP of the router. First we''re going get the IP of my computer or my device,
    and we are going to run `ifconfig wlan0` command; as seen in the following screenshot,
    the highlighted part is the IP of the computer:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的网络受到本章中解释的破解方法的影响，我们需要访问路由器的设置页面。每个路由器都有一个网页，用户可以在该网页上修改路由器的设置，通常在路由器的IP上。首先，我们要获取我的计算机或设备的IP，然后运行`ifconfig
    wlan0`命令；如下截图所示，突出显示的部分是计算机的IP：
- en: '![](assets/3f40bd1a-882c-4609-8c8e-0608fd1602a1.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f40bd1a-882c-4609-8c8e-0608fd1602a1.png)'
- en: Now open the browser, and navigate to `192.168.0.1`; for this example, the IP
    of the computer is `25`. Usually, the IP of the router is the first IP of the
    subnet. At the moment, it's `192.168.0.0`, and we are just going to add the number `1`,
    because that's the first IP in the subnet, and that will take us to the router
    settings page. At the settings page, it'll asking to enter a username and a password.
    Routers come with a pre-specified username and password—we can check what the
    default username and password are; it's highly recommended to change them afterwards.
    It's usually written in the manual, so check the manual, see what the default
    username and password are, and then log in using those credentials.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开浏览器，访问`192.168.0.1`；对于这个示例，计算机的IP是`25`。通常情况下，路由器的IP是子网的第一个IP。此时，它是`192.168.0.0`，我们只需加上`1`，因为那是子网中的第一个IP，这将带我们进入路由器设置页面。在设置页面，它会要求输入用户名和密码。路由器通常都有预设的用户名和密码——我们可以查看默认的用户名和密码；强烈建议之后更改它们。通常这些信息会写在手册中，所以查看手册，了解默认的用户名和密码，然后用这些凭证登录。
- en: Now, in some cases, the attacker might be doing a deauthentication attack against
    us, so the attacker might be preventing us from connecting to our network wirelessly.
    What we can do is connect to the router using an Ethernet cable; when we do that,
    the attacker cannot use a deauthentication attack to deauthenticate or disconnect
    us, and we will be able to access the router settings using the wire. We can modify
    our security settings and change the encryption, change the password, and do all
    of the things that are recommended in order to increase the security, so that
    the attacker will not be able to attack the network and get the key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某些情况下，攻击者可能正在对我们进行去认证攻击，这样攻击者可能会阻止我们无线连接到网络。我们可以做的是通过以太网线连接到路由器；这样做时，攻击者就无法通过去认证攻击来断开我们的连接，我们将能够通过有线连接访问路由器设置。我们可以修改安全设置，改变加密方式，修改密码，做所有的安全增强操作，以避免攻击者能够攻击网络并获取密钥。
- en: Now, the settings of each router are different; they depend on the manufacturer,
    and even the model of the router. But usually, the way that we change the settings
    is the same; in 90% of the cases, the router is always at the first IP of the
    subnet, all we have to do is get your IP using the `ifconfig` command, like we
    did at the start of this topic. We got the `192.168.0.25` IP, and then we changed
    the last `25` to the number `1` to the first IP, and that is the IP of our router.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个路由器的设置都是不同的，取决于制造商，甚至是路由器的型号。但通常情况下，修改设置的方式是相同的；在90%的情况下，路由器的IP总是子网的第一个IP，我们只需要使用`ifconfig`命令获取IP，就像我们在本节开始时所做的那样。我们获得了`192.168.0.25`的IP，然后将最后的`25`改成`1`，就是第一个IP，这就是我们的路由器的IP。
- en: 'Now, we are going to navigate to the WIRELESS settings. As we see, there are
    a lot of settings that we can change for our network, and we''re concerned with
    the WIRELESS settings at the moment:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将导航到**无线**设置。正如我们所见，有很多设置可以修改我们的网络，目前我们关注的是**无线**设置：
- en: '![](assets/3935badb-89af-4efc-b778-adc9dff971d2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3935badb-89af-4efc-b778-adc9dff971d2.png)'
- en: As we can see in the preceding screenshot, the wireless setting is Enabled,
    we can even change the name of the network under SSID; we can change the Channel and
    the Bandwidth, as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，**无线**设置已启用，我们甚至可以在**SSID**下更改网络名称；我们还可以更改**频道**和**带宽**。
- en: 'After going to the Security option, we can see in the following screenshot,
    we are using WPA encryption with WPA/WPA2 authentication, and the encryption uses AES+TKIP:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**安全**选项后，我们可以在以下截图中看到，我们正在使用WPA加密和WPA/WPA2认证，且加密方式使用的是AES+TKIP：
- en: '![](assets/d142beba-58bb-4fe5-afb5-f663a237bee6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d142beba-58bb-4fe5-afb5-f663a237bee6.png)'
- en: 'If we go on WPS, we can see that WPS is Disabled; we are not using WEP, so that
    attackers cannot use any of the attacks to crack WEP encryptions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进入WPS选项，我们可以看到WPS已禁用；我们没有使用WEP加密，这样攻击者就无法使用任何攻击手段来破解WEP加密：
- en: '![](assets/132f5003-1b11-49fc-b74b-797ada1c8583.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/132f5003-1b11-49fc-b74b-797ada1c8583.png)'
- en: We are using WPA, which is much more secure, and we have disabled WPS, so that
    attacks cannot use `reaver` to determine the WPS PIN and then reverse-engineer
    the password. The only way that the hacker can access or get the password is by
    obtaining the handshake first, and then using a wordlist to find the password.
    The password is very random, even though it doesn't actually use numbers or digits,
    just letters; but it's very random, so there are very small chance of someone
    being able to guess it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用更加安全的WPA，并且已经禁用了WPS，这样攻击者就无法使用`reaver`来确定WPS PIN，然后反向工程密码。黑客能够访问或获取密码的唯一方法是首先获取握手，然后使用一个单词列表找到密码。密码非常随机，即使实际上没有使用数字或数字，只是字母；但它非常随机，所以很难有人能够猜到它。
- en: 'Now, there is also the Access Control; using this, we can add policies, such
    as an allow policy or a deny policy:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有访问控制；使用这个，我们可以添加策略，比如允许策略或拒绝策略：
- en: '![](assets/9391038c-3964-4e61-88c0-a1d7b65fa9b1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9391038c-3964-4e61-88c0-a1d7b65fa9b1.png)'
- en: 'We can specify MAC addresses that we want to allow to connect to our network;
    we can also specify MAC addresses that we want to deny from our network. For example,
    if there are not many people or many visitors coming to your house, or if you
    are in a company with a specified number of computers and only want to allow a
    number of computers to connect to the network, you can obtain their MAC addresses
    (for the people that you want to allow) and add them onto an Allow List. Even
    if someone has the actual key, and they don''t exist in the whitelist or in the Allow
    List, they will not be able to access the network. We can also add a Deny List when
    we want to deny a certain computer or a certain person that we think is suspicious;
    we can just add their MAC address onto the Deny List, and they will not be able
    to connect to your network:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定我们想要允许连接到我们网络的MAC地址；我们也可以指定我们想要从我们网络中拒绝的MAC地址。例如，如果你家里没有很多人或很多访客，或者如果你在一家有指定数量计算机的公司，并且只想允许一定数量的计算机连接到网络，你可以获取他们的MAC地址（对于你想要允许的人）并将它们添加到允许列表中。即使有人有实际的密钥，但他们不在白名单或允许列表中，他们将无法访问网络。当我们想要拒绝某台计算机或某个我们认为可疑的人时，我们可以添加他们的MAC地址到拒绝列表中，他们将无法连接到你的网络：
- en: '![](assets/60d936bf-6b50-4a9a-ae72-dce01d8578ff.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60d936bf-6b50-4a9a-ae72-dce01d8578ff.png)'
- en: The router settings page usually looks different for different routers; the
    names for options might be different, but the main point is that we should be
    able to access the router settings using the subnet IP and adding the number `1`,
    which is the first IP, at the end. If you are being attacked and can't connect
    to your network at all, then just use a cable and modify the settings, like we
    discussed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器设置页面通常对不同的路由器有不同的外观；选项的名称可能不同，但主要点是我们应该能够使用子网IP访问路由器设置，并在末尾添加数字`1`，这是第一个IP。如果你遭受攻击并且完全无法连接到你的网络，那么只需使用一根电缆并修改设置，就像我们讨论过的那样。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter we studied how easy it is to crack WEP-encrypted networks, even
    if there are no devices connect to the target network, and even if the network
    is idle. We also saw a number of methods to inject packets into the traffic and
    cause the amount of data to increase very rapidly, in order to crack the WEP key
    in a very short period of time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章我们研究了即使没有设备连接到目标网络，即使网络处于空闲状态，破解WEP加密网络有多么容易。我们还看到了一些方法将数据包注入到流量中，并导致数据量迅速增加，以便在很短的时间内破解WEP密钥。
- en: Then we studied all of the weaknesses that can be used by hackers in order to
    breach WEP, WPA, and WPA2 encrypted networks. Then we saw how hackers can use
    weaknesses to crack passwords and get keys for networks. Later we how as attackers
    are we will be able to deauthenticate, or disconnect, any device from any network,
    without the need to know the key.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们研究了黑客可以利用的所有弱点，以便入侵WEP、WPA和WPA2加密网络。然后我们看到黑客如何利用弱点来破解密码并获取网络的密钥。之后我们作为攻击者将能够取消认证，或者从任何网络中断开任何设备，而无需知道密钥。
- en: Towards the end of the chapter we discussed how we can modify the settings of
    our own routers, so that we can increase the encryption and the security of the
    network, preventing hackers from using attacks and getting passwords.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们讨论了如何修改我们自己路由器的设置，以增加网络的加密和安全性，防止黑客使用攻击并获取密码。
- en: In the next chapter we will be learning about information gathering and also
    use various tools that will give us refined information via various scans and
    reports they generate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习
