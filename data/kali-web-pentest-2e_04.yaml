- en: Testing Authentication and Session Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试身份验证和会话管理
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖：
- en: Username enumeration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名枚举
- en: Dictionary attack on login pages with Burp Suite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 对登录页面进行字典攻击
- en: Brute forcing basic authentication with Hydra
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hydra 强力破解基础身份验证
- en: Attacking Tomcat's passwords with Metasploit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Metasploit 攻击 Tomcat 的密码
- en: Manually identifying vulnerabilities in cookies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动识别 Cookie 中的漏洞
- en: Attacking a session fixation vulnerability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击会话固定漏洞
- en: Evaluating a session identifier's quality with Burp Sequencer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Burp Sequencer 评估会话标识符的质量
- en: Abusing insecure direct object references
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滥用不安全的直接对象引用
- en: Performing a Cross-Site Request Forgeryattack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行跨站请求伪造攻击
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When the information managed by an application is not meant to be public, a
    mechanism is required to verify that a user is allowed to see certain data; this
    is called **authentication**. The most common authentication method in web applications
    nowadays is the use of a username or identifier and a secret password combination.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序管理的信息不应公开时，需要一个机制来验证用户是否允许查看某些数据；这就是 **身份验证**。如今，web 应用程序中最常见的身份验证方法是使用用户名或标识符与秘密密码的组合。
- en: HTTP is a stateless protocol, which means it treats all requests as unique and
    doesn't have a way of relating two as belonging to the same user, so the application also requires
    a way of distinguishing requests from different users and allowing them to perform
    tasks that may require a series of requests performed by the same user and multiple
    users connected at the same time. This is called **session management**. Session
    identifiers in cookies are the most used session management method in modern web
    applications, although bearer tokens (values containing user identification information
    sent in the `Authorization` header of each request) are growing in popularity
    in certain types of applications, such as backend web services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一种无状态协议，这意味着它将所有请求视为独立的，并且没有办法将两者关联为属于同一个用户，因此应用程序还需要一种区分不同用户请求的方式，并允许他们执行可能需要一系列由同一用户完成的请求，或者同时由多个用户连接执行的任务。这被称为
    **会话管理**。Cookie 中的会话标识符是现代 web 应用程序中最常用的会话管理方法，尽管在某些类型的应用程序（如后台 web 服务）中，Bearer
    Token（包含用户身份信息的值，通常通过每个请求的 `Authorization` 头部发送）也在不断流行起来。
- en: In this chapter, we will cover the procedures to detect some of the most common
    vulnerabilities in web application authentication and session management, and
    how an attacker may abuse such vulnerabilities in order to gain access to restricted
    information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍检测 web 应用程序身份验证和会话管理中一些最常见漏洞的步骤，以及攻击者如何利用这些漏洞来获取受限信息的方式。
- en: Username enumeration
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户名枚举
- en: The first step to defeating a common user/password authentication mechanism
    is to discover valid usernames. One way of doing this is by enumeration; enumerating
    users in web applications is done by analyzing the responses when usernames are
    submitted in places such as login, registration, and password recovery pages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 战胜常见的用户/密码认证机制的第一步是发现有效的用户名。实现这一点的一种方法是枚举；在 web 应用程序中枚举用户是通过分析当用户名在登录、注册和密码恢复页面提交时的响应来完成的。
- en: In this recipe, we will use a list of common usernames to submit multiple requests
    to an application and figure out which of the submitted names belongs to an existing
    user by comparing the responses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将使用一个常见用户名列表，向应用程序提交多个请求，并通过比较响应来找出哪些提交的名字属于现有用户。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the WebGoat application in the vulnerable virtual
    machine `vm_1` and Burp Suite as proxy to our browser in Kali Linux.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，我们将在易受攻击的虚拟机 `vm_1` 中使用 WebGoat 应用程序，并将 Burp Suite 作为代理连接我们的 Kali Linux
    浏览器。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Almost all applications offer the user the possibility of recovering or resetting
    their password when it is forgotten. It''s not uncommon to find that these applications
    also tell when a non-existent username has been provided; this can be used to
    figure out a list of existing names:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序都提供用户在忘记密码时恢复或重置密码的功能。并且在这些应用程序中，通常会显示当提供了一个不存在的用户名时，这可以用来推断出一个有效用户名列表：
- en: From Kali Linux, browse to WebGoat (`http://192.168.56.11/WebGoat/attack`),
    and, if a login dialog pops up, use `webgoat` as both the username and password.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Kali Linux 中，浏览到 WebGoat（`http://192.168.56.11/WebGoat/attack`），如果弹出登录对话框，请使用
    `webgoat` 作为用户名和密码。
- en: 'Once in WebGoat, go to Authentication Flaws | Forgot Password. If we submit
    any random username and that user does not exist in the database, we will receive
    a message saying that the username is not valid:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 WebGoat 后，转到身份验证缺陷 | 忘记密码。如果我们提交任何随机的用户名，而该用户在数据库中不存在，我们将收到一条消息，提示该用户名无效：
- en: '![](assets/8baf0541-9d22-4eae-a1bd-d8d3450adbbf.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8baf0541-9d22-4eae-a1bd-d8d3450adbbf.png)'
- en: We can then assume that the response will be different when a valid username
    is provided. To test this, send the request to Intruder. In Burp's history, it
    should be a `POST` request to `http://192.168.56.11/WebGoat/attack?Screen=64&menu=500`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以假设当提供有效用户名时，响应会有所不同。为了验证这一点，将请求发送到 Intruder。在 Burp 的历史记录中，它应该是一个 `POST`
    请求，指向 `http://192.168.56.11/WebGoat/attack?Screen=64&menu=500`。
- en: 'Once in Intruder, leave the username as the only insertion position:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 Intruder 后，将用户名设置为唯一的插入位置：
- en: '![](assets/7940ce04-40fa-4c6a-8e5b-2a525323630e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7940ce04-40fa-4c6a-8e5b-2a525323630e.png)'
- en: 'Then, go to Payloads to set the list of users we will use in the attack. Leave
    the type as Simple List and click on the Load button to load the `/usr/share/wordlists/metasploit/http_default_users.txt` file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 Payloads 设置我们将在攻击中使用的用户名列表。将类型保持为 Simple List，并点击加载按钮加载 ` /usr/share/wordlists/metasploit/http_default_users.txt`
    文件：
- en: '![](assets/69138945-5c36-470a-baef-923c662c94d1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/69138945-5c36-470a-baef-923c662c94d1.png)'
- en: Now that we know the message when a user doesn't exist, we can use Burp to tell
    us when that message appears in the results. Go to Options | Grep - Match and
    clear the list.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道当用户不存在时的消息后，可以使用 Burp 来告诉我们该消息何时出现在结果中。进入选项 | Grep - Match 并清除列表。
- en: 'Add a new string to match `Not a valid username`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的字符串来匹配 `Not a valid username`：
- en: '![](assets/3287dab6-be24-4047-b142-0aaade525fe4.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3287dab6-be24-4047-b142-0aaade525fe4.png)'
- en: 'Now, start the attack. Notice how there are some names, such as `admin`, in
    which the message of an invalid username is not marked by Burp Suite; those are
    the ones that are valid names within the application:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始攻击。注意一些用户名，例如 `admin`，它们的无效用户名消息没有被 Burp Suite 标记；这些就是应用程序中有效的用户名：
- en: '![](assets/40ce6475-0bee-45ef-b7f6-e7ffa5428302.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/40ce6475-0bee-45ef-b7f6-e7ffa5428302.png)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If we are testing a web application that requires a username and password to
    perform any task, we need to evaluate how an attacker could discover valid usernames
    and passwords. The slightest difference in responses to valid and invalid users
    in the login, registration, and password recovery pages will let us find the first
    piece of information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在测试一个需要用户名和密码才能执行任何操作的 Web 应用程序，我们需要评估攻击者可能如何发现有效的用户名和密码。登录、注册和密码恢复页面中对于有效和无效用户响应的最细微差异，都能让我们找到第一条信息。
- en: Analyzing the differences in responses to similar requests is a task we will
    always be performing as penetration testers. Here, we used Burp Suite's tools,
    such as a proxy to record the original request, and Intruder to repeat it many
    times with variations in the value of a variable (username). Intruder also allowed
    us to automatically search for a string and indicated to us in which responses
    that string was found.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分析对相似请求的响应差异是我们作为渗透测试人员始终会执行的任务。在这里，我们使用了 Burp Suite 的工具，例如代理来记录原始请求，使用 Intruder
    多次发送请求并改变变量（用户名）的值。Intruder 还允许我们自动搜索字符串，并告诉我们该字符串在响应中出现的位置。
- en: Dictionary attack on login pages with Burp Suite
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 进行登录页面的字典攻击
- en: Once we have a list of valid usernames for our target application, we can try
    a brute force attack, which tries all possible character combinations until a
    valid password is found. Brute force attacks are not feasible in web applications
    due to the enormous number of combinations and the response times between client
    and server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了目标应用程序的有效用户名列表，就可以尝试暴力破解攻击，它会尝试所有可能的字符组合，直到找到有效密码。由于字符组合的巨大数量以及客户端与服务器之间的响应时间，暴力破解攻击在
    Web 应用程序中是不可行的。
- en: A more realistic solution is a dictionary attack, which takes a reduced list
    of highly probable passwords and tries them with a valid username.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的解决方案是字典攻击，它使用一个经过精简的高概率密码列表，并尝试与有效用户名组合。
- en: In this recipe, we will use Burp Suite Intruder to attempt a dictionary attack
    over a login page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用 Burp Suite Intruder 来尝试在登录页面上进行字典攻击。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use the WackoPicko admin section login to test this attack:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 WackoPicko 管理员部分的登录来测试此攻击：
- en: First, we set up Burp Suite as a proxy to our browser.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 Burp Suite 设置为代理我们的浏览器。
- en: Browse to `http://192.168.56.102/WackoPicko/admin/index.php?page=login`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`http://192.168.56.102/WackoPicko/admin/index.php?page=login`。
- en: We will see a login form. Let's try `test` for both username and password.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会看到一个登录表单。让我们尝试`test`作为用户名和密码。
- en: Now, go to Proxy's history and look for the `POST` request we just made with
    the login attempt and send it to Intruder.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到Proxy的历史记录，查找我们刚刚用来登录尝试的`POST`请求，并将其发送到Intruder。
- en: Click on Clear § to clear the pre-selected insertion positions.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Clear §”以清除预选的插入位置。
- en: 'Now, we add insertion positions on the values of the two `POST` parameters
    (`adminname` and `password`) by highlighting the value of the parameter and clicking
    Add §:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过高亮显示两个`POST`参数（`adminname`和`password`）的值，并点击“Add §”来添加插入位置：
- en: 'As we want our list of passwords to be tried against all users, we select Cluster
    bomb as the attack type:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望将密码列表尝试应用到所有用户，我们选择Cluster bomb作为攻击类型：
- en: '![](assets/f37456a1-ed4e-4dbf-98c9-111d986b7e3b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f37456a1-ed4e-4dbf-98c9-111d986b7e3b.png)'
- en: The next step is to define the values that Intruder is going to test against
    the inputs we selected. Go to the Payloads tab.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义Intruder将测试的输入值。转到Payloads选项卡。
- en: 'In the textbox in the Payload Options [Simple list] section, add the following
    names:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Payload Options [Simple list]部分的文本框中，添加以下名称：
- en: '`user`'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`'
- en: '`john`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`john`'
- en: '`admin`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin`'
- en: '`alice`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alice`'
- en: '`bob`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bob`'
- en: '`administrator`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`administrator`'
- en: '![](assets/8f671aca-19b3-46b5-8c67-4219ef59c898.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8f671aca-19b3-46b5-8c67-4219ef59c898.png)'
- en: 'Now, select list 2 from the Payload set box. This list will be our password
    list and we''ll use the 25 most common passwords of 2017 for this exercise ([http://time.com/5071176/worst-passwords-2017/](http://time.com/5071176/worst-passwords-2017/)):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从Payload set框中选择列表2。这个列表将是我们的密码列表，我们将使用2017年最常见的25个密码进行此练习（[http://time.com/5071176/worst-passwords-2017/](http://time.com/5071176/worst-passwords-2017/)）：
- en: '![](assets/75f20419-7676-4492-9abf-c82229dd0c6b.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75f20419-7676-4492-9abf-c82229dd0c6b.png)'
- en: 'Start the attack. We can see that all responses seem to have the same length
    apart from one: the `admin`/`admin` combination has a status 303 (a redirection)
    and a minor length. If we check it, we can see that it''s a redirection to the
    admin''s home page:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动攻击。我们可以看到，除了一条外，所有响应的长度似乎都相同：`admin`/`admin`组合的状态是303（重定向）且长度较小。如果我们检查它，会发现它是重定向到管理员主页：
- en: '![](assets/b8db4135-d63d-40ca-b63c-980f3a055b8f.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8db4135-d63d-40ca-b63c-980f3a055b8f.png)'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As for the results, we can see that all failed login attempts get the same response,
    but one has status 200 (OK) and that is 813 bytes long in this case, so we suppose
    that a successful one would have to be different, at least in length (as it will
    have to redirect or send the user to their home page). If it transpires that successful
    and failed requests are the same length, we can also check the status code or
    use the search box to look for a specific pattern in responses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 至于结果，我们可以看到所有失败的登录尝试都得到了相同的响应，但其中有一个返回状态200（OK），且长度为813字节，因此我们推测，成功的请求至少在长度上会有所不同（因为它需要重定向或将用户发送到主页）。如果成功和失败的请求长度相同，我们也可以检查状态码，或使用搜索框查找响应中的特定模式。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Kali Linux includes a very useful collection of password dictionaries and wordlists
    in `/usr/share/wordlists`. Some files you will find there are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux包含一组非常有用的密码字典和词汇表，存储在`/usr/share/wordlists`目录中。你会在那里找到一些文件，如下所示：
- en: '`rockyou.tar.gz`: The RockYou website was hacked in December 2010, more than
    14 million passwords were leaked, and this list includes them. These passwords
    are archived in this file, so you will need to decompress it before using it:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rockyou.tar.gz`：RockYou网站于2010年12月被黑客攻击，超过1400万个密码被泄露，这个列表包含了这些密码。这些密码存储在该文件中，因此在使用之前需要解压：'
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`dnsmap.txt`: Contains common subdomain names, such as `intranet`, `ftp`, or
    `www`; it is useful when brute forcing a DNS server.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnsmap.txt`：包含常见的子域名，如`intranet`、`ftp`或`www`；在暴力破解DNS服务器时非常有用。'
- en: '`/dirbuster/*`: The `dirbuster` directory contains names of files commonly
    found in web servers; these files can be used when using DirBuster or OWASP-ZAP''s
    Forced Browse.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dirbuster/*`：`dirbuster`目录包含常见Web服务器文件的名称；这些文件可以在使用DirBuster或OWASP-ZAP的强制浏览时使用。'
- en: '`/wfuzz/*`: Inside this directory, we can find a large collection of fuzzing
    strings for web attacks and brute forcing files.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/wfuzz/*`：在此目录中，我们可以找到用于Web攻击和暴力破解文件的大量模糊字符串。'
- en: '`/metasploit/*`: This directory contains all default dictionaries used by Metasploit
    Framework plugins. It contains dictionaries with default passwords for multiple
    services, hostnames, usernames, filenames, and many others.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/metasploit/*`：该目录包含Metasploit框架插件使用的所有默认字典。它包含多个服务、主机名、用户名、文件名等的默认密码字典。'
- en: Brute forcing basic authentication with Hydra
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hydra进行基本认证的暴力破解
- en: THC Hydra (or simply Hydra) is a network online logon cracker; this means it
    can be used to find login passwords by brute forcing active network services.
    Among the many services Hydra supports, we can find HTTP form login and HTTP basic
    authentication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: THC Hydra（简称Hydra）是一个网络在线登录破解工具；这意味着它可以通过暴力破解活跃的网络服务来查找登录密码。在Hydra支持的众多服务中，我们可以找到HTTP表单登录和HTTP基本认证。
- en: 'In HTTP basic authentication, the browser sends the username and password,
    encoded using base64 encoding, in the `Authorization` header. For example, if
    the username is `admin` and the password is `Password`, the browser will encode
    `admin:Password`, resulting in the string `*YWRtaW46UGFzc3dvcmQ=*` and the request
    header will have a line such as this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP基本认证中，浏览器会将用户名和密码使用base64编码后发送到`Authorization`头部。例如，如果用户名是`admin`，密码是`Password`，浏览器会将`admin:Password`编码为`*YWRtaW46UGFzc3dvcmQ=*`，然后请求头中会包含如下内容：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Almost every time we see a seemingly random alphanumeric string ending in one
    or two equal to (=) symbols, that string is base64 encoded. We can easily decode
    it using Burp Suite's Decoder or the `base64` command in Kali Linux. The = symbol
    may be encoded to be URL-friendly, that is, replaced by `%3D` in some requests
    and responses.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每次我们看到一个看似随机的字母数字字符串，并以一个或两个等号（=）符号结尾时，这个字符串都是base64编码的。我们可以轻松地使用Burp Suite的Decoder或Kali
    Linux中的`base64`命令来解码它。`=`符号可能会被编码为URL友好形式，即在某些请求和响应中会被替换为`%3D`。
- en: In the previous recipe, we used Burp Suite's Intruder to attack a login form;
    in this recipe, we will use THC Hydra to attack a different login mechanism, HTTP
    basic authentication.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的教程中，我们使用了Burp Suite的Intruder来攻击登录表单；在本教程中，我们将使用THC Hydra来攻击另一种登录机制——HTTP基本认证。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As well as the password list we used in the previous recipe, in order to execute
    this dictionary attack, we will need to have a username list. We will assume we
    already did our reconnaissance and obtained several valid usernames. Create a
    text file (ours will be `user_list.txt`) containing the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前面的教程中使用的密码列表外，为了执行这个字典攻击，我们还需要一个用户名列表。我们假设已经进行了侦察，并获得了几个有效的用户名。创建一个文本文件（我们将其命名为`user_list.txt`），其中包含以下内容：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the directory where both users and password dictionaries are stored in our
    Kali Linux VM, we do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们Kali Linux虚拟机中存放用户名和密码字典的目录下，我们执行以下操作：
- en: Open a terminal and run `hydra`, or use the Applications menu in Kali Linux
    Applications | 05 - Password Attacks | Online Attacks | Hydra.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`hydra`，或者在Kali Linux的应用程序菜单中选择Applications | 05 - 密码攻击 | 在线攻击 | Hydra。
- en: 'Issuing the command without arguments displays the basic help:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入没有参数的命令会显示基本的帮助信息：
- en: '![](assets/0d2669ca-f425-4b6b-a51a-1ffe33f97b83.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0d2669ca-f425-4b6b-a51a-1ffe33f97b83.png)'
- en: Here, we can see some useful information for what we want to do. By using the
    `-L` option, we can use a file containing possible usernames. `-P` allows us to
    use a password dictionary. We need to end the command with the service we want
    to attack, followed by `://` and the server, and, optionally, the port number
    and service options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些有用的信息，帮助我们完成目标。通过使用`-L`选项，我们可以使用包含可能用户名的文件。`-P`允许我们使用密码字典。我们需要在命令后加上我们要攻击的服务，后接`://`和服务器地址，最后可选加上端口号和服务选项。
- en: 'In the terminal, issue the following command to execute the attack:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入以下命令以执行攻击：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](assets/edbc5a52-c3d6-45d4-a51b-84fa649fd3aa.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edbc5a52-c3d6-45d4-a51b-84fa649fd3aa.png)'
- en: Hydra found two different username/password combinations that successfully logged
    in to the server.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Hydra找到两个不同的用户名/密码组合，成功登录到服务器。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unlike other authentication methods, such as the form-based one, basic authentication
    is standard in what it sends to the server, how it sends it, and the response
    it expects from it. This allows attackers and penetration testers to save precious analysis time
    on which parameters contain the username and password, how are they processed
    and sent, and how to distinguish a successful response from an unsuccessful one.
    This is one of the many reasons why basic authentication is not considered a secure
    mechanism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他身份验证方法（如基于表单的认证）不同，基本身份验证在发送给服务器的内容、发送方式以及期望的响应上是标准化的。这使得攻击者和渗透测试人员可以节省宝贵的分析时间，不用关注哪些参数包含用户名和密码，如何处理和发送它们，以及如何区分成功和失败的响应。这是基本身份验证被认为不安全的众多原因之一。
- en: 'When calling Hydra, we used some parameters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 Hydra 时，我们使用了一些参数：
- en: '`-L user_list.txt` tells Hydra to take the usernames from the `user_list.txt` file.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L user_list.txt` 告诉 Hydra 从 `user_list.txt` 文件中获取用户名。'
- en: '`-P top25_passwords.txt` tells Hydra to take the prospective passwords from
    the `top25_passwords.txt` file.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P top25_passwords.txt` 告诉 Hydra 从 `top25_passwords.txt` 文件中获取可能的密码。'
- en: '`-u`—Hydra will iterate usernames first, instead of passwords. This means that
    Hydra will try all usernames with a single password first and then move on to
    the next password. This is sometimes useful to prevent account blocking.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`—Hydra 将首先遍历用户名，而不是密码。这意味着 Hydra 将首先尝试所有用户名与一个密码的组合，然后再尝试下一个密码。这在某些情况下有助于防止账户被锁定。'
- en: '`-e ns`—Hydra will try an empty password (`n`) and the username as password
    (`s`) as well as the list provided.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e ns`—Hydra 会尝试空密码（`n`）和用户名作为密码（`s`），以及提供的密码列表。'
- en: '`http-get` indicates that Hydra will be executed against HTTP basic authentication
    using `GET` requests.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-get` 表示 Hydra 将针对 HTTP 基本身份验证执行 `GET` 请求。'
- en: The service is followed by `://` and the target server (`192.168.56.11`). After
    the next `/`, we put the server's options, in this case the URL where the authentication
    is requested. The port is not specified and Hydra will try the default one, TCP
    `80`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务后跟着 `://` 和目标服务器（`192.168.56.11`）。接下来的 `/` 后是服务器的选项，在本例中是请求身份验证的 URL。端口未指定，Hydra
    将尝试默认的 TCP `80`。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: It is not recommended performing brute force attacks or dictionary attacks with
    large numbers of passwords on production servers because we risk interrupting
    the service, blocking valid users, or being blocked by our client's protection
    mechanisms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在生产服务器上执行暴力破解攻击或字典攻击，特别是在密码数量较多的情况下，因为这样可能会导致服务中断、有效用户被阻止，或者被客户的保护机制封锁。
- en: 'It is recommended, as a penetration tester, performing this kind of attack
    using a maximum of four login attempts per user to avoid a blockage; for example,
    we could try `-e ns`, as we did here, and add `-p 123456` to cover three possibilities:
    no password, the password is the same as the username, and the password is `123456`,
    which is one of the most common passwords in the world.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员，建议每个用户执行此类攻击时最多进行四次登录尝试，以避免被阻止；例如，我们可以像这里一样尝试 `-e ns`，并添加 `-p 123456`
    来覆盖三种可能性：没有密码、密码与用户名相同，以及密码是 `123456`，这是全球最常见的密码之一。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'So far, we have seen two authentication methods in web applications, namely,
    form-based authentication and basic authentication. These are not the only ones
    used by developers; the reader is encouraged to further investigate advantages,
    weaknesses, and possible implementation failures in methods such as:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在 web 应用程序中看到两种身份验证方法，即基于表单的身份验证和基本身份验证。这些并不是开发人员使用的唯一方法；建议读者进一步调查其他方法的优缺点，以及可能的实现失败，例如：
- en: '**Digest authentication**: This is significantly more secure than basic authentication.
    Instead of sending the username and password encoded in the header, the client
    calculates the MD5 hash of a value provided by the server, called a nonce, together
    with their credentials, and sends this hash to the server, which already knows
    the nonce, username, and password, and can recalculate the hash and compare both
    values.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要认证**：这种认证方法比基本认证更加安全。客户端不会直接将用户名和密码编码在请求头中，而是计算由服务器提供的一个称为 nonce 的值与其凭证一起的
    MD5 哈希值，并将此哈希值发送到服务器。服务器已经知道 nonce、用户名和密码，并可以重新计算哈希并比较两个值。'
- en: '**NTLM/Windows authentication**: Following the same principle as digest, NTLM
    authentication uses Windows credentials and the NTLM hashing algorithm to process
    a challenge provided by the server. This scheme requires multiple request-response
    exchanges, and the server and any intervening proxies must support persistent
    connections.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NTLM/Windows 认证**：与摘要认证遵循相同原理，NTLM 认证使用 Windows 凭证和 NTLM 哈希算法来处理服务器提供的挑战。该方案需要多次请求-响应交换，且服务器和任何中间代理必须支持持久连接。'
- en: '**Kerberos authentication**: This authentication scheme makes use of the Kerberos
    protocol to authenticate to a server. As with NTLM, it doesn''t ask for a username
    and password, but it uses Windows credentials to log in.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kerberos 认证**：该认证方案利用 Kerberos 协议来进行服务器认证。与 NTLM 一样，它不要求输入用户名和密码，而是使用 Windows
    凭证进行登录。'
- en: '**Bearer tokens**: A bearer token is a special value, usually a randomly generated
    long string or a base64-encoded data structure signed using a cryptographic hashing
    function, which grants access to any client that presents it to the server.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bearer Token（持有者令牌）**：持有者令牌是一种特殊值，通常是一个随机生成的长字符串或一个经过加密哈希函数签名的 base64 编码数据结构，它授予任何向服务器提供该令牌的客户端访问权限。'
- en: Attacking Tomcat's passwords with Metasploit
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Metasploit 攻击 Tomcat 的密码
- en: Apache Tomcat is one of the most widely used servers for Java web applications
    in the world. It is also very common to find a Tomcat server with some configurations
    left by default. Among those configurations, it is surprisingly common to find
    that a server has the manager web application exposed, that is, the application
    that allows the administrator to start, stop, add, and delete applications in
    the server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Tomcat 是全球最广泛使用的 Java Web 应用服务器之一。通常可以发现 Tomcat 服务器存在一些默认配置。在这些配置中，惊人地常见的是服务器暴露了管理应用程序，即允许管理员启动、停止、添加和删除服务器中的应用程序的那个应用程序。
- en: In this recipe, we will use a Metasploit module to perform a dictionary attack
    over a Tomcat server in order to obtain access to its manager application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用 Metasploit 模块对 Tomcat 服务器执行字典攻击，以便获得其管理应用的访问权限。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'If it''s the first time you have run Metasploit Framework, you need to start
    the database service and initialize it. Metasploit uses a PostgreSQL database
    to store the logs and results, so the first thing we do is start the service:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次运行 Metasploit Framework，你需要启动数据库服务并初始化它。Metasploit 使用 PostgreSQL 数据库来存储日志和结果，所以我们首先要做的是启动服务：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we use the Metasploit database tool to create and initialize the database:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 Metasploit 数据库工具来创建并初始化数据库：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we start the Metasploit console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动 Metasploit 控制台：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](assets/876cafce-d3dc-4884-8273-bcf4de22fd54.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/876cafce-d3dc-4884-8273-bcf4de22fd54.png)'
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We could use Hydra or Burp Suite to attack the Tomcat server, but having alternative
    ways to do things in case something doesn''t work as expected, and using alternative
    tools, should be part of the skill set of any good penetration tester. So, we
    will use Metasploit in this recipe:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Hydra 或 Burp Suite 来攻击 Tomcat 服务器，但遇到某些不如预期的情况时，能够有备用的解决方案，并使用其他工具，应该是任何优秀渗透测试人员的技能之一。所以，我们在本教程中将使用
    Metasploit：
- en: 'The vulnerable virtual machine `vm_1` has a Tomcat server running on port `8080`.
    Browse to `http://192.168.56.11:8080/manager/html`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 漏洞虚拟机 `vm_1` 上运行着一个 Tomcat 服务器，端口为 `8080`。浏览器访问 `http://192.168.56.11:8080/manager/html`：
- en: '![](assets/f7c85495-777f-4131-b9e8-f1f6a3a1f905.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7c85495-777f-4131-b9e8-f1f6a3a1f905.png)'
- en: We get a basic authentication popup requesting a username and password.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到一个基本认证弹窗，要求输入用户名和密码。
- en: 'Open a terminal and start the Metasploit console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并启动 Metasploit 控制台：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When it finishes starting, we need to load the proper module. Type the following
    in the `msf>` prompt:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动完成后，我们需要加载合适的模块。在 `msf>` 提示符下输入以下内容：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We may want to see what parameter it uses:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能想查看它使用的参数：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we set our target hosts; in this case, it is only one:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置目标主机；在这种情况下，只有一个目标：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make it work a little faster, but not too fast, we increase the number of
    threads. This means requests sent in parallel:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让它运行得稍微快一点，但又不至于太快，我们增加线程数。这意味着并行发送请求：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, we don''t want our server to crash due to too many requests, so we lower
    the brute force speed:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，我们不希望由于请求过多导致服务器崩溃，因此我们降低了暴力破解速度：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](assets/556790f7-e7a8-4b81-84e3-94c4d97075f1.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/556790f7-e7a8-4b81-84e3-94c4d97075f1.png)'
- en: 'The remainder of the parameters work just as they are for our case, so let''s
    run the attack:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的参数与我们的案例一样工作，所以我们现在运行攻击：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After failing in some attempts, we will find a valid password, the one marked
    with a green `[+]` symbol:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几次尝试失败后，我们会找到一个有效的密码，那个被绿色 `[+]` 符号标记的密码：
- en: '![](assets/fddc467d-77fb-43cc-946f-694d57702340.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fddc467d-77fb-43cc-946f-694d57702340.png)'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By default, Tomcat uses TCP port `8080` and has its manager application in
    `/manager/html`. That application uses basic HTTP authentication. Metasploit''s
    auxiliary module we just used (`tomcat_mgr_login`) has some configuration options
    worth mentioning here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Tomcat 使用 TCP 端口 `8080`，并且其管理应用位于 `/manager/html`。该应用使用基本的 HTTP 身份验证。我们刚才使用的
    Metasploit 辅助模块（`tomcat_mgr_login`）有一些配置选项值得在这里提到：
- en: '`BLANK_PASSWORDS`: Adds a test with a blank password for every user tried'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLANK_PASSWORDS`：为每个测试的用户添加一个空密码的测试'
- en: '`PASSWORD`: Useful if we want to test a single password with multiple users
    or to add a specific one not included in the list'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASSWORD`：如果我们想测试一个密码在多个用户下的有效性，或是添加一个列表中未包含的特定密码，这个选项很有用。'
- en: '`PASS_FILE`: The password list we will use for the test'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASS_FILE`：我们将在测试中使用的密码列表'
- en: '`Proxies`: If we need to go through a proxy to reach our target, or to avoid
    detection, this is the option we need to configure'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proxies`：如果我们需要通过代理访问目标，或为了避免被检测到，我们需要配置此选项'
- en: '`RHOSTS`: The host, hosts (separated by spaces), or file with hosts (`file:
    /path/to/file/with/hosts`) we want to test'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RHOSTS`：我们想要测试的主机、主机列表（用空格分隔）或包含主机的文件（`file: /path/to/file/with/hosts`）'
- en: '`RPORT`: The TCP port in the hosts being used by Tomcat'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPORT`：Tomcat 在主机上使用的 TCP 端口'
- en: '`STOP_ON_SUCCESS`: Stop trying a host when a valid password is found for it'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOP_ON_SUCCESS`：当找到有效密码时停止对主机的进一步尝试'
- en: '`TARGERURI`: Location of the manager application inside the host'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TARGERURI`：主机内管理应用的位置'
- en: '`USERNAME`: Defines a specific username to test; it can be tested alone or
    added to the list defined in `USER_FILE`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USERNAME`：定义一个特定的用户名进行测试；它可以单独测试或添加到 `USER_FILE` 中定义的列表中'
- en: '`USER_PASS_FILE`: A file containing username/password combinations to be tested'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER_PASS_FILE`：包含用户名/密码组合的文件，用于测试'
- en: '`USER_AS_PASS`: Try every username in the list as its password'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER_AS_PASS`：将列表中的每个用户名作为其密码进行尝试'
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Once we gain access to a Tomcat server, we can see and manipulate (start, stop,
    restart, and delete) the applications installed therein:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了对 Tomcat 服务器的访问权限，我们可以查看并操作（启动、停止、重启和删除）安装在其中的应用程序：
- en: '![](assets/127d10f1-309e-4a54-ab1a-1fbf472f6398.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/127d10f1-309e-4a54-ab1a-1fbf472f6398.png)'
- en: 'Also, we can upload our own applications, including ones that execute commands
    in the server. It is left as an exercise to the reader to upload and deploy a
    webshell to the server and execute system commands in it. Kali Linux includes
    many useful webshell source codes in `/usr/share/webshells`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以上传自己的应用程序，包括那些在服务器上执行命令的应用程序。上传并部署一个 webshell 到服务器并在其中执行系统命令的练习留给读者自己完成。Kali
    Linux 在 `/usr/share/webshells` 中包含了许多有用的 webshell 源代码：
- en: '![](assets/f4d29781-6664-47d9-87a7-0e9048f7bc90.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4d29781-6664-47d9-87a7-0e9048f7bc90.png)'
- en: Manually identifying vulnerabilities in cookies
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动识别 Cookie 中的漏洞
- en: Cookies are pieces of information that servers store in the client computer,
    persistently or temporarily. In modern web applications, cookies are the most
    common way of keeping track of the user's session. By saving session identifiers
    generated by the server stored in the user's computer, the server is able to distinguish
    between different requests made from different clients at the same time. When
    any request is sent to the server, the browser adds the cookie and then sends
    the request so that the server can distinguish the session based on the cookie.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie 是服务器存储在客户端计算机中的信息，可以是持久性的也可以是临时的。在现代 Web 应用程序中，Cookie 是跟踪用户会话的最常见方式。通过将服务器生成的会话标识符保存在用户的计算机中，服务器能够区分同时来自不同客户端的请求。当任何请求发送到服务器时，浏览器会添加
    Cookie，然后发送请求，这样服务器就可以根据 Cookie 区分会话。
- en: In this recipe, we will see how to identify common vulnerabilities in cookies
    that would allow an attacker to hijack the session of a valid user.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看到如何识别 Cookie 中的常见漏洞，这些漏洞可能允许攻击者劫持有效用户的会话。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'It''s recommended to delete all cookies before doing this recipe. It may get
    confusing to have cookies from many different applications, as all of those applications
    are in the same server and all cookies belong to the same domain:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在执行此示例之前删除所有 cookie。因为来自不同应用程序的 cookie 可能会混淆，所有这些应用程序都在同一服务器上，并且所有 cookie
    都属于同一域：
- en: Browse to `http://192.168.56.11/WackoPicko/`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 `http://192.168.56.11/WackoPicko/`。
- en: We can use the Cookies Manager browser add-on to check the cookies' values and
    parameters. To do this, just click on the add-on's icon and it will display all
    cookies currently stored by the browser.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 Cookies Manager 浏览器插件来检查 cookie 的值和参数。为此，只需点击插件图标，它将显示浏览器当前存储的所有 cookie。
- en: 'Select any cookie, for example `PHPSESSID` from the domain `192.168.56.11`,
    and double-click on it, or click Edit to open a new dialog to view and be able
    to change all of its parameters:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何一个 cookie，例如来自域 `192.168.56.11` 的 `PHPSESSID`，然后双击它，或者点击编辑以打开新对话框查看并修改其所有参数：
- en: '![](assets/fb1cba3a-bf3a-4406-9a53-f011e1603116.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb1cba3a-bf3a-4406-9a53-f011e1603116.png)'
- en: '`PHPSESSID` is the default name of session cookies in PHP-based web applications.
    By looking at the parameter''s values in this cookie, we can see that it can be
    sent by secure and insecure channels (HTTP and HTTPS) and that it can be read
    by the server and also by the client through scripting code, because it doesn''t
    have the Secure (noticed by the Send For: Any type of connection parameter) and
    HTTP Only flags enabled. This means that the sessions in this application may
    be hijackable.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`PHPSESSID` 是基于 PHP 的 web 应用程序中会话 cookie 的默认名称。通过查看该 cookie 中参数的值，我们可以看到它可以通过安全和不安全通道（HTTP
    和 HTTPS）发送，并且可以通过服务器和客户端的脚本代码读取，因为它没有启用 Secure（通过“Send For: Any type of connection”参数可以看出）和
    HTTP Only 标志。这意味着该应用程序中的会话可能会被劫持。'
- en: 'We can also use the browser''s Developer Tools to view and modify cookie values.
    Open the Developer Tools and go to Storage:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用浏览器的开发者工具来查看和修改 cookie 值。打开开发者工具并进入存储：
- en: '![](assets/ad9794e9-5bfb-44e8-852d-1d1c55f938eb.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ad9794e9-5bfb-44e8-852d-1d1c55f938eb.png)'
- en: 'In this screenshot, we selected a cookie called `session`, which only has an
    effect over the WackoPicko directory in the server (given by the `Path` parameter);
    it will be erased when the browser is closed (`Expires: "Session"`) and as with `PHPSESSID`,
    it doesn''t have the `HttpOnly` and `Secure` flags enabled, hence it can be accessed
    via scripting (HttpOnly) and will be transmitted via either HTTP or HTTPS (Secure).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个截图中，我们选择了一个名为 `session` 的 cookie，它仅对服务器上的 WackoPicko 目录有效（由 `Path` 参数指定）；当浏览器关闭时它会被清除（`Expires:
    "Session"`），并且与 `PHPSESSID` 一样，它没有启用 `HttpOnly` 和 `Secure` 标志，因此可以通过脚本访问（HttpOnly），并且可以通过
    HTTP 或 HTTPS 传输（Secure）。'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we just checked some values of a cookie. Although not as spectacular
    as others, it is important to check the cookie configuration in every penetration
    test we perform; an incorrectly configured session cookie opens the door to a
    session hijacking attack and the misuse of a trusted user's account.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只是检查了一个 cookie 的一些值。虽然它不像其他示例那样引人注目，但在每次进行渗透测试时，检查 cookie 配置非常重要；配置错误的会话
    cookie 会导致会话劫持攻击，并可能滥用可信用户的帐户。
- en: If a cookie doesn't have the `HTTPOnly` flag enabled, it can be read by scripting,
    which means that if there is a **Cross-Site Scripting** (**XSS**) vulnerability,
    which we will see in later chapters, the attacker will be able to get the identifier
    of a valid session and use that value to impersonate the real user in the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 cookie 没有启用 `HTTPOnly` 标志，它可以被脚本读取，这意味着如果存在 **跨站脚本** (**XSS**) 漏洞（我们将在后面的章节中看到），攻击者将能够获取有效会话的标识符，并利用该值冒充真实用户在应用程序中的身份。
- en: The **Secure** attribute, or Send For Encrypted Connections Only in Cookies
    Manager, tells the browser to only send or receive this cookie over encrypted
    channels. This means sending only via an HTTPS connection. If this flag is not
    set, an attacker could perform a **man-in-the-middle** (**MiTM**) attack and force
    the communication to be unencrypted, exposing the session cookie in clear text,
    which takes us again to a scenario where the attacker can impersonate a valid
    user by having their session identifier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Secure** 属性，或在 Cookie 管理器中选择“仅在加密连接中发送”，告诉浏览器仅通过加密通道发送或接收此 cookie。这意味着仅通过
    HTTPS 连接发送。如果没有设置这个标志，攻击者可能会执行 **中间人攻击** (**MiTM**)，并迫使通信不加密，从而暴露会话 cookie 为明文，导致攻击者能够通过会话标识符冒充有效用户。'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As `PHPSESSID` is the default name for PHP session cookies, other platforms
    have known names for theirs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PHPSESSID` 是 PHP 会话 Cookie 的默认名称，其他平台也有已知的会话 Cookie 名称：
- en: '`ASP.NET_SessionId` is the name for an ASP .Net session cookie'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASP.NET_SessionId` 是 ASP .Net 会话 Cookie 的名称'
- en: '`JSESSIONID` is the session cookie for JSP implementations'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSESSIONID` 是 JSP 实现的会话 Cookie'
- en: 'OWASP has a very thorough article on securing session cookies: [https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 提供了一篇关于安全会话 Cookie 的非常详尽的文章：[https://www.owasp.org/index.php/Session_Management_Cheat_Sheet](https://www.owasp.org/index.php/Session_Management_Cheat_Sheet)。
- en: Attacking a session fixation vulnerability
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击会话固定漏洞
- en: When a user loads the home page of an application, it sets a session identifier,
    be it a cookie, token, or internal variable; if, once the user logs in to the
    application, this is when the user enters into a restricted area of the application
    that requires a username and password or other type of identification, this identifier
    is not changed, then the application may be vulnerable to session fixation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户加载应用程序的主页时，它会设置一个会话标识符，可以是 Cookie、令牌或内部变量；如果一旦用户登录应用程序并进入需要用户名和密码或其他身份验证的受限区域后，该标识符未发生更改，那么该应用程序可能会受到会话固定攻击的影响。
- en: A session fixation attack occurs when the attacker forces a session ID value
    into a valid user, and then this user logs in to the application and the ID provided
    by the attacker is not changed. This allows for the attacker to simply use the
    same session ID and hijack the user's session.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 会话固定攻击发生在攻击者将一个会话 ID 强制分配给一个有效用户，然后该用户登录应用程序时，攻击者提供的 ID 没有被更改。这使得攻击者可以简单地使用相同的会话
    ID 劫持用户的会话。
- en: In this recipe, we will learn the process of a session fixation attack by using
    one of the applications in the vulnerable virtual machine `vm_1`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将通过使用易受攻击的虚拟机 `vm_1` 中的一个应用程序来学习会话固定攻击的过程。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'WebGoat has a somewhat simplistic, yet very illustrative, exercise on session
    fixation. We will use it to illustrate how this attack can be executed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: WebGoat 提供了一个有些简单，但非常具说明性的会话固定练习。我们将利用它来展示如何执行这一攻击：
- en: In the Kali VM, log in to WebGoat and go to Session Management Flaws | Session
    Fixation in the menu.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kali 虚拟机中，登录到 WebGoat 并在菜单中选择 Session Management Flaws | Session Fixation。
- en: 'We are in the first stage of the attack. The description says we are an attacker
    attempting to send a phishing email to our victim to force a session ID of our
    choice. Replace the `href` value in the HTML code with the following (be careful
    of the capitalization as the server is case-sensitive):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处于攻击的第一阶段。描述中提到我们是攻击者，试图向受害者发送网络钓鱼邮件，以强制使用我们选择的会话 ID。将 HTML 代码中的 `href` 值替换为以下内容（请注意大小写，因为服务器对大小写敏感）：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](assets/b63138c4-4370-4142-a813-3ce168400300.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b63138c4-4370-4142-a813-3ce168400300.png)'
- en: The important part here is the `SID` parameter, which contains a session value
    controlled by us, the attacker.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是 `SID` 参数，它包含一个由我们（攻击者）控制的会话值。
- en: Click on Send Mail to go to STAGE 2.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“发送邮件”进入第二阶段。
- en: 'In STAGE 2, we take the perspective of the victim reading the malicious email.
    If you put your mouse over the link to Goat Hills Financial, you''ll notice that
    the destination URL contains the `SID` value we set as attackers:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，我们从受害者阅读恶意邮件的角度出发。如果你将鼠标悬停在 Goat Hills Financial 的链接上，你会注意到目标 URL 包含了我们作为攻击者设置的
    `SID` 值：
- en: '![](assets/6b01d3f9-77b8-48a6-9636-408043c723bb.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6b01d3f9-77b8-48a6-9636-408043c723bb.png)'
- en: Click on the link to move on to STAGE 3.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击链接进入第三阶段。
- en: 'Now that the victim is on the login page, use the credentials provided and
    log in. Notice how the `SID` value in the address bar is still the one we set:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在受害者已在登录页面，使用提供的凭据登录。请注意地址栏中的 `SID` 值仍然是我们设置的那个：
- en: '![](assets/d19bf421-2ab3-4331-8e54-f10c04ecb465.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d19bf421-2ab3-4331-8e54-f10c04ecb465.png)'
- en: Now, in STAGE 4, we are back to the attacker's perspective, and we have a link
    to Goat Hills Financial; click on it to go to the login page.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第四阶段，我们回到攻击者的视角，并且有一个链接指向 Goat Hills Financial；点击它进入登录页面。
- en: 'Notice how the address bar has a different `SID` value now; this would happen
    if we go to the login page without being authenticated. Use the browser''s developer
    tools to find and change the `action` parameter of the login form so that it has
    the session value we established in relation to the victim:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意地址栏现在有了不同的`SID`值；如果我们在没有认证的情况下访问登录页面，情况就会如此。使用浏览器的开发者工具查找并更改登录表单的`action`参数，以使其包含我们为受害者建立的会话值：
- en: '![](assets/d2cfc6ea-3ece-4dda-b6f1-30cd575f195e.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2cfc6ea-3ece-4dda-b6f1-30cd575f195e.png)'
- en: 'When the `SID` value is changed, click on Login; there''s no need to set any
    username or password as the fields are not validated:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`SID`值发生变化时，点击登录；无需设置用户名或密码，因为这些字段没有经过验证：
- en: '![](assets/c84eea11-7aed-4931-82b2-e4081ee2d698.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c84eea11-7aed-4931-82b2-e4081ee2d698.png)'
- en: By changing the `SID` parameter the login form uses when submitted, we tricked
    the server into thinking our request is coming from a valid, existing session.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改登录表单提交时使用的`SID`参数，我们欺骗了服务器，让它认为我们的请求来自一个有效的现有会话。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we followed the complete path of an attack involving social
    engineering, by sending an email containing a malicious link to a victim. This
    link exploited a session fixation vulnerability, which should have been previously
    discovered by the attacker, and when the victim user logs in to the application,
    it keeps the session ID provided by the attacker and links it to the user; this
    enables the attacker to manipulate his/her own parameters in the application to
    replicate the same ID, and thereby hijack a valid user's session.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们跟踪了一个涉及社交工程的攻击路径，通过向受害者发送一封包含恶意链接的邮件。这个链接利用了会话固定漏洞，攻击者应该在之前发现这个漏洞，并且当受害者用户登录应用时，会话ID保持由攻击者提供，并将其与用户关联；这使得攻击者能够在应用中操控自己的参数，以复制相同的ID，从而劫持有效用户的会话。
- en: Evaluating the quality of session identifiers with Burp Sequencer
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Sequencer评估会话标识符的质量
- en: Burp Suite's Sequencer requests thousands of session identifiers from the server
    (by repeating the login request, for example) and analyzes the responses to determine
    the randomness and cryptographic strength of the algorithm generating the identifiers.
    The stronger the algorithm, the harder for an attacker to replicate a valid ID.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite的Sequencer向服务器请求数千个会话标识符（例如，通过重复登录请求），并分析响应以确定生成标识符的算法的随机性和加密强度。算法越强，攻击者越难以复制有效的ID。
- en: In this recipe, we will use Burp Sequencer to analyze the session ID generation
    by two different applications and determine some characteristics of a secure session
    ID generation algorithm.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用Burp Sequencer来分析两个不同应用程序的会话ID生成，并确定一个安全的会话ID生成算法的一些特性。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use WebGoat and RailsGoat (a WebGoat version made with the Ruby on Rails
    framework). Both applications are available in the vulnerable VM (`vm_1`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用WebGoat和RailsGoat（WebGoat的Ruby on Rails框架版本）。这两个应用都可以在易受攻击的虚拟机（`vm_1`）中找到。
- en: You will need to create a user in RailsGoat; to do that, use the signup button
    on the main page.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在RailsGoat中创建一个用户；为此，请使用主页上的注册按钮。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start analyzing RailsGoat''s session cookie. We could have used any
    `PHPSESSID` or `JSESSIONID` cookie, but we will take advantage of this one being
    a custom value to review additional concepts. Configure your browser to use Burp
    Suite as a proxy and follow the next steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始分析RailsGoat的会话cookie。我们本可以使用任何`PHPSESSID`或`JSESSIONID`cookie，但我们将利用这个自定义值来审查额外的概念。配置你的浏览器以使用Burp
    Suite作为代理，并按照以下步骤操作：
- en: Log in to RailsGoat and look at the proxy's history for a response setting a
    session cookie. You should have the header `Set-Cookie` and should set a cookie
    called `_railsgoat_session`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到RailsGoat并查看代理的历史记录，寻找一个设置会话cookie的响应。你应该看到`Set-Cookie`头，并且应该设置一个名为`_railsgoat_session`的cookie。
- en: 'In this case, this is a request to `/railsgoat/session`. Right-click on the
    URL, or on the body of the request or response, and select Send to Sequencer:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，这是一个针对`/railsgoat/session`的请求。右键点击URL，或请求或响应的正文，并选择“发送到Sequencer”：
- en: '![](assets/0c3e56d6-af36-43ce-8d2d-d12fd639c290.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c3e56d6-af36-43ce-8d2d-d12fd639c290.png)'
- en: Before continuing with Sequencer, let's see what the session cookie contains.
    This `_railsgoat_session` cookie looks like a base64-encoded string joined to
    a hexadecimal string by two hyphens (`--`). We'll explain this deduction later
    in this recipe. Select the value of the cookie, right-click on it, and select
    Send to Decoder.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续进行Sequencer分析之前，先看看会话cookie包含了什么内容。这个`_railsgoat_session` cookie看起来像是一个base64编码的字符串，通过两个短横线（`--`）与十六进制字符串连接起来。我们将在本食谱的后续部分解释这一推断。选择cookie的值，右击它，选择“发送到解码器”。
- en: 'Once in decoder, we first decode it as a URL, and then, in the second line,
    we decode it as base64:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解码器中，首先将其解码为URL格式，然后在第二行中，将其解码为base64格式：
- en: '![](assets/82cdfc18-c854-4a00-ba43-5c97345a659a.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82cdfc18-c854-4a00-ba43-5c97345a659a.png)'
- en: 'It seems as if the base64 code contains three fields: `session_id`, which is
    a hexadecimal value, perhaps a hash; `csrf_token`, which is a value used to prevent
    **Cross-Site Request Forgery** (**CSRF**) attacks; and `user_id`, which seems
    to be just two characters, maybe a sequential number. The rest of the cookie (the
    part after the `--`) is not base64-encoded and appears to be a random hash. Now,
    we understand a little bit more about the session ID, and have learned a little
    bit about encoding and Burp Suite''s Decoder.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来base64编码中包含了三个字段：`session_id`，它是一个十六进制值，可能是一个哈希；`csrf_token`，它是用来防止**跨站请求伪造**（**CSRF**）攻击的一个值；以及`user_id`，它似乎只是两个字符，可能是一个顺序号。cookie的其余部分（`--`之后的部分）不是base64编码的，看起来像是一个随机哈希。现在，我们对会话ID有了更多了解，也学到了一些关于编码和Burp
    Suite解码器的知识。
- en: 'Let''s continue with our analysis in Sequencer. Go to the Sequencer tab in
    Burp Suite and ensure that the correct request and cookie are selected:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续在Sequencer中的分析。在Burp Suite的Sequencer标签页中，确保选中了正确的请求和cookie：
- en: '![](assets/b2b6360f-a9f6-46ef-894d-b685b4324138.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2b6360f-a9f6-46ef-894d-b685b4324138.png)'
- en: We know the cookie is encoded with base64; go to Analysis Options and select
    Base64-decode before analyzing. This way, Burp Suite will analyze the decoded
    information in the cookie.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道这个cookie是用base64编码的；在分析之前，进入分析选项并选择Base64解码。这样，Burp Suite就会分析cookie中的解码信息。
- en: Go back to the Live capture tab and click on Start live capture. A new window
    will appear; we wait for it to finish. It'll take some time.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到实时捕获标签页，点击开始实时捕获。会弹出一个新窗口，我们等待它完成。可能需要一些时间。
- en: 'Once it is finished, click on Analyze now:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击现在分析：
- en: '![](assets/70e32361-df92-4aa9-b733-59c7fc258aef.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70e32361-df92-4aa9-b733-59c7fc258aef.png)'
- en: We can see that the cookie is of excellent quality; this means it is not easily
    guessable by an attacker. Feel free to explore all the result tabs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个cookie的质量极好，这意味着攻击者不容易猜测它。可以自由浏览所有的结果标签页。
- en: That was an example of a good quality session cookie; let's see a not-so-good
    one this time. Log in to WebGoat and go to Session Management Flaws | Hijack a
    Session.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个质量良好的会话cookie的示例；这次我们来看看一个质量较差的。登录WebGoat并进入会话管理漏洞 | 劫持会话。
- en: 'This exercise is about bypassing a login form by hijacking a valid session
    ID. Attempt a login with any random username and password, just to get it recorded
    in Burp Suite:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本次练习是关于通过劫持有效会话ID来绕过登录表单。尝试使用任意随机的用户名和密码进行登录，仅仅是为了让它被记录在Burp Suite中：
- en: '![](assets/3ef404d9-ba39-45fc-86b4-0cf6a3a96426.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ef404d9-ba39-45fc-86b4-0cf6a3a96426.png)'
- en: 'In this case, the request that sets the session cookie is the one that first
    loads the exercise; search in Burp Suite''s history for the `Set-Cookie: WEAKID=`
    response header. This ID is merely numbers separated by a hyphen.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在这种情况下，设置会话cookie的请求是首先加载练习的请求；在Burp Suite的历史记录中搜索`Set-Cookie: WEAKID=`响应头。这个ID仅仅是由短横线分隔的数字。'
- en: Send the request to Sequencer.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求到Sequencer。
- en: Select the `WEAKID` cookie as the target to analyze.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`WEAKID` cookie作为目标进行分析。
- en: 'Start the live capture and wait for it to finish and execute the analysis:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实时捕获并等待其完成后执行分析：
- en: '![](assets/41065b0d-2dba-449b-9310-f9f4634dc3e3.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41065b0d-2dba-449b-9310-f9f4634dc3e3.png)'
- en: 'For this ID, we can see that the quality is extremely poor. Going to the character
    analysis, we can have a better idea:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个ID，我们可以看到质量极差。进入字符分析，我们可以更好地了解：
- en: '![](assets/88ec218d-cb3c-44a3-bdf9-c6faf0b7d8e2.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88ec218d-cb3c-44a3-bdf9-c6faf0b7d8e2.png)'
- en: This chart shows the degree of change or significance for each character position.
    We see that significance increases from position **2** to position **3** and from
    **3** to **4**, to then fall again in **5**, which is the location of the hyphen.
    This suggests that the first part of the ID is incremental and that the same may
    apply to the second part, but with a different rate.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表展示了每个字符位置的变化或重要程度。我们看到从位置**2**到位置**3**，以及从**3**到**4**的重要性增加，然后在**5**处（即连字符的位置）再次下降。这表明
    ID 的第一部分是递增的，第二部分也可能是递增的，但变化的速率不同。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Burp Suite's Sequencer performs different statistical analyses on large amounts
    of session identifiers (or whatever piece of information from a response we provide
    to it) to determine whether such data is being randomly generated or whether there
    may be a predictable pattern that may allow an attacker to generate a valid ID
    and hijack a session with it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 的 Sequencer 对大量会话标识符（或我们提供的响应中的任何数据）进行不同的统计分析，以确定这些数据是否是随机生成的，还是可能存在可预测的模式，攻击者可以利用这种模式生成有效的
    ID 并劫持会话。
- en: First, we analyzed a complex session cookie composed by a data structure encoded
    using the base64 algorithm and what seems to be an SHA-1 hash. We can tell that
    the first part is base64-encoded because it contains lowercase and uppercase letters,
    numbers, may also contain a plus symbol (`+`) or a slash (`/`), and it also ends
    in `%3D`, which is the URL escape sequence for `=`, a string terminator in base64\.
    We say the second part of the cookie is an SHA-1 hash because it is a hexadecimal
    string of 40 digits; each hexadecimal digit represents 4 bits, and 4 bits * 40
    digits = 160 bits; and SHA-1 is the most popular 160-bit hashing algorithm.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们分析了一个复杂的会话 cookie，它由一个使用 base64 算法编码的数据结构和看似是 SHA-1 哈希组成。我们可以通过它包含大小写字母、数字，并且可能还包含加号（`+`）或斜杠（`/`），并且以
    `%3D` 结尾（这是 `=` 的 URL 转义序列），从而判断第一部分是 base64 编码的。我们说 cookie 的第二部分是 SHA-1 哈希，因为它是一个由
    40 位十六进制数字组成的字符串；每个十六进制数字代表 4 个比特，4 个比特 * 40 位 = 160 位；而 SHA-1 是最流行的 160 位哈希算法。
- en: Then, we analyzed a weakly generated session ID. It's rather obvious that it
    is incremental, since in decimal numbers, the digit in the rightmost position
    changes ten times more frequently than its closest left-hand neighbor. The second
    part of the ID, based on its length and most significant digits, suggests a Unix
    timestamp ([https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分析了一个生成较弱的会话 ID。显然它是递增的，因为在十进制数字中，最右侧的位置的数字变化频率是其最左边相邻位置的十倍。ID 的第二部分，根据其长度和最重要的数字，暗示它是一个
    Unix 时间戳（[https://en.wikipedia.org/wiki/Unix_time](https://en.wikipedia.org/wiki/Unix_time)）。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: Dig further into the generation mechanisms for the `WEAKID` session cookie and
    try to figure out a way of discovering an active session cookie to bypass the
    login. Use Burp Suite's Repeater and Intruder to facilitate the job.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究`WEAKID`会话 cookie 的生成机制，尝试找出一种方法来发现活动的会话 cookie，以绕过登录。使用 Burp Suite 的 Repeater
    和 Intruder 工具来帮助完成此任务。
- en: 'To learn more about how to distinguish encoding, hashing, and encryption, check
    out this excellent article: [https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何区分编码、哈希和加密的内容，可以查看这篇精彩的文章：[https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/)。
- en: Abusing insecure direct object references
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滥用不安全的直接对象引用
- en: A direct object reference is when an application uses input provided by the
    client to access a server-side resource by name or other simple identifier, for
    example, using a file parameter to search for a specific file in the server and
    allowing the user to access it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 直接对象引用是指应用程序使用客户端提供的输入，通过名称或其他简单标识符访问服务器端资源，例如，使用文件参数在服务器中搜索特定文件并允许用户访问它。
- en: If the application doesn't properly validate the value provided by the user,
    and that such a user is allowed to access the resource, an attacker can take advantage
    of this to bypass privilege level controls and access files or information not
    authorized for that user.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有正确验证用户提供的值，并且允许该用户访问资源，攻击者可以利用这一点绕过权限控制，访问该用户未授权的文件或信息。
- en: In this recipe, we will analyze and exploit a simple example of this vulnerability
    in the RailsGoat application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将分析并利用RailsGoat应用中的这一简单漏洞。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to have at least two users registered in RailsGoat.
    One of them will be the victim with the username `user`, and the other one will
    be the attacker, called `attacker`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本次练习，我们需要在RailsGoat中注册至少两个用户。其中一个是用户名为`user`的受害者，另一个是用户名为`attacker`的攻击者。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this exercise, it is preferable that we know the passwords for both users,
    although we only really need to know the attacker's password in a real-life scenario.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本次练习，最好我们知道两个用户的密码，尽管在真实场景中我们实际上只需要知道攻击者的密码。
- en: 'Configure the browser to use Burp Suite as a proxy and do the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 配置浏览器使用Burp Suite作为代理，并执行以下操作：
- en: 'Log in as the `user` and go to account settings; click on the profile picture
    (top right-hand corner) and account settings:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`user`身份登录并进入账户设置；点击个人资料图片（右上角）和账户设置：
- en: '![](assets/a3142d8a-3ff9-44df-a250-00f4a210c2ec.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a3142d8a-3ff9-44df-a250-00f4a210c2ec.png)'
- en: Notice that, in our example, the URL says `users/7/account_settings`. Could
    it be that that number `7` is a user ID?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的示例中，URL显示为`users/7/account_settings`。这是否意味着数字`7`是用户ID？
- en: Log out and log in as the `attacker`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出并以`attacker`身份登录。
- en: Go to account settings again and observe that the URL for the attacker settings
    has a different number.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次进入账户设置，观察攻击者设置的URL是否有不同的数字。
- en: Enable request interception in Burp Suite.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Burp Suite中启用请求拦截。
- en: Change the password for the attacking user. Set a new password, confirm it,
    and click Submit.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改攻击者用户的密码。设置一个新密码，确认并点击提交。
- en: 'Let''s analyze the intercepted request:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分析拦截到的请求：
- en: '![](assets/6379899b-3fa1-441c-856a-6cb5a3079221.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6379899b-3fa1-441c-856a-6cb5a3079221.png)'
- en: Let's focus on the underlined parts of the screenshot. First, the request is
    made to a `9.json` file; `9` is the number in the URL of the attacker's account
    settings, so that may be the user ID. Next, there is a `user%5Buser_id%50` parameter
    (`user[user_id]`, if we decode it) with the value `9`, and then a `user%5Bemail%50`
    or `user[email]` once URL-decoded. The last two parameters are the password and
    its confirmation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注截图中加下划线的部分。首先，请求是发送到一个`9.json`文件；`9`是攻击者账户设置URL中的数字，所以这可能是用户ID。接下来，有一个`user%5Buser_id%50`参数（如果解码的话就是`user[user_id]`），其值为`9`，然后是`user%5Bemail%50`或解码后的`user[email]`。最后两个参数是密码和密码确认。
- en: So, what if all those references to user number `9` in the attacker's requests
    are not correctly validated? Let's try and attack the victim user, which has the
    ID of `7`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，如果攻击者请求中所有关于用户`9`的引用没有得到正确验证，会怎么样呢？让我们尝试攻击受害者用户，其ID为`7`。
- en: As the attacker, make a password change and intercept the request again.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为攻击者，进行一次密码更改，并再次拦截请求。
- en: Change the request, replacing the attacker's ID with the victim's ID in both
    the URL and `user_id` parameters.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改请求，将攻击者的ID替换为受害者的ID，修改URL和`user_id`参数。
- en: 'Change the rest of the request as per the underlined values in the screenshot,
    or choose your own:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改请求的其余部分，参考截图中的加下划线值，或者选择自己的值：
- en: '![](assets/68c61750-0b04-43f6-9a9a-bae791651a68.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68c61750-0b04-43f6-9a9a-bae791651a68.png)'
- en: Submit the request and verify that it is accepted (response code 200 and a message
    `success` in the body).
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交请求并验证其是否被接受（响应代码为200，并且正文中有`success`消息）。
- en: Log out and try to log in as the victim user with the original password and
    the login will fail.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登出并尝试使用原密码以受害者用户身份登录，登录将失败。
- en: Now, try the password set in the attacker's request and the login will be successful.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用攻击者请求中设置的密码，登录将会成功。
- en: 'Go to account settings and verify that the other changes also happened:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入账户设置并验证其他更改也已生效：
- en: '![](assets/5d91d21c-1bdf-496f-a5a5-6ce21d0b4830.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d91d21c-1bdf-496f-a5a5-6ce21d0b4830.png)'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we first checked the URL of the user's account settings and
    noticed that the application may distinguish users by a numeric ID. Then, we performed
    a request to change the user's information and verified the use of numeric identifiers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们首先检查了用户账户设置的URL，并注意到应用可能通过数字ID区分用户。然后，我们执行了一次更改用户信息的请求，并验证了数字标识符的使用。
- en: Then, we attempted to replace the ID of the user, making changes to affect other
    users, and it turned out that RailsGoat makes a direct object reference to the
    object that contains the user's information and only validates with the user ID
    provided in the body of the same request to make changes. This way, as the attacker,
    we only needed to know the victim's ID to change their information, even the password,
    which allowed us to log in on their behalf.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们尝试替换用户的 ID，做出更改以影响其他用户，结果发现 RailsGoat 直接引用了包含用户信息的对象，并且仅通过请求正文中提供的用户 ID
    来验证和进行更改。这样，作为攻击者，我们只需要知道受害者的 ID，就可以更改他们的信息，甚至是密码，从而让我们代表他们登录。
- en: Performing a Cross-Site Request Forgery attack
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行跨站请求伪造攻击（Cross-Site Request Forgery）
- en: A CSRF attack is one that makes authenticated users perform unwanted actions
    in the web application they are authenticated with. This is done through an external
    site that the user visits, and that triggers these actions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 攻击是让已认证用户在他们已认证的 web 应用程序中执行不想要的操作。通过用户访问的外部网站触发这些操作。
- en: In this recipe, we will obtain the required information from the application
    in order to know what the attacking site should do to send valid requests to the
    vulnerable server, and then we will create a page that simulates the legitimate
    requests and tricks the user into visiting that page while authenticated. We will
    also make a few iterations on the basic proof of concept to make it look more
    like a real-world attack, where the victim doesn't notice it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将从应用程序中获取所需的信息，以便知道攻击网站应该如何向脆弱的服务器发送有效的请求，然后我们将创建一个页面，模拟合法请求并欺骗用户在已认证状态下访问该页面。我们还将对基本的概念验证进行几次迭代，使其看起来更像一个现实中的攻击，受害者不会注意到它。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'You''ll need a valid user account in BodgeIt for this recipe. We''ll use `user@example.com`
    as our victim:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个有效的 BodgeIt 用户账户来进行这个教程。我们将使用`user@example.com`作为我们的受害者：
- en: '![](assets/2ce59f95-cfd0-4804-844f-ac7858b4da06.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ce59f95-cfd0-4804-844f-ac7858b4da06.png)'
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We first need to analyze the request we want to force the victim to make. To
    do this, we need Burp Suite, or another proxy configured in the browser:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要分析我们想要强迫受害者执行的请求。为此，我们需要使用 Burp Suite 或其他在浏览器中配置的代理：
- en: Log in to BodgeIt as any user and click on the username to go to the profile.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以任何用户身份登录到 BodgeIt 并点击用户名进入个人资料页面。
- en: 'Make a password change. Let''s see what the request looks like in the proxy:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行密码更改。我们来看一下代理中请求的样子：
- en: '![](assets/63d1ffbb-3262-4f9d-a3df-2d49958d0819.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63d1ffbb-3262-4f9d-a3df-2d49958d0819.png)'
- en: So, it is a `POST` request to `http://192.168.56.11/bodgeit/password.jsp` and
    has only the password and its confirmation in the body.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它是一个 `POST` 请求，发送到 `http://192.168.56.11/bodgeit/password.jsp`，请求正文中仅包含密码及其确认信息。
- en: 'Let''s try to make a very simple HTML page that replicates this request. Create
    a file (we''ll name it `csrf-change-password.html`) with the following contents:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试制作一个非常简单的 HTML 页面来复制这个请求。创建一个文件（我们将其命名为`csrf-change-password.html`），并将以下内容写入其中：
- en: '[PRE15]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, load this file in the same browser as our logged-in session:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在与我们已登录会话相同的浏览器中加载这个文件：
- en: '![](assets/f5129a54-3664-4acf-9e4e-0729f69f8b2f.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5129a54-3664-4acf-9e4e-0729f69f8b2f.png)'
- en: Click on submit and you'll be redirected to the user's profile page. It'll tell
    you that the password was successfully updated.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击提交，你将被重定向到用户的个人资料页面。页面会告诉你密码已成功更新。
- en: 'Although this proves the point, an external site (or a local HTML page as in
    this case) can execute a password change request on the application. It''s still
    unlikely that a user will click on the Submit button. We can automate that and
    hide the input fields so that the malicious content is hidden. Let''s make a new
    page based on the previous one; we''ll call it `csrf-change-password-scripted.html`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管这证明了这一点，但外部网站（或者像本例中的本地 HTML 页面）仍然可以在应用程序上执行密码更改请求。用户仍然不太可能点击提交按钮。我们可以自动化这个过程并隐藏输入字段，使恶意内容保持隐藏。让我们基于之前的页面创建一个新页面，命名为`csrf-change-password-scripted.html`：
- en: '[PRE16]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the form has an ID parameter and there is a script in the page that
    will submit its content when the page is loaded completely.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，表单有一个 ID 参数，并且页面中有一个脚本，当页面完全加载时会自动提交内容。
- en: 'If we load this page in the same browser where we have a BodgeIt session initiated,
    it will automatically send the request and the user''s profile page will show
    after that. In the following screenshot, we used the browser''s Debugger to set
    a breakpoint just before the request is made:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在与 BodgeIt 会话已启动的相同浏览器中加载这个页面，它会自动发送请求，并且用户的个人资料页面会随之显示。在下图中，我们使用浏览器的调试器在请求发送之前设置了一个断点：
- en: '![](assets/511c7c8a-3264-4620-8802-19488addcee5.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/511c7c8a-3264-4620-8802-19488addcee5.png)'
- en: This last attempt looks better from an attacker's perspective; we only need
    the victim to load the page and the request will be sent automatically, but then
    the victim will see the Your password has been changed message and that will surely
    raise an alert.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，最后这次尝试看起来更好；我们只需要受害者加载页面，请求就会自动发送，但接着受害者会看到“Your password has been
    changed”消息，这肯定会引起警觉。
- en: 'We can further improve the attacking page by making it load the response in
    an invisible frame inside the same page. There are many ways of doing this; a
    quick and dirty one is to set a size `0` for the frame. Our file would look like
    this:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过让攻击页面在同一页面的不可见框架中加载响应来进一步改进该攻击页面。有很多方法可以做到这一点；一种快速而简单的方法是将框架的大小设置为 `0`。我们的文件将如下所示：
- en: '[PRE17]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how the target property of the form is the `iframe` defined just below
    it, and that such frame has `0%` `height` and `width`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表单的 target 属性是下面定义的 `iframe`，而且这个框架的 `height` 和 `width` 都是 `0%`。
- en: 'Load the new page in the browser where the session is initiated. This screenshot
    shows how the page looks when being inspected with the browser''s Developer Tools:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动会话的浏览器中加载新页面。此截图显示了使用浏览器的开发者工具检查页面时的外观：
- en: '![](assets/a8964913-8631-43d1-a3ca-67a87d6c916f.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8964913-8631-43d1-a3ca-67a87d6c916f.png)'
- en: Notice that the `iframe` object is only a black line in the page and, in the
    `Inspector`, we can see that it contains the BodgeIt user's profile page.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`iframe` 对象在页面中仅为一条黑线，在 `Inspector` 中，我们可以看到它包含了 BodgeIt 用户的个人资料页面。
- en: 'If we analyze the network communications undertaken by our CSRF page, we can
    see that it actually makes requests to change the BodgeIt password:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们分析我们的 CSRF 页面所进行的网络通信，我们可以看到它实际上是在请求更改 BodgeIt 密码：
- en: '![](assets/ec4821c6-e984-412f-8ae9-0d48fc724867.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec4821c6-e984-412f-8ae9-0d48fc724867.png)'
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When we send a request from a browser and already have a cookie belonging to
    the target domain stored, the browser will attach the cookie to the request before
    it is sent; this is what makes cookies so convenient as session identifiers, but
    this characteristic of how HTTP works is also what makes it vulnerable to an attack
    like the one we saw in this recipe.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从浏览器发送请求，并且已经存储了属于目标域的 cookie 时，浏览器会在请求发送之前自动将该 cookie 附加到请求中；这正是 cookie
    作为会话标识符如此方便的原因，但 HTTP 的这种工作方式也是使其容易受到像我们在本例中看到的攻击的原因。
- en: When we load a page in the same browser where we have an active session in an
    application, even if it's a different tab or window, and this page makes a request
    to the domain where the session is initiated, the browser will automatically attach
    the session cookie to that request. If the server doesn't verify that the requests
    it receives actually originated from within the application, usually by adding
    a parameter containing a unique token that changes with every request or on every
    occasion, it allows a malicious site to make calls on behalf of legitimate, active
    users that visit this malicious site while authenticated to the target domain.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在同一个浏览器中加载一个页面，而该浏览器中已经有一个活动的应用程序会话，即使是不同的标签页或窗口，并且该页面向会话发起的域发起请求时，浏览器会自动将会话
    cookie 附加到该请求中。如果服务器没有验证其接收到的请求是否确实来源于应用程序内部，通常是通过添加一个包含唯一令牌的参数，该令牌在每个请求或每次情况下都会变化，它就允许恶意网站代表合法的、已认证的用户发起请求，而这些用户在登录目标域时访问了这个恶意网站。
- en: In a web application penetration test, the first code we used, the one with
    the two text fields and the Submit button, may be enough to demonstrate the presence
    of a security flaw. However, if the penetration testing of the application is
    part of another engagement, such as a social engineering or red team exercise,
    some extra effort will be required to prevent the victim user from suspecting
    that something is happening. In this recipe, we used JavaScript to automate the
    sending of the request by setting the `onload` event in the page and executing
    the form's submit method in the event handler function. We also used a hidden
    `iframe` to load the response of the password change, so, the victim never sees
    the message that his/her password has changed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 web 应用程序渗透测试中，我们使用的第一个代码，包含两个文本字段和提交按钮，可能足以证明存在安全漏洞。然而，如果应用程序的渗透测试是其他工作的一部分，比如社会工程学或红队演习，则需要一些额外的努力，以防止受害用户怀疑发生了什么。在这个过程中，我们使用
    JavaScript 来自动发送请求，通过在页面中设置 `onload` 事件，并在事件处理函数中执行表单的提交方法。我们还使用了一个隐藏的 `iframe`
    来加载密码更改的响应，这样，受害者就永远看不到密码已更改的消息。
- en: See also
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Applications often use web services to perform certain tasks or retrieve information
    from the server without changing or reloading pages; these requests are made via
    JavaScript (they will add the header `X-Requested-With: XMLHttpRequest`)  and
    usually in JSON or XML formats, with a `Content-Type` header with the value `application/json`
    or `application/xml`. When this happens, and we try to make a cross-site/domain
    request, the browser will perform what is called a **preflight check**, which
    means that before the intended request, the browser will send an `OPTIONS` request
    to verify what methods and content types the server allows being requested from
    cross origins (domains other than the one the application belongs to).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '应用程序通常使用 web 服务执行某些任务或从服务器检索信息，而无需更改或重新加载页面；这些请求是通过 JavaScript 发出的（它们会添加请求头
    `X-Requested-With: XMLHttpRequest`），通常采用 JSON 或 XML 格式，并带有 `Content-Type` 头，其值为
    `application/json` 或 `application/xml`。当发生这种情况并且我们尝试进行跨站点/域请求时，浏览器将执行所谓的 **预检请求**，这意味着在预定请求之前，浏览器会发送一个
    `OPTIONS` 请求来验证服务器允许从跨源（与应用程序所在域不同的域）请求哪些方法和内容类型。'
- en: The preflight check can interrupt a CSRF attack as the browser won't send the
    malicious request if the server doesn't allow cross-origin requests. However,
    this protection only works when the request is made via scripting, and not when
    it is made via a form. So, if we can convert the JSON or XML request to a regular
    HTML form, we can make a CSRF attack. If this is not possible, because the server
    only allows certain content types, for example, then our only chance for a successful
    CSRF is if the server's **Cross Origin Resource Sharing** (**CORS**) policy allows
    requests from our attacking domain, so check for the `Access-Control-Allow-Origin`
    header in the server's responses.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 预检请求可以中断 CSRF 攻击，因为如果服务器不允许跨域请求，浏览器就不会发送恶意请求。然而，这种保护仅在通过脚本发起请求时有效，而在通过表单发起请求时则无效。因此，如果我们能够将
    JSON 或 XML 请求转换为普通的 HTML 表单，我们就可以发起 CSRF 攻击。如果无法做到这一点，例如因为服务器只允许某些特定的内容类型，那么我们成功发起
    CSRF 攻击的唯一机会就是服务器的 **跨源资源共享**（**CORS**）策略允许来自我们攻击域的请求，因此需要检查服务器响应中的 `Access-Control-Allow-Origin`
    头。
