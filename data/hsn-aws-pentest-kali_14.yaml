- en: Privilege Escalation of AWS Accounts Using Stolen Keys, Boto3, and Pacu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用窃取的密钥、Boto3和Pacu提升AWS账户的特权
- en: An important aspect of pentesting AWS environments is the process of enumerating
    what permissions your user has, and then escalating those privileges, if possible.
    Knowing what you have access to is the first battle, and it will allow you to
    formulate an attack plan in the environment. Next is privilege escalation, where
    if you can gain further access to the environment, you can perform more devastating
    attacks. In this chapter, we will dive into the Python `boto3` library to learn
    how to make AWS API calls programmatically, learn how to use it to automate the
    enumeration of our permissions, and then finally, learn how to use it to escalate
    our permissions if our user is vulnerable to escalation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AWS环境渗透测试的一个重要方面是枚举用户的权限，并在可能的情况下提升这些特权。知道你可以访问什么是第一场战斗，它将允许你在环境中制定攻击计划。接下来是特权升级，如果你可以进一步访问环境，你可以执行更具破坏性的攻击。在本章中，我们将深入研究Python的`boto3`库，学习如何以编程方式进行AWS
    API调用，学习如何使用它来自动枚举我们的权限，最后学习如何使用它来提升我们的权限，如果我们的用户容易受到提升攻击。
- en: The enumeration of our permissions is very important for a multitude of reasons.
    One of these is that we will avoid needing to guess what our permissions are,
    preventing many access denied errors in the process. Another is that it can possibly
    disclose information about other parts of the environment, such as if a specific
    resource is marked in one of our **Identity and Access Management** (**IAM**)
    policies, we then know that the resource is in use and is important to some degree.
    Further, we can compare our list of permissions against a list of known privilege
    escalation methods to see if we can grant ourselves more access. The more access
    we can gain to the environment, the higher the impact and the more dangerous our
    attack will be to our client if we were real malicious attackers instead of pentesters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举我们的权限对于多种原因非常重要。其中之一是我们将避免需要猜测我们的权限是什么，从而在过程中防止许多访问被拒绝的错误。另一个是它可能披露有关环境其他部分的信息，比如如果特定资源在我们的**身份和访问管理**（**IAM**）策略中被标记，那么我们就知道该资源正在使用，并且在某种程度上很重要。此外，我们可以将我们的权限列表与已知的特权升级方法列表进行比较，以查看是否可以授予自己更多访问权限。我们可以获得对环境的更多访问权限，攻击的影响就越大，如果我们是真正的恶意攻击者而不是渗透测试人员，我们的攻击就会更加危险。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the `boto3` library for reconnaissance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`boto3`库进行侦察
- en: Dumping all the account information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转储所有账户信息
- en: Permissions enumeration with compromised AWS keys
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用受损的AWS密钥进行权限枚举
- en: Privilege escalation and gathering credentials using Pacu
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权升级和使用Pacu收集凭据
- en: The importance of permissions enumeration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限枚举的重要性
- en: In any case, whether you can escalate your privileges or not, having a definitive
    list of what permissions you do have is extremely important. This can save you
    a lot of time when attacking an environment as you don't need to spend time trying
    to guess what access you might have, and instead, you can do manual analysis offline
    to leave a smaller logging footprint. By knowing what access you have, you can
    avoid the need to run test commands to determine whether you have privileges or
    not. This is beneficial because API errors, especially access denied errors, can
    be very noisy, and will likely alert a defender to your activity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，无论您是否可以提升权限，拥有确切的权限列表都非常重要。这可以节省您在攻击环境时的大量时间，因为您不需要花时间尝试猜测您可能拥有的访问权限，而是可以进行离线手动分析，以留下更小的日志记录。通过了解您拥有的访问权限，您可以避免运行测试命令以确定您是否具有特权的需要。这是有益的，因为API错误，特别是访问被拒绝的错误，可能会非常嘈杂，并且很可能会警告防御者您的活动。
- en: In many cases, you might find that your user does not have enough permissions
    to be able to enumerate their full list of permissions. In these situations, it
    is generally recommended to make assumptions based on the information that you
    already have, such as where the keys were retrieved from. Maybe you got these
    compromised keys from a web app that uploads files to `S3`. It will be safe to
    assume that the keys have permission to upload files to `S3` and that they could
    have read/list permissions as well. It will be unlikely that this set of keys
    has access to the IAM service, so it could be rather noisy to make IAM API calls,
    because it will most likely return an access denied error. This doesn't mean you
    shouldn't ever decide to try those permissions though, as sometimes it is your
    only option, and you may need to make some noise in the account to figure out
    what your next steps will be.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您可能会发现您的用户没有足够的权限来枚举他们的全部权限。在这些情况下，通常建议根据您已经拥有的信息做出假设，比如密钥是从哪里检索到的。也许你从一个上传文件到`S3`的Web应用程序中获得了这些受损的密钥。可以安全地假设这些密钥有权限上传文件到`S3`，并且它们也可能具有读取/列出权限。这组密钥很可能无法访问IAM服务，因此进行IAM
    API调用可能会相当嘈杂，因为它很可能会返回访问被拒绝的错误。但这并不意味着你永远不应该尝试这些权限，因为有时这是你唯一的选择，你可能需要在账户中制造一些噪音，以找出接下来的步骤。
- en: Using the boto3 library for reconnaissance
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用boto3库进行侦察
- en: 'Boto3 is the AWS **software development kit** (**SDK**) for Python and can
    be found here: [https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html).
    It provides an interface to the AWS APIs, allowing us to interact with them programmatically,
    meaning that we can automate and control what we are trying to do in AWS. It is
    managed by AWS, so it is constantly updated with the latest features and offerings
    from AWS. It is also used on the backend of the AWS **Command Line Interface**
    (**CLI**), so it makes more sense for us to interact with this library than to
    try and run AWS CLI commands from within our code.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Boto3是Python的AWS软件开发工具包（SDK），可以在这里找到：[https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html)。它提供了与AWS
    API交互的接口，意味着我们可以以编程方式自动化和控制我们在AWS中所做的事情。它由AWS管理，因此会不断更新最新的AWS功能和服务。它还用于AWS命令行界面（CLI）的后端，因此与其在代码中运行AWS
    CLI命令相比，与这个库进行交互更有意义。
- en: Because we are going to be using Python for our scripts, `boto3` is the perfect
    option to allow us to interact with the AWS APIs. This way, we can automate our
    reconnaissance/information gathering phase with a lot of the extra stuff already
    taken care of (such as signing the HTTP requests to the AWS API). We'll be using
    the AWS APIs to gather information about our target account, allowing us to determine
    our level of access to the environment and helping us to formulate our attack
    plan with precision.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用Python来编写我们的脚本，`boto3`是与AWS API进行交互的完美选择。这样，我们就可以自动化我们的侦察/信息收集阶段，很多额外的工作已经被处理了（比如对AWS
    API的HTTP请求进行签名）。我们将使用AWS API来收集有关目标账户的信息，从而确定我们对环境的访问级别，并帮助我们精确制定攻击计划。
- en: This section will assume that you have Python 3 installed along with the `pip`
    package manager.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将假定您已经安装了Python 3以及`pip`包管理器。
- en: 'Installing `boto3` is as simple as running a single `pip install` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`boto3`就像运行一个`pip install`命令一样简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now `boto3` and its dependencies should be installed on your computer. If the
    `pip3` command does not work for you, you may need to invoke `pip` directly through
    the Python command, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`boto3`及其依赖项应该已经安装在您的计算机上。如果`pip3`命令对您不起作用，您可能需要通过Python命令直接调用`pip`，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our first Boto3 enumeration script
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Boto3枚举脚本
- en: 'Once `boto3` is installed, it just needs to be imported to your Python script.
    For this chapter, we will begin with the following Python script that declares
    itself as `python3` and then imports `boto3`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`boto3`，它只需要被导入到您的Python脚本中。在本章中，我们将从以下声明自己为`python3`的Python脚本开始，然后导入`boto3`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are a few different ways that we can set up credentials with `boto3`,
    but we are going to stick with just one, and that is by creating a `boto3` `session` to
    make our API calls ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种不同的方式来设置`boto3`的凭据，但我们将坚持只使用一种方法，那就是通过创建一个`boto3`的`session`来进行API调用（[https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/core/session.html)）。
- en: 'In the previous chapter, we created our IAM user and saved their keys to the
    AWS CLI, so now with `boto3`, we can retrieve those credentials and use them in
    our scripts. We will do that by first instantiating a `boto3` `session` for the
    `us-west-2` region with the following line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了IAM用户并将他们的密钥保存到了AWS CLI中，所以现在我们可以使用`boto3`来检索这些凭据并在我们的脚本中使用它们。我们将首先通过以下代码实例化一个`boto3`的`session`，用于`us-west-2`地区：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code creates a new `boto3` `session` and will search the computer for the
    AWS CLI profile with the name of `Test`, which we have already set up. By using
    this method to handle credentials within our scripts, we don't need to directly
    include hardcoded credentials in our code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新的`boto3` `session`，并将在计算机上搜索名为`Test`的AWS CLI配置文件，这是我们已经设置好的。通过使用这种方法来处理我们脚本中的凭据，我们不需要直接在代码中包含硬编码的凭据。
- en: 'Now that we have our session created, we can use that session to create `boto3`
    clients, which are then used to make API calls to AWS. Clients accept multiple
    parameters when they are created to manage different configuration values, but
    in general, there is only one that we need to worry about and that is the `service_name` parameter.
    It is a positional parameter and will always be the first parameter we pass to
    the client. The following line of code sets up a new `boto3` client with our credentials,
    which targets the EC2 AWS service:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的session，我们可以使用该session来创建`boto3`客户端，然后用于对AWS进行API调用。客户端在创建时接受多个参数来管理不同的配置值，但一般来说，我们只需要担心一个参数，那就是`service_name`参数。它是一个位置参数，将始终是我们传递给客户端的第一个参数。以下代码设置了一个新的`boto3`客户端，使用我们的凭据，目标是EC2
    AWS服务：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we can use this newly created client to make AWS API calls to the EC2 service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个新创建的客户端来对EC2服务进行AWS API调用。
- en: For a list of available methods, you can visit the EC2 reference page in the
    `boto3` documentation at [https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用方法的列表，您可以访问`boto3`文档中的EC2参考页面：[https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#client)。
- en: 'There are many methods to choose from, but for the sake of information enumeration,
    we are going to start out with the `describe_instances` method, which, just as
    we showed previously (that is, in the *Using IAM access keys* section of [Chapter
    9](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml), *Identity Access Management on
    AWS*)with the AWS CLI, will enumerate EC2 instances in the target region. We can
    run this API call and retrieve the results with the following line of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可供选择，但为了信息枚举的目的，我们将从`describe_instances`方法开始，就像我们之前展示的那样（即在[第9章](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml)的*在AWS上使用IAM访问密钥*部分中所示），使用AWS
    CLI，将枚举目标区域中的EC2实例。我们可以运行此API调用并使用以下代码行检索结果：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `describe_instances` method accepts some optional arguments, but for the
    first call we make, we don't need any yet. One thing that the documentation for
    this method ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances))
    tells us is that it supports pagination. Depending on the number of EC2 instances
    in the account you're targeting, you may not receive all the results in the first
    API call. We can take care of this by creating a separate variable to house all
    the enumerated instances and checking if the results are complete or not.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe_instances`方法接受一些可选参数，但对于我们进行的第一个调用，我们还不需要。这个方法的文档告诉我们，它支持分页。根据您要定位的账户中的EC2实例数量，您可能无法在第一次API调用中收到所有结果。我们可以通过创建一个单独的变量来存储所有枚举的实例，并检查结果是否完整来解决这个问题。'
- en: 'The previous line of code that we added (`response = client.describe_instances()`)
    will need to be rearranged a little bit, so that it will end up as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的上一行代码（`response = client.describe_instances()`）需要稍微重新排列一下，以便最终如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can be sure that even in large environments with `1000s` of EC2 instances,
    we have a complete list of them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确保即使在具有数千个EC2实例的大型环境中，我们也有完整的实例列表。
- en: Saving the data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存数据
- en: 'Well, now we have the list of EC2 instances, but what should we do with it?
    A simple solution is to output the data to a local file so that it can be referenced
    later. We can do this by importing the `json` Python library and dumping the contents
    of `instances` to a file in the same directory as our script. Let''s add the following
    code to our script:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了EC2实例列表，但我们应该怎么处理呢？一个简单的解决方案是将数据输出到本地文件中，以便以后可以引用。我们可以通过导入`json` Python库并将`instances`的内容转储到与我们的脚本相同的目录中的文件中来实现这一点。让我们将以下代码添加到我们的脚本中：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the full script (without comments) should look as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完整的脚本（不包括注释）应该如下所示：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can run this script with the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令运行此脚本：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A new file named `ec2-instances.json` should be created in the current directory,
    and when you open it up, you should see something like the following screenshot,
    where a JSON representation of all EC2 instances in the `us-west-2` region is
    listed. This JSON data holds basic information on the EC2 instances, including
    identifying information, networking information, and other configurations applicable
    to EC2 instances. However, all these details aren''t important at the moment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录中应该创建一个名为`ec2-instances.json`的新文件，当您打开它时，您应该看到类似以下截图的内容，其中列出了`us-west-2`区域中所有EC2实例的JSON表示。这些JSON数据包含有关EC2实例的基本信息，包括标识信息、网络信息和适用于EC2实例的其他配置。但是，这些细节目前并不重要：
- en: '![](img/12e9ca4d-6999-4d21-9b92-f52d23776c29.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e9ca4d-6999-4d21-9b92-f52d23776c29.png)'
- en: This file should now have all the enumerated information for all the instances
    in the region we previously specified in the code (`us-west-2`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件现在应该包含我们之前在代码中指定的区域中所有实例的枚举信息。
- en: Adding some S3 enumeration
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些S3枚举
- en: Now let's say that we want to enumerate what `S3` buckets exist in the account
    and what files are in those buckets. Currently, our test IAM user does not have
    `S3` permissions, so I have gone ahead and directly attached the AWS-managed policy
    `AmazonS3ReadOnlyAccess` to our user. If you need help doing so for your own user,
    refer to [Chapter 9](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml), *Identity Access
    Management on AWS*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要枚举账户中存在的`S3`存储桶以及这些存储桶中的文件。目前，我们的测试IAM用户没有`S3`权限，因此我已经直接将AWS托管策略`AmazonS3ReadOnlyAccess`附加到我们的用户上。如果您需要为自己的用户执行此操作，请参考[第9章](08482ee1-cf12-4e93-81b7-633cc6c71e7b.xhtml)的*在AWS上使用身份访问管理*。
- en: 'We will add the following code to the bottom of the existing script that we
    have already created. First, we will want to figure out what `S3` buckets are
    in the account, so we will need a new `boto3` client set up to target `S3`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在已经创建的现有脚本的底部添加以下代码。首先，我们将想要弄清楚账户中有哪些`S3`存储桶，因此我们需要设置一个新的`boto3`客户端来定位`S3`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we will use the `list_buckets` method to retrieve a list of `S3` buckets
    in the account. Note that unlike the `ec2:DescribeInstances` API call, the `s3:ListBuckets`
    API call is not paginated, and you can expect all the buckets in the account in
    a single response:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`list_buckets`方法来检索账户中`S3`存储桶的列表。请注意，与`ec2:DescribeInstances` API调用不同，`s3:ListBuckets`
    API调用不是分页的，您可以期望在单个响应中看到账户中的所有存储桶：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The data returned comes with some information that we aren''t interested in
    right now (such as the bucket creation date), so we are going to iterate through
    the response and only pull out the names of the buckets:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据中包含一些我们目前不感兴趣的信息（例如存储桶创建日期），因此我们将遍历响应并仅提取存储桶的名称：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have the names of all the buckets in the account, we can go ahead
    and list out the files in each one by using the `list_objects_v2` API call. The
    `list_objects_v2` API call is a paginated operation, so it is possible that not
    every object will be returned to us in the first API call, so we will take that
    into account in our script. We will add the following code to our script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道账户中所有存储桶的名称，我们可以继续使用`list_objects_v2`API调用列出每个存储桶中的文件。`list_objects_v2`API调用是一个分页操作，因此可能不是每个对象都会在第一个API调用中返回给我们，因此我们将在脚本中考虑到这一点。我们将添加以下代码到我们的脚本中：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When that loop completes, we should end up with `bucket_objects` being a dictionary,
    where each key is a bucket name in the account and it contains a list of objects
    that are stored in it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环完成时，我们应该得到`bucket_objects`是一个字典，其中每个键是账户中的存储桶名称，它包含存储在其中的对象列表。
- en: 'Similarly to how we dumped all the EC2 instance data to `ec2-instances.json`,
    we are now going to dump all the file information into multiple different files,
    where the name is the name of the bucket. We can add the following code to do
    so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将所有EC2实例数据转储到`ec2-instances.json`类似，我们现在将所有文件信息转储到多个不同的文件中，文件名是存储桶的名称。我们可以添加以下代码来实现：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now the final code that we have added to our original script should look like
    this (without comments):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加到原始脚本的最终代码应该如下（不包括注释）：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can run our script again with the same command as before:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用与之前相同的命令再次运行我们的脚本：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When it completes, it should have again enumerated the EC2 instances and stored
    them in the `ec2-instances.json` file, and there should now also be a file for
    each bucket in the account that contains the filenames and file sizes of all the
    objects in them. The following screenshot shows a snippet of the information that
    was downloaded from one of our `test` buckets:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当它完成时，它应该再次枚举EC2实例并将它们存储在`ec2-instances.json`文件中，现在账户中每个存储桶也应该有一个文件，其中包含其中所有对象的文件名和文件大小。以下屏幕截图显示了从我们的一个`test`存储桶中下载的信息的片段：
- en: '![](img/1e52f85b-0308-4d24-9a49-a31bca5e6399.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e52f85b-0308-4d24-9a49-a31bca5e6399.png)'
- en: Now that we know what files exist, we could try using the AWS S3 API command, `get_object`,
    to download files that sound interesting, but I will leave that as a task for
    you. Bear in mind that data transfer incurs charges for the AWS account that it
    occurs in, so it is generally not a good idea to write scripts that try to download
    every single file in a bucket. If you did do that, you could easily run into a
    bucket with terabytes of data in it and cause a lot of unexpected charges to the
    AWS account. That is why it is important to pick and choose the files that you
    want to download based on name and size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道哪些文件存在，我们可以尝试使用AWS S3 API命令`get_object`来下载听起来有趣的文件，但我会把这个任务留给你。请记住，数据传输会导致发生在AWS账户中的费用，因此通常不明智编写尝试下载存储桶中的每个文件的脚本。如果你这样做了，你可能会轻易地遇到一个存储了数百万兆字节数据的存储桶，并导致AWS账户产生大量意外费用。这就是为什么根据名称和大小选择要下载的文件是很重要的。
- en: Dumping all the account information
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转储所有账户信息
- en: AWS makes it possible to retrieve data from an account via multiple methods
    (or APIs), and some of these are easier than others. This works to our advantage
    as an attacker because we may be denied access to one permission, but allowed
    access to another, which can, ultimately, be used to reach the same goal.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: AWS使得可以通过多种方法（或API）从账户中检索数据，其中一些方法比其他方法更容易。这对我们作为攻击者来说是有利的，因为我们可能被拒绝访问一个权限，但允许访问另一个权限，最终可以用来达到相同的目标。
- en: A new script – IAM enumeration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个新的脚本 - IAM枚举
- en: 'In this section, we are going to start out with a new script, and the goal
    will be to have it enumerate various points of data about the IAM service and
    the AWS account. The script will start with some of the things that we have already
    filled in:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从一个新的脚本开始，目标是枚举IAM服务和AWS账户的各种数据点。脚本将从我们已经填写的一些内容开始：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have declared the file to be a `python3` file, imported the `boto3` library,
    created our `boto3` `session` using the credentials from the `Test` profile in
    the `us-west-2` region, and then created a `boto3` client for the IAM service
    with those credentials.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明文件为`python3`文件，导入了`boto3`库，使用`us-west-2`区域`Test`配置文件中的凭据创建了我们的`boto3`
    `session`，然后使用这些凭据为IAM服务创建了一个`boto3`客户端。
- en: 'We are going to start off with the `get_account_authorization_details` API
    call ([https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details)),
    which returns a wealth of information from the account, including user, role,
    group, and policy information. This is a paginated API call, so we will start
    off by creating empty lists to accumulate the data as we enumerate it, and then
    make our first API call:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`get_account_authorization_details`API调用开始（[https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam.html#IAM.Client.get_account_authorization_details)），该调用从账户中返回大量信息，包括用户、角色、组和策略信息。这是一个分页的API调用，因此我们将首先创建空列表来累积我们枚举的数据，然后进行第一个API调用：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we need to check if the response is paginated and if we need to make another
    API call to get more results. Just like before, we can do this with a simple loop:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要检查响应是否分页，以及是否需要进行另一个API调用来获取更多结果。就像之前一样，我们可以使用一个简单的循环来做到这一点：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may have noticed that there are inconsistencies with the names and structures
    of AWS API call arguments and responses (such as `ContinuationToken` versus `NextToken`
    versus `Marker`). There is no way around this, the `boto3` library is just inconsistent
    in its naming schemes, so it is important to read the documentation for the commands
    you are running.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到AWS API调用参数和响应的名称和结构存在不一致性（例如`ContinuationToken`与`NextToken`与`Marker`）。这是无法避免的，`boto3`库在其命名方案上存在不一致性，因此重要的是阅读您正在运行的命令的文档。
- en: Saving the data (again)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存数据（再次）
- en: 'Now, just like before, we will want to save this data somewhere. We will store
    it in four separate files, `users.json`, `groups.json`, `roles.json`, and `policies.json`,
    with the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像以前一样，我们希望将这些数据保存在某个地方。我们将使用以下代码将其存储在四个单独的文件`users.json`、`groups.json`、`roles.json`和`policies.json`中：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should end up with the final script (without comments) looking like the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使最终脚本（不包括注释）看起来像下面这样：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can run the script with the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令运行脚本：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The current folder should end up with four new files created in it with the
    details of the users, groups, roles, and policies in the account.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文件夹应该有四个新文件，其中包含帐户中用户、组、角色和策略的详细信息。
- en: Permission enumeration with compromised AWS keys
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受损的AWS密钥进行权限枚举
- en: We can now extend the script from the previous section to use the collected
    data to determine what exact permissions your current user has by correlating
    the data stored in the different files. To do this, we will first need to find
    our current user in the list of users we pulled down.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以扩展上一节的脚本，使用收集的数据来确定您当前用户具有的确切权限，通过相关不同文件中存储的数据。为此，我们首先需要在我们拉下来的用户列表中找到我们当前的用户。
- en: Determining our level of access
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定我们的访问级别
- en: 'In an attack scenario, it is possible that you don''t know the username of
    your current user, so we will add this line of code that uses the `iam:GetUser`
    API to determine that information (note that this call will fail if your credentials
    belong to a role):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击场景中，您可能不知道当前用户的用户名，因此我们将添加使用`iam:GetUser` API来确定该信息的代码行（请注意，如果您的凭据属于角色，则此调用将失败）：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we will iterate through the user data we collected and look for our current
    user:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历我们收集的用户数据，并寻找我们当前的用户：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now check a few different pieces of information that may or may not be
    attached to our user object. If a certain piece of information doesn't exist,
    then that means there are no values for it that we need to worry about.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查一些可能附加到我们用户对象的不同信息。如果某个信息不存在，那么意味着我们不需要担心它的值。
- en: 'To come up with a complete list of permissions for our user, we will need to
    inspect the following data: `UserPolicyList`, `GroupList`, and `AttachedManagedPolicies`.
    `UserPolicyList` will contain all inline policies that are attached to our user,
    `AttachedManagedPolicies` will include all managed policies attached to our user,
    and `GroupList` will contain the list of groups that our user is a part of. For
    each of the policies, we will need to pull the documents associated with them
    and for the groups, we will then need to check what inline policies and managed
    policies are attached to it, and then pull the documents associated with those
    to finally come up with a definitive list of permissions.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得出我们用户的完整权限列表，我们需要检查以下数据：`UserPolicyList`、`GroupList`和`AttachedManagedPolicies`。`UserPolicyList`将包含附加到我们用户的所有内联策略，`AttachedManagedPolicies`将包括附加到我们用户的所有托管策略，`GroupList`将包含我们用户所属的组的列表。对于每个策略，我们需要提取与之关联的文档，对于组，我们需要检查附加到它的内联策略和托管策略，然后提取与之关联的文档，最终得出一个明确的权限列表。
- en: Analysing policies attached to our user
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析附加到我们用户的策略
- en: 'We are going to start out by gathering the inline policy documents attached
    to our user. Luckily for us, the entire document for any inline policies is included
    with our user. We will add the following code to our script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先收集附加到我们用户的内联策略文档。幸运的是，任何内联策略的整个文档都包含在我们的用户中。我们将向我们的脚本添加以下代码：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now `my_policies` should include all the inline policies that are directly
    attached to our user. Next, we will gather the managed policy documents that are
    attached to our user. The policy documents are not directly attached to our user,
    so we must use the identifying information to find the policy document in our
    `policy_details` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`my_policies`应该包括直接附加到我们用户的所有内联策略。接下来，我们将收集附加到我们用户的托管策略文档。策略文档并未直接附加到我们的用户，因此我们必须使用标识信息在我们的`policy_details`变量中找到策略文档：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now `my_policies` should include all the inline policies and managed policies
    that are directly attached to our user. Next, we will figure out what groups we
    are a part of, then enumerate the inline policies and managed policies that are
    attached to each of those groups. When that is complete, we will have a complete
    list of the permissions that are assigned to our user:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`my_policies`应该包括直接附加到我们用户的所有内联策略和托管策略。接下来，我们将找出我们所属的组，然后枚举附加到每个组的内联策略和托管策略。完成后，我们将得到分配给我们用户的完整权限列表：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now the script should be complete and our `my_policies` variable should have
    the policy documents for all inline and managed policies that are directly attached
    to our user, as well as all inline and managed policies attached to each group
    that our user is a member of. We can check these results out by adding one final
    snippet that outputs the data to a local file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本应该完成了，我们的`my_policies`变量应该包含直接附加到我们用户的所有内联和托管策略的策略文档，以及附加到我们用户所属的每个组的所有内联和托管策略。我们可以通过添加一个最终片段来检查这些结果，将数据输出到本地文件：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run the file with the same command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的命令运行文件：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we can check the generated `my-user-permissions.json`, which should contain
    the list of all policies and permissions that apply to your user. It should look
    something like the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以检查生成的`my-user-permissions.json`，其中应包含适用于您的用户的所有策略和权限的列表。它应该看起来像以下的屏幕截图：
- en: '![](img/1a13046f-3011-49de-9475-47e670bddbcc.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a13046f-3011-49de-9475-47e670bddbcc.png)'
- en: Now we have a nice list of what permissions we have, what resources we can use
    those permissions on, and under what conditions we can apply those permissions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的权限列表，我们可以使用这些权限，以及我们可以在什么条件下应用这些权限。
- en: An alternative method
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一种方法
- en: An important point to note is that this script will fail if the user does not
    have the `iam:GetAccountAuthorization` permission, because they will not be able
    to gather the list of users, groups, roles, and policies. To potentially solve
    this problem, we can refer to the beginning of this section, where it was noted
    that sometimes there is more than one way to do something through the AWS API,
    and those different ways require different sets of permissions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是，如果用户没有`iam:GetAccountAuthorization`权限，此脚本将失败，因为他们将无法收集用户、组、角色和策略列表。为了可能解决这个问题，我们可以参考本节开头的部分，其中指出有时通过AWS
    API有多种方法来做某事，这些不同的方法需要不同的权限集。
- en: 'In the case where our user does not have the `iam:GetAccountAuthorizationDetails` permission,
    but they do have other IAM read permissions, it might still be possible to enumerate
    our list of permissions. We will not be running through and creating a script
    that does this, but here is a general guide if you should like to try it out:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户没有`iam:GetAccountAuthorizationDetails`权限的情况下，但他们拥有其他IAM读取权限，可能仍然有可能枚举我们的权限列表。我们不会运行并创建执行此操作的脚本，但如果您愿意尝试，这里是一个一般指南：
- en: Check if we have the `iam:GetAccountAuthorizationDetails` permission
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否有`iam:GetAccountAuthorizationDetails`权限
- en: If so, run the script that we just created
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，请运行我们刚创建的脚本
- en: If not, go to step 2
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，请转到步骤2
- en: Use the `iam:GetUser` API to determine what user we are (note that this won't
    work for roles!)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetUser` API确定我们是什么用户（请注意，这对于角色不起作用！）
- en: Use the `iam:ListUserPolicies` API to fetch the list of inline policies that
    are attached to our user
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:ListUserPolicies` API获取附加到我们的用户的内联策略列表
- en: Use the `iam:GetUserPolicy` API to fetch the documents for each inline policy
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetUserPolicy` API获取每个内联策略的文档
- en: Use the `iam:ListAttachedUserPolicies` API to fetch the list of managed policies
    that are attached to our user
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:ListAttachedUserPolicies` API获取附加到我们的用户的托管策略列表
- en: Use the `iam:GetPolicy` API to determine the default version for each managed
    policy that is attached to our user
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetPolicy` API确定附加到我们的用户的每个托管策略的默认版本
- en: Use the `iam:GetPolicyVersion` API to fetch the policy document for each managed
    policy that is attached to our user
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetPolicyVersion` API获取附加到我们的用户的每个托管策略的策略文档
- en: Use the `iam:ListGroupsForUser` API to find out what groups our user is a part
    of
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:ListGroupsForUser` API查找我们的用户属于哪些组
- en: Use the `iam:ListGroupPolicies` API to list the inline policies that are attached
    to each group
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:ListGroupPolicies` API列出附加到每个组的内联策略
- en: Use the `iam:GetGroupPolicy` API to get the document for each inline policy
    that is attached to each group
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetGroupPolicy` API获取附加到每个组的每个内联策略的文档
- en: Use the `iam:ListAttahedGroupPolicies` API to list the managed policies that
    are attached to each group
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:ListAttahedGroupPolicies` API列出附加到每个组的托管策略
- en: Use the `iam:GetPolicy` API to determine the default version for each managed
    policy that is attached to each group
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetPolicy` API确定附加到每个组的每个托管策略的默认版本
- en: Use the `iam:GetPolicyVersion` API to fetch the policy document for each managed
    policy that is attached to each group
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iam:GetPolicyVersion` API获取附加到每个组的每个托管策略的策略文档
- en: As you can probably tell, this method of permission enumeration requires far
    more API calls to AWS, and it will likely be a lot louder to a listening defender
    than our first method. However, it might be the right choice if you don't have
    the `iam:GetAccountAuthorizationDetails` permission but you do have the permissions
    required to follow all the steps that are listed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，这种权限枚举方法需要对AWS进行更多的API调用，而且可能会对倾听的防御者产生更大的影响，比我们的第一种方法。但是，如果您没有`iam:GetAccountAuthorizationDetails`权限，但您有权限遵循列出的所有步骤，那么这可能是正确的选择。
- en: Privilege escalation and gathering credentials using Pacu
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pacu进行特权升级和收集凭据
- en: 'Prior to trying to detect and exploit privilege escalation for our target user,
    we are going to add another policy that will make the user vulnerable to privilege
    escalation. Add an inline policy named `PutUserPolicy` to our original `Test` user
    with the following document before proceeding:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试检测和利用我们目标用户的特权升级之前，我们将添加另一个策略，使用户容易受到特权升级的影响。在继续之前，向我们的原始`Test`用户添加一个名为`PutUserPolicy`的内联策略，并使用以下文档：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This policy gives our user access to run the `iam:PutUserPolicy` API action
    on any user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略允许我们的用户在任何用户上运行`iam:PutUserPolicy` API操作。
- en: Pacu – an open source AWS exploitation toolkit
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pacu - 一个开源的AWS利用工具包
- en: '**Pacu** is an open source AWS exploitation toolkit written by Rhino Security
    Labs. It was built to aid penetration testers in attacking AWS environments; so,
    now we will quickly install and set up Pacu to automate these attacks that we
    have been trying.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pacu**是由Rhino Security Labs编写的开源AWS利用工具包。它旨在帮助渗透测试人员攻击AWS环境；因此，现在我们将快速安装和设置Pacu，以自动化我们一直在尝试的这些攻击。'
- en: More in-depth instructions for installation and configuration can be found in
    [Chapter 19](aeb03296-ac3a-4d61-ac6a-c6a11f267f95.xhtml), *Putting It All Together-Real-World
    AWS Pentesting*; these steps aim to get you set up and using Pacu as soon as possible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装和配置的更详细说明可以在[第19章](aeb03296-ac3a-4d61-ac6a-c6a11f267f95.xhtml)中找到，*将所有内容整合在一起-真实世界的AWS渗透测试*；这些步骤旨在让您尽快设置并使用Pacu。
- en: 'Pacu is available through GitHub, so we will need to run a few commands to
    get everything installed (we are running Kali Linux). First, let''s confirm we
    have `git` installed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu可以通过GitHub获得，因此我们需要运行一些命令来安装所有内容（我们正在运行Kali Linux）。首先，让我们确认是否已安装`git`：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we will clone the Pacu repository from GitHub ([https://github.com/RhinoSecurityLabs/pacu](https://github.com/RhinoSecurityLabs/pacu)):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们将从GitHub克隆Pacu存储库（[https://github.com/RhinoSecurityLabs/pacu](https://github.com/RhinoSecurityLabs/pacu)）:'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we will switch into the Pacu directory and run the install script, which
    will ensure we have the correct Python version installed (Python 3.5 or later),
    and install the necessary dependencies with `pip3`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将切换到Pacu目录并运行安装脚本，这将确保我们安装了正确的Python版本（Python 3.5或更高版本），并使用`pip3`安装必要的依赖项：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now Pacu should be successfully installed, and we can start it up with this
    command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pacu应该已经成功安装，我们可以使用以下命令启动它：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A few messages will appear to let you know that a new settings file was generated
    and that a new database was created. It will detect that we have not set up a
    `session` yet, so it will ask us to name a new session to create. A Pacu session
    is basically a project, in that you can have multiple Pacu sessions in the same
    installation that are separate. The session data is stored in a local SQLite database,
    and each individual session can be thought of as a project or target company.
    It allows you to keep data and credentials separated when you are working on more
    than one environment. Logs and configuration are also separate between each Pacu
    session; we are going to name our session `Demo`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将会出现一些消息，让您知道已生成新的设置文件并创建了新的数据库。它将检测到我们尚未设置`session`，因此会要求我们命名一个新的会话以创建。Pacu会话基本上是一个项目，您可以在同一安装中拥有多个独立的Pacu会话。会话数据存储在本地SQLite数据库中，每个单独的会话可以被视为一个项目或目标公司。当您在多个环境上工作时，它允许您保持数据和凭证的分离。每个Pacu会话之间的日志和配置也是分开的；我们将命名我们的会话为`Demo`：
- en: '![](img/58a56fd7-354a-48e5-aa14-01e84088d581.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a56fd7-354a-48e5-aa14-01e84088d581.png)'
- en: Once our new session is successfully created, we will be presented with some
    helpful information relating to Pacu that we will go into in more depth later.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功创建了新会话，将会呈现一些有关Pacu的有用信息，我们稍后将更深入地了解这些信息。
- en: Kali Linux detection bypass
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kali Linux检测绕过
- en: 'Because we are running Pacu on Kali Linux, we are presented with an extra message
    about our user agent after the help output, similar to what is shown in the following
    screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在Kali Linux上运行Pacu，所以在帮助输出之后，我们会看到有关我们用户代理的额外消息，类似于以下截图中显示的内容：
- en: '![](img/1bfd49e7-c99d-4886-89c8-3d794ea0a6c5.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bfd49e7-c99d-4886-89c8-3d794ea0a6c5.png)'
- en: We can see that Pacu has detected that we are running Kali Linux and modified
    our user agent as a result. `GuardDuty` is one of the many security services that
    AWS offers, and it is used to detect and alert to suspicious behavior going on
    in an AWS environment. One thing that `GuardDuty` checks for is if you are making
    AWS API calls that originate from Kali Linux ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1)).
    We want to trigger as few alerts as possible in an account we are attacking, so
    Pacu has it built-in to automatically bypass this security measure. `GuardDuty`
    checks the user agent of whoever is making the API call to see if it recognizes
    Kali Linux from it, and alerts to it if it does. Pacu modifies our user agent
    to a generic user agent that does not look suspicious to `GuardDuty`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Pacu已经检测到我们正在运行Kali Linux，并相应地修改了我们的用户代理。 `GuardDuty`是AWS提供的众多安全服务之一，用于检测和警报AWS环境中发生的可疑行为。
    `GuardDuty`检查的一项内容是您是否正在从Kali Linux发起AWS API调用（[https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_pentest.html#pentest1)）。我们希望在攻击某个账户时尽量触发尽可能少的警报，因此Pacu已经内置了自动绕过这项安全措施。
    `GuardDuty`检查发起API调用的用户代理，以查看是否能从中识别Kali Linux，并在识别到时发出警报。Pacu将我们的用户代理修改为一个通用用户代理，不会引起`GuardDuty`的怀疑。
- en: The Pacu CLI
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pacu CLI
- en: 'Right after that output, we can see something called the Pacu CLI:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着这个输出，我们可以看到一个名为Pacu CLI的东西：
- en: '![](img/5db694f7-e5df-446b-a60f-cf8b6eed15db.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5db694f7-e5df-446b-a60f-cf8b6eed15db.png)'
- en: What this is showing us is that we are in the Pacu CLI, our active session is
    named Demo, and we have no active keys. We can add some AWS keys to the Pacu database
    in a few different ways, such as using the `set_keys` command, or importing them
    from the AWS CLI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们正在Pacu CLI中，我们的活动会话名为Demo，我们没有活动密钥。我们可以通过几种不同的方式向Pacu数据库添加一些AWS密钥，例如使用`set_keys`命令，或者从AWS
    CLI导入它们。
- en: 'We have already set up our AWS keys to work with the AWS CLI, so the simplest
    approach will be to import them from the AWS CLI. We can import our `Test` AWS
    CLI profile by running the following Pacu command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了AWS密钥以便与AWS CLI一起使用，因此最简单的方法是从AWS CLI导入它们。我们可以通过运行以下Pacu命令导入我们的`Test`
    AWS CLI配置文件：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command should return the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应返回以下输出：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now if we run the `whoami` command, we should be able to see that our access
    key ID and secret access key have been imported, and if we look at the Pacu CLI
    we can see that now instead of `No Keys Set`, it says the name of the keys we
    imported. The location of the Pacu CLI indicates what the active set of credentials
    are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`whoami`命令，我们应该能够看到我们的访问密钥ID和秘密访问密钥已被导入，如果我们查看Pacu CLI，我们现在可以看到，而不是`No
    Keys Set`，它显示了我们导入的密钥的名称。Pacu CLI的位置指示了当前凭证集的位置：
- en: '![](img/6a20c952-5fa3-427d-9756-85a44e405fef.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a20c952-5fa3-427d-9756-85a44e405fef.png)'
- en: 'Now that we have Pacu set up, we can retrieve the list of current modules by
    running the `ls` command from the Pacu CLI. To automate one of the processes that
    we worked through earlier in this chapter, we are going to use the `iam__enum_permissions` module.
    This module will perform the necessary API calls and parsing of the data to gather
    a confirmed list of permissions for our active set of credentials. This module
    can also be run against other users or roles in the account, so to get a better
    understanding of its capabilities, run the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了Pacu，我们可以通过从Pacu CLI运行`ls`命令来检索当前模块的列表。为了自动化本章前面我们已经完成的一个过程，我们将使用`iam__enum_permissions`模块。该模块将执行必要的API调用和数据解析，以收集我们的活动凭证集的确认权限列表。该模块也可以针对账户中的其他用户或角色运行，因此为了更好地了解其功能，运行以下命令：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now you should be able to see a description of the module and what arguments
    it supported. To run this module for our own user, we don''t need to pass in any
    arguments, so we can just run the following command to execute the module:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够看到该模块的描述以及它支持的参数。为了针对我们自己的用户运行该模块，我们不需要传入任何参数，所以我们可以直接运行以下命令来执行该模块：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the current set of credentials has permission to enumerate their privileges
    (which they should, because of what we set up earlier in the chapter), the output
    should indicate that the module successfully gathered the permissions for that
    user or role:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前的凭证集有权限枚举他们的权限（这是应该的，因为我们在本章前面设置了），输出应该表明模块成功地收集了该用户或角色的权限：
- en: '![](img/66bcf05a-27fc-4c4e-9df3-a19880b75ab2.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66bcf05a-27fc-4c4e-9df3-a19880b75ab2.png)'
- en: Now that the permissions for our user have been enumerated, we can view the
    enumerated data by running the `whoami` command again. This time, most of the
    data will be filled in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经枚举了我们用户的权限，我们可以通过再次运行`whoami`命令来查看枚举的数据。这次，大部分数据将被填充。
- en: The Groups field will contain information on any groups that our user is a part
    of and the Policies field will contain information on any IAM policies attached
    to our user. Identifying information such as the `UserName`, `Arn`, `AccountId`,
    and `UserId` fields should be filled in as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Groups字段将包含我们的用户所属的任何组的信息，Policies字段将包含任何附加到我们的用户的IAM策略的信息。识别信息，如`UserName`，`Arn`，`AccountId`和`UserId`字段也应该填写。
- en: Towards the bottom of the output, we can see the `PermissionsConfirmed` field,
    which holds true or false, and it indicates whether we were able to successfully
    enumerate the permissions we have. The value will be false if we are denied access
    to some APIs and are not able to gather a complete list of our permissions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的底部，我们可以看到`PermissionsConfirmed`字段，其中包含true或false，并指示我们是否能够成功枚举我们拥有的权限。如果我们被拒绝访问某些API并且无法收集完整的权限列表，该值将为false。
- en: The `Permissions` field will contain each IAM permission that our user is given,
    the resources those permissions can be applied to, and the conditions required
    to use them. Just like the script we wrote earlier in the chapter, this list contains
    permissions granted by any inline or managed policies attached to our user, as
    well as any inline or managed policies attached to any groups that our user is
    a member of.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Permissions`字段将包含我们的用户被赋予的每个IAM权限，这些权限可以应用到的资源以及使用它们所需的条件。就像我们在本章前面编写的脚本一样，这个列表包含了附加到我们的用户的任何内联或托管策略授予的权限，以及附加到我们的用户所属的任何组的任何内联或托管策略授予的权限。'
- en: From enumeration to privilege escalation
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从枚举到特权升级
- en: Our permissions have been enumerated, so now we will move into trying to use
    those permissions for privilege escalation in the environment. There is also a
    Pacu module for this called `iam_privesc_scan`. This module will run and check
    the set of permissions that you enumerated to see if your user is vulnerable to
    any methods out of 21 different known privilege escalation methods in AWS.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的权限已经被枚举，所以现在我们将尝试使用这些权限进行环境中的特权升级。还有一个Pacu模块叫做`iam_privesc_scan`。该模块将运行并检查你枚举的权限集，以查看你的用户是否容易受到AWS中21种不同已知的特权升级方法中的任何一种的影响。
- en: 'Rhino Security Labs wrote an article that details these 21 different privilege
    escalation methods and how they can be manually exploited, which you can refer
    to here: [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Rhino Security Labs撰写了一篇文章，详细介绍了这21种不同的特权升级方法以及如何手动利用它们，你可以在这里参考：[https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)。
- en: 'After the module checks to see if we are vulnerable to any of those methods,
    it will then try to exploit them to do the privilege escalation for us, which
    makes our job easy. If you are interested in reading more about the privilege
    escalation module, you can use the `help` command to do so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块检查我们是否容易受到这些方法中的任何一种的影响之后，它将尝试利用它们来为我们进行特权升级，这让我们的工作变得容易。如果你对特权升级模块想了解更多，你可以使用`help`命令来查看：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, this module can also be run against other users and roles in
    the account to determine whether they are vulnerable to privilege escalation as
    well, but for the time being we are only going to target our own user.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个模块也可以针对账户中的其他用户和角色运行，以确定它们是否也容易受到特权升级的影响，但目前我们只会针对我们自己的用户。
- en: 'We have already enumerated our permissions, so we can go ahead and run just
    the privilege escalation module without any arguments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经枚举了我们的权限，所以我们可以继续运行特权升级模块而不带任何参数：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The module will execute, search your permissions to see if you are vulnerable
    to any of the escalation methods it checks for, and then it will try to exploit
    them. In the case of our `Test` user, it should detect that we are vulnerable
    to the `PutUserPolicy` privilege escalation method. It will then try to abuse
    that permission to put (essentially attach) a new inline policy on our user. We
    are in control of the policy that we attach to our user, so we can specify an
    administrator level IAM policy and attach it to our user, where we will then be
    given administrator access. The module will do this automatically by adding the
    following policy document to our user:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将执行，搜索您的权限，看看您是否容易受到它检查的任何升级方法的攻击，然后它将尝试利用它们。对于我们的`Test`用户，它应该会检测到我们容易受到`PutUserPolicy`特权升级方法的攻击。然后它将尝试滥用该权限，以在我们的用户上放置（实质上附加）一个新的内联策略。我们控制着我们附加到用户的策略，因此我们可以指定一个管理员级别的IAM策略并将其附加到我们的用户，然后我们将获得管理员访问权限。该模块将通过向我们的用户添加以下策略文档来自动执行此操作：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following screenshot shows output that should be similar to what you see
    when you run the privilege escalation module:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示的输出应该与您运行特权升级模块时看到的类似：
- en: '![](img/9f7c65a0-0008-42aa-bb2a-0d36becbb74d.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f7c65a0-0008-42aa-bb2a-0d36becbb74d.png)'
- en: In the preceding screenshot, we can see the line `Successfully added an inline
    policy named jea70c72mk! You should not have administrator permissions.` This
    sounds good, but let's confirm this just to be sure.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到一行`成功添加了名为jea70c72mk的内联策略！您不应该具有管理员权限。`这听起来不错，但让我们确认一下以确保。
- en: We can confirm this in a few different ways; one is to run the `iam__enum_permissions` module
    again and then view the Permissions field. It should include a new permission
    that is just a star (`*`), which is a wildcard that says `all permissions`. That
    means we have administrator access to the environment!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种不同的方式来确认这一点；其中一种是再次运行`iam__enum_permissions`模块，然后查看权限字段。它应该包括一个新的权限，即星号（`*`），这是一个通配符，表示`所有权限`。这意味着我们对环境拥有管理员访问权限！
- en: 'If we view our user in the AWS web console, we will see that we have a new
    policy named `jea70c72mk` attached to our user, and when we click on the arrow
    next to it to drop-down the document, we can see the administrator policy placed
    inside it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在AWS Web控制台中查看我们的用户，我们会看到我们的用户附加了一个名为`jea70c72mk`的新策略，当我们点击它旁边的箭头以展开文档时，我们可以看到其中放置了管理员策略：
- en: '![](img/a70a6049-18db-4ef1-ad7a-1028fe8966d2.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a70a6049-18db-4ef1-ad7a-1028fe8966d2.png)'
- en: Using our new administrator privileges
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的新管理员特权
- en: Pacu allows us to use AWS CLI directly from Pacu CLI for situations where you
    may want to run a single command, rather than a full module. Let's use this functionality
    and our new administrator permissions to run an AWS CLI command to request data
    that we didn't previously have. This can be done just by running the AWS CLI command
    as we normally would, so that we can try running a command to enumerate other
    resources in the account. We are currently in our own personal account, so this
    command might not return any valid data for you, but it will be important to check
    this API call in other accounts that you are attacking.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu允许我们直接从Pacu CLI使用AWS CLI，用于您可能只想运行单个命令而不是完整模块的情况。让我们利用这个功能和我们的新管理员权限来运行一个AWS
    CLI命令，以请求我们以前没有的数据。这可以通过像平常一样运行AWS CLI命令来完成，这样我们就可以尝试运行一个命令来枚举账户中的其他资源。我们目前在我们自己的个人账户中，所以这个命令可能对您来说不会返回任何有效数据，但是在攻击其他账户时检查这个API调用将是很重要的。
- en: 'We can check if the account has `GuardDuty` enabled in the `us-east-1` region
    by running this command from the Pacu CLI:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从Pacu CLI运行以下命令来检查账户是否在`us-east-1`地区启用了`GuardDuty`：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In our `Test` account, we do have `GuardDuty` running, so we get the output
    shown in the following screenshot. But if you do not have `GuardDuty` running,
    then the `DetectorIds` field will be empty:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Test`账户中，我们确实运行了`GuardDuty`，所以我们得到了下面截图中显示的输出。但是，如果您没有运行`GuardDuty`，那么`DetectorIds`字段将为空：
- en: '![](img/a679d048-b454-47a5-b46a-d7f24af21fc0.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a679d048-b454-47a5-b46a-d7f24af21fc0.png)'
- en: The command returned a single `DetectorId` from AWS. For this API call, the
    presence of any data means that GuardDuty has been enabled previously for this
    region, so it is safe to assume that it is still enabled without making any more
    API calls. If `GuardDuty` is disabled in the target region, `DetectorIds` will
    just be an empty list. As an attacker, it is preferable for `GuardDuty` to be
    disabled, because then we know that it is not alerting our target to any malicious
    activity that we are performing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从AWS返回了一个`DetectorId`。对于这个API调用，任何数据的存在都意味着`GuardDuty`先前已经在该地区启用，因此可以安全地假定它仍然在没有进行更多API调用的情况下启用。如果在目标地区禁用了`GuardDuty`，`DetectorIds`将只是一个空列表。作为攻击者，最好是`GuardDuty`被禁用，因为这样我们就知道它不会警报我们正在执行的任何恶意活动。
- en: Even if `GuardDuty` is enabled, however, this does not mean that our efforts
    are futile. There are many factors that come into play in an attack scenario like
    this, such as if anyone is even paying attention to the `GuardDuty` alerts that
    are being triggered, the response time for someone to react to the alerts if they
    do notice one, and whether the person reacting has a strong understanding of AWS
    to be able to trace your actions fully.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使启用了`GuardDuty`，这并不意味着我们的努力是徒劳的。在这样的攻击场景中，有许多因素会起作用，比如是否有人在关注被触发的`GuardDuty`警报，如果他们注意到了警报，对警报做出反应的响应时间，以及做出反应的人是否对AWS有深入的了解，能够完全追踪你的行动。
- en: We can check for `GuardDuty`, and other logging and monitoring services by running
    the `detection__enum_services` Pacu module. This module will check for CloudTrail
    configurations, CloudWatch alarms, the active shield **Distributed Denial of Service** (**DDoS**) protection
    plan, `GuardDuty` configurations, Config configurations and resources, and **virtual
    private cloud (****VPC)** flow logs. These services all have different purposes,
    but as an attacker it is important to know what is watching you and what is tracking
    you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`detection__enum_services` Pacu模块来检查`GuardDuty`和其他日志记录和监控服务。该模块将检查CloudTrail配置、CloudWatch警报、活动的Shield分布式拒绝服务（DDoS）保护计划、`GuardDuty`配置、Config配置和资源，以及虚拟私有云（VPC）流日志。这些服务都有不同的目的，但作为攻击者，了解谁在监视您和跟踪您非常重要。
- en: Pacu has many modules within the enum category that can be used to enumerate
    various resources in our target AWS account. Some interesting modules to check
    include the `aws__enum_account` module, which enumerates information about current
    AWS account; the `aws__enum_spend` module, which gathers a list of AWS services
    that money is being spent on (so you can determine what services are in use without
    needing to query that services API directly); or the `ec2__download_userdata` module,
    which downloads and decodes the EC2 user data that is attached to each EC2 instance
    in the account.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu在枚举类别中有许多模块，可用于枚举目标AWS帐户中的各种资源。一些有趣的模块包括`aws__enum_account`模块，用于枚举当前AWS帐户的信息；`aws__enum_spend`模块，用于收集正在花费资金的AWS服务列表（因此您可以确定使用哪些服务，而无需直接查询该服务的API）；或`ec2__download_userdata`模块，用于下载和解码附加到帐户中每个EC2实例的EC2用户数据。
- en: EC2 user data is essentially just some text that you add to an EC2 instance,
    and once the instance is online that data is made available to it. This can be
    used to set up the initial configuration of an instance or provide it with settings
    or values that it might need to query later. It is also possible to execute code
    through EC2 user data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: EC2用户数据本质上只是一些文本，您可以将其添加到EC2实例中，一旦实例上线，该数据就会对其可用。这可以用于设置实例的初始配置，或者为其提供可能需要稍后查询的设置或值。还可以通过EC2用户数据执行代码。
- en: Often, users or software will place hardcoded secrets (such as API keys, passwords,
    and environment variables) into EC2 user data. This is bad practice and is discouraged
    by Amazon in their documentation, but it continues to be a problem. As an attacker,
    this works to our benefit. EC2 user data can be read by any user with the `ec2:DescribeInstanceAttribute` permission,
    so any hardcoded secrets are also made available to them. As an attacker, it is
    important to check this data for anything that may be useful.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用户或软件会将硬编码的机密信息（例如API密钥、密码和环境变量）放入EC2用户数据中。这是不良做法，并且亚马逊在其文档中不鼓励这样做，但这仍然是一个问题。作为攻击者，这对我们有利。任何用户都可以通过`ec2:DescribeInstanceAttribute`权限读取EC2用户数据，因此任何硬编码的机密信息也会对他们可用。作为攻击者，检查这些数据是否有用非常重要。
- en: The `ec2__download_userdata` Pacu module will automatically go through and download
    the user data for all the instances and launch templates that were enumerated
    in the account, making it easy for us to sift through the results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ec2__download_userdata` Pacu模块将自动遍历并下载帐户中枚举的所有实例和启动模板的用户数据，使我们能够轻松地筛选结果。'
- en: 'You can run the following command to start the module:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行以下命令来启动该模块：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now Pacu will check each EC2 instance that it is aware of for user data, and
    if there is any, it will download it to the `./sessions/[session name]/downloads/ec2_user_data/`
    folder inside the main Pacu directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pacu将检查其已知的每个EC2实例是否有用户数据，如果有，它将下载到主Pacu目录中的`./sessions/[session name]/downloads/ec2_user_data/`文件夹中。
- en: 'If you haven''t already enumerated EC2 instances and launch templates in the
    target account with the `ec2__enum` module, you will be prompted to run it prior
    to the module executing. You will likely be presented with a message that confirms
    if you want to run the module against every AWS region, which for right now is
    fine, so we will answer `y`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未使用`ec2__enum`模块在目标帐户中枚举EC2实例和启动模板，则在执行模块之前将提示您运行它。您可能会收到一条消息，确认是否要针对每个AWS区域运行该模块，这样做现在是可以的，因此我们将回答`y`：
- en: '![](img/d93c92a6-e74e-4a18-8066-ef9ce9be44a7.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d93c92a6-e74e-4a18-8066-ef9ce9be44a7.png)'
- en: After the EC2 instances have been enumerated, it will likely ask you the same
    question for EC2 launch templates, which also hold user data. We can allow this
    to enumerate as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举了EC2实例之后，它可能会询问您是否对EC2启动模板进行相同的操作，因为启动模板也包含用户数据。我们也可以允许它进行枚举。
- en: After instances and launch templates have been enumerated, the execution will
    switch back to our original `ec2__download_userdata` module to download and decode
    the user data associated with any instances or launch templates that we found.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举了实例和启动模板之后，执行将切换回我们原始的`ec2__download_userdata`模块，以下载和解码我们找到的任何实例或启动模板相关联的用户数据。
- en: 'The module found three EC2 instances and one EC2 launch template in our account
    that had user data associated with them. The following screenshot shows the output
    from the module, including the results of its execution and where it stored that
    data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块在我们的帐户中找到了三个EC2实例和一个EC2启动模板，这些实例和模板都与用户数据相关联。以下截图显示了模块的输出，包括其执行结果以及存储数据的位置：
- en: '![](img/ed322637-f4f9-4021-9eb3-819e9fe9e0d6.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed322637-f4f9-4021-9eb3-819e9fe9e0d6.png)'
- en: The `ec2__download_userdata` module found user data attached to three out of
    four EC2 instances in the account and one out of one launch template found in
    the account. It then saved that data to the `./sessions/Demo/downloads/ec2_user_data/`
    folder of the Pacu directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ec2__download_userdata`模块在帐户中找到了附加到四个EC2实例中的用户数据，并在帐户中找到了一个启动模板中的一个。然后将这些数据保存到Pacu目录的`./sessions/Demo/downloads/ec2_user_data/`文件夹中。'
- en: 'If we navigate to the folder that these files were downloaded to and open them
    in a text editor, we can see the data in plaintext. The following screenshot shows
    that the instance with the `i-0d4ac408c4454dd9b` ID instance in the `ap-northeast-2` region had
    the user data that follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到这些文件下载到的文件夹并在文本编辑器中打开它们，我们可以看到明文数据。以下截图显示了`ap-northeast-2`地区中具有`i-0d4ac408c4454dd9b`ID实例的用户数据如下：
- en: '![](img/dc42e7e7-0963-4aa3-bc64-ddcedaa894eb.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc42e7e7-0963-4aa3-bc64-ddcedaa894eb.png)'
- en: 'This is just an example to demonstrate the concept, so basically when the EC2
    instance is started up, it will run this command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，用来演示这个概念，所以基本上当EC2实例启动时，它将运行这个命令：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then it will continue the boot process. Most of the time, scripts that are passed
    into the EC2 user data are only executed when an instance is first created, but
    by using the `#cloud-boothook` directive in the preceding user data, the instance
    is instructed to run this code on every single boot instead. This is a good method
    to use to gain persistent access to EC2 instances by placing a reverse shell in
    the user data to be executed on every instance reboot, but this will be looked
    at more in further chapters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将继续引导过程。大多数情况下，传递到EC2用户数据中的脚本只有在实例首次创建时才会执行，但是通过在前面的用户数据中使用`#cloud-boothook`指令，实例被指示在每次引导时运行此代码。这是一种很好的方法，可以通过在用户数据中放置一个反向shell来获得对EC2实例的持久访问权限，以便在每次实例重新启动时执行，但这将在后续章节中进一步讨论。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered how to use the Python `boto3` library to our
    advantage during an AWS pentest. It allows us to quickly and simply automate parts
    of our attack process, where we specifically covered how to enumerate IAM permissions
    for ourselves and others in the environment (in two different ways) and how to
    apply that knowledge to escalate our privileges to hopefully become a full administrator
    of the account.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了如何利用Python的`boto3`库来进行AWS渗透测试。它使我们能够快速简单地自动化我们攻击过程的部分，我们特别介绍了如何为自己和环境中的其他人枚举IAM权限的方法（以两种不同的方式），以及如何应用这些知识来提升我们的特权，希望成为账户的完整管理员。
- en: We also looked at how a lot of this process has already been automated for us
    in Pacu. As nice as it would be, Pacu can't encompass every idea, attack methodology,
    or exploit that you think of, so it is important to learn how to use the AWS libraries
    to properly interact with the AWS APIs outside of Pacu. Then, with that knowledge,
    you could even begin writing your own Pacu modules for others to enjoy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了Pacu已经为我们自动化了很多这个过程。尽管Pacu很好，但它不能涵盖你所想到的每一个想法、攻击方法或漏洞，因此学会如何在Pacu之外正确地与AWS
    API进行交互是很重要的。然后，凭借这些知识，你甚至可以开始为其他人编写自己的Pacu模块。
- en: In the next chapter, we are going to continue using `boto3` and Pacu to establish
    persistent access for our target environment. This allows us to survive detection
    by a defender and be sure that we can maintain our access to the environment,
    even in worst-case scenarios. This allows us to help train defenders in incident
    response, so that they can understand what areas of their environment they are
    blind to, and how they can fix them. There are many kinds of potential methods
    to establish persistence in AWS, some of which have already been automated by
    Pacu, and we will take a look at using IAM and Lambda to deploy methods like these.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用`boto3`和Pacu来为我们的目标环境建立持久访问。这使我们能够在最坏的情况下幸存，并确保我们可以保持对环境的访问权限。这使我们能够帮助培训防御者进行事件响应，以便他们可以了解他们的环境中哪些区域是盲点，以及他们如何修复它们。在AWS中建立持久性的潜在方法有很多种，其中一些已经被Pacu自动化，我们将研究如何使用IAM和Lambda来部署这些方法。
