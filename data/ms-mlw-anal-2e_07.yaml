- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Understanding Kernel-Mode Rootkits
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内核模式下的 Rootkit
- en: In this chapter, we are going to dig deeper into the Windows kernel and its
    internal structures and mechanisms. We will cover different techniques used by
    malware authors to hide the presence of their malware from users and antivirus
    products.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将深入探讨 Windows 内核及其内部结构和机制。我们将介绍恶意软件作者用来隐藏恶意软件存在的不同技术，避免被用户和杀毒软件发现。
- en: We will look at different advanced kernel-mode hooking techniques, process injection
    in kernel mode, and how to perform static and dynamic analysis there.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究不同的高级内核模式挂钩技术、内核模式中的进程注入，以及如何在其中进行静态和动态分析。
- en: Before we get into rootkits and learn how they are implemented, we need to understand
    how the **operating system** (**OS**) works and how rootkits can target different
    parts of the OS and use it to their advantage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 Rootkit 和它们是如何实现之前，我们需要理解 **操作系统**（**OS**）是如何工作的，以及 Rootkit 如何针对操作系统的不同部分并加以利用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Kernel mode versus user mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模式与用户模式
- en: Windows internals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 内部结构
- en: Rootkits and device drivers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rootkit 和设备驱动程序
- en: Hooking mechanisms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂钩机制
- en: DKOM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DKOM
- en: Process injection in kernel mode
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模式中的进程注入
- en: KPP in x64 systems (PatchGuard)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x64 系统中的 KPP（PatchGuard）
- en: Static and dynamic analysis in kernel mode
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模式中的静态和动态分析
- en: Kernel mode versus user mode
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模式与用户模式
- en: You have already seen several user-mode processes on your computer (all the
    applications you see are running in user mode) and learned how to modify files,
    connect to the internet, and perform lots of activities. However, you might be
    surprised to know that user-mode applications don't have privileges to do all
    of this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到计算机上运行的多个用户模式进程（所有你看到的应用程序都在用户模式下运行），并学习了如何修改文件、连接互联网并执行大量操作。然而，你可能会惊讶地发现，用户模式应用程序并没有执行所有这些操作的权限。
- en: For any process to create a file or connect to a domain, it needs to send a
    request to the kernel mode to perform that action. This request is done through
    what is known as a system call, and this system call switches to kernel mode to
    perform this action (if permission is granted). Kernel mode and user mode are
    not only supported by the OS – they are also supported by the processors through
    protection rings (or hardware restrictions).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让任何进程创建文件或连接到域，它需要向内核模式发送请求来执行该操作。这个请求是通过所谓的系统调用来完成的，系统调用会切换到内核模式以执行该操作（如果权限允许）。内核模式和用户模式不仅得到操作系统的支持，还得到处理器通过保护环（或硬件限制）的支持。
- en: Protection rings
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护环
- en: 'x86 processors provide four rings of privileges (x64 is slightly different).
    Each ring has lower privileges than the previous one, as shown in the following
    diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: x86 处理器提供四个特权环（x64 稍有不同）。每个环的特权比前一个低，如下图所示：
- en: '![Figure 7.1 – Processor rings'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 处理器环'
- en: '](img/Figure_7.1_B18500.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B18500.jpg)'
- en: Figure 7.1 – Processor rings
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 处理器环
- en: 'Windows uses mainly two of these rings: *RING 0* for kernel mode and *RING
    3* for user mode. Modern processors such as Intel and AMD have another ring (*RING
    1*) for hypervisors and virtualization so that each OS can run natively with hypervisors
    controlling certain operations, such as hard disk access.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 主要使用这两个环：*RING 0* 用于内核模式，*RING 3* 用于用户模式。现代处理器如 Intel 和 AMD 还有另一个环（*RING
    1*）用于虚拟机监控程序（Hypervisor）和虚拟化，以便每个操作系统可以原生运行，同时由虚拟机监控程序控制某些操作，如硬盘访问。
- en: These rings are created for handling faults (such as memory access faults or
    any type of exceptions) and for security. *RING 3* has the least privileges –
    that is, the processes in this ring cannot affect the system, they cannot access
    the memory of other processes, and they cannot access physical memory (they must
    run in virtualized memory). In contrast, *RING 0* can do anything – it can directly
    affect the system and its resources. Therefore, it's only accessible to the Windows
    kernel and the device drivers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保护环用于处理故障（如内存访问故障或任何类型的异常）以及安全性。*RING 3* 具有最少的权限——也就是说，处于此环中的进程无法影响系统，无法访问其他进程的内存，也无法访问物理内存（它们必须在虚拟内存中运行）。相比之下，*RING
    0* 可以做任何事——它可以直接影响系统及其资源。因此，只有 Windows 内核和设备驱动程序可以访问该环。
- en: Windows internals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 内部结构
- en: Before we dive into the malicious activities of rootkits, let's take a look
    at how the Windows OS works and how the interaction between the user mode and
    kernel mode is organized. This knowledge will allow us to understand the specifics
    of kernel-mode malware and what parts of the system it may target.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 rootkit 的恶意活动之前，先来了解一下 Windows 操作系统的工作原理以及用户模式与内核模式之间的交互是如何组织的。这些知识将帮助我们理解内核模式恶意软件的具体情况，以及它可能针对系统的哪些部分。
- en: The anatomy of Windows
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 解剖图
- en: 'As we mentioned previously, the OS is divided into two parts: user mode and
    kernel mode. This is shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，操作系统分为两部分：用户模式和内核模式。以下图示展示了这一点：
- en: '![Figure 7.2 – The Windows OS design'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – Windows 操作系统设计'
- en: '](img/Figure_7.2_B18500.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B18500.jpg)'
- en: Figure 7.2 – The Windows OS design
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Windows 操作系统设计
- en: 'Now, let''s learn about the scope of these applications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下这些应用程序的作用范围：
- en: '`kernel32.dll` in the Win32 and Win64 subsystems.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel32.dll` 在 Win32 和 Win64 子系统中的作用。'
- en: 'These `ntdll.dll`), which communicates directly to kernel mode. `Ntdll.dll`
    is a library that sends requests to the kernel using special instructions, such
    as `sysenter` or `syscall` (depending on the mode and whether it is Intel or AMD;
    in this chapter, we will be using them interchangeably). The request ID is passed
    using the `eax` register:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `ntdll.dll`，它直接与内核模式通信。`Ntdll.dll` 是一个库，使用特殊指令（如 `sysenter` 或 `syscall`，具体取决于模式和是
    Intel 还是 AMD 处理器；在本章中我们将交替使用它们）向内核发送请求。请求 ID 是通过 `eax` 寄存器传递的：
- en: '![Figure 7.3 – The syscall instruction'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 系统调用指令'
- en: '](img/Figure_7.3_B18500.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B18500.jpg)'
- en: Figure 7.3 – The syscall instruction
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 系统调用指令
- en: '**Kernel mode**: This manages all the resources, including the memory, files,
    UI, sound, graphics, and more. It also schedules threads and processes and manages
    the UI of all applications. Kernel mode communicates with device drivers that
    directly send commands or receive inputs from the hardware. It manages all of
    these requests and any operations that should be done before and after.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模式**：管理所有资源，包括内存、文件、用户界面、声音、图形等。它还负责调度线程和进程，并管理所有应用程序的 UI。内核模式与直接发送命令或接收硬件输入的设备驱动程序进行通信。它管理所有这些请求以及在操作前后的任何工作。'
- en: That was a brief explanation of how the Windows OS works. Now, it is time to
    explore the life cycle of a request from user mode to kernel mode so that we can
    gain an understanding of how all this works together. Additionally, we will explore
    how rootkits can interfere with the system to perform malicious activities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Windows 操作系统工作原理的简要解释。现在，我们将深入探讨从用户模式到内核模式的请求生命周期，以便更好地理解这一切是如何协同工作的。此外，我们还将探讨
    rootkit 如何干扰系统并执行恶意活动。
- en: The execution path from user mode to kernel mode
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户模式到内核模式的执行路径
- en: 'First, let''s take a look at the life cycle of one API call that requires kernel
    mode functionality (in this example, this will be `FindFirstFileA`). We will dissect
    each step so that we can understand the role that each part of the system plays
    in handling process requests. This is an important prerequisite for us to understand
    where malware can intervene in this sequence of actions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，来看一下需要内核模式功能的一个 API 调用的生命周期（在这个例子中，我们将使用 `FindFirstFileA`）。我们将详细拆解每一个步骤，以便理解系统中每个部分在处理进程请求时所扮演的角色。这是我们理解恶意软件如何介入这一系列操作的一个重要前提：
- en: '![Figure 7.4 – The API call life cycle'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – API 调用生命周期'
- en: '](img/Figure_7.4_B18500.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B18500.jpg)'
- en: Figure 7.4 – The API call life cycle
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – API 调用生命周期
- en: 'Let''s break down the preceding diagram, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析前面的图示，如下所示：
- en: First, the process calls the `FindFirstFileA` API, which is implemented in the
    `kernel32.dll` library.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进程调用了 `FindFirstFileA` API，该 API 实现于 `kernel32.dll` 库中。
- en: Then, `kernel32.dll` (like all subsystem DLLs) calls a function in the `ntdll.dll`
    library. In this example, it calls an API called `ZwQueryDirectoryFile` (or `ZwQueryDirectoryFileEx`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`kernel32.dll`（与所有子系统 DLL 相同）调用 `ntdll.dll` 库中的一个函数。在这个例子中，它调用了一个名为 `ZwQueryDirectoryFile`（或
    `ZwQueryDirectoryFileEx`）的 API。
- en: All of the `Zw*` APIs execute the `syscall` instruction, as you saw in *Figure
    7.3*. `ZwQueryDirectoryFile` executes `syscall` by providing the command ID in
    `eax` form (here, the command ID is changing from one Windows version to another).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 `Zw*` API 都执行 `syscall` 指令，正如你在 *图 7.3* 中看到的那样。`ZwQueryDirectoryFile` 通过将命令
    ID 以 `eax` 形式提供来执行 `syscall`（这里，命令 ID 会随着 Windows 版本的不同而变化）。
- en: Now, the application moves to kernel mode and the execution is redirected to
    a kernel-mode function called System Service Dispatcher. It is available under
    the name `KiSystemService` (or directly `KiFastCallEntry`) on 32-bit machines
    and `KiSystemCall64` on 64-bit machines; compatibility mode will use the `KiSystemCall32`
    name. The system may also use shadow versions of them with a suffix of `Shadow`
    at the end of it (for example, `KiSystemServiceShadow` or `KiSystemCall64Shadow`).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应用程序进入内核模式，执行被重定向到一个名为系统服务调度器的内核模式函数。它在32位机器上以`KiSystemService`（或直接为`KiFastCallEntry`）的名称提供，在64位机器上则是`KiSystemCall64`；兼容模式下将使用`KiSystemCall32`名称。系统还可能使用带有`Shadow`后缀的它们的影像版本（例如，`KiSystemServiceShadow`或`KiSystemCall64Shadow`）。
- en: 'System Service Dispatcher searches for the function that represents the command
    ID that was in `eax` form (in this case, it is 0x91) in the `NtQueryDirectoryFile`.
    It calls this function and passes all the arguments that were passed to `FindFirstFileA`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统服务调度器搜索表示`eax`形式的命令ID（在本例中为0x91）在`NtQueryDirectoryFile`中的函数。它调用这个函数，并传递所有传递给`FindFirstFileA`的参数：
- en: '![Figure 7.5 – SSDT explained'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – SSDT 解释'
- en: '](img/Figure_7.5_B18500.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B18500.jpg)'
- en: Figure 7.5 – SSDT explained
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – SSDT 解释
- en: Next, `NtQueryDirectoryFile` is executed, and this function sends a request
    called an `fastfat.sys` or `ntfs.sys` driver (this depends on the filesystem that
    is installed). More details on IRPs will be provided shortly.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，执行`NtQueryDirectoryFile`，此函数会发送一个请求，称为`fastfat.sys`或`ntfs.sys`驱动程序（这取决于已安装的文件系统）。更多关于IRP的细节将在稍后提供。
- en: This request passes through multiple device drivers attached to the filesystem
    driver. These device drivers can modify the inputs in any request and the outputs
    (or responses) from the filesystem.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个请求经过多个附加到文件系统驱动程序的设备驱动程序。这些设备驱动程序可以修改任何请求中的输入以及文件系统返回的输出（或响应）。
- en: Finally, the filesystem driver processes the request. The IRP request makes
    its way back to `NtQueryDirectoryFile` with an instruction called `sysret` (or
    `sysexit`). Then, control is returned to the user-mode process, along with the
    results.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，文件系统驱动程序处理请求。IRP请求通过一个名为`sysret`（或`sysexit`）的指令返回到`NtQueryDirectoryFile`。然后，控制权返回到用户模式进程，并带回结果。
- en: This may sound relatively complex but for now, this is all you need to know
    to be able to understand how kernel-mode rootkits work and, more importantly,
    what weaknesses in this process the rootkits can use to achieve their goals.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能相对复杂，但目前为止，这些就是你需要知道的内容，以便理解内核模式rootkit是如何工作的，更重要的是，rootkit如何利用这个过程中存在的弱点来实现它们的目标。
- en: Rootkits and device drivers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rootkit和设备驱动程序
- en: Now that you understand Windows internals and how user mode and kernel mode
    interactions work, let's dig into rootkits. In this section, we will understand
    what rootkits are and how they are designed. After we grasp the basic concepts
    of rootkits, we will discuss device drivers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了Windows内部结构以及用户模式和内核模式交互的工作原理，让我们深入探讨rootkit。在这一部分，我们将了解rootkit是什么以及它们是如何设计的。在我们掌握了rootkit的基本概念后，我们将讨论设备驱动程序。
- en: What is a rootkit?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是rootkit？
- en: Rootkits are essentially low-level tools that provide stealth capabilities to
    malicious modules. This way, their main purpose is generally to complicate the
    malware detection and remediation procedures on the target machine by hiding the
    presence of related artifacts. There are multiple ways this can be done, so let's
    discuss them in detail.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Rootkit本质上是提供隐匿功能的低级工具。它们的主要目的是通过隐藏相关的伪迹来使恶意模块更难被检测和修复，从而使目标机器的恶意软件检测和修复过程复杂化。实现这一目标有多种方法，接下来我们将详细讨论这些方法。
- en: Types of rootkits
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rootkit的类型
- en: 'There are various types of rootkits in user mode, kernel mode, and even boot
    mode:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户模式、内核模式甚至启动模式中都有各种类型的rootkit：
- en: '**User-mode or application rootkits**: We covered user-mode rootkits in [*Chapter
    5*](B18500_05.xhtml#_idTextAnchor446), *Inspecting Process Injection and API Hooking*;
    they inject malicious code into other processes and hook their APIs to hide the
    malware files, registry keys, and other **Indicators of Compromise** (**IoCs**)
    from these processes. They can be used to bypass AV programs, task managers, and
    more.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户模式或应用程序rootkit**：我们在[*第5章*](B18500_05.xhtml#_idTextAnchor446)中介绍了用户模式rootkit，*检查进程注入和API钩取*；它们将恶意代码注入到其他进程中，并挂钩其API，以隐藏恶意软件文件、注册表键和其他**妥协指标**（**IoC**）不被这些进程发现。它们可以用来绕过防病毒程序、任务管理器等。'
- en: '**Kernel-mode rootkits**: We will be primarily covering these rootkits in this
    chapter. These rootkits are device drivers that hook different functions in kernel
    mode to hide the malware''s presence and give the malware the power of kernel
    mode. They can also inject code and data into other processes, terminate AV processes,
    intercept network traffic, perform **man-in-the-middle** (**MITM**) attacks, and
    more.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模式根套件**：本章将主要介绍这些根套件。它们是设备驱动程序，钩住内核模式中的不同功能，以隐藏恶意软件的存在并赋予恶意软件内核模式的权限。它们还可以向其他进程注入代码和数据，终止
    AV 进程，拦截网络流量，执行**中间人攻击**（**MITM**）等。'
- en: '**Bootkits**: Bootkits are rootkits that modify the boot loader. They are used
    to load malicious files before the OS even boots. This allows the malware to take
    full control before the OS and its security mechanisms launch.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导根套件**：引导根套件是修改引导加载程序的根套件。它们用于在操作系统启动之前加载恶意文件。这使得恶意软件可以在操作系统及其安全机制启动之前完全控制计算机。'
- en: '**Firmware rootkits**: This group of threats targets firmware (such as **Unified
    Extensible Firmware Interface** (**UEFI**) or **Basic Input/Output System** (**BIOS**))
    to achieve the earliest execution possible.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固件根套件**：这一类威胁针对固件（如**统一可扩展固件接口**（**UEFI**）或**基本输入输出系统**（**BIOS**））进行攻击，以实现尽早的执行。'
- en: '**Hypervisor or virtual rootkits**: At the time of writing, these threats exist
    mostly in the form of **Proofs of Concept** (**PoCs**). They are supposed to reside
    in Ring 1 (hypervisor).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机监控程序或虚拟根套件**：在撰写本文时，这些威胁大多以**概念验证**（**PoCs**）的形式存在。它们应该位于环 1（虚拟机监控程序）中。'
- en: In this chapter, we will focus on kernel-mode rootkits and how they can hook
    multiple functions or modify kernel objects to hide malware. Before we get into
    their hooking mechanisms, first, let's understand what device drivers are.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注内核模式根套件及其如何钩住多个功能或修改内核对象来隐藏恶意软件。在了解它们的钩子机制之前，首先，让我们理解什么是设备驱动程序。
- en: What is a device driver?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是设备驱动程序？
- en: Device drivers are kernel-mode tools that are created to interact with hardware.
    Each hardware manufacturer creates a device driver to communicate with their own
    hardware and translate the IRPs into requests that the hardware device understands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序是内核模式工具，用于与硬件交互。每个硬件制造商都会创建一个设备驱动程序来与他们自己的硬件通信，并将 IRP 转换为硬件设备能够理解的请求。
- en: One of the main purposes of any OS is to standardize the channel of communication
    with any type of device, regardless of the vendor. For example, if you have replaced
    your wired mouse with a wireless one from a different vendor, it should not affect
    the applications that interact with the mouse in general. Additionally, if you
    are a developer, you should not worry about what type of keyboard or printer the
    user has.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的主要目的之一是标准化与任何类型设备的通信渠道，无论设备供应商如何。例如，如果你将有线鼠标换成了来自不同厂商的无线鼠标，它不应影响与鼠标交互的应用程序。同样，如果你是开发者，你也不必担心用户使用的是什么类型的键盘或打印机。
- en: Device drivers make it possible to understand the I/O request and return the
    output in a standardized format, regardless of how the device works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序使得可以理解 I/O 请求，并以标准化格式返回输出，无论设备的工作方式如何。
- en: There are other drivers as well that are not related to actual devices, such
    as antivirus modules and, in our case, rootkits. Kernel-mode rootkits are device
    drivers that use the capabilities that kernel mode provides to support the actual
    malware in terms of stealth and persistence.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些驱动程序与实际设备无关，例如防病毒模块，以及在我们的案例中，根套件。内核模式根套件是设备驱动程序，利用内核模式提供的功能来支持实际的恶意软件，确保其隐蔽性和持久性。
- en: Now, let's take a look at how rootkits achieve their goals and what weaknesses
    in the execution path from user mode to kernel mode they take advantage of.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看根套件如何实现它们的目标，以及它们如何利用从用户模式到内核模式的执行路径中的弱点。
- en: Hooking mechanisms
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子机制
- en: 'In this section, we will explore different types of hooking mechanisms. In
    the following diagram, we can see various types of hooking techniques that rootkits
    use at different stages of the request processing flow:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同类型的钩子机制。在下面的图示中，我们可以看到根套件在请求处理流程的不同阶段使用的各种钩子技术：
- en: '![Figure 7.6 – The hooking mechanisms of rootkits'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 根套件的钩子机制'
- en: '](img/Figure_7.6_B18500_.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B18500_.jpg)'
- en: Figure 7.6 – The hooking mechanisms of rootkits
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 根套件的钩子机制
- en: 'Rootkits can install hooks at different stages of this process flow:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根套件可以在这个过程流的不同阶段安装钩子：
- en: '**User-mode hooking/API hooking**: These are the user-mode API hooking mechanisms
    that are used for hiding malware processes, files, registry keys, and more. We
    covered this in [*Chapter 5*](B18500_05.xhtml#_idTextAnchor446), *Inspecting Process
    Injection and API Hooking*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户模式挂钩/API挂钩**：这些是用于隐藏恶意软件进程、文件、注册表项等的用户模式API挂钩机制。我们在[*第5章*](B18500_05.xhtml#_idTextAnchor446)中讨论过，*检查进程注入和API挂钩*。'
- en: '`sysenter` will transfer the execution to and intercept all requests from user
    mode to kernel mode.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysenter`将把执行转移到内核模式，并拦截从用户模式到内核模式的所有请求。'
- en: '**SSDT hooking**: This technique works more closely with the functions that
    the rootkit wants to hook. This type of hooking modifies the SSDT so that it redirects
    requests to a malicious function instead of the actual function that handles the
    request (it is similar to IAT hooking).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSDT挂钩**：该技术与rootkit希望挂钩的函数更紧密地合作。这种挂钩类型修改SSDT，使其将请求重定向到恶意函数，而不是实际处理请求的函数（类似于IAT挂钩）。'
- en: '**Code patching**: Rather than modifying the SSDT, this rootkit patches the
    function that handles the request to call the malicious function at the start
    (it is similar to API hooking).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码修补**：与其修改SSDT，这种rootkit会修补处理请求的函数，使命令一开始就调用恶意函数（类似于API挂钩）。'
- en: '**Layered drivers/IRP hooking**: This is the legitimate technique for hooking
    and intercepting requests and modifying inputs and outputs. It is harder to detect
    as it is officially supported by Microsoft.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层驱动程序/IRP挂钩**：这是一种合法的挂钩技术，用于拦截请求并修改输入输出。它更难以检测，因为它是微软官方支持的。'
- en: We will also be exploring other techniques used by rootkits, such as `EPROCESS`
    and `ETHREAD`, which we talked about in [*Chapter 3*](B18500_03.xhtml#_idTextAnchor084),
    *Basic Static and Dynamic Analysis for x86/x64*. Apart from that, `sysenter` became
    the preferred method of doing this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索rootkit使用的其他技术，例如`EPROCESS`和`ETHREAD`，这些我们在[*第3章*](B18500_03.xhtml#_idTextAnchor084)中提到过，*x86/x64的基本静态和动态分析*。除此之外，`sysenter`成为了执行这一操作的首选方法。
- en: Now, let's go through these techniques in greater detail.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地了解这些技术。
- en: Hooking the SYSENTER entry function
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂钩SYSENTER入口函数
- en: When a user-mode application executes `sysenter` (`int 0x2e` in Windows 2000
    and earlier versions), the processor switches the execution to kernel mode and,
    in particular, to a specific address stored in the **Model-Specific Register**
    (**MSR**). MSRs are the control registers that are used for debugging, monitoring,
    toggling, or disabling various CPU features.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户模式应用程序执行`sysenter`（在Windows 2000及更早版本中为`int 0x2e`）时，处理器会将执行切换到内核模式，特别是切换到存储在**模型特定寄存器**（**MSR**）中的特定地址。MSR是用于调试、监控、切换或禁用各种CPU功能的控制寄存器。
- en: 'There are several important registers for the user-mode-to-kernel-mode switching
    process when it''s using `sysenter`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`sysenter`进行用户模式到内核模式的切换过程中，有几个重要的寄存器：
- en: '`sysenter`; here, the SS segment register will be a CS value of + 8.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysenter`；在这里，SS段寄存器将是一个值为+8的CS值。'
- en: '`sysenter` is executed; it is where the arguments will be copied to.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysenter`被执行时，它将是参数被复制到的地方。'
- en: '`sysenter`. It points to System Service Dispatcher.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysenter`。它指向系统服务调度器。'
- en: '`KiSystemCall64`).*   `KiSystemCall32`).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KiSystemCall64`).*   `KiSystemCall32`).'
- en: 'These registers can be read and modified using the `rdmsr` and `wrmsr` assembly
    instructions, respectively. The `rdmsr` instruction takes the register ID in the
    `ecx/rcx` register and returns the result in `edx:eax` (`rdx:rax` registers in
    x64; the higher 32 bits in both registers are not used). An example of this is
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器可以分别通过`rdmsr`和`wrmsr`汇编指令进行读取和修改。`rdmsr`指令会将寄存器ID放入`ecx/rcx`寄存器中，并将结果返回到`edx:eax`（在x64中为`rdx:rax`寄存器；这两个寄存器的高32位未使用）。以下是一个示例：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`wrmsr` is very similar to `rdmsr`. `wrmsr` takes the register ID in `ecx`
    and the value to write in the `edx:eax` pair. The hooking code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrmsr`与`rdmsr`非常相似。`wrmsr`将寄存器ID放入`ecx`中，并将要写入的值放入`edx:eax`寄存器对中。以下是挂钩代码：'
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This technique has multiple drawbacks, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有多个缺点，具体如下：
- en: For environments that have multiple processors, only one processor is hooked.
    This means that the attacker has to create multiple threads, hoping that they
    will run on all processors so that it becomes possible to hook all of them.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于有多个处理器的环境，仅挂钩一个处理器。这意味着攻击者必须创建多个线程，希望它们能在所有处理器上运行，从而使得挂钩所有处理器成为可能。
- en: The attacker needs to get the arguments from the user-mode stack and parse them.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者需要从用户模式堆栈中获取参数并解析它们。
- en: In this way, all functions are being hooked, so it is necessary to implement
    some filtration to check only the functions that are supposed to be hooked.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式，所有函数都被挂钩，因此有必要实现一些过滤，以便只检查应挂钩的函数。
- en: This is the first place that malware can hook in kernel mode. Let's take a look
    at the second place, which is while modifying SSDT.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是恶意软件可以在内核模式下挂钩的第一个地方。接下来我们来看第二个地方，就是修改 SSDT 时。
- en: Modifying SSDT in an x86 environment
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 x86 环境中修改 SSDT
- en: 'First things first, the SSDT table is different from and pointed to by the
    first element of the `ntoskrnl.exe` under the name of `KeServiceDescriptorTable`.
    There are slots for four different SDT entries, but Windows has used only two
    of them at the time of writing: `KeServiceDescriptorTable` and `KeServiceDescriptorTableShadow`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，SSDT 表与 `ntoskrnl.exe` 中的第一个元素不同，并且由其指向，名称为 `KeServiceDescriptorTable`。该表有四个不同的
    SDT 条目的插槽，但在写作时，Windows 只使用了其中两个：`KeServiceDescriptorTable` 和 `KeServiceDescriptorTableShadow`。
- en: 'When a user-mode application uses `sysenter`, as you saw in *Figure 7.3*, the
    application provides the function number or ID in the `eax` register. In `eax`,
    this value is divided in the following way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户模式应用程序使用 `sysenter` 时，正如你在 *图 7.3* 中看到的，应用程序会将函数编号或 ID 提供到 `eax` 寄存器中。在 `eax`
    中，这个值以如下方式分割：
- en: '![Figure 7.7 – The sysenter eax argument value'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – sysenter eax 参数值'
- en: '](img/Figure_7.7_B18500.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B18500.jpg)'
- en: Figure 7.7 – The sysenter eax argument value
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – sysenter eax 参数值
- en: 'These values are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值如下所示：
- en: '`bits 0-11`: This is the **System Service Number** (**SSN**), which is the
    index of this function in the SSDT'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits 0-11`：这是 **系统服务编号** (**SSN**)，它是该函数在 SSDT 中的索引。'
- en: '`bits 12-13`: This is the SDT, which represents the SDT number (here, `KeServiceDescriptorTable`
    is 0x00 and `KeServiceDescriptorTableShadow` is 0x01)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits 12-13`：这是 SDT，表示 SDT 编号（这里，`KeServiceDescriptorTable` 是 0x00，`KeServiceDescriptorTableShadow`
    是 0x01）'
- en: '`bits 14-31`: This value is not used and is filled with zeros'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits 14-31`：此值未使用，填充为零'
- en: 'The SDT stores an array of `SYSTEM_SERVICE_TABLE` entries with the first element
    mainly used by modern OSs. It consists of the following fields:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SDT 存储一个 `SYSTEM_SERVICE_TABLE` 条目的数组，现代操作系统主要使用第一个元素。它包含以下字段：
- en: '`KiServiceTable`: This is an SSDT table, an array of function addresses representing
    each SSN that can be passed via `eax` before `sysenter`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KiServiceTable`：这是一个 SSDT 表，表示每个可以通过 `eax` 在 `sysenter` 之前传递的 SSN 的函数地址数组。'
- en: '`CounterBaseTable`: Not used in free (retail) versions of Windows.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CounterBaseTable`：在 Windows 的免费（零售）版本中未使用。'
- en: '`nSystemCalls`: This is the number of items in the `KiServiceTable` and `KiArgumentTable`
    tables.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nSystemCalls`：这是 `KiServiceTable` 和 `KiArgumentTable` 表中项的数量。'
- en: '`KiArgumentTable`: This is an array that is sorted in the same way as `KiServiceTable`.
    Here, each item includes the number of bytes that should be allocated for each
    function''s arguments.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KiArgumentTable`：这是一个数组，其排序方式与 `KiServiceTable` 相同。这里，每个项包含应为每个函数的参数分配的字节数。'
- en: 'For malware to hook this table, it needs to get `KeServiceDescriptorTable`,
    which is exported by `ntoskrnl.exe`, and then move to `KiServiceTable` and modify
    the function that it wants to hook. To be able to modify this table, it needs
    to disable the write protection (as this is a read-only table). There are multiple
    ways to do this, and the most common way is by modifying the `CR0` register value
    and setting the write-protection bit to zero:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让恶意软件挂钩这个表，它需要获取由 `ntoskrnl.exe` 导出的 `KeServiceDescriptorTable`，然后移动到 `KiServiceTable`
    并修改它想要挂钩的函数。为了能够修改这个表，必须禁用写保护（因为这是一个只读表）。有多种方法可以实现这一点，最常见的方法是通过修改 `CR0` 寄存器值并将写保护位设置为零：
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The full hooking mechanism looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的挂钩机制如下所示：
- en: '![Figure 7.8 – The SSDT hooking code from the winSRDF project'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 来自 winSRDF 项目的 SSDT 挂钩代码'
- en: '](img/Figure_7.8_B18500.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B18500.jpg)'
- en: Figure 7.8 – The SSDT hooking code from the winSRDF project
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 来自 winSRDF 项目的 SSDT 挂钩代码
- en: As you can see, the application was able to get the address of the SDT, which
    was exported under the `KeServiceDescriptorTable` name from `ntoskrnl.exe`. Then,
    it got the `KiServiceTable` array, disabled the write protection, and, finally,
    used `InterlockedExchange` to modify the table while no other thread was using
    it (`InterlockedExhange` protects the application from writing at the same time
    when another thread is reading).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用程序能够获取`KeServiceDescriptorTable`的地址，该地址在`ntoskrnl.exe`中以该名称导出。然后，它获取`KiServiceTable`数组，禁用写保护，最后使用`InterlockedExchange`在没有其他线程使用时修改表格（`InterlockedExhange`可以防止应用程序在另一个线程读取时进行写操作）。
- en: Modifying SSDT in an x64 environment
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在x64环境中修改SSDT
- en: For x64 environments, Windows implemented more protection from patching SSDT.
    Initially, SSDT hooking was used by malware and anti-malware products alike. It
    was also used by sandboxes and other behavioral antivirus tools. However, in the
    64-bit version, Microsoft decided to stop this completely and began offering legitimate
    applications and other alternatives rather than SSDT hooking.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x64环境，Windows实现了更多的保护措施来阻止对SSDT的修改。最初，SSDT hooking被恶意软件和反恶意软件产品共同使用，也被沙盒和其他行为型病毒防护工具使用。然而，在64位版本中，微软决定完全停止这种做法，并开始提供合法应用程序和其他替代方案，而不是SSDT
    hooking。
- en: Microsoft implemented multiple forms of protection to stop SSDT hooking, such
    as `KeServiceDescriptorTable` via `ntoskrnl.exe`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 微软实施了多种形式的保护措施来阻止SSDT hooking，如通过`ntoskrnl.exe`中的`KeServiceDescriptorTable`。
- en: Since `KeServiceDescriptorTable` is not exported, malware families started to
    search for functions that used this table to gain access to the addresses. One
    of the functions they used was `KiSystemServiceRepeat`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`KeServiceDescriptorTable`没有导出，恶意软件家族开始寻找使用该表的函数，以便访问地址。他们使用的其中一个函数是`KiSystemServiceRepeat`。
- en: 'This function contains the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能包含以下代码：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, this function uses the addresses of both SSDT entries. However,
    finding this function and the code inside it isn''t very easy. As this function
    is close to `KiSystemCall64` (the `sysenter` entry function in the x64 environment),
    malware generally gets the address of `KiSystemCall64` using the `IA32_SYSENTER_EIP`
    MSR register. By doing so, it can start searching from it until it finds the preceding
    code. In general, malware searches for particular opcodes to find this function,
    as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数使用了两个SSDT条目的地址。然而，找到这个函数及其内部代码并不容易。由于该函数接近`KiSystemCall64`（x64环境中的`sysenter`入口函数），恶意软件通常使用`IA32_SYSENTER_EIP`
    MSR寄存器获取`KiSystemCall64`的地址。通过这样做，它可以从该地址开始搜索，直到找到前面的代码。通常，恶意软件通过搜索特定的操作码来找到这个函数，如下图所示：
- en: '![Figure 7.9 – SSDT hooking in the x64 environment by the zer0m0n project'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – zer0m0n 项目在 x64 环境下的SSDT hooking'
- en: '](img/Figure_7.9_B18500.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.9_B18500.jpg)'
- en: Figure 7.9 – SSDT hooking in the x64 environment by the zer0m0n project
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – zer0m0n 项目在 x64 环境下的SSDT hooking
- en: This mechanism is not completely reliable, and it could easily be broken in
    a later Windows version; however, it's one of the best-known mechanisms for finding
    an SSDT address in x64.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制并不完全可靠，且很容易在以后的Windows版本中被打破；然而，它是寻找x64环境中SSDT地址的最著名机制之一。
- en: Patching SSDT functions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打补丁SSDT函数
- en: The final technique worth mentioning in SSDT hooking is hooking the functions
    that are referenced in the SSDT. This is very similar to API hooking. In this
    case, malware gets the function from the SSDT using the function ID and patches
    the first few bytes with `jmp <malicious_func>`. Then, it returns the execution
    to the original function after checking the process that called this function
    and its parameters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSDT hooking中，最后一个值得提及的技巧是钩取SSDT中引用的函数。这与API hooking非常相似。在这种情况下，恶意软件通过函数ID从SSDT中获取函数，并用`jmp
    <malicious_func>`修改前几个字节。然后，在检查调用该函数的进程及其参数后，它将执行返回到原始函数。
- en: This technique is used because SSDT hooks can easily be detected by antivirus
    or rootkit scanning programs. It's easy to loop through all the functions inside
    the SSDT and search for a function that is outside the legitimate driver's or
    application's memory image.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这一技术是因为SSDT hooks很容易被杀毒软件或rootkit扫描程序检测到。通过遍历SSDT中的所有函数并搜索在合法驱动程序或应用程序内存映像之外的函数，能够轻松地发现钩子。
- en: That's all for SSDT hooking; now, let's take a look at layered drivers, also
    known as IRP hooking.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是SSDT hooking的全部内容；现在，让我们来看看分层驱动程序，也就是IRP hooking。
- en: IRP hooking
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IRP hooking
- en: 'IRPs are the main objects that represent the input (a request) and the output
    (a response) from a device. In many cases, a request packet is processed by a
    chain of drivers until the message can be understood by either the final device
    or the user-mode application (depending on the direction):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: IRP 是代表设备输入（请求）和输出（响应）的主要对象。在许多情况下，请求包会通过一链条驱动程序进行处理，直到该消息能够被最终设备或用户模式应用程序理解（取决于请求的方向）：
- en: '![Figure 7.10 – The structure of the IRP from the official documentation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – IRP 结构，来自官方文档'
- en: '](img/Figure_7.10_B18500.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B18500.jpg)'
- en: Figure 7.10 – The structure of the IRP from the official documentation
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – IRP 结构，来自官方文档
- en: For example, consider that you want to play a music file (such as an MP3 file).
    Once the file has been opened by an application that understands MP3 format, it
    is converted into the format that can be understood by a kernel-mode driver. Then,
    this driver simplifies it for the next driver and so on, until it reaches the
    actual speaker as an encoded group of waves. Another example is an electric signal
    from a keyboard, which is simplified to be a click on a button using an ID (for
    example, the *r* button). Then, it is passed to a keyboard driver, which understands
    that this is the letter *r* and passes it to the next one. This continues until
    it reaches, say, a text editor, such as Notepad, to write the letter *r*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想播放一个音乐文件（例如 MP3 文件）。一旦文件被理解 MP3 格式的应用程序打开，它将被转换为内核模式驱动程序可以理解的格式。接着，这个驱动程序会简化该格式并传递给下一个驱动程序，直到它到达实际的扬声器，并以编码的波形组的形式输出。另一个例子是来自键盘的电信号，它被简化为通过
    ID（例如 *r* 键）点击一个按钮。然后，它被传递给键盘驱动程序，驱动程序理解这是字母 *r* 并将其传递给下一个驱动程序。这一过程一直持续，直到它到达文本编辑器，比如记事本，来写下字母
    *r*。
- en: So, how does all of this relate to rootkits? Well, a rootkit that is present
    in a chain of drivers that processes IRP request packets can change the input
    or the output, thus manipulating the outcome. For example, when a malicious file
    is looked for by a researcher or an antivirus product, the driver can make it
    invisible. This is the only legitimate way that Windows allows developers to hook
    any request from user mode and modify its input and output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切与 rootkit 有什么关系呢？其实，存在于处理 IRP 请求包的驱动链中的 rootkit 可以改变输入或输出，从而操控结果。例如，当研究人员或杀毒软件寻找恶意文件时，驱动程序可以让它变得不可见。这是
    Windows 允许开发人员唯一合法的方式，通过它可以挂钩任何来自用户模式的请求并修改其输入和输出。
- en: Now, let's learn how it will look in assembly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看它在汇编语言中的表现。
- en: Devices and major functions
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备和主要功能
- en: For any driver to be able to receive and handle IRP requests, it is necessary
    to create a device object. This device can be attached to a chain of device drivers
    that process a specific type of IRP request. For example, if the attackers want
    to hook filesystem requests, they need to create a device and attach it to the
    chain of filesystem devices. After this, it becomes possible to start receiving
    IRP requests associated with this filesystem (such as opening a file or querying
    a directory).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让任何驱动程序能够接收和处理 IRP 请求，必须创建一个设备对象。该设备可以附加到处理特定类型 IRP 请求的设备驱动程序链上。例如，如果攻击者想要挂钩文件系统请求，他们需要创建一个设备并将其附加到文件系统设备链上。之后，便可以开始接收与该文件系统相关的
    IRP 请求（例如打开文件或查询目录）。
- en: 'Creating a device object is simple: the driver can simply call the `IoCreateDevice`
    API and provide the flags that correspond to the device it wants to attach to.
    For malware analysis, these flags could help you understand the goal of this device,
    such as the `FILE_DEVICE_DISK_FILE_SYSTEM` flag.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建设备对象很简单：驱动程序可以直接调用 `IoCreateDevice` API 并提供与其要附加的设备相对应的标志。对于恶意软件分析，这些标志可以帮助你理解该设备的目的，例如
    `FILE_DEVICE_DISK_FILE_SYSTEM` 标志。
- en: 'The driver also needs to set up all the dispatch functions (following the `DRIVER_DISPATCH`
    structure) that will receive and handle these requests. Each IRP request has a
    major function code in `IRP_MJ_XXX` format. This code helps us understand what
    this IRP request is about, such as `IRP_MJ_CREATE` (this could be used for creating
    a file or opening a file) or `IRP_MJ_DIRECTORY_CONTROL` (this could be used for
    querying a directory). The initialization is done by placing a pointer to the
    dispatch function in the right place in the `MajorFunction` array of `DriverObject`
    (following the `_DRIVER_OBJECT` structure), where `IPR_MJ_XXX` codes serve as
    indexes. Here is an example of the code implementing this setup:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序还需要设置所有调度函数（遵循 `DRIVER_DISPATCH` 结构），这些函数将接收并处理这些请求。每个 IRP 请求都有一个 `IRP_MJ_XXX`
    格式的主要功能代码。此代码帮助我们理解此 IRP 请求的内容，例如 `IRP_MJ_CREATE`（可用于创建文件或打开文件）或 `IRP_MJ_DIRECTORY_CONTROL`（可用于查询目录）。初始化是通过将调度函数的指针放置到
    `DriverObject` 的 `MajorFunction` 数组中的正确位置来完成的（遵循 `_DRIVER_OBJECT` 结构），其中 `IRP_MJ_XXX`
    代码充当索引。以下是实现此设置的代码示例：
- en: '![Figure 7.11 – Setting up the major functions'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – 设置主要功能'
- en: '](img/Figure_7.11_B18500.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B18500.jpg)'
- en: Figure 7.11 – Setting up the major functions
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 设置主要功能
- en: 'In each of these functions, the driver can get the parameters of this request
    from what is known as the IRP stack. The IRP stack contains all the necessary
    information related to this request, and the driver can add, modify, or remove
    them along the way. To get the pointer to this stack, the driver calls the `IoGetCurrentIrpStackLocation`
    API and provides the address of the IRP of interest. The following is an example
    of a major function that filters files with the `_root_` name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些功能中，驱动程序可以从所谓的 IRP 堆栈中获取此请求的参数。IRP 堆栈包含与此请求相关的所有必要信息，驱动程序可以在处理过程中添加、修改或删除它们。为了获取指向此堆栈的指针，驱动程序调用
    `IoGetCurrentIrpStackLocation` API，并提供感兴趣的 IRP 地址。以下是一个示例，展示了一个过滤名称为 `_root_`
    文件的主要功能：
- en: '![Figure 7.12 – A major function creates a ﬁlter to process ﬁles with the "_root_"
    name'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – 一个主要功能创建一个过滤器来处理具有“_root_”名称的文件'
- en: '](img/Figure_7.12_B18500.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B18500.jpg)'
- en: Figure 7.12 – A major function creates a ﬁlter to process ﬁles with the "_root_"
    name
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 一个主要功能创建一个过滤器来处理具有“_root_”名称的文件
- en: After the rootkit has created its device(s) and set up its major functions,
    it can hook the corresponding requests by attaching itself to the device that
    receives the requests of the rootkit's interest.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 rootkit 创建了其设备并设置了主要功能后，它可以通过将自己附加到接收 rootkit 感兴趣的请求的设备上来拦截相应的请求。
- en: From the user-mode side, software can also send custom requests to drivers by
    utilizing `DeviceIoControl` API. Calling this function will create an `IRP_MJ_DEVICE_CONTROL`
    request. Some IOCTLs are public in that they are system-defined and documented
    by Microsoft, while some are private in that they are unique to a particular piece
    of software, including malware. It is also worth mentioning that upper-level drivers
    can send IOCTL codes to lower-level drivers using the `IRP_MJ_DEVICE_CONTROL`
    and `IRP_MJ_INTERNAL_DEVICE_CONTROL` requests. The drivers process them the same
    way as any other IRPs – by registering dedicated `DRIVER_DISPATCH` callback functions
    in the driver object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户模式侧，软件也可以利用 `DeviceIoControl` API 向驱动程序发送自定义请求。调用此函数会创建一个 `IRP_MJ_DEVICE_CONTROL`
    请求。某些 IOCTL 是公开的，它们是系统定义的，并由 Microsoft 文档化，而一些则是私有的，特定于某个软件，包括恶意软件。还值得一提的是，上级驱动程序可以通过
    `IRP_MJ_DEVICE_CONTROL` 和 `IRP_MJ_INTERNAL_DEVICE_CONTROL` 请求将 IOCTL 代码发送给下级驱动程序。驱动程序会像处理其他
    IRP 一样处理它们，通过在驱动对象中注册专门的 `DRIVER_DISPATCH` 回调函数。
- en: Attaching to a device
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加到设备
- en: 'For the rootkit to attach to a named device (for example, `\\FileSystem\\fastfat`,
    to receive filesystem requests), it needs to get the device object for that named
    device. There are multiple ways to do this, and one of them is to use the undocumented
    `ObReferenceObjectByName` API. Once the device object is found, the rootkit can
    use the `IoAttachDeviceToDeviceStack` API to attach to its chain of drivers and
    receive the IRP requests that are sent to it. The code for this could be as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 rootkit 附加到一个命名设备（例如，`\\FileSystem\\fastfat`，以接收文件系统请求），它需要获取该命名设备的设备对象。有多种方法可以实现这一点，其中一种方法是使用未记录的
    `ObReferenceObjectByName` API。一旦找到设备对象，rootkit 就可以使用 `IoAttachDeviceToDeviceStack`
    API 将其附加到设备驱动链中，从而接收发送给它的 IRP 请求。代码可能如下所示：
- en: '![Figure 7.13 – Attaching to the FastFat ﬁlesystem'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 – 附加到 FastFat 文件系统'
- en: '](img/Figure_7.13_B18500.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B18500.jpg)'
- en: Figure 7.13 – Attaching to the FastFat ﬁlesystem
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 附加到 FastFat 文件系统
- en: After executing the `IoAttachDeviceToDeviceStack` API, the driver will be added
    to the top of the chain, which means that the rootkit driver will be the first
    driver to receive the IRP requests. Then, it can pass requests along to the next
    driver using the `IoCallDriver` API. Additionally, the rootkit would be the last
    driver to modify the response of the IRP request after setting a completion routine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `IoAttachDeviceToDeviceStack` API 后，驱动程序将被添加到链条的顶部，这意味着 rootkit 驱动程序将是第一个接收到
    IRP 请求的驱动程序。然后，它可以通过 `IoCallDriver` API 将请求传递给下一个驱动程序。此外，在设置完成例程后，rootkit 会是最后一个修改
    IRP 请求响应的驱动程序。
- en: Modifying the IRP response and setting a completion routine
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改 IRP 响应并设置完成例程
- en: Completion routines cover situations where more processing is required after
    the request is processed by the last driver. For a rootkit, completion routines
    allow it to modify the output of the request; for example, deleting a filename
    from a list of files in a specific directory. Setting up a completion routine
    requires it to copy the request parameters to the lower driver in the chain. To
    copy these parameters to the next driver's stack, the rootkit can use the `IoCopyCurrentIrpStackLocationToNext`
    API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成例程涵盖了请求被最后一个驱动程序处理后仍需要进一步处理的情况。对于 rootkit 来说，完成例程允许它修改请求的输出；例如，从特定目录中的文件列表中删除文件名。设置完成例程时，它需要将请求参数复制到链条中较低的驱动程序。为了将这些参数复制到下一个驱动程序的堆栈，rootkit
    可以使用 `IoCopyCurrentIrpStackLocationToNext` API。
- en: 'Once all the parameters have been copied for the next driver, the malware can
    set the completion routine using `IoSetCompletionRoutine`, and then pass this
    request to the next driver using `IoCallDriver`. An example from the Microsoft
    documentation is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有参数都被复制到下一个驱动程序，恶意软件可以通过 `IoSetCompletionRoutine` 设置完成例程，然后通过 `IoCallDriver`
    将请求传递给下一个驱动程序。以下是来自微软文档的示例：
- en: '[PRE4]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the last driver in the chain executes the `IoCompleteRequest` API, the
    completion routines will be executed one by one, starting from the lowest driver's
    completion routine to the highest. If the rootkit is the last driver attached
    to this device, it will have its completion routine executed last.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链条中的最后一个驱动程序执行 `IoCompleteRequest` API，完成例程将按顺序执行，从最低的驱动程序的完成例程开始，依次到最高的。如果
    rootkit 是附加到该设备的最后一个驱动程序，它的完成例程将在最后执行。
- en: Now, let's learn about another technique that's commonly used by rootkits to
    hide malicious activity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解另一种常常被 rootkit 用来隐藏恶意活动的技术。
- en: DKOM
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DKOM
- en: 'DKOM is one of the most common techniques used by rootkits to hide malicious
    user-mode processes. This technique relies on how the OS represents processes
    and threads. To understand this technique, you need to learn more about the objects
    that are being manipulated by the rootkit: `EPROCESS` and `ETHREAD`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: DKOM 是 rootkit 用来隐藏恶意用户模式进程的最常见技术之一。该技术依赖于操作系统如何表示进程和线程。要理解这一技术，你需要更多地了解 rootkit
    操作的对象：`EPROCESS` 和 `ETHREAD`。
- en: The kernel objects – EPROCESS and ETHREAD
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核对象 – EPROCESS 和 ETHREAD
- en: 'Windows creates an object called `EPROCESS` for each process that''s created
    in the system. This object includes all the important information about this process,
    such as its `ActiveProcessLinks`, which connects all `EPROCESS` objects of all
    processes. Each `EPROCESS` includes an address to the next `EPROCESS` object (which
    represents the next process) called `FLink` and the address to the previous `EPROCESS`
    object (which is associated with the previous process) called `BLink`. Both addresses
    are stored in `ActiveProcessLinks`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 为系统中每个创建的进程创建一个叫做 `EPROCESS` 的对象。该对象包含关于此进程的所有重要信息，例如它的 `ActiveProcessLinks`，该链连接所有进程的
    `EPROCESS` 对象。每个 `EPROCESS` 对象包含指向下一个 `EPROCESS` 对象（表示下一个进程）的地址，称为 `FLink`，以及指向前一个
    `EPROCESS` 对象（与前一个进程相关）的地址，称为 `BLink`。这两个地址都存储在 `ActiveProcessLinks` 中：
- en: '![Figure 7.14 – The EPROCESS structure'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – EPROCESS 结构'
- en: '](img/Figure_7.14_B18500.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B18500.jpg)'
- en: Figure 7.14 – The EPROCESS structure
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – EPROCESS 结构
- en: The exact structure of `EPROCESS` changes from one version of the OS to another.
    That is, some fields get added, some get removed, and, sometimes, rearrangements
    happen. Rootkits have to keep up with these changes if they want to manipulate
    these structures.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`EPROCESS` 的确切结构会随着操作系统版本的不同而变化。也就是说，某些字段会被添加，某些字段会被删除，有时还会发生重排。rootkits 必须跟上这些变化，才能操控这些结构。'
- en: 'Before we dive into the object manipulation strategies, there''s another object
    that you need to know about: `ETHREAD`. `ETHREAD`, and its core, `KTHREAD`, includes
    all the information related to a specific thread, including its context, status,
    and the address of the corresponding process object (`EPROCESS`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨对象操控策略之前，还有一个你需要了解的对象：`ETHREAD`。`ETHREAD` 及其核心 `KTHREAD` 包含与特定线程相关的所有信息，包括线程上下文、状态以及相应进程对象
    (`EPROCESS`) 的地址：
- en: '![Figure 7.15 – The ETHREAD structure'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – ETHREAD 结构'
- en: '](img/Figure_7.15_B18500.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B18500.jpg)'
- en: Figure 7.15 – The ETHREAD structure
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – ETHREAD 结构
- en: When Windows switches between threads, it follows the links between them in
    the `ETHREAD` structure (that is, the linked list that connects all `ETHREAD`
    objects). From this object, it loads the thread's process (following its `EPROCESS`
    address) and then loads the thread context to execute it. This process of loading
    each thread is not directly connected to the linked list that connects all processes
    (particularly, their `EPROCESS` representations), and this is what makes the DKOM
    so effective.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Windows 在线程之间切换时，它会遵循 `ETHREAD` 结构中的链接（即连接所有 `ETHREAD` 对象的链表）。从这个对象，它加载线程的进程（跟踪其
    `EPROCESS` 地址），然后加载线程上下文来执行它。加载每个线程的过程与连接所有进程的链表（特别是它们的 `EPROCESS` 表示）没有直接关系，这使得
    DKOM 攻击非常有效。
- en: How do rootkits perform an object manipulation attack?
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rootkits 如何执行对象操控攻击？
- en: 'For a rootkit to hide a process, it is enough to modify `ActiveProcessLink`
    in the previous and the following `EPROCESS` objects (relative to malware) to
    skip the `EPROCESS` address of the process it wants to hide. The steps are simple
    and are given as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏进程，rootkit 只需修改前后两个 `EPROCESS` 对象（相对于恶意软件）的 `ActiveProcessLink`，跳过它想要隐藏的进程的
    `EPROCESS` 地址。步骤很简单，具体如下：
- en: Get the current process's `EPROCESS` using the `PsLookupProcessByProcessId`
    API.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PsLookupProcessByProcessId` API 获取当前进程的 `EPROCESS`。
- en: Follow the ActiveProcessLinks to find the `EPROCESS` object of the process that
    needs to be hidden.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪 `ActiveProcessLinks`，找到需要隐藏的进程的 `EPROCESS` 对象。
- en: Change the `FLink` property of the previous `EPROCESS` so that it doesn't point
    to this `EPROCESS` but the next one instead.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改前一个 `EPROCESS` 的 `FLink` 属性，使其不指向此 `EPROCESS`，而是指向下一个进程。
- en: Change the `BLink` property of the next process so that it doesn't point to
    this `EPROCESS` but the previous one instead.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改下一个进程的 `BLink` 属性，使其不指向此 `EPROCESS`，而是指向前一个进程。
- en: 'The challenging part in this process is to reliably find the `ActiveProcessLinks`
    with all the changes that Windows introduces from one version to another. There
    are multiple techniques for dealing with the offset of `ActiveProcessLinks` (and
    the process ID as well), as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中具有挑战性的一部分是，可靠地找到 `ActiveProcessLinks`，因为 Windows 从一个版本到另一个版本引入了许多变化。处理
    `ActiveProcessLinks`（以及进程 ID）偏移量的技术有多种，如下所示：
- en: Get the OS version and, based on that version, choose the right offset from
    the precalculated offsets for each version of the OS.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取操作系统版本，并根据该版本选择合适的偏移量（从为每个操作系统版本预先计算的偏移量中选择）。
- en: Search for the process ID (you can get it from `PsGetCurrentProcessId`) and
    find the `ActiveProcessLinks` offset from the process ID.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找进程 ID（可以通过 `PsGetCurrentProcessId` 获取），并找到与进程 ID 相关的 `ActiveProcessLinks`
    偏移量。
- en: 'Here is an example of the second technique:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二种技术的示例：
- en: '![Figure 7.16 – Finding the process ID from the EPROCESS object'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 – 从 EPROCESS 对象中查找进程 ID'
- en: '](img/Figure_7.16_B18500.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B18500.jpg)'
- en: Figure 7.16 – Finding the process ID from the EPROCESS object
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 从 EPROCESS 对象中查找进程 ID
- en: 'Once the rootkit can find the process ID (`pids`) inside the `EPROCESS` object
    (`epocs`), it can use the offset between `ActiveProcessLinks` and the process
    ID (this is usually precalculated and is the next field in the structure). The
    last step is to remove the links between the processes, as shown in the following
    screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 rootkit 能够在 `EPROCESS` 对象（`epocs`）中找到进程 ID（`pids`），它可以使用 `ActiveProcessLinks`
    和进程 ID 之间的偏移量（通常是预先计算好的，并且是结构中的下一个字段）。最后一步是删除进程之间的链接，如下图所示：
- en: '![Figure 7.17 – Removing the process links to perform a DKOM attack'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.17 – 移除进程链接以执行 DKOM 攻击'
- en: '](img/Figure_7.17_B18500.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B18500.jpg)'
- en: Figure 7.17 – Removing the process links to perform a DKOM attack
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 移除进程链接以执行 DKOM 攻击
- en: 'This is what the result will look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Figure 7.18 – DKOM attack – the process in the middle is skipped during traversal'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.18 – DKOM攻击 – 遍历时跳过中间的进程'
- en: '](img/Figure_7.18_B18500.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.18_B18500.jpg)'
- en: Figure 7.18 – DKOM attack – the process in the middle is skipped during traversal
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – DKOM攻击 – 遍历时跳过中间的进程
- en: The most popular technique for detecting DKOM attacks is to loop through all
    the running threads and follow their link to `EPROCESS`, before comparing the
    results with the data obtained by following `ActiveProcessLinks`. If there's a
    missing `EPROCESS` object in `ActiveProcessLink` that appeared as an `EPROCESS`
    for an active thread, it implies that a DKOM attack is being performed by a rootkit
    to hide this process and its `EPROCESS` object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 检测DKOM攻击的最常见技术是遍历所有正在运行的线程，并通过它们的链接找到`EPROCESS`，然后将结果与通过`ActiveProcessLinks`获得的数据进行比较。如果在`ActiveProcessLink`中缺少一个出现在活跃线程中的`EPROCESS`对象，这意味着根套件正在执行DKOM攻击，隐藏该进程及其`EPROCESS`对象。
- en: Now, let's talk about how malware can perform process injection from kernel
    mode.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论恶意软件如何在内核模式下执行进程注入。
- en: Process injection in kernel mode
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模式下的进程注入
- en: Process injection in kernel mode is a popular technique used by multiple malware
    families, including **Stuxnet** (with its **MRxCls** rootkit), to create another
    way of maintaining persistence and disguising malware activities under a legitimate
    process name. For a device driver to be able to read and write memory inside a
    process, it needs to attach itself to this process's memory space.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式下的进程注入是一种被多个恶意软件家族广泛使用的技术，包括**Stuxnet**（其**MRxCls** rootkit）利用该技术在合法进程名称下维护持久性并隐藏恶意活动。为了让设备驱动程序能够读写进程内存，它需要将自身附加到该进程的内存空间。
- en: 'Once the driver is attached to this process''s memory space, it can see this
    process''s virtual memory, and it becomes possible to read and write directly
    to it. For example, if the process executable''s ImageBase is `0x00400000`, then
    the driver can access it normally, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦驱动程序附加到该进程的内存空间，它就可以看到该进程的虚拟内存，并能够直接读写。举个例子，如果进程可执行文件的ImageBase是`0x00400000`，那么驱动程序可以正常访问它，如下所示：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For a driver to be able to attach to the process memory, it needs to get its
    `EPROCESS` using the `PsLookupProcessByProcessId` API and then use the `KeStackAttachProcess`
    API to attach to this process''s memory space. In disassembly, the code will be
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让驱动程序能够附加到进程内存，它需要使用`PsLookupProcessByProcessId` API获取其`EPROCESS`，然后使用`KeStackAttachProcess`
    API附加到该进程的内存空间。在反汇编代码中，代码如下所示：
- en: '![Figure 7.19 – Getting the EPROCESS object using its PID (from the Stuxnet
    rootkit, MRxCls)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.19 – 使用PID获取EPROCESS对象（来自Stuxnet rootkit，MRxCls）'
- en: '](img/Figure_7.19_B18500.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B18500.jpg)'
- en: Figure 7.19 – Getting the EPROCESS object using its PID (from the Stuxnet rootkit,
    MRxCls)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 使用PID获取EPROCESS对象（来自Stuxnet rootkit，MRxCls）
- en: 'Then, to attach to that process''s memory space, you can use the following
    code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要附加到该进程的内存空间，你可以使用以下代码：
- en: '![Figure 7.20 – Attaching to the process''s memory space'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.20 – 附加到进程的内存空间'
- en: '](img/Figure_7.20_B18500.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.20_B18500.jpg)'
- en: Figure 7.20 – Attaching to the process's memory space
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 附加到进程的内存空间
- en: Once the driver is attached, it can read and write to its memory space, as well
    as allocate memory using the `ZwAllocateVirtualMemory` API, providing the process
    handle using the `ZwOpenProcess` API (which is equivalent to `OpenProcess` in
    user mode).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦驱动程序附加，它就可以读取和写入其内存空间，并且可以使用`ZwAllocateVirtualMemory` API分配内存，通过`ZwOpenProcess`
    API提供进程句柄（相当于用户模式下的`OpenProcess`）。
- en: 'For a driver to detach from the process memory, it can execute the `KeUnstackDetachProcess`
    API, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序要从进程内存中分离，可以执行`KeUnstackDetachProcess` API，如下所示：
- en: '[PRE6]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are other techniques as well, but this technique is the most common way
    for any driver to easily access the virtual memory of any process as its own memory.
    Now, let's take a look at how it can execute code inside that process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他技术，但这种技术是任何驱动程序轻松访问任何进程虚拟内存作为自身内存的最常见方式。现在，让我们来看一下它是如何在该进程内执行代码的。
- en: Executing the inject code using APC queuing
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用APC排队执行注入代码
- en: An `SleepEx`, `SignalObjectAndWait`, `MsgWaitForMultipleObjectsEx`, `WaitForMultipleObjectsEx`,
    or `WaitForSingleObjectEx` APIs) and before it gets resumed, all the queued user-mode
    and kernel-mode APC functions are executed in the context of that thread, allowing
    the malware to execute user-mode code inside that process before returning control
    to it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `SleepEx`、`SignalObjectAndWait`、`MsgWaitForMultipleObjectsEx`、`WaitForMultipleObjectsEx`
    或 `WaitForSingleObjectEx` 等 API 后，线程被恢复之前，所有排队的用户模式和内核模式 APC 函数都将在该线程的上下文中执行，从而使恶意软件能够在该进程内执行用户模式代码，然后再将控制权交还给它。
- en: 'For a malware sample to queue an APC function, it needs to perform the following
    steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个恶意软件样本排队 APC 函数，它需要执行以下步骤：
- en: Get the `ETHREAD` object of the thread it wants to queue an APC function by
    providing its `PsLookupThreadByThreadId` API.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供 `PsLookupThreadByThreadId` API，获取要排队 APC 函数的线程的 `ETHREAD` 对象。
- en: Attach the user-mode function to this thread using the `KeInitializeApc` API.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `KeInitializeApc` API 将用户模式函数附加到该线程。
- en: 'Add this function to the queue of the APC functions to be executed in this
    thread using the `KeInsertQueueApc` API, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `KeInsertQueueApc` API 将此函数添加到该线程中待执行的 APC 函数队列，如下图所示：
- en: '![Figure 7.21 – APC queuing to execute a user-mode function (from the winSRDF
    project)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.21 – APC 排队执行用户模式函数（来自 winSRDF 项目）'
- en: '](img/Figure_7.21_B18500.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B18500.jpg)'
- en: Figure 7.21 – APC queuing to execute a user-mode function (from the winSRDF
    project)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – APC 排队执行用户模式函数（来自 winSRDF 项目）
- en: In this example, the `KeInitializeApc` API will execute a kernel-mode function
    called `ApcKernelRoutine` and a user-mode function called `Entrypoint` once the
    thread returns from its alertable state.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`KeInitializeApc` API 将在线程从其可警报状态返回后执行一个内核模式函数 `ApcKernelRoutine` 和一个用户模式函数
    `Entrypoint`。
- en: If the thread didn't execute any of the previously mentioned APIs and never
    enters an alertable state until it is terminated, none of the queued APC functions
    will be executed. Therefore, some malware families tend to attach their APC thread
    to multiple running threads in the application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程没有执行之前提到的任何 API，并且在终止之前从未进入可警报状态，那么队列中的 APC 函数将不会被执行。因此，一些恶意软件家族倾向于将它们的
    APC 线程附加到应用程序中的多个运行线程上。
- en: Other rootkits, such as MRxCls (from Stuxnet), modify the entry point of the
    application before it gets executed. This allows the malicious code to be executed
    in the context of the main thread before the application runs and without using
    any APC queuing functionality.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 rootkit，例如 MRxCls（来自 Stuxnet），在应用程序执行之前修改其入口点。这允许恶意代码在应用程序运行之前在主线程的上下文中执行，并且不使用任何
    APC 排队功能。
- en: At this stage, we have learned enough about how rootkits generally work, so
    let's talk about what protection mechanisms have been developed to fight them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一阶段，我们已经了解了 rootkit 的一般工作原理，接下来让我们谈谈为了对抗 rootkit 所开发的保护机制。
- en: KPP in x64 systems (PatchGuard)
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x64 系统中的 KPP（PatchGuard）
- en: In x64 systems, Microsoft has introduced new protection against kernel-mode
    hooking and patching called **KPP**, or **PatchGuard**. This protection disables
    any patching of the SSDT and the core kernel code. It doesn't allow the usage
    of kernel stacks beyond what was allocated by the kernel itself.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x64 系统中，微软引入了一种新的保护机制，防止内核模式钩取和打补丁，称为 **KPP**，也叫 **PatchGuard**。此保护机制禁用了对
    SSDT 和核心内核代码的任何打补丁，并且不允许使用内核分配以外的内核栈。
- en: Additionally, Microsoft allows only signed drivers to be loaded in the x64 systems,
    except for situations when the system is running in test mode or driver signature
    enforcement is disabled.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微软只允许在 x64 系统中加载签名的驱动程序，除非系统处于测试模式或禁用了驱动程序签名强制。
- en: KPP received lots of criticism from antivirus and firewall vendors when it was
    first introduced because SSDT hooking and other hooking types were heavily used
    in multiple security products. Microsoft has created a new API to help antivirus
    products replace their hooking methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当 KPP 最初推出时，受到防病毒和防火墙厂商的强烈批评，因为 SSDT hooking 和其他钩取方法在多个安全产品中被广泛使用。微软为帮助防病毒产品替换其钩取方法，创建了一个新的
    API。
- en: Although several ways of bypassing PatchGuard have been documented, for the
    last several years, Microsoft has released only a few major updates to deal with
    these techniques. In addition, the PatchGuard code is changing its position in
    kernel mode from one update to another, making it a moving target and breaking
    all the previous malware families that had been able to bypass it in the previous
    versions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已有多种绕过 PatchGuard 的方法被文档化，但在过去的几年里，微软仅发布了少数几个主要更新来应对这些技术。此外，PatchGuard 代码在内核模式中的位置会随着每次更新发生变化，使其成为一个移动目标，并且打破了所有先前能够绕过
    PatchGuard 的恶意软件家族。
- en: Now, let's take a look at different bypassing techniques that were introduced
    in some of the previous malware families.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些之前的恶意软件家族介绍的不同绕过技术。
- en: Bypassing driver signature enforcement
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过驱动程序签名强制检查
- en: 'Apart from the ability to use stolen certificates to sign the malicious driver
    (an example of this could be Stuxnet drivers), it''s also possible to disable
    the driver signature enforcement option using the Command Prompt, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用被窃取的证书签名恶意驱动程序（例如 Stuxnet 驱动程序），还可以通过命令提示符禁用驱动程序签名强制选项，如下所示：
- en: '[PRE7]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, the system will start allowing drivers to be signed with certificates
    that are not issued by Microsoft. This command requires administrator privileges
    and the machine to be restarted afterward. However, with the help of social engineering,
    it''s possible to trick the user into making it. Another option that used to be
    available was the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，系统将开始允许使用未由微软颁发的证书签名的驱动程序。此命令需要管理员权限，并且之后需要重启机器。然而，通过社会工程学的帮助，可以欺骗用户执行此操作。以前可用的另一个选项是以下命令：
- en: '[PRE8]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, at the time of writing, this option is ignored on major modern versions
    of Windows.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写时，这个选项在现代版本的 Windows 上被忽视。
- en: Additionally, some malware families abuse vulnerable signed drivers of legitimate
    products, which either have code execution vulnerabilities or vulnerabilities
    that allow the arbitrary memory inside the kernel to be modified. An example of
    this is Turla malware (which is believed to be state-sponsored APT malware). It
    loads a VirtualBox driver and uses it to amend the `g_CiEnabled` kernel variable
    and, by doing so, disable driver signature enforcement on the fly (without the
    need to restart the system).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些恶意软件家族滥用合法产品的有漏洞签名驱动程序，这些驱动程序要么存在代码执行漏洞，要么存在允许修改内核内部任意内存的漏洞。一个例子就是 Turla
    恶意软件（被认为是国家支持的APT恶意软件）。它加载了一个 VirtualBox 驱动程序，并利用它修改了 `g_CiEnabled` 内核变量，从而在运行时禁用驱动程序签名强制检查（无需重启系统）。
- en: Bypassing PatchGuard – the Turla example
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过 PatchGuard – Turla 示例
- en: Turla was also able to bypass PatchGuard by disabling its ability to show the
    blue screen of death when the system integrity check fails. After PatchGuard detects
    the unauthorized patching of the system kernel or its important tables (such as
    SSDT or IDT), it calls the `KeBugCheckEx` API to show the blue screen of death.
    Turla malware hooks this API and continues its execution normally.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Turla 还通过禁用系统完整性检查失败时显示蓝屏死机的功能绕过了 PatchGuard。PatchGuard 在检测到未经授权的系统内核修补或其重要表格（如
    SSDT 或 IDT）被修改时，调用 `KeBugCheckEx` API 来显示蓝屏死机。Turla 恶意软件挂钩了这个 API，并正常执行。
- en: 'A later version of PatchGuard was cloning this API on-the-fly to ensure that
    the verification was enforced and caused the system to shut down. However, Turla
    was able to hook an early subroutine in the `KeBugCheckEx` API to make sure it
    was able to resume the execution of the system normally after the integrity check
    failed. The following code is a snippet of the `KeBugCheckEx` API:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: PatchGuard 的一个后续版本会动态克隆这个 API，以确保验证得到执行并导致系统关闭。然而，Turla 能够挂钩 `KeBugCheckEx`
    API 中的一个早期子程序，确保在完整性检查失败后能够正常恢复系统执行。以下代码是 `KeBugCheckEx` API 的一个代码片段：
- en: '[PRE9]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it executes a function called `RtlCaptureContext`, which is
    what Turla malware decided to hook to bypass this update.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它执行了一个名为 `RtlCaptureContext` 的函数，这是 Turla 恶意软件选择挂钩的地方，用来绕过这个更新。
- en: Bypassing PatchGuard – GhostHook
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过 PatchGuard – GhostHook
- en: This technique was introduced by the CyberArk research team in 2017\. It abuses
    a new feature that was introduced by Intel called **Intel Processor Trace** (**Intel
    PT**). This technology allows debugging software to trace single processes, user-mode
    and kernel-mode execution, or perform instruction pointer tracing. This Intel
    PT technology was designed for performance monitoring, diagnostic code coverage,
    debugging, fuzzing, malware analysis, and exploit detection.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术由 CyberArk 研究团队在2017年提出。它利用了英特尔引入的一个新功能，称为 **Intel 处理器跟踪** (**Intel PT**)。该技术允许调试软件跟踪单个进程、用户模式和内核模式的执行，或进行指令指针跟踪。Intel
    PT 技术设计用于性能监控、诊断代码覆盖、调试、模糊测试、恶意软件分析和漏洞检测。
- en: Intel processors and their `callback` routine to handle the memory space issue.
    This `callback` function (that is, the PMI handler) is a function that is targeted
    by the malware as it gets executed in the context of the running thread that is
    being monitored.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Intel 处理器及其 `callback` 例程来处理内存空间问题。这个 `callback` 函数（即 PMI 处理程序）是恶意软件的目标，它在被监控的运行线程的上下文中执行。
- en: Under specific circumstances and by using a very small buffer, malware can force
    the execution of its PMI handler after each `sysenter` call and perform another
    technique, known as `sysenter` hooking, without alerting the PatchGuard protection
    and without the need to do API hooking.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定情况下，恶意软件可以通过使用非常小的缓冲区，在每次 `sysenter` 调用后强制执行其 PMI 处理程序，并执行另一种技术，称为 `sysenter`
    钩取，而不会触发 PatchGuard 保护，也不需要进行 API 钩取。
- en: Now, we will take a look at how to analyze rootkits and, in particular, how
    to dynamically analyze rootkits.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何分析 rootkits，特别是如何动态分析 rootkits。
- en: Static and dynamic analysis in kernel mode
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模式下的静态和动态分析
- en: Once we know how rootkits work, it becomes possible to analyze them. The first
    thing worth mentioning is that not all kernel-mode malware families just hide
    the presence of actual payloads – some of them can perform malicious actions on
    their own as well. In this section, we will familiarize ourselves with tools that
    can facilitate rootkit analysis to understand malware functionalities and learn
    some particular usage-related nuances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了 rootkits 的工作原理，就可以开始分析它们。值得一提的是，并非所有内核模式恶意软件家族只是隐藏实际负载的存在——其中一些还可以执行恶意操作。在本节中，我们将熟悉一些工具，它们可以促进
    rootkit 分析，帮助理解恶意软件功能，并学习一些特定使用的细微差别。
- en: Static analysis
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: It always makes sense to start from static analysis, especially if the debugging
    setup is not available straight away. In some cases, it is possible to perform
    both static and dynamic analysis using the same tools.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从静态分析开始总是明智的，尤其是在调试环境无法立即使用的情况下。在某些情况下，使用相同的工具可以同时进行静态和动态分析。
- en: Rootkit file structure
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rootkit 文件结构
- en: Rootkit samples are usually drivers that implement the traditional MZ-PE structure
    with the `IMAGE_SUBSYSTEM_NATIVE` value specified in the subsystem field of the
    `IMAGE_OPTIONAL_HEADER32` structure. They use the usual x86 or x64 instructions
    that we are already familiar with. Thus, any tool (excluding user-mode debuggers
    such as OllyDbg) that supports them should handle rootkits without any major problems.
    Examples of them include tools such as IDA, radare2, and many others. Additionally,
    IDA plugins such as **win_driver_plugin** and **DriverBuddy** can be very useful
    for auxiliary operations, such as decoding the IOCTL codes involved.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Rootkit 样本通常是实现传统 MZ-PE 结构的驱动程序，并在 `IMAGE_OPTIONAL_HEADER32` 结构的子系统字段中指定 `IMAGE_SUBSYSTEM_NATIVE`
    值。它们使用我们已经熟悉的传统 x86 或 x64 指令。因此，任何支持这些指令的工具（不包括用户模式调试器如 OllyDbg）应该能够处理 rootkits，而不会遇到重大问题。它们的例子包括
    IDA、radare2 等工具。此外，IDA 插件如 **win_driver_plugin** 和 **DriverBuddy** 对于辅助操作非常有用，比如解码涉及的
    IOCTL 代码。
- en: Analysis workflow
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析工作流程
- en: 'Once the sample is open, the first step is to track down `DriverObject`, which
    is provided as the first argument of the main function (through the stack for
    32-bit systems and the `rcx` register for 64-bit systems). In this way, we can
    monitor whether any of the major functions are defined by malware. This object
    implements the `_DRIVER_OBJECT` structure with a list of major functions located
    at the end of it. The corresponding structure member is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开样本，第一步是追踪 `DriverObject`，它作为主函数的第一个参数提供（在32位系统中通过堆栈，在64位系统中通过 `rcx` 寄存器）。通过这种方式，我们可以监视是否有任何主要功能是由恶意软件定义的。这个对象实现了
    `_DRIVER_OBJECT` 结构，并在其末尾列出了主要功能。对应的结构成员如下：
- en: '[PRE10]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In assembly, they will likely be accessed by offsets and can easily be mapped
    by applying this structure.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，它们可能通过偏移量进行访问，可以通过应用此结构轻松映射。
- en: Additionally, it is worth checking whether any completion routine is specified
    using the `IoSetCompletionRoutine` API.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得检查是否通过`IoSetCompletionRoutine` API指定了任何完成例程。
- en: Then, we need to search for the presence of instructions that allow us to disable
    security measures such as the previously mentioned write protection, which involves
    using the `CR0` register. In this way, it becomes possible to easily identify
    the exact location in the code where this functionality is implemented.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要搜索允许禁用安全措施的指令，例如前面提到的写保护，涉及使用`CR0`寄存器。通过这种方式，可以轻松识别代码中实现此功能的确切位置。
- en: Following this, we need to keep track of the crucial import functions we've
    already discussed, which are most commonly used by rootkits, and check the corresponding
    argument strings to learn their purpose. Are there any devices malware attaches
    to? Is there any process or filename mentioned there? Once all these questions
    have been answered, it becomes possible to figure out the rootkit's goal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要跟踪已经讨论过的重要导入函数，这些函数通常被rootkit使用，并检查相应的参数字符串以了解其用途。恶意软件是否附着到任何设备上？是否提到任何进程或文件名？一旦这些问题得到解答，就可以弄清楚rootkit的目标。
- en: Finally, if import functions are resolved dynamically, it makes sense to restore
    them before continuing the analysis. Generally, this can be done either by scripting
    or with the help of dynamic analysis.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果导入函数是动态解析的，在继续分析之前恢复它们是有意义的。通常，可以通过脚本或借助动态分析来完成此操作。
- en: Dynamic and behavioral analysis
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态与行为分析
- en: The dynamic analysis of kernel-mode threats is a trickier part here because
    it is performed on a low level, and any mistake may result in a system crash.
    Therefore, it is highly recommended to perform it on **virtual machines** (**VMs**)
    so that the debugging state can be quickly restored to the previous state. Another
    option is to use a separate machine that is attached using a serial port. However,
    in this case, it generally takes more effort to restore the previous debugging
    state.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式威胁的动态分析是一个更为棘手的部分，因为它在低级别进行，任何错误都可能导致系统崩溃。因此，强烈建议在**虚拟机**（**VMs**）上进行操作，这样调试状态可以快速恢复到之前的状态。另一种选择是使用通过串口连接的独立机器。然而，在这种情况下，恢复之前的调试状态通常需要更多的努力。
- en: Debuggers
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试器
- en: 'When we talk about dynamic analysis, the main group of tools we are referring
    to is debuggers. The most popular debuggers are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论动态分析时，我们所指的主要工具是调试器。最流行的调试器如下：
- en: '`.`"), and extension commands (the ones that start with "`!`"). Here are some
    of the most common commands that are used when performing rootkit analysis:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`")，以及扩展命令（以 "`!`" 开头的命令）。以下是进行rootkit分析时最常用的一些命令：'
- en: '`?`: This is used to display regular commands.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：用于显示常规命令。'
- en: '`.help`: This is used to display meta-commands.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.help`：用于显示元命令。'
- en: '`.hh`: This is used to open the documentation for the specified command.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.hh`：用于打开指定命令的文档。'
- en: '`bp`, `bu`, and `ba`: These are used to set breakpoints, including the usual
    breakpoint, the unresolved breakpoint (this is activated once the module is loaded),
    and the breakpoint on access.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bp`，`bu`，和`ba`：用于设置断点，包括常规断点、未解析断点（当模块加载时激活）和访问断点。'
- en: '`bl`, `bd`, `be`, and `bc`: These are used to list, disable, enable, and clear
    breakpoints, respectively.'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl`，`bd`，`be`，和`bc`：分别用于列出、禁用、启用和清除断点。'
- en: '`g`, `p`, and `t`: These commands refer to go (continue execution), single
    step, and single trace, respectively.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`，`p`，和`t`：这些命令分别表示继续执行（go），单步执行（single step）和单步追踪（single trace）。'
- en: '`d` and `u`: These commands display memory and disassembled instructions, respectively.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 和 `u`：分别用于显示内存和反汇编指令。'
- en: '`e`: This is used to enter specified values into memory (that is, edit memory).'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`：用于将指定的值输入内存（即编辑内存）。'
- en: '`dt`: This is used to parse and describe data types. For example, `dt ntdll!_PEB`
    will display the PEB structure with offsets, field names, and data types.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dt`：用于解析和描述数据类型。例如，`dt ntdll!_PEB`将显示带有偏移量、字段名和数据类型的PEB结构。'
- en: '`r`: This allows you to display or modify registers. Here, `r eip=<val>` can
    be used to change the instruction pointer.'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：用于显示或修改寄存器。这里，`r eip=<val>`可以用来更改指令指针。'
- en: '`x`: This is used to list symbols that match the pattern; for example, `x ntdll!*`
    will list all symbols from `ntdll`.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 用于列出匹配模式的符号；例如，`x ntdll!*` 将列出来自 `ntdll` 的所有符号。'
- en: '`lm`: This is used to list modules; it works by displaying a list of loaded
    drivers and their corresponding memory ranges.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lm`: 用于列出模块；它通过显示加载的驱动程序及其对应的内存范围来工作。'
- en: '`!dh`: This is a dump header command; it can be used to parse and display the
    MZ-PE header by ImageBase.'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!dh`: 这是一个转储头命令；它可以用来解析和显示 MZ-PE 头信息，通过 ImageBase。'
- en: '`!process`: This displays various pieces of information about the specified
    process, including the PEB address. For example, `!process 0 0 lsass.exe` will
    display basic information about `lsass.exe`, and the 7 flag can be used to display
    full details, including TEB structures.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!process`: 显示指定进程的各种信息，包括 PEB 地址。例如，`!process 0 0 lsass.exe` 将显示 `lsass.exe`
    的基本信息，使用 7 标志可以显示完整的细节，包括 TEB 结构。'
- en: '`.process`: This command sets the process context. For example, `.process /i
    <PROCESS>` (where the `<PROCESS>` value can be taken from the output of the `!process`
    command that was previously mentioned) followed by `g` and `.reload /user` allows
    you to switch to the debugging of the specified process.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.process`: 此命令设置进程上下文。例如，`.process /i <PROCESS>`（其中 `<PROCESS>` 值可以从之前提到的
    `!process` 命令的输出中获取），然后执行 `g` 和 `.reload /user` 可以让你切换到指定进程的调试模式。'
- en: '`!peb`: This parses and displays the PEB structure of the specified process.
    This command can help you switch to the process context using the `.process` command
    first.'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!peb`: 解析并显示指定进程的 PEB 结构。此命令可以帮助你通过首先使用 `.process` 命令切换到进程上下文。'
- en: '`!teb`: This parses and displays the specified TEB structure.'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!teb`: 解析并显示指定的 TEB 结构。'
- en: '`.shell`: This allows you to use Windows console commands from WinDbg. For
    example, `.shell -ci "<windbg_command>" findstr <value>` will allow you to parse
    the output of executed commands.'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shell`: 允许你从 WinDbg 使用 Windows 控制台命令。例如，`.shell -ci "<windbg_command>" findstr
    <value>` 允许你解析执行命令的输出。'
- en: '`.writemem`: This dumps memory to a file.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.writemem`: 该命令将内存转储到文件中。'
- en: '**IDA**: While unable to debug kernel-mode code on its own, this can be used
    as a UI for WinDbg. In this way, it can allow you to store all markup from the
    static analysis and debug code in the same place.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDA**: 虽然不能单独调试内核模式代码，但它可以作为 WinDbg 的 UI 使用。通过这种方式，它可以让你将静态分析的所有标记和调试代码存储在同一地方。'
- en: '**radare2**: Same as IDA, this tool can be used on top of WinDbg with a dedicated
    plugin.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**radare2**: 与 IDA 相同，这个工具可以在 WinDbg 上使用，且有专门的插件支持。'
- en: '**SoftICE (obsolete)**: This was once one of the most popular tools for performing
    low-level dynamic analysis on Windows. At the time of writing, the tool is obsolete
    and doesn''t support new systems.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SoftICE (已废弃)**: 这曾是最流行的 Windows 低级动态分析工具之一。本文写作时，该工具已经废弃，不支持新系统。'
- en: Apart from this, there are several other kernel-mode debuggers, such as **Syser**,
    **Rasta Ring 0 Debugger** (**RR0D**), **HyperDbg**, and **BugChecker**, that don't
    appear to be maintained anymore.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些其他内核模式调试器，如 **Syser**、**Rasta Ring 0 Debugger** (**RR0D**)、**HyperDbg**
    和 **BugChecker**，这些工具似乎不再维护。
- en: Monitors
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监视器
- en: 'These tools are supposed to give us insight into various objects and events
    associated with kernel mode:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以帮助我们洞察与内核模式相关的各种对象和事件：
- en: '**DriverView**: This is a tool developed by NirSoft; it allows you to quickly
    get a list of loaded drivers and their location in memory.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DriverView**: 这是 NirSoft 开发的一个工具；它可以让你快速获取已加载驱动程序及其在内存中的位置。'
- en: '**DebugView**: This is a Sysinternals tool that allows you to monitor the debugging
    output from both user and kernel mode.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DebugView**: 这是一个 Sysinternals 工具，允许你监视来自用户模式和内核模式的调试输出。'
- en: '**WinObj**: This is another useful tool from Sysinternals that can present
    a list of various system objects relevant to kernel-mode debugging, such as devices
    and drivers.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WinObj**: 这是 Sysinternals 提供的另一个有用工具，可以列出与内核模式调试相关的各种系统对象，例如设备和驱动程序。'
- en: Using them may give you a quick insight into the current global state of the
    system.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们可能让你快速了解当前系统的全局状态。
- en: Rootkit detectors
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rootkit 检测器
- en: 'This group of tools checks for the presence of techniques commonly used by
    rootkits in the system and provides detailed information. They are very useful
    for behavioral analysis to confirm that the sample has been loaded properly. Additionally,
    they can be used to determine the functionality of the sample relatively quickly.
    Some of the most popular tools are as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这组工具检查系统中是否存在 rootkit 常用的技术，并提供详细信息。它们在行为分析中非常有用，可以确认样本是否已正确加载。此外，它们还可以用来相对快速地确定样本的功能。一些最受欢迎的工具如下：
- en: '**GMER**: This powerful tool supports multiple rootkit patterns and provides
    relatively detailed technical information. It can search for various hidden artifacts,
    such as processes, services, files, registry keys, and more. Additionally, it
    features the rootkit removal tool.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GMER**：这个强大的工具支持多种 rootkit 模式，并提供相对详细的技术信息。它可以搜索各种隐藏的伪装物，如进程、服务、文件、注册表项等。此外，它还具有
    rootkit 清除工具。'
- en: '**RootkitRevealer**: This is another advanced rootkit detection tool, this
    time from Sysinternals. Unlike GMER, its output is less technical, and it hasn''t
    been updated for a while.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RootkitRevealer**：这是另一个先进的 rootkit 检测工具，来自 Sysinternals。与 GMER 不同，它的输出不太技术化，并且已经有一段时间没有更新了。'
- en: Other rootkit detection tools (now discontinued) include **Rootkit Unhooker**,
    **DarkSpy**, and **IceSword**.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 rootkit 检测工具（现已停用）包括 **Rootkit Unhooker**、**DarkSpy** 和 **IceSword**。
- en: Apart from these, multiple rootkit removal tools are being developed by antivirus
    vendors; however, they generally don't provide enough information to technically
    analyze the threat.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，许多杀毒厂商还在开发多种 rootkit 清除工具；然而，它们通常没有提供足够的技术信息来分析威胁。
- en: Setting up a testing environment
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: 'There are several options available for performing kernel-mode debugging:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可用的选项来执行内核模式调试：
- en: '**The debugger client is running on the target machine**: An example of such
    a setup is WinDbg or the KD debugger, utilizing local kernel debugging or working
    together with the **LiveKd** tool. This approach doesn''t require an engineer
    to set up a remote connection, but not all the commands will be available in this
    case.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器客户端在目标机器上运行**：这种设置的一个例子是 WinDbg 或 KD 调试器，利用本地内核调试或与**LiveKd**工具协作。这种方法不需要工程师设置远程连接，但在这种情况下，并非所有命令都可用。'
- en: '**The debugger client is running on the host machine**: Here, the virtual or
    another physical machine is used to execute a sample, and all the debugging tools
    with the result of your work in the form of markup are stored outside of it. This
    approach may take slightly more time to set up, but it is generally recommended
    as it will save lots of time and effort later.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器客户端在主机机器上运行**：在这种情况下，虚拟机或其他物理机用于执行样本，所有调试工具以及以标记形式保存的工作结果都存储在外部。此方法可能需要稍多的设置时间，但通常推荐使用，因为它会在后期节省大量时间和精力。'
- en: '**The debugger client is running on the remote machine**: This setup is not
    commonly used; the idea here is that the host machine is running a debugging server
    that can interact with the target machine, and the engineer connects to this server
    remotely from a third machine. This technique is called remote debugging by Microsoft.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器客户端在远程机器上运行**：这种设置并不常见；这里的想法是，主机机器运行一个调试服务器，可以与目标机器进行交互，工程师从第三台机器远程连接到该服务器。这种技术被微软称为远程调试。'
- en: 'The exact way to set up a connection between host and target machines may vary,
    depending on the engineer''s preferences. Generally, this is done either through
    a network or through cables. For VMs, it is commonly done by mapping a serial
    port to the pipe; for example, if the **COM1** port is being used, you would follow
    these steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 设置主机和目标机器之间的连接的具体方法可能会有所不同，取决于工程师的偏好。通常，通过网络或电缆进行连接。对于虚拟机，通常通过将串口映射到管道来完成；例如，如果使用的是
    **COM1** 端口，你可以按照以下步骤进行：
- en: In VMWare, go to `\\.\pipe\<any_pipe_name>`. In the remaining options, choose
    **This end is the server** and **The other end is an application**, and then tick
    the **Yield CPU on poll** checkbox.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VMWare 中，转到 `\\.\pipe\<any_pipe_name>`。在其余选项中，选择 **该端是服务器** 和 **另一端是应用程序**，然后勾选
    **在轮询时让 CPU 休眠** 复选框。
- en: 'In VirtualBox, open the VM''s settings and go to the `\\.\pipe\<any_pipe_name>`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VirtualBox 中，打开虚拟机的设置并转到 `\\.\pipe\<any_pipe_name>`：
- en: '![Figure 7.22 – VirtualBox setup for kernel-mode debugging over the COM port'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.22 – 通过 COM 端口进行内核模式调试的 VirtualBox 设置'
- en: '](img/Figure_7.22_B18500.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B18500.jpg)'
- en: Figure 7.22 – VirtualBox setup for kernel-mode debugging over the COM port
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 使用VirtualBox进行内核模式调试通过COM端口
- en: Remote debugging via a network is also possible, but in this case, the guest
    and the host machines should share a network connection, which may not always
    be desirable.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过网络进行远程调试，但在这种情况下，来宾机和主机应该共享网络连接，这可能并不总是可取的。
- en: 'Apart from this, to be able to perform kernel-mode debugging, it should also
    be explicitly allowed by the target system. Perform the following steps to do
    so:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，要能够进行内核模式调试，目标系统还需要显式允许。执行以下步骤以实现此功能：
- en: 'On a modern Windows OS, run a standard `bcdedit` tool as an administrator and
    type the following command:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现代Windows操作系统上，以管理员身份运行标准的`bcdedit`工具并输入以下命令：
- en: '[PRE11]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If local kernel debugging is being used, execute the following command:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用本地内核调试，请执行以下命令：
- en: '[PRE12]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, if a serial port is being used, execute the following command
    instead (for COM1):'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，如果使用的是串口，请执行以下命令（适用于COM1）：
- en: '[PRE13]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to keep the original boot settings as well, you can create a separate
    entry, as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还想保留原始启动设置，可以创建一个单独的条目，设置如下：
- en: '[PRE14]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, you can take the generated `<guid>` value and use it to apply the required
    settings to the new entry:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以获取生成的`<guid>`值，并使用它来将所需的设置应用到新条目中：
- en: '[PRE15]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On an older OS, such as Windows XP, it is possible to enable kernel-mode debugging
    by duplicating the default boot entry in the `boot.ini` file with a new display
    name and adding the `/debug` argument. It can also be combined with setting up
    a debug port by adding the `/debugport=com1 /baudrate=115200` argument. The resulting
    entry will be as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的操作系统（如Windows XP）上，可以通过在`boot.ini`文件中复制默认的启动条目，并使用新的显示名称，添加`/debug`参数来启用内核模式调试。也可以结合设置调试端口，添加`/debugport=com1
    /baudrate=115200`参数。最终的条目将如下所示：
- en: '[PRE16]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure that the system location specified matches the one used in the original
    entry.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 确保指定的系统位置与原始条目中使用的匹配。
- en: After this, it is necessary to restart the machine and choose the newly added
    option during the bootup process. This step can also be done later, after disabling
    the security checks.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，需要重启计算机，并在启动过程中选择新添加的选项。此步骤也可以在稍后进行，方法是禁用安全检查后进行。
- en: If it is necessary to set up network debugging or use Hyper-V machines, always
    follow the most recent official Microsoft documentation.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要设置网络调试或使用Hyper-V机器，请始终遵循最新的官方Microsoft文档。
- en: Setting up the debugger
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置调试器
- en: 'Now, we can run the debugger and check that everything works as expected. If
    local debugging is being used, it can be done by executing WinDbg as an administrator
    using the following command line:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行调试器并检查一切是否按预期工作。如果使用的是本地调试，可以通过以管理员身份运行WinDbg并使用以下命令行来完成：
- en: '[PRE17]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For debugging over a serial port, it is possible to specify the port and the
    baud rate using the `_NT_DEBUG_PORT` and `_NT_DEBUG_BAUD_RATE` environment variables
    or using the right command-line arguments. For the COM port, this will look as
    follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过串口调试，可以使用`_NT_DEBUG_PORT`和`_NT_DEBUG_BAUD_RATE`环境变量，或使用正确的命令行参数来指定端口和波特率。对于COM端口，设置如下：
- en: '[PRE18]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is also possible to do this from the GUI using **File** | **Kernel Debug...**:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过图形界面进行此操作，使用**文件**| **内核调试...**：
- en: '![Figure 7.23 – Kernel-mode debugging with VirtualBox and WinDbg over the COM
    port'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.23 – 使用VirtualBox和WinDbg通过COM端口进行内核模式调试'
- en: '](img/Figure_7.23_B18500.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.23_B18500.jpg)'
- en: Figure 7.23 – Kernel-mode debugging with VirtualBox and WinDbg over the COM
    port
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 使用VirtualBox和WinDbg通过COM端口进行内核模式调试
- en: Don't forget to restart the guest machine afterward.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了之后重启来宾机。
- en: Another option here is to use a separate **VirtualKD** project, which is aimed
    at improving kernel debugging performance if VMWare or VirtualBox VMs are being
    used. Follow the official installation documentation to make sure it is working
    as expected.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用一个独立的**VirtualKD**项目，它旨在提高内核调试的性能，特别是在使用VMWare或VirtualBox虚拟机时。请遵循官方安装文档，确保它按预期工作。
- en: 'If you are using a combination of IDA and WinDbg, then it can be set up in
    the following way:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是IDA和WinDbg的组合，可以按以下方式进行设置：
- en: It is better to make sure that the correct path to WinDbg is specified in the
    `PATH` environment variable or the `%IDA%\cfg\ida.cfg` file (the `DBGTOOLS` variable).
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好确保在`PATH`环境变量或`%IDA%\cfg\ida.cfg`文件中指定了正确的WinDbg路径（即`DBGTOOLS`变量）。
- en: For kernel-mode debugging, it is often recommended to use the 32-bit version
    of WinDbg; double-check which version is being used in IDA's **Output** window.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于内核模式调试，通常建议使用 WinDbg 的 32 位版本；请再次确认在 IDA 的 **输出** 窗口中使用的是哪个版本。
- en: Open the IDA instance, don't open any files, but select the **Go** quick start
    option.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDA 实例，不打开任何文件，但选择 **开始** 快速启动选项。
- en: 'Go to **Debugger** | **Attach** | **Windbg debugger** and specify the following
    connection string, with the pipe name matching the one used in the VM:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **调试器** | **附加** | **Windbg 调试器**，并指定以下连接字符串，管道名称与虚拟机中使用的名称匹配：
- en: '[PRE19]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, in the same dialog window, go to **Debug options** | **Set specific options**
    and select the **Kernel mode debugging with reconnect and initial break** option
    (reconnect is optional, but it should match the value specified in the connection
    string).
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在同一对话框中，转到 **调试选项** | **设置特定选项**，并选择 **带有重连和初始中断的内核模式调试** 选项（重连是可选的，但应与连接字符串中指定的值匹配）。
- en: 'Once confirmed, the following dialog window will appear:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认，以下对话框将会出现：
- en: '![Figure 7.24 – The IDA attaching to the Windows kernel on a target machine'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.24 – IDA 附加到目标机器上的 Windows 内核'
- en: '](img/Figure_7.24_B18500.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.24_B18500.jpg)'
- en: Figure 7.24 – The IDA attaching to the Windows kernel on a target machine
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 – IDA 附加到目标机器上的 Windows 内核
- en: Press **OK**. The debugger will break in the kernel and the WINDBG command line
    will become available at the bottom of the window.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **确定**。调试器将中断到内核，WINDBG 命令行将在窗口底部显示。
- en: Add the kernel mode-related type libraries (usually, they have `ddk` or `wdk`
    in their names) in **View** | **Open subviews** | **Type libraries** (you can
    also use the *Shift* + *F11* keyboard shortcut) to get access to multiple standard
    enums and structures.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **查看** | **打开子视图** | **类型库** 中添加与内核模式相关的类型库（通常，它们的名称中包含 `ddk` 或 `wdk`），这样可以访问多个标准枚举和结构体（你也可以使用
    *Shift* + *F11* 键盘快捷键）。
- en: 'Once we''ve made sure that the debugger executes successfully, it is necessary
    to set up symbol information so that standard Windows names can be used in various
    WinDbg commands. To do this, execute the following command in the WinDbg console:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认调试器成功执行，就需要设置符号信息，以便可以在各种 WinDbg 命令中使用标准的 Windows 名称。为此，请在 WinDbg 控制台中执行以下命令：
- en: '[PRE20]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the WinDbg GUI, this can be specified in the `-y` command-line argument.
    Additionally, it is possible to set it in the `_NT_SYMBOL_PATH` environment variable.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WinDbg 图形用户界面中，可以通过 `-y` 命令行参数来指定此项。此外，也可以在 `_NT_SYMBOL_PATH` 环境变量中进行设置。
- en: 'If the target and host machines don''t have internet access, then symbols can
    also be downloaded from another computer using a symbol manifest file created
    on the target machine. To do this, perform the following steps:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标机器和主机机器没有互联网访问权限，则也可以通过使用在目标机器上创建的符号清单文件，从另一台计算机下载符号。为此，请执行以下步骤：
- en: 'On the target machine, execute the following command:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标机器上执行以下命令：
- en: '[PRE21]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `ntkrnlpa.exe` can be used instead of `ntoskrnl.exe`. The last argument,
    `/s`, aims to avoid name resolution delays.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ntkrnlpa.exe` 可以替代 `ntoskrnl.exe`。最后一个参数 `/s` 旨在避免名称解析延迟。'
- en: Important Note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some WinDbg versions have a bug that results in the output file being empty.
    In this case, try a different version of it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 WinDbg 版本存在一个 bug，导致输出文件为空。在这种情况下，请尝试使用不同的版本。
- en: Move the created `manifest.txt` file to the machine that has internet access.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的 `manifest.txt` 文件移动到具有互联网访问权限的机器上。
- en: 'Run the following command:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE22]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once this is done, the downloaded symbols can be moved to the host machine
    and used for debugging purposes:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，可以将下载的符号文件移动到主机机器并用于调试目的：
- en: '[PRE23]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Keep in mind that if you update the target machine, the symbols may become invalid,
    and the process should be repeated.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果更新目标机器，符号可能会变得无效，应该重复该过程。
- en: Stopping at the driver's entry point
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止在驱动程序入口点
- en: 'Now, we should set up a debugger to intercept the moment the driver code gets
    executed so that we can get control over it immediately once it starts. In most
    cases, we don''t have symbol information for the analyzed sample, so we can''t
    use common WinDbg commands such as `bp <driver_name>!DriverEntry` to stop at the
    driver''s entry point. There are several other ways this can be done, as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该设置一个调试器来拦截驱动程序代码执行的瞬间，以便在其开始时立即控制它。在大多数情况下，我们没有分析样本的符号信息，因此无法使用常见的 WinDbg
    命令（如 `bp <driver_name>!DriverEntry`）来停止在驱动程序入口点。有几种其他方法可以做到这一点，如下所示：
- en: '**By setting unresolved breakpoints**: The following command can be used to
    set a breakpoint that will trigger once the module is loaded:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过设置未解析的断点**：可以使用以下命令设置一个断点，当模块加载时将触发：'
- en: '[PRE24]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even though the debugger doesn't stop exactly at the entry point here, it is
    possible to reach it manually after the first stop. To do this, take the base
    of the driver from the console output window, add the entry point's offset to
    it, and then set a breakpoint for the result address. Then, remove or disable
    the previous breakpoint and continue execution.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调试器在此处不会准确地停在入口点，但在第一次停下后，可以手动到达入口点。为此，从控制台输出窗口获取驱动程序的基址，添加入口点的偏移量，然后为结果地址设置一个断点。接着，移除或禁用先前的断点并继续执行。
- en: '**By breaking on the module load**: The following command allows you to intercept
    all new modules being loaded (a colon or space can be used):'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过模块加载中断**：以下命令允许你拦截所有新加载的模块（可以使用冒号或空格）：'
- en: '[PRE25]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is how it will look in the debugger:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试器中的显示方式如下：
- en: '![Figure 7.25 – Breaking when a particular module is loading'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.25 – 在特定模块加载时中断'
- en: '](img/Figure_7.25_B18500.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.25_B18500.jpg)'
- en: Figure 7.25 – Breaking when a particular module is loading
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 在特定模块加载时中断
- en: 'Once the debugger breaks, it is possible to set a breakpoint on the driver''s
    entry point and continue to make the execution stop there:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器中断，就可以在驱动程序的入口点设置断点，并继续使执行在那里停下来：
- en: '![Figure 7.26 – Setting a breakpoint on the driver''s entry point'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.26 – 在驱动程序入口点设置断点'
- en: '](img/Figure_7.26_B18500.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.26_B18500.jpg)'
- en: Figure 7.26 – Setting a breakpoint on the driver's entry point
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 – 在驱动程序入口点设置断点
- en: In IDA, when working with WinDbg, this can be achieved globally for all modules
    by going to **Debugger** | **Debugger options...** and enabling the **Suspend
    on library load/unload** option.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA中，与WinDbg一起工作时，可以通过转到**调试器** | **调试器选项...**并启用**在库加载/卸载时挂起**选项来全局实现此功能。
- en: '`IopLoadDriver` API transfers control to the driver. It will be slightly different
    for different versions of Windows, and it can be found using the following commands:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IopLoadDriver` API将控制权转移到驱动程序。不同版本的Windows中会有所不同，可以通过以下命令找到它：'
- en: '[PRE26]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the offset has been found (it will look like `nt!IopLoadDriver+N`), it
    is possible to set a breakpoint at this address and intercept all moments when
    the system transfers control to the newly loaded drivers. The good thing is that
    it can be reused multiple times until the system receives an update changing it:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到了偏移量（它将类似于`nt!IopLoadDriver+N`），就可以在该地址设置断点，并拦截系统将控制权转移到新加载的驱动程序的所有时刻。好处是它可以多次重用，直到系统接收到更新并改变它：
- en: '![Figure 7.27 – Intercepting the moment when the system transfers control to
    the loaded driver'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.27 – 拦截系统将控制权转移到加载的驱动程序的时刻'
- en: '](img/Figure_7.27_B18500.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.27_B18500.jpg)'
- en: Figure 7.27 – Intercepting the moment when the system transfers control to the
    loaded driver
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27 – 拦截系统将控制权转移到加载的驱动程序的时刻
- en: '`int 3` instruction representing a software breakpoint), recalculate the checksum
    field in its header (in the **Hiew** editor, this can be done by selecting this
    field in the header, pressing *F3* once to recalculate it, and then *F9* to save
    the changes), and load it. The debugger will break at this instruction, so it
    becomes possible to restore the modified value to the original one. Usually, the
    modified instruction won''t be executed after patching. This means that it is
    necessary to do a single step, make sure that it didn''t work, return the IP register
    to the changed instruction, and only then continue the analysis as usual.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int 3` 指令表示软件断点），重新计算其头部中的校验和字段（在**Hiew**编辑器中，可以通过选择头部中的此字段，按一次*F3*重新计算它，然后按*F9*保存更改），并加载它。调试器会在此指令处断开，因此可以恢复修改后的值为原始值。通常，修改后的指令在修补后不会执行。这意味着需要单步执行，确保它不起作用，返回IP寄存器到已更改的指令，然后再继续像往常一样进行分析。'
- en: This approach generally takes more time and will also break the driver's signature,
    but it can still be used if necessary.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常需要更多时间，而且也会破坏驱动程序的签名，但在必要时仍然可以使用。
- en: Loading the driver
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载驱动程序
- en: You aren't allowed to load unsigned drivers on modern 64-bit Windows systems
    or 32-bit systems with Secure Boot turned on. If the sample driver is not signed,
    it generally makes sense to figure out the way it is being executed in the wild
    (for example, by abusing other legitimate drivers) and reproduce it. In this way,
    we can guarantee that malware will behave exactly as expected.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 64 位 Windows 系统或开启了安全启动的 32 位系统不允许加载未签名的驱动程序。如果示例驱动程序未签名，通常需要弄清楚它是如何在实际环境中执行的（例如，通过滥用其他合法驱动程序），并复现它。通过这种方式，我们可以确保恶意软件的行为完全符合预期。
- en: Alternatively, it is possible to disable system security mechanisms. The most
    reliable way to temporarily disable it is by going to the advanced options for
    the booting process and selecting the `bcdedit.exe /set testsigning on` command
    is not recommended for analysis as it still requires the driver to be correctly
    signed by some certificate.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以禁用系统安全机制。暂时禁用它最可靠的方法是进入启动过程的高级选项，并选择 `bcdedit.exe /set testsigning on`
    命令，但不建议用于分析，因为它仍然要求驱动程序必须由某个证书正确签名。
- en: 'Now, it is time to load the analyzed driver. This can also be done straight
    from the Windows console using the standard `sc` functionality:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候加载分析过的驱动程序了。这也可以通过 Windows 控制台直接使用标准的 `sc` 功能来完成：
- en: '[PRE27]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An example of the preceding code block is as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面代码块的一个示例：
- en: '![Figure 7.28 – Loading a custom driver using the sc tool'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.28 – 使用 sc 工具加载自定义驱动程序'
- en: '](img/Figure_7.28_B18500.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.28_B18500.jpg)'
- en: Figure 7.28 – Loading a custom driver using the sc tool
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.28 – 使用 sc 工具加载自定义驱动程序
- en: Notice the spaces after the `type=` and `binpath=` arguments; they are important
    to make things work as expected.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `type=` 和 `binpath=` 参数后的空格；它们对于确保操作如预期般顺利至关重要。
- en: Restoring the debugging state
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复调试状态
- en: 'If IDA is being used, the problem that many engineers face when they load the
    driver again is that its base address changes in memory, so IDA can''t apply existing
    markup to it. One option here is to save the markup in IDC files and create a
    script that will remap all the addresses according to the new locations. However,
    there is a better way to organize this: it is recommended to make VM snapshots
    with debugging states and then reconnect to them with IDA when necessary. In this
    way, all the addresses are guaranteed to be the same, so the same IDC files can
    be applied without any changes being required.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 IDA，许多工程师在重新加载驱动程序时会遇到一个问题，即它的基地址在内存中发生了变化，导致 IDA 无法应用现有的标记。一个解决方案是将标记保存为
    IDC 文件，并创建一个脚本，根据新的位置重新映射所有地址。然而，还有一种更好的组织方式：建议通过调试状态创建 VM 快照，并在必要时通过 IDA 重新连接到这些快照。这样，所有地址都能保持一致，因此可以无更改地应用相同的
    IDC 文件。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we familiarized ourselves with Windows kernel mode and learned
    how requests are passed from user mode to kernel mode and back again. Then, we
    discussed rootkits, what parts of this process may be targeted by them, and for
    what reason. We also covered various techniques that are implemented in modern
    rootkits, including how existing security mechanisms can be bypassed by malware.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了 Windows 内核模式，学习了如何将请求从用户模式传递到内核模式，再从内核模式返回。然后，我们讨论了 Rootkit，它们可能针对这个过程的哪些部分，以及为什么这样做。我们还介绍了现代
    Rootkit 中实施的各种技术，包括恶意软件如何绕过现有的安全机制。
- en: Finally, we explored the tools that are available to perform static and dynamic
    analysis of kernel-mode threats, learned how to set up a testing environment,
    and summarized generic guidelines that can be followed when performing the analysis.
    By completing this chapter, you should have a strong understanding of how advanced
    kernel-mode threats work and how they can be analyzed using various tools and
    approaches.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了用于执行内核模式威胁静态和动态分析的工具，学习了如何设置测试环境，并总结了进行分析时可以遵循的通用指南。通过完成本章，您应该对高级内核模式威胁的工作原理以及如何使用各种工具和方法进行分析有了深入的了解。
- en: In [*Chapter 8*](B18500_08.xhtml#_idTextAnchor811), *Handling Exploits and Shellcode*,
    we will explore the various types of exploits and learn how legitimate software
    can be abused to let attackers perform malicious actions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18500_08.xhtml#_idTextAnchor811)，《处理漏洞与 Shellcode》中，我们将探讨各种类型的漏洞，并了解合法软件如何被滥用，以便攻击者执行恶意操作。
- en: Part 3 Examining Cross-Platform and Bytecode-Based Malware
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 检查跨平台和字节码恶意软件
- en: Being able to support multiple platforms using the same source code is always
    preferred by both attackers looking to infect as many users as possible and those
    specializing in targeted attacks. Consequently, multiple cross-platform malware
    families have appeared over the last several years, creating a need for engineers
    who know how to analyze them. By going through this section, you will learn about
    the specifics of cross-platform malware and will get a hands-on understanding
    of how to deal with them.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用相同的源代码支持多个平台始终是攻击者和专注于有针对性攻击的人士首选的方法。因此，在过去几年中出现了多个跨平台恶意软件家族，这导致了对能够分析它们的工程师的需求增加。通过学习本节，您将了解跨平台恶意软件的具体情况，并深入理解如何处理它们。
- en: 'In this section are the following chapters:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 8*](B18500_08.xhtml#_idTextAnchor811)*, Handling Exploits and Shellcode*'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18500_08.xhtml#_idTextAnchor811)*，处理利用和Shellcode*'
- en: '[*Chapter 9*](B18500_09.xhtml#_idTextAnchor946)*, Reversing Bytecode Languages
    – .NET, Java, and More*'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18500_09.xhtml#_idTextAnchor946)*，逆向字节码语言 – .NET、Java及其他*'
- en: '[*Chapter 10*](B18500_10.xhtml#_idTextAnchor1106)*, Scripts and Macros – Reversing,
    Deobfuscation, and Debugging*'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18500_10.xhtml#_idTextAnchor1106)*，脚本和宏 – 逆向、反混淆和调试*'
