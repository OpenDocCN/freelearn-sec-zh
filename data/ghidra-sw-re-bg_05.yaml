- en: '*Chapter 4*: Using Ghidra Extensions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使用Ghidra扩展'
- en: In this chapter, we will introduce Ghidra extensions or modules. By using Ghidra
    extensions, you will be able to incorporate new functionalities into Ghidra according
    to your needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Ghidra扩展或模块。通过使用Ghidra扩展，您将能够根据需要将新功能集成到Ghidra中。
- en: Extensions are optional components that can extend Ghidra's functionality with
    experimental or user-contributed Ghidra plugins or analyzers. By using extensions,
    you can, for instance, integrate other tools into Ghidra, such as Eclipse or IDA
    Pro.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是可选组件，可以通过实验性或用户贡献的Ghidra插件或分析器扩展Ghidra的功能。例如，使用扩展，您可以将其他工具集成到Ghidra中，如Eclipse或IDA
    Pro。
- en: We will continue using the Eclipse IDE for development but we will also need
    to install Gradle in order to compile Ghidra extensions. Both the Ghidra program
    and its extensions are prepared to be built using Gradle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用Eclipse IDE进行开发，但还需要安装Gradle以编译Ghidra扩展。Ghidra程序及其扩展都已准备好使用Gradle进行构建。
- en: By developing extensions or modules (formerly known as contribs), you will be
    able to make higher contributions to the Ghidra project (such as adding integration
    with other reverse engineering tools, supporting new file formats and processors,
    and so on) than developing mere plugins.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过开发扩展或模块（以前称为contribs），您将能够对Ghidra项目做出更高的贡献（例如，增加与其他逆向工程工具的集成、支持新的文件格式和处理器等），而不仅仅是开发简单的插件。
- en: Finally, you will learn how to use the Eclipse IDE for extension development
    and how to export a Ghidra extension from Eclipse after the development process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将学习如何使用Eclipse IDE进行扩展开发，以及如何在开发过程结束后从Eclipse导出Ghidra扩展。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Installing existing Ghidra extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装现有的Ghidra扩展
- en: Understanding the Ghidra extension skeleton
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Ghidra扩展骨架
- en: Developing a Ghidra extension
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Ghidra扩展
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follow:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: 'Java JDK 11 for x86_64 (available here: [https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot](https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot))'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对x86_64架构的Java JDK 11（可在此下载：[https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot](https://adoptopenjdk.net/releases.html?variant=openjdk11&jvmVariant=hotspot)）
- en: 'The Eclipse IDE for Java developers (any version supporting JDK 11 available
    here: [https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/))
    as it is the IDE that is officially integrated and supported by Ghidra'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java开发人员版的Eclipse IDE（任何支持JDK 11的版本，点击此链接下载：[https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/)），因为它是Ghidra官方集成并支持的IDE
- en: 'Gradle (the build automation tool required to compile Ghidra extensions): [https://gradle.org/install/](https://gradle.org/install/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle（编译Ghidra扩展所需的构建自动化工具）：[https://gradle.org/install/](https://gradle.org/install/)
- en: 'PyDev 6.3.1 (available here: [https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip](https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip))'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyDev 6.3.1（可在此下载：[https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip](https://netix.dl.sourceforge.net/project/pydev/pydev/PyDev%206.3.1/PyDev%206.3.1.zip)）
- en: 'Assuming you have installed Java JDK 11, PyDev 6.3.1, and the Eclipse IDE for
    Java developers as explained in the previous chapter, you will need some additional
    software requirements in order to compile the Ghidra extensions: [https://gradle.org/next-steps/?version=5.0&format=bin](https://gradle.org/next-steps/?version=5.0&format=bin).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经按照上一章的说明安装了Java JDK 11、PyDev 6.3.1和Eclipse Java开发人员版IDE，您还需要一些额外的软件要求才能编译Ghidra扩展：[https://gradle.org/next-steps/?version=5.0&format=bin](https://gradle.org/next-steps/?version=5.0&format=bin)。
- en: Installing Gradle is a straightforward process. It consists of decompressing
    the ZIP file in the `C:\Gradle\` folder (as specified by the official install
    documentation), then setting the `GRADLE_HOME` system environment variable to
    point to `C:\Gradle\gradle-5.0`, and finally, adding `%GRADLE_HOME%\bin` to the
    `PATH` system environment variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Gradle是一个简单的过程。它包括将ZIP文件解压到`C:\Gradle\`文件夹（按照官方安装文档的说明），然后设置`GRADLE_HOME`系统环境变量指向`C:\Gradle\gradle-5.0`，最后将`%GRADLE_HOME%\bin`添加到`PATH`系统环境变量中。
- en: The GitHub repository containing all the necessary code for this chapter can
    be found at [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter04](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter04).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包含本章节所有必要代码的 GitHub 仓库可以在 [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter04](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter04)
    中找到。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2VTiUfw](https://bit.ly/2VTiUfw)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看“代码实践”视频：[https://bit.ly/2VTiUfw](https://bit.ly/2VTiUfw)
- en: Installing Gradle documentation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Gradle 文档
- en: 'For more details on installing Gradle, you can refer to the official documentation
    available online at [https://docs.gradle.org/current/userguide/installation.html](https://docs.gradle.org/current/userguide/installation.html).
    You can also refer to the offline documentation contained in the Gradle ZIP file:
    `getting-started.html`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装 Gradle 的更多详细信息，请参阅官方在线文档：[https://docs.gradle.org/current/userguide/installation.html](https://docs.gradle.org/current/userguide/installation.html)。您也可以参考
    Gradle ZIP 文件中的离线文档：`getting-started.html`。
- en: Installing existing Ghidra extensions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装现有的 Ghidra 扩展
- en: A Ghidra extension is a Java code which extends Ghidra in some way and is distributed
    as an installable package. Ghidra extensions have access to the internals of Ghidra,
    allowing them to freely extend it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 扩展是扩展 Ghidra 功能的 Java 代码，作为可安装的包进行分发。Ghidra 扩展可以访问 Ghidra 的内部，允许它们自由扩展
    Ghidra。
- en: 'Some ready-to-use extensions are available in the appropriate `ghidra_9.1.2\
    Extensions\Ghidra` folder of your installation of Ghidra:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Ghidra 后，您可以在适当的 `ghidra_9.1.2\ Extensions\Ghidra` 文件夹中找到一些现成可用的扩展：
- en: '`ghidra_9.1.2_PUBLIC_20200212_GnuDisassembler.zip`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ghidra_9.1.2_PUBLIC_20200212_GnuDisassembler.zip`'
- en: '`ghidra_9.1.2_PUBLIC_20200212_sample.zip`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ghidra_9.1.2_PUBLIC_20200212_sample.zip`'
- en: '`ghidra_9.1.2_PUBLIC_20200212_SampleTablePlugin.zip`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ghidra_9.1.2_PUBLIC_20200212_SampleTablePlugin.zip`'
- en: '`ghidra_9.1.2_PUBLIC_20200212_SleighDevTools.zip`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ghidra_9.1.2_PUBLIC_20200212_SleighDevTools.zip`'
- en: 'Let''s take a look at the steps to install these already-available extensions.
    Please, open the `Chapter04` Ghidra project, `hello world.gpr`, and follow these
    steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看安装这些现成扩展的步骤。请打开 `Chapter04` Ghidra 项目，`hello world.gpr`，并按照以下步骤操作：
- en: These extensions can be easily installed from Ghidra by clicking on `Extensions\Ghidra`
    directory of your Ghidra distribution.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些扩展可以通过点击 Ghidra 中的 `Extensions\Ghidra` 目录轻松安装。
- en: After checking **SampleTablePlugin** and clicking **OK**, you will see the following
    screen, so you will know for sure that you checked the extension:![Figure 4.2
    – Extensions Changed! message after installing SampleTablePlugin
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在勾选 **SampleTablePlugin** 并点击 **确定** 后，您将看到以下屏幕，这样您就可以确认已勾选该扩展：![图 4.2 – 安装
    SampleTablePlugin 后出现的“扩展已更改！”消息
- en: '](img/B16207_04_002.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_002.jpg)'
- en: Figure 4.2 – Extensions Changed! message after installing SampleTablePlugin
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2 – 安装 SampleTablePlugin 后出现的“扩展已更改！”消息
- en: After clicking **OK** and manually restarting Ghidra, a prompt message asking
    to configure the plugin will appear when you open **CodeBrowser** via **Tools**
    | **Run Tool** | **CodeBrowser**:![Figure 4.3 – New Plugins Found! message after
    installing SampleTablePlugin and restarting Ghidra
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**并手动重启 Ghidra 后，当通过 **工具** | **运行工具** | **代码浏览器** 打开 **CodeBrowser**
    时，会弹出一个提示消息，询问是否配置插件：![图 4.3 – 安装 SampleTablePlugin 并重启 Ghidra 后出现的“发现新插件！”消息
- en: '](img/B16207_04_003.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_003.jpg)'
- en: Figure 4.3 – New Plugins Found! message after installing SampleTablePlugin and
    restarting Ghidra
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3 – 安装 SampleTablePlugin 并重启 Ghidra 后出现的“发现新插件！”消息
- en: By answering affirmatively, we can take the opportunity to configure which plugins
    we are interested in enabling:![Figure 4.4 – Sample table plugin configuration
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过肯定回答，我们可以趁机配置我们感兴趣的插件：![图 4.4 – 样本表插件配置
- en: '](img/B16207_04_004.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_004.jpg)'
- en: Figure 4.4 – Sample table plugin configuration
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4 – 样本表插件配置
- en: After this step, a new option named **Sample Table Provider** will appear in
    the **Window** menu:![Figure 4.5 – The Sample Table Provider window implemented
    by the plugin
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此步骤后，名为 **样本表提供者** 的新选项将出现在 **窗口** 菜单中：![图 4.5 – 插件实现的样本表提供者窗口
- en: '](img/B16207_04_005.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_005.jpg)'
- en: Figure 4.5 – The Sample Table Provider window implemented by the plugin
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.5 – 插件实现的样本表提供者窗口
- en: By clicking on it, you will see that the functionality of Ghidra has been extended
    with a docking window allowing you to calculate function metrics. In this case,
    I checked `__main` function on the disassembly window.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它，你将看到Ghidra的功能已经通过一个停靠窗口得到了扩展，允许你计算函数度量。在这种情况下，我在反汇编窗口中检查了`__main`函数。
- en: 'You can easily locate the `__main` function (notice it starts with two `_`
    characters) using the **Filter** option in the **Symbol Tree** pane:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用**过滤器**选项在**符号树**窗格中轻松定位`__main`函数（注意它以两个`_`字符开头）：
- en: '![Figure 4.6 – Using Symbol Tree to locate the __main function in disassembly'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 使用符号树在反汇编中定位`__main`函数'
- en: '](img/B16207_04_006.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_04_006.jpg)'
- en: Figure 4.6 – Using Symbol Tree to locate the __main function in disassembly
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 使用符号树在反汇编中定位`__main`函数
- en: 'The result of running the algorithms targeting `__main` looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行针对`__main`的算法结果如下所示：
- en: '![Figure 4.7 – Sample Table Provider executed over the __main function'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 在`__main`函数上执行的示例表格提供器'
- en: '](img/B16207_04_007.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_04_007.jpg)'
- en: Figure 4.7 – Sample Table Provider executed over the __main function
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 在__main函数上执行的示例表格提供器
- en: In the next section, we will analyze the source code of this Ghidra extension.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将分析这个Ghidra扩展的源代码。
- en: Analyzing the code of the Sample Table Provider plugin
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析示例表格提供器插件的代码
- en: 'Most Ghidra components are extensible but, when developing, you must first
    decide what kind of project you are dealing with: analyzer, plugin, loader, filesystem,
    or exporter.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Ghidra组件都是可扩展的，但在开发时，你必须首先决定你处理的项目类型：分析器、插件、加载器、文件系统或导出器。
- en: In this case, Sample Table Provider consists of a plugin Ghidra extension. A
    plugin extension is a program that extends from the `ghidra.app.plugin.ProgramPlugin`
    class, allowing it to handle the most common program events and also implement
    GUI components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，示例表格提供器由一个Ghidra插件扩展组成。插件扩展是一个从`ghidra.app.plugin.ProgramPlugin`类扩展的程序，使其能够处理最常见的程序事件，并实现GUI组件。
- en: Let's look over the code available in the `SampleTablePlugin\lib\SampleTablePlugin-src\ghidra\examples`
    directory of `ghidra_9.1.2_PUBLIC_20200212_SampleTablePlugin.zip`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看`ghidra_9.1.2_PUBLIC_20200212_SampleTablePlugin.zip`中的`SampleTablePlugin\lib\SampleTablePlugin-src\ghidra\examples`目录下可用的代码。
- en: 'The plugin part of Sample Table Provider is implemented by the `SampleTablePlugin.java`
    file, whose class extends from `ghidra.app.plugin.ProgramPlugin`, allowing you
    to update its internal `currentFunction` attribute when an event related to the
    current function happens, as mentioned in [*Chapter 3*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041),
    *Ghidra Debug Mode*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例表格提供器的插件部分由`SampleTablePlugin.java`文件实现，该类从`ghidra.app.plugin.ProgramPlugin`扩展，使你能够在与当前函数相关的事件发生时更新其内部`currentFunction`属性，正如在[*第3章*](B16207_03_Final_SK_ePub.xhtml#_idTextAnchor041)中提到的，*Ghidra调试模式*：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As `SampleTableModel.java` implements the table model by extending from `ThreadedTableModelStub`,
    `ThreadedTableModelStub` admits an abstract data type as a row, allowing you to
    define a custom class to store the rows. In this case, rows are objects whose
    class is `FunctionStatsRowObject`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SampleTableModel.java`通过继承`ThreadedTableModelStub`实现了表格模型，`ThreadedTableModelStub`允许作为一行的抽象数据类型，这样你就可以定义一个自定义类来存储这些行。在这种情况下，行是其类为`FunctionStatsRowObject`的对象：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `FunctionStatsRowObject.java` class is a Java class containing row fields:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionStatsRowObject.java`类是一个包含行字段的Java类：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `SampleTableProvider.java` class is responsible for painting the table
    on the screen, filling the content, and defining the behavior when interacting:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleTableProvider.java`类负责在屏幕上绘制表格、填充内容，并定义与之交互时的行为：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `FunctionAlgorithm.java` class defines the interface for those classes
    used to retrieve the data to fill the table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`FunctionAlgorithm.java`类定义了用于检索数据以填充表格的接口：'
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At last, there are some classes allowing you to calculate the values of the
    `Score` column in Sample Table Provider:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些类允许你计算示例表格提供器中`Score`列的值：
- en: '`BasicBlockCount``erFunctionAlgorithm.java`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasicBlockCount``erFunctionAlgorithm.java`'
- en: '`FunctionAlgorithm.java`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FunctionAlgorithm.java`'
- en: '`ReferenceFunctionAlgorithm.java`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceFunctionAlgorithm.java`'
- en: '`SizeFunctionAlgorithm.java`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SizeFunctionAlgorithm.java`'
- en: 'For instance, the `SizeFunctionAlgorithm` class retrieves the number of addresses
    contained in the current function to determine the size of the function. The retrieved
    data, as is evident, is obtained via Ghidra API calls:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`SizeFunctionAlgorithm`类检索当前函数中包含的地址数量，以确定函数的大小。显然，检索的数据是通过Ghidra API调用获得的：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We will delve much deeper into the peculiarities of every kind of extension
    in *Section 3*, *Extending Ghidra*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第3节*、*扩展Ghidra*中深入探讨各种扩展的特点。
- en: Ghidra extensions inheritance
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra扩展继承
- en: 'Remember that you can search for the classes you are extending from in the
    source code of Ghidra: [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/ProgramPlugin.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/ProgramPlugin.java).
    These classes are pretty well commented, so you can also check the auto-generated
    documentation from Ghidra via **Help** | **Ghidra API Help**.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以在Ghidra的源代码中搜索您正在扩展的类：[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/ProgramPlugin.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/ProgramPlugin.java)。这些类有详细的注释，您还可以通过**帮助**
    | **Ghidra API帮助**检查Ghidra自动生成的文档。
- en: In this section, you learned what a Ghidra extension is, how it works internally,
    and how it looks in Ghidra from the users' perspective. In the next section, we
    will cover the skeleton of an extension.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了什么是Ghidra扩展、它的内部工作原理以及从用户的角度看它在Ghidra中的表现。在下一节中，我们将介绍扩展的骨架。
- en: Understanding the Ghidra extension skeleton
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Ghidra扩展骨架
- en: In the `ghidra_9.1.2\Extensions\Ghidra` Ghidra extensions folder, there is also
    a `skeleton` folder, which includes five skeleton source code located in `ghidra_9.1.2\Extensions\Ghidra\Skeleton\src\main\java\skeleton`,
    which enables us to write any kind of Ghidra extension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ghidra_9.1.2\Extensions\Ghidra` Ghidra扩展文件夹中，还有一个`skeleton`文件夹，其中包含五个位于`ghidra_9.1.2\Extensions\Ghidra\Skeleton\src\main\java\skeleton`的骨架源代码，这使我们能够编写任何类型的Ghidra扩展。
- en: Next, we will discuss the different types of plugin extensions by overviewing
    its skeletons. Those skeletons are available from Eclipse and we will create an
    extension later using a skeleton in the *Developing a Ghidra extension* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过概述其骨架来讨论不同类型的插件扩展。这些骨架可以从Eclipse中获取，我们稍后将在*开发Ghidra扩展*部分使用骨架创建一个扩展。
- en: Analyzers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器
- en: Analyzers allow us to extend the Ghidra code analysis functionality. The skeleton
    to develop analyzers is available in the `SkeletonAnalyzer.java` file, which extends
    from `ghidra.app.services.AbstractAnalyzer`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器使我们能够扩展Ghidra的代码分析功能。用于开发分析器的骨架可在`SkeletonAnalyzer.java`文件中找到，该文件扩展自`ghidra.app.services.AbstractAnalyzer`。
- en: 'The analyzer skeleton consists of the following elements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器骨架包含以下元素：
- en: 'A constructor, which indicates the analyzer''s name, its description, and the
    analyzer''s type. In addition, you can call to `setSupportOneTimeAnalysis` before
    the call to `super` to indicate that the analyzer supports it:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，表示分析器的名称、描述和分析器的类型。此外，在调用`super`之前，可以调用`setSupportOneTimeAnalysis`，以指示分析器是否支持：
- en: '[PRE41]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The analyzer''s type can be one of the following: `BYTE_ANALYZER`, `DATA_ANALYZER`,
    `FUNCTION_ANALYZER`, `FUNCTION_MODIFIERS_ANALYZER`, `FUNCTION_SIGNATURES_ANALYZER`,
    `INSTRUCTION_ANALYZER`, or `ONE_SHOT_ANALYZER`.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分析器的类型可以是以下之一：`BYTE_ANALYZER`、`DATA_ANALYZER`、`FUNCTION_ANALYZER`、`FUNCTION_MODIFIERS_ANALYZER`、`FUNCTION_SIGNATURES_ANALYZER`、`INSTRUCTION_ANALYZER`或`ONE_SHOT_ANALYZER`。
- en: The `getDefaultEnablement` method returns a Boolean value indicating whether
    this analyzer will be enabled all the time.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefaultEnablement`方法返回一个布尔值，指示该分析器是否将始终启用。'
- en: The `canAnalyze` method returns true if the program can be analyzed. You can
    check here, for instance, if your analyzer supports the assembly language of the
    program.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canAnalyze`方法返回true表示程序可以被分析。您可以在这里检查，例如，您的分析器是否支持程序的汇编语言。'
- en: If you want to let the user set some options for your analyzer, then you can
    override the `registerOptions` method.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望让用户为分析器设置一些选项，则可以重写`registerOptions`方法。
- en: Finally, when things are added to the program, the method added will get called
    in order to perform the analysis.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当程序中添加了内容时，所添加的方法将被调用以执行分析。
- en: Analyzer tips
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分析器技巧
- en: Don't let `getDefaultEnablement` return true if your analyzer is not fast enough
    because it can slow down Ghidra.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的分析器速度不够快，请不要让`getDefaultEnablement`返回true，因为这可能会使Ghidra变慢。
- en: Analyzers can be useful, for instance, when analyzing a C++ program to obtain
    object-oriented programming information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器可以在分析C++程序以获取面向对象编程信息时非常有用。
- en: Filesystems
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: Filesystems allow us to extend Ghidra to support archive files. Examples of
    archive files are APK, ZIP, RAR, and so on. The skeleton to develop filesystems
    is available in the `SkeletonFileSystem.java` file, which extends from `GFileSystem`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统允许我们扩展Ghidra以支持归档文件。归档文件的示例包括APK、ZIP、RAR等。用于开发文件系统的框架可以在`SkeletonFileSystem.java`文件中找到，它继承自`GFileSystem`。
- en: 'The filesystem skeleton consists of the following elements:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统框架由以下元素组成：
- en: A constructor. It receives as a parameter the root of the filesystem as the
    **Filesystem Resource Locator** (**FSRL**) and the filesystem provider.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数。它接收文件系统的根目录作为**文件系统资源定位符**（**FSRL**）和文件系统提供者作为参数。
- en: 'A filesystem implementation is complex. It consists of the following methods:
    `mount`, `close`, `getName`, `getFSRL`, `isClosed`, `getFileCount`, `getRefManager`,
    `lookup`, `getInputStream`, `getListing`, `getInfo`, and `getInfoMap`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统的实现是复杂的。它包含以下方法：`mount`、`close`、`getName`、`getFSRL`、`isClosed`、`getFileCount`、`getRefManager`、`lookup`、`getInputStream`、`getListing`、`getInfo`和`getInfoMap`。
- en: Plugins
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件
- en: Plugins allow us to extend Ghidra in a lot of ways by accessing the GUI and
    the event notification systems. The skeleton to develop plugins is available in
    the `SkeletonPlugin.java` file, which extends from `ghidra.app.plugin.ProgramPlugin`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 插件使我们能够通过访问GUI和事件通知系统以多种方式扩展Ghidra。开发插件的框架可以在`SkeletonPlugin.java`文件中找到，它继承自`ghidra.app.plugin.ProgramPlugin`。
- en: 'The plugin skeleton consists of the following elements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 插件框架由以下元素组成：
- en: A constructor. It receives the parent tool as a parameter and allows us to customize
    or remove both the provider and the help of the plugin.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数。它接收父工具作为参数，并允许我们自定义或移除插件的提供者和帮助。
- en: An `init` method allowing us to acquire services if needed.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`init`方法，允许我们在需要时获取服务。
- en: It also includes an example of a provider extending from `ComponentProvider`,
    allowing us to customize the GUI and the actions.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还包括一个扩展自`ComponentProvider`的提供者示例，使我们能够自定义GUI和操作。
- en: Plugin tips
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 插件提示
- en: 'If you want to see the complete list of services, please search for `ghidra.app.services`
    in Ghidra''s Java documentation: `/api/ghidra/app/services/package-summary.html`.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想查看完整的服务列表，请在Ghidra的Java文档中搜索`ghidra.app.services`：`/api/ghidra/app/services/package-summary.html`。
- en: As you can imagine, plugin extensions are very versatile.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，插件扩展非常灵活多样。
- en: Exporters
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出器
- en: Exporters allow us to extend Ghidra by implementing the ability to export parts
    of a program available in Ghidra's program database. The skeleton to develop exporters
    is available in the `SkeletonExporter.java` file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器允许我们通过实现导出Ghidra程序数据库中部分程序的能力来扩展Ghidra。开发导出器的框架可以在`SkeletonExporter.java`文件中找到。
- en: 'The exporter skeleton consists of the following elements:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器框架由以下元素组成：
- en: A constructor. It allows us to set the name of the exporter and also associate
    a file extension to it.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数。它允许我们设置导出器的名称，并将文件扩展名与之关联。
- en: A `getOptions` method is also available to define custom options if required.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还提供一个`getOptions`方法，用于定义自定义选项（如果需要）。
- en: A `setOptions` method to assign custom options, if they exist, to the exporter.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`setOptions`方法，用于为导出器分配自定义选项（如果存在）。
- en: An `export` method where the export operation must be implemented, and returns
    a Boolean value indicating whether the operation was successful or not.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`export`方法，必须实现导出操作，并返回一个布尔值，表示操作是否成功。
- en: 'Some examples of preinstalled Ghidra exporters are the following: `AsciiExporter`,
    `BinaryExporter`, `GzfExporter`, `HtmlExporter`, `IntelHexExporter`, `ProjectArchiveExporter`,
    and `XmlExporter`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些预装的Ghidra导出器示例如下：`AsciiExporter`、`BinaryExporter`、`GzfExporter`、`HtmlExporter`、`IntelHexExporter`、`ProjectArchiveExporter`和`XmlExporter`。
- en: Loaders
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器
- en: Loaders allow us to extend Ghidra by adding support to new binary code formats.
    Examples of binary code formats are `SkeletonLoader.java` file, which extends
    from `AbstractLibrarySupportLoader`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器允许我们通过添加对新二进制代码格式的支持来扩展Ghidra。二进制代码格式的示例包括`SkeletonLoader.java`文件，它继承自`AbstractLibrarySupportLoader`。
- en: 'The loader skeleton consists of the following elements:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器框架由以下元素组成：
- en: A `getName` method, which must be overridden to return the loader's name.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`getName`方法，必须重写以返回加载器的名称。
- en: A `findSupportedLoadSpecs` method, which must return an `ArrayList` with the
    specifications of the file if it is able to load it. If it is not able to load
    it, then it must return an empty `ArrayList`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `findSupportedLoadSpecs` 方法，必须返回一个 `ArrayList`，如果能够加载文件，则包含文件的规范。如果无法加载，则返回一个空的
    `ArrayList`。
- en: A `load` method where the bulk of the implementation takes place. It loads the
    bytes from the provider into the program.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `load` 方法，主要实现部分。它将从提供者加载字节到程序中。
- en: If the loader has custom options, then you must define them in the `getDefaultOptions`
    method and also validate them in the `validateOptions` method.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加载器有自定义选项，则必须在 `getDefaultOptions` 方法中定义它们，并在 `validateOptions` 方法中进行验证。
- en: In this section, we went over the skeleton for every type of Ghidra extension.
    Go ahead and modify any skeleton in a way that may help you for development. In
    the next section, we will cover what Ghidra extension skeletons look like in Eclipse.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了每种类型的 Ghidra 扩展的框架。可以根据需要修改任何框架，以帮助开发。在接下来的章节中，我们将介绍 Ghidra 扩展框架在
    Eclipse 中的样子。
- en: Developing a Ghidra extension
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Ghidra 扩展
- en: 'In this section, we will cover how to create a Ghidra extension in Eclipse
    and then how to export it to Ghidra:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何在 Eclipse 中创建 Ghidra 扩展，然后如何将其导出到 Ghidra：
- en: First, to create a new Ghidra extension in Eclipse, click on **GhidraDev** |
    **New** | **Ghidra Module Project…**:![Figure 4.8 – Creating a new Ghidra module
    project
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，要在 Eclipse 中创建一个新的 Ghidra 扩展，点击 **GhidraDev** | **新建** | **Ghidra 模块项目...**:![图
    4.8 – 创建新的 Ghidra 模块项目
- en: '](img/B16207_04_008.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_008.jpg)'
- en: Figure 4.8 – Creating a new Ghidra module project
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.8 – 创建新的 Ghidra 模块项目
- en: Set a name for the Ghidra project as well as the project root directory. In
    this case, I'm setting `MyExtensions` as the project name and leaving the default
    values for the rest of the parameters:![Figure 4.9 – Setting the project name
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Ghidra 项目的名称以及项目根目录。在此案例中，我将项目名称设置为 `MyExtensions`，并将其余参数保持为默认值：![图 4.9 –
    设置项目名称
- en: '](img/B16207_04_009.jpg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_009.jpg)'
- en: Figure 4.9 – Setting the project name
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.9 – 设置项目名称
- en: As you know from the previous section, Ghidra has some module templates available.
    Choose those that are useful for your purpose. We are choosing all of them because
    we want to have all the Ghidra module skeletons. Click on **Next >** instead of
    **Finish** to take two additional and useful steps:![Figure 4.10 – Choosing the
    module templates needed for this Ghidra module project
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如前一节所述，Ghidra 提供了一些模块模板。选择那些对您有用的模板。我们选择了所有模板，因为我们希望拥有所有的 Ghidra 模块框架。点击 **下一步
    >**，而不是 **完成**，以进行两个额外且有用的步骤：![图 4.10 – 选择此 Ghidra 模块项目所需的模块模板
- en: '](img/B16207_04_010.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_010.jpg)'
- en: Figure 4.10 – Choosing the module templates needed for this Ghidra module project
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.10 – 选择此 Ghidra 模块项目所需的模块模板
- en: Associate a Ghidra installation with your module project. This is an important
    step because the Ghidra module will be generated for this version of Ghidra:![Figure
    4.11 – Associating a Ghidra installation with your module project
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Ghidra 安装与您的模块项目关联。这是一个重要步骤，因为 Ghidra 模块将为此版本的 Ghidra 生成：![图 4.11 – 将 Ghidra
    安装与您的模块项目关联
- en: '](img/B16207_04_011.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_011.jpg)'
- en: Figure 4.11 – Associating a Ghidra installation with your module project
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11 – 将 Ghidra 安装与您的模块项目关联
- en: You can also enable Python by clicking on **Enable Python** and selecting a
    Jython interpreter:![Figure 4.12 – Enabling Python support
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以通过点击 **启用 Python** 并选择 Jython 解释器来启用 Python：![图 4.12 – 启用 Python 支持
- en: '](img/B16207_04_012.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_012.jpg)'
- en: Figure 4.12 – Enabling Python support
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.12 – 启用 Python 支持
- en: 'You can configure the Ghidra installation and Python support at any time later
    by clicking on **GhidraDev** | **Link Ghidra…**:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过点击 **GhidraDev** | **链接 Ghidra...** 在以后任何时间配置 Ghidra 安装和 Python 支持：
- en: '![Figure 4.13 – Linking the Ghidra installation and enabling Python support
    if desired at any time'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.13 – 链接 Ghidra 安装并在任何时候启用 Python 支持（如果需要）'
- en: '](img/B16207_04_013.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_013.jpg)'
- en: Figure 4.13 – Linking the Ghidra installation and enabling Python support if
    desired at any time
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.13 – 链接 Ghidra 安装并在任何时候启用 Python 支持（如果需要）
- en: 'Develop your Ghidra extension using the Eclipse IDE:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Eclipse IDE 开发 Ghidra 扩展：
- en: '![Figure 4.14 – Developing Ghidra extensions using the Eclipse IDE'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 使用 Eclipse IDE 开发 Ghidra 扩展'
- en: '](img/B16207_04_014.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_04_014.jpg)'
- en: Figure 4.14 – Developing Ghidra extensions using the Eclipse IDE
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 使用 Eclipse IDE 开发 Ghidra 扩展
- en: 'After developing your Ghidra extension, you can export it to Ghidra using the
    following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发完 Ghidra 扩展后，你可以使用以下步骤将其导出到 Ghidra：
- en: Go to **File** | **Export…**, choose **Ghidra Module Extension**, and click
    on the **Next >** button:![Figure 4.15 – Exporting a Ghidra module extension from
    Eclipse
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **文件** | **导出…**，选择 **Ghidra 模块扩展**，然后点击 **下一步 >** 按钮：![图 4.15 – 从 Eclipse
    导出 Ghidra 模块扩展
- en: '](img/B16207_04_015.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_015.jpg)'
- en: Figure 4.15 – Exporting a Ghidra module extension from Eclipse
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.15 – 从 Eclipse 导出 Ghidra 模块扩展
- en: Choose the Ghidra module project you want to export:![Figure 4.16 – Selecting
    the Ghidra module project to export
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你要导出的 Ghidra 模块项目：![图 4.16 – 选择要导出的 Ghidra 模块项目
- en: '](img/B16207_04_016.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16207_04_016.jpg)'
- en: Figure 4.16 – Selecting the Ghidra module project to export
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.16 – 选择要导出的 Ghidra 模块项目
- en: 'Set the Gradle installation directory. If you followed the steps explained
    at the beginning of this chapter, it will be available in the `GRADLE_HOME` environment
    variable:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Gradle 安装目录。如果你按照本章开头的步骤进行操作，它将保存在 `GRADLE_HOME` 环境变量中：
- en: '![Figure 4.17 – Setting the Gradle installation directory'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – 设置 Gradle 安装目录'
- en: '](img/B16207_04_017.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_04_017.jpg)'
- en: Figure 4.17 – Setting the Gradle installation directory
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 设置 Gradle 安装目录
- en: 'After clicking on `dist` directory of your Ghidra module project has been generated:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `dist` 目录后，你的 Ghidra 模块项目已经生成：
- en: '![Figure 4.18 – Console output after exporting a Ghidra extension project'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – 导出 Ghidra 扩展项目后的控制台输出'
- en: '](img/B16207_04_018.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_04_018.jpg)'
- en: Figure 4.18 – Console output after exporting a Ghidra extension project
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 导出 Ghidra 扩展项目后的控制台输出
- en: As explained before, the generated extension will only be valid for the version
    of Ghidra chosen during the module project creation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，生成的扩展仅对在模块项目创建时选择的 Ghidra 版本有效。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to install existing Ghidra extensions and how
    to drop new ones into Ghidra in order to later install it. We analyzed the code
    of an example plugin Ghidra extension and also the development templates of every
    kind of Ghidra extension.Finally, we followed the steps for creating a new Ghidra
    module project in the Eclipse IDE and also covered how to export our new project
    to Ghidra.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了如何安装现有的 Ghidra 扩展，以及如何将新的扩展放入 Ghidra 中以便稍后安装。我们分析了一个示例插件 Ghidra 扩展的代码，还分析了各种类型
    Ghidra 扩展的开发模板。最后，我们按照步骤在 Eclipse IDE 中创建了一个新的 Ghidra 模块项目，并介绍了如何将新项目导出到 Ghidra。
- en: Now, you are able to identify useful extensions and install them. You are also
    able to understand how the code works and perform modifications and adaptions
    when needed. Of course, you can also now write your own Ghidra extensions, but
    you will improve these skills in *Section 3*, *Extending Ghidra*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经能够识别有用的扩展并安装它们。你也能够理解代码的工作原理，并在需要时进行修改和调整。当然，你现在也可以编写自己的 Ghidra 扩展，但你将在
    *第 3 章*，*扩展 Ghidra* 中进一步提高这些技能。
- en: In the next chapter of this book, we will cover how to reverse engineer malware
    using Ghidra, which is a great opportunity to demonstrate how to use this knowledge
    to solve real-world challenges.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章中，我们将介绍如何使用 Ghidra 进行恶意软件逆向工程，这是一个很好的机会，展示如何利用这些知识解决现实世界的挑战。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between Ghidra extensions and Ghidra scripts?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ghidra 扩展与 Ghidra 脚本有什么区别？
- en: If you are analyzing a program developed in C++ (which is an object-oriented
    programming language), what kind of Ghidra extension can help you to identify
    classes, methods, and so on?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在分析一个用 C++ 开发的程序（这是一种面向对象的编程语言），什么样的 Ghidra 扩展可以帮助你识别类、方法等？
- en: As you know, Ghidra extensions have access to Ghidra internals, which is really
    powerful. Is it always better to write a Ghidra extension than to write a Ghidra
    script?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所知，Ghidra 扩展可以访问 Ghidra 内部，这非常强大。那么，写一个 Ghidra 扩展总比写一个 Ghidra 脚本更好吗？
- en: Further reading
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to learn more about the topics covered in this chapter, go ahead
    and check out the following books and links:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多本章涉及的主题，可以查看以下书籍和链接：
- en: 'Ghidra advanced development course: [http://ghidra.re/courses/GhidraClass/AdvancedDevelopment/GhidraAdvancedDevelopment_withNotes.html#GhidraAdvancedDevelopment.html](http://ghidra.re/courses/GhidraClass/AdvancedDevelopment/GhidraAdvancedDevelopment_withNotes.html#GhidraAdvancedDevelopment.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ghidra高级开发课程：[http://ghidra.re/courses/GhidraClass/AdvancedDevelopment/GhidraAdvancedDevelopment_withNotes.html#GhidraAdvancedDevelopment.html](http://ghidra.re/courses/GhidraClass/AdvancedDevelopment/GhidraAdvancedDevelopment_withNotes.html#GhidraAdvancedDevelopment.html)
- en: '*Python development*, *Burkhard. A Meier*, *November 2016* [Video]: [https://www.packtpub.com/eu/application-development/python-projects-video](https://www.packtpub.com/eu/application-development/python-projects-video)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python开发*，*Burkhard. A Meier*，*2016年11月* [视频]：[https://www.packtpub.com/eu/application-development/python-projects-video](https://www.packtpub.com/eu/application-development/python-projects-video)'
- en: 'PyDev official manual: [http://www.pydev.org/manual.html](http://www.pydev.org/manual.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyDev官方手册：[http://www.pydev.org/manual.html](http://www.pydev.org/manual.html)
- en: '*Java Projects – Second Edition*, *Peter Verhas*, *August 2018*: [https://www.packtpub.com/eu/application-development/java-projects-second-edition](https://www.packtpub.com/eu/application-development/java-projects-second-edition)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java项目 - 第二版*，*Peter Verhas*，*2018年8月*：[https://www.packtpub.com/eu/application-development/java-projects-second-edition](https://www.packtpub.com/eu/application-development/java-projects-second-edition)'
