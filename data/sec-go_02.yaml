- en: The Go Programming Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 编程语言
- en: Before diving into the more complex examples of using Go for security, it is
    important to have a solid foundation. This chapter provides an overview of the
    Go programming language so that you have the knowledge necessary to follow the
    subsequent examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨使用 Go 进行安全编程的复杂示例之前，建立坚实的基础非常重要。本章提供了 Go 编程语言的概述，以便你具备跟随后续示例所需的知识。
- en: This chapter is not an exhaustive treatise of the Go programming language, but
    will give you a solid overview of the major features. The goal of this chapter
    is to provide you with the information you need to understand and follow the source
    code if you have never used Go before. If you are already familiar with Go, this
    chapter should be a quick and easy review of things you already know, but perhaps
    you will learn a new piece of information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是 Go 编程语言的详尽论文，而是为你提供主要特性的一次全面概述。本章的目标是为你提供理解和跟随源代码所需的信息，即使你之前从未使用过 Go。如果你已经熟悉
    Go，本章应该是对你已知内容的快速回顾，但或许你会学到一些新的信息。
- en: 'This chapter specifically covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章特别涉及以下主题：
- en: The Go language specification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言规范
- en: The Go playground
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go playground
- en: A tour of Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言游览
- en: Keywords
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字
- en: Notes about source code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于源代码的说明
- en: Comments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释
- en: Types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Control structures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Defer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: Packages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Classes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Goroutines
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutine
- en: Getting help and documentation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帮助和文档
- en: Go language specification
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 语言规范
- en: The entire Go language specification can be found online at [https://golang.org/ref/spec](https://golang.org/ref/spec).
    Much of the information in this chapter comes from the specification, as this
    is the one true documentation of the language. The rest of the information here
    is short examples, tips, best practices, and other things that I have learned
    during my time with Go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的完整规范可以在[https://golang.org/ref/spec](https://golang.org/ref/spec)在线查看。本章中的许多信息都来源于该规范，因为它是语言的唯一真实文档。这里的其余信息包括简短的示例、技巧、最佳实践和我在使用
    Go 语言期间学到的其他内容。
- en: The Go playground
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go playground
- en: 'The Go playground is a website where you can write and execute Go code without
    having to install anything. In the playground, [https://play.golang.org](https://play.golang.org),
    you can test pieces of code to explore the language and fiddle with things to
    understand how the language works. It also allows you to share your snippet by
    creating a unique URL that stores your snippet. Sharing code through the playground
    can be much more helpful than a plaintext snippet, since it allows the reader
    to actually execute the code and tinker with the source if they have any questions
    about how it works:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go playground 是一个网站，允许你在不安装任何软件的情况下编写和执行 Go 代码。在 playground，[https://play.golang.org](https://play.golang.org)，你可以测试代码片段，探索语言，调整内容以理解语言的工作原理。它还允许你通过创建一个唯一的
    URL 来共享你的代码片段，这个 URL 会存储你的代码。通过 playground 分享代码比分享纯文本代码片段更有帮助，因为它允许读者实际执行代码，并在对代码如何工作有疑问时进行修改：
- en: '![](img/d5514c8a-7253-4641-8b61-3e02ebcac15e.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5514c8a-7253-4641-8b61-3e02ebcac15e.png)'
- en: The preceding screenshot shows a simple program being run in the playground.
    There are buttons at the top to run, format, add import statements, and share
    the code with others.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了一个简单程序在 playground 中的运行。顶部有按钮可以运行、格式化、添加导入语句，并与他人共享代码。
- en: A tour of Go
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 语言游览
- en: Another resource provided by the Go team is *A Tour of Go*. This website, [https://tour.golang.org](https://tour.golang.org),
    is built on top of the playground mentioned in the previous section. The tour
    was my first introduction to the language, and when I completed it, I felt well-equipped
    to start tackling projects in Go. It walks you through the language step by step
    along with working code examples so that you can run and modify the code to get
    familiar with the language. It is a practical way to introduce a newcomer to Go.
    If you have never used Go at all, I encourage you to check it out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Go 团队提供的另一个资源是*Go 语言游览*。这个网站，[https://tour.golang.org](https://tour.golang.org)，是建立在前面提到的
    playground 之上的。这个游览是我第一次接触这门语言，当我完成它时，我感觉自己已经做好准备开始进行 Go 项目了。它一步步带你走过语言的各个方面，并提供了可以运行和修改的代码示例，以帮助你熟悉语言。这是一个向新手介绍
    Go 的实用方法。如果你从未使用过 Go，我鼓励你去查看一下。
- en: '![](img/155646d8-315b-4b13-aa31-c7be08feb713.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/155646d8-315b-4b13-aa31-c7be08feb713.png)'
- en: The preceding screenshot shows the first page of the tour. On the right-hand
    side, you will have a small embedded playground with the code sample relevant
    to the short lesson shown on the left-hand side. Each lesson comes with a short
    code example that you can run and tinker with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图展示了学习页面的第一页。在右侧，你将看到一个小型嵌入式游乐场，展示了与左侧简短课程相关的代码示例。每个课程都附带一个可以运行和修改的简短代码示例。
- en: Keywords
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字
- en: To emphasize how simple Go is, here is a breakdown of all its 25 keywords. You
    probably already know most of them if you are familiar with other programming
    languages. The keywords are grouped together to examine them according to their
    use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调 Go 的简洁性，以下是其 25 个关键字的详细介绍。如果你熟悉其他编程语言，你可能已经知道其中大部分。关键字根据它们的用途被分组在一起进行分析。
- en: '**Data types**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型**：'
- en: '| `var` | This defines a new variable |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 这定义了一个新的变量 |'
- en: '| `const` | This defines a constant value that does not change |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `const` | 这定义了一个不可变的常量值 |'
- en: '| `type` | This defines a new data type |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 这定义了一个新的数据类型 |'
- en: '| `struct` | This defines a new structured data type that contains multiple
    variables |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `struct` | 这定义了一个新的结构数据类型，包含多个变量 |'
- en: '| `map` | This defines a new map or hash variable |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 这定义了一个新的映射或哈希变量 |'
- en: '| `interface` | This defines a new interface |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | 这定义了一个新的接口 |'
- en: '**Functions**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**：'
- en: '| `func` | This defines a new function |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `func` | 这定义了一个新的函数 |'
- en: '| `return` | This exits a function, optionally returning values |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 这退出一个函数，并可选地返回值 |'
- en: '**Packages**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**包**：'
- en: '| `import`  | This imports an external package in the current package |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 这将外部包导入到当前包中 |'
- en: '| `package` | This specifies what package a file belongs to |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `package` | 这指定了一个文件属于哪个包 |'
- en: '**Program flow**:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序流程**：'
- en: '| `if` | This is used for branch execution based on a condition that is true
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `if` | 这用于基于条件为真的情况执行分支 |'
- en: '| `else` | This is used for a branch if a condition is not true |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `else` | 这用于在条件不为真时执行一个分支 |'
- en: '| `goto` | This is used to jump directly to a label; it is rarely used and
    not encouraged |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `goto` | 这用于直接跳转到标签；它很少使用，并且不推荐使用 |'
- en: '**Switch statements**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Switch 语句**：'
- en: '| `switch` | This is used to branch based off of a condition |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `switch` | 这用于根据条件进行分支 |'
- en: '| `case` | This defines the condition for the `switch` statement |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `case` | 这定义了 `switch` 语句的条件 |'
- en: '| `default` | This defines default execution when no case is matched |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 这定义了在没有匹配的 case 时的默认执行行为 |'
- en: '| `fallthrough` | This is used to continue executing the next case |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `fallthrough` | 这用于继续执行下一个 case |'
- en: '**Iteration**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代**：'
- en: '| `for` | The `for` loop can be used like in C, where you provide three expressions:
    the initializer, the condition, and the incrementer. In Go, there is no `while`
    loop and the `for` keyword takes on the role of both `for` and `while`. A `for`
    loop can be used just like a `while` loop if one expression, the condition, is
    passed. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `for` | `for` 循环可以像 C 语言中一样使用，提供三个表达式：初始化器、条件和增量。在 Go 中没有 `while` 循环，`for`
    关键字既可以作为 `for` 也可以作为 `while` 使用。如果只传入一个条件表达式，`for` 循环就像 `while` 循环一样使用。 |'
- en: '| `range` | The `range` keyword is used with a `for` loop to iterate over a
    map or slice. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `range` | `range` 关键字与 `for` 循环一起使用，用于迭代映射或切片 |'
- en: '| `continue` | The `continue` keyword will skip any execution left in the current
    loop and jump directly to the next iteration. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `continue` | `continue` 关键字会跳过当前循环中剩余的执行部分，直接跳转到下一次迭代 |'
- en: '| `break` | The `break` keyword will immediately exit the `for` loop completely,
    skipping any remaining iterations. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `break` | `break` 关键字将立即完全退出 `for` 循环，跳过任何剩余的迭代。 |'
- en: '**Concurrency**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发性**：'
- en: '| `go` | Goroutines are lightweight threads built in to the language. You simply
    put the `go` keyword in front of a call to a function and Go will execute that
    function call in a separate thread. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `go` | Goroutine 是内建的轻量级线程。你只需在调用函数前加上 `go` 关键字，Go 会在一个单独的线程中执行该函数调用。 |'
- en: '| `chan` | To communicate between threads, channels are used. Channels are
    used to send and receive specific data types. They are blocking by default. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `chan` | 为了在线程间进行通信，使用通道。通道用于发送和接收特定的数据类型。默认情况下，通道是阻塞的。 |'
- en: '| `select` | The `select` statements allow channels to be used in a nonblocking
    fashion. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `select` | `select` 语句允许以非阻塞方式使用通道 |'
- en: '**Convenience**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**便利性**：'
- en: '| `defer` | The `defer` keyword is a relatively unique keyword that I have
    not previously encountered in other languages. It allows you to specify a function
    to be called later when the surrounding function returns. It is useful when you
    want to ensure some type of cleanup action whenever the current function ends,
    but you are not sure when or where it might return. A common use case is to defer
    a file closure. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `defer` | `defer` 关键字是一个相对独特的关键字，在我之前接触的其他语言中并没有遇到过。它允许你指定一个函数，在外部函数返回时稍后调用。它在你想确保在当前函数结束时执行某种清理操作时非常有用，但你不确定何时或在哪里它可能会返回。一个常见的用例是延迟文件关闭。
    |'
- en: Notes about source code
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码说明
- en: Go source code files should have the `.go` extension. The source code of Go
    files is encoded in UTF-8 Unicode. This means that you can use any Unicode characters
    in your code, like hardcoding Japanese characters in a string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go 源代码文件应该使用 `.go` 扩展名。Go 文件的源代码使用 UTF-8 编码，这意味着你可以在代码中使用任何 Unicode 字符，例如将日文字符硬编码到字符串中。
- en: Semicolons are optional at the end of a line and typically omitted. Semicolons
    are only required when separating multiple statements or expressions on a single
    line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分号在行尾是可选的，通常会省略。分号仅在同一行上分隔多个语句或表达式时才需要。
- en: Go does have a code formatting standard which can easily be adhered to by running
    `go fmt` on source code files. The code formatting should be followed, but it
    is not strictly enforced by the compiler the way Python requires exact formatting
    to execute properly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Go 确实有一个代码格式化标准，可以通过运行 `go fmt` 来轻松遵循源代码文件的格式。代码格式化应该遵循，但与 Python 需要精确格式化才能正常执行不同，Go
    的编译器不会严格强制执行这一点。
- en: Comments
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments follow a C++ style allowing the double slash and the slash-asterisk
    wrapped style:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注释遵循 C++ 风格，支持双斜杠和斜杠-星号包裹的风格：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Types
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: The built-in data types are named intuitively enough. Go comes with a set of
    integer and unsigned integer types with varying bit lengths. There are also floating
    point numbers, Booleans, and strings, which should come as no surprise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 内置数据类型的命名足够直观。Go 提供了一组不同位长的整数和无符号整数类型。还有浮点数、布尔值和字符串，这些都不足为奇。
- en: There are a few types like runes that are not common in other languages. This
    section covers all of the different types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些类型，例如 rune，在其他语言中不常见。本节将介绍所有不同的类型。
- en: Boolean
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean type represents a true or false value. Some languages don''t provide
    a `bool` type, and you have to use an integer or define your own enumeration,
    but Go conveniently comes with a predeclared `bool` type. The `true` and `false`
    constants are also predefined and used in all lowercase. Here is an example of
    creating a Boolean:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型表示一个真假值。有些语言没有 `bool` 类型，你必须使用整数或定义自己的枚举类型，但 Go 提供了一个预定义的 `bool` 类型。`true`
    和 `false` 常量也是预定义的，并且总是以小写形式使用。以下是创建布尔值的示例：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `bool` type is not unique to Go by any means, but one interesting piece
    of trivia about the Boolean type is that it's the only type named after a person.
    George Boole lived from 1815 to 1864 and wrote *The Laws of Thought*, where he
    described Boolean algebra, which is what all digital logic is based upon. The
    `bool` type is very simple in Go, but the history behind the name is very rich.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 类型并非 Go 独有，但关于布尔类型的一个有趣小知识是，它是唯一一个以人名命名的类型。乔治·布尔（George Boole）生于 1815
    年，卒于 1864 年，他写了《思维法则》（The Laws of Thought），在其中描述了布尔代数，这是所有数字逻辑的基础。Go 中的 `bool`
    类型非常简单，但它背后的历史却极其丰富。'
- en: Numeric
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: The primary numeric data types are integers and floating point numbers. Go also
    offers a complex number type, a byte type, and a rune. Here are the numeric data
    types available in Go.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的数值数据类型是整数和浮点数。Go 还提供了一个复数类型、一个字节类型和一个 rune 类型。以下是 Go 中可用的数值数据类型。
- en: Generic numbers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型数字
- en: These generic types can be used when you don't particularly care about whether
    a number is 32- or 64-bits. The largest available size will automatically be used,
    but will be compatible with 32- and 64-bit processors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不特别关心数字是 32 位还是 64 位时，可以使用这些泛型类型。系统会自动使用最大可用的大小，但它兼容 32 位和 64 位处理器。
- en: '`uint`: This is an unsigned integer of either 32 or 64 bits'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint`：这是一个无符号整数，大小为 32 或 64 位'
- en: '`int`: This is a signed integer with the same size as `uint`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这是一个有符号整数，大小与 `uint` 相同'
- en: '`uintptr`: This is an unsigned integer to store a pointer value'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uintptr`：这是一个无符号整数，用于存储指针值'
- en: Specific numbers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定数字
- en: These numeric types specify the bit length and whether it has a sign bit to
    determine positive or negative values. The bit length will determine the maximum
    range. Signed integers have the range reduced by one bit because the last bit
    is reserved for the sign.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字类型指定了位长度，并且是否包含符号位来确定正负值。位长度将决定最大范围。带符号整数的范围会因为最后一位被保留为符号位而减少一位。
- en: Unsigned integers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无符号整数
- en: 'Using `uint` without a number generally chooses the largest size for your system,
    typically 64 bits. You can also specify one of the four specific `uint` sizes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带数字的 `uint` 通常会选择系统支持的最大大小，通常为 64 位。你也可以指定四种特定的 `uint` 大小：
- en: '`uint8`: Unsigned 8-bit integer (0 to 255)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint8`：无符号 8 位整数（0 到 255）'
- en: '`uint16`: Unsigned 16-bit integer (0 to 65535)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint16`：无符号 16 位整数（0 到 65535）'
- en: '`uint32` : Unsigned 32-bit integer (0 to 4294967295)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32`：无符号 32 位整数（0 到 4294967295）'
- en: '`uint64`: Unsigned 64-bit integer (0 to 18446744073709551615)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint64`：无符号 64 位整数（0 到 18446744073709551615）'
- en: Signed integers
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带符号整数
- en: 'Like unsigned integers, you can use `int` by itself to choose the best default
    size, or specify one of these four specific `int` sizes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 像无符号整数一样，你可以单独使用 `int` 来选择最佳的默认大小，或者指定这四种特定的 `int` 大小：
- en: '`int8`: 8-bit integer (-128 to 127)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8`：8 位整数（-128 到 127）'
- en: '`int16`: 16-bit integer (-32768 to 32767)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int16`：16 位整数（-32768 到 32767）'
- en: '`int32`: 32-bit integer (-2147483648 to 2147483647)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32`：32 位整数（-2147483648 到 2147483647）'
- en: '`int64`: 64-bit integer (-9223372036854775808 to 9223372036854775807)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64`：64 位整数（-9223372036854775808 到 9223372036854775807）'
- en: Floating point numbers
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'The floating point type does not have a generic type, and must be one of these
    two options:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型没有通用类型，必须是以下两种选项之一：
- en: '`float32`: IEEE-754 32-bit floating-point number'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float32`：IEEE-754 32 位浮点数'
- en: '`float64`: IEEE-754 64-bit floating-point number'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float64`：IEEE-754 64 位浮点数'
- en: Other numeric types
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数字类型
- en: 'Go also provides a complex number for advanced mathematical applications, and
    a few aliases for conveniences:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还提供了一个复数类型，用于高级数学应用，并提供了一些别名以方便使用：
- en: '`complex64`: Complex number with `float32` real and imaginary parts'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex64`：复数，具有 `float32` 类型的实部和虚部'
- en: '`complex128`: Complex number with `float64` real and imaginary parts'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex128`：复数，具有 `float64` 类型的实部和虚部'
- en: '`byte`: Alias for `uint8`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：`uint8` 的别名'
- en: '`rune`: Alias for `int32`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rune`：`int32` 的别名'
- en: You can define numbers in the decimal, octal, or hexadecimal format. Decimal
    or base-ten numbers need no prefix. Octal or base-eight numbers should be prefixed
    with a zero. Hexadecimal or base-sixteen numbers should be prefixed with a zero
    and an x.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用十进制、八进制或十六进制格式定义数字。十进制或基数十的数字不需要前缀。八进制或基数八的数字应该以零作为前缀。十六进制或基数十六的数字应该以零和
    x 为前缀。
- en: You can read more about the octal numeral system at [https://en.wikipedia.org/wiki/Octal](https://en.wikipedia.org/wiki/Octal),
    decimal at [https://en.wikipedia.org/wiki/Decimal](https://en.wikipedia.org/wiki/Decimal),
    and hexadecimal at [https://en.wikipedia.org/wiki/Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://en.wikipedia.org/wiki/Octal](https://en.wikipedia.org/wiki/Octal)
    阅读更多关于八进制的知识，在 [https://en.wikipedia.org/wiki/Decimal](https://en.wikipedia.org/wiki/Decimal)
    阅读更多关于十进制的知识，在 [https://en.wikipedia.org/wiki/Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal)
    阅读更多关于十六进制的知识。
- en: 'Note that numbers are stored as integers, and there are no differences between
    them except for how they are formatted in the source code for the human. Octal
    and hexadecimal can be useful when working with binary data. Here is a short example
    of how to define integers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数字是作为整数存储的，除了在源代码中如何格式化以供人类使用外，它们之间没有区别。八进制和十六进制在处理二进制数据时非常有用。以下是定义整数的简短示例：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: String
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Go comes with a `string` type as well as a `strings` package with a suite of
    useful functions such as `Contains()`, `Join()`, `Replace()`, `Split()`, `Trim()`,
    and `ToUpper()`. There is additionally a `strconv` package dedicated to converting
    various data types to and from strings. You can read more about the `strings`
    package at [https://golang.org/pkg/strings/](https://golang.org/pkg/strings/),
    and the `strconv` package at [https://golang.org/pkg/strconv/](https://golang.org/pkg/strconv/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 `string` 类型，以及一个包含一系列有用函数的 `strings` 包，如 `Contains()`、`Join()`、`Replace()`、`Split()`、`Trim()`
    和 `ToUpper()`。此外，还有一个专门用于将不同数据类型转换为字符串的 `strconv` 包。你可以在 [https://golang.org/pkg/strings/](https://golang.org/pkg/strings/)
    阅读更多关于 `strings` 包的信息，在 [https://golang.org/pkg/strconv/](https://golang.org/pkg/strconv/)
    阅读更多关于 `strconv` 包的信息。
- en: 'Double quotes are used for strings. Single quotes are used only for an individual
    character or runes, not strings. Strings can be defined using the long form or
    short form with the declare-and-assign operator. You can also use the `` ` `` (backticks) symbol
    to encapsulate strings that span multiple lines. Here is a short example of string
    usage:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号用于字符串。单引号仅用于表示单个字符或符文，而不是字符串。字符串可以使用长形式或短形式的声明并赋值操作符来定义。你还可以使用`` ` ``（反引号）符号来封装跨越多行的字符串。以下是字符串使用的简短示例：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Array
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are made up of sequenced elements of a specific type. An array can be
    created for any data type. The length of an array cannot be changed and must be
    specified at the time of declaration. Arrays are seldom used directly, but are
    used mostly through the slice type covered in the next section. Arrays are always
    one-dimensional, but you can create an array of arrays to create multidimensional
    objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数组由特定类型的顺序元素组成。可以为任何数据类型创建数组。数组的长度不能改变，并且必须在声明时指定。数组很少直接使用，而是通过下一个部分介绍的切片类型使用。数组始终是一维的，但可以通过创建数组的数组来创建多维对象。
- en: 'To create an array of 128 bytes, this syntax can be used:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个128字节的数组，可以使用以下语法：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Individual elements of an array can be accessed by its 0-based numeric index.
    For example, to get the fifth element from the byte array, the syntax is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过数组的基于0的数字索引来访问单个元素。例如，要获取字节数组的第五个元素，语法如下：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Slice
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Slices use arrays as the underlying data type. The main advantage is that slices
    can be resized, unlike arrays. Think of slices as a viewing window in to an underlying
    array. The **capacity** refers to the size of the underlying array, and the maximum
    possible length of a slice. The **length** of a slice refers to its current length
    which can be resized.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 切片使用数组作为底层数据类型。主要优点是切片可以改变大小，而数组不能。可以将切片看作是底层数组的一个视图窗口。**容量**指的是底层数组的大小，以及切片的最大可能长度。**长度**指的是切片的当前长度，可以调整大小。
- en: 'Slices are created using the `make()` function. The `make()` function will
    create a slice of a certain type with a certain length and capacity. The `make()`
    function can be used two ways when creating a slice. With only two parameters,
    the length and capacity are the same. With three parameters, you can specify a
    maximum capacity larger than the length. Here are two of the `make()` function
    declarations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是使用`make()`函数创建的。`make()`函数会创建一个特定类型、特定长度和容量的切片。使用`make()`函数创建切片时，有两种方式。只使用两个参数时，长度和容量相同。使用三个参数时，可以指定一个大于长度的最大容量。以下是两种`make()`函数声明方式：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A nil slice can be created with a capacity and length of 0\. There is no underlying
    array associated with a nil slice. Here is a short example program demonstrating
    how to create and inspect a slice:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个容量和长度为0的`nil`切片。`nil`切片没有与之关联的底层数组。以下是一个简短的示例程序，演示如何创建和检查切片：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also append to a slice using the built-in `append()` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内置的`append()`函数向切片追加元素。
- en: Append can add one or more elements at a time. The underlying array will be
    resized if necessary. This means that the maximum capacity of a slice can be increased.
    When a slice increases its underlying capacity, creating a larger underlying array,
    it will create the array with some extra space. This means that if you surpass
    a slice's capacity by one, it might increase the array size by four. This is done
    so that the underlying array has room to grow to reduce the number of times the
    underlying array has to be resized, which may require moving memory around to
    accommodate the larger array. It could be expensive to resize an array every time
    just to add a single element. The slice mechanics will automatically determine
    the best size for resizing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Append` 可以一次添加一个或多个元素。如果有必要，底层数组将被重新调整大小。这意味着切片的最大容量可以增加。当切片增加其底层容量，创建一个更大的底层数组时，它会为数组创建一些额外的空间。这意味着如果你超出了切片的容量一个单位，它可能会将数组的大小增加四倍。这样做是为了让底层数组有足够的空间增长，减少底层数组需要重新调整大小的次数，因为这可能需要移动内存以适应更大的数组。每次仅添加一个元素就重新调整数组大小可能是昂贵的。切片的机制会自动确定调整大小的最佳尺寸。'
- en: 'This code sample provides various examples of working with slices:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例提供了多个关于切片操作的例子：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Struct
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: In Go, a struct or data structure is a collection of variables. The variables
    can be of different types. We will look at an example of creating a custom struct
    type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，结构体或数据结构是变量的集合，这些变量可以是不同类型的。我们将通过一个创建自定义结构体类型的示例来说明。
- en: Go uses case-based scoping to declare a variable either `public` or `private`.
    Variables and methods that are capitalized are exported and accessible from other
    packages. Lowercase values are private and only accessible within the same package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用基于大小写的作用域来声明变量为`public`或`private`。首字母大写的变量和方法是公开的，可以从其他包中访问。小写的值是私有的，仅能在同一个包内访问。
- en: 'The following example creates a simple struct named `Person` and one named
    `Hacker`. The `Hacker` type has a `Person` type embedded within it. An instance
    of each type is then created and the information about them is printed to standard
    output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个名为`Person`的简单结构体和一个名为`Hacker`的结构体。`Hacker`类型内嵌了`Person`类型。然后创建每种类型的实例，并将它们的信息打印到标准输出：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can create *private* variables by starting their name with a lowercase letter.
    I use quotation marks because private variables work slightly different than in
    other languages. The privacy works at the package level and not at the *class*
    or type level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将变量名首字母小写来创建*私有*变量。我使用引号是因为私有变量的工作方式与其他语言稍有不同。隐私是基于包级别的，而不是基于*类*或类型级别的。
- en: Pointer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Go provides a pointer type that stores the memory location where data of a specific
    type is stored. Pointers can be used to pass a struct to a function by reference
    without creating a copy. This also allows a function to modify an object in-place.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一种指针类型，用于存储特定类型数据的内存位置。可以使用指针通过引用将结构体传递给函数，而不创建副本。这还允许函数就地修改对象。
- en: There is no pointer arithmetic allowed in Go. Pointers are considered *safe*
    because Go does not even define the addition operator on the pointer type. They
    can only be used to reference an existing object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go不允许指针运算。指针被认为是*安全*的，因为Go甚至没有为指针类型定义加法运算符。指针只能用于引用现有对象。
- en: 'This example demonstrates basic pointer usage. It first creates an integer,
    and then creates a pointer to the integer. It then prints out the data type of
    the pointer, the address stored in the pointer, and then the value of data being
    pointed at:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了基本的指针用法。它首先创建一个整数，然后创建一个指向该整数的指针。接着，它打印出指针的数据类型、指针中存储的地址以及指针指向的数据值：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Function
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are defined with the `func` keyword. Functions can have multiple parameters.
    All parameters are positional and there are no named parameters. Go supports variadic
    parameters allowing for an unknown number of parameters. Functions are first-class
    citizens in Go, and can be used anonymously and returned as a variable. Go also
    supports multiple return values from a function. The underscore can be used to
    ignore a return variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过`func`关键字定义。函数可以有多个参数，所有参数都是位置参数，没有命名参数。Go支持可变参数，允许传入未知数量的参数。函数在Go中是第一类公民，可以匿名使用并作为变量返回。Go还支持从函数返回多个值。可以使用下划线忽略返回值。
- en: 'All of these examples are demonstrated in the following code source:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都在以下代码源中演示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Interface
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are a special type that define a collection of function signatures.
    You can think of an interface as saying, "a type must implement function X and
    function Y to satisfy this interface." If you create any type and implement the
    functions needed to satisfy the interface, your type can be used anywhere that
    the interface is expected. You don't have to specify that you are trying to satisfy
    an interface, the compiler will determine if it satisfies the requirements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种特殊类型，定义了一组函数签名。你可以将接口理解为“一个类型必须实现函数X和函数Y才能满足该接口”。如果你创建了一个类型并实现了满足接口所需的函数，那么这个类型就可以在任何需要该接口的地方使用。你不必显式地指定你正在尝试满足一个接口，编译器会自动判断它是否符合要求。
- en: You can add as many other functions as you want to your custom type. The interface
    defines the functions that are required, but it does not mean that your type is
    limited to implementing only those functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向自定义类型添加任意多的其他函数。接口定义了必需的函数，但并不意味着你的类型只能实现这些函数。
- en: 'The most commonly used interface is the `error` interface. The `error` interface
    only requires a single function to be implemented, a function named `Error()`
    that returns a string with the error message. Here is the interface definition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的接口是`error`接口。`error`接口只需要实现一个函数，名为`Error()`，它返回一个包含错误信息的字符串。以下是该接口的定义：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This makes it very easy for you to implement your own error interfaces. This
    example creates a `customError` type and then implements the `Error()` function
    needed to satisfy the interface. Then, a sample function is created, which returns
    the custom error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你可以非常容易地实现自己的错误接口。这个例子创建了一个`customError`类型，并实现了满足接口所需的`Error()`函数。然后，创建了一个示例函数，返回自定义错误：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Other frequently used interfaces are the `Reader` and `Writer` interfaces.
    Each one only requires one function to be implemented in order to satisfy the
    interface requirements. The big benefit here is that you can create your own custom
    types that reads and writes data in some arbitrary way. The implementation details
    are not important to the interface. The interface won''t care whether you are
    reading and writing to a hard disk, a network connection, storage in memory, or
    `/dev/null`. As long as you implement the function signatures that are required,
    you can use your type anywhere the interface is used. Here is the definition of
    the `Reader` and `Writer` interfaces:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常用的接口包括`Reader`和`Writer`接口。每个接口只需要实现一个函数，以满足接口要求。这里的一个大好处是，你可以创建自己的自定义类型，以某种任意方式读写数据。实现细节对接口来说并不重要。接口不会关心你是在读取和写入硬盘、网络连接、内存存储还是`/dev/null`。只要你实现了所需的函数签名，就可以在接口使用的任何地方使用你的类型。以下是`Reader`和`Writer`接口的定义：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Map
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: A map is a hash table or dictionary that stores key and value pairs. The key
    and value can be any data types, including maps themselves, creating multiple
    dimensions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: map 是一个哈希表或字典，用于存储键值对。键和值可以是任何数据类型，包括 map 本身，从而创建多维结构。
- en: The order is not guaranteed. You can iterate over a map multiple times and it
    might be different. Additionally, maps are not concurrent safe. If you must share
    a map between threads, use a mutex.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序是不保证的。你可以多次遍历一个 map，每次的顺序可能都不同。此外，map 不是并发安全的。如果你必须在多个线程之间共享 map，请使用互斥锁（mutex）。
- en: 'Here are some example map usages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 map 使用的示例：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Channel
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Channel
- en: Channels are used to communicate between threads. Channels are **first-in, first-out**
    (**FIFO**) queues. You can push objects on to the queue and pull from the front
    asynchronously. Each channel can only support one data type. Channels are blocking
    by default, but can be made nonblocking with a `select` statement. Like slices
    and maps, channels must be initialized before use with the `make()` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通道用于线程间通信。通道是**先进先出**（**FIFO**）队列。你可以将对象推入队列，并异步从队列的前端取出。每个通道只能支持一种数据类型。通道默认是阻塞的，但可以通过`select`语句使其变为非阻塞。像切片和映射一样，通道在使用前必须通过`make()`函数进行初始化。
- en: The saying in Go is *Do not communicate by sharing memory; instead, share memory
    by communicating*. Read more about this philosophy at [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Go 里的格言是*不要通过共享内存进行通信，而应该通过通信来共享内存*。更多关于这一哲学的内容可以参考[https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating)。
- en: 'Here is an example program that demonstrates basic channel usage:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例程序，展示了基本的通道使用方法：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Control structures
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Control structures are used to control the flow of program execution. The most
    common forms are the `if` statements, `for` loops, and `switch` statements. Go
    also supports the `goto` statement, but should be reserved for cases of extreme
    performance and not used regularly. Let's look briefly at each of these to understand
    the syntax.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构用于控制程序执行的流程。最常见的形式是`if`语句、`for`循环和`switch`语句。Go 还支持`goto`语句，但应仅在极端性能需求的情况下使用，不宜频繁使用。让我们简要地了解一下每种结构的语法。
- en: if
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if
- en: The `if` statement comes with the `if`, `else if`, and `else` clauses, just
    like most other languages. The one interesting feature that Go has is the ability
    to put a statement before the condition, creating temporary variables that are
    discarded after the `if` statement has completed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句包括`if`、`else if`和`else`语句块，就像大多数其他语言一样。Go 中一个有趣的特性是，能够在条件之前写一个语句，用来创建临时变量，这些变量会在`if`语句执行完毕后被丢弃。'
- en: 'This example demonstrates the various ways to use an `if` statement:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了使用 `if` 语句的不同方式：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: for
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for
- en: 'The `for` loop has three components, and can be used just like a `for` loop
    in C or Java. Go has no `while` loop because the `for` loop serves the same purpose
    when used with a single condition. Refer to the following example for more clarity:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环有三个组成部分，并且可以像 C 或 Java 中的 `for` 循环一样使用。Go 没有 `while` 循环，因为 `for` 循环在使用单一条件时可以实现同样的功能。参考以下示例可以更清楚：'
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: range
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`range`'
- en: 'The `range` keyword is used to iterate over a slice, map, or other data structure.
    The `range` keyword is used in combination with the `for` loop, to operate on
    an iterable data structure. The `range` keyword returns the key and value variables.
    Here are some basic examples of using the `range` keyword:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 关键字用于遍历切片、映射或其他数据结构。`range` 关键字与 `for` 循环结合使用，操作可迭代的数据结构。`range` 关键字返回键和值变量。以下是一些使用
    `range` 关键字的基本示例：'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: switch, case, fallthrough, and default
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: switch、case、fallthrough 和 default
- en: The `switch` statement allows you to branch execution based on the state of
    a variable. It is similar to the `switch` statement in C and other languages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句允许你根据变量的状态分支执行。它与 C 和其他语言中的 `switch` 语句类似。'
- en: There is no `fallthrough` by default. This means once the end of a case is reached,
    the code exits the `switch` statement completely unless an explicit `fallthrough`
    command is provided. A `default` case can be provided if none of the cases are
    matched.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下没有 `fallthrough`。这意味着，一旦到达一个 case 的末尾，代码会完全退出 `switch` 语句，除非显式提供了 `fallthrough`
    命令。如果没有匹配的 case，可以提供一个 `default` case。
- en: You can put a statement in front of the variable to be switched, such as the
    `if` statement. This creates a variable whose scope is limited to the `switch`
    statement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在要切换的变量前放一个语句，比如 `if` 语句。这会创建一个仅在 `switch` 语句范围内有效的变量。
- en: 'This example demonstrates two `switch` statements. The first one uses hardcoded
    values and includes a `default` case. The second `switch` statement uses an alternate
    syntax that allows for a statement in the first line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了两个 `switch` 语句。第一个使用硬编码的值，并包含一个 `default` case。第二个 `switch` 语句使用一种替代语法，可以在第一行放入语句：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: goto
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: goto
- en: 'Go does have a `goto` statement, but it is very rarely used. Create a label
    with a name and a colon, then *go to* it using the `goto` keyword. Here is a basic
    example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Go 确实有 `goto` 语句，但它非常少用。你可以通过创建一个带有名称和冒号的标签，然后使用 `goto` 关键字跳转到该标签。以下是一个基本示例：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Defer
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Defer
- en: By deferring a function, it will run whenever the current function is exited.
    This is a convenient way to ensure that a function will get executed before exiting,
    which is useful for cleaning up or closing files. It is convenient because a deferred
    function will get executed no matter where the surrounding function exits if there
    are multiple return locations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过推迟一个函数，它将在当前函数退出时执行。这是一种确保函数在退出前执行的便捷方式，特别适合进行清理或关闭文件。因为即使函数有多个返回位置，推迟的函数也会在任何位置退出时执行。
- en: Common use cases are deferring calls to close a file or database connection.
    Right after opening a file, you can defer a call to close. This will ensure that
    a file is closed whenever the function is exited, even if there are multiple return
    statements and you can't be sure about when and where the current function will
    exit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的用例是推迟关闭文件或数据库连接的调用。在打开文件后，可以推迟一个关闭文件的调用。这将确保每当函数退出时，文件会被关闭，即使有多个返回语句，你也无法确定当前函数何时以及在哪里退出。
- en: 'This example demonstrates a simple use case for the `defer` keyword. It creates
    a file and then defers a call to `file.Close()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了 `defer` 关键字的简单用法。它创建一个文件，然后推迟调用 `file.Close()`：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Be sure to properly check and handle errors. The `defer` call will panic if
    using a nil pointer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保正确检查并处理错误。如果使用空指针，`defer` 调用会触发 panic。
- en: It is also important to understand that deferred functions are run when the
    surrounding function is exited. If you put a `defer` call inside a `for` loop,
    it will not get called at the end of each `for` loop iteration.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要理解，推迟的函数是在围绕的函数退出时执行的。如果你将 `defer` 调用放在 `for` 循环内，它不会在每次 `for` 循环迭代结束时调用。
- en: Packages
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: Packages are just directories. Every directory is its own package. Creating
    subdirectories creates a new package. Having no subpackages leads to a flat hierarchy.
    Subdirectories are used just for organizing code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 包就是目录。每个目录就是一个包。创建子目录会创建一个新的包。没有子包会导致扁平的层次结构。子目录仅用于组织代码。
- en: Packages should be stored in the `src` folder of your `$GOPATH` variable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 包应该存储在`$GOPATH`变量的`src`文件夹中。
- en: A package name should match the folder name or be named `main`. A `main` package
    means that it is not intended to be imported into another application, but meant
    to compile and run as a program. Packages are imported using the `import` keyword.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 包名应与文件夹名称匹配，或者命名为`main`。`main`包意味着它不打算被导入到其他应用程序中，而是作为程序进行编译和运行。包通过`import`关键字导入。
- en: 'You can import packages individually:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以单独导入包：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can import multiple packages at once by wrapping them with
    parenthesis:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过将多个包用括号括起来一次性导入：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Classes
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Go technically does not have classes, but there are only a few subtle distinctions
    that keep it from being called an object-oriented language. Conceptually, I do
    consider it an object-oriented programming language, though it only supports the
    most basic features of an object-oriented language. It does not come with all
    of the features many people have come to associate with object-oriented programming,
    such as inheritance and polymorphism, which are replaced with other features such
    as embedded types and interfaces. Perhaps you could call it a *microclass* system,
    because it is a minimalistic implementation with none of the extra features or
    baggage, depending on your perspective.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Go没有类，但只有一些细微的区别使它不能被称为面向对象语言。概念上，我确实认为它是面向对象的编程语言，尽管它只支持面向对象语言的最基本特性。它不包含许多人习惯于与面向对象编程相关联的所有特性，如继承和多态，这些被嵌入类型和接口等其他特性所取代。根据你的角度，你或许可以称其为*微类*系统，因为它是一个极简实现，去除了所有额外的特性和负担。
- en: Throughout this book, the terms *object* and *class* may be used to illustrate
    a point using familiar terms, but be aware that these are not formal terms in
    Go. A type definition in combination with the functions that operate on that type
    are like the class, and the object is an instance of a type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，*对象*和*类*这两个术语可能会用来通过熟悉的术语来阐明一个观点，但请注意，这些不是Go语言中的正式术语。类型定义与操作该类型的函数结合在一起类似于类，而对象则是类型的一个实例。
- en: Inheritance
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'There is no inheritance in Go, but you can embed types. Here is an example
    of a `Person` and `Doctor` types, which embeds the `Person` type. Instead of inheriting
    the behavior of `Person` directly, it stores the `Person` object as a variable,
    which brings with it all of its expected `Person` methods and attributes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Go中没有继承，但你可以嵌入类型。这里是一个`Person`和`Doctor`类型的例子，`Doctor`类型嵌入了`Person`类型。`Doctor`不是直接继承`Person`的行为，而是将`Person`对象作为变量存储，这样它就拥有了所有`Person`的方法和属性：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Polymorphism
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: There is no polymorphism in Go, but you can use interfaces to create common
    abstraction that can be used by multiple types. Interfaces define one or more
    method declarations that must be satisfied to be compatible with the interface.
    Interfaces were covered earlier in this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中没有多态，但你可以使用接口创建一个可以被多个类型使用的公共抽象。接口定义一个或多个方法声明，必须满足这些声明才能与接口兼容。接口在本章早些时候已经讨论过。
- en: Constructors
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'There are no constructors in Go, but there are `New()` functions that act like
    factories initializing an object. You simply have to create a function named `New()`
    that returns your data type. Here is an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Go中没有构造函数，但有`New()`函数，它类似于工厂方法来初始化一个对象。你只需创建一个名为`New()`的函数并返回你的数据类型。这里是一个例子：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are no deconstructors in Go, since everything is garbage collected and
    you do not manually destroy objects. Defer is the closest you can get by deferring
    a function call to perform some cleanup when the current function ends.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中没有析构函数，因为一切都由垃圾回收管理，你无需手动销毁对象。`defer`是最接近析构函数的功能，它可以延迟调用一个函数，在当前函数结束时执行一些清理操作。
- en: Methods
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'Methods are functions that belong to a specific type, and are called using
    the dot notation, for example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是属于特定类型的函数，并且通过点符号调用，例如：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The dot notation is widely used in C++ and other object-oriented languages.
    The dot notation and the class system stemmed from a common pattern that was used
    in C. The common pattern is to define a set of functions that all operate on a
    specific data type. All of the related functions have the same first parameter,
    which is the data to be operated on. Since this is such a common pattern, Go built
    it into the language. Instead of passing the object to be manipulated as the first
    argument, there is a special place to designate the receiver in a Go function
    definition. The receiver is specified between a set of parenthesis before the
    function name. The next example demonstrates how to use function receivers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 点（dot）符号在 C++ 和其他面向对象语言中被广泛使用。点符号和类系统源自于 C 语言中使用的一个共同模式。这个常见模式是定义一组操作特定数据类型的函数。所有相关函数的第一个参数都是要操作的数据。由于这是一个常见模式，Go
    将其内建到语言中。与其将要操作的对象作为第一个参数传递，不如在 Go 函数定义中通过一个特殊的位置指定接收器。接收器被指定在函数名之前的一对括号中。接下来的例子演示了如何使用函数接收器。
- en: 'Instead of writing a large set of functions that all took a pointer as their
    first parameter, you can write functions that have a special *receiver*. The receiver
    can either be a type or a pointer to a type:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写具有特殊*接收器*的函数，而不是编写一个庞大的函数集，其中所有函数的第一个参数都是指针。接收器可以是一个类型，也可以是该类型的指针：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Go, you do not encapsulate all of the variables and methods inside a monolithic
    pair of braces. You define a type, and then define methods that operate on that
    type. This allows you to define all of your structs and data types in one place,
    and define the methods elsewhere in your package. You also have the option of
    defining a type and the methods right next to each other. It's pretty simple and
    straightforward, and it creates a slightly clearer distinction between the state
    (data) and the logic.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，你不会将所有的变量和方法都封装在一对庞大的大括号中。你定义一个类型，然后定义作用于该类型的方法。这允许你将所有结构体和数据类型定义在一个地方，并在包的其他地方定义方法。你也可以选择将类型和方法直接放在一起定义。这种方式简单明了，并且在状态（数据）和逻辑之间创建了更清晰的区分。
- en: Operator overloading
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: There is no operator overloading in Go, so you can't add to structs together
    with the `+` sign, but you can easily define an `Add()` function on the type and
    then call something like `dataSet1.Add(dataSet2)`. By omitting operator overloading
    from the language, we can confidently use the operators without worrying about
    unexpected behavior due to operator behavior being overloaded somewhere else in
    code without realizing it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不支持运算符重载，因此你不能通过 `+` 运算符将结构体相加，但你可以很容易地在类型上定义一个 `Add()` 函数，然后调用类似 `dataSet1.Add(dataSet2)`
    的方式。通过将运算符重载从语言中去除，我们可以放心使用运算符，而不用担心由于某些地方不小心重载了运算符，导致的意外行为。
- en: Goroutines
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: Goroutines are lightweight threads built into the language. You simply have
    to put the word `go` in front of a function call to have the function execute
    in a thread. Goroutines may also be referred to as threads in this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine 是 Go 内建的轻量级线程。你只需在函数调用前加上`go`关键字，就能让函数在一个线程中执行。在本书中，Goroutine 也可能被称为线程。
- en: Go does provide mutexes, but they are avoidable in most cases and will not be
    covered in this book. You can read more about mutexes in the `sync` package documentation
    at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/). Channels should
    be used instead for sharing data and communicating between threads. Channels were
    covered earlier in this chapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Go 确实提供了互斥锁（mutex），但在大多数情况下可以避免使用，它们不会在本书中讲解。你可以在[`sync`包文档](https://golang.org/pkg/sync/)中阅读更多关于互斥锁的信息。应使用通道（Channels）来共享数据并在线程之间进行通信。通道在本章之前已经讲解过。
- en: 'Note that the `log` package is safe to use concurrently, but the `fmt` package
    is not. Here is a short example of using goroutines:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`log`包是安全的并且支持并发使用，而`fmt`包则不支持并发使用。这里是一个使用 goroutine 的简单示例：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Getting help and documentation
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助和文档
- en: Go has both online and offline help documentation. The offline documentation
    is built-in for Go and is the same documentation that is hosted online. These
    next sections will walk you through accessing both forms of documentation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Go 既有在线帮助文档，也有离线文档。Go 的离线文档是内置的，和在线托管的文档相同。接下来的部分将引导你如何访问这两种形式的文档。
- en: Online Go documentation
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线 Go 文档
- en: The online documentation is available at [https://golang.org/](https://golang.org/),
    and has all the formal documentation, specifications, and help files. Language
    documentation specifically is at [https://golang.org/doc/](https://golang.org/doc/),
    and information about the standard library is at [https://golang.org/pkg/](https://golang.org/pkg/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在线文档可以在 [https://golang.org/](https://golang.org/) 上找到，包含所有正式文档、规范和帮助文件。语言文档特别在
    [https://golang.org/doc/](https://golang.org/doc/) 上，标准库的信息可以在 [https://golang.org/pkg/](https://golang.org/pkg/)
    找到。
- en: Offline Go documentation
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线 Go 文档
- en: 'Go also comes with offline documentation with the `godoc` command-line tool.
    You can use it on the command line, or have it run a web server where it serves
    the same website that [https://golang.org/](https://golang.org/) hosts. It is
    quite handy to have the full website documentation available locally. Here are
    a few examples that get documentation for the `fmt` package. Replace `fmt` with
    whatever package you are interested in:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还提供了一个离线文档，使用 `godoc` 命令行工具。你可以在命令行中使用它，或者让它运行一个 web 服务器，提供与 [https://golang.org/](https://golang.org/)
    相同的网站内容。能够在本地访问完整的网站文档非常方便。以下是一些获取 `fmt` 包文档的示例。将 `fmt` 替换为你感兴趣的任何包：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The HTTP option serves the same documentation that is available on [https://golang.org/](https://golang.org/).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 选项提供与 [https://golang.org/](https://golang.org/) 上相同的文档。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter you should have a basic understanding of Go fundamentals
    such as what the keywords are, what they do, and what basic data types are available.
    You should also feel comfortable creating functions and custom data types.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该对 Go 基础知识有一个基本的理解，比如关键字是什么，它们的作用以及有哪些基本数据类型。你也应该能熟练创建函数和自定义数据类型。
- en: The goal is not to memorize all of the preceding information, but to be aware
    of what tools are available in the language. Use this chapter as a reference if
    necessary. You can find more information about the Go language specification at
    [https://golang.org/ref/spec](https://golang.org/ref/spec).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是记住所有前面的信息，而是了解语言中有哪些工具可供使用。如有需要，可以将本章作为参考。你可以在[https://golang.org/ref/spec](https://golang.org/ref/spec)找到更多关于
    Go 语言规范的信息。
- en: In the next chapter, we will look at working with files in Go. We will cover
    basics such as getting file information, seeing whether a file exists, truncating
    files, checking permissions, and creating new files. We will also cover the reader
    and writer interfaces, as well as a number of ways to read and write data. In
    addition to this, we will cover things such as archiving to ZIP or TAR files and
    compressing files with GZIP.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Go 中处理文件。我们将涵盖一些基础内容，如获取文件信息、查看文件是否存在、截断文件、检查权限以及创建新文件。我们还将讲解读取器和写入器接口，以及多种读取和写入数据的方法。除此之外，我们还会涉及归档为
    ZIP 或 TAR 文件以及使用 GZIP 压缩文件等内容。
