- en: '*Chapter 11*: Incorporating New Binary Formats'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：纳入新二进制格式'
- en: In this chapter, we will discuss how to incorporate new binary formats into
    Ghidra, enabling you to analyze exoteric binaries – for instance, ROMs of video
    games (a copy of the data from the cartridge or any other read-only memory). Throughout
    this chapter, you will learn how to develop Ghidra loader extensions, which were
    previously introduced in the *Loaders* subsection of the *The Ghidra extension
    module skeleton* section in [*Chapter 4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063),
    *Using Ghidra Extensions*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论如何将新的二进制格式纳入 Ghidra，使您能够分析特殊的二进制文件——例如视频游戏的 ROM（来自游戏卡带或其他只读存储器的数据副本）。在本章中，您将学习如何开发
    Ghidra 加载器扩展，这些扩展在 [*第 4 章*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)的
    *使用 Ghidra 扩展* 部分的 *加载器* 子部分中已有介绍。
- en: We will start by looking at what a binary file is. We will explore the differences
    between raw binary files and formatted binary files and how Ghidra can deal with
    them. Next, we will perform some experiments with Ghidra to understand how binaries
    are loaded from a user perspective. Finally, we will analyze the loader for **old-style
    DOS executable binaries** from a Ghidra developer perspective. The loader under
    analysis is responsible for enabling Ghidra to load MS-DOS executable binaries,
    so you will learn about loader development by analyzing a real-world example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从了解什么是二进制文件开始。我们将探讨原始二进制文件和格式化二进制文件之间的区别，以及 Ghidra 如何处理它们。接下来，我们将进行一些 Ghidra
    实验，从用户的角度理解二进制文件如何加载。最后，我们将从 Ghidra 开发者的角度分析 **旧版 DOS 可执行二进制文件** 的加载器。所分析的加载器负责使
    Ghidra 能够加载 MS-DOS 可执行二进制文件，因此通过分析一个实际的例子，您将学习加载器开发。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding the difference between raw binaries and formatted binaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原始二进制文件与格式化二进制文件之间的区别
- en: Developing a Ghidra loader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Ghidra 加载器
- en: Understanding filesystem loaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件系统加载器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: '**Flat assembler** (**fasm**), which is an assembly language compiler that
    can produce binaries of different formats (plain binary, MZ, PE, COFF, or ELF):
    [https://flatassembler.net/download.php](https://flatassembler.net/download.php)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flat assembler**（**fasm**），这是一款汇编语言编译器，可以生成多种格式的二进制文件（纯二进制、MZ、PE、COFF 或 ELF）：[https://flatassembler.net/download.php](https://flatassembler.net/download.php)'
- en: 'HexIt v.1.57, which is a hex editor allowing you to parse old MS-DOS executable
    files (MZ): [https://mklasson.com/hexit.php](https://mklasson.com/hexit.php)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HexIt v.1.57，这是一款十六进制编辑器，允许您解析旧版 MS-DOS 可执行文件（MZ）：[https://mklasson.com/hexit.php](https://mklasson.com/hexit.php)
- en: The GitHub repository containing all the necessary code for this chapter can
    be found at [https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包含本章所有必要代码的 GitHub 仓库可以在以下链接找到：[https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11](https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners/tree/master/Chapter11)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3mQraZo](https://bit.ly/3mQraZo)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看《代码实战》视频：[https://bit.ly/3mQraZo](https://bit.ly/3mQraZo)
- en: Understanding the difference between raw binaries and formatted binaries
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解原始二进制文件与格式化二进制文件之间的区别
- en: In this section, you will learn the difference between raw and formatted binaries.The
    concept of a binary file can be easily defined by negation; that is, a **binary
    file** is a file that is not a text file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解原始二进制文件与格式化二进制文件之间的区别。二进制文件的概念可以通过否定的方式简单定义；也就是说，**二进制文件**是一个不是文本文件的文件。
- en: 'We can classify binary files into two categories: raw binary files and formatted
    binary files.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将二进制文件分为两类：原始二进制文件和格式化二进制文件。
- en: '**Raw binaries** are those binary files that contain unprocessed data, so these
    binary files have no format in any way. An example of a raw binary could be a
    memory dump taken from some buffer containing a piece of code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始二进制文件**是包含未经处理数据的二进制文件，因此这些二进制文件在任何方面都没有格式。原始二进制文件的一个例子可能是从某个缓冲区中获取的一段代码的内存转储。'
- en: 'On the other hand, **formatted binaries** are those binary files that have
    a format specification so that you can parse it. Examples of formatted binaries
    are the Windows executable (image) files and object files that follow the **Portable
    Executable** (**PE**) format, the specification of which is available online:
    https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**格式化二进制文件**是指具有格式规范的二进制文件，这样你就可以解析它们。格式化二进制文件的例子包括遵循**可移植可执行文件**（**PE**）格式的Windows可执行文件（图像）和目标文件，PE格式的规范可以在线查阅：https://docs.microsoft.com/en-us/windows/win32/debug/pe-format。
- en: For the purpose of Ghidra, raw binaries are a truly general concept, meaning
    any file treated without taking into account its format. You can deal with raw
    binaries and manually process the data by structuring the file in some way, but
    it is much more comfortable to work with formatted binaries. It is for this reason
    that you will want to develop your own loaders for binary formats that are not
    supported yet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ghidra而言，原始二进制文件是一个非常通用的概念，意味着任何文件都可以不考虑其格式进行处理。你可以处理原始二进制文件并手动按某种方式构造数据，但使用格式化二进制文件会更为舒适。因此，你可能会想为那些尚不支持的二进制格式开发自己的加载器。
- en: Understanding raw binaries
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原始二进制文件
- en: 'Ghidra can load any kind of file from your filesystem, even if that file is
    not of a known file format (that is, files not having a known file structure).
    For instance, you can write a file that relates numbers with words and separates
    those pairs with a semicolon and Ghidra will be able to load it. We can generate
    a `raw.dat` file in this way by executing the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra可以从你的文件系统中加载任何类型的文件，即使该文件不是已知的文件格式（也就是说，文件没有已知的文件结构）。例如，你可以编写一个文件，将数字与单词关联，并用分号分隔这些对，Ghidra也能加载它。我们可以通过执行以下命令以这种方式生成一个`raw.dat`文件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you drag and drop the resulting `raw.dat` file into a Ghidra project, it
    will be loaded as a **Raw Binary** file (a sequence of bytes without sense) because
    Ghidra doesn't know its file format.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将生成的`raw.dat`文件拖放到Ghidra项目中，它将作为**原始二进制**文件（没有意义的字节序列）被加载，因为Ghidra不知道它的文件格式。
- en: 'As you can see in the following screenshot, Ghidra, based on the loader''s
    results, recognizes the file as **Raw Binary** during the importing phase and
    suggests this as the best format to use:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，Ghidra根据加载器的结果，在导入阶段识别该文件为**原始二进制文件**，并建议将其作为最合适的格式使用：
- en: '![Figure 11.1 – Loading a raw binary'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 加载原始二进制文件'
- en: '](img/B16207_11_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_001.jpg)'
- en: Figure 11.1 – Loading a raw binary
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 加载原始二进制文件
- en: 'The drop-down list of file formats is filled based on two concepts, **tiers**
    and **tiers priority**, which allows you to sort the list of formats from the
    most adequate (**Raw Binary** in *Figure 11.1*) to the least:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式的下拉列表基于两个概念**层级**和**层级优先级**进行填充，这使得你能够按从最合适的格式（*图11.1*中的**原始二进制**）到最不合适的格式对文件格式进行排序：
- en: '**Tiers**, an integer number in range 0 to 3 allowing us to represent four
    classes of loaders and enabling us to sort the loaders from the most specialized
    (tier 0) or appropriate to the least (tier 3).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层级**，一个整数，范围为0到3，允许我们表示四类加载器，并使我们能够按最专业（层级0）到最不合适（层级3）的顺序对加载器进行排序。'
- en: While the higher-tier value wins, an integer number named **tiers priority**
    is used to tiebreak when more than one loader is able to load a file with the
    same tier. Both tiers and tiers priority are mandatory when developing a loader.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然更高层级的值会获胜，但一个名为**层级优先级**的整数用于在多个加载器能够加载具有相同层级的文件时进行平局打破。开发加载器时，层级和层级优先级都是必需的。
- en: More about tiers and tiers priority
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于层级和层级优先级的信息
- en: 'As always, you can check the documentation on tiers and tiers priority if you
    want to look at them further in depth: [https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html)
    and [https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority()](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority()).'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像往常一样，如果你希望更深入地了解层级和层级优先级，可以查阅文档：[https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/LoaderTier.html)
    和 [https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority()](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html#getTierPriority())。
- en: We did this little experiment with `raw.dat` to understand, in baby steps, the
    basics of loaders using a file that you fully understand. Let's now try something
    a little more complicated!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`raw.dat`做了一个小实验，通过完全理解的文件来一步步理解加载器的基本原理。现在，让我们尝试一些稍微复杂一点的东西！
- en: To provide a more realistic example, let's load the shellcode of the Alina malware
    previously shown when analyzing the `0x004554E0` function in [*Chapter 5*](B16207_05_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Reversing Malware Using Ghidra*, under the *In-depth analysis* section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个更现实的示例，让我们加载之前在[*第 5 章*](B16207_05_Final_SK_ePub.xhtml#_idTextAnchor082)中分析`0x004554E0`函数时展示的Alina恶意软件的Shellcode，*使用Ghidra进行恶意软件逆向分析*一节中的*深入分析*部分。
- en: 'As it is not recognized, we must manually set the language in which the shellcode
    was written:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未被识别，我们必须手动设置Shellcode的编写语言：
- en: '![Figure 11.2 – Choosing a language and compiler for the raw binary'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – 为原始二进制选择语言和编译器'
- en: '](img/B16207_11_002.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_002.jpg)'
- en: Figure 11.2 – Choosing a language and compiler for the raw binary
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 为原始二进制选择语言和编译器
- en: You can also set a value for **Destination Folder** for the importing file,
    and **Program Name**, which will be used for importing the file into the project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为导入的文件设置**目标文件夹**和**程序名称**，这些将在将文件导入项目时使用。
- en: Finally, you can import just a block of the file by clicking on **Options…**,
    as shown in the following screenshot. It shows a menu allowing you to choose the
    block name (a name for this block of data), the base address, indicating the memory
    address where the block will start or be put on, and finally, a file offset, indicating
    the position of the block in the importing file and the length of the block.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过点击**选项…**来仅导入文件的一个块，如下截图所示。它显示了一个菜单，允许你选择块名称（该数据块的名称）、基址，表示块将从哪个内存地址开始或放置，最后是文件偏移量，表示该块在导入文件中的位置以及块的长度。
- en: 'The block will be labeled using `shellcode` by writing it into the input box).
    If you check the **Apply Processor Defined Labels** box, then the importer will
    create labels at some addresses as specified by the processor. On the other hand,
    those labels will not be moved even if the image base is changed later if you
    check the **Anchor Processor Defined Labels** box:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该块将通过在输入框中输入`shellcode`来标记。如果勾选**应用处理器定义标签**框，导入器将在处理器指定的某些地址创建标签。另一方面，即使以后更改了图像基址，如果勾选了**锚定处理器定义标签**框，这些标签也不会被移动：
- en: '![Figure 11.3 – Loading a block of a raw binary'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 加载原始二进制块'
- en: '](img/B16207_11_003.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_003.jpg)'
- en: Figure 11.3 – Loading a block of a raw binary
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 加载原始二进制块
- en: 'You can also add, remove, or edit blocks of memory by accessing the **Window**
    | **Memory Map** option of Ghidra''s CodeBrowser:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过访问Ghidra的CodeBrowser中的**窗口** | **内存映射**选项，添加、删除或编辑内存块：
- en: '![ Figure 11.4 – Adding, removing, and editing memory blocks'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 添加、删除和编辑内存块'
- en: '](img/B16207_11_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_004.jpg)'
- en: Figure 11.4 – Adding, removing, and editing memory blocks
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 添加、删除和编辑内存块
- en: 'As you can see in the following screenshot, if the file format is not recognized
    by Ghidra, you will have to manually perform a lot of work. In this case, you
    will need to define the bytes as code or strings, create symbols, and so on:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，如果Ghidra无法识别文件格式，你将不得不手动执行大量工作。在这种情况下，你需要将字节定义为代码或字符串，创建符号等等：
- en: '![ Figure 11.5 – Alina malware shellcode loaded as a raw binary'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – 加载为原始二进制的Alina恶意软件Shellcode'
- en: '](img/B16207_11_005.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_005.jpg)'
- en: Figure 11.5 – Alina malware shellcode loaded as a raw binary
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 加载为原始二进制的Alina恶意软件Shellcode
- en: Instead of doing it manually, you can extend Ghidra by developing a loader for
    such a format. Let's look at how we do this in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不必手动完成，你可以通过开发一个加载器来扩展Ghidra以支持这种格式。让我们看看下一部分是如何做到的。
- en: Understanding formatted binaries
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解格式化的二进制文件
- en: 'Executable binaries are formatted binaries; therefore, their importers must
    import them by taking into account the format structure. To understand this, let''s
    generate and look at an old MS-DOS executable because it will produce a light
    binary and, since the old MS-DOS executable structure is not especially complex,
    it is a really good real-world example to start with. The code of our `hello world`
    old MS-DOS executable program (the `mz.asm` file), written in assembly language,
    looks as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件是格式化的二进制文件；因此，它们的导入器必须考虑到格式结构进行导入。为了理解这一点，我们先生成并查看一个旧的MS-DOS可执行文件，因为它会生成一个轻量级的二进制文件，而且由于旧的MS-DOS可执行文件结构并不复杂，它是一个非常好的实际例子。我们这个`hello
    world`旧MS-DOS可执行程序（`mz.asm`文件）的代码，用汇编语言写成，内容如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Line `00` tells the compiler that this is an old MS-DOS program. At line `04`,
    we are triggering an interrupt, `21h` (most of the DOS API calls are invoked using
    interrupt `21h`), which receives `9h` in the `ah` register as a parameter (line
    `02`), indicating that the program has to print the message referenced by `dx`
    (line `03`), which is located at line `09`, to `stdout`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 行`00`告诉编译器这是一个旧的MS-DOS程序。在`04`行，我们触发了一个中断，`21h`（大多数DOS API调用是通过中断`21h`进行的），它在`ah`寄存器中接收`9h`作为参数（`02`行），表示程序必须将由`dx`（`03`行）引用的消息打印到`stdout`，该消息位于`09`行。
- en: 'Finally, the program ends, passing control to the operative system. This is
    done by passing the corresponding value in `ax` to indicate that the program must
    end its execution (line `06`) and again triggering the `21h` interruption. Let''s
    compile the program using `fasm`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序结束，将控制权交给操作系统。这是通过将对应的值传递给`ax`寄存器，指示程序必须结束执行（`06`行），并再次触发`21h`中断来完成的。让我们使用`fasm`编译程序：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By compiling the program, we obtained an `mz.exe` file as a result. To show
    you the format, I'm using HexIt v.1.57, which is a hexadecimal editor that parses
    old DOS executable headers when *F6* is pressed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译程序，我们得到了一个`mz.exe`文件。为了展示格式，我使用了HexIt v.1.57，这是一个十六进制编辑器，当按下*F6*时，它会解析旧的DOS可执行文件头。
- en: 'In the following screenshot, you can see the DOS .EXE header. Each row starts
    with the offset of the header field between brackets, then the name of the field,
    and, finally, its value. For instance, at the very beginning of the file (offset
    **[00]**), we have **Signature**, which has a value of **MZ**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到DOS .EXE头。每行以头字段的偏移量开始，字段名称之后是其值。例如，在文件的最开始（偏移**[00]**），我们有**Signature**，其值为**MZ**：
- en: '![Figure 11.6 – Showing the DOS .EXE header in HexIt v1.57'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 在HexIt v1.57中显示DOS .EXE头'
- en: '](img/B16207_11_006.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_006.jpg)'
- en: Figure 11.6 – Showing the DOS .EXE header in HexIt v1.57
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 在HexIt v1.57中显示DOS .EXE头
- en: 'Ghidra includes a loader that is able to parse these **old-style DOS executable
    (MZ)** binaries, so when you drag and drop this file into Ghidra, the language
    and format will both be recognized:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra包括一个加载器，能够解析这些**旧式DOS可执行文件（MZ）**二进制文件，因此，当你将这个文件拖入Ghidra时，语言和格式都会被识别：
- en: '![Figure 11.7 – Importing an old-style DOS executable (MZ) to Ghidra'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 – 将旧式DOS可执行文件（MZ）导入Ghidra'
- en: '](img/B16207_11_007.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_007.jpg)'
- en: Figure 11.7 – Importing an old-style DOS executable (MZ) to Ghidra
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 将旧式DOS可执行文件（MZ）导入Ghidra
- en: 'As you can see in the following screenshot, when this formatted binary file
    is loaded by Ghidra''s CodeBrowser, the entry point of the program is successfully
    detected. Addresses and a lot of useful information are automatically given to
    you:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，当这个格式化的二进制文件被Ghidra的CodeBrowser加载时，程序的入口点成功被检测到。地址和许多有用的信息会自动提供给你：
- en: '![Figure 11.8 – Ghidra successfully loaded the old-style DOS executable (MZ)
    and its disassembly matches our source code'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 – Ghidra成功加载了旧式DOS可执行文件（MZ），并且它的反汇编与我们的源代码匹配'
- en: '](img/B16207_11_008.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_008.jpg)'
- en: Figure 11.8 – Ghidra successfully loaded the old-style DOS executable (MZ) and
    its disassembly matches our source code
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – Ghidra成功加载了旧式DOS可执行文件（MZ），并且它的反汇编与我们的源代码匹配
- en: In the following section, we will overview how this **old-style DOS executable
    (MZ)** loader is implemented.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将概述如何实现这个**旧式DOS可执行文件（MZ）**加载器。
- en: Developing a Ghidra loader
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发Ghidra加载器
- en: 'A loader is a Ghidra extension module that extends from the `AbstractLibrarySupportLoader`
    class. This class has the following methods: `getName`, `findSupportedLoadSpecs`,
    `load`, and, optionally, if supporting custom options,`getDefaultOptions` and
    `validateOptions`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是一个 Ghidra 扩展模块，继承自`AbstractLibrarySupportLoader`类。该类具有以下方法：`getName`、`findSupportedLoadSpecs`、`load`，如果支持自定义选项，还可以有`getDefaultOptions`和`validateOptions`方法。
- en: I'm assuming that you are familiar with loaders and these methods because they
    were superficially overviewed in [*Chapter 4*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063),
    *Using Ghidra Extensions*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经熟悉加载器和这些方法，因为它们在[*第4章*](B16207_04_Final_SK_ePub.xhtml#_idTextAnchor063)《使用
    Ghidra 扩展》中已有简要概述。
- en: The old-style DOS executable (MZ) parser
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧式 DOS 可执行文件（MZ）解析器
- en: 'The existing Ghidra loader for MZ files must be able to parse the old-style
    DOS executable (MZ) file as we did by using **HexIt v.1.57** in the *Formatted
    binaries* section of this chapter. To do that, Ghidra implements a parser for
    these kinds of binaries that is available here: [https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 Ghidra MZ 文件加载器必须能够解析旧式 DOS 可执行文件（MZ），就像我们在本章的*格式化二进制文件*部分中使用**HexIt v.1.57**一样。为了实现这一点，Ghidra
    实现了一个针对这类二进制文件的解析器，可以在此找到：[https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/mz)。
- en: 'This link contains three files:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该链接包含三个文件：
- en: '`DOSHeader.java`: A file implementing the old-style DOS executable parser.
    It relies on the `StructConverter` class to create a structure data type that
    is equivalent to the `DOSHeader` class members.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOSHeader.java`：一个实现旧式 DOS 可执行文件解析器的文件。它依赖于`StructConverter`类来创建与`DOSHeader`类成员等效的结构数据类型。'
- en: '`OldStyleExecutable.java`: A class that uses `FactoryBundledWithBinaryReader`
    to read data from a generic byte provider and passes it to the `DOSHeader` class
    in order to parse it. The `OldStyleExecutable` class exposes both via getter methods:
    `DOSHeader` and the underlying `FactoryBundledWithBinaryReader` object.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OldStyleExecutable.java`：一个使用`FactoryBundledWithBinaryReader`从通用字节提供者读取数据并将其传递给`DOSHeader`类以进行解析的类。`OldStyleExecutable`类通过
    getter 方法公开了`DOSHeader`和底层的`FactoryBundledWithBinaryReader`对象。'
- en: '`package.html`: A short description of the directory content.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.html`：该目录内容的简短描述。'
- en: Relevant parser classes
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相关解析器类
- en: You can find the documentation for `StructConverter` at [https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html).
    You can find the documentation for `FactoryBundledWithBinaryReader` at [https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在此找到`StructConverter`的文档：[https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/StructConverter.html)。你可以在此找到`FactoryBundledWithBinaryReader`的文档：[https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/bin/format/FactoryBundledWithBinaryReader.html)。
- en: When writing your own loaders, you can put your parsers into the `format` directory
    of Ghidra (`Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format`), which
    will be available as both `*.jar` and `*.src` files in your Ghidra distribution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写你自己的加载器时，可以将你的解析器放入 Ghidra 的`format`目录（`Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format`），这些解析器将作为`*.jar`和`*.src`文件包含在你的
    Ghidra 分发版中。
- en: The old-style DOS executable (MZ) loader
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧式 DOS 可执行文件（MZ）加载器
- en: 'After implementing the parser for this format, the loader itself is implemented
    here, extending from `AbstractLibrarySupportLoader`: [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此格式的解析器后，加载器本身在此实现，从`AbstractLibrarySupportLoader`扩展：[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java)。
- en: Let's look at how this class is implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类是如何实现的。
- en: The getTierPriority method
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getTierPriority` 方法'
- en: 'This loader defines a tier priority of `60`, which is less than the PE (Portable
    Executable) tier priority. It is done in this way to prevent PE files from being
    loaded as MZ files. This could happen because the PE file format contains an MZ
    stub at the beginning. On the other hand, MZ files can''t be loaded by the PE
    loader:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载器定义了一个优先级为 `60` 的层级优先级，低于 PE（可移植执行文件）层级优先级。这样做是为了防止 PE 文件被当作 MZ 文件加载。这种情况可能发生，因为
    PE 文件格式在开头包含一个 MZ 存根。另一方面，MZ 文件无法被 PE 加载器加载：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is a simple method but no less important.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，但同样重要。
- en: The getName method
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getName` 方法'
- en: 'As mentioned before, a `getName` method must be implemented, allowing us to
    show the name of the loader when importing the file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，必须实现 `getName` 方法，允许我们在导入文件时显示加载器的名称：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The returned name must be descriptive enough taking into account the user's
    perspective.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的名称必须足够描述性，考虑到用户的视角。
- en: The findSupportedLoadSpecs method
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`findSupportedLoadSpecs` 方法'
- en: The loader specs are loaded by implementing the `findSupportedLoadSpecs` method,
    which queries the opinion service ([https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `findSupportedLoadSpecs` 方法来加载加载器规范，该方法查询意见服务（[https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/QueryOpinionService.html#query(java.lang.String,java.lang.String,java.lang.String))）。
- en: 'The `query` method receives the name of the loader as the first parameter,
    the primary key as the second parameter, and, finally, the secondary key:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` 方法接收加载器的名称作为第一个参数，主键作为第二个参数，最后是次键：'
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The opinion service retrieves the loader specifications from a `*.opinion`
    file ([https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion)).
    Opinion files contain constraints allowing you to determine whether the file can
    be loaded or not:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 意见服务从 `*.opinion` 文件中检索加载器规范（[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Processors/x86/data/languages/x86.opinion)）。意见文件包含约束条件，允许您确定文件是否可以加载：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The short format opinion documentation is available here: [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简短格式的意见文档可以在此查看：[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Framework/SoftwareModeling/data/languages/Steps%20to%20creation%20of%20Format%20Opinion.txt)。
- en: In any case, the XML attributes are self-explanatory.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，XML 属性是自解释的。
- en: The load method
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载方法
- en: 'At last, the `load` method does the hard job of loading the file into Ghidra.
    Let''s analyze the code. The loader starts obtaining information from the program
    being analyzed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`load` 方法做了将文件加载到 Ghidra 中的繁重工作。让我们来分析代码。加载器开始从正在分析的程序中获取信息：
- en: 'It obtains the bytes of the file being analyzed by calling the `MemoryBlockUtils.createFileBytes`
    function (lines `09`–`14`):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过调用 `MemoryBlockUtils.createFileBytes` 函数（`09`–`14` 行）获取正在分析的文件的字节：
- en: '[PRE36]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result of the call to `MemoryBlockUtils.createFileBytes()` is the `fileBytes`
    variable containing all the bytes of the file.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用 `MemoryBlockUtils.createFileBytes()` 的结果是 `fileBytes` 变量，包含文件的所有字节。
- en: 'It creates an address space to deal with Intel-segmented address spaces. Briefly,
    Intel memory segmentation allows you to isolate memory regions, offering, in this
    way, security. Due to segmentation, a memory address consists of a segment register
    (for example, the `CS` register) pointing to some segment of memory (for example,
    `code segment`) and an offset. The task of creating an address space for Intel-segmented
    address spaces is performed in two steps:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建一个地址空间来处理 Intel 分段的地址空间。简而言之，Intel 内存分段允许您隔离内存区域，从而提供安全性。由于分段，一个内存地址由一个段寄存器（例如
    `CS` 寄存器）指向内存的某个段（例如 `代码段`）和一个偏移量组成。为 Intel 分段的地址空间创建一个地址空间的任务分两步完成：
- en: 'a. First, it obtains the address factory for the language of the current program
    (line `15`):'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 首先，它获取当前程序语言的地址工厂（第`15`行）：
- en: '[PRE37]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `getAddressFactory()` result is `af`, an `AddressFactory` object that is
    expected to be a segmented address space. It is checked by the `instanceof` operator.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getAddressFactory()`的结果是`af`，它是一个`AddressFactory`对象，预计是一个分段地址空间。通过`instanceof`运算符进行检查。'
- en: 'b. Next, it obtains the segmented address space using the address factory (lines
    `23`–`24`):'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 接下来，它通过地址工厂获取分段地址空间（第`23`–`24`行）：
- en: '[PRE38]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After creating an address space, it retrieves the `25`) and the processor register
    context over the address space (line `26`):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建地址空间后，它检索了`25`）以及处理器寄存器上下文（第`26`行）：
- en: '[PRE39]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, it obtains the memory of the program (line `27`):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它获取程序的内存（第`27`行）：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By using the old-style DOS executable (MZ) parser (line `28`), the loader obtained
    the DOS header (line `34`) and a reader (lines `35` and `36`), allowing it to
    read bytes from the generic provider:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用旧式DOS可执行文件（MZ）解析器（第`28`行），加载器获得了DOS头（第`34`行）和读取器（第`35`和`36`行），使其能够从通用提供程序中读取字节：
- en: '[PRE41]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After retrieving all the previously mentioned information about the executable
    file, the loading actions are performed. Since actions are long tasks, every action
    is preceded by a `monitor.isCancelled()` call, allowing it to cancel the loading
    process (lines `38`, `43`, `47`, `51`, and `55`), and the user is notified when
    starting the action via the `monitor.setMessage()` call (lines `39`, `44`, `48`,
    `52`, and `56`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取了有关可执行文件的所有上述信息后，加载操作开始执行。由于操作是长任务，因此每个操作前都会调用`monitor.isCancelled()`，使其能够取消加载过程（第`38`、`43`、`47`、`51`和`55`行），并且用户在开始操作时会通过`monitor.setMessage()`调用（第`39`、`44`、`48`、`52`和`56`行）收到通知：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the upcoming sections, we will look over the following actions in order
    to deeply understand the `load` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将依次讨论以下操作，以深入理解`load`函数：
- en: '`processSegments()` (line `34`):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processSegments()`（第`34`行）：'
- en: '[PRE43]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`adjustSegmentStarts()` (line `39`):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`adjustSegmentStarts()`（第`39`行）：'
- en: '[PRE44]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`doRelocations()` (line `43`):'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doRelocations()`（第`43`行）：'
- en: '[PRE45]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`createSymbols()` (line `47`):'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createSymbols()`（第`47`行）：'
- en: '[PRE46]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`setRegisters()` (line `56`):'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setRegisters()`（第`56`行）：'
- en: '[PRE47]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After covering the sequence of calls performed by the `load` function, let's
    analyze each one in detail. In the following section, we will start by looking
    at how program segments are processed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾`load`函数执行的调用序列后，我们将逐一详细分析每个调用。接下来的部分将首先讨论程序段是如何被处理的。
- en: Processing segments
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理段
- en: 'The `processSegments()` function processes program segments. The following
    code snippet illustrates how it calculates segments. The code snippet extracts
    the code segment relative address from the DOS header via `dos.e_cs()`, as shown
    on line `04`, and, as it is relative to the segment the program was loaded at
    (in this case, `csStart`, whose value is equal to the `INITIAL_SEGMENT_VAL` constant,
    as shown on line `00`), it adds the `csStart` value to it, as shown again on line
    `04`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`processSegments()`函数处理程序段。以下代码片段展示了它如何计算段。代码片段通过`dos.e_cs()`从DOS头提取代码段相对地址，如第`04`行所示，并且由于该地址是相对于程序加载所在的段（在本例中为`csStart`，其值等于`INITIAL_SEGMENT_VAL`常量，如第`00`行所示），它将`csStart`的值加到该地址上，如第`04`行再次所示：'
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After calculating the segment addresses, `processSegments()` uses the Ghidra
    `MemoryBlockUtils.createInitializedBlock()` (line `01`) and `MemoryBlockUtils.createUninitializedBlock()`
    (line `09`) API methods to create the segments (memory regions) that were previously
    calculated:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算完段地址后，`processSegments()`使用Ghidra的`MemoryBlockUtils.createInitializedBlock()`（第`01`行）和`MemoryBlockUtils.createUninitializedBlock()`（第`09`行）API方法来创建先前计算出的段（内存区域）：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since segment processing is not precise, it requires some adjustment. In the
    next section, we will look at how to adjust the segments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于段处理不精确，因此需要进行一些调整。在下一部分中，我们将讨论如何调整这些段。
- en: Adjusting segment starts
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整段开始位置
- en: 'The function responsible for segment adjustment is `adjustSegmentStarts()`.
    It receives the `prog` program object as a parameter (an object of the `Program`
    class). It also retrieves the memory of the program via `prog.getMemory()` (line
    `00`), which allows access to its blocks of memory via the `getBlocks()` method
    (line `01`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 负责段调整的函数是`adjustSegmentStarts()`。它接收`prog`程序对象作为参数（`Program`类的一个对象）。它还通过`prog.getMemory()`（第`00`行）获取程序的内存，并通过`getBlocks()`方法（第`01`行）访问其内存块：
- en: '[PRE69]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The approach to adjust the segment consists of checking whether the starting
    bytes (`0x10` bytes) of the current block contain a far return (`FAR_RETURN_OPCODE`,
    as shown on line `00`), in which case the block is split by the far return (line
    `03`) appending it and the code preceding it to the previous block of memory (line
    `04`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 调整段的方式是检查当前块的起始字节（`0x10` 字节）是否包含远程返回（`FAR_RETURN_OPCODE`，如第 `00` 行所示），如果包含，则通过远程返回（第
    `03` 行）将其与前面的代码一起附加到前一个内存块中（第 `04` 行）：
- en: '[PRE71]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now that we've covered segment adjustment, let's see how code is loaded in the
    next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了段的调整，接下来我们将看到代码如何加载。
- en: Code relocation
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码重定位
- en: Code relocation allows us to load addresses for position-dependent code, adjusting
    both code and data. It is implemented by the `doRelocations()` function, which
    uses the `e_lfarlc()` method of `DOSHeader` to retrieve the address of the MZ
    relocation table (line `01`). By using `e_crlc()`, it also retrieves the number
    of entries comprising the relocation table (line `02`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重定位使我们能够加载位置相关代码的地址，调整代码和数据。它通过 `doRelocations()` 函数实现，该函数使用 `DOSHeader` 的
    `e_lfarlc()` 方法检索 MZ 重定位表的地址（第 `01` 行）。通过使用 `e_crlc()`，它还检索构成重定位表的条目数量（第 `02`
    行）。
- en: 'For each entry (line `03`), the segment and the offset being relative to the
    segment (lines `04`-`05`) allows you to calculate the location (line `07`), which
    is relative to the segment the program is loaded at (line `08`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个条目（第 `03` 行），段和相对于段的偏移量（第 `04`–`05` 行）可以计算位置（第 `07` 行），该位置相对于程序加载的段（第 `08`
    行）：
- en: '[PRE79]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now that the code is loaded, it is also possible to create useful symbols for
    referencing it. We will overview how to create symbols in the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码加载完成后，我们还可以创建有用的符号来引用它。在下一节中，我们将概述如何创建符号。
- en: Creating symbols
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建符号
- en: 'The `createSymbols()` function creates the entry point of the program, which
    is a symbol. To do that, it uses two `DOSHeader` methods, `e_ip()` (line `00`)
    and `e_cs()` (lines `01`–`02`), whose values are relative to the segment the program
    was loaded at:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSymbols()` 函数创建程序的入口点符号。为此，它使用两个 `DOSHeader` 方法，`e_ip()`（第 `00` 行）和
    `e_cs()`（第 `01`–`02` 行），它们的值是相对于程序加载的段：'
- en: '[PRE99]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'By using `e_ip()`, the program retrieves the IP start value (the entry point
    offset relative to the code segment) while the code segment is retrieved via `e_cs()`.
    By calling to the `getAddress()` method of `SegmentedAddressSpace` and giving
    to it the `IP` and `CS` values, it retrieves the entry point at `addr` (line `00`).
    Finally, it creates the label for the entry point using the `createLabel()` method
    of the `SymbolTable` class (lines `01`–`02`) and adds the entry point symbol (line
    `03`) to the program:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `e_ip()`，程序获取 IP 起始值（相对于代码段的入口点偏移量），而代码段通过 `e_cs()` 获取。通过调用 `SegmentedAddressSpace`
    的 `getAddress()` 方法，并将 `IP` 和 `CS` 值传给它，它可以检索入口点的地址（第 `00` 行）。最后，使用 `SymbolTable`
    类的 `createLabel()` 方法（第 `01`–`02` 行）为入口点创建标签，并将入口点符号（第 `03` 行）添加到程序中：
- en: '[PRE102]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: After creating the entry point symbol, let's look at how to set the segment
    registers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建入口点符号后，我们来看一下如何设置段寄存器。
- en: Setting registers
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置寄存器
- en: The program registers are set by the `setRegisters()` function, which gets the
    stack and segment register objects (`ss`, `sp`, `ds`, and `cs`) by calling the
    `getRegister()` method of `ProgramContext`. Then, it sets the register object
    via `setValue()` with values extracted from the DOS header.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 程序寄存器由 `setRegisters()` 函数设置，该函数通过调用 `ProgramContext` 的 `getRegister()` 方法获取栈和段寄存器对象（`ss`，`sp`，`ds`，`cs`）。然后，它通过
    `setValue()` 方法将从 DOS 头中提取的值设置到寄存器对象中。
- en: 'The following code snippet illustrates how to retrieve the `ss` register (line
    `00`) and set the appropriate MZ header-retrieved value (line `04`) to it (line
    `01`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何检索 `ss` 寄存器（第 `00` 行）并将从 MZ 头中检索到的相应值（第 `04` 行）设置给它（第 `01` 行）：
- en: '[PRE106]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The MzLoader source code
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: MzLoader 源代码
- en: 'In the previous code snippets, a lot of implementation details were omitted
    in order to keep the focus on the key aspects and relevant parts. If you want
    to dig into the details, please, follow this link: [https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，为了专注于关键方面和相关部分，省略了许多实现细节。如果你想深入了解详情，请访问此链接：[https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/MzLoader.java)。
- en: As you will notice, the loader development complexity strongly depends on the
    binary format. We learned about loaders by analyzing a real-world example; therefore,
    the complexity of the code shown here is real-world complexity.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，加载器开发的复杂性在很大程度上取决于二进制格式。我们通过分析一个真实的例子来学习加载器，因此，这里展示的代码复杂性是真实世界的复杂性。
- en: Understanding filesystem loaders
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件系统加载器
- en: 'Ghidra also allows us to load filesystems. Filesystems are, basically, archive
    files (a file containing other files):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 还允许我们加载文件系统。文件系统本质上是归档文件（包含其他文件的文件）：
- en: '![ Figure 11.9 – A file named hello_world.zip imported as a filesystem'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 一个名为 hello_world.zip 的文件作为文件系统导入'
- en: '](img/B16207_11_009.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16207_11_009.jpg)'
- en: Figure 11.9 – A file named hello_world.zip imported as a filesystem
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 一个名为 hello_world.zip 的文件作为文件系统导入
- en: 'A good example of a filesystem loader implemented by Ghidra is the ZIP compressed
    format loader, which is available here: [https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 实现的一个很好的文件系统加载器示例是 ZIP 压缩格式加载器，可以在这里找到：[https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip](https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/FileFormats/src/main/java/ghidra/file/formats/zip)。
- en: 'To develop a filesystem, you will need to implement the `GFileSystem` interface
    with the following methods: `getDescription`, `getFileCount`, `getFSRL`, `getInfo`,
    `getInputStream`, `getListing`, `getName`, `getRefManager`, `getType`, `isClosed`,
    `isStatic` `lookup`, and `close`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个文件系统，你需要实现 `GFileSystem` 接口，并包含以下方法：`getDescription`、`getFileCount`、`getFSRL`、`getInfo`、`getInputStream`、`getListing`、`getName`、`getRefManager`、`getType`、`isClosed`、`isStatic`、`lookup`
    和 `close`。
- en: FileSystem Resource Locator
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统资源定位符
- en: 'A remarkable method of the `GFileSystem` interface is `getFSRL`, which allows
    you to retrieve the **FileSystem Resource Locator** (**FSRL**). An FSRL is a string
    allowing Ghidra to access files and directories stored in a filesystem:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`GFileSystem` 接口的一个显著方法是 `getFSRL`，它允许你检索 **文件系统资源定位符** (**FSRL**)。FSRL 是一个字符串，允许
    Ghidra 访问存储在文件系统中的文件和目录：'
- en: 'The FSRL for accessing a file located in the local filesystem: `file://directory/subdirectory/file`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问本地文件系统中文件的 FSRL：`file://directory/subdirectory/file`。
- en: 'The FSRL for accessing a file located in a ZIP archive file: `file://directory/subdirectory/example.zip|zip://file`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问位于 ZIP 压缩文件中的文件的 FSRL：`file://directory/subdirectory/example.zip|zip://file`。
- en: 'The FSRL for accessing a file in nested filesystems (for example, `tar` stored
    in a `zip` file): `file://directory/subdirectory/example.zip|zip:// directory
    /nested.tar|tar://file`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问嵌套文件系统中文件的 FSRL（例如，存储在 `zip` 文件中的 `tar`）：`file://directory/subdirectory/example.zip|zip://
    directory/nested.tar|tar://file`。
- en: 'The FSRL for accessing a file but checking its `MD5`: `file://directory/subdirectory/example.zip?MD5=
    6ab0553f4ffedd5d1a07ede1230c4887 |zip://file?MD5= 0ddb5d230a202d20a8de31a69d836379`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问文件并检查其 `MD5` 的 FSRL：`file://directory/subdirectory/example.zip?MD5=6ab0553f4ffedd5d1a07ede1230c4887|zip://file?MD5=0ddb5d230a202d20a8de31a69d836379`。
- en: Another remarkable method is `getRefManager`, which allows accessing `GFileSystem`
    but preventing it from being closed via the `close` method.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个显著的方法是 `getRefManager`，它允许访问 `GFileSystem`，但通过 `close` 方法阻止其关闭。
- en: Finally, `FileSystemService` can be used to instantiate filesystems.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`FileSystemService` 可以用来实例化文件系统。
- en: Filesystem loaders
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件系统加载器
- en: 'If you want to learn more about loaders, please check out the following official
    documentation links:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于加载器的内容，请查看以下官方文档链接：
- en: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html)
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/GFileSystem.html)
- en: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html)
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FSRL.html)
- en: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html)
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – [https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html](https://ghidra.re/ghidra_docs/api/ghidra/formats/gfilesystem/FileSystemService.html)
- en: This is the way that filesystem loaders are implemented. If you want to look
    further into the details, please remember to check the ZIP filesystem implementation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件系统加载器的实现方式。如果你想进一步了解详细信息，请记得查看ZIP文件系统的实现。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned what a binary file is and how it can be dichotomously
    classified as a raw binary or a formatted binary, and you also learned that any
    formatted binary is also a raw binary.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是二进制文件，以及它如何被二分为原始二进制文件或格式化二进制文件，你还了解到任何格式化的二进制文件也是原始二进制文件。
- en: You learned skills for Ghidra file importing by loading both raw binaries and
    formatted binaries. This new skill allows you to configure better options when
    loading a file and manually perform some adjustments if necessary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过加载原始二进制文件和格式化二进制文件，学习了Ghidra文件导入的技能。这项新技能使你能够在加载文件时配置更好的选项，并在必要时手动进行一些调整。
- en: You also learned about the old-style DOS executable format by producing a `hello
    world` program from scratch written in assembly language and later analyzing it
    with a hexadecimal editor.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你还通过从头开始编写一个用汇编语言编写的`hello world`程序，并通过十六进制编辑器分析它，了解了旧式DOS可执行文件格式。
- en: Finally, you learned how to extend Ghidra with new loaders and filesystems,
    allowing you to import unsupported and exoteric binary formats and archive files.
    You learned this by analyzing the old-style DOS executable format loader, a good
    real-world example to start with.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了如何通过新增加载器和文件系统来扩展Ghidra，允许你导入不支持的和冷门的二进制格式以及归档文件。你通过分析旧式DOS可执行文件格式加载器，开始了这个很好的实际案例学习。
- en: In the next chapter, we will cover an advanced topic in Ghidra, which is processor
    module development. This skill will enable you to incorporate unsupported processors
    into Ghidra. It includes virtualization processors commonly used in advanced binary
    obfuscation. Beyond that, you will learn a lot about disassemblers along the way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论Ghidra中的一个高级话题，即处理器模块开发。这项技能将使你能够将不支持的处理器集成到Ghidra中。它包括在高级二进制混淆中常用的虚拟化处理器。除此之外，你还将在这个过程中学到很多关于反汇编器的知识。
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between raw binaries and formatted binaries?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始二进制文件和格式化二进制文件有什么区别？
- en: Taking into account that any formatted binary is also a raw binary, why are
    formatted binaries necessary?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到任何格式化的二进制文件也是原始二进制文件，为什么还需要格式化的二进制文件呢？
- en: What is an old-style DOS executable and what software pieces comprise the loader
    enabling Ghidra to support it?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是旧式DOS可执行文件？是什么软件组件组成了使Ghidra能够支持它的加载器？
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下链接，获取有关本章讨论主题的更多信息：
- en: '*Mastering Assembly Programming*, *Alexey Lyashko*, *September 2017*: [https://subscription.packtpub.com/book/application_development/9781787287488](https://subscription.packtpub.com/book/application_development/9781787287488)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握汇编编程*，*Alexey Lyashko*，*2017年9月*：[https://subscription.packtpub.com/book/application_development/9781787287488](https://subscription.packtpub.com/book/application_development/9781787287488)'
- en: 'The DOS MZ executable – format specification using the Kaitai Struct declarative
    language: [https://formats.kaitai.io/dos_mz/index.html](https://formats.kaitai.io/dos_mz/index.html)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOS MZ可执行文件 – 使用Kaitai Struct声明性语言的格式规范：[https://formats.kaitai.io/dos_mz/index.html](https://formats.kaitai.io/dos_mz/index.html)
- en: 'Online Ghidra loader documentation: [https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线Ghidra加载器文档：[https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html](https://ghidra.re/ghidra_docs/api/ghidra/app/util/opinion/Loader.html)
