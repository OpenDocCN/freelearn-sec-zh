- en: Using Boto3 and Pacu to Maintain AWS Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boto3和Pacu维持AWS持久性
- en: Establishing persistence in an AWS environment allows you to maintain privileged
    access, even in scenarios where your active attack gets detected and your primary
    means of access to an environment is shut down. It's not always possible to stay
    completely under the radar, so in those situations where we get caught, we need
    a backup plan (or two, or three, or...). Ideally, this backup plan is stealthy
    to establish and stealthy to exercise if we need to gain access to the environment
    again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS环境中建立持久性允许您保持特权访问，即使在您的主动攻击被检测到并且您对环境的主要访问方式被关闭的情况下。并不总是可能完全保持低调，所以在我们被抓到的情况下，我们需要一个备用计划（或两个，或三个，或……）。理想情况下，这个备用计划是隐蔽的，以便在需要再次访问环境时建立和执行。
- en: There are many techniques and methodologies relating to malware, evasion, and
    persistence that could be applied to this chapter, but we are going to stick with
    the different methods we can abuse in AWS and not necessarily the methodology
    behind a whole red-team-style penetration testing engagement. Persistence techniques
    in AWS differ greatly from traditional types of persistence, such as on a Windows
    server, but those techniques (as we already know) can also be applied to any servers
    within the AWS environment we are attacking.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与恶意软件、逃避和持久性相关的技术和方法论可以应用到本章，但我们将专注于在AWS中可以滥用的不同方法，而不一定是整个红队风格的渗透测试的方法论。在AWS中的持久性技术与传统的持久性类型有很大不同，比如在Windows服务器上，但这些技术（正如我们已经知道的）也可以应用于我们攻击的AWS环境中的任何服务器。
- en: In this chapter, we are going to focus on persistence within the actual AWS
    environment, rather than on servers that lie within the environment. These types
    of persistence include techniques such as backdoor user credentials, backdoor
    role trust relationships, backdoor EC2 Security Groups, backdoor Lambda functions,
    and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于实际AWS环境中的持久性，而不是环境中的服务器。这些类型的持久性包括后门用户凭据、后门角色信任关系、后门EC2安全组、后门Lambda函数等等。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Backdooring users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后门用户凭据
- en: Backdooring role trust relationships
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后门角色信任关系
- en: Backdooring EC2 Security Groups
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后门EC2安全组
- en: Using Lambda functions as persistent watchdogs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda函数作为持久性看门狗
- en: Backdooring users
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后门用户
- en: Before we begin, let's define what backdooring really is. In the context of
    this chapter, it means almost exactly what it sounds like in that we are opening
    up a backdoor into an environment so that if the frontdoor is closed, we can still
    get in. In AWS, the backdoor could be any number of things that are covered throughout
    this chapter, and the frontdoor would be our primary means of access to the environment
    (that is, compromised IAM user credentials). We want our backdoors to outlast
    a situation where our compromise is detected by a defender and the compromised
    user is shut down, because we can still hopefully enter through the backdoor in
    that case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们定义一下后门到底是什么。在本章的背景下，它的意思几乎与字面上的意思相同，即我们正在打开一个后门进入环境，以便在前门关闭时，我们仍然可以进入。在AWS中，后门可以是本章中涵盖的任何一种东西，前门将是我们对环境的主要访问方式（即被攻破的IAM用户凭据）。我们希望我们的后门能够在我们的妥协被防御者检测到并关闭被攻破的用户的情况下持续存在，因为在这种情况下，我们仍然可以通过后门进入。
- en: As we have demonstrated and used repeatedly in previous chapters, IAM users
    can be set up with an access key ID and a secret access key that allows them access
    to the AWS APIs. Best practice is to generally use alternative methods of authentication,
    such as **single sign-on** (**SSO**), which grants temporary federated access
    to an environment, but best practices aren't always followed. We will continue
    with a similar scenario to the one we used in the previous chapters, where we
    had the credentials to one IAM user, `Test`. We will also continue with the idea
    that our user has administrator-level access to the environment, through the privilege
    escalation we exploited in [Chapter 10](05397993-74ba-4bae-a6f9-cc0d23f8f420.xhtml), *Privilege
    Escalation of AWS Accounts Using Stolen Keys, Boto3 and Pacu*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中反复演示和使用的那样，IAM用户可以设置访问密钥ID和秘密访问密钥，允许他们访问AWS API。最佳实践通常是使用替代的身份验证方法，比如单点登录（SSO），它授予对环境的临时联合访问，但并非总是遵循最佳实践。我们将继续使用与之前章节中相似的场景，我们在那里拥有一个IAM用户`Test`的凭据。我们还将继续使用我们的用户通过特权升级获得对环境的管理员级别访问的想法，这是我们在[第10章](05397993-74ba-4bae-a6f9-cc0d23f8f420.xhtml)中利用的特权升级AWS账户使用被盗的密钥、Boto3和Pacu。
- en: Multiple IAM user access keys
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个IAM用户访问密钥
- en: 'Each IAM user in an account has a limit of two access key pairs. Our test user
    already has one created, so one more can be created before our limit has been
    hit. Considering the scenario where the keys we have been using are someone else''s
    and we happened to gain access to them, a simple form of persistence we could
    use would be to just create a second set of keys for our user. By doing so, we
    would have two sets of keys for the same user: one that we compromised, and one
    that we created ourselves.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 账户中的每个IAM用户有两对访问密钥的限制。我们的测试用户已经创建了一个，所以在我们达到限制之前还可以创建一个。考虑到我们一直在使用的密钥是别人的，我们碰巧获得了对它们的访问，我们可以使用的一种简单的持久性形式就是为我们的用户创建第二组密钥。这样做，我们将拥有同一个用户的两组密钥：一组是我们被攻破的，另一组是我们自己创建的。
- en: This is a little too simple, though, because if we were to get detected and
    someone on the defensive side was to just remove our user, it would delete both
    of our methods of access to the environment in one go. We can instead target a
    different privileged user in the environment to create our backdoor keys for.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有点太简单了，因为如果我们被检测到，防御方的人员只需移除我们的用户，就可以一举删除我们对环境的两种访问方法。相反，我们可以选择针对环境中的不同特权用户创建我们的后门密钥。
- en: 'First, we will want to see what users exist in the account, so we will run
    the following AWS CLI command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要查看账户中存在哪些用户，所以我们将运行以下AWS CLI命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will return some identifying information about each IAM user in
    the account. Each one of these users is a possible target for our backdoor keys,
    but we need to consider users who already have two sets of access keys. If a user
    already has two sets and someone tries to create a third set, an API error is
    thrown, which could end up being very noisy to a listening defender, ultimately
    getting us caught.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回账户中每个IAM用户的一些标识信息。这些用户中的每一个都是我们后门密钥的潜在目标，但我们需要考虑已经有两组访问密钥的用户。如果一个用户已经有两组密钥，而有人尝试创建第三组，API将抛出一个错误，这可能会对倾听的捍卫者产生很大的噪音，最终使我们被抓住。
- en: 'I want to target the user `Mike`, who was one of the users returned from our
    AWS CLI command. Before trying t7o add access keys to `Mike`, I will check to
    make sure that he doesn''t already have two sets of access keys with the following
    command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我想针对用户`Mike`进行操作，他是我们AWS CLI命令返回的用户之一。在尝试给`Mike`添加访问密钥之前，我将通过以下命令检查他是否已经有两组访问密钥：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the output of that command, and that `Mike`
    already has two sets of access keys:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了该命令的输出，以及`Mike`已经有两组访问密钥：
- en: '![](img/3632ae0c-963e-44bc-bfda-da9d5f7d52af.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3632ae0c-963e-44bc-bfda-da9d5f7d52af.png)'
- en: 'Figure 1: Listing the access keys for Mike shows that he already has two set
    up'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：列出Mike的访问密钥显示他已经有两组
- en: This means that we should not target `Mike`. This is because trying to create
    another set of keys would fail, resulting in an error from the AWS API. A vigilante
    defender may be able to correlate that error to your malicious activity, ultimately
    getting you caught.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不应该针对`Mike`进行操作。这是因为尝试创建另一组密钥将失败，导致AWS API出现错误。一个自以为是的捍卫者可能能够将该错误与您的恶意活动相关联，最终使您被抓住。
- en: 'There is another user that appeared previously with a user name of `Sarah`,
    so let''s check how many access keys she has set up:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前出现过另一个用户名为`Sarah`的用户，所以让我们来检查她设置了多少个访问密钥：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time, the results show up as an empty array, which indicates that there
    are no access keys set up for `Sarah`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，结果显示为空数组，这表明`Sarah`没有设置访问密钥：
- en: '![](img/cf323cea-9d65-4a23-a590-6c264ce137ff.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf323cea-9d65-4a23-a590-6c264ce137ff.png)'
- en: 'Figure 2: No access keys show up when we try to list Sarah''s'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：当我们尝试列出Sarah的时候，没有访问密钥显示出来
- en: 'Now we know we can target `Sarah` for our persistence, so let''s run the following
    command to create a new pair of keys:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以针对`Sarah`进行持久化，所以让我们运行以下命令来创建一对新的密钥：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The response should look something like the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该类似于以下截图：
- en: '![](img/f9abfe8b-34b8-499b-b8ba-b2525f62a482.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9abfe8b-34b8-499b-b8ba-b2525f62a482.png)'
- en: 'Figure 3: An access key ID and secret access key that belong to Sarah'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：属于Sarah的访问密钥ID和秘密访问密钥
- en: Now we can use the keys that were returned to access any permission associated
    with `Sarah`. Keep in mind that this method can be used for privilege escalation
    in addition to persistence in a scenario where your initial access user has a
    low number of privileges, but `iam:CreateAccessKey` is one of them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用返回的密钥来访问与`Sarah`相关的任何权限。请记住，这种方法可以用于特权升级，以及在您的初始访问用户权限较低的情况下进行持久化，但`iam:CreateAccessKey`是其中之一。
- en: 'Let''s store credentials of `Sarah` locally with the AWS CLI so we don''t need
    to worry about them in the meantime. To do so, we can run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Sarah`的凭据存储在本地，以便我们在此期间不需要担心它们。为此，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we can fill in the values that we are prompted for. Similarly, we can add
    these keys into Pacu with the `set_keys` command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以填写我们被提示的值。同样，我们可以使用`set_keys`命令将这些密钥添加到Pacu中。
- en: Do it with Pacu
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pacu进行操作
- en: 'Pacu has a module that automates this entire process for us as well. This module
    is known as the `iam__backdoor_users_keys` module, and automates the process we
    just went through. To try it out, run the following command within Pacu:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu还有一个模块可以为我们自动完成整个过程。这个模块称为`iam__backdoor_users_keys`模块，自动完成了我们刚刚进行的过程。要尝试它，请在Pacu中运行以下命令：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, we will get a list of users to choose from, but alternatively we
    could have supplied a username in the original command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将得到一个用户列表供选择，但也可以在原始命令中提供用户名。
- en: Now when our original access to the environment is discovered, we have backup
    credentials to a (hopefully highly privileged) user. If we wanted, we could use
    techniques from previous chapters to enumerate the permissions for that user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们的原始访问环境被发现时，我们有了一个（希望是高特权的）用户的备份凭据。如果我们愿意，我们可以使用之前章节的技术来枚举该用户的权限。
- en: Backdooring role trust relationships
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后门角色信任关系
- en: IAM roles are an integral part of AWS. In the very simplest terms, roles can
    be assumed to supply a specific set of permissions to someone/something for a
    temporary amount of time (the default being 1 hour). This someone or something
    could be a person, an application, an AWS service, another AWS account, or really
    anything that programmatically accesses AWS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IAM角色是AWS的一个重要组成部分。简单来说，角色可以被认为是为某人/某物在一段时间内（默认为1小时）提供特定权限的。这个某人或某物可以是一个人，一个应用程序，一个AWS服务，另一个AWS账户，或者任何以编程方式访问AWS的东西。
- en: IAM role trust policies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM角色信任策略
- en: 'An IAM role has a document associated with it that is known as its trust policy.
    The trust policy is a JSON policy document (for example IAM policies such as `ReadOnlyAccess`
    or `AdministratorAccess`) that specifies who/what can assume that role and under
    what conditions that is allowed or denied. A common trust policy document that
    allows the AWS EC2 service permission to assume a certain role might look like
    the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: IAM角色有一个与之关联的文档，称为其信任策略。信任策略是一个JSON策略文档（例如IAM策略，如`ReadOnlyAccess`或`AdministratorAccess`），指定谁/什么可以假定该角色，以及在什么条件下允许或拒绝。允许AWS
    EC2服务假定某个角色的常见信任策略文档可能如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This policy allows the EC2 service access to assume the role it belongs to.
    A scenario where this policy might be used is when an IAM role is added to an
    EC2 instance profile, which is then attached to an EC2 instance. Then, temporary
    credentials for the attached role are accessible from within the instance and
    the EC2 service will use it for anything that it needs access to.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略允许EC2服务访问它所属的角色。这个策略可能会在IAM角色被添加到EC2实例配置文件，然后附加到EC2实例时使用。然后，附加角色的临时凭证可以从实例内部访问，EC2服务将使用它来访问所需的任何内容。
- en: 'Some features of IAM roles that work out very nicely for us attackers are as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们攻击者来说，IAM角色的一些特性非常适合我们：
- en: Role trust policies can be updated at will
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色信任策略可以随意更新
- en: Role trust policies can provide access to other AWS accounts
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色信任策略可以提供对其他AWS账户的访问
- en: In terms of establishing persistence, this is perfect. That means, generally,
    that all we need to do is update the trust policy of a privileged role in a target
    account to create a trust relationship between that role and our own personal
    attacker AWS account.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就建立持久性而言，这是完美的。这意味着，通常情况下，我们只需要更新目标账户中特权角色的信任策略，就可以在该角色和我们自己的攻击者AWS账户之间建立信任关系。
- en: In our example scenario, we have two AWS accounts created. One of them (account
    ID `012345678912`) is our own personal attacker account, which means we personally
    registered this through AWS. The other (account ID `111111111111`) is the account
    that we have compromised keys for. We want to establish cross-account persistence
    to guarantee our future access to the environment. This means that even after
    the compromise is detected by a defender, we can still regain access to the environment
    through cross-account methods, allowing us to maintain access to our target environment
    without opening any other security holes in the process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，我们创建了两个AWS账户。其中一个（账户ID `012345678912`）是我们自己的个人攻击者账户，这意味着我们通过AWS个人注册了这个账户。另一个（账户ID
    `111111111111`）是我们已经获取了密钥的账户。我们想要建立跨账户持久性，以确保我们将来能够访问环境。这意味着即使防御者检测到了我们的入侵，我们仍然可以通过跨账户方法重新访问环境，从而在不打开任何其他安全漏洞的情况下保持对目标环境的访问。
- en: Finding a suitable target role
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找合适的目标角色
- en: The first step in establishing this kind of persistence will be to find a suitable
    role to target. Not all roles allow you to update their trust policy document,
    which means we don't want to target those roles. They are generally service-linked
    roles, which are a unique type of IAM role that is linked directly to an AWS service
    ([https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 建立这种持久性的第一步将是找到一个合适的目标角色。并非所有角色都允许你更新它们的信任策略文档，这意味着我们不想以它们为目标。它们通常是服务关联角色，这是一种直接与AWS服务关联的独特类型的IAM角色（[https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)）。
- en: 'These roles can be quickly identified from the IAM roles page of the AWS web
    console in a few different ways. First, you will likely see that they begin with `AWSServiceRoleFor` in
    their name and will be followed by the AWS service they are for. Another indicator
    is in the trusted entities column of the role list; it will say something like
    `AWS service:<service name>(Service-Linked role)`. If you see the `Service-Linked
    role` note, then you know you cannot update the trust policy document. Finally,
    all AWS service-linked roles will include the path `/aws-service-role/`. No other
    roles are allowed to use that path for a new role:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些角色可以通过AWS Web控制台的IAM角色页面以几种不同的方式快速识别。首先，你可能会发现它们的名称以`AWSServiceRoleFor`开头，后面跟着它们所属的AWS服务。另一个指示是在角色列表的受信实体列中；它会说类似于`AWS
    service:<service name>(Service-Linked role)`。如果你看到`Service-Linked role`的说明，那么你就知道你不能更新信任策略文档。最后，所有AWS服务关联角色都将包括路径`/aws-service-role/`。其他角色不允许使用该路径创建新角色：
- en: '![](img/928e2843-f15c-4672-a0c7-264f13130378.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/928e2843-f15c-4672-a0c7-264f13130378.png)'
- en: 'Figure 4: Two service-linked roles in our test account'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：我们测试账户中的两个服务关联角色
- en: 'Don''t get tricked, though! By only relying on the name to indicate what roles
    are service roles, you could get fooled. The perfect example is the following
    screenshot, where the role `AWSBatchServiceRole` is shown:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不过不要被骗了！仅仅依靠名称来指示哪些角色是服务角色，你可能会上当。一个完美的例子就是下面的截图，其中显示了角色`AWSBatchServiceRole`：
- en: '![](img/d7081826-2480-44ac-aebf-f8a9289b4375.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7081826-2480-44ac-aebf-f8a9289b4375.png)'
- en: 'The name `AWSBatchServiceRole` clearly would indicate that this role is a service-linked
    role, right? Wrong. If you noticed, there is no `(Service-Linked role)` note after
    `AWS service: batch`. So, this means that we can update the trust policy for this
    role, even though it sounds like a service-linked role.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWSBatchServiceRole`这个名字显然表明这个角色是一个服务关联角色，对吗？错。如果你注意到，在`AWS service: batch`之后没有`(Service-Linked
    role)`的说明。所以，这意味着我们可以更新这个角色的信任策略，即使它听起来像是一个服务关联角色。'
- en: In our test environment, we found a role named `Admin`, which should immediately
    scream `high privileged` to you as an attacker, so we are going to target this
    role for our persistence. We don't want to screw anything up in the target environment,
    so we will want to add ourselves to the trust policy, rather than overwrite it
    with our own policy that could potentially screw things up in the environment.
    If we happened to remove access for a certain AWS service, resources that rely
    on that access may begin to fail and we don't want that for many different reasons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试环境中，我们找到了一个名为`Admin`的角色，这对于攻击者来说应该立即引起`高特权`的警觉，所以我们将以这个角色为目标进行持久性攻击。我们不想在目标环境中搞砸任何事情，所以我们希望将自己添加到信任策略中，而不是用我们自己的策略覆盖它，这可能会在环境中搞砸一些东西。如果我们不小心移除了对某个AWS服务的访问权限，依赖于该访问权限的资源可能会开始失败，而我们不希望出现这种情况，有很多不同的原因。
- en: 'The data returned from `iam:GetRole` and `iam:ListRoles` should already include
    the active trust policy document for the role we want under the `AssumeRolePolicyDocument` key
    of the JSON response object. The admin role we are targeting looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iam:GetRole`和`iam:ListRoles`返回的数据应该已经包括我们想要的角色的活动信任策略文档，在JSON响应对象的`AssumeRolePolicyDocument`键下。我们要定位的管理员角色如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we look at the value under `AssumeRolePolicyDocument` > `Statement`, we can
    see that there is a single principal allowed to assume this role currently, which
    is the **Amazon Resource Name** (**ARN**), `arn:aws:iam::111111111111:root`. This
    ARN refers to the root user of the account with the ID `111111111111`, which basically
    translates to `any resource in account ID 111111111111`. That includes the root
    user, IAM users, and IAM roles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`AssumeRolePolicyDocument` > `Statement`下的值，我们可以看到目前只允许一个主体假定这个角色，即**Amazon资源名称**（**ARN**）`arn:aws:iam::111111111111:root`。这个ARN指的是帐户ID为`111111111111`的帐户的根用户，基本上可以翻译为`帐户ID
    111111111111中的任何资源`。这包括根用户、IAM用户和IAM角色。
- en: Adding our backdoor access
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的后门访问
- en: 'We are now going to add our attacker-owned account as a trust policy to this
    role. First, we will save the value of the `AssumeRolePolicyDocument` key in the
    roles trust policy to a local JSON file (`trust-policy.json`). To add trust to
    our own account without removing the current trust, we can turn the value of the
    `Principal` `AWS` key from a string to an array. This array will include the root
    ARN that already is in place and the root ARN of our attacker account. `trust-policy.json` should
    look like the following now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把我们的攻击者拥有的账户添加为此角色的信任策略。首先，我们将把角色信任策略中`AssumeRolePolicyDocument`键的值保存到本地JSON文件（`trust-policy.json`）中。为了向我们自己的账户添加信任而不移除当前的信任，我们可以将`Principal`
    `AWS`键的值从字符串转换为数组。这个数组将包括已经存在的根ARN和我们攻击者账户的根ARN。`trust-policy.json`现在应该看起来像下面这样：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will update the role with this trust policy using the AWS CLI:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用AWS CLI更新具有此信任策略的角色：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If everything was successful, then the AWS CLI should not return any output
    to the console. Otherwise, you will see an error and a short description of what
    went wrong. If we wanted to confirm that everything went correctly, we could use
    the AWS CLI to `get` that role and view the trust policy document again:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么AWS CLI不应该向控制台返回任何输出。否则，您将看到一个错误和一个简短的描述出了什么问题。如果我们想要确认一切都正确，我们可以使用AWS
    CLI来`get`该角色并再次查看信任策略文档：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The response from that command should include the trust policy you just uploaded.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的响应应该包括您刚刚上传的信任策略。
- en: The only other thing we will need to do is to save the role's ARN somewhere
    locally, so that we don't forget it. In this example, the ARN of our target role
    was `arn:aws:iam::111111111111:role/Admin`. Now everything is done.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要做的另一件事是将角色的ARN保存在本地某个地方，这样我们就不会忘记它。在这个例子中，我们目标角色的ARN是`arn:aws:iam::111111111111:role/Admin`。现在一切都完成了。
- en: Confirming our access
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认我们的访问
- en: 'We can test our new method of persistence by trying to `assume` our target
    role from within our own attacker account. There is already a local AWS CLI profile
    named `MyPersonalUser`, which is a set of access keys that belong to my personal
    AWS account. Using those keys, I should be able to run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试从我们自己的攻击者账户内部“假定”我们的目标角色来测试我们的新持久性方法。已经有一个名为`MyPersonalUser`的本地AWS CLI配置文件，这是属于我的个人AWS账户的一组访问密钥。使用这些密钥，我应该能够运行以下命令：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We only need to supply the ARN of the role we want credentials for and a role
    session name, which can be an arbitrary string value that is associated with the
    temporary credentials that are returned. If everything went as planned, the AWS
    CLI should respond with something like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要提供我们想要凭证的角色的ARN和角色会话名称，这可以是与返回的临时凭证关联的任意字符串值。如果一切按计划进行，AWS CLI应该会以以下类似的方式做出响应：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Perfect! Now, what we have done is use our own personal account credentials
    to retrieve credentials for our target AWS account. We can run the same `aws sts` API
    call at any time, as long as we are still a trusted entity, and retrieve another
    set of temporary credentials whenever we want.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，我们所做的是使用我们自己的个人账户凭据来检索我们目标AWS账户的凭据。只要我们仍然是受信任的实体，我们随时都可以运行相同的`aws sts`
    API调用，并在需要时检索另一组临时凭据。
- en: 'We could make these keys available to the AWS CLI by modifying our `~/.aws/credentials` file.
    The profile would just require the extra `aws_session_token` key, which would
    end up with the following being added to our credentials file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的`~/.aws/credentials`文件使这些密钥对AWS CLI可用。配置文件只需要额外的`aws_session_token`键，这将导致以下内容被添加到我们的凭据文件中：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then we could manually add those credentials into Pacu or we could import them
    from the AWS CLI to Pacu.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以手动将这些凭据添加到Pacu中，或者我们可以从AWS CLI导入它们到Pacu中。
- en: Automating it with Pacu
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pacu自动化
- en: 'Just like the previous section on backdooring users, this can all be easily
    automated! In addition to that, it already has been automated for you, with the
    `iam__backdoor_assume_role` Pacu module. This module accepts three different arguments,
    but we are only going to use two of them. The `--role-names` parameter accepts
    a list of IAM roles to backdoor in our target account and the `--user-arns` parameter
    takes a list of ARNs with which to add a trust relationship for each targeted
    role. If we were to replicate the scenario we just walked through, that means
    we would run the following Pacu command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前一节关于后门用户的部分一样，这一切都可以很容易地自动化！除此之外，它已经为您自动化了，使用`iam__backdoor_assume_role`
    Pacu模块。该模块接受三个不同的参数，但我们只会使用其中的两个。`--role-names`参数接受要在我们的目标账户中设置后门的IAM角色列表，`--user-arns`参数接受要为每个目标角色添加信任关系的ARN列表。如果我们要复制刚刚经历的情景，那么我们将运行以下Pacu命令：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Pacu will automatically backdoor the `Admin` role and create a trust relationship
    with the ARN that we supplied. The output should look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu将自动设置`Admin`角色的后门，并与我们提供的ARN建立信任关系。输出应该看起来像这样：
- en: '![](img/7327d803-84a1-4735-b740-444466a00ed2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7327d803-84a1-4735-b740-444466a00ed2.png)'
- en: 'Figure 5: Running the Pacu iam__backdoor_assume_role module'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：运行Pacu iam__backdoor_assume_role模块
- en: If we didn't know what role we wanted to target, we could omit the `--role-names` argument.
    Then Pacu would gather all roles in the account and give us a list to choose from.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道我们想要攻击的角色，我们可以省略`--role-names`参数。然后Pacu将收集账户中的所有角色，并给我们一个选择列表。
- en: A somewhat important side note here, which you may or may not have been wondering
    about, is that trust policy documents do accept wildcards such as the star (*)
    character! Trust policies can be wildcarded so that anything can assume the role,
    and that literally means anything. It is never a good idea to trust everyone with
    IAM roles, especially if you are attacking an account. You don't want to open
    doors into the environment that weren't already there where other attackers might
    be able to slide in. It is important to understand what exactly a wild-carded
    role trust policy means, though, for rare cases when you encounter one like that
    in an account.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个相当重要的副注，你可能一直在想，信任策略文档确实接受通配符，比如星号（*）字符！信任策略可以使用通配符，以便任何东西都可以假定该角色，这实际上意味着任何东西。信任每个人拥有IAM角色绝不是一个好主意，特别是如果你正在攻击一个账户。你不希望打开环境中原本不存在的门，其他攻击者可能会趁机溜进来。然而，了解通配符角色信任策略的确切含义是很重要的，因为在账户中遇到这样的情况是很少见的。
- en: Backdooring EC2 Security Groups
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EC2安全组的后门
- en: EC2 Security Groups act as virtual firewalls that manage inbound and outbound
    traffic rules for one or more EC2 instances. Typically, you will find that traffic
    to specific ports on an instance are white-listed to another IP range or Security
    Groups. All access is denied by default and access can be granted by creating
    new rules. As attackers, we can't bypass Security Group rules, but that doesn't
    mean that our access is completely blocked.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: EC2安全组充当管理一个或多个EC2实例的入站和出站流量规则的虚拟防火墙。通常，你会发现对实例上特定端口的流量被列入白名单，以允许来自其他IP范围或安全组的流量。默认情况下拒绝所有访问，可以通过创建新规则来授予访问权限。作为攻击者，我们无法绕过安全组规则，但这并不意味着我们的访问完全被阻止。
- en: All we need to do is add our own Security Group rule to the target Security
    Groups. It will ideally be a rule that allows traffic from our IP address/range
    to a set of ports on the instances that the Security Group applies to. You might
    think that you want to just whitelist access for all ports (`0`-`65535`) and all
    protocols (TCP, UDP, and so on), but in general this is a bad idea because of
    some very basic detections that are out there. It is considered a bad practice
    to allow traffic to every single port in your Security Group, so there are many
    tools out there that will alert on that kind of Security Group rule.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是向目标安全组添加我们自己的安全组规则。理想情况下，这将是一个允许我们的IP地址/范围到安全组适用的实例上的一组端口的规则。你可能认为你想要为所有端口（`0`-`65535`）和所有协议（TCP、UDP等）添加白名单访问，但一般来说，这是一个坏主意，因为有一些非常基本的检测存在。允许流量到安全组的每个端口被认为是一种不好的做法，因此有许多工具会对这种安全组规则发出警报。
- en: Knowing that detecting when all ports are allowed inbound is a typical best
    practices check, we can refine our access to a subset of common ports. These ports
    might just be a shorter range, such as `0`-`1024`, a single common port such as
    port `80`, a port of a service you know they run on your target's servers, or
    really anything you want.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 知道检测所有端口都允许入站是典型的最佳实践检查，我们可以将我们的访问精细化到一些常见端口的子集。这些端口可能只是一个较短的范围，比如`0`-`1024`，一个常见端口，比如端口`80`，你知道他们在目标服务器上运行的服务的端口，或者你想要的任何东西。
- en: 'Using our same old `Test` user, let''s say we discovered an EC2 instance that
    we want to attack. This could be through something like just describing EC2 instances
    in the current region with the following AWS CLI command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们同样的`Test`用户，假设我们发现了一个我们想要攻击的EC2实例。这可能是通过像下面的AWS CLI命令描述当前区域中的EC2实例：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command returns quite a bit of information, but the important information
    is the instance ID `(i-08311909cfe8cff10`) of our target, the public IP of our
    target (`2.3.4.5`), and the list of Security Groups that are attached to it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令返回了相当多的信息，但重要的信息是我们目标的实例ID（`i-08311909cfe8cff10`），我们目标的公共IP（`2.3.4.5`），以及附加到它的安全组的列表：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is a single group attached to the target instance named `corp`; we can
    guess that it stands for corporate. Now we have the name and ID of the Security
    Group, but we want to see what rules already exist on it. We can find this information
    by running the following AWS CLI command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个附加到目标实例的单个组名为`corp`；我们可以猜测它代表公司。现在我们有了安全组的名称和ID，但我们想要看看它上面已经存在的规则。我们可以通过运行以下AWS
    CLI命令找到这些信息：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The response from that command should display what inbound and outbound rules
    have been added to the Security Group. The `IpPermissions` key of the response
    contains the inbound traffic rules and the `IpPermissionsEgress` key contains
    the outbound traffic rules. The inbound traffic rules for our target `corp` Security
    Group are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的响应应该显示已添加到安全组的入站和出站规则。响应的`IpPermissions`键包含入站流量规则，`IpPermissionsEgress`键包含出站流量规则。我们目标`corp`安全组的入站流量规则如下：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we are being shown is that inbound TCP access is allowed from the IP range
    `10.0.0.1/24` to any port in the range `27017` to `27018`. Maybe you recognize
    those ports! Those ports typically belong to MongoDB, a type of NoSQL database.
    The problem is that access is whitelisted to an internal IP range, which means
    we would already need a foothold in the network to be able to access these ports.
    This is where we will add our backdoor Security Group rule so that we can access
    MongoDB directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的是允许来自IP范围`10.0.0.1/24`到范围`27017`到`27018`的任何端口的入站TCP访问。也许你认识这些端口！这些端口通常属于MongoDB，一种NoSQL数据库。问题是访问被列入白名单到一个内部IP范围，这意味着我们已经需要在网络中有一个立足点才能访问这些端口。这就是我们将添加我们的后门安全组规则，以便我们可以直接访问MongoDB的地方。
- en: 'To do this, we can use the `ec2:AuthorizeSecurityGroupIngress` API. We will
    say that our own attacker IP address is `1.1.1.1` and we already know what ports
    we want to open access to, so we can run the following AWS CLI command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用`ec2:AuthorizeSecurityGroupIngress` API。我们将说我们自己的攻击者IP地址是`1.1.1.1`，我们已经知道要打开访问权限的端口，所以我们可以运行以下AWS
    CLI命令：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If everything went correctly, you won't see any output from this command, but
    an error will appear if something went wrong. Now that our backdoor rule has been
    successfully applied, every EC2 instance that is in the Security Group we targeted
    should now allow us access. Keep in mind that it is possible to specify `0.0.0.0/0`
    as your IP address range and it will give access to any IP address. As an attacker,
    we don't ever want to do this because it would open doors into the environment
    that other attackers might find and abuse, so we always want to make sure that
    even our backdoor access rules are fine-grained.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将不会看到此命令的任何输出，但如果出现问题，将会出现错误。现在我们的后门规则已成功应用，我们所针对的安全组中的每个EC2实例现在应该允许我们访问。请记住，可以指定`0.0.0.0/0`作为您的IP地址范围，并且它将允许任何IP地址访问。作为攻击者，我们绝对不希望这样做，因为这将打开其他攻击者可能发现和滥用的环境入口，因此我们始终要确保即使我们的后门访问规则也是细粒度的。
- en: 'Now we can attempt to access MongoDB remotely to test if our backdoor rule
    was successful and hopefully gain access to a previously private MongoDB server.
    The following screenshot shows us connecting to the Mongo database on port `27017`,
    where a couple of misconfigurations of the server work to our benefit. As can
    be seen in the outlined section of the screenshot, access control (authentication)
    is not set up, which means we can read and write to the database without credentials
    being required. The next message shows that the Mongo process is running as root,
    which means that if we were able to perform any kind of file read or code execution
    on the Mongo server, it would be run as the root user:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试远程访问MongoDB，以测试我们的后门规则是否成功，并希望获得对以前私有的MongoDB服务器的访问权限。以下屏幕截图显示我们连接到端口`27017`上的Mongo数据库，服务器的一些错误配置对我们有利。如屏幕截图的轮廓部分所示，访问控制（身份验证）未设置，这意味着我们可以在不需要凭据的情况下读取和写入数据库。下一条消息显示Mongo进程正在以root用户身份运行，这意味着如果我们能够在Mongo服务器上执行任何文件读取或代码执行，它将以root用户身份运行：
- en: '![](img/a765957b-d8e1-44fc-afe1-98fc2732d516.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a765957b-d8e1-44fc-afe1-98fc2732d516.png)'
- en: 'Again, just like the previous sections, this can be, and already has been,
    automated for you with Pacu! We can target one or more Security Groups, but by
    default, Pacu will backdoor all the groups in the current region with the rule
    that you specify. To replicate the process we just went through, we could run
    the following Pacu command (Pacu uses the Security Group name instead of the ID,
    so we supply `corp` instead):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的部分一样，这对您来说可能已经被Pacu自动化了！我们可以针对一个或多个安全组，但默认情况下，Pacu将使用您指定的规则在当前区域中的所有组中设置后门。要复制我们刚刚经历的过程，我们可以运行以下Pacu命令（Pacu使用安全组名称而不是ID，因此我们提供`corp`）：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then Pacu will add our backdoor rule to the target Security Group. Don''t ever
    forget the `--ip` argument though, because you don''t want to open anything up
    to the World (`0.0.0.0/0`). The following screenshot shows the output of the preceding
    Pacu command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Pacu将向目标安全组添加我们的后门规则。但是永远不要忘记`--ip`参数，因为您不希望向世界（`0.0.0.0/0`）打开任何东西。以下屏幕截图显示了前面Pacu命令的输出：
- en: '![](img/8bbbbcd4-3706-4055-8fa5-69ef058fd30d.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bbbbcd4-3706-4055-8fa5-69ef058fd30d.png)'
- en: 'Figure 6: The output from Pacu when backdooring the corp Security Group'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Pacu在后门公司安全组时的输出
- en: 'Then if you were to view the rules applied to that Security Group in the AWS
    web console, you would see something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您要查看应用于该安全组的规则，您将看到类似于这样的内容：
- en: '![](img/9022b74d-78b2-4d7d-b26f-2d16f23e40a1.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9022b74d-78b2-4d7d-b26f-2d16f23e40a1.png)'
- en: 'Figure 7: A backdoor rule on our target Security Group'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：我们目标安全组上的后门规则
- en: Using Lambda functions as persistent watchdogs
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda函数作为持久看门狗
- en: Now, creating our persistent backdoors in an account is extremely useful, but
    what if even those get detected and removed from the environment? We can use AWS
    Lambda as a watchdog to monitor activity in the account and to run commands in
    response to certain events, allowing us to react to a defender's actions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在帐户中创建我们的持久后门非常有用，但是如果即使这些后门被检测到并从环境中删除了呢？我们可以使用AWS Lambda作为看门狗来监视帐户中的活动，并对某些事件做出响应，从而允许我们对防御者的行动做出反应。
- en: Basically, AWS Lambda is how you run serverless code in AWS. In simple terms,
    you upload your code (whether that is Node.js, Python, or whatever) and set up
    a trigger for your function so that, when that trigger is hit, your code executes
    in the cloud and does something with the incoming data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，AWS Lambda是您在AWS中运行无服务器代码的方式。简单来说，您上传您的代码（无论是Node.js、Python还是其他任何东西），并为您的函数设置一个触发器，当触发器被触发时，您的代码在云中执行并对传入的数据进行处理。
- en: 'We attackers can use this to our advantage in many ways. We can use it to alert
    on activity in the account:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们攻击者可以利用这一点做很多事情。我们可以用它来警示帐户中的活动：
- en: The activity may help us to exploit the account
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些活动可能有助于我们利用该帐户
- en: It might mean we have been detected by a defender
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能意味着我们已经被防御者发现。
- en: There are many more things you can do with Lambda functions, but this is what
    we will focus on for now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数还有很多其他用途，但现在我们将专注于这个。
- en: Automating credential exfiltration with Lambda
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lambda自动化凭据外泄
- en: Starting with the first point in the previous section, we want a Lambda function
    to trigger on an event that might be worthy of exploiting. We will tie this into
    our methods of persistence described earlier in this chapter, so for backdooring
    IAM users, the event that might be worthy of exploiting might be when a new user
    is created. We could trigger our Lambda function with that event (with CloudWatch
    Events), which then runs our code that is set up to automatically add a new set
    of access keys to that user, then exfiltrates those credentials to a server we
    specified.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节的第一点开始，我们希望一个Lambda函数在可能值得利用的事件上触发。我们将把这与本章前面描述的持久性方法联系起来，因此对于后门IAM用户，可能值得利用的事件可能是创建新用户时。我们可以使用CloudWatch
    Events触发我们的Lambda函数，然后运行我们的代码，该代码设置为自动向该用户添加一组新的访问密钥，然后将这些凭证外发到我们指定的服务器。
- en: 'This scenario ties together like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况如下绑定在一起：
- en: The attacker (us) creates a malicious Lambda function in a target account
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者（我们）在目标账户中创建了一个恶意Lambda函数
- en: The attacker creates a trigger to run the Lambda function every time a new IAM
    user is created
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者创建了一个触发器，每当创建新的IAM用户时就运行Lambda函数
- en: The attacker sets up a listener on a server that they control, which will wait
    for credentials
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者在他们控制的服务器上设置一个监听器，等待凭证
- en: 2 days pass
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过2天
- en: A regular user in the environment creates a new IAM user
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境中的普通用户创建了一个新的IAM用户
- en: The attacker's Lambda function is triggered
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者的Lambda函数被触发
- en: The function adds a set of access keys to the newly created user
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数向新创建的用户添加一组访问密钥
- en: The function makes an HTTP request to the attacker's server with the credentials
    that were created
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数使用创建的凭证向攻击者的服务器发出HTTP请求
- en: Now the attacker just sits back and waits for credentials to flow in to their
    server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击者只需坐下来等待凭证流入他们的服务器。
- en: It may seem like a complicated process, but in the simplest terms, you can think
    of it as a persistent method of establishing persistence. We already understand
    how to establish persistence in the first place, so all Lambda adds to the equation
    is the ability to do it continuously.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个复杂的过程，但简单来说，你可以把它看作是一种持久性建立持久性的方法。我们已经知道如何首先建立持久性，所以Lambda增加的是连续执行的能力。
- en: For a function to trigger an event, such as a user being created, a CloudWatch
    Event rule must be created. A CloudWatch Event rule is a way to basically say—perform
    this action if I see this happen in the environment. For our CloudWatch Event
    rule to work correctly, we also need CloudTrail logging enabled in the `us-east-1`
    region. This is because we are triggered by an IAM event (`iam:CreateUser`), and
    IAM events are only delivered to `us-east-1` CloudWatch Events. In most situations,
    CloudTrail logging will be enabled. It is best practice to enable it across all
    AWS regions, and if CloudTrail isn't enabled, then you are likely in a less-polished
    environment where there are other problems to focus on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发事件的函数，例如创建用户，必须创建一个CloudWatch Event规则。CloudWatch Event规则是一种基本上说——如果我在环境中看到这种情况发生，就执行这个动作的方法。为了使我们的CloudWatch
    Event规则正常工作，我们还需要在`us-east-1`地区启用CloudTrail日志记录。这是因为我们是由IAM事件（`iam:CreateUser`）触发的，并且IAM事件只传递到`us-east-1`
    CloudWatch Events。在大多数情况下，CloudTrail日志记录将被启用。最佳做法是在所有AWS地区启用它，如果CloudTrail未启用，则您可能处于一个不太完善的环境中，需要关注其他问题。
- en: Using Pacu for the deployment of our backdoor
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pacu部署我们的后门
- en: The process of creating the backdoor Lambda function, creating the CloudWatch
    Events rule, and connecting the two would be annoying to do manually every time,
    so that has been automated and integrated into Pacu for us.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后门Lambda函数、创建CloudWatch Events规则并连接两者的过程可能会很烦人，因此已经自动化并集成到Pacu中。
- en: 'The first Pacu module we will look at is called `lambda__backdoor_new_users`,
    and it basically just automates the process of creating a Lambda backdoor that
    backdoors and exfiltrates credentials for newly created users in the environment.
    If we look at the source code of the Lambda function that the Pacu module uses,
    we see the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个Pacu模块称为`lambda__backdoor_new_users`，它基本上只是自动化了在环境中为新创建的用户创建后门并外发凭证的过程。如果我们查看Pacu模块使用的Lambda函数的源代码，我们会看到以下内容：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All the code does is check whether the event that triggered it was an `iam:CreateUser`
    API call, and if so, it will try to use the Python `boto3` library to create credentials
    for that newly created user. Then once that is successful, it will send those
    credentials to the attacker's server, which is indicated by `POST_URL` (Pacu replaces
    that string prior to launching the function).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的作用只是检查触发它的事件是否是`iam:CreateUser` API调用，如果是，它将尝试使用Python的`boto3`库为新创建的用户创建凭证。然后一旦成功，它将发送这些凭证到攻击者的服务器，这由`POST_URL`指示（Pacu在启动函数之前替换该字符串）。
- en: The rest of the module's code sets up all the required resources *or* deletes
    any backdoors that it knows you launched into the account, sort of like a clean-up
    mode.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的其余代码设置了所有必需的资源，或者删除了它知道您在账户中启动的任何后门，有点像清理模式。
- en: 'To receive the credentials that we are creating, we need to start an HTTP listener
    on our own server, as the credentials are `POSTed` in the body. After that, we
    can just run the following Pacu command and hope for credentials to start pouring
    in:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接收我们创建的凭证，我们需要在自己的服务器上启动一个HTTP监听器，因为凭证是在请求体中`POST`的。之后，我们只需运行以下Pacu命令，希望凭证开始涌入：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When that Pacu command finishes, the target account should have our Lambda backdoor
    set up now. As soon as someone else in the environment creates a new IAM user,
    we should receive a request back to our HTTP listener with those credentials.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pacu命令完成时，目标账户现在应该已经设置了我们的Lambda后门。只要环境中的其他人创建了一个新的IAM用户，我们应该收到一个带有这些凭证的HTTP监听器的请求。
- en: 'The following screenshot shows some of the output from running the `lambda__backdoor_new_users` Pacu
    module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行`lambda__backdoor_new_users` Pacu模块的一些输出：
- en: '![](img/482885c6-1634-4167-bc6a-5b3a6127c6c0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/482885c6-1634-4167-bc6a-5b3a6127c6c0.png)'
- en: 'Now, the next screenshot shows the credentials that were POSTed to our HTTP
    server after someone created a user in our target environment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个截图显示了在有人在我们的目标环境中创建用户后，向我们的HTTP服务器POST的凭据：
- en: '![](img/fc4f4128-1065-4292-b803-1dd997d58bcf.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc4f4128-1065-4292-b803-1dd997d58bcf.png)'
- en: 'We can see the access key ID and secret access key both were included in the
    body of this HTTP POST request. Now that we have collected keys for a user, we
    could remove our backdoor if we felt that was necessary (you shouldn''t leave
    anything leftover in an environment you are testing against!). To do this, we
    can run the following Pacu command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到访问密钥ID和秘密访问密钥都包含在这个HTTP POST请求的正文中。现在我们已经为一个用户收集了密钥，如果我们觉得有必要，我们可以删除我们的后门（您不应该在您正在测试的环境中留下任何东西！）。为了做到这一点，我们可以运行以下Pacu命令：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command should output something like the following screenshot, which indicates
    it removed the backdoor resources that we previously created:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该输出类似以下截图的内容，表明它已经删除了我们之前创建的后门资源：
- en: '![](img/e7c1f06d-0048-4c4b-9ae4-753254afac30.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7c1f06d-0048-4c4b-9ae4-753254afac30.png)'
- en: Other Lambda Pacu modules
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Lambda Pacu模块
- en: 'In addition to the `lambda__backdoor_new_users` Pacu module, there are also
    two others:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`lambda__backdoor_new_users` Pacu模块之外，还有另外两个：
- en: '`lambda__backdoor_new_sec_groups`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda__backdoor_new_sec_groups`'
- en: '`lambda__backdoor_new_roles`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda__backdoor_new_roles`'
- en: The `lambda__backdoor_new_sec_groups` module can be used to backdoor new EC2
    Security Groups as they are created by white-listing our own IP address, and the `lambda__backdoor_new_roles` module
    will modify the trust relationship of newly created roles to allow us to assume
    them cross-account, then it will exfiltrate the ARN of the role so we can go ahead
    and collect our temporary credentials. Both these modules work like the `lambda__backdoor_new_users` module
    we covered previously in that they deploy resources into the AWS account that
    trigger on the basis of events, and they have clean-up options to remove those
    resources.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda__backdoor_new_sec_groups`模块可以用于在创建新的EC2安全组时设置后门，通过将我们自己的IP地址列入白名单，而`lambda__backdoor_new_roles`模块将修改新创建角色的信任关系，允许我们跨账户假定它们，然后它将外泄角色的ARN，以便我们可以继续收集我们的临时凭据。这两个模块都像我们之前介绍的`lambda__backdoor_new_users`模块一样，在AWS账户中部署资源，这些资源会根据事件触发，并且它们有清理选项来删除这些资源。'
- en: The `lambda__backdoor_new_sec_groups` modules uses the EC2 APIs (rather than
    IAM), so it is not necessary for the Lambda function to be created in `us-east-1`; instead
    it should be launched into the region that you would like to backdoor new Security
    Groups in.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda__backdoor_new_sec_groups`模块使用EC2 API（而不是IAM），因此不需要在`us-east-1`中创建Lambda函数；相反，它应该在您希望在其中设置新安全组后门的区域中启动。'
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at how we can establish a means of persistent
    access to a target AWS environment. This can be done directly, as we have shown
    with something like adding backdoor keys to other IAM users, or we can use more
    long-term methods with services such as AWS Lambda and CloudWatch Events. There
    are many different ways you can establish some kind of persistence in a target
    AWS account, but sometimes it can just take a little research on the target to
    determine where might be a good location.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了如何在目标AWS环境中建立持久访问的方法。这可以直接完成，就像我们展示的那样，比如向其他IAM用户添加后门密钥，或者我们可以使用更长期的方法，比如AWS
    Lambda和CloudWatch Events等服务。在目标AWS账户中，您可以建立各种不同的持久性方式，但有时候只需要对目标进行一些研究，就可以确定一个好的位置。
- en: Lambda provides a very flexible platform from which to react and respond to
    events within our target account, meaning we can establish persistence (or more)
    as resources are created; however just like we have shown by backdooring EC2 Security
    Groups, not every backdoor needs to be based on/within the IAM service and can
    sometimes be a backdoor for alternate kinds of access. This chapter setout to
    show some common methods of persistence in a way that can help you discover other
    methods of persistence in your engagements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda提供了一个非常灵活的平台，可以在我们的目标账户中对事件做出反应和响应，这意味着我们可以在资源创建时建立持久性（或更多）；然而，就像我们通过给EC2安全组设置后门所展示的那样，并不是每个后门都需要基于/在IAM服务中，并且有时候可以成为其他类型访问的后门。本章旨在展示一些常见的持久性方法，以帮助您发现在您的工作中其他持久性方法。
- en: Rather than creating new resources in an account, which may be quite noisy to
    someone paying attention, it is also possible to backdoor existing Lambda functions.
    These attacks are a little bit more specific to the environment you are targeting
    and require a different set of privileges, but can be much stealthier and longer-lasting.
    These methods will be discussed in the next chapter, where we will discuss pentesting
    AWS Lambda, investigate backdoors and data exfiltration from existing Lambda functions,
    and more.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与在账户中创建新资源（可能会引起注意）不同，也可以对现有的Lambda函数设置后门。这些攻击对您所针对的环境更具体，并且需要不同的权限集，但可以更隐蔽和持久。这些方法将在下一章中讨论，我们将讨论AWS
    Lambda的渗透测试，调查现有Lambda函数的后门和数据外泄等。
