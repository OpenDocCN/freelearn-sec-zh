- en: Web Application Fuzzing - Logical Bug Hunting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序模糊测试 - 逻辑漏洞挖掘
- en: In the previous chapters, we have learned about Metasploit basics, the Metasploit
    modules that can be used in web application penetration testing, performing reconnaissance
    and enumeration using Metasploit modules, different modules supported by Metasploit
    for different technologies and different **Content Management Systems** (**CMSes**),
    and the different exploitation techniques used. In this chapter, we'll be learning
    about another important aspect of web application penetration testing – web application
    fuzzing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经学习了Metasploit的基础知识，可以在Web应用程序渗透测试中使用的Metasploit模块，使用Metasploit模块进行侦察和枚举，Metasploit支持的不同技术和不同内容管理系统（CMSes）的不同模块，以及不同的利用技术。在本章中，我们将学习Web应用程序渗透测试的另一个重要方面
    - Web应用程序模糊测试。
- en: 'Web application fuzzing is not exactly a mandatory phase in a generic penetration
    test case. However, it is a crucial step in finding logical vulnerabilities. Based
    on how a web application server responds to certain requests, the fuzzer can be
    used to understand the behavior of the server to find flaws that are unseen by
    the tester''s eyes. Metasploit comes with three web fuzzer modules that can be
    used to test memory overflows in forms and other fields in a web application.
    In this chapter, we will be learning about fuzzing by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序模糊测试并不是一般渗透测试案例中的强制阶段。然而，它是发现逻辑漏洞的关键步骤。根据Web应用程序服务器对某些请求的响应方式，可以使用模糊器来了解服务器的行为，以发现测试人员未见的缺陷。Metasploit配备了三个Web模糊器模块，可用于测试Web应用程序中表单和其他字段的内存溢出。在本章中，我们将学习以下主题来学习模糊测试：
- en: What is fuzzing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模糊测试？
- en: Fuzzing terminology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试术语
- en: Fuzzing attack types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊攻击类型
- en: Introduction to web app fuzzing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序模糊测试简介
- en: Identifying web application attack vectors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别Web应用程序攻击向量
- en: Scenarios
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的技术要求：
- en: Wfuzz: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wfuzz: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)
- en: Ffuf: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ffuf: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
- en: 'Burp Suite: [https://portswigger.net/burp](https://portswigger.net/burp)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Burp Suite: [https://portswigger.net/burp](https://portswigger.net/burp)'
- en: What is fuzzing?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模糊测试？
- en: 'Fuzzing, also known as fuzz testing, is a type of black box software testing
    that is used to find implementation bugs by using malformed/semi-malformed data
    in an automated way. Fuzz testing was developed by Professor Barton Miller and
    his students at the University of Wisconsin-Madison in 1989 (their ongoing work
    can be found at [http://www.cs.wisc.edu/~bart/fuzz/](http://www.cs.wisc.edu/~bart/fuzz/)).
    When performing fuzz testing, the application/software response is observed, and,
    based on changes in its behavior (crashing or hanging), implementation bugs are
    discovered. In a nutshell, the fuzzing process is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试，也称为模糊测试，是一种使用畸形/半畸形数据以自动化方式发现实现错误的黑盒软件测试。模糊测试是由威斯康星大学麦迪逊分校的Barton Miller教授及其学生于1989年开发的（他们的持续工作可以在[http://www.cs.wisc.edu/~bart/fuzz/](http://www.cs.wisc.edu/~bart/fuzz/)找到）。在进行模糊测试时，观察应用程序/软件的响应，并根据其行为的变化（崩溃或挂起），发现实现错误。简而言之，模糊测试过程如下：
- en: '![](img/8753a263-90ef-485f-b20f-913481827b94.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8753a263-90ef-485f-b20f-913481827b94.png)'
- en: We need to identify the targets and the input vectors (in the case of system
    applications) and the endpoints (in the case of web applications) that need to
    be fuzzed. After a proper input seed is generated (random fuzz data), the malformed/semi-malformed
    fuzz data will be given as input to the fuzzer for testing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定目标和输入向量（在系统应用程序的情况下）以及需要进行模糊处理的端点（在Web应用程序的情况下）。在生成适当的输入种子（随机模糊数据）之后，畸形/半畸形的模糊数据将被输入到模糊器进行测试。
- en: Meanwhile, we need to understand the application's behavior throughout fuzz
    testing by monitoring and analyzing the server/application responses (web server
    responses in the case of web application fuzzing, and application diagnostic information/trace
    information in the case of system application fuzzing, which includes FTP servers,
    SSH servers, and SMTP servers). To better understand fuzz testing, let's first
    learn some common terminology used in fuzzing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们需要通过监控和分析服务器/应用程序响应（在Web应用程序模糊测试的情况下为Web服务器响应，在系统应用程序模糊测试的情况下为应用程序诊断信息/跟踪信息，其中包括FTP服务器、SSH服务器和SMTP服务器）来了解应用程序在模糊测试期间的行为。为了更好地理解模糊测试，让我们首先学习一些在模糊测试中常用的术语。
- en: Fuzzing terminology
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试术语
- en: 'To have a better understanding of fuzzing and fuzzing techniques, let''s have
    a look at different fuzzing terminology that will help us to grasp the fuzzing
    concepts and techniques that are used in this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解模糊测试和模糊测试技术，让我们先看一下本章中将帮助我们掌握模糊测试概念和技术的不同模糊测试术语：
- en: '**Fuzzer:** A fuzzer is a program/tool that injects malformed/semi-malformed
    data into the server/web application and observes the behavior of the application
    to detect bugs. The malformed/semi-malformed data used by the fuzzer is generated
    using a generator.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊器：** 模糊器是一种将畸形/半畸形数据注入到服务器/网络应用程序中并观察应用程序行为以检测错误的程序/工具。模糊器使用生成器生成的畸形/半畸形数据。'
- en: '**Generator:** A generator uses a combination of fuzzing vectors and some random
    data. The generated data is then fed to the fuzzer, which injects this malformed
    data into the application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器：** 生成器使用模糊向量和一些随机数据的组合。然后将生成的数据馈送给模糊器，模糊器将这些畸形数据注入到应用程序中。'
- en: '**Fuzz vectors:** A fuzz vector is a known-to-be-dangerous value that is used
    by the fuzzer. By observing the behavior of the application, the fuzzer can inject
    different fuzz vectors.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊向量：** 模糊向量是模糊器使用的已知危险值。通过观察应用程序的行为，模糊器可以注入不同的模糊向量。'
- en: '**Input seeds:** These are valid input samples that are used by the fuzzer
    for testing. An input seed can be any test file that contains the data format
    to be used by the fuzzer. The generator will then generate the data based on the
    input seed that will be used by the fuzzer. If the input seed is chosen carefully,
    we can find a great number of bugs in an application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入种子：**这些是模糊器用于测试的有效输入样本。输入种子可以是包含模糊器要使用的数据格式的任何测试文件。生成器将根据输入种子生成数据，然后由模糊器使用。如果选择输入种子小心翼翼，我们可以在应用程序中找到大量的错误。'
- en: '**Instrumentation:** This is a technique used by the to measure the application''s
    performance and diagnostic information, including any errors. During fuzzing,
    the instrumentation technique will temporarily take control of the application/software
    that is being fuzzed at runtime, just like an interceptor, to look for errors
    from the trace information.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器：**这是一种技术，用于测量应用程序的性能和诊断信息，包括任何错误。在模糊处理期间，仪器技术将在运行时暂时控制被模糊处理的应用程序/软件，就像拦截器一样，以查找来自跟踪信息的错误。'
- en: Now that we have learned some new terminology, let's have a look at the attack
    types with which we can perform fuzz testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些新的术语，让我们看看可以使用哪些攻击类型来执行模糊测试。
- en: Fuzzing attack types
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊攻击类型
- en: The fuzzer will generally try a combination of attacks using numbers (signed/unsigned
    integers or floats), chars (URLs or command-line inputs), user-input text, pure
    binary sequences, and so on. A list of fuzz vectors can be generated from these
    types. For example, for integers, the fuzz vectors could be zero, a negative value,
    or a very big integer value; for chars, the fuzz vectors could be escaped characters,
    Unicode characters, URL-encoded characters, special characters, or a sequence
    of all of the characters. Once the list of fuzz vectors is generated, the fuzzer
    will use the list to perform fuzzing on the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊器通常会尝试使用数字（有符号/无符号整数或浮点数）、字符（URL或命令行输入）、用户输入文本、纯二进制序列等进行攻击的组合。可以从这些类型生成一系列模糊向量。例如，对于整数，模糊向量可以是零、负值或非常大的整数值；对于字符，模糊向量可以是转义字符、Unicode字符、URL编码字符、特殊字符或所有字符的序列。生成模糊向量列表后，模糊器将使用该列表对应用程序进行模糊处理。
- en: Application fuzzing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序模糊处理
- en: For a desktop-based application, a fuzzer can perform fuzzing on its interface
    (a combination of button sequences, text inputs, and so on), command-line options
    (if applicable), and import/export capabilities provided by the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于桌面的应用程序，模糊器可以对其界面（按钮序列的组合、文本输入等）、命令行选项（如果适用）以及应用程序提供的导入/导出功能进行模糊处理。
- en: For web-based applications, a fuzzer can perform fuzzing on its URLs, user input
    forms, HTTP request headers, HTTP POST data, HTTP protocols, and HTTP methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Web的应用程序，模糊器可以对其URL、用户输入表单、HTTP请求头、HTTP POST数据、HTTP协议和HTTP方法进行模糊处理。
- en: Protocol fuzzing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议模糊处理
- en: A protocol fuzzer will forge network packets and send them to the server. If
    there's a bug in the protocol stack, it will be revealed using protocol fuzzing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 协议模糊器将伪造网络数据包并将其发送到服务器。如果协议栈中存在错误，将使用协议模糊来揭示它。
- en: File-format fuzzing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件格式模糊处理
- en: File-format fuzzing is generally used in those cases where a program is importing/exporting
    data streams in and out of files. To perform file-format fuzzing, you have to
    generate multiple input seeds with different file formats and save them in a single
    file. The fuzzer will then use the saved file as an input to the server/application,
    recording any kind of crash that may occur. We will now move on to the next section,
    which will introduce us to web app fuzzing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式模糊处理通常用于那些程序在文件中导入/导出数据流的情况。要执行文件格式模糊处理，您必须生成多个具有不同文件格式的输入种子，并将它们保存在单个文件中。然后，模糊器将使用保存的文件作为服务器/应用程序的输入，记录可能发生的任何崩溃。现在我们将进入下一节，该节将向我们介绍Web应用程序模糊处理。
- en: Introduction to web app fuzzing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序模糊处理简介
- en: 'Now that we have a clear understanding of the fuzzing concept, the terminology,
    and the attack types, let''s start with web application-based fuzzing. As mentioned
    before, web application-based fuzzing is done by using URLs, forms, headers, and
    methods as the primary fuzz vectors. In this chapter, we will be using the following
    tools for fuzzing an HTTP-based web application: **Wfuzz**, **Ffuf**, and **Burp
    Suite**. Before moving forward, let''s install the tools outlined in this section
    to hunt logical bugs.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模糊概念、术语和攻击类型有了清晰的理解，让我们开始基于Web应用程序的模糊处理。如前所述，基于Web应用程序的模糊处理是通过使用URL、表单、标头和方法作为主要模糊向量来完成的。在本章中，我们将使用以下工具对基于HTTP的Web应用程序进行模糊处理：**Wfuzz**、**Ffuf**和**Burp
    Suite**。在继续之前，让我们安装本节中概述的工具，以便查找逻辑错误。
- en: Fuzzer installation (Wfuzz)
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fuzzer安装（Wfuzz）
- en: 'Wfuzz is a Python-based web application fuzzer that uses the replacive technique
    to replace the **FUZZ** keyword in the command with the fuzz vectors given to
    the fuzzer. This fuzzer can perform complex web security attacks in different
    web application components, such as parameters, authentication, forms, directories/files,
    and headers. Wfuzz is also equipped with a variety of modules, including iterators,
    encoders, payloads, printers, and scripts. Depending upon the web application,
    we can use these modules to perform successful fuzz testing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz是一个基于Python的Web应用程序模糊器，它使用替换技术来将命令中的**FUZZ**关键字替换为提供给模糊器的模糊向量。该模糊器可以在不同的Web应用程序组件（如参数、身份验证、表单、目录/文件和标头）中执行复杂的Web安全攻击。Wfuzz还配备了各种模块，包括迭代器、编码器、有效载荷、打印机和脚本。根据Web应用程序的不同，我们可以使用这些模块来执行成功的模糊测试：
- en: 'We can install the **Wfuzz** tool by cloning the GitHub repository, as we can
    see in the following screenshot:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过克隆GitHub存储库来安装**Wfuzz**工具，如下面的屏幕截图所示：
- en: '![](img/00825c4a-b2d7-4054-a19a-4f8b6994cc3a.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/00825c4a-b2d7-4054-a19a-4f8b6994cc3a.png）
- en: 'Before running the tool, we need to install it by executing the `python setup.py
    install` command. This will install all the files on the system, as we can see
    in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行工具之前，我们需要通过执行`python setup.py install`命令来安装它。这将在系统上安装所有文件，如下截图所示：
- en: '![](img/1492d0b0-63ec-4ada-9280-e72ec91f8832.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1492d0b0-63ec-4ada-9280-e72ec91f8832.png)
- en: 'To confirm whether the tool has been successfully installed or not, let''s
    execute the `wfuzz -h` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认工具是否已成功安装，让我们执行`wfuzz -h`命令：
- en: '![](img/581aa7f1-8303-4042-8dde-df6df3c07d25.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/581aa7f1-8303-4042-8dde-df6df3c07d25.png)
- en: Let's now install the second tool that we'll use in this chapter, **Fuzz Faster
    U Fool** (**ffuf**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装本章中将使用的第二个工具**Fuzz Faster U Fool**（**ffuf**）。
- en: Fuzzer installation (ffuf)
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊器安装（ffuf）
- en: '**Fuzz Faster U Fool** (**ffuf**) is a web application fuzzer written in Go
    that has the functionality of Gobuster as well as **Wfuzz**. We can either clone
    the GitHub repository from [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
    or we can download the pre-compiled version from [https://github.com/ffuf/ffuf/releases](https://github.com/ffuf/ffuf/releases).
    Let''s install it by following these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fuzz Faster U Fool**（**ffuf**）是用Go编写的Web应用程序模糊器，具有Gobuster和**Wfuzz**的功能。我们可以从[https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)克隆GitHub存储库，也可以从[https://github.com/ffuf/ffuf/releases](https://github.com/ffuf/ffuf/releases)下载预编译版本。让我们按照以下步骤安装它：'
- en: 'We can either clone the repository using the `git clone https://github.com/ffuf/ffuf`
    command or using `go get https://github.com/ffuf/ffuf`. Let''s clone the repository:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`git clone https://github.com/ffuf/ffuf`命令或`go get https://github.com/ffuf/ffuf`命令来克隆存储库。让我们克隆存储库：
- en: '![](img/af630c71-8b5e-4211-9f37-0e92a8464fac.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/af630c71-8b5e-4211-9f37-0e92a8464fac.png)
- en: 'Now, let''s install it by executing the `go build .` command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过执行`go build .`命令来安装它：
- en: '![](img/e46d7e4e-5684-4d71-b910-443fe397ccab.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e46d7e4e-5684-4d71-b910-443fe397ccab.png)
- en: 'Upon a successful build, we can see that a compiled program, `ffuf`, is created
    in the same directory. We can run the program as shown in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功构建后，我们可以看到在同一目录中创建了一个名为`ffuf`的编译程序。我们可以按照以下截图中显示的方式运行程序：
- en: '![](img/cb00e1fb-fdd3-4205-9b0c-eb81fa9cbca2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/cb00e1fb-fdd3-4205-9b0c-eb81fa9cbca2.png)
- en: 'Our third and final tool for this chapter will be the infamous Burp Suite Intruder:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的第三个和最后一个工具将是臭名昭著的Burp Suite Intruder：
- en: '![](img/df47d7d4-86be-4bda-9cb6-4a5dcc14185f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/df47d7d4-86be-4bda-9cb6-4a5dcc14185f.png)
- en: Now that we have installed all the tools required for us to perform fuzzing,
    let's try to understand the fuzzing inputs and vectors that we'll be using while
    performing fuzzing on web applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了执行模糊测试所需的所有工具，让我们试着了解在执行对Web应用程序进行模糊测试时将使用的模糊测试输入和向量。
- en: Identifying web application attack vectors
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别Web应用程序攻击向量
- en: 'Attack vectors are the regions/sections of a web application where the fuzzer
    can inject malformed/semi-malformed data. For a web application, the following
    are the sections where we can perform fuzzing:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击向量是Web应用程序的区域/部分，模糊器可以在其中注入畸形/半畸形数据。对于Web应用程序，以下是我们可以执行模糊测试的部分：
- en: HTTP request verbs
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求动词
- en: HTTP request URIs
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求URI
- en: HTTP request headers
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求头
- en: HTTP `POST` data
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP `POST`数据
- en: Older versions of the HTTP protocol
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP协议的旧版本
- en: Let's try to understand each section and all the fuzz vectors we can use for
    web application fuzzing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着了解每个部分以及我们可以用于Web应用程序模糊测试的所有模糊向量。
- en: HTTP request verbs
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求动词
- en: Request verbs are also known as request methods, which are used by a web application
    client to indicate the desired action to be performed for a given resource on
    the server. Each of the methods used depends upon the resources required by the
    client from the server. Some of the most common HTTP verbs are `GET`, `POST`,
    `OPTIONS`, `HEAD`, `PUT`, `DELETE`, `TRACE`, `PATCH`, and `CONNECT`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请求动词也称为请求方法，它们由Web应用程序客户端用于指示对服务器上给定资源执行的期望操作。所使用的每种方法取决于客户端从服务器获取的资源。一些最常见的HTTP动词是`GET`，`POST`，`OPTIONS`，`HEAD`，`PUT`，`DELETE`，`TRACE`，`PATCH`和`CONNECT`。
- en: Fuzzing HTTP request methods can help us to identify the changes in a web application's
    responses based on different methods being supplied by the fuzzer. We can also
    identify the methods allowed by the web application server, which can be used
    to check a few attack test cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTTP请求方法进行模糊测试可以帮助我们识别基于模糊器提供的不同方法而发生的Web应用程序响应的变化。我们还可以识别Web应用程序服务器允许的方法，这可以用于检查一些攻击测试用例。
- en: Fuzzing HTTP methods/verbs using Wfuzz
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz对HTTP方法/动词进行模糊测试
- en: 'Fuzzing HTTP methods is quite easy and, at the same time, quite helpful. Let''s
    try to fuzz the HTTP verbs on a simple web application using **Wfuzz**. Fuzzing
    HTTP request methods can be done by following these steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTTP方法进行模糊测试非常简单，同时也非常有帮助。让我们尝试使用**Wfuzz**在简单的Web应用程序上对HTTP动词进行模糊测试。可以通过以下步骤来执行HTTP请求方法的模糊测试：
- en: 'Execute the following command in the Terminal to get started with **Wfuzz**:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行以下命令以开始使用**Wfuzz**：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/1c9e8a86-a359-4122-a1e2-d74a3e45217d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1c9e8a86-a359-4122-a1e2-d74a3e45217d.png)
- en: The `-z` option is used to input the payload. In this case, we used a list (`-z`
    <list name>) of common HTTP request methods (`GET`, `POST`, `HEAD`, `OPTIONS`,
    `TRACE`, and `PUT`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-z`选项用于输入有效负载。在这种情况下，我们使用了一个常见的HTTP请求方法列表（`GET`，`POST`，`HEAD`，`OPTIONS`，`TRACE`和`PUT`）。'
- en: The `-X` option is used to provide the HTTP request method to be used by the
    fuzzer. If the `-X` option is not provided, the fuzzer will use the HTTP `GET`
    request method for fuzzing by default.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-X`选项用于提供模糊器要使用的HTTP请求方法。如果未提供`-X`选项，模糊器将默认使用HTTP `GET`请求方法进行模糊测试。'
- en: Now, let's see how we can fuzz HTTP verbs using **ffuf**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用**ffuf**对HTTP动词进行模糊测试。
- en: Fuzzing HTTP methods/verbs using ffuf
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ffuf对HTTP方法/动词进行模糊测试
- en: We can also fuzz request headers using **ffuf.**
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用**ffuf**来模糊请求头。
- en: 'We can execute the following command to fuzz the request headers using a wordlist:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下命令，使用单词列表来模糊测试请求头：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/6f847355-66fa-4600-8ecd-1ecb67235780.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f847355-66fa-4600-8ecd-1ecb67235780.png)'
- en: As we can see in the preceding screenshot, the fuzzer found a few HTTP methods
    that are acceptable to the web application server. Let's try to fuzz the same
    case using Burp Suite.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，模糊器找到了一些Web应用程序服务器可接受的HTTP方法。让我们尝试使用Burp Suite来模糊相同的情况。
- en: 'Note: The `-c` option in **ffuf** is given to add color to the HTTP response
    code. It helps us to identify hidden files and directories faster.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在**ffuf**中使用`-c`选项是为了给HTTP响应代码添加颜色。这有助于我们更快地识别隐藏的文件和目录。
- en: Fuzzing HTTP methods/verbs using Burp Suite Intruder
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Suite Intruder来模糊测试HTTP方法/动词
- en: 'HTTP verbs can also be fuzzed using Burp Suite Intruder by clicking the Intruder
    tab and opening the Positions sub-tab. Burp Suite will automatically mark any
    value matching the `[parameter]=[value]` format with the **§** payload marker.
    Anything within the payload marker will be considered a fuzz vector by Burp Suite.
    Burp Suite Intruder supports four attack types: Sniper, Battering Ram, Pitchfork,
    and Cluster Bomb. To learn more about the attack types, please refer to [https://portswigger.net/burp/documentation/desktop/tools/intruder/positions.](https://portswigger.net/burp/documentation/desktop/tools/intruder/positions)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词也可以通过Burp Suite Intruder来进行模糊测试，方法是单击Intruder选项卡，然后打开Positions子选项卡。Burp
    Suite将自动使用**§**载荷标记标记任何匹配`[parameter]=[value]`格式的值。在载荷标记内的任何内容都将被Burp Suite视为模糊向量。Burp
    Suite Intruder支持四种攻击类型：Sniper、Battering Ram、Pitchfork和Cluster Bomb。要了解有关攻击类型的更多信息，请参阅[https://portswigger.net/burp/documentation/desktop/tools/intruder/positions.](https://portswigger.net/burp/documentation/desktop/tools/intruder/positions)
- en: 'Let''s clear the fuzz vector position by clicking the Clear § button, as we
    can see in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过单击“清除§”按钮来清除模糊向量位置，如下面的屏幕截图所示：
- en: '![](img/f53cdd70-96a5-4e7b-8124-dd97ed63447f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f53cdd70-96a5-4e7b-8124-dd97ed63447f.png)'
- en: 'To fuzz the HTTP request methods, let''s add the payload marker (**§**) by
    clicking the Add § button, as we can see in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要对HTTP请求方法进行模糊测试，让我们通过单击“添加§”按钮添加载荷标记（**§**），如下面的屏幕截图所示：
- en: '![](img/0a140795-64f2-454d-8db1-4597c0f1b93a.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a140795-64f2-454d-8db1-4597c0f1b93a.png)'
- en: 'Now that the payload marker is set, we need to define the payloads that should
    be used by Intruder for fuzzing. This can be done by clicking on the Payloads
    tab (as we can see in the following screenshot). In this case, we''ll be using
    a wordlist that contains some of the common HTTP request methods. The wordlist
    can be used by first setting the Payload type to `Simple list` and then loading
    the list by clicking the Load … button:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置了载荷标记，我们需要定义应该由入侵者用于模糊测试的载荷。这可以通过单击“载荷”选项卡来完成（如下面的屏幕截图所示）。在这种情况下，我们将使用包含一些常见HTTP请求方法的单词列表。可以通过首先将载荷类型设置为“简单列表”，然后单击“加载…”按钮来加载列表：
- en: '![](img/e8a6247d-7d36-4cea-b666-ba4b9ab5a1c8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8a6247d-7d36-4cea-b666-ba4b9ab5a1c8.png)'
- en: 'Once the wordlist is loaded, we can click on the Start attack button to begin
    the fuzzing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 加载了单词列表后，我们可以单击“开始攻击”按钮开始模糊测试：
- en: '![](img/9749d679-1c7b-44d7-a7ff-23f3e70a5f25.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9749d679-1c7b-44d7-a7ff-23f3e70a5f25.png)'
- en: 'A new window will open with the fuzzing results, as we can see in the following
    screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个新窗口，显示模糊测试的结果，如下面的屏幕截图所示：
- en: '![](img/c26bd352-5b18-44af-87a4-a37065e6462e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c26bd352-5b18-44af-87a4-a37065e6462e.png)'
- en: In the preceding screenshot, we can observe that the server responds with HTTP
    `400` (**Bad Request**) and HTTP `405` (**Method Not Allowed**) codes when HTTP
    CONNECT and TRACE methods are used, respectively. This shows us the behavior of
    the web application server regarding these two request headers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的屏幕截图中，我们可以观察到当使用HTTP CONNECT和TRACE方法时，服务器分别以HTTP `400`（**错误请求**）和HTTP `405`（**不允许的方法**）代码做出响应。这显示了关于这两个请求头的Web应用程序服务器的行为。 '
- en: 'Note: We can use other custom lists freely available online for fuzzing HTTP
    methods as well.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们也可以自由使用在线可用的其他自定义列表来模糊测试HTTP方法。
- en: HTTP request URIs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求URI
- en: 'To begin HTTP request URI fuzzing, we first need to understand the URI structure.
    A URI has the following universally acceptable structure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开始HTTP请求URI模糊测试，我们首先需要了解URI的结构。URI具有以下通用可接受的结构：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fuzzing an HTTP request URl path using Wfuzz
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz来模糊测试HTTP请求URI路径
- en: 'To fuzz the URI path with the help of Wfuzz, let''s execute the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Wfuzz来模糊测试URI路径，让我们执行以下命令：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/e43be872-33ab-4b77-8005-195e6fbe5352.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e43be872-33ab-4b77-8005-195e6fbe5352.png)'
- en: 'Using the `--hc` switch, we can filter out the results based on the HTTP codes.
    In this case, we have filtered the HTTP `404` (**Not Found**) code, as we can
    see in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--hc`开关，我们可以根据HTTP代码过滤结果。在这种情况下，我们已经过滤了HTTP `404`（**未找到**）代码，如下面的屏幕截图所示：
- en: '![](img/0b541a0f-1df0-4d38-9f37-5eacbdfe27d4.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b541a0f-1df0-4d38-9f37-5eacbdfe27d4.png)'
- en: We can do the same thing using **ffuf**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用**ffuf**来做同样的事情。
- en: Fuzzing an HTTP request URl path using ffuf
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ffuf来模糊测试HTTP请求URI路径
- en: 'To fuzz the URI path, let''s execute the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要模糊URI路径，让我们执行以下命令：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/0db80f3c-d17b-4db1-b8e7-75e5da2ecd4f.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0db80f3c-d17b-4db1-b8e7-75e5da2ecd4f.png)'
- en: In both of the preceding cases, the `FUZZ` keyword is replaced with the wordlist
    entries that are used for fuzzing the directory names. As we can see in the preceding
    screenshot, the server responded with HTTP `301` when the fuzzer requested css,
    img, js, and setup. Observing the size of the response and the words, we can conclude
    that the fuzzer was able to find directories in the web application server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两种情况下，`FUZZ`关键字被替换为用于模糊处理目录名称的单词列表条目。正如我们在前面的屏幕截图中所看到的，当模糊器请求css、img、js和setup时，服务器响应了HTTP
    `301`。通过观察响应的大小和单词，我们可以得出结论，模糊器能够在Web应用程序服务器中找到目录。
- en: Fuzzing an HTTP request URl path using Burp Suite Intruder
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Suite Intruder进行HTTP请求URI路径的模糊处理
- en: 'Now that we have used **Wfuzz** and **ffuf** to fuzz the URI path, let''s try
    the same in Burp Suite Intruder. The concept here is the same. Let''s place a
    payload marker (as shown in the following screenshot) for the fuzzer to send data to
    the vector:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用了**Wfuzz**和**ffuf**来模糊处理URI路径，让我们尝试在Burp Suite Intruder中进行相同的操作。这里的概念是相同的。让我们放置一个负载标记（如下面的屏幕截图所示），以便模糊器将数据发送到向量：
- en: '![](img/6babe9a4-8114-4323-b048-3265b0b2d1de.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6babe9a4-8114-4323-b048-3265b0b2d1de.png)'
- en: 'Let''s set Payload type to `Simple list` and import a wordlist using the Load
    … button:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将负载类型设置为“简单列表”，并使用“加载…”按钮导入一个单词列表：
- en: '![](img/df043969-85ec-4ed1-b308-41b6e6983672.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df043969-85ec-4ed1-b308-41b6e6983672.png)'
- en: 'Click on the Start attack button (as shown in the preceding screenshot) and
    Intruder will try to fuzz the URI path with the custom wordlist given to it. The
    result for the fuzzer will be displayed in another window with the HTTP response
    codes and the Length, which we can see in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“开始攻击”按钮（如前面的屏幕截图所示），Intruder将尝试使用给定的自定义单词列表对URI路径进行模糊处理。模糊器的结果将显示在另一个窗口中，其中包括HTTP响应代码和长度，我们可以在下面的屏幕截图中看到：
- en: '![](img/8bd12f1d-54ea-41fc-958f-b504201833d3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bd12f1d-54ea-41fc-958f-b504201833d3.png)'
- en: As we can see in the preceding screenshot, we were able to fuzz the URI path
    (directories) of the web application server. Now, let's see how we can fuzz URI
    filenames and file extensions using the same tools.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的屏幕截图中所看到的，我们能够模糊处理Web应用程序服务器的URI路径（目录）。现在，让我们看看如何使用相同的工具模糊处理URI文件名和文件扩展名。
- en: Fuzzing HTTP request URl filenames and file extensions using Wfuzz
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz进行HTTP请求URI文件名和文件扩展名的模糊处理
- en: 'Wfuzz can also fuzz the filenames and file extensions of the web application
    server:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz还可以模糊处理Web应用程序服务器的文件名和文件扩展名：
- en: '`wfuzz -c --hc=404 -z file,SecLists/Discovery/Web-Content/raft-small-files-lowercase.txt
    http://192.168.2.19:8090/xvwa/FUZZ.php` (filename fuzzing)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wfuzz -c --hc=404 -z file,SecLists/Discovery/Web-Content/raft-small-files-lowercase.txt
    http://192.168.2.19:8090/xvwa/FUZZ.php`（文件名模糊处理）'
- en: '`wfuzz -c --hc=404 -z list,php-asp-aspx-jsp-txt http://192.168.2.19:8090/xvwa/home.FUZZ`
    (file extension fuzzing)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wfuzz -c --hc=404 -z list,php-asp-aspx-jsp-txt http://192.168.2.19:8090/xvwa/home.FUZZ`（文件扩展名模糊处理）'
- en: Fuzzing HTTP request URl filenames and file extensions using ffuf
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ffuf进行HTTP请求URI文件名和文件扩展名的模糊处理
- en: 'To fuzz the HTTP request URI filenames and file extensions, the following commands
    can be used for the ffuf fuzzer:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要对HTTP请求URI文件名和文件扩展名进行模糊处理，可以使用ffuf模糊器的以下命令：
- en: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/FUZZ.php` (filename
    fuzzing)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/FUZZ.php`（文件名模糊处理）'
- en: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/home.FUZZ` (file extension
    fuzzing)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/home.FUZZ`（文件扩展名模糊处理）'
- en: Fuzzing HTTP request URl filenames and file extensions using Burp Suite Intruder
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Suite Intruder进行HTTP请求URI文件名和文件扩展名的模糊处理
- en: 'The payload marker is placed before the file extension to fuzz filenames (as
    we can see in the following screenshot):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 负载标记放置在文件扩展名之前，以模糊文件名（如我们在以下屏幕截图中所见）：
- en: '![](img/cb4d3bdb-ef88-4da7-b5b9-d86b0a8efc4f.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb4d3bdb-ef88-4da7-b5b9-d86b0a8efc4f.png)'
- en: 'The payload marker is placed after the filename to fuzz file extensions (as
    we can see in the following screenshot):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 负载标记放置在文件名之后，以模糊文件扩展名（如我们在以下屏幕截图中所见）：
- en: '![](img/b8eb76a9-67ad-4b49-a23e-fec14ac3b464.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8eb76a9-67ad-4b49-a23e-fec14ac3b464.png)'
- en: The cool thing about Wfuzz and Burp Suite Intruder is the ability to fuzz multiple
    payload locations using multiple fuzz vectors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz和Burp Suite Intruder的很酷的功能是能够使用多个模糊向量来模糊处理多个负载位置。
- en: Fuzzing an HTTP request URl using Wfuzz (GET parameter + value)
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz进行HTTP请求URI的模糊处理（GET参数+值）
- en: 'Wfuzz has the built-in functionality to fuzz multiple payload locations by
    adding the **FUZZ**, **FUZ2Z**, **FUZ3Z**... keywords. Let''s say we want to fuzz
    the `GET` parameter name and the value of the web application server. As we cannot
    use the same wordlist in both fuzz vectors, we will use the **FUZZ** and **FUZ2Z**
    keywords to perform fuzzing. Let''s execute the following command in Wfuzz:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Wfuzz具有内置功能，可以通过添加**FUZZ**、**FUZ2Z**、**FUZ3Z**...关键字来模糊处理多个负载位置。假设我们想要模糊处理Web应用程序服务器的`GET`参数名称和值。由于我们不能在两个模糊向量中使用相同的单词列表，我们将使用**FUZZ**和**FUZ2Z**关键字来执行模糊处理。让我们在Wfuzz中执行以下命令：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see in the preceding command, we have fed **Wfuzz** two wordlists, `parameter_wordlist`
    and `value_wordlist`, using the `-z` option (yes, we can use the `-z`, `-H`, and
    `-b` options repeatedly) and the `[parameter]=[value]` is shown in `/?FUZZ=FUZ2Z`
    format. Upon executing this command, the fuzzer will use the first entry in `parameter_wordlist`,
    replace it with the `FUZZ` keyword, and then loop through all the `value_wordlist`
    entries via `FUZ2Z`. And like this, the fuzzer will fuzz through both wordlists.
    Let's now see how we can achieve the same thing using Intruder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的命令中所看到的，我们使用了`-z`选项（是的，我们可以重复使用`-z`，`-H`和`-b`选项）和`[parameter]=[value]`以`/?FUZZ=FUZ2Z`格式显示。执行此命令时，模糊器将使用`parameter_wordlist`中的第一个条目，将其替换为`FUZZ`关键字，然后通过`FUZ2Z`循环遍历所有`value_wordlist`条目。就像这样，模糊器将通过两个单词列表进行模糊处理。现在让我们看看如何使用Intruder实现相同的功能。
- en: Fuzzing an HTTP request URl using Burp Suite Intruder (GET parameter + value)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Burp Suite Intruder进行HTTP请求URI的模糊处理（GET参数+值）
- en: 'In Burp Suite, the different attack types help us with this kind of test case.
    To fuzz through two wordlists simultaneously, we''ll be using the cluster bomb
    attack type in Intruder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Burp Suite中，不同的攻击类型可以帮助我们进行这种测试。为了同时使用两个字典进行模糊测试，我们将在Intruder中使用簇炸弹攻击类型：
- en: 'To begin with, let''s set the Attack type to Cluster bomb and set the payload
    marker as /?§§=§§ (as shown in the following screenshot):'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将攻击类型设置为簇炸弹，并将有效负载标记设置为/?§§=§§（如下图所示）：
- en: '![](img/438502f0-3dda-4096-81b9-b473985b4974.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/438502f0-3dda-4096-81b9-b473985b4974.png)'
- en: 'As we''ll be using two payload sets in this case, let''s set our first Payload
    set (parameter name) and change the Payload type to Simple list:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用两个有效负载集，让我们将第一个有效负载集（参数名称）设置为简单列表，并将有效负载类型更改为Simple list：
- en: '![](img/1ddec7f4-1858-44c1-8b17-b64ad292725b.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ddec7f4-1858-44c1-8b17-b64ad292725b.png)'
- en: 'Now that our first payload set is configured, let''s configure our second payload
    set (parameter value). After setting Payload set to `2`, let''s change Payload
    type to `Numbers`. As the parameter value is in the integer format (in this case),
    let''s set the range from `1` to `5` and set Step to `1`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的第一个有效负载集已经配置好了，让我们配置第二个有效负载集（参数值）。在将有效负载集设置为`2`后，让我们将有效负载类型更改为`Numbers`。由于参数值是整数格式（在这种情况下），让我们将范围设置为`1`到`5`，并将步长设置为`1`：
- en: '![](img/739393b1-0221-4070-bc95-af0d19774bbf.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739393b1-0221-4070-bc95-af0d19774bbf.png)'
- en: 'Our Intruder is now configured for fuzzing through multiple payload sets. Let''s
    begin the fuzz testing by clicking on the Start attack button (as we can see in
    the preceding screenshot). We will then see the following screen:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Intruder现在已经配置好了，可以对多个有效负载集进行模糊测试。让我们通过单击“开始攻击”按钮（如前面的屏幕截图中所示）开始模糊测试。然后我们会看到以下屏幕：
- en: '![](img/c7d02540-96f8-4fe4-b29a-3b334581b6ed.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d02540-96f8-4fe4-b29a-3b334581b6ed.png)'
- en: Success!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: As we can see from the preceding screenshot, Intruder was able to find an item parameter
    name with some parameter values. How can we differentiate between the found parameter
    name and values from other entries in the wordlist? By observing the response
    length.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的屏幕截图中看到的，Intruder能够找到一个带有一些参数值的参数名称。我们如何区分在字典中找到的参数名称和值与其他条目？通过观察响应长度。
- en: 'Let''s try to fuzz three fuzz vectors using **Wfuzz** (directories, files,
    and file extensions). This would definitely take a lot of time as it combines
    different payload sets simultaneously. To fuzz the directories, filenames, and
    file extensions, we can execute the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用**Wfuzz**模糊三个模糊向量（目录、文件和文件扩展名）。这肯定会花费很多时间，因为它同时结合了不同的有效负载集。为了对目录、文件名和文件扩展名进行模糊测试，我们可以执行以下命令：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/55074e56-707a-49f3-9699-47f0bfffd6ab.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55074e56-707a-49f3-9699-47f0bfffd6ab.png)'
- en: 'The result can be filtered based on the number of characters (`--hh`), words
    (`--hw`), or lines (`--hl`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以根据字符数（`--hh`）、单词数（`--hw`）或行数（`--hl`）进行过滤：
- en: '![](img/984a6a22-925e-48ae-9f28-1ae8590564a3.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/984a6a22-925e-48ae-9f28-1ae8590564a3.png)'
- en: Now that we have some idea of how to fuzz HTTP request URIs, let's understand
    how we can fuzz HTTP headers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何模糊HTTP请求URI有了一些了解，让我们了解如何模糊HTTP头部。
- en: HTTP request headers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求头
- en: Fuzzing request headers is conceptually the same as fuzzing URIs. The only difference
    is that the number of vulnerabilities found by fuzzing the request headers will
    be higher than when fuzzing URIs because these headers are sent to the web application
    server and the server processes these headers internally. This means we have a
    larger scope for finding vulnerabilities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊请求头在概念上与模糊URI相同。唯一的区别是，通过模糊请求头找到的漏洞数量将比模糊URI找到的漏洞数量更多，因为这些头部被发送到Web应用程序服务器，服务器会在内部处理这些头部。这意味着我们有更大的范围来发现漏洞。
- en: 'There are different types of HTTP headers at play:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的HTTP头部在起作用：
- en: Standard HTTP headers (`Cookie`, `User-Agent`, `Accept`, `Host`, and so on)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的HTTP头（`Cookie`，`User-Agent`，`Accept`，`Host`等）
- en: Non-standard HTTP headers (`X-Forwarded-For`, `X-Requested-With`, `DNT`, and
    so on)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准的HTTP头（`X-Forwarded-For`，`X-Requested-With`，`DNT`等）
- en: Custom headers (any other header beginning with `X-` except the non-standard
    headers)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义头部（除了非标准头部之外，任何以`X-`开头的头部）
- en: Let's try to understand how can we fuzz each type of header using the same fuzzers
    as in the rest of this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试了解如何使用与本章其他部分相同的模糊器模糊每种类型的头部。
- en: Fuzzing standard HTTP headers using Wfuzz, ffuf, and Burp Suite
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz、ffuf和Burp Suite对标准的HTTP头进行模糊测试
- en: Standard HTTP headers are commonly used by web servers to process client requests.
    While performing a web application penetration test, it's recommended to understand
    the workings of the web application and how the web application server processes
    request headers (standard and non-standard). Having a better understanding of
    the web application can help us define some pretty decent fuzz vectors that would
    greatly increase the probability of finding logical flaws in the web application.
    In this topic, we'll be going through some custom test cases to understand how
    to fuzz a web application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的HTTP头通常被Web服务器用来处理客户端请求。在进行Web应用程序渗透测试时，建议了解Web应用程序的工作原理以及Web应用程序服务器如何处理请求头（标准和非标准）。更好地了解Web应用程序可以帮助我们定义一些相当不错的模糊向量，从而大大增加在Web应用程序中找到逻辑缺陷的可能性。在本主题中，我们将通过一些自定义测试案例来了解如何对Web应用程序进行模糊测试。
- en: Scenario 1 – Cookie header fuzzing
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景1 - Cookie头部模糊
- en: 'Let''s take a look at the following scenario. We have a PHP file, `- cookie_test.php`.
    We request this file with the `Cookie` flag as `lang=en_us.php`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个场景。我们有一个PHP文件，名为`- cookie_test.php`。我们使用`Cookie`标志请求这个文件，值为`lang=en_us.php`：
- en: '![](img/f907ce35-6c74-40d8-974d-31c5852ff288.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f907ce35-6c74-40d8-974d-31c5852ff288.png)'
- en: 'The server responds with the message Language in use: *English*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应消息为正在使用的语言：*英语*：
- en: '![](img/4325003b-aaaa-4a0d-9d78-8e8297ce34c8.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4325003b-aaaa-4a0d-9d78-8e8297ce34c8.png)'
- en: From the `en_us.php` file, we may think that the `cookie` parameter is including
    the file from the server (file inclusion) and executing the file, which, in turn,
    is printing the message from the server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从`en_us.php`文件中，我们可能会认为`cookie`参数正在从服务器包含文件（文件包含）并执行文件，然后打印服务器的消息。
- en: 'Let''s now see how we can fuzz the `cookie` header using **Wfuzz**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用**Wfuzz**模糊`cookie`头部：
- en: '![](img/a43071e4-195f-4331-bd11-9c1795df1329.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a43071e4-195f-4331-bd11-9c1795df1329.png)'
- en: 'As we can see in the preceding screenshot, the `-b` option is used to provide
    the `cookie` value, and we used `lang=FUZZ`. Using fuzz vectors based on web application
    attacks, we were able to find the payloads, using which the server responds with
    a different response length. Here, we used one of the payloads found by the fuzzer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上述截图中所看到的，`-b`选项用于提供`cookie`值，我们使用了`lang=FUZZ`。使用基于Web应用程序攻击的模糊向量，我们能够找到服务器响应长度不同的有效载荷。在这里，我们使用了fuzzer找到的有效载荷之一：
- en: '![](img/1dd33b80-ed49-433d-aa23-1b25d9468162.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dd33b80-ed49-433d-aa23-1b25d9468162.png)'
- en: 'We were able to confirm the existence of a file inclusion vulnerability:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够确认存在文件包含漏洞。
- en: '![](img/79d44d89-396a-4c6b-815d-3891d9b87eb7.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79d44d89-396a-4c6b-815d-3891d9b87eb7.png)'
- en: 'The same can be done using **ffuf** by executing the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**ffuf**执行以下命令也可以完成相同的操作：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Burp Suite, we just need to add the payload marker to the `Cookie` header:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Burp Suite，我们只需要将有效载荷标记添加到`Cookie`头部：
- en: '![](img/9e5382b2-b171-43c6-ad2f-a07ee8040a83.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e5382b2-b171-43c6-ad2f-a07ee8040a83.png)'
- en: Similarly, we can fuzz a user-defined `Cookie` header using the same tools.
    Let's have a look into this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用相同的工具来模糊用户定义的`Cookie`头部。让我们来看看这个。
- en: Scenario 2 – User-defined cookie header fuzzing
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景2 - 用户定义的cookie头部模糊
- en: 'This scenario is different to the previous one. In this scenario, we''ll request
    the `cookie_test.php` file from the server with the `lang=en_us` cookie value
    attached to it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况与之前的情况不同。在这种情况下，我们将使用`lang=en_us` cookie值从服务器请求`cookie_test.php`文件：
- en: '![](img/3a3c04d4-653c-44ab-9315-ea001db10402.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a3c04d4-653c-44ab-9315-ea001db10402.png)'
- en: 'The server responds with Unauthorized Access!, as we can see in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应为未经授权的访问！如下截图所示：
- en: '![](img/85a9f71c-fedd-418d-b148-cd4b521dc0ad.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85a9f71c-fedd-418d-b148-cd4b521dc0ad.png)'
- en: 'With just the normal request, the server echoes the defined cookie back to
    us:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用普通请求，服务器将定义的cookie回显给我们：
- en: '![](img/59da639e-6499-4421-8134-404060b7b223.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59da639e-6499-4421-8134-404060b7b223.png)'
- en: 'Let''s say our goal is to access the `home.php` file but it''s restricted right
    now, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标是访问`home.php`文件，但目前受到限制，如下所示：
- en: '![](img/de682f84-8bbc-46f9-9fab-5ca80d9f92ae.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de682f84-8bbc-46f9-9fab-5ca80d9f92ae.png)'
- en: 'As there is no login authentication page where we can authenticate to the server,
    we have to assume that the authentication is being done either on the `User-Agent`
    part or on the `Cookie` part. Let''s assume that the authentication is being done
    by checking the cookie values. A user-defined cookie value can be used by the
    client to connect to the server and successfully authenticate. To fuzz a blind
    user-defined cookie value, let''s execute the following command using wfuzz:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有登录认证页面，我们无法对服务器进行身份验证，我们必须假设身份验证是在`User-Agent`部分或`Cookie`部分进行的。让我们假设身份验证是通过检查cookie值来进行的。客户端可以使用用户定义的cookie值来连接到服务器并成功进行身份验证。为了模糊一个盲目的用户定义的cookie值，让我们使用wfuzz执行以下命令：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/c1a68f1e-ec7a-4c7c-b1bd-c1ffe7849747.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a68f1e-ec7a-4c7c-b1bd-c1ffe7849747.png)'
- en: 'Wow! As we can see in the preceding screenshot, the server responded with a
    different page when a user-defined cookie with the value `Cookie: admin=admin;`
    was inserted. Let''s use the same user-defined cookie parameter name and value
    to request the same page:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '哇！正如我们在上述截图中所看到的，当插入一个具有值`Cookie: admin=admin;`的用户定义的cookie时，服务器响应了一个不同的页面。让我们使用相同的用户定义的cookie参数名称和值来请求相同的页面：'
- en: '![](img/3f9648d5-8084-47b5-9a56-4113c07cb214.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f9648d5-8084-47b5-9a56-4113c07cb214.png)'
- en: 'As we can see in the following screenshot, the server is redirecting us to
    the `home.php` page:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到服务器正在将我们重定向到`home.php`页面：
- en: '![](img/f4c616a2-02f6-41cd-ac4a-6443cdcd1531.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4c616a2-02f6-41cd-ac4a-6443cdcd1531.png)'
- en: 'Fuzzing the user-defined cookie parameter name and value, we were able to authenticate
    using the `cookie_test.php` page to access the `home.php` page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模糊用户定义的cookie参数名称和值，我们能够使用`cookie_test.php`页面进行身份验证，以访问`home.php`页面：
- en: '![](img/2c01f185-880d-4931-b857-8387489d6b28.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c01f185-880d-4931-b857-8387489d6b28.png)'
- en: The same method could be used to find a variety of vulnerabilities, such as
    SQL injections, XSS, and RCE.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法可以用来发现各种漏洞，如SQL注入，XSS和RCE。
- en: 'Note: It all depends on the web application and how the web application processes
    the `Cookie` header. If the `Сookie` header is just used to provide a temporary
    session by the server to the client, there''s not much we can do other than test
    session-based vulnerabilities.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这完全取决于Web应用程序以及Web应用程序如何处理`Cookie`头部。如果`Сookie`头部只是用于服务器向客户端提供临时会话，那么我们除了测试基于会话的漏洞之外，别无他法。
- en: Other standard headers can also be fuzzed, including `User-Agent`, `Host`, `Accept`,
    and `Content-Type`. In the case of fuzzing non-standard HTTP headers, we can use
    a wordlist to check the server response for each and every header requested by
    the fuzzer. Sometimes, by using these non-standard headers, such as X-Forwarded-For
    and others, we can bypass the IP-based access restriction placed on the application
    by the server.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准头部也可以进行模糊，包括`User-Agent`，`Host`，`Accept`和`Content-Type`。在模糊非标准HTTP头部的情况下，我们可以使用一个单词列表来检查fuzzer请求的每个头部的服务器响应。有时，通过使用这些非标准头部，如X-Forwarded-For等，我们可以绕过服务器对应用程序设置的基于IP的访问限制。
- en: Fuzzing a custom header using Wfuzz, ffuf, and Burp Suite
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Wfuzz，ffuf和Burp Suite模糊自定义头部
- en: In a number of web applications, the developer introduces some custom HTTP headers
    that are then parsed when a request is processed. From generating a user-specific
    token to allowing access control through such custom headers, these headers have
    a different level of functionality altogether. In such scenarios, sometimes, the
    developer forgets to sanitize the user input, which, in turn, could become a target
    for exploitation. Let's see how we can fuzz custom headers using Wfuzz, ffuf,
    and Burp Suite.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多网络应用程序中，开发人员引入了一些自定义的HTTP头，当请求被处理时，这些头就会被解析。从生成用户特定令牌到通过这些自定义头实现访问控制，这些头具有完全不同的功能级别。在这种情况下，有时开发人员会忘记对用户输入进行消毒，这反过来可能成为利用的目标。让我们看看如何使用Wfuzz、ffuf和Burp
    Suite来模糊自定义头。
- en: Scenario 3 – Custom header fuzzing
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景3 - 自定义头模糊
- en: 'In this scenario, we have an application running on PHP – `custom_header.php`.
    We request the following page from the server:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个运行在PHP上的应用程序 - `custom_header.php`。我们从服务器请求以下页面：
- en: '![](img/0045ba2f-03b2-4731-aea7-517f538ed962.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0045ba2f-03b2-4731-aea7-517f538ed962.png)
- en: 'The server responds with an Unauthorized Access! message and two unknown headers
    – `X-isAdmin: false` and `X-User: Joe` (as we can see in the following screenshot):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '服务器以未经授权的访问！消息和两个未知的头部 - `X-isAdmin: false`和`X-User: Joe`（正如我们在下面的屏幕截图中所看到的）做出回应：'
- en: '![](img/7e7db2c9-1969-459a-ac0a-942f9daee7d1.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7e7db2c9-1969-459a-ac0a-942f9daee7d1.png)
- en: 'The message from the server is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的消息如下：
- en: '![](img/35912b35-cb43-45a7-aa6c-48e8c18811d4.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/35912b35-cb43-45a7-aa6c-48e8c18811d4.png)
- en: 'By observing these two custom headers, we can assume that the server is processing
    these headers as well. The first header, that is, `X-isAdmin`, looks like a custom
    header accepting Boolean values: `true` or `false`. The other header, `X-User`,
    maybe accepts the user''s first name, so the value is in a string format. Let''s
    use **Wfuzz** to fuzz through these headers and find out what can we do about
    it. Let''s execute the following command in **Wfuzz**:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察这两个自定义头，我们可以假设服务器也在处理这些头。第一个头，即`X-isAdmin`，看起来像是一个接受布尔值`true`或`false`的自定义头。另一个头，`X-User`，可能接受用户的名字，所以值是字符串格式。让我们使用**Wfuzz**来模糊这些头，找出我们能做些什么。让我们在**Wfuzz**中执行以下命令：
- en: '[PRE9]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了上述命令的输出：
- en: '![](img/20e2586b-6999-4ada-99a0-690b403b5702.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/20e2586b-6999-4ada-99a0-690b403b5702.png)
- en: 'We can use the `-H` flag at multiple locations in the HTTP request. Now that
    we''re getting the same responses from the server, let''s filter out the results
    based on character length (the `--hh` flag):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在HTTP请求中的多个位置使用`-H`标志。现在我们从服务器得到了相同的响应，让我们根据字符长度过滤结果（`--hh`标志）：
- en: '![](img/681defe9-2e9e-455d-938d-346f0e7fbb76.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/681defe9-2e9e-455d-938d-346f0e7fbb76.png)
- en: 'Incredible! We found the value for `X-isAdmin: true` and `X-User: Billy`. This
    means that Billy is the admin here. Using this custom header in the HTTP request,
    let''s see whether we can access the page:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '不可思议！我们找到了`X-isAdmin: true`和`X-User: Billy`的值。这意味着Billy是管理员。使用这个自定义头在HTTP请求中，让我们看看我们是否能访问页面：'
- en: '![](img/7ffc3c57-317f-4354-8074-c4dd4636f9b0.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7ffc3c57-317f-4354-8074-c4dd4636f9b0.png)
- en: 'As we can see in the following screenshot, we were able to authenticate with
    the page using custom HTTP headers and following the authentication, the server
    redirects us to the `home.php` page:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的屏幕截图中所看到的，我们能够使用自定义的HTTP头进行身份验证，并在身份验证后，服务器将我们重定向到`home.php`页面：
- en: '![](img/3b970bdd-0872-4c20-b139-d72256846f17.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3b970bdd-0872-4c20-b139-d72256846f17.png)
- en: 'The `home.php` page looks as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.php`页面如下所示：'
- en: '![](img/d0a8de11-cdfe-4262-860b-7595ffcc0674.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/d0a8de11-cdfe-4262-860b-7595ffcc0674.png)
- en: 'Now that we have some clarity regarding fuzzing HTTP request headers, we can
    use similar fuzzing techniques on HTTP `POST` parameters as well, which we can
    see in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对模糊HTTP请求头有了一些清晰的认识，我们也可以在HTTP `POST`参数上使用类似的模糊技术，我们可以在下面的屏幕截图中看到：
- en: '![](img/5214d1b6-2d45-4bea-add1-52fcb68f7847.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/5214d1b6-2d45-4bea-add1-52fcb68f7847.png)
- en: In the same way, we can also fuzz the HTTP `POST` parameters to find APIs supported
    by the application and the acceptable values supported by those API parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以对HTTP `POST`参数进行模糊测试，以找到应用程序支持的API和这些API参数支持的可接受值。
- en: Performing fuzz testing on web application attack vectors can provide us with
    more insights into web application penetration testing. It's always a good practice
    to log each request and response when the fuzzer finds something interesting.
    Lastly, fuzz testing is quite effective if elaborative fuzzing data is provided
    to the fuzzer. In most cases, fuzz testing can find code execution and other technical
    vulnerabilities that a generic web application scanner cannot.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对Web应用程序攻击向量进行模糊测试可以为我们提供更多关于Web应用程序渗透测试的见解。当模糊器发现有趣的东西时，记录每个请求和响应总是一个好习惯。最后，如果向模糊器提供详细的模糊数据，模糊测试就会非常有效。在大多数情况下，模糊测试可以找到代码执行和其他技术漏洞，这是通用Web应用程序扫描器无法找到的。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we first learned about the basics of fuzzing and the different
    types of fuzzing attacks. Then, we moved deeper into web application fuzzing and
    looked at the installation of **Wfuzz** and **ffuf**. After that, we performed
    fuzzing on HTTP request verbs and request URIs. Toward the end of the chapter,
    we looked at three scenarios: cookie header fuzzing, user-defined cookie header
    fuzzing, and custom header fuzzing. Having learned about fuzz testing, you can
    now understand the behavior of a web application, which will help you to find
    technical as well as logical vulnerabilities. You can use fuzz testing as part
    of your regular penetration testing while doing bug bounties, or while playing
    challenging **Capture The Flags** (**CTFs**).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了模糊测试的基础知识和不同类型的模糊攻击。然后，我们深入研究了Web应用程序模糊测试，并查看了**Wfuzz**和**ffuf**的安装。之后，我们对HTTP请求动词和请求URI进行了模糊测试。在本章的最后，我们看了三种情景：cookie头部模糊测试，用户定义的cookie头部模糊测试和自定义头部模糊测试。通过学习模糊测试，您现在可以了解Web应用程序的行为，这将帮助您发现技术和逻辑漏洞。您可以在进行漏洞赏金、或者参加具有挑战性的**夺旗赛**（**CTFs**）时，将模糊测试作为常规渗透测试的一部分。
- en: In the next chapter, we will look at the key points that must be included in
    penetration testing reports.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下渗透测试报告中必须包括的关键要点。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can I perform fuzzing on SSL-based web applications?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以对基于SSL的Web应用程序执行模糊测试吗？
- en: Are these fuzzers (the ones mentioned in this chapter) supported in Windows?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些模糊测试工具（本章提到的）在Windows中受支持吗？
- en: Do I need to perform fuzzing in all web application penetration tests?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我需要在所有Web应用程序渗透测试中执行模糊测试吗？
- en: What kinds of vulnerabilities will I find if I perform fuzzing?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我执行模糊测试，会发现什么样的漏洞？
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Wfuzz download page: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wfuzz下载页面：[https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)
- en: 'ffuf download page: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ffuf下载页面：[https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
- en: 'Burp Suite official site: [https://portswigger.net/burp](https://portswigger.net/burp)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burp Suite官方网站：[https://portswigger.net/burp](https://portswigger.net/burp)
- en: 'Understanding the basics of fuzzing: [https://owasp.org/www-community/Fuzzing](https://owasp.org/www-community/Fuzzing)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模糊测试的基础知识：[https://owasp.org/www-community/Fuzzing](https://owasp.org/www-community/Fuzzing)
- en: 'Learning about web application attack vectors: [https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf](https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Web应用程序攻击向量：[https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf](https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf)
