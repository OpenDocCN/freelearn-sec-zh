- en: '*Chapter 16*: Using Cryptography'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：使用密码学'
- en: If you're new to **cryptography**, let's talk about its purpose. I'm going to
    try to make this easy to understand, because to some folks, cryptography can be
    overwhelming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是**密码学**的新手，我们来谈谈它的目的。我会尽量让它简单易懂，因为对于一些人来说，密码学可能让人感到难以应对。
- en: Cryptography is all about protecting data, usually in the form of messages or
    files. This can be done by taking data and transforming it into an unreadable
    format, often called **ciphertext**. The only way to transform the ciphertext
    back into readable data is with a **special key**, which only the sender and recipient
    of the message have access to. This process is called **encryption**, and it's
    the basis of how cryptography works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学的核心就是保护数据，通常是以消息或文件的形式。这可以通过将数据转换成不可读的格式来实现，这种格式通常被称为**密文**。将密文转换回可读数据的唯一方法是使用**特殊密钥**，只有发送者和接收者才能访问该密钥。这个过程叫做**加密**，它是密码学工作原理的基础。
- en: When you're through with this chapter, my hope is that you'll come away with
    an added perspective and greater depth of understanding of the essential role
    cryptography plays in the guarding and protecting of information and digital communication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本章后，我希望你能带着更广泛的视角和对密码学在保护信息和数字通信方面的核心作用有更深入的理解。
- en: 'Here is what we''ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下内容：
- en: Understanding cryptography
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解密码学
- en: Standards and protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准与协议
- en: Countermeasures for cryptography
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学的对策
- en: Let's first discuss why cryptology is important to our security efforts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论密码学为何对我们的安全工作至关重要。
- en: Understanding cryptography
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解密码学
- en: In this section, we'll discuss why cryptology is important and some of the best
    cryptology tools and resources available to us. Having knowledge of the proper
    tools and resources will be invaluable to you as a security professional. So,
    let's jump in and discuss what this is all about.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论为什么密码学如此重要，以及一些可供我们使用的最佳密码学工具和资源。掌握适当的工具和资源对你作为一名安全专家来说将是非常宝贵的。所以，让我们开始讨论这究竟是什么。
- en: Why use cryptology?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用密码学？
- en: So, what does cryptography bring to the table? Well, it brings **non-repudiation**.
    This means that whoever sent a message can't later deny having altered the document.
    For example, *"It wasn't me, Dale, I swear,"* to which I'll reply, *"No, it was
    you because it was encrypted with your key."*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，密码学为我们带来了什么呢？它带来了**不可否认性**。这意味着发送消息的人不能后悔或否认自己修改了文档。例如，*“不是我，Dale，我发誓，”*
    我会回答，*“不，是你，因为它是用你的密钥加密的。”*
- en: Cryptography also brings **authentication** to the table. Sometimes we visit
    websites where it's important that we authenticate who we say we are, as well
    as obviously wanting to authenticate our credit card information, right? So, it's
    important to us, especially to those within our industry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学还带来了**认证**功能。有时我们访问网站时，验证我们身份的真实性至关重要，显然，我们也想验证我们的信用卡信息，对吧？所以，这对我们来说非常重要，尤其是对我们行业中的人们而言。
- en: And, of course, **confidentiality** is another major factor as far as what cryptography
    can do for us. As far as confidentiality is concerned, we can only make certain
    resources available to authorized users. Now, as far as how this process works
    or how cryptography works, these are at a very plain or elementary level. The
    process goes like this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，**保密性**是密码学能为我们做的另一大重要因素。就保密性而言，我们只能将某些资源提供给授权用户。至于这个过程是如何运作的，或者说密码学如何运作，这些内容都是非常基础或初步的。过程如下。
- en: We have **plaintext**; this is the text that is formatted and that we can read.
    Maybe it's a Word document, maybe it's an email, but it gets encrypted using an
    algorithm, such as the **Data Encryption Standard** (**DES**) or the **Advanced
    Encryption Standard** (**AES**), or even **Rivest—Shamir—Adleman** (**RSA**).
    After the encryption has been applied, we refer to that whole document as ciphertext.
    It's completely unreadable. This file is then transmitted, and on the opposite
    end, it just goes through the opposite process, right? The ciphertext uses the
    keys it's aware of to do decryption, and then it gives us the plaintext that the
    original sender or the resource wanted us to see.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有**明文**；这是可以格式化并且我们可以读取的文本。它可能是一个Word文档，可能是一个电子邮件，但它会通过某种算法进行加密，例如**数据加密标准**（**DES**）或**高级加密标准**（**AES**），甚至是**里维斯—沙米尔—阿德尔曼**（**RSA**）。加密应用后，我们称整个文档为密文。它完全无法读取。这个文件随后会被传输，在另一端，它会经历相反的过程，对吗？密文会使用已知的密钥进行解密，然后给我们展示原始发送者或资源希望我们看到的明文。
- en: Cryptography is an important part of keeping our information safe and secure
    and is used in a variety of different applications. Everything from our email
    to our financial information is protected by cryptography, and it's important
    to understand how it works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学是确保我们信息安全的重要组成部分，并且在各种不同的应用中都得到了广泛使用。从我们的电子邮件到金融信息，都受到加密技术的保护，因此理解其工作原理非常重要。
- en: See? I told you this would be easy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧？我告诉过你这很简单。
- en: Next, let's talk about the types of cryptography.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈加密技术的类型。
- en: Types of cryptography
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密技术的类型
- en: 'There''s not a whole lot of talking to do on this subject because guess what?
    There are only two, symmetric and asymmetric:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题没有太多要讲的，因为你猜怎么着？它只有两种类型：对称加密和非对称加密：
- en: '**Symmetric cryptography** is all about using the same key for both encryption
    and decryption. So, what we have are a sender and a recipient, and they''re going
    to use the same key to encrypt the message they want to send back and forth. It''s
    very fast, it''s very efficient, but it also has a couple of major drawbacks:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密**完全是使用相同的密钥进行加密和解密。因此，我们有一个发送方和一个接收方，他们将使用相同的密钥加密他们想要往返发送的消息。它非常快速，也非常高效，但也有几个主要的缺点：'
- en: The first is, if you lose that key, then you've lost all access to the information
    that's been encrypted.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是，如果你丢失了那个密钥，那么你就失去了对加密信息的所有访问权限。
- en: And second, it's very difficult to manage large-scale deployments of symmetric
    cryptography.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，管理大规模的对称加密部署非常困难。
- en: '**Asymmetric cryptography** is just about as opposite of symmetric cryptography
    as you can get. Rather than using one key to do both encryption and decryption,
    it uses two keys, a public key and a private key:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称加密**几乎可以说是与对称加密的完全对立。与使用一个密钥进行加密和解密不同，非对称加密使用两个密钥，一个公钥和一个私钥：'
- en: The first key is the **public key** and it's a key anybody can have access to.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个密钥是**公钥**，它是任何人都可以访问的密钥。
- en: The second key is the **private key**, and it's meant to be known only by the
    owner. It should never be given to anybody else. And, the great thing about this
    is that, if you use a public key to encrypt information, the only way to decrypt
    it is by using the corresponding private key. So, even if somebody were to intercept
    that message, they wouldn't be able to do anything with it because they don't
    have access to the private key.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个密钥是**私钥**，它应该仅为所有者所知。绝不应将其交给其他任何人。而且，关于这一点的好消息是，如果你使用公钥加密信息，那么解密它的唯一方式就是使用相应的私钥。因此，即使有人拦截了消息，他们也无法做任何事情，因为他们没有私钥的访问权限。
- en: The other great thing about asymmetric cryptography is that it doesn't require
    a secure initial exchange of keys like symmetric cryptography does. So, it's a
    little bit more secure in that sense. It's not perfect, but it's definitely more
    secure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密的另一个优点是，它不需要像对称加密那样进行安全的初始密钥交换。因此，在这方面它稍微更安全。它不是完美的，但肯定更安全。
- en: Asymmetric also utilizes **digital signatures**. Digital signatures are just
    a way to ensure the message has not been tampered with in transit. And, the way
    that this works is the sender of the message will use their private key to encrypt
    it, and they'll send both the message and their public key to the recipient. The
    recipient can then use the sender's public key to decrypt the message and then
    they can compare it to the original message to ensure it hasn't been tampered
    with.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密也使用**数字签名**。数字签名只是确保消息在传输过程中没有被篡改的一种方式。其工作原理是，消息的发送者使用他们的私钥对消息进行加密，并将消息和他们的公钥一起发送给接收者。接收者可以使用发送者的公钥解密消息，然后将其与原始消息进行对比，确保消息未被篡改。
- en: Now, it does have some cons to it. It's a little bit slower than symmetric cryptography
    (we're talking about half an eyeblink versus a full eyeblink), and it also requires
    more bandwidth. But overall, it's a much more secure way to send information.
    Now, nothing is foolproof, right? If I've taught you anything through this series,
    it's that there's always a way. When it comes to asymmetric, it is susceptible
    to **man-in-the-middle** (**MITM**) attacks, as well as **brute-force** **attacks**.
    And, unfortunately, if the private key gets lost, then there's really no way to
    decrypt the information that's been encrypted with it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它也有一些缺点。它比对称加密略慢一点（我们说的是半个眼皮眨眼的时间和完全眨眼的时间），而且也需要更多的带宽。但总体来说，这是一种更安全的信息传输方式。现在，没有什么是万无一失的，对吧？如果通过这一系列的内容我教会了你什么，那就是总有破解的办法。对于非对称加密，它容易受到**中间人攻击**（**MITM**）和**暴力破解**攻击的威胁。而且，不幸的是，如果私钥丢失了，那么就没有办法解密用它加密的信息。
- en: Let's discuss some other keys next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论一些其他的密钥。
- en: GAK
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GAK
- en: The **Government Access Key** (**GAK**) is a system proposed by the United States
    **National Security Agency** (**NSA**) to allow government access to encrypted
    communications. The key would be a mathematical value that would be used to decrypt
    messages. The existence of such a key would make it possible for the NSA to read
    encrypted communications, including those between citizens and businesses, as
    well as between different countries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**政府访问密钥**（**GAK**）是美国**国家安全局**（**NSA**）提出的一个系统，旨在允许政府访问加密通信。该密钥将是一个数学值，用于解密消息。这样的密钥的存在将使NSA能够读取加密通信，包括公民和企业之间的通信，以及不同国家之间的通信。'
- en: 'The problem with this system is that it would require a key that is incredibly
    complex and difficult to generate. And, of course, the NSA would need to keep
    this key completely secret. If the key were to get out, then anybody could use
    it to read encrypted communications. Has anyone seen the 1991 movie *Sneakers*
    starring Robert Redford? Talk about a movie that predicted the future of encryption!
    (*Homework assignment from Dale: watch this movie!*).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的问题在于，它需要一个极其复杂且难以生成的密钥。当然，NSA需要完全保密这个密钥。如果这个密钥泄露出去，那么任何人都可以用它来读取加密通信。有没有人看过1991年上映的电影*《偷天换日》*，主演是罗伯特·雷德福？这部电影可谓预测了加密技术的未来！(*Dale的家庭作业：观看这部电影！*)
- en: Another problem with GAK is that it would be very difficult to implement. Any
    change to the encryption algorithms used by businesses and governments would need
    to be approved by the NSA. This would give the NSA a lot of power, and it's not
    clear that they could be trusted with such power.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: GAK的另一个问题是，它将非常难以实现。任何对企业和政府所使用的加密算法的更改都需要经过NSA的批准。这将赋予NSA巨大的权力，而且目前还不清楚是否可以信任他们拥有如此大的权力。
- en: It's also worth noting the NSA is not the only government agency interested
    in reading encrypted communications. The United Kingdom's **Government Communications
    Headquarters** (**GCHQ**) has also expressed an interest in a system that would
    allow them to read encrypted communications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样值得注意的是，NSA并不是唯一一个对读取加密通信感兴趣的政府机构。英国的**政府通信总部**（**GCHQ**）也表达了对一种可以让他们读取加密通信的系统的兴趣。
- en: Let's continue to talk further about another tool for encryption next called
    **ciphers**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们继续讨论另一个加密工具，叫做**密码**。
- en: Learning about ciphers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解密码
- en: What we're talking about when it comes to ciphers is an algorithm. You can think
    of it as a defined series of steps that have to be performed for the encryption
    and decryption process to occur. Once a message or data has been encrypted using
    a cipher, it is considered unreadable unless, of course, whoever's receiving the
    data or message knows the secret key that's required to decrypt it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论密码时，其实是在讨论一个算法。你可以把它看作是一个定义好的步骤序列，必须按照这个序列来执行加密和解密过程。一旦消息或数据通过某种密码加密，它就会被认为是不可读的，除非接收消息或数据的人知道解密所需的秘密密钥。
- en: Now, believe it or not, ciphers are used everywhere, not just in our emails
    and our data itself, but we also use them in other communication technologies,
    such as cell phones. This is what makes our cell phone calls more secure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，信不信由你，密码实际上无处不在，不仅仅是在我们的电子邮件和数据中，我们还在其他通讯技术中使用它们，比如手机。这使得我们的手机通话更加安全。
- en: Types of ciphers
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码类型
- en: 'Now, I know what you''re thinking: *"Dale, is there only one cipher?"* No,
    there are several different types of ciphers. We can categorize them into two
    different types, either classical or modern. I know, it sounds like we''re going
    to talk about art, but we''re not.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道你在想什么：*“Dale，只有一种密码吗？”* 不，实际上有几种不同类型的密码。我们可以将它们分为两种类型，要么是经典的，要么是现代的。我知道，这听起来像是我们要讨论艺术，但我们并不会讨论这个。
- en: Let's look at classical and modern ciphers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下经典密码和现代密码。
- en: Classical ciphers
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 经典密码
- en: '**Classical ciphers** are those that were developed before the invention of
    the computer. They include classical ciphers such as the **Caesar cipher**, which
    is a simple **substitution cipher**, where each letter of the alphabet is replaced
    with another letter according to a defined pattern. *Figure 16.1* is an example
    of a Caesar cipher:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**经典密码**是指在计算机发明之前开发的密码。它们包括经典密码，例如**凯撒密码**，这是一种简单的**替换密码**，其中每个字母都根据定义的模式替换为另一个字母。*图16.1*是凯撒密码的示例：'
- en: '![Figure 16.1 – Example of a Caesar cipher (a simple substitution of letters)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – 凯撒密码示例（简单的字母替换）'
- en: '](Images/B17486_16_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_01.jpg)'
- en: Figure 16.1 – Example of a Caesar cipher (a simple substitution of letters)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 凯撒密码示例（简单的字母替换）
- en: So, in this case here, **MY VOICE IS MY PASSWORD**, as you can see, gets translated
    to **DB XGOET OL DB HALLCGKR**. All we're doing is basically replacing the **M**
    with another letter, in this case, **D**. Notice how **DB** represents **MY**
    in both instances. This would help me to figure out how to decrypt this message,
    given enough time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这个例子中，**MY VOICE IS MY PASSWORD**，如你所见，会被转换为 **DB XGOET OL DB HALLCGKR**。我们所做的就是基本上将**M**替换为另一个字母，在这个例子中是**D**。注意到**DB**在两个实例中都代表**MY**。这将帮助我在有足够时间的情况下，弄清楚如何解密这条消息。
- en: 'Another type of classical cipher is referred to as a **transposition**. In
    a transposition, you use what they refer to as a **key**. Now, depending on the
    transposition cipher that you''re using, in this case, I''m showing you (in *Figure
    16.2*) what they refer to as a **rail fence cipher**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种经典密码被称为**换位密码**。在换位密码中，你使用一种被称为**密钥**的东西。现在，根据你使用的换位密码，这里我展示的是（在*图16.2*中）一种被称为**铁路线密码**：
- en: '![Figure 16.2 – Example of a rail fence cipher'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 – 铁路线密码示例'
- en: '](Images/B17486_16_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_02.jpg)'
- en: Figure 16.2 – Example of a rail fence cipher
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 铁路线密码示例
- en: In this case, the key is **3**, which means there are three spaces between characters.
    You see that **MY VOICE IS MY PASSWORD** is spelled out in this up-and-down method,
    and the spaces in between are kind of ignored completely. So, the first line ends
    up becoming just **MISAO** while the next line of code would be just simply **YOCIMPSWR**,
    and the third row would just simply equal **VEYSD**. Now, obviously, the recipient
    would have to know that the key is **3** to decrypt this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，密钥是**3**，意味着字符之间有三个空格。你可以看到，**MY VOICE IS MY PASSWORD**被以这种上下排列的方法拼写出来，中间的空格几乎完全被忽略。所以，第一行最终变成了**MISAO**，而下一行的代码则变成了**YOCIMPSWR**，第三行则变成了**VEYSD**。显然，接收方需要知道密钥是**3**才能解密此消息。
- en: 'Another type of transposition cipher is a **route cipher**. With the route
    cipher, we end up taking the same data or information we''re trying to encrypt.
    In *Figure 16.3*, I''m going to use the text, **MY VOICE IS MY PASSWORD**, and
    I''m going to lay it out like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种换位密码是**路线密码**。使用路线密码时，我们会对要加密的相同数据或信息进行处理。在*图16.3*中，我将使用文本**MY VOICE IS MY
    PASSWORD**，并像这样排列它：
- en: '![Figure 16.3 – Example of a route cipher'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 – 路由密码示例'
- en: '](Images/B17486_16_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_03.jpg)'
- en: Figure 16.3 – Example of a route cipher
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 路由密码示例
- en: Can you see it all there? So, it lays the plaintext out in a grid pattern just
    like this, and, of course, the last two characters are just random characters.
    This type of cipher is determined based on the route.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到所有内容吗？它将明文按照网格模式展示，就像这样，当然，最后两个字符只是随机字符。这种类型的密码是根据路由决定的。
- en: Those are just some quick examples of classical ciphers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是经典密码的一些快速示例。
- en: Let's look at modern ciphers next.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来看一下现代密码。
- en: Modern ciphers
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现代密码
- en: You can see with the classical type how easy it would be to crack those types
    of ciphers. With modern ciphers, they're a little bit more difficult to try to
    crack manually. And typically, modern ciphers are there to provide authenticity,
    security, and integrity to the sender.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到经典密码类型是多么容易被破解。现代密码相对来说更难手动破解。通常，现代密码的目的是为发送者提供真实性、安全性和完整性。
- en: The types of modern ciphers you'll see are both symmetric and asymmetric. While
    I'm talking about it, there's a way to use both asymmetric and symmetric at the
    same time, but that might be going a little too deep here, so I'm just going to
    leave that up to you. If you want to do a little bit more research, you can look
    at that further.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的现代密码类型包括对称密码和非对称密码。在我谈到这些时，其实有一种方法可以同时使用非对称和对称密码，但这可能有些深入，因此我就不在这里展开讲解了，如果你想深入研究，可以进一步查阅相关资料。
- en: There are also ciphers that are based on the input of data. We have what they
    refer to as a **block cipher**, and what we mean by *block* is the algorithm operates
    in groups of bits or a block of a fixed size. Most of the cryptography we see
    today, such as DES, AES, or even the **International Data Encryption Algorithm**
    (**IDEA**), are all using block-based ciphers. Now, if by chance, the block size
    of the data coming across is less than what is used by the cipher itself, there's
    some padding that helps to make sure it achieves the block size that's needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些密码是基于数据输入的。我们有一种叫做**分组密码**的密码，所谓的*分组*就是算法以比特组或固定大小的块为单位进行运算。我们今天看到的大多数密码学算法，如DES、AES，甚至**国际数据加密算法**（**IDEA**），都是使用基于分组的密码。现在，如果传输的数据块大小小于密码本身使用的块大小，就会有一些填充，以确保它达到所需的块大小。
- en: There are also **stream ciphers**. When it comes to a stream cipher, we're basically
    talking about a symmetric key cipher, where the plaintext digit is combined with
    a pseudorandom cipher digit stream, which we sometimes refer to as a **keystream**.
    In a stream cipher, each character is encrypted one at a time, and with it goes
    a corresponding digit of the keystream; this gives us a cyber-text digit stream.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有**流密码**。说到流密码，实际上就是一种对称密钥密码，其中明文数字与伪随机密码数字流相结合，我们有时称之为**密钥流**。在流密码中，每个字符一次加密一个，并且与之对应的密钥流数字也一同加密；这样我们就得到了加密文本数字流。
- en: Let's look at some other types of algorithms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下其他类型的算法。
- en: Using other algorithms
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他算法
- en: When it comes to different algorithms out there, the most common we will see
    are going to be **DES**, **triple DES** (**3DES**), **AES**, and **RC4**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的算法中，我们最常见的包括**DES**、**三重DES**（**3DES**）、**AES**和**RC4**。
- en: Let's discuss these next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来讨论这些。
- en: DES
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DES
- en: This was created back in the 1970s by **IBM**. It utilizes a 64-bit block. On
    top of that, it only uses a 56-bit key for encryption and decryption, which is
    not that great. In fact, in 1999, this algorithm was cracked, especially considering
    the computing power we had back then was not very much. But, DES itself provided
    up to 72 quadrillion possible encryption keys, and we were able to crack it back
    in 1999\. Now, because this was cracked, the US government got involved and helped.
    Now, obviously, to cover this vulnerability, which could be brute force-attacked
    very easily, we came up with triple DES, or some people might call it 3DES. The
    reason it's called 3DES is that it goes through and does the DES algorithm three
    times with three different keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法是在1970年代由**IBM**创建的。它使用64位的块大小。除此之外，它仅使用56位的密钥进行加密和解密，这并不是很安全。事实上，在1999年，这个算法就被攻破了，尤其考虑到当时的计算能力并不强大。但DES本身提供了多达72万亿种可能的加密密钥，而我们在1999年就攻破了它。现在，既然这个算法被攻破了，美国政府介入并提供了帮助。显然，为了弥补这一漏洞，防止其被暴力破解，我们提出了三重DES，或者有人称之为3DES。之所以叫3DES，是因为它通过三次不同的密钥，重复执行DES算法三次。
- en: 'Now, as far as how these keys are used, you have a couple of different options:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于这些密钥的使用方法，你有几种不同的选择：
- en: The first option is all three of the keys are completely different or independent.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种选择是三个密钥完全不同或独立。
- en: The second option is using the **K1** and **K3** keys, but since they're both
    used for encryption, they are identical.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择是使用**K1**和**K3**密钥，但由于它们都用于加密，因此它们是相同的。
- en: And, there's a third option, which is where all three keys are the same, but
    that's not very secure.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，还有第三种选择，那就是三个密钥相同，但这并不十分安全。
- en: The most secure would be the first option, which is where all three keys are
    independent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的选择是第一种方式，即所有三个密钥都是独立的。
- en: AES
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AES
- en: AES is kind of a fully grown adult compared to DES and 3DES. It utilizes a 128-bit
    block size, and its keys are 128, 192, or 256-bit in size. I bet you can't guess
    what they call each one of those, right? They're called **AES128**, **AES192**,
    and **AES256**. That was tricky, wasn't it? AES is a symmetric-key algorithm,
    created with the help of the **National Institute of Standards and Technology**
    (**NIST**). The government agencies use this for encrypting data that is considered
    unclassified.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与 DES 和 3DES 相比，AES可以算是一个完全成熟的成人。它采用128位的块大小，密钥长度为128、192或256位。我敢打赌，你一定猜不到它们各自的名字，对吧？它们分别被称为**AES128**、**AES192**和**AES256**。这有点难猜，是吧？AES是一种对称密钥算法，创建时得到了**国家标准与技术研究院**（**NIST**）的帮助。政府机构用它来加密被认为是非机密的数据。
- en: RC4
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RC4
- en: Some folks call it **Ron Rivest**. Ron is the first name of the gentleman who
    helped create it, but the cipher is called Ron Rivest; it's **Rivest Cipher 4**.
    Now, this cipher is considered a variable key size symmetric keystream cipher.
    And, let's be honest, it's not that great because guess what? We use this in **Wired
    Equivalent Privacy** (**WEP**), which is the wireless security protocol that's
    been hacked very, very easily.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人称之为**Ron Rivest**。Ron是帮助创建这个密码的先生的名字，但这个密码叫做Ron Rivest，它是**Rivest Cipher
    4**。这个密码被认为是一个可变密钥长度的对称密钥流密码。老实说，它并不好，因为你知道吗？我们在**有线等效隐私**（**WEP**）中使用这个加密算法，而WEP是一个被非常容易攻破的无线安全协议。
- en: The reason why RC4 was vulnerable to different types of attacks was that it
    had what they refer to as a **biased output**. There is a rule that if the third
    byte in its original state is *0*, and if the second byte doesn't equal *2*, this
    means the second output byte is always *0*. Now, this may seem complicated, but
    trust me, once we see patterns like this, we're able to go through and reverse
    engineer the cipher and crack it. And, that's what happened to WEP.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: RC4之所以容易受到多种攻击，是因为它存在所谓的**偏置输出**。有一个规则，如果其原始状态下第三个字节为*0*，而第二个字节不等于*2*，则意味着第二个输出字节总是*0*。现在，这可能看起来有些复杂，但相信我，一旦我们看到像这样的模式，我们就能通过逆向工程破译这个密码。这就是WEP被攻破的原因。
- en: Two other algorithms that we should be familiar with are **Blowfish** and **Twofish**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个我们应该熟悉的算法是**Blowfish**和**Twofish**。
- en: Blowfish and Twofish
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Blowfish 和 Twofish
- en: The Blowfish algorithm was developed back in 1993, and I know you're thinking,
    *"Dale, that's a long time ago."* But it's quite a strong symmetric block cipher
    that we still use today. It uses the same key to encrypt and decrypt. It utilizes
    a 64-bit block, and its key is a variable key anywhere from 32 to 448 bits. This
    protocol was designed to replace DES and triple DES.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Blowfish 算法是在 1993 年开发的，我知道你会想，*“Dale，那是很久以前的事了。”* 但它仍然是一个非常强大的对称块加密算法，我们今天仍在使用。它使用相同的密钥来加密和解密。它采用
    64 位块，密钥的长度从 32 位到 448 位不等。这个协议设计的目的是替代 DES 和三重 DES。
- en: Now, it may be surprising to know that a lot of people still enjoy using AES,
    and I guess there's nothing wrong with it, but you need to know that one of the
    advantages of Blowfish is its speed. It breaks things down into a 64-bit block
    as compared to AES, which, by using a 128-bit block, allows for faster encryption
    and decryption.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能会让你感到惊讶的是，很多人仍然喜欢使用 AES，我想这没什么错，但你需要知道 Blowfish 的一个优势就是它的速度。它将数据拆分为 64
    位块，而 AES 使用的是 128 位块，从而实现更快的加密和解密。
- en: We also have something called Twofish. This encryption was created a few years
    after Blowfish. It was introduced to us back in 1998, and it's relatively close
    to the Blowfish cipher. That's why we have a similar name here, but it encrypts
    data with a 128-bit block just like AES. In fact, Twofish is very similar to AES
    because it supports a 256-bit block, as well as a 192 or 128 key size. And, just
    like Blowfish, it uses a single key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个叫做 Twofish 的加密算法。这种加密算法是在 Blowfish 后几年创建的。它是在 1998 年推出的，与 Blowfish 算法非常相似。这就是我们这里有相似名字的原因，但它像
    AES 一样使用 128 位块进行数据加密。实际上，Twofish 与 AES 非常相似，因为它支持 256 位块，以及 192 或 128 位的密钥大小。而且，和
    Blowfish 一样，它使用单一的密钥。
- en: Then, there's **Threefish**, which was developed in 2008 and is a part of the
    Skein algorithm. It is a 12-round Feistel network cipher with a block size of
    128 bits and a key length of 256 bits. Threefish is very fast and very secure,
    with a high degree of resistance to attack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 **Threefish**，它是在 2008 年开发的，是 Skein 算法的一部分。它是一种 12 轮 Feistel 网络加密算法，块大小为
    128 位，密钥长度为 256 位。Threefish 非常快速且安全，具有很高的抗攻击能力。
- en: Now, another reason why both these ciphers are extremely popular is that they
    haven't been patented. They're open-sourced. In fact, Twofish was the algorithm
    that was one of the top five finalists to replace DES for the US government but,
    unfortunately, it didn't win. *But I think it did win Ms. Congeniality. Now I'm
    just kidding.*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个加密算法之所以非常受欢迎的另一个原因是，它们没有被专利保护。它们是开源的。事实上，Twofish 曾是美国政府用来替代 DES 的五个最终候选算法之一，但不幸的是，它没有获胜。*不过我想它赢得了“最具亲和力奖”。现在我只是开玩笑。*
- en: So, now that we've got the most popular algorithms out of the way, in the next
    section, we'll talk about standards and protocols.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经讨论了最流行的算法，在接下来的部分中，我们将讨论标准和协议。
- en: Standards and protocols
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准和协议
- en: Let's talk about some of the most common standards we see out there. In this
    section, we'll talk about more algorithms, hashes, ciphers, and other cryptographic
    mechanisms that will assist you in securing the data and communication you help
    protect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈一些我们在外面看到的最常见的标准。在这一部分，我们将讨论更多的算法、哈希、加密算法以及其他加密机制，帮助你保护数据和通信的安全。
- en: DSA
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DSA
- en: This is a federal information processing standard for creating digital signatures.
    How this signature standard works is that it creates a 320-bit digital signature,
    but the signature is also accompanied by anything from 512- to 1024-bit security.
    It also utilizes our private and public key technology or process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个联邦信息处理标准，用于创建数字签名。这个签名标准的工作原理是，它创建一个 320 位的数字签名，但签名还伴随着 512 位到 1024 位的安全性。它还利用我们的私钥和公钥技术或过程。
- en: RSA
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RSA
- en: Hey, you know what? RSA are the initials of the creators. The *R* is from the
    same *Ron Rivest* from RC4, as well as from two other gentlemen. The *S* is after
    *Shamir,* and the *A* is after *Alderman*. All three of these gentlemen worked
    at the **Massachusetts Institute of Technology** (**MIT**). Rivest and Shamir
    worked as computer scientists and Alderman was a mathematician.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，你知道吗？RSA 是创始人的首字母缩写。*R* 代表与 RC4 中的 *Ron Rivest* 相同的那位，还有另外两位先生。*S* 代表 *Shamir*，而
    *A* 代表 *Alderman*。这三位先生都在**麻省理工学院**（**MIT**）工作过。Rivest 和 Shamir 是计算机科学家，Alderman
    是一位数学家。
- en: 'Now, RSA also uses a public key encryption system and uses two large prime
    numbers as its basis. We see RSA as a standard in a lot of our operating systems
    today: Microsoft, Apple, and Sun Microsystems, as well as being utilized in networking
    cards, smartcards, and even what we refer to as hardware-secured phones. Now,
    this may make your brain hurt a little bit, but let me give you a brief synopsis
    of how this works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，RSA 还使用公钥加密系统，并且以两个大质数为基础。今天我们看到 RSA 是很多操作系统中的标准：微软、苹果、Sun Microsystems，并且广泛应用于网络卡、智能卡，甚至我们所说的硬件加密手机。现在，这可能会让你有点脑袋疼，但让我简要介绍一下它是如何工作的：
- en: 'First, two large prime numbers are taken, and we''re going to call them *A*
    and *B*. These two prime numbers and their product are determined by saying that
    *C* is equal to *A* B*, and *C* (in math, we''d see it this way: *C=AB*) and,
    therefore, *C* is referred to as the **modulus**.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择两个大的质数，我们称它们为 *A* 和 *B*。这两个质数及其乘积通过设置 *C* 等于 *A* 和 *B* 的乘积来确定，*C*（数学上我们可以表示为
    *C=AB*），因此 *C* 被称为 **模数**。
- en: RSA then chooses another number called *E* that is less than *C* and relatively
    prime to *(A-1)(B-1)*. What this does is it makes sure that *E* and *A-1 x B-1*
    have no common factors with each other except for the number *1*.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RSA 然后选择另一个称为 *E* 的数字，它小于 *C* 并且与 *(A-1)(B-1)* 互质。这样做的目的是确保 *E* 和 *A-1 x B-1*
    之间除了数字 *1* 外没有其他共同因子。
- en: I know, it keeps getting better because then RSA chooses another number, *F*,
    and it does this so that *EF-1* is divisible by *A-1 x B-1*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我知道，这越来越好，因为接下来 RSA 选择了另一个数字 *F*，并且这样做是为了让 *EF-1* 能被 *A-1 x B-1* 整除。
- en: Now, some of you *algebra folks* are following right along. But wait, there's
    more. The values of *E* and *F* are referred to as the public and private exponents.
    In using those exponents, the public key is paired with *C* and *E* to create
    that public key, and the private key is created by pairing *C* and *F* together.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一些 *代数爱好者* 跟得上了。但等一下，还有更多内容。*E* 和 *F* 的值分别被称为公钥和私钥的指数。使用这些指数时，公钥通过将 *C* 和
    *E* 配对来生成，而私钥则是通过将 *C* 和 *F* 配对来生成。
- en: Now, the reason why this is extremely secure is that it's considered to be extremely
    difficult to obtain the private key from the public key. Now, obviously, if someone
    can factor *C* into *A* and *B*, then that person could decipher the private key,
    but the odds of somebody trying to get a hold of those two prime numbers that
    are taken at random are almost impossible. So, again, a lot more secure for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种加密方法之所以非常安全，是因为从公钥获取私钥被认为是极其困难的。显然，如果有人能够将 *C* 因式分解为 *A* 和 *B*，那么那个人就可以解密私钥，但几乎不可能有人能够获取这两个随机选择的质数。所以，这对于我们来说再次提高了安全性。
- en: Hashes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希
- en: I'm getting hungry. I think hash browns or just some good cabbage and hash are
    delicious. I've got to get food off my mind here!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始饿了。感觉土豆饼或者一些美味的卷心菜和炖肉非常好吃。我得把食物从脑袋里赶出去！
- en: When it comes to **hashes**, what we're trying to do is come up with a way to
    verify that a particular document hasn't changed. We want to know it's legitimate,
    that it has been signed, and no one has changed or tampered with it. Now, how
    we do this is we take the document, and we assign a **digital signature** associated
    with it. That signature is represented by a hexadecimal code. This code tells
    us the document and the default for this document; if it is equal to the hexadecimal
    code number, we know it's legit, it's been signed, and nobody has changed it.
    This also applies to an executable or an email. But, if somehow the document or
    the executable is changed, that hash value won't work, or it won't calculate out
    correctly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **哈希**，我们试图做的是找出一种方式来验证特定文档是否未被更改。我们想知道它是否合法，是否已经签名，并且没有人修改或篡改它。我们通过将文档与一个
    **数字签名** 相关联来做到这一点。这个签名用十六进制代码表示。这个代码告诉我们文档的默认值，如果它等于十六进制代码数字，我们就知道它是合法的，已经签名，并且没有被更改。这同样适用于可执行文件或电子邮件。但是，如果文档或可执行文件被修改了，那么哈希值就无法正常工作，或者计算结果不正确。
- en: Message digest
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息摘要
- en: When we talk about cryptography, there's something that we need to keep in mind,
    and that is the **message digest**. The message digest is also referred to as
    a **hash value**. What it does is it takes a block of data and produces a unique
    fingerprint or hash value of that data. This is important because when we're talking
    about authentication, we're talking about making sure the data has not been altered
    in any way. And so, this allows us to look at the message and be able to say,
    *"Okay, this is exactly what was sent. It hasn't been changed in any way."*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论加密时，有一件事情我们需要记住，那就是**消息摘要**。消息摘要也被称为**哈希值**。它的作用是取一块数据并生成该数据的唯一指纹或哈希值。这很重要，因为当我们谈论认证时，我们是在确保数据没有被以任何方式更改。因此，这使我们能够查看消息并能够说：“好的，这正是发送的内容。它没有被以任何方式更改。”
- en: Another hash method is referred to as **Secure Hash Algorithm 1** (**SHA-1**)
    and was introduced in 1993 by the NSA. Now, its function is to take the input
    and produce a 160-bit hash value that is then turned into hexadecimal, which is
    about 40 characters long once it's converted. It's typically utilized with other
    protocols or security protocols, such as **Pretty Good Privacy** (**PGP**), **Transport
    Layer Security** (**TLS**), **Secure Shell** (**SSH**), and **Secure Sockets Layer**
    (**SSL**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种哈希方法被称为**安全哈希算法1**（**SHA-1**），于1993年由NSA引入。现在，它的功能是接受输入并生成一个160位的哈希值，然后将其转换为十六进制，一旦转换完成，大约有40个字符长。它通常与其他协议或安全协议一起使用，例如**Pretty
    Good Privacy**（**PGP**）、**传输层安全**（**TLS**）、**安全外壳**（**SSH**）和**安全套接字层**（**SSL**）。
- en: 'Now, I know what you may be thinking: *"Dale, why''d we start with 1? Where''s
    the SHA-0?"* Well, **SHA-0** was 160-bit, but it was so bad it was pulled for
    a significant flaw. Well, they then obviously came out with **SHA-2**. Now, SHA-2
    is extremely similar to SHA-1, but it does use 256-bit, but it is stronger and
    larger than SHA-1\. And, what I mean by that is there are two different block
    sizes that it can use, either **SHA256**, which gives you a **32-bit word**, and
    **SHA256**, which, double it, **64-bit**, right? Guess what?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道你可能在想什么：“*戴尔，为什么我们从1开始？SHA-0在哪里？”* 嗯，**SHA-0**是160位的，但是它太糟糕了，因为存在一个重大缺陷而被淘汰。然后，他们显然推出了**SHA-2**。现在，SHA-2与SHA-1非常相似，但它使用256位，比SHA-1更强大和更大。而且，我所说的是它可以使用两种不同的块大小，要么是**SHA256**，给你一个**32位字**，要么是**SHA256**，双倍，**64位**，对吧？猜猜看？
- en: They then came out with **SHA-3**. It's unlike SHA-2, which was similar to SHA-1
    (and SHA-1 was similar to SHA-0); SHA-3's only likeness is in its name. The reason
    behind it being a completely different beast is that it uses what's referred to
    as **sponge construction**. The data is absorbed, or the input is absorbed, and
    the output or the result is squeezed out. Now, during the absorption process,
    the message blocks themselves are XORed into initial bits of state or a subset.
    That subset is then transformed using a permutation function. So, yeah, it's a
    little bit tougher.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们推出了**SHA-3**。它不像SHA-2，后者类似于SHA-1（而SHA-1类似于SHA-0）；SHA-3唯一相似之处在于其名称。它被称为完全不同的东西的原因是它使用了所谓的**海绵构造**。数据被吸收，或者输入被吸收，输出或结果被挤出来。在吸收过程中，消息块本身被异或到状态的初始位或子集中。然后，使用排列函数转换该子集。所以，是的，这有点困难。
- en: So, now that we've got our hands on these different types of ciphers, there
    are some ciphers that are designed for messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经掌握了这些不同类型的密码，有一些密码是为消息设计的。
- en: Ciphers designed for messages
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为消息设计的密码
- en: We first start with **hash-based message authentication code** (**HMAC**). This
    algorithm includes the embedding of the hash functions, such as SHA-1 or the **message-digest
    algorithm** (**MD5**). Where its strength comes from is dependent upon the embedded
    hash function, key size, and the size of the hash output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从**基于哈希的消息认证码**（**HMAC**）开始。该算法包括嵌入哈希函数，例如SHA-1或**消息摘要算法**（**MD5**）。它的强度取决于嵌入的哈希函数、密钥大小和哈希输出的大小。
- en: How HMAC operates is there are two different stages. Now, in those stages, there's
    a secret key that's created. There's one for an *innie* and one for an *outie*.
    I know, I just made a *belly button* joke. It's **inner** and **outer**, but the
    concept remains the same.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC的操作方式是有两个不同的阶段。在这些阶段中，创建了一个秘密密钥。有一个用于*innie*，一个用于*outie*。我知道，我刚刚开了一个*肚脐*笑话。它是**内部**和**外部**，但概念是相同的。
- en: The first pass of the algorithm produces an internal hash derived from the message
    and the inner key. The second pass includes the final HMAC code derived from the
    inner hash result and the outer key. Now, HMAC itself doesn't encrypt the message,
    but instead, it takes the message whether it's encrypted or not, and it must be
    sent alongside the HMAC hash. This way, both parties can verify using the secret
    key that the message is coming from who it says it's coming from, or that its
    authenticity is correct.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一次运算产生了一个内部哈希值，该值由消息和内部密钥衍生出来。第二次运算包括最终的HMAC代码，该代码由内部哈希结果和外部密钥衍生出来。现在，HMAC本身并不加密消息，而是将消息（无论它是否加密）与HMAC哈希一起发送。这样，双方都可以使用秘密密钥验证消息是否来自声称的发送方，或者它的真实性是否正确。
- en: Let's discuss another authentication mechanism next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论另一种认证机制。
- en: CHAP
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CHAP
- en: The **Change Handshake Authentication Protocol** (**CHAP**) is an authentication
    mechanism we use via **Point to Point Protocol** (**PPP**) and a three-way handshake.
    CHAP provides a way to protect yourself against what we refer to as **replay attacks**.
    Now, the downside is that CHAP uses that shared key thing where both the client
    and the server must know the plaintext of the secret key. Now, the funny thing
    here is Microsoft came out with their own version of CHAP (called **MS-CHAP**)
    that doesn't require either the sender or the receiver to know the plaintext,
    and it doesn't transmit it, but it's also been hacked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更握手认证协议**（**CHAP**）是我们通过**点对点协议**（**PPP**）和三次握手使用的一种认证机制。CHAP提供了一种防范我们所称的**重放攻击**的方法。现在，CHAP的缺点是它使用共享密钥的方式，客户端和服务器必须知道密钥的明文。搞笑的是，微软推出了他们自己的CHAP版本（叫做**MS-CHAP**），它不需要发送方或接收方知道明文，也不传输明文，但它也曾被黑客攻破。'
- en: EAP
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EAP
- en: The **Extensible Authentication Protocol** (**EAP**) was originally designed
    for point-to-point communications. It is used as an alternative to CHAP, as well
    as the **Password Authentication Protocol** (**PAP**). I didn't talk about PAP
    because it's so outdated. EAP itself is more secure and supports different authentication
    mechanisms, such as using either one-time passwords, standard passwords, or smart
    tokens.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展认证协议**（**EAP**）最初是为点对点通信设计的。它作为CHAP的替代方案，也用于替代**密码认证协议**（**PAP**）。我没有讲PAP，因为它已经过时。EAP本身更安全，并且支持不同的认证机制，比如使用一次性密码、标准密码或智能令牌。'
- en: Let's talk about what **public key infrastructure** (**PKI**) is next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来讨论一下**公钥基础设施**（**PKI**）。
- en: PKI made simple
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的PKI
- en: The PKI is asymmetric, which means we have a two-key technology to help make
    sure that information is encrypted and only decrypted by the appropriate parties.
    Remember, in symmetric, we only use one key that is shared between both parties.
    In this one here, we're going to have two keys, and you've heard me talk about
    public keys and private keys. Next, let's see what PKI consists of.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PKI是非对称的，这意味着我们有两把密钥来确保信息被加密，并且只有适当的各方才能解密。记住，在对称加密中，我们只使用一把共享密钥，而在PKI中，我们有两把密钥，你听我提到过公钥和私钥。接下来，让我们看看PKI包括哪些内容。
- en: Your certificate
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的证书
- en: '*"Hey, Dale, you keep talking about this certificate. What is this so-called
    certificate?"* So, a **certificate** is a way of identifying an organization,
    or even a user. Typically, certificates are based on what''s referred to as an
    **X.509 standard**, and they typically contain fields such as when the certificate
    is valid, when it''s expired, what algorithm is used for the encryption of the
    public key, and who issues the certificate.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*“嘿，Dale，你一直在说这个证书，什么是所谓的证书？”* 证书是一种用来识别组织甚至用户的方式。通常，证书是基于**X.509标准**，并且通常包含一些字段，例如证书的有效期、到期时间、用于加密公钥的算法以及证书的颁发者。'
- en: In fact, let me show you something here real fast. So, here I am at the **Packt**
    website, and because we have an **HTTPS** connection, that means it's a secured
    connection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我快速给你展示一些东西。这里是**Packt**网站，由于我们使用的是**HTTPS**连接，这意味着它是一个安全的连接。
- en: '![Figure 16.4 – An HTTPS site will show a lock indicating a secure connection'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4 – HTTPS站点会显示一个锁图标，表示连接是安全的。'
- en: '](Images/B17486_16_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_04.jpg)'
- en: Figure 16.4 – An HTTPS site will show a lock indicating a secure connection
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – HTTPS站点会显示一个锁图标，表示连接是安全的。
- en: I'm going to just hover over the lock here, and it tells me that I can view
    the site information or the certificate. So, I can come down and select to look
    at the certificate. It tells me it's currently valid without me having to drill
    into it, but let's go ahead and drill into it here. You can see here that it's
    created for the following purpose, to verify the identity of the remote computer
    and to provide your identity to the remote computer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里悬停在锁定图标上，它告诉我可以查看站点信息或证书。所以，我可以向下选择查看证书。它告诉我当前证书是有效的，无需深入查看，但让我们还是深入查看一下。你可以在这里看到，它是为了以下目的创建的：验证远程计算机的身份，并将你的身份提供给远程计算机。
- en: '![Figure 16.5 – The certificate shows the purpose and valid dates'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.5 – 证书显示了目的和有效日期'
- en: '](Images/B17486_16_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_05.jpg)'
- en: Figure 16.5 – The certificate shows the purpose and valid dates
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 证书显示了目的和有效日期
- en: This way, Packt can make sure they know who they're talking to. It shows who
    it was issued to. It tells us it was issued by **Cloudflare** on their **ECC CA-3**
    server. And, of course, the validity period here is anywhere from **6/6/2021**
    through **6/6/2022**. I can go into the **Details** tab for the certificate, and
    I can see all kinds of things here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Packt可以确保他们知道自己在与谁交谈。它显示了证书的颁发对象。告诉我们这是由**Cloudflare**在其**ECC CA-3**服务器上颁发的。当然，这里的有效期是从**2021年6月6日**到**2022年6月6日**。我可以进入证书的**详细信息**标签，查看这里的各种信息。
- en: '![Figure 16.6 – The Details tab reveals more information'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6 – 详细信息标签显示更多信息'
- en: '](Images/B17486_16_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_06.jpg)'
- en: Figure 16.6 – The Details tab reveals more information
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 详细信息标签显示更多信息
- en: Again, I can see the issuer, which is **sha256**. I can see, again, the validity
    date, and the subject, which is basically, again, to who it applies. You can see
    that when they issued the certificate, you must fill out an application so they
    can issue it, and then they verify; in this case here, Cloudflare went through
    and verified that it was, in fact, Packt Publishing. This way, I can't create
    my own certificate for Packt and put it on the web and make people think that,
    hey, I'm Packt Publishing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我可以看到颁发者是**sha256**。我还可以再次看到有效日期和主题，基本上就是证书适用于谁。你可以看到，当他们颁发证书时，你必须填写申请，以便他们能为你颁发证书，接着他们会进行验证；在这里，Cloudflare
    确认了这确实是 Packt Publishing。这样，我就无法为 Packt 创建自己的证书并将其放到网上，骗别人认为我就是 Packt Publishing。
- en: The public key, again, is **ECC (256 bits)**, and that's the key there. I can
    again scroll down and see information here about the subject alternative names,
    which, they've got their wildcard in here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥再次是**ECC（256位）**，这就是密钥。我还可以继续向下滚动，查看有关主题备用名称的信息，他们在这里使用了通配符。
- en: '![Figure 16.7 – More details of the certificate including the public key'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 – 证书的更多细节，包括公钥'
- en: '](Images/B17486_16_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_07.jpg)'
- en: Figure 16.7 – More details of the certificate including the public key
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 证书的更多细节，包括公钥
- en: 'So, everywhere that we go, we are interacting with certificates. Sometimes,
    you don''t even realize it. Now, when it comes to certificates, there are two
    different types:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在任何地方都会与证书进行交互。有时，你甚至没有意识到这一点。现在，关于证书，有两种不同的类型：
- en: There's a **signed certificate** where a CA signs it, a public CA, and issues
    the certificate. And, again, these certificates normally contain the public key
    and the identity of the owner of that key. The private key is kept secret by the
    CA.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个**签名证书**，由一个公共的证书颁发机构（CA）签名并颁发证书。同样，这些证书通常包含公钥和密钥所有者的身份信息。私钥由证书颁发机构（CA）保密。
- en: There are also **self-signed certificates**. This is where the identity of the
    certificate is signed by the same organization or the entity that identifies that
    it's certified. So, for example, if I wanted to create my own certificate within
    my organization, I'm going to have my own CA server, and I'm going to do a self-signed
    certificate from that server. We don't normally use self-signed certificates.
    In fact, you should never use a self-signed certificate in the wild, only within
    your own infrastructure.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有**自签名证书**。这是指证书的身份由同一组织或实体签署，证明它是经过认证的。例如，如果我想在自己的组织内创建一个证书，我将拥有自己的CA服务器，并从该服务器生成一个自签名证书。我们通常不使用自签名证书。事实上，你永远不应该在公开环境中使用自签名证书，只能在你自己的基础设施内使用。
- en: See? I told you I'd make PKI easy to understand.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧？我告诉你我会让PKI变得容易理解。
- en: Let's talk about digital signatures now.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈数字签名。
- en: Digital signatures
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字签名
- en: It's designed to verify that a particular email or document came from a particular
    source. For example, if *Bruce Wayne* was sending an email to *Selina Kyle*, they
    both would have a public key and a private key.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它的设计目的是验证特定的电子邮件或文档是否来自特定的来源。例如，如果*布鲁斯·韦恩*向*塞琳娜·凯尔*发送电子邮件，他们俩都会有与之相关联的公钥和私钥。
- en: Selina would take her private key and sign her email so that Bruce Wayne can
    make sure that it was from her. She uses that private key to sign the document,
    which isn't a physical signature, it's just a code that's attached to the email
    saying that it was from Selina. Again, anybody could try to fake this if they
    wanted. But, here's what happens. When the email gets sent over to Bruce, he grabs
    a copy of her public key. Remember that key? It's public and can go to anybody,
    and he uses that public key to run against the signature to verify that the email
    came from Selina. Again, what you must remember here is digital signatures do
    not in any way whatsoever encrypt. It's just to verify a document, an email, or
    even a file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 塞琳娜会使用她的私钥签署她的电子邮件，这样布鲁斯·韦恩就可以确认邮件确实来自她。她用私钥签署文档，这并不是物理签名，而是附加在邮件上的一段代码，表示这是塞琳娜发来的。再次强调，任何人如果愿意，也可以伪造这一签名。但这里有一个关键点。当邮件发送给布鲁斯时，他获取了塞琳娜的公钥副本。记得那个公钥吗？它是公开的，可以提供给任何人，他用公钥来验证签名，确保邮件确实来自塞琳娜。再强调一次，数字签名并不加密内容，它只是用来验证文档、邮件，甚至文件的来源。
- en: Up next, we'll talk about additional ways to secure our communications over
    a network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论通过网络加固通信的其他方式。
- en: SSL and TLS
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 和 TLS
- en: SSL and TLS are both cryptographic protocols that can be used to secure communications
    over an insecure network such as the internet. SSL is the predecessor to TLS and
    is more commonly used today.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 和 TLS 都是可以用于通过不安全网络（如互联网）加密通信的加密协议。SSL 是 TLS 的前身，如今更常用的是 TLS。
- en: SSL and TLS use a combination of a symmetric key cipher and an asymmetric key
    cipher to encrypt communications. The symmetric key cipher is used to encrypt
    the data, and the asymmetric key cipher is used to exchange the keys. SSL and
    TLS also use digital certificates to authenticate entities and prevent MITM attacks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 和 TLS 使用对称密钥加密和非对称密钥加密的结合来加密通信。对称密钥加密用于加密数据，而非对称密钥加密用于交换密钥。SSL 和 TLS 还使用数字证书来验证实体身份并防止中间人攻击（MITM）。
- en: 'When we look at TLS, it goes through a handshake process:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看 TLS 时，它会经历一个握手过程：
- en: We're going to have our server that is encrypted or has the encrypted information,
    and then we have our client system. We know that we have public keys and private
    keys associated with that server or the data source itself.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将拥有一个加密的服务器，或者是包含加密信息的服务器，然后是我们的客户端系统。我们知道与该服务器或数据源相关联的有公钥和私钥。
- en: What happens is the client sends another client a *Hello* message, along with
    a random value, and it tells the server the supported ciphers it can use.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向另一个客户端发送一个*Hello*消息，带有一个随机值，并告诉服务器它支持的加密算法。
- en: The server responds by sending, *"Hey, how you doing? I'm a server."* It's called
    a server *Hello* message, along with the server's random value. The server also
    sends, *"Hey, I'm done saying hello to you."* Now, if the server has requested
    a certificate from the client, the client would then send one back.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器回应发送*“嘿，你好吗？我是一个服务器。”*这叫做服务器*Hello*消息，附带服务器的随机值。服务器还会发送*“嘿，我已经跟你打完招呼了。”*如果服务器要求客户端提供证书，客户端则会将证书发送回去。
- en: The client then creates a random pre-master secret and encrypts it with the
    public key from the server's certificate, then sends that pre-master secret to
    the server, and here's what's interesting; once it's received, the server and
    the client will each generate a brand-new master secret and session key, which
    is based on the pre-master secret.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端创建一个随机的预主密钥，并用服务器证书中的公钥对其加密，然后将预主密钥发送给服务器。接下来有个有趣的地方；一旦接收到预主密钥，服务器和客户端将各自生成一个全新的主密钥和会话密钥，这些密钥都是基于预主密钥生成的。
- en: Once they've both done that, the client then sends a message that says, *"Hey,
    I'm going to change the cipher spec."* And that cipher spec is going to be based
    on the new session keys that we just generated, and we're going to use those for
    hashing, as well as encrypting. The client also sends a *"Yo, I'm done"* message
    or a **client finished message**. The server receives the updated cipher spec
    and switches over to a security state that will use a symmetric encryption using
    the session keys. The server also sends a *"Yo, I'm finished"* or a **server finished
    message**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它们都完成了这些步骤，客户端接着发送一条消息，表示，*“嘿，我要改变加密算法规格。”* 这个加密算法规格将基于我们刚刚生成的新会话密钥，我们将用它们来进行哈希和加密。客户端还会发送一条*“哟，我完成了”*的消息，或者**客户端完成消息**。服务器接收到更新后的加密算法规格，并切换到使用会话密钥进行对称加密的安全状态。服务器还会发送一条*“哟，我完成了”*，或**服务器完成消息**。
- en: Now, both the client and the server have the new master secret, as well as the
    session keys; they'll both start using those session keys to exchange data back
    and forth over a secure channel.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，客户端和服务器都有了新的主密钥和会话密钥；它们都将开始使用这些会话密钥通过安全通道来交换数据。
- en: All the messages sent from the client to the server and from the server to the
    client are then encrypted. That's a lot, huh?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端到服务器、以及从服务器到客户端发送的所有消息都会被加密。这可不轻松吧？
- en: When it comes to using SSL and TLS, there are several different toolkits out
    there. The one I want to warn you about, it's probably one of the more popular
    but this is just more historical information, is one that's referred to as **OpenSSL**.
    Now, OpenSSL is like the Swiss army knife of cryptography, and because it's an
    open source resource, this makes it very attractive, right?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SSL和TLS时，有几个不同的工具包可供选择。我想提醒你注意的是，它可能是最流行的工具之一，但这只是一些历史信息，它被称为**OpenSSL**。现在，OpenSSL就像是加密学的瑞士军刀，因为它是一个开源资源，这使得它非常具有吸引力，对吧？
- en: Now, there's one thing I need to warn you about and that is OpenSSL had a very
    big issue. It was something called **Heartbleed**, which was an extremely bad
    vulnerability. The Heartbleed vulnerability allowed anyone on the internet to
    read the memory of systems protected by the vulnerable versions of OpenSSL. Now,
    don't worry, it's been patched. Hint… you will want to know that in preparing
    to take the exam.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一件事我需要警告你，那就是OpenSSL曾经出现了一个非常严重的问题，叫做**Heartbleed**，这是一个极其严重的漏洞。Heartbleed漏洞允许互联网上的任何人读取受易受攻击版本的OpenSSL保护的系统内存。现在，别担心，它已经被修复了。提示……你会希望在准备考试时了解这个问题。
- en: PGP
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PGP
- en: PGP is the understatement of the year. PGP gets its start all the way back in
    1991\. Now, the reason PGP is pretty good is we can use it for encrypting messages
    and files, as well as the digital signatures or signing documents, and, of course,
    deleting documents and even compression. In fact, PGP encryption uses a serial
    combination of hashing, then data compression, symmetric-key cryptography, and,
    finally, public-key cryptography. Each step uses several supported algorithms,
    and each of the public keys is bound to a username or an email address.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PGP是今年的低调之作。PGP的起源可以追溯到1991年。PGP之所以非常好，是因为我们可以用它来加密消息和文件，以及数字签名或签署文档，当然，还包括删除文档甚至压缩。事实上，PGP加密使用的是哈希、数据压缩、对称密钥加密，最后是公钥加密的串联组合。每个步骤都使用了几种支持的算法，每个公钥都与一个用户名或电子邮件地址绑定。
- en: Let's look at how PGP happens and operates.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下PGP是如何发生和操作的。
- en: '![Figure 16.8 – PGP flow'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8 – PGP流程'
- en: '](Images/B17486_16_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17486_16_08.jpg)'
- en: Figure 16.8 – PGP flow
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – PGP流程
- en: When a user encrypts data with PGP, PGP compresses that data down. This compression
    helps to avoid some exploits that could be used to try to crack the cipher because
    the patterns in the plaintext have been compressed.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户使用PGP加密数据时，PGP会先对数据进行压缩。这种压缩有助于避免一些可以用来破解加密的攻击，因为明文中的模式已经被压缩。
- en: PGP then creates a random key that is a one-time-use-only, secret key, and it
    uses that key to encrypt the plaintext, which results in our ciphertext.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PGP接着会创建一个只使用一次的随机密钥，并用这个密钥来加密明文，从而生成我们的密文。
- en: Once it's done encrypting, the random key is encrypted using the recipient's
    public key. That encrypted data is sent to the recipient. Obviously, the encryption
    operates in a reverse manner.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦加密完成，随机密钥会使用接收方的公钥进行加密。然后，这个加密数据会发送给接收方。显然，加密过程是反向进行的。
- en: You may be thinking, *"But Dale, PGP is still good today. Isn't it?"* Yeah,
    it really is. In fact, the only way I'm aware they have been able to crack or
    attack PGP is by installing a piece of malware that would capture keystrokes so
    they could capture the passwords as they type them in. Now, at the time of writing
    this book, **Symantec** owns PGP, and they've renamed it. They call it the **Symantec
    Encryption Desktop**, and the server component is just referred to as the **Symantec
    Encryption Management Server**. But basically, it's still PGP.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，*“但戴尔，PGP到今天还是很好用的，不是吗？”* 是的，它确实还是很好用。事实上，我所知道的破解或攻击PGP的唯一方法，就是通过安装一款恶意软件来捕获按键记录，这样他们就可以捕获输入密码时的按键。现在，在写这本书的时候，**赛门铁克**拥有PGP，并且他们重新命名了它。现在它叫做**赛门铁克加密桌面**，而服务器组件则被称为**赛门铁克加密管理服务器**。但基本上，它仍然是PGP。
- en: So, now that we've got that down, let's finish up talking about countermeasures.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经弄清楚这些了，来继续讨论对策吧。
- en: Countermeasures for cryptography
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密学的对策
- en: You know me, I don't want to leave you all panicking that all is lost! There
    are some countermeasures that we can take to mitigate the attacks that might come
    our way. Let's talk about some of these countermeasures.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解我，我可不想让你们都陷入恐慌，觉得一切都完了！我们可以采取一些对策来减轻可能袭来的攻击。让我们来谈谈其中的一些对策。
- en: 'EC-Council lists 12 countermeasures to use:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: EC-Council列出了12个应对措施：
- en: The first one is when it comes to accessing the cryptography keys, that access
    should only be given to users directly, as well as applications.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个要点是，当涉及到访问加密密钥时，只有用户和应用程序才能获得访问权限。
- en: You should also make sure you have an **intrusion detection system** (**IDS**)
    that's been deployed, and you are monitoring the exchange and access of those
    keys, so you've got a log somewhere of what happened and when. This is just in
    case you must go back and take a look at those logs because something got compromised.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还应该确保部署了**入侵检测系统**（**IDS**），并且你正在监控这些密钥的交换和访问，确保你有日志记录发生了什么以及何时发生的。这是以防万一你必须回过头去查看这些日志，因为某些东西被泄露了。
- en: The other thing you're going to want to do is that if you plan on storing the
    encryption key on a system or on a drive, you need to use passphrases and passwords.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，你还需要做的是，如果你计划将加密密钥存储在系统或驱动器上，你必须使用密码短语和密码。
- en: 'This next one''s for you more advanced developers out there: under no circumstances
    should the keys be inside of the source code or inside of any binaries.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来这一条是为你们这些高级开发者准备的：在任何情况下，密钥都不应该放在源代码中或任何二进制文件里。
- en: Now, when it comes to certificates for signing the transfer of private keys,
    it's a major no-no. We never, ever transfer private keys. We just say no, got
    it? I'll be a little happier now that you're agreeing with me.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关于用于签署私钥转移的证书，这是一个大忌。我们绝不、绝不转移私钥。我们只需要说“不”，明白了吗？看到你同意我说的话，我心里稍微高兴一点。
- en: When it comes to symmetric algorithms, you should make sure you use the maximum
    number of bits that you possibly can. You should be using at least 168 bits or
    256 bits.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到对称算法时，你应该确保使用可能的最大位数。你至少应该使用168位或256位。
- en: If you're going to implement encryption for symmetric key protocols, you've
    got to make sure that message authentication is performed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打算实现对称密钥协议的加密，你必须确保执行消息认证。
- en: As far as asymmetric algorithms are concerned, you need to use the largest sizes
    available, either 1536 or 2048\. Just say 2048, please.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于非对称算法，你需要使用最大的可用密钥大小，至少是1536位或2048位。请说2048位。
- en: When it comes to your hash algorithms gain, use the highest bits possible, 168
    or 256 bits, please!
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说到哈希算法时，请使用尽可能高位数的位数，168位或256位，请！
- en: When creating or implementing a cryptographic environment, please don't do anything
    homemade. I know some of you developers might be like, *"Well, I can do this a
    little bit better."* Trust me, don't! Use what would be considered an industry
    standard. Some people will try to create self-engineered crypto algorithms as
    well as functions, and inevitably they're going to leave some holes open for you.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建或实现加密环境时，请不要做任何自制的东西。我知道你们一些开发者可能会想，*“哦，我可以做得更好一点。”* 相信我，别做！使用那些被认为是行业标准的东西。有些人会尝试创建自制的加密算法以及函数，结果不可避免地会给你们留下漏洞。
- en: I would also put a limit on the number of operations per second per key. This
    way, you don't have somebody trying to quickly brute force to try to discover
    what the key is.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我还会对每个密钥每秒的操作次数设置限制。这样，你就不会让某个人试图通过暴力破解快速找到密钥。
- en: And finally, the output of a hash or any hash function should have the largest
    bit length possible, so it makes it hard to decrypt.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个哈希或任何哈希函数的输出应该具有最大的位数，以便使其难以解密。
- en: Okay, see? That's how easy those 12 things are. And, this brings us to the end.
    So, as you can see, standards and protocols are essential for us when dealing
    with and protecting our data and communications. Understanding the tools and processes
    is necessary for you to be an effective IT security professional.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看到没？这就是这12个内容是多么简单。这也带我们来到了结尾。所以，正如你所看到的，标准和协议对于我们处理和保护数据与通信至关重要。理解工具和流程是你成为一名有效IT安全专业人员所必需的。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the major ways to protect your resources from attackers is to use encryption
    for data in motion or in waiting. Your job as a security professional isn't to
    stop attackers, that's impossible. Anything is hackable. Your job is to slow them
    down or discourage them, and cryptography definitely does this.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的资源免受攻击者侵害的主要方式之一是使用加密保护流动数据或待处理数据。作为安全专业人员，你的工作不是阻止攻击者，这几乎是不可能的。任何东西都可以被黑客攻破。你的工作是减慢他们的速度或使他们气馁，而加密技术确实能够做到这一点。
- en: This brings us to the end of this book and the beginning of your journey in
    cybersecurity. As you study for the **CEH** exam, remember that it's not an easy
    task to accomplish. The test is designed to make sure you know your craft.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到此结束，但这也是你进入网络安全旅程的开始。当你为 **CEH** 考试做准备时，请记住，这并不是一项容易完成的任务。这个测试是为了确保你真正掌握了你的专业技能。
- en: Keep in mind that if you haven't fully grasped all the concepts we've talked
    about in this book, review it again. Do your own research. Reach out to me via
    my social media channels. My passion and mission are to help everyone and every
    company stay safer while using technology. Please be sure to *tweet* me or post
    on LinkedIn when you pass your exam or that you've learned something from me.
    The comments I get from my students, viewers, and readers really do bring a smile
    to my face. And, do me a favor…Be safe!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你还没有完全掌握我们在本书中讨论的所有概念，请再次复习。进行你自己的研究。通过我的社交媒体渠道联系我。我的热情和使命是帮助每个人和每个公司在使用技术时保持更安全。通过推特或LinkedIn告诉我你通过了考试或从我这里学到了一些东西。来自学生、观众和读者的评论真的让我笑容满面。而且，帮个忙……保持安全！
- en: Questions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，这里有一些问题，供你测试自己对本章内容的掌握。你会在 *附录* 的 *评估* 部分找到答案：
- en: Which of the following terms does asymmetric encryption also go by?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个术语也是非对称加密的别名？
- en: A shared key
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个共享密钥
- en: Hashing
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希
- en: A public key
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个公钥
- en: Block
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块
- en: Which of the following is a mechanism for SSL?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是SSL的机制？
- en: Authenticating data
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据认证
- en: Securing stored data
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储数据的安全
- en: Verifying data
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证数据
- en: Securing transmitted data
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输数据的安全
- en: A common hashing protocol is which of the following?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种是常见的哈希协议？
- en: RSA
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: RSA
- en: MD5
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MD5
- en: DES
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: DES
- en: AES
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AES
- en: _________ is another name for symmetric cryptography.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: _________ 是对称加密的另一个名称。
- en: Shared key cryptography
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: Steganography
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐写术
- en: Public key cryptography
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥加密
- en: Hashing
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希
