- en: Static Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: Static analysis is the technique of analyzing the suspect file without executing
    it. It is an initial analysis method that involves extracting useful information
    from the suspect binary to make an informed decision on how to classify or analyze
    it and where to focus your subsequent analysis efforts. This chapter covers various
    tools and techniques to extract valuable information from the suspect binary.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是分析可疑文件的一种技术，无需执行它。这是一种初步的分析方法，涉及从可疑二进制文件中提取有用的信息，以便做出明智的决策，决定如何分类或分析它，以及接下来分析工作的重点。本章将介绍多种工具和技术，用于从可疑二进制文件中提取有价值的信息。
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习以下内容：
- en: Identifying the malware's target architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别恶意软件的目标架构
- en: Fingerprinting the malware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 病毒指纹识别
- en: Scanning the suspect binary with anti-virus engines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用杀毒引擎扫描可疑二进制文件
- en: Extracting strings, functions, and metadata associated with the file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取与文件相关的字符串、函数和元数据
- en: Identifying the obfuscation techniques used to thwart analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用来阻碍分析的混淆技术
- en: Classifying and comparing the malware samples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类和比较恶意软件样本
- en: These techniques can reveal different information about the file. It is not
    required to follow all these techniques, and they need not be followed in the
    order presented. The choice of techniques to use depends on your goal and the
    context surrounding the suspect file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可以揭示关于文件的不同信息。并不要求必须遵循所有这些技术，也不需要按呈现的顺序来执行。使用哪些技术取决于你的目标和可疑文件周围的上下文。
- en: 1\. Determining the File Type
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 确定文件类型
- en: During your analysis, determining the file type of a suspect binary will help
    you identify the malware's target operating system (Windows, Linux, and so on)
    and architecture (32-bit or 64-bit platforms). For example, if the suspect binary
    has a file type of *Portable Executable* (*PE*), which is the file format for
    Windows executable files (`.exe`, `.dll`, `.sys`, `.drv`, `.com`, `.ocx`, and
    so on), then you can deduce that the file is designed to target the Windows operating
    system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析过程中，确定可疑二进制文件的文件类型将帮助你识别恶意软件的目标操作系统（如Windows、Linux等）和架构（32位或64位平台）。例如，如果可疑的二进制文件是*Portable
    Executable*（*PE*）文件类型，这是Windows可执行文件（`.exe`、`.dll`、`.sys`、`.drv`、`.com`、`.ocx`等）的文件格式，那么你可以推测该文件是为Windows操作系统设计的。
- en: Most Windows-based malware are executable files ending with extensions such
    as `.exe`, `.dll`, `.sys`, and so on. But relying on file extensions alone is
    not recommended. File extension is not the sole indicator of file type. Attackers
    use different tricks to hide their file by modifying the file extension and changing
    its appearance to trick users into executing it. Instead of relying on file extension,
    *File signature* can be used to determine the file type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于Windows的恶意软件都是以`.exe`、`.dll`、`.sys`等扩展名结尾的可执行文件。但仅仅依靠文件扩展名是不推荐的。文件扩展名并不是文件类型的唯一指标。攻击者通过修改文件扩展名和改变文件外观，利用各种技巧隐藏其文件，诱使用户执行它。与其依赖文件扩展名，不如使用*文件签名*来确定文件类型。
- en: A *file signature* is a unique sequence of bytes that is written to the file's
    header. Different files have different signatures, which can be used to identify
    the type of file. The Windows executable files, also called *PE files* (such as
    the files ending with `.exe`, `.dll`, `.com`, `.drv`, `.sys`, and so on), have
    a file signature of `MZ` or hexadecimal characters `4D 5A` in the first two bytes
    of the file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件签名*是写入文件头部的唯一字节序列。不同的文件具有不同的签名，可以用来识别文件的类型。Windows可执行文件，也叫做*PE文件*（例如以`.exe`、`.dll`、`.com`、`.drv`、`.sys`等结尾的文件），其文件签名是`MZ`或十六进制字符`4D
    5A`，位于文件的前两个字节。'
- en: A handy resource for determining the file signatures of different file types
    based on their extension is available at [http://www.filesignatures.net/](http://www.filesignatures.net/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的资源可以帮助确定不同文件类型的文件签名，基于它们的扩展名，网址为[http://www.filesignatures.net/](http://www.filesignatures.net/)。
- en: 1.1 Identifying File Type Using Manual Method
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 使用手动方法识别文件类型
- en: 'The manual method of determining the file type is to look for the *file signature*
    by opening it in a hex editor. A *hex editor* is a tool that allows an examiner
    to inspect each byte of the file; most hex editors provide many functionalities
    that help in the analysis of a file. The following screenshot shows the file signature
    of `MZ` in the first two bytes when an executable file is opened with the *HxD
    hex editor* ([https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确定文件类型的手动方法是通过在十六进制编辑器中打开文件查找 *文件签名*。*十六进制编辑器* 是一种工具，它允许检查人员检查文件的每个字节；大多数十六进制编辑器提供许多功能，帮助分析文件。以下截图展示了使用
    *HxD 十六进制编辑器*（[https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)）打开可执行文件时，前两个字节中的文件签名
    `MZ`：
- en: '![](../images/00013.jpeg)You have many options when it comes to choosing hex
    editors for Windows; these hex editors offer different features. For a list and
    comparison of various hex editors, refer to this link: [https://en.wikipedia.org/wiki/Comparison_of_hex_editors](https://en.wikipedia.org/wiki/Comparison_of_hex_editors).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00013.jpeg)在选择 Windows 的十六进制编辑器时，你有很多选项；这些十六进制编辑器提供不同的功能。有关各种十六进制编辑器的列表和比较，请参阅此链接：[https://en.wikipedia.org/wiki/Comparison_of_hex_editors](https://en.wikipedia.org/wiki/Comparison_of_hex_editors)。'
- en: 'On Linux systems, to look for the file signature, the `xxd` command can be
    used, which generates a hex dump of the file as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，要查找文件签名，可以使用 `xxd` 命令，它会生成文件的十六进制转储，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 1.2 Identifying File Type Using Tools
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 使用工具识别文件类型
- en: 'The other convenient method of determining the file type is to use file identification
    tools. On Linux systems, this can be achieved using the *file* utility. In the
    following example, the file command was run on two different files. From the output,
    it can be seen that even though the first file does not have any extension, it
    is detected as a 32-bit executable file (`PE32`) and the second file is a 64-bit
    (`PE32+`) executable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种便捷的确定文件类型的方法是使用文件识别工具。在 Linux 系统中，可以使用 *file* 实用程序来实现。以下示例中，`file` 命令被应用于两个不同的文件。从输出结果可以看出，尽管第一个文件没有任何扩展名，但它被识别为一个
    32 位可执行文件（`PE32`），而第二个文件则是一个 64 位（`PE32+`）可执行文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On Windows, *CFF Explorer*, part of *Explorer Suite* ([http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php)),
    can be used to determine the file type; it is not just limited to determining
    file type. It is also a great tool for inspecting executable files (both 32-bit
    and 64-bit) and allows you to examine the PE internal structure, modify fields,
    and extract resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，*CFF Explorer*（属于 *Explorer Suite*）([http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php))
    可以用来确定文件类型；它不仅限于确定文件类型，还可以作为一个出色的工具来检查可执行文件（包括 32 位和 64 位），并允许你检查 PE 内部结构、修改字段和提取资源。
- en: 1.3 Determining File Type Using Python
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 使用 Python 确定文件类型
- en: In Python, the `python-magic` module can be used to determine the file type.
    The installation of this module on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction
    to Malware Analysis.* On Windows, to install the `python-magic` module, you can
    follow the procedure mentioned at [https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`python-magic` 模块可以用来确定文件类型。在 Ubuntu Linux 虚拟机上安装此模块的过程在[第 1 章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)，*恶意软件分析介绍*中已有介绍。在
    Windows 上，要安装 `python-magic` 模块，可以按照[https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic)中提到的步骤进行操作。
- en: 'Once the `python-magic` is installed, the following commands can be used in
    the script to determine the file type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `python-magic` 后，可以在脚本中使用以下命令来确定文件类型：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To demonstrate the use of detecting file type, let''s take an example of a
    file that was made to look like a *Word document* by changing the extension from
    `.exe` to `.doc.exe`. In this case, attackers took advantage of the fact that,
    by default, *"Hide extension for known file types*" is enabled in the *"Windows
    folder view options"*; this option prevents the file extension from being displayed
    to the user. The following screenshot shows the appearance of the file with *"Hide
    extension for known file types*" enabled:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何检测文件类型，我们以一个文件为例，该文件通过将扩展名从 `.exe` 改为 `.doc.exe`，被伪装成一个 *Word 文档*。在这种情况下，攻击者利用了默认情况下
    *“隐藏已知文件类型的扩展名”* 在 *“Windows 文件夹选项”* 中启用的事实；该选项会阻止文件扩展名显示给用户。以下截图展示了启用 *“隐藏已知文件类型的扩展名”*
    后文件的外观：
- en: '![](../images/00014.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: 'Opening the file in the *CFF Explorer* reveals that it is a 32-bit executable
    file and not a word document, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *CFF Explorer* 文件后，可以发现它是一个32位的可执行文件，而不是一个Word文档，如下所示：
- en: '![](../images/00015.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: 2\. Fingerprinting the Malware
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 指纹识别恶意软件
- en: 'Fingerprinting involves generating the cryptographic hash values for the suspect
    binary based on its file content. The cryptographic hashing algorithms such as *MD5*,
    *SHA1* or *SHA256* are considered the de facto standard for generating file hashes
    for the malware specimens. The following list outlines the use of cryptographic
    hashes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹识别涉及基于文件内容生成可疑二进制文件的加密哈希值。加密哈希算法，如 *MD5*、*SHA1* 或 *SHA256*，被认为是生成恶意软件样本文件哈希的事实标准。以下列表概述了加密哈希值的用途：
- en: Identifying a malware specimen based on filename is ineffective because the
    same malware sample can use different filenames, but the cryptographic hash that
    is calculated based on the file content will remain the same. Hence, a cryptographic
    hash for your suspect file serves as a unique identifier throughout the course
    of analysis.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅根据文件名识别恶意软件样本是无效的，因为同一恶意软件样本可能会使用不同的文件名，但基于文件内容计算的加密哈希值始终保持不变。因此，针对可疑文件的加密哈希值在整个分析过程中充当独特的标识符。
- en: During dynamic analysis, when malware is executed, it can copy itself to a different
    location or drop another piece of malware. Having the cryptographic hash of the
    sample can help in identifying whether the newly dropped/copied sample is the
    same as the original sample or a different one. This information can assist you
    in deciding whether the analysis needs to be performed on a single sample or multiple
    samples.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动态分析过程中，当恶意软件被执行时，它可能会将自身复制到另一个位置，或释放另一个恶意软件。拥有样本的加密哈希值可以帮助确定新释放/复制的样本是否与原始样本相同，或是否是不同的样本。这些信息有助于你决定分析是只针对一个样本进行，还是需要分析多个样本。
- en: File hash is frequently used as an indicator to share with other security researchers
    to help them identify the sample.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希值常常作为与其他安全研究人员共享的指标，帮助他们识别样本。
- en: File hash can be used to determine whether the sample has been previously detected
    by searching online or searching the database of multi Anti-virus scanning service
    like *VirusTotal*.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希值可以用来确定该样本是否曾经被在线搜索或在多个反病毒扫描服务的数据库中检测到，如 *VirusTotal*。
- en: 2.1 Generating Cryptographic Hash Using Tools
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 使用工具生成加密哈希值
- en: 'On a Linux system, file hashes can be generated using the `md5sum`, `sha256sum`,
    and `sha1sum` utilities:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，可以使用 `md5sum`、`sha256sum` 和 `sha1sum` 工具生成文件哈希值：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Windows, various tools for generating file hashes can be found online. *HashMyFiles*
    ([http://www.nirsoft.net/utils/hash_my_files.html](http://www.nirsoft.net/utils/hash_my_files.html)) is
    one such tool that generates hash values for single or multiple files, and it
    also highlights identical hashes with same colors. In the following screenshot,
    it can be seen that `log.exe` and `bunny.exe` are the same samples based on their
    hash values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，许多生成文件哈希值的工具可以在网上找到。*HashMyFiles* ([http://www.nirsoft.net/utils/hash_my_files.html](http://www.nirsoft.net/utils/hash_my_files.html))
    就是其中一个工具，可以生成单个或多个文件的哈希值，并且它还会用相同的颜色高亮显示相同的哈希值。在下图中，可以看到 `log.exe` 和 `bunny.exe`
    根据其哈希值是相同的样本：
- en: '![](../images/00016.jpeg)You can get a list and comparison of various hashing
    tools here: [https://en.wikipedia.org/wiki/Comparison_of_file_verification_software](https://en.wikipedia.org/wiki/Comparison_of_file_verification_software#Program_hash_function_support).
    Feel free to choose the ones that best suit your needs after a careful review.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00016.jpeg) 你可以在这里查看各种哈希工具的列表及对比：[https://en.wikipedia.org/wiki/Comparison_of_file_verification_software](https://en.wikipedia.org/wiki/Comparison_of_file_verification_software#Program_hash_function_support)。在仔细审查后，选择最适合你需求的工具。'
- en: 2.2 Determining Cryptographic Hash in Python
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 使用Python确定加密哈希值
- en: 'In Python, it is possible to generate file hashes using the `hashlib` module,
    as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以使用 `hashlib` 模块生成文件哈希值，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3\. Multiple Anti-Virus Scanning
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 多重反病毒扫描
- en: Scanning the suspect binary with multiple anti-virus scanners helps in determining
    whether malicious code signatures exist for the suspect file. The signature name
    for a particular file can provide additional information about the file and its
    capabilities. By visiting the respective antivirus vendor websites or searching
    for the signature in search engines, you can yield further details about the suspect
    file. Such information can help in your subsequent investigation and can reduce
    the analysis time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个杀毒软件扫描可疑的二进制文件有助于确定该文件是否含有恶意代码签名。特定文件的签名名称可以提供有关该文件及其功能的更多信息。通过访问相应的杀毒软件供应商网站或在搜索引擎中搜索该签名，你可以获得关于可疑文件的更多细节。这些信息可以帮助你后续的调查，并缩短分析时间。
- en: 3.1 Scanning the Suspect Binary with VirusTotal
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 使用 VirusTotal 扫描可疑二进制文件
- en: '*VirusTotal* ([http://www.virustotal.com](http://www.virustotal.com)) is a
    popular web-based malware scanning service. It allows you to upload a file, which
    is then scanned with various anti-virus scanners, and the scan results are presented
    in real time on the web page. In addition to uploading files for scanning, the
    VirusTotal web interface provides you the ability to search their database using
    *hash*, *URL*, *domain, or IP address*. VirusTotal offers another useful feature
    called *VirusTotal Graph*, built on top of the VirusTotal dataset. Using VirusTotal
    Graph, you can visualize the relationship between the file that you submit and
    its associated indicators such as *domains*, *IP addresses*, and *URLs*. It also
    allows you to pivot and navigate over each indicator; this feature is extremely
    useful if you want to quickly determine the indicators associated with a malicious
    binary. For more information on *VirusTotal Graph*, refer to the documentation:
    [https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph](https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*VirusTotal* ([http://www.virustotal.com](http://www.virustotal.com)) 是一个流行的基于
    Web 的恶意软件扫描服务。它允许你上传文件，然后使用各种杀毒软件扫描该文件，扫描结果会实时显示在网页上。除了上传文件进行扫描外，VirusTotal 的网页界面还提供了通过
    *哈希值*、*URL*、*域名* 或 *IP 地址* 搜索其数据库的功能。VirusTotal 还提供了一个名为 *VirusTotal Graph* 的有用功能，它建立在
    VirusTotal 数据集之上。使用 VirusTotal Graph，你可以可视化你提交的文件与其相关指标（如 *域名*、*IP 地址* 和 *URL*）之间的关系。它还允许你在每个指标之间进行切换和浏览；如果你想快速确定与恶意二进制文件相关的指标，这个功能非常有用。有关
    *VirusTotal Graph* 的更多信息，请参考文档：[https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph](https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph)。'
- en: 'The following screenshot shows the detection names for a malware binary, and
    it can be seen that the binary was scanned with 67 Anti-virus engines; 60 of them
    detected this binary as malicious. If you wish to use the *VirusTotal Graph* on
    the binary to visualize indicator relationships, just click on the VirusTotal
    Graph icon and sign in with your VirusTotal (community) account:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了恶意二进制文件的检测名称，可以看到该二进制文件已通过 67 个杀毒引擎进行扫描，其中 60 个引擎检测到该二进制文件为恶意文件。如果你希望在二进制文件上使用*VirusTotal
    Graph*来可视化指标关系，只需点击 VirusTotal Graph 图标并使用你的 VirusTotal（社区）账户登录：
- en: '![](../images/00017.jpeg)VirusTotal offers different private (paid) services
    ([https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services](https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services)),
    which allow you to perform threat hunting and download samples submitted to it.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00017.jpeg)VirusTotal 提供不同的私人（付费）服务 ([https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services](https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services))，这些服务允许你进行威胁狩猎并下载提交给它的样本。'
- en: 3.2 Querying Hash Values Using VirusTotal Public API
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 使用 VirusTotal 公共 API 查询哈希值
- en: VirusTotal also provides scripting capabilities via its public API ([https://www.virustotal.com/en/documentation/public-api/](https://www.virustotal.com/en/documentation/public-api/));
    it allows you to automate file submission, retrieve file/URL scan reports, and
    retrieve domain/IP reports.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal 还通过其公共 API 提供脚本功能 ([https://www.virustotal.com/en/documentation/public-api/](https://www.virustotal.com/en/documentation/public-api/))；它允许你自动提交文件，检索文件/URL
    扫描报告，以及检索域名/IP 报告。
- en: 'The following is a Python script that demonstrates the use of VirusTotal''s
    public API. This script takes the hash value (*MD5/SHA1/SHA256*) as input and
    queries the VirusTotal database. To use the following script, you need to use
    a *Python 2.7.x* version; you must be connected to the internet and must have
    a VirusTotal public API key (which can be obtained by signing up for a *VirusTotal*
    account). Once you have the API key, just update the `api_key` variable with your
    API key:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个展示如何使用VirusTotal公共API的Python脚本。该脚本以哈希值（*MD5/SHA1/SHA256*）作为输入，并查询VirusTotal数据库。要使用以下脚本，你需要使用*Python
    2.7.x*版本；必须连接到互联网，并且必须有一个VirusTotal公共API密钥（可以通过注册*VirusTotal*帐户获得）。一旦你获得了API密钥，只需更新`api_key`变量中的API密钥：
- en: The following script and most of the scripts written in this book are used to
    demonstrate the concept; they do not perform input validation or error handling.
    If you wish to use them for production, you should consider modifying the script
    to follow the best practices mentioned here: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本和本书中大多数脚本用于演示概念；它们没有执行输入验证或错误处理。如果你希望将它们用于生产环境，应该考虑修改脚本，遵循这里提到的最佳实践：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running the preceding script by giving it an MD5 hash of a binary shows the
    antivirus detections and the signature names for the binary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给定二进制文件的MD5哈希值运行前面的脚本，可以显示该二进制文件的防病毒检测结果和签名名称。
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The other alternative is to use PE analysis tools such as *pestudio* ([https://www.winitor.com/](https://www.winitor.com/))
    or *PPEE* ([https://www.mzrst.com/](https://www.mzrst.com/)). Upon loading the
    binary, the hash value of the binary is automatically queried from the VirusTotal
    database and the results are displayed, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用PE分析工具，如*pestudio*（[https://www.winitor.com/](https://www.winitor.com/)）或*PPEE*（[https://www.mzrst.com/](https://www.mzrst.com/)）。加载二进制文件后，二进制文件的哈希值会自动从VirusTotal数据库中查询，并显示结果，如下图所示：
- en: '![](../images/00018.jpeg)Online scanners such as *VirSCAN* ([http://www.virscan.org/](http://www.virscan.org/)),
    *Jotti Malware Scan* ([https://virusscan.jotti.org/](https://virusscan.jotti.org/)),
    and *OPSWAT''s Metadefender* ([https://www.metadefender.com/#!/scan-file](https://www.metadefender.com/#!/scan-file))
    allow you to scan a suspect file with multiple anti-virus scanning engines, and
    some of them also allow you to do hash lookups.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00018.jpeg)在线扫描工具如*VirSCAN*（[http://www.virscan.org/](http://www.virscan.org/)）、*Jotti
    Malware Scan*（[https://virusscan.jotti.org/](https://virusscan.jotti.org/)）和*OPSWAT的Metadefender*（[https://www.metadefender.com/#!/scan-file](https://www.metadefender.com/#!/scan-file)）允许你使用多个反病毒扫描引擎扫描可疑文件，其中一些还允许你进行哈希值查询。'
- en: 'There are a few factors/risks to consider when scanning a binary with Anti-Virus
    scanners or when submitting a binary to online anti-virus scanning services:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反病毒扫描器扫描二进制文件或将二进制文件提交给在线反病毒扫描服务时，有几个因素/风险需要考虑：
- en: If a suspect binary does not get detected by the Anti-Virus scanning engines,
    it does not necessarily mean that the suspect binary is safe. These anti-virus
    engines rely on signatures and heuristics to detect malicious files. The malware
    authors can easily modify their code and use obfuscation techniques to bypass
    these detections, because of which some of the anti-virus engines might fail to
    detect the binary as malicious.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可疑的二进制文件未被反病毒扫描引擎检测到，并不一定意味着该二进制文件是安全的。这些反病毒引擎依赖签名和启发式方法来检测恶意文件。恶意软件作者可以轻松修改其代码并使用混淆技术来绕过这些检测，因此某些反病毒引擎可能未能将该二进制文件识别为恶意。
- en: When you upload a binary to a public site, the binary you submit may be shared
    with third parties and vendors. The suspect binary may contain sensitive, personal,
    or proprietary information specific to your organization, so it is not advisable
    to submit a binary that is part of a confidential investigation to public anti-virus
    scanning services. Most web-based anti-virus scanning services allow you to search
    their existing database of scanned files using cryptographic hash values (MD5,
    SHA1, or SHA256); so an alternative to submitting the binary is to search based
    on the cryptographic hash of the binary.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将二进制文件上传到公共网站时，提交的二进制文件可能会与第三方和供应商共享。可疑的二进制文件可能包含敏感的、个人的或属于你组织的专有信息，因此不建议将作为机密调查一部分的二进制文件提交给公共反病毒扫描服务。大多数基于网页的反病毒扫描服务允许你使用加密哈希值（MD5、SHA1或SHA256）搜索它们已有的扫描文件数据库；因此，提交二进制文件的替代方法是根据二进制文件的加密哈希进行搜索。
- en: When you submit a binary to the online antivirus scanning engines, the scan
    results are stored in their database, and most of the scan data is publicly available
    and can be queried later. Attackers can use the search feature to query the hash
    of their sample to check whether their binary has been detected. Detection of
    their sample may cause the attackers to change their tactics to avoid detection.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个二进制文件提交到在线的病毒扫描引擎时，扫描结果会存储在它们的数据库中，且大多数扫描数据是公开的，可以稍后查询。攻击者可以使用搜索功能查询他们样本的哈希值，检查他们的二进制文件是否已被检测到。如果他们的样本被检测到，攻击者可能会改变战术以避免被检测。
- en: 4\. Extracting Strings
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 提取字符串
- en: Strings are ASCII and Unicode-printable sequences of characters embedded within
    a file. Extracting strings can give clues about the program functionality and
    indicators associated with a suspect binary. For example, if a malware creates
    a file, the *filename* is stored as a string in the binary. Or, if a malware resolves
    a *domain name* controlled by the attacker, then the domain name is stored as
    a string. Strings extracted from the binary can contain references to filenames,
    URLs, domain names, IP addresses, attack commands, registry keys, and so on. Although
    strings do not give a clear picture of the purpose and capability of a file, they
    can give a hint about what malware is capable of doing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是嵌入在文件中的 ASCII 和 Unicode 可打印字符序列。提取字符串可以为可疑二进制文件提供程序功能线索和相关指示。例如，如果恶意软件创建了一个文件，*文件名*
    会作为字符串存储在二进制文件中。或者，如果恶意软件解析了由攻击者控制的 *域名*，则该域名会作为字符串存储。通过二进制文件提取的字符串可能包含对文件名、URL、域名、IP
    地址、攻击命令、注册表键等的引用。虽然字符串无法清楚地展示文件的目的和功能，但它们可以提供恶意软件可能执行的操作的提示。
- en: 4.1 String Extraction Using Tools
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 使用工具提取字符串
- en: 'To extract strings from a suspect binary, you can use the strings utility on
    Linux systems. The s*trings* command, by default, extracts the ASCII strings that
    are at least four characters long. With the `-a` option it is possible to extract
    strings from the entire file. The following ASCII strings extracted from the malicious
    binary show reference to an *IP address.* This indicates that when this malware
    is executed, it probably establishes a connection with that IP address:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可疑的二进制文件中提取字符串，可以在 Linux 系统上使用 `strings` 工具。默认情况下，`strings` 命令提取至少四个字符长的 ASCII
    字符串。通过使用 `-a` 选项，可以从整个文件中提取字符串。以下从恶意二进制文件中提取的 ASCII 字符串显示了对*IP 地址*的引用。这表明，当这个恶意软件被执行时，它可能会与该
    IP 地址建立连接：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following example, the *ASCII* strings extracted from a malware called
    *Spybot* give an indication of its *DOS* and *Key logging* capabilities:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，从名为 *Spybot* 的恶意软件提取的 *ASCII* 字符串表明了它的 *DOS* 和 *键盘记录* 功能：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Malware specimens also use *Unicode* (2 bytes per character) strings. To get
    useful information from the binary, sometimes you need to extract both *ASCII*
    and *Unicode* strings. To extract Unicode strings using the *strings* command,
    use the `-el `option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件样本还使用 *Unicode*（每个字符 2 字节）字符串。为了从二进制文件中获取有用信息，有时你需要同时提取 *ASCII* 和 *Unicode*
    字符串。要使用 `strings` 命令提取 Unicode 字符串，可以使用 `-el` 选项。
- en: 'In the following example, the malware sample did not reveal unusual *ASCII*
    strings, but extracting the *Unicode* strings showed references to the *domain
    name*, and the *Run registry key* (which is frequently used by malware to survive
    the reboot); and it also highlights a malware''s possible capability to add a
    program to the firewall whitelist:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，恶意软件样本并未揭示出异常的 *ASCII* 字符串，但提取的 *Unicode* 字符串显示了对 *域名* 和 *Run 注册表键*（恶意软件常用来在重启后保持存活）的引用；它还突出了恶意软件可能具有将程序添加到防火墙白名单的能力：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On Windows, *pestudio* ([https://www.winitor.com](https://www.winitor.com))
    is a handy tool that displays both ASCII and Unicode strings. pestudio is an excellent
    PE analysis tool for performing initial malware assessment of a suspect binary,
    and is designed to retrieve various pieces of useful information from a PE executable.
    Various other features of this tool will be covered in subsequent sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，*pestudio* ([https://www.winitor.com](https://www.winitor.com))
    是一款方便的工具，能够显示 ASCII 和 Unicode 字符串。pestudio 是一款出色的 PE 分析工具，用于执行对可疑二进制文件的初步恶意软件评估，旨在从
    PE 可执行文件中提取各种有用信息。此工具的其他多种功能将在后续章节中详细介绍。
- en: 'The following screenshot shows some of the *ASCII* and *Unicode* strings listed
    by pestudio; it assists you by highlighting some of the notable strings in the
    blacklisted column, which allows you to focus on the interesting strings in the
    binary:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了pestudio列出的一些*ASCII*和*Unicode*字符串，它通过在黑名单列中突出显示一些显著的字符串，帮助你专注于二进制文件中的有趣字符串：
- en: '![](../images/00019.jpeg)The *strings* utility ported to Windows by Mark Russinovich
    ([https://technet.microsoft.com/en-us/sysinternals/strings.aspx](https://technet.microsoft.com/en-us/sysinternals/strings.aspx))
    and *PPEE* ([https://www.mzrst.com/](https://www.mzrst.com/)) are some of the
    other tools that can be used to extract both ASCII and Unicode strings.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00019.jpeg)由Mark Russinovich移植到Windows的*strings*工具（[https://technet.microsoft.com/en-us/sysinternals/strings.aspx](https://technet.microsoft.com/en-us/sysinternals/strings.aspx)）和*PPEE*（[https://www.mzrst.com/](https://www.mzrst.com/)）是其他可以用来提取ASCII和Unicode字符串的工具。'
- en: 4.2 Decoding Obfuscated Strings Using FLOSS
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 使用FLOSS解码混淆字符串
- en: Most of the times, malware authors use simple string obfuscation techniques
    to avoid detection. In such cases, those obfuscated strings will not show up in
    the strings utility and other string extraction tools. *FireEye Labs Obfuscated
    String Solver* (*FLOSS*) is a tool designed to identify and extract obfuscated
    strings from malware automatically. It can help you determine the strings that
    malware authors want to hide from string extraction tools. *FLOSS* can also be
    used just like the strings utility to extract human-readable strings (ASCII and
    Unicode). You can download *FLOSS* for Windows or Linux from [https://github.com/fireeye/flare-floss](https://github.com/fireeye/flare-floss).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，恶意软件作者使用简单的字符串混淆技术来避免被检测到。在这种情况下，那些混淆过的字符串不会出现在`strings`工具和其他字符串提取工具中。*FireEye实验室混淆字符串解码器*（*FLOSS*）是一款旨在自动识别和提取恶意软件中混淆字符串的工具。它可以帮助你识别恶意软件作者想要隐藏的字符串，避免被字符串提取工具提取。*FLOSS*也可以像`strings`工具一样，用于提取人类可读的字符串（ASCII和Unicode）。你可以从[https://github.com/fireeye/flare-floss](https://github.com/fireeye/flare-floss)下载适用于Windows或Linux的*FLOSS*。
- en: In the following example, running a *FLOSS* standalone *binary* on a malware
    specimen not only extracted the human-readable strings but also decoded the obfuscated
    strings and extracted *stack strings* missed by the strings utility and other
    string extraction tools. The following output shows reference to an *executable*,
    *Excel file*, and *Run registry key:*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，运行一个*FLOSS*独立的*二进制文件*在恶意软件样本上，不仅提取了人类可读的字符串，还解码了混淆过的字符串，并提取了*栈字符串*，这些是`strings`工具和其他字符串提取工具遗漏的。以下输出显示了对*可执行文件*、*Excel
    文件*和*运行注册表项*的引用：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you are only interested in the *decoded/stack strings* and want to exclude
    the static strings (ASCII and Unicode) from the FLOSS output, then provide it
    the `–-no-static-strings` switch. Detailed information about the workings of FLOSS
    and its various usage options is available at [https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html](https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对*解码/栈字符串*感兴趣，并且想要从FLOSS输出中排除静态字符串（ASCII和Unicode），那么可以使用`--no-static-strings`开关。关于FLOSS工作原理及其各种使用选项的详细信息，请访问[https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html](https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html)。
- en: 5\. Determining File Obfuscation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 确定文件混淆
- en: Even though string extraction is an excellent technique to harvest valuable
    information, often malware authors obfuscate or armor their malware binary. Obfuscation
    is used by malware authors to protect the inner workings of the malware from security
    researchers, malware analysts, and reverse engineers. These obfuscation techniques
    make it difficult to detect/analyze the binary; extracting the strings from such
    binary results in very fewer strings, and most of the strings are obscure. Malware
    authors often use programs such as *Packers* and *Cryptors* to obfuscate their
    file to evade detection from security products such as anti-virus and to thwart
    analysis.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符串提取是一种出色的技术，可以获取有价值的信息，但恶意软件作者常常对其恶意软件二进制文件进行混淆或加固。恶意软件作者使用混淆技术来保护恶意软件的内部工作原理，防止安全研究人员、恶意软件分析师和逆向工程师的分析。这些混淆技术使得检测/分析二进制文件变得困难；从这样的二进制文件中提取字符串的结果是字符串数量非常少，而且大多数字符串都是模糊不清的。恶意软件作者通常使用诸如*打包器*和*加密器*之类的程序对文件进行混淆，以避免安全产品如反病毒软件的检测，并破坏分析过程。
- en: 5.1 Packers and Cryptors
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 打包器和加密器
- en: A *Packer* is a program that takes the executable as input, and it uses compression
    to obfuscate the executable's content. This obfuscated content is then stored
    within the structure of a new executable file; the result is a new executable
    file (packed program) with obfuscated content on the disk. Upon execution of the
    packed program, it executes a decompression routine, which extracts the original
    binary in memory during runtime and triggers the execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*打包器*（*Packer*）是一个程序，它将可执行文件作为输入，并使用压缩来混淆可执行文件的内容。这个混淆后的内容会存储在新可执行文件的结构中；最终结果是一个带有混淆内容的新可执行文件（打包程序），并存储在磁盘上。在执行这个打包程序时，它会执行一个解压例程，在运行时将原始二进制文件提取到内存中并触发执行。'
- en: A *Cryptor* is similar to a *Packer,* but instead of using compression, it uses
    encryption to obfuscate the executable's content, and the encrypted content is
    stored in the new executable file. Upon execution of the encrypted program, it
    runs a decryption routine to extract the original binary in the memory and then
    triggers the execution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密器*（*Cryptor*）类似于*打包器*（*Packer*），但它使用加密而非压缩来混淆可执行文件的内容，加密后的内容存储在新的可执行文件中。在执行加密程序时，它会运行解密例程，从内存中提取原始二进制文件，并触发执行。'
- en: 'To demonstrate the concept of file obfuscation, let''s take an example of a
    malware sample called *Spybot* (not packed); extracting strings from *Spybot*
    show, references to suspicious executable names and IP addresses, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示文件混淆的概念，我们以一个名为*Spybot*的恶意软件样本（未打包）为例；从*Spybot*中提取字符串后，显示出可疑的可执行文件名和IP地址，如下所示：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Spybot sample was then run through a popular packer *UPX* ([https://upx.github.io/](https://upx.github.io/)),
    which resulted in a new packed executable file (`spybot_packed.exe`). The following
    command output shows the size discrepancy between the original and the packed
    binary.UPX uses compression, because of which the size of the packed binary is
    lower than the original binary:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*Spybot*样本通过一个流行的打包工具*UPX*（[https://upx.github.io/](https://upx.github.io/)）进行了打包，结果是生成了一个新的打包可执行文件（`spybot_packed.exe`）。以下命令输出显示了原始文件与打包文件之间的大小差异。UPX使用压缩，因此打包后的二进制文件比原始二进制文件小：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running the strings command on the packed binary shows obscured strings and
    does not reveal much valuable information; this is one of the reasons why attackers
    obfuscate their files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对打包二进制文件运行strings命令会显示被混淆的字符串，且没有透露出太多有价值的信息；这也是攻击者混淆文件的原因之一：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: UPX is a common packer, and many times you will come across malware samples
    packed with UPX. In most cases, it is possible to unpack the sample using the `-d`option*. *An
    example command is `upx -d -o spybot_unpacked.exe spybot_packed.exe` .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: UPX是一个常见的打包工具，你经常会遇到用UPX打包的恶意软件样本。在大多数情况下，你可以使用`-d`选项来解包样本。*一个示例命令是`upx -d -o
    spybot_unpacked.exe spybot_packed.exe`*。
- en: 5.2 Detecting File Obfuscation Using Exeinfo PE
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 使用Exeinfo PE检测文件混淆
- en: Most legitimate executables do not obfuscate content, but some executables may
    do it to prevent others from examining their code. When you come across a sample
    that is packed, there is a high chance of it being malicious. To detect packers
    on Windows, you can use a freeware tool such as *Exeinfo PE* ([http://exeinfo.atwebpages.com/](http://exeinfo.atwebpages.com/));
    it has an easy-to-use GUI. At the time of writing this book, it uses more than
    4,500 signatures (stored in `userdb.txt` in the same directory) to detect various
    compilers, packers, or cryptors utilized to build the program. In addition to
    detecting Packers, another interesting feature of *Exeinfo PE* is that it gives
    information/references on how to unpack the sample.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数合法的可执行文件不会混淆内容，但一些可执行文件可能会这样做，以防止他人检查其代码。当你遇到一个被打包的样本时，它很可能是恶意的。为了检测Windows上的打包工具，你可以使用像*Exeinfo
    PE*这样的免费工具（[http://exeinfo.atwebpages.com/](http://exeinfo.atwebpages.com/)）；它具有易于使用的图形界面。写这本书时，它使用超过4,500个签名（存储在`userdb.txt`文件中）来检测构建程序时使用的各种编译器、打包工具或加密工具。除了检测打包工具，*Exeinfo
    PE*的另一个有趣功能是，它会提供如何解包样本的信息或参考。
- en: 'Loading the packed *Spybot* malware sample into *Exeinfo PE* shows that it
    is packed with UPX, and it also gives a hint on which command to use to decompress
    the obfuscated file; this can make your analysis much easier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将打包的*Spybot*恶意软件样本加载到*Exeinfo PE*中显示它是用UPX打包的，并且还给出了使用哪个命令来解压混淆文件的提示；这可以让你的分析变得更加轻松：
- en: '![](../images/00020.jpeg)Other CLI and GUI tools that can help you with packer
    detections include *TrID *([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html)),
    *TRIDNet* ([http://mark0.net/soft-tridnet-e.html](http://mark0.net/soft-tridnet-e.html)),
    *Detect It Easy *([http://ntinfo.biz/](http://ntinfo.biz/)), *RDG Packer Detector*
    ([http://www.rdgsoft.net/](http://www.rdgsoft.net/)), *packerid.py* ([https://github.com/sooshie/packerid](https://github.com/sooshie/packerid)),
    and *PEiD* ([http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00020.jpeg)其他可以帮助你进行打包检测的 CLI 和 GUI 工具包括 *TrID* ([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html))，*TRIDNet*
    ([http://mark0.net/soft-tridnet-e.html](http://mark0.net/soft-tridnet-e.html))，*Detect
    It Easy* ([http://ntinfo.biz/](http://ntinfo.biz/))，*RDG Packer Detector* ([http://www.rdgsoft.net/](http://www.rdgsoft.net/))，*packerid.py*
    ([https://github.com/sooshie/packerid](https://github.com/sooshie/packerid))，和
    *PEiD* ([http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml))。'
- en: 6\. Inspecting PE Header Information
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 检查 PE 头部信息
- en: Windows executables must conform to the *PE/COFF (Portable Executable/Common
    Object File Format)*. The PE file format is used by the Windows executable files
    (such as `.exe`, `.dll`, `.sys`, `.ocx`, and `.drv`) and such files are generally
    called *Portable Executable (PE)* files. The PE file is a series of structures
    and sub-components that contain the information required by the operating system
    to load it into memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 可执行文件必须符合 *PE/COFF（可移植可执行/通用对象文件格式）*。PE 文件格式被 Windows 可执行文件（如 `.exe`、`.dll`、`.sys`、`.ocx`
    和 `.drv`）使用，这些文件通常被称为 *可移植可执行（PE）* 文件。PE 文件是由一系列结构和子组件组成，包含了操作系统加载到内存所需的信息。
- en: When an executable is compiled, it includes a header (PE header), which describes
    its structure. When the binary is executed, the operating system loader reads
    the information from the PE header and then loads the binary content from the
    file into the memory. The PE header contains information such as where the executable
    needs to be loaded into memory, the address where the execution starts, the list
    of libraries/functions on which the application relies on, and the resources used
    by the binary. Examining the PE header yields a wealth of information about the
    binary, and its functionalities.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个可执行文件被编译时，它包含一个头部（PE 头部），该头部描述了其结构。当二进制文件被执行时，操作系统加载器从 PE 头部读取信息，然后将二进制内容从文件加载到内存中。PE
    头部包含的信息有：可执行文件需要加载到内存中的位置、执行开始的地址、应用程序所依赖的库/函数列表以及二进制文件使用的资源。检查 PE 头部可以获得关于二进制文件及其功能的丰富信息。
- en: 'This book does not cover the basics of PE file structure. However, the concepts
    that are relevant to malware analysis will be covered in the following sub-sections;
    various resources can help in understanding the PE file structure. The following
    are some of the great resources for understanding the PE file structure:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不涵盖 PE 文件结构的基础知识。然而，与恶意软件分析相关的概念将在以下小节中进行讨论；有各种资源可以帮助理解 PE 文件结构。以下是一些理解 PE
    文件结构的优秀资源：
- en: '*An In-Depth Look into the Win32 Portable Executable File Format - Part 1:*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解 Win32 可移植可执行文件格式 - 第 1 部分：*'
- en: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1)'
- en: '*An In-Depth Look into the Win32 Portable Executable File Format - Part 2:*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解 Win32 可移植可执行文件格式 - 第 2 部分：*'
- en: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2)'
- en: '*PE Headers and structures:*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PE 头部和结构：*'
- en: '[http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)'
- en: '*PE101 - A Windows Executable Walkthrough:*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PE101 - Windows 可执行文件解析：*'
- en: '[https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf](https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf](https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf)'
- en: 'You can get a clear understanding of the PE file format by loading a suspect
    file into PE analysis tools. The following are the some of the tools that allow
    you to examine and modify the PE structure and its sub-components:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将可疑文件加载到 PE 分析工具中，你可以清楚地了解 PE 文件格式。以下是一些允许你检查和修改 PE 结构及其子组件的工具：
- en: '*CFF Explorer:* [http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CFF Explorer:* [http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php)'
- en: '*PE Internals:* [http://www.andreybazhan.com/pe-internals.html](http://www.andreybazhan.com/pe-internals.html)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PE 内部结构:* [http://www.andreybazhan.com/pe-internals.html](http://www.andreybazhan.com/pe-internals.html)'
- en: '*PPEE(puppy):* [https://www.mzrst.com/](https://www.mzrst.com/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PPEE(puppy):* [https://www.mzrst.com/](https://www.mzrst.com/)'
- en: '*PEBrowse Professional:* [http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html](http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEBrowse Professional:* [http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html](http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html)'
- en: The subsequent sections will cover some of the important PE file attributes
    that are useful for malware analysis. A tool such as *pestudio* ([https://www.winitor.com](https://www.winitor.com))
    or *PPEE (puppy***: **[https://www.mzrst.com/](https://www.mzrst.com/)) can assist
    you with exploring interesting artifacts from the PE file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '后续部分将介绍一些对恶意软件分析有用的重要 PE 文件属性。诸如 *pestudio* ([https://www.winitor.com](https://www.winitor.com))
    或 *PPEE (puppy)*: **[https://www.mzrst.com/](https://www.mzrst.com/)** 等工具，可以帮助你探索
    PE 文件中的有趣信息。'
- en: 6.1 Inspecting File Dependencies and Imports
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 检查文件依赖关系和导入
- en: Usually, malware interacts with the file, registry, network, and so on. To perform
    such interactions, malware frequently depends on the functions exposed by the
    operating system. Windows exports most of its functions, called *Application Programming
    Interfaces (API),* required for these interactions in *Dynamic Link Libary (DLL)*
    files. Executables import and call these functions typically from various DLLs
    that provide different functionality. The functions that an executable imports
    from other files (mostly DLLs) are called *imported functions* (or *imports*)*.*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，恶意软件与文件、注册表、网络等进行交互。为了执行这些交互，恶意软件通常依赖于操作系统暴露的功能。Windows 导出大部分执行这些交互所需的功能，这些功能被称为*应用程序编程接口（API）*，并存储在*动态链接库（DLL）*文件中。可执行文件通常从提供不同功能的各种
    DLL 文件中导入并调用这些函数。可执行文件从其他文件（主要是 DLL）导入的函数称为*导入函数*（或*imports*）。
- en: For example, if a malware executable wants to create a file on disk, on Windows,
    it can use an API `CreateFile()`, which is exported in `kernel32.dll`. To call
    the API, it first has to load `kernel32.dll` into its memory and then call the
    `CreateFile()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果恶意软件可执行文件想要在磁盘上创建一个文件，它可以使用 Windows 中的 `CreateFile()` API，该 API 存储在 `kernel32.dll`
    中。为了调用该 API，恶意软件首先必须将 `kernel32.dll` 加载到其内存中，然后调用 `CreateFile()` 函数。
- en: Inspecting the DLLs that a malware relies upon and the API functions that it
    imports from the DLLs can give an idea about the functionality and capability
    of malware and what to anticipate during its execution. The file dependencies
    in Windows executables are stored in the import table of the PE file structure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 检查恶意软件依赖的 DLL 以及它从这些 DLL 导入的 API 函数，可以帮助了解恶意软件的功能和能力，并预测其执行过程中可能发生的情况。Windows
    可执行文件中的文件依赖关系存储在 PE 文件结构的导入表中。
- en: 'In the following example, the *spybot* sample was loaded in pestudio. Clicking
    on the libraries button in pestudio displays all the DLL files the executable
    depends on and the number of imported functions imported from each DLL. These
    are the DLL files that will be loaded into the memory when the program is executed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，*spybot* 样本被加载到 pestudio 中。点击 pestudio 中的库按钮，显示出可执行文件依赖的所有 DLL 文件，以及从每个
    DLL 导入的函数数量。这些是程序执行时会加载到内存中的 DLL 文件：
- en: '![](../images/00021.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: 'Clicking on the imports button in pestudio displays the API functions imported
    from those DLLs. In the following screenshot, the malware imports network-related
    API functions (such as `connect`, `socket`, `listen`, `send`, and so on) from
    `wsock32.dll`, indicating that the malware, upon execution, will most likely connect
    to the Internet or perform some network activity. pestudio highlights the API
    functions that are frequently used by malwares in the blacklisted column. In subsequent
    chapters, the techniques to inspect API functions will be covered in more detail:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 pestudio 中的导入按钮会显示从这些 DLL 导入的 API 函数。在以下截图中，恶意软件从 `wsock32.dll` 导入与网络相关的
    API 函数（如 `connect`、`socket`、`listen`、`send` 等），这表明恶意软件在执行时很可能会连接到互联网或执行某些网络活动。
    pestudio 会在黑名单栏中突出显示恶意软件常用的 API 函数。在后续章节中，将更详细地介绍如何检查 API 函数的技巧：
- en: '![](../images/00022.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: Sometimes, malware can load a DLL explicitly during runtime using API calls
    such as `LoadLibrary()` or `LdrLoadDLL()`, and it can resolve the function address
    using the `GetProcessAdress()` API. Information about the DLLs loaded during runtime
    will not be present in the import table of the PE file and therefore will not
    be displayed by the tools.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，恶意软件可以在运行时显式加载 DLL，使用 `LoadLibrary()` 或 `LdrLoadDLL()` 等 API 调用，并且可以通过 `GetProcessAdress()`
    API 来解析函数地址。在运行时加载的 DLL 信息不会出现在 PE 文件的导入表中，因此工具不会显示这些信息。
- en: Information about an API function and what it does can be determined from *MSDN
    (Microsoft Developer Network)*. Enter the API name in the search bar ([https://msdn.microsoft.com/en-us/default.aspx](https://msdn.microsoft.com/en-us/default.aspx))
    to get detailed information about the API.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 API 函数及其功能的信息可以从 *MSDN（Microsoft Developer Network）* 获得。输入 API 名称在搜索框中（[https://msdn.microsoft.com/en-us/default.aspx](https://msdn.microsoft.com/en-us/default.aspx)），以获取有关该
    API 的详细信息。
- en: In addition to determining the malware functionality, imports can help you detect
    whether a malware sample is obfuscated. If you come across a malware with very
    few imports, then it is a strong indication of a packed binary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确定恶意软件功能外，导入项还可以帮助你检测恶意软件样本是否被混淆。如果你遇到一个导入项非常少的恶意软件，那么这强烈表明它是一个打包的二进制文件。
- en: 'To demonstrate that, let''s compare the imports between the *unpacked sample
    of spybot* and the *packed spybot sample*. The following screenshot shows 110
    imports in the unpacked spybot sample:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们比较 *未打包的 spybot 样本* 和 *打包的 spybot 样本* 之间的导入项。以下截图显示了未打包的 spybot 样本中有
    110 个导入项：
- en: '![](../images/00023.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: 'On the other hand, the *packed sample* of spybot shows only 12 imports:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，spybot 的 *打包样本* 仅显示了 12 个导入：
- en: '![](../images/00024.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: 'Sometimes you might want to use Python to enumerate DLL files and imported
    functions (probably to work with a large number of files); this can be done using
    Ero Carerra''s *pefile* module ([https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile)).
    The installation of the *pefile* module on Ubuntu Linux VM was covered in [Chapter
    1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction to Malware
    Analysis.* If you are using any other operating system, then it can be installed
    using pip (`pip install pefile`). The following Python script demonstrates the
    use of the *pefile* module to enumerate the DLLs and the imported API functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要使用 Python 来列举 DLL 文件和导入的函数（可能是为了处理大量文件）；这可以使用 Ero Carerra 的 *pefile*
    模块完成（[https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile)）。在
    [第1章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)，*恶意软件分析简介* 中已介绍如何在
    Ubuntu Linux 虚拟机上安装 *pefile* 模块。如果你使用的是其他操作系统，可以通过 pip 安装（`pip install pefile`）。以下
    Python 脚本演示了如何使用 *pefile* 模块列举 DLL 文件和导入的 API 函数：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the result of running the preceding script against the `spybot_packed.exe`
    sample; from the output, you can see the list of DLLs and imported functions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行上述脚本对 `spybot_packed.exe` 样本进行分析后的结果；从输出中可以看到 DLL 文件和导入函数的列表：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 6.2  Inspecting Exports
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2  检查导出
- en: The executable and DLL can export functions, which can be used by other programs.
    Typically, a DLL exports functions (*exports*) that are imported by the executable.
    A DLL cannot run on its own and depends on a host process for executing its code.
    An attacker often creates a DLL that exports functions containing malicious functionality.
    To run the malicious functions within the DLL, it is somehow made to be loaded
    by a process that calls these malicious functions. DLLs can also import functions
    from other libraries (DLLs) to perform system operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件和 DLL 可以导出函数，供其他程序使用。通常，DLL 导出由可执行文件导入的函数 (*exports*)。DLL 本身无法独立运行，依赖于主进程来执行其代码。攻击者通常会创建一个导出包含恶意功能的函数的
    DLL。为了执行 DLL 中的恶意函数，必须通过某种方式使其被加载到一个进程中，并调用这些恶意函数。DLL 还可以从其他库（DLL）导入函数以执行系统操作。
- en: 'Inspecting the exported functions can give you a quick idea of the DLL''s capabilities.
    In the following example, loading a DLL associated with malware called *Ramnit*
    in pestudio shows its exported functions, giving an indication of its capabilities.
    When a process loads this DLL, at some point, these functions will be called to
    perform malicious activities:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查导出的函数可以快速了解 DLL 的功能。在以下示例中，加载一个与恶意软件 *Ramnit* 相关的 DLL 到 pestudio 中，查看其导出函数，从而推测其功能。当一个进程加载这个
    DLL 时，某个时刻，这些函数会被调用来执行恶意活动：
- en: '![](../images/00025.jpeg)Export function names may not always give an idea
    of a malware''s capabilities. An attacker may use random or fake export names
    to mislead your analysis or to throw you off track.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00025.jpeg)导出函数的名称可能无法完全反映恶意软件的功能。攻击者可能使用随机或伪造的导出名称来误导你的分析，或者将你引入误区。'
- en: 'In Python, the exported functions can be enumerated using the *pefile module*,
    as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用 *pefile 模块* 枚举导出函数，如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 6.3  Examining PE Section Table And Sections
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3  检查 PE 段表和段
- en: The actual content of the PE file is divided into sections. The sections are
    immediately followed by the PE header. These sections represent either *code*
    or *data* and they have in-memory attributes such as read/write. The section representing
    code contains instructions that will be executed by the processor, whereas the
    section containing data can represent different types of data, such as read/write
    program data (global variables), import/export tables, resources, and so on. Each
    section has a distinct name that conveys the purpose of the section. For example,
    a section with name `.text` indicates code and has an attribute of `read-execute`;
    a section with name `.data` indicates global data and has an attribute of `read-write`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: PE 文件的实际内容被划分为多个段（sections）。这些段紧接在 PE 头之后。这些段代表的是 *代码* 或 *数据*，并具有如读/写等内存属性。代表代码的段包含将由处理器执行的指令，而包含数据的段可以代表不同类型的数据，如读/写程序数据（全局变量）、导入/导出表、资源等。每个段都有一个独特的名称，用来表示该段的目的。例如，名为
    `.text` 的段表示代码，并具有 `read-execute` 属性；名为 `.data` 的段表示全局数据，并具有 `read-write` 属性。
- en: 'During the compilation of the executable, consistent section names are added
    by the compilers. The following table outlines some of the common sections in
    a PE file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在可执行文件的编译过程中，编译器会添加一致的段名。下表列出了 PE 文件中一些常见的段：
- en: '| **Section Name** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **段名** | **描述** |'
- en: '| `.text` or `CODE` | Contains executable code. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `.text` 或 `CODE` | 包含可执行代码。 |'
- en: '| `.data` or `DATA` | Typically Contains read/write data and global variables.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `.data` 或 `DATA` | 通常包含读/写数据和全局变量。 |'
- en: '| .`rdata` | Contains read-only data. Sometimes it also contains import and
    export information.  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `.rdata` | 包含只读数据。有时它还包含导入和导出信息。 |'
- en: '| `.idata` | If present, contains the import table. If not present, then the
    import information is stored in `.rdata` section. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `.idata` | 如果存在，包含导入表。如果不存在，则导入信息存储在 `.rdata` 段中。 |'
- en: '| `.edata` | If present, contains export information. If not present, then
    the export information is found in `.rdata` section. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `.edata` | 如果存在，包含导出信息。如果不存在，则导出信息位于 `.rdata` 段中。 |'
- en: '| `.rsrc` | This section contains the resources used by the executable such
    as icons, dialogs, menus, strings, and so on. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `.rsrc` | 此段包含可执行文件使用的资源，如图标、对话框、菜单、字符串等。 |'
- en: These section names are mainly for humans and are not used by the operating
    system, which means it is possible for an attacker or an obfuscation software
    to create sections with different names. If you come across section names that
    are not common, then you should treat them with suspicion, and further analysis
    is required to confirm maliciousness.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节名称主要供人类使用，操作系统并不使用它们，这意味着攻击者或混淆软件可能会创建具有不同名称的节。如果你遇到不常见的节名称，应当对此保持怀疑，并且需要进一步分析以确认其是否具有恶意。
- en: Information about these sections (such as section name, where to find the section,
    and its characteristics) is present in the *section table* in the PE header. Examining
    a section table will give information about the section and its characteristics.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节的信息（如节名称、节的位置以及其特征）存在于PE头中的*节表*中。检查节表将提供关于节及其特征的信息。
- en: 'When you load an executable in *pestudio* and click on sections, it displays
    the section information extracted from the section table and its attributes (read/write and
    so on). The next screenshot from pestudio shows the section information for an
    executable, and some relevant fields from the screenshot are explained here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*pestudio*中加载一个可执行文件并点击节时，它会显示从节表提取的节信息及其属性（如读/写等）。以下是来自pestudio的可执行文件的节信息截图，截图中一些相关字段在此进行解释：
- en: '| **Field** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **描述** |'
- en: '| Names | Displays section names. In this case, the executable contains four
    sections (`.text`, `.data`, `.rdata` and `.rsrc`). |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 显示节名称。在这种情况下，可执行文件包含四个节（`.text`、`.data`、`.rdata`和`.rsrc`）。 |'
- en: '| Virtual-Size | Indicates the size of the section when loaded into memory.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟大小 | 指示加载到内存时节的大小。 |'
- en: '| Virtual-Address | This is the relative virtual address (that is, offset from
    the base address of the executable) where the section can be found in memory.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟地址 | 这是节在内存中的相对虚拟地址（即，从可执行文件的基地址开始的偏移）。'
- en: '| Raw-size | Indicates the size of the section on the disk. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 原始大小 | 指示节在磁盘上的大小。 |'
- en: '| Raw-data | Indicates the offset in the file where the section can be found.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据 | 指示文件中节所在的偏移位置。 |'
- en: '| Entry-point | This is the RVA (relative virtual address) where the code starts
    executing. In this case, the entry point is in the `.text` section, which is normal. 
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 入口点 | 这是代码开始执行的RVA（相对虚拟地址）。在这种情况下，入口点位于`.text`节中，这是正常的。 |'
- en: '![](../images/00026.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: 'Examining the section table can also help in identifying any anomaly in the
    PE file. The following screenshot shows the section names of a malware packed
    with UPX; the malware sample contains the following discrepancies:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查节表也有助于识别PE文件中的任何异常。以下截图显示了一个使用UPX打包的恶意软件的节名称；该恶意软件样本包含以下差异：
- en: The section names do not contain common sections added by the compiler (such
    as `.text`, `.data`, and so on) but contain section names `UPX0` and `UPX1`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节名称不包含编译器添加的常见节（如`.text`、`.data`等），而是包含`UPX0`和`UPX1`节名称。
- en: The entry point is in the `UPX1` section, indicating that execution will start
    in this section (decompression routine).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点位于`UPX1`节中，这表明执行将从此节开始（解压缩例程）。
- en: Typically, `raw-size` and the `virtual-size` should be almost equal, but small
    differences are normal due to section alignment. In this case, `raw-size` is `0`,
    indicating that this section will not take up space on the disk, but `virtual-size`
    specifies that, in memory, it takes up more space (around `127 kb`). This is a
    strong indication of a packed binary. The reason for this discrepancy is that
    when a packed binary is executed, the decompression routine of the packer will
    copy decompressed data or instructions into the memory during runtime.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，`原始大小`和`虚拟大小`应该几乎相等，但由于节对齐的原因，存在小的差异是正常的。在这种情况下，`原始大小`为`0`，表示该节不会占用磁盘空间，但`虚拟大小`指定该节在内存中占用更多空间（大约`127
    KB`）。这强烈表明这是一个打包的二进制文件。造成这种差异的原因是，当一个打包的二进制文件执行时，打包程序的解压例程会在运行时将解压后的数据或指令复制到内存中。
- en: '![](../images/00027.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'The following Python script demonstrates the use of the *pefile* module to
    display the section and its characteristics:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python脚本演示了如何使用*pefile*模块来显示节及其特征：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output after running the preceding Python script:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行前面Python脚本后的输出：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*pescanner* by Michael Ligh and Glenn P. Edwards is an excellent tool to detect
    suspicious PE files based on the PE file attributes; it uses heuristics instead
    of using signatures and can help you identify packed binaries even if there are
    no signatures for it. A copy of the script can be downloaded from [https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py](https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Ligh 和 Glenn P. Edwards 开发的 *pescanner* 是一个出色的工具，可以根据 PE 文件属性检测可疑的 PE
    文件；它使用启发式方法而不是签名，并且即使没有签名，也能帮助你识别被打包的二进制文件。你可以从 [https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py](https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py)
    下载脚本副本。
- en: 6.4 Examining the Compilation Timestamp
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 检查编译时间戳
- en: 'The PE header contains information that specifies when the binary was compiled;
    examining this field can give an idea of when the malware was first created. This
    information can be useful in building a timeline of the attack campaign. It is
    also possible that an attacker modifies the timestamp to prevent an analyst from
    knowing the actual timestamp. A compile timestamp can sometimes be used to classify
    suspicious samples. The following example shows a malware binary whose timestamp
    was modified to a future date in 2020\. In this case, even though the actual compilation
    timestamp could not be detected, such characteristics can help you identify anomalous
    behavior:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PE 头部包含指定二进制文件编译时间的信息；检查这个字段可以帮助你了解恶意软件首次创建的时间。这些信息对于构建攻击活动的时间线非常有用。攻击者也可能修改时间戳，防止分析人员了解实际的时间戳。有时候，编译时间戳可以用来分类可疑样本。以下示例显示了一个恶意软件二进制文件，其时间戳被修改为
    2020 年的未来日期。在这种情况下，尽管无法检测到实际的编译时间戳，但这些特征可以帮助你识别异常行为：
- en: '![](../images/00028.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'In Python, you can determine the compile timestamp using the following Python
    commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以使用以下 Python 命令来确定编译时间戳：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All Delphi binaries have a compile timestamp set to June 19, 1992, making it
    hard to detect the actual compile timestamp. If you are investigating a malware
    binary set to this date, there is a high possibility that you are looking at Delphi
    binary. The blog post at a [http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/](http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/) gives
    information on how it may be possible to get the compilation timestamp from a
    Delphi binary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Delphi 二进制文件的编译时间戳都设置为 1992 年 6 月 19 日，这使得很难检测到实际的编译时间戳。如果你正在调查一个时间戳设置为这个日期的恶意软件二进制文件，很可能你正在查看
    Delphi 二进制文件。以下博客文章 [http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/](http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/)
    提供了有关如何从 Delphi 二进制文件获取编译时间戳的信息。
- en: 6.5 Examining PE Resources
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 检查 PE 资源
- en: The resources required by the executable file such as icons, menu, dialog, and
    strings are stored in the resource section (`.rsrc`) of an executable file. Often, attackers
    store information such as additional binary, and decoy documents, configuration
    data in the resource section, so examining the resource can reveal valuable information
    about a binary. The resource section also contains version information that can
    reveal information about the origin, company name, program author details, and
    copyright information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件所需的资源，如图标、菜单、对话框和字符串，都存储在可执行文件的资源部分（`.rsrc`）中。攻击者通常将附加的二进制文件、诱饵文档、配置数据等信息存储在资源部分，因此检查资源部分可以揭示二进制文件的有价值信息。资源部分还包含版本信息，可以揭示有关来源、公司名称、程序作者细节和版权信息。
- en: '*Resource Hacker* ([http://www.angusj.com/resourcehacker/](http://www.angusj.com/resourcehacker/))
    is a great tool to examine, view, and extract the resource from a suspect binary.
    Let''s take an example of binary that looks like an Excel file on the disk (notice
    how the file extension is changed to `.xls.exe`), as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*Resource Hacker* ([http://www.angusj.com/resourcehacker/](http://www.angusj.com/resourcehacker/))
    是一个非常好的工具，可以用来检查、查看和提取可疑二进制文件中的资源。我们以一个看起来像 Excel 文件的二进制文件为例（注意文件扩展名被更改为 `.xls.exe`），如下所示：'
- en: '![](../images/00029.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'Loading a malicious binary in resource hacker shows three resources (*Icon*,
    *Binary,* and *Icon Group*). The malware specimen uses the icon of Microsoft Excel
    (to give the appearance of an excel sheet):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意二进制文件加载到 Resource Hacker 中，显示三个资源（*图标*，*二进制* 和 *图标组*）。该恶意软件样本使用了 Microsoft
    Excel 的图标（以给人一种 Excel 表格的假象）：
- en: '![](../images/00030.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: 'The executable also contains binary data; one of them has a file signature
    of `D0 CF 11 E0 A1 B1 1A E1`. This sequence of bytes represents the file signature
    for a Microsoft Office document file. The attackers, in this case, stored a decoy
    excel sheet in the resource section. Upon execution, the malware is executed in
    the background, and this decoy excel sheet is displayed to the user as a diversion:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件还包含二进制数据；其中一个具有文件签名`D0 CF 11 E0 A1 B1 1A E1`。这组字节表示Microsoft Office文档文件的文件签名。在这种情况下，攻击者在资源部分存储了一个诱饵Excel表。在执行时，恶意软件在后台执行，并且这个诱饵Excel表显示给用户作为一种转移：
- en: '![](../images/00031.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: 'To save the binary to disk, right-click on the resource that you want to extract
    and click on Save Resource to a *.bin file as shown in the following screenshot.
    In this case, the resource was saved as `sample.xls`*. *The following screenshot
    shows the decoy excel sheet that will be displayed to the user:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制文件保存到磁盘上，请右键单击要提取的资源，然后单击“保存资源”到*.bin文件，如下面的屏幕截图所示。在这种情况下，资源被保存为`sample.xls`。下面的屏幕截图显示了将显示给用户的诱饵Excel表：
- en: '![](../images/00032.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: Just by exploring the contents of the resource section, a lot can be learned
    about the malware characteristics.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索资源部分的内容，可以了解很多关于恶意软件特征的信息。
- en: 7. Comparing And Classifying The Malware
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 比较和分类恶意软件
- en: During your malware investigation, when you come across a malware sample, you
    may want to know whether the malware sample belongs to a particular malware family
    or if it has characteristics that match with the previously analyzed samples.
    Comparing the suspect binary with previously analyzed samples or the samples stored
    in a public or private repository can give an understanding of the malware family,
    its characteristics, and the similarity with the previously analyzed samples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行恶意软件调查时，当您遇到一个恶意软件样本时，您可能想知道该恶意软件样本是否属于特定的恶意软件家族，或者它是否具有与先前分析的样本相匹配的特征。将可疑二进制文件与先前分析的样本或存储在公共或私人存储库中的样本进行比较，可以了解恶意软件家族、其特征以及与先前分析的样本的相似性。
- en: 'While cryptographic hashing (*MD5/SHA1/SHA256*) is a great technique to detect
    identical samples, it does not help in identifying similar samples. Very often,
    malware authors change minute aspects of malware, which changes the hash value
    completely. The following sections describe some of the techniques that can help
    in comparing and classifying the suspect binary:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然加密哈希（*MD5/SHA1/SHA256*）是一种检测相同样本的好方法，但它并不能帮助识别相似的样本。恶意软件作者经常改变恶意软件的微小方面，这会完全改变哈希值。以下部分描述了一些可以帮助比较和分类可疑二进制文件的技术：
- en: 7.1 Classifying Malware Using Fuzzy Hashing
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 使用模糊哈希分类恶意软件
- en: '*Fuzzy hashing* is a great method to compare files for similarity. *ssdeep*
    ([http://ssdeep.sourceforge.net](http://ssdeep.sourceforge.net)) is a useful tool
    to generate the fuzzy hash for a sample, and it also helps in determining percentage
    similarity between the samples. This technique is useful in comparing a suspect
    binary with the samples in a repository to identify the samples that are similar;
    this can help in identifying the samples that belong to the same malware family
    or the same actor group.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊哈希*是一种比较文件相似性的好方法。*ssdeep* ([http://ssdeep.sourceforge.net](http://ssdeep.sourceforge.net))是一个有用的工具，用于为样本生成模糊哈希，还有助于确定样本之间的相似度百分比。这种技术在比较可疑二进制文件与存储库中的样本时非常有用，以识别相似的样本；这有助于识别属于相同恶意软件家族或相同行动者组的样本。'
- en: 'You can use *ssdeep* to calculate and compare fuzzy hashes. Installation of
    *ssdeep* on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), To
    determine a fuzzy hash of a sample, run the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*ssdeep*来计算和比较模糊哈希。在Ubuntu Linux虚拟机上安装*ssdeep*已在[第1章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)中介绍过。要确定样本的模糊哈希，请运行以下命令：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To demonstrate the use of fuzzy hashing, let''s take an example of a directory
    consisting of three malware samples. In the following output, you can see that
    all three files have completely different MD5 hash values:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示模糊哈希的使用，让我们以一个包含三个恶意软件样本的目录为例。在下面的输出中，您可以看到所有三个文件具有完全不同的MD5哈希值：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The pretty matching mode (`-p` option) in ssdeep can be used to determine percentage
    similarity. From the following output, out of the three samples, two samples have
    99% similarity, suggesting that these two samples probably belong to the same
    malware family:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ssdeep中的美观匹配模式（`-p`选项）可以用来确定相似度百分比。从以下输出可以看出，在三个样本中，有两个样本的相似度为99%，这表明这两个样本可能属于同一恶意软件家族：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As demonstrated in the preceding example, cryptographic hashes were not helpful
    in determining the relationship between the samples, whereas the fuzzy hashing
    technique identified the similarity between the samples.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，加密哈希在确定样本之间的关系时并没有提供帮助，而模糊哈希技术则识别了样本之间的相似性。
- en: 'You might have a directory containing many malware samples. In that case, it
    is possible to run `ssdeep` on directories and subdirectories containing malware
    samples using the recursive mode (`-r`) as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个包含多个恶意软件样本的目录。在这种情况下，可以使用递归模式（`-r`）在包含恶意软件样本的目录及其子目录上运行`ssdeep`，如这里所示：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also match a suspect binary with a list of file hashes. In the following
    example, the ssdeep hashes of all the binaries were redirected to a text file
    (`all_hashes.txt`), and then the suspect binary (`blab.exe`) is matched with all
    the hashes in the file. From the following output, it can be seen that the suspect
    binary (`blab.exe`) is identical to `jnas.exe` (100% match) and has 99% similarity
    with `aiggs.exe`. You can use this technique to compare any new file with the
    hashes of previously analyzed samples:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将可疑的二进制文件与文件哈希列表进行匹配。在以下示例中，所有二进制文件的ssdeep哈希被重定向到一个文本文件（`all_hashes.txt`），然后将可疑二进制文件（`blab.exe`）与文件中的所有哈希进行匹配。从以下输出可以看出，可疑二进制文件（`blab.exe`）与`jnas.exe`完全相同（100%
    匹配），并且与`aiggs.exe`的相似度为99%。你可以使用这种技术将任何新文件与先前分析过的样本哈希进行比较：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In Python, the fuzzy hash can be computed using *python-ssdeep* ([https://pypi.python.org/pypi/ssdeep/3.2](https://pypi.python.org/pypi/ssdeep/3.2)).
    The installation of the *python-ssdeep* module on Ubuntu Linux VM was covered
    in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction
    to Malware Analysis*. To calculate and compare fuzzy hashes, the following commands
    can be used in the script:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，模糊哈希可以使用*python-ssdeep*（[https://pypi.python.org/pypi/ssdeep/3.2](https://pypi.python.org/pypi/ssdeep/3.2)）计算。在[第1章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)，*恶意软件分析入门*中介绍了如何在Ubuntu
    Linux虚拟机上安装*python-ssdeep*模块。要计算和比较模糊哈希，可以在脚本中使用以下命令：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 7.2 Classifying Malware Using Import Hash
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 使用导入哈希分类恶意软件
- en: '*Import Hashin*g is another technique that can be used to identify related
    samples and the samples used by the same threat actor groups. *Import hash* (or
    *imphash*) is a technique in which hash values are calculated based on the library/imported
    function (API) names and their particular order within the executable. If the
    files were compiled from the same source and in the same manner, those files would
    tend to have the same *imphash* value. During your malware investigation, if you
    come across samples that have the same imphash values, it means that they have
    the same import address table and are probably related.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*导入哈希*是另一种可以用来识别相关样本和同一威胁行为者组使用的样本的技术。*导入哈希*（或*imphash*）是一种通过计算基于库/导入函数（API）名称及其在可执行文件中特定顺序的哈希值的技术。如果文件是从相同的源代码编译的，并且采用相同的方式，那么这些文件的*imphash*值通常会相同。在你的恶意软件调查中，如果你遇到具有相同imphash值的样本，说明它们具有相同的导入地址表，很可能是相关的。'
- en: For detailed information on import hashing, and how it can be used to track
    threat actor groups, read [https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关导入哈希的详细信息，以及如何使用它来追踪威胁行为者组，请阅读[https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html)。
- en: 'When you load an executable into *pestudio*, it calculates the imphash as shown
    here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个可执行文件加载到*pestudio*时，它会计算出imphash，如此处所示：
- en: '![](../images/00033.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: 'In Python, imphash can be generated using the *pefile* module. The following
    Python script takes the sample as input and calculates its imphash:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以使用*pefile*模块生成imphash。以下Python脚本以样本为输入并计算其imphash：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output as a result of running the preceding script against a malware sample
    is shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本对恶意软件样本进行处理后，输出结果如下：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should also take a look at [http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html](http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html)
    which covers details of using import API and the fuzzy hashing technique (impfuzzy)
    to classify malware samples.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该查看[http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html](http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html)，该页面详细介绍了使用导入
    API 和模糊哈希技术（impfuzzy）来分类恶意软件样本的内容。
- en: 'To demonstrate the use of import hashing, let''s take the example of two samples
    from the same threat actor group. In the following output, the samples have different
    cryptographic hash values (MD5), but the impash of these samples are identical;
    this indicates that they were probably compiled from the same source and in the
    same manner:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示导入哈希的使用，我们以来自同一威胁团体的两个样本为例。在以下输出中，样本具有不同的加密哈希值（MD5），但这些样本的 impash 是相同的；这表明它们可能是从相同的源编译的，并且以相同的方式进行编译：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Files having the same *imphash* does not necessarily mean they are from the
    same threat group; you might have to correlate information from various sources
    to classify your malware. For example, it is possible that the malware samples
    were generated using a common builder kit that is shared among groups; in such
    cases, samples might have the same *imphash.*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同 *imphash* 的文件不一定来自同一威胁组；你可能需要从各种来源关联信息来分类你的恶意软件。例如，恶意软件样本可能是使用一个在不同团体之间共享的通用构建工具生成的；在这种情况下，样本可能会有相同的
    *imphash*。
- en: 7.3 Classifying Malware Using Section Hash
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 使用部分哈希分类恶意软件
- en: 'Similar to import hashing, section hashing can also help in identifying related
    samples. When an executable is loaded in *pestudio*, it calculates the *MD5* of
    each section (`.text`, `.data`, `.rdata`, and so on.). To view the section hashes,
    click on sections as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于导入哈希，部分哈希也可以帮助识别相关的样本。当可执行文件在 *pestudio* 中加载时，它会计算每个部分的 *MD5*（`.text`、`.data`、`.rdata`
    等）。要查看部分哈希，请点击部分，如下所示：
- en: '![](../images/00034.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'In Python, pefile module can be used to determine the sections hashes as shown
    here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用 pefile 模块来确定各个部分的哈希值，如下所示：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you are analyzing a malware sample, you should consider generating the
    fuzzy hash, imphash, and section hashes for the malicious binary and store them
    in a repository; that way, when you come across a new sample, it can be compared
    with these hashes to determine similarity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析恶意软件样本时，你应该考虑为恶意二进制文件生成模糊哈希、imphash 和部分哈希，并将它们存储在一个存储库中；这样，当你遇到一个新的样本时，可以将其与这些哈希进行比较，以确定相似性。
- en: 7.4 Classifying Malware Using YARA
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 使用 YARA 分类恶意软件
- en: A malware sample can contain many strings or binary indicators; recognizing
    the strings or binary data that are unique to a malware sample or a malware family
    can help in malware classification. Security researchers classify malware based
    on the unique strings and the binary indicators present in the binary. Sometimes,
    malware can also be classified based on general characteristics.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件样本可以包含许多字符串或二进制指示符；识别对恶意软件样本或恶意软件家族独特的字符串或二进制数据有助于恶意软件的分类。安全研究人员根据二进制文件中包含的独特字符串和二进制指示符来分类恶意软件。有时，恶意软件也可以根据一般特征进行分类。
- en: '*YARA* ([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/))
    is a powerful malware identification and classification tool. Malware researchers
    can create YARA rules based on textual or binary information contained within
    the malware specimen. These YARA rules consist of a set of strings and a Boolean
    expression, which determines its logic. Once the rule is written, you can use
    those rules to scan files using the YARA utility or you can use `yara-python`
    to integrate with your tools. This book does not cover all the details on writing
    yara rules but it includes enough information, and its use to get you started.
    For details on writing YARA rules, read the YARA documentation ([http://yara.readthedocs.io/en/v3.7.0/writingrules.html](http://yara.readthedocs.io/en/v3.7.0/writingrules.html)).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*YARA* ([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/))
    是一款强大的恶意软件识别和分类工具。恶意软件研究人员可以根据恶意软件样本中包含的文本或二进制信息创建 YARA 规则。这些 YARA 规则由一组字符串和一个布尔表达式组成，布尔表达式决定其逻辑。一旦编写了规则，你可以使用这些规则通过
    YARA 工具扫描文件，或者使用 `yara-python` 将其与其他工具集成。本书不会涵盖编写 YARA 规则的所有细节，但包含了足够的信息，帮助你入门。有关编写
    YARA 规则的详细信息，请阅读 YARA 文档（[http://yara.readthedocs.io/en/v3.7.0/writingrules.html](http://yara.readthedocs.io/en/v3.7.0/writingrules.html)）。'
- en: 7.4.1 Installing YARA
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4.1 安装 YARA
- en: You can download and install *YARA* from ([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/)).
    Installation of YARA on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485),* Introduction
    to Malware Analysis*. If you would like to install YARA on any other operating
    system then refer to the installation documentation: [http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html](http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/))下载并安装*YARA*。在[第1章](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485)中介绍了在Ubuntu
    Linux虚拟机上安装YARA的过程，*恶意软件分析入门*。如果你希望在其他操作系统上安装YARA，请参阅安装文档：[http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html](http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html)
- en: 7.4.2 YARA Rule Basics
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4.2 YARA规则基础
- en: 'Once installed, the next step is to create YARA rules; these rules can be generic
    or very specific, and they can be created using any text editor. To understand
    the YARA rule syntax, let''s take an example of a simple YARA rule that looks
    for suspicious strings in any file, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，下一步是创建YARA规则；这些规则可以是通用的或非常具体的，可以使用任何文本编辑器创建。为了理解YARA规则的语法，我们来看一个简单的YARA规则示例，它查找任何文件中的可疑字符串，如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The YARA rule consists of the following components:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: YARA规则由以下组件组成：
- en: '*Rule identifier:* This is a name that describes the rule (`suspicious_strings`
    in the preceding example). The rule identifiers can contain any alphanumeric character
    and the underscore character, but the first character cannot be a digit. The rule
    identifiers are case-sensitive and cannot exceed 128 characters.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规则标识符：* 这是描述规则的名称（在前面的示例中为`suspicious_strings`）。规则标识符可以包含任何字母数字字符和下划线字符，但第一个字符不能是数字。规则标识符是区分大小写的，且不能超过128个字符。'
- en: '*String Definition:* This is the section where the strings (text, hexadecimal,
    or regular expressions) that will be part of the rule are defined. This section
    can be omitted if the rule does not rely on any strings. Each string has an identifier
    consisting of a `$` character followed by a sequence of alphanumeric characters
    and underscores. From the preceding rule, think of `$a`, `$b`, and `$c` as variables
    containing values. These variables are then used in the condition section.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符串定义：* 这是定义将成为规则一部分的字符串（文本、十六进制或正则表达式）所在的部分。如果规则不依赖于任何字符串，可以省略此部分。每个字符串都有一个标识符，由一个`$`字符后跟一串字母数字字符和下划线组成。在前面的规则中，`$a`、`$b`和`$c`可以看作是包含值的变量。这些变量随后将在条件部分中使用。'
- en: '*Condition Section:* This is not an optional section, and this is where the
    logic of the rule resides. This section must contain a Boolean expression that
    specifies the condition under which the rule will match or not match.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件部分：* 这不是一个可选部分，逻辑部分就在这里。此部分必须包含一个布尔表达式，指定规则匹配或不匹配的条件。'
- en: 7.4.3 Running YARA
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4.3 运行YARA
- en: 'Once you have the rule ready, the next step is to use the yara utility to scan
    the files using the YARA rules. In the preceding example, the rule looked for
    three suspicious strings (defined in `$a`, `$b` and `$c`), and based on the condition,
    the rule matched if any of the three strings is present in a file. The rule was
    saved as `suspicious.yara`, and running the yara against a directory containing
    malware samples returned two malware samples matching the rule:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好规则，下一步是使用yara工具根据YARA规则扫描文件。在前面的示例中，规则查找了三个可疑字符串（分别定义在`$a`、`$b`和`$c`中），并且根据条件，如果文件中存在任何一个字符串，规则就会匹配。该规则保存为`suspicious.yara`，并且对包含恶意软件样本的目录运行yara时，返回了两个符合该规则的恶意软件样本：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding YARA rule, by default, will match on ASCII strings, and it performs
    the case-sensitive match. If you want the rule to detect both ASCII and Unicode
    (wide character) strings, then you specify the `ascii` and `wide` modifier next
    to string. The `nocase` modifier will perform a case-insensitive match (that is,
    it will match Synflooding, synflooding, sYnflooding, and so on). The modified
    rule to implement case-insensitive match and to look for ASCII and Unicode strings
    is shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，前面的YARA规则将匹配ASCII字符串，并执行区分大小写的匹配。如果你希望规则同时检测ASCII和Unicode（宽字符）字符串，那么可以在字符串旁边指定`ascii`和`wide`修饰符。`nocase`修饰符将执行不区分大小写的匹配（即，它会匹配Synflooding、synflooding、sYnflooding等）。修改后的规则以实现不区分大小写的匹配，并查找ASCII和Unicode字符串，如下所示：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the preceding rule detected the two executable files containing ASCII
    strings, and it also identified a document (`test.doc`) containing Unicode strings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述规则检测到包含ASCII字符串的两个可执行文件，它还识别了一个包含Unicode字符串的文档（`test.doc`）：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding rule matches any file containing those ASCII and Unicode strings.
    The document (`test.doc`) that it detected was a legitimate document that had
    those strings in its content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则匹配任何包含这些ASCII和Unicode字符串的文件。它检测到的文档（`test.doc`）是一个合法文档，且其内容包含了这些字符串。
- en: 'If your intention is to look for strings in an executable file, you can create
    a rule as shown below. In the following rule, the `$mz`* at* `0` in the condition
    specifies YARA to look for the signature `4D 5A` (first two bytes of PE file)
    at the beginning of the file; this ensures that the signature triggers only for
    PE executable files. Text strings are enclosed in double quotes, whereas hex strings
    are enclosed in curly braces as in the `$mz` variable:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在可执行文件中查找字符串，可以像下面这样创建规则。在以下规则中，条件中的`$mz`*在*`0`处指定YARA在文件开头查找签名`4D 5A`（PE文件的前两个字节）；这确保只有PE可执行文件会触发该签名。文本字符串用双引号括起来，而十六进制字符串则用大括号括起来，如`$mz`变量中的情况：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, running the preceding rule only detected the executable files:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行上述规则只检测到可执行文件：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 7.4.4 Applications of YARA
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4.4 YARA的应用
- en: 'Let''s take another example of the sample that was previously used in *Section
    6.5*, *Examining PE resources*. The sample (`5340.exe`) stored a decoy excel document
    in its resource section; some malware programs store a decoy document to present
    it to the user upon execution. The following YARA rule detects an executable file
    containing an embedded Microsoft Office document in it. The rule will trigger
    if the hex string is found at an offset greater than `1024` bytes in the file
    (this skips the PE header), and the `filesize` specifies the end of the file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，使用的是*第6.5节*中曾经使用过的样本，*检查PE资源*。该样本（`5340.exe`）将一个诱饵Excel文档存储在它的资源区段；一些恶意软件程序会存储诱饵文档，以便在执行时向用户展示。以下YARA规则检测包含嵌入的Microsoft
    Office文档的可执行文件。如果在文件中偏移量大于`1024`字节处找到十六进制字符串（跳过PE头），并且`filesize`指定文件末尾，则触发规则：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running the preceding yara rule detected only the sample that contained the
    embedded excel document:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述YARA规则只检测到包含嵌入Excel文档的样本：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following example detects a malware sample called *9002 RAT* using the
    serial number of its digital certificate. RAT 9002 used a digital certificate
    with a serial number `45 6E 96 7A 81 5A A5 CB B9 9F B8 6A CA 8F 7F 69` ([https://blog.cylance.com/another-9002-trojan-variant](https://blog.cylance.com/another-9002-trojan-variant)).
    The serial number can be used as a signature to detect samples that have the same
    digital certificate:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过数字证书的序列号来检测名为*9002 RAT*的恶意软件样本。RAT 9002使用了序列号为`45 6E 96 7A 81 5A A5 CB
    B9 9F B8 6A CA 8F 7F 69`的数字证书（[https://blog.cylance.com/another-9002-trojan-variant](https://blog.cylance.com/another-9002-trojan-variant)）。这个序列号可以作为签名，用来检测拥有相同数字证书的样本：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the rule detected all samples with the same digital certificate, and
    all of these samples turned out to be *RAT 9002* samples:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该规则检测到所有具有相同数字证书的样本，所有这些样本最终都被确定为*RAT 9002*样本：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'YARA rules can also be used to detect packers. In *Section 5*, *Determining
    file obfuscation*, we looked at how to detect packers using the *Exeinfo PE* tool.
    *Exeinfo PE* uses signatures stored in a plain text file called `userdb.txt`.
    The following is an example signature format used by *Exeinfo PE* to detect the *UPX*
    packer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: YARA规则也可以用来检测打包器。在*第5节*，*确定文件混淆*中，我们讨论了如何使用*Exeinfo PE*工具来检测打包器。*Exeinfo PE*使用存储在名为`userdb.txt`的纯文本文件中的签名。以下是*Exeinfo
    PE*用于检测*UPX*打包器的示例签名格式：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ep_only=true` in the preceding signature means that *Exeinfo PE* should
    only check for the signature at the program''s address of the entry point (which
    is where the code starts executing). The preceding signature can be converted
    to a YARA rule. The new versions of YARA support the *PE* module, which allows
    you to create rules for PE files by using attributes and features of the PE file
    format. If you are using newer versions of YARA, the Exeinfo PE signature can
    be translated to a YARA rule as shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述签名中的`ep_only=true`意味着*Exeinfo PE*只应在程序入口点的地址处检查签名（即代码开始执行的地方）。上述签名可以转换为YARA规则。YARA的新版本支持*PE*模块，它允许你使用PE文件格式的属性和特征来创建针对PE文件的规则。如果你使用的是YARA的新版本，Exeinfo
    PE签名可以转化为如下所示的YARA规则：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you are using older versions of YARA (which do not have support for the
    PE module), then use the following rule:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不支持 PE 模块的旧版本的 YARA，则使用以下规则：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, running a yara rule on the samples directory detected the samples that
    were packed with UPX:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在样本目录上运行一个 yara 规则，检测到使用 UPX 打包的样本：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using the preceding method, all the packer signatures in Exeinfo PE's `userdb.txt`
    can be converted to YARA rules.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，Exeinfo PE 的`userdb.txt`中的所有打包器签名都可以转换为 YARA 规则。
- en: '*PEiD* is another tool that detects packers (this tool is no longer supported);
    it stores the signature in a text file, `UserDB.txt`. Python scripts *peid_to_yara.py*
    written by Matthew Richard (part of Malware Analyst''s Cookbook) and Didier Steven''s
    peid*-*userdb*-to-yara-rules.py* ([https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py](https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py))
    convert `UserDB.txt` signatures to YARA rules.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEiD* 是另一个检测打包器的工具（此工具不再受支持）；它将签名存储在文本文件`UserDB.txt`中。由 Matthew Richard 编写的
    Python 脚本*peid_to_yara.py*（Malware Analyst''s Cookbook 的一部分）和 Didier Steven 的*peid-userdb-to-yara-rules.py*（[https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py](https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py)）将`UserDB.txt`签名转换为
    YARA 规则。'
- en: 'YARA can be used to detect patterns in any file. The following YARA rule detects
    communication of different variants of the *Gh0stRAT* malware:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: YARA 可用于检测任何文件中的模式。以下 YARA 规则可检测不同变种的*Gh0stRAT*恶意软件的通信：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the preceding rule on a directory containing network packet captures
    (pcaps), detecting the GhostRAT pattern in some of the pcaps as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含网络数据包捕获（pcaps）的目录上运行上述规则，检测到一些 pcaps 中的 GhostRAT 模式，如下所示：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After you analyze the malware, you can create signatures to identify its components;
    the following code shows an example YARA rule to detect the driver and the DLL
    components of *Darkmegi Rootkit*:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 分析恶意软件后，您可以创建签名以识别其组件；以下代码显示了一个检测*Darkmegi Rootkit*驱动程序和 DLL 组件的示例 YARA 规则：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding rule was created after analyzing a single sample of *Darkmegi*;
    however, running the preceding rule on a directory containing malware samples
    detected all the *Darkmegi* rootkit samples matching the pattern:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析单个*Darkmegi*样本后创建了上述规则；然而，在包含恶意软件样本的目录上运行上述规则，检测到所有与模式匹配的*Darkmegi* rootkit
    样本：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: YARA is a powerful tool; creating YARA rules to scan a repository of known samples
    can identify and classify samples having same characteristics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: YARA 是一个强大的工具；创建 YARA 规则以扫描已知样本库可以识别和分类具有相同特征的样本。
- en: The strings that you use in the rule might create false positives. It is a good
    idea to test your signatures against known good files and also to think of situations
    that might trigger false positives. To write sound YARA rules, read [https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/](https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/).
    For generating YARA rules, you might consider using Florian Roth's *yarGen* ([https://github.com/Neo23x0/yarGen](https://github.com/Neo23x0/yarGen))
    or Joe Security's YARA rule generator ([https://www.yara-generator.net/](https://www.yara-generator.net/)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则中使用的字符串可能会产生误报。测试您的签名与已知良好文件，并考虑可能触发误报的情况是个好主意。要编写健壮的 YARA 规则，请阅读[https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/](https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/)。要生成
    YARA 规则，您可以考虑使用 Florian Roth 的*yarGen*（[https://github.com/Neo23x0/yarGen](https://github.com/Neo23x0/yarGen)）或
    Joe Security 的 YARA 规则生成器（[https://www.yara-generator.net/](https://www.yara-generator.net/)）。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Static analysis is the first step in malware analysis; it allows you to extract
    valuable information from the binary and helps in comparing and classifying the
    malware samples. This chapter introduced you to various tools and techniques,
    using which different aspects of malware binary can be determined without executing
    it. In the next chapter, *Dynamic Analysis*, you will learn how to determine the
    behavior of malware by executing it within an isolated environment.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是恶意软件分析的第一步；它允许您从二进制文件中提取有价值的信息，并有助于比较和分类恶意软件样本。本章向您介绍了各种工具和技术，使用这些工具和技术可以确定恶意软件二进制的不同方面，而无需执行它。在下一章节*动态分析*中，您将学习如何通过在隔离环境中执行来确定恶意软件的行为。
