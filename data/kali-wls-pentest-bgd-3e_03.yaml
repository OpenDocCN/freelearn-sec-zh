- en: Chapter 3. Bypassing WLAN Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 绕过 WLAN 认证
- en: '|   | *"A false sense of security is worse than being unsure."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"虚假的安全感比不确定更糟糕。"* |   |'
- en: '|   | --*Anonymous* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*匿名* |'
- en: '*A false sense of security is worse than being insecure, as you may not be
    prepared to face the eventuality of being hacked.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚假的安全感比没有安全感更糟糕，因为你可能没有准备好面对被黑客攻击的结果。*'
- en: '*WLANs can have weak authentication schemas that can be easily broken and bypassed.
    In this chapter, we will take a look at the various basic authentication schemas
    used in WLANs and learn how to beat them.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*WLAN 可能具有脆弱的认证方案，容易被破解和绕过。在本章中，我们将研究 WLAN 中使用的各种基本认证方案，并学习如何击败它们。*'
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Uncovering hidden SSIDs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭露隐藏的 SSID
- en: Beating MAC filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击败 MAC 过滤器
- en: Bypassing Open Authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过开放认证
- en: Bypassing **Shared Key Authentication** (**SKA**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过 **共享密钥认证**（**SKA**）
- en: Hidden SSIDs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏 SSID
- en: In the default configuration mode, all access points send out their SSIDs in
    beacon frames. This allows clients in the vicinity to discover them easily. Hidden
    SSIDs is a configuration where the access point does not broadcast its SSID in
    beacon frames. Thus, only clients that know the SSID of the access point can connect
    to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置模式下，所有接入点都会在信标帧中广播其 SSID。这使得附近的客户端能够轻松发现它们。隐藏 SSID 是一种配置，其中接入点不在信标帧中广播其
    SSID。因此，只有知道接入点 SSID 的客户端才能连接到它。
- en: Unfortunately, this measure does not provide robust security, but most network
    administrators think it does. Hidden SSIDs should not be considered a security
    measure by any stretch of the imagination. We will now take a look at how to uncover
    hidden SSIDs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一措施并未提供强大的安全性，但大多数网络管理员认为它有效。隐藏 SSID 绝不应被视为一种安全措施。现在我们将探讨如何揭露隐藏的 SSID。
- en: Time for action – uncovering hidden SSIDs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动 – 揭露隐藏的 SSID
- en: 'Perform the following instructions to get started:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下指示操作，开始进行：
- en: Using Wireshark, if we monitor beacon frames in the Wireless Lab network, we
    are able to see the SSID in plain text. You should see beacon frames, as shown
    in the following screenshot:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Wireshark，如果我们监控无线实验室网络中的信标帧，我们能够看到 SSID 明文。你应该能看到信标帧，如下图所示：![开始行动 – 揭露隐藏的
    SSID](graphics/B09903_03_01.jpg)
- en: Configure your access point to set the `Wireless Lab` network as a hidden SSID.
    The configuration option to do this may differ across access points. In my case,
    I need to check the `Invisible` option in the **Visibility Status** option, as
    shown in the following screenshot:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_02.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的接入点，将 `Wireless Lab` 网络设置为隐藏 SSID。不同的接入点配置选项可能不同。在我的案例中，我需要在 **可见性状态** 选项中勾选
    `Invisible`，如下图所示：![开始行动 – 揭露隐藏的 SSID](graphics/B09903_03_02.jpg)
- en: Now if you take a look at the Wireshark trace, you will find that the SSID `Wireless
    Lab` has disappeared from the beacon frames. This is what hidden SSIDs are all
    about:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_03.jpg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你查看 Wireshark 跟踪，你会发现 SSID `Wireless Lab` 已经从信标帧中消失。这就是隐藏 SSID 的本质：![开始行动
    – 揭露隐藏的 SSID](graphics/B09903_03_03.jpg)
- en: In order to bypass beacon frames, we will first use the passive technique of
    waiting for a legitimate client to connect to the access point. This will generate
    probe request and probe response packets that will contain the SSID of the network,
    thus revealing its presence:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_04.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绕过信标帧，我们将首先使用被动技术，等待合法客户端连接到接入点。这将生成探测请求和探测响应数据包，其中包含网络的 SSID，从而揭示其存在：![开始行动
    – 揭露隐藏的 SSID](graphics/B09903_03_04.jpg)
- en: Alternatively, you can use the `aireplay-ng` utility to send deauthentication
    packets to all stations on behalf of the `Wireless Lab` access point by typing
    `aireplay-ng -0 5 -a <mac> --ignore-negative wlan0mon`, where `<mac>` is the MAC
    address of the router. The `-0` option is used to choose a deauthentication attack,
    and `5` is the number of deauthentication packets to send. Finally, `-a` specifies
    the MAC address of the access point you are targeting:![Time for action – uncovering
    hidden SSIDs](graphics/B09903_03_05.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`aireplay-ng`工具代表`Wireless Lab`接入点向所有站点发送去认证数据包，命令为`aireplay-ng -0
    5 -a <mac> --ignore-negative wlan0mon`，其中`<mac>`是路由器的MAC地址。`-0`选项用于选择去认证攻击，`5`是要发送的去认证数据包的数量。最后，`-a`指定你要攻击的接入点的MAC地址：![行动时刻
    – 揭开隐藏的SSID](graphics/B09903_03_05.jpg)
- en: The preceding deauthentication packets will force all legitimate clients to
    disconnect and reconnect. It would be a good idea to add a filter for deauthentication
    packets to view them in an isolated way, which we can do with `wlan.fc.type_subtype
    == 0x0c`:![Time for action – uncovering hidden SSIDs](graphics/B09903_03_06.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的去认证数据包将迫使所有合法客户端断开连接并重新连接。最好添加一个过滤器来以隔离的方式查看去认证数据包，方法是使用`wlan.fc.type_subtype
    == 0x0c`：![行动时刻 – 揭开隐藏的SSID](graphics/B09903_03_06.jpg)
- en: The probe responses from the access point will end up revealing its hidden SSID.
    These packets will show up on Wireshark as shown in the following screenshot.
    Once the legitimate clients connect back, we can see the hidden SSID using the
    probe request and probe response frames. You can use the filter `(wlan.bssid ==
    <the AP MAC>) && !(wlan.fc.type_subtype == 0x08)` to monitor all non-beacon packets
    to and fro from the access point. The `&&` sign stands for the logical AND operator
    and the `!` sign stands for the logical NOT operator:![Time for action – uncovering
    hidden SSIDs](graphics/B09903_03_07.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自接入点的探测响应最终会揭示其隐藏的SSID。这些数据包会显示在Wireshark中，如下截图所示。一旦合法客户端重新连接，我们可以通过探测请求和探测响应帧查看隐藏的SSID。你可以使用过滤器`(wlan.bssid
    == <the AP MAC>) && !(wlan.fc.type_subtype == 0x08)`来监视进出接入点的所有非信标数据包。`&&`表示逻辑与运算符，`!`表示逻辑非运算符：![行动时刻
    – 揭开隐藏的SSID](graphics/B09903_03_07.jpg)
- en: '*What just happened?*'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Even though the SSID is hidden and not broadcasted, whenever a legitimate client
    tries to connect to the access point, they exchange probe request and probe response
    packets. These packets contain the SSID of the access point. As these packets
    are not encrypted, they can be very easily sniffed from the air and the SSID can
    be found.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使SSID被隐藏且未广播，每当合法客户端尝试连接到接入点时，它们会交换探测请求和探测响应数据包。这些数据包包含接入点的SSID。由于这些数据包没有加密，因此可以非常轻松地从空气中嗅探到，SSID也就暴露出来。
- en: We will cover using probe requests for other purposes such as tracking in a
    later chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中讲解使用探测请求进行其他目的，如跟踪。
- en: In many cases, all clients may be already connected to the access point and
    there may be no probe request/response packets available in the Wireshark trace.
    Here, we can forcibly disconnect the clients from the access point by sending
    forged deauthentication packets on the air. These packets will force the clients
    to reconnect back to the access point, thus revealing the SSID.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，所有客户端可能已经连接到接入点，Wireshark跟踪中可能没有探测请求/响应数据包。此时，我们可以通过在空中发送伪造的去认证数据包，强制客户端从接入点断开连接。这些数据包将迫使客户端重新连接接入点，从而揭示SSID。
- en: Have a go hero – selecting deauthentication
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动起来，英雄 – 选择去认证
- en: In the previous exercise, we sent broadcast deauthentication packets to force
    reconnection of all wireless clients. Try to verify how you can selectively target
    individual clients using the `aireplay-ng` utility.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们发送了广播去认证数据包以迫使所有无线客户端重新连接。试着验证如何使用`aireplay-ng`工具有选择地针对单个客户端。
- en: It is important to note that, even though we are illustrating many of these
    concepts using Wireshark, it is possible to orchestrate these attacks with other
    tools, such as the `aircrack-ng` suite as well. We encourage you to explore the
    entire `aircrack-ng` suite of tools and other documentation located on their website
    at [http://www.aircrack-ng.org](http://www.aircrack-ng.org).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管我们使用Wireshark说明了许多概念，但也可以使用其他工具来进行这些攻击，比如`aircrack-ng`套件。我们鼓励你探索整个`aircrack-ng`工具集，并查阅其官网上的其他文档：[http://www.aircrack-ng.org](http://www.aircrack-ng.org)。
- en: MAC filters
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC过滤器
- en: MAC filters are an age-old technique used for authentication and authorization
    and have their roots in the wired world. Unfortunately, they fail miserably in
    the wireless world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: MAC过滤器是一种古老的身份验证和授权技术，其根源在有线网络中。不幸的是，它们在无线环境中效果极差。
- en: The basic idea is to authenticate based on the MAC address of the client. The
    MAC filter is an identification code assigned to a network interface; a router
    will be able to check this code and compare it to a list of approved MACs. This
    list of allowed MAC addresses will be maintained by the network administrator
    and will be fed into the access point. We will now take a look at how easy it
    is to bypass MAC filters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路是基于客户端的MAC地址进行身份验证。MAC过滤器是分配给网络接口的身份识别码；路由器能够检查这个代码，并将其与批准的MAC地址列表进行比较。允许的MAC地址列表将由网络管理员维护，并输入到接入点。接下来我们将看看绕过MAC过滤有多么容易。
- en: Time for action – beating MAC filters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时刻——突破MAC过滤
- en: 'Let''s follow the instructions to get started:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的说明开始操作：
- en: Let's first configure our access point to use MAC filtering and then add the
    client MAC address of the victim laptop. The settings pages on my router looks
    as follows:![Time for action – beating MAC filters](graphics/B09903_03_08.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们配置接入点使用MAC过滤，并将受害者笔记本的客户端MAC地址添加到白名单中。我路由器的设置页面如下所示：![Time for action –
    beating MAC filters](graphics/B09903_03_08.jpg)
- en: Once MAC filtering is enabled, only the allowed MAC address will be able to
    successfully authenticate with the access point. If we try to connect to the access
    point from a machine with a non-whitelisted MAC address, the connection will fail.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启用MAC过滤，只有允许的MAC地址才能成功通过接入点的身份验证。如果我们尝试从具有非白名单MAC地址的机器连接接入点，连接将会失败。
- en: Behind the scenes, the access point is sending authentication failure messages
    to the client. The packet trace resembles the following:![Time for action – beating
    MAC filters](graphics/B09903_03_09.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台，接入点正在向客户端发送认证失败消息。数据包跟踪如下所示：![Time for action – beating MAC filters](graphics/B09903_03_09.jpg)
- en: In order to beat MAC filters, we can use `airodump-ng` to find the MAC addresses
    of clients connected to the access point. We can do this by issuing the `airodump-ng
    -c 10 -a --bssid <mac> wlan0mon` command. By specifying the `bssid` command, we
    will only monitor the access point, which is of interest to us. The `-c 10` command
    sets the channel to `10`, where the access point is. The `-a` command ensures
    that, in the client section of the `airodump-ng` output, only clients associated
    and connected to an access point are shown. This will show us all the client MAC
    addresses associated with the access point:![Time for action – beating MAC filters](graphics/B09903_03_10.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绕过MAC过滤器，我们可以使用`airodump-ng`来查找连接到接入点的客户端的MAC地址。我们可以通过执行`airodump-ng -c 10
    -a --bssid <mac> wlan0mon`命令来实现。通过指定`bssid`命令，我们将只监控感兴趣的接入点。`-c 10`命令设置频道为`10`，即接入点所在的频道。`-a`命令确保在`airodump-ng`输出的客户端部分中，仅显示已关联并连接到接入点的客户端。这将展示与接入点关联的所有客户端MAC地址：![Time
    for action – beating MAC filters](graphics/B09903_03_10.jpg)
- en: Once we find a whitelisted client's MAC address, we can spoof the MAC address
    of the client using the `macchanger` utility, which ships with Kali. You can use
    the `macchanger –m <mac> wlan0mon` command to get this done. The MAC address you
    specify with the `-m` command option is the new spoofed MAC address for the `wlan0mon`
    interface:![Time for action – beating MAC filters](graphics/B09903_03_11.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们找到了白名单客户端的MAC地址，就可以使用Kali自带的`macchanger`工具伪造该客户端的MAC地址。你可以使用`macchanger
    –m <mac> wlan0mon`命令来完成此操作。你在`-m`命令选项中指定的MAC地址将是`wlan0mon`接口的新伪造MAC地址：![Time for
    action – beating MAC filters](graphics/B09903_03_11.jpg)
- en: As you can clearly see, we are now able to connect to the access point after
    spoofing the MAC address of a whitelisted client.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们现在能够通过伪造一个白名单客户端的MAC地址来连接到接入点。
- en: '*What just happened?*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We monitored the air using `airodump-ng` and found the MAC address of legitimate
    clients connected to the wireless network. We then used the `macchanger` utility
    to change our wireless card's MAC address to match the client's. This fooled the
    access point into believing that we were the legitimate client, and it allowed
    us access to its wireless network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`airodump-ng`监控无线信号，找到了连接到无线网络的合法客户端的MAC地址。然后，我们使用`macchanger`工具将无线网卡的MAC地址更改为与客户端相匹配的地址。这样接入点误以为我们是合法客户端，允许我们访问其无线网络。
- en: You are encouraged to explore the different options of the `airodump-ng` utility
    by going through the documentation on their website at [http://www.aircrack-ng.org/doku.php?id=airodump-ng](http://www.aircrack-ng.org/doku.php?id=airodump-ng).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您被鼓励通过查阅它们网站上的文档来探索`airodump-ng`工具的不同选项：[http://www.aircrack-ng.org/doku.php?id=airodump-ng](http://www.aircrack-ng.org/doku.php?id=airodump-ng)。
- en: Open Authentication
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放认证
- en: The term Open Authentication is almost a misnomer, as it actually provides no
    authentication at all. When an access point is configured to use Open Authentication,
    it will successfully authenticate all clients that connect to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 开放认证这一术语几乎是一个误称，因为它实际上根本不提供认证。当接入点配置为使用开放认证时，它将成功地认证所有连接到它的客户端。
- en: We will now do an exercise to authenticate and connect to an access point using
    Open Authentication.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进行一个练习，以通过开放认证对接入点进行身份验证和连接。
- en: Time for action – bypassing Open Authentication
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 绕过开放认证
- en: 'Let''s now take a look at how to bypass Open Authentication:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何绕过开放认证：
- en: We will first set our lab access point Wireless Lab to use Open Authentication.
    On my access point, this is simply done by setting **Security Mode** to **Disable
    Security**:![Time for action – bypassing Open Authentication](graphics/B09903_03_12.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先设置我们的实验室接入点Wireless Lab以使用开放认证。在我的接入点上，这只需通过将**安全模式**设置为**禁用安全**来完成：![操作时间
    - 绕过开放认证](graphics/B09903_03_12.jpg)
- en: We then connect to this access point using the `iwconfig wlan0 essid Wireless
    Lab` command and verify that the connection has succeeded and that we are connected
    to the access point.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`iwconfig wlan0 essid Wireless Lab`命令连接到此接入点，并验证连接是否成功以及我们是否已连接到接入点。
- en: Note that we did not have to supply any username/password/passphrase to get
    through Open Authentication.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们无需提供任何用户名/密码/口令即可通过开放认证。
- en: '*What just happened?*'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This is probably the simplest exercise so far. As you saw, there is no barrier
    to connecting to an Open Authentication network and connecting to the access point.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能是最简单的练习了。正如您所见，连接到开放认证网络并连接到接入点没有障碍。
- en: Shared Key Authentication
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享密钥认证
- en: 'SKA uses a shared secret such as the WEP key to authenticate the client. The
    exact exchange of information is illustrated in the following screenshot (taken
    from [www.netgear.com](http://www.netgear.com)):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SKA使用共享密钥，如WEP密钥，用于对客户端进行身份验证。以下截图显示了信息的确切交换过程（来自[www.netgear.com](http://www.netgear.com)）：
- en: '![Shared Key Authentication](graphics/B09903_03_13.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![共享密钥认证](graphics/B09903_03_13.jpg)'
- en: The wireless client sends an authentication request to the access point, which
    responds back with a challenge. The client now needs to encrypt this challenge
    with the shared key and send it back to the access point, which decrypts this
    to check whether it can recover the original challenge text. If it succeeds, the
    client successfully authenticates; if not, it sends an authentication failed message.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 无线客户端向接入点发送认证请求，接入点响应挑战。现在客户端需要用共享密钥加密此挑战并将其发送回接入点，接入点解密以检查是否可以恢复原始挑战文本。如果成功，客户端成功认证；否则，发送认证失败消息。
- en: The security problem here is that an attacker passively listening to this entire
    communication by sniffing the air has access to both the plain text challenge
    and the encrypted challenge. He can apply the XOR operation to retrieve the keystream.
    This keystream can be used to encrypt any future challenge sent by the access
    point without needing to know the actual key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的安全问题在于，通过侦听空中的整个通信，攻击者可以访问明文挑战和加密挑战。他可以应用XOR操作来检索密钥流。此密钥流可用于加密接入点发送的任何未来挑战，而无需知道实际密钥。
- en: The most common form of shared authentication is known as **Wired Equivalent
    Privacy** (**WEP**). It is easy to break, and numerous tools have been created
    over time to facilitate the cracking of WEP networks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的共享认证形式被称为**有线等效隐私**（**WEP**）。它很容易被破解，随着时间的推移，已经开发出了许多工具来帮助破解WEP网络。
- en: In this exercise, we will learn how to sniff the air to retrieve the challenge
    and the encrypted challenge, retrieve the keystream, and use it to authenticate
    to the access point without needing the shared key.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何侦听空中以检索挑战和加密挑战，检索密钥流，并使用它来认证到接入点，而无需共享密钥。
- en: Time for action – bypassing shared authentication
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 绕过共享认证
- en: 'Bypassing shared authentication is a bit more challenging than the previous
    exercises, so follow the steps carefully:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过共享认证比以前的练习更具挑战性，因此请仔细跟随以下步骤：
- en: Let's first set up shared authentication for our Wireless Lab network. I have
    done this on my access point by setting the security mode as **WEP** and **Authentication**
    as **Shared Key**:![Time for action – bypassing shared authentication](graphics/B09903_03_14.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先为我们的无线实验室网络设置共享认证。我已经在我的访问点上通过将安全模式设置为**WEP**和**认证**设置为**共享密钥**来完成此操作：![操作时间——绕过共享认证](graphics/B09903_03_14.jpg)
- en: Let's now connect a legitimate client to this network using the shared key we
    have set in step 1.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用我们在步骤1中设置的共享密钥将合法客户端连接到该网络。
- en: In order to bypass SKA, we will first start sniffing packets between the access
    point and its clients. However, we would also like to log the entire shared authentication
    exchange. To do this, we use the `airodump-ng` utility using the `airodump-ng
    wlan0mon -c 11 --bssid <mac> -w keystream` command. The `-w` option, which is
    new here, requests `airodump-ng` to store the packets in a file whose name is
    prefixed with the word `keystream`. Incidentally, it might be a good idea to store
    different sessions of packet captures in different files. This allows you to analyze
    them long after the trace has been collected:![Time for action – bypassing shared
    authentication](graphics/B09903_03_15.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绕过SKA，我们首先开始嗅探访问点和其客户端之间的数据包。然而，我们也希望记录整个共享认证交换过程。为了做到这一点，我们使用`airodump-ng`实用程序，并使用命令`airodump-ng
    wlan0mon -c 11 --bssid <mac> -w keystream`。这里的`-w`选项是新加入的，请求`airodump-ng`将数据包存储在以单词`keystream`为前缀的文件中。顺便说一句，将不同会话的数据包捕获到不同的文件中可能是个好主意，这样您可以在收集跟踪数据之后长时间分析它们：![操作时间——绕过共享认证](graphics/B09903_03_15.jpg)
- en: We can either wait for a legitimate client to connect to the access point or
    force a reconnect using the deauthentication technique used previously. Once a
    client connects and the SKA succeeds, `airodump-ng` will capture this exchange
    automatically by sniffing the air. An indication that the capture has succeeded
    is when the `AUTH` column reads WEP.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以等待合法客户端连接到访问点，或者使用之前使用的去认证技术强制重新连接。一旦客户端连接并SKA成功，`airodump-ng`将通过嗅探到的空中捕获此交换。捕获成功的指示是`AUTH`列显示WEP。
- en: The captured keystream is stored in a file prefixed with the word `keystream`
    in the current directory. In my case, the name of the file is `keystream-01-00-21-91-D2-8E-25.xor`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获的密钥流存储在当前目录中以单词`keystream`为前缀的文件中。在我的情况下，文件名为`keystream-01-00-21-91-D2-8E-25.xor`。
- en: If this doesn't work, you can use `aireplay-ng -4 -h <Connected Device MAC>
    -a <AP BSSID> wlan0mon` to generate an `.xor` file. This requires a connected
    device to be on the target WEP protected network and will generate packets spoofing
    their MAC address to identify the XOR stream and key.![Time for action – bypassing
    shared authentication](graphics/B09903_03_16.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个方法不起作用，您可以使用`aireplay-ng -4 -h <Connected Device MAC> -a <AP BSSID> wlan0mon`生成一个`.xor`文件。这需要一个连接设备连接到目标WEP保护网络，并生成伪造其MAC地址的数据包来识别XOR流和密钥。![操作时间——绕过共享认证](graphics/B09903_03_16.jpg)
- en: In order to fake a SKA, we will use the `aireplay-ng` tool. We run the `aireplay-ng
    -1 0 -e "Wireless Lab" -y keystream-01-00-21-91-D2-8E-25.xor -a <mac> -h AA:AA:AA:AA:AA:AA
    wlan0mon` command. This `aireplay-ng` command uses the keystream we just retrieved
    and tries to authenticate with the access point with the SSID, `Wireless Lab`
    and the MAC address, `00:21:91:D2:8E:25`, and uses an arbitrary client MAC address,
    `AA:AA:AA:AA:AA:AA.`
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了伪造SKA，我们将使用`aireplay-ng`工具。我们运行`aireplay-ng -1 0 -e "无线实验室" -y keystream-01-00-21-91-D2-8E-25.xor
    -a <mac> -h AA:AA:AA:AA:AA:AA wlan0mon`命令。这个`aireplay-ng`命令使用我们刚刚检索到的密钥流，并尝试使用SSID为`无线实验室`、MAC地址为`00:21:91:D2:8E:25`的访问点进行身份验证，并使用任意客户端MAC地址`AA:AA:AA:AA:AA:AA`。
- en: Fire up Wireshark and sniff all packets of interest by applying a `wlan.addr
    == AA:AA:AA:AA:AA:AA` filter. We can verify this using Wireshark. You should see
    a trace on the Wireshark screen, as shown in the following screenshot:![Time for
    action – bypassing shared authentication](graphics/B09903_03_17.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Wireshark并通过应用`wlan.addr == AA:AA:AA:AA:AA:AA`过滤器嗅探所有感兴趣的数据包。我们可以使用Wireshark进行验证。您应该在Wireshark屏幕上看到一个跟踪，如下图所示：![操作时间——绕过共享认证](graphics/B09903_03_17.jpg)
- en: The first packet is the authentication request sent by the `aireplay-ng` tool
    to the access point:![Time for action – bypassing shared authentication](graphics/B09903_03_18.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个数据包是`aireplay-ng`工具发送给接入点的认证请求：![行动时间 – 绕过共享认证](graphics/B09903_03_18.jpg)
- en: The second packet consists of the access point sending the client challenge
    text, as shown in the following screenshot:![Time for action – bypassing shared
    authentication](graphics/B09903_03_19.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个数据包包含接入点发送给客户端的挑战文本，如下图所示：![行动时间 – 绕过共享认证](graphics/B09903_03_19.jpg)
- en: In the third packet, the tool sends the encrypted challenge to the access point:![Time
    for action – bypassing shared authentication](graphics/B09903_03_20.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三个数据包中，工具将加密的挑战发送到接入点：![行动时间 – 绕过共享认证](graphics/B09903_03_20.jpg)
- en: As the `aireplay-ng` tool used the derived keystream for encryption, the authentication
    succeeds and the access point sends a success message in the fourth packet:![Time
    for action – bypassing shared authentication](graphics/B09903_03_21.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`aireplay-ng`工具使用推导出的密钥流进行加密，认证成功，接入点在第四个数据包中发送了成功消息：![行动时间 – 绕过共享认证](graphics/B09903_03_21.jpg)
- en: After the authentication succeeds, the tool fakes an association with the access
    point, which succeeds as well. If you check the wireless logs in your access point's
    administrative interface, you should now see a wireless client with the MAC address,
    `AA:AA:AA:AA:AA:AA` connected:![Time for action – bypassing shared authentication](graphics/B09903_03_22.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证成功后，工具伪造了与接入点的关联，且成功连接。如果你检查接入点管理界面的无线日志，你应该能看到一个无线客户端，其MAC地址为`AA:AA:AA:AA:AA:AA`连接：![行动时间
    – 绕过共享认证](graphics/B09903_03_22.jpg)
- en: '*What just happened?*'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We were successful in deriving the keystream from a shared authentication exchange,
    and we used it to fake an authentication to the access point.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地从共享认证交换中推导出了密钥流，并使用它伪造了对接入点的认证。
- en: Have a go hero – filling up the access point's tables
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手吧英雄 – 填充接入点的表格
- en: Access points have a maximum client count after which they start refusing connections.
    By writing a simple wrapper over `aireplay-ng`, it is possible to automate and
    send hundreds of connection requests from random MAC addresses to the access point.
    This will end up filling the internal tables and once the maximum client count
    is reached, the access point will stop accepting new connections. This is typically
    what is called a **Denial of Service** (**DoS**) attack and can force the router
    to reboot or make it dysfunctional. This can lead to all the wireless clients
    being disconnected and being unable to use the authorized network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接入点在达到最大客户端数后会开始拒绝连接。通过在`aireplay-ng`上写一个简单的包装程序，可以自动化并发送数百个来自随机MAC地址的连接请求到接入点。这将填充内部表格，一旦达到最大客户端数，接入点将停止接受新连接。这通常被称为**拒绝服务**（**DoS**）攻击，并可能迫使路由器重启或使其无法正常工作。这可能导致所有无线客户端断开连接并无法使用授权网络。
- en: Check whether you can verify this in your lab!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否可以在实验室中验证这一点！
- en: Pop quiz – WLAN authentication
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测试 – WLAN认证
- en: Q1\. How can you force a wireless client to reconnect to the access point?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 如何强制无线客户端重新连接到接入点？
- en: By sending a deauthentication packet
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过发送去认证数据包
- en: By rebooting the client
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重启客户端
- en: By rebooting the access point
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重启接入点
- en: All of the above
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述情况
- en: Q2\. What does Open Authentication do?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 开放认证做了什么？
- en: It provides decent security
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了不错的安全性
- en: It provides no security
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不提供任何安全性
- en: It requires the use of encryption
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要使用加密
- en: None of the above
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述都不是
- en: Q3\. How does breaking SKA work?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 破解SKA是如何工作的？
- en: By deriving the keystream from the packets
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从数据包中推导密钥流
- en: By deriving the encryption key
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过推导加密密钥
- en: By sending deauthentication packets to the access point
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向接入点发送去认证数据包
- en: By rebooting the access point
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重启接入点
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learnt about WLAN authentication. Hidden SSIDs are a security-through-obscurity
    feature and are relatively simple to beat. MAC address filters do not provide
    any security, as MAC addresses can be sniffed from the air from the wireless packets.
    This is possible because the MAC addresses are unencrypted in the packet. Open
    Authentication provides no real authentication at all. SKA is a bit tricky to
    beat but, with the help of the right tools, we can derive the store and the keystream,
    using which it is possible to answer all future challenges sent by the access
    point. The result is that we can authenticate without needing to know the actual
    key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了WLAN认证。隐藏SSID是一种安全隐蔽特性，相对容易被突破。MAC地址过滤并不提供任何安全性，因为MAC地址可以通过无线数据包从空中嗅探到。这是可能的，因为MAC地址在数据包中是未加密的。开放认证根本不提供任何真实的认证。SKA虽然有点难以突破，但借助合适的工具，我们可以推导出存储和密钥流，从而能够回应接入点发送的所有未来挑战。结果是，我们可以在不需要知道实际密钥的情况下完成认证。
- en: In the next chapter, we will take a look at different WLAN encryption mechanisms—WEP,
    WPA, and WPA2—and look at the insecurities that plague them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看不同的WLAN加密机制——WEP、WPA和WPA2，并探讨它们存在的安全漏洞。
