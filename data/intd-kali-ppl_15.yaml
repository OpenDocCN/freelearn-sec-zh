- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Autopilot, Python, and NIST Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autopilot、Python 和 NIST 控制
- en: After a thorough examination of the Blue Team side of the Kali Purple family,
    we grabbed a taste of some of the Red Team aspects in the previous chapter. The
    reason these are put together in the Purple distribution is because the offensive
    tools are used to test the defensive tools and provide quality training as well
    as proof of concept to cybersecurity analysts through penetration testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入审视 Kali Purple 家族中的蓝队部分之后，我们在上一章中体验了一些红队方面的内容。这些功能被整合在紫队版本中的原因是，进攻工具用于测试防御工具，并通过渗透测试向网络安全分析师提供高质量的培训以及概念验证。
- en: In this chapter, we are going to look at the automation aspect of these penetration
    testing utilities through a Kali Linux-provided tool called **Autopilot**. Just
    as the name suggests, Autopilot is used to automate attacks, which helps to improve
    the efficiency of penetration testing teams. Through Autopilot, you gain some
    subtle references to scripting languages – in particular, Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过 Kali Linux 提供的工具 **Autopilot** 来了解这些渗透测试工具的自动化方面。正如其名所示，Autopilot
    用于自动化攻击，从而提高渗透测试团队的效率。通过 Autopilot，你将对脚本语言有一些微妙的了解——特别是 Python。
- en: We are going to take a peek at the Python scripting language, but not in the
    manner you might think. This isn’t a learn-to-code training manual and we’re not
    here to teach you that. However, if it is something of interest to you, we will
    provide links to an abundance of references. What we are going to do is look at
    the key components of what you might see within a block of Python code. We’re
    going to teach you how to recognize what is going on within the code. This will
    help you to understand what any piece of software, both good and bad, might be
    attempting to do and if it’s a case of software that you have the ability to edit,
    then you may even have enough knowledge to change certain items for the sake of
    testing and manipulating the code to your liking.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍 Python 脚本语言，但并非以你想象的方式进行。这不是一本学习编程的培训手册，我们并不打算教授你如何编码。然而，如果你对此感兴趣，我们会提供大量参考资料链接。我们将重点讲解你可能在一段
    Python 代码中看到的关键组成部分。我们要教你如何识别代码的内容。这将帮助你理解任何软件（无论是好的还是坏的）试图做什么。如果是你有能力编辑的软件，凭借这些知识，你甚至可以更改某些部分，以便测试和调整代码，按照自己的喜好进行修改。
- en: After that, we will take a look at the freshly updated **NIST Cybersecurity
    Framework** (**CSF**), which released version 2.0 in February of 2024, adding
    a new core function – *Govern* – directed at high-level cybersecurity managers
    that helps to regulate the other five core functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将回顾刚刚更新的 **NIST 网络安全框架**（**CSF**），该框架于 2024 年 2 月发布了 2.0 版本，增加了一个新的核心功能——*Govern*，专为高层网络安全管理人员设计，帮助监管其他五个核心功能。
- en: 'In this chapter, you can expect to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习到以下内容：
- en: Kali Autopilot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Autopilot
- en: Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: NIST Control
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NIST 控制
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: '**Minimum requirements**: A computing device with either the *amd64 (x86_64/64-bit)*
    or *i386 (x86/32-bit)* architecture. It should contain at least *4 GB* of RAM.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最低要求**：一台具备 *amd64 (x86_64/64-bit)* 或 *i386 (x86/32-bit)* 架构的计算设备，至少配备 *4
    GB* 内存。'
- en: '**Recommended requirements**: Based on feedback from cybersecurity field practitioners,
    aim for the *amd64 (x86_64/64-bit)* architecture with *8 GB* of RAM.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推荐要求**：根据网络安全领域从业者的反馈，建议使用 *amd64 (x86_64/64-bit)* 架构，并配备 *8 GB* 内存。'
- en: Autopilot
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autopilot
- en: '**Kali Autopilot** is a cybersecurity framework and application created with
    Red and Purple team exercises in mind. It is aimed at enhancing offensive and
    defensive security operations in unison. Autopilot focuses on automation and streamlining
    various tasks within cybersecurity operations for the purpose of improving both
    the efficiency and effectiveness of the exercises.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kali Autopilot** 是一个网络安全框架和应用程序，专为红队和紫队演练而设计。其目标是提升进攻和防守安全操作的协同效能。Autopilot
    专注于自动化和简化网络安全操作中的各项任务，旨在提高演练的效率和有效性。'
- en: 'Key features of Kali Autopilot include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Autopilot 的主要功能包括以下几点：
- en: '**Automation capabilities**: Kali Autopilot offers robust automation capabilities
    for executing predefined attack scenarios, security assessments, penetration testing
    tasks, and defensive measures in red team and purple team exercises. This automation
    streamlines complex processes and saves time for cybersecurity professionals.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化功能**：Kali Autopilot 提供强大的自动化功能，用于执行预定义的攻击场景、安全评估、渗透测试任务和防御措施，在红队和紫队演习中尤为有效。此自动化简化了复杂的流程，为网络安全专业人员节省了时间。'
- en: '**Scenario creation and execution**: The framework allows users to create and
    execute customized attack scenarios, simulation exercises, and cybersecurity assessments
    to test and improve the organization’s security posture. This includes emulating
    real-world threats and tactics to identify vulnerabilities and weaknesses.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景创建与执行**：该框架允许用户创建和执行定制的攻击场景、模拟演习和网络安全评估，测试并改善组织的安全防护。这包括模拟现实世界的威胁和战术，以识别漏洞和弱点。'
- en: '**Red team operations**: Kali Autopilot facilitates red team operations by
    providing tools and functionalities for reconnaissance, exploitation, privilege
    escalation, lateral movement, and post-exploitation activities. It enables red
    teams to simulate sophisticated cyber-attacks and assess the effectiveness of
    defensive measures.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红队操作**：Kali Autopilot 通过提供侦察、利用、权限提升、横向移动和后期利用活动的工具和功能，促进红队操作。它使红队能够模拟复杂的网络攻击，并评估防御措施的有效性。'
- en: '**Purple team collaboration**: The framework supports purple teaming initiatives
    by fostering collaboration between red and blue teams. Kali Autopilot enables
    joint exercises where offensive and defensive security teams work together to
    simulate attacks, detect threats, respond to incidents, and enhance overall security
    resilience.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紫队协作**：该框架通过促进红队和蓝队之间的协作，支持紫队行动。Kali Autopilot 使得进攻性和防御性安全团队可以共同进行演习，模拟攻击、检测威胁、应对事件，并增强整体的安全韧性。'
- en: '**Reporting and documentation**: Kali Autopilot includes features for generating
    detailed reports, documenting findings, and tracking the progress of red team
    and purple team activities. These reports can be utilized for compliance purposes,
    risk assessment, incident response planning, and security improvement initiatives.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告与文档**：Kali Autopilot 包含生成详细报告、记录发现和跟踪红队与紫队活动进展的功能。这些报告可以用于合规性检查、风险评估、事件响应规划以及安全改进措施。'
- en: '**Tool integration**: The framework integrates a wide range of security tools,
    scripts, and frameworks commonly used in red team and purple team engagements.
    This seamless integration enhances the toolkit available to cybersecurity professionals
    and ensures comprehensive coverage of security assessment tasks.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具集成**：该框架集成了广泛的安全工具、脚本和框架，这些工具和框架通常用于红队和紫队任务中。无缝集成增强了网络安全专业人员可用的工具包，并确保了安全评估任务的全面覆盖。'
- en: '**Customization and flexibility**: Users can customize and fine-tune the behavior,
    parameters, and configuration settings of Kali Autopilot to align with specific
    red teaming and purple teaming objectives. This flexibility allows for tailored
    approaches to cybersecurity assessments and exercises.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制化与灵活性**：用户可以定制和微调 Kali Autopilot 的行为、参数和配置设置，以使其符合特定的红队和紫队目标。这种灵活性使得网络安全评估和演习可以采取量身定制的方法。'
- en: '**Training and skill development**: Kali Autopilot serves as a valuable platform
    for cybersecurity professionals to enhance their skills, knowledge, and expertise
    in offensive and defensive security practices. It offers hands-on experience in
    simulated environments to improve proficiency in handling cyber threats and vulnerabilities.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**培训与技能发展**：Kali Autopilot 是一个宝贵的平台，供网络安全专业人员提升其进攻性和防御性安全实践的技能、知识和专长。它提供模拟环境中的实操经验，帮助提高处理网络威胁和漏洞的能力。'
- en: '**Scalability and enterprise deployment**: The framework is designed to be
    scalable and adaptable to different organizational sizes, security environments,
    and operational requirements. Kali Autopilot supports enterprise-level deployment
    for managing and coordinating red teaming and purple teaming activities at scale.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性与企业部署**：该框架设计上具备可扩展性，可以适应不同组织规模、安全环境和操作需求。Kali Autopilot 支持企业级部署，用于大规模管理和协调红队和紫队活动。'
- en: '**Community support and updates**: Kali Autopilot benefits from a vibrant community
    of cybersecurity professionals, red teamers, and purple teamers who contribute
    to its development, enhancement, and support. Users can leverage community-driven
    resources, updates, and collaboration opportunities to maximize the framework’s
    effectiveness.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区支持与更新**：Kali Autopilot受益于一个充满活力的网络安全专业人士、红队成员和紫队成员社区，他们为其开发、改进和支持做出了贡献。用户可以利用社区驱动的资源、更新和合作机会，最大化该框架的有效性。'
- en: There is no additional downloading, installing, or activating for Kali Autopilot.
    If you installed Kali Purple, it should be already set up and raring to go!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Autopilot无需额外的下载、安装或激活。如果你已经安装了Kali Purple，它应该已经设置好并准备就绪！
- en: 'To launch Kali Autopilot, take these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Kali Autopilot，请按照以下步骤操作：
- en: Launch and log in to your Kali Purple VM instance
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动并登录到你的Kali Purple虚拟机实例
- en: Select the Kali Linux dragon icon at the top left of your screen, under the
    word **File**
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择屏幕左上角的Kali Linux龙图标，位于**文件**字样下方
- en: Move your cursor down the left column and hover over **08 -** **Exploitation
    Tools**
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移动到左侧栏，悬停在**08 -** **利用工具**上
- en: 'Select **Kali Autopilot** from the second column that appears, as seen in *Figure
    11**.1*:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第二列中选择**Kali Autopilot**，如*图 11.1*所示：
- en: '![Figure 11.1 – Launch Kali Autopilot from the menu](image/B21223_11_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 从菜单启动Kali Autopilot](image/B21223_11_01.jpg)'
- en: Figure 11.1 – Launch Kali Autopilot from the menu
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 从菜单启动Kali Autopilot
- en: Alternatively, if for some odd reason Kali Autopilot is not already installed
    in your Kali Purple instance – that really, truly should not be the case – then
    you can open a terminal window and type **sudo apt install kali-autopilot**, making
    sure you include the dash.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种奇怪的原因Kali Autopilot未在你的Kali Purple实例中安装——这真的不应该发生——那么你可以打开终端窗口，输入**sudo
    apt install kali-autopilot**，确保包括连字符。
- en: 'Once you complete the preceding steps, the **Kali Autopilot - Automated Attack
    Generator** will load, showing two rows of content. The first row will have three
    columns. The left column will be a windowpane to manage your attack scripts, to
    include options to add, delete, import, export, or save them. The middle column
    will be a windowpane you will use to manage your variables for the selected script.
    The right windowpane will be networking and communication settings for the product
    to do its job. The second row has only one column, spanning the distance. It contains
    the attack sequence:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述步骤后，**Kali Autopilot - 自动化攻击生成器**将加载，并显示两行内容。第一行将包含三列。左侧的列是用于管理攻击脚本的窗格，包括添加、删除、导入、导出或保存脚本的选项。中间的列是用于管理所选脚本变量的窗格。右侧的窗格是产品执行任务所需的网络和通信设置。第二行只有一列，跨越整个宽度，包含攻击序列：
- en: '![Figure 11.2 – Kali Autopilot default GUI](image/B21223_11_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Kali Autopilot默认图形界面](image/B21223_11_02.jpg)'
- en: Figure 11.2 – Kali Autopilot default GUI
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Kali Autopilot默认图形界面
- en: Now that you’ve learned how to launch it the hard way, we should tell you that
    you can also open the command terminal and simply type **kali-autopilot** to load
    the Autopilot GUI. Let’s go ahead and create our very first automated attack script
    using Autopilot. If you’ve never written code or created a script before, fear
    not! Autopilot does most of the hard work for you. We will guide you through it
    all.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何通过繁琐的方式启动它，我们还要告诉你，你也可以打开命令终端，直接输入**kali-autopilot**来加载Autopilot图形界面。接下来，让我们用Autopilot创建第一个自动化攻击脚本。如果你以前从未写过代码或创建过脚本，别担心！Autopilot会为你完成大部分繁重的工作。我们会一步步引导你完成。
- en: Before we get too much further along, let’s make sure we have a utility called
    **Dirb** available to us. Make sure you have this tool by going to your command
    line and typing **sudo apt-get install dirb**. Dirb is often referred to as **Directory
    Buster** or **Directory Brute-Forcer**. Its purpose is to find hidden web content,
    directories, and files on web servers by performing dictionary attacks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们先确保你可以使用名为**Dirb**的工具。请通过进入命令行并输入**sudo apt-get install dirb**来确认你已经安装了这个工具。Dirb常被称为**目录突破工具**或**目录暴力破解工具**，它的作用是通过执行字典攻击来查找网络服务器上隐藏的网页内容、目录和文件。
- en: 'Next, let’s start making our attack script. To create a test script, go to
    the **Attack Scripts** windowpane in the upper left of Autopilot. Within the **Script**
    field at the bottom of that pane, type **MyFirstAutopilotScript** or any name
    you want – just remember it’s the name of your script. Then select the **Add**
    button, as you see in *Figure 11**.3*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始编写攻击脚本。要创建测试脚本，进入 Autopilot 的左上角的**攻击脚本**窗口。在该窗口底部的**脚本**字段中输入**MyFirstAutopilotScript**或任何你喜欢的名称——记得这是你脚本的名称。然后点击**添加**按钮，如*图
    11.3*所示：
- en: '![Figure 11.3 – Creating your first Kali Autopilot script](image/B21223_11_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 创建你的第一个 Kali Autopilot 脚本](image/B21223_11_03.jpg)'
- en: Figure 11.3 – Creating your first Kali Autopilot script
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 创建你的第一个 Kali Autopilot 脚本
- en: You will notice the middle windowpane will automatically populate with your
    new script name, as seen in *Figure 11**.6*. All we’re going to do here is make
    a simple script to scan our host machine and a web server, which we will set up
    now. You may already have it on your system, but in case you don’t, type **sudo
    apt install apache2** and follow any prompts. If you have it, you’ll get a message
    saying as much. If not, it will install. It’s very quick, painless, and should
    not involve the loss of blood. If you do lose blood from installing the Apache
    Web Server, stop what you’re doing immediately because you are doing something
    very, very wrong. Seek medical attention and then find a Linux install professional
    in your area before proceeding.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到中间的窗口会自动填充上你的新脚本名称，如*图 11.6*所示。我们在这里要做的只是创建一个简单的脚本，用来扫描我们的主机系统和一个 Web 服务器，我们现在就开始设置。如果你的系统中已经有它了，那么直接跳过这一步。如果没有，输入**sudo
    apt install apache2**并按照提示操作。如果你已经安装过，它会显示相关信息。如果没有，它会开始安装。这个过程非常迅速且简单，应该不会造成任何痛苦。如果在安装
    Apache Web 服务器时你出现了失血的情况，立刻停止操作，因为你做错了某些非常非常严重的事情。寻求医疗帮助，然后在继续之前找到附近的 Linux 安装专业人员。
- en: When medically and technologically cleared to return, start the web server you
    just installed by typing **sudo systemctl start apache2** and follow that up by
    typing **sudo systemctl status apache2** to ensure everything was successful.
    Now, we’re going to create two variables. The first, we’ll call **Subnet** and
    that will be to scan our host system. The second will be **Webserver** and that
    will be to scan the web server we just installed. We are going to set the values
    of these variables as their respective IP addresses. This way, if those IP addresses
    ever change, we don’t need to rewrite the entire script. We can simply return
    to this middle windowpane, change their values, and ask Autopilot to regenerate
    the script. It will substitute the new values in place of the old ones.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经被医治好并且可以重新开始时，输入**sudo systemctl start apache2**启动你刚刚安装的 Web 服务器，然后输入**sudo
    systemctl status apache2**以确保一切正常。现在，我们要创建两个变量。第一个我们叫**Subnet**，它将用于扫描我们的主机系统。第二个是**Webserver**，它将用于扫描我们刚刚安装的
    Web 服务器。我们将把这些变量的值设定为它们各自的 IP 地址。这样，如果这些 IP 地址发生变化，我们无需重写整个脚本，只需回到中间窗口，修改它们的值，再让
    Autopilot 重新生成脚本，它会用新的值替换旧的值。
- en: 'To create these variables, we first need to grab the default values, which
    are the present IP address. Drop into your host system and open the command terminal.
    Return to [*Chapter 3*](B21223_03.xhtml#_idTextAnchor052) and review it if you
    don’t remember how to do this. If your host is Windows, type **ipconfig** and
    look for the IPv4 value, as you see highlighted in *Figure 11**.4*. If it’s macOS
    or Linux, you would type **ifconfig** to grab the same information:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些变量，我们首先需要获取默认值，即当前的 IP 地址。进入你的主机系统并打开命令终端。如果你不记得如何操作，可以回到[*第 3 章*](B21223_03.xhtml#_idTextAnchor052)进行查看。如果你的主机是
    Windows，输入**ipconfig**并查找 IPv4 值，如*图 11.4*所示。如果是 macOS 或 Linux，你需要输入**ifconfig**来获取相同的信息：
- en: '![Figure 11.4 – Windows system ipconfig command](image/B21223_11_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – Windows 系统 ipconfig 命令](image/B21223_11_04.jpg)'
- en: Figure 11.4 – Windows system ipconfig command
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – Windows 系统 ipconfig 命令
- en: 'Record that information and then, within a terminal window in your Kali Purple
    instance, type **ifconfig** to get information for your web server. Your web server
    is hosted on your Kali Purple instance. You’ll want to grab your eth0 IP address
    as highlighted in *Figure 11**.5*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记录下这些信息，然后在 Kali Purple 实例中的终端窗口里输入**ifconfig**，以获取 Web 服务器的信息。你的 Web 服务器托管在
    Kali Purple 实例上，你需要获取显示在*图 11.5*中的 eth0 IP 地址：
- en: '![Figure 11.5 – VM system ifconfig command](image/B21223_11_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – VM 系统 ifconfig 命令](image/B21223_11_05.jpg)'
- en: Figure 11.5 – VM system ifconfig command
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – VM 系统 ifconfig 命令
- en: Return to your Autopilot application and create two variables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你的 Autopilot 应用程序并创建两个变量。
- en: To create a variable, you will want to place your cursor on the first empty
    row (in this case, it’s row 1) in the first column of the middle windowpane, just
    under the **Name** header. With the field highlighted, simply start typing the
    content you wish to enter and then press *Enter*. Name the first one **Subnet**
    and the second one **Webserver**. Place the value of your host machine’s IP address,
    adding a slash and the number 24 after it, as seen in *Figure 11**.6*. The usage
    of that slash is known as a **Classless Inter-Domain Routing** (**CIDR**) notation.
    It’s a shortcut manner of defining a range of IP addresses without having to list
    each and every single one. We’ll toss a link in the *Further reading* section
    if you’d like to study in more depth about the mechanics of CIDR notations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个变量，你需要将光标放在中间窗口第一列的第一行（在此例中是第1行），在**Name**标题下方的空白行中。选中该字段后，直接开始输入你想要输入的内容，然后按*Enter*键。将第一个命名为**Subnet**，第二个命名为**Webserver**。填写你的主机的
    IP 地址，并在其后加上斜杠和数字 24，如*图 11.6*所示。使用这个斜杠的方式被称为**无类域间路由**（**CIDR**）表示法。这是一种定义 IP
    地址范围的快捷方式，而无需列出每一个单独的地址。如果你想深入研究 CIDR 表示法的原理，我们会在*进一步阅读*部分提供一个链接供你参考。
- en: 'In this case, you’ll note that each IP address is comprised of four groups
    of numbers separated by a dot. This is known as an octet – because the dot itself
    is part of the code and there are four dots. The final dot, at the end of every
    IP address, is invisible. It’s not really – we just leave it out when writing
    IP addresses for readability. Each non-dot octet – also 4 of them – is a number
    ranging from 0 to 255, which is a maximum of 256 numbers (zero plus 1 – 255).
    So here, we’re telling the code that 24 of a maximum possible 32 bits are not
    available, leaving only 8 bits to work with, and that means your variable is going
    to scan a total of 256 IP addresses because those 8 bits can be manipulated by
    256 different combinations of ones and zeros. The 256 IP addresses are **10.0.0.0**
    – **10.0.0.255** with only the final numerical octet changing in value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你会注意到每个 IP 地址由四组数字组成，且每组数字之间用点分隔。这被称为一个八位字节（octet）—因为点本身是代码的一部分，总共有四个点。最后的点，在每个
    IP 地址的末尾，是不可见的。其实它并不是真正消失了，我们只是为了便于书写省略了它。每个非点的八位字节（总共4个）是从 0 到 255 的数字，即最大 256
    个数字（从 0 到 255）。所以在这里，我们告诉代码，32 位中有 24 位不可用，剩下的 8 位可以使用，这意味着你的变量将扫描最多 256 个 IP
    地址，因为这 8 位可以通过 256 种不同的 1 和 0 的组合来操作。这 256 个 IP 地址是**10.0.0.0** – **10.0.0.255**，只有最后的数字八位字节的值会发生变化：
- en: '![Figure 11.6 – Setting variables in Autopilot](image/B21223_11_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 在 Autopilot 中设置变量](image/B21223_11_06.jpg)'
- en: Figure 11.6 – Setting variables in Autopilot
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 在 Autopilot 中设置变量
- en: Once our variables are set, we have the option in the top-right windowpane to
    add some randomization to our attack script. Why would we do this? Well, if you
    ask any experienced SOC analyst, you will learn that they notice things such as
    patterns. Patterns such as precise actions occurring with identical precise timing
    intervals are an obvious sign of automation. Automation will nearly always trigger
    a deeper dig and there is a high probability that the attack will be noticed.
    Why do we care if we are only operating ethically? Because part of being a pentester
    or ethical hacker is doing whatever you can to evade defenses in very much the
    same way a real cybercriminal does. That will help us to learn from our vulnerabilities
    and work to discover or develop new ways to identify potentially malicious behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的变量设置完成，我们可以在右上角的窗口中选择为我们的攻击脚本添加一些随机化。为什么我们要这么做呢？如果你问任何一位经验丰富的 SOC 分析师，你会了解到他们会注意到一些模式。比如说，精确的动作在相同的时间间隔内反复发生，这显然是自动化的迹象。自动化几乎总会引起更深入的挖掘，并且攻击被发现的概率非常高。为什么我们要在只进行道德操作时也要关心这个问题呢？因为作为一名渗透测试员或道德黑客的一部分，正是要像真正的网络犯罪分子那样尽可能躲避防御措施。这将帮助我们从漏洞中学习，努力发现或开发新的方式来识别潜在的恶意行为。
- en: Those of you working in law enforcement or who have law enforcement backgrounds
    have probably heard something along the lines of *“If you want to learn how to
    catch a criminal, then you need to learn how to think like a criminal”* at some
    point in your training. The same is true in the cybersecurity profession. If you
    want to learn how to catch a hacker, then you need to learn how to think like
    a hacker.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你们这些从事执法工作或有执法背景的人中，可能在某个时候听到过类似于*“如果你想学会如何抓住罪犯，那么你需要学会如何像罪犯一样思考”*的话。这在网络安全行业也是如此。如果你想学会如何抓住黑客，那么你需要学会如何像黑客一样思考。
- en: 'It’s pretty much self-explanatory in the **Settings** pane. The values for
    **Delay** are the range between the minimum milliseconds versus the maximum milliseconds
    you want the script to randomly delay between each action. The **Interface** field
    is a reference to the network interface you are running the attack against. We
    will leave ours at **eth0**. We will also leave the API port set to **80** since
    we’re launching an attack against a web server:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在**设置**面板中，这几乎是显而易见的。**延迟**的值是你希望脚本在每个动作之间随机延迟的最小毫秒数和最大毫秒数之间的范围。**接口**字段是指你正在进行攻击的网络接口。我们将保持**eth0**不变。我们还将保持API端口设置为**80**，因为我们正在对一个Web服务器发起攻击：
- en: '![Figure 11.7 – Settings windowpane allows for randomization](image/B21223_11_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 设置窗口允许随机化](image/B21223_11_07.jpg)'
- en: Figure 11.7 – Settings windowpane allows for randomization
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 设置窗口允许随机化
- en: We have our script name, variables, and settings set. Now, let’s write the actual
    attack script. Autopilot works in stages, with stage zero being the first. We
    don’t write instructions for stage zero. That’s internal, which Autopilot can
    use to set up the main attack. That said, let’s identify the beginning of our
    instructions as stage one. On line 1 of **Scripted Attack Sequence**, write **STAGE**
    in all caps under the first column – **Action**. It’s actually not necessary to
    write it in all caps, this is just something that is done for readability. Under
    the second column – **Refer** – input the number **1** to reflect which stage
    we are talking about.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了脚本名称、变量和设置。现在，让我们编写实际的攻击脚本。Autopilot按阶段工作，阶段零是第一阶段。我们不为阶段零编写指令。那是内部的，Autopilot可以用来设置主要攻击。话虽如此，让我们将指令的开始标识为第一阶段。在**脚本化攻击序列**的第1行，在第一列**动作**下写上**STAGE**（全大写）。实际上，写成全大写并不是必须的，这只是为了可读性。在第二列**引用**下，输入数字**1**来表示我们所讨论的阶段。
- en: On lines two and three, we are going to perform two scanning actions – one against
    our host operating system and the other against the web server we set up. Therefore,
    we will name the actions very precisely according to which action we are taking,
    and we are taking the action of scanning. Type **Scanning** on rows two and three
    under the **Action** column. Now that we’ve identified the action, let’s input
    the actual command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行和第三行，我们将执行两个扫描动作——一个是针对我们的主机操作系统，另一个是针对我们设置的Web服务器。因此，我们会非常精确地命名这些动作，以便反映我们所采取的动作——扫描。
    在第二行和第三行的**动作**列下，输入**扫描**。现在我们已经确定了动作，让我们输入实际的命令。
- en: 'On row two, under the **Command** column, type **nmap -sn {Subnet}**. The braces
    indicate that we are inputting a variable in our instructions. The value inside
    those braces is the name of the variable. In this case, we’ve input **Subnet**,
    which is the first variable we created in Autopilot. So, the **nmap -sn {Subnet}**
    command could just as easily have been written as **nmap -sn {10.0.0.192/24}**,
    except by doing it this way, if we want to change the range or IP address we are
    scanning, we only need to change the value in the **Variables** windowpane for
    **Subnet**, without having to touch the actual attack sequence code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行的**命令**列下，输入**nmap -sn {Subnet}**。大括号表示我们正在输入一个变量。大括号内的值就是变量的名称。在这种情况下，我们输入的是**Subnet**，这是我们在Autopilot中创建的第一个变量。因此，**nmap
    -sn {Subnet}**命令也可以写成**nmap -sn {10.0.0.192/24}**，不过这样做的好处是，如果我们想更改要扫描的范围或IP地址，只需在**变量**窗口中更改**Subnet**的值，而不必触及实际的攻击序列代码：
- en: '![Figure 11.8 – Autopilot attack sequence](image/B21223_11_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – Autopilot攻击序列](image/B21223_11_08.jpg)'
- en: Figure 11.8 – Autopilot attack sequence
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – Autopilot攻击序列
- en: The **–** symbol, which is often referred to as a *tack* symbol (it can also
    be called a dash, hyphen, or minus sign but has gained popularity as tack, which
    comes from the military), means these are extra instructions added to Nmap. The
    **s** is telling Nmap to apply the values in this command to a scanning activity.
    This is because Nmap has many uses other than scanning. The **n** is telling Nmap
    that this is a no-port scan. It’s telling Nmap to be broader in its scan and send
    ICMP echo requests to determine the online or offline status of the target without
    taking the time to scan for open ports.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**–**符号，通常被称为*tack*符号（也可以叫做破折号、连字符或减号，但它作为*“tack”*符号更为流行，这个词来自军事术语），表示这是添加到
    Nmap 的附加指令。**s**表示让 Nmap 将此命令中的值应用于扫描活动。这是因为 Nmap 除了扫描外，还有许多其他用途。**n**表示告诉 Nmap
    这是一个无端口扫描。它指示 Nmap 执行更广泛的扫描，通过发送 ICMP 回显请求来确定目标的在线或离线状态，而不花时间扫描开放端口。'
- en: On row three, under the **Command** column, type **nmap -PS -sV {Webserver}**.
    Note that we do not need to add the port number to this command because that was
    set in the top-right **Settings** windowpane. In this case, the **-PS** is telling
    Nmap to perform a TCP SYN ping scan. It’s telling Nmap to perform this scan by
    sending TCP SYN packets to the target hosts to determine whether they are reachable.
    It evaluates whether they are by this scan discovering whether the hosts are active
    and responding. The **-sV** option enables version detection. It tries to determine
    the version of the services running on the target host. This can be very valuable
    information to an attacker because older versions of any particular service could
    have documented vulnerabilities associated with them, which could tell the attacker
    they have more attack vectors than originally expected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行的**命令**列中，键入**nmap -PS -sV {Webserver}**。请注意，我们不需要为此命令添加端口号，因为它已经在右上角的**设置**窗口中设置了。在这种情况下，**-PS**告诉
    Nmap 执行 TCP SYN Ping 扫描。它告诉 Nmap 通过向目标主机发送 TCP SYN 数据包来执行扫描，以确定它们是否可达。它通过此扫描评估主机是否活动并响应。**-sV**选项启用版本检测。它会尝试确定目标主机上运行的服务的版本。这对于攻击者来说是非常有价值的信息，因为任何特定服务的旧版本可能会有已知的漏洞，这可能会告诉攻击者他们拥有比预期更多的攻击途径。
- en: On row four, we are going to attempt to enumerate, therefore the value in the
    **Action** column should be **Enumeration**. Then, in the **Command** column,
    type **dirb http://{Webserver}**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，我们将尝试执行枚举，因此**操作**列中的值应为**枚举**。然后，在**命令**列中，键入**dirb http://{Webserver}**。
- en: 'When finished, click the **Generate** button at the bottom of Autopilot and
    it will automatically generate the Python attack script for you. You’ll get a
    popup showing the location at which Autopilot placed your attack script, as seen
    in *Figure 11**.9*. Navigate to that location using the **cd** utility:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击自动驾驶工具底部的**生成**按钮，它将自动为你生成 Python 攻击脚本。你会看到一个弹窗，显示 Autopilot 放置攻击脚本的位置，如*图
    11.9*所示。使用**cd**命令导航到该位置：
- en: '![Figure 11.9 – Autopilot Python script generation](image/B21223_11_09.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 自动驾驶 Python 脚本生成](image/B21223_11_09.jpg)'
- en: Figure 11.9 – Autopilot Python script generation
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 自动驾驶 Python 脚本生成
- en: 'In our case, the command is **cd kali-autopilot/MyFirstAutopilotScript**. Next,
    we will issue a command to invoke our web server with Python and get it running.
    Type **python3 -m http.server** to make that happen. You can press *Ctrl* + *Z*
    to break out of the loop and then type **ps ux** to look for and confirm that
    the server is running. It will show up on a row near the bottom of your active
    process listing as the exact command you typed – **python3 -m http.server** –
    in the far-right column, as seen in *Figure 11**.10*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，命令是**cd kali-autopilot/MyFirstAutopilotScript**。接下来，我们将发布一个命令来调用我们的
    Python 网络服务器并使其运行。键入**python3 -m http.server**来实现这个目标。你可以按*Ctrl* + *Z*来中断循环，然后键入**ps
    ux**来查找并确认服务器是否在运行。它将在你活动进程列表的底部附近显示，显示的命令与你输入的完全一致——**python3 -m http.server**——并且出现在最右列，如*图
    11.10*所示：
- en: '![Figure 11.10 – PS ux command showing our server is running](image/B21223_11_10.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – PS ux 命令显示我们的服务器正在运行](image/B21223_11_10.jpg)'
- en: Figure 11.10 – PS ux command showing our server is running
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – PS ux 命令显示我们的服务器正在运行
- en: 'Leaving that terminal window open, double-click on the terminal icon to open
    another terminal window and navigate to your Python script by typing the same
    **cd kali-autopilot/MyFirstAutopilotScript** command as the preceding step. Naturally,
    if you named your script something else, then the path will be adjusted to match
    what you named it. Once there, type **ls** to see if your script is in the folder
    – and it very well should be. Type **./MyFirstAutopilotScript.py** to run the
    script. You may get an error for a missing module. To get a missing module, you
    would type **pip install <module name>**. So, in our case, we typed **pip install
    paramiko**, as seen in *Figure 11**.11*. Once you’ve installed any missing modules,
    attempt to start your script by again typing **python3 ./<scriptname>**, and,
    if successful, you’ll get the input you see in *Figure 11**.11*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保持终端窗口打开，双击终端图标打开另一个终端窗口，并通过键入与前一步相同的**cd kali-autopilot/MyFirstAutopilotScript**命令来导航到您的Python脚本。自然地，如果您将脚本命名为其他名称，则路径将根据您的命名进行调整。进入该目录后，键入**ls**以查看您的脚本是否在该文件夹中——它应该在。键入**./MyFirstAutopilotScript.py**来运行脚本。您可能会遇到缺少模块的错误。若缺少模块，您可以键入**pip
    install <module name>**来安装该模块。因此，在我们的例子中，我们键入了**pip install paramiko**，如*图11.11*所示。安装任何缺失的模块后，再次键入**python3
    ./<scriptname>**来尝试启动脚本。如果成功，您将看到如*图11.11*所示的输入：
- en: '![Figure 11.11 – Install missing modules and start the Autopilot script](image/B21223_11_11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 安装缺失的模块并启动Autopilot脚本](image/B21223_11_11.jpg)'
- en: Figure 11.11 – Install missing modules and start the Autopilot script
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 安装缺失的模块并启动Autopilot脚本
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If not successful, read any errors very carefully. Often, they will tell you
    what needs to be done. There are an indefinite number of possibilities as to why
    one might receive an error that others don’t. Almost always, it’s something specific
    to your technology. One of the best modern-day recommendations we can give when
    it comes to Linux shells, scripts, and compiling errors is to simply copy and
    paste that error into your favorite AI chatbot. We highly recommend Google’s Gemini
    for anything Linux- or code-related.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不成功，请仔细阅读任何错误信息。通常，它们会告诉您需要做什么。出现错误的原因有无数种，往往是由于某些特定的技术问题。我们给出的现代建议之一是，当遇到Linux
    shell、脚本或编译错误时，您可以将错误信息复制并粘贴到您最喜欢的AI聊天机器人中。我们强烈推荐谷歌的Gemini用于任何与Linux或代码相关的问题。
- en: 'At this point, your script has been launched but has not yet been put into
    play by us. It is at stage zero. To move it along, we will open a web browser
    and go to [http://localhost/check](http://localhost/check). When you get there,
    you’ll be asked to sign in with a username and password. The default username
    and password for Autopilot are both **offsec**. Then, when the page loads, you’ll
    get a very simple text report that confirms the attack is at stage zero. In this
    case, it says it’s at stage zero of one because we only established one stage
    in our script. If we had twelve stages, it would’ve said **Attack is at Stage
    0 of 12**. You get the point:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的脚本已经启动，但尚未由我们投入使用。它处于零阶段。为了推动它向前，我们将打开一个网页浏览器并访问[http://localhost/check](http://localhost/check)。当您到达该页面时，系统会要求您使用用户名和密码登录。Autopilot的默认用户名和密码均为**offsec**。然后，当页面加载完毕时，您将看到一个非常简单的文本报告，确认攻击处于零阶段。在这种情况下，它显示的是零阶段中的第一阶段，因为我们在脚本中只设置了一个阶段。如果我们有十二个阶段，它会显示**攻击处于第0阶段，共12阶段**。您明白了：
- en: '![Figure 11.12 – Browser confirms attack is at stage 0 out of the maximum stages
    in the script](image/B21223_11_12.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – 浏览器确认攻击处于脚本中的第0阶段](image/B21223_11_12.jpg)'
- en: Figure 11.12 – Browser confirms attack is at stage 0 out of the maximum stages
    in the script
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 浏览器确认攻击处于脚本中的第0阶段
- en: 'To push our attack along, we will select the **URL** field in the browser and
    change the address to read [http://localhost/set?mutex=1](http://localhost/set?mutex=1)
    to set the attack stage to 1\. Return to the terminal where you typed the command
    to invoke your script and you’ll see your script beginning its magic, as seen
    in *Figure 11**.13*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推进我们的攻击，我们将选择浏览器中的**URL**字段，并将地址更改为[http://localhost/set?mutex=1](http://localhost/set?mutex=1)，以将攻击阶段设置为1。返回到您输入命令以启动脚本的终端窗口，您将看到您的脚本开始工作，如*图11.13*所示：
- en: '![Figure 11.13 – Browser confirms attack is at stage 0 out of the maximum stages
    in the script](image/B21223_11_13.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13 – 浏览器确认攻击处于脚本中的第0阶段](image/B21223_11_13.jpg)'
- en: Figure 11.13 – Browser confirms attack is at stage 0 out of the maximum stages
    in the script
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 浏览器确认攻击处于脚本中的第0阶段
- en: There you have it! If you made it this far, congratulations! You’ve just successfully
    created and run your very own automated cyber-attack script! There are many programming
    languages that developers will use for scripting. While there are no hard rules
    for when to use which scripting language, you are most likely to find JavaScript,
    for example, within a web developer’s toolbox. In cybersecurity, you’ll find a
    lot of Bash within the *nix family of operating systems, which includes Linux.
    However, cybersecurity is not restricted to *nix operating systems. Probably the
    most likely and most universal scripting language you’ll find for cybersecurity
    purposes is Python. In fact, you’ve seen dependencies for Python numerous times
    already within this book alone. This is because Python is versatile, easy to learn
    compared to other languages, and filled with a very rich set of libraries and
    frameworks, which make it suitable for tasks such as penetration testing, network
    security monitoring, automation, and general scripting. That said, let’s take
    a look at the Python scripting language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果你已经做到这一点，恭喜你！你刚刚成功创建并运行了自己的自动化网络攻击脚本！开发人员会使用许多编程语言进行脚本编写。虽然没有硬性规定什么时候使用哪种脚本语言，但例如你很可能会在一个网页开发者的工具箱中找到JavaScript。在网络安全领域，你会在*nix家族的操作系统中看到大量的Bash，这包括Linux。然而，网络安全并不限于*nix操作系统。对于网络安全目的来说，最有可能和最通用的脚本语言是Python。事实上，你在本书中已经多次看到Python的依赖。这是因为Python非常多才多艺，相比其他语言易于学习，并且拥有非常丰富的库和框架，使其适用于渗透测试、网络安全监控、自动化和一般脚本编写等任务。那么，让我们来看看Python脚本语言。
- en: Python
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python
- en: Our Python lessons here are going to be unlike any other programming language
    lessons you’ve likely encountered thus far. They are going to be very quick and
    concise. That’s because we are not here to teach you how to code. There are already
    a plethora of resources out there for that. While learning how to write your own
    code is something that has great value, especially at the middle to higher levels
    of cybersecurity, knowing how to do so from the start is not a necessity. What
    is a necessity, however, is being able to read and understand code. That requires
    a much less stringent lesson plan.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的Python课程与你迄今为止遇到的任何编程语言课程都不同。课程将非常简短而精炼。因为我们不是要教你如何编写代码，市面上已经有大量的资源可以帮助你学习这一点。虽然学习如何编写自己的代码具有很大的价值，尤其是在网络安全的中高级阶段，但从一开始就知道如何写代码并不是必要的。然而，必要的是能够阅读和理解代码。这要求我们有一个不那么严格的课程计划。
- en: 'One of the most important aspects of Python is knowing when the language in
    the script is part of the code itself versus being part of the coder’s instructions
    for humans to read. This is done by entering the **#** symbol, which tells any
    Python compiler to ignore all the text that comes after it on that line. So, if
    you have a large amount of non-code information to share, you will need to precede
    each line with the **#** symbol:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个重要方面是知道脚本中的语言何时是代码的一部分，何时又是给人类阅读的程序员指令的一部分。这是通过输入**#**符号来实现的，它告诉任何Python编译器忽略该行中**#**符号后面的所有文本。所以，如果你有大量非代码信息要共享，你需要在每一行前加上**#**符号：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One of the strengths of any programming language is having the ability to define
    and use variable information. That is information that can change over time. In
    Python, this is simple. You decide what you want to name your variable, add an
    equals sign, and then add a default (starting) value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的一个优点是能够定义并使用可变的信息。也就是说，这些信息可以随着时间的推移而改变。在Python中，这是很简单的。你只需决定你想给变量命名，添加一个等号，然后给它一个默认（初始）值：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This means that any time you see the word **awesomeSauce** in the code, it
    is either the value of **0** or the new value if a mathematical operation has
    been applied to it in the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次你在代码中看到**awesomeSauce**这个词时，它要么是**0**的值，要么是在代码中对它应用数学运算后的新值：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In that context, you’ve also noted that if you want your Python code to print
    something to the user’s screen, you will simply use the word **print**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，你还注意到如果你希望Python代码将某些内容打印到用户的屏幕上，你只需使用**print**这个词。
- en: 'What if you wanted to have a variable that is a word instead of a number? That
    is just as simple. You would simply place the value inside quotation marks to
    tell the compiler that the characters inside of the quote, whether letters or
    numbers, are text characters and not numbers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让一个变量是一个单词而不是数字呢？这也很简单。你只需要将值放在引号中，以告诉编译器引号内的字符，无论是字母还是数字，都是文本字符而不是数字：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll notice the string, that is text characters, is reflected by using quotations.
    Both mathematical values and calling a variable, as seen inside the **print**
    function, do not use quotes. You can use plus symbols to piece together the different
    pieces of a phrase in the event a variable is used within a sentence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，字符串（即文本字符）是通过使用引号来表示的。而数学值和调用变量（如在 **print** 函数中所见）则不使用引号。当一个变量被用在句子中时，你可以使用加号来将不同部分的句子拼接在一起。
- en: 'You’ll notice the plus signs are not adding numbers per se but they are adding
    something. They are adding pieces of the string together. Rest assured, when you
    see the usual mathematical operators within Python code, they are performing the
    mathematical operations you think they are in some capacity. These include the
    following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到加号并不是直接加数字，而是在将某些内容组合在一起。它们在将字符串的各部分拼接在一起。放心，当你看到 Python 代码中的常见数学运算符时，它们确实在执行你所期望的数学操作。这些包括：
- en: '| **Title** | **Symbol** | **Operation** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **符号** | **操作** |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Plus | **+** | Addition |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 加号 | **+** | 加法 |'
- en: '| Minus | **-** | Subtraction |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 减号 | **-** | 减法 |'
- en: '| Asterisk | ***** | Multiplication |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 星号 | ***** | 乘法 |'
- en: '| Forward Slash | **/** | Division |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 斜杠 | **/** | 除法 |'
- en: '| Percent | **%** | Modulus (the remainder of division) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 百分号 | **%** | 取余（除法的余数） |'
- en: '| Double asterisk | ****** | Exponents |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 双星号 | ****** | 指数运算 |'
- en: Table 11.1 – Python mathematical operators
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 – Python 数学运算符
- en: 'There are others but this is just an introductory lesson to help you understand
    a basic piece of code written in Python. Along those lines, you will also want
    to familiarize yourself with comparison operators. This is when you compare one
    piece of data to another. These include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他运算符，但这只是一个入门课程，帮助你理解 Python 中一段基本代码。沿着这个思路，你还需要熟悉比较运算符。这是指将一组数据与另一组数据进行比较。它们包括以下几种：
- en: '| **Comparison** **Operator Name** | **Symbol** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **比较** **运算符名称** | **符号** |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Equal | a == b |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | a == b |'
- en: '| Not equal | a != b |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 不等于 | a != b |'
- en: '| Less than | a < b |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | a < b |'
- en: '| Less than or equal to | a <=b |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | a <= b |'
- en: '| Greater than | a > b |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | a > b |'
- en: '| Great than or equal to | a >=b |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | a >= b |'
- en: Table 11.2 – Python comparison operator
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2 – Python 比较运算符
- en: 'Using these mathematical and comparison operators, you can control the flow
    of information. So when reading Python code, you can examine such statements as
    follows to get an idea of what the code might do based on the identified conditions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数学和比较运算符，你可以控制信息的流动。因此，在阅读 Python 代码时，你可以查看如下语句，以便根据已识别的条件了解代码可能会执行的操作：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, **elif** stands for *“or else if the previous statement
    isn’t true but if this statement is true, then do the following line”* and **else**
    stands for *“or else if none of the previous statements are true, then perform
    the following action no* *matter what.”*
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，**elif** 代表 *“如果前一个语句不成立，但如果这个语句成立，那么就执行下一行”*，而 **else** 代表 *“如果前面的语句都不成立，那么不管怎样，都执行下一行”*。
- en: 'You can also control the flow of information with loops. The first is called
    a **while** loop. It just means that while a condition is true, continue to perform
    the following action over and over and over until it is no longer true. Consider
    the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过循环控制信息的流动。第一个是 **while** 循环。它意味着，只要某个条件为真，就继续不断地执行接下来的操作，直到条件不再为真。考虑以下代码：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What do you think the preceding code would do? If you said it would print the
    line **"The beatings will continue"** 10 times before printing the line **"Morale
    has improved! The beatings will stop."** just one time, you are correct. That’s
    because the **morale** variable starts at the value of **0** and the final line
    of the code means to increment the value of that variable by **1** and then run
    through the loop again. It will continue to run through the loop until the initial
    condition becomes false. That happens when **morale** reaches the value of **11**
    because the **while** loop clearly states that it is only to run if the value
    is less than **11**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为上述代码会做什么呢？如果你说它会打印**"The beatings will continue"** 10次，然后再打印一次**"Morale has
    improved! The beatings will stop."**，那么你是正确的。这是因为**morale**变量的初始值为**0**，代码的最后一行表示将该变量的值增加**1**，然后重新运行循环。它会继续循环，直到初始条件变为假。发生这种情况时，**morale**的值达到**11**，因为**while**循环明确指出，它只会在值小于**11**时运行。
- en: 'The next kind of loop is called a **for** loop. In Python, this is a little
    bit different from many other languages. It’s much simpler. It more or less means
    *“as long as”* and can be done with strings or numbers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种循环叫做**for**循环。在 Python 中，它与许多其他语言略有不同。它更简单。它差不多意味着*“只要”*，可以用在字符串或数字上：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The core of any programming language is the function. In Python, functions
    are declared pretty much the same as in any other language, with just a subtle
    change in syntax. Creating a function in Python is done by using the word **def**,
    which stands for define. Then, on the same line, you state the name of the function,
    and within parentheses, any parameters you wish to set for that function. If you
    later wish to call that function, you simply type the function name with any value
    you want to apply to it within the parentheses. The following code sets the parameter
    of **cname** to serve as a variable for any information that is passed to the
    function whenever it is called from somewhere else in the code. We call the function
    six times, passing six different text variables to the original function parameter
    of **cname** to be processed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的核心都是函数。在 Python 中，函数的声明与其他语言几乎相同，只是在语法上有细微的变化。在 Python 中创建函数是通过使用**def**这个关键词来定义的。然后，在同一行中，您需要写出函数的名称，并在圆括号中指定您希望为该函数设置的任何参数。如果您之后希望调用该函数，只需在圆括号中输入您希望传递给它的任何值即可。以下代码将**cname**作为参数，用作任何信息的变量，每当从代码的其他地方调用该函数时，都会传递给它。我们调用函数六次，传递六个不同的文本变量给原始的函数参数**cname**进行处理：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code creates a function called **security_clearance** and accepts
    a parameter that it has named **cname**. When the function is called, it executes
    the commands within. In this case, the only command is to take the parameter of
    **cname**, which will be entered when the function is called, and append the text
    **** CLASSIFIED **** to it. The following six lines are all examples of calling
    the function and passing the data that is within the parentheses to the function,
    making it the **cname** variable. So, for each line, it takes the value in parentheses
    and adds the text **** CLASSIFIED **** after it. The first line, for example,
    would print **"Confidential ** CLASSIFIED **"** to your screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为**security_clearance**的函数，并接受一个名为**cname**的参数。当调用该函数时，它会执行其中的命令。在这个例子中，唯一的命令是接受**cname**参数，该参数会在函数调用时被输入，并将文本****
    CLASSIFIED ****附加到它后面。以下六行代码都是调用该函数并将括号中的数据传递给函数的例子，这样它就成为了**cname**变量。所以，对于每一行，它都会获取括号中的值并在其后添加文本****
    CLASSIFIED ****。例如，第一行将会输出**"Confidential ** CLASSIFIED **"**到屏幕上。
- en: When reading Python code, any time you see **def <sometext>(<value>)**, then
    you can assume that’s a function being defined. Any time you see **<sometext>(<value>)**,
    without the word **def** in front of it, that’s an example of calling the function
    and taking the value in parentheses and passing it to the function definition
    where the instructions are located about what to do with the information you are
    passing to it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 Python 代码时，任何看到**def <sometext>(<value>)**的地方，都可以认为那是在定义一个函数。任何看到**<sometext>(<value>)**的地方，如果前面没有**def**，那就是调用函数的例子，并将括号中的值传递给函数定义中的指令，以告诉程序如何处理您传递给它的信息。
- en: 'If you see the following in a Python script, you can safely conclude that the
    code is trying to read the file that you see listed at the location of the file
    path you see listed. Of course, if you’re trying to open that file, hopefully,
    it means you’re working for the FBI and looking to save some lives. Otherwise,
    you might find yourself in a very bad place:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Python 脚本中看到以下内容，你可以放心地得出结论，代码正在尝试读取你在文件路径中看到的那个文件。当然，如果你正在尝试打开那个文件，希望你是在
    FBI 工作并且想要拯救一些生命。否则，你可能会发现自己身处一个非常糟糕的境地：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should also look for the Python code to create new files or write to them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该查看 Python 代码是否会创建新文件或写入文件：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you see code that looks like the following, that’s Python connecting to
    a database. In this case, it’s connecting to MySQL, which is a very popular database
    folks use:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到像以下这样的代码，那就是 Python 正在连接数据库。在这种情况下，它正在连接到 MySQL，这是一个非常流行的数据库，大家都在用：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, so there’s a whole lot more to Python folks; an exponentially greater
    number of features. However, the purpose of this lesson is not to teach you Python.
    It’s how to recognize the most basic components of Python code so that, as you
    navigate through others’ Python scripts, you can glean a basic understanding of
    what the code is doing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Python 还有更多的内容，功能数量成指数级增长。然而，本节课的目的不是教你 Python，而是教你如何识别 Python 代码的最基本组成部分，这样在浏览他人的
    Python 脚本时，你可以大致理解代码的作用。
- en: 'Let’s put your newly acquired Python identification skills to use. Consider
    the following code, which checks for specific keywords in log files and raises
    an alert if it finds a match:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运用你新学到的 Python 识别技能。考虑以下代码，它会检查日志文件中的特定关键字，并在找到匹配时触发警报：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we near the end of our journey, we’ve begun to cover automation and have
    taken a look at the Python code that Autopilot uses – and many of Kali Purple’s
    utilities use, for that matter. We should now take a look at the framework that
    guides Kali Purple’s structure. We introduced it briefly in [*Chapter 1*](B21223_01.xhtml#_idTextAnchor013).
    It is the NIST CSF, which was updated by NIST for the first time on February 26,
    2024, to version 2.0.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近旅程的尾声，我们已经开始涉及自动化，并且查看了 Autopilot 使用的 Python 代码——事实上，Kali Purple 的许多工具也使用了这些代码。现在，我们应该看看引导
    Kali Purple 结构的框架。在[*第一章*](B21223_01.xhtml#_idTextAnchor013)中，我们曾简要介绍过它。它就是 NIST
    CSF，该框架在 2024 年 2 月 26 日由 NIST 首次更新，版本号为 2.0。
- en: NIST Control
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NIST 控制
- en: 'When Kali Purple was developed, initially as a proof of concept (which rapidly
    evolved into a total framework and platform), the developers based it on five
    basic cyber defense stages: *Identify*, *Protect*, *Detect*, *Respond*, and *Recover*.
    These five stages themselves were developed by the **National Institute of Standards
    and Technology** (**NIST**). In February of 2024, NIST added a sixth stage, *Govern*,
    to the framework.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kali Purple 被开发出来时，最初作为一个概念验证（后来迅速演变成一个完整的框架和平台），开发者基于五个基本的网络防御阶段来构建它：*识别*、*保护*、*检测*、*响应*和*恢复*。这五个阶段本身是由**国家标准与技术研究院**（**NIST**）开发的。在
    2024 年 2 月，NIST 为该框架新增了第六个阶段，*治理*。
- en: NIST is actually an agency within the US Department of Commerce and was founded
    way back in the year 1901 when most technology was likely to be manifested within
    the factory industry. The great irony of NIST creating a cyber framework is that
    it was originally established as a physical science laboratory. However, it has
    expanded its area of coverage over the years and its purpose as it relates to
    cybersecurity is to establish best practices to improve the security and resilience
    of information systems as well as the protection of sensitive data. NIST regularly
    conducts research and provides resources to help organizations address cybersecurity
    challenges so they can maintain a strong cybersecurity posture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: NIST 实际上是美国商务部下属的一个机构，成立于 1901 年，当时大多数技术可能还是集中在工厂行业。NIST 创建网络框架的最大讽刺是，它最初是作为一个物理科学实验室成立的。然而，随着多年来的扩展，其覆盖领域也逐渐增加，其在网络安全领域的目的在于制定最佳实践，以提高信息系统的安全性和韧性，并保护敏感数据。NIST
    定期开展研究，并提供资源，帮助组织应对网络安全挑战，以保持强大的网络安全态势。
- en: 'If you boot up your Kali Purple VM instance and log in to the desktop, you’ll
    see an icon in the upper-left corner, just underneath the word **File**, with
    the Kali Linux dragon mascot and a purple background. Select that icon and notice
    the organization of the drop-down menu:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动 Kali Purple 虚拟机实例并登录桌面，你会看到屏幕左上角有一个图标，位于**文件**字样下方，图标是 Kali Linux 龙的吉祥物，背景为紫色。选择该图标后，你会注意到下拉菜单的组织方式：
- en: '![Figure 11.14 – Kali Purple tools menu](image/B21223_11_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – Kali Purple 工具菜单](image/B21223_11_14.jpg)'
- en: Figure 11.14 – Kali Purple tools menu
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – Kali Purple 工具菜单
- en: The full NIST framework consists of three main – or parent – components, the
    Core, Implementation Tiers, and Profiles. For the purposes of Kali Purple, we
    are only going to focus on the Core. More specifically, we are going to focus
    on the five main functions of the Core. Those functions are *Identify*, *Protect*,
    *Detect*, *Respond*, and *Recover*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 NIST 框架由三个主要（或父级）组成部分构成：核心、实施层级和配置文件。针对 Kali Purple 的目的，我们将只关注核心部分。更具体地说，我们将专注于核心的五个主要功能。这些功能包括*识别*、*保护*、*检测*、*响应*和*恢复*。
- en: Identify
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别
- en: 'The *Identify* function in the NIST CSF is a critical component that focuses
    on developing an understanding of the organization’s assets, business environment,
    cybersecurity risks, and processes. It involves establishing the foundation for
    effective cybersecurity risk management by identifying and documenting the following
    elements in great detail:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NIST CSF 中的*识别*功能是一个关键组件，专注于发展对组织资产、业务环境、网络安全风险和流程的理解。它通过详细识别和记录以下元素，为有效的网络安全风险管理奠定基础：
- en: Asset management
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产管理
- en: Business environment
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务环境
- en: Governance
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 治理
- en: Risk management and strategy
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险管理与战略
- en: Supply chain risk management
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应链风险管理
- en: Cybersecurity roles and responsibilities
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全角色与责任
- en: Can you think of any tools we’ve covered that might apply to any of these areas?
    There indeed are some that will loosely fall under this category but the majority
    of Kali Purple’s *Identify* tools can be found on the Red Team – the strictly
    Kali Linux – side of the family. We’ve talked about several of those previously
    and in this chapter. They include the likes of GVM, Kali Autopilot, Maltego, and
    ZAP.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到我们已经介绍的哪些工具可能适用于这些领域吗？的确有一些工具大致可以归类于这一类别，但大部分 Kali Purple 的*识别*工具可以在红队——严格意义上的
    Kali Linux——这一家庭分支中找到。我们在本章之前提到过其中的几个工具，包括 GVM、Kali Autopilot、Maltego 和 ZAP。
- en: Protect
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护
- en: 'The *Protect* function within the NIST CSF focuses on implementing safeguards
    to ensure the security, integrity, and resilience of an organization’s assets
    and infrastructure. It aims to develop and implement appropriate safeguards to
    ensure the protection and privacy of sensitive data, as well as to respond to
    cybersecurity risks in a timely and effective manner. Some of the core aspects
    of this function include the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: NIST CSF 中的*保护*功能专注于实施保障措施，以确保组织资产和基础设施的安全性、完整性和韧性。其目标是制定并实施适当的保障措施，确保敏感数据的保护和隐私，并及时有效地应对网络安全风险。该功能的一些核心方面包括：
- en: Access control
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Awareness and training
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意识和培训
- en: Data security
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据安全
- en: Information protection, processes, and procedures
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息保护、流程和程序
- en: Technology maintenance
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术维护
- en: Secure tech configurations
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全技术配置
- en: The tools we’ve covered definitely contribute to this function as well as some
    of the Kali Linux-specific tools. Keep in mind that the classification of these
    tools can fall under multiple core functions, and where a tool falls may be subjective
    in nature, depending on how you use it. Under *Protect*, you’ll find Suricata
    and Zeek; the latter will also fall under *Detect*, which we speak of next.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所介绍的工具无疑有助于这一功能，此外还有一些 Kali Linux 特定的工具。请记住，这些工具的分类可以归属于多个核心功能，而一个工具所属的功能可能是主观的，取决于你的使用方式。在*保护*功能下，你会找到
    Suricata 和 Zeek；后者也会归属于*检测*，我们将在接下来的部分讨论。
- en: Detect
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测
- en: The *Detect* function of the NIST CSF involves the ongoing identification of,
    detection of, and timely response to cybersecurity events. It focuses on developing
    and implementing systems, processes, and capabilities to identify the occurrence
    of cybersecurity threats, unauthorized activities, and potential vulnerabilities
    within an organization’s environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: NIST CSF的*检测*功能涉及对网络安全事件的持续识别、检测和及时响应。它侧重于开发和实施系统、流程和能力，以识别组织环境中的网络安全威胁、未经授权的活动和潜在漏洞的发生。
- en: 'The primary goal of this function is to enable organizations to promptly and
    effectively recognize and respond to security incidents, intrusions, and anomalous
    activities that may pose risks to their assets, data, and operations. Some of
    the key components associated with the *Detect* function include the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的主要目标是使组织能够迅速有效地识别和响应可能对其资产、数据和运营构成风险的安全事件、入侵和异常活动。与*检测*功能相关的一些关键组件包括以下内容：
- en: Continuous monitoring
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续监控
- en: Anomaly detection
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常检测
- en: Threat intelligence integration
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 威胁情报集成
- en: Incident response preparedness
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件响应准备
- en: Vulnerability scanning and assessment
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞扫描与评估
- en: Security event correlation
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全事件关联
- en: Endpoint detection and response
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端检测与响应
- en: Threat hunting and analysis
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 威胁狩猎与分析
- en: As you might well have guessed, most of the tools we’ve covered definitely fall
    into this category, such as the ELK Stack, depending on how you configure and
    use it, and Arkime and Zeek, the IDS and IPS systems we just talked about in the
    previous section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，我们涵盖的大部分工具确实属于这一类别，比如根据配置和使用方式不同的ELK Stack，以及我们在上一节讨论过的IDS和IPS系统——Arkime和Zeek。
- en: Respond
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应
- en: 'The *Respond* core function pertains to the development and implementation
    of measures and processes to respond promptly and effectively to cybersecurity
    incidents, breaches, and disruptions. It emphasizes the capability to contain,
    mitigate, and recover from security events, while also ensuring the restoration
    of normal operations and the preservation of critical assets. The *Respond* function
    focuses on coordinated actions, communication, and strategic decision-making to
    address the impact of security incidents and minimize their consequences. The
    core features of this function include the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应*核心功能涉及开发和实施措施与流程，以迅速有效地响应网络安全事件、泄露和干扰。它强调具备遏制、缓解和从安全事件中恢复的能力，同时确保恢复正常操作并保护关键资产。*响应*功能侧重于协调行动、沟通和战略决策，以应对安全事件的影响并最小化其后果。该功能的核心特点包括以下内容：'
- en: Incident response planning
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件响应规划
- en: Containment and eradication
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遏制与消除
- en: Communication and reporting
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信与报告
- en: Evidence preservation
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证据保存
- en: Recovery and remediation
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复与修复
- en: Post-incident analysis
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件后分析
- en: Legal and regulatory compliance
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法律和合规性
- en: Business continuity and resilience
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务连续性与韧性
- en: Stakeholder coordination
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者协调
- en: The tools and topics we discussed in [*Chapter 8*](B21223_08.xhtml#_idTextAnchor134)
    are directly related to this function, such as Cortex, MISP, and TheHive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B21223_08.xhtml#_idTextAnchor134)讨论的工具和话题直接与该功能相关，如Cortex、MISP和TheHive。
- en: Recover
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复
- en: 'The *Recover* core function within the NIST CSF focuses on developing and implementing
    strategies and processes to restore, recover, and reconstitute critical capabilities
    and services following cybersecurity incidents, disruptions, or breaches. It aims
    to minimize the impact of incidents, improve response effectiveness, and facilitate
    the timely recovery of operations, systems, and data. This function emphasizes
    continuity and restoration of normal business operations while simultaneously
    addressing the root causes of incidents to prevent future reoccurrences. Key recovery
    components include the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: NIST CSF中的*恢复*核心功能聚焦于开发和实施策略与流程，以恢复、修复并重建在网络安全事件、干扰或泄露后的关键能力和服务。其目的是最小化事件的影响，提高响应效率，并促进操作、系统和数据的及时恢复。该功能强调业务正常运营的连续性和恢复，同时解决事件的根本原因，以防止未来的重复发生。关键恢复组件包括以下内容：
- en: Continuity planning
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续性规划
- en: Resource restoration
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源恢复
- en: Data recovery and integrity
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据恢复与完整性
- en: Infrastructure reconstitution
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施重建
- en: Resilience and redundancy
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 韧性与冗余
- en: Post-incident analysis and improvement
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件后分析与改进
- en: Stakeholder communication
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者沟通
- en: Legal and regulatory compliance
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法律和监管合规
- en: Vendor and supply chain coordination
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商和供应链协调
- en: Business impact assessment
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务影响评估
- en: Several of the tools we’ve covered would contribute to the *Recover* function
    of the NIST CSF. However, it’s important to recognize that Kali Linux itself provides
    over 600 preinstalled tools, and Kali Purple – which includes the default Kali
    Linux – adds an additional 100 or so tools. In this book, we’ve covered some of
    the most common, well-known tools and added coverage of others that are similar
    or supportive of those. Most of the data collection tools assist in recovery,
    such as Elasticsearch, Suricata, Zeek logs, and especially TheHive/Cortex group
    of utilities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍的一些工具有助于支持NIST CSF的*恢复*功能。然而，重要的是要认识到，Kali Linux本身提供了超过600个预安装的工具，而Kali
    Purple（包括默认的Kali Linux）则增加了大约100个额外工具。在本书中，我们介绍了一些最常见、最著名的工具，并补充了一些与之相似或互补的工具。大多数数据收集工具有助于恢复，比如Elasticsearch、Suricata、Zeek日志，尤其是TheHive/Cortex工具组。
- en: Govern
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 治理
- en: The *Govern* function in the NIST CSF was added to the framework in version
    2.0, which was released in February 2024\. It was created with **Chief Information
    Security Officers** (**CISOs**) in mind. As the role of cybersecurity as a self-contained
    profession expanded and the tools, teams, and challenges grew, so did the gaps
    in policy, transparency, and the ability to manage as such. *Govern* is designed
    to improve transparency, provide organizational context, establish clear definitions
    of roles in cybersecurity functions, and promote adherence to policies, procedures,
    and processes. We won’t delve too deeply into this function here because this
    book is about learning about and understanding a suite of technologies. However,
    those technologies are based upon the other five NIST CSF functions and those
    five functions are now considered to fall under the all-encompassing sixth function
    of *Govern*. *Govern* establishes the pathways and parameters of what an organization
    may do to achieve the other five functions. It helps CISOs to understand the full
    organization context as it relates to risk management, roles, responsibilities,
    authority, and policy. It is very much an oversight function. We will provide
    a direct link to the NIST CSF 2.0 in *Further reading*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NIST CSF中的*治理*功能在版本2.0中加入该框架，该版本于2024年2月发布。它的设计是为了考虑**首席信息安全官**（**CISO**）的需求。随着网络安全作为一个独立职业的角色扩展，工具、团队和挑战的增加，政策、透明度和管理能力方面的差距也随之增大。*治理*旨在提高透明度，提供组织背景，明确网络安全功能中的角色定义，并推动遵守政策、程序和流程。我们在这里不会深入探讨这一功能，因为本书主要是介绍和理解一系列技术。然而，这些技术是基于其他五个NIST
    CSF功能的，而这五个功能现在被认为都归属于*治理*这一广泛的第六个功能。*治理*建立了组织为了实现其他五个功能所能采取的路径和参数。它帮助CISO理解与风险管理、角色、职责、权力和政策相关的整个组织背景。它确实是一个监督功能。我们将在*进一步阅读*中提供NIST
    CSF 2.0的直接链接。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: What a journey! Here in this final chapter of *Introduction to Kali Purple*,
    you evaluated the process of automating pentesting through the simulation of cyber-attacks
    by setting up Kali Autopilot and providing a simple scanning script. Now, you
    know the basics of creating your own automated attack script.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 真是一段旅程！在《Kali Purple入门》的最后一章中，你评估了通过设置Kali Autopilot并提供简单的扫描脚本来自动化渗透测试的过程。现在，你了解了如何创建自己的自动化攻击脚本的基础。
- en: We also covered a very high-level overview of the Python scripting language,
    with the expectation that you’d recognize the core components of the majority
    of Python scripts out there. This should enable you to understand what is going
    on within any particular script and even give you the ability to edit the script
    so that it performs to your liking without having to actually know how to write
    Python code!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了Python脚本语言的高级概述，期望你能识别出大多数Python脚本的核心组件。这应该能够帮助你理解任何特定脚本中的内容，甚至让你在不需要真正懂得编写Python代码的情况下，编辑脚本以使其符合你的需求！
- en: Finally, we covered the updated NIST CSF 2.0, which includes the newly added
    *Govern* function, and grabbed a basic understanding of each of the NIST functions,
    including *Govern*. We learned that the Kali Purple distribution was created with
    the NIST CSF in mind and the idea that a well-rounded set of tools would be most
    useful for cybersecurity professionals from either the Red or Blue team.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讲解了更新的NIST CSF 2.0，其中包括新添加的*治理*功能，并对每个NIST功能有了基本的理解，包括*治理*。我们了解到Kali Purple发行版是根据NIST
    CSF创建的，其理念是对于红队或蓝队的网络安全专业人员来说，拥有一套全面的工具集是最有用的。
- en: As you continue to negotiate your cybersecurity career, whether you are on the
    Blue Team, the Red Team, or are a true Purple Teamer who utilizes concepts and
    technologies from both to better understand and master both, you will always encounter
    new challenges, and with them, new solutions. Remember, the learning never stops
    because the bad actors never stop. They will always find new exploits for which
    the good actors will always find cures. Perhaps, eventually, someday we will have
    a foolproof world where bad deeds will no longer be possible. However, until such
    a world comes to fruition, there will always be a need for folks like you and
    us.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续谈判你的网络安全职业生涯时，无论你是蓝队、红队，还是真正的紫队成员，利用来自两者的概念和技术来更好地理解和掌握两者，你都会不断面对新的挑战，以及相应的新解决方案。记住，学习永远不会停止，因为坏人永远不会停止。他们将总是找到新的漏洞，而好人将永远找到解决方案。也许，最终，总有一天我们会拥有一个百分之百安全的世界，坏行为将不再可能。然而，在这样一个世界实现之前，我们总是需要像你和我们这样的人。
- en: We are a community of professional problem solvers, and we emphasize the use
    of the word professional. We are not here to pick on others or boost our own egos
    (well… maybe a little), but instead, we are here to hold each other up; build
    each other up; empower each other; and create a unified, safer world using nothing
    but our brains and ability to solve problems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是一群专业的问题解决者，强调使用“专业”这个词。我们在这里不是为了挑毛病或炫耀自己的自负（嗯...也许有点），而是要互相支持，互相建设，互相赋能，并使用我们的大脑和解决问题的能力创造一个统一、更安全的世界。
- en: 'We leave you with this final instruction as you embark on upskilling your cyber
    careers: No matter what your knowledge and skill level, always be kind, humble,
    and curious. Master those three things and the rest of your path will present
    itself before you.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留给你的最后一条指导是，在你提升你的网络安全职业生涯时：无论你的知识和技能水平如何，始终保持善良、谦逊和好奇心。掌握这三样东西，你的道路余下的部分将会展现在你面前。
- en: Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Kali Autopilot?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Kali自动驾驶？
- en: An application used to hack drones
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于黑客无人机的应用程序
- en: An application used to automate pentesting and mock cyber-attacks against digital
    defenses
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于自动化渗透测试和模拟网络防御的应用程序。
- en: An application used by airline pilots flying out of California
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于加利福尼亚飞行员的应用程序
- en: If you want to learn how to catch a hacker then, you need to…
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想学习如何捕捉一个黑客，那么你需要...
- en: Watch Swordfish over and over until it sinks in
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反复观看《剑鱼》直到理解透彻。
- en: Eat like a hacker; diet is critical!
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 吃饭像一个黑客；饮食很关键！
- en: Go to hacker school and complete a four-year degree in hacking
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去黑客学校，在那里完成四年的黑客学位
- en: Think like a hacker
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想像自己是一个黑客
- en: How do you distinguish between Python code and text meant for human eyes?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何区分Python代码和面向人类的文本？
- en: All data after the **#** symbol is ignored by the compiler/interpreter and meant
    for human eyes
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有数据在**#**符号之后都会被编译器/解释器忽略，只用于人类阅读。
- en: Python statements all end in **Sssssssssss**…
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python语句都以**Sssssssssss**结尾...
- en: All data after the **#** symbol is processed by the compiler/interpreter and
    everything else is for humans
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有**#**符号之后的数据都会被编译器/解释器处理，其余的都是为了人类。
- en: Only members of Slytherin House can read Python
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有**斯莱特林学院**的成员才能阅读Python。
- en: How does one define a function in Python?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Python中定义一个函数？
- en: Type **define func** followed by the function name
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**define func**，后跟函数名称
- en: Type the name of the function and append it with **.py**
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入函数名称，然后附加**.py**
- en: Type the word **def** followed by the function name and function parameters
    in parenthesis
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入单词**def**，后跟函数名称和括号内的函数参数
- en: Look it up in Webster’s Dictionary
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在韦氏词典中查找它
- en: For the first time since its creation, NIST has released an update to the CSF.
    What is the new sixth function that has been added to the framework?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自其创建以来，NIST首次发布了CSF的更新。新增的框架中的第六个功能是什么？
- en: Identify
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别
- en: Govern
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 治理
- en: Rule
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则
- en: Protect
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护
- en: Who’s your favorite author (only one correct answer)?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最喜欢的作者是谁（只有一个正确答案）？
- en: Carl Laehn
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: Karl Layne
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: Karl Lane
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: Carl Lane
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: Carl Layne
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: Karl Laehn
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡尔·莱恩
- en: James Patterson
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 詹姆斯·帕特森
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Understanding CIDR** **Notation**: [https://www.w3schools.com/training/aws/understanding-cidr-notation.php](https://www.w3schools.com/training/aws/understanding-cidr-notation.php)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解CIDR** **表示法**: [https://www.w3schools.com/training/aws/understanding-cidr-notation.php](https://www.w3schools.com/training/aws/understanding-cidr-notation.php)'
- en: '**Learn to code in** **Python**: [https://www.packtpub.com/search?query=introduction%20to%20python](https://www.packtpub.com/search?query=introduction%20to%20python)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习编程语言** **Python**: [https://www.packtpub.com/search?query=introduction%20to%20python](https://www.packtpub.com/search?query=introduction%20to%20python)'
- en: '**NIST CSF 2.0** **publication**: [https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.29.pdf](https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.29.pdf)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NIST CSF 2.0** **发布**: [https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.29.pdf](https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.29.pdf)'
