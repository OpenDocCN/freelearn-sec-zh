- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Validating (Data) Inputs – Part 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证（数据）输入 - 第二部分
- en: Here in [*Chapter 7*](B18829_07.xhtml#_idTextAnchor262), we will continue with
    input validation. We will cover **code injection**, which enables the attacker
    to insert custom code into the program that it will then run. We will then take
    a look at **command injection**, which uses pre-existing code to run commands,
    typically in the context of a shell. We’ll discuss **server-side template injection**
    (**SSTI**), which is when user input is inserted in an unsafe manner in a template,
    resulting in remote code execution on the server. Lastly, we will cover **Server-Side
    Request Forgery** (**SSRF**), which exploits the server functionality to read
    or alter internal resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18829_07.xhtml#_idTextAnchor262)中，我们将继续进行输入验证的内容。我们将讨论**代码注入**，它使攻击者能够向程序中插入自定义代码并执行。接下来我们将讲解**命令注入**，它通过使用现有代码来执行命令，通常是在Shell环境下进行。然后我们会讨论**服务器端模板注入**（**SSTI**），即用户输入以不安全的方式插入模板，导致在服务器上执行远程代码。最后，我们会介绍**服务器端请求伪造**（**SSRF**），该漏洞通过利用服务器功能读取或更改内部资源。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Testing for code injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码注入
- en: Testing for command injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试命令注入
- en: Testing for server-side template injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务器端模板注入
- en: Testing for server-side request forgery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务器端请求伪造
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, it is required that you install OWASP ZAP and utilize your
    PortSwigger account for access to the PortSwigger Academy labs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你安装OWASP ZAP并使用PortSwigger账户访问PortSwigger Academy实验。
- en: Testing for code injection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码注入
- en: Code injection is a vulnerability that involves injecting code into the application
    that is then interpreted or executed by the application. This vulnerability allows
    an attacker to get information from the backend of the application all the way
    up to fully compromising the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注入是一种漏洞，指的是将代码注入到应用程序中，后者会解释或执行这些代码。此漏洞允许攻击者从应用程序的后台获取信息，甚至完全控制应用程序。
- en: In this recipe, we will walk you through the *Remote code execution via web
    shell upload* PortSwigger lab to create and upload a new file via the web application
    feature that includes the code injection payload.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带你通过*通过Web Shell上传进行远程代码执行*的PortSwigger实验，创建并上传一个包含代码注入有效载荷的新文件，通过Web应用程序功能实现上传。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个PortSwigger Academy账户以及ZAP工具，用于拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this lab, you will be exposed to a vulnerable image upload feature that does
    not validate the files uploaded by users before putting them on the server’s storage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，你将接触到一个存在漏洞的图片上传功能，该功能没有验证用户上传的文件，在将其存储到服务器之前存在安全隐患。
- en: You will exploit this flaw by uploading a simple PHP web shell and utilizing
    it to exfiltrate the contents of the **/****home/carlos/secret** file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过上传一个简单的PHP Web Shell并利用它来提取**/home/carlos/secret**文件的内容，从而利用此漏洞。
- en: 'Navigate to the *Remote code execution via web shell upload* PortSwigger Academy
    lab and obtain the credentials provided in the lab description. The following
    URL points to the lab: [https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload](https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 导航至*通过Web Shell上传进行远程代码执行*的PortSwigger Academy实验，并获取实验说明中提供的凭据。以下URL指向该实验：[https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload](https://portswigger.net/web-security/file-upload/lab-file-upload-remote-code-execution-via-web-shell-upload)：
- en: With the browser proxied to ZAP, log into the PortSwigger Academy website to
    launch the lab.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器通过ZAP代理后，登录PortSwigger Academy网站以启动实验。
- en: Once you launch the lab, navigate to **My Account** and log in with the **wiener**
    account, and **peter** as the password. This is also provided on the lab instruction
    page, where you click to launch the application.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动实验后，导航至**我的账户**并使用**wiener**账户登录，密码为**peter**。这些信息也可以在实验说明页面找到，点击即可启动应用。
- en: From the **My Account** page, click **Choose File** and select any image you
    have to upload. In *Figure 7**.1*, you can see I have selected an Avatar picture
    of myself and uploaded the photo. After you upload the picture, click on **back
    to my account**, and you will notice now you can see the image uploaded.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**我的账户**页面，点击**选择文件**并选择要上传的任何图片。如*图 7.1*所示，你可以看到我选择了自己的头像并上传了照片。上传图片后，点击**返回我的账户**，你会注意到现在可以看到已上传的图片。
- en: '![Figure 7.1 – The My Account page](image/Figure_7.01_B18829.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 我的账户页面](image/Figure_7.01_B18829.jpg)'
- en: Figure 7.1 – The My Account page
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 我的账户页面
- en: 'Next, check the ZAP Sites window for the request that the application used
    to obtain the avatar image from the **My Account** page, as shown in *Figure 7**.2*:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查 ZAP Sites 窗口，查看应用程序用来从**我的账户**页面获取头像图片的请求，如*图 7.2*所示：
- en: '![Figure 7.2 – The avatar image request](image/Figure_7.02_B18829.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 头像图片请求](image/Figure_7.02_B18829.jpg)'
- en: Figure 7.2 – The avatar image request
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 头像图片请求
- en: 'Then right-click on the image, as shown in *Figure 7**.3*, and click on **Open/Resend
    with** **Request Editor**:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键点击图片，如*图 7.3*所示，点击**使用请求编辑器打开/重发**：
- en: '![Figure 7.3 – The Open/Resend with Request Editor option](image/Figure_7.03_B18829.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 使用请求编辑器的打开/重发选项](image/Figure_7.03_B18829.jpg)'
- en: Figure 7.3 – The Open/Resend with Request Editor option
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 使用请求编辑器的打开/重发选项
- en: 'From here, you can minimize the current **Request Editor** window to create
    a new file with the code injection payload. The file you are going to create is
    named **exploit.php**, and the code inside the file is shown as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，你可以最小化当前的**请求编辑器**窗口，创建一个包含代码注入有效载荷的新文件。你将要创建的文件名为**exploit.php**，文件中的代码如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you have created the payload file and saved it, go ahead and upload the
    file in the same way you uploaded the profile image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建并保存了有效载荷文件后，按照上传个人资料图片的方式上传该文件。
- en: 'Notice that once you select the **exploit.php** file to upload as the avatar
    image, the name of the file is shown before you upload the file, as shown in *Figure
    7**.4*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，一旦你选择了**exploit.php**文件作为头像图片上传，文件名会在上传文件之前显示，如*图 7.4*所示：
- en: '![Figure 7.4 – Upload image feature](image/Figure_7.04_B18829.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 上传图片功能](image/Figure_7.04_B18829.jpg)'
- en: Figure 7.4 – Upload image feature
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 上传图片功能
- en: Once you upload the exploit file, you can go back to ZAP, and in the **Manual
    Request Editor** window that you minimized earlier, change the path at the end
    of your URL to **/files/avatars/exploit.php** and send the request. Notice that
    it returns a random generated string. This is the solution needed to complete
    the lab that demonstrates how we can read the file inside the server located in
    the same path we used for our **/****home/carlos/secret** exploit.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦上传了漏洞文件，你可以回到 ZAP，并在之前最小化的**手动请求编辑器**窗口中，将 URL 末尾的路径更改为**/files/avatars/exploit.php**，然后发送请求。注意，它返回了一个随机生成的字符串。这是完成实验所需的解决方案，演示了我们如何读取服务器中位于与我们用于**/****home/carlos/secret**漏洞相同路径的文件。
- en: Congratulations! You have read a file inside a server by exploiting a code injection
    vulnerability on the application.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜！你已经通过利用应用程序中的代码注入漏洞读取了服务器中的文件。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Code injection is a technique for injecting arbitrary code into a program or
    process to execute it. This can be done for several reasons, such as testing,
    debugging, or malevolent objectives, such as malware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注入是一种将任意代码注入程序或进程中并执行的技术。这可以出于多种原因，比如测试、调试或恶意目的，例如恶意软件。
- en: 'Code injection can happen in a variety of ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注入可以通过多种方式发生：
- en: '**Buffer overflow**: A buffer overflow vulnerability happens when software
    attempts to store more data than it is meant to contain in a buffer (a temporary
    data storage space). This can overwrite nearby memory, allowing an attacker to
    execute arbitrary code.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**：缓冲区溢出漏洞发生在软件尝试存储比其预定容量更多的数据到缓冲区（一个临时数据存储区）时。这可能会覆盖附近的内存，从而允许攻击者执行任意代码。'
- en: '**SQL injection**: SQL injection is a kind of code injection in which an attacker
    may send malicious SQL statements to a database server via a susceptible application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL 注入**：SQL 注入是一种代码注入攻击，攻击者可以通过易受攻击的应用程序向数据库服务器发送恶意 SQL 语句。'
- en: '**Cross-site scripting (XSS)**: XSS is a kind of code injection in which an
    attacker injects malicious code into a web page, which is subsequently executed
    by the victim’s browser.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击（XSS）**：XSS是一种代码注入，攻击者将恶意代码注入网页，随后该代码由受害者的浏览器执行。'
- en: '**Remote code execution (RCE)**: RCE is a kind of code injection in which an
    attacker is able to execute code on a remote machine by exploiting a vulnerability
    in a network service or application.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程代码执行（RCE）**：RCE是一种代码注入，攻击者通过利用网络服务或应用程序中的漏洞，可以在远程计算机上执行代码。'
- en: Code injection can be avoided by using effective input validation and sanitization,
    safe coding techniques, and frequent security updates and patches.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用有效的输入验证和清理、编写安全的代码技术以及定期进行安全更新和修补，可以避免代码注入。
- en: Testing for command injection
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令注入
- en: Command injection is a vulnerability that enables an attacker to execute commands
    on the application’s underlying operating system (the host). This vulnerability
    occurs when the application takes unsanitized and unvalidated user input and executes
    it in a system command. Some examples of system commands are **grep**, **exec**,
    and **system**. The system commands differ depending on the programming language
    that the application is developed with. Usually, to perform the command injection
    attack, you provide the application with the expected input and then a special
    character to execute the desired commands right after the expected input (command).
    Special characters, such as **|**, **&**, **;**, **|**, **||**, **&**, **&&**,
    and **\n** append more commands to the executed command. Using these special characters,
    you can execute more commands at the same time. The severity of the vulnerability
    is determined by the permissions granted to the application’s user account. It
    could be as critical as viewing the passwords stored in the system, exfiltrating
    data, or interacting with other systems on the network.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入是一种漏洞，它允许攻击者在应用程序的底层操作系统（主机）上执行命令。当应用程序接受未经清理和验证的用户输入并将其执行为系统命令时，就会发生此漏洞。系统命令的例子有**grep**、**exec**和**system**等。系统命令会根据应用程序开发所用的编程语言不同而有所不同。通常，要进行命令注入攻击，你需要为应用程序提供预期输入，之后再加上一个特殊字符，以执行所需的命令。特殊字符如**|**、**&**、**;**、**|**、**||**、**&**、**&&**和**\n**，可以将更多命令附加到已执行的命令中。通过使用这些特殊字符，你可以同时执行多个命令。漏洞的严重性取决于应用程序用户帐户所授予的权限。它的影响可能极为严重，像是查看存储在系统中的密码、窃取数据或与网络上的其他系统交互等。
- en: In this recipe, we will walk through the *OS command injection, simple case*
    lab in PortSwigger’s Web Security Academy and learn how to exploit the vulnerability
    of successfully triggering commands that we input.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将带你完成PortSwigger Web安全学院中的*操作系统命令注入，简单案例*实验，并学习如何利用成功触发的输入命令的漏洞。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need to start ZAP and ensure it intercepts the request and responses
    between your browser and the PortSwigger Academy lab.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要启动ZAP，并确保它能够拦截浏览器与PortSwigger学院实验之间的请求和响应。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To demonstrate how to exploit a common injection vulnerability, we are going
    to use one of PortSwigger’s Web Security Academy labs. ZAP will intercept the
    traffic, and we will modify a request to exploit the vulnerability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何利用常见的注入漏洞，我们将使用PortSwigger Web安全学院中的一个实验。ZAP将拦截流量，我们将修改请求以利用该漏洞。
- en: 'The following steps walk you through completing the lab and exploiting the
    vulnerability:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你完成实验并利用该漏洞：
- en: Start ZAP, and in your browser, navigate to PortSwigger Academy. Log in and
    click on the **All** **Labs** button.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动ZAP，并在浏览器中访问PortSwigger学院。登录后点击**所有** **实验**按钮。
- en: 'Scroll down to the **OS command injection** section, and click on the **OS
    command injection, simple case** lab, found at [https://portswigger.net/web-security/os-command-injection/lab-simple](https://portswigger.net/web-security/os-command-injection/lab-simple):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动至**操作系统命令注入**部分，点击**操作系统命令注入，简单案例**实验，链接位于[https://portswigger.net/web-security/os-command-injection/lab-simple](https://portswigger.net/web-security/os-command-injection/lab-simple)：
- en: '![Figure 7.5 – The OS command injection lab](image/Figure_7.05_B18829.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 操作系统命令注入实验](image/Figure_7.05_B18829.jpg)'
- en: Figure 7.5 – The OS command injection lab
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 操作系统命令注入实验
- en: Click on **Access the lab**, and the vulnerable application will open in a new
    tab.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**访问实验**，易受攻击的应用程序将在新标签页中打开。
- en: Add the application to the scope to limit the results you see to only the scope.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序添加到范围内，以限制你所看到的结果仅限于该范围。
- en: 'In this application, the function to check the stock level of every item shown
    is vulnerable to command injection vulnerability. Therefore, open any item, scroll
    to the bottom until you can select the **Check stock** button, as seen in *Figure
    7**.6*:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个应用程序中，用于检查每个显示项库存水平的功能存在命令注入漏洞。因此，打开任何一个商品，滚动到底部，直到你可以选择**检查库存**按钮，如*图 7.6*所示：
- en: '![Figure 7.6 – The Check stock button](image/Figure_7.06_B18829.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 检查库存按钮](image/Figure_7.06_B18829.jpg)'
- en: Figure 7.6 – The Check stock button
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 检查库存按钮
- en: 'We clicked on the button to generate the request. Now that the request has
    been sent, find it in the **History** tab of ZAP. It will be a **POST** HTTP request
    to **/product/stock**, as seen in *Figure 7**.7*:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击按钮生成请求。现在请求已经发送，找到它在 ZAP 的**历史**选项卡中。它将是一个**POST** HTTP 请求，发送到**/product/stock**，如*图
    7.7*所示：
- en: '![Figure 7.7 – A POST request to /product/stock](image/Figure_7.07_B18829.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 一个发送到 /product/stock 的 POST 请求](image/Figure_7.07_B18829.jpg)'
- en: Figure 7.7 – A POST request to /product/stock
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 一个发送到 /product/stock 的 POST 请求
- en: Right-click the request and click on **Open/Resend with Request Editor**, also
    known as **Manual** **Request Editor**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击请求，然后点击**使用请求编辑器打开/重新发送**，也称为**手动请求编辑器**。
- en: '**Manual Request Editor** will open in a new window. To exploit the vulnerability,
    add the **|** pipe symbol and a command right after **storeId=1**. For this step,
    add **|pwd**, as seen in *Figure 7**.8*, to see which directory we are in, and
    click on the **Send** button:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**手动请求编辑器**将在新窗口中打开。为了利用该漏洞，在**storeId=1**后添加**|**管道符号和命令。在此步骤中，添加**|pwd**，如*图
    7.8*所示，以查看我们在哪个目录，并点击**发送**按钮：'
- en: '![Figure 7.8 – The storeId request](image/Figure_7.08_B18829.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – storeId 请求](image/Figure_7.08_B18829.jpg)'
- en: Figure 7.8 – The storeId request
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – storeId 请求
- en: As you can see, the request we have sent with the system command has been executed,
    and now we can see that the directory we are in is **/home/peter-IkA8ei**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们发送的带有系统命令的请求已经执行，现在我们可以看到我们所在的目录是**/home/peter-IkA8ei**。
- en: 'Now, for fun, let’s create a file. Go back to the **Request** tab of **Manual
    Request Editor** and add the **|** pipe symbol and **cat > CommandInjection.txt**,
    as seen in *Figure 7**.9*. The **200** HTTP response status code tells us that
    the request was successful:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了好玩，我们来创建一个文件。返回到**请求**选项卡中的**手动请求编辑器**，添加**|**管道符号和**cat > CommandInjection.txt**，如*图
    7.9*所示。**200** HTTP 响应状态码告诉我们请求成功：
- en: '![Figure 7.9 –  The CommandInjection request](image/Figure_7.09_B18829.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 命令注入请求](image/Figure_7.09_B18829.jpg)'
- en: Figure 7.9 – The CommandInjection request
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 命令注入请求
- en: 'Now, to see the file we have created, repeat the same steps, but this time
    add a **|** pipe symbol and the **ls** command, as seen in *Figure 7**.10*, and
    click on **Send**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要查看我们创建的文件，请重复相同的步骤，但这次添加**|**管道符号和**ls**命令，如*图 7.10*所示，然后点击**发送**：
- en: '![Figure 7.10 – The ls command in request](image/Figure_7.10_B18829.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 请求中的 ls 命令](image/Figure_7.10_B18829.jpg)'
- en: Figure 7.10 – The ls command in request
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 请求中的 ls 命令
- en: 'In the response, you can see that the command was executed successfully, and
    we can see the file we have created listed, as seen in *Figure 7**.11*:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应中，你可以看到命令已经成功执行，我们可以看到我们创建的文件已列出，如*图 7.11*所示：
- en: '![Figure 7.11 – The executed command injection](image/Figure_7.11_B18829.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 执行的命令注入](image/Figure_7.11_B18829.jpg)'
- en: Figure 7.11 – The executed command injection
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 执行的命令注入
- en: This concludes this lab. In this lab, you successfully exploited a command injection
    vulnerability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本实验的结束。在本实验中，你成功利用了命令注入漏洞。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since the application is vulnerable to command injections, it does not validate
    the user input. Therefore, we could execute system commands, see which directory
    we were in, and create files. We could also delete files if we wanted to.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该应用程序存在命令注入漏洞，因此没有验证用户输入。因此，我们可以执行系统命令，查看当前目录，并创建文件。如果我们愿意，我们还可以删除文件。
- en: Remediation measures for command injection vulnerabilities can be prevented
    by sanitizing the user’s input.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 针对命令注入漏洞的修复措施可以通过清理用户输入来防止。
- en: There’s more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'ZAP Active Scan can detect the command injection vulnerability. Run an active
    scan on the application, navigate to the **Alerts** tab after it has finished,
    and search for the presence of **Remote OS Command Injection**. In the alert,
    more information is provided about the vulnerability, and in the **Attack** field,
    you will see the successful payload. Using the payload observed in the **Attack**
    field, you can recreate the attack to view the password file or more. *Figure
    7**.12* is a screenshot of the alert:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP 活跃扫描可以检测到命令注入漏洞。对应用程序运行活跃扫描，扫描完成后转到**警报**标签页，搜索是否存在**远程操作系统命令注入**。在警报中，您将获得有关漏洞的更多信息，在**攻击**字段中，您会看到成功的有效载荷。使用在**攻击**字段中观察到的有效载荷，您可以重新创建攻击，查看密码文件或其他内容。*图
    7.12* 是警报的截图：
- en: '![Figure 7.12 – The Alerts tab attack description](image/Figure_7.12_B18829.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 警报标签页攻击描述](image/Figure_7.12_B18829.jpg)'
- en: Figure 7.12 – The Alerts tab attack description
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 警报标签页攻击描述
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Commix is an open source tool developed to automatically detect and exploit
    command injection vulnerability exploitation. It is also included as a tool in
    Kali Linux. To learn more about Commix, please visit the tool’s GitHub page ([https://github.com/commixproject/commix](https://github.com/commixproject/commix)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Commix 是一个开源工具，旨在自动检测并利用命令注入漏洞。它也作为一个工具包含在 Kali Linux 中。欲了解更多关于 Commix 的信息，请访问该工具的
    GitHub 页面 ([https://github.com/commixproject/commix](https://github.com/commixproject/commix))。
- en: Testing for server-side template injection
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务器端模板注入
- en: In this recipe, you will learn how to conduct a basic SSTI attack using a lab
    from PortSwigger Academy. Because of the insecure construction of an ERB template,
    the application in this lab is vulnerable to SSTI. You will learn what SSTI is
    by completing the lab. First, read the ERB documentation to learn how to run arbitrary
    code, then delete the **morale.txt** file from Carlos’s home directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何使用 PortSwigger Academy 的实验室进行基本的 SSTI 攻击。由于 ERB 模板的构建不安全，本实验室中的应用程序容易受到
    SSTI 攻击。通过完成实验室，您将了解什么是 SSTI。首先，阅读 ERB 文档，学习如何运行任意代码，然后删除**morale.txt**文件，该文件位于
    Carlos 的主目录中。
- en: Furthermore, you will learn how server-side templates work and how this leads
    to attackers exploiting vulnerabilities to gain control over the server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将学习服务器端模板的工作原理，以及这如何导致攻击者利用漏洞控制服务器。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start up your local ZAP tool and log in to your PortSwigger Academy account,
    then go to the *Basic server-side template injection* lab at [https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic](https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 启动本地 ZAP 工具并登录到您的 PortSwigger Academy 账户，然后访问 [https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic](https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic)
    中的*基本服务器端模板注入*实验室。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'A good first step toward exploitation is to fuzz the template by injecting
    a sequence of special characters commonly used in template expressions, such as
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 进行漏洞利用的一个好方法是通过注入一系列在模板表达式中常用的特殊字符来模糊化模板，例如以下字符：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So when fuzzing produces an error or result, such as the use of mathematical
    equations, this will indicate that the template is vulnerable to injection as
    the server is attempting to evaluate the payload. Doing so is important in identifying
    its context before being able to exploit it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当模糊化产生错误或结果时，例如使用数学方程式，这将表明模板存在注入漏洞，因为服务器正试图评估有效载荷。这样做对于在能够利用漏洞之前识别其上下文是非常重要的：
- en: 'First, click **View Details** to learn more about the first product. A **GET**
    request uses the message parameter to render; then you will get the **Unfortunately
    this product is out of stock** message on the home page, as shown in *Figure 7**.13*:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击**查看详情**以了解第一个产品的更多信息。一个**GET**请求使用消息参数进行渲染；然后您将看到首页上的**很抱歉，该产品已售罄**信息，如*图
    7.13*所示：
- en: '![Figure 7.13 – The GET request displaying an out-of-stock message](image/Figure_7.13_B18829.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 显示缺货信息的 GET 请求](image/Figure_7.13_B18829.jpg)'
- en: Figure 7.13 – The GET request displaying an out-of-stock message
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 显示缺货信息的 GET 请求
- en: 'Looking up the ERB documentation (the *See also* section has a link to the
    documentation), you can see that the syntax for an expression is **<%= someExpression
    %>**, which is used to evaluate an expression and render the results on the page.
    You can also generate an error using the expression, which will disclose information
    that the template is using Ruby ERB. (see *Figure 7**.14*):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查阅 ERB 文档（*另见*部分有链接到文档），你可以看到表达式的语法是**<%= someExpression %>**，用于评估表达式并将结果渲染到页面上。你还可以使用该表达式生成错误，从而泄露模板正在使用
    Ruby ERB。（见*图 7.14*）：
- en: '![Figure 7.14 – Internal Server Error disclosing Ruby ERB](image/Figure_7.14_B18829.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 内部服务器错误泄露 Ruby ERB](image/Figure_7.14_B18829.jpg)'
- en: Figure 7.14 – Internal Server Error disclosing Ruby ERB
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 内部服务器错误泄露 Ruby ERB
- en: 'Enter the URL of a test payload after **message=** containing a simple mathematical
    operation using the ERB expression syntax:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**message=**后输入一个测试有效载荷，包含一个使用 ERB 表达式语法的简单数学运算：
- en: '[PRE2]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will notice that the math equation is solved and rendered to the page of
    the web application shown in *Figure 7**.15*. This will appear in the same place
    as before, as seen in *Figure 7**.16*. This indicates that we may have an SSTI
    vulnerability:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到数学公式已经被求解并渲染到 web 应用程序页面中，如*图 7.15*所示。它将出现在与之前相同的位置，如*图 7.16*所示。这表明我们可能存在
    SSTI 漏洞：
- en: '![Figure 7.15 – The math operation rendered to the web page](image/Figure_7.15_B18829.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 数学运算结果渲染到网页](image/Figure_7.15_B18829.jpg)'
- en: Figure 7.15 – The math operation rendered to the web page
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 数学运算结果渲染到网页
- en: 'Refer to the Ruby documentation and use the **system()** method. This method
    can be used to execute arbitrary operating system commands. You can test that
    the commands work with a simple Linux command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参考 Ruby 文档并使用**system()**方法。此方法可用于执行任意操作系统命令。你可以通过一个简单的 Linux 命令来测试这些命令是否有效：
- en: '[PRE3]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we can see the result of the command displayed back in the web application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到命令在 web 应用程序中显示的结果：
- en: '![Figure 7.16 – The pwd command result](image/Figure_7.16_B18829.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – pwd 命令结果](image/Figure_7.16_B18829.jpg)'
- en: Figure 7.16 – The pwd command result
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – pwd 命令结果
- en: 'Now that we can see the server is executing commands to print the current working
    directory as well as listing all files, let’s build a payload that will delete
    a file from Carlos’s directory:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以看到服务器正在执行命令以打印当前工作目录并列出所有文件，让我们构造一个有效载荷，以便从 Carlos 的目录中删除一个文件：
- en: '[PRE5]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Successful execution of the lab will result in a congratulations screen being
    displayed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行实验将显示一个祝贺页面：
- en: '![Figure 7.17 – Lab solved](image/Figure_7.17_B18829.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 实验已解决](image/Figure_7.17_B18829.jpg)'
- en: Figure 7.17 – Lab solved
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 实验已解决
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If the command results in an error message or does not execute, convert the
    payload to be URL encoded, for example, **%3C%25%3D%20system%28%22ls%20-a%22%29%20%25%3E**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令导致错误消息或没有执行，请将有效载荷转换为 URL 编码，例如，**%3C%25%3D%20system%28%22ls%20-a%22%29%20%25%3E**。
- en: 'Use the OWASP ZAP **Encode/Decode/Hash** tool or the *Ctrl + E* shortcut, as
    shown in *Figure 7**.18*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OWASP ZAP **编码/解码/哈希**工具或快捷键*Ctrl + E*，如*图 7.18*所示：
- en: '![Figure 7.18 – The Encode/Decode/Hash tool](image/Figure_7.18_B18829.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 编码/解码/哈希工具](image/Figure_7.18_B18829.jpg)'
- en: Figure 7.18 – The Encode/Decode/Hash tool
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 编码/解码/哈希工具
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can use static template files in your application thanks to template engines
    such as Smarty for PHP, Freemarker for Java, or Jinja2 for Python. The template
    engine replaces variables in the template file with actual user-provided values
    at runtime and converts the template into an HTML file that is sent to the client.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用像 Smarty（PHP）、Freemarker（Java）或 Jinja2（Python）这样的模板引擎，在你的应用程序中使用静态模板文件。模板引擎会在运行时将模板文件中的变量替换为实际用户提供的值，并将模板转换为
    HTML 文件，然后发送给客户端。
- en: By submitting invalid syntax, a resulting error message will indicate to an
    attacker what template engine is being used and, in some cases, which version.
    This allows an attacker insight into crafting malicious payloads or invalid syntax
    into a template to execute server-side commands.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提交无效的语法，结果错误消息将向攻击者指示正在使用的模板引擎，并在某些情况下指明其版本。这使攻击者能够构造恶意有效载荷或将无效语法嵌入模板中，从而执行服务器端命令。
- en: There’s more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Developers use server-side templates to preemptively load a web page with custom
    user data directly on the server. It is common for web frameworks to generate
    HTML code dynamically, where the template contains the static parts of the desired
    HTML output as well as the syntax that describes how dynamic content will be inserted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用服务器端模板预先在服务器上加载自定义用户数据的网页。现代网页框架通常动态生成 HTML 代码，模板包含所需 HTML 输出的静态部分以及描述如何插入动态内容的语法。
- en: The template engines then process template files, assisting in the fusion of
    dynamic data into web pages. When an HTTP request is received, the template engine
    generates the HTML output response.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎随后处理模板文件，帮助将动态数据融入网页。当收到 HTTP 请求时，模板引擎会生成 HTML 输出响应。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'GitHub SSTI payloads: [https://github.com/payloadbox/ssti-payloads](https://github.com/payloadbox/ssti-payloads)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub SSTI Payloads: [https://github.com/payloadbox/ssti-payloads](https://github.com/payloadbox/ssti-payloads)'
- en: For further reading on template frameworks, visit the followi[ng links:](https://www.smarty.net/)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 若要进一步阅读有关模板框架的内容，请访问以下链接：[https://www.smarty.net/](https://www.smarty.net/)
- en: '[For PHP:](https://www.smarty.net/)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于 PHP:](https://www.smarty.net/)'
- en: '[Sma](https://www.smarty.net/)rty: [https://www.smarty.net/](https://www.smarty.net/)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Smarty:](https://www.smarty.net/) [https://www.smarty.net/](https://www.smarty.net/)'
- en: 'Twig: [https://twig.symfony.com/](https://twig.symfony.com/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Twig: [https://twig.symfony.com/](https://twig.symfony.com/)'
- en: 'PHPTAL: [https://phptal.org/](https://phptal.org/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PHPTAL: [https://phptal.org/](https://phptal.org/)'
- en: 'For Java:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java：
- en: 'JSP/JSTL: [https://www.oracle.com/java/technologies/jstl-documentation.html](https://www.oracle.com/java/technologies/jstl-documentation.html)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSP/JSTL: [https://www.oracle.com/java/technologies/jstl-documentation.html](https://www.oracle.com/java/technologies/jstl-documentation.html)'
- en: 'Apache Velocity: [https://velocity.apache.org/](https://velocity.apache.org/)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apache Velocity: [https://velocity.apache.org/](https://velocity.apache.org/)'
- en: 'Apache FreeMarker: [https://freemarker.apache.org/](https://freemarker.apache.org/)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apache FreeMarker: [https://freemarker.apache.org/](https://freemarker.apache.org/)'
- en: 'Thymeleaf: [https://www.thymeleaf.org/](https://www.thymeleaf.org/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Thymeleaf: [https://www.thymeleaf.org/](https://www.thymeleaf.org/)'
- en: 'Pippo: [http://www.pippo.ro/](http://www.pippo.ro/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Pippo: [http://www.pippo.ro/](http://www.pippo.ro/)'
- en: '**Groovy Server Pages** (**GSP**): [https://gsp.grails.org/latest/guide/index.html](https://gsp.grails.org/latest/guide/index.html)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Groovy Server Pages** (**GSP**): [https://gsp.grails.org/latest/guide/index.html](https://gsp.grails.org/latest/guide/index.html)'
- en: 'For Python:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python：
- en: 'Jinja2: [https://pypi.org/project/Jinja2/](https://pypi.org/project/Jinja2/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jinja2: [https://pypi.org/project/Jinja2/](https://pypi.org/project/Jinja2/)'
- en: 'Mako: [https://www.makotemplates.org/](https://www.makotemplates.org/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mako: [https://www.makotemplates.org/](https://www.makotemplates.org/)'
- en: 'Tornado: [https://pypi.org/project/tornado/](https://pypi.org/project/tornado/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Tornado: [https://pypi.org/project/tornado/](https://pypi.org/project/tornado/)'
- en: 'For Ruby:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ruby：
- en: 'ERB: [https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html](https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ERB: [https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html](https://ruby-doc.org/stdlib-3.1.2/libdoc/erb/rdoc/index.html)'
- en: '**system()**: [https://www.rubyguides.com/2018/12/ruby-system/](https://www.rubyguides.com/2018/12/ruby-system/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**system()**: [https://www.rubyguides.com/2018/12/ruby-system/](https://www.rubyguides.com/2018/12/ruby-system/)'
- en: 'Haml: [https://rubygems.org/gems/haml/versions/5.1.2](https://rubygems.org/gems/haml/versions/5.1.2)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Haml: [https://rubygems.org/gems/haml/versions/5.1.2](https://rubygems.org/gems/haml/versions/5.1.2)'
- en: 'Slim: [https://rubygems.org/gems/slim/versions/4.1.0](https://rubygems.org/gems/slim/versions/4.1.0)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Slim: [https://rubygems.org/gems/slim/versions/4.1.0](https://rubygems.org/gems/slim/versions/4.1.0)'
- en: Testing for server-side request forgery
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端请求伪造的测试
- en: Internal and external resources routinely interact with web applications. While
    you would expect only the intended resource to receive the data you supply, improper
    data management might result in SSRF, a kind of injection attack. A successful
    SSRF attack can grant the attacker access to restricted operations, internal services,
    or internal files within the program or the company. In this recipe, we will show
    how to perform an SSRF attack on a backend system to search for an internal IP
    address and subsequently remove the user.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 内部和外部资源经常与 Web 应用程序交互。虽然你会期望只有预定的资源接收到你提供的数据，但不当的数据管理可能导致 SSRF，这是一种注入攻击。成功的
    SSRF 攻击可以让攻击者访问限制性操作、内部服务或程序或公司内部的文件。在本教程中，我们将展示如何对后端系统执行 SSRF 攻击，寻找内部 IP 地址并随后删除用户。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start up your local ZAP tool and log in to your PortSwigger Academy account,
    then go to the *Basic SSRF against another back-end system* lab at [https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system](https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 启动本地 ZAP 工具并登录你的 PortSwigger Academy 账户，然后访问 [https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system](https://portswigger.net/web-security/ssrf/lab-basic-ssrf-against-backend-system)
    上的 *Basic SSRF against another back-end system* 实验。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We’ll utilize the PortSwigger Academy *Basic SSRF versus another back-end system*
    lab in this recipe. SSRF is an attack where an attacker sends malicious requests
    from a susceptible server to a target server, gaining access to otherwise restricted
    resources or information. Backend systems are the infrastructure and components
    that enable a website or application to function. These systems are often invisible
    to the end user and are in charge of functions such as data storage and processing,
    request and response management, and system integration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本食谱中使用 PortSwigger Academy 的 *Basic SSRF versus another back-end system*
    实验。SSRF 是一种攻击，攻击者通过易受攻击的服务器向目标服务器发送恶意请求，从而获取本来受限的资源或信息。后端系统是支撑网站或应用程序正常运行的基础设施和组件。这些系统通常对最终用户不可见，负责数据存储与处理、请求与响应管理以及系统集成等功能。
- en: 'Backend systems include the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 后端系统包括以下内容：
- en: Databases
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Application servers
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器
- en: Integration systems
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成系统
- en: Backend systems, in general, are a significant aspect of a website’s or application’s
    overall architecture and are responsible for most of the behind-the-scenes work
    that allows the program to run successfully.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 后端系统通常是网站或应用程序整体架构的重要组成部分，负责大多数幕后工作，确保程序能够成功运行。
- en: This lab contains a stock check feature that retrieves data from an internal
    system and then scans the internal IP address range for an admin interface, which
    is then used to remove the user Carlos.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验包含一个库存检查功能，该功能从内部系统获取数据，然后扫描内部 IP 地址范围以查找管理接口，接着利用该接口删除用户 Carlos。
- en: 'The following steps walk you through completing the lab and exploiting the
    vulnerability:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导你完成实验并利用该漏洞：
- en: Visit the web application and capture the traffic via a Manual or Automated
    Scan in ZAP.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问网页应用并通过 ZAP 进行手动或自动扫描以捕获流量。
- en: 'Next, visit any product and click on **Check stock**, using **Break Set**,
    intercept the request, or select the path from the **Sites** window, right-clicking
    and going to **Manual Request Editor**, as seen in *Figure 7**.19*:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，访问任何产品并点击 **检查库存**，使用 **Break Set** 拦截请求，或者从 **Sites** 窗口选择路径，右键点击并进入 **Manual
    Request Editor**，如*图 7.19*所示：
- en: '![Figure 7.19 – Locate stockAPI from the Sites window](image/Figure_7.19_B18829.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 从 Sites 窗口定位 stockAPI](image/Figure_7.19_B18829.jpg)'
- en: Figure 7.19 – Locate stockAPI from the Sites window
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 从 Sites 窗口定位 stockAPI
- en: 'Change the **stockApi** parameter value to **http://192.168.0.1:8080/admin/...**,
    which will let us access the administrator’s portal, as shown in *Figure 7**.20*:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **stockApi** 参数值更改为 **http://192.168.0.1:8080/admin/...**，这将允许我们访问管理员门户，如*图
    7.20*所示：
- en: '![Figure 7.20 – The stockAPI request in Manual Request Editor](image/Figure_7.20_B18829.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 手动请求编辑器中的 stockAPI 请求](image/Figure_7.20_B18829.jpg)'
- en: Figure 7.20 – The stockAPI request in Manual Request Editor
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 手动请求编辑器中的 stockAPI 请求
- en: 'Highlight the final octet of the IP address (the number **1**) and right-click
    to open in **Fuzzer** (shown in *Figure 7**.21*):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示 IP 地址的最后一个八位字节（数字**1**），右键点击以在 **Fuzzer** 中打开（如*图 7.21*所示）：
- en: '![Figure 7.21 – The Fuzz stockAPI parameter value](image/Figure_7.21_B18829.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – Fuzz stockAPI 参数值](image/Figure_7.21_B18829.jpg)'
- en: Figure 7.21 – The Fuzz stockAPI parameter value
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – Fuzz stockAPI 参数值
- en: 'In **Fuzz Locations**, click **Add** twice to open a menu and switch **Type**
    to **Numberzz**. Then, fill in the following fields with the values provided:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Fuzz Locations** 中，点击 **添加** 两次以打开菜单，并将 **类型** 切换为 **Numberzz**。然后，按照提供的值填写以下字段：
- en: '**From**: **1**'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从**: **1**'
- en: '**To**: **255**'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到**: **255**'
- en: Click **Add** to complete the payload (shown in *Figure 7**.22* and *Figure
    7**.23*).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 完成负载（如*图 7.22*和*图 7.23*所示）。
- en: 'Click **Start Fuzzer**:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **启动 Fuzzer**：
- en: '![Figure 7.22 – Fuzzing the API endpoint](image/Figure_7.22_B18829.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – 对 API 端点进行 Fuzz 测试](image/Figure_7.22_B18829.jpg)'
- en: Figure 7.22 – Fuzzing the API endpoint
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 对 API 端点进行 Fuzz 测试
- en: '![Figure 7.23 – The Numberzz payload](image/Figure_7.23_B18829.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – Numberzz 负载](image/Figure_7.23_B18829.jpg)'
- en: Figure 7.23 – The Numberzz payload
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – Numberzz 有效载荷
- en: Click on the **Status** column in the Fuzzer **Information** window to sort
    the attack by status code. You will see an entry with a status of **200** that
    showcases there is a successful IP address for an admin page at that location.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **状态** 列在 Fuzzer **信息** 窗口中按状态码对攻击进行排序。你将看到一个状态为 **200** 的条目，展示该位置存在一个成功的管理员页面
    IP 地址。
- en: 'Open the request again in **Manual Request Editor**, and change the path in
    **stockApi** to the following string:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **手动请求编辑器** 中再次打开请求，并将 **stockApi** 中的路径更改为以下字符串：
- en: '[PRE6]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Convert the parameters into HTML-encoded strings.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数转换为 HTML 编码字符串。
- en: Send the request to delete the user.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求以删除用户。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SSRF is a form of attack in which an application that interacts with the internal/external
    network or the host itself is exploited. An example would be the mishandling of
    URL parameter factors or webhook customization, where users specify webhook handlers
    or callback URLs. Attackers can also interact with requests of another service
    to provide specific functionality. Most often, user data is sent to be processed
    by the server and, if improperly handled, can then be used to perform specific
    injection attacks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF 是一种攻击形式，利用与内部/外部网络或主机本身交互的应用程序进行攻击。例如，URL 参数因素或 Webhook 自定义的处理不当，用户指定 Webhook
    处理程序或回调 URL。攻击者还可以通过与其他服务的请求交互来提供特定功能。通常，用户数据被发送到服务器进行处理，如果处理不当，可能会被用来执行特定的注入攻击。
- en: SSRF attacks entail convincing a server to make a request to an external resource
    on the attacker’s behalf. For example, even if a **web application firewall**
    (**WAF**) is blocking regular requests, an attacker may be able to carry out an
    SSRF attack by discovering a means to circumvent the WAF.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: SSRF 攻击涉及说服服务器代表攻击者向外部资源发起请求。例如，即使 **Web 应用防火墙** (**WAF**) 阻止了常规请求，攻击者也可能通过发现绕过
    WAF 的方法来实施 SSRF 攻击。
- en: An attacker might achieve this by utilizing a bypass method to avoid detection
    by the WAF. An attacker, for example, might use URL encoding, Unicode encoding,
    or other ways to change the look of the request in a way that the WAF does not
    identify as malicious. An attacker might also circumvent a WAF by discovering
    a weakness in the application that allows them to launch an SSRF attack.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能通过利用绕过方法来避免被 WAF 检测到。例如，攻击者可能使用 URL 编码、Unicode 编码或其他方式改变请求的外观，使得 WAF 无法识别为恶意请求。攻击者还可能通过发现应用程序中的弱点绕过
    WAF，从而发起 SSRF 攻击。
- en: 'For example, an attacker may discover a weakness in the application’s input
    validation that allows them to inject a URL into a form field that the server
    will execute on their behalf, as shown in *Figure 7**.24*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，攻击者可能会发现应用程序输入验证中的弱点，允许他们将 URL 注入到表单字段中，服务器会代表他们执行该请求，如 *图 7.24* 所示：
- en: '![Figure 7.24 – Diagram of an SSRF attack](image/Figure_7.24_B18829.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.24 – SSRF 攻击示意图](image/Figure_7.24_B18829.jpg)'
- en: Figure 7.24 – Diagram of an SSRF attack
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 – SSRF 攻击示意图
- en: There’s more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: The HTTP protocol is not the only protocol where SSRF can occur. HTTP is used
    first in requests, but if an application performs a second request, it may use
    a variety of other protocols, such as FTP, SMB, SMTP, or others and/or schemes
    such as **file:/**, **data:/**, and **dict:/** and more.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议并不是唯一可能发生 SSRF 攻击的协议。HTTP 首先在请求中使用，但如果应用程序执行第二次请求，它可能会使用多种其他协议，例如 FTP、SMB、SMTP
    或其他协议和/或方案，如 **file:/**、**data:/** 和 **dict:/** 等。
- en: In addition, SSRF is frequently used in cloud environments to gain access to
    and steal credentials or access tokens from metadata services, such as metadata
    servers in AWS or Azure environments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SSRF 经常在云环境中使用，用于获取并窃取凭证或访问令牌，如在 AWS 或 Azure 环境中的元数据服务（如元数据服务器）。
- en: Lastly, consider other attacks, such as **XML External Entity** (**XXE**) that
    can be leveraged to exploit an SSRF vulnerability.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑其他攻击方式，如 **XML 外部实体** (**XXE**)，它可以被用来利用 SSRF 漏洞。
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more information on XXE, visit *Chapter 13*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 XXE 的更多信息，请参阅 *第 13 章*。
