- en: Intel Instruction Set Architecture (ISA)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔指令集架构（ISA）
- en: It may virtually be right to say that any digital device has a specific set
    of instructions. Even a transistor, the foundation stone of modern digital electronics,
    has two instructions, on and off, where each one is represented by 1 or 0 (which
    one of these represents on and off depends on whether the transistor is *n-p-n*
    or *p-n-p*). A processor is constructed from millions of transistors and is, as
    well, controlled by sequences of 1s and 0s (grouped into 8-bit bytes grouped into
    instructions). Fortunately, we do not have to take care of instruction encoding
    (it's the 21st century out there) as assemblers do that for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以说，任何数字设备都有一套特定的指令。甚至一个晶体管，作为现代数字电子学的基石，也有两个指令，开和关，每个指令用1或0表示（哪一个表示开和关取决于晶体管是*n-p-n*还是*p-n-p*）。处理器由数百万个晶体管构成，同样也由1和0的序列控制（这些序列被分组成8位字节，进而组成指令）。幸运的是，我们不必担心指令编码（毕竟现在是21世纪），因为汇编器会为我们做这些事。
- en: Each CPU instruction (and this is right for any CPU, not only Intel based) has
    a mnemonic designation (further simply mnemonic), which you need to learn about
    along with a few simple rules regarding operand sizes (and memory addressing,
    but we will take a deeper look at that in [Chapter 4](7a0e22a2-ba7f-4750-ac01-91e2460ce0cd.xhtml),
    *Memory Addressing Modes*), and this is exactly what we will do in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每条CPU指令（这对于任何CPU都适用，不仅仅是基于英特尔的）都有一个助记符（以下简称助记符），你需要学习这个助记符以及一些关于操作数大小（和内存寻址，具体内容将在[第4章](7a0e22a2-ba7f-4750-ac01-91e2460ce0cd.xhtml)，*内存寻址模式*中深入探讨）的简单规则，这正是我们在本章要做的事情。
- en: 'We will begin by creating a simple Assembly template, which we will use throughout
    the book as a starting point for our code. Then, we will proceed to the actual
    CPU instruction set and get acquainted with the following types of instructions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个简单的汇编模板开始，这个模板将贯穿全书，作为我们代码的起始点。接着，我们将进入实际的CPU指令集，熟悉以下类型的指令：
- en: Data transfer instructions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输指令
- en: Arithmetic instructions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术指令
- en: Floating point instructions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点指令
- en: Execution flow control instructions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行流控制指令
- en: Extensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: Assembly source template
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编源模板
- en: We will start with two 32-bit templates, one for Windows and one for Linux.
    64-bit templates will be added very soon and we will see that they are not much
    different from 32-bit ones. The templates contain some macro instructions and
    directives that will be explained later in the book. As for now, these templates
    are provided with the sole purpose to give you the ability to write simple (and
    not so simple) snippets of code, compile them, and test them in a debugger.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个32位模板开始，一个用于Windows，一个用于Linux。64位模板将很快添加进来，我们会看到它们与32位模板没有太大区别。这些模板包含一些宏指令和指令，这些将在书中稍后解释。至于现在，这些模板仅提供了让你能够编写简单（或不那么简单）代码片段、编译它们并在调试器中测试它们的能力。
- en: The Windows Assembly template (32-bit)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows汇编模板（32位）
- en: A Windows executable consists of several sections (the structure of a PE executable/object
    file will be covered in more detail in [Chapter 9](17490bf0-6e1c-4061-8cd1-339e5a5ec48a.xhtml),
    *Operating System Interface*); usually, one section for code, one for data, and
    one for import data (this contains information on external procedures, which are
    imported from dynamic link libraries). **Dynamic-link libraries** (**DLL**) also
    have an export section, which contains information on procedures/objects publicly
    available in the DLL itself. In our template, we simply define the sections and
    let the assembler do the rest of the work (write headers and so on).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Windows可执行文件由多个部分组成（PE可执行文件/对象文件的结构将在[第9章](17490bf0-6e1c-4061-8cd1-339e5a5ec48a.xhtml)，*操作系统接口*中更详细地讨论）；通常包含一个代码部分，一个数据部分和一个导入数据部分（其中包含有关从动态链接库导入的外部过程的信息）。**动态链接库**（**DLL**）也有一个导出部分，包含该DLL中公开的过程/对象信息。在我们的模板中，我们只是定义这些部分，并让汇编器完成剩余的工作（编写头文件等）。
- en: 'Now, let''s take a look at the template itself. See further explanation of
    PE specifics in the comments:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看模板本身。有关PE特定细节的进一步说明请参见注释：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Linux Assembly template (32-bit)
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux汇编模板（32位）
- en: 'On Linux, although files on disc are divided into sections, executables in
    memory are divided into code and data segments. The following is our template
    for the ELF 32-bit executable for Linux:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，虽然磁盘上的文件被划分为多个部分，但内存中的可执行文件则划分为代码段和数据段。以下是我们的Linux 32位ELF可执行文件模板：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As was mentioned in the preceding code, these two templates will be used as
    a starting point for any code we will write in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面代码所提到的，这两个模板将作为我们在本书中编写的任何代码的起点。
- en: Data types and their definitions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型及其定义
- en: Before we start working with Assembly instructions, we have to know how to define
    data, or, to be more precise, how to tell the assembler which type of data we
    are using.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写汇编指令之前，我们必须知道如何定义数据，或者更准确地说，如何告诉汇编器我们正在使用的数据类型。
- en: 'The Flat Assembler supports six built-in types of data and allows us to either
    define or declare variables. The difference between a definition and a declaration
    in this case is that when we define a variable we also assign a certain value
    to it, but when we declare, we simply reserve space for a certain type of data:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Flat Assembler支持六种内置数据类型，并允许我们定义或声明变量。这里定义和声明的区别在于，当我们定义一个变量时，我们同时为它赋予一个特定的值，而声明时，我们只是为某种数据类型保留空间：
- en: '**Variable definition format**: `[label] definition_directive value(s)`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量定义格式**：`[label] definition_directive value(s)`'
- en: '`label`: This is optional, but addressing an unnamed variable is harder'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是可选的，但引用未命名的变量会更困难。'
- en: 'Variable declaration format: `[label] declaration_directive count`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明格式：`[label] declaration_directive count`
- en: '`label`: This is optional, but addressing an unnamed variable is harder'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是可选的，但引用未命名的变量会更困难。'
- en: '`count`: This tells the assembler how many entries of the type specified in
    `declaration_directive` it should reserve memory for'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：这告诉汇编器它需要为`declaration_directive`中指定的类型预留多少个数据条目'
- en: 'The following table shows definition and declaration directives for built-in
    data types, sorted by size thereof:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了按大小排序的内置数据类型的定义和声明指令：
- en: '| **Size of data type in bytes** | **Definition directive** | **Declaration
    (reservation) directive** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型的字节大小** | **定义指令** | **声明（预留空间）指令** |'
- en: '| 1 | `db` file (includes binary file) | `rb` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `db` 文件（包括二进制文件） | `rb` |'
- en: '| 2 | `dw` `du` (defines unicode character) | `rw` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `dw` `du`（定义unicode字符） | `rw` |'
- en: '| 4 | `dd` | `rd` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `dd` | `rd` |'
- en: '| 6 | `dp` `df` | `rp` `rf` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `dp` `df` | `rp` `rf` |'
- en: '| 8 | `dq` | `rq` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `dq` | `rq` |'
- en: '| 10 | `dt` | `rt` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `dt` | `rt` |'
- en: 'The preceding table lists acceptable data types ordered by their size in bytes,
    which is in the leftmost column. The column in the middle contains the directives
    we use in the Assembly code for definition of data of a certain type. For example,
    if we want to define a byte variable named `my_var`, then we write the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上表列出了按字节大小排序的可接受数据类型，最左侧列出的是这些类型的字节大小。中间的列包含我们在汇编代码中用来定义某种类型数据的指令。例如，如果我们想定义一个名为`my_var`的字节变量，那么我们会写如下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `0x5a` is the value we assign to this variable. In cases where we do
    not need to initialize the variable with any specific value, we write this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`0x5a`是我们为该变量赋予的值。在不需要初始化变量为特定值的情况下，我们可以写成如下方式：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the question mark (`?`) means that the assembler may initialize the memory
    area occupied by this variable to any value (which would typically be `0`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，问号（`?`）意味着汇编器可以将此变量占用的内存区域初始化为任何值（通常为`0`）。
- en: 'There are two directives that require a bit more attention:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个指令需要更多注意：
- en: '`file`: This directive instructs the assembler to include a binary file during
    the compilation.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`：该指令告诉汇编器在编译过程中包含一个二进制文件。'
- en: '`du`: This directive is used just like `db` is used to define characters or
    strings thereof, yet it produces unicode-like characters/strings instead of ASCII.
    The effect is the 0 extension of 8-bit values to 16-bit values. This is rather
    a convenience directive and has to be overridden when a proper transformation
    to unicode is required.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`du`：此指令的使用方法与`db`类似，用于定义字符或其字符串，但它生成的是类似unicode的字符/字符串，而不是ASCII。其效果是将8位值扩展为16位值。这是一个便利指令，当需要进行适当的unicode转换时，必须进行重写。'
- en: 'Directives shown in the rightmost column are used when we want to reserve space
    for a range of data entries of a certain type without specifying the values thereof.
    For example, if we want to reserve space for, let''s say, 12 32-bit integers labeled
    `my_array`, then we would write the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最右侧的指令用于当我们需要为某种类型的数据条目保留空间时，而不需要指定其具体值。例如，如果我们想为12个32位整数（标记为`my_array`）预留空间，那么我们会写如下代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The assembler would then reserve 48 bytes for this array, beginning at a place
    labeled `my_array` in the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器将为这个数组保留48个字节，从代码中标记为`my_array`的位置开始。
- en: Although you will use these directives in the data section most of the time,
    there is no limitation as to where they may be placed. For example, you may (for
    whatever purpose) reserve some space within a procedure, or between two procedures,
    or include a binary file containing precompiled code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分时间你会在数据段中使用这些指令，但它们可以放置在任何地方。例如，你可以（出于任何目的）在一个过程内部、两个过程之间保留一些空间，或者包含一个包含预编译代码的二进制文件。
- en: A debugger
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个调试器
- en: 'We are almost ready to begin the process of instruction set exploration; however,
    there is one more thing that we have not touched yet, as there was no need for
    it--a debugger. There is a relatively wide choice of debuggers out there and you,
    being a developer, have most likely worked with at least one of them. However,
    since we are interested in debugging programs written in the Assembly language,
    I would suggest one of the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好开始指令集探索的过程了；然而，还有一件事情我们还没有涉及，因为没有必要--调试器。市面上有相对较多的调试器可供选择，作为开发者，你很可能至少使用过其中一个。然而，由于我们对调试用汇编语言编写的程序感兴趣，我建议选择以下之一：
- en: '**IDA Pro** ([https://www.hex-rays.com/products/ida/index.shtml](https://www.hex-rays.com/products/ida/index.shtml)):
    Very convenient, but also very expensive. If you have it, good! If not, never
    mind, we have other options. Windows only.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDA Pro** ([https://www.hex-rays.com/products/ida/index.shtml](https://www.hex-rays.com/products/ida/index.shtml))：非常方便，但也非常昂贵。如果你有它，那很好！如果没有，没关系，我们还有其他选择。仅适用于Windows。'
- en: '**OllyDbg** ([http://www.ollydbg.de/version2.html](http://www.ollydbg.de/version2.html)):
    Free debugger/disassembler. More than enough for what we need. Windows only. Unfortunately,
    the 64-bit version of this tool was never finished, meaning that you would not
    be able to use it with 64-bit examples.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OllyDbg** ([http://www.ollydbg.de/version2.html](http://www.ollydbg.de/version2.html))：免费调试器/反汇编器。对我们所需的内容已经足够了。仅适用于Windows。不幸的是，该工具的64位版本从未完成，这意味着你无法将其用于64位示例。'
- en: '**HopperApp** ([https://www.hopperapp.com](https://www.hopperapp.com)): Commercial,
    but very affordable disassembler with GDB frontend. macOS X and Linux.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HopperApp** ([https://www.hopperapp.com](https://www.hopperapp.com))：商业化，但价格非常实惠的反汇编器，带有GDB前端。macOS
    X和Linux。'
- en: '**GDB** (**GNU DeBugger**): Freely available, works on Windows, Linux, mac
    OS X, and others. Although GDB is a command-line tool, it is quite easy to use.
    The only limitation is that the disassembler''s output is in AT&T syntax.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GDB**（**GNU调试器**）：免费提供，在Windows、Linux、mac OS X等系统上运行。虽然GDB是一个命令行工具，但使用起来相当容易。唯一的限制是反汇编器的输出是AT&T语法。'
- en: You are free to choose either one of these or a debugger that is not mentioned
    on the list (and there are relatively many). There is only one important factor
    to consider while selecting a debugger--you should feel comfortable with it, as
    running your code in a debugger, seeing everything that happens in registers of
    a processor or in memory, would greatly enhance your experience while writing
    code in Assembly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由选择这些中的任何一个，或者选择列表中未提及的调试器（有相对较多的选择）。在选择调试器时只有一个重要因素需要考虑--你应该感到舒适，因为在调试器中运行代码，查看处理器寄存器或内存中发生的一切，将极大地增强你在汇编语言编写代码时的体验。
- en: The instruction set summary
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令集摘要
- en: We have finally got to the interesting part--the instruction set itself. Unfortunately,
    describing each and every instruction of a modern Intel-based processor would
    require a separate book, but since there is already such a book ([http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)),
    we will not multiply things without need and will concentrate on instruction groups
    rather than on individual instructions. At the end of the chapter, we will implement
    AES128 encryption for the sake of demonstration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了有趣的部分--指令集本身。不幸的是，描述现代基于英特尔的处理器的每一条指令都需要一本单独的书，但由于已经有这样一本书（[http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)），我们不会无谓地增加东西，而是集中在指令组而不是单个指令上。在本章末尾，我们将实现AES128加密以进行演示。
- en: General purpose instructions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用指令
- en: 'The general purpose instructions perform basic operations such as data movement,
    arithmetic, flow control, and so on. They are grouped by their purpose:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通用指令执行基本操作，如数据移动、算术运算、流程控制等。它们按功能分组：
- en: Data transfer instructions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输指令
- en: Binary arithmetic instructions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制算术指令
- en: Decimal arithmetic instructions
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制算术指令
- en: Logical instructions
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑指令
- en: Shift and rotate instructions
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位与旋转指令
- en: Bit/byte manipulation instructions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位/字节操作指令
- en: Flow control instructions
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制指令
- en: String manipulation instructions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作指令
- en: ENTER/LEAVE instructions
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENTER/LEAVE指令
- en: Flag control instructions
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志控制指令
- en: Miscellaneous instructions
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项指令
- en: The division of instructions into groups is the same as in the Intel Software
    Developer's Manual.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的分组与《Intel软件开发者手册》中所述相同。
- en: Data transfer instructions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传输指令
- en: Data transfer instructions, as the name of the group suggests, are used to transfer
    data between registers or between registers and memory. Some of them may have
    an immediate value as their source operand. The following example illustrates
    their usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输指令，顾名思义，用于在寄存器之间或寄存器与内存之间传输数据。它们中的一些可能将立即数作为源操作数。以下示例说明了它们的使用。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s take a closer look at the instructions used with the example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下与示例一起使用的指令：
- en: '**PUSH**: This instructs the processor to store the value of the operand onto
    a stack and decrements stack pointer (ESP register on 32-bit systems and RSP register
    on 64-bit ones).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUSH**：该指令要求处理器将操作数的值存储到堆栈中，并递减堆栈指针（32位系统中是ESP寄存器，64位系统中是RSP寄存器）。'
- en: '**MOV**: This is the most commonly used instruction for transferring data:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MOV**：这是最常用的数据传输指令：'
- en: It moves data between registers of the same size
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在相同大小的寄存器之间移动数据
- en: It loads a register with either an immediate value or a value read from memory
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将立即数或从内存读取的值加载到寄存器中
- en: It stores the content of a register to memory
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将寄存器的内容存储到内存中
- en: It stores the immediate value to memory
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将立即数存储到内存中
- en: '**MOVZX**: This is less powerful than MOV by means of addressing modes, as
    it may only transfer data from register to register or from memory to register,
    but it has its special feature--the value being transferred is converted to a
    wider (one that uses more bits) one and is zero extended. As to the addressing
    modes supported by this instruction, it may only do the following:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MOVZX**：这条指令在寻址模式上不如MOV强大，因为它只能在寄存器与寄存器之间或内存与寄存器之间传输数据，但它有一个特殊的功能——被传输的值会转换为更宽（使用更多位）的值，并且会进行零扩展。至于该指令支持的寻址模式，它只能执行以下操作：'
- en: It moves the byte value from register or memory to a word-sized register and
    extends the resulting value with zeroes (one byte would be added)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将字节值从寄存器或内存移动到字大小的寄存器，并用零扩展结果值（将添加一个字节）
- en: It moves byte value from register or memory to a double word-sized register,
    in which case three bytes would be added to the original value and the value itself
    would be extended with zeroes
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将字节值从寄存器或内存移动到一个双字节大小的寄存器，在这种情况下，原始值将添加三个字节，并用零扩展该值
- en: It moves word-sized value from register or memory to a double word-sized register,
    adding two bytes and filling them with the extension value of 0
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将字节大小的值从寄存器或内存移动到双字节大小的寄存器中，添加两个字节并用0的扩展值填充
- en: '**MOVSX** is similar to MOVZX; however, the extended bits are filled with the
    sign bit of the source operand.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MOVSX** 类似于MOVZX；然而，扩展位被源操作数的符号位填充。'
- en: '**BSWAP/MOVBE** The BSWAP instruction is the easiest way to switch the endianness
    of a value; however, it is not really a transfer instruction as it only rearranges
    data within a register. The BSWAP instruction only works on 32/64-bit operands.
    MOVBE is a more convenient instruction for swapping byte order as it also moves
    data between the operands. This instruction works on 16, 32, and 64-bit operands.
    It cannot move data from register to register.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSWAP/MOVBE**：BSWAP指令是切换值的字节序最简单的方法；然而，它实际上并不是一条传输指令，因为它仅在寄存器内重新排列数据。BSWAP指令仅适用于32位/64位操作数。MOVBE是一条更方便的字节顺序交换指令，因为它不仅可以交换字节顺序，还可以在操作数之间移动数据。该指令适用于16位、32位和64位操作数，但无法在寄存器之间移动数据。'
- en: '**POP**: This retrieves values previously stored on stack. The only operand
    of this instruction is the destination where the value should be stored, and it
    may be a register or a location in memory. This instruction increments the stack
    pointer register as well.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POP**：此指令从栈中检索先前存储的值。此指令的唯一操作数是值应存储的目标，可以是寄存器或内存位置。此指令还会增加栈指针寄存器。'
- en: Binary Arithmetic Instructions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制算术指令
- en: These instructions perform basic arithmetic operations. Operands may be byte,
    word, double-word or quad-word registers, memory locations, or immediate values.
    They all modify CPU flags according to the result of operation thereof, which,
    in turn, lets us change the execution flow depending on the values of certain
    flags.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令执行基本的算术操作。操作数可以是字节、字、双字或四字寄存器、内存位置或立即数。它们都会根据操作结果修改 CPU 标志，这反过来允许我们根据某些标志的值改变执行流程。
- en: 'Let us take a look at a few basic arithmetic instructions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个基本的算术指令：
- en: '**INC**: This is short for increment. This instruction adds 1 to the value
    of its operand. Obviously, the inc instruction, or its counterpart, the `dec`
    instruction, may not be used with immediate values. The `inc` instruction affects
    certain CPU flags. For example, consider that we take a register (let it be the
    EAX register for the sake of simplicity), set it to 0, and execute it, as follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INC**：这是增量的缩写。此指令将 1 加到其操作数的值上。显然，`inc` 指令或其对应的 `dec` 指令不能与立即数一起使用。`inc`
    指令会影响某些 CPU 标志。例如，考虑我们取一个寄存器（为了简化起见，假设是 EAX 寄存器），将其设置为 0，并执行如下操作：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, EAX would equal to 1 and ZF (zero flag, remember?) would be set
    to 0, meaning that the operation resulted in a non-zero value. On the other hand,
    if we load the EAX register with the `0xffffffff` value and increment it with
    the `inc` instruction, the register will become zero and, since zero is the result
    of the latest operation, ZF would be set then (will have value of `1`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，EAX 的值将为 1，ZF（零标志，记得吗？）将被设置为 0，这意味着操作结果是一个非零值。另一方面，如果我们将 EAX 寄存器加载为 `0xffffffff`，并使用
    `inc` 指令将其增量 1，则寄存器将变为零，并且由于零是最新操作的结果，ZF 将被设置（值为 `1`）。
- en: '**ADD**: This performs simple addition, adding the source operand to the destination
    operand and storing the resulting value in the destination operand. This instruction
    affects several CPU flags as well. In the following example, we will add `0xffffffff`
    to the EBX register, which has been set to `1`. The result of such an operation
    would be a 33-bit value, but as we only have 32 bits to store the result, the
    extra bit would go into the carry flag. Such a mechanism, in addition to being
    useful for control of the execution flow, may also be used when adding two big
    numbers (may be even hundreds of bits wide) as we can then process the numbers
    by smaller portions (of, for example, 32 bits).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADD**：该指令执行简单的加法操作，将源操作数加到目标操作数，并将结果存储在目标操作数中。此指令还会影响几个 CPU 标志。在以下示例中，我们将
    `0xffffffff` 加到已设置为 `1` 的 EBX 寄存器。此操作的结果将是一个 33 位的值，但由于我们只能用 32 位存储结果，多余的一位将进入进位标志。此机制不仅对控制执行流程有用，还可以在加法操作两个大数时使用（可能是几百位数），因为我们可以通过较小的部分（例如
    32 位）来处理这些数字。'
- en: '**ADC**: Talking about addition of big numbers, the `adc` instruction is the
    one that allows us to add the value of the carry flag, as set by a previous operation,
    to the summation of additional two values. For example, if we want to add `0x802597631`
    and `0x4fe013872`, we would then add `0x02597631` and `0xfe013872` first, resulting
    in `0x005aaea3` and a set carry flag. Then, we would add 8, 4 and, the value of
    the carry flag:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADC**：谈到大数加法，`adc` 指令允许我们将由先前操作设置的进位标志的值，添加到额外两个值的和中。例如，如果我们想要加 `0x802597631`
    和 `0x4fe013872`，我们首先将 `0x02597631` 和 `0xfe013872` 相加，结果是 `0x005aaea3`，并且进位标志被设置。接下来，我们将加上
    8、4 和进位标志的值：'
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This would result in `8 + 4 + 1` (where 1 is the implicit operand--the value
    of the CF) `= 0xd`, thus, the overall result would be `0xd005aaea3`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到 `8 + 4 + 1`（其中 1 是隐式操作数——CF 的值）`= 0xd`，因此，最终结果将是 `0xd005aaea3`。
- en: 'The following example illustrates these instructions in more detail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例更详细地说明了这些指令：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Decimal arithmetic instructions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十进制算术指令
- en: 'In about 15 years of Assembly development and reverse engineering software,
    I encountered these instructions exactly once, and that was in the college. However,
    it would be right to mention them, for a few reasons:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大约15年的汇编语言开发和反向工程软件过程中，我只遇到过这些指令一次，那是在大学时。然而，提到它们是正确的，原因有几个：
- en: Instructions like AAM and AAD may sometimes be used as a smaller variant of
    multiplication and division, since they allow immediate operand. They're smaller
    as they allow generation of smaller code due to their encoding.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像AAM和AAD这样的指令有时会作为乘法和除法的较小变体使用，因为它们允许立即操作数。它们较小，因为它们的编码方式可以生成更小的代码。
- en: Sequences like AAD 0 (which is division by zero) may be used as an exception
    trigger in certain protection schemes.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像AAD 0（即除以零）这样的指令可以用作某些保护方案中的异常触发器。
- en: Not mentioning them would be historically wrong.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提及这些指令将是历史性的错误。
- en: Decimal arithmetic instructions are illegal on 64-bit platforms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制算术指令在64位平台上是非法的。
- en: First of all, what is BCD? It is **Binary coded decimal** (**BCD**) and is,
    in fact, an attempt to ease the conversion of binary representations of numbers
    to their ASCII equivalent and vice versa, as well as adding the ability to perform
    basic arithmetic operations on decimal numbers represented in a hexadecimal form
    (not their hexadecimal equivalents!).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是BCD？它是**二进制编码十进制** (**BCD**)，实际上是为了简化将数字的二进制表示转换为其ASCII等效值，反之亦然，同时增加了对以十六进制形式表示的十进制数执行基本算术操作的能力（不是它们的十六进制等价物！）。
- en: 'There are two types of BCD: packed and unpacked. Packed BCD represents a decimal
    number using nibbles of a single byte. For example, the number 12 would be represented
    as 0x12\. Unpacked BCD, on the other hand, uses bytes for representation of individual
    digits (for example, 12 converts to 0x0102).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: BCD有两种类型：压缩BCD和非压缩BCD。压缩BCD使用单字节的nibbles来表示十进制数。例如，数字12将表示为0x12。另一方面，非压缩BCD使用字节表示单独的数字（例如，12转换为0x0102）。
- en: However, given the fact that these instructions have not been changed since
    their first appearance, they only operate on values stored in a single byte, for
    packed BCD, or values stored in a single word, for unpacked BCD. More than this,
    these values should be stored only in the AL register for packed BCD and the AX
    register (or, to say it in a more precise way, in the AH:AL pair) for unpacked
    BCD.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到这些指令自首次出现以来并未发生变化，它们仅作用于存储在单个字节中的值（对于压缩BCD）或存储在单个字中的值（对于非压缩BCD）。更重要的是，这些值应仅存储在AL寄存器中（对于压缩BCD），或存储在AX寄存器中（更精确地说，是存储在AH:AL对寄存器中，针对非压缩BCD）。
- en: 'There are only six BCD instructions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只有六个BCD指令：
- en: '**Decimal Adjust after Addition** (**DAA**): This instruction is specific to
    packed BCD. Since the addition of two packed BCD numbers would not necessarily
    result in a valid packed BCD number, the invocation of DAA fixes the problem by
    making the adjustments needed for converting a result into a proper packed BCD
    value. For example, let''s add 12 and 18\. Normally, the result would be 30, but
    if we add `0x12` and `0x18`, the result would be `0x2a`. The following example
    illustrates the procedure for such a calculation:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法后的十进制调整** (**DAA**)：该指令专用于压缩BCD。由于两个压缩BCD数字的加法结果不一定是有效的压缩BCD数字，因此调用DAA可以通过进行必要的调整，将结果转换为正确的压缩BCD值。例如，让我们加上12和18。通常结果是30，但如果我们加上`0x12`和`0x18`，结果将是`0x2a`。以下示例说明了此类计算的过程：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Decimal Adjust after Subtraction** (**DAS**): This instruction performs similar
    adjustments after subtracting two packed BCD numbers. Let''s add some more lines
    to the preceding code (AL still contains `0x30`):'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法后的十进制调整** (**DAS**)：此指令在减去两个压缩BCD数字后执行类似的调整。让我们在前面的代码中再添加一些行（AL仍然包含`0x30`）：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**ASCII Adjust after Addition** (**AAA**): This instruction is similar to DAA,
    yet it works on unpacked BCD numbers (meaning, the AX register). Let''s look at
    the following example, where we still add 18 to 12, but we do that with the unpacked
    BCD:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法后的ASCII调整** (**AAA**)：此指令类似于DAA，但它作用于非压缩BCD数字（即，AX寄存器）。让我们来看以下示例，在其中我们仍然加上18到12，但我们使用非压缩BCD来执行此操作：'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The resulting value may easily be converted to the ASCII representation by adding
    `0x3030`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果值可以通过加上`0x3030`轻松转换为ASCII表示。
- en: '**ASCII Adjust after Subtraction** (**AAS**): This instruction is similar to
    DAS, but operates on unpacked BCD numbers. We may continue to add code to the
    preceding example (The AX register still has the value of `0x0300`). Let''s subtract
    3, which should, at the end, give us the value of `0x0207`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法后的 ASCII 调整** (**AAS**): 该指令类似于 DAS，但作用于解包的 BCD 数字。我们可以继续在前面的示例中添加代码（AX
    寄存器仍然有 `0x0300` 的值）。让我们减去 3，最终得到的结果应该是 `0x0207`：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What went wrong then? In fact, nothing went wrong; it is just that the internal
    implementation of the AAS instruction caused carry (and, as we may see in a debugger,
    the CF is in deed set) or, to be more precise, a borrow occurred. That is why
    it is better for our convenience to finalize this with the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题出在哪里呢？事实上，并没有出什么问题；只是 AAS 指令的内部实现导致了进位（如我们在调试器中所见，CF 标志确实被设置了），或者更确切地说，发生了借位。这就是为什么我们为了方便，最好做如下处理：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We end up with `0x0207`, which is the unpacked BCD representation of 27--exactly
    the result we were expecting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果为 `0x0207`，它是 27 的解包 BCD 表示——正是我们所期待的结果。
- en: '**ASCII Adjust AX after Multiply** (**AAM**): Result of the multiplication
    of two unpacked BCD numbers, as well, requires certain adjustments to be made
    in order to be in an unpacked BCD form. However, what we have to remember first
    of all is the size limitation implied by these operations. As we are limited to
    the AX register, the maximum value of a multiplicand is 9 (or `0x09`), meaning
    that, being limited to AX with the resulting value, we are limited to one byte
    with multiplicands. Let''s say we want to multiply 8 by 4 (which would be `0x08
    * 0x04`); naturally, the result would be `0x20` (the hexadecimal equivalent of
    32), which is not even close to being an unpacked BCD represented number. The
    `aam` instruction solves this problem by converting the value of the AL register
    to the unpacked BCD format and stores it in AX:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法后的 ASCII 调整** (**AAM**): 两个解包 BCD 数字相乘的结果，也需要进行某些调整，以使其成为解包 BCD 格式。但我们首先要记住的是这些操作所涉及的大小限制。由于我们仅限于
    AX 寄存器，所以乘数的最大值是 9（或 `0x09`），意味着在 AX 中存储结果时，我们只能处理一个字节的乘数。假设我们想将 8 乘以 4（即 `0x08
    * 0x04`）；自然，结果将是 `0x20`（32 的十六进制表示），这远远不是一个解包 BCD 表示的数字。`aam` 指令通过将 AL 寄存器的值转换为解包
    BCD 格式并存储在 AX 中来解决这个问题：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we see, the multiplication of two unpacked BCD bytes results in an unpacked
    BCD word.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两字节解包 BCD 的相乘结果是一个解包 BCD 字。
- en: '**ASCII Adjust AX before Division** (**AAD**): This is exactly as the name
    of the instruction suggests--it should adjust the value of the AX register before
    division. The size limitations are just the same as in AAM. The AX register still
    contains `0x0302` after the previous example, so let''s divide it by 4:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法前的 ASCII 调整** (**AAD**): 如同指令的名称所示，它应该在除法之前调整 AX 寄存器的值。其大小限制与 AAM 中相同。前一个示例后，AX
    寄存器仍包含 `0x0302`，所以我们来将其除以 4：'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we see, although these instructions may seem to be somewhat convenient, there
    are better ways to convert numbers between their ASCII notation and their binary
    equivalents, not to mention the fact that regular arithmetic instructions are
    much more convenient to use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，尽管这些指令看似有点方便，但在数字之间转换 ASCII 表示法和二进制等价物时，有更好的方法，更不用说常规算术指令使用起来要方便得多了。
- en: Logical instructions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑指令
- en: This group contains instructions for bitwise logical operations which you, being
    a developer, already know. These are NOT, OR, XOR, and AND operations. However,
    while high-level languages do make a difference between bitwise and logical operators
    (for example, bitwise AND (&) and logical AND (&&) in C), they are all the same
    on the Assembly level and are quite commonly used in conjunction with the EFlags
    register (or RFlags on 64-bit systems).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一组指令包含了位操作逻辑运算，这些你作为开发者肯定已经知道。这些包括 NOT、OR、XOR 和 AND 运算。然而，虽然高级语言区分位运算符和逻辑运算符（例如，在
    C 中，位与 (&) 和逻辑与 (&&)），但它们在汇编层面上是相同的，并且通常与 EFlags 寄存器（或 64 位系统上的 RFlags）一起使用。
- en: 'For example, consider the following simple snippet in C that checks for a specific
    bit being set and conditionally executes certain code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 C 语言的简单代码片段，它检查某个特定位是否已设置，并根据条件执行某些代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It may be implemented in Assembly like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以这样在汇编中实现：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One of the many other applications of these instructions is the finite field
    arithmetic, where XOR stands for addition and AND stands for multiplication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的众多其他应用之一是有限域算术，在其中XOR代表加法，AND代表乘法。
- en: Shift and rotate instructions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移位和旋转指令
- en: Instructions of this group let us move bits within the destination operand,
    which is something we only partially have in high-level languages. We can shift,
    but we cannot rotate, neither can we implicitly specify arithmetic shifts (the
    selection of arithmetic or a logical shift is usually performed by high-level
    language implementation based on the type of data the operations are carried on).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这一组指令允许我们在目标操作数内移动位，这是高级语言中仅部分支持的功能。我们可以移位，但不能旋转，也不能隐式指定算术移位（算术移位或逻辑移位的选择通常由高级语言实现，依据操作的数据类型决定）。
- en: Using shift instructions, in addition to their primary role of moving bits left
    or right a certain number of positions, is a simpler way to perform integer multiplication
    and division of the destination operand by powers of two. Additionally, two special
    shift instructions exist that let us move certain amount of bits from one location
    to another--to be more precise, from a register to another register or to a memory
    location.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移位指令，除了它们主要的作用是将位向左或向右移动一定位置外，它也是一种执行目标操作数乘除以2的幂的整数乘除法的简便方法。此外，还有两条特殊的移位指令，允许我们将一定数量的位从一个位置移动到另一个位置——更精确地说，是从一个寄存器移动到另一个寄存器或内存位置。
- en: 'Rotation instructions allow us, as the name suggests, to rotate bits from one
    end of the destination operand to another. It is important to mention that bits
    may be rotated through the CF (carry flag), meaning that the bit that is shifted
    out is stored in the CF while the value of the CF is shifted into the operand
    on the other side. Let''s consider the following example, one of the simplest
    integrity control algorithms, CRC8:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转指令允许我们，如其名称所示，将位从目标操作数的一端旋转到另一端。值得一提的是，位可以通过CF（进位标志位）进行旋转，这意味着被移出的位会存储到CF中，同时CF的值会被旋转到操作数的另一侧。我们来看下面的例子，这是最简单的完整性控制算法之一：CRC8：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The body of the loop in the preceding snippet was intentionally left without
    comments as we would like to take a closer look at what is happening there.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码段中的循环体故意没有添加注释，因为我们希望更详细地观察那里发生了什么。
- en: The first instruction of the loop `shl al, 1` shifts out the most significant
    bit of the value we are calculating CRC8 for and stores it into the CF. The next
    instruction `rcl bl, 1` stores the value of the CF (the bit we shifted out of
    our bit stream) into the BL register. The following two instructions do the same
    for the DL register, storing the most significant bit into BH. The side effect
    of the `rcl` instruction is that the most significant bits of the first BL and
    then the BH register are moved to the CF. Although it is of no importance in this
    specific case, we should not forget about this when rotating through the CF. At
    the end, this means after 8 iterations, the preceding code provides us with the
    CRC8 value for `0x16` (which is `0xE5`) in the DL register.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一条指令`shl al, 1`将我们正在计算CRC8值的最重要位移出，并将其存储到CF标志位中。接下来的指令`rcl bl, 1`将CF（我们从比特流中移出的位）的值存入BL寄存器。接下来的两条指令做同样的事情，将最重要的位存入DL寄存器并保存到BH寄存器。`rcl`指令的副作用是，BL和BH寄存器中的最重要位被移到CF标志位中。虽然在这个特定的例子中这并不重要，但在旋转CF标志位时我们应该记住这一点。最终，这意味着在8次迭代后，前面的代码为我们提供了`0x16`（即`0xE5`）的CRC8值，并将其存储在DL寄存器中。
- en: 'The two shift and rotate instructions mentioned in the example have their right-sided
    counterparts:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中提到的两个移位和旋转指令有它们右侧的对应指令：
- en: '**SHR**: This shifts bits to the right, while saving the last bit shifted out
    in the CF'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHR**：这会将位向右移，同时将最后移出的位保存在CF中。'
- en: '**RCR**: This rotates bits to the right through the carry flag'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RCR**：这通过进位标志位将位旋转到右边。'
- en: 'There are a few additional instructions in this group that we cannot skip:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些我们不能跳过的额外指令：
- en: '**SAR**: This shifts bits to the right while "dragging" the sign bit instead
    of simply filling the "vacant" bits with zeroes.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAR**：这会将位移向右，同时“拖动”符号位，而不是简单地用零填充“空缺”的位。'
- en: '**SAL**: This is an arithmetic shift to the left. It is not truly an instruction,
    rather a mnemonic used for a programmer''s convenience. The assembler generates
    the same encoding as for SHL.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAL**：这是一个算术左移。它不是真正的指令，而是为了方便程序员使用的助记符。汇编程序会生成与SHL相同的编码。'
- en: '**ROR**: This rotates bits to the right. Each bit being shifted out to the
    right and shifted in to the left is also stored in the CF.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROR**：这会将位向右旋转。每个被右移的位都被移入左侧，并且也存储在CF中。'
- en: 'Finally, as it was mentioned earlier, the two special shift instructions are
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如前面提到的，两个特殊的移位指令如下：
- en: '**SHLD**: This shifts a certain number of left-side (most significant) bits
    from a register into another register or into a memory location'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHLD**：将一定数量的左侧（最高有效）位从一个寄存器移入另一个寄存器或内存位置。'
- en: '**SHRD**: This shifts a certain number of right-side (least significant) bits
    from a register into another register or into a memory location'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHRD**：将一定数量的右侧（最低有效）位从一个寄存器移入另一个寄存器或内存位置。'
- en: Another new instruction in the previous example is TEST, but it will be explained
    in the next section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的另一个新指令是TEST，但它将在下一节中解释。
- en: Bit and byte instructions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位与字节指令
- en: Instructions of this group are those that let us manipulate individual bits
    within an operand and/or set bytes in accordance with the sate of flags in the
    EFlags/RFlags register.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这一组指令是让我们能够在操作数内操作单个位和/或根据EFlags/RFlags寄存器中的标志状态设置字节的指令。
- en: With high-level languages that implement bit fields, it is quite easy to access
    individual bits even if we want to perform more complex operations than just scan,
    test, set or reset, as provided by Intel Assembly. However, with high-level languages
    having no bit fields we have to implement certain constructs in order to have
    access to individual bits and that is where Assembly is more convenient.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现位字段的高级语言中，即使我们想执行比仅仅扫描、测试、设置或重置更复杂的操作，也很容易访问单个位，正如Intel汇编语言提供的那样。然而，对于没有位字段的高级语言，我们必须实现某些构造，以便能够访问单个位，这也是汇编语言更为方便的地方。
- en: 'While bit and byte instructions may have a variety of applications, let''s
    consider them (just a few of them) in the context of the CRC8 example. It would
    not be completely right to say that using these instructions in that example would
    have significantly optimized it; after all, it would let us get rid of a single
    instruction, making the implementation of the algorithm look a bit clearer. Let''s
    see how `crc_loop` would have changed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然位和字节指令可能有多种应用，但让我们在CRC8示例的上下文中考虑它们（仅仅是其中几个）。说这些指令在该示例中会显著优化它并不完全正确；毕竟，它只会让我们去掉一条指令，使得算法的实现看起来更清晰。我们来看看`crc_loop`会如何变化：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code is quite self-explanatory, but let''s take a closer look
    at the set of bit instructions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常直观，但让我们更详细地了解一下这一组位指令：
- en: '**BT**: This stores a bit from the destination operand (bit base) to the CF.
    The bit is identified by the index specified in the source operand.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BT**：将目标操作数（位基）中的一位存储到CF。该位通过源操作数中指定的索引来标识。'
- en: '**BTS**: This is the same as BT, but it also sets the bit in the destination
    operand.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTS**：这与BT相同，但它还会设置目标操作数中的位。'
- en: '**BTR**: This is the same as BT, but it also resets the bit in the destination
    operand.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTR**：这与BT相同，但它还会重置目标操作数中的位。'
- en: '**BTC**: This is the same as BT, but it also inverts (complements) the bit
    in the destination operand.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTC**：这与BT相同，但它还会反转（补码）目标操作数中的位。'
- en: '**BSF**: This stands for **bit scan forward**. It searches the source operand
    for the least significant bit that is set. The index of the bit, if found, is
    returned in the destination operand. If the source operand is all zeros, then
    the value for the destination operand is not defined and ZF is set.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSF**：这代表**位扫描前移**。它会在源操作数中查找设置的最低有效位。如果找到，该位的索引将返回到目标操作数中。如果源操作数全为零，则目标操作数的值未定义，并且ZF被置为1。'
- en: '**BSR**: This stands for **bit scan reverse**. It searches the source operand
    for the most significant bit that is set. The index of the bit, if found, is returned
    in the destination operand. If the source operand is all zeros, then the value
    of the destination operand is not defined and ZF is set.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSR**：这代表**位扫描反向**。它会在源操作数中查找设置的最高有效位。如果找到，该位的索引将返回到目标操作数中。如果源操作数全为零，则目标操作数的值未定义，并且ZF被置为1。'
- en: '**TEST**: This instruction makes it possible to check for several bits being
    set at the same time. To put it simply, the TEST instruction performs the logical
    AND operation, sets flags accordingly, and discards the result.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TEST**：此指令使得可以同时检查多个位是否被设置。简而言之，TEST指令执行逻辑与运算，设置相应的标志，并丢弃结果。'
- en: 'Byte instructions are all of a form SETcc, where **cc** stands for **condition
    code**. The following are the condition codes on the Intel platform, as specified
    in section B.1 Condition Codes of *Appendix B EFlags Condition Codes* of Intel
    64 and IA-32 Architectures Software Developer''s Manual Volume 1:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字节指令的格式通常为SETcc，其中**cc**表示**条件码**。以下是Intel平台上的条件码，参照《Intel 64 和 IA-32 架构软件开发者手册
    第1卷 附录B EFlags 条件码》的B.1 条件码部分：
- en: '| **Mnemonic (cc)** | **Condition tested for** | **Status flags setting** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **助记符 (cc)** | **测试条件** | **状态标志设置** |'
- en: '| O | Overflow | OF = 1 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| O | 溢出 | OF = 1 |'
- en: '| NO | No overflow | OF = 0 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| NO | 无溢出 | OF = 0 |'
- en: '| B NAE | Below Neither above nor equal | CF = 1 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| B NAE | 小于 既不大于也不等于 | CF = 1 |'
- en: '| NB AE | Not below Above or equal | CF = 1 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| NB AE | 不小于或等于 | CF = 1 |'
- en: '| E Z | Equal Zero | ZF = 1 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| E Z | 等于 零 | ZF = 1 |'
- en: '| NE NZ | Not equal Not zero | ZF = 0 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| NE NZ | 不等于 不为零 | ZF = 0 |'
- en: '| BE NA | Below or equal Not above | (CF or ZF) = 1 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| BE NA | 小于或等于 不大于 | (CF 或 ZF) = 1 |'
- en: '| NBE A | Neither below nor equal Above | (CF or ZF) = 0 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| NBE A | 既不小于也不等于 大于 | (CF 或 ZF) = 0 |'
- en: '| S | Sign | SF = 1 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| S | 符号 | SF = 1 |'
- en: '| NS | No sign | SF = 0 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| NS | 无符号 | SF = 0 |'
- en: '| P PE | Parity Parity even | PF = 1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| P PE | 奇偶校验 偶校验 | PF = 1 |'
- en: '| NP PO | No parity Parity odd | PF = 0 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| NP PO | 无奇偶校验 奇校验 | PF = 0 |'
- en: '| L NGE | Less Neither greater nor equal | (SF xor OF) = 1 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| L NGE | 小于 既不大于也不等于 | (SF xor OF) = 1 |'
- en: '| NL GE | Not less Greater or equal | (SF xor OF) = 0 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| NL GE | 不小于 大于或等于 | (SF xor OF) = 0 |'
- en: '| LE NG | Less or equal Not greater | ((SF xor OF) or ZF) = 1 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| LE NG | 小于或等于 不大于 | ((SF xor OF) 或 ZF) = 1 |'
- en: '| NLE G | Not less or equal Greater | ((SF xor OF) or ZF) = 0 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| NLE G | 不小于或等于 大于 | ((SF xor OF) 或 ZF) = 0 |'
- en: So, as we may conclude using the preceding table and the `setc` instruction
    from the CRC8 example, it instructs the processor to set `bl` (and `bh`) to 1
    if the C condition is true, which means CF == 1.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过前面的表格和CRC8示例中的`setc`指令，我们可以得出结论：它指示处理器在C条件为真时将`bl`（和`bh`）设置为1，即CF == 1。
- en: Execution flow transfer instructions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行流程转移指令
- en: 'Instructions of this group make it possible to easily branch the execution,
    whether in accordance to a specific condition designated by the EFlags/RFlags
    register or completely unconditionally, and may, therefore, be divided into two
    groups:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这一组指令使得无论是依据EFlags/RFlags寄存器中指定的特定条件，还是完全无条件的，执行流程都可以轻松地进行分支，因此可以将其分为两组：
- en: 'Unconditional execution flow transfer instructions:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无条件执行流程转移指令：
- en: '**JMP**: Perform unconditional jump to an explicitly specified location. This
    loads the instruction pointer register with the address of the specified location.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JMP**：执行无条件跳转到明确指定的位置。这会将指令指针寄存器加载为指定位置的地址。'
- en: '**CALL**: This instruction is used to call a procedure. This pushes the address
    of the next instruction onto the stack and loads the instruction pointer with
    the address of the first instruction in the called procedure.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CALL**：此指令用于调用一个过程。它将下一条指令的地址推送到栈中，并将指令指针加载为被调用过程中的第一条指令地址。'
- en: '**RET**: This instruction performs a return from procedure. It pops the value
    stored on the stack into the instruction pointer register. When used at the end
    of a procedure, it returns the execution to instruction following the CALL instruction.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RET**：此指令用于从过程返回。它将栈中存储的值弹出到指令指针寄存器。当在过程末尾使用时，它将执行返回到CALL指令后的指令。'
- en: The RET instruction may have a two-bytes value as its operand, in which case
    the value defines the amount of bytes occupied by the operands that were passed
    to the procedure on stack. The stack pointer is then automatically adjusted by
    adding the amount of bytes.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: RET指令可能会有一个2字节的操作数，在这种情况下，该值定义了在栈上传递给过程的操作数占用的字节数。然后，栈指针会通过加上字节数自动调整。
- en: '**INT**: This instruction causes a software interrupt.'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INT**：此指令触发软件中断。'
- en: The use of this instruction on Windows while programming in ring 3 is quite
    rare. It may even be safe to assume that the only usage is INT3--software breakpoint.
    On 32-bit Linux, however, it is used for invocation of system calls.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Windows上编程时，在环3中使用此指令相当罕见。甚至可以安全地假设唯一的使用场景是INT3——软件断点。然而，在32位Linux上，它用于调用系统调用。
- en: 'Conditional execution flow transfer instructions:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件执行流转移指令：
- en: '**Jcc**: This is the conditional variant of the JMP instruction, where **cc**
    stands for **condition code**, which may be one of the condition codes listed
    in the preceding table. For example, look at the `jz .noxor` line from the CRC8
    example.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jcc**：这是JMP指令的条件变种，其中**cc**代表**条件码**，可以是前面表格中列出的条件码之一。例如，查看CRC8示例中的`jz .noxor`行。'
- en: '**JCXZ**: This is a special version of the conditional jump instruction, which
    uses the CX register as a condition. The jump is only executed if the CX register
    contains 0.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JCXZ**：这是条件跳转指令的特殊版本，使用CX寄存器作为条件。只有当CX寄存器的值为0时，跳转才会执行。'
- en: '**JECXZ**: This is the same as above, but it operates on the ECX register.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JECXZ**：这与上面相同，但它作用于ECX寄存器。'
- en: '**JRCXZ**: This is the same as above, but it operates on the RCX register (long
    mode only).'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JRCXZ**：这与上面相同，但它作用于RCX寄存器（仅限长模式）。'
- en: '**LOOP**: A loop with ECX as a counter, this decrements ECX and, if the result
    is not 0, loads the instruction pointer register with the address of the loop
    label. We have already used this instruction in the CRC8 example.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOOP**：一个以ECX作为计数器的循环，这将递减ECX，并且如果结果不为0，则将指令指针寄存器加载为循环标签的地址。我们已经在CRC8示例中使用了这个指令。'
- en: '**LOOPZ**/**LOOPE**: This is the loop with ECX as a counter while ZF = 1.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOOPZ**/**LOOPE**：这是一个以ECX作为计数器的循环，前提是ZF = 1。'
- en: '**LOOPNZ**/**LOOPNE**: This is the loop with ECX as a counter while ZF = 0.'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOOPNZ**/**LOOPNE**：这是一个以ECX作为计数器的循环，前提是ZF = 0。'
- en: 'Let''s, for the sake of example, implement the CRC8 algorithm as a procedure
    (insert the following into the code section of the relevant 32-bit template):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们实现CRC8算法作为一个过程（将以下代码插入到相关32位模板的代码部分）：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: String instructions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串指令
- en: 'This is an interesting group of instructions that operate on strings of bytes,
    words, double words, or quad words (long mode only). These instructions have implicit
    operands only:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的指令组，操作的是字节、字、双字或四字的字符串（仅限长模式）。这些指令只有隐式操作数：
- en: The source address should be loaded into the ESI (RSI for long mode) register
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源地址应加载到ESI寄存器中（长模式下为RSI寄存器）
- en: The destination address should be loaded into the EDI (RDI for long mode) register
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标地址应加载到EDI寄存器中（长模式下为RDI寄存器）
- en: One of the EAX (for example, AL and AX) register variations is used with all
    of them except the MOVS* and CMPS* instructions
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有指令中，除了MOVS*和CMPS*指令之外，都使用了EAX（例如，AL和AX）寄存器的某个变体。
- en: The number of iterations (if any) should be in ECX (only used with the REP*
    prefix)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代次数（如果有的话）应位于ECX中（仅与REP*前缀一起使用）
- en: 'ESI and/or EDI registers are automatically incremented by one for byte, two
    for word, and four for double word data. The direction of these operations (whether
    they increment or decrement ESI/EDI) is controlled by the direction flag (DF)
    in the EFlags register: DF = 1 : decrement ESI/EDI DF = 0 : increment ESI/EDI.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字节数据，ESI和/或EDI寄存器自动增加1；对于字数据，增加2；对于双字数据，增加4。这些操作的方向（增或减ESI/EDI）由EFlags寄存器中的方向标志（DF）控制：DF
    = 1：递减ESI/EDI，DF = 0：递增ESI/EDI。
- en: 'These instructions may be divided into five groups. In fact, to put it in a
    more precise manner, there are five instructions supporting four data sizes each:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以分为五组。实际上，更准确地说，有五个指令，每个指令支持四种数据大小：
- en: '**MOVSB**/**MOVSW**/**MOVSD**/**MOVSQ**: These move byte, word, double word,
    or quad word in memory from the location pointed by ESI/RSI to the location pointed
    by EDI/RDI. The instruction''s suffix specifies the size of data to be moved.
    Setting ECX/RCX to the amount of data items to be moved and prefixing it with
    the REP* prefix instructs the processor to execute this instruction ECX times
    or while the condition used with the REP* prefix (if any) is true.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MOVSB**/**MOVSW**/**MOVSD**/**MOVSQ**：这些指令将内存中的字节、字、双字或四字从由ESI/RSI指向的位置移动到由EDI/RDI指向的位置。指令的后缀指定要移动的数据大小。将ECX/RCX设置为要移动的数据项数量，并在其前加上REP*前缀，指示处理器执行该指令ECX次，或者在使用REP*前缀的条件（如果有的话）为真时执行。'
- en: '**CMPSB**/**CMPSW**/**CMPSD**/**CMPSQ**: These compare the data pointed by
    the ESI/RSI register to the data pointed by the EDI/RDI register. The iteration
    rules are the same as for MOVS* instruction.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMPSB**/**CMPSW**/**CMPSD**/**CMPSQ**：这些指令将 ESI/RSI 寄存器指向的数据与 EDI/RDI 寄存器指向的数据进行比较。迭代规则与
    MOVS* 指令相同。'
- en: '**SCASB**/**SCASW**/**SCASD**/**SCASQ**: These scan sequences of data items
    (size thereof is specified by the instruction''s suffix) pointed by the EDI/RDI
    register for a value specified in AL, AX, EAX, or RAX, depending on the mode (protected
    or long) and the instruction''s suffix. Iterations rules are the same as those
    for the MOVS* instruction.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCASB**/**SCASW**/**SCASD**/**SCASQ**：这些指令扫描由 EDI/RDI 寄存器指向的数据项序列（其大小由指令的后缀指定），查找存储在
    AL、AX、EAX 或 RAX 中的值，具体取决于操作模式（保护模式或长模式）和指令的后缀。迭代规则与 MOVS* 指令相同。'
- en: '**LODSB**/**LODSW**/**LODSD**/**LODSQ**: These load AL, AX, EAX, or RAX (depending
    on operation mode and instruction''s suffix) with a value from memory, pointed
    by the ESI/RSI register. The iteration rules are the same as those for the MOVS*
    instruction.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LODSB**/**LODSW**/**LODSD**/**LODSQ**：这些指令将 AL、AX、EAX 或 RAX（取决于操作模式和指令的后缀）从内存中加载值，该值由
    ESI/RSI 寄存器指向。迭代规则与 MOVS* 指令相同。'
- en: '**STOSB**/**STOSW**/**STOSD**/**STOSQ**: These store the value of the AL, AX,
    EAX, or RAX registers to the memory location pointed by the EDI/RDI register.
    These iteration rules are the same as those for the MOVS* instruction.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STOSB**/**STOSW**/**STOSD**/**STOSQ**：这些指令将 AL、AX、EAX 或 RAX 寄存器的值存储到由 EDI/RDI
    寄存器指向的内存位置。这些迭代规则与 MOVS* 指令相同。'
- en: 'All of the preceding instructions have the explicit-operands form without a
    suffix, but in such a case, we need to specify the size of the operands. While
    the operands themselves may not be changed and therefore would always be ESI/RSI
    and EDI/RDI, all we may change is the size of the operand. The following is an
    example of such case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的指令都有没有后缀的显式操作数形式，但在这种情况下，我们需要指定操作数的大小。虽然操作数本身不会改变，因此始终是 ESI/RSI 和 EDI/RDI，但我们可以改变的只是操作数的大小。以下是这种情况的示例：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following example shows typical usage of the SCAS* instruction--scanning
    a sequence of, in this particular case, bytes for specific value, which is stored
    in the AL register. The other instructions are similar in their usage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 SCAS* 指令的典型用法——扫描一个字节序列（在此特定情况下）以查找存储在 AL 寄存器中的特定值。其他指令的使用方法类似。
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `rep` prefix, used in the preceding example, indicates to the processor
    that it should execute the prefixed command using the ECX register as a counter
    (in the same manner as it is used by the LOOP* instructions). However, there is
    one more optional condition designated by ZF (zero flag). Such a condition is
    specified by the condition suffix attached to REP. For example, using it with
    the E or Z suffix would instruct the processor to check ZF for being set before
    each iteration. Suffixes NE or NZ would instruct the processor to check ZF for
    being reset before each iteration. Consider the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`rep` 前缀，在前面的示例中使用，表示处理器应使用 ECX 寄存器作为计数器来执行带前缀的命令（就像它在 LOOP* 指令中使用一样）。但是，还有一个由
    ZF（零标志）指定的可选条件。这样的条件由附加在 REP 后面的条件后缀指定。例如，使用 E 或 Z 后缀会指示处理器在每次迭代之前检查 ZF 是否已设置。后缀
    NE 或 NZ 会指示处理器在每次迭代之前检查 ZF 是否已重置。考虑以下示例：'
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This would instruct the processor to keep comparing two sequences of bytes (pointed
    by the EDI/RDI and ESI/RSI registers) while they are equal and ECX is not zero.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示处理器在两个字节序列相等且 ECX 不为零时，持续比较由 EDI/RDI 和 ESI/RSI 寄存器指向的字节序列。
- en: ENTER/LEAVE
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENTER/LEAVE
- en: According to the Intel manual for developers, *these instructions provide machine-language
    support for procedure calls in block-structured languages;* however, they are
    very useful for Assembly developers as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据英特尔开发者手册，*这些指令为块结构语言中的过程调用提供机器语言支持；*然而，它们对汇编开发者同样非常有用。
- en: 'When we implement a procedure, we have to take care of the creation of the
    stack frame where we store the procedure''s variables, storing the value of ESP
    and then restoring all that before we leave a procedure. These two instructions
    can do all that work for us:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现一个过程时，我们必须处理栈帧的创建，存储过程变量，存储 ESP 的值，然后在离开过程之前恢复这些内容。这两条指令可以为我们完成所有这些工作：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code is equivalent to the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码等价于以下代码：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Flag control instructions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志控制指令
- en: 'The EFlags register contains information on certain aspects of the last ALU
    operation as well as certain settings of the CPU (for example, the direction of
    string instructions); however, we have the mechanism for controlling the content
    of this register, up to the level of a single flag, with the following instructions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: EFlags 寄存器包含有关最后一次 ALU 操作的某些信息以及 CPU 的某些设置（例如，字符串指令的方向）；然而，我们有机制通过以下指令控制该寄存器的内容，甚至是单个标志：
- en: '**Set**/**clear carry flag** (**STC**/**CLC**): We may want to have the CF
    set or reset prior to certain operations.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**/**清除进位标志** (**STC**/**CLC**)：在某些操作之前，我们可能需要设置或重置 CF。'
- en: '**Complement the carry flag** (**CMC**): This instruction inverts the value
    of the CF.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补充进位标志** (**CMC**)：该指令反转 CF 的值。'
- en: '**Set**/**clear direction flag** (**STD**/**CLD**): We may use these instructions
    to set or reset the DF in order to define whether ESI/EDI (RSI/RDI) should increment
    or decrement with string instructions.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**/**清除方向标志** (**STD**/**CLD**)：我们可以使用这些指令来设置或重置 DF，以确定在字符串指令中 ESI/EDI（RSI/RDI）是递增还是递减。'
- en: '**Load flags into the AH register** (**LAHF**): There are certain flags, for
    example, ZF, that do not have associated instructions for direct modification,
    therefore, we may load the Flags register into AH, modify the corresponding bit,
    and reload the Flags register with the modified value.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将标志加载到 AH 寄存器** (**LAHF**)：某些标志（例如 ZF）没有直接修改的相关指令，因此我们可以将 Flags 寄存器加载到 AH
    中，修改相应的位，并用修改后的值重新加载 Flags 寄存器。'
- en: '**Store the AH register into flags** (**SAHF**): This instruction stores the
    value of AH register into the Flags register.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 AH 寄存器存储到标志寄存器** (**SAHF**)：该指令将 AH 寄存器的值存储到标志寄存器中。'
- en: '**Set**/**clear the interrupt flag** (**STI**/**CLI**) (not in user land):
    These instructions are used on the operating system-level to enable/disable interrupts.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**/**清除中断标志** (**STI**/**CLI**)（非用户空间）：这些指令用于操作系统级别的中断使能/禁用。'
- en: '**Push Flags**/**EFlags**/**RFlags register onto the stack** (**PUSHF**/**PUSHFD**/**PUSHFQ**):
    LAHF/SAHF instructions may not be sufficient for inspection/modification of certain
    flags in the Flags/EFlags/RFlags register. With the PUSHF* instruction, we gain
    access to other bits (flags).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将标志**/**EFlags**/**RFlags 寄存器推送到堆栈** (**PUSHF**/**PUSHFD**/**PUSHFQ**)：LAHF/SAHF
    指令可能不足以检查/修改 Flags/EFlags/RFlags 寄存器中的某些标志。通过使用 PUSHF* 指令，我们可以访问其他位（标志）。'
- en: '**Retrieve Flags**/**EFlags**/**RFlags register from the stack** (**POPF**/**POPFD**/**POPFQ**):
    These reload Flags/EFlags/RFlags register with the new value from the stack.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从堆栈恢复标志**/**EFlags**/**RFlags 寄存器** (**POPF**/**POPFD**/**POPFQ**)：这些指令将从堆栈中重新加载
    Flags/EFlags/RFlags 寄存器的新值。'
- en: Miscellaneous instructions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项指令
- en: 'There are a few instructions without any particular category assigned to them,
    which are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些指令没有特别指定的类别，具体如下：
- en: '**Load effective address** (**LEA**): This instruction calculates the effective
    address specified with one of the processor''s addressing modes in the source
    operand and stores it in the destination operand. It is also frequently used instead
    of the ADD instruction when terms are specified as parts of the addressing mode.
    The following example code shows both cases:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载有效地址** (**LEA**)：该指令根据处理器的寻址模式，在源操作数中计算有效地址，并将其存储到目标操作数中。当寻址模式中指定的项需要计算时，它也常常作为
    ADD 指令的替代使用。以下示例代码展示了这两种情况：'
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**No operation** (**NOP**): As the name states, this instruction performs no
    operation and is often used for filling the gaps between aligned procedures.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无操作** (**NOP**)：顾名思义，该指令不执行任何操作，通常用于填充对齐过程之间的空白。'
- en: '**Processor identification** (**CPUID**): Depending on the value of the operand
    (in EAX), this instruction returns CPU identification information. This instruction
    is available only if the ID flag in the EFlags register (bit 21) is set.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器识别** (**CPUID**)：根据操作数（在 EAX 中）的值，该指令返回 CPU 的识别信息。只有当 EFlags 寄存器中的 ID
    标志（第 21 位）被设置时，才可以使用该指令。'
- en: FPU instructions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FPU 指令
- en: 'FPU instructions are executed by the x87 **floating-point unit** (**FPU**)
    and operate on floating point, integer, or binary coded decimal values. These
    instructions are grouped by their purpose:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: FPU 指令由 x87 **浮点单元** (**FPU**) 执行，处理浮点、整数或二进制编码十进制值。这些指令根据它们的用途进行分组：
- en: FPU data transfer instructions
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPU 数据传输指令
- en: FPU basic arithmetic instructions
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPU 基本算术指令
- en: FPU comparison instructions
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPU 比较指令
- en: FPU load constant instructions
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPU 加载常量指令
- en: FPU control instructions
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPU控制指令
- en: Another important aspect of the FPU operation is the fact that, unlike the registers
    of the processor, floating point registers are organized in the form of a stack.
    Instructions like `fld` are used to push the operand onto the top of the stack,
    instructions like `fst` are used for reading a value from the top of the stack,
    and instructions like `fstp` are used for popping the value from the top of the
    stack and moving other values toward the top.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: FPU操作的另一个重要方面是，与处理器的寄存器不同，浮点寄存器是以堆栈的形式组织的。像`fld`这样的指令用于将操作数压入堆栈顶部，像`fst`这样的指令用于从堆栈顶部读取值，而像`fstp`这样的指令则用于将值从堆栈顶部弹出，并将其他值向顶部移动。
- en: 'The following example shows the calculation of the circumference for a circle
    with radius of `0.2345`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了计算半径为`0.2345`的圆的周长：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Extensions
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Since the first Intel microprocessor, technology has significantly evolved
    and so has the complexity of the processor architecture. The initial set of instructions,
    although it was and still is quite powerful, is not enough for some tasks (and
    here we have to admit that the number of such tasks is growing as time goes by).
    The solution adopted by Intel is nice and quite user friendly: **Instruction Set
    Architecture Extensions** (**ISA Extensions**). Intel has gone a long way from
    **MMX** (unofficially, **MultiMedia eXtension**) to SSE4.2, AVX, and AVX2 extensions,
    which introduced support for 256-bit data processing and AVX-512, which allows
    the processing of 512-bit data and extends the number of usable SIMD registers
    to 32\. All of these are SIMD extensions, where SIMD stands for single instruction
    multiple data. In this section, we will particularly pay attention to the AES-NI
    extension and partially to SSE (which will be covered in more detail in [Chapter
    5](81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml), *Parallel Data Processing*).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第一个Intel微处理器问世以来，技术发展显著，处理器架构的复杂性也大大增加。最初的一套指令，虽然现在仍然非常强大，但已无法满足某些任务的需求（在这里我们不得不承认，随着时间的推移，这类任务的数量正在增加）。Intel采用的解决方案非常好，而且相当用户友好：**指令集架构扩展**（**ISA扩展**）。从**MMX**（非官方地称为**多媒体扩展**）到SSE4.2、AVX和AVX2扩展，Intel走了很长一段路，这些扩展引入了对256位数据处理的支持，以及AVX-512，后者允许处理512位数据，并将可用的SIMD寄存器数量扩展到32个。所有这些都是SIMD扩展，SIMD代表单指令多数据。在本节中，我们将特别关注AES-NI扩展，并部分关注SSE（将在[第5章](81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml)中详细讲解，*并行数据处理*）。
- en: AES-NI
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AES-NI
- en: '**AES-NI** stands for **Advanced Encryption Standard New Instructions**, an
    extension initially proposed by Intel in 2008 for speeding up AES algorithm implementations.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**AES-NI**代表**高级加密标准新指令**，这是Intel在2008年首次提出的扩展，旨在加速AES算法的实现。'
- en: 'The following code checks whether AES-NI is supported by the CPU:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查CPU是否支持AES-NI：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instructions in this extension are rather simple and few:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展中的指令相对简单且数量较少：
- en: '**AESENC**: This performs one round of AES encryption on 128-bit data using
    a 128-bit round key for all encryption rounds except the last round'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESENC**：此指令对128位数据执行AES加密的一轮，使用128位轮密钥，适用于除最后一轮以外的所有加密轮次'
- en: '**AESENCLAST**: This performs the last round of AES encryption on 128-bit data'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESENCLAST**：此指令对128位数据执行AES加密的最后一轮'
- en: '**AESDEC**: This performs one round of AES decryption on 128-bit data using
    a 128-bit round key for all decryption rounds except the last round'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESDEC**：此指令对128位数据执行AES解密的一轮，使用128位轮密钥，适用于除最后一轮以外的所有解密轮次'
- en: '**AESDECLAST**: This performs the last round of AES decryption on 128-bit data'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESDECLAST**：此指令对128位数据执行AES解密的最后一轮'
- en: '**AESKEYGENASSIST**: This assists in the generation of an AES round key using
    an 8-bit round constant (RCON)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESKEYGENASSIST**：此指令帮助使用8位轮常量（RCON）生成AES轮密钥'
- en: '**AESIMC**: This performs the inverse mix column transformation on a 128-bit
    round key'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AESIMC**：此指令对128位轮密钥执行逆混合列转换'
- en: SSE
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSE
- en: 'SSE stands for Streaming SIMD Extension, which allows, as the name suggest,
    processing of multiple data with a single instruction, which is best seen in the
    following example code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: SSE代表流式SIMD扩展，顾名思义，它允许通过单一指令处理多个数据，最典型的例子如下代码所示：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example program
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例程序
- en: As you have noticed, the previous two sections (AES-NI and SSE) were left without
    proper examples. The reason is that the best way to demonstrate the abilities
    of both extensions would be to mix them in a single program. In this section,
    we will implement a simple AES-128 encryption algorithm with the help of the two.
    AES encryption is one the classic examples of an algorithm that would definitely
    benefit from parallel processing of data offered by SSE.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到，前两节（AES-NI和SSE）没有适当的示例。原因在于，展示这两种扩展功能的最佳方式是将它们混合在一个程序中。在这一节中，我们将借助这两个扩展实现一个简单的AES-128加密算法。AES加密是一个经典的例子，显然会从SSE提供的数据并行处理中受益。
- en: 'We will use the templates we prepared in the beginning of this chapter, thus,
    all we have to do is write the following code in place of this comment:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在本章开头准备的模板，因此，我们只需要在这条评论的位置写下以下代码：
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code runs equally well on both Windows and Linux, so no other preparations
    required:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Windows和Linux上运行都一样，因此无需其他准备：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following should be placed in the data section/segment:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容应放置在数据段/段落中：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We began this chapter with creation of two templates--one for a 32-bit Windows
    executable and the other for a 32-bit Linux executable. While there are certain
    parts of both templates that may still be unclear, let that bother you not, as
    we will cover each and every aspect thereof when the time comes. You may use these
    templates as a skeleton for your own code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以创建两个模板开始本章——一个用于32位Windows可执行文件，另一个用于32位Linux可执行文件。虽然这两个模板中有些部分可能仍不清楚，但请不要为此烦恼，因为我们会在适当的时候逐一讲解它们。你可以将这些模板作为自己代码的骨架。
- en: The most significant part of the chapter, however, was dedicated to the Intel
    Instruction Set Architecture itself. It was, of course, a very brief overview
    as there was no need to describe each and every instruction--Intel did the job
    releasing their Programmer's Manual, which contains over three thousand pages.
    Instead, a decision was made to provide only the basic information and help us
    achieve certain level of acquaintance with Intel instruction set.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的部分，然而，是专门介绍了Intel指令集架构本身。当然，这只是一个非常简短的概述，因为没有必要描述每一条指令——Intel通过发布其程序员手册完成了这项工作，该手册包含超过三千页内容。因此，决定只提供基本信息，帮助我们对Intel指令集有一个基本的了解。
- en: We ended the chapter by implementing the AES128 encryption algorithm with the
    aid of AES-NI extension, which makes the process of AES128 encryption/decryption
    significantly simpler and easier.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后，我们借助AES-NI扩展实现了AES128加密算法，这使得AES128加密/解密过程变得显著更简单和更容易。
- en: Now, when we understand the instructions, we are ready to proceed further to
    the memory organization and data and code addressing modes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们理解了这些指令后，我们准备继续深入学习内存组织以及数据和代码寻址模式。
