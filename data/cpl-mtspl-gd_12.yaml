- en: Reinventing Metasploit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新发明Metasploit
- en: We have covered the basics of Metasploit, so now we can move further into the
    underlying coding part of the Metasploit framework. We will start with the basics
    of Ruby programming to understand various syntaxes and its semantics. This chapter
    will make it easy for you to write Metasploit modules. In this chapter, we will
    see how we can design and fabricate various Metasploit modules with the functionality
    of our choice. We will also look at how we can create custom post-exploitation
    modules, which will help us gain better control of the exploited machine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Metasploit的基础知识，现在我们可以进一步了解Metasploit框架的底层编码部分。我们将从Ruby编程的基础知识开始，以了解各种语法和语义。本章将使您更容易编写Metasploit模块。在本章中，我们将看到如何设计和制作各种具有我们选择功能的Metasploit模块。我们还将看看如何创建自定义后渗透模块，这将帮助我们更好地控制被利用的机器。
- en: Consider a scenario where the number of systems under the scope of the penetration
    test is massive, and we crave a post-exploitation feature such as downloading
    a particular file from all the exploited systems. Manually, downloading a specific
    file from each system is not only time-consuming, but inefficient. Therefore,
    in a scenario like this, we can create a custom post-exploitation script that
    will automatically download the file from all of the compromised systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个情景，渗透测试范围内的系统数量庞大，我们渴望一个后渗透功能，比如从所有被利用的系统中下载特定文件。手动从每个系统下载特定文件不仅耗时，而且低效。因此，在这种情况下，我们可以创建一个自定义后渗透脚本，它将自动从所有被攻陷的系统中下载文件。
- en: 'This chapter kicks off with the basics of Ruby programming in the context of
    Metasploit, and ends with developing various Metasploit modules. In this chapter,
    we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以Metasploit上下文中的Ruby编程的基础知识开始，并以开发各种Metasploit模块结束。在本章中，我们将涵盖：
- en: The basics of Ruby programming in the context of Metasploit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Metasploit的上下文中了解Ruby编程的基础知识
- en: Exploring modules in Metasploit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Metasploit中的模块
- en: Writing custom scanners, brute force, and post-exploitation modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义扫描器、暴力破解和后渗透模块
- en: Coding Meterpreter scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Meterpreter脚本
- en: Understanding the syntaxes and semantics of Metasploit modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Metasploit模块的语法和语义
- en: Performing the impossible with **RailGun** by using DLLs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DLLs通过**RailGun**执行不可能的任务
- en: Now, let's understand the basics of Ruby programming and gather the required
    essentials we need to code the Metasploit modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解Ruby编程的基础知识，并收集我们编写Metasploit模块所需的必要要素。
- en: 'Before we delve deeper into coding Metasploit modules, we must have knowledge
    on the core features of Ruby programming that are required to design these modules.
    Why do we need Ruby for Metasploit? The following key points will help us understand
    the answer to this question:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入编写Metasploit模块之前，我们必须了解Ruby编程的核心功能，这些功能是设计这些模块所需的。为什么我们需要Ruby来开发Metasploit？以下关键点将帮助我们理解这个问题的答案：
- en: Constructing an automated class for reusable code is a feature of the Ruby language
    that matches the needs of Metasploit
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用代码的自动化类是Ruby语言的一个特性，符合Metasploit的需求
- en: Ruby is an object-oriented style of programming
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby是一种面向对象的编程风格
- en: Ruby is an interpreter-based language that is fast and reduces development time
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby是一种基于解释器的语言，速度快，减少开发时间
- en: Ruby - the heart of Metasploit
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby - Metasploit的核心
- en: Ruby is indeed the heart of the Metasploit framework. However, what exactly
    is Ruby? According to the official website, Ruby is a simple and powerful programming
    language and was designed by Yokihiru Matsumoto in 1995\. It is further defined
    as a dynamic, reflective, and general-purpose object-oriented programming language
    with functions similar to Perl.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby确实是Metasploit框架的核心。但是，Ruby到底是什么？根据官方网站，Ruby是一种简单而强大的编程语言，由松本行弘于1995年设计。它进一步被定义为一种动态、反射和通用的面向对象的编程语言，具有类似Perl的功能。
- en: 'You can download Ruby for Windows/Linux from: [https://rubyinstaller.org/downloads/](https://rubyinstaller.org/downloads/).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下网址下载Windows/Linux的Ruby：[https://rubyinstaller.org/downloads/](https://rubyinstaller.org/downloads/)。
- en: 'You can refer to an excellent resource for learning Ruby practically at: [http://tryruby.org/levels/1/challenges/0](http://tryruby.org/levels/1/challenges/0).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到一个学习Ruby实践的优秀资源：[http://tryruby.org/levels/1/challenges/0](http://tryruby.org/levels/1/challenges/0)。
- en: Creating your first Ruby program
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个Ruby程序
- en: Ruby is an easy-to-learn programming language. Now, let's start with the basics
    of Ruby. Remember that Ruby is a broad programming language, and covering all
    of the capabilities of Ruby will push us beyond the scope of this book. Therefore,
    we will only stick to the essentials that are required in designing Metasploit
    modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是一种易于学习的编程语言。现在，让我们从Ruby的基础知识开始。请记住，Ruby是一种广泛的编程语言，覆盖Ruby的所有功能将超出本书的范围。因此，我们只会坚持设计Metasploit模块所需的基本要素。
- en: Interacting with the Ruby shell
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Ruby shell交互
- en: Ruby offers an interactive shell, and working with it will help us understand
    the basics. So, let's get started. Open the CMD/Terminal and type `irb` to launch
    the Ruby interactive shell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby提供了一个交互式shell，与之一起工作将帮助我们了解基础知识。所以，让我们开始吧。打开CMD/Terminal并键入`irb`以启动Ruby交互式shell。
- en: 'Let''s input something into the Ruby shell and see what happens; suppose I
    type in the number `2`, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Ruby shell中输入一些内容，看看会发生什么；假设我输入数字`2`，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The shell simply returns the value. Let''s give another input, such as one
    with the addition operator, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: shell只是返回值。让我们再输入一些内容，比如带有加法运算符的内容，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that if we input numbers in an expression style, the shell returns
    the result of the expression.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，如果我们以表达式的形式输入数字，shell会返回表达式的结果。
- en: 'Let''s perform some functions on the string, such as storing the value of a
    string in a variable, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对字符串执行一些功能，例如将字符串的值存储在变量中，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After assigning values to both variables, `a` and `b`, let''s see what happens
    when we issue `a` and `a+b` on the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在为变量`a`和`b`分配值之后，让我们看看当我们在控制台上输入`a`和`a+b`时会发生什么：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that when we typed in `a` as the input, it reflected the value stored
    in the variable named `a`. Similarly, `a+b` gave us `a` and `b` concatenated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到当我们输入`a`时，它反映了存储在名为`a`的变量中的值。同样，`a+b`给了我们连接的`a`和`b`。
- en: Defining methods in the shell
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在shell中定义方法
- en: 'A method or a function is a set of statements that will execute when we make
    a call to it. We can declare methods easily in Ruby''s interactive shell, or we
    can declare them using scripts. Knowledge of methods is important when working
    with Metasploit modules. Let''s see the syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 方法或函数是一组语句，当我们调用它时将执行。我们可以在Ruby的交互式shell中轻松声明方法，也可以使用脚本声明方法。在处理Metasploit模块时，了解方法是很重要的。让我们看看语法：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To define a method, we use `def` followed by the method name, with arguments
    and expressions in parentheses. We also use an `end` statement, following all
    of the expressions to set an end to the method''s definition. Here, `arg` refers
    to the arguments that a method receives. Also, `expr` refers to the expressions
    that a method receives or calculates inline. Let''s have a look at an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个方法，我们使用`def`后跟方法名，括号中包含参数和表达式。我们还使用`end`语句，跟随所有表达式以设置方法定义的结束。在这里，`arg`指的是方法接收的参数。此外，`expr`指的是方法接收或计算的表达式。让我们看一个例子：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We defined a method named `xorops`, which receives two arguments named `a`
    and `b`. Furthermore, we XORed the received arguments and stored the results in
    a new variable called `res`. Finally, we returned the result using the `return`
    statement:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`xorops`的方法，它接收名为`a`和`b`的两个参数。此外，我们对接收的参数进行了异或操作，并将结果存储在一个名为`res`的新变量中。最后，我们使用`return`语句返回结果：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see our function printing out the correct value by performing the XOR
    operation. Ruby offers two different functions to print the output: `puts` and
    `print`. When it comes to the Metasploit framework, the `print_line` function
    is primarily used. However, symbolizing success, status, and errors can be done
    using `print_good`, `print_status`, and `print_error` statements, respectively.
    Let''s look at some examples here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的函数通过执行异或操作打印出了正确的值。Ruby提供了两种不同的函数来打印输出：`puts`和`print`。当涉及到Metasploit框架时，主要使用`print_line`函数。然而，可以使用`print_good`、`print_status`和`print_error`语句来表示成功、状态和错误。让我们看一些例子：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These `print` methods, when used with Metasploit modules, will produce the
    following output that depicts the green `+` symbol for good, the blue `*` for
    denoting status messages, and the red `-` symbol representing errors:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`print`方法在与Metasploit模块一起使用时，将产生以下输出：绿色的`+`符号表示良好，蓝色的`*`表示状态消息，红色的`-`表示错误：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will see the workings of various `print` statement types in the latter half
    of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后半部分看到各种`print`语句类型的工作方式。
- en: Variables and data types in Ruby
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的变量和数据类型
- en: A variable is a placeholder for values that can change at any given time. In
    Ruby, we declare a variable only when required. Ruby supports numerous variable
    data types, but we will just discuss the ones relevant to Metasploit. Let's see
    what they are.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是一个可以随时更改值的占位符。在Ruby中，我们只在需要时声明变量。Ruby支持许多变量数据类型，但我们只讨论与Metasploit相关的类型。让我们看看它们是什么。
- en: Working with strings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Strings are objects that represent a stream or sequence of characters. In Ruby,
    we can assign a string value to a variable with ease, as seen in the previous
    example. By merely defining the value in quotation marks or a single quotation
    mark, we can assign a value to a string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是表示字符流或序列的对象。在Ruby中，我们可以轻松地将字符串值赋给变量，就像在前面的例子中看到的那样。只需在引号或单引号中定义值，我们就可以将值赋给字符串。
- en: 'It is recommended to use double quotation marks because if single quotations
    are used, it can create problems. Let''s have a look at the problems that may
    arise:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用双引号，因为如果使用单引号，可能会出现问题。让我们看看可能出现的问题：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that when we used a single quotation mark, it worked. However, when
    we tried to put `Msf's` instead of the value `Msf`, an error occurred. This is
    because it read the single quotation mark in the `Msf's` string as the end of
    single quotations, which is not the case; this situation caused a syntax-based
    error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到当我们使用单引号时，它可以正常工作。然而，当我们尝试将`Msf's`替换为值`Msf`时，出现了错误。这是因为它将`Msf's`字符串中的单引号解释为单引号的结束，这并不是事实；这种情况导致了基于语法的错误。
- en: Concatenating strings
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'We will need string concatenation capabilities throughout our journey in dealing
    with Metasploit modules. We will have multiple instances where we need to concatenate
    two different results into a single string. We can perform string concatenation
    using the `+` operator. However, we can elongate a variable by appending data
    to it using the `<<` operator:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Metasploit模块时，我们将需要字符串连接功能。我们将有多个实例需要将两个不同的结果连接成一个字符串。我们可以使用`+`运算符执行字符串连接。但是，我们可以使用`<<`运算符向变量附加数据来延长变量：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that we started by assigning the value `"Nipun"` to the variable
    `a`, and then appended `"loves"` and `"Metasploit"` to it using the `<<` operator.
    We can see that we used another variable, `b`, and stored the `"and plays counter
    strike"` value in it. Next, we simply concatenated both of the values using the
    + operator and got the complete output as `"Nipun loves Metasploit and plays counter
    strike"`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们首先将值`"Nipun"`赋给变量`a`，然后使用`<<`运算符将`"loves"`和`"Metasploit"`附加到它上。我们可以看到我们使用了另一个变量`b`，并将值`"and
    plays counter strike"`存储在其中。接下来，我们简单地使用+运算符连接了这两个值，并得到了完整的输出`"Nipun loves Metasploit
    and plays counter strike"`。
- en: The substring function
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子字符串函数
- en: 'It''s quite easy to find the substring of a string in Ruby. We just need to
    specify the start index and length along the string, as shown in the following
    example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中找到字符串的子字符串非常容易。我们只需要在字符串中指定起始索引和长度，如下例所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The split function
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分函数
- en: 'We can split the value of a string into an array of variables using the `split`
    function. Let''s have a look at a quick example that demonstrates this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`split`函数将字符串的值拆分为变量数组。让我们看一个快速示例来演示这一点：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that we have split the value of a string from the `","` position
    into a new array, `b`. The `"mastering,metasploit"` string now forms the 0th and
    1st element of the array, `b`, containing the values `"mastering"` and `"metasploit"`,
    respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将字符串的值从`","`位置拆分为一个新数组`b`。现在，包含值`"mastering"`和`"metasploit"`的`"mastering,metasploit"`字符串分别形成数组`b`的第0和第1个元素。
- en: Numbers and conversions in Ruby
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的数字和转换
- en: We can use numbers directly in arithmetic operations. However, remember to convert
    a string into an integer when working on user input using the `.to_i` function.
    On the other hand, we can transform an integer number into a string using the
    `.to_s` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在算术运算中使用数字。但是，在处理用户输入时，记得使用`.to_i`函数将字符串转换为整数。另一方面，我们可以使用`.to_s`函数将整数转换为字符串。
- en: 'Let''s have a look at some quick examples, and their output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些快速示例及其输出：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that when we assigned `a` value to `b` in quotation marks, it was
    considered as a string, and an error was generated while performing the addition
    operation. Nevertheless, as soon as we used the `to_i` function, it converted
    the value from a string into an integer variable, and an addition was performed
    successfully. Similarly, regarding strings, when we tried to concatenate an integer
    with a string, an error showed up. However, after the conversion, it worked perfectly
    fine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们将`a`的值赋给带引号的`b`时，它被视为字符串，并且在执行加法操作时生成了错误。然而，一旦使用`to_i`函数，它将值从字符串转换为整数变量，并且加法操作成功执行。同样，关于字符串，当我们尝试将整数与字符串连接时，会出现错误。但是，在转换后，它可以正常工作。
- en: Conversions in Ruby
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的转换
- en: 'While working with exploits and modules, we will require tons of conversion
    operations. Let''s see some of the conversions we will use in the upcoming sections:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理漏洞利用和模块时，我们将需要大量的转换操作。让我们看看我们将在接下来的部分中使用的一些转换：
- en: '**Hexadecimal to decimal conversion**:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十六进制转十进制转换**：'
- en: 'It''s quite easy to convert a value to a decimal from a hexadecimal in Ruby
    using the inbuilt `hex` function. Let''s look at an example:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ruby中，使用内置的`hex`函数很容易将值从十六进制转换为十进制。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see we got the value `16` for a hexadecimal value of `10`.
  id: totrans-73
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，对于十六进制值`10`，我们得到了值`16`。
- en: '**Decimal to hexadecimal conversion**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制转十六进制转换**：'
- en: 'The opposite of the preceding function can be performed with the `to_s` function,
    as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面函数的相反操作可以使用`to_s`函数执行，如下所示：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ranges in Ruby
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的范围
- en: Ranges are important aspects, and are widely used in auxiliary modules such
    as scanners and fuzzers in Metasploit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是重要的方面，在Metasploit等辅助模块中广泛使用扫描仪和模糊测试器。
- en: 'Let''s define a range, and look at the various operations we can perform on
    this data type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个范围，并查看我们可以对这种数据类型执行的各种操作：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that a range offers various operations, such as searching, finding
    the minimum and maximum values, and displaying all the data in a range. Here,
    the `include?` function checks whether the value is contained in the range or
    not. In addition, the `min` and `max` functions display the lowest and highest
    values in a range.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，范围提供了各种操作，如搜索、查找最小和最大值以及显示范围内的所有数据。在这里，`include?`函数检查值是否包含在范围内。此外，`min`和`max`函数显示范围内的最低和最高值。
- en: Arrays in Ruby
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的数组
- en: 'We can simply define arrays as a list of various values. Let''s have a look
    at an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地将数组定义为各种值的列表。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Up to this point, we have covered all the required variables and data types
    that we will need for writing Metasploit modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了编写Metasploit模块所需的所有变量和数据类型。
- en: 'For more information on variables and data types, refer to the following link:
    [https://www.tutorialspoint.com/ruby/index.htm](https://www.tutorialspoint.com/ruby/index.htm).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有关变量和数据类型的更多信息，请参阅以下链接：[https://www.tutorialspoint.com/ruby/index.htm](https://www.tutorialspoint.com/ruby/index.htm)。
- en: 'Refer to a quick cheat sheet for using Ruby programming effectively at the
    following link: [https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解如何有效使用Ruby编程的快速备忘单：[https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)。
- en: 'Transitioning from another programming language to Ruby? Refer to a helpful
    guide: [http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他编程语言转换到Ruby？请参考一个有用的指南：[http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting)。
- en: Methods in Ruby
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的方法
- en: 'A method is another name for a function. Programmers with a different background
    than Ruby might use these terms interchangeably. A method is a subroutine that
    performs a specific operation. The use of methods implements the reuse of code
    and decreases the length of programs significantly. Defining a method is easy,
    and their definition starts with the `def` keyword and ends with the `end` statement.
    Let''s consider a simple program to understand how they work for example, printing
    out the square of `50`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是函数的另一个名称。与Ruby不同背景的程序员可能会互换使用这些术语。方法是执行特定操作的子例程。使用方法实现代码的重用，并显著减少程序的长度。定义方法很容易，它们的定义以`def`关键字开始，并以`end`语句结束。让我们考虑一个简单的程序，以了解它们的工作原理，例如，打印出`50`的平方：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `print_data` method receives the parameter sent from the main function,
    multiplies it with itself, and sends it back using the `return` statement. The
    program saves this returned value in a variable named `answer`, and prints the
    value. We will use methods heavily in the latter part of this chapter as well
    as in the next few chapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_data`方法接收从主函数发送的参数，将其与自身相乘，并使用`return`语句发送回去。程序将这个返回值保存在一个名为`answer`的变量中，并打印这个值。在本章的后半部分以及接下来的几章中，我们将大量使用方法。'
- en: Decision-making operators
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策运算符
- en: 'Decision-making is also a simple concept, as with any other programming language.
    Let''s have a look at an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 决策也是一个简单的概念，与任何其他编程语言一样。让我们看一个例子：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s also consider the case of string data:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑字符串数据的情况：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s consider a simple program with decision-making operators:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个带有决策运算符的简单程序：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding program, we used the word `"Metasploit"`, which sits right
    in the middle of junk data and is assigned to the `a` variable. Next, we send
    this data to the `find_match()` method, where it matches the `/Metasploit/` regex.
    It returns a true condition if the `a` variable contains the word `"Metasploit"`,
    otherwise a false value is assigned to the `bool_b` variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的程序中，我们使用了单词`"Metasploit"`，它位于垃圾数据的中间，并赋值给变量`a`。接下来，我们将这些数据发送到`find_match()`方法，它匹配`/Metasploit/`正则表达式。如果变量`a`包含单词`"Metasploit"`，则返回true条件，否则将false值赋给变量`bool_b`。
- en: Running the preceding method will produce a valid condition based on the decision-making
    operator, `=~`, that matches both the values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述方法将基于决策运算符`=~`产生一个有效条件，匹配两个值。
- en: 'The output of the preceding program will be somewhat similar to the following
    output when executed in a Windows-based environment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows环境中执行上述程序的输出将与以下输出类似：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Loops in Ruby
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的循环
- en: 'Iterative statements are termed as loops; as with any other programming language,
    loops also exist in Ruby programming. Let''s use them and see how their syntax
    differs from other languages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句被称为循环；与任何其他编程语言一样，Ruby编程中也存在循环。让我们使用它们，并看看它们的语法与其他语言有何不同：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code iterates the loop from `0` to `10`, as defined in the range,
    and consequently prints out the values. Here, we have used `#{i}` to print the
    value of the `i` variable in the `print` statement. The `n` keyword specifies
    a new line. Therefore, every time a variable is printed, it will occupy a new
    line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码从`0`到`10`迭代循环，如范围中定义的那样，并打印出值。在这里，我们使用`#{i}`在`print`语句中打印`i`变量的值。`n`关键字指定了一个新行。因此，每次打印一个变量，它都会占据一行新行。
- en: 'Iterating loops through `each` loop is also a common practice and is widely
    used in Metasploit modules. Let''s see an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`each`循环迭代循环也是一种常见的做法，在Metasploit模块中被广泛使用。让我们看一个例子：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we defined a method that accepts an array, `a`, and prints
    all its elements using the `each` loop. Performing a loop using the `each` method
    will store elements of the `a` array into `i` temporarily, until overwritten in
    the next loop. `t`, in the `print` statement, denotes a tab.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了一个接受数组`a`的方法，并使用`each`循环打印出所有的元素。使用`each`方法进行循环将把`a`数组的元素临时存储在`i`中，直到在下一个循环中被覆盖。`t`在`print`语句中表示一个制表符。
- en: Refer to [http://www.tutorialspoint.com/ruby/ruby_loops.htm](http://www.tutorialspoint.com/ruby/ruby_loops.htm)
    for more on loops.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于循环的信息，请参考[http://www.tutorialspoint.com/ruby/ruby_loops.htm](http://www.tutorialspoint.com/ruby/ruby_loops.htm)。
- en: Regular expressions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Regular expressions are used to match a string or its number of occurrences
    in a given set of strings or a sentence. The concept of regular expressions is
    critical when it comes to Metasploit. We use regular expressions in most cases
    while writing fuzzers, scanners, analyzing the response from a given port, and
    so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于匹配字符串或在给定一组字符串或句子中的出现次数。当涉及到Metasploit时，正则表达式的概念至关重要。我们在大多数情况下使用正则表达式，比如编写模糊测试器、扫描器、分析给定端口的响应等。
- en: Let's have a look at an example of a program that demonstrates the usage of
    regular expressions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个演示正则表达式用法的程序的例子。
- en: 'Consider a scenario where we have a variable, `n`, with the value `Hello world`,
    and we need to design regular expressions for it. Let''s have a look at the following
    code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个情景，我们有一个变量`n`，值为`Hello world`，我们需要为它设计正则表达式。让我们看一下以下代码片段：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have created another variable called `r` and stored our regular expression
    in it, namely, `/world/`. In the next line, we match the regular expression with
    the string using the `match` object of the `MatchData` class. The shell responds
    with a message, `MatchData "world"`, which denotes a successful match. Next, we
    will use another approach of matching a string using the `=~` operator, which
    returns the exact location of the match. Let''s see one other example of doing
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了另一个名为`r`的变量，并将我们的正则表达式存储在其中，即`/world/`。在下一行，我们使用`MatchData`类的`match`对象将正则表达式与字符串进行匹配。Shell响应了一条消息，`MatchData
    "world"`，表示成功匹配。接下来，我们将使用另一种方法来使用`=~`运算符匹配字符串的方式，它返回匹配的确切位置。让我们看另一个做法：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's assign a new value to `r`, namely, `/^world/`; here, the `^` operator
    tells the interpreter to match the string from the start. We get `nil` as an output
    if it is not matched. We modify this expression to start with the word `Hello`;
    this time, it gives us back the location `0`, which denotes a match as it starts
    from the very beginning. Next, we modify our regular expression to `/world$/`,
    which denotes that we need to match the word `world` from the end so that a successful
    match is made.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给`r`赋一个新值，即`/^world/`；这里，`^`运算符告诉解释器从开头匹配字符串。如果没有匹配，我们得到`nil`作为输出。我们修改这个表达式以从单词`Hello`开始；这次，它给我们返回位置`0`，表示匹配从最开始开始。接下来，我们将正则表达式修改为`/world$/`，表示我们需要从结尾匹配单词`world`，以便进行成功匹配。
- en: For further information on regular expressions in Ruby, refer to: [http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ruby正则表达式的更多信息，请参阅：[http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm)。
- en: 'Refer to a quick cheat sheet for using Ruby programming efficiently at the
    following links: [https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)
    and [http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解如何有效使用Ruby编程的快速备忘单：[https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)
    和 [http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting)。
- en: Refer to [http://rubular.com/](http://rubular.com/) for more on building correct
    regular expressions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构建正确的正则表达式，请参考 [http://rubular.com/](http://rubular.com/)。
- en: Wrapping up with Ruby basics
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Ruby基础知识结束
- en: 'Hello! Still awake? It was a tiring session, right? We have just covered the
    basic functionalities of Ruby that are required to design Metasploit modules.
    Ruby is quite vast, and it is not possible to cover all of its aspects here. However,
    refer to some of the excellent resources on Ruby programming from the following
    links:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你好！还醒着吗？这是一次累人的会话，对吧？我们刚刚介绍了设计Metasploit模块所需的Ruby基本功能。Ruby非常广泛，不可能在这里涵盖所有方面。但是，请参考以下链接中关于Ruby编程的一些优秀资源：
- en: An excellent resource for Ruby tutorials is available at: [http://tutorialspoint.com/ruby/](http://tutorialspoint.com/ruby/)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby教程的优秀资源可在以下链接找到：[http://tutorialspoint.com/ruby/](http://tutorialspoint.com/ruby/)
- en: 'A quick cheat sheet for using Ruby programming efficiently is available at
    the following links:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ruby编程的快速备忘单可以在以下链接找到：
- en: '[https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)'
- en: '[http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting)'
- en: More information on Ruby is available at: [http://en.wikibooks.org/wiki/Ruby_Programming](http://en.wikibooks.org/wiki/Ruby_Programming)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Ruby的更多信息，请访问：[http://en.wikibooks.org/wiki/Ruby_Programming](http://en.wikibooks.org/wiki/Ruby_Programming)
- en: Developing custom modules
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义模块
- en: Let's dig deeper into the process of writing a module. Metasploit has various
    modules such as payloads, encoders, exploits, NOP generators, and auxiliaries.
    In this section, we will cover the essentials of developing a module; then, we
    will look at how we can create our custom modules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解编写模块的过程。Metasploit有各种模块，如有效载荷、编码器、利用、NOP生成器和辅助程序。在本节中，我们将介绍开发模块的基本知识；然后，我们将看看如何创建自定义模块。
- en: We will discuss the development of auxiliary and post-exploitation modules.
    Additionally, we will cover core exploit modules in the next chapter. But, for
    this chapter, let's examine the essentials of module building in detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论辅助和后利用模块的开发。此外，我们将在下一章中介绍核心利用模块。但是，在本章中，让我们详细讨论模块构建的基本要点。
- en: Building a module in a nutshell
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在脑袋里建立一个模块
- en: Before diving deep into building modules, let's understand how the components
    are arranged in the Metasploit framework, and what they do.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入构建模块之前，让我们了解Metasploit框架中组件的排列方式以及它们的作用。
- en: The architecture of the Metasploit framework
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metasploit框架的架构
- en: 'Metasploit contains various components, such as necessary libraries, modules,
    plugins, and tools. A diagrammatic view of the structure of Metasploit is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit包含各种组件，如必要的库、模块、插件和工具。Metasploit结构的图形视图如下：
- en: '![](img/4cbc993e-fac3-4a57-83d3-352590424706.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cbc993e-fac3-4a57-83d3-352590424706.png)'
- en: 'Let''s see what these components are and how they work. It is best to start
    with the libraries that act as the heart of Metasploit. We can see the core libraries
    in the following table:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些组件是什么，它们是如何工作的。最好从作为Metasploit核心的库开始。我们可以在下表中看到核心库：
- en: '| **Library name** | **Usage** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **库名称** | **用法** |'
- en: '| `REX` | Handles almost all core functions such as setting up sockets, connections,
    formatting, and all other raw functions |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `REX` | 处理几乎所有核心功能，如设置套接字、连接、格式化和所有其他原始功能 |'
- en: '| `MSF CORE` | Provides the underlying API and the actual core that describes
    the framework |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `MSF CORE` | 提供了描述框架的底层API和实际核心 |'
- en: '| `MSF BASE` | Provides friendly API support to modules |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `MSF BASE` | 为模块提供友好的API支持 |'
- en: 'We have many types of modules in Metasploit, and they differ in functionalities.
    We have payload modules for creating access channels to exploited systems. We
    have auxiliary modules to carry out operations such as information gathering,
    fingerprinting, fuzzing an application, and logging in to various services. Let''s
    examine the basic functionality of these modules, as shown in the following table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metasploit中有许多类型的模块，它们在功能上有所不同。我们有用于创建对被利用系统的访问通道的有效载荷模块。我们有辅助模块来执行操作，如信息收集、指纹识别、模糊化应用程序和登录到各种服务。让我们看一下这些模块的基本功能，如下表所示：
- en: '| **Module type** | **Usage** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **模块类型** | **用法** |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Payloads | Payloads are used to carry out operations such as connecting to
    or from the target system after exploitation, or performing a specific task such
    as installing a service, and so on.Payload execution is the very next step after
    a system is exploited successfully. The widely used Meterpreter shell in the previous
    chapter is a typical Metasploit payload. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 有效载荷 | 有效载荷用于在利用系统后执行操作，如连接到或从目标系统，或执行特定任务，如安装服务等。在成功利用系统后，有效载荷执行是下一步。在上一章中广泛使用的Meterpreter
    shell是典型的Metasploit有效载荷。 |'
- en: '| Auxiliary | Modules that perform specific tasks such as information gathering,
    database fingerprinting, port scanning, and banner grabbing on a target network
    are auxiliary modules. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 辅助 | 执行特定任务的模块，如信息收集、数据库指纹识别、端口扫描和目标网络上的横幅抓取的辅助模块。 |'
- en: '| Encoders | Encoders are used to encode payloads and attack vectors to evade
    detection by antivirus solutions or firewalls. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 编码器 | 编码器用于对载荷和攻击向量进行编码，以逃避杀毒软件或防火墙的检测。 |'
- en: '| NOPs | NOP generators are used for alignment, which results in making exploits
    stable. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| NOPs | NOP生成器用于对齐，从而使利用稳定。 |'
- en: '| Exploits | The actual pieces of code that trigger a vulnerability. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 利用 | 触发漏洞的实际代码。 |'
- en: Understanding the file structure
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解文件结构
- en: 'File structure in Metasploit is laid out in the scheme shown in the following
    figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit的文件结构按照以下图示的方案布置：
- en: '![](img/3af3fb91-752e-4b53-9784-a022dd492b5d.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3af3fb91-752e-4b53-9784-a022dd492b5d.png)'
- en: 'We will cover the most relevant directories, which will aid us in building
    modules for Metasploit, through the following table:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下表格介绍最相关的目录，这将帮助我们构建Metasploit模块：
- en: '| **Directory** | **Usage** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **目录** | **用途** |'
- en: '| `lib` | The heart and soul of Metasploit; it contains all the essential library
    files to help us build MSF modules. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `lib` | Metasploit的核心；它包含了所有必要的库文件，帮助我们构建MSF模块。 |'
- en: '| `modules` | All the Metasploit modules are contained in this directory; from
    scanners to post exploitation modules, every module which was integrated into
    the Metasploit project can be found in this directory. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `模块` | 所有的Metasploit模块都包含在这个目录中；从扫描器到后渗透模块，Metasploit项目中集成的每个模块都可以在这个目录中找到。
    |'
- en: '| `tools` | Command-line utilities that aid penetration testing are contained
    in this folder; from creating junk patterns to finding JMP ESP addresses for successful
    exploit writing, all the necessary command-line utilities are present here. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `工具` | 包含在这个文件夹中的命令行实用程序有助于渗透测试；从创建垃圾模式到查找成功利用编写的JMP ESP地址，所有必要的命令行实用程序都在这里。
    |'
- en: '| `plugins` | All of the plugins, which extend the features of Metasploit,
    are stored in this directory. Standard plugins are OpenVAS, Nexpose, Nessus, and
    various others that can be loaded into the framework using the `load` command.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `插件` | 所有扩展Metasploit功能的插件都存储在这个目录中。标准插件包括OpenVAS、Nexpose、Nessus等，可以使用`load`命令加载到框架中。
    |'
- en: '| `scripts` | This directory contains Meterpreter and various other scripts.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `脚本` | 这个目录包含Meterpreter和其他各种脚本。 |'
- en: The libraries layout
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库布局
- en: Metasploit modules are the buildup of various functions contained in different
    libraries, and general Ruby programming. Now, to use these functions, we first
    need to understand what they are. How can we trigger these functions? What number
    of parameters do we need to pass? Moreover, what will these functions return?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit模块是由不同库中包含的各种功能以及一般的Ruby编程构建而成。现在，要使用这些功能，我们首先需要了解它们是什么。我们如何触发这些功能？我们需要传递多少个参数？此外，这些功能会返回什么？
- en: 'Let''s have a look at how these libraries are organized; this is illustrated
    in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些库是如何组织的；如下截图所示：
- en: '![](img/51674a72-5d3b-4507-9e3e-b78bcd74f75e.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51674a72-5d3b-4507-9e3e-b78bcd74f75e.png)'
- en: As we can see in the preceding screenshot, we have the critical `rex` libraries
    along with all other essential ones in the `/lib` directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所看到的，我们在`/lib`目录中有关键的`rex`库以及所有其他必要的库。
- en: 'The `/base` and `/core` libraries are also a crucial set of libraries, and
    are located under the `/msf` directory:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`/base`和`/core`库也是一组关键的库，位于`/msf`目录下：'
- en: '![](img/29673620-c69b-419c-9591-d7f21d6532bb.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29673620-c69b-419c-9591-d7f21d6532bb.png)'
- en: 'Now, under the `/msf/core` libraries folder, we have libraries for all the
    modules we used earlier in the first chapter; this is illustrated in the following
    screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`/msf/core`库文件夹下，我们有所有在第一章中使用的模块的库；如下截图所示：
- en: '![](img/a23f5b25-9c52-4dc2-9a2f-ae0995883ebf.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a23f5b25-9c52-4dc2-9a2f-ae0995883ebf.png)'
- en: 'These library files provide the core for all modules. However, for different
    operations and functionalities, we can refer to any library we want. Some of the
    most widely used library files in most of the Metasploit modules are located in
    the `core/exploits/` directory, as shown in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库文件为所有模块提供了核心。然而，对于不同的操作和功能，我们可以参考任何我们想要的库。在大多数Metasploit模块中使用的一些最常用的库文件位于`core/exploits/`目录中，如下截图所示：
- en: '![](img/798dd250-a34c-4de1-a0eb-8af6c76244ed.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/798dd250-a34c-4de1-a0eb-8af6c76244ed.png)'
- en: As we can see, it's easy to find all the relevant libraries for various types
    of modules in the `core/` directory. Currently, we have core libraries for exploits,
    payload, post-exploitation, encoders, and various other modules.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，很容易在`core/`目录中找到各种类型模块的相关库。目前，我们在`/lib`目录中有用于利用、载荷、后渗透、编码器和其他各种模块的核心库。
- en: Visit the Metasploit Git repository at [https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework) to
    access the complete source code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Metasploit Git存储库[https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework)以访问完整的源代码。
- en: Understanding the existing modules
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解现有模块
- en: The best way to start writing modules is to delve deeper into the existing Metasploit
    modules, and see how they work internally.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写模块的最佳方法是深入研究现有的Metasploit模块，了解它们内部是如何工作的。
- en: The format of a Metasploit module
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metasploit模块的格式
- en: 'The skeleton for Metasploit modules is reasonably straightforward. We can see
    the universal header section in the code shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit模块的骨架相当简单。我们可以在这里显示的代码中看到通用的头部部分：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A module starts by including the necessary libraries using the `require` keyword,
    which in the preceding code is followed by the `msf/core` libraries. Thus, it
    includes the core libraries from the `/msf` directory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块通过使用`require`关键字包含必要的库开始，前面的代码中跟随着`msf/core`库。因此，它包括了来自`/msf`目录的核心库。
- en: The next major thing is to define the class type that is to specify the kind
    of module we are going to create. We can see that we have set `MSF::Auxiliary`
    for the same purpose.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的事情是定义类类型，以指定我们要创建的模块的类型。我们可以看到我们已经为同样的目的设置了`MSF::Auxiliary`。
- en: 'In the `initialize` method, which is the default constructor in Ruby, we define
    the `Name`, `Description`, `Author`, `License`, `CVE` details, and so on. This
    method covers all the relevant information for a particular module: `Name` generally
    contains the software name that is being targeted; `Description` includes the
    excerpt on the explanation of the vulnerability; `Author` is the name of the person
    who develops the module; and `License` is the `MSF_LICENSE`, as stated in the
    code example listed previously. The auxiliary module''s primary method is the
    `run` method. Hence, all the operations should be performed inside it unless and
    until you have plenty of other methods. However, the execution will still begin
    with the `run` method.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`方法中，这是Ruby中的默认构造函数，我们定义了`Name`，`Description`，`Author`，`License`，`CVE`等详细信息。此方法涵盖了特定模块的所有相关信息：`Name`通常包含被定位的软件名称；`Description`包含有关漏洞解释的摘录；`Author`是开发模块的人的名字；`License`是`MSF_LICENSE`，如前面列出的代码示例中所述。辅助模块的主要方法是`run`方法。因此，除非您有大量其他方法，否则所有操作都应在其中执行。但是，执行仍将从`run`方法开始。
- en: Disassembling the existing HTTP server scanner module
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解现有的HTTP服务器扫描器模块
- en: 'Let''s work with a simple module for an HTTP version scanner, and see how it
    works. The path to this Metasploit module is: `/modules/auxiliary/scanner/http/http_version.rb`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个简单的HTTP版本扫描器模块，并看看它是如何工作的。这个Metasploit模块的路径是：`/modules/auxiliary/scanner/http/http_version.rb`。
- en: 'Let''s examine this module systematically:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们系统地检查这个模块：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s discuss how things are arranged here. The copyright lines, starting
    with the `#` symbol, are the comments and are included in all Metasploit modules.
    The `require ''rex/proto/http''` statement tasks the interpreter to include a
    path to all the HTTP protocol methods from the `rex` library. Therefore, the path
    to all the files from the `/lib/rex/proto/http` directory is now available to
    the module, as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这里的安排方式。以`#`符号开头的版权行是注释，包含在所有Metasploit模块中。`require 'rex/proto/http'`语句要求解释器包含来自`rex`库的所有HTTP协议方法的路径。因此，来自`/lib/rex/proto/http`目录的所有文件的路径现在对模块可用，如下面的屏幕截图所示：
- en: '![](img/be6b1a9a-8d80-4010-80f3-9229193146b7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be6b1a9a-8d80-4010-80f3-9229193146b7.png)'
- en: All these files contain a variety of HTTP methods, which include functions to
    set up a connection, the `GET` and `POST` request, response handling, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件都包含各种HTTP方法，包括建立连接、`GET`和`POST`请求、响应处理等功能。
- en: 'In the next line, `Msf::Auxiliary` defines the code as an auxiliary type module.
    Let''s continue with the code, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，`Msf::Auxiliary`将代码定义为辅助类型模块。让我们继续看代码，如下所示：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding section includes all the necessary library files that contain
    methods used in the modules. Let''s list the path for these included libraries,
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分包括所有包含在模块中使用的方法的必要库文件。让我们列出这些包含的库的路径，如下所示：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用法** |'
- en: '| `Msf::Exploit::Remote::HttpClient` | `/lib/msf/core/exploit/http/client.rb`
    | This library file will provide various methods such as connecting to the target,
    sending a request, disconnecting a client, and so on. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Exploit::Remote::HttpClient` | `/lib/msf/core/exploit/http/client.rb`
    | 此库文件将提供各种方法，如连接到目标，发送请求，断开客户端等。|'
- en: '| `Msf::Auxiliary::WmapScanServer` | `/lib/msf/core/auxiliary/wmapmodule.rb`
    | You might be wondering, what is WMAP? WMAP is a web-application-based vulnerability
    scanner add-on for the Metasploit framework that aids web testing using Metasploit.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Auxiliary::WmapScanServer` | `/lib/msf/core/auxiliary/wmapmodule.rb`
    | 你可能想知道，WMAP是什么？WMAP是Metasploit框架的基于Web应用程序的漏洞扫描器附加组件，它利用Metasploit进行Web测试。|'
- en: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | This file
    contains all the various functions for scanner-based modules. This file supports
    various methods such as running a module, initializing and scanning the progress,
    and so on. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | 此文件包含基于扫描器的模块的各种功能。该文件支持各种方法，如运行模块，初始化和扫描进度等。|'
- en: 'Let''s look at the next piece of code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码的下一部分：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This part of the module defines the `initialize` method, which initializes
    the basic parameters such as `Name`, `Author`, `Description`, and `License` for
    this module and initializes the WMAP parameters as well. Now, let''s have a look
    at the last section of the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分模块定义了`initialize`方法，该方法初始化了此模块的基本参数，如`Name`，`Author`，`Description`和`License`，并初始化了WMAP参数。现在，让我们看一下代码的最后一部分：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function here is the meat of the scanner.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数是扫描器的核心。
- en: Libraries and the function
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和函数
- en: 'Let''s see some essential methods from the libraries that are used in this
    module, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在这个模块中使用的一些库的一些基本方法，如下所示：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库文件** | **用法** |'
- en: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | The main method that
    will run once for each host |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | 这是每个主机运行一次的主要方法 |'
- en: '| `connect` | `/lib/msf/core/auxiliary/scanner.rb` | This is used to make a
    connection to the target host |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `connect` | `/lib/msf/core/auxiliary/scanner.rb` | 这用于与目标主机建立连接|'
- en: '| `send_raw_request` | `/core/exploit/http/client.rb` | This method is used
    to make raw HTTP requests to the target |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `send_raw_request` | `/core/exploit/http/client.rb` | 此方法用于向目标发出原始的HTTP请求
    |'
- en: '| `request_raw` | `/rex/proto/http/client.rb` | The library method to which
    `send_raw_request` passes data to |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `request_raw` | `/rex/proto/http/client.rb` | `send_raw_request`传递数据到的库方法
    |'
- en: '| `http_fingerprint` | `/lib/msf/core/exploit/http/client.rb` | Parses the
    HTTP response into usable variables |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `http_fingerprint` | `/lib/msf/core/exploit/http/client.rb` | 将HTTP响应解析为可用变量
    |'
- en: '| `report_service` | `/lib/msf/core/auxiliary/report.rb` | This method is used
    to report and store the service found on the target host onto the database |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `report_service` | `/lib/msf/core/auxiliary/report.rb` | 此方法用于报告和存储在目标主机上找到的服务到数据库中
    |'
- en: 'Let''s now understand the module. Here, we have a method named `run_host` with
    the IP as the parameter to establish a connection to the required host. The `run_host`
    method is referred from the `/lib/msf/core/auxiliary/scanner.rb` library file.
    This method will run once for each host, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解一下这个模块。这里，我们有一个名为`run_host`的方法，以IP作为参数来建立与所需主机的连接。`run_host`方法是从`/lib/msf/core/auxiliary/scanner.rb`库文件中引用的。这个方法将为每个主机运行一次，如下面的截图所示：
- en: '![](img/27caf839-f795-44f8-adfc-fae97dc3f14c.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27caf839-f795-44f8-adfc-fae97dc3f14c.png)'
- en: Next, we have the `begin` keyword, which denotes the beginning of the code block.
    In the next statement, we have the `connect` method, which establishes the HTTP
    connection to the server, as discussed in the table previously.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`begin`关键字，表示代码块的开始。在下一条语句中，我们有`connect`方法，它建立与服务器的HTTP连接，如前面的表中所讨论的。
- en: 'Next, we define a variable named `res`, which will store the response. We will
    use the `send_raw_request` method from the `/core/exploit/http/client.rb` file
    with the parameter `URI` as `/`, and the `method` for the request as `GET`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为`res`的变量，它将存储响应。我们将使用`/core/exploit/http/client.rb`文件中的`send_raw_request`方法，参数为`URI`为`/`，请求的`method`为`GET`：
- en: '![](img/bb0246ee-c356-4c53-9c28-ecc57b513c24.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb0246ee-c356-4c53-9c28-ecc57b513c24.png)'
- en: The preceding method will help you to connect to the server, create a request,
    send a request, and read the response. We save the response in the `res` variable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法将帮助您连接到服务器，创建请求，发送请求并读取响应。我们将响应保存在`res`变量中。
- en: 'This method passes all the parameters to the `request_raw` method from the
    `/rex/proto/http/client.rb` file, where all these parameters are checked. We have
    plenty of parameters that can be set in the list of parameters. Let''s see what
    they are:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将所有参数传递给`/rex/proto/http/client.rb`文件中的`request_raw`方法，这里检查了所有这些参数。我们有很多可以在参数列表中设置的参数。让我们看看它们是什么：
- en: '![](img/92c14168-346b-41bc-8e3f-23e3ba902d89.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92c14168-346b-41bc-8e3f-23e3ba902d89.png)'
- en: '`res` is a variable that stores the results. In the next statement, the `http_fingerprint`
    method from the `/lib/msf/core/exploit/http/client.rb` file is used for analyzing
    the data in the `fp` variable. This method will record and filter out information
    such as `Set-cookie`, `Powered-by`, and other such headers. This method requires
    an HTTP response packet to make the calculations. So, we will supply `:response`
    `=> res` as a parameter, which denotes that fingerprinting should occur on the
    data received from the request generated previously using `res`. However, if this
    parameter is not given, it will redo everything and get the data again from the
    source. The next statement prints out a type good informational message with details
    such as IP, port, and the service name, but only when the `fp` variable is set.
    The `report_service` method just stores the information to the database. It will
    save the target''s IP address, port number, service type (HTTP or HTTPS, based
    on the service), and the service information. The last line, `rescue ::Timeout::Error,
    ::Errno::EPIPE`, will handle exceptions if the module times out.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`res`是一个存储结果的变量。在下一条语句中，从`/lib/msf/core/exploit/http/client.rb`文件中使用`http_fingerprint`方法来分析`fp`变量中的数据。这个方法将记录和过滤诸如`Set-cookie`、`Powered-by`和其他这样的头信息。这个方法需要一个HTTP响应数据包来进行计算。因此，我们将提供`:response`
    `=> res`作为参数，表示应该对之前使用`res`生成的请求接收到的数据进行指纹识别。然而，如果没有给出这个参数，它将重新做一切，并再次从源获取数据。下一条语句在`fp`变量被设置时打印出一个类型良好的信息消息，其中包括IP、端口和服务名称的详细信息。`report_service`方法只是将信息存储到数据库中。它将保存目标的IP地址、端口号、服务类型（基于服务的HTTP或HTTPS）和服务信息。最后一行`rescue
    ::Timeout::Error, ::Errno::EPIPE`将处理模块超时的异常。'
- en: 'Now, let''s run this module and see what the output is:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个模块，看看输出是什么：
- en: '![](img/d0a0aa59-585f-4ea4-84cb-465a970676d1.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0a0aa59-585f-4ea4-84cb-465a970676d1.png)'
- en: So far, we have seen how a module works. We can see that on a successful fingerprint
    of the application, the information is posted on the console and saved in the
    database. Additionally, on a timeout, the module doesn't crash and is handled
    well. Let's take this a step further and try writing our custom module.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了模块是如何工作的。我们可以看到，在成功对应用程序进行指纹识别后，信息被发布在控制台上并保存在数据库中。此外，在超时时，模块不会崩溃，并且处理得很好。让我们再进一步，尝试编写我们自定义的模块。
- en: Writing out a custom FTP scanner module
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个自定义的FTP扫描器模块
- en: 'Let''s try and build a simple module. We will write a simple FTP fingerprinting
    module and see how things work. Let''s examine the code for the FTP module:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个简单的模块。我们将编写一个简单的FTP指纹模块，看看事情是如何工作的。让我们来检查FTP模块的代码：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We start our code by defining the type of Metasploit module we are going to
    build. In this case, we are writing an auxiliary module that is very similar to
    the one we previously worked on. Next, we define the library files we need to
    include from the core library set, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义我们要构建的Metasploit模块的类型来开始我们的代码。在这种情况下，我们正在编写一个辅助模块，它与我们之前工作过的模块非常相似。接下来，我们定义了需要从核心库集中包含的库文件，如下所示：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用法** |'
- en: '| `Msf::Exploit::Remote::Ftp` | `/lib/msf/core/exploit/ftp.rb` | The library
    file contains all the necessary methods related to FTP, such as methods for setting
    up a connection, logging in to the FTP service, sending an FTP command, and so
    on. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|Msf::Exploit::Remote::Ftp|`/lib/msf/core/exploit/ftp.rb`|该库文件包含了所有与FTP相关的必要方法，如建立连接、登录FTP服务、发送FTP命令等方法。|'
- en: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | This file
    contains all the various functions for scanner-based modules. This file supports
    various methods such as running a module, initializing, and scanning progress.
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|Msf::Auxiliary::Scanner|`/lib/msf/core/auxiliary/scanner.rb`|该文件包含了所有基于扫描仪的模块的各种功能。该文件支持各种方法，如运行模块、初始化和扫描进度。|'
- en: '| `Msf::Auxiliary::Report` | `/lib/msf/core/auxiliary/report.rb` | This file
    contains all the various reporting functions that help in the storage of data
    from the running modules into the database. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|Msf::Auxiliary::Report|`/lib/msf/core/auxiliary/report.rb`|该文件包含了所有各种报告功能，帮助将运行模块的数据存储到数据库中。|'
- en: 'We define the information of the module with attributes such as name, description,
    author name, and license in the `initialize` method. We also define what options
    are required for the module to work. For example, here, we assign `RPORT` to port
    `21`, which is the default port for FTP. Let''s continue with the remaining part
    of the module:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`initialize`方法中定义模块的信息，如名称、描述、作者名称和许可证等属性。我们还定义了模块工作所需的选项。例如，在这里，我们将`RPORT`分配给端口`21`，这是FTP的默认端口。让我们继续处理模块的其余部分：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Libraries and functions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和函数
- en: 'Let''s see some important functions from the libraries that are used in this
    module, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这个模块中使用的一些重要函数的库，如下所示：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|**函数**|**库文件**|**用法**|'
- en: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | The main method which
    will run once for each host. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|`run_host`|`/lib/msf/core/auxiliary/scanner.rb`|每个主机运行一次的主要方法。|'
- en: '| `connect` | `/lib/msf/core/exploit/ftp.rb` | This function is responsible
    for initializing a connection to the host and grabbing the banner that it stores
    in the banner variable automatically. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|`connect`|`/lib/msf/core/exploit/ftp.rb`|该函数负责初始化与主机的连接，并自动抓取横幅并将其存储在横幅变量中。|'
- en: '| `report_service` | `/lib/msf/core/auxiliary/report.rb` | This method is used
    specifically for adding a service and its associated details into the database.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|`report_service`|`/lib/msf/core/auxiliary/report.rb`|该方法专门用于将服务及其相关详细信息添加到数据库中。|'
- en: 'We define the `run_host` method, which serves as the main method. The `connect`
    function will be responsible for initializing a connection to the host. However,
    we supply two parameters to the `connect` function, which are `true` and `false`.
    The `true` parameter defines the use of global parameters, whereas `false` turns
    off the verbose capabilities of the module. The beauty of the `connect` function
    lies in its operation of connecting to the target and recording the banner of
    the FTP service in the parameter named `banner` automatically, as shown in the
    following screenshot:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`run_host`方法，作为主要方法。`connect`函数将负责初始化与主机的连接。然而，我们向`connect`函数提供了两个参数，分别是`true`和`false`。`true`参数定义了使用全局参数，而`false`关闭了模块的冗长功能。`connect`函数的美妙之处在于它连接到目标并自动记录FTP服务的横幅在名为`banner`的参数中，如下截图所示：
- en: '![](img/de42a8c6-3d8e-4ec3-b2c9-b017fecadb15.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de42a8c6-3d8e-4ec3-b2c9-b017fecadb15.png)'
- en: 'Now, we know that the result is stored in the `banner` attribute. Therefore,
    we just print out the banner at the end. Next, we use the `report_service` function
    so that the scan data gets saved to the database for later use or advanced reporting.
    The method is located in the `report.rb` file in the auxiliary library section.
    The code for `report_service` looks similar to the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道结果存储在`banner`属性中。因此，我们只需在最后打印出横幅。接下来，我们使用`report_service`函数，以便将扫描数据保存到数据库中以供以后使用或进行高级报告。该方法位于辅助库部分的`report.rb`文件中。`report_service`的代码看起来类似于以下截图：
- en: '![](img/4af7446e-0dbf-4831-8225-8930d668c852.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4af7446e-0dbf-4831-8225-8930d668c852.png)'
- en: We can see that the provided parameters to the `report_service` method are passed
    to the database using another method called `framework.db.report_service` from
    `/lib/msf/core/db_manager/service.rb`. After performing all the necessary operations,
    we just disconnect the connection with the target.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`report_service`方法提供的参数通过另一个名为`framework.db.report_service`的方法传递到数据库中，该方法位于`/lib/msf/core/db_manager/service.rb`中。完成所有必要操作后，我们只需断开与目标的连接。
- en: This was an easy module, and I recommend that you try building simple scanners
    and other modules like these.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模块，我建议您尝试构建简单的扫描程序和其他类似的模块。
- en: Using msftidy
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msftidy
- en: 'Nevertheless, before we run this module, let''s check whether the module we
    just built is correct with regards to its syntax. We can do this by passing the
    module from an in-built Metasploit tool named `msftidy`, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行此模块之前，让我们检查我们刚刚构建的模块是否在语法上是正确的。我们可以通过使用内置的Metasploit工具`msftidy`来实现这一点，如下截图所示：
- en: '![](img/f827f0dc-cec6-488a-bf3b-55e4e307eb78.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f827f0dc-cec6-488a-bf3b-55e4e307eb78.png)'
- en: We will get a warning message indicating that there are a few extra spaces at
    the end of line 20\. When we remove the additional spaces and rerun `msftidy`,
    we will see that no error is generated, which means the syntax of the module is
    correct.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到一个警告消息，指示第20行末尾有一些额外的空格。当我们删除额外的空格并重新运行`msftidy`时，我们将看到没有生成错误，这意味着模块的语法是正确的。
- en: 'Now, let''s run this module and see what we gather:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个模块，看看我们收集到了什么：
- en: '![](img/2f5c9ed1-36b9-4ef0-8ed5-5676aa501325.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f5c9ed1-36b9-4ef0-8ed5-5676aa501325.png)'
- en: We can see that the module ran successfully, and it has the banner of the service
    running on port `21`, which is `220-FileZilla Server 0.9.60 beta`. The `report_service`
    function in the previous module stores data to the services section, which can
    be seen by running the `services` command, as shown in the preceding screenshot.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到模块成功运行，并且它具有在端口`21`上运行的服务的横幅，即`220-FileZilla Server 0.9.60 beta`。在前一个模块中，`report_service`函数将数据存储到服务部分，可以通过运行`services`命令来查看，如前面的截图所示。
- en: For further reading on the acceptance of modules in the Metasploit project,
    refer to: [https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements](https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Metasploit项目中模块的接受标准，可参考：[https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements](https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements)。
- en: Writing out a custom SSH-authentication with a brute force attack
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个自定义的SSH身份验证暴力攻击。
- en: For checking weak login credentials, we need to perform an authentication brute
    force attack. The agenda of such tests is not only to test an application against
    weak credentials, but to ensure proper authorization and access controls as well.
    These tests ensure that the attackers cannot simply bypass the security paradigm
    by trying the non-exhaustive brute force attack, and are locked out after a certain
    number of random guesses.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 检查弱登录凭据，我们需要执行身份验证暴力攻击。这些测试的议程不仅是为了测试应用程序是否容易受到弱凭据的攻击，还要确保适当的授权和访问控制。这些测试确保攻击者不能简单地通过尝试非穷尽的暴力攻击来绕过安全范式，并且在一定数量的随机猜测后被锁定。
- en: 'Designing the next module for authentication testing on the SSH service, we
    will look at how easy it is to design authentication-based checks in Metasploit,
    and perform tests that attack authentication. Let''s now jump into the coding
    part and begin designing a module, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 设计SSH服务的下一个身份验证测试模块，我们将看看在Metasploit中设计基于身份验证的检查有多容易，并执行攻击身份验证的测试。现在让我们跳入编码部分并开始设计一个模块，如下所示：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the previous examples, we have already seen the importance of using `Msf::Auxiliary::Scanner`
    and `Msf::Auxiliary::Report`. Let''s see the other included libraries and understand
    their usage through the following table:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经看到了使用`Msf::Auxiliary::Scanner`和`Msf::Auxiliary::Report`的重要性。让我们看看其他包含的库并通过下表了解它们的用法：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用法** |'
- en: '| `Msf::Auxiliary::AuthBrute` | `/lib/msf/core/auxiliary/auth_brute.rb` | Provides
    the necessary brute forcing mechanisms and features such as providing options
    for using single entry username and passwords, wordlists, and blank password.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Auxiliary::AuthBrute` | `/lib/msf/core/auxiliary/auth_brute.rb` | 提供必要的暴力攻击机制和功能，比如提供使用单个用户名和密码、单词列表和空密码的选项。'
- en: In the preceding code, we also included two files, which are `metasploit/framework/login_scanner/ssh`
    and `metasploit/framework/credential_collection`. The `metasploit/framework/login_scanner/ssh`
    file includes the SSH login scanner library that eliminates all manual operations
    and provides an underlying API to SSH scanning. The `metasploit/framework/credential_collection`
    file helps to create multiple credentials based on user inputs from the `datastore`.
    Next, we simply define the type of the module we are building.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还包括了两个文件，分别是`metasploit/framework/login_scanner/ssh`和`metasploit/framework/credential_collection`。`metasploit/framework/login_scanner/ssh`文件包括了SSH登录扫描器库，它消除了所有手动操作，并提供了SSH扫描的底层API。`metasploit/framework/credential_collection`文件帮助根据`datastore`中用户输入创建多个凭据。接下来，我们只需定义我们正在构建的模块的类型。
- en: 'In the `initialize` section, we define the basic information for this module.
    Let''s see the next section:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`部分，我们为这个模块定义了基本信息。让我们看看下一部分：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that we have two objects in the preceding code, which are `cred_collection`
    and `scanner`. An important point to make a note of here is that we do not require
    any manual methods of logging into the SSH service because the login scanner does
    everything for us. Therefore, `cred_collection` is doing nothing but yielding
    sets of credentials based on the `datastore` options set on a module. The beauty
    of the `CredentialCollection` class lies in the fact that it can take a single
    username/password combination, wordlists, and blank credentials all at once, or
    one of them at a time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的代码中有两个对象，分别是`cred_collection`和`scanner`。这里需要注意的一个重要点是，我们不需要任何手动登录SSH服务的方法，因为登录扫描器会为我们完成一切。因此，`cred_collection`只是根据模块上设置的`datastore`选项生成凭据集。`CredentialCollection`类的美妙之处在于它可以一次性接受单个用户名/密码组合、单词列表和空凭据，或者它们中的一个。
- en: All login scanner modules require credential objects for their login attempts.
    The `scanner` object defined in the preceding code initializes an object for the
    SSH class. This object stores the address of the target, port, credentials as
    generated by the `CredentialCollection` class, and other data-like proxy information,
    `stop_on_success` that will stop the scanning on the successful credential match,
    brute force speed, and the value of the attempted timeout.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有登录扫描器模块都需要凭据对象来进行登录尝试。在前面的代码中定义的`scanner`对象初始化了一个SSH类的对象。这个对象存储了目标的地址、端口、由`CredentialCollection`类生成的凭据，以及其他数据，比如代理信息、`stop_on_success`，它将在成功的凭据匹配时停止扫描，暴力攻击速度和尝试超时的值。
- en: Up to this point in the module, we have created two objects; `cred_collection`,
    which will generate credentials based on the user input, and the `scanner` object,
    which will use those credentials to scan the target. Next, we need to define a
    mechanism so that all the credentials from a wordlist are defined as single parameters
    and are tested against the target.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在模块中我们已经创建了两个对象；`cred_collection`将根据用户输入生成凭据，而`scanner`对象将使用这些凭据来扫描目标。接下来，我们需要定义一个机制，使得来自单词列表的所有凭据都被定义为单个参数，并针对目标进行测试。
- en: 'We have already seen the usage of `run_host` in previous examples. Let''s see
    what other vital functions from various libraries we are going to use in this
    module:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的示例中看到了`run_host`的用法。让我们看看在这个模块中我们将使用哪些来自各种库的其他重要函数：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库文件** | **用法** |'
- en: '| `create_credential()` | `/lib/msf/core/auxiliary/report.rb` | Yields credential
    data from the result object. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `create_credential()` | `/lib/msf/core/auxiliary/report.rb` | 从结果对象中产生凭据数据。
    |'
- en: '| `create_credential_login()` | `/lib/msf/core/auxiliary/report.rb` | Creates
    login credentials from the result object, which can be used to log in to a particular
    service. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `create_credential_login()` | `/lib/msf/core/auxiliary/report.rb` | 从结果对象中创建登录凭据，可用于登录到特定服务。
    |'
- en: '| `invalidate_login` | `/lib/msf/core/auxiliary/report.rb` | Marks a set of
    credentials as invalid for a particular service. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `invalidate_login` | `/lib/msf/core/auxiliary/report.rb` | 标记一组凭据为特定服务的无效。
    |'
- en: 'Let''s see how we can achieve that:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这一点：
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It can be observed that we used `.scan` to initialize the scan, and this will
    perform all the login attempts by itself, which means we do not need to specify
    any other mechanism explicitly. The `.scan` instruction is exactly like an `each`
    loop in Ruby.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到我们使用`.scan`来初始化扫描，这将自行执行所有的登录尝试，这意味着我们不需要明确指定任何其他机制。`.scan`指令就像Ruby中的`each`循环一样。
- en: In the next statement, the results get saved in the `result` object and are
    assigned to the `credential_data` variable using the `to_h` method, which will
    convert the data to hash format. In the next line, we merge the module name and
    workspace ID into the `credential_data` variable. Next, we run an if-else check
    on the `result` object using the `.success`, variable, which denotes successful
    login attempts into the target. If the `result.success?` variable returns true,
    we mark the credential as a successful login attempt and store it in the database.
    However, if the condition is not satisfied, we pass the `credential_data` variable
    to the `invalidate_login` method that denotes a failed login.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一个语句中，结果被保存在`result`对象中，并使用`to_h`方法分配给`credential_data`变量，该方法将数据转换为哈希格式。在下一行中，我们将模块名称和工作区ID合并到`credential_data`变量中。接下来，我们使用`.success`变量对`result`对象进行if-else检查，该变量表示成功登录到目标。如果`result.success?`变量返回true，我们将凭据标记为成功的登录尝试并将其存储在数据库中。但是，如果条件不满足，我们将`credential_data`变量传递给`invalidate_login`方法，表示登录失败。 '
- en: 'It is advisable to run all the modules in this chapter and all the later chapters
    only after performing a consistency check through `msftidy`. Let''s try running
    the module, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过`msftidy`进行一致性检查后再运行本章和后续章节中的所有模块。让我们尝试运行该模块，如下所示：
- en: '![](img/8e86e9fd-7aa8-4071-8b6d-b8121c2cf901.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e86e9fd-7aa8-4071-8b6d-b8121c2cf901.png)'
- en: 'We can see that we were able to log in with `claire` and `18101988` as the
    username and password. Let''s see if we were able to log the credentials into
    the database using the `creds` command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们能够使用`claire`和`18101988`作为用户名和密码登录。让我们看看我们是否能够使用`creds`命令将凭据记录到数据库中：
- en: '![](img/78045d49-4632-4ec4-80d9-59d5df3337fa.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78045d49-4632-4ec4-80d9-59d5df3337fa.png)'
- en: We can see that we have the details logged into the database, and they can be
    used to carry out advanced attacks, or for reporting.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们已经将详细信息记录到数据库中，并且可以用于进行高级攻击或报告。
- en: Rephrasing the equation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新表达方程
- en: 'If you are scratching your head after working on the module listed previously,
    let''s understand the module in a step-by-step fashion:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在之前列出的模块上工作后感到困惑，让我们逐步了解模块：
- en: We've created a `CredentialCollection` object that takes any user as input and
    yields credentials, which means that if we provide `USERNAME` as the root and
    `PASSWORD` as the root, it will yield those as a single credential. However, if
    we use `USER_FILE` and `PASS_FILE` as dictionaries, then it will take each username
    and password from the dictionary file and will generate credentials for each combination
    of username and password from the files, respectively.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`CredentialCollection`对象，它接受任何用户作为输入并产生凭据，这意味着如果我们将`USERNAME`作为root和`PASSWORD`作为root，它将作为单个凭据产生。但是，如果我们使用`USER_FILE`和`PASS_FILE`作为字典，那么它将从字典文件中获取每个用户名和密码，并分别为文件中的每个用户名和密码组合生成凭据。
- en: We've created a `scanner` object for SSH, which will eliminate any manual command
    usage and will simply check all the combinations we supplied one after the other.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为SSH创建了一个`scanner`对象，它将消除任何手动命令使用，并将简单地检查我们提供的所有组合。
- en: We've run our `scanner` using the `.scan` method, which will initialize the
    authentication of brute force on the target.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`.scan`方法运行了我们的`scanner`，它将在目标上初始化暴力破解的身份验证。
- en: The `.scan` method will scan all credentials one after the other and, based
    on the result, will either store it into the database and display the same with
    `print_good`, else it will show it using `print_status` without saving it.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.scan`方法将依次扫描所有凭据，并根据结果，将其存储到数据库中并使用`print_good`显示，否则将使用`print_status`显示而不保存。'
- en: Writing a drive-disabler post-exploitation module
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个驱动禁用后渗透模块
- en: As we have now seen the basics of module building, we can go a step further
    and try to build a post-exploitation module. A point to remember here is that
    we can only run a post-exploitation module after a target has been compromised
    successfully.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模块构建的基础知识，我们可以进一步尝试构建一个后渗透模块。这里需要记住的一点是，只有在成功攻击目标后才能运行后渗透模块。
- en: 'So, let''s begin with a simple drive-disabler module, which will disable the
    selected drive at the target system, which is a Windows 7 OS. Let''s see the code
    for the module, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从一个简单的驱动禁用模块开始，该模块将禁用目标系统上选择的驱动器，该系统是Windows 7操作系统。让我们看看模块的代码，如下所示：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We started in the same way as we did in the previous modules. We added the
    path to all the required libraries we needed for this post-exploitation module.
    Let''s see any new inclusion and their usage in the following table:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前模块相同的方式开始。我们添加了所有需要的库的路径，以便在这个后渗透模块中使用。让我们看看下表中的任何新的包含和它们的用法：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用法** |'
- en: '| `Msf::Post::Windows::Registry` | `lib/msf/core/post/windows/registry.rb`
    | This library will give us the power to use registry manipulation functions with
    ease using Ruby Mixins. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Post::Windows::Registry` | `lib/msf/core/post/windows/registry.rb`
    | 这个库将使我们能够使用Ruby Mixins轻松地进行注册表操作函数。|'
- en: Next, we define the type of module as `Post` for post-exploitation. Proceeding
    with the code, we describe the necessary information for the module in the `initialize`
    method. We can always define `register_options` to define our custom options to
    use with the module. Here, we describe `DriveName` as a string datatype using
    `OptString.new`. The definition of a new option requires two parameters that are
    `required` and `description`. We set the value of `required` to `true` because
    we need a drive letter to initiate the hiding and disabling process. Hence, setting
    it to `true` won't allow the module to run unless a value is assigned to it. Next,
    we define the description for the newly added `DriveName` option.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将模块的类型定义为`Post`，用于后渗透。在继续代码时，我们在`initialize`方法中描述了模块的必要信息。我们可以始终定义`register_options`来定义我们的自定义选项以与模块一起使用。在这里，我们使用`OptString.new`将`DriveName`描述为字符串数据类型。定义新选项需要两个参数，即`required`和`description`。我们将`required`的值设置为`true`，因为我们需要一个驱动器号来启动隐藏和禁用过程。因此，将其设置为`true`将不允许模块运行，除非为其分配一个值。接下来，我们定义了新添加的`DriveName`选项的描述。
- en: 'Before proceeding to the next part of the code, let''s see what important function
    we are going to use in this module:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续代码的下一部分之前，让我们看看在这个模块中我们将要使用的重要函数是什么：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库文件** | **用法** |'
- en: '| `meterpreter_registry_key_exist` | `lib/msf/core/post/windows/registry.rb`
    | Checks if a particular key exists in the registry |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `meterpreter_registry_key_exist` | `lib/msf/core/post/windows/registry.rb`
    | 检查注册表中是否存在特定的键 |'
- en: '| `registry_createkey` | `lib/msf/core/post/windows/registry.rb` | Creates
    a new registry key |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `registry_createkey` | `lib/msf/core/post/windows/registry.rb` | 创建一个新的注册表键
    |'
- en: '| `meterpreter_registry_setvaldata` | `lib/msf/core/post/windows/registry.rb`
    | Creates a new registry value |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `meterpreter_registry_setvaldata` | `lib/msf/core/post/windows/registry.rb`
    | 创建一个新的注册表值 |'
- en: 'Let''s see the remaining part of the module:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模块的剩余部分：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We generally run a post-exploitation module using the `run` method. So, defining
    `run`, we send the `DriveName` variable to the `drive_string` method to get the
    numeric value for the drive.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用`run`方法来运行后渗透模块。因此，在定义`run`时，我们将`DriveName`变量发送到`drive_string`方法，以获取驱动器的数值。
- en: We created a variable called `key1` and stored the path of the registry in it.
    We will use `meterpreter_registry_key_exist` to check if the key already exists
    in the system or not.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`key1`的变量，并将注册表的路径存储在其中。我们将使用`meterpreter_registry_key_exist`来检查系统中是否已经存在该键。
- en: If the key exists, the value of the `exists` variable is assigned `true` or
    `false`. In case the value of the `exists` variable is `false`, we create the
    key using `registry_createkey(key1)` and then proceed to create the values. However,
    if the condition is true, we simply create the values.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键存在，则将`exists`变量的值分配为`true`或`false`。如果`exists`变量的值为`false`，我们使用`registry_createkey(key1)`创建键，然后继续创建值。但是，如果条件为真，我们只需创建值。
- en: To hide drives and restrict access, we need to create two registry values that
    are `NoDrives` and `NoViewOnDrive`, with the value of the drive letter in decimal
    or hexadecimal from, and its type as `DWORD`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏驱动器并限制访问，我们需要创建两个注册表值，即`NoDrives`和`NoViewOnDrive`，其值为十进制或十六进制的驱动器号，类型为`DWORD`。
- en: We can do this using `meterpreter_registry_setvaldata` since we are using the
    meterpreter shell. We need to supply five parameters to the `meterpreter_registry_setvaldata`
    function to ensure its proper functioning. These parameters are the key path as
    a string, name of the registry value as a string, decimal value of the drive letter
    as a string, type of registry value as a string, and the view as an integer value,
    which would be 0 for native, 1 for 32-bit view, and 2 for 64-bit view.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`meterpreter_registry_setvaldata`来实现这一点，因为我们正在使用meterpreter shell。我们需要向`meterpreter_registry_setvaldata`函数提供五个参数，以确保其正常运行。这些参数是键路径（字符串）、注册表值的名称（字符串）、驱动器号的十进制值（字符串）、注册表值的类型（字符串）和视图（整数值），对于本机视图为0，32位视图为1，64位视图为2。
- en: 'An example of `meterpreter_registry_setvaldata` can be broken down as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`meterpreter_registry_setvaldata`的示例可以分解如下：'
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we set the path as `key1`, the value as `NoViewOnDrives`,
    16 as a decimal for drive `D`, `REG_DWORD` as the type of registry, and `REGISTRY_VIEW_NATIVE`,
    which supplies 0.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将路径设置为`key1`，将值设置为`NoViewOnDrives`，将驱动器`D`的十进制值设置为16，将注册表的类型设置为`REG_DWORD`，并将视图设置为`REGISTRY_VIEW_NATIVE`，即0。
- en: For 32-bit registry access, we need to provide 1 as the view parameter, and
    for 64-bit, we need to supply 2\. However, this can be done using `REGISTRY_VIEW_32_BIT`
    and `REGISTRY_VIEW_64_BIT`, respectively.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位注册表访问，我们需要将1作为视图参数提供，对于64位，我们需要提供2。但是，这可以使用`REGISTRY_VIEW_32_BIT`和`REGISTRY_VIEW_64_BIT`来完成。
- en: You might be wondering how we knew that for drive `E` we need to have the value
    of the bitmask as `16`? Let's see how the bitmask can be calculated in the following
    section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是如何知道对于驱动器`E`，我们需要将位掩码的值设置为`16`？让我们看看在下一节中如何计算位掩码。
- en: 'To calculate the bitmask for a particular drive, we have the formula `2^([drive
    character serial number]-1)`. Suppose we need to disable drive `E`; we know that
    character E is the fifth character in the alphabet. Therefore, we can calculate
    the exact bitmask value for disabling drive `E`, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算特定驱动器的位掩码，我们有公式`2^([驱动器字符序号]-1)`。假设我们需要禁用驱动器`E`；我们知道字符E是字母表中的第五个字符。因此，我们可以计算禁用驱动器`E`的确切位掩码值，如下所示：
- en: '*2^ (5-1) = 2^4= 16*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*2^ (5-1) = 2^4= 16*'
- en: 'The bitmask value is `16` for disabling `E` drive. However, in the preceding
    module, we hardcoded a few values in the `drive_string` method using the `case`
    switch. Let''s see how we did that:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 位掩码值为`16`用于禁用`E`驱动器。然而，在前面的模块中，我们在`drive_string`方法中使用`case`开关硬编码了一些值。让我们看看我们是如何做到的：
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can see that the previous method takes a drive letter as an argument and
    returns its corresponding numeral to the calling function. Let see how many drives
    there are at the target system:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，前面的方法接受一个驱动器字母作为参数，并将其对应的数字返回给调用函数。让我们看看目标系统上有多少个驱动器：
- en: '![](img/cdf52ba4-44f7-4138-a791-b6d112b9abf4.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdf52ba4-44f7-4138-a791-b6d112b9abf4.png)'
- en: 'We can see we have two drives, drive `C` and drive `E`. Let''s also check the
    registry entries where we will be writing the new keys with our module:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有两个驱动器，驱动器`C`和驱动器`E`。让我们也检查一下我们将在其中写入新键的注册表条目：
- en: '![](img/294642e8-bbf3-4d98-8916-8bab60661226.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/294642e8-bbf3-4d98-8916-8bab60661226.png)'
- en: 'We can see we don''t have an explorer key yet. Let''s run the module, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们还没有一个explorer键。让我们运行模块，如下所示：
- en: '![](img/fed15fd8-ff77-444e-9994-4e1d974f0539.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fed15fd8-ff77-444e-9994-4e1d974f0539.png)'
- en: 'We can see that the key doesn''t exist and, according to the execution of our
    module, it should have written the keys in the registry. Let''s check the registry
    once again:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该键不存在，并且根据我们模块的执行，它应该已经在注册表中写入了键。让我们再次检查注册表：
- en: '![](img/27fa3f01-dc25-4b67-ab0d-11fe554fd673.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27fa3f01-dc25-4b67-ab0d-11fe554fd673.png)'
- en: 'We can see we have the keys present. Upon logging out and logging back into
    the system, drive `E` should have disappeared. Let''s check:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有现有的键。注销并重新登录系统后，驱动器`E`应该已经消失了。让我们检查一下：
- en: '![](img/b66f51cc-8957-4a98-989a-4d6e7977f66d.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b66f51cc-8957-4a98-989a-4d6e7977f66d.png)'
- en: No signs of drive `E`. Hence, we successfully disabled drive `E` from the user's
    view, and restricted access to the same.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`E`驱动器的迹象。因此，我们成功地从用户视图中禁用了`E`驱动器，并限制了对其的访问。
- en: We can create as many post-exploitation modules as we want according to our
    needs. I recommend you put some extra time towards the libraries of Metasploit.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以创建尽可能多的后渗透模块。我建议您花一些额外的时间来了解Metasploit的库。
- en: Make sure that you have `SYSTEM`-level access for the preceding script to work,
    as `SYSTEM` privileges will not create the registry under the current user, but
    will create it on the local machine. In addition to this, we have used `HKLM`
    instead of writing `HKEY_LOCAL_MACHINE`, because of the inbuilt normalization
    that will automatically create the full form of the key. I recommend that you
    check the `registry.rb` file to see the various available methods.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您对上述脚本具有`SYSTEM`级别访问权限，因为`SYSTEM`特权不会在当前用户下创建注册表，而是会在本地计算机上创建注册表。除此之外，我们使用了`HKLM`而不是写`HKEY_LOCAL_MACHINE`，因为内置的规范化将自动创建键的完整形式。我建议您检查`registry.rb`文件以查看各种可用的方法。
- en: If you don't have system privileges, try using the `exploit/windows/local/bypassuac`
    module and switch to the escalated shell, and then try the preceding module.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有系统权限，请尝试使用`exploit/windows/local/bypassuac`模块并切换到提升的shell，然后尝试上述模块。
- en: Writing a credential harvester post-exploitation module
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写凭证收集后渗透模块
- en: 'In this example module, we will attack Foxmail 6.5\. We will try decrypting
    the credentials and store them in the database. Let''s see the code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例模块中，我们将攻击Foxmail 6.5。我们将尝试解密凭据并将其存储在数据库中。让我们看看代码：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Quite simple, as we saw in the previous module; we start by including all the
    required libraries and providing the basic information about the module.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的模块中看到的那样；我们首先包括所有必需的库，并提供有关模块的基本信息。
- en: 'We have already seen the usage of `Msf::Post::Windows::Registry` and `Msf::Auxiliary::Report`.
    Let''s look at the details of the new libraries we included in this module, as
    follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`Msf::Post::Windows::Registry`和`Msf::Auxiliary::Report`的用法。让我们看看我们在此模块中包含的新库的详细信息，如下所示：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用法** |'
- en: '| `Msf::Post::Windows::UserProfiles` | `lib/msf/core/post/windows/user_profiles.rb`
    | This library will provide all the profiles on a Windows system, which includes
    finding important directories, paths, and so on. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Post::Windows::UserProfiles` | `lib/msf/core/post/windows/user_profiles.rb`
    | 此库将提供Windows系统上的所有配置文件，包括查找重要目录、路径等。'
- en: '| `Msf::Post::File` | `lib/msf/core/post/file.rb` | This library will provide
    functions which will aid file operations, such as reading a file, checking a directory,
    listing directories, writing to a file, and so on. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Post::File` | `lib/msf/core/post/file.rb` | 此库将提供函数，将帮助文件操作，如读取文件、检查目录、列出目录、写入文件等。'
- en: 'Before understanding the next part of the module, let''s see what we need to
    perform to harvest the credentials:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解模块的下一部分之前，让我们看看我们需要执行哪些操作来收集凭据：
- en: We will search for user profiles and find the exact path for the current user's
    `LocalAppData` directory.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将搜索用户配置文件，并找到当前用户的`LocalAppData`目录的确切路径。
- en: We will use the previously found path and concatenate it with `\VirtualStore\Program
    Files (x86)\Tencent\Foxmail\mail` to establish a complete path to the `mail` directory.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用先前找到的路径，并将其与`\VirtualStore\Program Files (x86)\Tencent\Foxmail\mail`连接起来，以建立到`mail`目录的完整路径。
- en: We will list all the directories from the `mail` directory and will store them
    in an array. However, the directory names in the `mail` directory will use the
    naming convention of the username for various mail providers. For example, `nipunjaswal@rocketmail.com`
    would be one of the directories present in the `mail` directory.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从 `mail` 目录中列出所有目录，并将它们存储在一个数组中。但是，`mail` 目录中的目录名称将使用各种邮件提供程序的用户名命名约定。例如，`nipunjaswal@rocketmail.com`
    将是 `mail` 目录中存在的目录之一。
- en: Next, we will find `Account.stg` file in the accounts directories, found under
    the `mail` directory.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `mail` 目录下找到帐户目录中的 `Account.stg` 文件。
- en: We will read the `Account.stg` file and will find the hash value for the constant
    named `POP3Password`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将读取 `Account.stg` 文件，并找到名为 `POP3Password` 的常量的哈希值。
- en: We will pass the hash value to our decryption method, which will find the password
    in plain text.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将哈希值传递给我们的解密方法，该方法将找到明文密码。
- en: We will store the value in the database.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将值存储在数据库中。
- en: 'Quite simple! Let''s analyze the code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单！让我们分析代码：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Before starting to understand the previous code, let''s see what important
    functions are used in it, for a better approach toward its usage:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始理解前面的代码之前，让我们看一下其中使用的重要函数，以便更好地了解其用法：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库文件** | **用法** |'
- en: '| `grab_user_profiles()` | `lib/msf/core/post/windows/user_profiles.rb` | Grabs
    all paths for important directories on a Windows platform |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `grab_user_profiles()` | `lib/msf/core/post/windows/user_profiles.rb` | 获取
    Windows 平台上重要目录的所有路径 |'
- en: '| `directory?` | `lib/msf/core/post/file.rb` | Checks if a directory exists
    or not |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `directory?` | `lib/msf/core/post/file.rb` | 检查目录是否存在 |'
- en: '| `file?` | `lib/msf/core/post/file.rb` | Checks if a file exists or not |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `file?` | `lib/msf/core/post/file.rb` | 检查文件是否存在 |'
- en: '| `read_file` | `lib/msf/core/post/file.rb` | Reads the contents of a file
    |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `read_file` | `lib/msf/core/post/file.rb` | 读取文件的内容 |'
- en: '| `store_loot` | `/lib/msf/core/auxiliary/report.rb` | Stores the harvested
    information into a file and a database |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `store_loot` | `/lib/msf/core/auxiliary/report.rb` | 将收集到的信息存储到文件和数据库中 |'
- en: We can see in the preceding code that we grabbed the profiles using `grab_user_profiles()`
    and, for each profile, we tried finding the `LocalAppData` directory. As soon
    as we found it, we stored it in a variable called `full_path`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的代码中，我们使用 `grab_user_profiles()` 获取了配置文件，并尝试找到 `LocalAppData` 目录。一旦找到，我们将其存储在一个名为
    `full_path` 的变量中。
- en: 'Next, we concatenated the path to the `mail` folder where all the accounts
    are listed as directories. We checked the path existence using `directory?` and,
    on success, we copied all the directory names that contained `@` in the name to
    the `dir_list` using regex match. Next, we created another variable called `full_path_mail`
    and stored the exact path to the `Account.stg` file for each email. We made sure
    that the `Account.stg` file existed by using `file?`. On success, we read the
    file and split all the contents at newline. We stored the split content into the
    `file_content` list. Let''s see the next part of the code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将路径连接到列出所有帐户的 `mail` 文件夹。我们使用 `directory?` 检查路径是否存在，并在成功时使用正则表达式匹配将包含
    `@` 的目录名称复制到 `dir_list` 中。接下来，我们创建另一个名为 `full_path_mail` 的变量，并存储每封电子邮件的 `Account.stg`
    文件的确切路径。我们确保使用 `file?` 来检查 `Account.stg` 文件是否存在。成功后，我们读取文件并在换行符处拆分所有内容。我们将拆分的内容存储到
    `file_content` 列表中。让我们看代码的下一部分：
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For each entry in `file_content`, we ran a check to find the constant `POP3Password`.
    Once found, we split the constant at `=` and stored the value of the constant
    in a variable, `hash_value`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `file_content` 中的每个条目，我们运行了一个检查，以查找常量 `POP3Password`。一旦找到，我们将常量在 `=` 处拆分，并将常量的值存储在一个名为
    `hash_value` 的变量中。
- en: Next, we directly pass the `hash_value` and `dir_list` (account name) to the
    `decrypt` function. After successful decryption, the plain password gets stored
    in the `decrypted_pass` variable. We create another variable called `data_entry`
    and append all the credentials to it. We do this because we don't know how many
    email accounts might be configured on the target. Therefore, for each result,
    the credentials get appended to `data_entry`. After all the operations are complete,
    we store the `data_entry` variable in the database using the `store_loot` method.
    We supply six arguments to the `store_loot` method, which are named for the harvest,
    its content type, session, `data_entry`, the name of the file, and the description
    of the harvest.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们直接将 `hash_value` 和 `dir_list`（帐户名）传递给 `decrypt` 函数。成功解密后，明文密码将存储在 `decrypted_pass`
    变量中。我们创建另一个名为 `data_entry` 的变量，并将所有凭据附加到其中。我们这样做是因为我们不知道目标上可能配置了多少电子邮件帐户。因此，对于每个结果，凭据都会附加到
    `data_entry`。所有操作完成后，我们使用 `store_loot` 方法将 `data_entry` 变量存储在数据库中。我们向 `store_loot`
    方法提供了六个参数，分别为收集、内容类型、会话、`data_entry`、文件名和收集的描述。
- en: 'Let''s understand the decryption function, as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解解密函数，如下所示：
- en: '[PRE44]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the previous method, we received two arguments, which are the hashed password
    and username. The `magic` variable is the decryption key stored in an array containing
    decimal values for the `~draGon~` string, one after the other. We store the integer
    `90` as `fc0`, which we will talk about a bit later.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们收到了两个参数，即哈希密码和用户名。`magic` 变量是解密密钥，存储在一个包含 `~draGon~` 字符串的十进制值的数组中，依次存储。我们将整数
    `90` 存储为 `fc0`，稍后我们将详细讨论。
- en: Next, we find the size of the hash by dividing it by two and subtracting one
    from it. This will be the size of our new array, `b`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将哈希除以2并减去1来找到哈希的大小。这将是我们新数组 `b` 的大小。
- en: In the next step, we split the hash into bytes (two characters each) and store
    the same into array `b`. We perform `XOR` on the first byte of array `b`, with
    `fc0` into the first byte of `b` itself, thus updating the value of `b[0]` by
    performing the XOR operation on it with `90`. This is fixed for Foxmail 6.5.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将哈希拆分为字节（每两个字符一个），并将其存储到数组 `b` 中。我们对数组 `b` 的第一个字节执行 `XOR`，将其与 `fc0`
    执行 `XOR`，从而通过对其执行 `XOR` 操作来更新 `b[0]` 的值为 `90`。这对于 Foxmail 6.5 是固定的。
- en: Now, we copy the array magic twice into a new array, `double_magic`. We also
    declare the size of `double_magic` one less than that of array `b`. We perform
    `XOR` on all the elements of array `b` and the `double_magic` array, except the
    first element of `b` on which we already performed a XOR operation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将数组`magic`复制两次到一个新数组`double_magic`中。我们还声明`double_magic`的大小比数组`b`少一个。我们对数组`b`和`double_magic`数组的所有元素执行`XOR`操作，除了数组`b`的第一个元素，我们已经对其执行了XOR操作。
- en: We store the result of the XOR operation in array `d`. We subtract the complete
    array `d` from array `b` in the next instruction. However, if the value is less
    than 0 for a particular subtraction operation, we add 255 to the element of array
    `d`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将XOR操作的结果存储在数组`d`中。在下一条指令中，我们将完整的数组`d`从数组`b`中减去。但是，如果特定减法操作的值小于0，我们将向数组`d`的元素添加255。
- en: In the next step, we simply append the ASCII value of the particular element
    from the resultant array `e` into the `decoded` variable, and return it to the
    calling statement.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们只需将结果数组`e`中特定元素的ASCII值附加到`decoded`变量中，并将其返回给调用语句。
- en: 'Let''s see what happens when we run this module:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行这个模块时会发生什么：
- en: '![](img/ab5556c2-f187-49c8-8b79-7385b72ebc5c.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab5556c2-f187-49c8-8b79-7385b72ebc5c.png)'
- en: It is clear that we easily decrypted the credentials stored in Foxmail 6.5.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们轻松解密了存储在Foxmail 6.5中的凭据。
- en: Breakthrough Meterpreter scripting
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突破Meterpreter脚本
- en: The Meterpreter shell is the most desired type of access an attacker would like
    to have on the target. Meterpreter gives the attacker a broad set of tools to
    perform a variety of tasks on the compromised system. Meterpreter has many built-in
    scripts, which makes it easier for an attacker to attack the system. These scripts
    perform tedious and straightforward tasks on the compromised system. In this section,
    we will look at those scripts, what they are made of, and how we can leverage
    them in Meterpreter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter shell是攻击者希望在目标上拥有的最理想的访问类型。Meterpreter为攻击者提供了广泛的工具集，可以在受损系统上执行各种任务。Meterpreter有许多内置脚本，这使得攻击者更容易攻击系统。这些脚本在受损系统上执行繁琐和直接的任务。在本节中，我们将看看这些脚本，它们由什么组成，以及我们如何在Meterpreter中利用它们。
- en: The basic Meterpreter commands cheat sheet is available at: [http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf](http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Meterpreter命令速查表可在以下网址找到：[http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf](http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf)。
- en: Essentials of Meterpreter scripting
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meterpreter脚本的基本知识
- en: As far as we have seen, we have used Meterpreter in situations where we needed
    to perform some additional tasks on the system. However, now we will look at some
    of the problematic situations that may arise during a penetration test, where
    the scripts already present in Meterpreter seem to be of no help to us. Most likely,
    in this kind of situation, we will want to add our custom functionalities to Meterpreter
    and perform the required tasks. However, before we proceed to add custom scripts
    in Meterpreter, let's perform some of the advanced features of Meterpreter first,
    and understand its power.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所见，我们在需要在系统上执行一些额外任务时使用了Meterpreter。然而，现在我们将看一些可能在渗透测试中出现的问题情况，在这些情况下，Meterpreter中已经存在的脚本似乎对我们没有帮助。在这种情况下，我们很可能希望向Meterpreter添加我们自定义的功能，并执行所需的任务。然而，在我们继续向Meterpreter添加自定义脚本之前，让我们先执行一些Meterpreter的高级功能，并了解其功能。
- en: Setting up persistent access
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立持久访问
- en: 'Once we have access to the target machine, we can pivot to internal networks,
    as we saw in the previous chapter, but it is also mandatory to retain the hard-earned
    access. However, for a sanctioned penetration test, it should be mandatory only
    for the duration of the test and should be within the scope of the project. Meterpreter
    permits us to install backdoors on the target using two different approaches:
    **MetSVC** and **Persistence**.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问了目标机器，我们可以像在上一章中看到的那样转移到内部网络，但是保留辛苦获得的访问权限也是必要的。但是，对于经过批准的渗透测试，这应该只在测试期间是强制性的，并且应该在项目的范围内。Meterpreter允许我们使用两种不同的方法在目标上安装后门：**MetSVC**和**Persistence**。
- en: We will see some of the advanced persistence techniques in the upcoming chapters.
    Hence, here we will discuss the MetSVC method. The MetSVC service is installed
    in the compromised system as a service. Moreover, it opens a port permanently
    for the attacker to connect to whenever he or she wants.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到一些高级的持久性技术。因此，在这里我们将讨论MetSVC方法。MetSVC服务被安装在受损系统中作为一个服务。此外，它永久地为攻击者打开一个端口，以便他或她随时连接。
- en: 'Installing MetSVC at the target is easy. Let''s see how we can do this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标上安装MetSVC很容易。让我们看看我们如何做到这一点：
- en: '![](img/dbc90c86-3243-4b22-a01b-0516d64dc105.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbc90c86-3243-4b22-a01b-0516d64dc105.png)'
- en: We can see that the MetSVC service creates a service at port `31337`, and uploads
    the malicious files as well.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，MetSVC服务在端口`31337`创建了一个服务，并且还上传了恶意文件。
- en: 'Later, whenever access is required to this service, we need to use the `metsvc_bind_tcp`
    payload with an exploit-handler script, which will allow us to connect to the
    service again, as shown in the following screenshot:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，每当需要访问此服务时，我们需要使用`metsvc_bind_tcp`有效载荷和一个利用处理程序脚本，这将允许我们再次连接到服务，如下面的屏幕截图所示：
- en: '![](img/ccffdeee-c153-4038-9320-6bb14589c054.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccffdeee-c153-4038-9320-6bb14589c054.png)'
- en: The effect of MetSVC remains even after a reboot of the target machine. MetSVC
    is handy when we need permanent access to the target system, as it saves time
    that is required for re-exploitation of the target.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: MetSVC的效果甚至在目标机器重新启动后仍然存在。当我们需要对目标系统进行永久访问时，MetSVC非常方便，因为它节省了重新利用目标所需的时间。
- en: API calls and mixins
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API调用和混合
- en: We just saw how we could perform advanced tasks with Meterpreter. This indeed
    makes the life of a penetration tester easier.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用Meterpreter执行高级任务。这确实使渗透测试人员的生活变得更加轻松。
- en: Now, let's dig deeper into the working of Meterpreter and uncover the underlying
    building process of Meterpreter modules and scripts. Sometimes, it might happen
    that we may run out of Meterpreter's offerings and desire customized functionality
    to perform all the required tasks. In that case, we need to build our own custom
    Meterpreter modules that can implement or automate various tasks which are needed
    at the time of exploitation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解Meterpreter的工作原理，并揭示Meterpreter模块和脚本的基本构建过程。有时，我们可能会用尽Meterpreter的功能，并希望自定义功能来执行所有所需的任务。在这种情况下，我们需要构建自己的自定义Meterpreter模块，以实现或自动化在利用时所需的各种任务。
- en: Let's first understand the basics of Meterpreter scripting. The base for coding
    with Meterpreter is the **Application Programming Interface** (**API**) calls
    and mixins. These are required to perform specific tasks using a specific Windows-based
    **Dynamic Link Library** (**DLL)** and some common tasks using a variety of built-in
    Ruby-based modules.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解Meterpreter脚本的基础知识。使用Meterpreter进行编码的基础是**应用程序编程接口**（**API**）调用和混入。这些是使用特定的基于Windows的**动态链接库**（**DLL**）执行特定任务所需的，以及使用各种内置的基于Ruby的模块执行一些常见任务所需的。
- en: Mixins are Ruby-programming-based classes that contain methods from various
    other classes. Mixins are extremely helpful when we perform a variety of tasks
    at the target system. In addition to this, mixins are not exactly part of IRB,
    but they can be beneficial to write specific and advanced Meterpreter scripts
    with ease.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是基于Ruby编程的类，其中包含来自各种其他类的方法。当我们在目标系统上执行各种任务时，混入非常有帮助。除此之外，混入并不完全属于IRB，但它们可以帮助轻松编写特定和高级的Meterpreter脚本。
- en: For more information on mixins, refer to: [http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins](http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有关混入的更多信息，请参阅：[http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins](http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins)。
- en: I recommend that you all have a look at the `/lib/rex/post/meterpreter` and
    `/lib/msf/scripts/meterpreter` directories, to check out the various libraries
    used by meterpreter.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议大家查看`/lib/rex/post/meterpreter`和`/lib/msf/scripts/meterpreter`目录，以查看Meterpreter使用的各种库。
- en: API calls are Windows-specific calls used to call out specific functions from
    a Windows DLL file. We will learn about API calls shortly in the *Working with
    RailGun* section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: API调用是用于从Windows DLL文件中调用特定函数的Windows特定调用。我们将在*使用RailGun*部分很快学习有关API调用的知识。
- en: Fabricating custom Meterpreter scripts
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作自定义Meterpreter脚本
- en: Let's work out a simple example Meterpreter script, which will check whether
    we are an admin user, and then find the explorer process and migrate into it automatically.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来编写一个简单的示例Meterpreter脚本，它将检查我们是否是管理员用户，然后找到资源管理器进程并自动迁移到其中。
- en: 'Before looking into the code, let''s see all of the essential methods we will
    be using:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之前，让我们看看我们将使用的所有基本方法：
- en: '| **Functions** | **Library file** | **Usage** |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库文件** | **用法** |'
- en: '| `is_admin` | `/lib/msf/core/post/windows/priv.rb` | Checks if the session
    has admin privileges or not. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `is_admin` | `/lib/msf/core/post/windows/priv.rb` | 检查会话是否具有管理员权限。|'
- en: '| `is_in_admin_group` | `/lib/msf/core/post/windows/priv.rb` | Checks if a
    user belongs to an administrator group. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `is_in_admin_group` | `/lib/msf/core/post/windows/priv.rb` | 检查用户是否属于管理员组。|'
- en: '| `session.sys.process.get_processes()` | `/lib/rex/post/meterpreter/extensions/stdapi/sys/process.rb`
    | Lists all the running processes on the target. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `session.sys.process.get_processes()` | `/lib/rex/post/meterpreter/extensions/stdapi/sys/process.rb`
    | 列出目标上所有正在运行的进程。|'
- en: '| `session.core.migrate()` | `/lib/rex/post/meterpreter/client_core.rb` | Migrates
    the access from an existing process to the PID specified in the parameter. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `session.core.migrate()` | `/lib/rex/post/meterpreter/client_core.rb` | 将访问从现有进程迁移到参数中指定的PID。|'
- en: '| `is_uac_enabled?` | `/lib/msf/core/post/windows/priv.rb` | Checks if UAC
    is enabled. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `is_uac_enabled?` | `/lib/msf/core/post/windows/priv.rb` | 检查UAC是否已启用。|'
- en: '| `get_uac_level` | `/lib/msf/core/post/windows/priv.rb` | Gets the UAC level:
    0,2,5 and so on. 0: Disabled, 2: All, 5: Default. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `get_uac_level` | `/lib/msf/core/post/windows/priv.rb` | 获取UAC级别：0,2,5等。0：已禁用，2：全部，5：默认。|'
- en: 'Let''s look at the following code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE45]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We just check if the current user is an admin or not in the preceding code.
    The function `is_admin` returns a Boolean value, and based on that we print the
    result:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是检查前面的代码中当前用户是否是管理员。函数`is_admin`返回一个布尔值，基于此我们打印结果：
- en: '[PRE46]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the previous code, we check if the user belongs to the administrator''s
    group or not. The preceding piece of code is very similar to the previous one
    in terms of logic:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们检查用户是否属于管理员组。在逻辑上，前面的代码片段与先前的代码非常相似：
- en: '[PRE47]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The segment here is an exciting piece of code. We start by finding the current
    process ID using `session.sys.process.getpid` and then loop through all the processes
    on the target system using the loop on `session.sys.process.get_processes()`.
    If any process is found with the name `explorer.exe`, we print out a message and
    store its ID to an `explorer_ppid` variable. Using the `session.core.migrate()`
    method, we pass the stored process ID (`explorer.exe`) to migrate into the `explorer.exe`
    process. Finally, we just print out the current process ID again to ensure if
    we migrated successfully or not:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码段非常有趣。我们首先使用`session.sys.process.getpid`找到当前进程ID，然后使用`session.sys.process.get_processes()`上的循环遍历目标系统上的所有进程。如果找到任何名称为`explorer.exe`的进程，我们打印出一条消息并将其ID存储到`explorer_ppid`变量中。使用`session.core.migrate()`方法，我们将存储的进程ID（`explorer.exe`）传递到`explorer.exe`进程中进行迁移。最后，我们只是再次打印当前进程ID，以确保我们是否成功迁移：
- en: '[PRE48]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the previous piece of code, we simply find the current user''s identifier
    using the `sessions.sys.config.getuid` method:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们只是使用`sessions.sys.config.getuid`方法找到当前用户的标识符：
- en: '[PRE49]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code checks if UAC is enabled on the target system or not. In
    case UAC is enabled, we further drill down to find the level of UAC by using the
    `get_uac_level` method, and print the status through its response values.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码检查了目标系统上是否启用了UAC。如果启用了UAC，我们进一步深入，使用`get_uac_level`方法找到UAC的级别，并通过其响应值打印状态。
- en: 'Let''s save this code in the `/scripts/meterpreter/gather.rb` directory and
    launch this script from Meterpreter. This will give you an output similar to the
    following screenshot:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码保存在`/scripts/meterpreter/gather.rb`目录中，并从Meterpreter中启动此脚本。这将给您一个类似于以下屏幕截图的输出：
- en: '![](img/c19600f6-ff72-4397-9699-4228a20765f6.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c19600f6-ff72-4397-9699-4228a20765f6.png)'
- en: We can see how easy it was to create Meterpreter scripts, and perform a variety
    of tasks and task automation as well. I recommend you examine all the included
    files and paths used in the module for exploring Meterpreter extensively.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，创建Meterpreter脚本并执行各种任务和任务自动化是多么容易。我建议您检查模块中包含的所有文件和路径，以便广泛探索Meterpreter。
- en: According to the official wiki of Metasploit, you should no longer write Meterpreter
    scripts and instead write post-exploitation modules.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Metasploit的官方维基，您不应再编写Meterpreter脚本，而应编写后渗透模块。
- en: Working with RailGun
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RailGun
- en: RailGun sounds like a top-notch gun spitting out bullets faster than light;
    however, this is not the case. RailGun allows you to make calls to a Windows API
    without the need to compile your own DLL.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 电磁炮听起来像是一种比光还快的枪，射出子弹；然而，事实并非如此。RailGun允许您调用Windows API，而无需编译自己的DLL。
- en: It supports numerous Windows DLL files and eases the way for us to perform system-level
    tasks on the victim machine. Let's see how we can perform various tasks using
    RailGun, and carry out some advanced post-exploitation with it.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持许多Windows DLL文件，并为我们在受害者机器上执行系统级任务提供了便利。让我们看看如何使用RailGun执行各种任务，并进行一些高级的后渗透。
- en: Interactive Ruby shell basics
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式Ruby shell基础知识
- en: 'RailGun requires the `irb` shell to be loaded into Meterpreter. Let''s look
    at how we can jump to the `irb` shell from Meterpreter:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: RailGun需要将`irb` shell加载到Meterpreter中。让我们看看如何从Meterpreter跳转到`irb` shell：
- en: '![](img/d30b74c7-6dae-406e-8b49-bd33212e7df5.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d30b74c7-6dae-406e-8b49-bd33212e7df5.jpg)'
- en: We can see in the preceding screenshot that merely typing in `irb` from Meterpreter
    allows us to drop in the Ruby-interactive shell. We can perform a variety of tasks
    with the Ruby shell from here.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的屏幕截图中看到，仅仅从Meterpreter中键入`irb`就可以让我们进入Ruby交互式shell。我们可以在这里使用Ruby shell执行各种任务。
- en: Understanding RailGun and its scripting
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解RailGun及其脚本
- en: RailGun gives us immense power to perform tasks that Metasploit may not be able
    to carry out at times. Using RailGun, we can raise exception calls to any DLL
    file from the breached system.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: RailGun给了我们巨大的力量，可以执行Metasploit有时无法执行的任务。使用RailGun，我们可以向被侵入系统的任何DLL文件发出异常调用。
- en: 'Now, let''s see how we can call a function using basic API calls with RailGun,
    and understand how it works:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用RailGun进行基本API调用，并了解其工作原理：
- en: '[PRE50]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is the basic structure of an API call in RailGun. The `client.railgun`
    keyword defines the need of RailGun functionality for the client. The `DLLname`
    keyword specifies the name of the DLL file to which we will be making a call.
    The `function (parameters)` keyword in the syntax specifies the actual API function
    that is to be provoked with required parameters from the DLL file.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RailGun中API调用的基本结构。`client.railgun`关键字定义了客户端对RailGun功能的需求。`DLLname`关键字指定了我们将要调用的DLL文件的名称。语法中的`function
    (parameters)`关键字指定了要使用来自DLL文件的所需参数来激发的实际API函数。
- en: 'Let''s see an example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '![](img/43415550-6936-42db-ad36-87e3556a5b50.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43415550-6936-42db-ad36-87e3556a5b50.png)'
- en: 'The result of this API call is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 此API调用的结果如下：
- en: '![](img/368aa390-7c19-4ffd-9d98-917a0ada5957.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/368aa390-7c19-4ffd-9d98-917a0ada5957.png)'
- en: Here, a call is made to the `LockWorkStation()` function from the `user32.dll`
    DLL file that results in the locking of the compromised system.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用了来自`user32.dll` DLL文件的`LockWorkStation()`函数，导致了受损系统的锁定。
- en: 'Next, let''s see an API call, with parameters:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个带参数的API调用：
- en: '[PRE51]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When the preceding command runs, it deletes a particular user from the client''s
    machine. Currently, we have the following users:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述命令运行时，它会从客户端的机器中删除特定用户。目前，我们有以下用户：
- en: '![](img/2b3f1cfb-ab15-4472-be69-915aedfebbe0.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b3f1cfb-ab15-4472-be69-915aedfebbe0.png)'
- en: 'Let''s try deleting the `Nipun` username:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试删除`Nipun`用户名：
- en: '![](img/e76bfca2-5f19-4491-b614-c3fee8538e42.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e76bfca2-5f19-4491-b614-c3fee8538e42.png)'
- en: 'Let''s check whether the user has been successfully removed or not:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查用户是否已成功删除：
- en: '![](img/295610ba-e3f2-46e2-ac1c-cb3d70530ecb.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](img/295610ba-e3f2-46e2-ac1c-cb3d70530ecb.png)'
- en: The user seems to have gone fishing. The RailGun call has removed the user `Nipun`
    successfully. The `nil` value defines that the user is on the local machine. However,
    we can also target remote systems using a value for the name parameter.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 用户似乎已经去钓鱼了。RailGun调用已成功删除了用户`Nipun`。`nil`值定义了用户在本地机器上。但是，我们也可以使用名称参数来针对远程系统。
- en: Manipulating Windows API calls
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵Windows API调用
- en: DLL files are responsible for carrying out the majority of tasks on Windows-based
    systems. Therefore, it is essential to understand which DLL file contains which
    methods. This is very similar to the library files of Metasploit, which have various
    methods in them. To study Windows API calls, we have excellent resources at [http://source.winehq.org/WineAPI/](http://source.winehq.org/WineAPI/)
    and [http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx).
    I recommend you explore a variety of API calls before proceeding further with
    creating RailGun scripts.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: DLL文件负责在基于Windows的系统上执行大部分任务。因此，了解哪个DLL文件包含哪些方法是至关重要的。这与Metasploit的库文件非常相似，它们中有各种方法。要研究Windows
    API调用，我们在[http://source.winehq.org/WineAPI/](http://source.winehq.org/WineAPI/)和[http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx)上有很好的资源。我建议在继续创建RailGun脚本之前，您探索各种API调用。
- en: 'Refer to the following path to find out more about RailGun-supported DLL files:
    `/usr/share/metasploit-framework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下路径，了解有关RailGun支持的DLL文件的更多信息：`/usr/share/metasploit-framework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`。
- en: Fabricating sophisticated RailGun scripts
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作复杂的RailGun脚本
- en: 'Taking a step further, let''s delve deeper into writing scripts using RailGun
    for meterpreter extensions. First let''s create a script which will add a custom-named
    DLL file to the Metasploit context:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，让我们深入研究使用RailGun编写Meterpreter扩展的脚本。首先，让我们创建一个脚本，该脚本将向Metasploit上下文中添加一个自定义命名的DLL文件：
- en: '[PRE52]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Save the code under a file named `urlmon.rb`, under the `/scripts/meterpreter`
    directory.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存在名为`urlmon.rb`的文件中，放在`/scripts/meterpreter`目录下。
- en: The preceding script adds a reference path to the `C:\WINDOWS\system32\urlmon.dll`
    file that contains all the required functions for browsing, and functions such
    as downloading a particular file. We save this reference path under the name `urlmon`.
    Next, we add a function to the DLL file using the DLL file's name as the first
    parameter, and the name of the function we are going to hook as the second parameter,
    which is `URLDownloadToFileA`, followed by the required parameters. The very first
    line of the code checks whether the DLL function is already present in the DLL
    file or not. If it is already present, the script will skip adding the function
    again. The `pcaller` parameter is set to `NULL` if the calling application is
    not an ActiveX component; if it is, it is set to the COM object. The `szURL` parameter
    specifies the URL to download. The `szFileName` parameter specifies the filename
    of the downloaded object from the URL. `Reserved` is always set to `NULL`, and
    `lpfnCB` handles the status of the download. However, if the status is not required,
    this value should be set to `NULL`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本向`C:\WINDOWS\system32\urlmon.dll`文件添加了一个引用路径，其中包含所有浏览所需的函数，以及下载特定文件等功能。我们将此引用路径保存为`urlmon`的名称。接下来，我们使用DLL文件的名称作为第一个参数，我们将要挂钩的函数的名称作为第二个参数，即`URLDownloadToFileA`，然后是所需的参数，向DLL文件添加一个函数。代码的第一行检查DLL函数是否已经存在于DLL文件中。如果已经存在，脚本将跳过再次添加该函数。如果调用应用程序不是ActiveX组件，则将`pcaller`参数设置为`NULL`；如果是，则设置为COM对象。`szURL`参数指定要下载的URL。`szFileName`参数指定从URL下载的对象的文件名。`Reserved`始终设置为`NULL`，`lpfnCB`处理下载的状态。但是，如果不需要状态，则应将此值设置为`NULL`。
- en: Let's now create another script which will make use of this function. We will
    create a post-exploitation script that will download a freeware file manager and
    will modify the entry for the utility manager on the Windows OS. Therefore, whenever
    a call is made to the utility manager, our freeware program will run instead.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建另一个脚本，该脚本将利用此功能。我们将创建一个后渗透脚本，该脚本将下载一个免费文件管理器，并将修改Windows OS上实用程序管理器的条目。因此，每当调用实用程序管理器时，我们的免费程序将代替运行。
- en: 'We create another script in the same directory and name it `railgun_demo.rb`,
    as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一目录下创建另一个脚本，并将其命名为`railgun_demo.rb`，如下所示：
- en: '[PRE53]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As stated previously, the first line of the script will call the custom-added
    DLL function `URLDownloadToFile` from the `urlmon` DLL file, with the required
    parameters.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，脚本的第一行将调用自定义添加的DLL函数`URLDownloadToFile`，并提供所需的参数。
- en: Next, we create a key, `Utilman.exe`, under the parent key, `HKLMSOFTWAREMicrosoftWindows
    NTCurrentVersionImage File Execution Options`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在父键`HKLMSOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution
    Options`下创建一个名为`Utilman.exe`的键。
- en: We create a registry value of type `REG_SZ` named `Debugger` under the `utilman.exe`
    key. Lastly, we assign the value `a43.exe` to the `Debugger`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`utilman.exe`键下创建一个名为`Debugger`的`REG_SZ`类型的注册表值。最后，我们将值`a43.exe`分配给`Debugger`。
- en: 'Let''s run this script from the Meterpreter to see how things work:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Meterpreter运行此脚本，看看情况如何：
- en: '![](img/811f4a49-d537-441c-b9f0-7b9e0d639357.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](img/811f4a49-d537-441c-b9f0-7b9e0d639357.png)'
- en: As soon as we run the `railgun_demo` script, the file manager is downloaded
    using the `urlmon.dll` file and is placed in the `system32` directory. Next, registry
    keys are created that replace the default behavior of the utility manager to run
    the `a43.exe` file. Therefore, whenever the ease-of-access button is pressed from
    the login screen, instead of the utility manager, the `a43` file manager shows
    up and serves as a login screen backdoor on the target system.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行`railgun_demo`脚本，文件管理器将使用`urlmon.dll`文件下载，并放置在`system32`目录中。接下来，创建注册表键，以替换实用程序管理器的默认行为，运行`a43.exe`文件。因此，每当从登录屏幕按下辅助功能按钮时，`a43`文件管理器将显示并作为目标系统上的登录屏幕后门。
- en: 'Let''s see what happens when we press the ease-of-access button from the login
    screen, in the following screenshot:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从登录屏幕按下辅助功能按钮时会发生什么，如下截图所示：
- en: '![](img/831b6cc5-2b48-459f-88df-336d3bbc4184.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831b6cc5-2b48-459f-88df-336d3bbc4184.png)'
- en: We can see that it opens an `a43` file manager instead of the utility manager.
    We can now perform a variety of functions including modifying the registry, interacting
    with CMD, and much more, without logging into the target. You can see the power
    of RailGun, which eases the process of creating a path to whichever DLL file you
    want, and allows you to add custom functions to it as well.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它打开了一个`a43`文件管理器，而不是实用程序管理器。现在我们可以执行各种功能，包括修改注册表、与CMD交互等，而无需登录到目标。您可以看到RailGun的强大之处，它简化了创建您想要的任何DLL文件的路径的过程，并且还允许您向其中添加自定义功能。
- en: More information on this DLL function is available at: [https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此DLL函数的更多信息，请访问：[https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85))。
- en: Summary and exercises
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和练习
- en: In this chapter, we covered coding for Metasploit. We worked on modules, post-exploitation
    scripts, Meterpreter, RailGun, and Ruby programming too. Throughout this chapter,
    we saw how we could add our custom functions to the Metasploit framework, and
    make the already powerful framework much more powerful. We began with familiarizing
    ourselves with the basics of Ruby. We learned about writing auxiliary modules,
    post-exploitation scripts, and Meterpreter extensions. We saw how we could make
    use of RailGun to add custom functions, such as adding a DLL file and a custom
    function to the target's DLL files.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了Metasploit的编码工作。我们还研究了模块、后渗透脚本、Meterpreter、RailGun和Ruby编程。在本章中，我们看到了如何向Metasploit框架添加我们自定义的功能，并使已经强大的框架变得更加强大。我们首先熟悉了Ruby的基础知识。我们学习了编写辅助模块、后渗透脚本和Meterpreter扩展。我们看到了如何利用RailGun添加自定义功能，比如向目标的DLL文件添加DLL文件和自定义功能。
- en: 'For additional learning, you can try the following exercises:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步学习，您可以尝试以下练习：
- en: Create an authentication brute force module for FTP
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为FTP创建一个身份验证暴力破解模块
- en: Work on at least three post-exploitation modules each for windows, Linux, and
    macOS, which are not yet a part of Metasploit
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Windows、Linux和macOS各开发至少三个后渗透模块，这些模块尚不是Metasploit的一部分
- en: Work on RailGun and develop custom modules for at least three different functions from
    any unknown Windows DLLs
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RailGun上工作，并为至少三个不同功能的Windows DLL开发自定义模块
- en: In the next chapter, we will look at development in context and exploiting the
    modules in Metasploit. This is where we will begin to write custom exploits, fuzz
    various parameters for exploitation, exploit software, and write advanced exploits
    for software and the web.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在Metasploit中的开发和利用模块的背景下进行研究。这是我们将开始编写自定义利用、对各种参数进行模糊测试以进行利用、利用软件，并为软件和网络编写高级利用的地方。
