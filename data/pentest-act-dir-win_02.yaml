- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Defense Evasion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御规避
- en: The main idea of this chapter is simple – *know your tooling*. It can be very
    tempting to start pulling fresh tooling from GitHub after getting an initial foothold
    on the target machine, looking for low-hanging fruit and quick wins. It may work
    well in some training labs to learn about attacking concepts; however, during
    real engagement, a mature opponent can easily detect your malicious activity.
    There are quite a lot of professionally written tools for both defense and offense,
    not to mention C2 frameworks, vendor EDRs, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要思想很简单 – *了解你的工具*。在获得目标机器的初始立足点后，从GitHub上获取新工具可能非常诱人，寻找低 hanging fruit 和快速胜利。在一些培训实验室中学习攻击概念可能效果很好；然而，在真实的参与中，一个成熟的对手可以轻松检测到你的恶意活动。有很多专业编写的工具，既有防御也有进攻，更不用说C2框架、供应商EDR等等。
- en: This chapter is not a fully comprehensive guide on how to evade all possible
    detection. Evasion is a constantly evolving game between the sword and the shield.
    Several factors can influence the way offensive operation is going, including
    preparation, the development of specific tooling, the team’s skill set, and the
    capabilities of both sides. We are not going to touch EDR/antivirus evasion. Excellent
    books have been published that will teach you how to find and develop possible
    bypasses, including attacking security solutions themselves.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是一个完全全面的指南，教你如何规避所有可能的检测。规避是一个不断发展的游戏，处于攻击和防御之间。有几个因素可以影响进攻操作的方式，包括准备工作、特定工具的开发、团队的技能组合以及双方的能力。我们不会触及EDR/杀毒软件规避。已经出版了一些优秀的书籍，将教你如何找到和开发可能的绕过方法，包括攻击安全解决方案本身。
- en: 'We will focus on built-in security capabilities that can be deployed and enforced
    in the Windows environment. In this chapter, we are going to cover the following
    main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于可以在Windows环境中部署和强制执行的内置安全功能。在本章中，我们将涵盖以下主要主题：
- en: AMSI, AppLocker, and PowerShell **Constrained Language Mode** (**CLM**) deployment
    and bypass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMSI、AppLocker和PowerShell **Constrained Language Mode**（**CLM**）的部署和绕过
- en: Deploy PowerShell Enhanced Logging, evade it, and use Sysmon to detect yourself
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署PowerShell增强日志记录，规避它，并使用Sysmon来检测自己
- en: What is ETW? What extra capabilities and insights can it provide?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是ETW？它可以提供什么额外的功能和见解？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will use only two VMs from the GOADv2 lab – DC01 and SRV01\.
    Ensure that SRV01 is a domain-joined machine, as we are going to use Group Policies
    during this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将只使用GOADv2实验室中的两个虚拟机 – DC01和SRV01。确保SRV01是一个加入域的机器，因为我们将在本章中使用组策略。
- en: AMSI, PowerShell CLM, and AppLocker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMSI、PowerShell CLM和AppLocker
- en: In this section, we will discuss some of the built-in capabilities in Windows
    that can limit attacker’s actions on the compromised machine. AMSI, AppLocker,
    and PowerShell CLM can be bypassed in different ways, but considering them as
    defense in depth is a good decision. As usual, we need to know the limitations
    and cover bypasses where it is possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Windows中一些内置功能，可以限制攻击者在受损机器上的操作。AMSI、AppLocker和PowerShell CLM可以以不同方式被绕过，但将它们视为深度防御是一个明智的决定。像往常一样，我们需要了解限制，并在可能的情况下覆盖绕过。
- en: Antimalware Scan Interface
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Antimalware Scan Interface
- en: Let’s first discuss what **Antimalware Scan Interface** (**AMSI**) is. Microsoft
    developed it to provide a set of API calls for applications, including any third-party
    applications, to perform a signature-based scan of the content. Windows Defender
    uses it to scan PowerShell scripts, .NET, VBA macros, **Windows Script Host**
    (**WSH**), VBScript, and JavaScript to detect common malware. The important thing
    about AMSI is that you do not need to deploy it; it has been there since Windows
    10.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论**Antimalware Scan Interface**（**AMSI**）是什么。微软开发了它，为应用程序提供一组API调用，包括任何第三方应用程序，以执行基于签名的内容扫描。Windows
    Defender使用它来扫描PowerShell脚本、.NET、VBA宏、**Windows脚本宿主**（**WSH**）、VBScript和JavaScript以检测常见恶意软件。关于AMSI的重要之处在于你不需要部署它；自Windows
    10以来它一直存在。
- en: 'In plain words, the AMSI algorithm works as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，AMSI算法的工作原理如下：
- en: '**amsi.dll** will be loaded into the process memory space; for example, PowerShell
    and **AmsiInitialize** will be called.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**amsi.dll**将加载到进程内存空间中；例如，PowerShell和**AmsiInitialize**将被调用。'
- en: Then, **AmsiOpenSession** is called, which opens a session for a scan.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用**AmsiOpenSession**，为扫描打开一个会话。
- en: The script content will be scanned before the execution invoking one of the
    APIs is called – **AmsiScanBuffer** or **AmsiScanString**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用其中一个API（**AmsiScanBuffer**或**AmsiScanString**）执行之前，脚本内容将被扫描。
- en: If the content is clear from known malicious signatures, Microsoft Defender
    will return **1** as the result and the script will be executed.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内容没有已知的恶意签名，Microsoft Defender将返回**1**作为结果，脚本将被执行。
- en: 'To confirm this AMSI behavior, we can use Process Hacker[1] or API monitor[2].
    These open source tools allow us to see loaded in-process modules, get information
    about them, and a lot of other information. In the following screenshot, we can
    see the loaded **amsi.dll** and a list of exported functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认AMSI的行为，我们可以使用Process Hacker[1]或API monitor[2]。这些开源工具允许我们查看加载的进程内模块，获取有关它们的信息以及其他许多信息。在以下截图中，我们可以看到已加载的**amsi.dll**及其导出的函数列表：
- en: '![Figure 2.1 – Loaded amsi.dll and exported functions](image/B18964_02_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 加载的 amsi.dll 及其导出函数](image/B18964_02_01.jpg)'
- en: Figure 2.1 – Loaded amsi.dll and exported functions
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 加载的 amsi.dll 及其导出函数
- en: 'One important caveat from the Microsoft documentation is as follows – “*But
    you ultimately need to supply the scripting engine with plain, un-obfuscated code.
    And that is the point at which you invoke the AMSI APIs*.” A quick test to prove
    this statement is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Microsoft文档的重要警告如下：“*但你最终需要向脚本引擎提供纯净的、未混淆的代码。正是在这个点上你调用AMSI API*。”用来证明这一点的快速测试如下：
- en: '![Figure 2.2 – Detection and concatenation](image/B18964_02_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 检测与串联](image/B18964_02_02.jpg)'
- en: Figure 2.2 – Detection and concatenation
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 检测与串联
- en: It looks trivial. We can split the string first and then bypass AMSI using concatenation,
    but in more complex code this approach will require much more effort. There are
    a few strategies that were used by researchers to develop reliable bypasses –
    encoding/obfuscation, hooking, memory patching, forcing an error, registry key
    modification, and DLL hijacking. You can find two great compiled lists of bypasses
    and credits to original research created by *S3cur3Th1sSh1t*[3] and *Pentest Laboratories*[4].
    Some of the bypasses look like a one-liner, but I highly encourage you to dive
    deeper and review them, read the original research, and follow the thought process.
    It’s also worth mentioning that not every bypass will be successful, as Microsoft
    tries to patch them as well. The chances are not great that the good old base64-encoded
    one-liners will do the trick. The best way to ensure that your bypass will work
    in the target environment is to precisely identify the victim’s OS version, recreate
    it in your lab environment, and test, test, test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单。我们可以先分割字符串，然后使用串联绕过AMSI，但在更复杂的代码中，这种方法将需要更多的努力。研究人员用来开发可靠绕过的策略有很多——编码/混淆、钩子、内存修补、强制错误、注册表键修改和DLL劫持。你可以找到由*S3cur3Th1sSh1t*[3]和*Pentest
    Laboratories*[4]创建的两份很棒的绕过汇总列表及其原创研究致谢。某些绕过看起来像一个单行代码，但我强烈建议你深入研究并回顾它们，阅读原始研究并理解思维过程。还值得一提的是，并非每个绕过都会成功，因为微软也在不断修补它们。老牌的base64编码一行代码可能不会奏效。确保绕过在目标环境中有效的最佳方法是准确识别受害者的操作系统版本，在你的实验室环境中重现它，并进行测试、测试、测试。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For some quick wins, there is a great free website developed by *Flangvik* ([https://amsi.fail/](https://amsi.fail/)),
    where you can generate various PowerShell snippets to disable or break AMSI. Another
    helpful tool is Invoke-Obfuscation[5], written by *Daniel Bohannon*. This tool
    has different modes. For me, AST mode was the one that provided reliable bypasses
    most of the time. The idea is that the script will be obfuscated in such a way
    that it breaks the AST parsing algorithm in AMSI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些快速解决方案，有一个由*Flangvik*开发的免费优秀网站（[https://amsi.fail/](https://amsi.fail/)），你可以在这个网站上生成各种PowerShell代码片段来禁用或突破AMSI。另一个有用的工具是Invoke-Obfuscation[5]，由*Daniel
    Bohannon*编写。这个工具有不同的模式。对我而言，AST模式是大多数时候提供可靠绕过的模式。其原理是，脚本将被混淆处理，以至于打破AMSI中的AST解析算法。
- en: 'We will try to bypass AMSI using three different techniques: error forcing,
    obfuscation, and memory patching. As mentioned previously, I will use the SRV01
    machine:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用三种不同的技术绕过AMSI：错误强制、混淆和内存修补。如前所述，我将使用SRV01机器：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Way 1 – Error forcing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 1 – 错误强制
- en: 'Let’s first look at error-forcing code and a bit of split/concatenate fantasy:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看错误强制代码和一些分割/串联的幻想：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of running the preceding commands is shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令的结果如下面的截图所示：
- en: '![Figure 2.3 – Error forcing](image/B18964_02_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 强制错误](image/B18964_02_03.jpg)'
- en: Figure 2.3 – Error forcing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 强制错误
- en: Way 2 – Obfuscation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 2 – 混淆
- en: 'For AST obfuscation, let’s try to get reverse shell callback using **PowerShellTcpOneLine.ps1**
    from the Nishang framework[6] and the previously mentioned Invoke-Obfuscation
    tool. We will set up a listener on port 443 with powercat[7] on another Windows
    box. Here is the original reverse shell code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AST 混淆，我们可以尝试使用 Nishang 框架[6]中的 **PowerShellTcpOneLine.ps1** 反向 Shell 回调，以及之前提到的
    Invoke-Obfuscation 工具。我们将在另一台 Windows 计算机上使用 powercat[7] 在 443 端口上设置监听器。以下是原始的反向
    Shell 代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we try to run it, AMSI catches us:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行时，AMSI 捕获了我们：
- en: '![Figure 2.4 – AMSI blocks original reverse shell](image/B18964_02_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – AMSI 阻止原始反向 Shell](image/B18964_02_04.jpg)'
- en: Figure 2.4 – AMSI blocks original reverse shell
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – AMSI 阻止原始反向 Shell
- en: 'Let’s run the Invoke-Obfuscation tool, choosing AST obfuscation, and providing
    the path to our original reverse shell. After obfuscation, the code looked like
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 Invoke-Obfuscation 工具，选择 AST 混淆，并提供原始反向 Shell 的路径。经过混淆后，代码如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result obtained by running the preceding commands is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令得到的结果如下：
- en: '![Figure 2.5 – Obfuscated reverse shell callback](image/B18964_02_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 混淆后的反向 Shell 回调](image/B18964_02_05.jpg)'
- en: Figure 2.5 – Obfuscated reverse shell callback
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 混淆后的反向 Shell 回调
- en: Way 3 – Memory patch
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 3 – 内存补丁
- en: 'There are a few ways we can manipulate AMSI in memory to achieve the bypass.
    The key reasoning behind this is that we are in full control of the process where
    **amsi.dll** will be loaded. One of the examples is to force **AmsiScanBuffer**
    to return **AMSI_RESULT_CLEAN**. The general idea is to import API calls and then
    return a specific value to the **AmsiScanBuffer()** call: **0x80070057**. The
    original bypass is detected by AMSI now, so we can manipulate with assembly instructions
    by using a double **add** operand and successfully bypass the control. The code
    for this is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式在内存中操控 AMSI 来实现绕过。其背后的关键原因是我们完全控制了 **amsi.dll** 被加载的进程。一个例子是强制 **AmsiScanBuffer**
    返回 **AMSI_RESULT_CLEAN**。一般思路是导入 API 调用，然后返回一个特定的值给 **AmsiScanBuffer()** 调用：**0x80070057**。原始的绕过方法现在已被
    AMSI 检测到，因此我们可以通过使用双重 **add** 操作数并成功绕过控制来操控汇编指令。相关代码如下：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result obtained by running the preceding commands is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令得到的结果如下：
- en: '![Figure 2.6 – Successful AMSI disarm using memory patching](image/B18964_02_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 使用内存补丁成功解除 AMSI 防护](image/B18964_02_06.jpg)'
- en: Figure 2.6 – Successful AMSI disarm using memory patching
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 使用内存补丁成功解除 AMSI 防护
- en: Also, as an attacker, we cannot ignore the fact that some defensive mechanisms
    can be abused as well as bypassed. A great example was published by *netbiosX*[8],
    which stated that AMSI can be used to achieve persistence on the compromised host.
    Using previous research and their coding skills, a fake AMSI provider was developed
    and registered on the compromised host. Using a special keyword, we can initiate
    a callback home from our backdoor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，我们不能忽视一些防御机制也可能被滥用和绕过的事实。一个很好的例子是 *netbiosX*[8] 发布的内容，指出 AMSI 可以用来在被攻破的主机上实现持久性。利用之前的研究和他们的编码技巧，开发了一个伪造的
    AMSI 提供者并在被攻破的主机上注册。通过使用特殊的关键词，我们可以从后门发起回调。
- en: All the techniques mentioned here will leave some sort of trace on the victim’s
    machine. Moreover, even successful bypasses can still be caught by defenders.
    Excellent blog posts by *Pentest Laboratories*[9] and *F-Secure*[10] show how
    to create detections and share excellent ready-to-use recipes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此处提到的所有技术都会在受害者的机器上留下某种痕迹。此外，即使绕过成功，防御者仍然有可能捕捉到。*Pentest Laboratories*[9] 和
    *F-Secure*[10] 的精彩博客文章展示了如何创建检测并分享现成的可用方案。
- en: In the next section, we are going to discuss two security controls that are
    quite often deployed in corporate environments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论两种在企业环境中常见的安全控制措施。
- en: AppLocker and PowerShell CLM
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppLocker 和 PowerShell CLM
- en: 'AppLocker was added by Microsoft in Windows 7 as a successor to the older **Software
    Restriction Policies** (**SRP**). It was supposed to be a comprehensive application
    white-listing solution. With this feature, you can limit not only applications,
    but also scripts, batches, DLLs, and more. There are a few ways that a limit can
    be applied: by Name, Path, Publisher, or Hash. As stated by Microsoft, AppLocker
    is a security feature, not a boundary. Nowadays, the recommendation is to enforce
    **Windows Defender Application Control** (**WDAC**) as restrictively as possible
    and then use AppLocker to fine-tune the restrictions. However, in complex enterprise
    environments, it is still common to see AppLocker alone as it is easier to deploy
    and administrate.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AppLocker是微软在Windows 7中添加的，作为较旧的**软件限制策略**（**SRP**）的继任者。它本应成为一种全面的应用程序白名单解决方案。通过这个功能，你不仅可以限制应用程序，还可以限制脚本、批处理文件、DLL等。限制的方式有几种：按名称、路径、发布者或哈希值进行限制。微软指出，AppLocker是一个安全功能，而不是边界。现在的推荐做法是尽可能严格地执行**Windows
    Defender应用程序控制**（**WDAC**），然后使用AppLocker来微调限制。然而，在复杂的企业环境中，仍然常见单独使用AppLocker，因为它更容易部署和管理。
- en: To understand in more detail how AppLocker is working, I recommend you read
    four parts of *Tyraniddo*’s blog[11] about this feature. He starts the journey
    with the AppLocker setup and overview. In part 2, the author reveals how the process
    creation is blocked by the operating system’s kernel, followed by a clear example.
    Part 3 is devoted to rule processing, covering access tokens and access checks.
    Some basic understanding of security descriptors and tokens will not hurt the
    reader. The final part has a full focus on DLL blocking.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解AppLocker的工作原理，我建议你阅读*Tyraniddo*关于此功能的博客四个部分[11]。他从AppLocker的设置和概述开始。第二部分，作者揭示了操作系统内核如何阻止进程创建，并通过一个清晰的例子加以说明。第三部分专注于规则处理，涉及访问令牌和访问检查。读者对安全描述符和令牌的基本了解会有所帮助。最后一部分则完全聚焦于DLL阻止。
- en: Now that we know what AppLocker is, why do we need anything on top? What is
    PowerShell CLM, and how does it relate to AppLocker? In short, we can limit PowerShell
    sensitive language capabilities to the users by enabling CLM. Some examples of
    these sensitive capabilities are Windows API invocation, creating arbitrary types,
    and dot sourcing[12].
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了AppLocker是什么，为什么还需要其他功能呢？什么是PowerShell CLM，它与AppLocker有什么关系？简而言之，我们可以通过启用CLM来限制用户使用PowerShell的敏感语言功能。这些敏感功能的一些例子包括Windows
    API调用、创建任意类型和点源代码[12]。
- en: CLM can be enforced via environment variables or by setting it through language
    mode. However, these methods are not reliable and can be bypassed with almost
    no effort from the attacker. But with system-wide application control solutions,
    it can be used. The idea is that PowerShell will detect when the AppLocker policy
    is being enforced and will run only in CLM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CLM可以通过环境变量强制执行，或者通过语言模式进行设置。然而，这些方法不可靠，攻击者几乎不费吹灰之力就能绕过它们。但是，通过系统级的应用控制解决方案，它是可以使用的。其思想是，当AppLocker策略被执行时，PowerShell会检测到并仅在CLM中运行。
- en: '*How robust are* *these protections?*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些保护措施有多强大？*'
- en: 'We will deploy it in our **sevenkingdoms.local** lab domain. I advise you to
    take a snapshot before any change in the lab so we can quickly revert to the initial
    state if required. We will create an AppLocker group policy on DC01 and enforce
    it on the SRV01 server. If you have never deployed AppLocker, there is a friendly
    guide available[13]. The rule is straightforward – action, user, condition, and
    exceptions if required. By following the previously mentioned guide[13], we will
    create default rules and restrictions for users to run **cmd.exe**. One important
    caveat – if you are in the **Administrators** group, by default, AppLocker is
    not applied to your account. To check your current ruleset, we can use the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的**sevenkingdoms.local**实验室域中部署它。我建议在实验室中进行任何更改之前先拍摄一个快照，这样我们可以在需要时迅速恢复到初始状态。我们将在DC01上创建一个AppLocker组策略，并将其强制执行到SRV01服务器上。如果你从未部署过AppLocker，这里有一份友好的指南[13]。规则很简单——动作、用户、条件以及必要时的例外。通过遵循前面提到的指南[13]，我们将为用户创建默认规则并限制运行**cmd.exe**。一个重要的注意事项——如果你属于**管理员**组，默认情况下，AppLocker不会应用到你的账户。要检查当前的规则集，我们可以使用以下命令：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new **Deny_CMD** rule can be seen in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**Deny_CMD**规则可以在以下截图中看到：
- en: '![Figure 2.7 – Deny rule in AppLocker](image/B18964_02_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – AppLocker中的拒绝规则](image/B18964_02_07.jpg)'
- en: Figure 2.7 – Deny rule in AppLocker
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – AppLocker中的拒绝规则
- en: 'Moreover, as we enforced rules for scripts as well, PowerShell went down in
    CLM. It is easy to check using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们还对脚本强制执行了规则，PowerShell在CLM中失效了。可以使用以下命令轻松检查：
- en: '![Figure 2.8 – PowerShell CLM in action](image/B18964_02_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – PowerShell CLM的实际操作](image/B18964_02_08.jpg)'
- en: Figure 2.8 – PowerShell CLM in action
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – PowerShell CLM的实际操作
- en: The robustness of these security features depends on the quality of the rules
    we are implementing. In AppLocker, we have Publisher, File Hash, and Path conditions.
    Let’s briefly discuss all of them and show some possible bypasses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安全功能的健壮性取决于我们正在实施的规则的质量。在AppLocker中，我们有发布者、文件哈希和路径条件。让我们简要讨论它们并展示一些可能的绕过方法。
- en: '*Path* restrictions can be bypassed by evaluating trusted paths and copying
    our binary there; for example, there are plenty of subfolders inside **C:\Windows**,
    where the normal user can copy files. The File Hash deny rule can be bypassed
    by changing the binary with the known hash mentioned in the rule. Let’s bypass
    the first two conditions combined and execute **nc64.exe** on the host. I created
    the rule to block **nc64.exe** by its hash. We will first copy **nc64.exe** to
    the **C:\Windows\System32\spool\drivers\color\** and then bypass the File Hash
    rule by changing the File Hash by adding an extra **A** at the end of the file.
    The result of the bypass is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径*限制可以通过评估受信任的路径并将我们的二进制文件复制到那里来绕过；例如，在**C:\Windows**内有许多子文件夹，普通用户可以在那里复制文件。通过更改二进制文件为规则中提到的已知哈希值的二进制文件，可以绕过文件哈希拒绝规则。让我们绕过前两个条件并在主机上执行**nc64.exe**。我创建了一个规则，通过其哈希值阻止**nc64.exe**。我们首先将**nc64.exe**复制到**C:\Windows\System32\spool\drivers\color\**，然后通过在文件末尾添加额外的**A**来更改文件哈希值以绕过文件哈希规则。绕过的结果如下：'
- en: '![Figure 2.9 – Path and hash rule bypass for nc.exe](image/B18964_02_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – nc.exe的路径和哈希规则绕过](image/B18964_02_09.jpg)'
- en: Figure 2.9 – Path and hash rule bypass for nc.exe
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – nc.exe的路径和哈希规则绕过
- en: 'The *Publisher* condition is much more difficult to bypass. The reason is that
    the application’s publisher signature and extended attributes will be checked.
    We cannot use self-signed certificates to bypass it, but we can abuse legitimate
    signed binaries, which have the extended functionality we need. There is a whole
    project with a list of such binaries at [https://lolbas-project.github.io/](https://lolbas-project.github.io/).
    There are two well-illustrated blog posts about common LOLBAS abuse to bypass
    AppLocker using **InstallUtil**[14] and MSBuild[15]. In brief, we will use **MSBuild.exe**
    to compile and run our malicious code stored in an XML file; for example, with
    Windows APIs we can allocate memory, and copy and run our shellcode. Another method
    is to use InstallUtil to run our executable if it is located on the victim’s box:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*发布者*条件要难得多。原因是将检查应用程序的发布者签名和扩展属性。我们不能使用自签名证书来绕过它，但我们可以滥用具有我们需要的扩展功能的合法签名二进制文件。在[https://lolbas-project.github.io/](https://lolbas-project.github.io/)上有一个包含此类二进制文件列表的整个项目。有两篇关于常见LOLBAS滥用以绕过AppLocker的博客文章，使用**InstallUtil**[14]和MSBuild[15]。简而言之，我们将使用**MSBuild.exe**来编译和运行存储在XML文件中的恶意代码；例如，使用Windows
    API我们可以分配内存，并复制和运行我们的shellcode。另一种方法是使用InstallUtil在受害者的计算机上运行我们的可执行文件：'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what if **cmd.exe** is locked down? Not a big deal! You create shortcuts
    of the required binaries, such as InstallUtil and csc, then manually change the
    target field value so that it stores the required command line to execute. It
    is still reliably working until the LOLBAS binaries are not blocked. The entire
    project with the AppLocker bypasses list is available on GitHub[16]. By evaluating
    them, we can assess how robust our rules are.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果**cmd.exe**被锁定怎么办？没关系！您可以创建所需二进制文件的快捷方式，比如InstallUtil和csc，然后手动更改目标字段值，以便存储所需的命令行来执行。只要LOLBAS二进制文件没有被阻止，它仍然可以可靠地工作。整个包含AppLocker绕过列表的项目都可以在GitHub[16]上找到。通过评估它们，我们可以评估我们的规则有多健壮。
- en: 'Speaking about CLM bypass, there are different ways to achieve Full Language
    Mode, such as spawn PowerShell such that it downgrades to version 2 (rarely installed
    these days), use **rundll32.exe** with **PowerShlld.dll**[17], or use bypasses
    such as a wrapper over **InstallUtil**[18] and function return value patching[19].
    The last three projects will require obfuscation to evade Microsoft Defender nowadays.
    To read more about the process of finding bypasses, I recommend going through
    *XPN’s* great research, “AppLocker and CLM Bypass via COM”[20]. But let me show
    you one of my favourite bypasses by *sp00ks* that I recently found[21]. The following
    code sets the environment registry value in the HKCU hive (you do not need to
    be an administrator for that), creates a PowerShell process using WMI, and then
    sets the value back:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 说到 CLM 绕过，有多种方法可以实现完全语言模式（Full Language Mode），例如启动 PowerShell 使其降级到版本 2（现在很少安装），使用**rundll32.exe**配合**PowerShlld.dll**[17]，或者使用绕过方法，如**InstallUtil**[18]的包装器和函数返回值修补[19]。如今，后三个项目需要混淆才能避开
    Microsoft Defender。要了解更多关于如何寻找绕过的方法，我推荐阅读*XPN*的优秀研究报告，“通过 COM 实现的 AppLocker 和
    CLM 绕过”[20]。不过让我给你展示一下我最近发现的一个我最喜欢的绕过方法，由*sp00ks*提供[21]。以下代码在 HKCU 注册表中设置环境变量值（你不需要是管理员），使用
    WMI 创建一个 PowerShell 进程，然后再将值恢复：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result obtained by running the preceding command is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令后得到的结果如下：
- en: '![Figure 2.10 – Example of CLM bypass](image/B18964_02_10.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – CLM 绕过示例](image/B18964_02_10.jpg)'
- en: Figure 2.10 – Example of CLM bypass
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – CLM 绕过示例
- en: As we mentioned at the beginning of the section, the best way to harden application
    control is to deploy **Windows Defender Application Control** (**WDAC**) together
    with AppLocker. One of the most powerful collections of rules is called AaronLocker[22],
    which can be deployed together with WDAC in your environment via Group Policy[23].
    It is recommended to start monitoring your rulesets in audit mode, gradually fine-tuning
    them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头提到的，增强应用程序控制的最佳方法是将**Windows Defender 应用程序控制**（**WDAC**）与 AppLocker
    一起部署。最强大的规则集之一叫做 AaronLocker[22]，它可以通过组策略[23]与 WDAC 一起部署到你的环境中。建议首先以审核模式监控你的规则集，逐步进行优化。
- en: PowerShell Enhanced Logging and Sysmon
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 增强日志记录与 Sysmon
- en: In this section, we are going to explore what Sysmon[24] is and how it can be
    used to detect attacker’s activities. Sysmon is a system service in Windows that
    we can install and use to log information about various events, including process
    creation, various file events, registry access, named pipes, and network connections.
    Logs stay in Windows Event Collection. Sysmon does not prevent any attacks or
    provide an analysis of the events. There are a few great projects that can help
    you get started with Sysmon. A great community guide is provided by *TrustedSec*[25],
    and we will use the Sysmon config created by *SwiftOnSecurity*[26] as it is one
    of the best high-quality event tracing templates. Two more projects that provide
    a variety of config files were created by *Florian Roth*[27] and *Olaf Hartong*[28].
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨 Sysmon[24] 是什么以及如何利用它来检测攻击者的活动。Sysmon 是 Windows 中的一项系统服务，我们可以安装它并用来记录各种事件的信息，包括进程创建、文件事件、注册表访问、命名管道和网络连接。日志会保存在
    Windows 事件收集器中。Sysmon 不会阻止任何攻击或提供事件分析。目前有一些很好的项目可以帮助你开始使用 Sysmon。*TrustedSec*[25]
    提供了一个很好的社区指南，我们将使用*SwiftOnSecurity*[26] 创建的 Sysmon 配置文件，因为它是最佳的高质量事件追踪模板之一。另外，*Florian
    Roth*[27] 和 *Olaf Hartong*[28] 也创建了提供多种配置文件的项目。
- en: 'Let’s install Sysmon, apply the configs from the preceding project, and start
    digging inside the logs. Installation is straightforward; only one command being
    run as administrator is required, which is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装 Sysmon，应用前一个项目中的配置，并开始深入分析日志。安装过程非常简单；只需以管理员身份运行一个命令，命令如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The expected result is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果如下：
- en: '![Figure 2.11 – Sysmon installation](image/B18964_02_11.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – Sysmon 安装](image/B18964_02_11.jpg)'
- en: Figure 2.11 – Sysmon installation
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – Sysmon 安装
- en: 'Now, we are going to enable PowerShell Transcription, Script Block, and Module
    Logging. To enable them, I will use Group Policy Management on **kingslanding.sevenkingdoms.local**.
    I will create a separate GPO at **Computer Configuration** | **Policies** | **Administrative
    Templates** | **Windows Components** | **Windows PowerShell**. The settings can
    be seen in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启用 PowerShell 转录、脚本块和模块日志记录。为了启用这些功能，我将使用 **kingslanding.sevenkingdoms.local**
    上的组策略管理工具。我将在 **计算机配置** | **策略** | **管理模板** | **Windows 组件** | **Windows PowerShell**
    中创建一个单独的 GPO。可以在以下截图中看到这些设置：
- en: '![Figure 2.12 – Group Policies to enable PowerShell Logging](image/B18964_02_12.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 启用 PowerShell 日志记录的组策略](image/B18964_02_12.jpg)'
- en: Figure 2.12 – Group Policies to enable PowerShell Logging
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 启用 PowerShell 日志记录的组策略
- en: 'These logging features are intended to provide better visibility for defenders
    if PowerShell is expected to be used across the organization. Our first control
    is **Script Block Logging**, including **Warning Logging of Suspicious Commands**.
    There are known bypasses found by *cobbr.io* (the author of the C2 Covenant Framework)
    for ScriptBlock Logging[29] and Suspicious Commands Logging[30]. I just slightly
    modified the code to bypass AMSI and added a bit more visibility:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志记录功能旨在为防御者提供更好的可见性，特别是在组织中预计会使用 PowerShell 时。我们的第一个控制是 **脚本块日志记录**，包括 **可疑命令的警告日志记录**。已知
    *cobbr.io*（C2 Covenant 框架的作者）发现了 ScriptBlock 日志记录[29] 和可疑命令日志记录[30] 的绕过方法。我只是稍微修改了代码以绕过
    AMSI，并增加了一些可见性：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result obtained from running the preceding command is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后得到的结果如下：
- en: '![Figure 2.13 – PowerShell Script Block Logging bypass](image/B18964_02_13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – PowerShell 脚本块日志记录绕过](image/B18964_02_13.jpg)'
- en: Figure 2.13 – PowerShell Script Block Logging bypass
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – PowerShell 脚本块日志记录绕过
- en: 'One point to consider is that our bypass will still be logged until we disable
    **Event Tracing for Windows** (**ETW**) for the current PowerShell session first.
    This can be done using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一点是，我们的绕过操作仍然会被记录，直到我们首先禁用当前 PowerShell 会话中的**Windows 事件跟踪**（**ETW**）。可以使用以下命令完成此操作：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can also obfuscate this command to bypass Suspicious ScriptBlock Logging.
    Do not rely much on obfuscation as an experienced blue team will de-obfuscate
    it with the help of a tool such as DeepBlue[31] and immediately launch the investigation.
    The good thing is that for this bypass, we do not need elevated privileges and
    only manipulate cached values from Group Policy, so no modification on the host
    is required.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以混淆此命令以绕过可疑的脚本块日志记录。不要过于依赖混淆，因为经验丰富的蓝队会使用 DeepBlue[31] 等工具进行去混淆，并立即展开调查。幸运的是，对于这个绕过，我们不需要提升权限，只需操作组策略中的缓存值，因此无需修改主机。
- en: Two new PowerShell ScriptBlock and Module Logging bypasses were introduced by
    *BC-security* in their series of blog posts. The ScriptBlock bypass is based on
    the fact that the script block that has already been logged will be skipped if
    it is encountered a second time. The idea is to set the value of **HasLogged**
    to **True** before invoking the script. The purpose of the Module Logging bypass
    was to create a callable command that has no module or PowerShell snap-in associated
    with it[32]. Part 2 of the blog series showed how commands can be obfuscated to
    make the defender’s analysis more difficult[33]. Quick prevention recommendations
    against these bypasses will require the PowerShell Protect module[34].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*BC-security* 在他们的系列博客文章中引入了两个新的 PowerShell ScriptBlock 和 Module Logging 绕过方法。ScriptBlock
    绕过基于这样一个事实：已经记录的脚本块如果第二次遇到会被跳过。其思路是在调用脚本之前将 **HasLogged** 的值设置为 **True**。Module
    Logging 绕过的目的是创建一个没有关联模块或 PowerShell 快捷方式的可调用命令[32]。博客系列的第二部分展示了如何对命令进行混淆，从而使防御者的分析更加困难[33]。针对这些绕过的快速预防建议将需要
    PowerShell Protect 模块[34]。'
- en: However, if PowerShell Transcription is enabled, our activity will be still
    logged in to the file regardless of the preceding bypass. The reason is that even
    if we disable transcription in the active PowerShell session, it will continue
    the transcription and ignore the newly changed value. The original way to bypass
    was shown by *Jann Lemm* from *Avantguard* in his blog post[35]. The idea is to
    create a custom runspace, overwrite the value of **EnableTranscripting**, and
    then open the new runspace. Proof-of-concept code is available in the blogpost.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果启用了PowerShell Transcription，我们的活动仍将记录在文件中，而不管之前的绕过。原因是即使我们在活动的PowerShell会话中禁用了转录，它仍将继续转录并忽略新更改的值。最初的绕过方法是由*Jann
    Lemm*在他的博客文章中展示的。这个想法是创建一个自定义runspace，覆盖**EnableTranscripting**的值，然后打开新的runspace。博客文章中提供了概念验证代码。
- en: But what if there is a tool that can help us to bypass everything with almost
    no manual effort? Well, please, welcome Invisi-Shell, written by *Omer Yair*.
    The tool hooks .NET assemblies via the CLR Profiler API, making PowerShell security
    controls blind. For more details, I highly encourage you to read the tools code[36]
    and watch the original talk presented by the author on DerbyCon. But keep in mind
    that the tool is quite old and is easily detected by most security solutions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果有一个工具可以帮助我们几乎不需要任何手动操作就绕过所有东西呢？那么，请欢迎Invisi-Shell，由*Omer Yair*编写。该工具通过CLR
    Profiler API钩住.NET程序集，使PowerShell安全控制失效。有关更多详细信息，我强烈建议您阅读该工具的代码，并观看作者在DerbyCon上的原始演讲。但请记住，该工具相当古老，并且很容易被大多数安全解决方案检测到。
- en: The most up-to-date tool to achieve all this was written by *mgeeky* and is
    called **Stracciatella**[37]. This tool is based on the SharpPick technique (launch
    PowerShell code from within a C# assembly using runspaces) with AMSI, ETW, and
    PowerShell Logging bypasses incorporated inside. Still, some AV evasion will be
    required.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有这些的最新工具是由*mgeeky*编写的，名为**Stracciatella**[37]。该工具基于SharpPick技术（从C#程序集中启动PowerShell代码使用runspaces），内置了AMSI、ETW和PowerShell日志记录绕过。但仍然需要一些AV逃避。
- en: 'Let’s say we achieved administrator privileges on the compromised box and decided
    to disable transcription by modifying the **EnableTranscripting** registry key,
    located in **HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription**.
    This can be done with the following PowerShell command running from an elevated
    shell:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在受损的计算机上获得了管理员权限，并决定通过修改位于**HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription**中的**EnableTranscripting**注册表键来禁用转录。可以通过以下PowerShell命令从提升的shell中运行来完成：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But let’s say we have a Sysmon rule, such as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们有一个Sysmon规则，如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will get an event that could potentially trigger an investigation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到一个可能触发调查的事件：
- en: '![Figure 2.14 – Sysmon detects registry change](image/B18964_02_14.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – Sysmon检测到注册表更改](image/B18964_02_14.jpg)'
- en: Figure 2.14 – Sysmon detects registry change
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – Sysmon检测到注册表更改
- en: Another good example of Sysmon detection is AMSI provider deletion via the registry,
    which will create event ID 13 in the log. All the providers have their unique
    keys. For example, Windows Defender has **HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}**.
    Sysmon can provide much more from a detection perspective if you examine the published
    configuration files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Sysmon检测的好例子是通过注册表删除AMSI提供程序，这将在日志中创建事件ID 13。所有提供程序都有其独特的键。例如，Windows Defender有**HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}**。如果您检查已发布的配置文件，Sysmon可以从检测的角度提供更多信息。
- en: 'Another good example for Sysmon is network connection detection. Let’s try
    to run something like the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Sysmon的好例子是网络连接检测。让我们尝试运行类似以下命令的内容：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sysmon will detect activity, but not prevent the connection:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Sysmon会检测活动，但不会阻止连接：
- en: '![Figure 2.15 – Suspicious outbound connection detected by Sysmon](image/B18964_02_15.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – Sysmon检测到可疑的出站连接](image/B18964_02_15.jpg)'
- en: Figure 2.15 – Suspicious outbound connection detected by Sysmon
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – Sysmon检测到可疑的出站连接
- en: We are close to concluding this section, so let’s briefly go through the possible
    ways to find and tamper with Sysmon. A great guide was created by *spotheplanet*[38].
    An adversary can check process and service names, evaluate registry keys for Sysmon
    Windows Events, and search for Sysmon configs and tools.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这一节，所以让我们简要地浏览一下查找和篡改Sysmon的可能方法。*spotheplanet*[38]创建了一个很好的指南。对手可以检查进程和服务名称，评估Sysmon
    Windows事件的注册表键，并搜索Sysmon配置和工具。
- en: 'We have two main ways to bypass Sysmon – operate inside rules’ blind spots
    or disarm Sysmon. Rules bypass will be specific to the environment and may vary
    significantly. So, let’s have a look at what we can do to disarm Sysmon. *Olaf
    Hartong* has an excellent blog post describing possible venues for attackers[39].
    Most of the techniques mentioned require highly privileged access on the box and
    can trigger an immediate critical security incident for the blue team, but they
    are still worth mentioning:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种主要方式绕过Sysmon——在规则的盲点内操作或解除Sysmon的武装。规则绕过将特定于环境，并可能有显著的差异。那么，让我们来看看我们可以做些什么来解除Sysmon的武装。*Olaf
    Hartong*有一篇出色的博客文章描述了攻击者可能的攻击方式[39]。其中大多数技术需要在机器上具有高度特权访问权限，并可能会触发蓝队的立即严重安全事件，但它们仍然值得一提：
- en: Configuration change
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置更改
- en: Sysmon service stop
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止Sysmon服务
- en: Suppress logging
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抑制日志记录
- en: Access/alter configuration via registry
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注册表访问/更改配置
- en: Process injection in **Sysmon.exe**
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Sysmon.exe**中进行进程注入
- en: Driver renaming
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序重命名
- en: 'The reliable way to silence Sysmon is by using the **Invoke-Phant0m** tool[40],
    which will keep the victim’s machine online but not logging anything, because
    it kills logging threads. There are also more advanced ways to put Sysmon in quiet
    mode, such as patching the **EtwEventWrite** API[41]. There is remarkable research
    done by *Code White* that shows how Sysmon can be hooked and events can be manipulated[42].
    Particularly, I would like to mention that this way of disarming Sysmon is probably
    the most silent publicly available way, as stated that by the researchers[42]:
    “*no suspicious ProcessAccess events on Sysmon are observable via Sysmon or the
    Event Log making the detection (**supposedly) nontrivial.*”'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 静默Sysmon的可靠方法是使用**Invoke-Phant0m**工具[40]，它可以保持受害者的机器在线，但不记录任何内容，因为它会终止日志线程。还有更先进的方式将Sysmon置于静默模式，比如修补**EtwEventWrite**
    API[41]。*Code White*做了显著的研究，展示了如何将Sysmon hook住，并且可以操控事件[42]。特别是，我想提到的是，这种解除Sysmon的方式可能是目前公开可用的最为“安静”的方式，正如研究人员所说[42]：“*没有可疑的ProcessAccess事件在Sysmon或事件日志中可见，使得检测（**据称**）变得非平凡。*”
- en: Another way is to unload the Sysmon driver completely using a tool called **Shhmon**[43].
    It allows the attacker to find even renamed Sysmon drivers and unload them. We
    can also use a built-in utility called **fltMC.exe** or the **misc::mflt** Mimikatz
    module for the same purpose. Anyway, there are notable events left in logs that
    can be used to hunt for this technique.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用一个名为**Shhmon**[43]的工具完全卸载Sysmon驱动程序。它允许攻击者找到甚至被重命名的Sysmon驱动程序并将其卸载。我们也可以使用一个内置的实用程序**fltMC.exe**或**misc::mflt**
    Mimikatz模块来达到同样的目的。无论如何，日志中仍然留下了显著的事件，可以用来追踪这种技术。
- en: Event Tracing for Windows (ETW)
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows事件跟踪（ETW）
- en: '**Event Tracing for Windows** (**ETW**) is a kernel-level tracing facility
    for logging events and is intended to be used for application debugging and can
    be enabled/disabled without restarting the application/system. In short, the system
    consists of three components – controllers, providers, and consumers. Controllers
    are used to start/stop the Event Tracing session, which is used to receive events
    from providers and deliver them to consumers. To start using ETW, I can recommend
    the most detailed beginners guide[44]. *Bmcder* shows how to use the **logman**
    and **wevtutil.exe** tools, event manifests, and APIs to access ETW. At the end,
    there is a list of useful providers for the blue team. Also, it’s important to
    note that ETW is useful for collecting ongoing events rather than historical ones.
    However, the number of events is huge and will require post-processing using SIEM
    and/or Yara.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows事件跟踪**（**ETW**）是一个内核级别的跟踪工具，用于记录事件，旨在应用程序调试时使用，并且可以在不重启应用程序/系统的情况下启用/禁用。简而言之，系统由三个组件组成——控制器、提供者和消费者。控制器用于启动/停止事件跟踪会话，该会话用于接收来自提供者的事件并将其传递给消费者。要开始使用ETW，我可以推荐最详细的初学者指南[44]。*Bmcder*展示了如何使用**logman**和**wevtutil.exe**工具、事件清单和API来访问ETW。最后，还列出了对蓝队有用的提供者。同时，值得注意的是，ETW适用于收集正在进行的事件，而非历史事件。然而，事件数量巨大，并且需要使用SIEM和/或Yara进行后处理。'
- en: 'Let’s investigate how to use ETW for .NET tooling usage visibility. There are
    two excellent blog posts by *F-Secure* on how to detect malicious use of .NET.
    Part 1[45] is dedicated to the process of loading .NET assemblies and how to gain
    visibility of them. Part 2[46] goes into the details of JIT and Interop tracing,
    showing how malicious examples of Meterpreter and SafetyKatz can be detected.
    Method names, assemblies, and common malware API calls will be a security concern
    for an insightful defender. For both offensive and defensive tests, we can use
    a great tool created by *FuzzySec* called **SilkETW**[47]. Essentially, it is
    a set of wrappers for ETW that we can use in real time for collecting and filtering
    .NET events from **Microsoft-Windows-DotNETRuntime** and other providers. We can
    further enhance our analysis by applying known indicators of compromise from Yara.
    Following is a simple example of running renamed Seatbelt[48]:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查如何使用 ETW 来查看 .NET 工具的使用情况。*F-Secure* 撰写了两篇优秀的博客文章，讲解如何检测 .NET 的恶意使用。第一部分[45]专注于加载
    .NET 程序集的过程以及如何获取这些程序集的可见性。第二部分[46]详细介绍了 JIT 和 Interop 跟踪，展示了如何检测恶意示例，如 Meterpreter
    和 SafetyKatz。方法名称、程序集和常见的恶意软件 API 调用对有洞察力的防御者来说是一个安全隐患。对于进攻性和防守性的测试，我们可以使用 *FuzzySec*
    创建的一个很棒的工具，叫做 **SilkETW**[47]。本质上，它是 ETW 的一组包装器，可以实时收集和过滤来自 **Microsoft-Windows-DotNETRuntime**
    和其他提供者的 .NET 事件。我们可以通过应用 Yara 中已知的妥协指示器进一步增强我们的分析。以下是运行重命名过的 Seatbelt[48]的简单示例：
- en: '![Figure 2.16 – Process Hacker shows loaded .NET assemblies](image/B18964_02_16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – Process Hacker 显示加载的 .NET 程序集](image/B18964_02_16.jpg)'
- en: Figure 2.16 – Process Hacker shows loaded .NET assemblies
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – Process Hacker 显示加载的 .NET 程序集
- en: 'We will start SilkETW by using the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用以下命令启动 SilkETW：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the launch of the SilkETW process, 820 events have been collected already.
    We execute Seatbelt to get system information by running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SilkETW 进程启动后，已经收集了 820 个事件。我们执行 Seatbelt，通过运行以下命令来获取系统信息：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The number of events goes up to 1,763, and some of them include indicators
    of compromise. Going through these events allows security products such as Yara
    or modern AV/EDR solutions to detect our activity:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的数量已达到1,763个，其中一些包含妥协的指示。浏览这些事件使得像 Yara 或现代 AV/EDR 解决方案等安全产品能够检测我们的活动：
- en: '![Figure 2.17 – SilkETW in action](image/B18964_02_17.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – SilkETW 在实际操作中](image/B18964_02_17.jpg)'
- en: Figure 2.17 – SilkETW in action
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – SilkETW 在实际操作中
- en: 'One of the corresponding log entries is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的日志条目如下：
- en: '![Figure 2.18 – Multiple Seatbelt entries inside the log](image/B18964_02_18.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 日志中多条 Seatbelt 记录](image/B18964_02_18.jpg)'
- en: Figure 2.18 – Multiple Seatbelt entries inside the log
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 日志中多条 Seatbelt 记录
- en: We have two main strategies to avoid detection – tamper with ETW or use some
    kind of obfuscation. One example of an open source protector is **ConfuserEx**[49].
    It still leaves some IOCs, but it can be a good starting point, as was demonstrated
    in the blog post by *White* *Knight Labs*[50].
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种主要策略来避免检测——篡改 ETW 或使用某种形式的混淆。一个开源保护器的例子是 **ConfuserEx**[49]。它仍然会留下些许 IOCs，但作为起点是一个不错的选择，正如
    *White* *Knight Labs*[50] 博客文章所展示的那样。
- en: A more promising way to bypass ETW is to hide tradecraft from it. *XPN* published
    great research on how to do it in his blog[51]. The idea has much in common with
    AMSI bypass – patch the call to **ntdll!EtwEventWrite** in a way that will not
    log anything. Another way to achieve the same result was demonstrated by *Cneelis*
    in his TamperETW[52] example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过 ETW 的一种更有前途的方法是隐藏其监控的技艺。*XPN* 在他的博客中发布了关于如何做到这一点的精彩研究[51]。这一思路与 AMSI 绕过有很多相似之处——以一种不会记录任何内容的方式修补对
    **ntdll!EtwEventWrite** 的调用。*Cneelis* 在他的 TamperETW[52] 示例中展示了另一种实现相同结果的方法。
- en: To observe ETW in action, I encourage you to read an excellent blog post by
    *mez0*[53]. The author demonstrates .NET provider creation, simple .NET loader
    detection, and ETW neutralization. Repairing the ETW provider after execution
    is demonstrated as well. Links to relevant research and an overview of other security
    ETW providers are included as well, making this research unique and distinguishable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察 ETW 的实际运作，我鼓励你阅读 *mez0* 写的精彩博客文章[53]。作者演示了如何创建 .NET 提供者、简单的 .NET 加载器检测以及
    ETW 中和。执行后修复 ETW 提供者的过程也被展示了。此外，还包括了相关研究的链接以及对其他安全 ETW 提供者的概述，使这项研究独特且具有可辨识性。
- en: A list of other ETW tampering techniques was published by *Palantir* in their
    blog[54]. Two of these techniques (Autologger provider removal and provider **Enable**
    property modification) will require reboot, and all of them require at least administrator
    privileges.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*Palantir* 在他们的博客中发布了其他 ETW 篡改技术的列表[54]。其中两种技术（Autologger 提供者移除和提供者 **Enable**
    属性修改）需要重启，所有这些技术都至少需要管理员权限。'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we demonstrated the basic concepts of evasion for common security
    controls. This is just the tip of the iceberg, as we did not cover AV/EDR bypass,
    tool customization, shellcode loaders, and much more. We covered built-in controls
    (AMSI) as well as enhanced security components that can be deployed by Group Policies
    in the domain (AppLocker and Enhanced PowerShell Security). Then, we had a look
    at possible detection mechanisms that can be enforced in Windows with the help
    of Sysmon and ETW.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们演示了常见安全控制的规避基本概念。这只是冰山一角，因为我们没有涉及 AV/EDR 绕过、工具定制、Shellcode 加载程序等更多内容。我们讨论了内置控制（AMSI）以及可以通过组策略在域中部署的增强安全组件（AppLocker
    和增强的 PowerShell 安全性）。接着，我们查看了可能的检测机制，这些机制可以通过 Sysmon 和 ETW 在 Windows 中实施。
- en: In the upcoming chapters, we are going to use different tools and focus on concepts.
    We will run tools on machines with Microsoft Defender disabled. It is important
    to show that evasion is a vital part of the process and always comes first. The
    key to success is to know what our tools are doing under the hood, and what IOCs
    we leave on compromised machines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用不同的工具并专注于概念。我们将在禁用 Microsoft Defender 的机器上运行这些工具。展示规避技巧是整个过程的关键，并且总是第一步。成功的关键是了解我们的工具在幕后做了什么，以及我们在被攻击的机器上留下了哪些
    IOCs。
- en: The next chapter will be devoted to domain enumeration. We will see how it can
    be done with different tools, what the well-known patterns are for such activities,
    and how not to miss important bits.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门讲解域枚举。我们将展示如何使用不同的工具来完成此任务，了解这些活动的常见模式，并学习如何不遗漏重要细节。
- en: References
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Process Hacker: [https://processhacker.sourceforge.io/](https://processhacker.sourceforge.io/)'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Process Hacker: [https://processhacker.sourceforge.io/](https://processhacker.sourceforge.io/)'
- en: 'API monitor: [http://www.rohitab.com/apimonitor](http://www.rohitab.com/apimonitor)'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'API 监视器: [http://www.rohitab.com/apimonitor](http://www.rohitab.com/apimonitor)'
- en: AMSI bypass list by *S3cur3Th1sSh1t:*  [https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*S3cur3Th1sSh1t* 的 AMSI 绕过列表: [https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell)'
- en: AMSI bypass list by *Pentestlaboratories:*  [https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/](https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Pentestlaboratories* 的 AMSI 绕过列表: [https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/](https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/)'
- en: 'Invoke-Obfuscation script: [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Invoke-Obfuscation 脚本: [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)'
- en: 'Nishang project: [https://github.com/samratashok/nishang](https://github.com/samratashok/nishang)'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Nishang 项目: [https://github.com/samratashok/nishang](https://github.com/samratashok/nishang)'
- en: 'Powercat: [https://github.com/besimorhino/powercat](https://github.com/besimorhino/powercat)'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Powercat: [https://github.com/besimorhino/powercat](https://github.com/besimorhino/powercat)'
- en: 'Persistence via AMSI: [https://pentestlab.blog/2021/05/17/persistence-amsi/](https://pentestlab.blog/2021/05/17/persistence-amsi/)'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过 AMSI 的持久性: [https://pentestlab.blog/2021/05/17/persistence-amsi/](https://pentestlab.blog/2021/05/17/persistence-amsi/)'
- en: 'Threat Hunting AMSI bypasses by Pentest Laboratories: [https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/](https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/)'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Pentest Laboratories 的 AMSI 绕过威胁猎捕: [https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/](https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/)'
- en: 'Hunt for AMSI bypasses by *F-Secure*: [https://blog.f-secure.com/hunting-for-amsi-bypasses/](https://blog.f-secure.com/hunting-for-amsi-bypasses/)'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*F-Secure* 的 AMSI 绕过威胁猎捕: [https://blog.f-secure.com/hunting-for-amsi-bypasses/](https://blog.f-secure.com/hunting-for-amsi-bypasses/)'
- en: 'Tiraniddo’s research about Applocker internals: [https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml](https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml)'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Tiraniddo 关于 AppLocker 内部原理的研究: [https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml](https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml)'
- en: 'Sensitive PowerShell capabilities constrained by CLM: [https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain](https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain)'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CLM 限制的 PowerShell 敏感能力：[https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain](https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain)
- en: 'AppLocker beginners guide: [https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/](https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/)'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AppLocker 初学者指南：[https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/](https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/)
- en: 'AppLocker bypass using InstallUtil: [https://www.ired.team/offensive-security/code-execution/t1118-installutil](https://www.ired.team/offensive-security/code-execution/t1118-installutil)'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 InstallUtil 绕过 AppLocker：[https://www.ired.team/offensive-security/code-execution/t1118-installutil](https://www.ired.team/offensive-security/code-execution/t1118-installutil)
- en: 'AppLocker bypass using MSBuild: [https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c](https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 MSBuild 绕过 AppLocker：[https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c](https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c)
- en: 'AppLocker bypass list project: [https://github.com/api0cradle/UltimateAppLockerByPassList](https://github.com/api0cradle/UltimateAppLockerByPassList)'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AppLocker 绕过列表项目：[https://github.com/api0cradle/UltimateAppLockerByPassList](https://github.com/api0cradle/UltimateAppLockerByPassList)
- en: 'PowerShdll project uses PowerShell automation DLLs: [https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll)'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShdll 项目使用 PowerShell 自动化 DLL：[https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll)
- en: 'PSBypassCLM project to create a wrapper over InstalUtil: [https://github.com/padovah4ck/PSByPassCLM](https://github.com/padovah4ck/PSByPassCLM)'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PSBypassCLM 项目，创建一个 InstalUtil 的包装器：[https://github.com/padovah4ck/PSByPassCLM](https://github.com/padovah4ck/PSByPassCLM)
- en: 'Bypass-CLM project to patch the return value: [https://github.com/calebstewart/bypass-clm](https://github.com/calebstewart/bypass-clm)'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bypass-CLM 项目，修补返回值：[https://github.com/calebstewart/bypass-clm](https://github.com/calebstewart/bypass-clm)
- en: 'Bypass CLM with the help of COM: [https://blog.xpnsec.com/constrained-language-mode-bypass/](https://blog.xpnsec.com/constrained-language-mode-bypass/)'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用 COM 绕过 CLM：[https://blog.xpnsec.com/constrained-language-mode-bypass/](https://blog.xpnsec.com/constrained-language-mode-bypass/)
- en: 'Bypass CLM by setting the HKCU environment value: [https://sp00ks-git.github.io/posts/CLM-Bypass/](https://sp00ks-git.github.io/posts/CLM-Bypass/)'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置 HKCU 环境值绕过 CLM：[https://sp00ks-git.github.io/posts/CLM-Bypass/](https://sp00ks-git.github.io/posts/CLM-Bypass/)
- en: 'AaronLocker project: [https://github.com/microsoft/AaronLocker](https://github.com/microsoft/AaronLocker)'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AaronLocker 项目：[https://github.com/microsoft/AaronLocker](https://github.com/microsoft/AaronLocker)
- en: 'Deploy WDAC and AppLocker: [https://improsec.com/tech-blog/one-thousand-and-one-application-blocks](https://improsec.com/tech-blog/one-thousand-and-one-application-blocks)'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 WDAC 和 AppLocker：[https://improsec.com/tech-blog/one-thousand-and-one-application-blocks](https://improsec.com/tech-blog/one-thousand-and-one-application-blocks)
- en: 'Sysmon: [https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon)'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon：[https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon)
- en: 'Sysmon Community Guide: [https://github.com/trustedsec/SysmonCommunityGuide](https://github.com/trustedsec/SysmonCommunityGuide)'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon 社区指南：[https://github.com/trustedsec/SysmonCommunityGuide](https://github.com/trustedsec/SysmonCommunityGuide)
- en: 'Sysmon config version by *SwiftOnSecurity*: [https://github.com/SwiftOnSecurity/sysmon-config](https://github.com/SwiftOnSecurity/sysmon-config)'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon 配置版本由*SwiftOnSecurity*提供：[https://github.com/SwiftOnSecurity/sysmon-config](https://github.com/SwiftOnSecurity/sysmon-config)
- en: 'Sysmon config version by *Florian* *Roth*: [https://github.com/Neo23x0/sysmon-config](https://github.com/Neo23x0/sysmon-config)'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon 配置版本由*Florian* *Roth*提供：[https://github.com/Neo23x0/sysmon-config](https://github.com/Neo23x0/sysmon-config)
- en: 'Sysmon config version by *Olaf* *Hartong*: [https://github.com/olafhartong/sysmon-modular](https://github.com/olafhartong/sysmon-modular)'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon 配置版本由*Olaf* *Hartong*提供：[https://github.com/olafhartong/sysmon-modular](https://github.com/olafhartong/sysmon-modular)
- en: 'ScriptBlock Logging bypass by *cobbr.io*: [https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml)'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*cobbr.io* 提供的 ScriptBlock Logging 绕过：[https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml)'
- en: 'ScriptBlock Warning Event Logging by cobbr.io: [https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml)'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: cobbr.io的ScriptBlock警告事件日志绕过：[https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml)
- en: 'DeepBlue: [https://github.com/sans-blue-team/DeepBlueCLI](https://github.com/sans-blue-team/DeepBlueCLI)'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DeepBlue：[https://github.com/sans-blue-team/DeepBlueCLI](https://github.com/sans-blue-team/DeepBlueCLI)
- en: 'Newish bypasses Part 1: [https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的绕过方法第一部分：[https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/)
- en: 'Newish bypasses Part 2: [https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/)'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的绕过方法第二部分：[https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/)
- en: 'PowerShell Protect Module: [https://blog.ironmansoftware.com/protect-logging-bypass/](https://blog.ironmansoftware.com/protect-logging-bypass/)'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell保护模块：[https://blog.ironmansoftware.com/protect-logging-bypass/](https://blog.ironmansoftware.com/protect-logging-bypass/)
- en: 'Bypass of EnableTranscripting: [https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass](https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass)'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EnableTranscripting绕过：[https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass](https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass)
- en: 'Invisi-Shell tool: [https://github.com/OmerYa/Invisi-Shell](https://github.com/OmerYa/Invisi-Shell)
    and [https://www.youtube.com/watch?v=Y3oMEiySxcc](https://www.youtube.com/watch?v=Y3oMEiySxcc)'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Invisi-Shell工具：[https://github.com/OmerYa/Invisi-Shell](https://github.com/OmerYa/Invisi-Shell)
    和 [https://www.youtube.com/watch?v=Y3oMEiySxcc](https://www.youtube.com/watch?v=Y3oMEiySxcc)
- en: 'Stracciatella tool: [https://github.com/mgeeky/Stracciatella](https://github.com/mgeeky/Stracciatella)'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stracciatella工具：[https://github.com/mgeeky/Stracciatella](https://github.com/mgeeky/Stracciatella)
- en: 'Detect Sysmon: [https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host](https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host)'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测Sysmon：[https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host](https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host)
- en: 'Sysmon tampering: [https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9](mailto:https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9)'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sysmon篡改：[https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9](mailto:https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9)
- en: 'Phant0m tool: [https://github.com/hlldz/Phant0m](https://github.com/hlldz/Phant0m)'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Phant0m工具：[https://github.com/hlldz/Phant0m](https://github.com/hlldz/Phant0m)
- en: 'SysmonQuiet: [https://github.com/ScriptIdiot/SysmonQuiet](https://github.com/ScriptIdiot/SysmonQuiet)'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SysmonQuiet：[https://github.com/ScriptIdiot/SysmonQuiet](https://github.com/ScriptIdiot/SysmonQuiet)
- en: 'SysmonEnte: [https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml](https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml)'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SysmonEnte：[https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml](https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml)
- en: 'Shhmon: [https://github.com/matterpreter/Shhmon](https://github.com/matterpreter/Shhmon)'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shhmon：[https://github.com/matterpreter/Shhmon](https://github.com/matterpreter/Shhmon)
- en: 'ETW beginner’s guide: [https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw](https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw)'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ETW入门指南：[https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw](https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw)
- en: 'Detect malicious usage of .NET part 1: [https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/)'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测恶意使用.NET第一部分：[https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/)
- en: 'Detect malicious usage of .NET part 2: [https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/)'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测恶意使用.NET第二部分：[https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/)
- en: 'SilkETW: [https://github.com/mandiant/SilkETW](https://github.com/mandiant/SilkETW)'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SilkETW：[https://github.com/mandiant/SilkETW](https://github.com/mandiant/SilkETW)
- en: 'Seatbelt: [https://github.com/GhostPack/Seatbelt](https://github.com/GhostPack/Seatbelt)'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Seatbelt：[https://github.com/GhostPack/Seatbelt](https://github.com/GhostPack/Seatbelt)
- en: 'ConfuserEx: [https://github.com/mkaring/ConfuserEx](https://github.com/mkaring/ConfuserEx)'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'ConfuserEx: [https://github.com/mkaring/ConfuserEx](https://github.com/mkaring/ConfuserEx)'
- en: 'Bypass ETW by neutering the EtwEventWrite API: [https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/](https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/)'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使EtwEventWrite API无效来绕过ETW：[https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/](https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/)
- en: 'Patch EtwEventWrite API: [https://blog.xpnsec.com/hiding-your-dotnet-etw/](https://blog.xpnsec.com/hiding-your-dotnet-etw/)'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '补丁EtwEventWrite API: [https://blog.xpnsec.com/hiding-your-dotnet-etw/](https://blog.xpnsec.com/hiding-your-dotnet-etw/)'
- en: 'TamperETW: [https://github.com/outflanknl/TamperETW](https://github.com/outflanknl/TamperETW)'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'TamperETW: [https://github.com/outflanknl/TamperETW](https://github.com/outflanknl/TamperETW)'
- en: 'Evade ETW and AMSI: [https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue](https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue)'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规避ETW和AMSI：[https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue](https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue)
- en: 'Tampering with ETW: [https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63](https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '篡改ETW: [https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63](https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)'
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步学习的辅助资源，帮助你更深入地了解本章涉及的攻击：
- en: 'Great blog post with ready-to-use code for AmsiScanBufferBypass: [https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/](https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于AmsiScanBufferBypass的优秀博客文章，提供了即用的代码：[https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/](https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/)。
- en: 'Excellent blog post about PowerShell CLM and examples of rule evaluation: [https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/](https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于PowerShell CLM和规则评估示例的优秀博客文章：[https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/](https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/)
- en: 'There is an excellent post that combines the MSBuild and InstallUtils AppLocker
    bypass methods: [https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/](https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一篇结合了MSBuild和InstallUtils AppLocker绕过方法的优秀文章：[https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/](https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/)
