- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Basic Needs in My Build Chain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的构建链中的基本需求
- en: Security begins at the design table. True. Yet it is enhanced and comes alive
    in the build chain. It is here where we will implement and validate our security
    policies, test, scan our prototypes, and leverage all the informational sources
    at our disposal to ensure that our product is as secure and robust as it possibly
    can be, long before it sees its first customer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安全从设计桌面开始。这是事实。然而，它在构建链中得到增强并焕发活力。正是在这里，我们将实施并验证我们的安全政策，测试、扫描我们的原型，利用我们手头所有的信息资源，确保我们的产品在看到第一个客户之前，尽可能地安全且稳健。
- en: Here is truly where all the magic happens (or sadly, it doesn’t if you choose
    to ignore it). In the previous chapters, we have addressed countless design factors
    that have led up to your conceptual initial design criteria. From here and forward,
    we will be working hands-on to ensure those embedded systems’ best practices are
    adhered to along with the application of security measures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里才是真正的“魔法”发生的地方（或者不幸的是，如果你选择忽视它，它就不会发生）。在前几章中，我们讨论了无数的设计因素，这些因素最终促成了你概念上的初步设计标准。从这里起，我们将开始动手操作，确保遵循嵌入式系统的最佳实践，并应用安全措施。
- en: Here’s a non-exhaustive sample of what may be in your company’s build environment.
    These tools should be accessible only to those working directly on this product
    or supporting production releases. From secure repositories to scanning tools
    and everything else in between, these critical tools will greatly contribute to
    the success of your product’s lifecycle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你公司构建环境中可能出现的一个非详尽的示例。这些工具应该仅对直接参与该产品或支持生产发布的人员开放。从安全的仓库到扫描工具及其间的一切，这些关键工具将极大地助力你的产品生命周期的成功。
- en: 'The many tools you will need are vast and include (but are not limited to)
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要的众多工具是广泛的，包括（但不限于）以下内容：
- en: Local repositories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地仓库
- en: Source code control systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制系统
- en: Project management systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目管理系统
- en: Customer support systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户支持系统
- en: Build automation systems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自动化系统
- en: Compliance and security scanning systems
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规性和安全扫描系统
- en: Update infrastructure for deployed appliances
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新已部署设备的基础设施
- en: Most importantly, a comprehensive set of test systems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，一套完整的测试系统
- en: 'Here’s a perspective of systems and tools needed for a successful build chain
    infrastructure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是成功的构建链基础设施所需的系统和工具的视角：
- en: '![Figure 5.1 – Example systems in a secure build and support chain](img/B22104_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 安全构建和支持链中的示例系统](img/B22104_05_01.jpg)'
- en: Figure 5.1 – Example systems in a secure build and support chain
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 安全构建和支持链中的示例系统
- en: Grab your favorite beverage. Clear your calendar. Grab some USB thumb drives
    and let’s go to the lab. I invite you to join me on this journey, roll up your
    sleeves, and get your keyboard thumping. Are you ready to start practicing how
    to secure your software supply chain?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 拿上你喜欢的饮品，清空日程，准备好一些USB闪存驱动器，咱们去实验室吧。我邀请你与我一同踏上这段旅程，卷起袖子，开始敲击键盘。你准备好开始实践如何保护你的软件供应链了吗？
- en: 'In the following sections, I will address key concepts and then walk you through
    some detailed exercises:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将阐述关键概念，并引导你完成一些详细的练习：
- en: Software supply chain control
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件供应链控制
- en: Automation and tool integration – a brief overview
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化和工具集成 – 简要概述
- en: Security scanning, testing, and remediation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全扫描、测试和修复
- en: Manifest and configuration tracking
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单和配置跟踪
- en: Update control mechanisms
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新控制机制
- en: Let’s get started.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you’d like to follow along with the exercises within this chapter, you will
    need at least two machines (physical or virtual) running the same distribution
    of Linux. In the exercises themselves, I will call out which distribution I have
    used for the exercise and any other pertinent configuration information. For the
    purposes of this book, it is assumed that you and your team have a substantial
    level of experience with whichever solution(s) for source code control/management.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随本章的练习，你至少需要两台运行相同Linux发行版的机器（物理或虚拟）。在练习中，我会标明我使用了哪个发行版以及其他相关的配置信息。出于本书的目的，假设你和你的团队对任何一种源代码控制/管理解决方案有足够的经验。
- en: 'This book itself has its own GitHub page and repository. Many of the exercises
    and example configuration files can be found there:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本身有一个GitHub页面和仓库。许多练习和示例配置文件都可以在那里找到：
- en: '[https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises](https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises](https://github.com/PacktPublishing/The-Embedded-Linux-Security-Handbook/tree/main/Chapter05/exercises)'
- en: Software supply chain control
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件供应链控制
- en: As a solution provider, it is your responsibility to know, track, and maintain
    records of each component that goes into your solution. If your solution falls
    under any sort of government or industry compliance regulations, this requirement
    may have dire consequences if not maintained.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决方案提供商，您有责任了解、跟踪并保持每个组成部分的记录。如果您的解决方案需要遵守政府或行业的合规性要求，那么如果这些记录没有维护，可能会产生严重后果。
- en: This is a situation where again, I recommend leveraging an enterprise Linux
    distribution. Their software sources are secure, from source code to compilation
    to packaging and, ultimately, its delivery to you. They maintain great records.
    They have to! These vendors can provide your team with what we call a **Software
    Bill of Materials** (**SBOM**). This is a complete listing of the components and
    their versions. Additionally, it is an attestation that they use secure, tested,
    and validated software.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我再次推荐使用企业级 Linux 发行版。它们的软件源是安全的，从源代码到编译、打包，最终交付给您。它们有很好的记录——它们必须有！这些供应商可以为您的团队提供我们所说的**软件物料清单**（**SBOM**）。这是一份完整的组件及其版本清单。此外，它也是一份声明，证明他们使用的是经过安全测试和验证的软件。
- en: There are several commercial solutions available on the market. Companies like
    Aqua, Synopsys®, and Red Hat® (just to name a few) create some excellent comprehensive
    solutions to securing the software pipeline. There are lots of viable options
    for your team to consider in this aspect, so let’s move onto the next section,
    Source code control.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有几种商业解决方案。像 Aqua、Synopsys® 和 Red Hat® 等公司（仅举几例）提供了一些出色的综合解决方案，用于保护软件管道的安全。团队可以考虑的可行选项有很多，接下来我们进入下一个部分——源代码控制。
- en: Source code control
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码控制
- en: Intellectual property, that very special code that makes your solution oh so
    special, is meant to be protected. Sometimes, at virtually all costs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 知识产权，也就是使您的解决方案与众不同的那些特殊代码，应该受到保护。有时，几乎是任何代价都值得的。
- en: There are many excellent commercial and open source solutions for this. Oftentimes,
    these solutions are integrated with other solutions that may provide services
    for bug tracking, agile project management, software packaging solutions, etc.
    Regardless of which source code control system your organization has chosen, I
    recommend ensuring that all feasible steps to minimize access and secure the platform
    are taken. Protect your company’s intellectual property. Let’s move on to other
    parts of a good software supply chain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的商业和开源解决方案。通常，这些解决方案与其他服务（如 bug 跟踪、敏捷项目管理、软件打包解决方案等）集成。无论您组织选择了哪种源代码控制系统，我建议确保采取所有可行的措施来最小化访问并确保平台安全。保护您公司的知识产权。接下来我们来看一看软件供应链的其他部分。
- en: Automation and tool integration – a brief overview
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化和工具集成——简要概述
- en: No DevOps shop can be complete without a substantial level of automation throughout
    the operation. Just like with source code control, there are many excellent commercial
    and open source solutions for this. Red Hat Ansible®, SaltStack®, Puppet Enterprise®,
    Chef®, Ansible AWX®, and Puppet Bolt® are the most commonly used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有适当的自动化水平，任何 DevOps 环境都无法算完整。就像源代码控制一样，这方面有许多优秀的商业和开源解决方案。Red Hat Ansible®、SaltStack®、Puppet
    Enterprise®、Chef®、Ansible AWX® 和 Puppet Bolt® 是最常用的。
- en: Other products often found in a build chain may also include a significant level
    of automation. One such example is the platform offered by a company called CloudBees.
    Their Jenkins product has been at the leading edge of DevOps shops globally. This
    is just one example in a market of many solutions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建链中，其他产品也可能包含大量自动化。例如，CloudBees 公司提供的平台。它们的 Jenkins 产品在全球 DevOps 环境中处于领先地位。这只是众多解决方案中的一个例子。
- en: Automation is an area that I can rant about for hours on end. That is definitely
    not what I intend for this brief section. The message I want to impart to you
    here is that automation, when done correctly, can ease the burden of many cumbersome
    and menial tasks that can be error-prone when humans are doing them repetitively.
    Risk mitigation and efficiency, pure and simple.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是一个我可以滔滔不绝讲上好几个小时的话题。但这绝不是我在这一简短部分中想表达的重点。我想告诉你的是，正确实施自动化可以减轻许多人力操作时会犯错的繁琐和单调任务。风险缓解与效率，简单明了。
- en: Whichever tool (or tools) your team selects for the project, I recommend their
    usage and efficiency be reviewed in the same manner you would review any other
    agile process at the end of a sprint. There is no wrong selection here, except
    in the case of not leveraging some sort of automation at all in your build, test,
    and support chain. Don’t just find something. Find what works best for your budget
    and your team’s skills, and can be leveraged easily within the timeframes you
    are allotted for the project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的团队选择哪个工具（或多个工具）进行项目，我都建议你们像审查其他敏捷流程一样审查它们的使用效果和效率。这里没有错误的选择，唯一的错误是完全不在构建、测试和支持链条中使用任何自动化。不要只是找到一个工具，而是要找到最适合你们预算和团队技能，并能在项目的时间范围内轻松使用的工具。
- en: We will definitely be covering much more about tools and integration in later
    chapters, so let’s move on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定会在后续章节中深入探讨更多关于工具和集成的内容，接下来让我们继续前进。
- en: Security scanning, testing, and remediation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全扫描、测试和修复
- en: By using **Free Open Source Software** (**FOSS**), your team can achieve many,
    if not all, aspects of your product’s lifecycle. Yes, I am definitely an open
    source advocate and have been since the late 1990s. There’s a good reason, especially
    in the Linux world. It’s the portability of skills.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**自由开源软件**（**FOSS**），你的团队可以实现产品生命周期中的许多（如果不是全部的话）方面。是的，我确实是开源软件的倡导者，自上世纪90年代末以来一直如此，尤其是在
    Linux 的世界里。原因很简单，那就是技能的可移植性。
- en: Virtually all Linux distributions share about 90% of the same available commands
    and utilities. What they don’t share, that other 10%, is what makes those distributions
    unique, scalable, or more secure than the others. For discussion’s sake, I want
    to focus on that 90% – the common stuff.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 Linux 发行版都共享大约 90% 的相同命令和工具。它们不共享的那 10%，正是让这些发行版独特、可扩展或更安全的地方。为了讨论方便，我想专注于这
    90% —— 常见的工具。
- en: When at a command prompt in Linux (regardless of distribution), there’s a baseline
    of commands we all come to know and rely upon. Granted there are variations out
    there, but the most common tools are what I am focusing on here.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 的命令提示符下（无论是哪个发行版），有一些基本的命令是我们都熟悉并依赖的。虽然确实存在一些差异，但我这里重点讨论的是最常用的工具。
- en: The first command line tool I want to bring up is **Nmap**. Nmap has a GUI counterpart
    called **Zenmap** (or in older distributions, **nmap-fe**). It is commonly found
    in virtually all distributions of Linux and on all platforms. Why? Because it
    is great at finding out which ports are open and even doing something called **OS
    fingerprinting** (i.e., figuring out what operating system the host is using).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到的第一个命令行工具是**Nmap**。Nmap 有一个图形界面版本，叫做**Zenmap**（或者在旧版本中叫做**nmap-fe**）。它几乎可以在所有
    Linux 发行版和平台上找到。为什么？因为它擅长找出哪些端口是开放的，甚至能进行所谓的**操作系统指纹识别**（即，识别主机使用的是哪种操作系统）。
- en: So, let’s take a quick look at Nmap and Zenmap in action in a quick hands-on
    exercise.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们快速看一下 Nmap 和 Zenmap 在实际操作中的表现，做一个简短的实操练习。
- en: Exercise – executing a network port scan
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 执行网络端口扫描
- en: In this exercise, we will be running detailed network port scans on some test
    machines. We’ll be using two similar tools. The first tool, called Nmap, is an
    open source command-line port scanning tool. The second tool, called Zenmap, is
    also an open source tool; however, it has a graphical user interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将对一些测试机器进行详细的网络端口扫描。我们将使用两个类似的工具。第一个工具是 Nmap，它是一个开源的命令行端口扫描工具。第二个工具是
    Zenmap，它也是开源工具，但它有一个图形用户界面。
- en: Requirements for the exercise
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习要求
- en: For this exercise, you’ll need access to a Linux host with its graphical desktop
    enabled along with a defined target host (to scan). In the accompanying screenshots,
    I’ve used Fedora® as the Linux distribution but virtually any distribution is
    acceptable here. Nmap should be available from your distribution’s own repositories,
    but we’ll need to download Zenmap from FlathubTM. On Fedora, this repository is
    preconfigured for you if you enable third-party repositories in the gnome-software
    application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要访问启用了图形桌面的Linux主机以及一个定义好的目标主机（用于扫描）。在随附的截图中，我使用的是Fedora®作为Linux发行版，但几乎任何发行版都可以。Nmap应该可以从你的发行版自己的仓库中获取，但我们需要从FlathubTM下载Zenmap。在Fedora上，如果你在gnome-software应用中启用了第三方仓库，这个仓库已经为你配置好了。
- en: First, you need to log in to the host and open a terminal session. We can usually
    assume that it’s not installed by default, hence we will install it before continuing.
    If you’ve already installed the tools, you may skip this step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要登录到主机并打开终端会话。我们通常假设它默认没有安装，因此在继续之前我们将进行安装。如果你已经安装了相关工具，可以跳过这一步。
- en: 'Then, we’ll install the Flathub `flatpak` repository (if it’s not already installed):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将安装Flathub `flatpak` 仓库（如果它尚未安装）：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we’ll confirm that the Flathub repository is available at the command
    line.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在命令行确认Flathub仓库是否可用。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that even if this is configured within gnome-software, it may not
    be available on the command line unless you physically install/enable it yourself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在gnome-software中进行了配置，除非你亲自安装/启用它，否则它可能无法在命令行中使用。
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we’ll install the `zenmap` `flatpak`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装`zenmap` `flatpak`。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we’ll install Nmap out of the operating system’s own repository.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从操作系统的自身仓库安装Nmap。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will get the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下输出：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here’s an example of me running a scan in my network with the Nmap utility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在网络中使用Nmap工具进行扫描的示例。
- en: It’s actually me running a detailed port scan against a host called `ks01`.
    What we will see is the open ports and the services running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其实是我在对一个名为`ks01`的主机进行详细端口扫描。我们将看到的是开放端口和运行的服务。
- en: '![Figure 5.2 – Nmap portscan and results](img/B22104_05_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Nmap 端口扫描及结果](img/B22104_05_02.jpg)'
- en: Figure 5.2 – Nmap portscan and results
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Nmap 端口扫描及结果
- en: In that example scan, we can see that SSH and HTTP are both accessible to external
    hosts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个示例扫描中，我们可以看到SSH和HTTP都可以被外部主机访问。
- en: First, let’s see what our options really are (*hint – there* *are MANY!!*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的选项是什么（*提示 – 其实有很多！*）。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下输出：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let’s run a simple scan of a target host. Please substitute the name of
    your target host where I have defined my target (`ks01`); otherwise, this will
    not work for you. This first example is the *fast* port scan.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对目标主机进行简单扫描。请将我的目标主机名称（`ks01`）替换为你的目标主机名称；否则，这个操作对你来说无法生效。这个第一个示例是*快速*端口扫描。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now let’s do a more complex scan of our target host. Again, please substitute
    the name of your target host where I have listed my target (`ks01`). In this scan,
    we’ll be looking for detailed versioning information of the services running (when
    detected).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对目标主机进行更复杂的扫描。同样，请将我的目标主机名称（`ks01`）替换为你的目标主机。在这个扫描中，我们将查找正在运行的服务的详细版本信息（如果已检测到）。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, I will demonstrate that this Nmap tool can not just scan individual hosts
    but entire subnets at once. This operation can take significantly longer and the
    total time to execute can vary depending on how many targets are in the network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将展示这个Nmap工具不仅能扫描单个主机，还能一次扫描整个子网。此操作可能需要更长时间，执行的总时间会根据网络中目标的数量而有所不同。
- en: Warning
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t try this at work without prior coordination with those teams who run the
    network and systems – you don’t want to set off any alarms (or get yourself into
    trouble).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有提前与网络和系统运维团队协调的情况下，千万不要在工作中尝试这个——你可不想引发任何警报（或惹上麻烦）。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nmap is capable of running many types of scans and can also be somewhat intrusive
    if you are not careful. I recommend examining the documentation and perhaps grabbing
    one of the many cheat sheets on Nmap that are freely available online.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap能够执行多种类型的扫描，如果不小心，它也可能会有些侵入性。我建议你阅读相关文档，或许可以在线获取一些免费的Nmap备忘单。
- en: 'Now that we’ve done a brief introduction to port scanning at the command line,
    let’s move on to using the slightly more feature-rich GUI tool: Zenmap.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了命令行中的端口扫描，让我们继续使用稍微功能丰富一些的 GUI 工具：Zenmap。
- en: Here’s an example Zenmap scan that I ran, also targeting the same host as in
    the previous exercise and demonstration. Please note that the output is formatted
    much better than the command-line tool Nmap and there are options made available
    to the user for expanding upon details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我运行的一个 Zenmap 扫描示例，也针对与前一个练习和演示中相同的主机。请注意，输出格式比命令行工具 Nmap 更加优化，并且为用户提供了更多可扩展的细节选项。
- en: '![Figure 5.3 – Zenmap scan](img/B22104_05_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Zenmap 扫描](img/B22104_05_03.jpg)'
- en: Figure 5.3 – Zenmap scan
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Zenmap 扫描
- en: Here’s another example scan that I have run. This time, once I have the results,
    I have clicked on the **Ports / Hosts** tab in the interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我进行的另一个扫描示例。这次，当我获得结果后，我点击了界面中的**Ports / Hosts**标签。
- en: '![Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab](img/B22104_05_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 另一个 Zenmap 扫描；聚焦于 Ports / Hosts 标签](img/B22104_05_04.jpg)'
- en: Figure 5.4 – Another Zenmap scan; focus on the Ports / Hosts tab
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 另一个 Zenmap 扫描；聚焦于 Ports / Hosts 标签
- en: I cannot overemphasize the importance of ensuring that you scan release candidates
    for vulnerabilities, to validate open ports/services. We will touch on different
    types of scans in later chapters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法过分强调确保你扫描发布候选版本的漏洞，以验证开放端口/服务的重要性。我们将在后面的章节中讨论不同类型的扫描。
- en: Now that we have reviewed open source scanning, let’s move on to how one can
    track changes in the appliances.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了开源扫描，让我们继续讨论如何跟踪设备中的变化。
- en: Manifest and configuration tracking
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单和配置跟踪
- en: The creation of a software manifest is a crucial step in knowing how to maintain
    the security of your systems. This ultimately is a detailed list of software packages
    and their respective versions. It is the sum of all packages in your operating
    system and your application stack, along with any additional third-party packages
    or combined dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建软件清单是了解如何维护系统安全的关键步骤。这最终是一个详细的软件包及其版本的列表，包含了你操作系统和应用堆栈中的所有包，以及任何额外的第三方包或组合依赖项。
- en: Knowing what goes into each and every release and where those packages come
    from, and curating a secure anthology of said packages will empower you to control
    the lifecycle of your solution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 了解每个发布版本包含什么，以及这些包的来源，并策划一个安全的包清单，将帮助你掌控解决方案的生命周期。
- en: I am not saying this will be easy. It can be, but as solutions become more and
    more complex, this truly becomes a labored effort – especially if not everything
    your solutions have consumed is provided in the same format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说这会很容易。它有可能会，但随着解决方案变得越来越复杂，这确实会变成一项艰苦的工作——尤其是当你的解决方案所使用的并非全部都是以相同格式提供时。
- en: Let me go into detail here. What if your operating system provider gives you
    their packages as RPMs but you have some dependencies that are downloaded as **tarballs**,
    or as flatpaks? And then what if we also run some containerized microservices
    on top? Tracking everything can get complex really fast. In fact, it almost becomes
    impossible to track at all. This is why change tracking and the SBOM matter. So,
    let’s take a look at how we can track changes in our own appliances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我详细讲解一下。假设你的操作系统提供商将包以 RPM 格式提供，而你有一些依赖项是作为**tarballs**或者 flatpaks 下载的。那么，如果我们还运行一些容器化的微服务呢？跟踪这一切会变得非常复杂，实际上，几乎不可能完全跟踪。这就是为什么变更跟踪和
    SBOM 变得如此重要的原因。所以，让我们看看如何在我们自己的设备中跟踪变化。
- en: Exercise – tracking changes in your product
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 跟踪你产品的变化
- en: In this exercise, we'll dive deep into how to correlate what’s in an existing
    build versus what changes (aka deltas) are present in the next round of updates
    for your appliance. Knowing which packages are new (those deltas again) will blatantly
    highlight what your team will need to provide to existing users as an update bundle
    either in a custom repository or via other methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将深入探讨如何将现有版本与下一个更新轮次中的变化（即增量）进行对比。了解哪些包是新的（这些增量再次出现）将明显突出你的团队需要提供给现有用户的更新包，这可以通过自定义仓库或其他方式提供。
- en: Requirements for the exercise
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 练习要求
- en: For this hands-on exercise, you will only need access to a Linux machine (physical
    or virtual). Root (or `sudo`) access is mandatory. I am doing this example on
    my Fedora 40 box, but you could potentially follow along with me on any RHEL-like
    distribution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动手操作，你只需要访问一台 Linux 机器（物理机或虚拟机）。需要 root（或`sudo`）权限。我在我的 Fedora 40 机器上做这个示例，但你也可以在任何类似
    RHEL 的发行版上跟着我一起操作。
- en: First, we’ll create a script, using your favorite editor. Create a file called
    `my-inventory-creator.sh`. Ensure that you set the file permissions so that it’s
    executable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个脚本，使用你喜欢的编辑器。创建一个名为`my-inventory-creator.sh`的文件。确保设置文件权限，使其可执行。
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now let’s run the script and take note of the output file names (which include
    date stamps). These will be unique for you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行脚本，并注意输出的文件名（包括日期戳）。这些文件名对于你来说是唯一的。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will get the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let’s review those output files. These will also be unique for your build/system.
    We will start with the software sources file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看这些输出文件。这些文件对于你的构建/系统也是唯一的。我们将从软件源文件开始。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now let’s see the software details file (this will be long). The output of this
    command is huge so I will warn you upfront – I had to truncate it for space reasons.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下软件详情文件（这将非常长）。此命令的输出很庞大，因此我提前提醒你——我为了节省空间不得不截取了它。
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have a complete manifest of software and sources for our build. Let’s
    do a quick search for a specific package. For my example, I am using `httpd`,
    but you can practice searching for whichever package/version you prefer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建的完整软件和源清单。让我们快速搜索一个特定的包。以我的例子为例，我使用的是`httpd`，但你可以练习搜索任何你喜欢的包或版本。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let’s install a package that will drag in some dependencies along with it.
    I’m going to install a package called `kdiff3`, which belongs to the vast family
    of “diff” tools that find differences in files or from command-line outputs. Again,
    here, the output from this command is pages and pages long, hence I have truncated
    it again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装一个会带来一些依赖项的包。我将安装一个名为`kdiff3`的包，它属于“diff”工具的大家族，这些工具用于找出文件或命令行输出之间的差异。同样，此命令的输出非常长，因此我再次对其进行了截取。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the last step, we installed a single package (but it brought along 113 dependencies).
    So, let’s now rerun our inventory script and do some introspection on what really
    changed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们安装了一个包（但它带来了 113 个依赖项）。所以，让我们重新运行我们的清单脚本，并对实际发生的更改进行一些自我检查。
- en: Tip
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Take note of the new files that were created in this run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次运行中创建的新文件。
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your output files for this check are:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你这次检查的输出文件是：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let’s generate a list of differences between the two file sets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们生成两个文件集之间的差异列表。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There was no change in the sources we drew our files from but there will be
    significant changes in the software details lists. Let’s do a side-by-side comparison.
    Please note the output will be big.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从中获取文件的源没有发生变化，但软件详情列表会有显著的变化。让我们进行并排比较。请注意，输出将会很大。
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’ll now be able to see what was added (or changed) with this method. In the
    above example, there are 114 changes (actually, additions). I only truncated the
    output to save space and not bore you with the details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到使用此方法添加（或更改）的内容。在上面的例子中，共有 114 项更改（实际上是添加）。为了节省空间并避免让你感到无聊，我只截取了部分输出。
- en: This is where I prefer to leverage some GUI-based tools like the one I just
    installed. Let’s take a quick look at `kdiff3`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我喜欢利用一些图形用户界面工具的地方，像我刚刚安装的那个工具。让我们快速看看`kdiff3`。
- en: We’ll select the same files from the previous steps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择之前步骤中的相同文件。
- en: '![Figure 5.5 – Starting the kdiff3 comparison operation](img/B22104_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 启动 kdiff3 比较操作](img/B22104_05_05.jpg)'
- en: Figure 5.5 – Starting the kdiff3 comparison operation
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 启动 kdiff3 比较操作
- en: Next, select the files in the interface. **A (Base)** is the older software
    details file. Finally, select the file for **B** as the latest one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择界面中的文件。**A (Base)** 是旧的软件详情文件。最后，选择**B**文件作为最新的文件。
- en: '![Figure 5.6 – Selecting the files](img/B22104_05_06.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 选择文件](img/B22104_05_06.jpg)'
- en: Figure 5.6 – Selecting the files
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 选择文件
- en: Now that we’ve defined all the files to compare, we click **OK**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有要比较的文件，我们点击**OK**。
- en: The output of this will highlight the differences graphically in the two lists.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的输出将图形化显示两个列表之间的差异。
- en: '![Figure 5.7 – Running the comparison](img/B22104_05_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 运行比较](img/B22104_05_07.jpg)'
- en: Figure 5.7 – Running the comparison
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 运行比较
- en: The differences are crucial knowledge for you and your team. With this knowledge,
    you know which files you’ll need to curate proper update releases for your customers
    (assuming you run this type of comparison as part of your release candidate review
    process). This is the perfect segue to our next section on how to provide update
    control mechanisms within your product.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异对你和你的团队来说是至关重要的知识。掌握这些知识后，你就知道哪些文件需要策划，以为客户提供合适的更新版本（假设你将这种比较作为发布候选审查过程的一部分）。这是完美的过渡到我们下一节，关于如何在产品中提供更新控制机制。
- en: Update control mechanisms
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新控制机制
- en: One of my favorite discussions over the years with my embedded partners has
    been how to create a proper update methodology along with the processes and the
    infrastructure to support it. Ultimately, we already know – based on the customers’
    operating environment, use cases, and compliance footprint – whether these mechanisms
    will be simple and online, or offline and complex.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我与嵌入式合作伙伴讨论过的最喜欢的话题之一就是如何创建一个合适的更新方法论，并建立支持该方法的流程和基础设施。最终，根据客户的操作环境、用例和合规性要求，我们已经知道这些机制是简单的在线形式，还是复杂的离线形式。
- en: Your choices here will directly impact the User Interface (UI) of your product.
    Packaging your software and configurations will simplify lifecycle management
    and support costs while improving end-user experiences.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里的选择将直接影响你产品的用户界面（UI）。打包你的软件和配置将简化生命周期管理和支持成本，同时改善最终用户体验。
- en: For this next set of exercises, we will assume that your team has chosen to
    package up your special sauce along with using RPM packages and custom repositories
    in both your build and support chains. This is the easiest route but not always
    the most feasible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的这组练习，我们假设你的团队已经选择了将特定功能与使用 RPM 包和自定义仓库一起打包，在构建和支持链中使用。这是最简单的路径，但并非总是最可行的。
- en: We will cover other update control mechanisms later (and online in the book’s
    GitHub repository). They can be (but are not limited to) encrypted tarballs, ISO
    images, thumb drives, FTP bundles, and many others. Each of those will require
    additional work in your build chain and vastly more attention in the support chain,
    not to mention more support staff who are better trained.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在书本的 GitHub 仓库中讨论其他更新控制机制（并在线提供）。这些机制可以是（但不限于）加密的 tar 包、ISO 镜像、U盘、FTP 包等。每一个都需要在构建链中做额外的工作，并且在支持链中需要更多的关注，更不用说更多经过良好培训的支持人员了。
- en: Now that we have reviewed how to track and document changes in your appliance,
    let’s move on to another key facet of maintaining control of your SBOM – this
    time, via custom packaging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何追踪和记录你设备中的变更，接下来让我们讨论保持对你的 SBOM（软件物料清单）控制的另一个关键方面——这次通过自定义打包。
- en: Exercise – building custom software packages
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 构建自定义软件包
- en: I hope you are ready for some typing. We’re going to start building here. As
    there are a million things that you can do within your own custom packages, I
    will only cover something that’s near and dear to some embedded systems best practices,
    and that’s creating your own release definition file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经准备好开始输入了。我们将从这里开始构建。由于在自定义软件包中可以做的事情非常多，我将仅涵盖一些与嵌入式系统最佳实践相关的内容，那就是创建你自己的发布定义文件。
- en: 'The following link that I am sharing is somewhat the *go-to* reference for
    all things RPM-based. I recommend spending some serious time there:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我分享的以下链接基本上是所有与 RPM 相关的事项的*必备*参考资料。我建议你在此花些时间：
- en: '[https://rpm-packaging-guide.github.io/](https://rpm-packaging-guide.github.io/)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rpm-packaging-guide.github.io/](https://rpm-packaging-guide.github.io/)'
- en: Requirements for the exercise
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 练习要求
- en: You’ll need access to a Linux server. Root or `sudo` access is mandatory. A
    little bit about my demo environment – I am running Fedora 40 Workstation and
    I have created a user called `mattbuild` (you can create your own build environment
    user before starting this exercise) and I’ve added it to the `sudoers` file. Now
    let’s set up your RPM package building environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问一台 Linux 服务器。必须具有 root 或 `sudo` 权限。关于我的演示环境：我正在使用 Fedora 40 Workstation，并且创建了一个名为
    `mattbuild` 的用户（你可以在开始本练习之前创建自己的构建环境用户），并且我已经将其添加到 `sudoers` 文件中。现在让我们设置你的 RPM
    包构建环境。
- en: First, we’ll install the packaging tools (along with their numerous dependencies).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装打包工具（以及它们的众多依赖项）。
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we’ll modify the user account we are using to build the packages to become
    a member of the *mock* system group.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改用于构建软件包的用户账户，成为*mock*系统组的成员。
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we’ll confirm the changes to the user account. You can either leverage
    the `newgrp` command or log out and log back in to reset your environment. Once
    you’ve done either of those, validate that the group changes have taken effect.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将确认用户账户的更改。你可以使用`newgrp`命令，或者注销后重新登录以重置你的环境。完成其中任何一个操作后，验证组更改是否已生效。
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now let’s create a proper rpm build environment for that user. Running the `rpmdev-setuptree`
    command will build a folder structure that is required for the build process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为该用户创建一个合适的rpm构建环境。运行`rpmdev-setuptree`命令将构建一个构建过程中所需的文件夹结构。
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now let’s create a `.spec` file for our project. I use `vi` or `vim`, but feel
    free to use your favorite. I’ll place a copy of this file in the GitHub repository
    in case you do not want to type this one out.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的项目创建一个`.spec`文件。我使用`vi`或`vim`，但你可以随意使用你喜欢的编辑器。如果你不想自己输入这个文件，我会将这个文件的副本放到GitHub仓库里。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we’ll edit the contents of the file. Be sure to save your file when done.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑文件的内容。完成后，请确保保存文件。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Only use *spaces* and not *tabs* anywhere in this file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，只能使用*空格*而不是*制表符*。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let’s try our first rpm build. The output for this will be huge (so I’m
    not going to bother listing it all).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试第一次rpm构建。这个过程的输出会非常庞大（所以我不会列出全部内容）。
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now let’s do a test install.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行一次测试安装。
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alright! We have our first custom package and our first custom file installer
    (and it works!)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们已经有了第一个自定义软件包和第一个自定义文件安装程序（而且它有效！）
- en: Let’s show it off.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来展示一下它。
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Great job! Now you are on your way to securing your software supply chain by
    creating your own packages. I truly hope you had at least a little fun in this
    exercise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在你正在通过创建自己的软件包来保护你的软件供应链。我真心希望你在这个练习中至少有一点乐趣。
- en: Exercise – signing your custom RPM package
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 签署你的自定义RPM包
- en: Now it’s time for extra credit. This is not an introductory course. This is
    a master-level course. Yes, it’s great we can now create a custom RPM package
    but we are focusing on securing your software supply chain in this chapter. Time
    to step things up. It’s time to add your own GPG signature to your custom package!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为你增加额外的学分了。这不是一门入门课程，而是一个高级课程。是的，我们现在可以创建自定义的RPM包了，但本章的重点是保护你的软件供应链。是时候提升难度了，加入你自己的GPG签名到你的自定义包中吧！
- en: First, we’re going to leave the build account and switch over to root access.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将退出构建账户并切换到root权限。
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’re now going to ensure you have the right software installed to sign the
    RPMs that you build for your appliance. Install the `rpm-sign` package.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将确保你已经安装了正确的软件，以签署你为设备构建的RPM包。安装`rpm-sign`包。
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this next set of steps, you’re going to generate your own super-cool secure
    `gpg` key. When you do this for real in production, you must ensure that you are
    using official names, email addresses, and so on for your `gpg` key.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，你将生成自己的超级酷的安全`gpg`密钥。当你在生产环境中实际操作时，必须确保使用官方的名称、电子邮件地址等来为你的`gpg`密钥生成信息。
- en: For this example, we’ll use the name of John Doe with an email address of `john_doe@gmail.com`
    and the not-so-secure passphrase of `Embedded`. This next command is interactive
    and some of the dialogs actually present what I comically call screen vomit in
    order to keep the users’ attention to the dialogs. Others may simply call this
    a loosely managed **Text User** **Interface** (**TUI**).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用John Doe的名字，电子邮件地址为`john_doe@gmail.com`，密码短语为不太安全的`Embedded`。接下来的命令是交互式的，其中一些对话框实际上会展示我戏谑地称之为“屏幕呕吐”的内容，以吸引用户注意这些对话框。其他人可能会将其称为松散管理的**文本用户界面**（**TUI**）。
- en: Important note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Use `gpg --full-generate-key` for a full-featured key generation dialog.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpg --full-generate-key`命令来启动一个完整功能的密钥生成对话框。
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, the following dialog will appear; you’ll enter the passphrase `Embedded`
    and select `<OK>` to continue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下对话框将会出现；你需要输入密码短语`Embedded`并选择`<OK>`继续。
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will most likely get scolded by the system for not using a super-secure
    passphrase, but this is training, so select `<Take this one anyway>` to continue.
    One just has to love these interactive text interfaces. They really do prevent
    you from having to learn a command line that’s a mile long.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 系统很可能会因为你没有使用超级安全的密码短语而批评你，但这只是训练，所以请选择 `<Take this one anyway>` 继续。真该感谢这些交互式文本界面，它们确实避免了你需要学习一个超长的命令行。
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’re almost there in getting the key created. We must confirm the passphrase
    `Embedded` to continue.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离创建密钥已经不远了。我们必须确认密码短语 `Embedded` 才能继续。
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And let’s watch it do its work. Your output should appear much like this (but
    not exactly as each key generation is unique).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它如何工作。你的输出应该类似于这样（但每次密钥生成都是独特的，所以可能不完全一样）。
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So now let’s take a look at all the keys on our system so far.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们系统中目前所有的密钥。
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Your key is now imported. Let’s query the `rpm` database to see if it’s actually
    there. A simple query may not be sufficient, so we might need to add in some field
    parsing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你的密钥已经被导入。让我们查询 `rpm` 数据库，看看它是否真的存在。简单的查询可能不够，所以我们可能需要添加一些字段解析。
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Okay. Now, let’s set up the signing environment for root and then verify that
    it is all ready to go. As root, use your favorite editor to create the `.rpmmacros`
    file in the root home directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在，让我们为 root 设置签名环境，然后验证它是否已准备好。作为 root，使用你喜欢的编辑器在 root 主页目录下创建 `.rpmmacros`
    文件。
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here’s what you’ll need to place in the `.rpmmacros` file. Don’t forget to save
    the file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你需要放入 `.rpmmacros` 文件中的内容。别忘了保存文件。
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As many have heard me say (probably far too often), *Trust but verify*. So verify!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如许多人听我说过的（可能太频繁了），*信任但要验证*。所以要验证！
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The magic moment that you’ve been waiting for. Let’s sign the RPM that you just
    built with your shiny new `GPG` key! Remember you’ll be asked for our super-secret
    passphrase – `Embedded`. Enter it and then select `<OK>`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你等待的神奇时刻到了。让我们用你那崭新的 `GPG` 密钥来签署刚刚构建的 RPM！记住，你将被要求输入我们的超级秘密密码短语——`Embedded`。输入它后，选择
    `<OK>`。
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ve created your first custom file that aligns with embedded best practices
    by installing a release file in your appliance. Since security is paramount in
    the software supply chain, you’ve also ensured the sanctity of your package by
    adding your own `GPG` key signature. Pat yourself on the back.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在设备中安装发布文件，创建了符合嵌入式最佳实践的第一个自定义文件。由于安全在软件供应链中至关重要，你还通过添加自己的 `GPG` 密钥签名确保了包的完整性。为自己鼓掌吧。
- en: Show off that awesome new skill set by testing the package again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 展示你那炫酷的新技能，再次测试一下这个包。
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here we are. Journey complete. Let’s move on to the next steps in securing our
    software supply chain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这里。任务完成。让我们继续迈向确保软件供应链安全的下一步。
- en: Exercise – creating a custom DNF repository
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习——创建一个自定义 DNF 仓库
- en: There are actually two schools of thought on this. One creates separate repositories
    for the applications stack and the operating system, and the other simply puts
    it all in a monolithic custom repository. I prefer the latter. I say just put
    it all together as tracking gets simpler. I also believe in the creation of numerous
    custom RPMs in the said repository that shall assist your team in the maintenance
    of your solution. I can literally feel my own eyes rolling when I type that. Am
    I repeating myself? Probably.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于这个问题有两种不同的思路。一种是为应用堆栈和操作系统创建独立的仓库，另一种是将所有内容放在一个单一的自定义仓库中。我更倾向于后一种。我认为把所有内容放在一起会更简单，跟踪起来也更方便。我还认为，在这个仓库中创建大量自定义
    RPM 以帮助团队维护解决方案是非常有必要的。我在打字时简直能感觉到自己的眼睛在翻白眼。我是不是在重复自己？很可能是的。
- en: What else should go in this custom repository? First, I recommend an rpm that
    defines your release, much like we created just a little while ago. Second, I
    recommend the creation of a documentation rpm to be separate from your application
    itself. Finally, and most importantly, I strongly recommend the creation of an
    rpm that installs your repository information directly into the appliance. Defining
    the repository in its own rpm is key. It aids in the support and lifecycle of
    the solution and if you need to make changes to the repository (or the GPG keys),
    it gives you the simplest way of updating it for the end-customer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义存储库中还应该包含哪些内容？首先，我建议添加一个定义您版本的 rpm，就像我们刚才创建的那样。其次，我建议创建一个文档 rpm，最好与您的应用程序分开。最后，也是最重要的，我强烈建议创建一个
    rpm，直接将您的存储库信息安装到设备中。将存储库定义在其自己的 rpm 中非常关键。这有助于支持和生命周期管理，如果您需要对存储库（或 GPG 密钥）进行更改，它为最终客户提供了最简单的更新方式。
- en: These custom repositories are not just for the appliances’ updates. They can
    be greatly leveraged internally as part of your secure build chain. So, with all
    that said, how do we build a custom repository?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义存储库不仅仅用于设备的更新。它们可以作为您安全构建链的一部分，在内部大大发挥作用。那么，话说回来，我们该如何构建一个自定义存储库呢？
- en: Requirements for the exercise
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 练习要求
- en: For this hands-on exercise, you will only need access to a Linux machine (physical
    or virtual). Root (or `sudo`) access is mandatory. I am doing this example on
    my Fedora 40 box, but you could potentially follow along with me on any RHEL-like
    distribution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动手练习，您只需要访问一台 Linux 机器（物理机或虚拟机）。需要 root（或`sudo`）权限。我在我的 Fedora 40 系统上做这个示例，但您也可以在任何
    RHEL 类的发行版上跟着我一起操作。
- en: First, we’ll ensure that `httpd` and the `createrepo` utility are installed.
    Then, we’ll also make sure that the web server is actively running.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将确保已安装`httpd`和`createrepo`工具。然后，我们还需要确保 Web 服务器正在正常运行。
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, we’ll create a folder under the html directory for our repository. Then
    we’ll copy the rpm we created in the previous exercise to the directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 html 目录下创建一个文件夹来存放我们的存储库。然后，我们将把之前练习中创建的 rpm 文件复制到该目录。
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we’ll initialize the repository.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化存储库。
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Test to ensure that we can access the repository via a web browser locally.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 测试以确保我们可以通过本地的 Web 浏览器访问存储库。
- en: Here’s an example of what you’ll see by testing on a local browser. It will
    show you an accessible set of contents in your newly created custom repository.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在本地浏览器中测试时您会看到的一个示例。它将显示您新创建的自定义存储库中的可访问内容。
- en: '![Figure 5.8 – Localhost view of repository in a web browser](img/B22104_05_08.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 在网页浏览器中查看本地存储库](img/B22104_05_08.jpg)'
- en: Figure 5.8 – Localhost view of repository in a web browser
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 在网页浏览器中查看本地存储库
- en: Other steps for this internal repository are to enable `http` on the firewall
    (so our new repo can be accessed by machines in your lab internally) and, if in
    use, set the `selinux` file context for the repositories directory and files to
    `httpd_syscontent_t`. As this is not a basic sysadmin book, I trust you and your
    team already know how to do those simple tasks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内部存储库的其他步骤包括在防火墙上启用`http`（这样我们的新存储库可以被您实验室内的机器访问），如果正在使用，还需将存储库目录和文件的`selinux`文件上下文设置为`httpd_syscontent_t`。由于这不是一本基础的系统管理员书籍，我相信您和您的团队已经知道如何做这些简单的任务。
- en: This is generally an OK setup for a lab. This setup is beyond unacceptable for
    anything externally facing (i.e., internet-facing). For that use case, there are
    many books and resources available on how to secure your web server; however,
    I will make some baseline recommendations that should go without saying.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是实验室环境中的合适设置。对于任何面向外部的应用（即面向互联网的），这种设置是完全不可接受的。对于这种使用情况，有许多书籍和资源可供参考，教您如何保护
    Web 服务器；但是，我会做一些基础性建议，这些建议应该是显而易见的。
- en: For a public-facing web server, your system should be using `https` with a signed
    certificate. The server should be in your company’s external DNS so the customers
    can find it. Methods to control access, perhaps at an individual customer or user
    level, should be applied. Protect your system as best you can.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向公众的 Web 服务器，您的系统应使用带有签名证书的`https`。服务器应该在您公司外部的 DNS 中，以便客户能够找到它。应采用方法控制访问，或许在单个客户或用户级别上进行控制。尽可能保护您的系统。
- en: Now that we’ve created a custom package and hosted it via a custom repository,
    all that remains is how to configure the appliances to consume the new custom
    content. This next exercise will walk you through just that.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个自定义包并通过自定义仓库进行托管，剩下的就是如何配置设备以使用新的自定义内容。接下来的练习将带你完成这一过程。
- en: Exercise – configuring your solution to use your custom repository
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 配置你的解决方案以使用自定义仓库
- en: Let’s now configure our appliance to access our custom repository. This is a
    key step in ensuring that only your tested and vetted content is provided to your
    end-users in the future.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们配置设备以访问自定义仓库。这是确保将来只向最终用户提供经过测试和验证的内容的关键步骤。
- en: Requirements for the exercise
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 练习要求
- en: For this hands-on exercise, you will need access to the same Linux machine where
    you previously created a sample repository along with another machine to configure
    for accessing the said repository. Root (or `sudo`) access is mandatory. I am
    doing this example on my Fedora 40 box, but you could potentially follow along
    with me on any RHEL-like distribution.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个动手练习，你需要访问之前创建了示例仓库的同一台Linux机器，并且还需要另一台机器来配置以访问该仓库。必须具有root（或`sudo`）权限。我在我的Fedora
    40系统上做这个示例，但你也可以在任何类似RHEL的发行版上跟着我一起操作。
- en: These files are stored under `/etc/yum.repos.d/` and have the file extension
    of `.repo`. They should be owned by root, readable by all, but not writable by
    anyone else other than root. This will keep them secure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件存储在`/etc/yum.repos.d/`目录下，文件扩展名为`.repo`。它们应该由root用户拥有，所有人可读，但只有root可以写。这样可以确保它们的安全性。
- en: So before you create your own example repository definition file, let’s take
    a look at a detailed breakdown of one I created for the custom repository in the
    earlier exercise. Here is an example file called `mycustomstuff.repo`. I will
    place a copy of this file in the GitHub repository in case you do not wish to
    type this one out.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你自己的示例仓库定义文件之前，我们先来看一下我为之前练习中创建的自定义仓库所做的详细拆解。这是一个名为`mycustomstuff.repo`的示例文件。我会把这个文件的副本放在GitHub仓库中，以防你不想自己输入这个文件内容。
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that you have an example, create your own `mycustomstuff.repo` file and
    place it on the Linux machine that is not hosting the repo. The file should be
    owned by root but be readable by all groups and all users.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个示例，创建你自己的`mycustomstuff.repo`文件，并将其放在没有托管仓库的Linux机器上。该文件应该由root用户拥有，但所有用户和所有组都可以读取。
- en: Once you have completed that, test the functionality by installing the RPM package
    `myapprel` on the machine where you’ve set up the repository access.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，通过在已设置仓库访问的机器上安装RPM包`myapprel`来测试其功能。
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we’ve successfully attached our system to the repository and installed
    our custom package, we can celebrate our success. These exercises are crucial
    to how your team will be able to support your appliances in the future.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地将系统连接到仓库并安装了自定义包，我们可以庆祝我们的成功了。这些练习对于你的团队未来如何支持设备至关重要。
- en: Other concerns to account for
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的其他问题
- en: This should go without saying, but I will say it anyway. Have actual people
    test your prototypes and release candidates. Only this will let your team know
    if you have truly achieved success. I am not saying that you should not test with
    automation – actually, quite the opposite. Do both. Do all the automated tests,
    the penetration tests, and the scans first. Once satisfied with those results,
    move on to human trials.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这本该不言而喻，但我还是要说一遍。让实际人员测试你的原型和发布候选版本。只有这样，你的团队才能知道你是否真正取得了成功。我并不是说你不应该进行自动化测试——实际上，恰恰相反，你应该同时进行。首先做所有自动化测试、渗透测试和扫描。一旦对这些结果感到满意，再进行人工测试。
- en: You must also test your processes and support infrastructure. Test how new releases
    will impact the support chain and how each new release will be consumed by your
    customers. Failed or broken updates can cause outages, service blockages, unusable
    appliances, and, worst of all, very disgruntled and dissatisfied customers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须测试你的流程和支持基础设施。测试新版本将如何影响支持链，以及每个新版本将如何被你的客户使用。失败或损坏的更新可能会导致停机、服务阻塞、无法使用的设备，最糟糕的是，客户会非常不满和失望。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, let’s recap. We truly have covered a lot of material in this chapter. You
    should feel that you’ve achieved some level of success. You have come a long way
    in a short time. Initially, you established your appliance’s bill of materials
    (SBOM), and then you defined your own custom packages, releases, and custom repositories.
    All of this culminated in putting them into action by granting your appliance
    access to your custom repository and installing new packages. You have secured
    your own software supply chain! I hope you now feel that you’re empowered to track
    the lifecycle of your future offering, so let’s move on to the next chapter where
    we will dive deep into the usage of encryption and protecting the data within
    your solution.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来总结一下。我们在这一章中确实涵盖了很多内容。你应该感觉自己已经取得了一定的成就。你在短时间内已经走了很长一段路。最初，你建立了你的设备物料清单（SBOM），然后你定义了自己的自定义包、发布版本和自定义仓库。所有这些最终都通过授权设备访问你的自定义仓库并安装新包来付诸实践。你已经确保了自己的软件供应链安全！希望你现在能感到有能力跟踪未来产品的生命周期，接下来我们将进入下一章，深入探讨加密技术的使用以及如何保护你解决方案中的数据。
