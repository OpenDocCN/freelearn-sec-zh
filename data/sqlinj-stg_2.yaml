- en: '*Chapter 5*: Preventing SQL Injection with Defensive Solutions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：通过防御性解决方案防止 SQL 注入'
- en: Up until now, we have focused on the offensive aspect of SQL injection. We saw
    how a malicious user can perform main attack techniques in previous chapters,
    and what consequences a successful SQL injection attack could have. In a general
    sense, we saw how in principle, a SQL injection can quite easily result in a fully
    compromised database, which could leak sensitive information, give attackers full
    access to connected applications, or totally break the functionality of databases,
    applications, web services, or even connected devices, independent of the technology
    used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注 SQL 注入的进攻性方面。在前几章中，我们看到恶意用户如何执行主要的攻击技术，以及成功的 SQL 注入攻击可能带来的后果。从一般意义上讲，我们看到
    SQL 注入原理上是如何轻松地导致数据库完全被攻破的，这可能泄露敏感信息，赋予攻击者对连接应用程序的完全访问权限，或者完全破坏数据库、应用程序、网络服务，甚至连接设备的功能，无论使用何种技术。
- en: In this chapter, we will focus more on the defensive side of things; now that
    we know that such an impressive and destructive vulnerability exists—and how simple,
    in principle, it would be to exploit it—how can we stop it? This is the question
    we are trying to answer here. Obviously, the solution to this problem is not simple,
    and it usually involves applying various defenses at the same time. We will go
    through the most important defenses, tackling what, generally speaking, the differences
    are in securing applications that deal with databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更多关注防御方面的内容；既然我们已经知道存在如此强大且具有破坏性的漏洞——而且原理上它是如此容易被利用——我们该如何阻止它呢？这是我们在这里尝试回答的问题。显然，解决这个问题并不简单，通常需要同时采取多种防御措施。我们将逐一介绍最重要的防御措施，探讨在保护与数据库交互的应用程序时，通常需要注意的差异。
- en: 'This chapter is split into the following sub-sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下子章节：
- en: '**Understanding general weaknesses and SQL injection enablers**: After a very
    brief recap of the general weaknesses that make a SQL injection possible, we will
    analyze the nature of the problem so that we can move to the root cause.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解一般性弱点和 SQL 注入的促成因素**：在简要回顾使 SQL 注入成为可能的一般性弱点之后，我们将分析问题的本质，以便深入探讨其根本原因。'
- en: '**Treating user input**: Behind every SQL injection, there is always some input
    coming from a malicious agent that tries to tamper database queries to perform
    operations that are outside the range of what would normally be possible in a
    regular application. For this reason, we need a way to address how a user can
    interact with an application that sends queries to a database.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理用户输入**：每次 SQL 注入背后，都会有一些来自恶意代理的输入，试图篡改数据库查询，以执行通常在正常应用程序中无法进行的操作。因此，我们需要一种方法来处理用户如何与发送查询到数据库的应用程序进行交互。'
- en: '**Sanitization and input control**: When we start to view user input as not
    trusted, we need to process it in a secure way. This is done by applying some
    control techniques that may prevent SQL injection attempts right from the start
    by not giving attackers access to potentially dangerous commands or instructions.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入清理与控制**：当我们开始将用户输入视为不可信时，我们需要以安全的方式处理它。这是通过应用一些控制技术来实现的，这些技术可以从一开始就阻止 SQL
    注入尝试，防止攻击者访问潜在的危险命令或指令。'
- en: '**Defending against SQL injection – code-level defenses**: Some of these techniques
    can be applied directly when developing the application code. We will see some
    examples of how security can be pursued efficiently through secure coding since
    the design phase.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御 SQL 注入——代码层级防御**：其中一些技术可以直接在开发应用程序代码时应用。我们将看到一些如何通过安全编码在设计阶段高效地追求安全的例子。'
- en: '**Defending against SQL injection – platform-level defenses**: Other controls
    can be applied, besides at code-level, to other layers of the application flow,
    applying the concept of defense-in-depth at multiple stages of interaction.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御 SQL 注入——平台层级防御**：除了在代码层面，其他控制措施还可以应用到应用程序流程的其他层面，利用“深度防御”概念，在多个交互阶段进行防护。'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we strongly recommend familiarizing yourself with the main
    technologies involved in SQL injection scenarios. Besides going through the *Technical
    requirements* sections of previous chapters, we recommend taking a look at the
    documentation for some of the programming languages commonly used in conjunction
    with SQL so that we''re on the same page when talking about some solutions that
    can be adopted in application development:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，我们强烈建议先熟悉一下SQL注入场景中涉及的主要技术。除了阅读前几章中的*技术要求*部分，我们建议查看一些常见的与SQL结合使用的编程语言的文档，这样在讨论可以应用于应用开发的解决方案时，我们可以达成一致：
- en: '[https://docs.oracle.com/en/java/](https://docs.oracle.com/en/java/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/en/java/](https://docs.oracle.com/en/java/)'
- en: '[https://www.php.net/manual/en/](https://www.php.net/manual/en/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.php.net/manual/en/](https://www.php.net/manual/en/)'
- en: '[https://docs.microsoft.com/en-us/dotnet/](https://docs.microsoft.com/en-us/dotnet/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/](https://docs.microsoft.com/en-us/dotnet/)'
- en: Understanding general weaknesses and SQL injection enablers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见的弱点和SQL注入的启用因素
- en: SQL is an immensely powerful and effective tool for interacting with relational
    databases as it provides an opportunity to perform various tasks through the wide
    array of functions and commands available. Unfortunately, from a security standpoint,
    this boon is also a bane; allowing access to many different types of operations
    means that if no control is in place, anyone could potentially turn an application
    that utilizes databases on its head, leaving malicious imagination as the only
    limit to what attackers could achieve.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是与关系数据库交互的一个强大且有效的工具，因为它提供了通过各种功能和命令执行各种任务的机会。不幸的是，从安全角度来看，这种优势也可能成为负担；允许进行许多不同类型的操作意味着，如果没有适当的控制措施，任何人都可能将利用数据库的应用程序颠倒过来，使得攻击者能够根据恶意想象力做到任何事情，只有其他漏洞的存在才是攻击者能否成功的限制。
- en: You saw firsthand what a vulnerable application can lead to (and we hope you
    also had fun in the process) in the previous chapter, and if you've reached this
    point in the book, you may also be wondering whether there's any way to improve
    security to prevent all of this. SQL databases are still extensively used today,
    so you can probably guess that the short answer is definitely yes. The long answer
    is that these defenses need to be applied all at once.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你亲眼看到了一个脆弱应用程序可能导致的后果（我们也希望你在过程中玩得开心），如果你已经读到本书的这一部分，你可能也会在想是否有方法能够提高安全性，防止这一切的发生。SQL数据库今天仍然被广泛使用，所以你可以猜到，简短的答案肯定是有的。详细的答案是，这些防御措施需要一次性应用。
- en: When exploring the challenges of **Magical Code Injection Rainbow** or even
    the **Mutillidae II** web application, we saw how simple solutions alone may not
    be enough as there is usually a way to bypass them. However, if defense was applied
    at multiple points in the application, these workarounds would not work anymore
    due to the presence of other simultaneous defenses that may render SQL injection
    attacks almost impossible without the existence of other vulnerabilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索**魔法代码注入彩虹**或甚至**Mutillidae II** Web应用程序的挑战时，我们看到了单纯的解决方案往往不足以应对，因为通常总有绕过它们的方法。然而，如果防御措施在应用程序的多个点同时实施，那么这些应急方法将不再有效，因为其他同时存在的防御措施将使SQL注入攻击几乎不可能发生，除非存在其他漏洞。
- en: 'The main problem behind a SQL injection is how user input can interact with
    the actual syntax of SQL, mainly because, at the code level, SQL statements are
    usually constructed from text strings. Various programming languages use specific
    functions that take text strings as an argument. This text string is obviously
    written in SQL syntax in order to be interpreted as SQL input. The following is
    a SQL **String** declaration from the vulnerable Java web service we used in [*Chapter
    4*](B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069), *Attacking Web, Mobile, and
    IoT Applications*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入的主要问题在于用户输入如何与SQL的实际语法进行交互，主要是因为在代码层面上，SQL语句通常是由文本字符串构建的。各种编程语言使用特定的函数，这些函数接受文本字符串作为参数。显然，这个文本字符串是用SQL语法编写的，以便作为SQL输入进行解释。以下是我们在[*第4章*](B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069)中使用的脆弱Java
    Web服务中的SQL **字符串**声明，*攻击Web、移动和物联网应用*：
- en: String query = "SELECT * FROM " + USER_TABLE + " WHERE username='" + user_id
    + "' AND password='" + password + "'";
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: String query = "SELECT * FROM " + USER_TABLE + " WHERE username='" + user_id
    + "' AND password='" + password + "'";
- en: The **query** string will then be sent as a command to the database using **executeQuery(query)**,
    a Java function that, within a database connection, sends the input string to
    the database so that it can be processed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**query** 字符串将作为命令通过 **executeQuery(query)** 发送给数据库，这是一个 Java 函数，在数据库连接内将输入字符串发送到数据库，以便进行处理。'
- en: 'You can see that while some parts of the query have fixed content, as delimited
    by double quotes, other parts are made up of previously declared variables. You
    can already tell where we are going now as you have already seen a SQL injection
    in action. By inserting a malicious payload into the query structure, attackers
    could in fact make it possible to execute arbitrary commands as if they were writing
    parts of the query themselves. In the attacks we previously mentioned, it''s enough
    for an attacker to insert the malicious payload in place of the **user_id** parameter,
    altering the structure of the query in doing so. The resulting query, with respect
    to a tautology attack for bypassing authentication, would be the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，虽然查询中的某些部分有固定的内容，像是由双引号界定的，但其他部分则由先前声明的变量组成。你现在应该已经能够察觉出我们要表达的方向，因为你已经看到了
    SQL 注入的实际操作。通过将恶意负载插入查询结构中，攻击者实际上可以让查询执行任意命令，就好像他们自己在编写查询的一部分一样。在我们之前提到的攻击中，攻击者只需将恶意负载插入到**user_id**参数的位置，改变查询结构即可。对于绕过身份验证的同值攻击，生成的查询将如下所示：
- en: SELECT * FROM USER WHERE username=**'' OR 1=1 -- -'** AND password='password'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM USER WHERE username=**'' OR 1=1 -- -'** AND password='password'
- en: Inserting legal SQL expressions can alter the originally intended query functionality,
    as in this case, by using string delimiters and commenting. That is why user input
    needs to be taken into account in terms of security.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 插入合法的 SQL 表达式可能会改变原本设计的查询功能，就像本例中通过使用字符串定界符和注释所做的那样。这就是为什么在安全方面，必须考虑用户输入。
- en: Approaching this aspect in a naive way can lead to a plethora of attack scenarios
    made possible by a SQL injection, possibly causing widespread damage to the integrity
    and security of an application. For this reason, when dealing with parts of code
    that take input from the outside of the application, this data needs to be treated
    safely and you should always consider the worst-case scenario—that this input
    is from a potentially malicious user or it has been purposely altered in order
    to cause damage to the application context. That's why we need to talk about trust
    in terms of user input.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种天真的方式处理这个问题可能会导致大量的攻击场景，这些攻击通过 SQL 注入实现，可能会对应用程序的完整性和安全性造成广泛的损害。因此，在处理来自应用程序外部的输入时，必须确保这些数据的安全性，并且始终要考虑最坏的情况——即这些输入可能来自恶意用户，或者已被故意篡改，目的是破坏应用程序的上下文。这就是为什么我们需要在讨论用户输入时，提到“信任”。
- en: Treating user input
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: What do we mean by trust when talking about security? It is actually one of
    the most important concepts when dealing with security in general, not just application
    security.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论安全时，什么是“信任”？实际上，这个概念在处理安全问题时非常重要，不仅仅是应用安全。
- en: Let's say you are walking along the street when a stranger approaches you asking
    for directions. You make a decision on whether to give directions to this person—sure,
    they could be an ill-intentioned person who is willing to attack you to steal
    your money, but you may decide that this risk is low; after all, there are many
    people around you, and you feel pretty confident that you'll be fine even if the
    situation takes a wrong turn. You then decide to trust this person in this specific
    case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在街上走，突然有一个陌生人走过来问你路怎么走。你需要决定是否给这个人指路——当然，他可能是一个心怀不轨的人，想要攻击你偷走你的钱，但你可能会判断这个风险很低；毕竟，周围有很多人，你相信即使情况有些不对劲，你也能应付得了。于是，你决定在这个特定的情况下相信这个人。
- en: Of course, how wise this choice is depends on the context. Let's say you are
    now guarding an important energy plant when suddenly a person approaches you saying
    they forgot some important documents on the site and want to go through. As your
    role is making sure no one accesses the site without authorization, you have the
    specific duty to check the identity of this person and your default approach should
    be not letting anyone pass unless you recognize this person as having the right
    to do so based on their permissions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个选择的明智与否取决于具体情况。假设你现在正在保护一个重要的能源厂区，突然一个人走过来，说他们忘记带一些重要文件想要进入厂区。由于你的职责是确保没有人未经授权进入厂区，你有义务核实这个人的身份，默认情况下，你应该不让任何人通过，除非你确认此人拥有根据权限允许进入的资格。
- en: When dealing with security, of course, the second approach is the one we should
    replicate. Zero-trust is the name of the game. Considering how malicious users
    can also spoof their identity, you should trust nobody by default. The basic assumption
    is considering the worst-case scenario every time; each user might be a malicious
    user because you cannot tell their intentions and cannot state otherwise. It would
    be a shame if you acted the other way around, trusting everybody, as one single
    malicious agent is enough to turn your application—and possibly your entire IT
    infrastructure—to smithereens.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理安全问题时，第二种方法当然是我们应该复制的方式。零信任是这个游戏的核心。考虑到恶意用户也可以伪造身份，默认情况下，你不应该信任任何人。基本的假设是，每次都考虑最坏的情况；每个用户可能是恶意用户，因为你无法判断他们的意图，也不能排除这种可能。如果你采取相反的做法，信任每个人，那么一个恶意代理就足以让你的应用程序——甚至可能是你的整个
    IT 基础设施——付之一炬。
- en: In our case, this means applying defenses to our application and database because,
    as far as we know, anybody could perform SQL injection attacks against us—especially
    considering how simple it is to do so. These defenses can usually be summarized
    by the simple concept of sanitization and input control. The general solution
    of avoiding malicious input can in fact alter the behavior of our application,
    so that such input won't be interpreted by the application as possible un-envisioned
    instructions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这意味着需要对我们的应用程序和数据库进行防御，因为据我们所知，任何人都可能对我们发起 SQL 注入攻击——尤其是考虑到这种攻击的简单性。这些防御通常可以通过简单的清理和输入控制概念来总结。避免恶意输入的普遍解决方案实际上可以改变我们的应用程序行为，使得这些输入不会被应用程序解读为可能未曾设想的指令。
- en: We will now explore what it means to sanitize input and apply defensive controls
    in this way, as well as consider all the stages that can be applied for foiling
    any possible SQL injection plan that an attacker may have.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨什么是清理输入并应用防御控制的含义，同时考虑在各个阶段可以采取的措施，来挫败攻击者可能进行的任何 SQL 注入计划。
- en: Sanitization and input control
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理和输入控制
- en: We saw that all SQL (and other) databases are inherently vulnerable to SQL injection
    on their own as the only thing a database does is accept instructions. Therefore,
    we need to act at the early stages of the data flow, before a query actually reaches
    our database to prevent an injection from happening.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到所有 SQL（以及其他）数据库本身天生就容易受到 SQL 注入攻击，因为数据库唯一的作用就是接收指令。因此，我们需要在数据流的早期阶段采取措施，在查询实际到达数据库之前，防止注入攻击的发生。
- en: This is where sanitization comes in. Input, coming from the outside, is cleaned
    up from any possible malicious element that could result in dangerous commands.
    You can imagine this process like introducing a compulsory shower for people before
    they enter a public pool—you can assume that people have a good hygiene level,
    but since there is no guarantee of it, it's a wise choice to make up for people
    who don't by leveling out the field and making everyone do it. In most cases,
    this might not be necessary, but it ensures that cases in which a shower may be
    needed are covered.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，清理就发挥作用了。外部传入的输入会被清理掉任何可能导致危险指令的恶意元素。你可以将这个过程想象成强制要求每个人在进入公共泳池之前先洗个澡——你可以假设人们的个人卫生状况良好，但由于无法保证这一点，最好让每个人都洗个澡，这样可以弥补那些不洗澡的人。在大多数情况下，这可能不是必需的，但它确保了那些确实需要洗澡的情况被覆盖。
- en: 'Obviously, there is no single way in which sanitization can be done as these
    controls can be applied at various stages in the flow of the application. However,
    in most cases, there are two major areas for applying these defenses:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，清理并没有单一的方式，因为这些控制可以在应用程序流的不同阶段进行。然而，在大多数情况下，有两个主要领域可以应用这些防御：
- en: '**Application coding**: This is where the magic happens in terms of application
    functionality. Most defense mechanisms are in this domain, which we can call **code-level
    defenses**. By acting on code and information processing, most application attacks
    can be thwarted here, rigorously ensuring that input and commands are structured
    and formatted just the way we want. This can be done by transforming the input,
    accepting only some characters or input lengths, or generating queries dynamically.
    This generally foils SQL injection attempts, if done correctly.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序编码**：这就是应用程序功能实现的关键所在。大多数防御机制都属于这个领域，我们可以称之为**代码级防御**。通过对代码和信息处理的干预，大多数应用攻击都可以在这里被挫败，严格确保输入和命令按照我们希望的方式结构化和格式化。这可以通过转换输入、仅接受某些字符或输入长度，或动态生成查询来实现。如果做得正确，这通常可以挫败
    SQL 注入尝试。'
- en: '**Platform and infrastructure configuration**: Besides acting on the application
    code, security controls can be applied in the context in which the application
    is situated (in terms of the server and infrastructure in general). This includes
    the use of external modules, appliances, and network flow controls. While this
    might seem like overkill for secure application code, but it can help drastically
    reduce successful attacks in general by preventing any malicious input from reaching
    the application altogether, thereby also avoiding collateral damage and other
    types of attacks against your application or systems. We will refer to these mechanisms
    as **platform-level defenses**.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台和基础设施配置**：除了作用于应用程序代码外，安全控制还可以应用于应用程序所处的环境（从服务器和基础设施的角度来看）。这包括使用外部模块、设备和网络流量控制。虽然这对于安全应用程序代码而言可能显得过于复杂，但它通过阻止任何恶意输入到达应用程序，从而可以大幅减少成功攻击的机会，同时避免对你的应用程序或系统造成附带损害或其他类型的攻击。我们将这些机制称为**平台级防御**。'
- en: All of these measures are a form of **input control** as they represent a way
    in which application input is checked, analyzed, and altered to be rendered inoffensive
    or blocked altogether before it reaches our running software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些措施都是一种**输入控制**，因为它们代表了一种检查、分析和修改应用输入的方式，以使其在到达我们正在运行的软件之前变得无害或完全被阻止。
- en: 'Of course, applying just a single control mechanism at once does not guarantee
    our application is secure and safe against possible attacks. We already saw, in
    [*Chapter 4*](B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069), *Attacking Web,
    Mobile, and IoT Applications*, that applying just a single means of control might
    not be enough. When we looked at Mutillidae II, we saw some simple client-side
    controls in action. The following screenshot will remind you of when we tried
    performing a regular SQL injection using the web form with client-side controls:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅应用一个控制机制并不能保证我们的应用程序能够抵御潜在的攻击，保持安全无虞。我们在[*第 4 章*](B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069)中已经看到，*Web、移动和物联网应用攻击*，仅应用一个控制手段可能不够。当我们查看
    Mutillidae II 时，看到了一些简单的客户端控制措施。以下截图将提醒你，我们在尝试使用客户端控制的网页表单执行常规 SQL 注入时的情况：
- en: '![Figure 5.1 – Client-side controls in Mutillidae II'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – Mutillidae II 中的客户端控制'
- en: '](image/B15632_05_001.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_05_001.jpg)'
- en: Figure 5.1 – Client-side controls in Mutillidae II
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Mutillidae II 中的客户端控制
- en: 'This client-side control just prevented information from being submitted with
    empty fields. Another measure that Mutillidae II has (client-side wise) is checking
    for forbidden characters—in this case, SQL injection enablers (such as single
    quotes and hyphens—this is called **blacklisting**, and we will see it in action
    shortly). Performing an SQL injection attempt using the input web form will fail
    and the application will return a message with a JavaScript alert:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种客户端控制仅仅防止了信息在字段为空时被提交。Mutillidae II 还采取了另一项客户端控制措施，即检查是否存在禁止字符——在此情况下是 SQL
    注入启用字符（例如单引号和连字符——这叫做**黑名单**，我们很快会看到它的实际应用）。使用输入网页表单进行 SQL 注入尝试会失败，应用程序会返回一条带有
    JavaScript 警报的信息：
- en: '![Figure 5.2 – Client-side control message in Mutillidae II'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – Mutillidae II 中的客户端控制信息'
- en: '](image/B15632_05_002.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_05_002.jpg)'
- en: Figure 5.2 – Client-side control message in Mutillidae II
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Mutillidae II 中的客户端控制信息
- en: While this is definitely a code-level defense, we already saw that client-side
    controls alone are useless as long as the server side is vulnerable. We inserted
    the malicious payload at the HTTP request level, totally bypassing the web form
    input and ignoring this defense.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实是代码级防御，但我们已经看到，仅靠客户端控制是没有用的，只要服务器端存在漏洞。我们在HTTP请求级别插入了恶意载荷，完全绕过了Web表单输入，忽视了这一防御。
- en: What does this mean? In the end, the best thing to do is to apply many different
    layers of defense, dramatically decreasing the likelihood of a successful attack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么呢？最终，最好的做法是应用多层防御，大幅度降低成功攻击的可能性。
- en: In the following sections, we will see how these defense mechanisms can be applied,
    both at a code level and at a platform/infrastructure level, giving you a look
    at the tools available for securing an application against SQL injection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到这些防御机制如何在代码级别和平台/基础设施级别进行应用，了解可以用来保护应用程序免受SQL注入攻击的工具。
- en: Defending against SQL injection – code-level defenses
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御SQL注入——代码级防御
- en: 'As we said earlier, applying code-level defenses, if done correctly, should
    foil all the plans of a malicious agent that wishes to attack your application.
    Of course, mistakes can always be made, and that is why the wisest thing to do
    is to apply various defense mechanisms all at once. In this section, we will explore
    the main tools at our disposal to thwart possible attacks against our application
    in terms of SQL injection. We will also see how these controls can be implemented
    into actual code in three common programming languages for developing web applications:
    Java, PHP, and .NET.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，正确实施代码级防御应该能够挫败所有恶意攻击者攻击你应用程序的计划。当然，错误总是可能发生，这就是为什么最明智的做法是同时应用多种防御机制。在本节中，我们将探索可以用来防止SQL注入攻击的主要工具。我们还将看到如何将这些控制措施在三种常见的Web应用程序开发编程语言中实现：Java、PHP和.NET。
- en: Input validation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: Input validation is the process of accepting or rejecting input based on its
    content. We only want safe input to be processed by our application, preventing
    most of the attacks against us. So, only valid input, according to our rules,
    is accepted and processed by our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证是根据输入的内容来接受或拒绝输入的过程。我们只希望安全的输入被我们的应用程序处理，从而防止大多数攻击。因此，只有符合我们规则的有效输入才会被我们的应用程序接受和处理。
- en: 'Validation follows two main approaches, which are also common to other areas
    of information security:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 验证遵循两种主要方法，这两种方法在信息安全的其他领域也很常见：
- en: '**Blacklisting**: The approach of blacklisting consists of determining what
    is not allowed and refusing any input that falls into specific blacklisting rules.
    It''s definitely easy to implement, but it might be defeated in cases where particular
    encodings that were not considered by the rules are used, or if new ways of attacking
    are discovered.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑名单**：黑名单方法的核心是确定哪些输入是不允许的，并拒绝所有符合特定黑名单规则的输入。这种方法实施起来确实简单，但可能会在未考虑到的特定编码或发现新攻击方式时被击败。'
- en: '**Whitelisting**: The approach of whitelisting is the logical opposite of blacklisting;
    these rules define what is allowed and everything that does not fall into this
    model is rejected, only accepting input that satisfies the correctness rules.
    Its implementation may be more difficult, but it definitely pays off as it can
    thwart newly discovered attacks, totally ignoring what is not originally envisioned
    by the application itself. After all, what would be the reason for a user to try
    some exotic input if not for performing some kind of attack attempt?'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白名单**：白名单方法是黑名单的逻辑对立面；这些规则定义了什么是允许的，所有不符合该模型的输入都会被拒绝，只接受符合正确性规则的输入。它的实现可能更困难，但绝对值得，因为它能够抵御新发现的攻击，完全忽略应用程序本身未预见到的内容。毕竟，如果没有进行某种攻击尝试，用户为什么要输入一些不寻常的内容呢？'
- en: Input validation is probably the most basic and simple way to prevent malicious
    input from reaching our application and is by far the most common method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证可能是防止恶意输入到达应用程序的最基本、最简单的方法，而且它是迄今为止最常见的防范手段。
- en: Input validation in Java
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的输入验证
- en: Java is a very flexible language and it has a long history of frameworks developed
    for it, many of these being particularly useful for developing web applications.
    Due to the plethora of available frameworks, we will focus on the most basic side
    of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种非常灵活的语言，拥有悠久的框架开发历史，其中许多框架特别适合用于开发 Web 应用程序。由于可用框架种类繁多，我们将重点介绍最基础的部分。
- en: As we said earlier, implementing blacklisting is quite easy, and you could simply
    check whether strings contain sensitive characters. In the following example,
    we are just blacklisting the single quote and the hyphen characters for simplicity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，实现黑名单验证非常简单，你可以通过检查字符串是否包含敏感字符来完成。在以下示例中，我们为了简化，仅黑名单限制单引号和连字符字符。
- en: 'The following code checks the input string, sent as a variable named **input**,
    and proceeds to build the SQL statement by calling another function named **constructQuery()**,
    but only if the string does not contain any blacklisted characters:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查输入字符串，该字符串作为名为 **input** 的变量传入，并通过调用名为 **constructQuery()** 的函数继续构建 SQL
    语句，但只有当字符串不包含任何黑名单字符时：
- en: String s = input;
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: String s = input;
- en: if(s.contains("\'") OR s.contains("-")){
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: if(s.contains("\'") OR s.contains("-")){
- en: throw new IllegalArgumentException("Illegal input");
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: throw new IllegalArgumentException("非法输入");
- en: '} else {'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: constructQuery(s);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: constructQuery(s);
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Whitelists can be slightly more complex in terms of coding as we need to know
    exactly what a legal input is. If we are expecting a name to be inputted, we can
    use expressions based on the alphabet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 白名单在编码上可能会稍微复杂一些，因为我们需要确切知道什么是合法的输入。如果我们期望输入的是名字，可以使用基于字母表的表达式：
- en: String s = input;
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: String s = input;
- en: if(s.matches("[[A-Z][a-zA-Z]*]"){
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: if(s.matches("[[A-Z][a-zA-Z]*]"){
- en: constructQuery(s);
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: constructQuery(s);
- en: '} else {'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: throw new IllegalArgumentException("Illegal input");
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: throw new IllegalArgumentException("非法输入");
- en: '}'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: You will notice that the inner logic is a reversed version of that for blacklisting;
    we only accept our input if we can tell for sure that it's legal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，内部逻辑是黑名单的反向版本；只有当我们可以确定输入是合法时，才接受它。
- en: Of course, there are more refined ways to apply input validation to Java code,
    and they tend to be dependent on the specific frameworks used. You can check the
    documentation for your framework, but the principle is always the same and you
    will find yourself understanding how it works easily.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，针对 Java 代码应用输入验证的方式还有更多精细的方法，它们通常依赖于特定框架的使用。你可以查阅框架的文档，但原理总是相同的，你会发现自己很容易理解其工作原理。
- en: Input validation in PHP
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 中的输入验证
- en: 'As for PHP, like Java, implementations will depend on the framework used. Similarly
    to Java, it provides some useful functions that can help with implementing input
    validation in a simple way. One of these functions is **preg_match(regex, string)**,
    which, like the **String.matches()** function, checks whether a **string** string
    matches the regular **regex** expression pattern. This can, of course, be used
    both for blacklisting and whitelisting:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 PHP，与 Java 类似，具体实现取决于使用的框架。与 Java 相似，它提供了一些有用的函数，可以帮助以简单的方式实现输入验证。其函数之一是
    **preg_match(regex, string)**，它与 **String.matches()** 函数类似，用于检查 **string** 字符串是否符合正则表达式
    **regex** 模式。当然，这可以用于黑名单和白名单的实现：
- en: $s = $_POST['input'];
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: $s = $_POST['input'];
- en: if(preg_match("/\'/", $s) OR preg_match("\-", $s)){
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: if(preg_match("/\'/", $s) OR preg_match("\-", $s)){
- en: // failed validation handling
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: // 验证失败处理
- en: '}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Now, for the whitelisting case, we are keeping the same structure but reversing
    it in a logical way, as **if** now checks for any mismatches with the regular
    expression:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于白名单的情况，我们保持相同的结构，但以逻辑上反向的方式进行，因为 **if** 现在检查是否与正则表达式不匹配：
- en: $s = $_POST['input'];
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: $s = $_POST['input'];
- en: if(!preg_match("/[[A-Z][a-zA-Z]*]/", $s){
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: if(!preg_match("/[[A-Z][a-zA-Z]*]/", $s){
- en: // failed validation handling
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: // 验证失败处理
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: In the end, different languages aside, the mechanisms are quite the same for
    both Java and PHP.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，除了不同的语言外，Java 和 PHP 的机制基本相同。
- en: Input validation in .NET
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 中的输入验证
- en: In a different way from Java and PHP, ASP.NET has various built-in controls
    that are used to develop an application. One simple control is **RegularExpressionValidator**,
    which follows the same approach as the pattern-matching functions we saw for Java
    and PHP. This control enforces both server- and client-side validation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 和 PHP 不同，ASP.NET 有多种内置控件，用于开发应用程序。一个简单的控件是 **RegularExpressionValidator**，它与我们在
    Java 和 PHP 中看到的模式匹配函数采用相同的方法。该控件强制执行服务器端和客户端的验证。
- en: 'In the following example, we are applying the same whitelisting approach we
    saw for the previous two code examples, matching against a regular expression
    that only allows a string of letters, the first of which is uppercase:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们应用了与前两个代码示例中相同的白名单方法，通过正则表达式进行匹配，只允许一个字母字符串，第一个字母为大写：
- en: <asp:textbox id="input" runat="server"/>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <asp:textbox id="input" runat="server"/>
- en: <asp:RegularExpressionValidator id="inputRegEx"  runat="server"
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <asp:RegularExpressionValidator id="inputRegEx" runat="server"
- en: ControlToValidate="input"
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ControlToValidate="input"
- en: ErrorMessage="Parameter must contain letters only, the first of which must be
    uppercase."
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ErrorMessage="参数必须只包含字母，第一个字母必须是大写字母。"
- en: ValidationExpression="[A-Z][a-zA-Z]*" />
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ValidationExpression="[A-Z][a-zA-Z]*" />
- en: ASP.NET also has other built-in controls, but this one is generally the most
    useful as it natively validates input against regular expressions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 也有其他内置控件，但这个通常是最有用的，因为它可以原生地根据正则表达式验证输入。
- en: Parametrized queries
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化查询
- en: Another way of defeating SQL injection is through the use of so-called parameterized
    queries. The main reasoning behind this is that input is never sent to the database
    as it is—that is, as a string, as is the case in dynamic string building—but it
    is instead serialized and stored in separate parameters (hence the name).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种防止 SQL 注入的方法是使用所谓的参数化查询。其主要原因是输入永远不会以原始形式（即字符串形式）直接发送到数据库，就像动态字符串构建中那样；而是被序列化并存储在独立的参数中（因此得名）。
- en: This is done by using variables when building the SQL statement, using identifiers
    as placeholders so that the actual string can be built safely. This is made even
    more accessible through the use of an API that is available for most modern programming
    languages and is used for interacting with database systems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在构建 SQL 语句时使用变量，使用标识符作为占位符，使得实际字符串能够安全地构建。通过使用现代编程语言中大多数数据库系统交互的 API，这一过程变得更加简便。
- en: It's worth noting, however, that the use of parameterized queries alone does
    not mean an application is not vulnerable to SQL injection; sometimes, parameters
    can also contain stored procedures, which, if vulnerable, can still lead to an
    SQL injection. This is just one more reason to combine defense mechanisms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，单独使用参数化查询并不意味着应用程序就不会受到 SQL 注入的攻击；有时，参数也可以包含存储过程，而存储过程如果存在漏洞，仍然可能导致
    SQL 注入。这只是将防御机制结合使用的又一个原因。
- en: 'Another perk of parametrized queries is the simplicity in which it''s possible
    to convert already-existing dynamic strings for SQL queries into parameterized
    queries. We will see how this is done in Java, PHP, and .NET by starting from
    a regular (vulnerable) SQL query build:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化查询的另一个好处是，能够轻松地将已经存在的动态字符串 SQL 查询转换为参数化查询。我们将在 Java、PHP 和 .NET 中看到如何实现这一点，首先从一个常规（易受攻击的）SQL
    查询构建开始：
- en: User = request("username")
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: User = request("username")
- en: Pass = request("password")
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pass = request("password")
- en: Query = "SELECT * FROM users WHERE username='" + User + "' AND password='" +
    Pass + "'"
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Query = "SELECT * FROM users WHERE username='" + User + "' AND password='" +
    Pass + "'"
- en: Check = Db.Execute(Query)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Check = Db.Execute(Query)
- en: If (Check) {
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: If (Check) {
- en: Login()
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Login()
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let's now see how we can parametrize the query in the preceding snippet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何将前面片段中的查询进行参数化。
- en: Parametrized queries in Java
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 中的参数化查询
- en: 'One of the most used frameworks within Java when dealing with any database
    is the **Java DataBase Connectivity** (**JDBC**) framework. It''s available natively
    and supports database connectivity independently from the database technology
    used, providing useful functions for connecting to databases. One of these is
    the **PreparedStatement** class, which allows the use of the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中处理任何数据库时，最常用的框架之一是 **Java 数据库连接** (**JDBC**) 框架。它是原生提供的，支持独立于所使用数据库技术的数据库连接，提供连接数据库的有用功能。其中之一就是
    **PreparedStatement** 类，它允许使用以下代码：
- en: Connection con = DriverManager.getConnection(connectionString);
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Connection con = DriverManager.getConnection(connectionString);
- en: String query = "SELECT * FROM users WHERE username=? AND password=?";
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: String query = "SELECT * FROM users WHERE username=? AND password=?";
- en: PreparedStatement ps = con.prepareStatement(query);
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PreparedStatement ps = con.prepareStatement(query);
- en: ps.setString(1, user);
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ps.setString(1, user);
- en: ps.setString(2, pass);
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ps.setString(2, pass);
- en: rs = ps.executeQuery();
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: rs = ps.executeQuery();
- en: The basic SQL statement is altered by replacing the values with question marks,
    which are then referred to by the **PreparedStatement** instance, **ps**. The
    **setString()** method then inserts the values in place of the placeholder question
    marks in the order that they are found in the original query, **query** (**1**
    for **user** and **2** for **pass**). In the end, the **executeQuery()** method
    is called based on the prepared statement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 SQL 语句通过将值替换为问号来修改，然后通过 **PreparedStatement** 实例 **ps** 引用这些问号。然后，**setString()**
    方法将按原始查询 **query** 中出现的顺序（**1** 对应 **user** 和 **2** 对应 **pass**）将这些值插入到问号的占位符中。最后，基于准备好的语句调用
    **executeQuery()** 方法。
- en: Parametrized queries in PHP
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 中的参数化查询
- en: PHP also has several frameworks for implementing parameterized queries. Some
    of these are available in PHP.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 也有几个框架可以实现参数化查询。其中一些框架在 PHP 中可用。
- en: 'We will change the original snippet using the **PHP Data Object** (**PDO**)
    framework as it is the direct equivalent to the JDBC framework in Java in terms
    of compatibility and functionality. It''s included in PHP version 5.1 onward:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **PHP 数据对象**（**PDO**）框架修改原始代码，因为它与 Java 中的 JDBC 框架在兼容性和功能上是直接对应的。它从 PHP
    5.1 版本开始被包含在内：
- en: $query = "SELECT * FROM users WHERE user=? AND pass=?";
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: $query = "SELECT * FROM users WHERE user=? AND pass=?";
- en: $stmt = $dbh->prepare($query);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: $stmt = $dbh->prepare($query);
- en: $stmt->bindParam(1, $user, PDO::PARAM_STR);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: $stmt->bindParam(1, $user, PDO::PARAM_STR);
- en: $stmt->bindParam(2, $pass, PDO::PARAM_STR);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: $stmt->bindParam(2, $pass, PDO::PARAM_STR);
- en: $stmt->execute();
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: $stmt->execute();
- en: This code is almost the perfect equivalent to the JDBC example; the statement
    is prepared starting from an SQL query, **query**, containing placeholders in
    the form of a question mark. Then, the **bindParam()** function binds the input
    parameter to the question mark instances, ordered by number (**1** for **user**
    and **2** for **pass**), specifying the data type of the parameter (**PDO::PARAM_STR**
    defines a string parameter). The prepared statement is finally executed with **execute()**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与 JDBC 示例完全相同；语句是从包含问号形式占位符的 SQL 查询 **query** 中准备的。然后，**bindParam()**
    函数将输入参数绑定到问号实例，按数字顺序（**1** 对应 **user** 和 **2** 对应 **pass**），并指定参数的数据类型（**PDO::PARAM_STR**
    定义了一个字符串参数）。最后，使用 **execute()** 执行准备好的语句。
- en: Parametrized queries in .NET
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 中的参数化查询
- en: As for .NET, a way to implement parameterized queries is provided by the ADO.NET
    framework. The name derives from the previous **ActiveX Data Object** (**ADO**)
    technology on which it is based.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 .NET，ADO.NET 框架提供了一种实现参数化查询的方法。这个名字来源于其基础的前身技术——**ActiveX 数据对象**（**ADO**）。
- en: 'ADO.NET interacts with databases through the use of **data providers**, one
    for each supported database system. The code syntax varies with each provider,
    so we will show examples for the **System.Data.SqlClient** provider, which works
    with Microsoft SQL Server, and **System.Data.OracleClient** for Oracle Database.
    Let''s first see what the code looks like with **SqlClient**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ADO.NET 通过使用**数据提供程序**与数据库进行交互，每个支持的数据库系统都有一个相应的提供程序。由于每个提供程序的代码语法不同，因此我们将展示使用
    **System.Data.SqlClient** 提供程序的示例，它适用于 Microsoft SQL Server，以及适用于 Oracle 数据库的
    **System.Data.OracleClient**。首先我们来看一下使用 **SqlClient** 时的代码：
- en: SqlConnection con = new SqlConnection(ConnectionString);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SqlConnection con = new SqlConnection(ConnectionString);
- en: string Query = "SELECT * FROM users WHERE username=@user" AND password=@pass";
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: string Query = "SELECT * FROM users WHERE username=@user" AND password=@pass";
- en: cmd = new SqlCommand(Query, con);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: cmd = new SqlCommand(Query, con);
- en: cmd.Parameters.Add("@user", SqlDbType.NVarChar);
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Add("@user", SqlDbType.NVarChar);
- en: cmd.Parameters.Add("@pass", SqlDbType.NVarChar);
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Add("@pass", SqlDbType.NVarChar);
- en: cmd.Parameters.Value[„@user"] = user;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Value[„@user"] = user;
- en: cmd.Parameters.Value["@pass"] = pass;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Value["@pass"] = pass;
- en: reader = cmd.ExecuteReader();
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: reader = cmd.ExecuteReader();
- en: 'The parameters here are referred to with the **@** character, and they are
    added to the **cmd** prepared statement using **Parameters.Add()**, which sends
    in the parameter name and type (in this case, a string of characters denoted by
    **SqlDbType.NVarChar**). **OracleClient** works in a similar way:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数是通过 **@** 字符引用的，它们通过 **Parameters.Add()** 被添加到 **cmd** 准备好的语句中，这会传入参数名称和类型（在这种情况下，是由
    **SqlDbType.NVarChar** 表示的字符字符串）。**OracleClient** 的工作方式类似：
- en: OracleConnection con = new OracleConnection(ConnectionString);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OracleConnection con = new OracleConnection(ConnectionString);
- en: string Query = "SELECT * FROM users WHERE username=:user AND password=:pass";
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: string Query = "SELECT * FROM users WHERE username=:user AND password=:pass";
- en: cmd = new OracleCommand(Query, con);
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: cmd = new OracleCommand(Query, con);
- en: cmd.Parameters.Add("user",  OracleType.VarChar);
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Add("user", OracleType.VarChar);
- en: cmd.Parameters.Add("pass", OracleType.VarChar);
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Add("pass", OracleType.VarChar);
- en: cmd.Parameters.Value["user"] = user;
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Value["user"] = user;
- en: cmd.Parameters.Value["pass"] = pass;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: cmd.Parameters.Value["pass"] = pass;
- en: reader = cmd.ExecuteReader();
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: reader = cmd.ExecuteReader();
- en: This structure is almost identical to the **SqlClient** example. The only differences
    reside in the way that the parameters are referred to (with a semicolon in the
    query statement and with no special character elsewhere) and the object names.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构几乎与 **SqlClient** 示例相同。唯一的区别在于参数的引用方式（在查询语句中使用分号，而在其他地方不使用特殊字符）和对象名称。
- en: Character encoding and escaping
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符编码与转义
- en: Another popular way of applying countermeasures against malicious input leading
    to SQL injection is by using specific character encoding and escaping techniques
    so that enabling characters are not sent to the database. This prevents the most
    common types of SQL injection attacks. There are also times where other defenses
    cannot be applied—for example, in databases that expect surnames, as some surnames
    may contain an apostrophe, such as O'Malley or O'Brian, which of course is still
    encoded as a single quote. In this case, there is no other way of allowing these
    surnames in your database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应对恶意输入导致 SQL 注入的另一种流行方法是使用特定的字符编码和转义技术，这样使能字符就不会发送到数据库，从而防止了最常见的 SQL 注入攻击。有时，其他防御措施无法应用——例如，在一些预期姓氏的数据库中，因为某些姓氏可能包含撇号，比如
    O'Malley 或 O'Brian，尽管它们仍然会被编码为单引号。在这种情况下，没有其他方法可以允许这些姓氏出现在你的数据库中。
- en: This time, however, we are not acting at the same level of sanitization at the
    input level as instead, we more concerned with sanitizing the output so that SQL
    statements are deprived of dangerous characters. The objective here is avoiding
    non-sanitized statements from traveling within the application flow and outside
    it when they are supposed to reach the database system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们并没有在输入层面进行相同级别的清理，而是更关注清理输出，以便 SQL 语句中不包含危险字符。我们的目标是避免未清理的语句在应用程序流程中传输并最终到达数据库系统。
- en: Of course, these techniques vary from one database system to another due to
    the differences in syntax among them. We will see these techniques applied to
    MySQL, Microsoft SQL Server, and Oracle Database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些技术因数据库系统的不同而有所差异，因为它们之间的语法存在差异。我们将看到这些技术在 MySQL、Microsoft SQL Server 和
    Oracle 数据库中的应用。
- en: Character encoding and escaping in MySQL
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 中的字符编码与转义
- en: As MySQL uses single quotes as a string termination, this character needs to
    be encoded when included in strings used for SQL statement construction. This
    can be done by replacing the single quote with two single quotes or by escaping
    the use of a single quote by using the backslash character (**\**) instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MySQL 使用单引号作为字符串终止符，因此在构造 SQL 语句时，包含在字符串中的单引号需要进行编码。这可以通过将单引号替换为两个单引号，或者通过使用反斜杠字符（**\**）来转义单引号来实现。
- en: 'In Java, this can be done with a simple **replace()** function to replace occurrences
    of one character with other characters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，可以使用一个简单的**replace()**函数来将一个字符的所有出现替换为其他字符：
- en: query1 = query1.replace("'", "\'");
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: query1 = query1.replace("'", "\'");
- en: query2 = query2.replace("'", "''");
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: query2 = query2.replace("'", "''");
- en: 'From the PHP side of things, within the **mysqli** framework, a PHP framework
    for interacting specifically with MySQL is available on PHP 5.x onward. There
    is a pretty nifty function named **mysql_real_escape_string( )** that automatically
    puts a backslash in front of single quotes in a text string. This form of escaping
    is also applied to other dangerous characters:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PHP 方面来看，**mysqli** 框架是一个专门用于与 MySQL 交互的 PHP 框架，它适用于 PHP 5.x 及以后的版本。有一个非常方便的函数叫做
    **mysql_real_escape_string( )**，它会自动在文本字符串中的单引号前加上反斜杠。这种转义方法同样适用于其他危险字符：
- en: mysql_real_escape_string($parameter);
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: mysql_real_escape_string($parameter);
- en: 'Of course, a **REPLACE** function is still available in PHP:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，PHP 中依然可以使用 **REPLACE** 函数：
- en: SET @query1 = REPLACE(@query1, '\'', '\\\'');
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SET @query1 = REPLACE(@query1, '\'', '\\\'');
- en: SET @query2 = REPLACE(@query2 '\'', '"');
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: SET @query2 = REPLACE(@query2 '\'', '"');
- en: 'Another thing to keep in mind for sanitization is that other harmful characters
    include wildcards in a **LIKE** clause that can define any character, possibly
    causing tautology when added maliciously to a query. The most relevant wildcard
    is the **%** character, which corresponds to a wildcard of zero or more of any
    character. It can be escaped via a **replace()** function by adding a backslash
    before it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的清理问题是，其他有害字符包括**LIKE**子句中的通配符，这些通配符可以定义任意字符，可能会在恶意地添加到查询时导致自我证伪。最相关的通配符是**%**字符，它对应于零个或多个任意字符的通配符。可以通过在其前面添加反斜杠来通过**replace()**函数转义：
- en: query3 = query3.replace("%", "\%"); // Java
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: query3 = query3.replace("%", "\%"); // Java
- en: SET @query3 = REPLACE(@query3, '%', '\\%'); // PHP
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SET @query3 = REPLACE(@query3, '%', '\\%'); // PHP
- en: You can apply this mechanism to any possibly dangerous character before sending
    a query statement to the database or other parts of the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在将查询语句发送到数据库或应用程序的其他部分之前，您可以将此机制应用于任何可能危险的字符。
- en: Character encoding and escaping in SQL Server
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL Server 中的字符编码和转义
- en: 'The same assumptions and mechanisms we considered for MySQL can be applied
    to SQL Server. So, both the Java and PHP functions we have considered are valid
    for suppressing the single quote character. This time, when we talk about SQL
    server, we will consider the corresponding C# code, too, for replacing single
    quotes with double quotes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MySQL 的假设和机制，同样可以应用于 SQL Server。因此，我们之前提到的 Java 和 PHP 函数都适用于抑制单引号字符。这一次，当我们讨论
    SQL Server 时，我们还将考虑相应的 C# 代码，用于将单引号替换为双引号：
- en: query3 = query3.replace("'", "''");
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: query3 = query3.replace("'", "''");
- en: 'In addition to what we already considered for MySQL, SQL Server has an **ESCAPE**
    clause, which can be used to escape any character within a SQL query in a **LIKE**
    clause:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前考虑过的 MySQL，SQL Server 也有一个**ESCAPE**子句，可以在**LIKE**子句中用于转义 SQL 查询中的任何字符：
- en: SELECT * from users WHERE name LIKE 'a\%' ESCAPE '\'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * from users WHERE name LIKE 'a\%' ESCAPE '\'
- en: The preceding query escapes the backslash character in the **LIKE** clause,
    only returning records with a **a%** username (provided it exists).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询在**LIKE**子句中转义了反斜杠字符，仅返回用户名为**a%**的记录（前提是该用户名存在）。
- en: Character encoding and escaping in Oracle Database
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle 数据库中的字符编码和转义
- en: 'While considering the same assumptions made for MySQL, Oracle Database also
    usually relies on the PL/SQL language. This also has a **replace()** function,
    which can be used as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑与 MySQL 相同的假设时，Oracle 数据库通常也依赖于 PL/SQL 语言。它也有一个**replace()**函数，可以如下使用：
- en: query = replace(query, '''', '''''');
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: query = replace(query, '''', '''''');
- en: Oracle Database also supports an **ESCAPE** clause for the **LIKE** clauses,
    as was the case for SQL Server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 数据库也支持**ESCAPE**子句，用于**LIKE**子句，就像 SQL Server 一样。
- en: After dealing with these specific techniques, let's now move on to something
    more high-level in terms of code-level countermeasures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了这些特定技术后，现在我们可以转向更高层次的代码级对策了。
- en: Secure coding practices
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全编码实践
- en: In most cases, the root of all the application security problems resides in
    the design and development phase. More often than not, in fact, designers and
    developers tend not to consider security aspects in the applications they find
    themselves working on, usually giving more importance to the functional aspects.
    This leads not only to vulnerabilities such as SQL injection but also to the increasing
    difficulty in remediating these vulnerabilities. Addressing security problems
    during the design and development phase takes much less effort as the only thing
    to do is apply the tools we described earlier and some secure design principles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，所有应用程序安全问题的根源都存在于设计和开发阶段。事实上，设计师和开发人员往往不会在他们所工作的应用程序中考虑安全方面的内容，通常更关注功能方面。这不仅导致了像
    SQL 注入这样的漏洞，也导致了这些漏洞的修复变得越来越困难。在设计和开发阶段解决安全问题所需的努力要少得多，因为所要做的只是应用我们之前描述的工具和一些安全设计原则。
- en: The OWASP SAMM Framework
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP SAMM 框架
- en: OWASP, among other relevant projects, has devised an important framework to
    give organizations the tools to ensure the application of a model that promotes
    secure software development for all stages and stakeholders involved in the process
    of software design and development—the **Software Assurance Maturity Model** (**SAMM**).
    This framework provides a way for enterprises to self-assess their software development
    life cycle in terms of security, independent from the technologies used. For further
    information, you can access the project's web page at [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP及其他相关项目已经制定了一个重要框架，为组织提供工具，以确保应用一个促进安全软件开发的模型，涵盖软件设计和开发过程中所有阶段和利益相关者——**软件保障成熟度模型**（**SAMM**）。该框架为企业提供了一种自我评估其软件开发生命周期中安全性的方式，无论所使用的技术如何。欲了解更多信息，您可以访问该项目的网页：[https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)。
- en: We will now consider some good practices that can help in producing more secure
    code against SQL injection. This serves as an introduction to a security-focused
    approach for dealing with SQL injection from a coding perspective, introducing
    secure coding aspects to your application that can prove particularly effective
    and saving time and effort in subsequent stages of the application life cycle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑一些有助于防范SQL注入的良好实践。这为从编码角度处理SQL注入提供了一种以安全为重点的方法，介绍了一些可以证明特别有效的安全编码方面，从而节省在应用程序生命周期后续阶段中的时间和精力。
- en: Introducing additional abstraction layers
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入额外的抽象层
- en: When we talk about abstraction layers, we mean different logical components,
    each devised to interact with your application logic. General examples of application
    layers are the presentation layer, which incorporates the more graphical and interactive
    aspects of the application, and the data access layer, designed to interact with
    data separately from the core application logic. Separating layers in an application
    generally improves security as moving from one layer to another is generally subject
    to more controls and makes applying security measures much more linear and practical.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论抽象层时，我们指的是不同的逻辑组件，每个组件都旨在与您的应用程序逻辑进行交互。应用程序层的常见例子包括表示层，它包括应用程序中更具图形性和交互性的方面，以及数据访问层，它旨在与数据进行交互，独立于核心应用程序逻辑。应用程序中分离不同层通常会提高安全性，因为从一层到另一层的迁移通常会受到更多的控制，并使得应用安全措施的实施更加线性和实际。
- en: An example of special additional layers introduced for security reasons is the
    ADO.NET framework we saw earlier, which can be used to interact with the database
    by introducing an additional level to the application specifically to send secure
    commands to the database, much like a dedicated data-access layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个为安全原因引入的特殊附加层的例子是我们之前看到的ADO.NET框架，它通过引入一个附加层来与数据库进行交互，专门用于向数据库发送安全命令，类似于一个专用的数据访问层。
- en: Managing sensitive data securely
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全地管理敏感数据
- en: Another important security principle when designing a secure application is
    deciding how to manage and handle potentially sensitive data. Some of the information
    used and stored by the application might be extremely valuable to potential malicious
    attackers, including authentication information, such as passwords or credit card
    numbers, or even other sensitive or personal identifying information, such as
    names, surnames, physical addresses, and social security numbers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 设计安全应用程序时的另一个重要安全原则是决定如何管理和处理潜在的敏感数据。应用程序使用和存储的一些信息对于潜在的恶意攻击者可能具有极高价值，包括身份验证信息，如密码或信用卡号码，甚至其他敏感或个人身份信息，如姓名、姓氏、住址和社会保障号码。
- en: When dealing with passwords, usually we are talking about particularly relevant
    information that is often specifically targeted by attackers. One of the most
    useful measures to take is storing passwords with a particularly **Secure Hashing
    Algorithm** (**SHA**), such as SHA-2, which provides one of the highest standards
    in cryptographic hash, producing one-way digests with 256- or 512-bit lengths.
    We saw, in our previous chapter, how other surpassed standards, such as **Message
    Digest 5** (**MD5**), are no longer secure and could easily be broken into, with
    the attacker extracting the original password value, in the case of a successful
    SQL injection attack.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理密码时，通常我们谈论的是特别重要的信息，这些信息通常是攻击者特别关注的目标。采取的最有用的措施之一是使用特别的**安全哈希算法**（**SHA**），例如SHA-2，它提供了加密哈希中最高的标准之一，生成256位或512位长度的单向摘要。我们在上一章中看到，像**消息摘要算法5**（**MD5**）等已被超越的标准不再安全，容易被攻破，攻击者可以在成功的SQL注入攻击中提取原始密码值。
- en: Another means of securing sensitive information includes masking data by only
    showing parts of the data to the application while keeping the original data unaltered.
    This can be achieved by treating this data appropriately in the application, applying
    pseudonymization techniques that substitute, for example, a large part of the
    information with special characters (such as *****), making it recognizable to
    the owner of the information while at the same time not leaking more information
    than necessary to outsiders.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 保护敏感信息的另一种方式是通过屏蔽数据，只向应用程序显示部分数据，同时保持原始数据不变。这可以通过在应用程序中适当处理这些数据来实现，采用伪匿名化技术，例如，用特殊字符（如*****）替代数据的大部分，使其对信息拥有者可识别，同时又不会泄露超过必要的信息给外部人员。
- en: Of course, we want our application to be as invulnerable as possible to SQL
    injection, but considering that this risk will never be zero, this type of protection
    can definitely make a difference in securing an application and its data, minimizing
    the effects of a successful attack.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望我们的应用程序尽可能对SQL注入免疫，但考虑到这个风险永远不可能为零，这种类型的保护无疑能在确保应用程序及其数据的安全性方面起到决定性作用，最大程度地减少成功攻击的影响。
- en: Stored procedures
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储过程
- en: This measure is probably the most specific so far as it is directly linked to
    SQL databases. Stored procedures are specific instructions that are stored within
    the database itself and on which it's possible to apply stricter access control.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个措施可能是迄今为止最具体的，因为它直接与SQL数据库相关。存储过程是存储在数据库本身中的特定指令，可以对其实施更严格的访问控制。
- en: We saw how an application can potentially access the whole database so that
    when it's compromised with a SQL injection attack, it can give access to attackers,
    even to information residing on the same database in which the application database
    is not linked to the application itself, as we saw in the previous chapter with
    the shared MySQL database of the OWASP Broken Web Applications virtual machine,
    which allowed access to information belonging to other applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个应用程序可能会访问整个数据库，所以当它遭遇SQL注入攻击时，攻击者可能会获得访问权限，甚至访问数据库中其他应用程序所在的同一数据库中的信息，就像我们在上一章中看到的，OWASP损坏Web应用程序虚拟机的共享MySQL数据库，它允许访问属于其他应用程序的信息。
- en: When you are using stored procedures, you can change the access permissions
    for the instructions contained within it, giving less privilege than the application
    to the commands that are executed. This means enforcing the principle of **least
    privilege**, which means that if for some reason an attacker can compromise the
    stored procedure containing the SQL commands, the damage would be contained due
    to the stricter access controls implemented.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用存储过程时，你可以更改存储过程中的指令的访问权限，赋予执行的命令比应用程序更低的权限。这意味着要执行**最小权限原则**，即如果某种原因攻击者能够入侵包含SQL命令的存储过程，损害将会被限制，因为已经实施了更严格的访问控制。
- en: This concludes our look at what can be done in terms of application development
    and coding. Applying as many of these measures as possible can definitely help
    in securing your application against SQL injection attacks. However, this is not
    the only way in which you can apply additional security measures to your application,
    as you can also act outside of it in the context that the running application
    is in. Let's look at what this means.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容总结了在应用开发和编码方面可以采取的措施。尽可能多地应用这些措施，肯定有助于保护你的应用免受 SQL 注入攻击。然而，这并不是你可以对应用程序采取的唯一额外安全措施，因为你还可以在应用程序运行的环境上下手。让我们看看这意味着什么。
- en: Defending against SQL injection – platform-level defenses
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御 SQL 注入 – 平台级防护
- en: As mentioned earlier, platform-level defenses refer to all of the security measures
    we can apply at a platform and infrastructure level, possibly preventing malicious
    commands from entering or leaving the application and identifying and stopping
    harmful traffic. This also includes applying security measures to the database
    system itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，平台级防护指的是我们可以在平台和基础设施层面采取的所有安全措施，可能防止恶意命令进入或离开应用程序，并识别和阻止有害流量。这还包括对数据库系统本身应用安全措施。
- en: Here, we are presenting a view of what can be done to secure an application
    against SQL injection by applying security controls and measures outside of it,
    in this way, granting additional layers of protection. This concept is called
    **defense-in-depth** and is one of the most relevant aspects of information security,
    helping to minimize possible threats against systems and applications alike.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了通过在应用程序外部应用安全控制和措施来保护应用程序免受 SQL 注入攻击的方法，从而提供额外的保护层。这个概念被称为**深度防御**，它是信息安全中最相关的方面之一，帮助最小化系统和应用程序可能面临的威胁。
- en: Application-level firewall logic
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用级防火墙逻辑
- en: The first, and probably most well-known, concept of protection is firewalling.
    A firewall is, generally speaking, an object that decides, usually according to
    some specific rules, whether a data flow—usually network traffic—is allowed to
    pass. In enterprise security, firewalls are usually physical appliances located
    at the boundaries of networks and sub-networks, acting as gatekeepers. These appliances
    are usually hardened computers whose only purpose is to filter traffic that enters
    or exits a network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也是最著名的保护概念是防火墙。一般来说，防火墙是一种根据某些特定规则决定是否允许数据流（通常是网络流量）通过的设备。在企业安全中，防火墙通常是位于网络和子网络边界的物理设备，充当网关。这些设备通常是专门用于过滤进入或离开网络的流量的加固计算机。
- en: While, of course, traditional firewalls can help thwart any type of attack,
    we are more focused on the application-level side of things. Usually, firewalls
    exist independently of the presence of applications within a network, so we consider
    them external entities with respect to our scope. The same logic of firewalls,
    however, has also been applied to application-level concepts, filtering requests
    directed at application components in the same way that a traditional firewall
    would do, discarding whatever, according to a set rules, is deemed harmful to
    the specified application components. Let's see some examples of this concept.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传统的防火墙当然能帮助抵御任何类型的攻击，但我们更关注应用级的防护。通常，防火墙独立于网络中的应用程序存在，因此我们将它们视为相对于我们的范围的外部实体。然而，防火墙的相同逻辑也已应用于应用级概念，通过过滤指向应用组件的请求，方式与传统防火墙类似，丢弃任何根据一套规则被认为对指定应用组件有害的内容。让我们看一些这个概念的例子。
- en: Web application firewalls
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web 应用防火墙
- en: When talking about web application security, not mentioning **Web Application
    Firewalls** (**WAFs**) is almost impossible. A WAF, usually in the form of a software
    solution or built within a specific network appliance, is designed to protect
    web applications from possible attacks against them, including SQL injection attacks.
    The most practical solution is using software-based WAFs. These are usually built
    into a web application or web server and require little configuration effort as
    they do not alter the web infrastructure surrounding the applications. Appliance-based
    WAFs, on the other hand, can be useful in certain scenarios as their activity
    does not take up web server resources, thereby not impacting functionality and
    performance. However, as application developers usually tend not to meddle with
    the surrounding infrastructure, we will mostly refer to software-based WAFs, also
    because of how simply they can be implemented.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Web应用安全，几乎不提**Web应用防火墙**（**WAFs**）几乎是不可能的。WAF通常以软件解决方案或内嵌于特定网络设备中的形式存在，旨在保护Web应用免受各种可能的攻击，包括SQL注入攻击。最实际的解决方案是使用基于软件的WAF。这些WAF通常内建于Web应用或Web服务器中，并且由于不会改变应用周围的Web基础设施，因此几乎不需要配置工作。另一方面，基于设备的WAF在某些情况下也能发挥作用，因为它们的活动不会占用Web服务器的资源，从而不会影响功能和性能。然而，由于应用开发者通常不愿意干预周围的基础设施，因此我们通常会讨论基于软件的WAF，部分原因也是因为它们可以简单地实施。
- en: 'WAFs tend to work by using filters that define what is accepted and what is
    not. These act as the rules of the WAF and they are responsible for accepting
    or rejecting requests. Filters need to be properly configured in order to prevent
    most attacks against your application. There are many ways in which filters can
    be implemented:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: WAF通常通过使用定义允许和拒绝内容的过滤器来工作。这些过滤器作为WAF的规则，负责接受或拒绝请求。过滤器需要正确配置，以防止大多数针对应用的攻击。过滤器的实现方式有很多种：
- en: '**Web server filters**: These are filters that are installed as extra modules
    on a web server and tend to work as an additional component, evaluating requests
    entering the web server. Implementations can vary depending on the web server
    technology. Some examples include **ModSecurity** (available at [https://modsecurity.org/](https://modsecurity.org/)),
    which works for Apache, and **UrlScan** by Microsoft, which is made for IIS web
    servers ([https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference](https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference)).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务器过滤器**：这些过滤器作为额外模块安装在Web服务器上，通常作为额外组件工作，评估进入Web服务器的请求。根据Web服务器技术的不同，实施方式可能有所不同。一些例子包括**ModSecurity**（可在[https://modsecurity.org/](https://modsecurity.org/)找到），它适用于Apache，还有微软的**UrlScan**，它专为IIS
    Web服务器设计（[https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference](https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference)）。'
- en: '**Application filters**: These filters can be implemented as additional modules
    of your application in the same programming language. For application developers,
    this option is often considered as these filters tend to be independent of the
    web server technology and can be included as additional application plugins. A
    notable example by OWASP is OWASP Stinger, which, however, it is not supported
    by OWASP anymore.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用过滤器**：这些过滤器可以作为你应用的额外模块实现，通常使用相同的编程语言。对于应用开发者来说，这个选项通常被认为是可行的，因为这些过滤器通常与Web服务器技术无关，并且可以作为额外的应用插件加入。OWASP的一个显著例子是OWASP
    Stinger，但OWASP已经不再支持它。'
- en: '**Web service filters**: Another useful option is filtering web service messages.
    This can be done in a custom way—for example, by filtering input messages containing
    SQL injection attempts or even output messages containing information disclosures.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务过滤器**：另一个有用的选项是过滤Web服务消息。这可以通过定制方式进行，比如过滤包含SQL注入尝试的输入消息，或者过滤包含信息泄露的输出消息。'
- en: WAFs are a very versatile tool for protecting web applications as they can be
    used in various modes to further improve security.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: WAF是一种非常多功能的工具，可以用在不同的模式下进一步提高安全性。
- en: Application intrusion detection systems
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用入侵检测系统
- en: Aside from regular network-based **Intrusion Detection Systems** (**IDSes**),
    which can be used to identify cyberattacks in general and provide alerting functionalities,
    WAFs can be used as an application-level IDS to apply this concept directly to
    the specific applications it protects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的基于网络的**入侵检测系统**（**IDSes**），这些系统可以用来识别网络攻击并提供警报功能，Web应用防火墙（WAF）可以作为应用层IDS，直接将这一概念应用于它所保护的特定应用程序。
- en: The way this works is to use the WAF in passive mode so that it can inspect
    the application request and send alerts if suspicious requests are found. This
    way, network administrators can be warned if a security incident occurs, thereby
    acting in a timely fashion based on the alert trigger.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理是将WAF置于被动模式，这样它可以检查应用程序请求，并在发现可疑请求时发送警报。通过这种方式，网络管理员可以在安全事件发生时及时收到警告，从而根据警报触发采取行动。
- en: Database firewalls
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库防火墙
- en: The last firewall we will consider is the database firewall. A database firewall
    is basically a proxy server positioned between the application and its database
    that inspects the queries that are sent to it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要考虑的最后一个防火墙是数据库防火墙。数据库防火墙基本上是一个代理服务器，位于应用程序和数据库之间，负责检查发送到数据库的查询。
- en: The application sends the query in the same way as if it were directed directly
    to the database, but the query is sent to the database firewall instead. At this
    point, the database firewall can inspect the query to check whether there is anything
    wrong with it (for example, whether it contains statements that deviate from the
    normal application behavior, tautologies, or any specified illegal characters).
    The proxy might then decide, based on its evaluation rules, whether the query
    can reach the database so that the database does not even receive harmful queries.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序以与直接发送到数据库相同的方式发送查询，但查询会被发送到数据库防火墙。在这一点上，数据库防火墙可以检查查询，查看是否存在任何异常（例如，是否包含偏离正常应用行为的语句、同义反复或任何指定的非法字符）。代理随后可以根据其评估规则决定查询是否可以到达数据库，从而避免数据库接收到有害的查询。
- en: Since a database is usually contacted by an application to execute a specific
    set of functions, as defined by the application requisites, modeling whitelisting
    rules is the best approach, making it possible only for accepted queries to pass
    through the proxy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库通常由应用程序调用以执行由应用程序需求定义的一组特定功能，因此建模白名单规则是最好的方法，只允许被接受的查询通过代理。
- en: Database server security mechanisms
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库服务器安全机制
- en: Now that we have seen how it is possible to secure our application perimeter
    ny blocking malicious input and output data, the only missing element to be secured
    is the database server itself. We can apply some concepts of what we have seen
    so far also to secure the database itself.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到通过阻止恶意输入和输出数据来保护应用程序边界的方法，唯一需要保护的元素就是数据库服务器本身。我们可以将迄今为止所学到的一些概念应用于数据库的安全保护。
- en: Protecting the database data
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护数据库数据
- en: Besides applying the measures we already seen—such as hashing passwords and
    masking sensitive data—the most obvious security step to take in securing the
    database itself is applying cryptography to the stored data. Cryptography ensures
    that if the database is read directly—for example, if the data residing on it
    is copied or dumped in some way—its content remains protected and cannot be read
    by malicious attackers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用我们已经看到的措施——比如哈希密码和屏蔽敏感数据——确保数据库本身安全的最显而易见的步骤就是对存储的数据应用加密。加密确保了如果直接读取数据库（例如，如果数据库中的数据以某种方式被复制或转储），其内容仍然受到保护，无法被恶意攻击者读取。
- en: Cryptography by itself does not offer 100% certainty that the data can never
    be read by unauthorized individuals or organizations, but it does guarantee that
    breaking this protection requires a sufficiently long time and a lot of computational
    power, thereby rendering these attacks impractical or almost impossible.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 加密本身无法提供100%确定性，确保数据永远不会被未授权的个人或组织读取，但它保证了要破解这种保护需要足够长的时间和大量的计算能力，从而使得这些攻击变得不切实际或几乎不可能。
- en: Cryptographic algorithms always evolve over time, and they can be rendered obsolete
    whenever a major technological breakthrough takes place and more computational
    power is available to individuals and organizations. This has been the case for
    older cryptographical standards, such as the **Data Encryption Standard** (**DES**),
    which has been used for a long time. However, as common use computers have increasingly
    become more powerful, its cryptography was deemed no longer secure. Other, more
    reliable standards, such as 3DES—a triple iteration of the DES algorithm—are now
    considered insecure for the same reason. While a few years ago, they provided
    enough security, some actors might possess enough computational power to break
    them, thus being able to access protected information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法随着时间的推移不断发展，并且每当发生重大技术突破并且个人和组织拥有更多计算能力时，它们可能会变得过时。这种情况在较旧的加密标准中已经出现过，比如**数据加密标准**（**DES**），这种标准已使用多年。然而，随着普通计算机性能的不断提升，其加密方式被认为不再安全。其他更可靠的标准，如3DES（DES算法的三重迭代），现在也由于相同的原因被认为不安全。虽然几年前它们提供了足够的安全性，但一些攻击者可能拥有足够的计算能力来破解它们，从而能够访问受保护的信息。
- en: The de facto standard for modern cryptography is now the **Advanced Encryption
    Standard** (**AES**)—specifically, AES-256 with a 256-bit key, which provides
    a high guarantee of security. It works as a symmetrical cryptography algorithm
    as the same secret key is used for both the encrypting and decrypting of data.
    As long as the key remains secret, encrypted information will stay protected.
    To put this security feature in perspective, breaking a 256-bit key by brute-forcing,
    trying all the possible combinations, can require up to 2 to the power of 256
    attempts (the resulting number is a 78-digit number). Even if a single attempt
    took a nanosecond (one billionth of a second), the seconds needed to try all the
    possible combinations exceeds any 68-digit number. If a program was used to break
    the encryption, it would run for far longer than the estimated life of the sun,
    which is estimated to be 5 billion years.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现代加密学的事实标准如今是**高级加密标准**（**AES**）——特别是使用256位密钥的AES-256，它提供了很高的安全保证。它作为对称加密算法工作，因为加密和解密数据都使用相同的密钥。只要密钥保持秘密，所加密的信息将继续受到保护。为了让这个安全特性更有感知，破解256位密钥的暴力破解方法，需要尝试所有可能的组合，可能需要高达2的256次方次的尝试（结果是一个78位数字）。即使每次尝试只需要一纳秒（十亿分之一秒），破解所有可能的组合所需的时间也超过任何68位数的秒数。如果使用程序来破解加密，它运行的时间将远远超过太阳的预期寿命，而太阳的预期寿命大约是50亿年。
- en: The only challenge to securing data through cryptography is keeping the encryption
    key secret. This is far from simple; if the key is stored on the database server
    as it is, it could be read by attackers. One of the most feasible solutions is
    storing the key in a safe way in a different location—for example, on a secure
    location in the application server. In order to use it, an attacker would need
    to compromise both the application server and the database server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加密技术保护数据的唯一挑战在于保持加密密钥的秘密性。这远非易事；如果密钥直接存储在数据库服务器上，它可能会被攻击者读取。一个可行的解决方案是将密钥安全地存储在不同的位置——例如，存储在应用服务器的安全位置。为了使用密钥，攻击者需要同时攻破应用服务器和数据库服务器。
- en: Encrypting data on a database with the appropriate mechanisms should provide
    enough security in case raw data gets exfiltrated or the actual device on which
    the data is stored is outright stolen, preserving the confidentiality of the information.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的机制对数据库中的数据进行加密，应当能够在原始数据被外泄或存储数据的实际设备被盗时，提供足够的安全性，从而保护信息的机密性。
- en: Protecting the database server
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护数据库服务器
- en: 'After acting on the stored data, let''s now see how a database server can be
    protected. A database server is, first and foremost, a system within a network.
    As such, it might be inherently vulnerable to cyberattacks. There are a lot of
    ways to prevent or minimize the effects of malicious actions, of which we will
    look at some examples:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在对存储的数据进行操作之后，接下来我们来看看如何保护数据库服务器。数据库服务器首先是网络中的一个系统，因此它可能天生就容易受到网络攻击。有许多方法可以防止或最小化恶意行为的影响，以下是一些示例：
- en: '**Patching**: The database server is a server in your infrastructure. As such,
    you need to be sure that it has the least number of vulnerabilities so that attackers
    have the fewest possible amount of ways to compromise it. A fundamental security
    principle is ensuring that software running on the database server is always up
    to date and has the most recent security updates installed.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修补**：数据库服务器是你基础设施中的一部分。因此，你需要确保它的漏洞最少，以便攻击者能够通过最少的方式对其进行破坏。一个基本的安全原则是确保运行在数据库服务器上的软件始终保持最新，并安装了最新的安全更新。'
- en: Most updates are released to provide remediation to vulnerabilities, some of
    which present critical risks to the server and the surrounding infrastructure.
    It's of the utmost importance to have security updates installed on not only the
    database system but also the operating system and all the software installed.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数更新的发布是为了修复漏洞，其中一些漏洞对服务器及其周围基础设施构成严重风险。因此，安装安全更新至关重要，不仅要安装在数据库系统上，还要安装在操作系统和所有已安装的软件上。
- en: Vulnerabilities could, in fact, be exploited one after the other, and the presence
    of more vulnerabilities increases the risk of a system being compromised. Patching
    can be enforced not only manually but also through automatic patching agents,
    which are widely used in various enterprise networks.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 漏洞实际上可能会被一个接一个地利用，更多的漏洞意味着系统被攻破的风险增加。修补不仅可以手动执行，还可以通过自动修补代理来强制执行，这些代理在各种企业网络中被广泛使用。
- en: '**Enforcing the least privilege principle**: We already talked about the least
    privilege principle when dealing with stored procedures. This time, we need to
    address it more broadly. On an operating system, programs can be run at various
    levels, from a low-privileged to an administrator level.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行最小权限原则**：我们在处理存储过程时已经讨论过最小权限原则。这一次，我们需要更广泛地讨论它。在操作系统上，程序可以在不同级别运行，从低权限到管理员级别不等。'
- en: One way to improve security is by ensuring that database programs are run at
    a low privilege level in terms of reading, writing, and executing. Applying the
    least privilege principle ensures that, if the database is compromised, the actions
    resulting from this compromise are mitigated in their impact—an attacker has lower
    chances of causing damage to the system itself and possibly has a limited chance
    for lateral movement (which means attacking other systems in the network).
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提高安全性的一种方法是确保数据库程序在低权限级别下运行，包括读取、写入和执行权限。应用最小权限原则可以确保，即使数据库被攻破，由此导致的行动其影响也会被减轻——攻击者对系统本身造成损害的机会较小，并且可能仅能进行有限的横向移动（即攻击网络中的其他系统）。
- en: '**Enforcing authentication and monitoring controls**: Finally, another way
    to prevent attackers from causing damage is by improving the security controls
    relating to authentication and monitoring. This includes ensuring that passwords
    are not weak by enforcing a strong password policy, disabling default accounts
    (which are often targeted by attackers as they already know their username and
    only need to guess the password), and enabling logging so that possible authentication
    attempts are tracked, as well as actions on the server itself.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行身份验证和监控控制**：最后，防止攻击者造成损害的另一种方法是通过改善与身份验证和监控相关的安全控制。这包括确保密码不弱，通过实施强密码策略、禁用默认帐户（默认帐户通常是攻击者的目标，因为他们已经知道用户名，只需要猜测密码）以及启用日志记录，以便跟踪可能的身份验证尝试和服务器本身的操作。'
- en: This concludes our overview of the more practical measures that can be taken
    against SQL injection in terms of platform-level defenses. Besides these, it's
    worth noting some more general principles to be taken into account when securing
    applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分总结了在平台级防御中可以采取的更实际的措施来防范SQL注入。除了这些，值得注意的是在保护应用程序时需要考虑的一些更一般的原则。
- en: Other security measures
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他安全措施
- en: In addition to what we have seen so far, the infrastructure and platform-level
    defense can also include some other general principles that, if followed, can
    further improve the overall security of your environment. Generally speaking,
    applying all the measures we've seen so far would definitely put your application
    and systems at quite a satisfying security level, but for the sake of completeness,
    we will now list some other possible tweaks that can provide additional protection
    against SQL injection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们到目前为止所看到的，基础设施和平台级的防御还可以包括一些其他通用原则，如果遵循这些原则，可以进一步提高你的环境的整体安全性。一般来说，应用我们到目前为止所看到的所有措施肯定能使你的应用程序和系统达到一个相当令人满意的安全水平，但为了完整性，我们现在将列出一些可能的调整措施，提供额外的
    SQL 注入防护。
- en: Reducing information disclosure
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 降低信息泄露
- en: 'When performing offensive actions against an application or a system, a malicious
    agent will always try everything in their power to obtain as much information
    as possible about your environment so that they can attempt various attacks depending
    on the information they obtain. Limiting the information that they can access
    can effectively reduce their attack potential, thereby minimizing the risk that
    your application will be compromised. Here, we will present some areas in which
    reducing leaked information can prove useful and might effectively limit attackers''
    potential:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在对应用程序或系统进行攻击时，恶意代理总是会尽其所能尽可能多地获取关于你环境的信息，以便根据获得的信息尝试各种攻击。限制他们可以访问的信息可以有效减少他们的攻击潜力，从而最大限度地降低你的应用程序被入侵的风险。在这里，我们将介绍一些减少泄露信息可能有用的领域，并有效限制攻击者潜力的方式：
- en: '**Not showing error messages**: When we dealt with offensive SQL injection
    techniques, we tried to rely as much as possible on error messages. Default SQL
    error messages can leak information regarding versioning and query syntax, and
    can also give other clues to attackers for trying other attacks. Showing error
    messages can give an attacker more hints than you would probably wish for, so
    avoiding the display of error messages is a good idea.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不显示错误信息**：当我们处理攻击性 SQL 注入技术时，我们尽可能依赖错误信息。默认的 SQL 错误信息可能泄露关于版本和查询语法的信息，还可能为攻击者提供其他线索，尝试其他攻击。显示错误信息可能会给攻击者更多线索，比你可能希望的要多，因此避免显示错误信息是一个好主意。'
- en: Sometimes, it is a wise choice not to show that an error has occurred at all,
    avoiding possible blind SQL injection attempts. You could either not show any
    errors at all in your application, or else provide a general, customized HTTP
    error page (for example, an HTTP 500 error page). This, of course, can make things
    more difficult for debugging purposes, but if the application is in a production
    environment, this should not be an issue.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，完全不显示错误发生的情况是一个明智的选择，可以避免可能的盲目 SQL 注入攻击。你可以选择在应用程序中根本不显示任何错误，或者提供一个通用的自定义
    HTTP 错误页面（例如，HTTP 500 错误页面）。当然，这会使调试变得更加困难，但如果应用程序处于生产环境中，这应该不是问题。
- en: '**Prevent Google (and other search engine) hacking**: Google hacking techniques
    are a way to return specific information from websites by inserting specific operators
    within the search string of Google. Inserting certain keywords could allow attackers
    to obtain relevant information about your application by accessing specific web
    pages containing a specific keyword. This can be prevented by editing a file in
    the root directory of your website, which instructs search engines not to crawl
    your website so that inner pages cannot be accessed by them. This file is called
    **robots.txt**, and its content to prevent this behavior looks as follows:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止 Google（以及其他搜索引擎）黑客攻击**：Google 黑客技术是一种通过在 Google 搜索字符串中插入特定操作符来返回网站特定信息的方法。插入某些关键词可能使攻击者通过访问包含特定关键词的网页，获取与你的应用程序相关的信息。可以通过编辑你网站根目录中的一个文件来防止这种情况，指示搜索引擎不要抓取你的网站，从而避免内页被它们访问。这个文件叫做
    **robots.txt**，其内容如下所示，以防止这种行为：'
- en: 'User-agent: *'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '用户代理: *'
- en: 'Disallow: /'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '禁止: /'
- en: This means that web crawlers are not allowed to index your website, thereby
    preventing specific web searches from displaying content that could be used against
    you, which could provide useful information to attackers.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着不允许网络爬虫索引你的网站，从而防止通过特定的网页搜索显示可能被攻击者利用的内容，这些内容可能为攻击者提供有用的信息。
- en: Reducing the quantity of information that an application shows, limiting it
    to what is only strictly necessary, greatly improves security as it discourages
    potential attackers from trying to compromise your application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 限制应用程序展示的信息量，仅限于严格必要的内容，能极大提升安全性，因为它能有效打击潜在攻击者尝试破坏应用程序的行为。
- en: Secure server deployment
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全的服务器部署
- en: Another critical step for security is server deployment, which needs to be made
    in the least risky approach possible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键的安全步骤是服务器部署，部署时需要采取尽可能低风险的方法。
- en: In general, it's best to keep your application infrastructure elements separated.
    This includes the application/web server and the database server. If they are
    deployed on the same machine, by compromising one, an attacker could easily obtain
    access to the other one. This could, in addition, defeat the point of measures
    such as cryptography as an attacker would have access to the database and the
    stored encryption key at the same time. In general, splitting your architecture
    into more components helps preserve security by reducing the impact caused by
    possible malicious actions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好将应用程序基础设施元素分开。这包括应用程序/ Web 服务器和数据库服务器。如果它们部署在同一台机器上，攻击者通过攻破其中一方，可能轻易地获得对另一方的访问权限。此外，这可能会削弱诸如加密等措施的作用，因为攻击者将同时访问数据库和存储的加密密钥。一般来说，将架构拆分成更多组件有助于通过减少可能恶意行为造成的影响来保持安全性。
- en: Deployments should also take place while guaranteeing that the machine's configuration
    is made secure by removing settings that are typical of the testing and debugging
    stages of development. For example, some exposed services used for debugging and
    remote access can provide attack points that attackers could use to compromise
    your systems and application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 部署时还应确保机器配置已被安全设置，移除开发阶段调试和测试时的典型配置。例如，一些用于调试和远程访问的开放服务可能为攻击者提供攻击点，攻击者可以利用这些点破坏您的系统和应用程序。
- en: Network access control
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络访问控制
- en: Finally, another security measure that is used in conjunction with separate
    machines for each server is applying **Network Access Control** (**NAC**). NAC
    involves only allowing selected hosts to connect to specific servers and services.
    In a setting in which we have deployed a web server and database server separately,
    for example, we would want the database server to only accept connections coming
    from that web server. Otherwise, an attacker who has gained access to the network
    could interact with the database server directly, bypassing most of the security
    measures we put in place at the application level.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与为每个服务器使用单独机器配合的另一项安全措施是应用**网络访问控制**（**NAC**）。NAC包括仅允许特定主机连接到特定服务器和服务。例如，在我们将
    Web 服务器和数据库服务器分开部署的环境中，我们希望数据库服务器只接受来自 Web 服务器的连接。否则，攻击者如果成功入侵网络，可能直接与数据库服务器进行交互，从而绕过我们在应用程序层面所设置的大部分安全措施。
- en: This can be achieved, for example, by allowing a connection from hosts that
    have a specific certificate installed or through the use of firewalls, only allowing
    connections from specific hosts. Routers could also be instructed to enforce this
    principle by implementing access control lists that provide a set of hosts from
    which to accept connections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过例如仅允许具有特定证书的主机连接，或者通过使用防火墙，仅允许来自特定主机的连接来实现。路由器也可以通过实施访问控制列表来强制执行这一原则，提供一组允许接受连接的主机。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That was quite a lot of information. When dealing with defense mechanisms, there
    are a lot of factors to consider, and the more defense mechanisms you apply to
    your context, the less chance an attacker has to cause damage to your environment.
    For this reason, using all of the security measures we described in this chapter—or
    almost all, depending on the context and the applicability of these controls—is
    very important for security.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息确实不少。应对防御机制时，需要考虑许多因素，且应用于环境中的防御机制越多，攻击者造成损害的机会就越小。因此，使用本章中描述的所有安全措施——或者根据具体情况和这些控制的适用性，几乎所有的安全措施——对安全至关重要。
- en: This chapter first covered the general aspects of countermeasures against SQL
    injection—specifically, dealing with user input and controlling data flows. Then,
    we analyzed specific defenses for dealing with application coding, general patterns
    to follow in application development, and securing the infrastructure surrounding
    the application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了防止SQL注入的对策的基本方面——特别是如何处理用户输入和控制数据流。然后，我们分析了处理应用程序编码的具体防御措施，应用开发中的一般模式，以及保护应用程序周围基础设施的方式。
- en: As for code-level defenses, we saw how to validate input, using both blacklisting
    and whitelisting, to only accept safe input. Then, we applied sanitizing measures,
    both for query statement construction—using parameterized queries—and character
    encoding and escaping, to avoid harmful characters that could enable SQL injection.
    Secure coding practices were also examined, showing some rationales for building
    code that is secure against SQL injection and, collaterally, other attacks in
    general.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 至于代码级防御，我们看到如何验证输入，使用黑名单和白名单方法，只接受安全输入。接着，我们应用了清理措施，不仅在构建查询语句时使用参数化查询，还利用字符编码和转义来避免可能导致SQL注入的有害字符。同时，我们也审视了安全编码实践，展示了构建防止SQL注入攻击的安全代码的理由，并且间接提高了应对其他攻击的能力。
- en: Platform-level defenses can fall outside the strict scope of application security
    and involve more general security principles. We saw how firewall logic can be
    applied to application components through WAFs and database firewalls. We then
    analyzed ways to secure the database itself, which is one of the most important
    parts of database-reliant application architecture, both considering the data
    and the database server. Finally, other general security measures were discussed
    in order to improve the overall security of your application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级防御可能超出了应用安全的严格范围，涉及更多的安全原则。我们看到如何通过WAF和数据库防火墙将防火墙逻辑应用于应用组件。然后，我们分析了如何保护数据库本身，这是依赖数据库的应用架构中最重要的部分之一，既要考虑数据，也要考虑数据库服务器。最后，我们讨论了其他一般的安全措施，以提高应用程序的整体安全性。
- en: While all of these measures help against SQL injection, you will have realized
    that the focus tends to be directed more toward security in general. The next
    chapter will put all you have learned in perspective, giving you a way to critically
    examine all that you have learned. Consider it as looking back after a long journey,
    putting you in the position to think about all that you have seen and experienced.
    Hopefully, you will have become more educated not only about SQL injection but
    also about security in general. Maybe (just maybe) this will also spark an interest
    in cybersecurity in a broader sense!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些措施都有助于防止SQL注入，但你会意识到，重点通常更多地集中在一般安全性上。下一章将帮助你从更全面的视角审视你所学的内容，让你能够批判性地回顾所学的知识。可以把它当作一段长时间旅程后的回顾，让你有机会思考你所见所闻的所有内容。希望你不仅对SQL注入有更深的了解，也对一般安全性有了更广泛的认识。也许（仅仅也许）这还会激发你对更广泛的网络安全的兴趣！
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How should user input be treated when designing an application?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计应用程序时，应该如何处理用户输入？
- en: What does input validation mean? Describe two approaches for validation.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入验证是什么意思？请描述两种验证方法。
- en: What is a parameterized query?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是参数化查询？
- en: Why is character encoding and escaping useful against SQL injection?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么字符编码和转义对防止SQL注入有用？
- en: What does a WAF do?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WAF的作用是什么？
- en: Is it safe to store an encryption key in the same place where the encrypted
    data is stored?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加密密钥存储在与加密数据相同的位置安全吗？
