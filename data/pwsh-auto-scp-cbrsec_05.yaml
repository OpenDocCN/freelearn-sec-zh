- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: PowerShell Is Powerful – System and API Access
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 强大——系统和 API 访问
- en: Just when you thought PowerShell was already a mighty tool, get ready to be
    surprised by its ability to delve deep into the system. In this chapter, we’ll
    explore accessing the system and API by using PowerShell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以为 PowerShell 已经是一个强大的工具时，准备好惊讶于它深入系统的能力。在本章中，我们将探索如何使用 PowerShell 访问系统和 API。
- en: We’ll start by looking into the Windows Registry and how you can leverage PowerShell
    to easily access its keys and values. We’ll then move on to .NET Framework and
    the Windows API, and you’ll learn how to execute C# code directly from PowerShell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Windows 注册表开始，了解如何利用 PowerShell 轻松访问其键和值。接着，我们将深入 .NET 框架和 Windows API，你将学习如何直接从
    PowerShell 执行 C# 代码。
- en: Next, we’ll explore **Windows Management Instrumentation** (**WMI**), which
    can be used to access and manage a wide range of system resources, including hardware,
    software, network components, and other objects, through a standard interface.
    PowerShell makes it easy to interact with WMI and automate tasks and manipulate
    data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索 **Windows 管理工具** (**WMI**)，它可以用来通过标准接口访问和管理各种系统资源，包括硬件、软件、网络组件以及其他对象。PowerShell
    使得与 WMI 交互、自动化任务和操作数据变得简单。
- en: In this chapter, you will also learn how it is possible to run PowerShell commands
    without executing **powershell.exe**. You’ll learn how to run PowerShell code
    directly from within other applications or even in memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你还将学习如何在不执行 **powershell.exe** 的情况下运行 PowerShell 命令。你将学习如何直接在其他应用程序中，甚至在内存中运行
    PowerShell 代码。
- en: 'You’ll learn how to identify potential threats and secure your environment
    against these types of attacks. So, get ready to discover just how powerful PowerShell
    can be when it comes to system and API access. Let’s dive in! We will cover the
    following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何识别潜在威胁并保护你的环境免受这些类型的攻击。所以，准备好发现 PowerShell 在系统和 API 访问方面的强大功能吧。让我们开始吧！本章将涵盖以下内容：
- en: Getting familiar with the Windows Registry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 Windows 注册表
- en: Basics of the Windows API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows API 基础知识
- en: Exploring .NET Framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 .NET 框架
- en: Understanding the **Component Object Model** (**COM**) and COM hijacking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 **组件对象模型** (**COM**) 和 COM 劫持
- en: The **Common Information** **Model** (**CIM**)/WMI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用信息模型** (**CIM**)/WMI'
- en: Running PowerShell without **powershell.exe**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需 **powershell.exe** 运行 PowerShell
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To make the most out of this chapter, ensure that you have the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章的内容，请确保你具备以下条件：
- en: PowerShell 7.3 and above
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 7.3 及以上版本
- en: Installed Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Visual Studio Code
- en: Installed Visual Studio for your C# code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Visual Studio 用于 C# 代码编写
- en: C, C++, or C# knowledge and/or the ability to read C code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C、C++ 或 C# 知识和/或阅读 C 代码的能力
- en: Knowledge of how to use compilers, especially C/C++/C#
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用编译器的知识，特别是 C/C++/C#
- en: Visual Basic knowledge and/or the ability to read Visual Basic code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Basic 知识和/或阅读 Visual Basic 代码的能力
- en: Access to Microsoft Excel, or another tool from the Office suite that allows
    running macros
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Microsoft Excel 或 Office 套件中的其他工具，以运行宏
- en: Access to the GitHub repository for **Chapter05:**  [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 GitHub 仓库以获取 **第05章：** [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05)
- en: Getting familiar with the Windows Registry
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Windows 注册表
- en: The Windows Registry was introduced with **Windows 3.1**. Although back then,
    it primarily stored information for the COM-based components, it was developed
    over the years. Nowadays, it serves as the hierarchical database as we all know
    it – storing low-level configuration settings for the Windows operating system,
    as well as for applications running on it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 注册表在 **Windows 3.1** 中引入。尽管当时它主要存储 COM 基于组件的信息，但它随着时间的推移得到了发展。如今，它作为我们熟知的层次化数据库——存储
    Windows 操作系统的低级配置设置以及在其上运行的应用程序的配置。
- en: Although you can access the registry using multiple ways, we will concentrate
    in this section on how to access and operate the registry using PowerShell.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过多种方式访问注册表，但本节将重点介绍如何使用 PowerShell 访问和操作注册表。
- en: 'The Windows Registry of modern systems usually consists of five root keys.
    Each of them has their own purpose and contains different settings:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统的 Windows 注册表通常由五个根键组成。每个根键都有各自的目的，并包含不同的设置：
- en: '**HKEY_CLASSES_ROOT** (**HKCR**): Hives underneath this root key contain information
    about COM class registration information and file associations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_CLASSES_ROOT** (**HKCR**): 此根键下的分支包含有关 COM 类注册信息和文件关联的信息。'
- en: '**HKEY_CURRENT_USER** (**HKCU**): Contains settings that are specific to the
    user that is currently logged on. Technically, this root key is just a symbolic
    link that leads to **HKU\<CurrentUserSid>\**.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_CURRENT_USER** (**HKCU**): 包含特定于当前登录用户的设置。从技术上讲，此根键只是一个符号链接，指向 **HKU\<CurrentUserSid>\**。'
- en: '**HKEY_LOCAL_MACHINE** (**HKLM**): Settings that are specific to the local
    computer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_LOCAL_MACHINE** (**HKLM**): 特定于本地计算机的设置。'
- en: '**HKEY_USERS** (**HKU**): Subkeys for each user profile actively loaded on
    the machine (like **HKEY_CURRENT_USER**, but not exclusively limited to the currently
    logged-on user).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_USERS** (**HKU**): 每个活动加载在机器上的用户配置文件的子键（类似于 **HKEY_CURRENT_USER**，但不仅限于当前登录用户）。'
- en: '**HKEY_CURRENT_CONFIG** (**HKCC**): Hives under this root key don’t store any
    information themselves, but rather act as a pointer to registry keys that keep
    information about the current hardware profile.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_CURRENT_CONFIG** (**HKCC**): 此根键下的分支本身不存储任何信息，而是作为指向保留有关当前硬件配置文件信息的注册表键的指针。'
- en: PowerShell treats the registry like a virtual drive; you can access and modify
    it using the same commands as you would while navigating and editing files and
    folders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 将注册表视为虚拟驱动器；您可以使用与导航和编辑文件和文件夹相同的命令访问和修改它。
- en: Working with the registry
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注册表
- en: 'Using the **Get-PSDrive** cmdlet, you can get all drives of the current session.
    If you inspect the output a little bit further, you’ll see that not only system
    drives are listed here. The **HKCU** and **HKLM** registry root keys can also
    be found here as well:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Get-PSDrive** cmdlet，您可以获取当前会话的所有驱动器。如果进一步检查输出，您会看到不仅列出了系统驱动器。**HKCU**
    和 **HKLM** 注册表根键也可以在此处找到：
- en: '![Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive](image/B16679_05_001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 使用 Get-PSDrive 查找 HKCU 和 HKLM 注册表根键](image/B16679_05_001.jpg)'
- en: Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用 Get-PSDrive 查找 HKCU 和 HKLM 注册表根键
- en: And since PSDrives such as **HKCU** and **HKLM** are treated like regular file
    drives, it is not surprising that you can navigate through them using **Set-Location**
    (or the equivalent alias, **cd**), as well as **Get-ChildItem** (or the alias,
    **ls**) to list the contents of a folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像 **HKCU** 和 **HKLM** 这样的 PSDrive 被视为常规文件驱动器，因此您可以使用 **Set-Location**（或等效的别名
    **cd**）以及 **Get-ChildItem**（或别名 **ls**）来浏览它们以列出文件夹的内容，这并不奇怪。
- en: 'In the following example, I query the current Windows PowerShell version from
    the registry:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我从注册表中查询当前的 Windows PowerShell 版本：
- en: '![Figure 5.2 – Navigating through the registry](image/B16679_05_002.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 浏览注册表](image/B16679_05_002.jpg)'
- en: Figure 5.2 – Navigating through the registry
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 浏览注册表
- en: In the preceding screenshot, you can see all the sub-registry keys (**Name**),
    and also all the registry entries (also called **Property** in this context) that
    belong to each registry key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到所有子注册表键（名称），以及属于每个注册表键的所有注册表条目（在此上下文中也称为 **Property**）。
- en: 'It is also possible to browse other locations of the registry than only the
    listed drives by using **Registry::** followed by the root key you want to query.
    In the following screenshot, I use **Foreach-Object** to show the key names of
    all sub-registry keys:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 **Registry::** 后跟要查询的根键，还可以浏览注册表的其他位置，而不仅限于列出的驱动器。在下面的屏幕截图中，我使用 **Foreach-Object**
    显示所有子注册表键的键名：
- en: '![Figure 5.3 – Browsing the registry using the Registry:: prefix](image/B16679_05_003.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 使用 Registry:: 前缀浏览注册表](image/B16679_05_003.jpg)'
- en: 'Figure 5.3 – Browsing the registry using the Registry:: prefix'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5.3 – 使用 Registry:: 前缀浏览注册表'
- en: 'Working with registry keys is quite similar to working with files and folders,
    but nevertheless, there’s a difference when it comes to registry entries. They
    not only consist of keys but also of properties and values, as you can see in
    the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注册表键类似于处理文件和文件夹，但在处理注册表条目时仍然存在差异。它们不仅由键组成，还包括属性和值，正如您可以在下面的屏幕截图中看到的：
- en: '![Figure 5.4 – Displaying properties and values of a registry key by using
    Get-Item](image/B16679_05_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 使用 Get-Item 显示注册表键的属性和值](image/B16679_05_004.jpg)'
- en: Figure 5.4 – Displaying properties and values of a registry key by using Get-Item
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 使用 Get-Item 显示注册表键的属性和值
- en: 'When working with registry keys that have numerous subkeys and properties,
    you may want to obtain a list of all subkeys quickly. You can achieve this by
    using **ForEach-Object Name**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理具有大量子键和属性的注册表键时，你可能希望快速获取所有子键的列表。你可以通过使用 **ForEach-Object Name** 来实现：
- en: '![Figure 5.5 – Displaying all sub-registry keys](image/B16679_05_005.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 显示所有子注册表键](image/B16679_05_005.jpg)'
- en: Figure 5.5 – Displaying all sub-registry keys
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 显示所有子注册表键
- en: In this screenshot, we first changed the working directory to **HKLM:\SOFTWARE\Microsoft\Windows\**
    using the **Set-Location** cmdlet before querying the registry using **Get-ChildItem**.
    This way, you won’t need to type the entire path over and over again if you want
    to perform execute further commands in this location.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张截图中，我们首先使用 **Set-Location** cmdlet 将工作目录更改为 **HKLM:\SOFTWARE\Microsoft\Windows\**，然后使用
    **Get-ChildItem** 查询注册表。这样，如果你想在该位置执行进一步的命令，就不需要一遍又一遍地输入完整路径了。
- en: 'If you are not certain where a specific registry key is located, query the
    registry recursive as you would *search* for a specific file on a drive using
    the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定某个特定的注册表键的位置，可以像使用以下命令*搜索*驱动器上的特定文件一样，递归查询注册表：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the **New-Item** cmdlet, you can create a new registry key, and using
    **Remove-Item**, you can delete one or more registry keys, as shown in the following
    screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **New-Item** cmdlet，你可以创建一个新的注册表键，而使用 **Remove-Item**，你可以删除一个或多个注册表键，如下图所示：
- en: '![Figure 5.6 – Creating and deleting a registry key](image/B16679_05_006.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 创建和删除注册表键](image/B16679_05_006.jpg)'
- en: Figure 5.6 – Creating and deleting a registry key
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 创建和删除注册表键
- en: Using **Remove-Item** with the **-Recurse** parameter lets you delete a registry
    key as well as subkeys recursively without being prompted for confirmation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Remove-Item** 和 **-Recurse** 参数，可以递归删除注册表键及其子键，而无需确认提示。
- en: Registry entry properties
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册表条目属性
- en: You now know how to operate registry keys and how to display their properties,
    but when it comes to the registry, you want to understand how to work with the
    properties as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道如何操作注册表键和如何显示它们的属性，但当涉及到注册表时，你还需要了解如何操作属性。
- en: 'As mentioned earlier, although operating the registry is similar to working
    with files and folders, there are some differences when it comes to the properties
    of registry entries: while files have properties such as **LastWriteTime**, registry
    entries have their own set of properties.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，虽然操作注册表类似于处理文件和文件夹，但在注册表条目的属性方面存在一些差异：文件有 **LastWriteTime** 等属性，而注册表条目则有其独特的属性集。
- en: 'One way to get a quick overview of the properties might be **Get-Item**, but
    there’s another cmdlet that helps you to get more details – **Get-ItemProperty**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 获取属性的快捷方法之一是使用 **Get-Item**，但还有另一个 cmdlet 可以帮助你获取更多细节 —— **Get-ItemProperty**：
- en: '![Figure 5.7 – Using Get-ItemProperty to display registry entries](image/B16679_05_007.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 使用 Get-ItemProperty 显示注册表条目](image/B16679_05_007.jpg)'
- en: Figure 5.7 – Using Get-ItemProperty to display registry entries
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 使用 Get-ItemProperty 显示注册表条目
- en: 'By using the ***-ItemProperty** cmdlets, you can also manage registry entries.
    For example, to create a new registry entry, the **New-ItemProperty** cmdlet can
    help you. In the following screenshot, I have created a new entry in the startup
    folder for all users and deleted it using **Remove-ItemProperty**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 ***-ItemProperty** cmdlets，你还可以管理注册表条目。例如，要创建一个新的注册表条目，**New-ItemProperty**
    cmdlet 可以帮助你。以下截图中，我为所有用户创建了一个新的启动文件夹条目，并使用 **Remove-ItemProperty** 删除了它：
- en: '![Figure 5.8 – Creating and deleting a new registry entry](image/B16679_05_008.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 创建和删除新的注册表条目](image/B16679_05_008.jpg)'
- en: Figure 5.8 – Creating and deleting a new registry entry
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 创建和删除新的注册表条目
- en: 'It is also possible to change a registry entry by using the **Set-ItemProperty**
    cmdlet. The following example demonstrates how to use **Set-ItemProperty** to
    alter an existing startup entry to change the path of a script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过使用 **Set-ItemProperty** cmdlet 更改注册表条目。以下示例演示了如何使用 **Set-ItemProperty**
    修改现有的启动项条目以更改脚本的路径：
- en: '![Figure 5.9 – Altering a registry entry](image/B16679_05_009.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 修改注册表条目](image/B16679_05_009.jpg)'
- en: Figure 5.9 – Altering a registry entry
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 修改注册表项
- en: By the way, attackers like to create startup entries, too! This is, for example,
    one of many ways to establish persistence. So if you come across code similar
    to the preceding code in PowerShell logs and you did not create it yourself, it
    could be a sign of an attacker attempting to modify a startup entry to run their
    malware instead of its original intended purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，攻击者也喜欢创建启动项！例如，这是建立持久性的一种方式。所以，如果你在PowerShell日志中遇到类似于前面代码的内容，而你自己并未创建它，那可能是攻击者试图修改启动项以运行他们的恶意软件，而不是其原本预定的目的。
- en: 'You can get more information on how to operate the registry using PowerShell
    via the following help system commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下帮助系统命令获得更多关于如何使用PowerShell操作注册表的信息：
- en: '**Get-Help Registry**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-Help Registry**'
- en: '**Get-Help about_Providers**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-Help about_Providers**'
- en: Additionally, understanding the security use cases for working with the registry
    is essential for defenders. Let’s explore some of the most common ones next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解如何使用注册表进行安全性相关操作对防守者至关重要。接下来让我们探讨一些最常见的使用场景。
- en: Security use cases
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性使用场景
- en: There are multiple use cases for attackers where they query or attempt to modify
    the registry – use cases that defenders should also be familiar with. Let’s start
    exploring some of the most common ones.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者查询或尝试修改注册表的使用场景有很多种——防守者也应该熟悉这些场景。让我们先来探索一些最常见的场景。
- en: Reconnaissance
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 侦察
- en: 'Often, attackers access the registry to find out more about the current target
    system: is an antimalware solution in use, and does the attacker''s code need
    additional steps to avoid being detected? Is there a backup solution that would
    prevent a successful ransomware attack?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者经常访问注册表以了解更多关于当前目标系统的信息：是否在使用反恶意软件解决方案，攻击者的代码是否需要额外的步骤来避免被检测到？是否有备份解决方案可以防止勒索软件攻击成功？
- en: The registry is also often queried to find out more about the system and configured
    (security) options. And some adversaries also try to find out whether the system
    that is currently executing the code is a **virtual machine** (**VM**) or a **sandbox**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表也常常被查询，以了解更多关于系统和配置的（安全）选项。有些对手还会尝试找出当前执行代码的系统是否是**虚拟机**（**VM**）或**沙箱**。
- en: A VM is an emulated computer, which is hosted on another computer, the hypervisor.
    It does not require its own hardware, as it shares the hardware of the hypervisor
    with many other VMs. A sandbox is a system that is often used by security researchers
    or even antimalware solutions to detonate a potential malware and test how it
    behaves and whether it’s truly malicious. Attackers usually want to avoid their
    software being run on a VM or a sandbox as this could imply that someone is analyzing
    their malware to build protections against it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机（VM）是一个模拟计算机，它托管在另一个计算机上，即虚拟机监控程序（hypervisor）。它不需要自己的硬件，因为它与许多其他虚拟机共享虚拟机监控程序的硬件。沙箱是一个系统，通常由安全研究人员甚至反恶意软件解决方案使用，用来引爆潜在的恶意软件并测试它的行为以及是否真的是恶意的。攻击者通常希望避免其软件在虚拟机或沙箱中运行，因为这可能意味着有人正在分析他们的恶意软件，并建立防护措施来应对它。
- en: If that is the case, and if the malware is executed in a VM or in a sandbox,
    often it is implemented so that the software behaves in a different way than it
    would on a physical work device that is used by a real user – to complicate reverse
    engineering of their code to stay undetected for a longer period.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，并且恶意软件是在虚拟机（VM）或沙箱中执行的，它通常会被实现为使软件的行为与在真实用户使用的物理工作设备上执行时不同——以此来复杂化其代码的逆向工程，从而延长其保持隐蔽的时间。
- en: Coming back to the registry – storing credentials in the registry is a very
    bad practice and should be avoided. However, there are still administrators and
    software vendors that use the registry to store credentials in a very unsecure
    way. Therefore, attackers have been observed to query the registry to retrieve
    credentials.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到注册表——将凭证存储在注册表中是一个非常不好的做法，应该避免。然而，仍然有管理员和软件供应商以非常不安全的方式使用注册表存储凭证。因此，攻击者曾被观察到查询注册表以检索凭证。
- en: Some malware even uses the registry for their own purposes, and set and query
    their own registry hives or keys.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件甚至会将注册表用于它们自己的目的，设置并查询它们自己的注册表树或键。
- en: Remember that when you are searching for reconnaissance evidence, attackers
    also have other (programmatic) options to query the registry – such as the **reg.exe**
    command-line tool or WMI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你在寻找侦察证据时，攻击者也有其他（编程）选项来查询注册表——例如**reg.exe**命令行工具或WMI。
- en: Execution policy
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行策略
- en: 'In [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting Started
    with PowerShell*, we learned that **ExecutionPolicy** restricts the execution
    of scripts on the local machine – although it’s not a security control. Nevertheless,
    the **ExecutionPolicy** status can also be queried or modified using the registry:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)《PowerShell 入门》中，我们了解到**ExecutionPolicy**限制了在本地计算机上执行脚本—尽管这并不是一种安全控制。然而，**ExecutionPolicy**的状态也可以通过注册表查询或修改：
- en: '![Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry](image/B16679_05_010.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 使用注册表更改 Windows PowerShell ExecutionPolicy](image/B16679_05_010.jpg)'
- en: Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 使用注册表更改 Windows PowerShell ExecutionPolicy
- en: Changing **ExecutionPolicy** using the registry only works for Windows PowerShell.
    Therefore, you can see in the preceding screenshot that, first, the Windows PowerShell
    **ExecutionPolicy** shows that it is set to **Restricted**, but after configuring
    the registry entry, it is set to **Unrestricted**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注册表更改**ExecutionPolicy**只对 Windows PowerShell 有效。因此，你可以在前面的截图中看到，首先，Windows
    PowerShell 的**ExecutionPolicy**显示为**Restricted**，但在配置注册表条目后，它变为**Unrestricted**。
- en: 'PowerShell Core’s **ExecutionPolicy** is defined in the following file: **C:\Program
    Files\PowerShell\7\powershell.config.json**.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell Core 的**ExecutionPolicy**定义在以下文件中：**C:\Program Files\PowerShell\7\powershell.config.json**。
- en: Persistence
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久性
- en: 'Another reason attackers attempt to edit the registry is to establish persistence:
    a very common way to establish persistence is to add a Startup entry. This can
    be done by adding a link to either the Startup folder of the current user or all
    users.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者尝试编辑注册表的另一个原因是为了建立持久性：建立持久性的常见方法之一是添加启动项。这可以通过在当前用户或所有用户的启动文件夹中添加链接来完成。
- en: 'Another option to establish persistence via Startup is by adding either a **Run**
    or **RunOnce** registry key under one of the following Startup registry locations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通过启动项建立持久性的方式是通过在以下启动项注册表位置之一下添加**Run**或**RunOnce**注册表键：
- en: '**HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\**'
- en: '**HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\**'
- en: '**HCU\.DEFAULT\Software\Microsoft\CurrentVersion\**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HCU\.DEFAULT\Software\Microsoft\CurrentVersion\**'
- en: Note that **.DEFAULT** can also be replaced with the user **Security identifiers**
    (**SIDs**) of the respective folder under **HKEY_USERS**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**.DEFAULT**也可以替换为相应文件夹下**HKEY_USERS**中的用户**安全标识符**（**SIDs**）。
- en: The **Run** key executes the program each time a user logs on, while the **RunOnce**
    key runs the program once and then deletes the key. These keys can be set for
    the user or the machine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Run**键在每次用户登录时执行程序，而**RunOnce**键只执行一次程序，然后删除该键。这些键可以为用户或计算机设置。'
- en: 'To set, for example, a **RunOnce** key for the current user to execute a script
    *once* after the user logged on, you would use the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为当前用户设置一个**RunOnce**键，在用户登录后执行脚本*一次*，你可以使用以下代码：
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To set a **Run** key for the local machine to execute a script *every time*
    the machine is booted, use the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要为本地计算机设置一个**Run**键，使其在每次启动计算机时执行脚本，请使用以下命令：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Additionally, attackers can also establish persistence under other user's Startup
    keys by directly writing to their respective **Run**/**RunOnce** keys under the
    **HKU\<TargetSID>\Software\Microsoft\CurrentVersion\** key, provided they have
    the necessary permissions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，攻击者还可以通过直接写入他们各自的**Run**/**RunOnce**键到**HKU\<TargetSID>\Software\Microsoft\CurrentVersion\**下的相应位置，来在其他用户的启动项下建立持久性，前提是他们拥有必要的权限。
- en: 'Now that we explored the Windows Registry, let’s dive into another important
    part when it comes to security: local user rights.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 Windows 注册表，让我们深入了解与安全性相关的另一个重要部分：本地用户权限。
- en: User rights
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户权限
- en: 'User rights play a huge role in corporate environments: you can, for example,
    configure who is allowed to log on to which system and who is allowed to do what.
    A misconfiguration can cause a serious risk of identity theft and lateral movement.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户权限在企业环境中发挥着重要作用：例如，你可以配置谁可以登录哪个系统，以及谁可以做什么。配置错误可能导致严重的身份盗窃和横向移动风险。
- en: Adversaries can use it to find out which accounts are worthwhile to compromise
    to escalate their privileges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可以利用它来查明哪些帐户值得被攻击，以提升他们的特权。
- en: 'You can find a detailed overview of all user rights in the official documentation:
    [https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到所有用户权限的详细概述：[https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment)。
- en: I know the documentation is quite extensive and if you have no experience on
    user rights yet, you might quickly get lost. Therefore, let me explain some of
    the most important security-related user rights that I have often seen misconfigured.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道文档内容非常庞杂，如果你还没有用户权限的经验，可能会很快迷失其中。因此，让我来解释一些最常见的安全相关用户权限，我经常看到它们被错误配置。
- en: Configuring access user rights
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置访问用户权限
- en: In general, log-on rights are always critical if too many users and or groups
    are allowed to access a sensitive system. Many default rights are set by default
    and may need to be changed to harden the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，登录权限非常重要，如果允许过多的用户或组访问敏感系统，可能会带来安全隐患。许多默认权限在系统安装时已被预设，并且可能需要修改以加固系统安全。
- en: 'Depending on what machine type you’re configuring this policy for, you may
    want to limit the ability to log on locally or through a remote desktop to a machine
    to its users and/or specific administrator accounts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你为其配置此策略的机器类型，你可能需要限制本地登录或通过远程桌面登录的能力，只允许用户和/或特定的管理员帐户：
- en: '**Access this computer from the network** (**SeNetworkLogonRight**): For **domain
    controllers** (**DCs**), all authenticated users needs to have access to apply
    Group Policies, so configure **Administrators** and **Authenticated Users** to
    access DCs. Remove the built-in groups.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从网络访问此计算机** (**SeNetworkLogonRight**)：对于**域控制器**（**DC**），所有经过身份验证的用户都需要访问域控制器以应用组策略，因此需要配置**管理员**和**已验证用户**访问域控制器。移除内建组。'
- en: Remove **Everyone**, **Users**, as well as the built-in groups for member servers.
    For client PCs, only allow users and administrators to log on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 移除**所有人**、**用户**以及成员服务器的内建组。对于客户端计算机，仅允许用户和管理员登录。
- en: '**Allow log on locally** (**SeInteractiveLogonRight**): Remove **Guest** and
    built-in groups. If it’s a DC or a member server, also remove **Users**.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许本地登录** (**SeInteractiveLogonRight**)：移除**访客**和内建组。如果是域控制器或成员服务器，还需要移除**用户**。'
- en: '**Allow log on through Remote Desktop** **Services** (**SeRemoteInteractiveLogonRight**)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许通过远程桌面** **服务** (**SeRemoteInteractiveLogonRight**) 登录'
- en: '**Log on as a batch** **job** (**SeBatchLogonRight**)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为批处理作业登录** (**SeBatchLogonRight**)'
- en: '**Log on as a** **service** (**SeServiceLogonRight**)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为服务登录** (**SeServiceLogonRight**)'
- en: 'The *deny* rules overwrite the *allow* privileges: no matter what you configured
    as an *allow* rule, if access is forbidden by a *deny* rule, the affected user
    cannot log on or access the machine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*拒绝*规则会覆盖*允许*权限：无论你配置了什么样的*允许*规则，如果*拒绝*规则禁止访问，相关用户将无法登录或访问机器：'
- en: '**Deny access to this computer from the** **network** (**SeDenyNetworkLogonRight**)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝通过网络访问此计算机** (**SeDenyNetworkLogonRight**)'
- en: '**Deny log on as a batch** **job** (**SeDenyBatchLogonRight**)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝作为批处理作业登录** (**SeDenyBatchLogonRight**)'
- en: '**Deny log on as a** **service** (**SeDenyServiceLogonRight**)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝作为服务登录** (**SeDenyServiceLogonRight**)'
- en: '**Deny log on** **locally** (**SeDenyInteractiveLogonRight**)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝本地登录** (**SeDenyInteractiveLogonRight**)'
- en: '**Deny log on through Remote Desktop** **Services** (**SeDenyRemoteInteractiveLogonRight**)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝通过远程桌面** **服务** (**SeDenyRemoteInteractiveLogonRight**) 登录'
- en: These rules can help you to set up a solid tiering concept in your environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以帮助你在环境中建立一个稳固的分层概念。
- en: Do not remove **Guest** from the **Deny log on**/**access** permissions unless
    your specific configuration requires it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的特定配置要求，否则不要移除**访客**的**拒绝登录**/**访问**权限。
- en: Mitigating risks through backup and restore privileges
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过备份和恢复权限来降低风险
- en: 'Backup and restore privileges can be incredibly powerful, as they allow users
    to access and modify files and directories that they normally have no access to.
    It makes sense to evaluate very carefully who has these rights configured, especially
    on critical systems such as DCs. These rights could allow adversaries to extract
    sensitive information such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 备份和恢复权限非常强大，因为它们允许用户访问和修改通常无法访问的文件和目录。在关键系统（如域控制器）上，仔细评估哪些用户配置了这些权限非常重要。这些权限可能会让攻击者提取敏感信息，具体如下：
- en: '**Back up files and** **directories** (**SeBackupPrivilege**)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份文件和** **目录** (**SeBackupPrivilege**)'
- en: '**Restore files and** **directories** (**SeRestorePrivilege**)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复文件和** **目录** (**SeRestorePrivilege**)'
- en: It’s crucial to note that backup privileges allow a user to read any file, regardless
    of their normal permissions. This means that users with backup privileges can
    also potentially access sensitive information such as, for example, password hashes
    that are available in the **ntds.dit** database file on DCs. Restore privileges,
    on the other hand, allow a user to write any file, which could potentially be
    used to plant malicious code or modify critical system files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，备份权限允许用户读取任何文件，无论他们的正常权限是什么。这意味着拥有备份权限的用户也可能访问敏感信息，例如，在DC上的**ntds.dit**数据库文件中存储的密码哈希。另一方面，恢复权限允许用户写入任何文件，这可能被用来植入恶意代码或修改关键系统文件。
- en: By default, the built-in **Backup Operators** group is assigned both of these
    rights. Be careful if you plan to remove this group because some backup software
    packages rely on this group to enable the software to function. Where possible,
    assign the backup and restore privileges only to specific users or groups instead
    of relying on the built-in **Backup** **Operators** group.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，内置的**备份操作员**组被分配了这两项权限。如果你打算删除该组，请小心，因为某些备份软件依赖该组才能正常运行。尽可能地，将备份和恢复权限仅分配给特定的用户或组，而不是依赖于内置的**备份**
    **操作员**组。
- en: Delegation and impersonation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委派和 impersonation（身份冒充）
- en: 'Having the right for delegation allows someone to delegate rights to another
    account. Impersonation allows impersonating another account, which is usually
    used by web servers to access resources in the context of a user. If misconfigured,
    both can have dramatic consequences:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有委派权限的人可以将权限委派给另一个帐户。身份冒充允许冒充另一个帐户，通常由 Web 服务器在用户上下文中访问资源。如果配置错误，这两者可能会带来严重后果：
- en: '**Enable computer and user accounts to be trusted for delegation** (**SeEnableDelegationPrivilege**):
    If an account is trusted for delegation, that means that this account can set
    the *trusted for delegation* setting. Once set, this setting enables the ability
    to connect to multiple servers or services while retaining the credentials of
    the originating account. Web servers, which need to connect using the originating
    credentials to a database or data share, are a good example of a legitimate use
    case to be *trusted* *for delegation*.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用计算机和用户帐户信任委派** (**SeEnableDelegationPrivilege**): 如果一个帐户被信任进行委派，这意味着该帐户可以设置*信任委派*设置。一旦设置，这项设置将允许在保持原始帐户凭证的情况下连接到多个服务器或服务。Web
    服务器需要使用原始凭证连接到数据库或数据共享，这是一个合理的*信任* *委派*的用例。'
- en: Nevertheless, you want to avoid configuring this right unless it is really needed
    by a certain software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非某些软件确实需要，否则你应该避免配置此项权限。
- en: '**Impersonate a client after authentication** (**SeImpersonatePrivilege**):
    Impersonation allows services or threads to run under a different security context.
    If misconfigured, this ability could allow attackers to trick clients into connecting
    to a service created by the attacker to then impersonate the connecting client
    to elevate the attacker’s privileges.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份冒充客户端（身份验证后）** (**SeImpersonatePrivilege**): 身份冒充允许服务或线程在不同的安全上下文下运行。如果配置错误，这种能力可能使攻击者欺骗客户端连接到攻击者创建的服务，然后冒充连接的客户端来提升攻击者的权限。'
- en: '**Act as part of the operating system** (**SeTcbPrivilege**): This right allows
    an account to control the system and act as any user. This setting decides whether
    a process can take on the identity of any user, which gives access to the resources
    that the user can use.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为操作系统的一部分** (**SeTcbPrivilege**): 该权限允许帐户控制系统并充当任何用户。此设置决定一个进程是否可以获得任何用户的身份，从而访问该用户可以使用的资源。'
- en: Preventing event log tampering
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止事件日志篡改
- en: 'If you have access to the auditing and security log, you can tamper with it
    and hide your traces. The following settings affect access to the auditing and
    security log and should be configured with care:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以访问审计和安全日志，你可以篡改它并隐藏你的痕迹。以下设置会影响对审计和安全日志的访问，应该小心配置：
- en: '**Generate security audits** (**SeAuditPrivilege**): Although this privilege
    only allows generating new events, an attacker can create so much noise that their
    attacking attempts might go unnoticed, especially if the company does not forward
    event logs and deletes them after a certain volume is reached.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成安全审计**（**SeAuditPrivilege**）：尽管此权限仅允许生成新事件，但攻击者可以制造大量噪音，使他们的攻击尝试未被注意到，尤其是在公司未转发事件日志且在达到一定数量后会删除日志的情况下。'
- en: '**Manage auditing and security log** (**SeSecurityPrivilege**): If you can
    manage event logs, then you can surely delete them as well. Look for event ID
    **104** in the system event log. Please refer to [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090),
    *Detection – Auditing and Monitoring*, for more information on monitoring and
    detection.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理审计和安全日志**（**SeSecurityPrivilege**）：如果您可以管理事件日志，那么您肯定也能删除它们。请在系统事件日志中查找事件
    ID **104**。有关监控和检测的更多信息，请参阅 [*第 4 章*](B16679_04_Final_PD.xhtml#_idTextAnchor090)，*检测
    – 审计与监控*。'
- en: Preventing Mimikatz and credential theft
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止 Mimikatz 和凭证窃取
- en: 'Mimikatz and other tools that are used for credential theft usually require
    the right to debug programs or load kernel mode drivers. The following settings
    are usually required by tools such as Mimikatz and others to extract credentials:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Mimikatz 和其他用于凭证窃取的工具通常需要调试程序的权限或加载内核模式驱动程序的权限。以下设置通常是 Mimikatz 等工具提取凭证时所需的：
- en: '**Debug programs** (**SeDebugPrivilege**): A common misconception with the
    **Debug programs** privilege is that this would be needed by developers to debug
    their software. This is not true. The Debug programs privileges privilege allows
    access to otherwise protected operating system memory, effectively providing control
    over program execution and the ability to read and write memory. Tools such as
    Mimikatz that access the **Local Security Authority** (**LSA**) to extract credentials
    require this permission to properly function.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试程序**（**SeDebugPrivilege**）：关于**调试程序**权限的一个常见误解是，开发人员需要此权限来调试他们的软件。其实并非如此。调试程序权限允许访问本应受到保护的操作系统内存，实际上提供了对程序执行的控制能力以及读取和写入内存的能力。像
    Mimikatz 这样的工具，访问 **本地安全机构**（**LSA**）以提取凭证，需要此权限才能正常工作。'
- en: Normally, your administrators will not require this user right, so it’s safe
    to revoke this right for everybody, even for your administrators.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您的管理员不需要此用户权限，因此，即使是管理员也可以安全地撤销此权限。
- en: Note that administrators can assign this right to themselves; therefore, remove
    this privilege and monitor for changes. In this way, you can spot indicators for
    the beginning of a credential theft attack.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，管理员可以将此权限分配给自己；因此，移除此权限并监控其变更非常重要。通过这种方式，您可以发现凭证窃取攻击开始的迹象。
- en: '**Load and unload device drivers** (**SeLoadDriverPrivilege**): This right
    enables a user account to load kernel mode drivers. Since these drivers are located
    in kernel mode memory, they can be used to read or tamper with other kernel mode
    memory, much like the **Debug programs** right. Be cautious when granting this
    user right.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载和卸载设备驱动程序**（**SeLoadDriverPrivilege**）：此权限使用户帐户能够加载内核模式驱动程序。由于这些驱动程序位于内核模式内存中，因此它们可以用于读取或篡改其他内核模式内存，类似于**调试程序**权限。授予此用户权限时请谨慎。'
- en: System and domain access
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统和域访问
- en: 'Getting access to the system or adding machines to a domain can be very valuable
    for attackers. The following setting is related to these scenarios:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 获取系统访问权限或将计算机添加到域对于攻击者来说非常有价值。以下设置与这些场景相关：
- en: '**Add workstations to domain** (**SeMachineAccountPrivilege**): This privilege
    allows the user to add workstations to the domain.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将工作站添加到域**（**SeMachineAccountPrivilege**）：此权限允许用户将工作站添加到域中。'
- en: Time tampering
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间篡改
- en: 'Tampering with the time of an operating system is not considered a security
    flaw by default and should not be confused with **timestomping**, which involves
    modifying timestamps of file creation, access, modification, and so on. Nevertheless,
    it is important to be aware that certain programs may encounter issues when the
    system time is tampered with, and incorrect timestamps can lead to inaccurate
    conclusions during event log analysis. The following settings should be configured
    very carefully to avoid these scenarios:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的时间篡改默认情况下不被视为安全漏洞，并且不应与 **时间戳篡改** 混淆，后者涉及修改文件创建、访问、修改等时间戳。然而，重要的是要意识到，某些程序在系统时间被篡改时可能会遇到问题，且不正确的时间戳可能导致在事件日志分析过程中得出不准确的结论。为了避免这些情况，以下设置应谨慎配置：
- en: '**Change the system** **time** (**SeSystemtimePrivilege**)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改系统** **时间**（**SeSystemtimePrivilege**）'
- en: '**Change the time** **zone** (**SeTimeZonePrivilege**)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改时间** **时区**（**SeTimeZonePrivilege**）'
- en: 'Of course, this is only a summary of the user rights that I have seen mostly
    misconfigured and not a complete list. Please refer to the official documentation
    and follow the links to read more about each user privilege: [https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是我见过的多数配置错误的用户权限的总结，并非完整列表。请参考官方文档并跟随链接阅读有关每个用户权限的更多信息：[https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment)。
- en: 'And if you want to find out which built-in groups have which user rights assigned
    by default, the following documentation can be very helpful: [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解哪些内置组默认分配了哪些用户权限，以下文档会非常有帮助：[https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11))。
- en: You can use the **Policy Analyzer** as well to analyze and compare your settings
    with the official Microsoft recommendation. We will explore Policy Analyzer later
    in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150)*, Active Directory
    – Attacks* *and Mitigation*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用**Policy Analyzer**来分析并将您的设置与官方的Microsoft推荐进行比较。我们将在第[*6章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)中进一步探讨Policy
    Analyzer，章节内容包括*Active Directory – 攻击与缓解*。
- en: But Policy Analyzer is not the only way to analyze and compare user right assignments
    – let’s look at how to assert which rights are set and how to configure them in
    our next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Policy Analyzer并不是分析和比较用户权限分配的唯一方式——接下来我们将看看如何验证已设置的权限以及如何配置它们。
- en: Examining and configuring user rights
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查和配置用户权限
- en: 'If you want to examine which user rights are configured on the localhost, you
    can run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查本地计算机上配置了哪些用户权限，可以运行以下命令：
- en: '[PRE3]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to export the local and domain-managed policy merged, you can use
    the **/****mergedpolicy** parameter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想导出本地和域管理的合并策略，可以使用**/****mergedpolicy**参数：
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All current user rights will be written to **$Env:Temp\secedit.txt**. Under
    the **[Privilege Rights]** section, you can find all configured assignments. By
    using **secedit**, only the SIDs will be shown, so you will need to translate
    them into real user account names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当前的用户权限将被写入**$Env:Temp\secedit.txt**。在**[Privilege Rights]**部分，您可以找到所有已配置的权限分配。使用**secedit**时，仅会显示SIDs，因此您需要将其转换为真实的用户账户名称。
- en: '![Figure 5.11 – Privilege rights in the secedit file](image/B16679_05_011.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – secedit文件中的权限设置](image/B16679_05_011.jpg)'
- en: Figure 5.11 – Privilege rights in the secedit file
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – secedit文件中的权限设置
- en: 'You can find more information on further parameters and the usage of **secedit**
    in the official documentation: [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到更多关于**secedit**的其他参数和使用信息：[https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10))。
- en: 'I have written a script, **Get-UserRightsAssignment**, that will help you to
    translate the SIDs into account names and makes it easier to process user rights.
    You can use the **-Path** parameter to specify a custom location where the file
    generated by **secedit** should be saved to:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个脚本，**Get-UserRightsAssignment**，它可以帮助您将SIDs转换为账户名称，并简化用户权限的处理。您可以使用**-Path**参数指定一个自定义位置，保存**secedit**生成的文件：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The **secedit** file will be deleted after the script completes. If **-Path**
    is not specified, the default path will be **$env:TEMP\secedit.txt**. As the script
    leverages the **secedit** tool, you will need administrative rights to execute
    it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**secedit**文件将在脚本执行完毕后删除。如果没有指定**-Path**，默认路径将是**$env:TEMP\secedit.txt**。由于脚本使用了**secedit**工具，您需要具有管理员权限才能执行该脚本。'
- en: 'You can find and download the **Get-UserRightsAssignment** script in the GitHub
    repository of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到并下载**Get-UserRightsAssignment**脚本：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1)。
- en: You can also use Group Policy to configure the user rights assignment of multiple
    computers and/or servers in your environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用组策略配置环境中多个计算机和/或服务器的用户权限分配。
- en: Create a new **Group Policy Object** (**GPO**) and navigate to **Computer Configuration**
    | **Windows Settings** | **Security Settings** | **Local Policies** | **User**
    **Rights Assignment**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的**组策略对象**（**GPO**），并导航至**计算机配置** | **Windows 设置** | **安全设置** | **本地策略**
    | **用户权限分配**。
- en: '![Figure 5.12 – Configuring user rights assignment via Group Policy](image/B16679_05_012.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 通过组策略配置用户权限分配](image/B16679_05_012.jpg)'
- en: Figure 5.12 – Configuring user rights assignment via Group Policy
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 通过组策略配置用户权限分配
- en: 'Double-click each policy setting that you want to configure. A window will
    open. To configure the setting, check the **Define these policy settings** box
    and use **Add User or Group** to add additional users or groups, as shown in the
    following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 双击每个你想要配置的策略设置。会打开一个窗口。要配置该设置，勾选**定义这些策略设置**框，并使用**添加用户或组**来添加额外的用户或组，如下截图所示：
- en: '![Figure 5.13 – Configuring the Allow log on locally setting](image/B16679_05_013.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 配置本地登录权限设置](image/B16679_05_013.jpg)'
- en: Figure 5.13 – Configuring the Allow log on locally setting
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 配置本地登录权限设置
- en: Under the **Explain** tab, you will find more information on what this setting
    does and, often, also useful links on where to find more details on this setting.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解释**标签下，你可以找到更多关于此设置的功能说明，并且通常还会有一些有用的链接，提供更多关于此设置的详细信息。
- en: If you configure user rights assignments and assess the GPO on the system, you
    will see that a similar file is created as if you would create it manually. You
    can use it to compare your settings or just place a manually preconfigured **secedit**
    file here to avoid configuring all settings manually via the GPO interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你配置了用户权限分配并在系统上评估GPO，你会发现一个类似的文件被创建，就像你手动创建它一样。你可以使用它来比较设置，或者将一个手动预配置的**secedit**文件放在这里，避免通过GPO界面手动配置所有设置。
- en: 'For example in my domain, **PSSec.local**, I created the GPO with the unique
    ID **{B04231D1-A45A-4390-BB56-897DA6B1A910}**. If I want to access the newly created
    **secedit** configuration, I simply have to navigate to the following path and
    assess the **GptTmpl.inf** file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的域 **PSSec.local** 中，我创建了一个唯一ID为 **{B04231D1-A45A-4390-BB56-897DA6B1A910}**
    的GPO。如果我想访问新创建的 **secedit** 配置，只需导航到以下路径并查看 **GptTmpl.inf** 文件：
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, you can also just copy the **GptTmpl.inf** file from an existing
    Microsoft Security baseline into a newly created GPO to just configure the Microsoft
    recommendations. A Microsoft Security baseline is a configuration recommendation
    by Microsoft to provide security best practices. We will further look into baselines
    in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150)*, Active Directory
    – Attacks* *and Mitigation*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以直接将现有 Microsoft 安全基线中的**GptTmpl.inf**文件复制到新创建的GPO中，只配置Microsoft推荐的设置。Microsoft
    安全基线是Microsoft提供的一种配置建议，旨在提供安全最佳实践。我们将在[*第6章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)中进一步了解基线，主题包括*Active
    Directory – 攻击*和*缓解*。
- en: After exploring Windows user rights in the preceding section, we will now focus
    on another vital component of the Windows operating system – the Windows API.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中探索完Windows用户权限后，我们现在将重点关注Windows操作系统的另一个重要组件——Windows API。
- en: Basics of the Windows API
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows API 基础
- en: The Windows **Application Programming Interface** (**API**), also known as Win32
    or WinAPI, is a collection of libraries, functions, and interfaces that provide
    low-level access to various features and components of the Windows operating system.
    It allows developers direct access to system features and hardware, simplifying
    access to deeper layers of the operating system. The Windows API functions are
    written in C/C++ and are exposed by DLL files (such as **kernel32.dll** or **user32.dll**).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Windows **应用程序编程接口**（**API**），也称为 Win32 或 WinAPI，是一组库、函数和接口，提供对 Windows 操作系统各种功能和组件的底层访问。它允许开发者直接访问系统功能和硬件，简化对操作系统深层次功能的访问。Windows
    API 函数是用 C/C++ 编写的，并通过 DLL 文件（如**kernel32.dll** 或 **user32.dll**）暴露给开发者使用。
- en: The Windows API is implemented as a collection of **dynamic-link libraries**
    (**DLLs**) that are loaded into memory when an application needs to use them.
    These DLLs contain the functions and procedures that make up the API. When an
    application calls a function from the API, it is essentially sending a message
    to the operating system to perform a certain task. The operating system then executes
    the appropriate function from the appropriate DLL and returns the result to the
    application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API 被实现为一组**动态链接库**（**DLLs**），这些库在应用程序需要使用时被加载到内存中。这些 DLL 包含构成 API 的函数和过程。当应用程序调用
    API 中的某个函数时，它本质上是在向操作系统发送一条消息，要求执行某个任务。操作系统随后从适当的 DLL 中执行相应的函数，并将结果返回给应用程序。
- en: 'Nowadays, the names *Windows API* or *WinAPI* refers to several versions, although
    the versions implemented for different platforms can be still referred to by their
    own names (such as *Win32 API*):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现如今，*Windows API* 或 *WinAPI* 这个名称指代多个版本，尽管为不同平台实现的版本仍可以按照它们自己的名字来称呼（例如 *Win32
    API*）：
- en: '**Win16 API**: The first API version was the Win16 API, which was developed
    for 16-bit platforms, but is no longer supported.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Win16 API**：第一个 API 版本是 Win16 API，它是为 16 位平台开发的，但现在已不再支持。'
- en: '**Win32 API**: The Windows 32 API is still in use on all current modern Windows
    systems and was introduced with Windows NT and Windows 95.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Win32 API**：Windows 32 API 目前仍在所有现代 Windows 系统中使用，并且是在 Windows NT 和 Windows
    95 时引入的。'
- en: '**Win32s API**: This is the Windows 32 API for the Windows 3.1 family, and
    therefore, an extension to 32-bit, as systems in this family originally only supported
    16-bit. The **s** stands for **subset**.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Win32s API**：这是 Windows 3.1 系列的 Windows 32 API，因此是 32 位的扩展，因为该系列的系统最初仅支持
    16 位。**s**代表**子集**。'
- en: '**Win64 API**: This API is the variant for modern 64-bit operating systems
    and was introduced with Windows XP and Windows Server 2003.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Win64 API**：该 API 是现代 64 位操作系统的变体，并在 Windows XP 和 Windows Server 2003 中引入。'
- en: '**Windows Native API**: The Native API is used when other APIs such as the
    Win32 API are not yet accessible – for example, when a system is booted. Unlike
    the well-documented Win32 API functions in the **Microsoft Developer Network**
    (**MSDN**) (such as **kernel32.dll**), it is important to note that the Native
    API, exported via **NTDLL.DLL**, is not considered a “contractual” interface.
    This means that the behavior and definitions of functions exposed by **NTDLL.DLL**
    may change over time.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Native API**：当其他 API，如 Win32 API 尚不可访问时，使用原生 API——例如，在系统启动时。与在**微软开发者网络**（**MSDN**）中有良好文档支持的
    Win32 API 函数（如**kernel32.dll**）不同，需要注意的是，通过**NTDLL.DLL**导出的原生 API 并不被视为“契约性”接口。这意味着，**NTDLL.DLL**
    导出的函数行为和定义可能会随时间变化。'
- en: The Windows API functions are written exclusively in C, C++, and assembly and
    can therefore be used by developers in their own functions. The Win32 API itself
    is quite large, so there are multiple DLL files needed to export the entire functionality.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API 函数完全使用 C、C++ 和汇编语言编写，因此开发者可以在自己的函数中使用这些函数。Win32 API 本身非常庞大，因此需要多个
    DLL 文件来导出完整的功能。
- en: Nowadays, there are several layered APIs, which simplify access so that the
    developer does not need to directly work with the Win32 or Win64 API.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，有多个分层的 API，它们简化了访问，开发者无需直接使用 Win32 或 Win64 API。
- en: 'Some APIs that build on the Windows API are the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些建立在 Windows API 基础上的 API 如下：
- en: '**WinRT**: The Windows Runtime API was first introduced with Windows 8/Windows
    Server 2012\. WinRT is based on the COM and was implemented in C++. It enables
    developers to write their code now also in other languages, such as C++, C#, Visual
    Basic .NET, Rust/WinRT, Python/WinRT, and JavaScript/TypeScript.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WinRT**：Windows运行时API首次出现在Windows 8/Windows Server 2012中。WinRT基于COM，并使用C++实现。它使开发人员可以用其他语言编写代码，如C++、C#、Visual
    Basic .NET、Rust/WinRT、Python/WinRT以及JavaScript/TypeScript。'
- en: '**COM**: COM is a part of the APIs and is a technique for inter-process communication.
    We will have a deeper look at it later in this chapter.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COM**：COM是API的一部分，是一种进程间通信技术。我们将在本章后面深入探讨它。'
- en: '**.NET**/**.NET Framework**: .NET Framework is a software framework developed
    by Microsoft that provides a large library of pre-built functions and APIs that
    can be used by developers to build applications on Windows.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET**/**.NET Framework**：.NET Framework是微软开发的软件框架，提供大量预构建的函数和API，开发人员可以利用这些函数和API在Windows上构建应用程序。'
- en: One way to access the Windows API from PowerShell is through the use of .NET
    Framework. This allows you to access the same functionality provided by the Windows
    API, but from within PowerShell. It allows you to interact with the operating
    system at a lower level and perform tasks that may not be possible with standard
    PowerShell cmdlets. We will learn more about .NET Framework later in this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从PowerShell访问Windows API的一种方式是通过使用.NET Framework。这使你可以访问Windows API提供的相同功能，但可以在PowerShell内部进行操作。它允许你以更低的级别与操作系统进行交互，并执行一些标准PowerShell
    cmdlet无法实现的任务。我们将在本章后面详细了解.NET Framework。
- en: 'The following list is a collection of different API categories that can be
    utilized:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是可以利用的不同API类别：
- en: '**User interface**: Provides functions for creating and managing user interface
    elements such as windows, buttons, and menus.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：提供用于创建和管理用户界面元素的功能，如窗口、按钮和菜单。'
- en: '**Windows environment (Shell)**: Includes functions for interacting with the
    Windows Shell, which is the graphical user interface that provides access to the
    filesystem and other system resources.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows环境（Shell）**：包括与Windows Shell交互的功能，Windows Shell是图形用户界面，提供对文件系统和其他系统资源的访问。'
- en: '**User input and messaging**: Handling user input and messaging, such as keyboard
    and mouse events, window messages, and system notifications functionality will
    be provided through this interface.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入与消息传递**：通过此接口提供处理用户输入和消息传递的功能，如键盘和鼠标事件、窗口消息以及系统通知。'
- en: '**Data access and storage**: The Windows API provides functions for working
    with data and storage, including file and registry access, database connectivity,
    and data encryption.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问与存储**：Windows API提供用于处理数据和存储的功能，包括文件和注册表访问、数据库连接以及数据加密。'
- en: '**Diagnostics**: This interface provides access to monitoring system performance,
    logging events, and troubleshooting error functions.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诊断**：该接口提供访问系统性能监控、事件日志记录和故障排除错误功能的能力。'
- en: '**Graphics and multimedia**: Provides functions for working with graphics,
    multimedia, and game development, including DirectX and Windows Media.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形与多媒体**：提供用于处理图形、多媒体和游戏开发的功能，包括DirectX和Windows Media。'
- en: '**Devices**: The Windows API includes functions for interacting with hardware
    devices, such as printers, scanners, and cameras.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：Windows API包含与硬件设备交互的功能，如打印机、扫描仪和摄像头。'
- en: '**System services**: Contains functions for managing system services, such
    as starting and stopping processes and managing system resources.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统服务**：包含管理系统服务的功能，如启动和停止进程及管理系统资源。'
- en: '**Security and identity**: The security and identity interface includes functions
    for managing user authentication, access control, and cryptography.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全与身份**：安全与身份接口包括用于管理用户身份验证、访问控制和加密的功能。'
- en: '**Application installation and servicing**: Includes functions for installing
    and uninstalling applications, managing updates, and handling application errors.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序安装与维护**：包括安装和卸载应用程序、管理更新以及处理应用程序错误的功能。'
- en: '**System admin and management**: Contains functions for managing system settings,
    performance, and security, and for automating administrative tasks.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统管理与维护**：包含管理系统设置、性能和安全性，以及自动化管理任务的功能。'
- en: '**Networking and internet**: The Windows API includes functions for networking
    and internet connectivity, including TCP/IP, sockets, and web services.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络和互联网**：Windows API 包括用于网络和互联网连接的函数，包括 TCP/IP、套接字和 Web 服务。'
- en: '**Deprecated or legacy APIs**: For backward compatibility with older applications
    and systems, the Windows API also includes some older functions and interfaces.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已弃用或遗留的 API**：为了与旧版本的应用程序和系统保持向后兼容，Windows API 还包括一些较旧的函数和接口。'
- en: '**Windows and application SDKs**: In addition to the categories of APIs listed
    previously, there are also **software development kits** (**SDKs**) available
    for Windows and application development. PowerShell is one example of an SDK that
    uses the Windows API and .NET Framework. The **System.Management.Automation**
    assembly includes classes and cmdlets for working with PowerShell from within
    .NET applications.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 和应用程序 SDK**：除了之前列出的 API 类别外，还有用于 Windows 和应用程序开发的 **软件开发工具包**（**SDK**）。PowerShell
    就是一个使用 Windows API 和 .NET Framework 的 SDK 示例。**System.Management.Automation**
    程序集包含了用于在 .NET 应用程序中与 PowerShell 交互的类和 cmdlet。'
- en: Some of the most commonly used Windows API functions include those related to
    process and thread management, memory management, file and directory management,
    and registry manipulation. These functions can be used to perform a variety of
    tasks, such as enumerating processes and threads, reading and writing to memory,
    creating and deleting files and directories, and manipulating the Windows Registry.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的 Windows API 函数包括与进程和线程管理、内存管理、文件和目录管理以及注册表操作相关的函数。这些函数可以用来执行多种任务，如枚举进程和线程、读写内存、创建和删除文件与目录，以及操作
    Windows 注册表。
- en: 'There are of course many other APIs, but I will not concentrate on them in
    this book. A complete overview of the functions and structures within the Windows
    API that can be accessed can be found here: [https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他的 API，但在本书中我不会集中讨论它们。有关可以访问的 Windows API 函数和结构的完整概述，请参见：[https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)。
- en: Exploring .NET Framework
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 .NET Framework
- en: '**.NET Framework** is a software framework developed by Microsoft that provides
    a wide range of functionalities for building and running applications. It is a
    default part of every Windows installation since Windows Vista. One of the framework’s
    key features is the ability to access system and API resources, making it a powerful
    tool.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET Framework** 是微软开发的软件框架，提供了广泛的功能，用于构建和运行应用程序。自 Windows Vista 以来，它成为了每个
    Windows 安装的默认部分。框架的一个关键特性是能够访问系统和 API 资源，使其成为一个强大的工具。'
- en: '.NET Framework consists of two main components:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 包含两个主要组件：
- en: '**Common Language** **Runtime** (**CLR**):'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共语言运行时**（**CLR**）：'
- en: This is the runtime engine for .NET; it also contains a **Just in Time** (**JIT**)
    compiler, which translates bytecode in **Common Intermediate Language** (**CIL**)
    to the underlying compiler to turn it into machine code that can execute on the
    specific architecture of the computer it is running on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 .NET 的运行时引擎；它还包含一个 **即时编译**（**JIT**）编译器，用于将 **公共中间语言**（**CIL**）的字节码转换为底层编译器生成的机器代码，从而在计算机特定架构上执行。
- en: The CLR also includes thread management, a garbage collector, type safety, code
    access security, exception handling, and more.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 还包括线程管理、垃圾回收、类型安全、代码访问安全、异常处理等功能。
- en: Every .NET Framework version comes with its own CLR.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 .NET Framework 版本都有其自己的 CLR。
- en: '**.NET Framework Class** **Library** (**FCL**):'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Framework 类库**（**FCL**）：'
- en: The FCL is a large collection of types and APIs that implement common functionality
    – for example, user interface services, connecting to databases, networking, and
    more.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: FCL 是一个包含常见功能类型和 API 的大型集合——例如，用户界面服务、连接数据库、网络等。
- en: .NET applications can be written in C#, F#, Visual Basic, and many more, which
    are also supported on non-Windows systems such as Linux or macOS. On Windows-only
    systems, C++ can be used as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 应用程序可以使用 C#、F#、Visual Basic 等编写，这些语言也在非 Windows 系统（如 Linux 或 macOS）上受支持。在仅限
    Windows 的系统中，C++ 也可以使用。
- en: 'Once the code is written in a .NET Framework-compatible language, the code
    is compiled into a CIL and is usually stored in assemblies (**.dll** or **.exe**
    ending). To compile C# source code files, for example, .NET Framework ships its
    own compiler – **csc.exe** – which can be found on Windows 10 computers under
    CLR: **C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe**.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码用 .NET Framework 兼容的语言编写，代码会被编译成 CIL，并通常存储在程序集（**.dll** 或 **.exe** 结尾）中。例如，要编译
    C# 源代码文件，.NET Framework 会自带自己的编译器——**csc.exe**，这个编译器可以在 Windows 10 计算机上的 CLR 目录下找到：**C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe**。
- en: 'The compiler then writes the compiled CIL code as well as a manifest into a
    read-only part of the output file, which has a standard PE header (Win32-portable
    executable) and saves it as an assembly file (usually a file with an **.exe**
    ending – depends on which output format you choose):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器将编译后的 CIL 代码以及清单写入输出文件的只读部分，该部分有一个标准的 PE 头（Win32 可移植可执行文件），并将其保存为程序集文件（通常是以
    **.exe** 结尾的文件——具体取决于您选择的输出格式）：
- en: '![Figure 5.14 – How .NET Framework compiles applications](image/B16679_05_014.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – .NET 框架如何编译应用程序](image/B16679_05_014.jpg)'
- en: Figure 5.14 – How .NET Framework compiles applications
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – .NET 框架如何编译应用程序
- en: CIL code cannot be executed directly; it needs to be JIT compiled by the CLR
    into machine code first. Therefore, the CLR is needed on the system where the
    application should run.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: CIL 代码不能直接执行；它需要由 CLR 首先通过 JIT 编译成机器代码。因此，运行应用程序的系统上需要有 CLR。
- en: When the freshly compiled assembly is executed, the CLR takes the assembly and
    compiles it on the fly by using a JIT compiler. The assembly is then turned into
    machine code that can run on the architecture of the machine on which the application
    was started.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当新编译的程序集执行时，CLR 会通过使用 JIT 编译器即时编译该程序集。然后，程序集被转换为机器代码，可以在启动应用程序的机器架构上运行。
- en: .NET Framework versus .NET Core
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Framework 与 .NET Core
- en: With the rise of cross-platform and cloud-based applications, in 2016, Microsoft
    released .NET Core, a lightweight and modular version of the framework. Designed
    to run on multiple platforms including Windows, macOS, and Linux, .NET Core can
    be used to develop applications for web, desktop, mobile, gaming, and IoT.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 随着跨平台和云应用的兴起，微软在2016年发布了 .NET Core，这是一个轻量级且模块化的框架版本。设计上可以在多个平台上运行，包括 Windows、macOS
    和 Linux，.NET Core 可用于开发 Web、桌面、移动、游戏和物联网（IoT）应用。
- en: Later, **.NET Core** was renamed to **.NET**, while the Windows-specific branch
    is nowadays referred to as **.****NET Framework**.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，**.NET Core** 被更名为 **.NET**，而专为 Windows 设计的分支现在被称为 **.NET Framework**。
- en: 'In the following screenshot, we will take a closer look at the similarities
    and differences between .NET Framework and .NET:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们将更深入地了解 .NET Framework 和 .NET 之间的相似性和差异：
- en: '![Figure 5.15 – Comparing .NET and .NET Core](image/B16679_05_015.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 比较 .NET 和 .NET Core](image/B16679_05_015.jpg)'
- en: Figure 5.15 – Comparing .NET and .NET Core
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 比较 .NET 和 .NET Core
- en: Overall, .NET is a more lightweight and modular framework that is optimized
    for building modern, cloud-based, and containerized applications, whereas .NET
    Framework is a comprehensive framework that is designed for a wide range of programming
    scenarios, including large-scale enterprise applications and legacy systems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，.NET 是一个更轻量和模块化的框架，优化了构建现代、云端和容器化应用的能力，而 .NET Framework 是一个全面的框架，旨在支持广泛的编程场景，包括大规模企业应用和遗留系统。
- en: Compile C# code using .NET Framework
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET Framework 编译 C# 代码
- en: It is possible to compile C# code with .NET Framework and PowerShell by using
    the command-line compiler, **csc.exe**. This compiler is included with every installation
    of .NET Framework. Please note that the **csc.exe** compiler can run on any **.cs**
    file and does not need PowerShell for its execution. Nevertheless, we will be
    looking at how to use **csc.exe** from PowerShell in this section for completeness.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用命令行编译器 **csc.exe** 在 .NET Framework 和 PowerShell 中编译 C# 代码。此编译器随每个 .NET
    Framework 的安装一起提供。请注意，**csc.exe** 编译器可以运行任何 **.cs** 文件，并且不需要 PowerShell 执行它。然而，为了完整性，我们将在本节中介绍如何从
    PowerShell 使用 **csc.exe**。
- en: 'To compile a C# file using **csc.exe**, navigate to the directory containing
    the file and run the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **csc.exe** 编译 C# 文件，请导航到包含该文件的目录并运行以下命令：
- en: '[PRE7]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The **/out** option specifies the name of the output file, and **<input_file_name>**
    specifies the name of the C# file you want to compile. For example, to compile
    a file named **MyProgram.cs** and to generate an executable file named **MyProgram.exe**,
    run the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**/out**选项指定输出文件的名称，**<input_file_name>**指定要编译的C#文件的名称。例如，要编译名为**MyProgram.cs**的文件并生成名为**MyProgram.exe**的可执行文件，请运行以下命令：'
- en: '[PRE8]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To run the compiled executable file, simply type the name of the file into
    the PowerShell console:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行编译后的可执行文件，只需在PowerShell控制台中输入文件名：
- en: '[PRE9]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is an example of how to compile and run a simple **"Hello, World!"** program
    in C# using PowerShell:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何使用PowerShell编译和运行一个简单的**"Hello, World!"**程序：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once compiled, running **MyProgram.exe** will output **"Hello World!"** to
    the console, as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，运行**MyProgram.exe**将在控制台输出**"Hello World!"**，如下图所示：
- en: '![Figure 5.16 – Compiling C code using the csc.exe and executing it](image/B16679_05_016.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 使用csc.exe编译C代码并执行](image/B16679_05_016.jpg)'
- en: Figure 5.16 – Compiling C code using the csc.exe and executing it
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 使用csc.exe编译C代码并执行
- en: The **Out-File** cmdlet is used to write the C# code to a file named **MyProgram.cs**
    before it is compiled. This file can then be compiled using the **csc.exe** compiler,
    and the resulting executable can be run using **.\MyProgram.exe**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**Out-File** cmdlet用于在编译之前将C#代码写入名为**MyProgram.cs**的文件。然后可以使用**csc.exe**编译器编译此文件，生成的可执行文件可以使用**.\MyProgram.exe**运行。'
- en: Using Add-Type to interact with .NET directly
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Add-Type与.NET直接交互
- en: The easiest way to access the Windows API from PowerShell using .NET methods
    is by using the **Add-Type** cmdlet. By using **Add-Type**, it is possible to
    compile and run .NET code from the PowerShell command line. The **Add-Type** cmdlet
    allows you to define and create .NET Core classes within your PowerShell session.
    With this cmdlet, you can easily integrate custom objects into your PowerShell
    code and gain access to .NET Core libraries. By passing your C# code to the **-TypeDefinition**
    parameter of the **Add-Type** cmdlet, your code compiles in real time whenever
    calling your newly defined C# function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从PowerShell访问Windows API的最简单方法是使用**Add-Type** cmdlet。通过使用**Add-Type**，可以从PowerShell命令行编译并运行.NET代码。**Add-Type**
    cmdlet允许你在PowerShell会话中定义和创建.NET Core类。通过此cmdlet，你可以轻松将自定义对象集成到PowerShell代码中，并访问.NET
    Core库。通过将C#代码传递给**Add-Type** cmdlet的**-TypeDefinition**参数，调用新定义的C#函数时，你的代码将实时编译。
- en: For the following example, I have written a little C# class named **DirectoryTest**,
    which contains the **GetDirectories** function. **GetDirectories** checks whether
    the path that was passed to the function can be accessed and outputs all files
    and folders that path contains to the command line. If the path does not exist
    or is not a legitimate path, the returned output will be empty.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我编写了一个名为**DirectoryTest**的小型C#类，其中包含**GetDirectories**函数。**GetDirectories**检查传递给该函数的路径是否可访问，并将该路径包含的所有文件和文件夹输出到命令行。如果路径不存在或不是有效路径，则返回的输出将为空。
- en: 'You can find the code in the GitHub repository of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到代码：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1)。
- en: 'First, you need to create a class using C# that compiles and runs without errors.
    In my example, I first load my C# code into the **$Source** variable, which allows
    me to access it later:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用C#创建一个没有错误的类进行编译和运行。在我的示例中，我首先将C#代码加载到**$Source**变量中，这样我可以稍后访问它：
- en: '![Figure 5.17 – Storing the C# class in the source variable](image/B16679_05_017.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 将C#类存储在源变量中](image/B16679_05_017.jpg)'
- en: Figure 5.17 – Storing the C# class in the source variable
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 将C#类存储在源变量中
- en: '**Add-Type** allows you to define and use a .NET Core class in a PowerShell
    session. The .NET Core class can be either specified within a variable, as we
    are doing for this example, but it can also be specified inline or provided using
    a binary or source code file. The following screenshot shows the use of **Add-Type**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Add-Type** 允许你在 PowerShell 会话中定义并使用 .NET Core 类。这个 .NET Core 类可以像本示例中一样指定在变量内，也可以内联指定，或者通过二进制文件或源代码文件提供。以下截图展示了**Add-Type**的使用：'
- en: '![Figure 5.18 – Loading the source code into the current PowerShell session](image/B16679_05_018.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 将源代码加载到当前 PowerShell 会话](image/B16679_05_018.jpg)'
- en: Figure 5.18 – Loading the source code into the current PowerShell session
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 将源代码加载到当前 PowerShell 会话
- en: 'Now we can directly interact with the class and call the **GetDirectories**
    function using the **C:\** parameter to specify which directories of which path
    should be queried:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接与类交互，并使用 **C:\** 参数调用 **GetDirectories** 函数，指定应该查询哪些路径的目录：
- en: '![Figure 5.19 – Executing the GetDirectories function from the DirectoryTest
    class](image/B16679_05_019.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 执行 DirectoryTest 类中的 GetDirectories 函数](image/B16679_05_019.jpg)'
- en: Figure 5.19 – Executing the GetDirectories function from the DirectoryTest class
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 执行 DirectoryTest 类中的 GetDirectories 函数
- en: Et voilà – all subfolders of the **C** partition are being returned.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结果 – 所有 **C** 分区的子文件夹都被返回。
- en: Maybe you're now asking yourself, “*But why would I want to query the Windows
    API if I already have PowerShell?*” Well, there are a few reasons why you might
    prefer to use the API over PowerShell. One reason is that the API can offer low-level
    functionality that native PowerShell may not provide. Accessing raw Windows APIs
    directly through **P/Invoke** and executing unmanaged code might be another reason.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你现在在问自己，“*但是如果我已经有了 PowerShell，为什么还要查询 Windows API 呢？*” 好吧，有几个原因可能会让你倾向于使用
    API 而非 PowerShell。一个原因是，API 可以提供一些本地 PowerShell 可能无法提供的低级功能。通过 **P/Invoke** 直接访问原生
    Windows API 并执行非托管代码，可能是另一个原因。
- en: By using the API, you can create hooks (which is a technique to make code behave
    differently as originally designed by injecting custom code), intercept system
    events, manipulate system settings, monitor system resources, track user activity,
    and even manipulate the behavior of system processes, which can be useful for
    various purposes such as red teamers disabling antivirus or elevating privileges.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 API，你可以创建钩子（这是一种通过注入自定义代码使代码行为与原始设计不同的技术）、拦截系统事件、操作系统设置、监视系统资源、跟踪用户活动，甚至操控系统进程的行为，这对于各种目的都很有用，比如红队禁用防病毒软件或提升权限。
- en: 'For further information on **Add-Type**, please refer to the official **Add-Type**
    documentation: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于**Add-Type**的信息，请参考官方的**Add-Type**文档：[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type)。
- en: Loading a custom DLL from PowerShell
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 PowerShell 加载自定义 DLL
- en: There’s also a way to load a custom DLL from PowerShell when it is already compiled.
    Of course, you can also use **csc.exe** to compile your own program first.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法是在 PowerShell 中加载已编译的自定义 DLL。当然，你也可以先使用 **csc.exe** 编译你自己的程序。
- en: 'You can find the **DirectoryTest.cs** file that we are using in this example
    in this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到我们在本示例中使用的 **DirectoryTest.cs** 文件：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs)。
- en: 'We first compile the program into a DLL using **csc.exe**:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 **csc.exe** 将程序编译成 DLL：
- en: '[PRE11]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can load the compiled DLL and load it using the **[****System.Reflection.Assembly]::Load()**
    function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以加载已编译的 DLL，并使用 **[****System.Reflection.Assembly]::Load()** 函数加载它：
- en: '[PRE12]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In .NET, an assembly is basically the smallest, fundamental unit of deployment
    of an application. It is either a **.dll** or an **.exe** file. If the assembly
    is shared between applications, it is usually stored in the **Global Assembly**
    **Cache** (**GAC**).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，程序集是应用程序部署的最小基本单元。它可以是 **.dll** 文件或 **.exe** 文件。如果程序集是多个应用程序共享的，它通常存储在
    **全局程序集缓存** (**GAC**) 中。
- en: 'Once the DLL is successfully loaded, you can now access its methods from PowerShell,
    as shown in the following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 DLL 成功加载，你就可以从 PowerShell 访问它的方法，如下图所示：
- en: '![Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell](image/B16679_05_020.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 从 PowerShell 加载自定义 DLL 并访问其方法](image/B16679_05_020.jpg)'
- en: Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 从 PowerShell 加载自定义 DLL 并访问其方法
- en: 'As shown in the preceding screenshot, by using **[DirectoryTest]::GetDirectories("C:\tmp")**,
    it is possible to execute the **GetDirectories** function that was defined in
    **DirectoryTest.dll**: all folders and files that are in the specified directory
    will be written to the output.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，通过使用 **[DirectoryTest]::GetDirectories("C:\tmp")**，可以执行在 **DirectoryTest.dll**
    中定义的 **GetDirectories** 函数：所有指定目录中的文件夹和文件将写入输出。
- en: 'Similar to the **[System.Reflection.Assembly]::Load()** function, you can also
    use **Add-Type** with the **-Path** parameter to load a DLL in PowerShell:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 **[System.Reflection.Assembly]::Load()** 函数，你也可以使用 **Add-Type** 配合 **-Path**
    参数在 PowerShell 中加载 DLL：
- en: '![Figure 5.21 – Loading a DLL by using Add-Type](image/B16679_05_021.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 使用 Add-Type 加载 DLL](image/B16679_05_021.jpg)'
- en: Figure 5.21 – Loading a DLL by using Add-Type
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 使用 Add-Type 加载 DLL
- en: 'You can find the example code used in *Figure 5**.21* in the GitHub repository
    of this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的 GitHub 仓库中找到用于 *图 5.21* 的示例代码：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1)。
- en: Calling the Windows API using P/Invoke
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 P/Invoke 调用 Windows API
- en: Using the Windows API can be useful for PowerShell scripting when you want to
    call functions that are not exposed by PowerShell cmdlets or .NET classes (**unmanaged
    code**).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要调用 PowerShell cmdlet 或 .NET 类没有暴露的函数（**非托管代码**）时，使用 Windows API 对 PowerShell
    脚本编写是很有用的。
- en: 'To call a Windows API function from PowerShell, you need to do three things:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 PowerShell 调用 Windows API 函数，你需要做三件事：
- en: Declare the DLL file that contains the function using **DllImport**, specifying
    the location of the DLL.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **DllImport** 声明包含该函数的 DLL 文件，并指定 DLL 的位置。
- en: Declare the function signature (the name, parameters, return type, and calling
    convention).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明函数签名（名称、参数、返回类型和调用约定）。
- en: Invoke the function with the appropriate arguments.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的参数调用函数。
- en: 'Let’s look at how this can be done with an easy example using the **MessageBoxA**
    function from **user32.dll**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来看如何使用 **user32.dll** 中的 **MessageBoxA** 函数：
- en: '[PRE13]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we first declare the function signature for the **MessageBoxA**
    function from the **user32.dll** library using the **DllImport** attribute and
    save it in the **$signature** variable. We then add the function signature to
    the PowerShell session using the **Add-Type** cmdlet, which allows us to use the
    function in our PowerShell script.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们首先使用 **DllImport** 特性声明来自 **user32.dll** 库的 **MessageBoxA** 函数的签名，并将其保存在
    **$signature** 变量中。然后，我们使用 **Add-Type** cmdlet 将函数签名添加到 PowerShell 会话中，这样就可以在
    PowerShell 脚本中使用该函数。
- en: Finally, we call the **[Win32.User32]::MessageBoxA()** function, passing the
    appropriate arguments as specified by the function signature. In our example,
    we pass in a **null IntPtr** handle to specify that the message box should not
    have a parent window. We then specify the message string, as well as the title,
    and a **uint** value to specify the buttons and icons to display in the message
    box. In this example, **0** indicates that the message box should only have an
    **OK** button.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 **[Win32.User32]::MessageBoxA()** 函数，传入函数签名中指定的相应参数。在我们的示例中，我们传入一个 **null
    IntPtr** 句柄，以指定消息框不应具有父窗口。然后我们指定消息字符串、标题，以及一个 **uint** 值来指定在消息框中显示的按钮和图标。在这个示例中，**0**
    表示消息框应该只包含 **OK** 按钮。
- en: 'After executing, the defined message box opens and shows the message and title
    as specified:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，定义的消息框会打开，并显示指定的消息和标题：
- en: '![Figure 5.22 – Executing unmanaged code from PowerShell](image/B16679_05_022.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 从 PowerShell 执行非托管代码](image/B16679_05_022.jpg)'
- en: Figure 5.22 – Executing unmanaged code from PowerShell
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 从 PowerShell 执行非托管代码
- en: Note that when using **P/Invoke**, it’s important to ensure that the function
    signature matches the actual function in the unmanaged DLL, including the correct
    parameter types, return type, and calling convention.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用 **P/Invoke** 时，确保函数签名与非托管 DLL 中的实际函数匹配是非常重要的，包括正确的参数类型、返回类型和调用约定。
- en: In this example, we called unmanaged code from **user32.dll**, which resulted
    in opening a message box. You might ask yourself how this differentiates from
    calling the **MessageBox** function in the **System.Windows.Forms** .NET class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们调用了来自 **user32.dll** 的非托管代码，结果打开了一个消息框。你可能会问，这与调用 **System.Windows.Forms**
    .NET 类中的 **MessageBox** 函数有什么区别。
- en: Some Win32 APIs have corresponding .NET APIs that almost literally do what we
    demonstrated here (such as **System.Windows.Forms.MessageBox.Show()**), but many
    do not. By using the **P/Invoke** method demonstrated in the example, you can
    call any function defined in an unmanaged DLL from PowerShell, while the .NET
    class is limited to a specific set of functions, including **MessageBox**.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Win32 API 有对应的 .NET API，几乎完全可以实现我们在这里演示的内容（例如 **System.Windows.Forms.MessageBox.Show()**），但很多并没有。通过使用示例中演示的
    **P/Invoke** 方法，你可以从 PowerShell 调用任何在非托管 DLL 中定义的函数，而 .NET 类则仅限于一组特定的函数，包括 **MessageBox**。
- en: If you want to explore loading and executing unmanaged code further, a great
    resource is https://pinvoke.net/. It’s an invaluable resource to find and operate
    **P/Invoke** signatures, user-defined types, and other information related to
    working with unmanaged code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步探索加载和执行非托管代码，一个很好的资源是 [https://pinvoke.net/](https://pinvoke.net/)。这是一个宝贵的资源，可以帮助你查找和操作**P/Invoke**签名、用户定义类型以及与非托管代码相关的其他信息。
- en: 'For more examples of how you can use PowerShell to interact with the Windows
    API, also refer to the blog series *Use PowerShell to Interact with the Windows
    API*, *Parts 1-3*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于如何使用 PowerShell 与 Windows API 交互的示例，敬请参考博客系列 *使用 PowerShell 与 Windows API
    交互*，*第 1-3 部分*：
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/)'
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/)'
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/)'
- en: 'After exploring .NET Framework and **P/Invoke**, it’s time to focus on another
    crucial technology in the Windows operating system: the COM.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 .NET Framework 和 **P/Invoke** 后，是时候关注 Windows 操作系统中的另一项关键技术：COM。
- en: Understanding the Component Object Model (COM) and COM hijacking
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解组件对象模型（COM）和COM劫持
- en: COM is a binary standard for software componentry introduced by Microsoft in
    1993, which defines a set of rules for how software components interact with each
    other and allows inter-process communication. It was developed by Microsoft to
    address the need for interoperability between applications.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: COM 是由微软在 1993 年推出的软件组件二进制标准，它定义了一套规则，用于描述软件组件如何相互交互，并允许进程间通信。微软开发 COM 是为了应对应用程序之间的互操作性需求。
- en: COM is the basis of many other technologies, such as **OLE**, **COM+**, **DCOM**,
    **ActiveX**, **Windows User Interface**, **Windows Runtime**, and many others.
    Basically, COM is just middleware that sits between two components and allows
    them to communicate with each other.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: COM 是许多其他技术的基础，例如**OLE**、**COM+**、**DCOM**、**ActiveX**、**Windows 用户界面**、**Windows
    运行时**等。基本上，COM 只是一个中间件，位于两个组件之间，允许它们相互通信。
- en: 'One example of how COM is used can be demonstrated with how **Object Linking
    and Embedding** (**OLE**) works: if you want to include, for example, an Excel
    table in your PowerPoint presentation. Usually, to allow this, without COM, PowerPoint
    would need to have the actual code implemented that makes Excel work how it works.
    But since this would be a waste of resources and redundant code, it does not make
    sense to duplicate the same code in two applications. Rather, it makes sense to
    point to the other application to include the functionality. And this is basically
    what OLE does: it just embeds an Excel object into PowerPoint and links to the
    Excel functionality.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: COM 的使用示例可以通过 **对象链接和嵌入**（**OLE**）的工作方式来展示：例如，如果你想在 PowerPoint 演示文稿中包含一个 Excel
    表格。通常，如果没有 COM，PowerPoint 需要拥有实际的代码来实现使 Excel 工作的功能。但由于这样做会浪费资源并导致重复代码，显然没有必要在两个应用程序中复制相同的代码。更合理的做法是指向另一个应用程序以包含该功能。基本上，OLE
    就是这样做的：它将一个 Excel 对象嵌入 PowerPoint，并链接到 Excel 的功能。
- en: COM is a technology based on the **client-server model**, where a client creates
    and uses a COM component within a server to access its functionality through interfaces.
    A **COM server** provides services to other components, known as **COM clients**,
    by exposing its functionality through related *methods* and *properties* in **COM
    interfaces**. These interfaces define a standardized way for clients to access
    the functionality of objects, regardless of the implementation language. COM servers
    can be *in-process* DLLs or *out-of-process* EXEs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: COM 是一种基于 **客户端-服务器模型** 的技术，在这种模型中，客户端在服务器中创建并使用 COM 组件，通过接口访问其功能。**COM 服务器**
    通过在 **COM 接口** 中暴露相关的 *方法* 和 *属性*，为其他组件（称为 **COM 客户端**）提供服务。这些接口定义了客户端访问对象功能的标准化方式，无论实现语言如何。COM
    服务器可以是 *进程内* DLL 或 *进程外* EXE。
- en: A COM server is implemented as a **COM class**, which is a blueprint defining
    the behavior and functionality of a COM object. A COM class usually implements
    one or more interfaces and provides a set of *methods* and *properties* that clients
    can use. Each COM class is identified by a unique 128-bit **globally unique identifier**
    (**GUID**) called a **CLSID**, which the server must register. When a client requests
    an object from the server, COM uses this CLSID to locate the *DLL* or *EXE* containing
    the code that implements the class and creates an instance of the object.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: COM 服务器是作为 **COM 类** 实现的，COM 类是定义 COM 对象行为和功能的蓝图。一个 COM 类通常实现一个或多个接口，并提供一组客户端可以使用的
    *方法* 和 *属性*。每个 COM 类都有一个唯一的 128 位 **全局唯一标识符**（**GUID**），称为 **CLSID**，服务器必须注册该标识符。当客户端从服务器请求对象时，COM
    使用该 CLSID 定位包含实现该类代码的 *DLL* 或 *EXE*，并创建该对象的实例。
- en: These components can be used in PowerShell using the **New-Object** cmdlet,
    which allows you to instantiate COM objects and interact with them using their
    methods and properties.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件可以通过 PowerShell 中的 **New-Object** cmdlet 使用，允许你实例化 COM 对象并通过其方法和属性与之交互。
- en: 'In the following example, we use the **New-Object** cmdlet to create an instance
    of the **Excel.Application** COM object, which provides access to the Excel application
    and its functionality. We then use the instantiated object to create a new workbook,
    add a new worksheet, and write the string **"Hello world!"** to cell A1\. Finally,
    we save the workbook and quit the Excel application:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 **New-Object** cmdlet 创建 **Excel.Application** COM 对象的实例，该对象提供对
    Excel 应用程序及其功能的访问。然后，我们使用实例化的对象创建一个新工作簿，添加一个新工作表，并将字符串 **"Hello world!"** 写入单元格
    A1。最后，我们保存工作簿并退出 Excel 应用程序：
- en: '[PRE14]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that in order to use the Excel COM object, you need to have Excel installed
    on your computer. The Excel COM object provides a large number of methods and
    properties, so there’s a lot you can do with it beyond the preceding simple example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使用 Excel COM 对象，你需要在计算机上安装 Excel。Excel COM 对象提供了大量的方法和属性，因此你可以做的不仅仅是前面的简单示例。
- en: It is also possible to use PowerShell to interact with COM components on remote
    machines using **Distributed COM** (**DCOM**). DCOM enables a client to connect
    to a COM component running on a remote machine and use its functionality as if
    it were on the local machine.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 PowerShell 与远程机器上的 COM 组件交互，使用 **分布式 COM**（**DCOM**）。DCOM 使客户端能够连接到运行在远程机器上的
    COM 组件，并像在本地机器上一样使用其功能。
- en: While COM provides a powerful framework for software components to communicate
    and interoperate, it also provides clear advantages to adversaries, including
    the fact that they don’t need to worry about network or security settings such
    as proxy or firewall rules. In most cases, everything is already set up for **Internet
    Explorer** (**IE**). Additionally, IE can be fully automated and instrumented
    to perform various actions such as navigating to a specific URL, downloading a
    file, or interacting with the form fields of an HTML document. Everything can
    also be easily hidden from the user, as a newly created IE window is invisible
    by default, and if the browser was already executed and has already been loaded
    into memory, one additional instance is relatively unsuspicious. For adversaries,
    COM opens up the potential for abuse and exploitation, as in the case of **COM
    hijacking**.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 COM 为软件组件之间的通信和互操作提供了强大的框架，但它也为对手提供了明显的优势，包括他们无需担心网络或安全设置，如代理或防火墙规则。在大多数情况下，所有设置已经为
    **Internet Explorer**（**IE**）准备好。此外，IE 可以完全自动化并仪器化，执行各种操作，如导航到特定 URL、下载文件或与 HTML
    文档的表单字段交互。所有内容也可以轻松地隐藏于用户之外，因为新创建的 IE 窗口默认是不可见的，如果浏览器已经执行并加载到内存中，再启动一个实例也不会引起怀疑。对于对手来说，COM
    打开了滥用和利用的潜力，就像 **COM 劫持** 一样。
- en: COM hijacking
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COM 劫持
- en: Shared libraries such as DLLs allow multiple applications to share common code
    without duplicating it in memory, which reduces memory usage and prevents code
    duplication. Without shared libraries, each application would need to bring its
    own libraries, making programs larger and more memory-intensive. But this can
    also cause problems such as **DLL hell**, where different versions of the DLL
    are installed or used by different applications, leading to problems such as crashes
    or security issues.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库，如 DLL，允许多个应用程序共享公共代码，而无需在内存中重复加载，从而减少内存使用并防止代码重复。如果没有共享库，每个应用程序都需要携带自己的库，这会使程序变得更大、更占内存。但这也可能引发问题，例如
    **DLL 地狱**，即不同版本的 DLL 被不同的应用程序安装或使用，导致崩溃或安全问题等。
- en: COM solves DLL hell by using versioning. Each component has a unique identifier
    (CLSID) and a version identifier (**ProgID**), and each version is installed in
    a separate directory and registered in the Windows Registry. This allows multiple
    versions to coexist without conflicts.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: COM 通过使用版本控制来解决 DLL 地狱问题。每个组件都有一个唯一标识符（CLSID）和一个版本标识符（**ProgID**），每个版本都安装在一个单独的目录中并注册到
    Windows 注册表中。这允许多个版本共存而不会发生冲突。
- en: But this versioning mechanism can also be exploited for COM hijacking. In this
    attack, an adversary first locates a CLSID that is used by another process but
    is not registered yet. They create a malicious DLL and place it on the victim
    system. Then, they create a registry key that links the CLSID to the malicious
    DLL. As the registry key is created in HKCU, there are not even administrator
    rights needed for this operation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种版本机制也可能被用来进行 COM 劫持。在这种攻击中，攻击者首先定位到一个由另一个进程使用但尚未注册的 CLSID。他们创建一个恶意的 DLL
    并将其放置到受害者系统上。然后，他们创建一个注册表项，将 CLSID 链接到恶意 DLL。由于该注册表项是创建在 HKCU 中，因此此操作甚至不需要管理员权限。
- en: 'In the COM programming model, every interface implementation is required to
    include three fundamental methods: **QueryInterface**, **AddRef**, and **Release**.
    These methods are provided through the **IUnknown** interface, which is the base
    interface that all COM interfaces inherit from. The implementation of the **IUnknown**
    interface is mandatory for all COM objects.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 COM 编程模型中，每个接口实现都要求包括三个基本方法：**QueryInterface**、**AddRef** 和 **Release**。这些方法通过
    **IUnknown** 接口提供，而 **IUnknown** 接口是所有 COM 接口继承的基础接口。所有 COM 对象都必须实现 **IUnknown**
    接口。
- en: '**AddRef** is used to increment the reference count of an object when a client
    is using it, and **Release** is used to decrement the reference count when the
    client is done with the object.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddRef** 用于在客户端使用对象时增加对象的引用计数，**Release** 用于在客户端完成对对象的使用时减少引用计数。'
- en: '**QueryInterface** obtains a pointer to a different interface that is supported
    by the COM object. In a COM hijacking attack, the attacker’s malicious DLL must
    implement the same interfaces as the legitimate COM component it is impersonating,
    including the **IUnknown** interface and any other supported interfaces.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**QueryInterface** 用于获取指向 COM 对象支持的不同接口的指针。在 COM 劫持攻击中，攻击者的恶意 DLL 必须实现与其冒充的合法
    COM 组件相同的接口，包括 **IUnknown** 接口和任何其他支持的接口。'
- en: When a legitimate application tries to instantiate the COM object (that pointed
    formerly to an abandoned key) and queries the **IUnknown** interface of the malicious
    DLL file, the **QueryInterface** method returns the pointers to the other interfaces
    that were implemented by the malicious DLL file, enabling the attacker to take
    control of the victim application. By knowing which exports a DLL provides, an
    attacker can better plan their attack and identify the specific COM object they
    want to target.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当合法应用程序尝试实例化 COM 对象（该对象曾指向一个被废弃的键），并查询恶意 DLL 文件的 **IUnknown** 接口时，**QueryInterface**
    方法会返回恶意 DLL 文件实现的其他接口的指针，从而使攻击者能够控制受害者的应用程序。通过了解 DLL 提供的导出函数，攻击者可以更好地计划其攻击并确定其要攻击的特定
    COM 对象。
- en: 'First, we need to identify which COM servers are missing CLSIDs and don’t require
    elevated privileges (HKCU). **Process Monitor** (**procmon**), which is part of
    the **SysInternals** suite, can help us achieve this goal. You can download it
    from here: [https://learn.microsoft.com/en-us/sysinternals/downloads/procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要识别哪些 COM 服务器缺少 CLSID 并且不需要提升权限（HKCU）。**Process Monitor**（**procmon**）是
    **SysInternals** 套件的一部分，可以帮助我们实现这一目标。你可以从这里下载它：[https://learn.microsoft.com/en-us/sysinternals/downloads/procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)。
- en: 'There are several registry keys that we can use to audit for stale CLSIDs:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个注册表键来审计过期的 CLSID：
- en: '**InprocServer**/**InprocServer32**: This key specifies the path to the DLL
    that implements the in-process server. This is what we are using in this example.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InprocServer**/**InprocServer32**：此键指定实现进程内服务器的 DLL 的路径。这是我们在本例中使用的。'
- en: '**LocalServer**/**LocalServer32**: This key defines the complete path to a
    local COM server application, regardless of its bitness or architecture.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LocalServer**/**LocalServer32**：此键定义本地 COM 服务器应用程序的完整路径，不论其位数或架构如何。'
- en: '**TreatAs**: This registry key specifies the CLSID of a class capable of emulating
    the current class.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TreatAs**：此注册表项指定能够模拟当前类的类的 CLSID。'
- en: '**ProgID**: This key represents a human-readable string for a COM object to
    represent an underlying CLSID, making it easier for applications to reference
    a COM object.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProgID**：此键表示 COM 对象的可读字符串，代表底层的 CLSID，使应用程序更容易引用 COM 对象。'
- en: 'As we are looking for a stale **InprocServer32** CLSID that can be accessed
    and changed by the current user, we are looking for unused but registered CLSIDs
    within the HKCU using the following filter parameters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找一个可以被当前用户访问和更改的过期 **InprocServer32** CLSID，我们正在使用以下过滤器参数在 HKCU 中查找未使用但已注册的
    CLSID：
- en: '**Include**: **Operation** | **is** | **RegOpenKey**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：**操作** | **是** | **RegOpenKey**'
- en: '**Include**: **Result** | **is** | **NAME** **NOT FOUND**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：**结果** | **是** | **未找到名称**'
- en: '**Include**: **Path** | **ends with** | **InprocServer32**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：**路径** | **以...结尾** | **InprocServer32**'
- en: '**Exclude**: **Path** | **begins with** | **HKLM**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除**：**路径** | **以...开头** | **HKLM**'
- en: Note that in this example, we are using a stale **InprocServer32** CLSID, but
    COM hijacking would also be possible by abusing **InprocServer**, **LocalServer**,
    **LocalServer32**, **TreatAs**, or **ProgId**, or by replacing an existing COM
    object.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，我们使用的是一个过期的 **InprocServer32** CLSID，但通过滥用 **InprocServer**、**LocalServer**、**LocalServer32**、**TreatAs**
    或 **ProgId**，或者替换现有的 COM 对象，也有可能进行 COM 劫持。
- en: 'The following screenshot shows how this Process Monitor filter is configured:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何配置这个 Process Monitor 过滤器：
- en: '![Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive](image/B16679_05_023.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – 在 HKCU Hive 中过滤过期的 CLSID](image/B16679_05_023.jpg)'
- en: Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 在 HKCU Hive 中过滤过期的 CLSID
- en: Capture the events for some time (for example, 5 minutes) to make sure that
    common activities are captured.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获一些时间的事件（例如，5 分钟），确保常见活动被捕获。
- en: '![Figure 5.24 – Capturing stale CLSIDs](image/B16679_05_024.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24 – 捕获过期 CLSID](image/B16679_05_024.jpg)'
- en: Figure 5.24 – Capturing stale CLSIDs
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 捕获过期 CLSID
- en: Now, you can examine the captured CLSIDs and find the one(s) that you want to
    use in your COM hijacking demo. In this example, we are using **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}**,
    which was queried by **Explorer.exe**.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以检查捕获的 CLSID，并找到你在 COM 劫持演示中想要使用的 CLSID。在本例中，我们使用的是 **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}**，它是由
    **Explorer.exe** 查询的。
- en: We then create a **.dll** file, **COMHijack.dll**. You can find the code to
    compile the file in the GitHub repository under [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个 **.dll** 文件，**COMHijack.dll**。你可以在 GitHub 仓库中找到编译该文件的代码，链接为 [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp)。
- en: This code defines a Windows DLL that runs a new process to launch the Windows
    calculator, **calc.exe**, when it is loaded into memory. The DLL main function
    sets up a **switch** statement to handle different reasons for the DLL being loaded,
    and in the **DLL_PROCESS_ATTACH** case, it calls the **CallCalculator** function,
    which creates a new process to run the Windows calculator.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个 Windows DLL，当它被加载到内存中时，运行一个新进程来启动 Windows 计算器 **calc.exe**。DLL 的主函数设置了一个
    **switch** 语句来处理 DLL 被加载的不同原因，在 **DLL_PROCESS_ATTACH** 情况下，它调用 **CallCalculator**
    函数，后者创建一个新进程来运行 Windows 计算器。
- en: 'We compile **COMHijack.dll** and place it under **${Env:\TEMP}**. Then, we
    create a new registry key for **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}\InprocSServer32**
    and set the value of the default property to the location where **COMHijack.dll**
    was placed earlier:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译 **COMHijack.dll** 并将其放置在 **${Env:\TEMP}** 下。然后，我们为 **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}\InprocSServer32**
    创建一个新的注册表项，并将默认属性的值设置为之前放置 **COMHijack.dll** 的位置：
- en: '[PRE15]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And now, whenever **Explorer.exe** is opened, **calc.exe** will start as well.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当 **Explorer.exe** 被打开时，**calc.exe** 也会随之启动。
- en: This is, of course, not the only way for COM hijacking; there are many more
    options to explore. If you want to learn more about COM hijacking, I highly recommend
    looking into the links on COM hijacking in the *Further reading* section of this
    chapter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是 COM 劫持的唯一方式；还有很多其他选项可以探索。如果你想了解更多关于 COM 劫持的内容，我强烈推荐查阅本章 *进一步阅读* 部分的
    COM 劫持链接。
- en: Another important component in the Windows operating system is the WMI. This
    component can be leveraged by both attackers and defenders – let’s explore it
    in the next section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统中的另一个重要组件是 WMI。这个组件可以被攻击者和防御者利用——我们将在下一节中探讨它。
- en: Common Information Model (CIM)/WMI
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用信息模型（CIM）/WMI
- en: We already learned in [*Chapter 3*](B16679_03_Final_PD.xhtml#_idTextAnchor064),
    *Exploring PowerShell Remote Management Technologies and PowerShell Remoting*,
    that WMI is Microsoft’s implementation of the **CIM**, and how to use WMI- or
    CIM-related PowerShell cmdlets.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 3 章*](B16679_03_Final_PD.xhtml#_idTextAnchor064)《探索 PowerShell 远程管理技术与
    PowerShell 远程管理》一章中，已经学过 WMI 是微软的 **CIM** 实现，以及如何使用与 WMI 或 CIM 相关的 PowerShell
    cmdlet。
- en: In this chapter, we are exploring WMI a little bit further in the system context.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨 WMI 在系统环境中的应用。
- en: WMI is not a new technology, and WMI attacks are not a new attack vector. WMI
    only produces a small forensic footprint, runs in memory only, and is a great
    way to evade whitelisting as well as host-based security tools. Therefore, WMI
    has been weaponized in attacks in recent years like never before.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 不是一种新技术，WMI 攻击也不是一种新的攻击向量。WMI 只会留下很小的取证痕迹，仅在内存中运行，是规避白名单和主机安全工具的绝佳方式。因此，WMI
    在近年来的攻击中被武器化，前所未有。
- en: In general, applications such as PowerShell, .NET, C/C++, VBScript, and many
    more can access WMI through the WMI API. The **CIM Object Manager** (**CIMOM**)
    then manages the access between each WMI component. The communication relies on
    COM/DCOM.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，像 PowerShell、.NET、C/C++、VBScript 等应用程序可以通过 WMI API 访问 WMI。**CIM 对象管理器**（**CIMOM**）则管理每个
    WMI 组件之间的访问。通信依赖于 COM/DCOM。
- en: 'The following figure demonstrates the architecture of WMI:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了 WMI 的架构：
- en: '![Figure 5.25 – WMI architecture](image/B16679_05_025.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – WMI 架构](image/B16679_05_025.jpg)'
- en: Figure 5.25 – WMI architecture
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – WMI 架构
- en: The **WMI consumer** (or the managing application) connects using the WMI API
    to the WMI infrastructure and the WMI service (**Winmgmt**). In this case, we
    are looking at PowerShell as the only management application, but of course, there
    are also other possibilities, such as **wmic.exe**.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**WMI 消费者**（或管理应用程序）通过 WMI API 连接到 WMI 基础架构和 WMI 服务（**Winmgmt**）。在这种情况下，我们将
    PowerShell 作为唯一的管理应用程序，但当然，也有其他选择，例如 **wmic.exe**。'
- en: The **WMI infrastructure** acts as a mediator between the consumer, the providers,
    and managed objects. It consists of the CIM Core and the CIM repository. The WMI
    infrastructure is what keeps and connects everything within WMI together.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**WMI 基础设施** 充当消费者、提供程序和托管对象之间的中介。它由 CIM 核心和 CIM 仓库组成。WMI 基础设施是保持并连接 WMI 中所有内容的关键。'
- en: It supports various APIs, such as the **WMI COM API**, through which consumers
    can access WMI providers through the WMI infrastructure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持各种 API，例如 **WMI COM API**，通过这些 API，消费者可以通过 WMI 基础设施访问 WMI 提供程序。
- en: The CIM repository is a database that stores static information and is organized
    within **namespaces**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: CIM 仓库是一个存储静态信息的数据库，并且组织在 **命名空间** 中。
- en: Namespaces
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace is a logical database whose purpose is to basically group sets of
    classes and instances that are related to a certain managed environment. A good
    example is the Registry provider, which groups all WMI classes and providers to
    operate the Windows Registry.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个逻辑数据库，其目的是将与特定管理环境相关的类和实例分组。一个好的例子是注册表提供程序，它将所有 WMI 类和提供程序分组以操作 Windows
    注册表。
- en: 'The namespace root directory is called **ROOT**. Within all WMI installations,
    there are always the four *default* WMI namespaces underneath **ROOT**: **CIMV2**,
    **Default**, **Security**, and **WMI**. Some of them have their own sub-namespaces.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的根目录称为 **ROOT**。在所有 WMI 安装中，**ROOT** 下总是有四个 *默认* 的 WMI 命名空间：**CIMV2**、**Default**、**Security**
    和 **WMI**。其中一些命名空间还有自己的子命名空间。
- en: The **ROOT/cimv2** namespace is the most interesting namespace, as almost all
    interesting CIM classes are stored in this namespace. If you query all classes
    using **Get-CimClass** without specifying a namespace, **ROOT/cimv2** is queried
    by default.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROOT/cimv2** 命名空间是最有趣的命名空间，因为几乎所有有趣的 CIM 类都存储在此命名空间中。如果你使用 **Get-CimClass**
    查询所有类而不指定命名空间，默认会查询 **ROOT/cimv2**。'
- en: 'Some providers also define their own namespaces. This has the benefit for the
    developers that they don’t need to seek the permission of the owner of the namespace
    and can get rid of other restricting constraints as well:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一些提供程序还定义了他们自己的命名空间。对于开发者来说，这样的好处是他们不需要寻求命名空间所有者的许可，并且可以摆脱其他限制性约束：
- en: '![Figure 5.26 – Overview of some common namespaces](image/B16679_05_026.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26 – 一些常见命名空间的概览](image/B16679_05_026.jpg)'
- en: Figure 5.26 – Overview of some common namespaces
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.26 – 一些常见命名空间的概览
- en: 'Using the old WMI cmdlets, it was possible to enumerate all namespaces using
    the **-****Recurse** parameter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旧的 WMI cmdlet 时，可以使用 **-****Recurse** 参数枚举所有命名空间：
- en: '[PRE16]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But let’s look at how you can perform operations using the new CIM cmdlets,
    which are also supported within PowerShell Core – the WMI cmdlets are not supported
    anymore.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们看看如何使用新的 CIM cmdlet 执行操作，这些 cmdlet 也在 PowerShell Core 中得到支持——不再支持 WMI cmdlet。
- en: 'To search one namespace, you can use **Get-CimInstance**:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索一个命名空间，你可以使用 **Get-CimInstance**：
- en: '[PRE17]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, searching recursively is not possible using **Get-CimInstance**; this
    cmdlet does not offer a **-recurse** parameter. To search recursively using **Get-CimInstance**,
    I have written a little function, which you can find in the GitHub repository
    of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 **Get-CimInstance** 不能递归搜索；该 cmdlet 不提供 **-recurse** 参数。为了使用 **Get-CimInstance**
    递归搜索，我编写了一个小函数，你可以在本书的 GitHub 仓库中找到它：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1)。
- en: 'After loading the function, you can use it by calling it by its name, **Get-CimNamespace**.
    Using the **-recurse** parameter lets you query recursively, as shown in the following
    screenshot:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 加载函数后，你可以通过其名称 **Get-CimNamespace** 调用它。使用 **-recurse** 参数可以递归查询，如下图所示：
- en: '![Figure 5.27 – Querying all present namespaces recursively](image/B16679_05_027.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27 – 递归查询所有现有命名空间](image/B16679_05_027.jpg)'
- en: Figure 5.27 – Querying all present namespaces recursively
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.27 – 递归查询所有现有命名空间
- en: A namespace cannot work on its own; there’s always a managed object, managed
    by its **provider**, that’s registered to a namespace.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命名空间不能单独工作；总是有一个由其 **提供程序** 管理的托管对象，并且该对象注册到命名空间中。
- en: Providers
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供程序
- en: A provider is the interface between WMI and a managed object. It acts on behalf
    of the managing application, supplies the CIMOM with data from the managed object,
    and generates event notifications.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者是WMI和托管对象之间的接口。它代表管理应用程序，向CIMOM提供托管对象的数据，并生成事件通知。
- en: 'A provider usually consists of the following classifications: classes, events,
    event consumers, instances, methods, and properties.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者通常包括以下分类：类、事件、事件消费者、实例、方法和属性。
- en: Classes
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: Classes define and represent the general parameters of **managed objects**,
    which are provided by a provider. Usually, they are defined in a **Managed Object**
    **Format** (**MOF**).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义并表示**托管对象**的一般参数，这些对象由提供者提供。通常，它们在**托管对象格式**（**MOF**）中定义。
- en: If you remember [*Chap**ter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016)*,
    Getting Started with PowerShell*, we also talked about classes in this chapter.
    But in this context, a class is specific to WMI/CIM.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[*第1章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)《PowerShell入门》，我们在这一章中也讨论了类。但在这个上下文中，类是特定于WMI/CIM的。
- en: 'Using the **Get-CimClass** cmdlet helps you to list all available classes in
    a specific namespace or to get more information about a certain class using the
    **-ClassName** parameter, as shown in the following screenshot:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Get-CimClass** cmdlet可以帮助你列出特定命名空间中的所有可用类，或者通过**-ClassName**参数获取有关某个类的更多信息，如下截图所示：
- en: '![Figure 5.28 – Retrieving a CIM class in PowerShell Core](image/B16679_05_028.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28 – 在PowerShell Core中检索CIM类](image/B16679_05_028.jpg)'
- en: Figure 5.28 – Retrieving a CIM class in PowerShell Core
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 在PowerShell Core中检索CIM类
- en: 'By using the old **Get-WMIObject** cmdlet, you can query the **meta_class**
    table to get the same information as you did with **Get-CimClass**, as shown in
    the following screenshot:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旧版**Get-WMIObject** cmdlet，你可以查询**meta_class**表，以获取与**Get-CimClass**相同的信息，如下截图所示：
- en: '![Figure 5.29 – Retrieving a WMI class in Windows PowerShell](image/B16679_05_029.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29 – 在Windows PowerShell中检索WMI类](image/B16679_05_029.jpg)'
- en: Figure 5.29 – Retrieving a WMI class in Windows PowerShell
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 在Windows PowerShell中检索WMI类
- en: 'Every class also defines methods and properties, which are similar to our example
    of object-oriented programming from [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016)*,
    Getting Started with PowerShell*, but specific to CIM/WMI:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类还定义了方法和属性，这与我们在[*第1章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)《PowerShell入门》中讲解的面向对象编程的示例相似，但更具体地涉及CIM/WMI：
- en: '**Methods**: They define how we can interact with an object:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：它们定义了我们如何与对象进行交互：'
- en: '[PRE18]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Properties**: They allow us to define an object in more detail, such as the
    build number or version number:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：它们允许我们更详细地定义一个对象，如构建号或版本号：'
- en: '[PRE19]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In every namespace, you can find predefined classes, the **WMI system classes**.
    System classes are used to support WMI with activities such as event notification,
    event and provider registration, and various security tasks.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个命名空间中，你都可以找到预定义的类，即**WMI系统类**。系统类用于支持WMI的活动，如事件通知、事件和提供者注册以及各种安全任务。
- en: 'Compared to classes that are defined by a provider, system classes are not
    defined in MOF. You can find an overview of all predefined system classes in the
    official documentation: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 与由提供者定义的类相比，系统类没有在MOF中定义。你可以在官方文档中找到所有预定义系统类的概述：[https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes)。
- en: Instance
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例
- en: We discussed in [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting
    Started with PowerShell*, that an **object** is an **instance** of a **class**
    that contains **properties** and **methods**. Similarly, a **CIM instance** is
    a unique, individual **object** that contains **properties** and **methods** defined
    by a **CIM class**.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第1章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)《PowerShell入门》中讨论过，**对象**是包含**属性**和**方法**的**类实例**。类似地，**CIM实例**是一个独特的、单独的**对象**，它包含由**CIM类**定义的**属性**和**方法**。
- en: 'By using the **Get-CimInstance** cmdlet, you can query a specified CIM instance
    by specifying the **-Class** parameter. The following screenshot demonstrates
    how to query the **Win32_OperatingSystem** class:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Get-CimInstance** cmdlet，你可以通过指定**-Class**参数来查询指定的CIM实例。以下截图演示了如何查询**Win32_OperatingSystem**类：
- en: '![Figure 5.30 – Retrieving a CIM instance in PowerShell Core](image/B16679_05_030.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30 – 在 PowerShell Core 中检索 CIM 实例](image/B16679_05_030.jpg)'
- en: Figure 5.30 – Retrieving a CIM instance in PowerShell Core
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 在 PowerShell Core 中检索 CIM 实例
- en: 'Alternatively, you can also query WMI using the **-Query** parameter, as shown
    in the following example:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用**-Query**参数查询 WMI，如下例所示：
- en: '![Figure 5.31 – Retrieving a CIM instance using a query](image/B16679_05_031.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31 – 使用查询检索 CIM 实例](image/B16679_05_031.jpg)'
- en: Figure 5.31 – Retrieving a CIM instance using a query
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 使用查询检索 CIM 实例
- en: 'If you compare the output with the output of the CIM classes, you can quickly
    spot the difference between a class and an instance: the class defines the instance,
    and the instance contains the values that are specific to the current system.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将输出与 CIM 类的输出进行比较，您可以快速发现类和实例之间的区别：类定义实例，而实例包含特定于当前系统的值。
- en: Event
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are generated by specific actions that occur on a system. While not
    all actions generate events, many important system activities do result in an
    event being raised and recorded in the event log. CIM contains its own event infrastructure:
    whenever changes happen in data or services, notifications are generated.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是由系统上发生的特定操作生成的。虽然并非所有操作都会生成事件，但许多重要的系统活动确实会导致事件被触发并记录在事件日志中。CIM 包含自己的事件基础设施：每当数据或服务发生变化时，都会生成通知。
- en: Intrinsic events
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内在事件
- en: Intrinsic events are related to WMI/CIM itself, such as a new CIM instance being
    created or when changes in the WMI/CIM infrastructure occur. These changes can
    trigger an intrinsic event.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 内在事件与 WMI/CIM 本身相关，例如创建新的 CIM 实例或 WMI/CIM 基础设施发生变化时。这些变化可以触发内在事件。
- en: 'You can find examples of intrinsic event classes using **(Get-CimClass -ClassName
    "*Event").CimSystemProperties | Where-Object {$_.ClassName -like "__*"}**, as
    depicted in the following screenshot:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**(Get-CimClass -ClassName "*Event").CimSystemProperties | Where-Object
    {$_.ClassName -like "__*"}**找到内在事件类的示例，如下截图所示：
- en: '![Figure 5.32 – Querying intrinsic event classes](image/B16679_05_032.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.32 – 查询内在事件类](image/B16679_05_032.jpg)'
- en: Figure 5.32 – Querying intrinsic event classes
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – 查询内在事件类
- en: Everything within WMI/CIM is represented as an object, therefore every event
    is also represented as an object and has its own class. This behavior is similar
    to extrinsic WMI events.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WMI/CIM 中的一切都表示为对象，因此每个事件也表示为对象，并且有自己的类。这种行为类似于外在 WMI 事件。
- en: Extrinsic events
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外在事件
- en: Extrinsic events are generated by WMI providers in response to a change in the
    system state, such as the installation of new software or the modification of
    a system setting. For example, if the operating system is rebooted or if a registry
    key is changed, these events can be used by a provider to generate a WMI/CIM event.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 外在事件是由 WMI 提供程序响应系统状态变化而生成的，例如安装新软件或修改系统设置。例如，如果操作系统重新启动或更改注册表键，则提供程序可以使用这些事件生成
    WMI/CIM 事件。
- en: 'Examples of extrinsic event classes can be found using **(Get-CimClass).CimSystemProperties
    | Where-Object {($_.ClassName -notlike "__*") -and (($_.ClassName -like "*Event")
    -or ($_.ClassName -like "*Trace"))}**, as depicted in the following screenshot:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**(Get-CimClass).CimSystemProperties | Where-Object {($_.ClassName -notlike
    "__*") -and (($_.ClassName -like "*Event") -or ($_.ClassName -like "*Trace"))}**可以找到外在事件类的示例，如下截图所示：
- en: '![Figure 5.33 – Querying extrinsic event classes](image/B16679_05_033.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.33 – 查询外在事件类](image/B16679_05_033.jpg)'
- en: Figure 5.33 – Querying extrinsic event classes
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33 – 查询外在事件类
- en: A query like this helps in discovering event classes that can be used to monitor
    system changes. For instance, you can use these classes to create a script that
    creates a new event log entry when an event of interest is triggered.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的查询有助于发现可用于监视系统变化的事件类。例如，您可以使用这些类创建一个脚本，在触发感兴趣的事件时创建一个新的事件日志条目。
- en: Event consumer
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件消费者
- en: To support event notifications, event consumers can be used within a provider
    to map a physical consumer to a logical consumer. Consumers define what actions
    should be triggered if a certain change occurred.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持事件通知，事件消费者可以在提供程序内使用，将物理消费者映射到逻辑消费者。消费者定义了如果发生某种变化应触发什么操作。
- en: Events subscriptions
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件订阅
- en: Monitoring WMI/CIM events can help you, as a blue teamer, to detect changes
    that occurred on an operating system, but can also help red teamers who base their
    attacks on certain actions.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 监控WMI/CIM事件可以帮助你作为蓝队成员检测操作系统中发生的变化，同时也能帮助基于某些行为进行攻击的红队成员。
- en: When working with WMI/CIM events for the first time, it might quickly feel overwhelming.
    To help you to better understand, let’s look first at the basic steps in a simplified
    way
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次处理WMI/CIM事件时，可能会感到有些不知所措。为了帮助你更好地理解，我们首先以简化的方式查看基本步骤。
- en: '**Create a WMI Query Language (WQL) query**: Similar to querying data from
    WMI/CIM, you also need to create a query for the event subscription.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建WMI查询语言（WQL）查询**：与查询WMI/CIM数据类似，你还需要为事件订阅创建查询。'
- en: '**Create an event filter**: Once you have created a WQL query, you will need
    to create a filter, which then registers the query in CIM.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建事件过滤器**：一旦你创建了一个WQL查询，就需要创建一个过滤器，然后将查询注册到CIM中。'
- en: '**Create a consumer**: The consumer defines what action should be taken if
    an event filter returns that a change in a class occurred.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建消费者**：消费者定义了当事件过滤器返回类发生变化时应采取的行动。'
- en: '**Bind the event filter to the consumer**: With this last step, we make the
    WMI/CIM event subscription work. By performing this step, the consumer will be
    notified every time the event filter received a match.'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将事件过滤器绑定到消费者**：通过这最后一步，我们使WMI/CIM事件订阅生效。执行这一步骤后，每次事件过滤器收到匹配时，消费者将会收到通知。'
- en: Creating a WQL query
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建WQL查询
- en: 'In the earlier *Classes* section, you learned that predefined system classes
    exist for different purposes. When it comes to WMI/CIM events, the following four
    system classes might be the most interesting for you:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的*类*部分中，你已经了解了不同目的的预定义系统类。当涉及到WMI/CIM事件时，以下四个系统类可能对你最有兴趣：
- en: '**InstanceCreationEvent**: Checks whether a new instance was created. For example,
    you can check whether a new process was created.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InstanceCreationEvent**：检查是否创建了新实例。例如，你可以检查是否创建了新进程。'
- en: '**InstanceDeletionEvent**: Checks whether an instance was deleted. For example,
    you can check whether a process was terminated.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InstanceDeletionEvent**：检查是否删除了实例。例如，你可以检查进程是否被终止。'
- en: '**InstanceModificationEvent**: Checks whether an instance was modified. For
    example, you can check whether a registry key was modified.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InstanceModificationEvent**：检查实例是否被修改。例如，你可以检查注册表键是否被修改。'
- en: '**InstanceOperationEvent**: Checks for all three types of events – whether
    an instance was created, deleted, or modified.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InstanceOperationEvent**：检查所有三种类型的事件——实例是否被创建、删除或修改。'
- en: 'The following is an example of a WQL event subscription query. It will trigger
    if a Windows service was terminated:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个WQL事件订阅查询的例子。如果Windows服务被终止，它将被触发：
- en: '[PRE20]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using this example, you can get a brief understanding of what such a query
    would look like:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个例子，你可以简要理解这样的查询是什么样的：
- en: '![Figure 5.34 – The structure of a WQL event subscription query](image/B16679_05_034.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.34 – WQL事件订阅查询的结构](image/B16679_05_034.jpg)'
- en: Figure 5.34 – The structure of a WQL event subscription query
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34 – WQL事件订阅查询的结构
- en: The first part specifies where to look – in this case, **InstanceDeletionEvents**.
    The checking cycle specifies the polling interval in seconds of this query, indicated
    by the keyword **within**. In this example, the query runs every 15 seconds.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分指定了查询的对象——在这种情况下是**InstanceDeletionEvents**。检查周期指定了此查询的轮询间隔（以秒为单位），由关键字**within**指示。在这个例子中，查询每15秒运行一次。
- en: In an event subscription query, conditions are not mandatory, but they can be
    useful in specifying and narrowing down the results. Conditions are indicated
    by **where**, similar to regular WQL or SQL queries.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件订阅查询中，条件不是必须的，但它们可以帮助你指定和缩小结果范围。条件通过**where**表示，类似于常规的WQL或SQL查询。
- en: 'It is also possible to specify multiple conditions, which are attached to the
    query by using **AND** or **OR**. If we, for example, want to check and act on
    the event that Microsoft Defender was terminated, the query would look like the
    following:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以指定多个条件，这些条件通过使用**AND**或**OR**与查询关联。例如，如果我们想检查并处理微软防御者被终止的事件，查询将如下所示：
- en: '[PRE21]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In summary, using conditions in event subscription queries can help narrow down
    the results and enable targeted actions to be taken in response to specific events.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在事件订阅查询中使用条件可以帮助缩小结果范围，并使你能够对特定事件采取有针对性的行动。
- en: Creating an event filter
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建事件过滤器
- en: Now it’s time to create our event filter. This can be done by using the **New-CimInstance**
    cmdlet, which creates a new instance of the **__EventFilter** CIM class.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建我们的事件筛选器的时候了。这可以通过使用**New-CimInstance** cmdlet 来完成，创建一个新的**__EventFilter**
    CIM 类实例。
- en: 'Let’s use the WQL query that we just created and use it to create an event
    filter, as in the following example:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用刚刚创建的 WQL 查询，并使用它创建一个事件筛选器，如下例所示：
- en: '[PRE22]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To create an event filter, we need to define the properties, which is done in
    the **$CimEventDefenderFilter** hashtable. The instance is given the name **MicrosoftDefenderFilter**
    via the **Name** parameter. The query created earlier is assigned to the **$query**
    variable and then passed to the **$CimEventDefenderFilter** property’s **Query**
    parameter. The **QueryLanguage** parameter is set to **WQL** to indicate that
    the query is written in the WMI Query Language. Finally, the **EventNamespace**
    parameter specifies the namespace where the event filter will be registered, which,
    in this case, is **\root\cimv2**.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建事件筛选器，我们需要定义属性，这在**$CimEventDefenderFilter**哈希表中完成。通过**Name**参数，实例被赋予**MicrosoftDefenderFilter**的名称。之前创建的查询被分配给**$query**变量，然后传递给**$CimEventDefenderFilter**属性的**Query**参数。**QueryLanguage**参数设置为**WQL**，表示查询使用的是
    WMI 查询语言。最后，**EventNamespace**参数指定事件筛选器将被注册的命名空间，在此例中为**\root\cimv2**。
- en: Finally, a new CIM instance is created in the **Root/SubScription** namespace,
    using the **__EventFilter** class, to indicate that we are creating an event filter.
    The properties of this instance are set to the values in the hashtable of the
    **$****CimEventDefenderFilter** variable.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**Root/SubScription**命名空间中创建一个新的 CIM 实例，使用**__EventFilter**类，表示我们正在创建一个事件筛选器。此实例的属性设置为**$CimEventDefenderFilter**变量中的哈希表值。
- en: 'You can verify that the filter was created using the following command:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令验证筛选器是否已创建：
- en: '[PRE23]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot displays what it looks like when the event filter
    is successfully created:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了事件筛选器成功创建后的样子：
- en: '![Figure 5.35 – Verifying that the filter was created](image/B16679_05_035.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.35 – 验证筛选器是否已创建](image/B16679_05_035.jpg)'
- en: Figure 5.35 – Verifying that the filter was created
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35 – 验证筛选器是否已创建
- en: As a next step, we will need to create a consumer.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是，我们需要创建一个消费者。
- en: Creating a consumer
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建消费者
- en: 'In WMI/CIM event subscriptions, a consumer is used to define what action should
    be taken when an event filter receives a match. There are several types of consumers
    available, each with its own properties:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WMI/CIM 事件订阅中，消费者用于定义当事件筛选器匹配时应该采取的操作。提供了几种类型的消费者，每种都有自己的属性：
- en: '**ActiveScriptEventConsumer**: This consumer executes a script when an event
    occurs.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ActiveScriptEventConsumer**：当事件发生时，此消费者执行一个脚本。'
- en: '**CommandLineEventConsumer**: This consumer starts a process when an event
    occurs. Please verify the **access control list** (**ACL**) of the **.exe** file,
    so that adversaries are prevented from replacing the **.exe** file with a malicious
    file.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CommandLineEventConsumer**：当事件发生时，此消费者启动一个进程。请验证**.exe**文件的**访问控制列表**（**ACL**），以防止攻击者用恶意文件替换**.exe**文件。'
- en: '**LogFileEventConsumer**: This consumer creates a text log when an event occurs.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogFileEventConsumer**：当事件发生时，此消费者会创建一个文本日志。'
- en: '**NTEventLogEventConsumer**: This consumer logs an event to the Windows event
    log when an event occurs.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NTEventLogEventConsumer**：当事件发生时，此消费者将事件记录到 Windows 事件日志中。'
- en: '**SMTPEventConsumer**: This consumer sends an email when an event occurs.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMTPEventConsumer**：当事件发生时，此消费者会发送一封电子邮件。'
- en: Every consumer has its own properties, so make sure to check its properties
    before you define them.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消费者都有自己的属性，因此在定义它们之前，请务必检查其属性。
- en: 'The following example demonstrates how to configure a consumer that logs an
    event every time the Microsoft Defender service is terminated:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何配置一个消费者，每次 Microsoft Defender 服务终止时记录事件：
- en: '[PRE24]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **$Message** variable defines the body of the event log message, which includes
    the name and status of the terminated service. The **$CimDefenderConsumerProperties**
    variable defines the properties of **NTEventLogEventConsumer**, such as the machine
    name (**MachineName**), event ID (**EventID**), event type (**EventType**), the
    name of the event log in which the event should be logged (**SourceName = 'Application'**),
    and the message of the event itself (**InsertionStringTemplates**). **NumberOfInsertionStrings**
    specifies the number of insertion strings that will be used in the event message.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**$Message** 变量定义了事件日志消息的内容，其中包括已终止服务的名称和状态。**$CimDefenderConsumerProperties**
    变量定义了 **NTEventLogEventConsumer** 的属性，如机器名（**MachineName**）、事件 ID（**EventID**）、事件类型（**EventType**）、事件应记录的事件日志名称（**SourceName
    = ''Application''**）以及事件本身的消息（**InsertionStringTemplates**）。**NumberOfInsertionStrings**
    指定将在事件消息中使用的插入字符串数量。'
- en: 'In this case, **EventType** specifies that a warning (**2**) should be logged.
    Here’s an overview of all possible event types:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**EventType** 指定应记录一个警告（**2**）。以下是所有可能事件类型的概览：
- en: '**0**: Successful event'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0**：成功事件'
- en: '**1**: Error event'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1**：错误事件'
- en: '**2**: Warning event'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2**：警告事件'
- en: '**4**: Information event'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4**：信息事件'
- en: '**8**: Success audit type'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8**：成功审核类型'
- en: '**16**: Failure audit type'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**16**：失败审核类型'
- en: Finally, the **New-CimInstance** cmdlet creates the consumer.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**New-CimInstance** cmdlet 创建消费者。
- en: 'Use the **Get-CimInstance** cmdlet to verify that it was created successfully:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Get-CimInstance** cmdlet 验证它是否已成功创建：
- en: '[PRE25]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Binding the event filter to the consumer
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将事件筛选器绑定到消费者
- en: Finally, we will bind the event filter to the consumer in order to make the
    WMI/CIM event subscription work. Binding an event filter to a consumer ensures
    that the consumer will be notified every time the event filter receives a match.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将事件筛选器绑定到消费者，以使 WMI/CIM 事件订阅生效。将事件筛选器绑定到消费者可以确保每次事件筛选器收到匹配时，消费者都会收到通知。
- en: After creating an event filter and a consumer, the final step is to bind them
    together. This can be done by creating an instance of the **__FilterToConsumerBinding**
    class. This class defines a relationship between the event filter and the consumer.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 创建事件筛选器和消费者后，最后一步是将它们绑定在一起。这可以通过创建 **__FilterToConsumerBinding** 类的实例来完成。此类定义了事件筛选器与消费者之间的关系。
- en: 'The following example demonstrates how to create a binding instance between
    the event filter and the SMTP event consumer created in the previous example:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在前一个示例中创建的事件筛选器和 SMTP 事件消费者之间创建绑定实例：
- en: '[PRE26]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we are using the **New-CimInstance** cmdlet to create a new
    instance of the **__FilterToConsumerBinding** class. We pass the event filter
    and consumer instances as references to the **Filter** and **Consumer** properties
    of the binding instance.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用**New-CimInstance** cmdlet 创建 **__FilterToConsumerBinding** 类的新实例。我们将事件筛选器和消费者实例作为引用传递给绑定实例的
    **Filter** 和 **Consumer** 属性。
- en: 'Finally, we can verify that the binding was created by using the **Get-CimInstance**
    cmdlet, as follows:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 **Get-CimInstance** cmdlet 验证绑定是否创建成功，如下所示：
- en: '[PRE27]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will return all instances of the **__FilterToConsumerBinding** class in
    the **root/subscription** namespace, including the instance that we just created.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 **root/subscription** 命名空间中所有 **__FilterToConsumerBinding** 类的实例，包括我们刚刚创建的实例。
- en: Removing a CIM instance
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除 CIM 实例
- en: 'If you want to remove any CIM instance that you created, you can use the **Remove-CimInstance**
    cmdlet:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除创建的任何 CIM 实例，可以使用 **Remove-CimInstance** cmdlet：
- en: '[PRE28]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code snippet removes the event filter CIM instance, **'MicrosoftDefenderFilter'**,
    which we created earlier.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段移除我们之前创建的事件筛选器 CIM 实例，**'MicrosoftDefenderFilter'**。
- en: 'The following command removes the event log consumer CIM instance with the
    name **''Windows Defender Service (windefend)** **was terminated''**:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令移除名为 **'Windows Defender Service (windefend)** **已终止'** 的事件日志消费者 CIM 实例：
- en: '[PRE29]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And last but not least, to remove the CIM instance that is responsible for
    binding the event filter to the consumer, run the following command:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，要删除负责将事件筛选器绑定到消费者的 CIM 实例，请运行以下命令：
- en: '[PRE30]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Monitor WMI/CIM event subscriptions
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控 WMI/CIM 事件订阅
- en: You can detect and monitor WMI/CIM event-related activity by using both the
    Windows event log and Sysmon.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Windows 事件日志和 Sysmon 来检测和监控 WMI/CIM 事件相关的活动。
- en: 'When using the Windows event log, you can use the operational WMI activity
    log to track WMI/CIM-related events:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows 事件日志时，你可以使用操作性的 WMI 活动日志来跟踪 WMI/CIM 相关的事件：
- en: '**Full** **Name**: **Microsoft-Windows-WMI-Activity/Operational**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整** **名称**：**Microsoft-Windows-WMI-Activity/Operational**'
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WMI-Activity%4Operational.evtx**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志** **路径**：**%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WMI-Activity%4Operational.evtx**'
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **WMI Activity** | **Operational**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI 中的路径**：**应用和服务** | **Microsoft** | **Windows** | **WMI 活动** | **操作性**'
- en: 'The *most interesting event IDs* in this event log for PowerShell security
    logging are the following:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件日志中与 PowerShell 安全日志相关的 *最有趣的事件 ID* 如下：
- en: '**Event ID 5857**: Provider started with result code. This event shows provider
    loading.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 5857**：提供程序以结果代码启动。此事件显示提供程序加载情况。'
- en: '**Event ID 5858**: Error message. This event typically triggers for query errors.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 5858**：错误消息。此事件通常在查询错误时触发。'
- en: '**Event ID 5859**: This event indicates that a permanent event filter was started.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 5859**：此事件表示启动了一个永久事件过滤器。'
- en: '**Event ID 5860**: A temporary event consumer was registered or started.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 5860**：注册或启动了一个临时事件消费者。'
- en: '**Event ID 5861**: A permanent event consumer binding was registered.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 5861**：注册了一个永久事件消费者绑定。'
- en: Some of the WMI activity events can be extremely noisy, so ensure to filter
    accordingly to your environment and your needs. Event IDs *5859*, *5860*, and
    *5861* can especially help you to find malicious activity.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 WMI 活动事件可能会产生大量噪音，因此请根据你的环境和需求进行相应的过滤。事件 ID *5859*、*5860* 和 *5861* 特别有助于帮助你发现恶意活动。
- en: 'Another great resource if you want to learn more about tracking WMI activity
    using the Windows event log is the following blog article written by Carlos Perez:
    [https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity](https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于使用 Windows 事件日志跟踪 WMI 活动的内容，可以参考 Carlos Perez 撰写的以下博客文章：[https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity](https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity)。
- en: '**Sysmon** provides capabilities to monitor whenever an event filter or consumer
    is registered or when a consumer binds to a filter:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sysmon** 提供了监控每当事件过滤器或消费者被注册或消费者绑定到过滤器时的功能：'
- en: '**Event ID 19**: Logs the WMI namespace, filter name, and filter expression
    when a WMI event filter is registered. Malware can use this method to execute
    code.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 19**：当注册 WMI 事件过滤器时，记录 WMI 命名空间、过滤器名称和过滤器表达式。恶意软件可以利用这种方法执行代码。'
- en: '**Event ID 20**: Logs the registration of WMI consumers, including the consumer
    name, log, and destination.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 20**：记录 WMI 消费者的注册信息，包括消费者名称、日志和目标。'
- en: '**Event ID 21**: Logs the consumer name and filter path when a consumer binds
    to a filter. This can help identify which consumer is receiving events from a
    specific filter.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件 ID 21**：当消费者绑定到过滤器时，记录消费者名称和过滤器路径。这有助于识别哪个消费者正在接收来自特定过滤器的事件。'
- en: Sysmon is a little less noisy than the Windows WMI activity event log, but you
    will need to install it first on the systems that you want to monitor, so it has
    its up- as well as its downsides.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Sysmon 的噪音比 Windows WMI 活动事件日志少一些，但你需要先在你想要监控的系统上安装它，因此它既有优点也有缺点。
- en: For monitoring WMI activities *in general* – regardless of whether you use Windows
    event logs or Sysmon – look for new event filters and bindings being registered
    and filter out known good filters and bindings.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 WMI 活动的监控 *总体来说*——无论你使用 Windows 事件日志还是 Sysmon——都要查找新的事件过滤器和绑定被注册的情况，并过滤掉已知的好过滤器和绑定。
- en: Monitor the use of **wmic.exe** – look especially for the **'process call create'**
    argument. Observe the use of **winrm.exe** for lateral movement, and investigate
    whether **mofcomp.exe** was used to compile a new provider. Look for the creation
    of **MOF** files in unusual directories. And monitor the child processes of **WmiPrvse.exe**,
    as they could indicate an instantiation of processes through WMI.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 **wmic.exe** 的使用——特别是查找 **'process call create'** 参数。观察 **winrm.exe** 的使用是否有横向移动的迹象，并调查是否使用
    **mofcomp.exe** 编译了新的提供程序。查找在异常目录中创建的 **MOF** 文件。监控 **WmiPrvse.exe** 的子进程，因为它们可能表明通过
    WMI 实例化了进程。
- en: Manipulating CIM instances
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作 CIM 实例
- en: CIM instances provide a standardized way of representing managed resources in
    a system, allowing users to interact with these resources in a unified way. But
    CIM instances can also be manipulated. In such cases, the **Set-CimInstance**
    cmdlet can be used to modify one or more properties of a CIM instance.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: CIM 实例提供了一种标准化的方式来表示系统中的托管资源，允许用户以统一的方式与这些资源进行交互。但 CIM 实例也可以被操作。在这种情况下，可以使用
    **Set-CimInstance** cmdlet 修改一个或多个 CIM 实例的属性。
- en: 'It is not possible to manipulate all CIM instances; they need to be writable.
    To find out which properties are writable, you can use the following script, which
    was inspired by Trevor Sullivan:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有的 CIM 实例都可以操作，它们需要是可写的。要了解哪些属性是可写的，可以使用以下脚本，该脚本由 Trevor Sullivan 提供灵感：
- en: '[PRE31]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once you find a property that can be written to that you want to manipulate,
    you can alter it using **Set-CimInstance**.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个可以写入的属性并且你希望操作它，就可以使用 **Set-CimInstance** 来修改它。
- en: 'The following example demonstrates how you could use CIM to enable a disabled
    user account with PowerShell:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用 CIM 通过 PowerShell 启用禁用的用户帐户：
- en: '[PRE32]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, you can use the **Get-CimInstance** cmdlet to retrieve the instance of
    the **Win32_UserAccount** class that matches the specified filter criteria. In
    this case, we are searching for a user account whose name starts with **vicvega**.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用 **Get-CimInstance** cmdlet 来检索与指定筛选条件匹配的 **Win32_UserAccount** 类的实例。在此示例中，我们正在查找用户名以
    **vicvega** 开头的用户帐户。
- en: Then, you can modify the **Disabled** property of the retrieved user account
    instance to set it to **$false**. Finally, you can use the **Set-CimInstance**
    cmdlet to save the updated user account instance to the CIM repository.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以修改检索到的用户帐户实例的 **Disabled** 属性，将其设置为 **$false**。最后，你可以使用 **Set-CimInstance**
    cmdlet 将更新后的用户帐户实例保存到 CIM 仓库中。
- en: 'Use the following command to verify that the updated user account instance
    was saved successfully:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证更新后的用户帐户实例是否成功保存：
- en: '[PRE33]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Enumeration
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'WMI uses a subset of SQL, called **WMI Query Language** (**WQL**). WQL only
    supports a subset of commands, which are documented here: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 使用 SQL 的一个子集，称为 **WMI 查询语言** (**WQL**)。WQL 仅支持一部分命令，相关文档请参见：[https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi)。
- en: 'There are different types of queries – data, event, and schema queries. In
    this book, we will mostly concentrate on the most commonly used ones: data queries.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 查询有不同的类型——数据查询、事件查询和模式查询。在本书中，我们主要关注最常用的类型：数据查询。
- en: 'If you want to learn more about the other query types, I recommend referring
    to the official documentation: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql](https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多其他查询类型，建议参考官方文档：[https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql](https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql)。
- en: A data query simply serves the purpose to retrieve data – for example, about
    class instances or data associations.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 数据查询仅用于检索数据，例如类实例或数据关联信息。
- en: To query a class, you can either use WQL or query the class by its class name.
    So, for example, to query a group with the name **Administrators**, you can either
    query the class and then filter using PowerShell or use WQL and filter using the
    query.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 查询类时，你可以使用 WQL 或通过类名查询该类。例如，要查询名称为 **Administrators** 的组，你可以查询该类，然后使用 PowerShell
    进行筛选，或者使用 WQL 进行查询并筛选。
- en: 'Here is an example of querying the class and using PowerShell to filter:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查询类并使用 PowerShell 进行筛选的示例：
- en: '[PRE34]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And this shows you how to query and filter using WQL:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何使用 WQL 进行查询和筛选：
- en: '[PRE35]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Both methods will result in the same output:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法将产生相同的输出：
- en: '![Figure 5.36 – Querying using different methods](image/B16679_05_036.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.36 – 使用不同方法进行查询](image/B16679_05_036.jpg)'
- en: Figure 5.36 – Querying using different methods
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 – 使用不同方法进行查询
- en: Did You Know?
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: If you have the chance, you should always prefilter using WQL as that increases
    the performance of your queries. If you first query and then filter using PowerShell,
    it takes longer to calculate the results.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有机会，你应该始终使用 WQL 预筛选，因为这会提高查询的性能。如果先查询然后使用 PowerShell 进行筛选，计算结果会更慢。
- en: In this section, I will provide you with some examples of enumeration using
    CIM/WMI. You can adjust them to your needs or improve your existing detections.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将为您提供一些使用CIM/WMI的枚举示例。您可以根据需要调整它们，或改进现有的检测方法。
- en: 'Enumerate processes using the following command:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令枚举进程：
- en: '[PRE36]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using **Get-CimInstance** does not only retrieve information about processes
    but you can also use WMI to display the **CommandLine** property that is not available
    in the default .NET output objects:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Get-CimInstance** 不仅可以检索进程信息，还可以使用 WMI 显示默认 .NET 输出对象中不可用的 **CommandLine**
    属性：
- en: '[PRE37]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the following command to enumerate existing user accounts:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令枚举现有的用户账户：
- en: '[PRE38]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By using WMI to enumerate users, you can not only enumerate local users but
    also domain users will be enumerated while executing one single command.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 WMI 枚举用户，您不仅可以枚举本地用户，还可以在执行一个命令时枚举域用户。
- en: 'WMI also provides a huge advantage for red teamers: if you would be using PowerShell
    only, you would need to install the **ActiveDirectory** module to query domain
    users. By using WMI, you can simply enumerate all domain users if the computer
    on which you are executing commands is domain-joined.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 还为红队人员提供了巨大优势：如果您仅使用 PowerShell，您需要安装 **ActiveDirectory** 模块才能查询域用户。而使用
    WMI，您只需在执行命令的计算机加入域的情况下，简单枚举所有域用户。
- en: Additionally to other properties, **Get-CimInstance** also returns the **AccountType**
    property, which indicates whether the account is a *normal account* (**512**),
    a *workstation account* (**4096**), or, for example, even the account of a backup
    domain controller (*server trust account*, **8192**). The number **256** would
    indicate that it’s a *temporary duplicate account*, while the number **2048**
    indicates an *interdomain* *trust account*.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他属性，**Get-CimInstance** 还返回 **AccountType** 属性，指示该账户是 *普通账户* (**512**)、*工作站账户*
    (**4096**)，还是例如备份域控制器的账户（*服务器信任账户*，**8192**）。数字 **256** 表示它是一个 *临时重复账户*，而数字 **2048**
    表示一个 *跨域* *信任账户*。
- en: 'You can enumerate local groups and group members as follows:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式枚举本地组和组成员：
- en: '[PRE39]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, similar to the **win32_useraccount** table, **win32_group** and **win32_groupuser**
    are referring to both local and domain groups.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于 **win32_useraccount** 表，**win32_group** 和 **win32_groupuser** 表示本地和域组。
- en: 'WMI and CIM understand relationships between different instances, so you can
    even combine tables to find out which accounts are members of the local administrators.
    The **Get-CimAssociatedInstance** cmdlet allows you to get related objects that
    are linked to **-InputObject**:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 和 CIM 理解不同实例之间的关系，因此您甚至可以结合表格，找出哪些账户是本地管理员的成员。**Get-CimAssociatedInstance**
    cmdlet 允许您获取与 **-InputObject** 相关的对象：
- en: '[PRE40]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To get more information about currently installed hotfixes and updates, you
    can query the **win32_quickfixengineering** table:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关当前安装的修补程序和更新的更多信息，您可以查询 **win32_quickfixengineering** 表：
- en: '[PRE41]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find out which processes, programs, or scripts are configured to run when the
    operating system starts by querying the **Win32_StartupCommand** instance:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询 **Win32_StartupCommand** 实例，找出哪些进程、程序或脚本配置为在操作系统启动时运行：
- en: '[PRE42]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Where is the WMI/CIM database located?
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WMI/CIM 数据库位于哪里？
- en: And by the way, if you have always wondered where WMI is actually located on
    a Windows system, the WMI database itself can be found under **$Env:windir\System32\wbem\Repository**.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果您一直好奇WMI实际上位于Windows系统的哪里，WMI数据库本身可以在 **$Env:windir\System32\wbem\Repository**
    路径下找到。
- en: The following screenshot displays the context of this folder.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此文件夹的上下文。
- en: '![Figure 5.37 – WMI database](image/B16679_05_037.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.37 – WMI 数据库](image/B16679_05_037.jpg)'
- en: Figure 5.37 – WMI database
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37 – WMI 数据库
- en: 'Here, you can usually find the following files:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您通常可以找到以下文件：
- en: '**INDEX.BTR** (“binary tree index”):'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INDEX.BTR**（“二叉树索引”）：'
- en: The index of all managed objects that were imported into **OBJECTS.DATA**.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 所有已导入 **OBJECTS.DATA** 的管理对象的索引。
- en: '**OBJECTS.DATA**:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OBJECTS.DATA**：'
- en: All objects that are managed by WMI.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由 WMI 管理的对象。
- en: '**MAPPING[1-3].MAP**:'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MAPPING[1-3].MAP**：'
- en: Correlates data between **INDEX.BTW** and **OBJECTS.DATA**.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 关联 **INDEX.BTW** 和 **OBJECTS.DATA** 之间的数据。
- en: 'Now that we have covered the importance of monitoring and manipulating WMI
    for security purposes, it’s time to move on to another topic: while some individuals
    may believe that PowerShell is a security threat and advocate for blocking **powershell.exe**,
    attackers can still find ways to run PowerShell even if **powershell.exe** is
    prevented from being executed. In the following section, we will explore how this
    can be achieved.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了出于安全目的监控和操控WMI的重要性，接下来我们将讨论另一个话题：虽然有些人认为PowerShell是一个安全威胁，并主张阻止**powershell.exe**，攻击者仍然可以找到方法来运行PowerShell，即使**powershell.exe**被阻止执行。在接下来的部分，我们将探讨如何实现这一点。
- en: Running PowerShell without powershell.exe
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有powershell.exe的情况下运行PowerShell
- en: To execute PowerShell commands, you usually first start **powershell.exe**.
    But there may be situations where running PowerShell in a traditional manner is
    not possible or allowed.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行PowerShell命令，通常需要先启动**powershell.exe**。但可能会有一些情况，传统方式下无法或不允许运行PowerShell。
- en: In those cases, PowerShell can still be run by using other means, such as through
    **Windows Script Host** (**WSH**), WMI, .NET Framework, or more.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，PowerShell仍然可以通过其他方式运行，比如通过**Windows Script Host**（**WSH**）、WMI、.NET框架等。
- en: Using “living off the land” binaries to call assembly functions
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用“living off the land”二进制文件调用程序集函数
- en: The term **LOLbin** is short for **living off the land binaries** and was coined
    by malware researchers Christopher Campbell and Matt Graeber at DerbyCon 3 in
    2013\. In a Twitter discussion on what to call those binaries that can be abused
    to run malicious code, the term *LOLBins* came up for the first time and a (highly
    scientific) Twitter poll made the terms *LOLBins* and *LOLScripts* official within
    the community.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**LOLbin**一词是**living off the land binaries**的缩写，最早由恶意软件研究人员Christopher Campbell和Matt
    Graeber在2013年DerbyCon 3大会上提出。在关于如何称呼那些可以被滥用来运行恶意代码的二进制文件的Twitter讨论中，*LOLBins*一词首次出现，经过一次（高度科学的）Twitter投票，*LOLBins*和*LOLScripts*正式成为社区中常用的术语。'
- en: A LOLbin refers to legitimate, pre-installed system binaries or applications
    that can be abused by attackers to carry out malicious activities on a compromised
    system. Attackers use these LOLbins as part of their **tactics, techniques, and
    procedures** (**TTPs**) to evade detection by security solutions since these binaries
    are typically considered safe and allowed to execute on the system.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: LOLbin指的是合法的、预先安装的系统二进制文件或应用程序，攻击者可以利用它们在被攻击的系统上执行恶意活动。攻击者将这些LOLbin作为其**战术、技巧和程序**（**TTPs**）的一部分，用来躲避安全解决方案的检测，因为这些二进制文件通常被认为是安全的，且被允许在系统上执行。
- en: Basically, PowerShell is also considered a LOLbin, as PowerShell was added as
    a legitimate admin tool. But thankfully for blue teamers, PowerShell provides
    many possibilities to not only monitor but to also restrict the usage to preconfigured
    use cases, as well as users. Other examples of legitimate admin tools that could
    also serve as a LOLbin are **cmd**, **WMI**, **regsvr32.exe**, **rundll32.exe**,
    **mshta.exe**, **certutil.exe**, **wmic.exe**, **msbuild.exe**, **installutil.exe**,
    **regsvcs.exe**, **regasm.exe**, **PSExec.exe**, and others.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，PowerShell也被视为一个LOLbin，因为PowerShell被作为合法的管理员工具添加到系统中。不过幸运的是，对于蓝队成员来说，PowerShell提供了很多可能性，不仅可以监控，还可以限制仅限于预配置的用例以及用户。其他可以作为LOLbin的合法管理员工具示例包括**cmd**、**WMI**、**regsvr32.exe**、**rundll32.exe**、**mshta.exe**、**certutil.exe**、**wmic.exe**、**msbuild.exe**、**installutil.exe**、**regsvcs.exe**、**regasm.exe**、**PSExec.exe**等。
- en: '**PSExec.exe** is a great example of a LOLbin: while many administrators are
    still using it for administrative tasks, adversaries also happen to find this
    tool very useful. Especially when it comes to passing the hash and lateral movement,
    attackers love this tool.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**PSExec.exe**是LOLbin的一个典型例子：尽管许多管理员仍在使用它执行管理任务，但攻击者也发现这个工具非常有用，特别是在传递哈希和横向移动方面，攻击者非常喜欢这个工具。'
- en: Sometimes, LOLbins are also simply used for obfuscation to invoke actions in
    a way that defenders might overlook when monitoring their systems – such as, for
    example, **rundll.exe**; this executable can load and run 32-bit DLLs and execute
    functions. Note that it can only execute functions that were explicitly written
    to run with **rundll32.exe**.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，LOLbin也仅仅用于混淆，以一种防御者可能忽视的方式调用操作——例如，**rundll.exe**；该可执行文件可以加载并运行32位DLL文件并执行函数。请注意，它只能执行那些专门为**rundll32.exe**编写的函数。
- en: If you know how to write DLLs using C/C++/C#, **rundll32.exe** can run self-created
    DLLs – an ability that attackers can also profit from to run their own DLLs and
    bypass software restrictions.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何使用 C/C++/C# 编写 DLL，**rundll32.exe** 可以运行自定义的 DLL——攻击者也可以利用这个能力运行自己的 DLL
    并绕过软件限制。
- en: Since writing your own DLLs in C/C++/C# could fill an entire book itself, we
    won’t concentrate in detail on how to create a DLL in this book. In our next example,
    we will use an already existing DLL, **PowerShdll.dll**.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用 C/C++/C# 编写自己的 DLL 足以写成一本书，因此本书不会详细介绍如何创建 DLL。在下一个示例中，我们将使用一个已经存在的 DLL，**PowerShdll.dll**。
- en: '**PowerShdll.dll** was written and released by the GitHub user *p3nt4*: [https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll).'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**PowerShdll.dll**是由 GitHub 用户 *p3nt4* 编写并发布的：[https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll)。'
- en: 'Once downloaded, you can simply use **rundll32** or another LOLbin that is
    supported by **PowerShdll** and execute the following command from **cmd**:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您可以直接使用**rundll32**或其他由**PowerShdll**支持的 LOLbin，从**cmd**执行以下命令：
- en: '[PRE43]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Et voilà – the **Get-Process** cmdlet is executed from **cmd** without ever
    touching **powershell.exe**, as shown in the following screenshot:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这个**Get-Process** cmdlet 是通过**cmd**执行的，而完全没有接触到**powershell.exe**，如以下截图所示：
- en: '![Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32
    from cmd](image/B16679_05_038.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.38 – 通过 PowerShdll 和 rundll32 从 cmd 执行 PowerShell 命令](image/B16679_05_038.jpg)'
- en: Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32
    from cmd
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38 – 通过 PowerShdll 和 rundll32 从 cmd 执行 PowerShell 命令
- en: There are also other projects similar to **PowerShdll** that can be used by
    red teamers or adversaries, such as **NoPowerShell**, **PowerLessShell**, **p0wnedShell**,
    and many others.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些类似于**PowerShdll**的其他项目，可以被红队人员或攻击者使用，例如**NoPowerShell**、**PowerLessShell**、**p0wnedShell**等。
- en: Binary executables
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制可执行文件
- en: 'There are also projects such as **NotPowerShell** (**nps.exe**) that let you
    run PowerShell from its own compiled binaries:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些项目，例如**NotPowerShell**（**nps.exe**），它们允许你通过自己的编译二进制文件运行 PowerShell：
- en: '[PRE44]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can find the **NoPowerShell** project on GitHub: [https://github.com/Ben0xA/nps](https://github.com/Ben0xA/nps).'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到**NoPowerShell**项目：[https://github.com/Ben0xA/nps](https://github.com/Ben0xA/nps)。
- en: Executing PowerShell from .NET Framework using C#
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C# 从 .NET Framework 执行 PowerShell
- en: 'One way to run PowerShell without **powershell.exe** is by using .NET Framework.
    This can be done by creating a C# console application in Visual Studio with the
    code that is available in this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 PowerShell 而不使用**powershell.exe**的一种方法是使用 .NET Framework。你可以通过在 Visual Studio
    中创建一个 C# 控制台应用程序来实现，代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh)。
- en: 'For this example, we leverage the PowerShell class from the **System.Management.Automation**
    namespace, the definition of which you can find here: [https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell).'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用**System.Management.Automation**命名空间中的 PowerShell 类，您可以在此处找到其定义：[https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell)。
- en: 'To compile this program without errors, you will need to add **System.Management.Automation.dll**
    as a reference in Visual Studio:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有错误的情况下编译此程序，你需要在 Visual Studio 中将**System.Management.Automation.dll**作为引用添加：
- en: Right-click on the **Dependencies** project in **Solution Explorer** and select
    **Add** **Project Reference**.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**解决方案资源管理器**中的**依赖项**项目，选择**添加** **项目引用**。
- en: In **Reference Manager**, select **Browse** and navigate to the folder where
    the **System.Management.Automation.dll** assembly is located. The default location
    is **C:\Program Files (****x86)\Reference Assemblies\Microsoft\WindowsPowerShell\3.0**.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**引用管理器**中，选择**浏览**并导航到包含**System.Management.Automation.dll**程序集的文件夹。默认位置为**C:\Program
    Files (****x86)\Reference Assemblies\Microsoft\WindowsPowerShell\3.0**。
- en: Select the assembly and click **Add**.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择程序集并点击**添加**。
- en: Save and build your project.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并构建你的项目。
- en: The newly compiled code allows you to execute PowerShell commands or scripts
    without executing **powershell.exe**, and only relying on the PowerShell class
    to execute PowerShell commands. The C# code in this example takes all command-line
    arguments, concatenates them into a single string, and adds that string as a PowerShell
    script to execute. The program then invokes the PowerShell script and captures
    the output, which is then printed to the console.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 新编译的代码允许你在不执行**powershell.exe**的情况下执行 PowerShell 命令或脚本，并仅依赖 PowerShell 类来执行
    PowerShell 命令。这个示例中的 C# 代码接受所有命令行参数，将它们连接成一个字符串，并将该字符串作为 PowerShell 脚本执行。然后程序调用
    PowerShell 脚本并捕获输出，最后将输出打印到控制台。
- en: RunPosh.exe - Possible Command Injection Risk!
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: RunPosh.exe - 可能的命令注入风险！
- en: Please note that **RunPosh.exe** is vulnerable to trivial command injection.
    It should not be used in any productive environment and is only meant to demonstrate
    how PowerShell can be executed without running **powershell.exe**.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**RunPosh.exe** 易受到简单的命令注入攻击。它不应在任何生产环境中使用，仅用于演示如何在不运行**powershell.exe**的情况下执行
    PowerShell。
- en: After compiling **RunPosh.exe**, you can for example open a **cmd** command
    line and execute **RunPoSh.exe Get-NetAdapter** to get all network adapters using
    PowerShell.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译**RunPosh.exe**后，你可以例如打开一个**cmd**命令行，并执行**RunPoSh.exe Get-NetAdapter**，以使用
    PowerShell 获取所有网络适配器。
- en: '![Figure 5.39 – Executing PowerShell commands without powershell.exe](image/B16679_05_039.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.39 – 在不使用 powershell.exe 的情况下执行 PowerShell 命令](image/B16679_05_039.jpg)'
- en: Figure 5.39 – Executing PowerShell commands without powershell.exe
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39 – 在不使用 powershell.exe 的情况下执行 PowerShell 命令
- en: There are numerous other examples of how PowerShell can be executed without
    relying on **powershell.exe**. The ones discussed in this chapter were merely
    a few, intended to provide you with an understanding of the different methods
    available to achieve this goal.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他示例展示了如何在不依赖于**powershell.exe**的情况下执行 PowerShell。本章讨论的只是其中的一些，目的是让你理解实现这一目标的不同方法。
- en: Summary
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how PowerShell provides access to various system
    and API resources such as the Windows Registry, Windows API (including COM and
    .NET Framework), and WMI. We also learned how to run PowerShell without the use
    of the **powershell.exe** executable.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 PowerShell 如何访问各种系统和 API 资源，如 Windows 注册表、Windows API（包括 COM 和 .NET
    框架）以及 WMI。我们还学习了如何在不使用**powershell.exe**可执行文件的情况下运行 PowerShell。
- en: The chapter provided many examples that demonstrated how red teamers or adversaries
    can exploit these APIs and resources. It was also intended to help blue teamers
    to gain insights into adversary behavior and learn how to leverage PowerShell
    to monitor and detect suspicious behavior by leveraging CIM events.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了许多示例，展示了红队成员或对手如何利用这些 API 和资源。它还旨在帮助蓝队成员洞察对手的行为，并学习如何利用 PowerShell 通过 CIM
    事件来监控和检测可疑行为。
- en: By the end of the chapter, you should have gained a better understanding of
    how PowerShell can be used to interact with system resources and APIs, as well
    as how to leverage it for both offensive and defensive purposes.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对如何使用 PowerShell 与系统资源和 API 交互有了更深入的理解，并了解如何将其用于进攻性和防御性目的。
- en: When we are talking about PowerShell security, authentication and identities
    play an important role. Let’s have a look at Active Directory security from a
    PowerShell perspective in our next chapter.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 PowerShell 安全时，身份验证和身份扮演着重要角色。让我们在下一章从 PowerShell 角度看一下 Active Directory
    安全。
- en: Further reading
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    follow these resources:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入探索本章提到的一些主题，可以参考以下资源：
- en: '**API**:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**：'
- en: 'Low-Level Windows API Access From PowerShell: [https://www.fuzzysecurity.com/tutorials/24.html](https://www.fuzzysecurity.com/tutorials/24.html)'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低级 Windows API 访问 PowerShell：[https://www.fuzzysecurity.com/tutorials/24.html](https://www.fuzzysecurity.com/tutorials/24.html)
- en: '**CIM/WMI**:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**CIM/WMI**：'
- en: 'Use PowerShell to Manipulate Information with CIM: [https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/](https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/)'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 操作 CIM 信息：[https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/](https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/)
- en: '**COM hijacking**:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**COM 劫持**：'
- en: 'Demystifying Windows Component Object Model (COM): [https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com](https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com)'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '破解 Windows 组件对象模型（COM）: [https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com](https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com)'
- en: 'acCOMplice: [https://github.com/nccgroup/acCOMplice](https://github.com/nccgroup/acCOMplice)'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'acCOMplice: [https://github.com/nccgroup/acCOMplice](https://github.com/nccgroup/acCOMplice)'
- en: 'COM Hijacking Techniques, David Tulis (DerbyCon): [https://www.youtube.com/watch?v=pH14BvUiTLY](https://www.youtube.com/watch?v=pH14BvUiTLY)'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'COM 劫持技术，David Tulis（DerbyCon）: [https://www.youtube.com/watch?v=pH14BvUiTLY](https://www.youtube.com/watch?v=pH14BvUiTLY)'
- en: 'OleViewDotNet by James Forshaw: [https://github.com/tyranid/oleviewdotnet](https://github.com/tyranid/oleviewdotnet)'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'James Forshaw 的 OleViewDotNet: [https://github.com/tyranid/oleviewdotnet](https://github.com/tyranid/oleviewdotnet)'
- en: 'COM Class Objects and CLSIDs: [https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids](https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids)'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'COM 类对象和 CLSID: [https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids](https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids)'
- en: 'Hijacking .NET to Defend PowerShell: [https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf](https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf)'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '劫持 .NET 以防御 PowerShell: [https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf](https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf)'
- en: 'Playing around COM objects - PART 1: [https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1](https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1)'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '玩转 COM 对象 - 第一部分: [https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1](https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1)'
- en: 'IUnknown::QueryInterface(REFIID,void**) method (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IUnknown::QueryInterface(REFIID,void**) 方法 (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))'
- en: 'IUnknown interface (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown)'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IUnknown 接口 (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown)'
- en: 'IUnknown::QueryInterface(Q**) method (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q))'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IUnknown::QueryInterface(Q**) 方法 (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q))'
- en: '**.****NET Framework**:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**NET 框架：'
- en: 'Assemblies in .NET: [https://learn.microsoft.com/en-us/dotnet/standard/assembly/](https://learn.microsoft.com/en-us/dotnet/standard/assembly/)'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET 中的程序集: [https://learn.microsoft.com/en-us/dotnet/standard/assembly/](https://learn.microsoft.com/en-us/dotnet/standard/assembly/)'
- en: 'Global Assembly Cache: [https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac](https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac)'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '全局程序集缓存: [https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac](https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac)'
- en: '.NET Framework versions and dependencies: [https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies](https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies)'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET 框架版本和依赖关系: [https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies](https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies)'
- en: '**Running PowerShell** **without powershell.exe**:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 PowerShell** **不使用 powershell.exe**：'
- en: 'NoPowerShell: [https://github.com/bitsadmin/nopowershell](https://github.com/bitsadmin/nopowershell)'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NoPowerShell: [https://github.com/bitsadmin/nopowershell](https://github.com/bitsadmin/nopowershell)'
- en: 'PowerLessShell: [https://github.com/Mr-Un1k0d3r/PowerLessShell](https://github.com/Mr-Un1k0d3r/PowerLessShell)'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerLessShell: [https://github.com/Mr-Un1k0d3r/PowerLessShell](https://github.com/Mr-Un1k0d3r/PowerLessShell)'
- en: 'p0wnedShell: [https://github.com/Cn33liz/p0wnedShell](https://github.com/Cn33liz/p0wnedShell)'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'p0wnedShell: [https://github.com/Cn33liz/p0wnedShell](https://github.com/Cn33liz/p0wnedShell)'
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for [*Chapter 5*](B16679_05_Final_PD.xhtml#_idTextAnchor110) – no need to manually
    type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md).'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 仓库中找到本章提到的所有链接，链接位于[*第 5 章*](B16679_05_Final_PD.xhtml#_idTextAnchor110)
    – 无需手动输入每个链接：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md)。
