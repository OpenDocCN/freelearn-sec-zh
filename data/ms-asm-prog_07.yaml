- en: Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: As it has been stated more than once in this book, Assembly is about moving
    and performing certain basic operations on data, and Assembly programming is about
    knowing what to move where and which operations to apply to it on the way. Until
    now, we have primarily dedicated all our attention to operations that we are able
    to perform on different types of data, and it is now time to talk about the data
    itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中已经多次提到的，汇编语言是关于对数据进行移动和执行某些基本操作，汇编编程是关于知道该将数据移动到哪里，并在此过程中对其应用哪些操作。到目前为止，我们主要集中在对不同类型数据执行的操作上，现在是时候讨论数据本身了。
- en: The least data item that is accessible on Intel architecture-based processors
    is bit, and the least addressable item is byte (which is 8 bits on Intel architecture).
    We already know how to work with such data and even words, double words, and single-precision
    floating-point values. Data, however, may be much more complex than that, and
    I do not mean quad words and/or double-precision floating points.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Intel 架构的处理器中，最小的数据单元是比特，而最小的可寻址单元是字节（在 Intel 架构中是 8 位）。我们已经知道如何处理这样的数据，甚至是字、双字和单精度浮点值。然而，数据可能比这些更复杂，我指的不是四字、双精度浮点数等。
- en: In this chapter, we will see how to declare, define, and manipulate simple and
    complex data structures and how this may make our lives as Assembly developers
    much easier. Starting with simple data structures, such as arrays, we will proceed
    to more complex ones containing different types of data and go through linked
    lists and trees toward more complex and powerful methods of data arrangement.
    The intention here, given that you as a developer are familiar with different
    data structures, is to show how easy it may be to work with them in Assembly,
    especially using FASM with its powerful features as an assembler.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何声明、定义和操作简单以及复杂的数据结构，以及这如何使我们作为汇编开发者的工作变得更加轻松。从简单的数据结构（如数组）开始，我们将逐步探讨包含不同数据类型的更复杂结构，并逐步过渡到链表和树形结构，最终介绍更复杂、更强大的数据排列方法。鉴于你作为开发者已经熟悉不同的数据结构，本章的目的是展示在汇编中使用它们的简便性，特别是使用
    FASM 这款功能强大的汇编器。
- en: 'The following are the data structures (data arrangement schemes) covered in
    this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将讨论以下数据结构（数据排列方案）：
- en: Arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Arrays of structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体数组
- en: Linked lists and special cases thereof
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表及其特殊情况
- en: Binary Search Trees and balancing thereof
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树及其平衡
- en: Sparse matrices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Graphs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图
- en: Arrays
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: By now, we have come a long way, dealing primarily with basic data types ranging
    from bytes to quad words, preparing ourselves for more complex data-related concepts.
    Let's continue by looking into arrays, which may be characterized as the sequential
    storage of data of the same type. Theoretically, there is no limitation to the
    size of array members, but practically we are limited to, for example, the size
    of a register. However, workarounds exist and we will see that later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经走了很长一段路，主要处理从字节到四字的基本数据类型，为更复杂的数据相关概念做好准备。接下来我们将深入探讨数组，数组可以被视为相同类型数据的顺序存储。从理论上讲，数组成员的大小没有限制，但实际上我们受到诸如寄存器大小的限制。然而，存在一些变通方法，我们将在本章稍后看到。
- en: Simple byte arrays
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单字节数组
- en: 'A good example of a widely used, yet simple, array would be a forward substitution
    table and/or a reverse substitution table used with the AES algorithm:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广泛使用且简单的数组的例子是 AES 算法中使用的正向替代表和/或反向替代表：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we may clearly see, all values have a size of 1 byte and are stored sequentially
    one after the other. Accessing such arrays is very simple and may even be performed
    with the XLAT instruction. For example, imagine that we are in the middle of an
    AES-128 calculation and we have a value in which we need to substitute each byte
    with a byte from the preceding table. Let the following be the value:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以清楚看到的，所有值的大小都是 1 字节，并且是按顺序一个接一个地存储。访问这样的数组非常简单，甚至可以通过 XLAT 指令完成。例如，假设我们正在进行
    AES-128 计算，并且需要将每个字节替换为前面表格中的字节。假设以下是该值：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code would do the substitution:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将执行替代操作：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we do is load the base address of the table (of the s-box) into
    the EBX register, as the XLAT instruction uses exactly this register for addressing
    the substitution/lookup table. Then, we load the address of the array of values
    requiring
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是将表的基地址（S-box 的地址）加载到 EBX 寄存器中，因为 XLAT 指令正是使用这个寄存器来寻址替代/查找表。然后，我们加载需要的数组地址。
- en: substitution into the ESI register in order to not bother with index computations,
    as the ESI register is automatically incremented by the `lodsb` instruction. Duplicate
    the address into the EDI register, as we will be storing data back.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据替换到 ESI 寄存器中，以避免计算索引，因为 ESI 寄存器会被 `lodsb` 指令自动递增。将地址复制到 EDI 寄存器中，因为我们将把数据存回。
- en: You may as well process the 16 byte value from the last byte to the first by
    loading ESI and EDI with `lea esi, [needs_substitution + 0x0f]`, duplicating the
    address to EDI and setting the direction flag with the `std` instruction. Do not
    forget to clear the direction flag with the `cld` instruction when done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过从最后一个字节到第一个字节处理 16 字节的值，加载 ESI 和 EDI 寄存器为 `lea esi, [needs_substitution
    + 0x0f]`，将地址复制到 EDI，并使用 `std` 指令设置方向标志。完成后，别忘了使用 `cld` 指令清除方向标志。
- en: 'We then sequentially read each byte of the value, substitute it with a byte
    form the s-box with the XLAT instruction, and store the result back. As an alternative
    to the XLAT instruction (which is limited to 256 byte tables and may only operate
    on byte values depending on the AL register), we can write the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们顺序读取值的每个字节，用 XLAT 指令将其替换为来自 S-box 的字节，并将结果存回。作为 XLAT 指令的替代方案（XLAT 指令限制为
    256 字节的表，并且只能在 AL 寄存器依赖的字节值上操作），我们可以写出以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, we would have needed to set the whole EAX register to 0 prior to entering
    the loop, while XLAT allows the upper 24 bits of the EAX register to remain unchanged
    throughout the whole operation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要在进入循环之前将整个 EAX 寄存器置为 0，而 XLAT 允许 EAX 寄存器的高 24 位在整个操作过程中保持不变。
- en: Arrays of words, double words, and quad words
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字数组、双字数组和四字数组
- en: 'The previous simple example illustrates a trivial byte array and how we can
    access its members. The same would apply to arrays of words, double words, or
    quad words with a few additions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的简单示例展示了一个简单的字节数组，以及如何访问其成员。对于字数组、双字数组或四字数组，只需要做一些扩展，方法是：
- en: We cannot use XLAT on arrays bigger than 256 bytes, nor if members of an array
    are bigger than 8 bits
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在大于 256 字节的数组上使用 XLAT，也不能在数组成员大于 8 位时使用 XLAT。
- en: We would need to use SIB addressing (scale index base) in order to access array
    members bigger than one byte
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用 SIB 寻址（比例索引基址）来访问大于一个字节的数组成员。
- en: On 32-bit systems we would not be able to read a quad word into a single register
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 32 位系统上，我们无法将一个四字节值读入单个寄存器。
- en: For the sake of a simple example, let's consider using a lookup table for the
    calculation of the factorial for numbers in the range of 0 to 12 (this code is
    for 32-bit and factorials of larger numbers would not fit into a double word).
    Although the algorithm of factorial calculation is rather simple, using a lookup
    table even for such a short range is much more convenient.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们考虑使用一个查找表来计算 0 到 12 范围内数字的阶乘（此代码适用于 32 位，较大的数字的阶乘无法适应双字）。虽然阶乘计算的算法相当简单，但即使是如此短的范围，使用查找表要方便得多。
- en: 'First, put the following into the data section (you may put this into the code
    section too, as we are not going to change any value here, but let''s keep data
    with the data):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容放入数据段（你也可以将其放入代码段，因为我们这里不会更改任何值，但让我们把数据与数据放在一起）：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is our lookup table containing 13 values of factorials for numbers in
    the range of 0 to 12, where each entry is double word (32 bit). Now, let''s write
    a procedure that would use this table. The procedure will be implemented in accordance
    with the `stdcall` calling convention; it receives a single parameter, the number
    for which we need a factorial, and returns a factorial for the given number or
    0 if the number is not in the allowed range (as 0 cannot be a value of factorial).
    Put the following code into the code section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的查找表，包含了 13 个阶乘值，范围从 0 到 12，每个条目是双字（32 位）。现在，让我们编写一个过程来使用这个表。这个过程将按照`stdcall`调用约定实现；它接收一个参数，即我们需要计算阶乘的数字，并返回该数字的阶乘值，如果数字不在允许的范围内，则返回
    0（因为 0 不能是阶乘的值）。将以下代码放入代码段：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `virtual` directive lets us virtually define data at a specific address.
    In the preceding example, we defined a variable that points to the place on the
    stack where the parameter is stored. Everything we define within the `virtual`
    block is treated as a legal label by the assembler. In this case, the `arg0` translates
    to `ebp + 8`. If we had two or even more parameters passed to the procedure on
    stack, we could write the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual` 指令允许我们在特定地址虚拟定义数据。在前面的例子中，我们定义了一个指向存储参数的堆栈位置的变量。在`virtual`块内定义的所有内容都被汇编器视为合法标签。在这种情况下，`arg0`
    转换为 `ebp + 8`。如果我们有两个甚至更多通过堆栈传递给过程的参数，我们可以这样写：'
- en: '`virtual at ebp + 8`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual at ebp + 8`'
- en: '`arg0 dd ?`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg0 dd ?`'
- en: '`arg1 dd ?`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg1 dd ?`'
- en: '`; the rest`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`; 其余部分`'
- en: '`end virtual`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`end virtual`'
- en: Here, `arg1` would be translated to `ebp+12`, `arg2` (if defined), `ebp+16`,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`arg1` 会被转换为 `ebp+12`，`arg2`（如果定义了的话）为 `ebp+16`，以此类推。
- en: 'The procedure is indeed very simple as all it does is this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程确实非常简单，它做的就是这个：
- en: Checks whether the parameter fits the range
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查参数是否适合范围
- en: Returns `0` if the parameter does not fit the range
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数不符合范围，则返回`0`
- en: Uses the parameter as an index into the lookup table and returns a value referenced
    by the base address of the tables plus index (our parameter) times size of entries
    in the table
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数作为查找表中的索引，并返回由表的基地址加上索引（我们的参数）乘以表中条目的大小所引用的值
- en: Structures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: As a developer, I believe you would agree that most of the time we are not working
    with arrays of uniform data (I am definitely not underestimating the power of
    a regular array). Since data may be anything, starting with 8-bit numbers and
    ending with complex structures, we need a way to describe such data for the assembler,
    and the term *structure* is the key. Flat Assembler, just as any other assembler,
    lets us declare structures and treat them as additional types of data (similar
    to the `typedef` struct in C).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我相信你会同意，大多数时候我们处理的不是统一数据的数组（我绝对不是低估常规数组的强大）。由于数据可以是任何东西，从 8 位数字到复杂结构体，我们需要一种方式来为汇编器描述这些数据，而“结构体”这一术语就是关键。Flat
    Assembler 和其他任何汇编器一样，允许我们声明结构体，并将其作为额外的数据类型（类似于 C 语言中的`typedef`结构）来使用。
- en: 'Let''s declare a simple structure, an entry of a string table, and then see
    what is what:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个简单的结构体，即字符串表的一个条目，然后看看它是什么：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dot (`.`) preceding the names of members of the struct denotes that they
    are part of a larger namespace. In this specific case, the name `*.length*` belongs
    to `strtabentry`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体成员名前面的点符号 (`.`) 表示它们是更大命名空间的一部分。在这个具体的例子中，`*.length*`属于 `strtabentry`。
- en: 'Such a declaration would be equivalent to the following one in C:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的声明在 C 语言中相当于以下声明：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, while in C, we would have to initialize the variable of the type `strtabentry`,
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 C 语言中，我们必须初始化类型为`strtabentry`的变量，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Assembly, or to be more precise, when using Flat Assembler, we would initialize
    such a variable in a simpler way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，或者更准确地说，在使用 Flat Assembler 时，我们会以更简单的方式初始化这样的变量：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Either way, the structure is 32-bytes in size (as the string buffer is statically
    allocated and is 30 bytes) and has only two members:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，结构体的大小都是 32 字节（因为字符串缓冲区是静态分配的，大小为 30 字节），并且只有两个成员：
- en: '`length`: This is the word size integer containing the length of the string,
    plus 1 for a null terminator'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是包含字符串长度的字长整数，加 1 以包含 null 终止符'
- en: '`string`: This is the actual text'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：这是实际的文本'
- en: Addressing structure members
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问结构体成员
- en: 'A few words need to be said on how individual members of a structure may be
    addressed. When statically allocated, we may refer to a structure by its label/name,
    which is translated into its address. For example, if we have a `strtabentry`
    structure named `se` defined in our data section, and we need to read the *n*th
    byte from the string, all we have to do would be this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何访问结构体的各个成员，需要做一些说明。当结构体是静态分配时，我们可以通过它的标签/名称来引用结构体，这个标签会被转换成结构体的地址。例如，如果我们在数据段中定义了一个名为`se`的`strtabentry`结构，并且我们需要从字符串中读取第*n*个字节，那么我们所需要做的就是：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If, on the other hand, we cannot use a label (for example, we are in a procedure,
    and a pointer to a structure is its parameter), then we can use the mighty `virtual`
    directive. As a quick demonstration, here''s a procedure that returns the length
    of the string, not including the terminating zero:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们不能使用标签（例如，在一个过程内，而结构体的指针是其参数），那么我们可以使用强大的`virtual`指令。作为快速演示，这里是一个返回字符串长度的过程，不包括终止的零字符：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just to keep things fresh in memory, let''s take another look at the lines
    where we read the pointer from the stack and where we load AX with the length
    of the string. The first one is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助记忆，我们再看一下从栈中读取指针以及将字符串长度加载到AX寄存器的那几行。第一行如下所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code loads the parameter from the stack. As we remember, declaring
    a virtual label lets us assign a readable name to the memory locations that cannot
    be named otherwise, and the stack is one of the examples. In this specific case,
    `.structPtr` is translated into `ebp + 8`, thus the line itself is equivalent
    to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从栈中加载参数。正如我们所记得的，声明一个虚拟标签可以让我们为那些无法通过其他方式命名的内存位置赋予可读名称，而栈就是一个例子。在这个特定情况下，`.structPtr`
    转换为 `ebp + 8`，因此该行代码等价于以下内容：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, had there be a second parameter, the virtual declaration would look
    like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果有第二个参数，虚拟声明将如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In that case, reading the second parameter would be done like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，读取第二个参数将如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, it would translate into the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，它将转化为以下内容：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the second line we are interested in:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们感兴趣的第二行：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this specific case, we are accessing the first member of the structure -
    `.length`, which means that the line is translated into this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我们正在访问结构体的第一个成员—`.length`，这意味着该行代码可以转换为以下内容：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, should we need to access the string itself, for example, if we need
    to load a register with the address of the string, the code would look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们需要访问字符串本身，例如，如果我们需要加载一个寄存器以获取字符串的地址，代码将如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This would, in turn, translate into the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转化为以下形式：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Arrays of structures
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体数组
- en: By now, we are fine with everything regarding access to structures and members
    thereof, but what if we have more than one structure of the same type? We would
    naturally organize them into an array of structures. Looks simple, and partially
    so, it is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们在访问结构体及其成员方面已经没有问题了，但如果我们有多个相同类型的结构体该怎么办？我们自然会将它们组织成一个结构体数组。看起来很简单，部分而言，确实是的。
- en: 'In order to ease the process of accessing array members, we may use an array
    of pointers and access each structure in the array through a kind of lookup table.
    In this scenario, we would simply read a pointer from the lookup table with the
    following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化访问数组成员的过程，我们可以使用指针数组，并通过某种查找表访问数组中的每个结构体。在这种情况下，我们只需使用以下方式从查找表中读取指针：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having a pointer to the structure of interest, we continue the work as usual.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有指向感兴趣结构体的指针后，我们照常继续工作。
- en: Our example structure is very convenient due to its size, which is only 32 bytes.
    Should we arrange many structures of this type into an array, we would be able
    to painlessly access them in an array of 134,217,727 members (on a 32-bit system),
    which is 4 GB in terms of occupied memory. While we would hardly need this number
    of strings with a maximum length of 30 bytes (or such a number of strings at all),
    the addressing in this specific case is very simple (again, due to the comfortable
    size of the structure). We still use the index in the array of structures, but,
    as we cannot use the scale part of SIB addressing to scale the index by 32 bytes,
    we need to multiply the index itself prior to accessing the array.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例结构非常方便，因为它的大小仅为32字节。如果我们将许多此类结构排列成一个数组，我们将能够轻松地访问一个包含134,217,727个成员的数组（在32位系统上），该数组占用4GB的内存。虽然我们几乎不会需要这么多最大长度为30字节的字符串（或者根本不需要这么多字符串），但在这种特定情况下，地址计算非常简单（再次强调，得益于结构体的舒适大小）。我们仍然使用结构体数组中的索引，但是由于不能利用SIB寻址的比例部分将索引按32字节进行缩放，我们需要在访问数组之前先对索引进行乘法运算。
- en: 'Let''s define a macro instruction that would create such an array in the first
    place (building the pointer lookup table for demonstration purposes too):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个宏指令，用来首先创建这样的数组（同时构建指针查找表以供演示）：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The invocation of the preceding macro, with the following parameters, is as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面宏的调用，使用以下参数，形式如下：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would result in the following arrangement of data in memory:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致内存中数据的以下排列：
- en: '![](img/2f21d06a-2d07-4cd2-9739-100c84f67fae.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f21d06a-2d07-4cd2-9739-100c84f67fae.png)'
- en: As you can see, the `strtabName_ptr` variable contains the number of structures/pointers
    in the array followed by the array of four pointers. Next, at `strtabName`, (we
    can choose whatever name we want when invoking the macro as long as it fits the
    naming restrictions), we have the actual array of four structures.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`strtabName_ptr` 变量包含数组中的结构体/指针数量，后面跟着四个指针的数组。接下来，在 `strtabName` 处（我们可以在调用宏时选择任何符合命名规则的名称），我们有了四个结构体的实际数组。
- en: 'Now, should we need to retrieve the length of a string in the structure at
    index 2 (indices are zero based), we would modify the `get_string_length` procedure
    so that it would accept two parameters (pointer to structure array and index)
    in the following way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要检索结构体中索引为 2 的字符串长度（索引从 0 开始），我们将修改 `get_string_length` 程序，使其接受两个参数（结构体数组指针和索引），如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The procedure call would be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用将如下所示：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Arrays of pointers to structures
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指向结构体的指针数组
- en: 'The previous subsection shows us how to approach arrays of uniform structures.
    As there is no particular reason to have string buffers of fixed size and, therefore,
    no reason for a fixed size structure, let''s first of all make a tiny correction
    to the structure declaration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前一小节向我们展示了如何处理均匀结构体的数组。由于没有特别的理由需要固定大小的字符串缓冲区，因此也没有必要使用固定大小的结构体。首先，我们需要对结构体声明做一点小修正：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We only removed the `.pad` member of the `strtabentry` structure, thus allowing
    it to be of variable size. Obviously, we may no longer use the same `get_string_length`
    procedure as we have no constant step to iterate through the array. But you might
    have definitely noticed the `strtabName_ptr` structure in the preceding image.
    This structure is there to help us solve the problem of lack of a fixed step.
    Let''s rewrite the `get_string_length` procedure so that it would accept a pointer
    to an array of pointers to structures, rather than a pointer to the array itself
    and an index of the desired structure. The procedure would then look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只移除了 `strtabentry` 结构体中的 `.pad` 成员，使其可以具有可变大小。显然，我们不能再使用相同的 `get_string_length`
    程序，因为我们没有固定的步长来遍历数组。但你可能已经注意到前面图像中的 `strtabName_ptr` 结构。这个结构就是用来帮助我们解决没有固定步长的问题的。我们可以重写
    `get_string_length` 程序，使它接受一个指向结构体数组指针的指针，而不是直接接受数组指针和目标结构体的索引。修改后的程序如下所示：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Voila! We only had to make a few tiny modifications, add a line here and a line
    there, and now we are able to handle structures of variable sizes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我们只需要做一些小的修改，添加这一行，再加上一行，现在我们就能够处理具有可变大小的结构体了。
- en: Nothing complicated thus far, nothing complicated to follow. While there are
    not too many types of data, there are more ways to arrange it. While the structure
    may be considered both a data type and a method of arrangement for non-uniform
    data, we will, for convenience, treat it as a type that we are free to define.
    By now, we have seen how data may be arranged in static memory when the arrangement
    thereof is not expected to change, but what if we are dealing with dynamic data
    when the amount of data is not known at the time of writing the code? In such
    case we should know how to deal with dynamic data. This leads us to the next stage
    in data arrangement-linked lists and their types.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，内容并不复杂，接下来的内容也不难理解。虽然数据类型不多，但它的排列方式却有很多。结构体可以被视为一种数据类型，也可以看作是非均匀数据的排列方法，但为了方便起见，我们将其视为一个可以自由定义的数据类型。到现在为止，我们已经看到了当数据排列在静态内存中且排列不变时的情况，但是如果我们正在处理动态数据，而数据量在编写代码时无法确定该怎么办呢？在这种情况下，我们需要知道如何处理动态数据。这就引出了数据排列的下一个阶段——链表及其类型。
- en: Linked lists
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: 'Linked lists, as the name suggests, consists, of data items (nodes) that are
    linked to one another by means of pointers. Basically, there are two types of
    linked lists:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 链表顾名思义，由通过指针相互连接的数据项（节点）组成。基本上，链表有两种类型：
- en: '**Linked list**: This is where each node has a pointer to the following node'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链表**：每个节点都有指向下一个节点的指针'
- en: '**Doubly linked list**: This is where each node has a pointer to the following
    and previous nodes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向链表**：每个节点有指向下一个节点和前一个节点的指针'
- en: 'The following diagram illustrates the difference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了两者之间的区别：
- en: '![](img/e9b56891-f667-4363-bfa9-0e555b403f5b.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9b56891-f667-4363-bfa9-0e555b403f5b.png)'
- en: Linked lists of both types may be addressed in a few ways. Obviously, there
    is at least a pointer to the first node of the list (called `top`), which is optionally
    accompanied by a pointer to the last node of the list (called `tail`). There is,
    of course, no limit to the amount of auxiliary pointers, should there be a need
    for such. Pointer fields in the nodes are typically referred to as `next` and
    `previous`. As we can see in the diagram, the last node of a linked list and the
    first and the last nodes of a doubly linked list have `next`, `previous`, and
    `next` fields that point nowhere-such pointers are considered terminators denoting
    the end of the list and are typically populated with null values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的链表都可以通过几种方式进行寻址。显然，链表中至少有一个指向第一个节点的指针（称为`top`），可选地伴随有一个指向链表最后一个节点的指针（称为`tail`）。当然，若有需要，还可以添加多个辅助指针。节点中的指针字段通常称为`next`和`previous`。正如我们在图示中看到的，链表的最后一个节点以及双向链表中的第一个和最后一个节点都有`next`、`previous`和`next`字段，这些字段不指向任何地方——这样的指针被视为终止符，表示链表的结束，并且通常会填充`null`值。
- en: 'Before proceeding to the sample code, let''s make a tiny change to the structure
    we''ve been using in this chapter and add the `next` and `previous` pointers.
    The structure should look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续示例代码之前，让我们对本章使用的结构体做一个小改动，添加`next`和`previous`指针。结构体应该如下所示：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will leave the `make_strtab` macro intact as we still need something to build
    a set of `strtabentry` structures; however, we will not consider it to be an array
    of structures any more. Also, we will add a variable (of type double word) to
    store the `top` pointer. Let's name it `list_top`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留`make_strtab`宏不变，因为我们仍然需要一些东西来构建`strtabentry`结构体的集合；然而，我们将不再把它视为结构体数组。同时，我们将添加一个变量（类型为双字）来存储`top`指针。我们把它命名为`list_top`。
- en: 'Instead or writing a macro instruction that would link the four structures
    into a doubly linked list, we will write a procedure for adding new nodes to the
    list. The procedure requires two parameters--a pointer to the `list_top` variable
    and a pointer to the structure we want to add to the list. If we were writing
    in C, then the prototype of the corresponding function would be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再编写一个宏指令来将四个结构体连接成一个双向链表，而是编写一个过程来向列表中添加新节点。这个过程需要两个参数——指向`list_top`变量的指针和指向我们想要添加到列表中的结构体的指针。如果我们是在C语言中编写，则对应函数的原型如下：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, since we are not writing in C, we will put down the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们并非在编写C语言，我们将写下以下代码：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, having the procedure ready, we will call it from our main procedure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，过程已经准备好，我们将从主过程调用它：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first, second, third, and fourth refers to positions of structures in memory,
    not to positions of nodes in the doubly linked list. Thus, after the last line
    of the preceding code is executed, we have a doubly linked list of `strtabentry`
    structures (shown by their position in the linked list) `{0, 2, 3, 1}`. Let''s
    take a look at the following screenshot for a demonstration of the result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一、第二、第三和第四个指的是结构体在内存中的位置，而不是双向链表中节点的位置。因此，在执行前面代码的最后一行后，我们得到一个由`strtabentry`结构体组成的双向链表（通过其在链表中的位置显示）`{0,
    2, 3, 1}`。让我们通过以下截图来看一下结果的演示：
- en: '![](img/9782b7f6-79df-419a-8f6f-20d3ef962d33.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9782b7f6-79df-419a-8f6f-20d3ef962d33.png)'
- en: For the sake of convenience, the structures are named `struct_0`, `struct_1`,
    `struct_2`, and `struct_3` in accordance with the order of their appearance in
    memory. The last line is the `top` pointer `list_top`. As we can see, it points
    to `struct_0`, which was the last we added to the list, and `struct_0`, in turn,
    only has a pointer to the next structure, while its `previous` pointer has a `NULL`
    value. The `struct_0` structure's `next` pointer points to `struct_2`, `struct_2`
    structure's `next` points to `struct_3`, and the previous pointers lead us back
    in the reverse order.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，结构体按其在内存中出现的顺序命名为`struct_0`、`struct_1`、`struct_2`和`struct_3`。最后一行是`top`指针`list_top`。如我们所见，它指向`struct_0`，这是我们最后添加到列表中的结构体，而`struct_0`反过来只包含一个指向下一个结构体的指针，同时它的`previous`指针的值为`NULL`。`struct_0`结构体的`next`指针指向`struct_2`，`struct_2`结构体的`next`指针指向`struct_3`，而`previous`指针则以相反顺序引导我们返回。
- en: 'Obviously, linked lists (those with a single, either forward or backward),
    link are a bit simpler than doubly linked lists as we only have to take care of
    a single pointer member of a node. It may be a good idea to implement a separate
    structure that describes a linked list node (whether simple or doubly linked)
    and have a set of procedures for the creation/population of linked lists, search
    of a node, and removal of a node. The following structure would suffice:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，链表（单向链表，无论是前向还是后向）比双向链表要简单一些，因为我们只需要处理节点中的单个指针成员。实现一个描述链表节点（无论是简单链表还是双向链表）的单独结构，并为创建/填充链表、查找节点和删除节点编写一套过程，可能是个好主意。以下结构就足够了：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If, on the other hand, you are writing code for the long mode (64-bit), the
    only change you need to make is replacing `dd` (which stands for a 32-bit double
    word) with `dq` (which stands for a 64-bit quad word) in order to be able to store
    long mode pointers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写长模式（64位）的代码，那么唯一需要做的改变是将`dd`（表示32位双字）替换为`dq`（表示64位四字），以便能够存储长模式指针。
- en: In addition to this, you may also want or need to implement a structure that
    will describe a linked list, as a whole, having all the required pointers, counters,
    and so on (in our example, it was the `list_top` variable; not quite a structure,
    but it did its job well enough). However, when it comes to an array of linked
    lists, it would be much more convenient to utilize an array of pointers to linked
    lists, as this would provide easier access to members of the array, thus making
    your code less error prone, simpler, and faster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你可能还想或需要实现一个描述整个链表的结构，拥有所有必要的指针、计数器等（在我们的示例中，它是`list_top`变量；虽然不是严格意义上的结构体，但它完成了任务）。然而，谈到链表数组时，使用指向链表的指针数组会更方便，因为这将使访问数组中的成员更加容易，从而使代码更少出错、更简单和更快速。
- en: Special cases of linked lists
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表的特殊情况
- en: You have, most likely, heard a lot about different types of data structures
    other than arrays and linked lists in programming lessons, unless you are a self-taught
    developer, in which case you may still have heard or read about these a lot. By
    different types of data structures other than arrays and linked lists, I mean
    stacks, queues, deques, and priority queues. However, being a fan of the principle
    of Occam's Razor, I believe that we should face the truth and acknowledge that
    all of these are just special cases of linked lists, unless their implementation
    is based on arrays (which may sometimes be possible).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是自学成才的开发者，否则你很可能已经在编程课上听过很多除了数组和链表之外的不同数据结构，在这种情况下，你可能仍然听说过或读过这些内容。这里所指的不同数据结构是堆栈、队列、双端队列和优先队列。然而，作为奥卡姆剃刀原则的拥护者，我相信我们应该面对现实，承认所有这些都只是链表的特殊情况，除非它们的实现是基于数组的（在某些情况下这也可能是可行的）。
- en: Stack
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: A stack is a **LIFO** (**Last In First Out**) arrangement of data. The simplest
    example would be the process/thread stack. Although such an implementation is
    rather array based, it fairly illustrates the mechanism.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是**LIFO**（**后进先出**）的数据排列方式。最简单的例子是进程/线程堆栈。尽管这种实现方式主要基于数组，但它很好地展示了这一机制。
- en: 'However, most of the time, we would not know the size of the required stack
    in advance, maybe just a rough estimation. Not to mention the fact that we would
    hardly need to store only double or quad words; we''ll mostly have more complex
    structures. The most common implementation of a stack would be a singly linked
    list addressed by a `top` pointer only. Ideally, only three operations are permitted
    on a stack:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，我们无法提前知道所需堆栈的大小，可能只能做一个大致估算。更不用说我们几乎不需要只存储双字或四字；我们大多数时候会有更复杂的结构。堆栈的最常见实现是一个仅由`top`指针管理的单向链表。理想情况下，堆栈上只允许进行三种操作：
- en: '`push`: This is used to add a new member to the list'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`：用于向列表中添加一个新成员'
- en: '`top`: This is used to view/read the last added member of the list'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`：用于查看/读取列表中最后添加的成员'
- en: '`pop`: This is used to remove the last added member from the list'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`：用于移除列表中最后添加的成员'
- en: While the `push` and `pop` operations are equivalent to adding and removing
    a member from/to a singly linked list, the TOP operation basically means getting
    the value of the `top` pointer and so obtaining access to the topmost (added last)
    member of the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`push`和`pop`操作类似于在单向链表中添加和删除成员，但`TOP`操作基本上是获取`top`指针的值，从而访问链表中最上面的（最后添加的）成员。
- en: Queue and deque
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列与双端队列
- en: Queues are, exactly as the name states, queues of elements. A linked list is
    addressed by two pointers-one for the `top` element and one for the `tail` element.
    By nature, queues are a **FIFO** (**First In First Out**) arrangement of data,
    meaning that the element that was pushed first is to be popped first, too. It
    is totally up to you to decide where the queue starts and where it ends-whether
    `top` is the beginning or the end of a queue, and the same for `tail`. Should
    we want to convert the example of a linked list we used in this chapter to a queue,
    we would only need to add a `list_tail` pointer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 队列正如名称所示，是一组元素的队列。链表通过两个指针进行访问——一个指向`top`元素，另一个指向`tail`元素。就本质而言，队列是**FIFO**（**先进先出**）的数据排列方式，这意味着最先入队的元素也会最先出队。队列的开始和结束完全由你决定——`top`是队列的开始还是结束，`tail`也是一样。如果我们希望将本章中使用的链表示例转换为队列，只需要添加一个`list_tail`指针。
- en: Deques are double-ended queues, which means that elements may be pushed into
    the queue either at the `top` element or at the `tail` element depending on the
    algorithm. The same is true for popping elements from the queue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列是双向队列，这意味着元素可以根据算法从`top`元素或`tail`元素推入队列。同样地，弹出元素时也是如此。
- en: Priority queues
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A priority queue is a special case of a regular queue. The only difference is
    that elements added to it each have a certain priority, which is defined by the
    algorithm and depends on the needs. The idea is that elements with a higher priority
    are served first, then the elements with lower priorities. If two elements have
    the same priority, then the order they are served in is in accordance with their
    position in the queue, so there are at least two possible ways to implement such
    an arrangement.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列是常规队列的一种特例。唯一的区别是，加入其中的元素每个都有一定的优先级，这由算法定义，并根据需求来确定。其思想是，优先级高的元素先被服务，然后是优先级低的元素。如果两个元素具有相同的优先级，那么它们被服务的顺序是根据它们在队列中的位置来决定的，因此至少有两种可能的方式来实现这种排列。
- en: One would be the implementation of a sorting algorithm, which would add new
    elements according to their priority. This merely converts deque into a sorted
    list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方式是排序算法，它会根据元素的优先级来添加新元素。这仅仅是将双端队列转换为一个排序列表。
- en: The other would be combing a deque for elements with the highest priority and
    serving them first, which makes a deque not much different from a linked list.
    The only difference, probably, would be that elements may be added only to the
    `top` element or the `tail` element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法是通过双端队列来寻找具有最高优先级的元素并优先服务它们，这使得双端队列与链表没有太大区别。唯一的区别，可能是元素只能被添加到`top`元素或`tail`元素。
- en: Cyclic linked list
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: A cyclic linked list is probably the easiest to implement following the singly
    linked list. The only difference between the two is that the last element of the
    list points to the first element of the list, instead of its `next` pointer having
    a `NULL` value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表可能是仅次于单链表最容易实现的。两者之间的唯一区别是，链表的最后一个元素指向链表的第一个元素，而不是其`next`指针指向`NULL`。
- en: Summary for special cases of linked lists
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表特殊情况总结
- en: As we can see, the special cases of linked lists shown previously are simply
    different logical paradigms of the same idea. This is especially true in the case
    of Assembly, which, unlike higher-level languages (those higher than C), does
    not have any built-in implementation of the preceding approaches, thus performing
    the function of Occam's Razor, sweeping away redundant notions and showing how
    things are in low-level reality.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，之前提到的链表的特殊情况实际上只是同一思想的不同逻辑范式。在汇编语言的情况下尤其如此，与更高级的语言（如C语言以上）不同，汇编语言没有内置的实现这些方法，因此它发挥了奥卡姆剃刀的作用，剔除了多余的概念，展示了低级现实中的事物。
- en: 'However, we''ll consider what Albert Einstein said:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要考虑阿尔伯特·爱因斯坦说过的话：
- en: '"Everything should be made as simple as possible, but not simpler."'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “一切事物应尽可能简单，但不能更简单。”
- en: Having made the topic of linked lists and their special cases as simple as possible,
    we need to proceed to more complex, more powerful forms of data arrangement. In
    the next section of this chapter, we will meet trees-a very powerful and useful
    method to store data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在将链表及其特殊情况尽可能简化后，我们需要继续处理更复杂、更强大的数据排列形式。在本章的下一节中，我们将介绍树——一种非常强大且有用的数据存储方法。
- en: Trees
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: Sometimes, the data arrangement schemes we have already covered are not ideal
    for solving certain problems. For example, when having a set of data that is frequently
    being searched or modified, while having to maintain a sorted nature, we could
    place it into an array or a sorted linked list, but the search times could be
    non-satisfactory. In such a case, it would probably be best to arrange the data
    in the form of a tree. A binary search tree, for instance, is the best way to
    minimize the search time when searching dynamic (changing) data. In fact, the
    same applies to static data as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们已经覆盖的数据排列方案并不适合解决某些问题。例如，当处理一组经常被搜索或修改的数据，并且需要保持排序时，我们可以将它们放入数组或有序链表中，但搜索时间可能不理想。在这种情况下，最好将数据安排成树的形式。例如，二叉搜索树就是在搜索动态（变化的）数据时，最小化搜索时间的最佳方式。实际上，这同样适用于静态数据。
- en: 'But, first of all, what are trees in computing? When talking about trees, one
    may imagine a special type of graph (graphs will be briefly covered later in this
    chapter), consisting of nodes which have a parent node (except the root node,
    which is called, well, root node) and zero or more child nodes. In Assembly, we
    would declare a structure for a tree node like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是计算机中的树结构？谈到树结构时，人们可能会想到一种特殊类型的图（图将在本章后面简要介绍），它由一些节点组成，每个节点都有一个父节点（根节点除外，根节点通常称为“根节点”），并且可能有零个或多个子节点。在汇编语言中，我们可以像这样声明树节点的结构：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So, we have a structure which has a pointer to the left child node (traditionally,
    nodes with a lower value), a pointer to the right child node (traditionally, nodes
    with a higher value), and a pointer to the data represented by the node. In general,
    it is not a bad idea to add a pointer to the parent node, which may ease the task
    of balancing a tree; however, we do not need that for the example that we will
    examine in this part of the chapter. The preceding node structure is sufficient
    for building a tree like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有一个结构，它包含指向左子节点的指针（传统上，左子节点的值较小），指向右子节点的指针（传统上，右子节点的值较大），以及指向节点表示的数据的指针。通常来说，添加指向父节点的指针并不是一个坏主意，这有助于平衡树结构；然而，在本章接下来的例子中，我们并不需要这个指针。上面的节点结构就足够用于构建这样的树结构：
- en: '![](img/bed40237-dba5-4b61-b8a1-470acbfb6cce.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bed40237-dba5-4b61-b8a1-470acbfb6cce.png)'
- en: This figure demonstrates an ideal case of a balanced binary search tree. In
    reality, however, this happens not that often and depends on the balancing method.
    Unfortunately, methodologies of tree balancing slightly fall out of the scope
    of this book. The main idea, though, is to keep lower values to the left and higher
    values to the right, which may well involve a certain amount of rotation applied
    to subtrees, or even the whole tree.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图展示了一个理想的平衡二叉搜索树的情况。然而，在实际情况中，这并不常见，而且取决于平衡方法。不幸的是，树的平衡方法稍微超出了本书的范围。不过，主要的思路是将较小的值放在左边，将较大的值放在右边，这通常涉及对子树，甚至是整个树，应用一定的旋转操作。
- en: A practical example
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际的例子
- en: Enough with dry explanations. Being a developer, you are most likely familiar
    with tree-like structures and methods of balancing thereof, or you must have at
    least heard of them. Believing in learning by example as one of the most efficient
    ways of understanding something, I suggest we take a look at the following example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，别再讲枯燥的解释了。作为开发者，你很可能已经熟悉了树状结构及其平衡方法，或者至少听说过这些方法。相信通过实例学习是理解事物最有效的方式之一，我建议我们看一下下面的例子。
- en: Example - trivial cryptographic virtual machine
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例——简单的加密虚拟机
- en: The idea behind this example is widely used and well known-a simple, not to
    say primitive, virtual machine. Imagine a situation where we have to implement
    a virtual machine that performs trivial string encryption with an XOR operation
    using a single byte key.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的思路广泛应用并且非常著名——一个简单的，不得不说是原始的，虚拟机。假设我们需要实现一个虚拟机，用一个单字节的密钥，通过异或操作来执行简单的字符串加密。
- en: Virtual machine architecture
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机架构
- en: 'The architecture of the virtual processor is quite simple-it has a few registers
    that store the current execution state:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟处理器的架构相当简单——它有几个寄存器，用于存储当前的执行状态：
- en: '| **Register Name** | **Register function** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器名称** | **寄存器功能** |'
- en: '| `register_a` | An 8-bit general purpose register. The register is accessible
    to the VM code. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `register_a` | 一个8位通用寄存器。该寄存器可以被虚拟机代码访问。 |'
- en: '| `register_b` | An 8-bit general purpose register. The register is accessible
    to the VM code. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `register_b` | 一个8位通用寄存器，该寄存器可以被虚拟机代码访问。 |'
- en: '| `register_key` | An 8-bit register. This holds the encryption key byte. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `register_key` | 一个8位寄存器，存储加密密钥字节。 |'
- en: '| `register_cnt` | An 8-bit register. This holds the counter for `vm_loop`
    instruction. The register is accessible to VM code. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `register_cnt` | 一个8位寄存器，存储`vm_loop`指令的计数器。该寄存器可以被虚拟机代码访问。 |'
- en: '| `data_base` | A 32-bit (64-bit for the long mode) register. This holds the
    address of the data to be encrypted. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `data_base` | 一个32位寄存器（长模式下为64位寄存器）。存储要加密数据的地址。 |'
- en: '| `data_length` | A 32-bit register. This holds the length of the data to be
    encrypted (only 8 bits are used, so the data cannot be longer than 256 bytes).
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `data_length` | 一个32位寄存器，存储要加密数据的长度（仅使用8位，因此数据不能超过256字节）。 |'
- en: 'The virtual processor has a very limited instruction set, but they are not
    encoded sequentially:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟处理器的指令集非常有限，但它们并不是按顺序编码的：
- en: '| **Opcode** | **Mnemonic** | **Meaning** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **助记符** | **含义** |'
- en: '| 0x00 | `vm_load_key` | This loads the `key` parameter of the VM procedure
    into the `key` register of the virtual processor. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0x00 | `vm_load_key` | 将虚拟机过程的`key`参数加载到虚拟处理器的`key`寄存器中。 |'
- en: '| 0x01 | `vm_nop` | This is the NOP instruction. No operation is performed.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | `vm_nop` | 这是NOP指令，表示不执行任何操作。 |'
- en: '| 0x02 | `vm_load_data_length` | This loads the length of the string to be
    encrypted into the `data length` register of the virtual processor. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | `vm_load_data_length` | 将要加密的字符串长度加载到虚拟处理器的`data length`寄存器中。 |'
- en: '| 0x10 | `vm_loop target` | This jumps to `target` if the `counter` register
    is less than the `data length` register. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | `vm_loop target` | 如果`counter`寄存器小于`data length`寄存器，则跳转到`target`。
    |'
- en: '| 0x11 | `vm_jump target` | This unconditionally jumps to the `target` address.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0x11 | `vm_jump target` | 无条件跳转到`target`地址。 |'
- en: '| 0x12 | `vm_exit` | This notifies the virtual processor that it should stop.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 0x12 | `vm_exit` | 通知虚拟处理器停止运行。 |'
- en: '| 0x20 | `vm_encrypt regId` | Performs the XOR operation on the content of
    `register[regId]` with the content of the key `register`. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 0x20 | `vm_encrypt regId` | 对`register[regId]`的内容和`key`寄存器的内容进行异或操作。 |'
- en: '| 0x21 | `vm_decrement regId` | This decrements the content of `register[regId]`.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 0x21 | `vm_decrement regId` | 递减`register[regId]`的内容。 |'
- en: '| 0x22 | `vm_increment regId` | This increments the content of `register[regId]`.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 0x22 | `vm_increment regId` | 递增`register[regId]`的内容。 |'
- en: '| 0x30 | `vm_load_data_byte regId` | Load byte from `data_base_address + counter_register`
    into `register[regId]`. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0x30 | `vm_load_data_byte regId` | 从`data_base_address + counter_register`加载字节到`register[regId]`中。
    |'
- en: '| 0x31 | `vm_store_data_byte regId` | Store byte from `register[regId]` to
    `data_base_address + counter_register`. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 0x31 | `vm_store_data_byte regId` | 将`register[regId]`中的字节存储到`data_base_address
    + counter_register`中。 |'
- en: Adding support for a virtual processor to the Flat Assembler
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Flat Assembler添加虚拟处理器的支持
- en: 'We will skip the declaration of a separate structure for the processor; instead,
    its state will be stored on a stack. However, we do need to make some preparations.
    First of all, we need to make the Flat Assembler understand our mnemonics and
    create a proper binary output. For this purpose, we will create an additional
    source file and name it `vm_code.asm`. As it will contain declarations of macro
    instructions and the VM code, which will be treated as data, the inclusion of
    the file in the main source would be done by adding the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过为处理器声明单独结构的步骤；相反，处理器的状态将存储在堆栈中。不过，我们需要做一些准备工作。首先，我们需要让Flat Assembler理解我们的助记符并生成适当的二进制输出。为此，我们将创建一个附加的源文件，并命名为`vm_code.asm`。由于该文件将包含宏指令的声明和虚拟机代码（它们将作为数据处理），因此要在主源文件中包含此文件，可以通过添加以下内容：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add this line somewhere in the data section. The next step-we have to define
    macro instructions that can be translated into a binary output that our virtual
    processor can understand. This is a very powerful feature of FASM, as one may
    add support for almost any architecture with a set of macro instructions (which,
    by the way, is the exact idea behind the Flat Assembler G):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据部分的某个位置添加这一行。下一步，我们必须定义可以转换为虚拟处理器理解的二进制输出的宏指令。这是FASM的一个非常强大的功能，因为人们可以通过一组宏指令为几乎任何架构添加支持（顺便提一下，这正是Flat
    Assembler G的核心思想）：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Virtual code
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟代码
- en: 'Obviously, we did not write all of the preceding code just for fun; we need
    to write some code for the virtual processor. Since the architecture is very limited
    and restricted to a specific task, there are not too many options as to what the
    code may look like:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们写前面的所有代码不是为了好玩；我们需要为虚拟处理器编写一些代码。由于架构非常有限且专门针对特定任务，因此代码的形式选择不多：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The virtual processor
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟处理器
- en: Everything seems to be clear by now, except one thing-what does it all have
    to do with trees? We are almost there, as we have to implement the virtual processor
    itself, and that is what we are going to do here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切似乎都很清楚，除了一个问题——这一切与树有什么关系？我们快到了，因为我们必须实现虚拟处理器本身，这就是我们在这里要做的。
- en: The easiest and probably the most common implementation of a virtual processor
    is a `while()` loop, which runs by reading instructions from the VM's memory and
    selects a proper execution path with the `switch()` statement implemented as the
    **indirect jump** and **jump table** (the table of jump target addresses). Although
    our example would probably run best when implemented this way, and the architecture
    described below would fit better for a complex instruction set, it was intentionally
    made simple in order to avoid the need to discuss certain aspects that are clearly
    unrelated to the topic-trees.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟处理器最简单且可能最常见的实现是`while()`循环，它通过读取虚拟机内存中的指令运行，并通过实现为**间接跳转**和**跳转表**（跳转目标地址表）的`switch()`语句来选择合适的执行路径。尽管我们的示例可能在这种方式下运行效果最好，而且下面描述的架构更适合复杂指令集，但它故意简化以避免讨论那些与树形结构明显无关的方面。
- en: 'Our operation codes, as shown in the instruction/opcode table, are all 1 byte
    in size, plus a 1-byte or 4-byte operand (for instructions that require operand),
    and in range from `0x00` to `0x31`, with relatively large gaps. However, the amount
    of operation code allows us to arrange them in an almost perfect binary search
    tree:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如指令/操作码表所示，我们的操作码都是1字节大小，再加上一个1字节或4字节的操作数（对于需要操作数的指令），范围从`0x00`到`0x31`，并且有相对较大的间隔。然而，操作码的数量使我们可以将它们安排成一个几乎完美的二叉搜索树：
- en: '![](img/f1b36c80-d801-463f-a74d-05bd9090ed15.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b36c80-d801-463f-a74d-05bd9090ed15.png)'
- en: We say "almost" because if there were two child nodes for each of the nodes
    denoting opcodes `0x11` (`vm_jump`) and `0x20` (`vm_encrypt`), it would be an
    ideal binary search tree (but who says we cannot add four more instructions?).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说“几乎”是因为如果每个表示操作码`0x11`（`vm_jump`）和`0x20`（`vm_encrypt`）的节点都有两个子节点，那么它将是一个理想的二叉搜索树（但谁说我们不能再添加四个指令呢？）。
- en: 'Each node on the diagram represents a `tnode` structure containing all the
    necessary pointers, including a pointer to a small structure, which maps the operation
    code to real Assembly code in the virtual processor''s loop:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个节点代表一个`tnode`结构，包含所有必要的指针，包括一个指向小结构的指针，该结构将操作码映射到虚拟处理器循环中的真实汇编代码：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thus, the first thing we do is build a table that maps all operation codes
    to Assembly code. The format of the table is rather simple. Each row contains
    the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要做的就是建立一个将所有操作码映射到汇编代码的表格。表格的格式相当简单。每行包含以下内容：
- en: Double word operation code
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双字操作码
- en: A pointer to the Assembly code (double word for the 32-bit mode or 64-bit for
    the long mode).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向汇编代码的指针（32位模式为双字，64位模式为长模式）。
- en: 'The implementation of the table in code is rather simple:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现表格相当简单：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At last, we have reached the tree. Let''s skip the tree building and balancing
    procedure, as the tree is statically allocated and as we are interested particularly
    in the structure itself. In the following code, we in fact create an array of
    `tnode` structures which, however, are not addressed by `base+index`, but are
    linked to a tree. The last line defines a pointer to the root node of the tree,
    `tree_root`, which refers to `t_exit`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了树。我们跳过树的构建和平衡过程，因为树是静态分配的，而且我们特别关注的是结构本身。在下面的代码中，我们实际上创建了一个`tnode`结构的数组，这些结构并不是通过`base+index`来访问，而是通过树进行连接。最后一行定义了一个指向树根节点`tree_root`的指针，它指向`t_exit`：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once compiled, the data section of the executable would look like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，执行文件的数据部分看起来是这样的：
- en: '![](img/007e7922-46b3-4932-b871-2bd66506b1b6.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/007e7922-46b3-4932-b871-2bd66506b1b6.png)'
- en: Searching the tree
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索树
- en: We need to take care of a procedure that would extract the correct address of
    the Assembly implementation of the virtual instruction from the tree prior to
    beginning the implementation of the virtual processor's loop.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理一个过程，该过程会在开始实现虚拟处理器循环之前从树中提取虚拟指令的汇编实现的正确地址。
- en: 'The `tree_lookup` procedure requires two parameters:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree_lookup`过程需要两个参数：'
- en: The address of the `tree_root` variable
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tree_root`变量的地址'
- en: The byte opcode cast to double word
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节操作码转换为双字（double word）。
- en: 'When this procedure is called, it "walks" the tree node by node (in accordance
    with the rule the tree was sorted by) and compares the opcode parameter to the
    opcode value of the instruction structure referred to by the current node. The
    procedure returns the address of the Assembly implementation of the operation
    code, or it returns a zero if no such opcode has been defined:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当此过程被调用时，它会按照树排序的规则逐个节点地“遍历”树，并将操作码参数与当前节点所引用的指令结构中的操作码值进行比较。该过程返回操作码的汇编实现地址，若未定义该操作码，则返回零：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The loop
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'The implementation of the loop is a bit long, and we have many more interesting
    things to fill the space allocated for this chapter, so refer to the accompanying
    source code for the full version. Here, however, we will examine certain parts
    of the implementation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的实现稍微有些长，并且我们有许多其他有趣的内容填充本章的空间，因此请参考附带的源代码获取完整版本。不过，在这里我们将检查实现的某些部分：
- en: '**Creating a stack frame and parameter markup**: The procedure''s prolog code
    would be just as usual-we allocate some space on the stack and save registers
    that we want not to be affected by the procedure, and that means all the registers
    we use in the procedure:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建栈帧和参数标记**：该过程的前导代码和往常一样——我们在栈上分配一些空间，并保存那些我们希望在过程执行过程中不受影响的寄存器，也就是过程中的所有寄存器：'
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Preparing a virtual processor loop**: The loop itself begins with reading
    an opcode from the current position in the virtual code, then calls the `tree_lookup`
    procedure, and either jumps to the address returned by `tree_lookup` or to `.exit`
    if the procedure returns an error (zero):'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备虚拟处理器循环**：该循环本身首先从当前虚拟代码的位置读取操作码（opcode），然后调用`tree_lookup`过程，若`tree_lookup`返回错误（零），则跳转至`.exit`，否则跳转至`tree_lookup`返回的地址：'
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code is followed by a set of instructions emulating code fragments,
    as you can see in the accompanying source code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码后面是模拟代码片段的指令集，如附带源代码中所示。
- en: 'The last few lines of the `run_vm` procedure are, in fact, the emulation of
    the `vm_exit` opcode:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_vm`过程的最后几行实际上是`vm_exit`操作码的仿真：'
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tree balancing
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树平衡
- en: 'Now, when we know what a binary search tree looks like on the Assembly programming
    level, it would not be correct not to return to the question of binary search
    tree balancing. There are several approaches to this problem, however, we would
    only consider one-the Day-Stout-Warren algorithm (included in the accompanying
    code). The algorithm is simple:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们知道了二叉搜索树在汇编编程级别上的样子时，若不回到二叉搜索树平衡的问题上就是不正确的。这个问题有几种解决方法，但我们只考虑其中一种——Day-Stout-Warren算法（包含在附带的代码中）。该算法非常简单：
- en: Allocate a tree node and make it a "pseudo root" for the tree, making the original
    root the pseudo root's right child.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个树节点，并将其作为树的“伪根”，使得原始根节点成为伪根的右子节点。
- en: Convert the tree into a sorted linked list by means of an in-order traversal
    (this step also calculates the number of nodes in the original tree). No additional
    allocations are required, as the step reuses existing pointers in tree nodes.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过中序遍历将树转换为排序的链表（此步骤还会计算原树中的节点数量）。不需要额外的分配，因为此步骤会重用树节点中已有的指针。
- en: Convert the list back into a complete binary tree (one in which the bottom layer
    is populated strictly from left to right).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将链表重新转换为完整的二叉树（其中最底层的节点从左到右严格填充）。
- en: Make pseudo root's right child the tree's root.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使伪根的右子节点成为树的根。
- en: Dispose of the pseudo root node.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理伪根节点。
- en: 'Applying this algorithm to our opcode tree will result in the following structure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将此算法应用于我们的操作码树将会得到以下结构：
- en: '![](img/846f7bb7-b3ac-4b3a-b852-f1220d0b30a5.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/846f7bb7-b3ac-4b3a-b852-f1220d0b30a5.png)'
- en: The structure remains almost the same-four levels, including the root node,
    and four nodes at the bottom-most layer. The order of opcodes has changed a bit,
    but this is not that important in the case of this particular example. However,
    should we design a more complex system that expects much more load, we could design
    the encoding of the operation code in such a way that the most frequently used
    opcodes would be encoded with values from the upper layers and the least frequently
    used opcodes, with values from the bottom layers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 结构几乎保持不变——四个层级，包括根节点，以及最底层的四个节点。操作码的顺序有所变化，但在这个特定的例子中，这并不太重要。然而，如果我们设计一个期望承载更大负载的更复杂系统，我们可以将操作码的编码设计成这样：最常用的操作码使用上层的值进行编码，而最不常用的操作码则使用底层的值。
- en: Sparse matrices
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Sparse matrices are rarely discussed, if at all, due to the relative complexity
    of implementation and maintenance; however, they may be a very convenient and
    useful instrument in certain cases. Basically, sparse matrices are conceptually
    very close to arrays, but they're much more efficient when working with sparse
    data as they allow memory savings, which in turn allows the processing of much
    larger amounts of data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵很少被讨论，如果有的话，是因为它们的实现和维护相对复杂；然而，在某些情况下，它们可能是一个非常方便和有用的工具。基本上，稀疏矩阵在概念上与数组非常相似，但它们在处理稀疏数据时效率更高，因为它们节省内存，从而使得可以处理更大规模的数据。
- en: 'Let''s take astrophotography as an example. For those of us not familiar with
    the subject, amateur astrophotography means plugging your digital camera into
    a telescope, selecting a region in the night sky, and taking pictures. However,
    since pictures are taken at night time without a flashlight or any other aid (it
    would be silly to try to light celestial objects with a flashlight anyway), one
    has to take dozens of pictures of the same object and then stack the images together
    using a specific algorithm. In this case, there are two major problems:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以天文摄影为例。对于我们这些不熟悉这个领域的人来说，业余天文摄影意味着将数码相机连接到望远镜，选择夜空中的某个区域并拍摄照片。然而，由于拍摄是在没有手电筒或任何其他辅助设备的情况下进行的（其实用手电筒照亮天体是很愚蠢的做法），所以需要拍摄几十张相同物体的照片，然后使用特定算法将这些图像堆叠在一起。在这种情况下，存在两个主要问题：
- en: Noise reduction
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪声抑制
- en: Image alignment
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像对齐
- en: Lacking professional equipment (meaning not having a huge telescope with a cooled
    CCD or CMOS matrix), one faces the problem of noise. The longer the exposition,
    the more noise in the final image. Of course, there are numerous algorithms for
    noise reduction, but sometimes, a real celestial object may mistakenly be treated
    as noise and be removed by the noise reduction algorithm. Therefore, it is a good
    idea to process each image and detect potential celestial objects. If certain
    "light", which otherwise may be considered as noise, is present in at least 80%
    of images (it is hard to believe that any noise would have survived for such a
    long time without any changes, unless we are talking about dead pixels), then
    its area needs different treatment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏专业设备（即没有配备冷却CCD或CMOS矩阵的大型望远镜），就会面临噪声问题。曝光时间越长，最终图像中的噪声就越多。当然，有许多噪声抑制算法，但有时，某些真实的天体可能会被错误地当作噪声，并被噪声抑制算法去除。因此，处理每一张图像并检测潜在的天体是个好主意。如果某个“光点”，如果没有被认为是噪声，至少在80%的图像中出现（很难相信任何噪声能够在没有变化的情况下存活这么长时间，除非我们在谈论坏点），那么这个区域需要不同的处理。
- en: 'However, in order to process an image, we need to make a decision on how to
    store the result. We, of course, may use an array of structures describing each
    and every pixel, but that would be too expensive by means of the memory required
    for such operation. On the other hand, even if we take a picture of the highly
    populated area of the night sky, the area occupied by celestial objects would
    be significantly smaller than the "empty" space. Instead, we may divide an image
    into smaller areas, analyze certain characteristics of those smaller regions,
    and only take into consideration those that seem to be populated. The following
    figure presents the idea:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了处理图像，我们需要决定如何存储结果。当然，我们可以使用一个结构数组来描述每一个像素，但这样做在内存方面的开销太大。另一方面，即使我们拍摄的是夜空中人口密集的区域，天体所占的区域也远小于“空白”空间。相反，我们可以将图像划分成较小的区域，分析这些较小区域的某些特征，并且只考虑那些看起来被填充的区域。下图展示了这个想法：
- en: '![](img/a3ab2839-e62b-4191-beb4-a390fed31b3f.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3ab2839-e62b-4191-beb4-a390fed31b3f.png)'
- en: The figure (which shows the Messier 82 object, also known as *Cigar Galaxy*)
    is divided into 396 smaller regions (a matrix of 22 x 18 regions, 15 x 15 pixels
    each). Each region may be described by its luminosity, noise ratio, and many other
    aspects, including its location on the figure, meaning that it may occupy quite
    a sensible amount of memory. Having this data stored in a two-dimensional array
    with more than 30 images simultaneously may result in megabytes, of meaningless
    data. As the image shows, there are only two regions of interest, which together
    form about 0.5% (which fits the definition of sparse data more than perfectly),
    meaning that if we choose to use arrays, we waste 99.5% of the used memory.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该图（展示了梅西耶82天体，也被称为*雪茄星系*）被划分为396个较小的区域（一个22 x 18的矩阵，每个区域为15 x 15像素）。每个区域可以通过其亮度、噪声比以及许多其他方面来描述，包括它在图中的位置，这意味着它可能占用相当可观的内存。如果将这些数据存储在一个二维数组中，并同时存储超过30张图像，可能会产生数兆字节的无意义数据。正如图中所示，只有两个感兴趣的区域，它们共同构成约0.5%的数据（这更完美地符合稀疏数据的定义），这意味着如果我们选择使用数组，我们将浪费99.5%的内存。
- en: 'Utilizing sparse matrices, we may reduce the usage of memory to the minimum
    required to store important data. In this particular case, we would have a linked
    list of 22 column header nodes, 18 row header nodes, and only 2 nodes for data.
    The following is a very rough example of such an arrangement:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 利用稀疏矩阵，我们可以将内存的使用减少到仅存储重要数据所需的最小值。在这种特定情况下，我们将有一个22列头节点、18行头节点的链表，并且只有2个数据节点。以下是这种排列的一个非常粗略的示例：
- en: '![](img/e8ede3a0-c7bf-46b3-a72a-79dc92b1b1d8.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8ede3a0-c7bf-46b3-a72a-79dc92b1b1d8.png)'
- en: The preceding example is very rough; in reality, the implementation would contain
    a few other links. For example, empty column header nodes would have their `down`
    pointer point to themselves, and empty row headers would have their `right` pointers
    point to themselves, too. The last data node in a row would have its right pointer
    pointing to the row header node, and the same applies to the last data node in
    a column having its `down` pointer pointing to the column header node.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例非常粗略；实际上，实施中还会包含一些其他链接。例如，空列头节点的`down`指针会指向它自身，空行头节点的`right`指针也会指向它自身。行中的最后一个数据节点的`right`指针会指向行头节点，同样，列中的最后一个数据节点的`down`指针会指向列头节点。
- en: Graphs
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: The general definition of a graph states that a graph is a data structure consisting
    of a set of vertices (V) and edges (E). While the vertex may be anything (anything
    means any data structure), edge is defined by the two vertices it connects-*v*
    and *w*. Edges have a direction, meaning that the data flows from vertex *v* to
    vertex *w*, and *weight*, which indicates how difficult the flow is.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图的一般定义是，图是由一组顶点（V）和边（E）组成的数据结构。顶点可以是任何东西（任何东西意味着任何数据结构），边则由它连接的两个顶点-*v*和*w*来定义。边有方向，这意味着数据从顶点*v*流向顶点*w*，并且有*权重*，表示流动的难度。
- en: 'The easiest and probably the most common example of a graph structure is a
    perceptron-an artificial neural network paradigm:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且可能是最常见的图结构示例是感知机——一种人工神经网络范式：
- en: '![](img/d2bf874b-67e5-47f0-8096-48bfbf6f5d6c.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2bf874b-67e5-47f0-8096-48bfbf6f5d6c.png)'
- en: 'Traditionally, perceptrons are drawn from left to right, so we have three layers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，感知机是从左到右绘制的，因此我们有三个层：
- en: The input layer (sensors)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入层（传感器）
- en: The hidden layer (where most of the processing takes place)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏层（大多数处理发生的地方）
- en: The output layer (forms the output of a perceptron)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出层（形成感知机的输出）
- en: Although nodes of artificial neural network are called **neurons**, we will
    refer to them as vertices as we are discussing graphs, not ANNs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管人工神经网络的节点被称为**神经元**，但由于我们讨论的是图，因此我们将它们称为顶点，而不是ANN（人工神经网络）。
- en: In the preceding graph, we see a typical multilayer perceptron layout for an
    artificial neural network capable of solving the XOR problem.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到一个典型的多层感知机布局，用于解决XOR问题的人工神经网络。
- en: An XOR problem in artificial neural networks is the problem of making an ANN
    implementation receiving two inputs in the range *{0, 1}* to produce a result,
    as if two inputs were XOR'ed. A single layer perceptron (where the hidden layer
    is also the output layer) is not able to find solutions for this problem, therefore
    an additional layer is added.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 人工神经网络中的XOR问题是指使得一个ANN实现能够接收两个在 *{0, 1}* 范围内的输入并产生一个结果，仿佛两个输入进行了异或操作。单层感知机（其中隐藏层也是输出层）无法找到该问题的解决方案，因此需要添加额外的层。
- en: The vertices **S0** and **S1** do not perform any computations and serve as
    sources of data for vertices **N0** and **N1**. As it has been stated, edges have
    weights, and in this example, the data from **S0** and **S1** is multiplied with
    the weights of the edges *[s0, n0]*, *[s0, n1]*, *[s1, n0]*, and *[s1, n1]*. The
    same applies to data being transferred via *[bias, n0]*, *[bias, n1]*, *[n0, o]*,
    and *[n1, o]*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点**S0**和**S1**不执行任何计算，它们作为顶点**N0**和**N1**的数据源。正如所述，边具有权重，在这个示例中，来自**S0**和**S1**的数据会与边的权重进行相乘，边的权重包括
    *[s0, n0]*、*[s0, n1]*、*[s1, n0]* 和 *[s1, n1]*。同样的操作适用于通过 *[bias, n0]*、*[bias,
    n1]*、*[n0, o]* 和 *[n1, o]* 传输的数据。
- en: However, graphs may be of any shape and edges may lead data in any direction
    (even to the same vertex), depending on the problem they intend to solve.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图形可以是任意形状，边缘可以将数据传递到任何方向（甚至传递到同一顶点），具体取决于它们要解决的问题。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have briefly covered several types of data structures (not
    to be confused with the Assembly `struc[tures]`) and reviewed a few of their possible
    applications. However, being very vast, the topic of data structures may require
    a separate chapter for each of the structures briefly described here, and their
    variations, which, unfortunately, falls out of the scope of this book.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了几种数据结构（不要与汇编中的 `struc[tures]` 混淆）并回顾了它们的一些可能应用。然而，由于数据结构的主题非常广泛，可能需要为这里简要描述的每种结构及其变种单独开设章节，这不幸超出了本书的范围。
- en: Beginning with the next chapter ([Chapter 8](22b2b820-0431-48f6-9ed2-8b9e0cded10a.xhtml),
    *Mixing Modules Written in Assembly and Those Written in High-Level Languages*),
    we will approach more practical problems and will start applying the knowledge
    we have gathered thus far in an attempt to find an elegant solution.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章（[第8章](22b2b820-0431-48f6-9ed2-8b9e0cded10a.xhtml)，*将汇编语言编写的模块与高级语言编写的模块混合*）开始，我们将解决更多实际问题，并开始应用迄今为止所学的知识，力求找到优雅的解决方案。
- en: In the next chapter, we will see how the Assembly code written for both 32-bit
    and 64-bit Windows and Linux operating systems may be linked with existing libraries
    written either in Assembly or in a high-level language. We will even cover the
    topic of interoperability of .NET and Assembly code (on both Linux and Windows).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将为32位和64位Windows及Linux操作系统编写的汇编代码与现有的汇编或高级语言编写的库链接。我们甚至会讨论.NET与汇编代码的互操作性（在Linux和Windows上均适用）。
