- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Web Application Pentesting with Bash
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bash进行Web应用程序渗透测试
- en: This chapter explores how to use Bash for web application pentesting. We’ll
    look at how Bash’s flexibility can help you find vulnerabilities, automate tasks,
    analyze responses, and manage web data. By the end of this chapter, you’ll be
    able to use Bash to discover and exploit common web vulnerabilities, extract data
    efficiently, and integrate with other pentesting tools for a thorough web assessment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨如何使用Bash进行Web应用程序渗透测试。我们将了解Bash的灵活性如何帮助你发现漏洞、自动化任务、分析响应并管理Web数据。通过本章的学习，你将能够使用Bash发现和利用常见的Web漏洞，高效提取数据，并与其他渗透测试工具集成进行全面的Web评估。
- en: 'There are generally five use cases for testing web application security:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，进行Web应用程序安全测试有五个使用场景：
- en: Testing a single web application in depth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入测试单个Web应用程序
- en: Quickly testing (automated scanning) many web applications during a network
    pentest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络渗透测试期间，快速测试（自动化扫描）多个Web应用程序
- en: Creating scripts to fuzz for vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建脚本进行漏洞模糊测试
- en: Creating **proof-of-concept** ( **PoC** ) exploits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**概念验证**（**PoC**）漏洞利用
- en: '**Continuous integration and continuous delivery/deployment** ( **CI/CD** )
    testing'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成和持续交付/部署**（**CI/CD**）测试'
- en: This chapter focuses on the second, third, and fourth use cases. If I were testing
    in the first use case, I would prefer browser proxies such as **ZED Attack Proxy**
    ( [https://www.zaproxy.org](https://www.zaproxy.org) ), also known as **ZAP**
    , or Burp Suite ( [https://portswigger.net/burp](https://portswigger.net/burp)
    ). These tools enable a tester to thoroughly explore an application. In the case
    of ZAP, it does allow you to run the tool in a Bash terminal without showing the
    **graphical user interface** ( **GUI** ) to automate scanning. I’ll be showing
    how to use ZAP in the terminal later in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论第二、第三和第四种使用场景。如果我要测试第一个使用场景，我会更倾向于使用浏览器代理工具，如**ZED攻击代理**（[https://www.zaproxy.org](https://www.zaproxy.org)），也称为**ZAP**，或Burp
    Suite（[https://portswigger.net/burp](https://portswigger.net/burp)）。这些工具可以让测试人员深入探索应用程序。对于ZAP，它允许你在Bash终端中运行工具，而不显示**图形用户界面**（**GUI**），以自动化扫描。我将在本章稍后展示如何在终端中使用ZAP。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Automating HTTP requests in Bash
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Bash中自动化HTTP请求
- en: Analyzing web application security with Bash
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bash分析Web应用程序安全
- en: Learning advanced data manipulation techniques
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习高级数据处理技术
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The first prerequisite is that you started reading from [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017)
    and have access to a Bash shell. You should be using Kali Linux, as discussed
    in [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017) . You will find it difficult
    to follow along if you’re using a different operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个前提是你从[*第1章*](B22229_01.xhtml#_idTextAnchor017)开始阅读，并且能访问到Bash shell。你应该使用Kali
    Linux，正如[*第1章*](B22229_01.xhtml#_idTextAnchor017)中所讨论的那样。如果你使用其他操作系统，跟随本书内容会比较困难。
- en: 'Ensure that you have installed **ProjectDiscovery** tools before advancing:
    [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01#install-project-discovery-tools](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01#install-project-discovery-tools)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保已安装**ProjectDiscovery**工具：[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01#install-project-discovery-tools](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01#install-project-discovery-tools)
- en: 'Run the following commands to configure software prerequisites:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以配置软件前提条件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The **httpx** entry must be removed because the command name clashes with the
    **httpx** command from ProjectDiscovery.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 必须移除**httpx**条目，因为该命令名称与ProjectDiscovery的**httpx**命令发生冲突。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter09](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter09)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter09](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter09)找到。
- en: If you want to follow along interactively with the section that shows how to
    use **curl** to automate testing for **SQL injection** ( **SQLi** ), you’ll need
    to install **Damn Vulnerable Web Application** ( **DVWA** ), available at [https://github.com/digininja/DVWA](https://github.com/digininja/DVWA)
    . I’ll be running DVWA in Docker, which is the quickest way to start up the application.
    I’ll also be using Vulhub ( [https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub)
    ) when demonstrating a **nuclei** scan.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟随本节内容，互动演示如何使用**curl**来自动化测试**SQL注入**（**SQLi**），你需要安装**Damn Vulnerable
    Web Application**（**DVWA**），可以在[https://github.com/digininja/DVWA](https://github.com/digininja/DVWA)找到。我将在Docker中运行DVWA，这是启动应用程序的最快方式。在演示**nuclei**扫描时，我还将使用Vulhub（[https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub)）。
- en: Automating HTTP requests in Bash
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Bash中自动化HTTP请求
- en: Any serious discussion on making HTTP requests in a terminal must start with
    **curl** . The **curl** tool is a command-line tool used for transferring data
    to or from a server using various protocols such as HTTP, HTTPS, FTP, and more.
    It is widely used in pentesting to interact with web applications, sending custom
    requests to uncover vulnerabilities. You can visit the **curl** website and learn
    more by visiting [https://curl.se](https://curl.se) .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于在终端中进行HTTP请求的严肃讨论都必须从**curl**开始。**curl**工具是一个命令行工具，用于使用各种协议（如HTTP、HTTPS、FTP等）向服务器发送或从服务器接收数据。它在渗透测试中广泛使用，用来与Web应用程序交互，发送自定义请求以发现漏洞。你可以访问**curl**的官方网站，了解更多信息：[https://curl.se](https://curl.se)。
- en: I believe that most pentesters would prefer to use a browser proxy such as ZAP
    or Burp, or Python scripts for web application testing. However, knowledge of
    using **curl** in a Bash shell comes in handy. While I was writing this chapter,
    someone I worked with reached out to me for my help recreating a Metasploit HTTP
    exploit module in Bash because they couldn’t install Metasploit or any Python
    modules in the testing environment. The testing environment did have Bash and
    common command-line tools such as **curl** installed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信大多数渗透测试人员更倾向于使用像ZAP或Burp这样的浏览器代理，或者使用Python脚本进行Web应用程序测试。然而，了解如何在Bash shell中使用**curl**也非常有用。在我写这章的时候，有位我合作过的人联系我，求我帮忙在Bash中重现一个Metasploit
    HTTP漏洞模块，因为他们无法在测试环境中安装Metasploit或任何Python模块。测试环境中虽然没有这些，但却安装了Bash和常见的命令行工具，比如**curl**。
- en: 'Here are some common **curl** options that are useful for pentesters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常用的**curl**选项，渗透测试人员会觉得很有用：
- en: '**-X** or **--request** : Specify the request method ( **GET** , **POST** ,
    **PUT** , **DELETE** , and so on)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-X**或**--request**：指定请求方法（**GET**、**POST**、**PUT**、**DELETE**等）'
- en: '**-d** or **--data** : Send data with a **POST** request'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d**或**--data**：使用**POST**请求发送数据'
- en: '**-H** or **--header** : Pass custom headers to the server'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-H**或**--header**：向服务器传递自定义头部'
- en: '**-I** or **--head** : Show response header info only'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-I**或**--head**：只显示响应头信息'
- en: '**-u** or **--user** : Include user authentication'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-u**或**--user**：包括用户身份验证'
- en: '**-o** or **--output** : Write output to a file'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-o**或**--output**：将输出写入文件'
- en: '**-s** or **--silent** : Silent mode (no progress bar or error messages)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s**或**--silent**：静默模式（不显示进度条或错误消息）'
- en: '**-k** or **--insecure** : Allow insecure server connections when using SSL'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-k**或**--insecure**：在使用SSL时允许不安全的服务器连接'
- en: '**-L** or **--location** : Follow redirects'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-L**或**--location**：跟踪重定向'
- en: '**-w** or **--write-out <format>** : Make **curl** display information on **stdout**
    after a completed transfer'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-w**或**--write-out <format>**：使**curl**在传输完成后显示信息到**stdout**'
- en: The format is a string that may contain plain text mixed with any number of
    variables.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 格式是一个字符串，可以包含纯文本与任意数量的变量。
- en: '**-Z** or **--parallel** : Makes **curl** perform its transfers in parallel
    as compared to the regular serial manner'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Z**或**--parallel**：使**curl**以并行方式进行传输，而不是常规的串行方式'
- en: We’ll be covering usage examples of the preceding options throughout this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖上述选项的使用示例。
- en: '**GET** and **POST** requests are the most common HTTP request methods. There
    are many more. To learn more, see [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
    .'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET**和**POST**请求是最常见的HTTP请求方法。还有很多其他方法。要了解更多，请参见[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)。'
- en: 'A **GET** request is used to retrieve information from a server. Here’s how
    to use **curl** to make a **GET** request: **curl -X** **GET** [https://example.com](https://example.com)
    .'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET**请求用于从服务器检索信息。以下是如何使用**curl**发出**GET**请求：**curl -X** **GET** [https://example.com](https://example.com)
    。'
- en: 'Here is an explanation of this command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该命令的解释：
- en: '**curl** : Invokes the **curl** command'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**curl** ：调用**curl**命令'
- en: '**-X GET** : Specifies the request method as **GET**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-X GET** ：指定请求方法为**GET**'
- en: '**https://example.com** : The URL of the target server'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**https://example.com** ：目标服务器的URL'
- en: 'A **POST** request is used to send data to a server in the body of a request.
    Here’s an example: **curl -X POST https://example.com/login -** **d "username=user&password=pass"**
    .'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST**请求用于将数据发送到服务器的请求体中。下面是一个示例：**curl -X POST https://example.com/login
    -** **d "username=user&password=pass"** 。'
- en: 'The following points explain this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点解释了该命令：
- en: '**-X POST** : Specifies the request method as **POST**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-X POST** ：指定请求方法为**POST**'
- en: '**-d "username=user&password=pass"** : Sends data with the request'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d "username=user&password=pass"** ：随请求一起发送数据'
- en: 'The key difference between a **GET** and a **POST** request is how data is
    sent to the server. A **GET** request sends data in the URL as parameters. A raw
    **GET** request looks like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**GET**请求和**POST**请求之间的关键区别是数据发送到服务器的方式。**GET**请求将数据作为参数发送到URL。一个原始的**GET**请求如下所示：'
- en: '![Figure 9.1 – An example GET request](image/B22229_09_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 一个示例的GET请求](image/B22229_09_01.jpg)'
- en: Figure 9.1 – An example GET request
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 一个示例的GET请求
- en: The key area to focus on in the preceding figure is the first line, which starts
    with the **GET** method, followed by the relative URL ( **/admin/report?year=2024&month=7**
    ) and HTTP specification ( **HTTP/2** ). As you can see in the figure, data is
    sent to the server in the URL as the **year** and **month** parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，关键部分是第一行，它以**GET**方法开始，后面跟着相对URL（**/admin/report?year=2024&month=7**）和HTTP规范（**HTTP/2**）。如图所示，数据作为**year**和**month**参数发送到服务器。
- en: 'The **POST** request method sends data in the request body. A raw **POST**
    request looks similar to the one shown in the following figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST**请求方法将数据发送到请求的主体中。一个原始的**POST**请求看起来类似于以下图所示：'
- en: '![Figure 9.2 – An example POST request](image/B22229_09_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 一个示例的POST请求](image/B22229_09_02.jpg)'
- en: Figure 9.2 – An example POST request
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 一个示例的POST请求
- en: The key point to notice in the preceding figure is that data is sent to the
    server in the request body (the last line), which follows the headers ( **keyword:**
    **value** pairs).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，关键点是数据是在请求体中发送到服务器的（最后一行），这在头信息之后（**关键词：** **值**对）进行。
- en: 'Many web applications require authentication headers. Here’s how to include
    them in your request: **curl -X GET https://example.com/protected -H "Authorization:**
    **Bearer <token>"** .'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序需要身份验证头。以下是如何将其包含在请求中：**curl -X GET https://example.com/protected -H
    "Authorization:** **Bearer <token>"** 。
- en: 'You can send data from a file using the **--data-binary** option: **curl -X
    POST https://example.com/upload --** **data-binary @file.txt** .'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**--data-binary**选项从文件中发送数据：**curl -X POST https://example.com/upload --**
    **data-binary @file.txt** 。
- en: 'Often, pentesters need to combine multiple options to craft specific requests.
    Here’s an advanced example: **curl -X POST https://example.com/api -H "Authorization:
    Bearer <token>" -H "Content-Type: application/json" -** **d @data.json** .'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，渗透测试人员需要组合多个选项来构建特定的请求。以下是一个高级示例：**curl -X POST https://example.com/api
    -H "Authorization: Bearer <token>" -H "Content-Type: application/json" -** **d
    @data.json** 。'
- en: 'The following points explain the preceding command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点解释了之前的命令：
- en: '**-H "Content-Type: application/json"** : Specifies the content type of the
    data being sent'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-H "Content-Type: application/json"** ：指定所发送数据的内容类型'
- en: '**-d @data.json** : Sends the contents of **data.json** with the request'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-d @data.json** ：将**data.json**的内容随请求一起发送'
- en: 'It’s crucial to handle HTTP responses to analyze the behavior of the web application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 处理HTTP响应对于分析Web应用程序的行为至关重要：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s look at the code more closely:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下代码：
- en: '**response=$(...)** : It captures the HTTP response code in a variable.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**response=$(...)** ：它将HTTP响应码捕获到一个变量中。'
- en: '**-s -o /dev/null -w "%{http_code}"** : Silent mode, discard output, and print
    only the HTTP response code. See [https://curl.se/docs/manpage.html#-w](https://curl.se/docs/manpage.html#-w)
    for more information about the **-w** option and its use.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-s -o /dev/null -w "%{http_code}"** ：静默模式，丢弃输出，仅打印HTTP响应码。有关**-w**选项及其使用的更多信息，请参见[https://curl.se/docs/manpage.html#-w](https://curl.se/docs/manpage.html#-w)。'
- en: The **if** block analyzes the response code. If the response code is **200**
    , the request was successful.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if** 块分析响应码。如果响应码是 **200** ，则表示请求成功。'
- en: 'Pentesters often need to automate multiple requests. Here’s an example using
    a loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员经常需要自动化多个请求。以下是使用循环的示例：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the code and understand it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码并理解它：
- en: '**for i in {1..10}** : Loops from 1 to 10'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for i in {1..10}** ：从 1 循环到 10'
- en: '**"https://example.com/page$i"** : Dynamically constructs the URL for the page
    number for each iteration'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"https://example.com/page$i"** ：动态构造每次迭代的页面编号的 URL'
- en: 'Sometimes, you just want to check the HTTP response headers and discard the
    rest: **curl -** **I "https://www.example.com/**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你只想检查 HTTP 响应头并丢弃其余部分：**curl -** **I "https://www.example.com/**
- en: 'Here is an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '![Figure 9.3 – Capturing the headers from an HTTP request](image/B22229_09_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 捕获 HTTP 请求的头部](image/B22229_09_03.jpg)'
- en: Figure 9.3 – Capturing the headers from an HTTP request
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 捕获 HTTP 请求的头部
- en: Tip
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you experience errors when creating HTTP requests in the Bash shell, send
    requests through a proxy or save a packet capture to aid troubleshooting. This
    will allow you to see what is being sent and received, which may look different
    from what you intended due to encoding issues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Bash shell 中创建 HTTP 请求时遇到错误，可以通过代理发送请求或保存数据包捕获以帮助故障排除。这将帮助你查看发送和接收的数据，可能由于编码问题，看起来与预期不同。
- en: Now that you have a good foundation of knowledge on using **curl** to make HTTP
    requests, let’s put that knowledge to work and examine a real-world use case.
    The next example will demonstrate how to use Bash scripting for SQLi payloads.
    The example code can be found in the **ch09_sqliscanner.sh** file in this chapter’s
    folder in the GitHub repository. As in previous chapters, I’ll be breaking the
    script up into sections so that I can explain the code. It may be helpful to open
    the code from GitHub on another screen or use split-screen to help you follow
    the script structure at a high level as we examine each line in detail in this
    text.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了使用 **curl** 进行 HTTP 请求的基本知识，让我们开始实际应用这些知识，看看一个真实世界的案例。接下来的示例将展示如何使用
    Bash 脚本进行 SQL 注入有效负载的测试。示例代码可以在 GitHub 仓库中本章文件夹下的 **ch09_sqliscanner.sh** 文件中找到。和之前的章节一样，我会将脚本分成几个部分进行讲解，这样你可以更好地理解代码。你可以考虑在另一屏幕上打开
    GitHub 上的代码，或者使用分屏模式，以便在我们逐行讲解每段代码时，能更好地理解脚本结构。
- en: 'The following code is a function to check if **curl** and **parallel** dependencies
    are installed. If not, print an error message and exit:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个检查 **curl** 和 **parallel** 依赖项是否安装的函数。如果没有安装，则打印错误消息并退出：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The **print_usage** function contains the usage instructions for the script:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**print_usage** 函数包含脚本的使用说明：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In another part of the script, if the proper command-line arguments are not
    provided, it calls this function, which prints the usage instructions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的另一部分，如果没有提供正确的命令行参数，它会调用此函数，并打印使用说明。
- en: 'The **perform_sql_test** function sets two local variables and initializes
    them to the two provided function arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**perform_sql_test** 函数设置了两个局部变量并将它们初始化为传递的两个函数参数：'
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following code, we ensure the URL contains **FUZZ** for payload insertion;
    otherwise, print an error and exit:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们确保 URL 包含 **FUZZ** 以便插入有效负载；否则，打印错误信息并退出：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here we define an array of SQLi payloads:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义一个 SQL 注入有效负载的数组：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following code, we loop through the array of payloads:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们循环遍历有效负载数组：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The start time is saved to the **start_time** variable for reference at the
    end of the loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 起始时间被保存到 **start_time** 变量，以便在循环结束时参考。
- en: 'The **fuzzed_url** variable is assigned the result of the **${url//FUZZ/$payload}**
    parameter expansion:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**fuzzed_url** 变量被赋值为 **${url//FUZZ/$payload}** 参数展开的结果：'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a parameter expansion syntax in Bash used for string manipulation. This
    tells Bash to replace all occurrences of the **FUZZ** string within the **url**
    variable with the current value of **$payload** .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Bash 中用于字符串操作的参数展开语法。它告诉 Bash 将 **url** 变量中所有出现的 **FUZZ** 字符串替换为当前的 **$payload**
    值。
- en: 'Here we send a request to the fuzzed URL with or without the cookie header,
    depending on command-line arguments:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们根据命令行参数，决定是否带有 Cookie 头部发送请求到模糊化的 URL：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code calculates the duration of the request:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码计算请求的持续时间：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code checks if the request duration indicates a potential time-based
    SQLi vulnerability:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查请求时长是否表明存在潜在的基于时间的 SQL 注入漏洞：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A value of 7 seconds was included in each payload. We expect the response to
    take at least 7 seconds or longer based on network conditions and server load.
    We exported the function so that it can be called in the shell.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有效负载中都包含了7秒的值。根据网络条件和服务器负载，我们预计响应时间至少需要7秒或更长时间。我们将函数导出，以便在shell中调用。
- en: 'Here we process a list of URLs by either reading from a file or using a single
    URL:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过从文件中读取或使用单个URL来处理URL列表：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we call the **check_dependencies** function defined at the start of the
    script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用在脚本开头定义的**check_dependencies**函数：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code parses the command-line arguments for the URL, URL file,
    and cookie header:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解析命令行参数中的URL、URL文件和cookie头：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we validate the input and ensure that either a URL or a URL file is provided:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们验证输入并确保提供了URL或URL文件：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we process the URLs based on the provided input:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据提供的输入处理这些URL：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following output is found in the terminal after one of the payloads results
    in a response that takes longer than 7 seconds to complete. The URL and payload
    that triggered the SQLi is printed to the terminal:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有效负载的响应时间超过7秒时，终端中会显示以下输出，打印触发SQLi的URL和有效负载：
- en: '![Figure 9.4 – A successful SQLi URL and payload are printed to the terminal](image/B22229_09_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 成功的SQLi URL和有效负载被打印到终端](image/B22229_09_04.jpg)'
- en: Figure 9.4 – A successful SQLi URL and payload are printed to the terminal
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 成功的SQLi URL和有效负载被打印到终端
- en: Tip
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When including authentication cookies or tokens with a **curl** request, bear
    in mind the difference between the **-b** and **-H** options. If you use **-b**
    , **curl** inserts **Cookie:** in the request, followed by the cookie value you
    specify. If you use **-H** , supply the full value. See the **-b** parameter in
    *Figure 9* *.4* where I left off the beginning of the **Cookie** header, and compare
    that to *Figure 9* *.5* .
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当在**curl**请求中包含身份验证cookie或令牌时，请注意**-b**和**-H**选项之间的区别。如果使用**-b**，**curl**会在请求中插入**Cookie:**，后面跟上你指定的cookie值。如果使用**-H**，则需要提供完整的值。参见*图9.4*中的**-b**参数，我在其中省略了**Cookie**头的开头，并与*图9.5*进行比较。
- en: '![Figure 9.5 – The Cookie header is highlighted to make a point](image/B22229_09_05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – Cookie头被高亮显示以强调重点](image/B22229_09_05.jpg)'
- en: Figure 9.5 – The Cookie header is highlighted to make a point
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – Cookie头被高亮显示以强调重点
- en: After learning about **curl** , I want to briefly mention **wget** . Both **curl**
    and **wget** are command-line tools for downloading files from the internet, but
    they have different features and use cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解**curl**之后，我想简单提一下**wget**。**curl**和**wget**都是用于从互联网下载文件的命令行工具，但它们有不同的功能和应用场景。
- en: 'The following are features of **curl** :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**curl**的特点：
- en: Designed for transferring data with URL syntax
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于使用URL语法传输数据
- en: Supports a wide range of protocols (HTTP, HTTPS, FTP, SFTP, SCP, and so on)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持广泛的协议（HTTP、HTTPS、FTP、SFTP、SCP等）
- en: Can send data to a server using various HTTP methods ( **GET** , **POST** ,
    **PUT** , **DELETE** , and so on)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用各种HTTP方法（**GET**、**POST**、**PUT**、**DELETE**等）向服务器发送数据
- en: Supports uploading files
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持上传文件
- en: More suitable for complex operations such as interacting with APIs
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更适合进行与API交互等复杂操作
- en: 'The following are features of **wget** :'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**wget**的特点：
- en: Primarily designed for downloading files from the web
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要用于从网页下载文件
- en: Supports HTTP, HTTPS, and FTP protocols
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP、HTTPS和FTP协议
- en: Can recursively download files, which makes it useful for mirroring websites
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以递归下载文件，这使得它适用于网站镜像
- en: Designed to handle unreliable network connections by retrying downloads
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用于通过重试下载来处理不可靠的网络连接
- en: More suitable for bulk downloading and website mirroring
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更适合批量下载和网站镜像
- en: 'The most straightforward use of **wget** is to download a single file from
    a URL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**wget**的最直接用法是从URL下载单个文件：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can specify a different name for the downloaded file using the **-** **O**
    option:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**-O**选项指定下载文件的不同名称：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If a download gets interrupted, you can resume it with the **-** **c** option:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载被中断，你可以使用**-c**选项继续下载：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can download files in the background using the **-** **b** option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**-b**选项在后台下载文件：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can mirror a website using the **-r** (recursive) and **-p** (page requisites)
    options. The **-k** option converts the links to be suitable for local viewing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**-r**（递归）和**-p**（页面所需）选项来镜像一个网站。**-k**选项会将链接转换为适合本地查看的形式：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can limit the download speed using the **--** **limit-rate** option:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **--** **limit-rate** 选项限制下载速度：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can download files with a specific file extension using the **-** **A**
    option:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **-** **A** 选项下载具有特定文件扩展名的文件：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this section, you learned the most commonly used **curl** and **wget** options
    and examined common uses. Using **curl** and **wget** in Bash scripts allows pentesters
    to interact with web applications efficiently, sending customized requests to
    identify and exploit vulnerabilities. Mastering these options and techniques is
    essential for effective web application pentesting.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了最常用的 **curl** 和 **wget** 选项，并检查了它们的常见用法。在 Bash 脚本中使用 **curl** 和 **wget**
    允许渗透测试人员高效地与 Web 应用交互，发送定制的请求以识别和利用漏洞。掌握这些选项和技巧是有效进行 Web 应用渗透测试的关键。
- en: The next section will show how to use more advanced web application pentesting
    tools that you can use in the Bash shell, such as various ProjectDiscovery tools,
    as well as running command-line ZAP scans.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将展示如何使用更高级的网页应用渗透测试工具，你可以在 Bash shell 中使用这些工具，例如各种 ProjectDiscovery 工具，以及运行命令行
    ZAP 扫描。
- en: Analyzing web application security with Bash
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 分析 Web 应用安全性
- en: This section will examine common command-line tools that you should have in
    your toolbox for web application security testing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍你应该在工具箱中拥有的用于 Web 应用安全测试的常见命令行工具。
- en: ProjectDiscovery
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProjectDiscovery
- en: 'ProjectDiscovery maintains a variety of command-line tools you can run in your
    Bash shell. They’re designed to accept input and pass output via the shell pipeline,
    allowing you to chain together multiple tools. Their most popular tools include
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery 维护着一系列可以在 Bash shell 中运行的命令行工具。这些工具旨在通过 shell 管道接受输入并传递输出，允许你将多个工具串联在一起。它们最受欢迎的工具包括以下内容：
- en: '**nuclei** : An open source vulnerability scanner that uses YAML templates'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nuclei**：一个开源漏洞扫描器，使用 YAML 模板'
- en: '**nuclei-templates** : Templates for the **nuclei** engine to find security
    vulnerabilities'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nuclei-templates**：用于 **nuclei** 引擎查找安全漏洞的模板'
- en: '**subfinder** : A passive subdomain enumeration tool'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**subfinder**：一个被动子域枚举工具'
- en: '**httpx** : An HTTP toolkit that allows running sending probes to identify
    HTTP services'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**httpx**：一个 HTTP 工具包，允许发送探针以识别 HTTP 服务'
- en: '**cvemap** : A CLI to search for CVE'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cvemap**：一个用于搜索 CVE 的命令行工具'
- en: '**katana** : A web crawling and spidering framework'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**katana**：一个网页爬虫和蜘蛛框架'
- en: '**naabu** : A port scanner that integrates easily with other ProjectDiscovery
    tools'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**naabu**：一个易于与其他 ProjectDiscovery 工具集成的端口扫描器'
- en: '**mapcidr** : A utility program to perform multiple operations for a given
    subnet/CIDR range'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mapcidr**：一个实用程序，用于对给定子网/CIDR 范围执行多个操作'
- en: You can find the ProjectDiscovery tools at [https://github.com/projectdiscovery](https://github.com/projectdiscovery)
    .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/projectdiscovery](https://github.com/projectdiscovery)
    找到 ProjectDiscovery 工具。
- en: An example workflow combining these tools would start with **mapcidr** to expand
    a network address into individual IP addresses, piped to **naabu** to scan for
    open ports, piped to **httpx** to discover web services, and piped to **nuclei**
    to test for known vulnerabilities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结合这些工具的示例工作流程会从 **mapcidr** 开始，将网络地址扩展为单个 IP 地址，管道传输到 **naabu** 扫描开放端口，再传输到
    **httpx** 发现 Web 服务，最后传输到 **nuclei** 检测已知漏洞。
- en: Let’s examine some of these tools individually before experimenting with how
    they can be used together in a chain.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别检查这些工具中的一些，然后再实验它们如何在链中一起使用。
- en: 'The **mapcidr** tool accepts input via **stdin** . Here’s an example usage:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**mapcidr** 工具通过 **stdin** 接受输入。以下是一个示例用法：'
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Example output is shown in the following figure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下面的图所示：
- en: '![Figure 9.6 – An example of mapcidr usage](image/B22229_09_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – mapcidr 使用示例](image/B22229_09_06.jpg)'
- en: Figure 9.6 – An example of mapcidr usage
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – mapcidr 使用示例
- en: In the preceding figure, I use the Bash shell pipe ( **|** ) operator to pass
    the network address to the input of the **mapcidr** tool. The output contains
    the network address expanded to individual IP addresses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我使用 Bash shell 的管道（**|**）操作符将网络地址传递给 **mapcidr** 工具的输入。输出包含将网络地址扩展为单个
    IP 地址。
- en: Tip
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: By default, all ProjectDiscovery tools output a banner. Since we’ll be piping
    the output of each tool to the input of the next tool, this is undesired behavior.
    Include the **-silent** option with the ProjectDiscovery tools to suppress the
    banner.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有 ProjectDiscovery 工具都会输出横幅。由于我们将每个工具的输出传递给下一个工具的输入，这是不希望的行为。使用 **-silent**
    选项来抑制横幅。
- en: 'The **naabu** tool is a ProjectDiscovery tool that scans for open ports. You
    can include command-line options that follow up on each open port with an **nmap**
    scan, in addition to a large list of other options. Where **naabu** becomes helpful
    is its ability to fit in a command pipeline, piping the **stdout** of one ProjectDiscovery
    tool to the **stdin** of the next. In its default configuration, **naabu** scans
    a limited number of ports. However, command-line options include the ability to
    specify a list or range of ports:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**naabu**工具是ProjectDiscovery工具，用于扫描开放端口。您可以包括命令行选项，在每个开放端口之后执行**nmap**扫描，此外还包括许多其他选项。**naabu**的优势在于它能够适配命令管道，将一个ProjectDiscovery工具的**stdout**输出传递给下一个工具的**stdin**输入。在默认配置下，**naabu**扫描的端口数量有限。不过，命令行选项包括指定端口列表或范围的功能：'
- en: '![Figure 9.7 – An example naabu port scan is executed](image/B22229_09_07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 执行的naabu端口扫描示例](image/B22229_09_07.jpg)'
- en: Figure 9.7 – An example naabu port scan is executed
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 执行的naabu端口扫描示例
- en: 'The ProjectDiscovery **httpx** tool probes open ports for listening HTTP servers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery的**httpx**工具探测开放端口上的监听HTTP服务器：
- en: '![Figure 9.8 – An example httpx scan is executed](image/B22229_09_08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 执行的httpx扫描示例](image/B22229_09_08.jpg)'
- en: Figure 9.8 – An example httpx scan is executed
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 执行的httpx扫描示例
- en: In the preceding figure, I use the Bash shell pipe ( **|** ) operator to send
    the IP address **10.2.10.1** to the **naabu** **stdin** input. I include the silent
    option ( **-silent** ) to suppress banner output, followed by a list of ports
    ( **-p** ). The output is piped to the **httpx** tool using the **-silent** option.
    The output of **https** is a list of HTTP URLs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我使用Bash shell管道（**|**）操作符将IP地址**10.2.10.1**传送到**naabu**的**stdin**输入。我加入了静默选项（**-silent**）以抑制横幅输出，后面接着一个端口列表（**-p**）。输出通过**-silent**选项传送到**httpx**工具。**https**的输出是一组HTTP
    URL。
- en: The ProjectDiscovery **nuclei** tool scans for known vulnerabilities and misconfigurations.
    The **nuclei** templates also include *fuzzing* templates that scan for unknown
    vulnerabilities belonging to common vulnerability classes such as **cross-site
    scripting** ( **XSS** ) and SQLi.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery的**nuclei**工具用于扫描已知漏洞和配置错误。**nuclei**模板还包括*模糊测试*模板，用于扫描属于常见漏洞类别的未知漏洞，如**跨站脚本**（**XSS**）和SQL注入（SQLi）。
- en: 'The following figure demonstrates a **nuclei** scan:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了**nuclei**扫描：
- en: '![Figure 9.9 – An example nuclei scan is executed in a piped command](image/B22229_09_09.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 执行的nuclei扫描示例，通过管道命令](image/B22229_09_09.jpg)'
- en: Figure 9.9 – An example nuclei scan is executed in a piped command
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 执行的nuclei扫描示例，通过管道命令
- en: Tip
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: ProjectDiscovery tools have far more capability than I’ve shown here. You really
    should take the time to explore the documentation. These tools are an important
    part of any pentester or bug bounty hunter’s toolbox.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery工具比我展示的功能要强大得多。你确实应该花时间深入探索文档。这些工具是任何渗透测试人员或漏洞赏金猎人的重要工具箱之一。
- en: 'The ProjectDiscovery **katana** tool crawls or spiders web applications and
    prints discovered URLs. The following figure demonstrates using the **katana**
    tool to crawl a website:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery的**katana**工具用于爬取或蜘蛛抓取Web应用程序，并打印发现的URL。下图展示了如何使用**katana**工具爬取网站：
- en: '![Figure 9.10 – The katana tool is used to crawl a website](image/B22229_09_10.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 使用katana工具爬取网站](image/B22229_09_10.jpg)'
- en: Figure 9.10 – The katana tool is used to crawl a website
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 使用katana工具爬取网站
- en: 'In the next figure, I demonstrate piping output ( **|** ) from a **katana**
    crawl to a **nuclei** scan using the fuzzing templates ( **-dast** option). An
    XSS vulnerability is detected and displayed in the tool output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我演示了将**katana**爬取输出通过管道（**|**）传输到**nuclei**扫描，并使用模糊测试模板（**-dast**选项）。检测到并在工具输出中显示了XSS漏洞：
- en: '![Figure 9.11 – Katana output is piped to a nuclei scan](image/B22229_09_11.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – Katana输出通过管道传输到nuclei扫描](image/B22229_09_11.jpg)'
- en: Figure 9.11 – Katana output is piped to a nuclei scan
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – Katana输出通过管道传输到nuclei扫描
- en: Tip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When running tools in the Bash shell that connect to websites, always change
    the user agent, as shown in the preceding figures. You’ll frequently get blocked
    if you use the default user agent.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行连接网站的Bash shell工具时，始终更改用户代理，如前面图示所示。如果使用默认的用户代理，您很容易被阻止。
- en: 'Of course, you’re not limited to piping the ProjectDiscovery tool output to
    other ProjectDiscovery tools. This command uses the Bash pipe to send **httpx**
    output to **dirsearch** to discover content:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你并不限于将ProjectDiscovery工具的输出传递给其他ProjectDiscovery工具。此命令使用Bash管道将**httpx**的输出传递给**dirsearch**来发现内容：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s look at the explanation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个解释：
- en: As before, I echo the IP address and pipe it to the input to **naabu** with
    the silent option and a list of ports
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和之前一样，我回显IP地址并将其传递给**naabu**的输入，使用静默选项并提供端口列表
- en: The output of the **naabu** port scan is piped to **httpx**
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**naabu**端口扫描的输出通过管道传递给**httpx**'
- en: The URL’s output from **httpx** is piped to **dirsearch** for content discovery
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**httpx**获得的URL输出通过管道传递给**dirsearch**进行内容发现
- en: The **dirsearch** options accept input from **stdin** ( **--stdin** ), output
    the full URL ( **--full-url** ), suppress printing any banners ( **-q** ), and
    save the output ( **-o** ) to a file in CSV format ( **--format=csv** )
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dirsearch**选项接受来自**stdin**（**--stdin**）的输入，输出完整的URL（**--full-url**），抑制打印任何横幅（**-q**），并将输出（**-o**）保存到CSV格式的文件中（**--format=csv**）'
- en: 'An **awk** filter I commonly use to show only 200 or 302 responses from the
    CSV file uses a comma field separator ( **-F'',''** ) and filters the second field
    for 200 or 302 responses is shown as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我常用的一个**awk**过滤器，用于从CSV文件中仅显示200或302响应，使用逗号作为字段分隔符（**-F','**），并过滤第二个字段以显示200或302响应，具体如下：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The ProjectDiscovery tools are great for discovering known vulnerabilities and
    misconfigurations. A recent update extended **nuclei** ’s ability to fuzz for
    vulnerabilities. However, for more thorough web application vulnerability scans,
    I would recommend using ZAP. Think of these tools as complementary. Let’s move
    forward and explore ZAP scans.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ProjectDiscovery工具非常适合发现已知的漏洞和配置错误。最近的一次更新扩展了**nuclei**的模糊测试功能，能够发现漏洞。然而，对于更全面的Web应用漏洞扫描，我建议使用ZAP。可以把这些工具看作是互为补充的。接下来，我们继续探索ZAP扫描。
- en: Running command-line scans with ZAP
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ZAP进行命令行扫描
- en: ZAP is a web application vulnerability scanner and browser proxy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP是一个Web应用漏洞扫描器和浏览器代理。
- en: The GUI component of ZAP can be started from the GUI system menu or the terminal
    with the **zaproxy** command. However, this section will focus on running the
    **/usr/share/zaproxy/zap.sh** command-line scanner.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP的GUI组件可以从GUI系统菜单或终端使用**zaproxy**命令启动。然而，本节将重点讲解如何运行**/usr/share/zaproxy/zap.sh**命令行扫描器。
- en: 'Enter this command in your Bash terminal to examine ZAP command-line options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash终端中输入此命令以检查ZAP命令行选项：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One of the commands I run at the beginning of any web application pentest is
    **zapit** . This performs a quick reconnaissance scan. The output lists important
    details about the web application. Before running **zapit** , you must install
    the **wappalyzer** add-on using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我在任何Web应用渗透测试开始时都会运行的一个命令是**zapit**。它执行一个快速侦察扫描，输出中列出了Web应用程序的重要细节。在运行**zapit**之前，你必须使用以下命令安装**wappalyzer**附加组件：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You need to run the add-on installation command only once. Next, run a **zapit**
    scan. In this example, I’m scanning an application in my lab:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需运行一次附加组件安装命令。接下来，运行**zapit**扫描。在这个例子中，我正在扫描我的实验室中的一个应用程序：
- en: '![Figure 9.12 – A zapit scan fingerprints the web application](image/B22229_09_12.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 一个zapit扫描指纹识别Web应用](image/B22229_09_12.jpg)'
- en: Figure 9.12 – A zapit scan fingerprints the web application
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 一个zapit扫描指纹识别Web应用
- en: Tip
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can find a large list of vulnerable web app [lications for your lab at https:](https://github.com/vulhub/vulhub)
    //github.com/vulhub/vulhub .
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://github.com/vulhub/vulhub)找到大量适用于你实验室的易受攻击的Web应用程序。
- en: In the preceding figure, you see that the **zapit** scan revealed the application
    frameworks in the **Technology** section and some interesting information in the
    **Number of alerts** section. This is critical information needed for any application
    pentest.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到**zapit**扫描显示了**Technology**部分中的应用程序框架以及**Number of alerts**部分中的一些有趣信息。这是任何应用程序渗透测试所需的关键信息。
- en: 'Next, let’s run a vulnerability scan of the application. For the output parameter
    value ( **-quickout** ), we precede the path with **$(pwd)** to save the report
    to the current working directory because we don’t have permission to write to
    **/u sr/share/zaproxy** :'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行该应用程序的漏洞扫描。对于输出参数值（**-quickout**），我们使用**$(pwd)**来指定路径，并将报告保存到当前工作目录，因为我们没有权限写入**/usr/share/zaproxy**：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s take a look at the output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下输出：
- en: '![Figure 9.13 – Examining the ZAP quick scan output in JSON format](image/B22229_09_13.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 检查 ZAP 快速扫描输出的 JSON 格式](image/B22229_09_13.jpg)'
- en: Figure 9.13 – Examining the ZAP quick scan output in JSON format
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 检查 ZAP 快速扫描输出的 JSON 格式
- en: ZAP scan output can be saved in HTML, JSON, Markdown, and XML formats. For human-readable
    outputs, stick with HTML reports. For inclusion in an automation framework that
    relies on using Bash scripting to parse the output, use either JSON or XML.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP 扫描输出可以保存为 HTML、JSON、Markdown 和 XML 格式。对于可读性强的输出，建议使用 HTML 报告。对于依赖于 Bash
    脚本解析输出的自动化框架，使用 JSON 或 XML 格式。
- en: This section covered common use cases for using ProjectDiscovery and ZAP in
    your Bash shell. We’ve just scratched the surface here. There are many more options
    available in ProjectDiscovery tools and ZAP, including configuring automated scanning
    with credentials.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在 Bash shell 中使用 ProjectDiscovery 和 ZAP 的常见用例。我们这里只是略微介绍了一下。ProjectDiscovery
    工具和 ZAP 中还有许多其他选项，包括使用凭证配置自动化扫描。
- en: The next section will explore using Bash aliases and functions to transform
    data related to web application pentesting.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探索使用 Bash 别名和函数来转换与 Web 应用程序渗透测试相关的数据。
- en: Learning advanced data manipulation techniques
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习高级数据处理技巧
- en: In this section, we’ll explore various data encoding, encryption, and hashing
    algorithms that are common to testing web application security. You can put these
    functions in your **.bashrc** file and call them in your scripts. The following
    functions can be found in this chapter’s GitHub repository as **ch09_data_functions.sh**
    .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探索常见的 Web 应用程序安全测试中使用的数据编码、加密和哈希算法。你可以将这些功能放入你的 **.bashrc** 文件中，并在脚本中调用它们。以下函数可以在本章的
    GitHub 仓库中找到，文件名为 **ch09_data_functions.sh**。
- en: Base64 encoding is a method for converting binary data into an ASCII string
    format by encoding it into a Base64 representation. This encoding uses a set of
    64 characters, including uppercase and lowercase letters ( **A-Z** , **a-z** ),
    digits ( **0-9** ), and the symbols **+** and **/** , to represent the data. The
    primary purpose of Base64 encoding is to ensure that binary data, such as images
    or files, can be safely transmitted over media that are designed to handle textual
    data, such as email and URLs, without corruption. Base64 encoding also adds padding
    with the **=** character to ensure the encoded data is a multiple of 4 bytes,
    maintaining data integrity during transport and storage. Base64 encoding in Bash
    is very simple.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码是一种将二进制数据转换为 ASCII 字符串格式的方法，通过将其编码为 Base64 表示形式。该编码使用一组 64 个字符，包括大写字母和小写字母（**A-Z**，**a-z**）、数字（**0-9**）以及符号
    **+** 和 **/** 来表示数据。Base64 编码的主要目的是确保二进制数据（如图像或文件）能够安全地通过设计用于处理文本数据的媒介（如电子邮件和
    URL）传输，而不会发生损坏。Base64 编码还使用 **=** 字符进行填充，确保编码后的数据是 4 字节的倍数，从而在传输和存储过程中保持数据完整性。在
    Bash 中，Base64 编码非常简单。
- en: 'Here is a Base64 encoding example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Base64 编码示例：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the following is a Base64 decoding example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Base64 解码示例：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Base64 encoding and Base64 URL-safe encoding are methods for converting binary
    data into text strings, but they differ in their character sets and intended use
    cases. Base64 encoding uses a set of 64 characters, including uppercase and lowercase
    letters (A-Z, a-z), digits (0-9), and two special characters ( **+** and **/**
    ). This encoding is often used to encode data that needs to be stored or transmitted
    over media designed to handle textual data. However, the **+** and **/** characters
    are not URL-safe, which can cause issues when used in URLs or filenames. To address
    this, Base64 URL-safe encoding modifies the character set by replacing **+** with
    **-** (hyphen) and **/** with **_** (underscore), and it typically omits padding
    characters ( **=** ). This ensures that the encoded data can be safely included
    in URLs and filenames without the risk of being misinterpreted or causing errors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码和 Base64 URL 安全编码是将二进制数据转换为文本字符串的方法，但它们在字符集和预期用途上有所不同。Base64 编码使用一组
    64 个字符，包括大写字母和小写字母（A-Z, a-z）、数字（0-9）以及两个特殊字符（**+** 和 **/**）。这种编码通常用于编码需要存储或通过设计用于处理文本数据的媒介传输的数据。然而，**+**
    和 **/** 字符在 URL 中不安全，可能会在 URL 或文件名中使用时引发问题。为了解决这个问题，Base64 URL 安全编码通过将 **+** 替换为
    **-**（连字符）和 **/** 替换为 **_**（下划线），并通常省略填充字符（**=**），以确保编码后的数据可以安全地包含在 URL 和文件名中，而不会出现误解或错误。
- en: 'This function encodes data to a URL-safe Base64 representation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将数据编码为 URL 安全的 Base64 表示形式：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An example of URL-safe Base64 decoding is demonstrated here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里演示了 URL 安全的 Base64 解码：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The **gzip** data format is extensively utilized in HTTP communications to
    compress data transferred between web servers and clients, enhancing the efficiency
    of data transmission. When a web server sends data to a client, such as a web
    browser, it can use **gzip** to compress the content, significantly reducing the
    file size and thereby speeding up the download process. The compressed data includes
    a header with metadata, the compressed content, and a footer with a **Cyclic Redundancy
    Check 32** ( **CRC-32** ) checksum for verifying data integrity. Clients that
    support **gzip** , indicated via the **Accept-Encoding: gzip** HTTP header, can
    decompress the received content using **gunzip** to display or process the original
    data. This method of compression helps to improve load times, reduce bandwidth
    usage, and enhance overall web performance.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**gzip** 数据格式广泛用于 HTTP 通信中，用来压缩在 Web 服务器和客户端之间传输的数据，从而提高数据传输效率。当 Web 服务器向客户端（如
    Web 浏览器）发送数据时，可以使用 **gzip** 来压缩内容，显著减少文件大小，从而加快下载速度。压缩后的数据包括带有元数据的头部、压缩内容以及带有
    **循环冗余校验 32**（**CRC-32**）校验和的尾部，用于验证数据完整性。支持 **gzip** 的客户端（通过 **Accept-Encoding:
    gzip** HTTP 头标识）可以使用 **gunzip** 解压收到的内容，以显示或处理原始数据。此压缩方法有助于提高加载时间、减少带宽使用并增强整体
    Web 性能。'
- en: 'The **gzip** program is commonly installed on Linux systems by default. Here
    are some examples showing how to compress and uncompress data in the Bash shell:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**gzip** 程序通常在 Linux 系统中默认安装。以下是一些示例，展示了如何在 Bash shell 中压缩和解压数据：'
- en: '![Figure 9.14 – A demonstration of compressing and uncompressing data](image/B22229_09_14.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 压缩和解压数据的演示](image/B22229_09_14.jpg)'
- en: Figure 9.14 – A demonstration of compressing and uncompressing data
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 压缩和解压数据的演示
- en: '**Message-Digest Algorithm 5** ( **MD5** ) hashing is a widely used cryptographic
    hash function that produces a 128-bit (16-byte) hash value, typically rendered
    as a 32-character hexadecimal number. MD5 takes an input (or *message* ) and returns
    a fixed-size string of characters, which is unique to the input data. However,
    MD5 is considered weak due to its susceptibility to hash collisions, where two
    different inputs produce the same hash output. MD5 is no longer recommended for
    security-critical applications, with more secure algorithms such as **Secure Hash
    Algorithm 256-bit** ( **SHA-256** ) being preferred for hashing purposes.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息摘要算法 5**（**MD5**）哈希是一种广泛使用的加密哈希函数，生成一个 128 位（16 字节）哈希值，通常表示为一个 32 字符的十六进制数字。MD5
    接受一个输入（或 *消息*），并返回一个固定大小的字符字符串，该字符串对于输入数据是唯一的。然而，由于 MD5 容易发生哈希碰撞（即两个不同的输入产生相同的哈希输出），它被认为较弱。由于这个原因，MD5
    不再推荐用于安全关键的应用，更多安全的算法，如 **安全哈希算法 256 位**（**SHA-256**）被更倾向于用于哈希目的。'
- en: 'The following function creates an MD5 hash of a string:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数创建一个字符串的 MD5 哈希：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is another example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个例子：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: SHA-256 is a cryptographic hash function that generates a fixed-size 256-bit
    (32-byte) hash value from any input data, often represented as a 64-character
    hexadecimal number. Developed by the **National Security Agency** ( **NSA** )
    and part of the SHA-2 family, SHA-256 takes an input and produces a unique output,
    acting like a digital fingerprint of the data. It’s designed to be computationally
    infeasible to reverse the process or find two different inputs that produce the
    same hash (a collision). This makes SHA-256 highly secure and reliable for verifying
    data integrity and authenticity, which is why it’s widely used in various security
    applications, including SSL/TLS certificates, digital signatures, and blockchain
    technology.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-256 是一种加密哈希函数，它将任何输入数据生成一个固定大小的 256 位（32 字节）哈希值，通常表示为一个 64 字符的十六进制数字。SHA-256
    由**国家安全局**（**NSA**）开发，属于 SHA-2 家族的一部分，SHA-256 接受输入并生成唯一的输出，像是数据的数字指纹。它的设计目标是使反向过程或找到两个不同输入生成相同哈希（碰撞）变得计算上不可行。这使得
    SHA-256 在验证数据完整性和真实性方面高度安全可靠，因此广泛应用于各种安全应用中，包括 SSL/TLS 证书、数字签名和区块链技术。
- en: 'This function prints a SHA-256 hash of an input:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数打印输入的 SHA-256 哈希：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'See the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下示例：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Advanced Encryption Standard with a 256-bit key** ( **AES-256** ) is a symmetric
    encryption algorithm widely used to secure data. It works by taking plaintext
    data and transforming it into ciphertext using a secret key, ensuring that only
    someone with the same key can decrypt and access the original information. The
    *256* in AES-256 refers to the length of the encryption key, which is 256 bits
    long, making it extremely difficult to break using brute-force attacks. AES-256
    is known for its strong security and efficiency, which is why it is commonly used
    for protecting sensitive data in applications such as secure file storage, internet
    communications, and financial transactions.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级加密标准 256 位密钥**（**AES-256**）是一种广泛用于保护数据的对称加密算法。它通过使用秘密密钥将明文数据转换为密文，从而确保只有拥有相同密钥的人才能解密并访问原始信息。AES-256
    中的 *256* 指的是加密密钥的长度，即 256 位，这使得使用暴力破解极为困难。AES-256 以其强大的安全性和高效性而闻名，因此它在保护敏感数据的应用中得到广泛使用，例如安全文件存储、互联网通信和金融交易。'
- en: 'The following is an AES encryption function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 AES 加密函数：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function must be called as follows: **echo "data to be encrypted" |**
    **aes_encrypt "password"** .'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数必须按如下方式调用：**echo "data to be encrypted" |** **aes_encrypt "password"**。
- en: 'This is an AES decryption function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 AES 解密函数：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The **openssl** command specifies the AES algorithm with a 256-bit key size
    in **Cipher Block Chaining** ( **CBC** ) mode. The **-d** option means to decrypt.
    The **-pbkdf2** option indicates that the **Password-Based Key Derivation Function
    2** ( **PBKDF2** ) algorithm is used to derive the encryption key from a password.
    This enhances security by making brute-force attacks more difficult, as it applies
    a computationally intensive function iteratively.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**openssl** 命令指定了使用 **Cipher Block Chaining**（**CBC**）模式的 256 位密钥大小的 AES 算法。**-d**
    选项表示解密。**-pbkdf2** 选项表示使用 **基于密码的密钥派生函数 2**（**PBKDF2**）算法从密码派生加密密钥。这通过应用计算密集型函数进行迭代，增强了安全性，使暴力破解变得更加困难。'
- en: 'Similar to the encryption function, the data to decrypt must be passed in via
    a **stdin** pipe, and the decryption password must follow: **echo "data to be
    decrypted" |** **aes_decrypt "password"** .'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于加密函数，解密数据必须通过 **stdin** 管道传入，解密密码必须随之提供：**echo "data to be decrypted" |**
    **aes_decrypt "password"**。
- en: 'Here is an AES-256 encryption and decryption example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 AES-256 加密和解密的示例：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: HTML encoding is the process of converting special characters in HTML into their
    corresponding character entities to ensure they are displayed correctly in web
    browsers. This is necessary because certain characters, such as **<** , **>**
    , **&** , and **"** , have specific meanings in HTML syntax and can disrupt the
    structure of the HTML document if not properly encoded. For instance, **<** is
    used to start a tag, so encoding it as **&lt;** prevents it from being interpreted
    as the start of an HTML tag. Conversely, HTML decoding converts these character
    entities back into their original characters. This process is crucial for web
    security and functionality, as it prevents HTML injection attacks and ensures
    that content is rendered correctly without unintended formatting or behavior.
    By encoding special characters, developers can safely include user-generated content,
    code snippets, or other data within HTML documents without risking the integrity
    of the web page.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 编码是将 HTML 中的特殊字符转换为其相应字符实体的过程，以确保它们在网页浏览器中正确显示。这是必要的，因为某些字符，如 **<**、**>**、**&**
    和 **"**，在 HTML 语法中有特定的含义，如果不正确编码，可能会破坏 HTML 文档的结构。例如，**<** 用于开始一个标签，因此将其编码为 **&lt;**
    可以防止它被解释为 HTML 标签的开始。相反，HTML 解码则是将这些字符实体转换回其原始字符。这个过程对于网页安全和功能至关重要，因为它可以防止 HTML
    注入攻击，并确保内容在没有意外格式或行为的情况下正确呈现。通过编码特殊字符，开发人员可以安全地将用户生成的内容、代码片段或其他数据包含在 HTML 文档中，而不会危及网页的完整性。
- en: 'The following HTML function encodes the input:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 HTML 函数对输入进行编码：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Reminder
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: 'The following characters must be escaped when included as part of a string,
    as seen in the **html_encode** and **html_encode** functions: **\** , **$** ,
    **`** , **''** , **"** , **&** , ***** , **?** , **(** , **)** , **{** , **}**
    , **[** , **]** , **|** , **;** , **<** , **>** , **!** , **#** , **~** , **^**
    .'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符在作为字符串的一部分时必须进行转义，如 **html_encode** 和 **html_encode** 函数所示：**\**，**$**，**`**，**'**，**"**，**&**，*****，**?**，**(**，**)**，**{**，**}**，**[**，**]**，**|**，**;**，**<**，**>**，**!**，**#**，**~**，**^**。
- en: It is not necessary to escape them when the characters are used inside single
    quotes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符用于单引号内时，通常不需要对它们进行转义。
- en: 'Here is an example of escaping these characters:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是转义这些字符的示例：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here’s the corresponding decoding function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的解码函数：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is an example of HTML decoding data:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 HTML 解码数据的示例：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The section demonstrated how to use Bash to convert common data formats found
    in web application pentesting. Populate your **.bashrc** file with these functions
    in advance, and you’ll be prepared to solve even the most advanced data manipulation
    tasks in your pentests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用 Bash 转换在 Web 应用程序渗透测试中常见的数据格式。提前将这些函数添加到你的 **.bashrc** 文件中，你将准备好解决渗透测试中最复杂的数据处理任务。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You can’t always depend on having the ability to install tools or programming
    libraries in the testing environment. Bash scripting provides a way to use the
    built-in shell and tools to accomplish almost any task. In hindsight, there were
    many times in my career when I felt that I was hindered in my ability to accomplish
    a test without installing additional tools, or resorted to writing the tool in
    another language such as Python. This was due to my lack of knowledge of Bash
    scripting. Armed with this knowledge, you’re ready to tackle the most complex
    web application testing challenges using Bash.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能总是依赖于在测试环境中安装工具或编程库。Bash 脚本提供了一种方法，利用内置的 shell 和工具几乎可以完成任何任务。回顾我的职业生涯，曾有很多次我觉得在没有安装额外工具的情况下无法完成测试，或者不得不使用其他语言（如
    Python）编写工具。这一切源于我对 Bash 脚本的不了解。掌握了这些知识后，你就准备好使用 Bash 应对最复杂的 Web 应用测试挑战。
- en: In the next chapter, we’ll explore network and infrastructure pentesting with
    Bash.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 Bash 进行网络和基础设施渗透测试。
