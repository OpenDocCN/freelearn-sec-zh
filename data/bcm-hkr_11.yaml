- en: Chapter 11. Attacking APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 攻击API
- en: So far, we've looked at attacking a traditional application — one with a user interface
    and a login panel, and maybe a dashboard of some sort. Modern applications tend
    to implement a decoupled infrastructure and, unlike traditional applications,
    they are split into smaller applications or **microservices,** all working together
    to provide functionality for the user. **Application programming interfaces**
    (**APIs**) are not a new concept. The term API is used for anything from the Windows
    library of code, which allows our user-land code to interact with the operating
    system kernel, to the service exposed on the web that powers our note-taking apps.
    Obviously, we will not be focusing on the **Windows API** (**WinAPI**), but we
    will look at the web applications that power seemingly everything on the internet.
    When I speak of APIs in this chapter, I am referring to web services specifically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了攻击传统应用程序——那种带有用户界面、登录面板，可能还有某种仪表板的应用程序。现代应用程序通常实现了解耦的基础架构，与传统应用程序不同，它们被拆分成多个较小的应用程序或**微服务**，这些服务共同协作为用户提供功能。**应用程序编程接口**（**API**）并不是一个新概念。API一词用于描述从Windows代码库（允许我们的用户级代码与操作系统内核交互）到提供笔记应用服务的Web服务等各种应用。显然，我们不会关注**Windows
    API**（**WinAPI**），而是会关注支撑互联网几乎一切的Web应用程序。当我在本章中提到API时，我指的是Web服务。
- en: Microservices are a relatively new concept adopted by application developers,
    moving away from typical monolithic application design to a more decoupled approach.
    The idea is to split components into their own instances and access them via a
    common language, usually over the network, and more specifically, the HTTP protocol.
    This does wonders for development and agility, as it allows code to be pushed
    asynchronously to each component. Developers can focus on a specific component
    without fear of breaking anything else, so long as the interface to this component
    adheres to an agreed standard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是应用开发者采用的一个相对较新的概念，它摒弃了典型的单体应用设计，转而采用更加解耦的方式。其核心思想是将组件拆分为各自独立的实例，并通过一种通用语言（通常是通过网络，尤其是HTTP协议）进行访问。这种方式对开发和敏捷性大有裨益，因为它允许代码异步地推送到各个组件。开发人员可以专注于特定的组件，只要该组件的接口遵循约定的标准，就不必担心会破坏其他部分。
- en: It's not all rainbows with this type of approach, however. New security challenges
    are introduced with this model. Decoupled services mean a larger attack surface
    with multiple instances, be they virtual machines or Docker containers. More components
    usually equate to a greater chance of misconfiguration, which can, of course,
    be taken advantage of by us.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并非没有缺点。随着这种模式的采用，新的安全挑战也随之而来。解耦的服务意味着更大的攻击面，涉及多个实例，无论是虚拟机还是Docker容器。更多的组件通常意味着更大的配置错误的风险，而这些错误当然可能被我们所利用。
- en: Authentication and authorization enforcement between components is a new problem
    to solve as well. If my monolithic application has every component built in, I
    don't really need to worry about securely communicating with the authentication
    module, as it resides on the same server, and sometimes in the same process. If
    my authentication module was decoupled and it is now an HTTP web service running
    in the cloud, I have to consider the network communication between my user interface
    and the authentication module instance in the cloud. How does the API authenticate
    my user interface? How can the two components securely negotiate an authentication
    response so that the user is allowed access to the other components?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的身份验证和授权强制执行也是一个新问题。如果我的单体应用将所有组件都集成在一起，我实际上不需要担心如何安全地与身份验证模块通信，因为它与应用在同一服务器上，有时甚至在同一个进程中。但如果我的身份验证模块被解耦，并且现在是一个在云中运行的HTTP
    Web服务，那么我就必须考虑我的用户界面与云中身份验证模块实例之间的网络通信。API如何验证我的用户界面？这两个组件如何安全地协商身份验证响应，以便用户能够访问其他组件？
- en: Decoupling has other interesting effects on security as well. Suppose an API
    is developed to handle data for a Windows application. The API will accept an
    HTTP verb (`GET`, `PUT`, and so on) and respond with either JSON or XML. The Windows-native
    application reads the response and displays an error message returned in the JSON
    object. A Windows popup containing arbitrary strings is not inherently dangerous
    to display. There's no need to escape dangerous HTML code in the API response
    because the `MessageBox()` function of `user32.dll` does not do any kind of rendering
    of the string it displays. Now suppose that same API is suddenly integrated with
    a brand-new web application. Unescaped HTML data in the JSON response could be
    problematic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦对安全性也有其他有趣的影响。假设一个API是为Windows应用程序开发的来处理数据。API会接受一个HTTP方法（如`GET`、`PUT`等），并以JSON或XML的形式响应。Windows本地应用程序读取响应并显示在JSON对象中返回的错误信息。显示一个包含任意字符串的Windows弹窗本身并不危险。因为`user32.dll`的`MessageBox()`函数不会渲染它显示的字符串，所以无需对API响应中的危险HTML代码进行转义。现在假设同一个API突然被集成到一个全新的Web应用程序中。JSON响应中未转义的HTML数据可能就会成为问题。
- en: 'By the end of the chapter, you will be comfortable with:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够熟练掌握：
- en: The different types of web API architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的Web API架构
- en: How APIs handle authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API如何处理身份验证
- en: '**JSON Web Tokens** (**JWTs**)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON Web令牌**（**JWT**）'
- en: Automating API attacks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化API攻击
- en: API communication protocols
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API通信协议
- en: 'At their core, web APIs are simple HTTP client-server environments. A request
    comes in over HTTP and a response goes out. To standardize things a bit more,
    a couple of protocols have been developed, and many APIs follow one or the other to
    process requests. This is by no means an exhaustive list, but it is likely what you''ll encounter
    in the wild:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Web API是简单的HTTP客户端-服务器环境。请求通过HTTP进入，响应通过HTTP出去。为了进一步标准化，开发了一些协议，许多API遵循其中之一来处理请求。这绝不是一个详尽的列表，但它很可能是你在实际应用中遇到的：
- en: '**Representational State Transfer** (**REST**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表现层状态转移**（**REST**）'
- en: '**Simple Object Access Protocol** (**SOAP**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）'
- en: There are certainly other types of protocols that APIs can use, but while their
    protocols differ, the majority of the same security challenges remain. The most
    popular protocols are RESTful APIs, followed by SOAP APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他类型的协议可以供API使用，但尽管它们的协议不同，大多数相同的安全挑战仍然存在。最流行的协议是RESTful API，其次是SOAP API。
- en: SOAP
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP
- en: SOAP was developed by Microsoft because **Distributed Component Object Model**
    (**DCOM**) is a binary protocol, which makes communication over the internet a
    bit more complicated. SOAP leverages XML instead, a more structured and human-readable
    language, to exchange messages between the client and the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP是由微软开发的，因为**分布式组件对象模型**（**DCOM**）是一个二进制协议，这使得通过互联网进行通信变得有些复杂。SOAP则采用XML，一种结构化且人类可读的语言，用于在客户端和服务器之间交换消息。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SOAP is standardized and is available for review in its entirety at [https://www.w3.org/TR/soap12/](https://www.w3.org/TR/soap12/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP是标准化的，可以通过[https://www.w3.org/TR/soap12/](https://www.w3.org/TR/soap12/)进行完整的审阅。
- en: 'A typical SOAP request to an API host looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 向API主机发送的典型SOAP请求如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The response from the server, as you would expect, is also XML-formatted:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器返回的响应，正如你所期望的那样，也是XML格式的：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is a lot of overhead just to get user details. SOAP requires a header
    defining the XML version, the envelope specification, a body, and finally, the
    parameters. The response has similar structure requirements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户详细信息的过程需要大量开销。SOAP需要一个定义XML版本的头部，信封规范，一个主体，最后是参数。响应也有类似的结构要求。
- en: While SOAP is bloated by today's standards, its design is time-tested and has
    been around for a long time. As attackers, we are not concerned with performance
    or network bandwidth utilization. We just need to know all the possible injection
    points and understand how authentication is performed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SOAP在今天的标准下显得臃肿，但其设计经过时间考验，已经存在了很长时间。作为攻击者，我们不关心性能或网络带宽的利用率。我们只需要知道所有可能的注入点，并理解身份验证是如何执行的。
- en: While the `Envelope`, `Body`, and `Header` tags are standardized, the contents
    of the body can vary depending on the request type, the application, and the web
    service implementation itself. The `GetUserRequest` action and its `Name` parameter
    are specific to the `/UserData` endpoint. To look for potential vulnerabilities,
    we need to know all the possible endpoints and their respective actions or parameters.
    How can we grab this information in a black-box scenario?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Envelope`、`Body` 和 `Header` 标签是标准化的，但 body 的内容会根据请求类型、应用程序和 Web 服务的实现有所不同。`GetUserRequest`
    操作及其 `Name` 参数特定于 `/UserData` 端点。为了寻找潜在的漏洞，我们需要了解所有可能的端点及其相应的操作或参数。在黑盒场景中，我们如何获取这些信息？
- en: 'The SOAP XML structure for requests and responses is typically defined in a
    **Web Services Description Language** (**WSDL**) file. For public APIs, this is
    commonly available by querying the API itself directly and attaching `?wsdl` to
    the specific endpoint URL. If properly configured, the web service will respond
    with a large XML file with every possible action and parameter for that endpoint:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 请求和响应的 XML 结构通常在 **Web 服务描述语言** (**WSDL**) 文件中定义。对于公共 API，可以通过直接查询 API
    并在特定的端点 URL 后附加 `?wsdl` 来获得此文件。如果配置正确，Web 服务将以一个包含该端点所有可能操作和参数的大 XML 文件作出响应：
- en: '![SOAP](graphics/B09238_11_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![SOAP](graphics/B09238_11_01.jpg)'
- en: 'Figure 11.1: WSDL response for a public API'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：公共 API 的 WSDL 响应
- en: This file is extremely useful in an engagement but is not always available.
    In situations where the WSDL is not downloadable, it's best to reach out to the
    client and simply ask for the definitions or a list of sample requests. It's also
    possible that the client will refuse and want to test the API from an external
    threat's point of view.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件在进行互动时非常有用，但并非总是可用。如果 WSDL 无法下载，最好的做法是直接联系客户端，索要定义或请求示例列表。也有可能客户端会拒绝，并希望从外部威胁的角度测试
    API。
- en: The last resort is, obviously, just observing the web, mobile, or native applications
    interacting with the API, capturing the HTTP traffic in Burp, and replaying it
    through the Intruder or Scanner modules. This is certainly not ideal, as vulnerable
    parameters or actions may never be called under normal application operation.
    When the scope allows, it's always best to get the WSDL straight from the developer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的办法显然是观察 Web、移动或本地应用与 API 的交互，捕获 Burp 中的 HTTP 流量，并通过 Intruder 或 Scanner 模块重放它。这显然不是理想的做法，因为在正常的应用操作中，脆弱的参数或操作可能永远不会被调用。当范围允许时，最好直接从开发人员那里获取
    WSDL。
- en: REST
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: REST is the dominant architectural style you will likely encounter in modern
    applications. It is simple to implement and easy to read, and therefore widely
    adopted by developers. While not as mature as SOAP, it does provide a simple way to
    achieve decoupled design with microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是现代应用中最常见的架构风格，可能是你会遇到的主要架构。它易于实现，且易于阅读，因此被开发人员广泛采用。虽然它的成熟度不如 SOAP，但它提供了一种简单的方式来实现微服务的解耦设计。
- en: 'Much like SOAP, RESTful APIs operate over HTTP and they make heavy use of the protocol
    verbs, including but not limited to:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOAP 类似，RESTful API 通过 HTTP 操作，并且大量使用协议动词，包括但不限于：
- en: '`GET`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`POST`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`DELETE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: 'If we wish to query information about a user, a RESTful API may implement a `GET` verb
    with a `/users` endpoint. The query would then be submitted via the URL parameters:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望查询某个用户的信息，一个 RESTful API 可能会通过 `/users` 端点实现一个 `GET` 请求。查询将通过 URL 参数提交：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of note in the request are the `Content-Type`, `Accept`, and `Authorization`
    headers. The `Content-Type` header specifies in what format the incoming data
    is to be processed by the API. The `Accept` header specifies what format the client
    will accept in the response from the server. The typical APIs will support JSON
    or XML, or sometimes both. Finally, the `Authorization` header specifies a bearer
    token and will be required for endpoints that enforce authentication. This allows
    the server to identify which user is making the request and whether they are authorized
    to do so.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求中需要注意的是 `Content-Type`、`Accept` 和 `Authorization` 头。`Content-Type` 头指定了传入数据应由
    API 以何种格式处理。`Accept` 头指定了客户端在服务器响应中可接受的格式。典型的 API 将支持 JSON 或 XML，或有时两者兼容。最后，`Authorization`
    头指定了一个持有者令牌，对于要求身份验证的端点，这将是必须的。这使得服务器能够识别发起请求的用户，并确定他们是否被授权执行此操作。
- en: Some custom APIs might employ custom headers for authentication and authorization
    purposes, such as `X-Auth-Token`, but the principle is the same. Once we know
    how authentication and authorization tokens are passed between the client and
    the server, we can start looking for weaknesses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些自定义 API 可能会使用自定义头部进行身份验证和授权，例如 `X-Auth-Token`，但其原理是相同的。一旦我们知道身份验证和授权令牌是如何在客户端和服务器之间传递的，我们就可以开始寻找潜在的弱点。
- en: 'The server response to our earlier request is predictably simple and easy to
    read:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前请求的服务器响应可以预见地简单且易于读取：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `200` HTTP response indicates that it was successful, our token was valid,
    and we now have a JSON object with all the details concerning the admin user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `200` HTTP 响应表示请求成功，我们的令牌是有效的，我们现在得到了一个包含管理员用户所有详细信息的 JSON 对象。
- en: RESTful APIs typically use JSON for requests and responses, but there is no
    hard standard and developers may choose to use a custom XML protocol or even raw
    binary. This is unusual, as microservices interoperability and maintenance becomes
    difficult, but it is not unheard of.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 通常使用 JSON 进行请求和响应，但没有严格的标准，开发者可以选择使用自定义的 XML 协议，甚至是原始二进制数据。虽然这种做法不常见，因为微服务的互操作性和维护性变得困难，但也并非闻所未闻。
- en: API authentication
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 身份验证
- en: Decoupling brings about a few more challenges when it comes to authentication
    and authorization. It's not uncommon to have an API that does not require authentication,
    but the chances are some web services you'll encounter will require their clients
    to authenticate in one way or another.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦带来了一些身份验证和授权方面的挑战。虽然有些 API 不要求身份验证并不罕见，但你遇到的某些 Web 服务可能会要求客户端以某种方式进行身份验证。
- en: So, how do we achieve authentication with APIs? This process is not that different
    from a typical application. At its core, authentication requires that you provide
    something you know and, optionally, something you have, which corresponds to a record
    in the API's database. If that something you know and something you have is a
    secret and only the holder of this information, presumably, has access to it,
    the API can be reasonably sure that the client providing this information is given
    access. The API now only needs to track this particular client, since HTTP is
    stateless.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现 API 的身份验证呢？这个过程与典型的应用程序没有太大区别。其核心是，身份验证要求你提供某些你知道的信息，并可选地提供某些你拥有的东西，这些信息通常对应于
    API 数据库中的一条记录。如果你知道的东西和你拥有的东西是保密的，并且只有持有这些信息的人（假设是这样的人）才能访问它，那么 API 可以合理地确认提供这些信息的客户端获得了访问权限。由于
    HTTP 是无状态的，API 现在只需要跟踪这个特定的客户端。
- en: Traditional web applications will accept authentication data (something you
    know, along with a username and password combination) and may require a second factor
    (something you have, a one-time password, an SMS number, or a mobile push notification).
    Once the application has verified you, it will issue a session ID, which your
    browser will pass for subsequent authentication requests via cookies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Web 应用程序会接受身份验证数据（即你知道的信息，通常是用户名和密码组合），并可能需要第二重因素（即你拥有的东西，例如一次性密码、短信验证码或手机推送通知）。一旦应用程序验证了你的身份，它将发放一个会话
    ID，浏览器会通过 Cookies 在后续身份验证请求中传递此 ID。
- en: APIs are similar in that they require some sort of secret key or token to be
    passed back with each request that requires authentication. This token is usually
    generated by the API and given to the user after successfully authenticating via
    other means. While a typical web application will almost always use the `Cookie`
    header to track the session, APIs have a few options.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: API 也类似，需要在每次需要身份验证的请求中传递某种秘密密钥或令牌。这个令牌通常由 API 生成，在通过其他方式成功验证后发给用户。尽管典型的 Web
    应用程序几乎总是使用 `Cookie` 头部来跟踪会话，API 则有更多选择。
- en: Basic authentication
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: 'Yes, this is also common in web applications but is generally not used in modern
    applications, due to security concerns. Basic authentication will pass the username
    and password in cleartext via the `Authorization` header:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这种方式在 Web 应用程序中也很常见，但由于安全问题，现代应用程序一般不再使用。基本身份验证会通过 `Authorization` 头部以明文形式传递用户名和密码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The obvious issues with this are that the credentials are flying over the wire
    in cleartext and attackers only need to capture one request to compromise the
    user. Session IDs and tokens will still provide attackers with access, but they
    can expire and can be blacklisted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式显而易见的问题是，凭据以明文方式在网络中传输，攻击者只需要捕获一次请求就能破解用户。会话 ID 和令牌仍然能给攻击者提供访问权限，但它们可以过期或被列入黑名单。
- en: Basic authentication should be sent over HTTPS, since the user credentials are
    sent in plaintext over the wire. Modern APIs tend to avoid this type of authentication
    because credentials can be cached by proxies, can be intercepted using **man-in-the-middle**
    (**MITM**) attacks, or can be extracted from memory dumps. If the API uses LDAP
    to authenticate users to an Active Directory domain, it's not a good idea to have
    the user domain credentials flying over the wire with every API request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证应该通过HTTPS发送，因为用户凭证是以明文方式传输的。现代API通常避免使用这种认证方式，因为凭证可能被代理缓存，或者被**中间人攻击**（**MITM**）拦截，甚至可能从内存转储中提取出来。如果API使用LDAP来验证用户的Active
    Directory域，最好不要在每次API请求时都传输用户域凭证。
- en: API keys
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API密钥
- en: A more common way to authenticate is by supplying a key or token with our API
    request. The key is unique to the account with access to the web service and should
    be kept secret, much like a password. Unlike a password, however, it is not (usually)
    generated by the user and thus is less likely to be reused in other applications.
    There's no industry standard on how to pass this value to APIs, although **Open
    Authorization** (**OAuth**) and SOAP have some requirements defined by the protocol.
    Custom headers, the `Cookie` header, and even through a `GET` parameter are some
    of the common ways tokens or keys are sent along with the request.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的认证方式是通过提供一个密钥或令牌来进行API请求。密钥是与访问Web服务的账户唯一相关的，应该像密码一样保密。然而，与密码不同，密钥通常不是由用户生成，因此不太可能在其他应用程序中被重复使用。虽然没有行业标准来规定如何将此值传递给API，**开放授权**（**OAuth**）和SOAP协议中已有一些定义要求。常见的传递方式包括自定义头部、`Cookie`头部，甚至通过`GET`参数发送令牌或密钥。
- en: 'Using a `GET` URL parameter to pass the key is generally a bad idea because
    this value can be cached by browsers, proxies, and web server log files:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET` URL参数传递密钥通常是一个不好的主意，因为该值可能会被浏览器、代理和Web服务器日志文件缓存：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another option is using a custom header to send the API key with the request.
    This is a slightly better alternative but still requires secrecy through HTTPS
    to prevent MITM attacks from capturing this value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用自定义头部将API密钥与请求一起发送。这是一种稍微更好的替代方法，但仍然需要通过HTTPS保持保密，以防止MITM攻击捕获此值：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Bearer authentication
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承载者认证
- en: 'Similar to keys, bearer tokens are secret values that are usually passed via
    the `Authorization` HTTP header as well, but instead of using the `Basic` type,
    we use the `Bearer` type. For REST APIs, as long as the client and server agree
    on how to exchange this token, there is no standard defining this process and
    therefore you may see slight variations of this in the wild:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于密钥，承载令牌也是秘密值，通常通过`Authorization` HTTP头部传递，但与使用`Basic`类型不同，我们使用`Bearer`类型。对于REST
    API，只要客户端和服务器就如何交换此令牌达成一致，就没有标准来定义这个过程，因此你可能会在实际中看到稍有不同的实现：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding bearer token is an example of a JWT. It's a bit longer than a
    traditional opaque token, but it has some advantages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述承载令牌是JWT的一个示例。它比传统的不透明令牌稍长，但有一些优势。
- en: JWTs
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT
- en: JWTs are a relatively new authentication mechanism that is gaining market share with
    web services. They are a compact, self-contained method of passing information
    securely between two parties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一种相对较新的认证机制，在Web服务中逐渐占据市场份额。它是一种紧凑、自包含的方式，用于在两方之间安全地传递信息。
- en: JWTs are versatile and easy to implement in authentication protocols. SOAP and OAuth
    can both easily implement JWT as the bearer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JWT非常灵活，且易于在认证协议中实现。SOAP和OAuth都可以轻松实现JWT作为承载者。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OAuth information can be found at [https://oauth.net/2/](https://oauth.net/2/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth的相关信息可以在[https://oauth.net/2/](https://oauth.net/2/)找到。
- en: 'JWTs are essentially claims that have been signed using either **hash-based
    message authentication code** (**HMAC**) and a secret key, or with an RSA key
    pair. HMAC is an algorithm that can be used to verify both the data integrity
    and the authentication of a message, which works well for JWTs. JWTs are a combination
    of a `base64url` encoded header, payload, and the corresponding signature:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JWT（JSON Web Token）本质上是通过**基于哈希的消息认证码**（**HMAC**）和一个密钥，或者使用RSA密钥对签名的声明。HMAC是一种可以用来验证数据完整性和消息认证的算法，非常适合JWT。JWT由一个`base64url`编码的头部、有效载荷和相应的签名组成：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The header of the token will specify the algorithm used for signing and the
    payload will be the claim (for example, I am user1 and I am an administrator),
    while the third chunk will be the signature itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的头部将指定用于签名的算法，负载将是声明（例如，我是用户1并且我是管理员），第三部分将是签名本身。
- en: If we inspect the preceding bearer token, we can see the make-up of a typical
    JWT. There are three chunks of information separated by a period, encoded using
    URL-safe Base64.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查前面的持有者令牌，我们可以看到典型JWT的组成。它包含三个由句号分隔的信息块，使用URL安全的Base64编码。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: URL-safe Base64-encoded uses the same alphabet as traditional Base64, with the
    exception of replacing the characters `+` with `-` and `/` with `_`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: URL安全的Base64编码使用与传统Base64相同的字母表，唯一的区别是将字符`+`替换为`-`，将`/`替换为`_`。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first chunk is the header, describing the algorithm used for signing. In
    this case, HMAC with SHA-256\. The type is defined as a JWT.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是头部，描述了用于签名的算法。在这种情况下是使用SHA-256的HMAC。类型被定义为JWT。
- en: 'We can use JavaScript''s `atob()` function in the browser console to decode
    the chunk to readable text:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器控制台中使用JavaScript的`atob()`函数来解码该部分为可读文本：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The second chunk, or payload, is usually arbitrary data that makes a particular
    claim, also known as the payload. In this case, it tells the server that I am
    an administrative user called `admin`, with the user ID `1`, and a timestamp of
    `104507750`. Timestamps are a good idea, as they can prevent replay attacks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分或负载通常是任意数据，表示某个特定的声明，也称为负载。在这种情况下，它告诉服务器我是一个名为`admin`的管理员用户，用户ID为`1`，时间戳为`104507750`。时间戳是一个好主意，因为它们可以防止重放攻击。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The final piece is a `base64url` encoded 32-byte SHA-256 HMAC signature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`base64url`编码的32字节SHA-256 HMAC签名。
- en: 'When the API server receives this three-piece token, it will:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当API服务器接收到这个三部分的令牌时，它将：
- en: 'Parse the header to determine the algorithm: HMAC SHA-256 in this case'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析头部以确定算法：在这种情况下是HMAC SHA-256。
- en: 'Calculate the HMAC SHA-256 value of the `base64url` encoded first two chunks
    concatenated by a period:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算由句号连接的前两个`base64url`编码部分的HMAC SHA-256值：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the signature validates, consider the payload as valid as well
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果签名验证通过，则也认为负载有效。
- en: JWT quirks
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT怪癖
- en: While this process is currently cryptographically safe, there are a few ways
    we can play with this token to try to fool poor API implementations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程目前在密码学上是安全的，但我们有几种方法可以篡改这个令牌，试图欺骗不完善的API实现。
- en: First of all, while the header and the payload are signed, we can actually modify
    them. The token data is within our control. The only portion we don't know is
    the secret key. If we modify the payload, the signature will fail and we expect
    the server to reject our request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，虽然头部和负载是签名的，但我们实际上可以修改它们。令牌数据在我们的控制之下。唯一我们不知道的是密钥。如果我们修改了负载，签名将失败，并且我们预计服务器会拒绝我们的请求。
- en: Remember, though, that the header chunk is parsed before the signature is verified.
    This is because the header contains instructions on how the API will verify the
    message. This means we could potentially change this data and break something
    in the implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，头部部分在签名验证之前会被解析。这是因为头部包含关于API如何验证消息的指令。这意味着我们可能会更改这些数据，并破坏实现中的某些内容。
- en: 'What''s interesting about JWT is that the **Request for Comments** (**RFC**)
    specifies a supported signature algorithm called "none", which can be used by
    an implementation to assume that the token was validated by other means:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，JWT的**请求评论**（**RFC**）规范了一个名为"none"的受支持签名算法，可以通过实现来假设该令牌是通过其他方式验证的：
- en: '![JWT quirks](graphics/B09238_11_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![JWT quirks](graphics/B09238_11_02.jpg)'
- en: 'Figure 11.2: The RFC mention of an unsecured JWT using the "none" algorithm'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：RFC提到使用"none"算法的未加密JWT
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The full JWT RFC is available here: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的JWT RFC可以在这里查看：[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)。
- en: Some JWT libraries will follow the standard and support this particular algorithm
    as well. So, what happens when we use the "none" algorithm with our preceding
    payload?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些JWT库将遵循标准并支持这个特定的算法。那么，当我们在前面的负载中使用"none"算法时，会发生什么呢？
- en: 'Our token would look like this, with no signature appended after the last period:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的令牌看起来像这样，最后一个句号后面没有附加签名：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The token will be verified and deemed valid if the server-side library adheres
    to the JWT RFC. We can test this modified token using the Burp Suite **JSON Web
    Tokens** extension, which can be downloaded from the BApp Store:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器端库遵循JWT RFC，则该令牌将被验证并认为是有效的。我们可以使用Burp Suite **JSON Web Tokens**扩展来测试这个修改后的令牌，该扩展可以从BApp
    Store下载：
- en: '![JWT quirks](graphics/B09238_11_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![JWT的怪癖](graphics/B09238_11_03.jpg)'
- en: 'Figure 11.3: JWT Burp extension'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：JWT Burp扩展
- en: 'We can enter the JWT value in the first field and supply a dummy key. Since
    we are no longer using the keyed HMAC, this value will be ignored. The extension
    should confirm that the signature and JWT token are valid:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第一个字段中输入JWT值，并提供一个虚拟密钥。由于我们不再使用带密钥的HMAC，这个值将被忽略。扩展应该确认签名和JWT令牌是有效的：
- en: '![JWT quirks](graphics/B09238_11_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![JWT的怪癖](graphics/B09238_11_04.jpg)'
- en: 'Figure 11.4: JWT with no signature deemed valid'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：没有签名的JWT被视为有效
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information on this type of attack can be found on Auth0: [https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种类型攻击的更多信息可以在Auth0上找到：[https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)。
- en: This simple attack could be devastating in an API that uses a library with an
    insecure JWT implementation. The ability to forge authentication tickets could
    be very useful to us as attackers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的攻击在使用不安全JWT实现的库的API中可能会带来毁灭性的后果。伪造认证票证的能力对于我们作为攻击者来说非常有用。
- en: Burp JWT support
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Burp JWT支持
- en: Manually splitting the header, payload, and signature pieces is a bit tedious
    and we'd like to automate this process. If we are targeting the JWT implementation
    on the server, we may also want to modify some of the parameters. This can be
    tedious, especially if we have to recalculate the signature every time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 手动拆分头部、载荷和签名部分有些繁琐，我们希望能自动化这个过程。如果我们要攻击服务器上的JWT实现，我们可能还需要修改一些参数。这可能会很麻烦，尤其是每次都需要重新计算签名时。
- en: The **JWT4B** extension was created to check requests for JWT data, parse it,
    and verify the signature, all in the Burp Suite user proxy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT4B** 扩展程序是为了检查请求中的JWT数据、解析它并验证签名，所有这些操作都可以在Burp Suite用户代理中完成。'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JWT4B is available for download on GitHub at [https://github.com/mvetsch/JWT4B](https://github.com/mvetsch/JWT4B).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JWT4B可以从GitHub下载：[https://github.com/mvetsch/JWT4B](https://github.com/mvetsch/JWT4B)。
- en: 'Once we have downloaded the JWT4B JAR file to disk, we can load it manually
    into Burp. In the **Extender** tab, under **Extensions,** click the **Add** button:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完JWT4B JAR文件到磁盘后，我们可以手动将其加载到Burp中。在**Extender**选项卡下，点击**Extensions**，然后点击**Add**按钮：
- en: '![Burp JWT support](graphics/B09238_11_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Burp JWT支持](graphics/B09238_11_05.jpg)'
- en: 'Figure 11.5: The Burp Extensions tab'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：Burp扩展选项卡
- en: 'In the **Load Burp Extension** popup window, we can tell Burp to load the JWT4B
    JAR file from the location on disk:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Load Burp Extension**弹出窗口中，我们可以告诉Burp从磁盘上的位置加载JWT4B JAR文件：
- en: '![Burp JWT support](graphics/B09238_11_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Burp JWT支持](graphics/B09238_11_06.jpg)'
- en: 'Figure 11.6: Loading the JWT4B JAR extension file'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：加载JWT4B JAR扩展文件
- en: 'JWT4B will allow us to intercept requests with authorization headers containing
    a JWT, replace the payload, and re-sign with either the same key (if we have it)
    or a random key, or even change the algorithm:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JWT4B将允许我们拦截包含JWT的授权头请求，替换载荷，并重新签名，使用相同的密钥（如果我们有）或随机密钥，甚至可以更改算法：
- en: '![Burp JWT support](graphics/B09238_11_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Burp JWT支持](graphics/B09238_11_07.jpg)'
- en: 'Figure 11.7: Modifying JWTs on the fly'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：动态修改JWT
- en: JWT4B makes attacking JWT implementations much simpler, as it can do some of
    the heavy-lifting for us.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JWT4B使得攻击JWT实现变得更加简单，因为它可以为我们完成一些繁重的工作。
- en: Postman
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman
- en: When testing a typical web application, we first configure the system proxy
    to point to Burp Suite. Now, all of our requests can be inspected as we walk through
    the app. It's easy to launch attacks because these requests are built for us by
    the user interface that Burp can see over the wire. During normal operation, users
    enter data in a search field, for example, and the application constructs the
    `GET` or `POST` request with all the appropriate parameters, before sending it
    over the wire. All of these valid requests are now available for replay, modification,
    and scanning through the attack proxy. The discovery process is much simpler when
    there is a user interface to drive traffic generation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试典型的Web应用程序时，我们首先配置系统代理指向Burp Suite。现在，我们所有的请求都可以在使用应用程序时进行检查。发起攻击非常简单，因为这些请求是由Burp可以通过网络看到的用户界面为我们构建的。在正常操作中，用户输入数据到搜索字段中，例如，应用程序会构造包含所有适当参数的`GET`或`POST`请求，然后通过网络发送出去。所有这些有效的请求现在都可以通过攻击代理进行重放、修改和扫描。当有用户界面来驱动流量生成时，发现过程变得更加简单。
- en: If there is no user interface component and all we have is an API endpoint,
    and some documentation to work with, it is very tedious to build a series of `curl`
    requests and manually parse the responses. If authentication is required for interaction,
    requesting tokens would be a nightmare for complex web services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有用户界面组件，只有一个API端点和一些文档可供参考，那么构建一系列`curl`请求并手动解析响应将非常繁琐。如果交互需要身份验证，获取令牌对于复杂的Web服务来说将是一场噩梦。
- en: '**Postman** is a fantastic tool that we can use to build a collection of requests
    to the target API and make testing a breeze. This is especially true if there
    is cooperation from the client and the developers. To use testing time more efficiently,
    clients can provide us with a collection of already-generated requests, which
    can greatly speed up the application testing process.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman**是一个极好的工具，我们可以用它来构建一系列针对目标API的请求，使得测试变得轻松。如果客户和开发人员配合良好，尤其如此。为了更高效地利用测试时间，客户可以向我们提供一系列已生成的请求，这将大大加快应用程序的测试过程。'
- en: Our engagements are usually time-sensitive and building attack payloads for
    a RESTful API is extremely time-consuming, even with documentation. A tool such
    as Postman supports **Collections**, which are essentially a sequence of fully
    customizable API tests. Developers or other testers can create these collections,
    which include requests for every possible endpoint, with every possible parameter.
    They can even automate capturing the data, such as authentication tokens, and
    automatically insert it into subsequent requests. Postman makes testing APIs easy;
    developers love it and so do we.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作通常有时间限制，构建RESTful API的攻击载荷非常耗时，即使有文档也不例外。像Postman这样的工具支持**集合**，它本质上是一个完全可定制的API测试序列。开发人员或其他测试人员可以创建这些集合，集合中包含了每个可能的端点请求及其所有可能的参数。它们甚至可以自动捕获数据，例如身份验证令牌，并将其自动插入到后续的请求中。Postman使得API测试变得简单；开发人员喜欢它，我们也喜欢。
- en: As attackers, we can grab a fully decked-out collection from the client and
    just run it in our own environment. We can see exactly how the API is supposed
    to behave, as the developers intended it to. Postman also conveniently supports
    upstream proxies, so we can push all the properly formatted requests from the
    **Collection Runner** through Burp and quickly start our attack through Burp's
    Intruder, Scanner, and Repeater modules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，我们可以从客户那里获取一整套已配置好的集合，并在我们自己的环境中运行它。我们可以准确地看到API应该如何工作，正如开发人员所预期的那样。Postman还方便地支持上游代理，这样我们就可以通过Burp将所有格式正确的请求从**集合运行器**推送出去，并快速开始通过Burp的Intruder、Scanner和Repeater模块进行攻击。
- en: There is a free version of Postman that supports up to 1000 calls per month,
    but if you find yourself testing more and more APIs, the Pro and Enterprise versions
    may be a good investment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Postman有一个免费版，每月支持最多1000次调用，但如果你发现自己测试越来越多的API，Pro版和企业版可能是一个不错的投资。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Postman is available in Free, Pro, and Enterprise versions at [https://www.getpostman.com/](https://www.getpostman.com/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Postman有免费版、专业版和企业版，可以在[https://www.getpostman.com/](https://www.getpostman.com/)下载。
- en: For demonstration purposes, in this chapter, we will be using the vulnerable-API
    Docker application available from Matt Valdes at [https://github.com/mattvaldes/vulnerable-api](https://github.com/mattvaldes/vulnerable-api).
    In our demo, the API is running on `http://api.ecorp.local:8081/`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，本章我们将使用Matt Valdes提供的脆弱API Docker应用程序，网址为[https://github.com/mattvaldes/vulnerable-api](https://github.com/mattvaldes/vulnerable-api)。在我们的演示中，API运行在`http://api.ecorp.local:8081/`上。
- en: 'With Docker installed, the vulnerable API can be downloaded and executed with
    the `docker run` command from the Linux terminal. We can also specify the port
    to expose in the container using the `-p` switch. Finally, the `--name` parameter
    will instruct Docker to go fetch the `mkam/vulnerable-api-demo` container:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Docker后，脆弱的API可以通过Linux终端使用`docker run`命令下载并执行。我们还可以使用`-p`选项指定要在容器中暴露的端口。最后，`--name`参数将指示Docker去获取`mkam/vulnerable-api-demo`容器：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To test functionality, we can use `curl` to perform a `GET` request on the
    root URL for the Docker API we''ve just launched:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试功能，我们可以使用`curl`对我们刚启动的Docker API的根URL执行`GET`请求：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Installation
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: There are Linux, Mac, and Windows versions of the Postman client. For simplicity's
    sake, we will use the Linux client on our attack machine, Kali. Installation is
    fairly straightforward on Windows and Mac, but on Linux you may need a couple
    of dependencies to get going.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Postman客户端有Linux、Mac和Windows版本。为了简单起见，我们将在攻击机Kali上使用Linux客户端。在Windows和Mac上安装相对简单，但在Linux上你可能需要安装一些依赖项才能启动。
- en: 'The Postman client is an Electron application, making it fairly portable, but
    it does require `libgconf`, available in the Kali repositories. We can install
    this dependency using the `apt-get install` command from the terminal, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Postman客户端是一个Electron应用程序，具有相当的可移植性，但它确实需要`libgconf`，该库在Kali的仓库中提供。我们可以通过终端使用`apt-get
    install`命令安装这个依赖，命令如下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To grab the latest compiled Postman build, we can `wget` the gzipped tarball
    from its Linux x64 repository, available at [https://dl.pstmn.io/download/latest/linux64](https://dl.pstmn.io/download/latest/linux64).
    The `wget` command will save the file to `postman.tar.gz` in the local directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取最新编译的Postman版本，我们可以从其Linux x64仓库使用`wget`命令下载gzipped tarball，网址为[https://dl.pstmn.io/download/latest/linux64](https://dl.pstmn.io/download/latest/linux64)。`wget`命令会将文件保存为`postman.tar.gz`，存储在本地目录中：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will extract the contents to disk in our `tools` directory using the `tar
    zxvf` command, as shown:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`tar zxvf`命令将内容提取到我们的`tools`目录中，如下所示：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With dependencies installed, Postman can be launched by calling the precompiled
    `Postman` binary. This is, predictably, located in the `Postman/` directory we''ve
    just extracted from the tarball:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完依赖项后，可以通过调用预编译的`Postman`二进制文件来启动Postman。此文件位于我们刚从tarball中提取的`Postman/`目录中：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Installation](graphics/B09238_11_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![安装](graphics/B09238_11_08.jpg)'
- en: 'Figure 11.8: Postman client running on Linux'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：在Linux上运行的Postman客户端
- en: To play around with basic functionality, we can create a new request and the
    default workspace opens.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单测试基本功能，我们可以创建一个新的请求，默认工作区将打开。
- en: The user interface is fairly self-explanatory for the most part. We can enter
    an API URL, change the HTTP verb, pass in custom headers, and even build a valid
    authorization with a couple of clicks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面大部分都相当直观。我们可以输入API URL，修改HTTP方法，传递自定义头信息，甚至通过几次点击构建有效的授权。
- en: 'As a test, we can issue the same request we made with `curl` earlier. The response
    will appear in the **Body** tab, shown in the following screenshot, with the option
    to beautify the contents. Postman can automatically parse and format the response
    as XML, HTML, JSON, or plaintext. This is a welcome feature when the response
    is a massive blob of data:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，我们可以发出与之前用`curl`发出的相同请求。响应将出现在**正文**选项卡中，如下图所示，并且可以选择美化内容。当响应为大量数据时，Postman可以自动解析并将其格式化为XML、HTML、JSON或纯文本格式，这一特性非常受欢迎：
- en: '![Installation](graphics/B09238_11_09.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![安装](graphics/B09238_11_09.jpg)'
- en: 'Figure 11.9: Sample Postman request to the API'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：向API发送的Postman请求示例
- en: One of Postman's strengths comes in its ability to record all of the requests
    we've made in the left-hand **History** pane. This allows us, API developers or
    **Quality Assurance** (**QA**) analysts, to save requests and responses in Collections.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Postman的一个优势是能够记录我们在左侧**历史**面板中所做的所有请求。这使得我们，作为API开发人员或**质量保证**（**QA**）分析师，能够将请求和响应保存在集合中。
- en: Collections can be exported by developers and imported by us during an engagement.
    This saves us a ton of time building our own queries and we can jump straight
    into looking for security vulnerabilities.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以导出集合，我们则可以在参与过程中导入。这节省了我们大量构建自己查询的时间，并可以直接开始寻找安全漏洞。
- en: Upstream proxy
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上游代理
- en: Postman also supports routing requests through either the system proxy or a
    custom server. The wise choice is Burp or OWASP ZAP. Once we import and run a collection,
    every request will be captured, and ready to be inspected and replayed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Postman还支持通过系统代理或自定义服务器路由请求。明智的选择是Burp或OWASP ZAP。一旦我们导入并运行集合，每个请求都会被捕获，并准备好进行检查和重放。
- en: 'Under **File** and **SETTINGS**, there is a **Proxy** tab, which should let
    us point to the local Burp proxy, `127.0.0.1` on port `8080` by default:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在**文件**和**设置**下，找到一个**代理**标签，应该可以让我们指向本地的Burp代理，默认情况下是`127.0.0.1`，端口为`8080`：
- en: '![Upstream proxy](graphics/B09238_11_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![上游代理](graphics/B09238_11_10.jpg)'
- en: 'Figure 11.10: Postman upstream proxy configuration'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：Postman上游代理配置
- en: 'All of our subsequent requests in Postman will show up in Burp''s proxy HTTP
    history as well:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Postman中的所有后续请求也将显示在Burp的代理HTTP历史记录中：
- en: '![Upstream proxy](graphics/B09238_11_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![上游代理](graphics/B09238_11_11.jpg)'
- en: 'Figure 11.11: Burp showing Postman-generated requests'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：Burp显示Postman生成的请求
- en: The environment
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: 'In order to build effective collections, we should create a new Postman environment
    for each target API. Postman environments allow us to store data in variables
    that will prove useful for activities, such as passing authorization tokens between
    requests within a collection. To create a new environment, we can use the **Create
    New** tab in the top-left corner:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建有效的集合，我们应该为每个目标API创建一个新的Postman环境。Postman环境允许我们在变量中存储数据，这对于执行一些操作非常有用，例如在集合中的请求之间传递授权令牌。要创建新的环境，我们可以使用左上角的**创建新环境**标签：
- en: '![The environment](graphics/B09238_11_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![环境](graphics/B09238_11_12.jpg)'
- en: 'Figure 11.12: Creating a new environment in Postman'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：在Postman中创建新环境
- en: 'In the popup window, enter a meaningful name and click **Add** to create the
    new empty environment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出窗口中，输入一个有意义的名称，然后点击**添加**来创建一个新的空环境：
- en: '![The environment](graphics/B09238_11_13.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![环境](graphics/B09238_11_13.jpg)'
- en: 'Figure 11.13: Adding a new Postman environment'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：添加新的Postman环境
- en: Requests can now be associated with our ECorp API environment. Collections can
    also be run in specific environments, allowing the creation and passing of variables
    between requests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请求现在可以与我们的ECorp API环境关联。集合也可以在特定环境中运行，允许在请求之间创建和传递变量。
- en: 'The following figure shows a simple `GET` request queued to run in the ECorp
    API environment:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个简单的`GET`请求排队等待在ECorp API环境中运行：
- en: '![The environment](graphics/B09238_11_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![环境](graphics/B09238_11_14.jpg)'
- en: 'Figure 11.14: Specifying an environment for a request'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：为请求指定环境
- en: Collections
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: As we said earlier, a collection is simply a list of API requests in a particular
    sequence. They can be exported to JSON and imported into any Postman client, making
    them really portable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，集合只是按照特定顺序排列的一组API请求。它们可以导出为JSON格式并导入到任何Postman客户端中，使其具有很强的可移植性。
- en: To showcase the power of Postman collections, we will create one for our vulnerable
    API instance, `api.ecorp.local,` running on port `8081`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Postman集合的强大功能，我们将为我们的易受攻击API实例创建一个集合，实例名为`api.ecorp.local`，运行在端口`8081`上。
- en: If we look at the documentation for Matt Valdes' vulnerable API, we notice that
    most interactions require an authorization token passed via a custom `X-Auth-Token`
    HTTP header. While most RESTful APIs try to use the `Authorization` header for
    tokens, custom headers are not all that uncommon. This is why highly customizable
    tools such as Burp and Postman are ideal for security testing, as we can automate
    much of the work even when we encounter deviations from the norm.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看Matt Valdes的易受攻击API的文档，我们会注意到大多数交互都需要通过自定义的`X-Auth-Token` HTTP头传递授权令牌。虽然大多数RESTful
    API尝试使用`Authorization`头传递令牌，但自定义头并不少见。这就是为什么像Burp和Postman这样高度可定制的工具非常适合进行安全测试，因为即使我们遇到偏离常规的情况，它们也能让我们自动化大部分工作。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation can be found in the `README.md` for [https://github.com/mattvaldes/vulnerable-api](https://github.com/mattvaldes/vulnerable-api).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在`README.md`中找到，链接地址为[https://github.com/mattvaldes/vulnerable-api](https://github.com/mattvaldes/vulnerable-api)。
- en: 'The documentation states that we can get a new token if we send a `POST` to
    `/tokens` with the body containing JSON-formatted authentication data. The default
    credentials are `user1` with `pass1`. Our authentication request `POST` body should
    look like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 文档指出，如果我们发送一个包含 JSON 格式认证数据的 `POST` 请求到 `/tokens`，我们可以获得一个新的令牌。默认的凭证是 `user1`
    和 `pass1`。我们的认证请求 `POST` 请求体应该如下所示：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The API will respond with another JSON-formatted object containing the token
    needed for subsequent authenticated requests:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: API 将返回一个包含后续认证请求所需令牌的 JSON 格式对象：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then pass the `id` value to the `/user/1` endpoint via the `X-Auth-Token`
    header and the request should succeed:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过 `X-Auth-Token` 头将 `id` 值传递给 `/user/1` 端点，请求应该成功：
- en: '![Collections](graphics/B09238_11_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_15.jpg)'
- en: 'Figure 11.15: Successful authenticated request to the vulnerable API'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15：成功认证请求到漏洞 API
- en: Now that we have a sequence of requests, we want to create a collection and
    automate some of this testing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一系列请求，我们想要创建一个集合并自动化一些测试。
- en: 'Once again, from the **Create New** button in the top-left, select **Collection**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击左上角的 **Create New** 按钮，选择 **Collection**：
- en: '![Collections](graphics/B09238_11_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_16.jpg)'
- en: 'Figure 11.16: Creating a new collection'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：创建新的集合
- en: 'In the popup, we can enter the name, and a description if needed, before clicking
    the **Create** button:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出框中，我们可以输入名称，并在需要时添加描述，然后点击 **Create** 按钮：
- en: '![Collections](graphics/B09238_11_17.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_17.jpg)'
- en: 'Figure 11.17: Creating a new collection'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17：创建新的集合
- en: 'All of the requests we''ve made are recorded in the **History** tab in the
    workspace. We can highlight the ones we need for the collection and click the
    **Save** button next to **Send** in the top-right corner:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的所有请求都会记录在工作区的 **History** 标签中。我们可以选择需要的请求，并点击右上角 **Send** 旁边的 **Save**
    按钮：
- en: '![Collections](graphics/B09238_11_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_18.jpg)'
- en: 'Figure 11.18: Saving requests to a collection'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18：将请求保存到集合中
- en: 'At the bottom, we should see our new ECorp API collection and we can select
    it to save our requests:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们应该能看到新的 ECorp API 集合，并可以选择它来保存我们的请求：
- en: '![Collections](graphics/B09238_11_19.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_19.jpg)'
- en: 'Figure 11.19: Selecting the destination collection'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19：选择目标集合
- en: 'Repeat this process for any requests that must go into this collection. When
    run, we expect our collection to get a new token in the first request and make
    a second authenticated request to `/user/1` using the newly provided token:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何必须加入此集合的请求重复此过程。运行时，我们预计我们的集合会在第一个请求中获得新的令牌，并使用新提供的令牌发出第二个认证请求到 `/user/1`：
- en: '![Collections](graphics/B09238_11_20.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_20.jpg)'
- en: 'Figure 11.20: Authenticated Postman request'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20：认证的 Postman 请求
- en: At this point, we can export and import it somewhere else. As it stands, our
    collection will run, but the token will not be passed through to the second request.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以将其导出并导入到其他地方。目前，我们的集合可以运行，但令牌不会传递到第二个请求。
- en: For this, we need to leverage a Postman feature called **Tests**. Each request
    can be configured to execute tests and perform an action before continuing. Typically,
    these can be used to validate that the request was successful. Developers can
    leverage Tests to make sure the code they just pushed didn't break anything.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要利用 Postman 中的一个功能，叫做 **Tests**。每个请求都可以配置为在继续之前执行测试并执行某个操作。通常，这些可以用于验证请求是否成功。开发人员可以利用
    Tests 来确保他们刚刚推送的代码没有破坏任何东西。
- en: Tests are written in JavaScript, so a little bit of coding knowledge will go
    a long way. Thankfully, there are canned tests that we can repurpose for our needs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是用 JavaScript 编写的，所以一点点编程知识将大有帮助。幸运的是，我们可以复用现成的测试来满足我们的需求。
- en: For our `Get Auth Token` request in the ECorp API collection, the test needs
    to inspect the response, parse it as JSON, and extract the token ID. To pass it
    to another request, we can leverage the ECorp API environment and store the data
    in a variable we call `auth_token`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在 ECorp API 集合中的 `Get Auth Token` 请求，测试需要检查响应，解析为 JSON，并提取令牌 ID。为了将其传递给另一个请求，我们可以利用
    ECorp API 环境，并将数据存储在一个名为 `auth_token` 的变量中。
- en: 'The code to achieve this is fairly straightforward, albeit a bit strange if
    you''re not familiar with JavaScript. Each `pm.test` entry is a separate test
    to be executed in the order listed. If any of the tests fail, the run will alert
    us:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码相当简单，尽管如果您不熟悉JavaScript可能会有点奇怪。每个`pm.test`条目都是按照列出的顺序执行的单独测试。如果任何测试失败，运行将提醒我们：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first test simply checks to see whether the HTTP response from the API was
    `200`. Anything else will throw an error during the collection run.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试只是检查API的HTTP响应是否为`200`。其他任何响应都会在集合运行期间引发错误。
- en: 'The second test will parse the response text as JSON and store it in the local
    `data` variable. If you recall the hierarchy of the `/tokens` response, we need
    to access the `id` value in the `access.token` field using the JavaScript array
    notation: `data[''access''][''token''][''id'']`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试将解析响应文本为JSON并将其存储在本地的`data`变量中。如果您回忆一下`/tokens`响应的层次结构，我们需要使用JavaScript数组表示法访问`access.token`字段中的`id`值：`data['access']['token']['id']`。
- en: Using the `pm.environment.set` function, we store the `id` value in the `auth_token`
    environment variable, making it available to other requests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pm.environment.set`函数，我们将`id`值存储在`auth_token`环境变量中，使其可供其他请求使用。
- en: 'Each time this request in this collection runs, `auth_token` will be updated.
    Environments can be inspected by clicking the "eye" icon next to the name:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行此集合中的请求时，`auth_token`都将被更新。可以通过点击名称旁边的“眼睛”图标来检查环境：
- en: '![Collections](graphics/B09238_11_21.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_21.jpg)'
- en: 'Figure 11.21: Inspecting the Postman environment'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：检查Postman环境
- en: 'Our second request to `/user/1` requires that we pass this value via the `X-Auth-Token`
    header. To do this, we add a new custom header and, for the value, we pull up
    a list of existing variables by typing `{{` in the **Value** field. Postman will
    autocomplete existing variables for us:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`/user/1`的第二个请求要求通过`X-Auth-Token`标头传递此值。为此，我们添加一个新的自定义标头，并在**值**字段中键入`{{`以显示现有变量列表。Postman将为我们自动完成现有变量：
- en: '![Collections](graphics/B09238_11_22.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_22.jpg)'
- en: 'Figure 11.22: Using environment variables in requests'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：在请求中使用环境变量
- en: 'Clicking **Send**, we can verify that the authenticated request succeeded:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**发送**，我们可以验证身份验证请求是否成功：
- en: '![Collections](graphics/B09238_11_23.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Collections](graphics/B09238_11_23.jpg)'
- en: 'Figure 11.23: The authenticated request succeeds'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：身份验证请求成功
- en: Collection Runner
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection Runner
- en: Collections can be exported and imported using the familiar JSON format. Importing
    is a straightforward drag-and-drop operation. Developers and QAs can create these
    collections the same way we did earlier, export them, and as part of the engagement,
    send the file to us. This greatly simplifies our job of assessing the API, because
    the time-consuming work has already been done.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以使用熟悉的JSON格式导出和导入。导入是一个简单的拖放操作。开发人员和质量保证人员可以像之前一样创建这些集合，导出它们，并作为参与的一部分将文件发送给我们。这极大地简化了我们评估API的工作，因为耗时的工作已经完成。
- en: 'Once imported, our collection can be executed by the Postman Runner, accessible
    via the **Runner** button near to the **New** button in the menu:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，我们的集合可以通过Postman Runner执行，可通过菜单中**新建**按钮旁边的**Runner**按钮访问：
- en: '![Collection Runner](graphics/B09238_11_24.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Collection Runner](graphics/B09238_11_24.jpg)'
- en: 'Figure 11.24: Opening the Runner component'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：打开Runner组件
- en: 'A new **Collection Runner** window opens with all the imported collections.
    Select the ECorp API collection, the ECorp API environment, and click **Run ECorp
    API**:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的**Collection Runner**窗口，其中包含所有导入的集合。选择ECorp API集合，ECorp API环境，并点击**运行ECorp
    API**：
- en: '![Collection Runner](graphics/B09238_11_25.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Collection Runner](graphics/B09238_11_25.jpg)'
- en: 'Figure 11.25: Running the ECorp collection'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：运行ECorp集合
- en: 'If all goes well, we should see green across the board, as our tests should
    have succeeded, meaning the authentication request was successful, the token was
    extracted, and the user query returned some data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到所有都是绿色的，因为我们的测试应该已成功，这意味着身份验证请求成功，令牌被提取，并且用户查询返回了一些数据：
- en: '![Collection Runner](graphics/B09238_11_26.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![Collection Runner](graphics/B09238_11_26.jpg)'
- en: 'Figure 11.26: Successful Postman collection run'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：成功的Postman集合运行
- en: 'More importantly, all of the requests in the collection were passed upstream
    to our Burp proxy:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，集合中的所有请求都被传递到我们的Burp代理：
- en: '![Collection Runner](graphics/B09238_11_27.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Collection Runner](graphics/B09238_11_27.jpg)'
- en: 'Figure 11.27: Burp-captured Postman collection run'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27：Burp捕获的Postman集合运行
- en: From here, we can launch the Burp Scanner, Intruder, and Sequencer modules or
    replay any request to manipulate the data and look for vulnerabilities, as we
    normally do with traditional applications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以启动Burp Scanner、Intruder和Sequencer模块，或者重放任何请求以操控数据并寻找漏洞，正如我们在传统应用程序中常做的那样。
- en: Attack considerations
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击考虑事项
- en: 'Targeting HTTP-based APIs is really no different than traditional web applications.
    We have to follow the same basic procedure:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 针对基于HTTP的API的攻击与传统的Web应用程序并无太大不同。我们需要遵循相同的基本程序：
- en: Identify injection points
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定注入点
- en: Send unexpected input and observe how the API behaves
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送意外输入并观察API如何响应
- en: 'Look for the usual suspects: SQLi, XXE, XSS, command injection, LFI, and RFI'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找常见嫌疑：SQL注入、XXE、XSS、命令注入、LFI和RFI
- en: We can use all the tips and tricks we already know to find these issues, with
    some exceptions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用已经掌握的所有技巧和方法来发现这些问题，但也有一些例外情况。
- en: XSS vulnerabilities in a typical web application are easy to prove. You send
    the input, the input is reflected to the client as HTML or JavaScript, the browser
    renders the content, and the code executes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 典型Web应用程序中的XSS漏洞很容易证明。你发送输入，输入作为HTML或JavaScript被反射回客户端，浏览器渲染内容并执行代码。
- en: With web services, the response is typically not rendered, primarily due to
    the `Content-Type` header set by the response. This is usually JSON or XML, which
    most browsers will not render as HTML. I say "most" because, unfortunately, some
    older browsers may still render the content, ignoring the content type stated
    by the server, and guessing based on the data in the response.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web服务，响应通常不会被渲染，主要是因为响应头中的`Content-Type`设置。这通常是JSON或XML，大多数浏览器不会将其渲染为HTML。我说的是“大多数”，因为不幸的是，一些旧版浏览器可能仍会渲染内容，忽略服务器声明的内容类型，而是根据响应中的数据猜测。
- en: 'The following reflected input issue was discovered in the `api.ecorp.local/user/1` URL:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api.ecorp.local/user/1` URL中发现了以下反射型输入问题：
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We pass in the JavaScript payload and observe that the API reflects it back
    to the client, unescaped:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传入JavaScript负载并观察到API将其原封不动地返回给客户端，且没有进行转义：
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Normally, this would be enough to prove the vulnerability exists and users can
    be targeted using social engineering. However, if you look closely, you'll notice
    the content type is set to `application/json`, and this means that modern browsers
    will not render the response as HTML, rendering our payload useless.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这就足以证明存在漏洞，并且用户可能会通过社交工程攻击成为目标。然而，如果仔细观察，你会注意到内容类型设置为`application/json`，这意味着现代浏览器不会将响应渲染为HTML，从而使我们的负载无效。
- en: With APIs, we may still have hope. Web services are not typically accessed directly
    in a decoupled environment. It is possible that this particular API is leveraged
    by a web application. That error message could eventually find its way into a
    browser, which may eventually render our payload. What if all errors are logged
    by the web service and later neatly rendered in a status dashboard that's only
    visible internally? We would then have JavaScript code execution on any analyst
    who inspects the state of the API.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API，我们或许仍然抱有希望。在解耦环境中，Web服务通常不会直接访问。可能该特定API是通过Web应用程序进行调用的。错误消息可能最终会出现在浏览器中，浏览器可能最终渲染我们的负载。如果所有错误都被Web服务记录，并且稍后被整齐地呈现在仅内部可见的状态仪表板中呢？那么我们就能在任何分析师检查API状态时执行JavaScript代码。
- en: Web application scanners may identify this issue but mark it as informational,
    and it could be missed. It's important to consider the context around each vulnerability
    and how the affected service may be used by different clients. Remember out-of-band
    discovery and exploitation when attacking APIs, as not all vulnerabilities are immediately
    obvious.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序扫描器可能会识别到这个问题，但将其标记为信息性问题，因此可能会被忽略。考虑每个漏洞的上下文以及不同客户端如何使用受影响的服务非常重要。记住在攻击API时要注意带外发现和利用，因为并非所有漏洞都是立即显现的。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at different ways we can make attacking APIs easier.
    We described the two most common standards for web services, SOAP and REST. We
    looked at how authentication is handled and what role JWTs play in secure communication.
    We explored tools and extensions that help make us more efficient.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了让攻击API变得更容易的不同方式。我们介绍了Web服务的两种最常见标准：SOAP和REST。我们查看了身份验证是如何处理的，以及JWT在安全通信中扮演的角色。我们还探索了帮助提高效率的工具和扩展。
- en: We also played around with Postman and the idea of automating discovery, and the
    testing of API inputs and endpoints.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Postman，并尝试了自动化发现的想法，以及对API输入和端点的测试。
- en: APIs may be the latest trend for web and mobile applications, but they're not
    that different from the usual HTTP application. In fact, as we saw earlier, microservice
    architecture brings about some new challenges when it comes to authentication,
    which can be exploited alongside the usual server-side and client-side vulnerabilities.
    Coming up in the next chapter, we will look at CMSs, and some ways to discover
    and subvert them for fun and profit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: API可能是Web和移动应用程序的最新趋势，但它们与通常的HTTP应用程序并没有太大的区别。实际上，正如我们之前所看到的，微服务架构在身份验证方面带来了一些新的挑战，这些挑战可以与通常的服务器端和客户端漏洞一起利用。在接下来的章节中，我们将看看内容管理系统（CMS）以及一些发现和利用它们的有趣和有利的方法。
