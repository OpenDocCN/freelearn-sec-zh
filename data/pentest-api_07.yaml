- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Denial of Service and Rate-Limiting Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝服务与限速测试
- en: 'Continuing from basic API attacks, it’s now time for us to understand more
    about **denial-of-service** (**DoS**) and **distributed denial-of-service** (**DDoS**)
    threats and answer some questions, such as the following: Why are they so important?
    How impactful they could be for API endpoints? What can we leverage to successfully
    manage the triggering of these sorts of attacks? You will learn that DoS, especially
    the distributed form of it, is a global problem affecting pretty much any publicly
    exposed endpoint or application. Additionally, software that is only privately
    accessible is not immune to them. Although sometimes rarer, insider threats are
    present and can disrupt internal applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础的 API 攻击开始，现在是时候深入了解 **拒绝服务** (**DoS**) 和 **分布式拒绝服务** (**DDoS**) 威胁，并回答一些问题，例如：它们为何如此重要？它们对
    API 端点的影响有多大？我们能利用什么来成功管理这些攻击的触发？你将了解到，DoS，尤其是其分布式形式，是一个全球性问题，几乎影响所有公开暴露的端点或应用程序。此外，尽管比较少见，但仅在私有环境中可访问的软件也并非免疫于此类攻击。内部威胁虽然较少，但也存在，并且可能会破坏内部应用。
- en: '**Rate limiting** is a key defense mechanism against DoS attacks, designed
    to control the amount of traffic an API can handle from a particular user or IP
    address over a specific period. It prevents users from making too many requests
    in a short amount of time, which can be an indicator of an attack. Proper rate
    limiting can help maintain service availability even during an attack by allowing
    only a manageable number of requests.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**限速**是防御 DoS 攻击的关键机制，旨在控制 API 在特定时间内可以处理来自某个用户或 IP 地址的流量量。它可以防止用户在短时间内发送过多请求，这通常是攻击的指示。适当的限速可以在攻击期间帮助保持服务可用性，只允许一定数量的请求。'
- en: When conducting penetration testing, it’s important to identify the API’s rate-limiting
    mechanisms and test their effectiveness. It involves assessing the thresholds
    set for users and attempting to circumvent them to check the robustness of these
    controls. This phase of testing may also involve checking the API’s response to
    different attack vectors that could lead to service disruption.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，识别 API 的限速机制并测试其有效性非常重要。这包括评估为用户设置的阈值，并尝试绕过它们以检查这些控制的强度。此阶段的测试还可能包括检查
    API 对不同攻击向量的响应，这些攻击向量可能导致服务中断。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Testing for DoS vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 DoS 漏洞
- en: Identifying rate-limiting mechanisms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别限速机制
- en: Circumventing rate limitations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过限速
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As it happened with previous chapters, we’ll leverage the same environment as
    the one pointed out in previous chapters, such as an Ubuntu distribution. Some
    other new relevant utilities will be mentioned in the corresponding sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将利用之前章节中提到的相同环境，例如 Ubuntu 发行版。在相应的部分中还将提到一些新的相关工具。
- en: Testing for DoS vulnerabilities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 DoS 漏洞
- en: 'There were notable recent incidents that are worth mentioning to illustrate
    the power and reach of such kinds of attacks. They are listed by traffic volume,
    and the references are in the *Further reading* section at the end of the chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些值得提及的近期事件，这些事件能够展示这类攻击的威力和影响力。它们按流量规模列出，相关参考文献可以在本章最后的*进一步阅读*部分找到：
- en: The attack against Google Cloud reached 2.54 Tbps in 2017, but it was only disclosed
    to the public three years later in 2020\. The attacks sent forged packets to web
    servers pretending they were being sent by Google servers. All the responses to
    such packets were sent to Google, which caused this volume.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对 Google Cloud 的攻击在 2017 年达到了 2.54 Tbps，但直到三年后的 2020 年才向公众披露。攻击通过伪造的数据包发送到
    Web 服务器，伪装成 Google 服务器发送的请求。所有回应这些数据包的响应都被发送到 Google，从而导致了这一流量。
- en: In February 2020, one AWS customer’s infrastructure was the target of a 2.3
    Tbps DDoS attack. The specialized company service, AWS Shield, managed to absorb
    the “tsunami,” which protected the customer’s assets. By leveraging **Connectionless
    Directory Access Protocol** (**CLDAP**), the criminals dispatched huge amounts
    of packets toward publicly available **Lightweight Directory Access Protocol**
    (**LDAP**) servers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2020 年 2 月，一家 AWS 客户的基础设施成为 2.3 Tbps DDoS 攻击的目标。专门的服务 AWS Shield 成功吸收了这一“海啸”，从而保护了客户的资产。犯罪分子通过利用
    **无连接目录访问协议** (**CLDAP**) 向公开可用的 **轻量目录访问协议** (**LDAP**) 服务器发送了大量数据包。
- en: GitHub occupies the third place on our list. In 2018, making use of a well-known
    vulnerability in Memcached, a popular in-memory database, attackers could abuse
    public Memcached servers on the internet. The root cause was like the one that
    hit Google. By spoofing GitHub’s IP addresses, criminals sent packets that got
    amplified by such servers and sent back to GitHub.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 排在我们的列表第三位。在 2018 年，利用 Memcached（一个流行的内存数据库）中的一个著名漏洞，攻击者可以滥用互联网上的公共 Memcached
    服务器。根本原因类似于曾影响 Google 的事件。通过伪装 GitHub 的 IP 地址，罪犯发送了经过这些服务器放大的数据包，并将其返回到 GitHub。
- en: We will use our old friend Ubuntu to make the lab for this chapter. However,
    we will install a couple of additional tools because we need to send reasonable
    amounts of traffic and tweak some options to simulate what we are doing from different
    sources. For that sake, we will make use of **Mockoon**, an open-source solution
    to create mocked APIs. We’ve been using crAPI and our own Python application since
    then. It’s now time to test with some other software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用老朋友 Ubuntu 来构建本章的实验环境。但是，我们将安装一些额外的工具，因为我们需要发送合理数量的流量，并调整一些选项，以模拟从不同来源执行的操作。为此，我们将使用
    **Mockoon**，这是一个开源解决方案，用于创建模拟的 API。自那时以来，我们一直在使用 crAPI 和我们自己的 Python 应用程序。现在是时候用一些其他软件进行测试了。
- en: Getting to know Mockoon
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Mockoon
- en: The installation is as simple as using Snap to accomplish it (on Linux at least).
    The product is also available for Windows and macOS. Keep in mind that, at least
    when this book was being written, there was no version for ARM64\. So, unfortunately,
    you have to have an Intel system to use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程非常简单，可以通过使用 Snap 完成（至少在 Linux 上是如此）。该产品也适用于 Windows 和 macOS。请注意，至少在本书写作时，尚未提供
    ARM64 版本。所以，不幸的是，你必须拥有一个 Intel 系统才能使用它。
- en: Load the application. The first load might take some time. The opening screen
    is shown in the following screenshot. I recommend you go through the initial tour.
    It’s not too big and quite straightforward. It is important to say that Mockoon
    calls the endpoints **routes**. This is common throughout the literature and among
    some other products.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序。第一次加载可能需要一些时间。以下截图展示了开机画面。我建议你浏览一下初始导览。它不大且相当直观。值得一提的是，Mockoon 将端点称为
    **路由**。这是在文献中和一些其他产品中常见的命名方式。
- en: '![Figure 7.1 – Mockoon’s splash screen](img/B19657_figure_07.01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Mockoon 的启动画面](img/B19657_figure_07.01.jpg)'
- en: Figure 7.1 – Mockoon’s splash screen
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Mockoon 的启动画面
- en: 'You’ll realize that Mockoon already starts a pre-configured API (called **DemoAPI**)
    and some routes as soon as you finish the tour or simply cancel it. You need to
    push the *play* icon button to put the API to start listening to requests. On
    the **Settings** tab, you can choose the IP address, port, and optional prefix
    that will be used. It’s also possible to enable TLS. The product comes with a
    self-signed certificate, but you can optionally provide your own certificate file,
    the CA certificate file, and the relevant keys. When this option is enabled, a
    lock icon shows up just below the API name and you must restart the API if it’s
    already running. Simply click on the yellow circled arrow or follow this menu
    sequence: **Run** | **Start** | **Stop** | **Reload** **current environment**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，Mockoon 在你完成初步浏览或直接取消时，已经启动了一个预配置的 API（称为 **DemoAPI**）和一些路由。你需要点击 *播放*
    图标按钮，才能让 API 开始监听请求。在 **Settings** 标签页中，你可以选择将要使用的 IP 地址、端口和可选的前缀。还可以启用 TLS。该产品附带了一个自签名证书，但你也可以选择提供自己的证书文件、CA
    证书文件和相关的密钥。当启用此选项时，一个锁形图标会显示在 API 名称下方，如果 API 已经在运行，你必须重启它。只需点击黄色圆圈箭头，或按照以下菜单顺序操作：**Run**
    | **Start** | **Stop** | **Reload** **current environment**：
- en: '![Figure 7.2 – Restarting the Mockoon API after enabling TLS](img/B19657_figure_07.02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 启用 TLS 后重启 Mockoon API](img/B19657_figure_07.02.jpg)'
- en: Figure 7.2 – Restarting the Mockoon API after enabling TLS
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 启用 TLS 后重启 Mockoon API
- en: 'Take some time to navigate through the interface. All the routes (endpoints)
    are listed under the **Routes** tab. The DemoAPI has a total of seven of them.
    The data served as the response for **create, read, update, and delete** (**CRUD**)
    is a script using a type of language. It generates 50 random usernames and their
    IDs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间浏览界面。所有路由（端点）都列在 **Routes** 标签页下。DemoAPI 总共有七个路由。作为 **创建、读取、更新和删除**（**CRUD**）的响应数据是一个使用某种语言类型的脚本。它生成
    50 个随机的用户名及其 ID：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Interacting with Mockoon’s endpoints
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Mockoon 的端点进行交互
- en: 'The CRUD route is listening on `/users`. Observe what happens when you do this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 路由正在监听 `/users`。观察执行此操作时发生的情况：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The accepted headers are on the tab with the same name. By default, only the
    well-known `Content-Type: application/json` is there. Logs can be accessed on
    the eponymous tab. Let’s do a first test with this dummy API that Mockoon gives
    us. For that matter, we’ll make use of another famous tool: `ab`. This is the
    acronym for **ApacheBench**, and it’s a utility that developers and sysadmins
    usually apply when they need to do load tests on their applications. It’s also
    straightforward to install.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '可接受的请求头可以在同名标签页中找到。默认情况下，只有常见的`Content-Type: application/json`。日志可以在同名标签页中访问。让我们先用这个Mockoon提供的虚拟API进行第一次测试。为此，我们将使用另一个著名的工具：`ab`。这是**ApacheBench**的缩写，它是开发人员和系统管理员在进行应用程序负载测试时常用的工具。它的安装也很简单。'
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, I’ll interchangeably use *endpoint* and *route*. Just bear in mind
    that they have the same meaning in this context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我会交替使用*endpoint*和*route*这两个术语。请记住，在这个上下文中它们是相同的意思。
- en: 'We will target the `/users` route to see how our API behaves when receiving
    a reasonable number of requests. Let’s begin with 100 requests (the `-n` command
    option), with 10 (the `-c` command option) of them being simultaneous. Type the
    following command and observe the results:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标定在`/users`路由，看看当接收到合理数量的请求时，我们的API表现如何。让我们从100个请求（`-n`命令选项）开始，其中10个（`-c`命令选项）是并发请求。输入以下命令并观察结果：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first point we realize is that `ab` is somehow chatty. That’s expected
    since the main purpose is to load-test your application, right? Nevertheless,
    you can control its output with the `-q` and `-v` options. The main page explains
    all its switches. Mockoon seems to have behaved as expected (on my regular laptop
    and running on top of an Ubuntu VM). Pay special attention to the last section
    of the preceding output. It shows the percentiles of requests being served in
    specific periods. It should be interpreted like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先意识到`ab`有点啰嗦。这是可以预料的，因为它的主要目的是对你的应用程序进行负载测试，对吧？尽管如此，你可以通过`-q`和`-v`选项来控制它的输出。主页面解释了所有的选项开关。Mockoon似乎按预期表现（在我的常规笔记本电脑上运行，并且在Ubuntu虚拟机上）。特别注意前面输出的最后一部分。它显示了特定时间段内服务请求的百分位数。它应当这样理解：
- en: 50% of the requests were served in 1 ms or less.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50%的请求在1毫秒或更短时间内被服务。
- en: Up to 95% of the requests were served in 10 ms or less.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高达95%的请求在10毫秒或更短时间内被服务。
- en: The longest request took 23 ms to be served.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最长的请求花费了23毫秒才被服务。
- en: All requests were logged and none of them suffered big delays to be served.
    It’s however curious that Mockoon did not provide any data (not even HTML) when
    answering these requests. This can be perceived by the preceding `Document Length`,
    `Total transferred` and `HTML transferred` lines. This may reveal misconfiguration
    on the API side, unexpected errors, or that Mockoon skipped providing some answer
    to `ab`. This can happen sometimes since Mockoon is just a fake/mock API server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求都被记录，并且没有任何请求经历大的延迟。不过，值得注意的是，Mockoon在响应这些请求时并没有提供任何数据（甚至没有HTML）。从前面`Document
    Length`、`Total transferred`和`HTML transferred`行中可以看出这一点。这可能揭示了API端的配置错误、意外的错误，或是Mockoon在回答`ab`时跳过了某些响应。由于Mockoon只是一个假/mock
    API服务器，这种情况有时会发生。
- en: 'Now, let’s see how our dear API will behave when the numbers are multiplied
    by 10\. Some output was purposefully omitted for simplicity:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当请求数量乘以10时，我们亲爱的API会有什么表现。一些输出故意被省略，以简化展示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ha! Now, we are seeing data coming. That’s what I’m talking about, dude! Icebreakers
    apart, observe that the response time substantially increased when compared to
    the previous test. If you repeat this command, but through HTTPS, you will receive
    slightly longer times. I did a final test with 10,000 requests being 1,000 simultaneous,
    and Mockoon was not fully responsive this time:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 哈！现在，我们看到数据开始出现了。这才是我说的意思，伙计！抛开开场白不谈，观察到与上一次测试相比，响应时间显著增加。如果你重复这个命令，但通过HTTPS，你会收到稍微长一点的响应时间。我做了最后一次测试，10,000个请求，其中1,000个是并发请求，而这次Mockoon并没有完全响应：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This had nothing to do with the VM’s memory footprint. I was watching it the
    whole time and my system had around 2.5 GB of free RAM. I even restarted Mockoon
    to give it a clean memory area, but this didn’t suffice. Only 50 requests were
    logged this time (this is the maximum number of log entries the API shows by default).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这与虚拟机的内存占用无关。我全程监视着它，我的系统有大约2.5 GB的空闲RAM。我甚至重新启动了Mockoon，以便为它提供一个干净的内存空间，但这仍然不足以解决问题。此次只记录了50个请求（这是API默认显示的最大日志条目数）。
- en: Leveraging Scapy to attack Mockoon
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用Scapy攻击Mockoon
- en: 'It’s been a while since the last time we used Wireshark, huh? For the next
    tests, it will be more enlightening if we have it running. If you don’t have it
    on your system yet, install it and load it. Put it to listen to the loopback adapter.
    You may need to execute it as the root to accomplish this. For the next test,
    we will make use of `pip` and run the following small code. Observe its output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一段时间没使用 Wireshark 了，对吧？接下来的测试，如果我们能运行 Wireshark，将会更加有启发性。如果你系统中还没有它，赶紧安装并加载它。把它设置为监听回环适配器。你可能需要以
    root 用户身份执行它来完成此操作。接下来的测试中，我们将使用 `pip` 并运行以下小段代码。观察它的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code sends 5,000 packets to TCP port `3000` on localhost, with the `3000`
    is where Mockoon is listening to requests. Observe they are not HTTP packets,
    but just regular **Transmission Control Protocol** (**TCP**) packets. The point
    here is not to watch if the API itself will behave as expected, but if the infrastructure
    hosting it will deal with this unusual activity. If you don’t know much about
    TCP/IP networking, packets with such a flag are used to signal to the receiving
    peer that the connection should be terminated. Let’s see how Mockoon deals with
    this weird communication. You will receive something like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 5,000 个数据包发送到本地主机的 TCP 端口 `3000`，`3000` 是 Mockoon 监听请求的地方。观察它们不是 HTTP
    数据包，而只是普通的 **传输控制协议**（**TCP**）数据包。这里的关键不在于观察 API 本身是否按预期行为表现，而是在于托管 API 的基础设施是否能应对这种不寻常的活动。如果你对
    TCP/IP 网络了解不多，这类带有标志的数据包用于向接收方标明连接应终止。让我们看看 Mockoon 如何处理这种奇怪的通信。你将收到如下内容：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What has Wireshark captured? Switch to it and you will find lots of red lines
    corresponding to the packets (*Figure 7**.3*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 捕获到了什么？切换到 Wireshark，你会看到许多红色的行对应着数据包（*图 7.3*）。
- en: '![Figure 7.3 – Wireshark capturing the Scapy packets with the RST flag set](img/B19657_figure_07.03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Wireshark 捕获带有 RST 标志的 Scapy 数据包](img/B19657_figure_07.03.jpg)'
- en: Figure 7.3 – Wireshark capturing the Scapy packets with the RST flag set
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Wireshark 捕获带有 RST 标志的 Scapy 数据包
- en: The code didn’t return any error, which means Mockoon likely received (and probably
    ignored) all of them. If you are uncertain about the number of dots printed as
    part of the output, simply run the script on the command line and append `|` `wc
    -c`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码没有返回任何错误，这意味着 Mockoon 很可能接收到了所有数据包（并可能忽略了它们）。如果你不确定输出中打印的点的数量，只需在命令行上运行该脚本，并附加
    `|` `wc -c`。
- en: When a web server or API gateway is not configured to foresee this type of weird
    behavior, it can simply crash and eventually leak some internal data, such as
    details about the infrastructure. In our case, Mockoon didn’t throw any error
    messages or even crash. Maybe it leverages some backend server with support for
    such a thing. Or, maybe this happened because the packets were sent in a single
    sequence, one after the other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 服务器或 API 网关没有配置来预见这种奇怪行为时，它可能会直接崩溃，甚至泄露一些内部数据，例如基础设施的详细信息。在我们的案例中，Mockoon
    并没有抛出任何错误信息，也没有崩溃。也许它利用了一些支持这种行为的后端服务器。或者，可能是因为数据包是按顺序一个接一个地发送的，才没有出现问题。
- en: So far, we have tested from the same source IP address. This is good for simple
    tests, but not enough to check how the endpoints can handle connections from multiple
    addresses at the same time. This is the core of DDoS attacks. It may be difficult
    for API endpoints and their environments to distinguish between legitimate traffic
    and pure attacks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直从相同的源 IP 地址进行测试。这对于简单的测试很有帮助，但不足以检查端点如何同时处理来自多个地址的连接。这正是 DDoS 攻击的核心。API
    端点及其环境可能很难区分合法流量和纯粹的攻击。
- en: Mockoon with hping3 – initial tests
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 hping3 进行 Mockoon 测试 – 初步测试
- en: 'To help us with this, let’s invoke another tool: `hping3`. In the case of our
    lab, we can use `apt` to install it. There are at least five different ways you
    can leverage `hping3` to test your routes. First, we are going to send a couple
    of **Synchronize** (**SYN**) packets, pretending we are trying to establish TCP
    connections and see what happens:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们完成这个任务，让我们调用另一个工具：`hping3`。在我们的实验环境中，我们可以使用 `apt` 来安装它。你可以利用 `hping3`
    测试你的路由的方式至少有五种。首先，我们将发送几个 **同步**（**SYN**）数据包，假装我们正在尝试建立 TCP 连接，看看会发生什么：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output looks like the `ping` command we are used to. That’s the point.
    The tool boosts the possibilities given by its parent though. Observe how Wireshark
    recorded it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像我们习惯的 `ping` 命令。重点正是如此。尽管如此，这个工具增强了其父工具所提供的可能性。观察 Wireshark 是如何记录它的：
- en: '![Figure 7.4 – hping3 sending SYN packets and resetting the connections](img/B19657_figure_07.04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – hping3 发送 SYN 数据包并重置连接](img/B19657_figure_07.04.jpg)'
- en: Figure 7.4 – hping3 sending SYN packets and resetting the connections
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – hping3 发送 SYN 数据包并重置连接
- en: '`hping3` sends each SYN packet, receives the corresponding `Nmap`, too). The
    command is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`hping3` 发送每个 SYN 数据包，并接收相应的 `Nmap`，命令如下：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can inform multiple ports by separating them with commas or dashes (for
    ranges). We sent three packets, but Mockoon didn’t answer them. By checking on
    Wireshark, we can see the packets did hit Mockoon, but no reply was sent back
    whatsoever. Mockoon is possibly ignoring them since they’re just probe packets,
    not fully HTTP/HTTPS packets, and they don’t carry the expected headers or payloads:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过逗号或破折号（用于范围）分隔多个端口。我们发送了三个数据包，但 Mockoon 并未回应。通过在 Wireshark 中查看，我们可以看到数据包确实到达了
    Mockoon，但没有收到任何回复。Mockoon 可能正在忽略它们，因为它们只是探测数据包，而不是完整的 HTTP/HTTPS 数据包，也没有携带预期的头部或负载：
- en: '![Figure 7.5 – Packets sent against Mockoon to scan ports](img/B19657_figure_07.05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 向 Mockoon 发送数据包以扫描端口](img/B19657_figure_07.05.jpg)'
- en: Figure 7.5 – Packets sent against Mockoon to scan ports
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 向 Mockoon 发送数据包以扫描端口
- en: Sending random data with hping3
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 hping3 发送随机数据
- en: 'Let’s move forward. Now, we will send something completely random and nonsense.
    We’ve done this before in another context. This time, we will leverage `hping3`
    for it. Generate a 1 MB file and then send it to Mockoon with the following command.
    Observe the outcomes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。现在，我们将发送一些完全随机且无意义的数据。我们以前在其他场景中做过这个。此次，我们将使用 `hping3` 来实现。生成一个 1 MB
    的文件，然后使用以下命令将其发送给 Mockoon。观察结果：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In summary, we told `hping3` to do the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们告诉 `hping3` 执行以下操作：
- en: Send packets to port TCP `3000` (`-``p 3000`)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 TCP `3000` 端口发送数据包（`-p 3000`）
- en: Dispatch a total of 3 packets (`-``c 3`)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共发送 3 个数据包（`-c 3`）
- en: Use the just-created file as the data payload (`--``file random.bin`)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用刚创建的文件作为数据负载（`--file random.bin`）
- en: Define the packet size as 32768 bytes (`-``d 32768`)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据包大小定义为 32768 字节（`-d 32768`）
- en: Use `localhost` as the destination
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `localhost` 作为目标地址
- en: 'If you are still running Wireshark, you will capture something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在运行 Wireshark，你将捕获到类似以下的内容：
- en: '![Figure 7.6 – Wireshark packet capture when hping3 sent a file to Mockoon](img/B19657_figure_07.06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – Wireshark 捕获的数据包，当 hping3 向 Mockoon 发送文件时](img/B19657_figure_07.06.jpg)'
- en: Figure 7.6 – Wireshark packet capture when hping3 sent a file to Mockoon
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – Wireshark 捕获的数据包，当 hping3 向 Mockoon 发送文件时
- en: Observe that the connection attempts were all reset. That’s because no previously
    established connection could sustain the file transmission. The TCP/IP stack simply
    discarded all the attempts, sending packets with the RST flag on. I’m not sure
    if you realized this too, but `hping3` uses a different source port for every
    single packet it sends. Also, `sudo` was necessary this time. This is because
    the tool needs to make a syscall to the kernel’s network driver and that’s only
    allowed to the root operator or after some privilege elevation, which we can obtain
    with `sudo`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到所有连接尝试都被重置。这是因为没有之前建立的连接能够维持文件传输。TCP/IP 栈简单地丢弃了所有尝试，发送了带有 RST 标志的数据包。我不确定你是否也意识到，`hping3`
    为每个发送的数据包使用了不同的源端口。此外，这次需要使用 `sudo`。这是因为该工具需要进行系统调用，访问内核的网络驱动，而这只允许 root 操作员或经过特权提升后才能执行，我们可以通过
    `sudo` 获得这些权限。
- en: Sending fragmented packets with hping3
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 hping3 发送分片数据包
- en: 'On the next test, we will send fragmented packets to our target. Fragmented
    packets can disrupt an API endpoint due to the way they interact with the network
    infrastructure and the end service. When a large packet is sent over the internet,
    it often exceeds the `-``f` switch):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个测试中，我们将向目标发送分片数据包。由于与网络基础设施和目标服务的交互方式，分片数据包可能会干扰 API 端点。当一个大数据包通过互联网发送时，它通常会超过
    `-f` 开关的限制：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Packet fragmentation is something that worries network administrators. This
    kind of attack can cause problems for the target, such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包分片是网络管理员关心的问题。这种攻击可能会对目标造成如下问题：
- en: Resource exhaustion, because of increased CPU usage or memory overhead
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源耗尽，可能由于 CPU 使用率增加或内存开销
- en: Reassembly failures, due to reassembly timeout or overlapping fragments
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新组装失败，可能由于重新组装超时或重叠的分片
- en: 'The packet capture demonstrates the fragments flowing through the network.
    You will see many more than just three packets because we are forcing them to
    be fragmented:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包捕获演示了通过网络流动的分片。你会看到比仅仅三个数据包更多的包，因为我们强制将其分片：
- en: '![Figure 7.7 – The fragmented packets going to Mockoon](img/B19657_figure_07.07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 发送到 Mockoon 的分片数据包](img/B19657_figure_07.07.jpg)'
- en: Figure 7.7 – The fragmented packets going to Mockoon
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 发送到 Mockoon 的分片数据包
- en: Flooding Mockoon with hping3 packets
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 hping3 数据包进行洪水攻击 Mockoon
- en: 'So far, we’ve used `hping3` by asking it to send a small number of packets
    to our target API server. Now, we’ll go a step further. We’ll send a bigger number
    of packets to try to flood the target (the `--flood` switch), and we’ll verify
    whether Mockoon is smart enough to handle them. We will also randomize the source
    IP address to simulate a true DDoS attack. The following command accomplishes
    this task:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过让 `hping3` 向我们的目标 API 服务器发送少量数据包。现在，我们将进一步操作。我们将发送更多数据包，尝试洪水攻击目标（使用
    `--flood` 开关），并验证 Mockoon 是否足够智能来处理这些数据包。我们还会随机化源 IP 地址，以模拟真实的 DDoS 攻击。以下命令完成此任务：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see that I did not specify the number of packets. So, `hping3` will
    forever flood the target. Also, you can see that no packet was received, indicating
    there was a 100% loss. This caused two interesting behaviors in my system:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我没有指定数据包的数量。因此，`hping3` 将会不停地向目标发送数据包。此外，你还可以看到没有数据包被接收，表示存在 100% 丢包。这导致了系统中的两个有趣现象：
- en: 'First, the free memory drastically reduced in a matter of a few seconds and
    did not recover even after stopping `hping3`:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，空闲内存在几秒钟内急剧减少，并且即使停止 `hping3` 后也没有恢复：
- en: '![Figure 7.8 – The system’s RAM rapidly reducing because of the DDoS attack
    processing](img/B19657_figure_07.08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 系统内存因 DDoS 攻击处理而迅速减少](img/B19657_figure_07.08.jpg)'
- en: Figure 7.8 – The system’s RAM rapidly reducing because of the DDoS attack processing
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 系统内存因 DDoS 攻击处理而迅速减少
- en: 'Secondly, and possibly because of that lack of free memory, Wireshark often
    stopped responding, asking me to either wait for it or to stop it:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，可能由于缺乏空闲内存，Wireshark 经常停止响应，要求我等待或停止它：
- en: '![Figure 7.9 – Wireshark failing to be available while capturing network packets](img/B19657_figure_07.09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – Wireshark 在捕获网络数据包时无法使用](img/B19657_figure_07.09.jpg)'
- en: Figure 7.9 – Wireshark failing to be available while capturing network packets
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – Wireshark 在捕获网络数据包时无法使用
- en: 'When Wireshark finally decided to work at least for a while again, I could
    take a screenshot to show you the anatomy of the packets sent by `hping3`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Wireshark 最终决定至少再工作一段时间时，我可以截图给你展示 `hping3` 发送的数据包的结构：
- en: '![Figure 7.10 – Packets that were part of the hping3’s flooding attack](img/B19657_figure_07.10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – hping3 洪水攻击中的数据包](img/B19657_figure_07.10.jpg)'
- en: Figure 7.10 – Packets that were part of the hping3’s flooding attack
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – hping3 洪水攻击中的数据包
- en: You can easily verify they were very small packets (54 bytes in size) coming
    from virtually endless different IP address sources. This was successfully exhausted
    by the system’s memory and caused not only Mockoon to stop working, but all other
    applications as well. I could no longer even use `curl` to send simple requests
    to the API. This happened because the operating system received more packets than
    it could process in a feasible amount of time and the buffers were all opened
    at the same time in memory, pretty much fully occupying it. Only a full restart
    was recovered by the system to the previous state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松验证，这些是非常小的数据包（大小为 54 字节），来自几乎无限的不同 IP 地址源。这成功地耗尽了系统的内存，导致不仅 Mockoon 停止工作，其他所有应用程序也停止了。我甚至无法再使用
    `curl` 向 API 发送简单请求。这是因为操作系统接收到了比它能在合理时间内处理的更多数据包，并且所有缓冲区同时在内存中打开，几乎完全占用了内存。只有通过完全重启，系统才恢复到了之前的状态。
- en: Making the attack more interesting – the “fast” switch
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让攻击更有趣——“快速”开关
- en: 'At this point, you can ask me this question: Is there a way to turn this into
    something even worse? Guess what? The answer is a big *YES!* `hping3` has a `--fast`
    switch, where it can send around 10 packets per second, absolutely filling all
    possible packet buffers that a regular system can usually apply to handle the
    receiving of packets. Type the following command and observe the results. Your
    whole system might hang again, just as it happened with mine. The explanation
    is quite like the previous test:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，你可能会问我这个问题：有没有办法将其转变为更糟糕的情况？猜猜看？答案是一个大大的*是！* `hping3` 有一个 `--fast` 开关，它可以每秒发送大约
    10 个数据包，彻底填满普通系统通常能够处理接收数据包的所有可能的数据包缓冲区。输入以下命令并观察结果。你的系统可能会再次挂掉，就像我的系统发生的那样。解释和之前的测试非常相似：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `--syn` switch tells `hping3` to send TCP packets with the SYN flag on.
    I didn’t let it hang my system this time, though. I also didn’t choose to randomize
    the source IP addresses. Even with these restrictions, Mockoon occupied the top
    of the processes using more memory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`--syn` 开关告诉 `hping3` 发送带有 SYN 标志的 TCP 数据包。这次我没有让它挂掉我的系统。也没有选择随机化源 IP 地址。即使有这些限制，Mockoon
    仍然占据了使用更多内存的进程的顶部：'
- en: '![Figure 7.11 – Output of the top command showing processes using more memory](img/B19657_figure_07.11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 显示使用更多内存的进程的 top 命令输出](img/B19657_figure_07.11.jpg)'
- en: Figure 7.11 – Output of the top command showing processes using more memory
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 显示使用更多内存的进程的 top 命令输出
- en: 'The packet capture is also interesting, showing Mockoon trying to reset the
    packets as they arrive, which was a noble yet not enough task:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该包捕获也很有趣，展示了 Mockoon 尝试在数据包到达时重置它们，虽然这是一个高尚的任务，但并不足以应对：
- en: '![Figure 7.12 – Packet capture with hping3’s --fast switch](img/B19657_figure_07.12.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 使用 hping3 的 --fast 开关的包捕获](img/B19657_figure_07.12.jpg)'
- en: Figure 7.12 – Packet capture with hping3’s --fast switch
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 使用 hping3 的 --fast 开关的包捕获
- en: Even though not having been generated by different source IP addresses, this
    traffic was still massive and can surely cause some damage to unprepared API endpoints
    and their backends when they are not protected against DoS attacks. It’s all about
    how strong and smart the system is to deal with so many packet handles. In the
    next section, we are going to investigate how we can detect rate-limiting controls.
    They are quite useful to block against simple and sometimes complex attacks such
    as the ones we just learned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些流量并非来自不同的源 IP 地址，但它仍然是巨大的，确实可以对未做好准备的 API 端点及其后端造成一些损害，尤其是在它们没有防范 DoS 攻击时。这完全取决于系统处理如此多数据包句柄的能力和智慧。接下来，我们将探讨如何检测速率限制控制。速率限制对于抵御简单甚至有时复杂的攻击非常有用，就像我们刚刚学习的那种攻击。
- en: Identifying rate-limiting mechanisms
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别速率限制机制
- en: You just learned several ways to trigger DoS attacks against an API endpoint.
    We even sent a trivial but powerful DDoS wave of packets that made our target
    unable to handle them feasibly. The first option to protect against such types
    of threats is rate-limiting the traffic, also called **throttling**. For more
    information, see the link in the *Further* *reading* section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到了一些触发 DoS 攻击 API 端点的方法。我们甚至发送了一波微不足道但强大的 DDoS 数据包，使得我们的目标无法有效地处理这些数据包。防止此类威胁的第一种方法是对流量进行速率限制，也称为**节流**。更多信息，请参阅*进一步阅读*部分中的链接。
- en: Identifying rate-limiting mechanisms within an API is an essential aspect of
    both security and usability assessments. Rate limiting is designed to prevent
    abuse by limiting the number of requests a user can make in each period. It helps
    mitigate various attacks, such as brute force or DDoS, by capping the action frequency.
    This is achieved by applying a policy. This policy ensures that servers are not
    overwhelmed by too many requests at once, which could degrade service for others
    or lead to server failure. Rate limiting can be based on several factors, including
    IP addresses, user accounts, API tokens, or sessions. It typically involves setting
    a maximum number of allowable requests and a time window for these requests. For
    example, an API might allow 100 requests per minute per user. This mechanism helps
    to maintain the quality of service, prevent abuse, and manage server resources
    more effectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 识别 API 中的速率限制机制是安全性和可用性评估中的关键部分。速率限制旨在通过限制用户在每个时间段内可以发起的请求数量，防止滥用。它有助于缓解各种攻击，如暴力破解或分布式拒绝服务（DDoS），通过限制操作频率来实现。这是通过应用一项策略来实现的，该策略确保服务器不会因同时收到过多请求而超载，这可能会影响其他用户的服务质量或导致服务器崩溃。速率限制可以基于多个因素，包括
    IP 地址、用户账户、API 令牌或会话。它通常涉及设置允许的最大请求数量和这些请求的时间窗口。例如，一个 API 可能允许每个用户每分钟最多发起 100
    个请求。该机制有助于保持服务质量、防止滥用，并更有效地管理服务器资源。
- en: There are various ways to implement rate limiting, such as fixed window counters,
    rolling window logs, and leaky buckets, each with its advantages and use cases.
    A fixed window counter resets the count at fixed intervals, potentially allowing
    bursts of traffic at the interval edges. Rolling windows track the count in a
    continuously moving window, which can prevent bursts but requires more complex
    tracking. Leaky buckets allow requests at a steady pace, smoothing outbursts.
    Choosing the right algorithm depends on the specific requirements and behavior
    of the API you’re protecting. Let’s understand a bit more about each one of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种实现速率限制的方法，例如固定窗口计数器、滚动窗口日志和漏桶算法，每种方法都有其优点和应用场景。固定窗口计数器在固定的时间间隔内重置计数，可能会在间隔边缘允许流量突发。滚动窗口在一个持续移动的窗口中跟踪计数，可以防止突发流量，但需要更复杂的跟踪机制。漏桶算法以稳定的速度允许请求，从而平滑流量的激增。选择合适的算法取决于你所保护的
    API 的具体要求和行为。让我们进一步了解每种方法的细节。
- en: Fixed window counters
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定窗口计数器
- en: This is an important concept in the world of rate-limiting requests. They are
    simply counters that record the number of requests arriving during a specific
    amount of time. With this window, an API can check at any time what the current
    number of requests is and reduce or increase them, accordingly, depending on the
    threshold. If the traffic is assessed to be legitimate and the API needs to serve
    more requests (for example, after a new product release), the threshold is increased.
    On the other hand, when nothing justifies having a specific volume of traffic,
    it can be capped.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是速率限制请求中的一个重要概念。它们只是记录在特定时间段内到达的请求数量的计数器。通过这个窗口，API 可以随时检查当前的请求数量，并根据阈值相应地减少或增加请求数量。如果流量被评估为合法，并且
    API 需要处理更多的请求（例如，在新产品发布后），则会提高阈值。另一方面，当没有理由维持特定量的流量时，可以对其进行限制。
- en: During a pentest, you can leverage fixed window counters to your advantage.
    By strategically sending bursts of requests within the defined window timeframe,
    you can attempt to identify the rate limit itself. Observing server responses
    after exceeding the limit is key. Look for changes in response times, the appearance
    of specific error codes (such as 429 Too Many Requests), or the presence of headers
    revealing rate-limiting information. This information helps pentesters understand
    the API’s tolerance for request volume and the consequences of exceeding the limit.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试过程中，你可以利用固定窗口计数器为自己谋取优势。通过在定义的窗口时间内战略性地发送突发请求，你可以尝试识别速率限制本身。超出限制后的服务器响应观察至关重要。注意响应时间的变化、特定错误代码（如
    429 请求过多）的出现，或是显示速率限制信息的头部。这些信息有助于渗透测试人员了解 API 对请求量的容忍度以及超出限制的后果。
- en: There are limitations, though. Window counters are not bulletproof against what
    is called bursting. With this technique, you send a consistent wave of requests
    just before the window time is going to be refreshed (the previous window ends,
    the next window starts). This can exploit the gap between the counter reaching
    its limit and the window resetting, allowing a temporary bypass of the rate limit.
    As a pentester, identifying an API that relies solely on fixed window counters
    highlights a potential vulnerability that could be exploited in a real-world attack
    scenario.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这种方式也有局限性。窗口计数器并不完全防止所谓的突发流量攻击。在这种攻击中，你在窗口时间即将刷新之前（前一个窗口结束，下一窗口开始）发送一波持续的请求。这可以利用计数器达到极限与窗口重置之间的空隙，从而暂时绕过速率限制。作为渗透测试人员，识别一个仅依赖固定窗口计数器的
    API 可以揭示出在实际攻击场景中可能被利用的潜在漏洞。
- en: Rolling window logs
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动窗口日志
- en: 'While fixed window counters offer a basic level of rate-limiting, pentesters
    often encounter APIs that employ a more sophisticated approach: rolling window
    logs. Unlike fixed counters, rolling window logs maintain a chronological record
    of timestamps associated with incoming requests. This record is constantly updated,
    with older timestamps falling out of the window as new requests arrive. The API
    calculates the rate limit by analyzing the number of requests within this dynamic
    window.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 固定窗口计数器提供了基本的速率限制功能，但渗透测试人员常常遇到使用更复杂方法的 API：滚动窗口日志。与固定计数器不同，滚动窗口日志维护了与传入请求相关的时间戳的时间顺序记录。这个记录会不断更新，随着新请求的到来，旧的时间戳会被移出窗口。API
    通过分析这个动态窗口内的请求数量来计算速率限制。
- en: This dynamic nature offers several advantages compared to fixed window counters.
    Bursting does not have the same level of success with it. The window is frequently
    being adjusted, which reduces the chances of attackers exploiting the window reset
    timers. Also, rolling window logs provide a more realistic representation of patterns
    for real-time requests. They can account for sudden surges in legitimate traffic
    that might be incorrectly flagged by a fixed window counter. This allows for a
    more nuanced approach to rate limiting, potentially avoiding unnecessary blocking
    of legitimate users during periods of high activity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于固定窗口计数器，这种动态特性提供了若干优势。突发流量不会像在固定窗口计数器中那样轻易成功。窗口频繁调整，这减少了攻击者利用窗口重置定时器的机会。此外，滚动窗口日志能更真实地呈现实时请求的模式。它们可以考虑到正常流量的突然激增，这些流量可能会被固定窗口计数器错误地标记。这使得速率限制能够更精细化，避免在高活动时期不必要地阻止合法用户。
- en: However, they present a different set of challenges for a pentester. It can
    be more difficult to identify the specific window size and rate limit when compared
    to fixed counters. You might need to employ more sophisticated techniques such
    as sending requests with varying intervals to analyze server responses and infer
    the underlying logic of the rolling window. Additionally, certain implementations
    of rolling window logs might not provide clear feedback through error codes or
    headers, making it slightly more challenging to pinpoint the exact rate limit
    settings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也给渗透测试人员带来了不同的挑战。与固定计数器相比，识别具体的窗口大小和速率限制可能更加困难。你可能需要采用更复杂的技术，例如发送间隔变化的请求来分析服务器响应，并推断滚动窗口的底层逻辑。此外，某些滚动窗口日志的实现可能不会通过错误代码或头部提供明确的反馈，这使得精确确定速率限制设置变得稍微有些困难。
- en: Leaky buckets
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏桶
- en: This concept is somehow unique in the world of rate-limiting for API routes.
    Imagine a bucket with a small hole at the bottom, constantly leaking out a controlled
    amount of water. The arriving requests can be compared to water being put into
    this bucket. The maximum number of requests that can be processed during a specific
    amount of time corresponds to the bucket’s capacity (like a real one with liters
    or gallons). If the bucket starts spilling out *water* (too many requests arriving
    at the endpoint), subsequent ones are rejected because of the lack of capacity,
    and new requests are only accepted once the bucket has some room to accommodate
    them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在 API 路由的速率限制中算是独特的。想象一个桶，底部有一个小孔，水持续以受控的量从孔中漏出。到达的请求可以比作水被倒入这个桶中。特定时间内能够处理的最大请求数对应于桶的容量（就像实际的桶有升或加仑的容量）。如果桶开始溢出*水*（有过多的请求到达端点），随后到达的请求会因没有足够的容量而被拒绝，只有当桶有足够空间容纳新请求时，才会接受新的请求。
- en: This analogy translates to a dynamic rate-limiting mechanism for APIs. The bucket’s
    capacity represents the maximum allowed request volume within a timeframe, and
    the leak rate defines how quickly requests are *processed* and considered permissible.
    This approach offers several advantages for pentesting APIs. Leaky buckets work
    better than fixed window counters with respect to bursts of requests. Even if
    a surge of requests arrives, the bucket can accommodate them to a certain extent,
    preventing unnecessary blocking of legitimate users. Also, as happens with **quality
    of service** (**QoS**) mechanisms, leaky buckets can prioritize certain types
    of packets, processing them even when they don’t have the capacity to accommodate
    more. By adjusting the leak rate for different request types, the API can ensure
    critical requests are processed even during periods of high traffic, enhancing
    overall system responsiveness.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比转化为 API 的动态速率限制机制。漏桶的容量表示在一定时间内允许的最大请求量，而泄漏速率定义了请求被*处理*并视为允许的速度。这种方法为渗透测试
    API 提供了多个优势。漏桶比固定窗口计数器更适合处理突发请求。即使有大量请求涌入，漏桶也能在一定程度上容纳这些请求，防止无谓地阻止合法用户。此外，正如 **服务质量**
    (**QoS**) 机制一样，漏桶可以优先处理某些类型的包，即使没有足够的容量容纳更多请求。通过为不同类型的请求调整泄漏速率，API 可以确保在高流量期间处理关键请求，从而提升整体系统的响应能力。
- en: Nonetheless, for pentesters, leaky buckets present a different testing challenge.
    Unlike fixed windows or rolling window logs with their focus on request counts,
    leaky buckets involve analyzing both capacity and leak rate. Pentesters might
    need to send a series of requests with varying intervals and observe how the server
    responds. By monitoring for changes in response times or the appearance of error
    codes such as 429 Too Many Requests, testers can attempt to infer the bucket’s
    capacity and leak rate. This information can reveal potential weaknesses in the
    leaky bucket implementation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于渗透测试人员来说，漏桶模型提出了不同的测试挑战。与固定窗口或滚动窗口日志侧重于请求计数不同，漏桶模型涉及分析容量和泄漏速率。渗透测试人员可能需要发送一系列具有不同时间间隔的请求，并观察服务器如何响应。通过监控响应时间的变化或出现类似
    429 Too Many Requests 的错误代码，测试人员可以尝试推测漏桶的容量和泄漏速率。这些信息能够揭示漏桶实现中的潜在弱点。
- en: In the next section, we are going to implement a rate-limiting mechanism to
    protect the API we created with Mockoon and check whether we can detect its presence.
    Mockoon itself already comes with some protection controls that you can play with,
    but you can also leverage some external tools for this purpose, which will be
    our case.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个速率限制机制，以保护我们用 Mockoon 创建的 API，并检查是否能够检测到其存在。Mockoon 本身已经提供了一些保护控制，你可以进行尝试，但我们也可以利用一些外部工具来实现这一目的，这将是我们的做法。
- en: A rate-limiting detection lab
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个速率限制检测实验
- en: 'To implement this lab, we will leverage NGINX. We could have done this in the
    form of a Docker container, but since Mockoon is directly running on top of our
    VM, we will take the secondary path: install NGINX on our Linux box. Just follow
    your operating system’s documentation on how to install the software. On Ubuntu,
    it’s a matter of a couple of `apt` commands. As soon as you finish it, NGINX will
    be listening on port `80`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个实验，我们将使用 NGINX。我们本可以通过 Docker 容器来完成，但由于 Mockoon 是直接运行在我们的虚拟机上的，所以我们选择了第二种方式：在我们的
    Linux 主机上安装 NGINX。只需按照操作系统的文档来安装该软件。在 Ubuntu 上，只需要几个 `apt` 命令。当安装完成后，NGINX 会在端口
    `80` 上监听：
- en: '![Figure 7.13 – NGINX default page](img/B19657_figure_07.13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – NGINX 默认页面](img/B19657_figure_07.13.jpg)'
- en: Figure 7.13 – NGINX default page
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – NGINX 默认页面
- en: 'Now, we need a proper `nginx.conf` file to tell NGINX to work as a reverse
    proxy, forwarding all requests to Mockoon and rate-limiting them. Replace the
    contents of the default `/etc/nginx/nginx.conf` file with the following contents:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个合适的 `nginx.conf` 文件，告诉 NGINX 作为反向代理工作，将所有请求转发到 Mockoon 并进行速率限制。将默认的
    `/etc/nginx/nginx.conf` 文件内容替换为以下内容：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each option or directive has its own purpose:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项或指令都有其特定的用途：
- en: '`worker_connections`: This directive tells NGINX how many concurrent connections
    each worker process can handle, which is vital for handling multiple requests
    simultaneously.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worker_connections`：此指令告诉 NGINX 每个工作进程能够处理多少并发连接，这对于同时处理多个请求至关重要。'
- en: '`limit_req_zone $binary_remote_addr zone=limitlab:10m rate=1r/s`: This directive
    is used to define a rate-limiting property that limits the rate of requests that
    a client can make to a server. The `$binary_remote_addr` portion represents the
    client’s IP address in compact binary format. This applies the same rule for every
    single IP address that hits NGINX. We are allocating 10 MB of RAM for the `limitlab`
    shared memory zone we created and specifying a rate of one request per second.
    Further options are configured on the `limit_req` portion.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit_req_zone $binary_remote_addr zone=limitlab:10m rate=1r/s`：此指令用于定义一个限流属性，限制客户端向服务器发起请求的速率。`$binary_remote_addr`部分表示客户端的IP地址，以紧凑的二进制格式呈现。此规则适用于每一个访问NGINX的IP地址。我们为创建的`limitlab`共享内存区分配了10
    MB的RAM，并指定了每秒一个请求的速率。进一步的选项在`limit_req`部分进行配置。'
- en: '`include mime.types` and `default_type application/json` ensure that NGINX
    handles MIME types appropriately.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include mime.types` 和 `default_type application/json` 确保NGINX适当地处理MIME类型。'
- en: '`limit_req zone=limitlab burst=5`: On the previously created `limitlab` zone,
    establish that a burst of up to five requests is processed without limiting, helping
    to accommodate scenarios where a client might occasionally make several requests
    in quick succession.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit_req zone=limitlab burst=5`：在之前创建的`limitlab`区上，设定最多处理五个请求的突发流量，不做限制，以适应客户端偶尔快速连续发起多个请求的场景。'
- en: '`proxy_pass http://localhost:3000` and `proxy_http_version 1.1`: Define the
    HTTP version to use and the backend’s address. In our case, the Mockoon API server.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_pass http://localhost:3000` 和 `proxy_http_version 1.1`：定义要使用的HTTP版本以及后端的地址。在我们的例子中是Mockoon
    API服务器。'
- en: '`proxy_set_header Upgrade $http_upgrade`: This header is crucial for supporting
    WebSocket connections. The `Upgrade` header in HTTP requests is used to ask the
    server to switch protocols (e.g., from `HTTP/1.1` to `WebSocket`). It’s here for
    educational purposes only. Not applicable to our case.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header Upgrade $http_upgrade`：此头对于支持WebSocket连接至关重要。HTTP请求中的`Upgrade`头用于请求服务器切换协议（例如，从`HTTP/1.1`切换到`WebSocket`）。此项仅为教育用途，不适用于我们的案例。'
- en: '`proxy_set_header Connection ''upgrade''`: This header is used to control whether
    the network connection stays open after the current transaction finishes. Setting
    this to `''upgrade''` complements the `Upgrade` header and is used primarily for
    WebSocket or other protocol upgrades. Educational only.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header Connection ''upgrade''`：此头用于控制当前事务结束后，网络连接是否保持开启。将此设置为`''upgrade''`与`Upgrade`头配合使用，主要用于WebSocket或其他协议的升级。仅用于教育用途。'
- en: '`proxy_set_header Host $host`: This header sets the `Host` header of the forwarded
    request to the value of the host of the incoming request to the NGINX server.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header Host $host`：此头将转发请求的`Host`头设置为NGINX服务器接收到的请求的主机值。'
- en: '`proxy_set_header X-Real-IP $remote_addr`: This custom header is commonly used
    to pass the original client’s IP address to the backend server.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header X-Real-IP $remote_addr`：此自定义头通常用于将原始客户端的IP地址传递给后端服务器。'
- en: '`proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for`: This header
    is used to append the client’s IP address to any existing `X-Forwarded-For` header
    received by NGINX. If there is no such header, NGINX will create it.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for`：此头用于将客户端的IP地址追加到NGINX接收到的任何现有的`X-Forwarded-For`头。如果没有此头，NGINX将创建一个。'
- en: '`proxy_set_header X-Forwarded-Proto $scheme`: This header is used to inform
    the backend server about the protocol the client used to connect to the proxy.
    `$scheme` will contain `http` or `https`, depending on the protocol.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_set_header X-Forwarded-Proto $scheme`：此头用于通知后端服务器客户端用来连接代理的协议。`$scheme`将包含`http`或`https`，具体取决于协议。'
- en: '`proxy_cache_bypass $http_upgrade`: This directive is used to bypass the cache
    if the `Upgrade` header is present in the client’s request. This is typically
    used in scenarios where caching responses may not be desirable, such as when initiating
    WebSocket connections. This is for educational purposes only too.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_cache_bypass $http_upgrade`：此指令用于在客户端请求中包含`Upgrade`头时绕过缓存。这通常用于不希望缓存响应的场景，例如在初始化WebSocket连接时。此项也仅为教育用途。'
- en: 'I put a link in the *Further reading* section with more information about how
    to configure NGINX to work as a remote proxy. Restart the service if it is already
    running. By default, all accesses are logged to `/var/log/nginx/access.log`, and
    all errors are recorded on `/var/log/nginx/error.log`. Launch Wireshark too so
    you can inspect whether something different goes on. We’ll start with our friend,
    `ab`. We’ll suppress the `:3000` portion since we are now sending requests to
    NGINX, not directly to Mockoon. Parts of the output were omitted for brevity:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*进一步阅读*部分中放了一个链接，里面有关于如何配置NGINX作为远程代理的更多信息。如果它已经在运行，请重启服务。默认情况下，所有访问都记录在`/var/log/nginx/access.log`中，所有错误则记录在`/var/log/nginx/error.log`中。也启动Wireshark，以便你检查是否发生了不同的情况。我们将从我们的朋友`ab`开始。由于我们现在是向NGINX发送请求，而不是直接向Mockoon发送，因此我们将省略`:3000`部分。为了简洁起见，部分输出被省略：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Very interesting! Compare this with the previous results we obtained when sending
    packets directly to Mockoon. Observe that 94 out of 100 packets failed to be received!
    This means that 94% of the traffic was filtered by NGINX. Considering that we
    allowed a burst of five requests per second, this signifies that `ab` successfully
    received one of its bursts and one packet that was sent all alone. When you go
    to Wireshark to inspect the traffic, we will find some packets being sent with
    a 503 error code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有趣！将此与我们直接发送数据包到Mockoon时获得的先前结果进行比较。观察到100个数据包中有94个未能接收！这意味着94%的流量被NGINX过滤掉了。考虑到我们允许每秒5个请求的突发流量，这表示`ab`成功接收了它的一次突发流量和一个单独发送的数据包。当你使用Wireshark检查流量时，我们会发现一些数据包带有503错误代码：
- en: '![Figure 7.14 – NGINX filtering the excessive requests that would go to Mockoon](img/B19657_figure_07.14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – NGINX过滤掉过多的请求，这些请求原本会发送到Mockoon](img/B19657_figure_07.14.jpg)'
- en: Figure 7.14 – NGINX filtering the excessive requests that would go to Mockoon
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – NGINX过滤掉过多的请求，这些请求原本会发送到Mockoon
- en: 'This happened with our basic test of 100 connections, with 10 of them simultaneously.
    In parallel, I was also monitoring the amount of allocated RAM and CPU occupation.
    There was no harm to any of them. Let’s repeat the most aggressive test that we
    ran with `ab` to see whether something changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在我们基本的100连接测试中，其中10个是同时进行的。与此同时，我也在监控已分配的RAM和CPU占用情况。它们没有受到任何影响。让我们重复之前使用`ab`进行的最激进的测试，看看是否有变化：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is the same number of blocked connections. Also, we notice a huge increase
    in the processing time for most of the requests (from 1 ms to around 60 ms on
    average). An analog output can be verified on Wireshark as well. Check `/var/log/nginx/error.log`
    and you’ll find some lines like this one:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 被阻止的连接数量是相同的。此外，我们还注意到大多数请求的处理时间大幅增加（从1毫秒增加到平均约60毫秒）。在Wireshark中也可以验证类似的输出。检查`/var/log/nginx/error.log`，你会发现类似这样的几行：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Well, we can attest that our rate-limiting mechanism is doing its job. Let’s
    see how we can discover this when such a thing is in place. For this, we apply
    Burp Suite. Before starting it, double-check that you don’t have any other service
    running on its proxy service port (by default, `8080`). With Burp on, switch to
    the **Proxy** tab and then to the **Proxy Settings** sub-tab to confirm it’s on.
    Then, go to the **Intruder** tab and click on the **Intercept is on** button to
    turn it off. We don’t want to have to click on **Intercept** for every single
    request we will send.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以确认我们的速率限制机制正在发挥作用。让我们看看如何在启用这种机制时发现这一点。为此，我们使用Burp Suite。在启动之前，请再次确认你没有在其代理服务端口（默认情况下为`8080`）上运行其他服务。启动Burp后，切换到**Proxy**标签页，然后切换到**Proxy
    Settings**子标签页，确认它已启用。接着，转到**Intruder**标签页，点击**Intercept is on**按钮将其关闭。我们不希望每发送一个请求时都点击**Intercept**。
- en: 'Now, on the `http://localhost/users` on this internal browser. You will receive
    the expected JSON structure with random usernames and IDs. You are good to close
    this browser. Now, back to Burp’s main screen, go to the **Proxy** tab, and click
    on the **HTTP history** sub-tab. You will see the request there:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个内部浏览器的`http://localhost/users`页面，你将收到带有随机用户名和ID的预期JSON结构。你可以关闭这个浏览器了。接下来，回到Burp的主界面，进入**Proxy**标签页，点击**HTTP
    history**子标签页。你将在那里看到该请求：
- en: '![Figure 7.15 – Burp capturing the request sent to Mockoon and its response](img/B19657_figure_07.15.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – Burp捕获发送到Mockoon的请求及其响应](img/B19657_figure_07.15.jpg)'
- en: Figure 7.15 – Burp capturing the request sent to Mockoon and its response
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – Burp捕获发送到Mockoon的请求及其响应
- en: 'Right-click on this request and select **Send to Intruder**. You’ll see that
    the **Intruder** tab will become orange. Click there. The first screen that shows
    up is named **Positions**. We won’t use it since we don’t need to change anything
    on the request. We are not fuzzing anything this time. We just need Burp to repeat
    it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击这个请求并选择 **发送到 Intruder**。你会看到 **Intruder** 选项卡变成橙色。点击那里。首先显示的界面名为 **Positions**。我们不需要使用它，因为我们不需要更改请求内容。我们这次不进行模糊测试（fuzzing）。我们只需要
    Burp 重复请求：
- en: '![Figure 7.16 – The original request captured by Burp’s Intruder](img/B19657_figure_07.16.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – Burp 的 Intruder 捕获的原始请求](img/B19657_figure_07.16.jpg)'
- en: Figure 7.16 – The original request captured by Burp’s Intruder
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – Burp 的 Intruder 捕获的原始请求
- en: You are good to use any attack type, although, for this test, either the Sniper
    or Battering ram attack would suffice. With multiple payloads, the Pitchfork or
    Cluster Bomb methods would be more appropriate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何攻击类型，不过对于这个测试，使用狙击手攻击（Sniper）或撞锤攻击（Battering ram）都足够了。如果使用多个有效载荷，Pitchfork
    或 Cluster Bomb 方法会更合适。
- en: Next, switch to the `30` in the **Generate payloads** textbox. In the following
    figure, you can see the parameters changed in the **Payloads** section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到 **生成有效载荷** 文本框中的 `30`。在下图中，你可以看到 **Payloads** 部分的参数已经发生变化。
- en: '![Figure 7.17 – Configuring Intruder to send 30 equal packets](img/B19657_figure_07.17.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 配置 Intruder 发送 30 个相同的数据包](img/B19657_figure_07.17.jpg)'
- en: Figure 7.17 – Configuring Intruder to send 30 equal packets
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 配置 Intruder 发送 30 个相同的数据包
- en: 'Now, navigate to the `10`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到 `10`：
- en: '![Figure 7.18 – Creating a resource pool and defining the number of concurrent
    requests](img/B19657_figure_07.18.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 创建资源池并定义并发请求数量](img/B19657_figure_07.18.jpg)'
- en: Figure 7.18 – Creating a resource pool and defining the number of concurrent
    requests
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 创建资源池并定义并发请求数量
- en: Finally, click on the **Start attack** button. This will open the attack window
    (*Figure 7**.19*). This will make Intruder send repeated requests to NGINX. You
    will be watching them pop up on this window until request number 30\. Some requests
    might arrive earlier than others, outside of the original order. That’s expected
    since NGINX is imposing limitations on them. As a side note, the delay while receiving
    packets is one variable we need to consider. This may mean a rate-limiting control
    is in place. You can see one of the successful requests in *Figure 7**.19*. Pay
    attention to the date.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击 **开始攻击** 按钮。这将打开攻击窗口（*图 7.19*）。这会使 Intruder 向 NGINX 发送重复的请求。你会看到它们在这个窗口中不断出现，直到第
    30 个请求。一些请求可能比其他请求更早到达，顺序也可能会乱。这是预期的，因为 NGINX 对它们施加了限制。顺便提一下，接收数据包时的延迟是我们需要考虑的一个变量。这可能意味着存在速率限制控制。你可以在
    *图 7.19* 中看到一个成功的请求。注意查看日期。
- en: '![Figure 7.19 – A successful request captured by Intruder](img/B19657_figure_07.19.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 由 Intruder 捕获的成功请求](img/B19657_figure_07.19.jpg)'
- en: Figure 7.19 – A successful request captured by Intruder
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 由 Intruder 捕获的成功请求
- en: 'Let’s compare it with the request right after it (*Figure 7**.20*), which failed
    (a 503 response code). You can see that the failed request was sent four seconds
    before the successful one, showing that a possible rate-limiting mechanism is
    activated:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与紧随其后的请求进行比较（*图 7.20*），这是一个失败的请求（503 响应代码）。你可以看到，失败的请求在成功请求之前四秒发送，这表明可能启用了速率限制机制：
- en: '![Figure 7.20 – A failed request that was received before the successful one](img/B19657_figure_07.20.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 在成功请求之前收到的失败请求](img/B19657_figure_07.20.jpg)'
- en: Figure 7.20 – A failed request that was received before the successful one
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 在成功请求之前收到的失败请求
- en: Other indications that such types of controls are protecting the API are the
    presence of response codes such as 429, which means “too many requests” or the
    presence of the `Retry-After` header on the responses. Now that we have identified
    the possibility of being throttled while sending requests to API endpoints, we
    need to learn how we can bypass such protection mechanisms. That’s exactly what
    we will cover in the next section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 API 的其他迹象包括响应代码如 429，表示“请求过多”或响应中包含 `Retry-After` 头部。现在我们已经识别出在向 API 端点发送请求时可能会受到限流保护，接下来我们需要学习如何绕过这些保护机制。正是这一点将是下一节的内容。
- en: Circumventing rate limitations
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过速率限制
- en: When NGINX acts as a vigilant guard, rate limiting becomes the key security
    measure controlling traffic flow and preventing malicious activities. NGINX has
    a set of rate-limiting configurations to restrict the number of requests an API
    client can send within a specific amount of time. To navigate these restrictions
    effectively, we must first become familiar with the specific rate-limiting mechanisms
    employed. This involves deciphering server responses, looking for clues such as
    `Retry-After` headers or specific error codes (e.g., 429 Too Many Requests) that
    signal the presence and details of rate limiting as we covered before.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当 NGINX 充当严密守卫时，速率限制成为控制流量并防止恶意活动的关键安全措施。NGINX 有一套速率限制配置，用于限制 API 客户端在特定时间内能够发送的请求数量。为了有效绕过这些限制，我们首先需要熟悉所使用的具体速率限制机制。这包括解读服务器响应，寻找诸如
    `Retry-After` 头部或特定错误码（例如，429 Too Many Requests）等线索，这些都能表明速率限制的存在及其细节，正如我们之前所讨论的那样。
- en: The first step to bypassing rate limitations is uncovering what triggers them.
    Common culprits include the client’s IP address, user session, or API key. By
    strategically varying these factors, we can pinpoint how the rate limit is applied.
    Tools such as Burp Suite become our allies, allowing us to manipulate request
    headers and simulate requests originating from different IPs or user sessions.
    Analyzing how the server’s response changes with different inputs can offer valuable
    hints about the underlying rate-limiting logic. In our case, we know NGINX is
    imposing a rate based on the source IP addresses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过速率限制的第一步是揭示触发限制的原因。常见的罪魁祸首包括客户端的 IP 地址、用户会话或 API 密钥。通过有策略地改变这些因素，我们可以找出速率限制的应用方式。像
    Burp Suite 这样的工具成为我们的盟友，允许我们操控请求头部并模拟来自不同 IP 或用户会话的请求。分析服务器响应如何随不同输入变化，可以提供有关底层速率限制逻辑的有价值线索。在我们的案例中，我们知道
    NGINX 基于源 IP 地址实施了速率限制。
- en: To bypass such a restriction, we commonly apply a rotation of the source IP
    address. By constantly changing the IP address used to send requests, we can evade
    restrictions tied to a specific IP. Tools such as VPNs, public proxy servers,
    or anonymizing networks such as Tor can be employed for this purpose. Furthermore,
    automated scripts or specialized tools can be used to dynamically route requests
    through a pool of different IP addresses, further complicating detection. That’s
    exactly what we’re going to do here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这种限制，我们通常会应用源 IP 地址的轮换。通过不断改变用于发送请求的 IP 地址，我们可以避开与特定 IP 绑定的限制。像 VPN、公共代理服务器或像
    Tor 这样的匿名网络都可以用于此目的。此外，还可以使用自动化脚本或专门的工具，通过不同的 IP 地址池动态路由请求，进一步增加检测的难度。这正是我们在这里要做的。
- en: If the rate limit hinges on session identifiers or specific user-agent strings,
    altering these elements can potentially reset the rate limit counters. Burp Suite
    empowers us to manipulate cookies (which might store session data) and the `User-Agent`
    header within requests. Scripting custom headers for each request or leveraging
    browser automation tools that randomize user-agent strings can effectively bypass
    restrictions associated with user sessions or device types.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速率限制依赖于会话标识符或特定的用户代理字符串，修改这些元素可能会重置速率限制计数器。Burp Suite 使我们能够操控 cookies（可能存储会话数据）和请求中的`User-Agent`头部。为每个请求编写自定义头部，或者利用浏览器自动化工具随机化用户代理字符串，可以有效绕过与用户会话或设备类型相关的限制。
- en: Another way to successfully perpetrate rate-limiting bypassing is by splitting
    the requests among multiple servers or devices. If NGINX tracks the number of
    requests per IP address, utilizing multiple servers, each with a unique IP, to
    send requests can help distribute the load and lessen the risk of hitting rate
    limits. While this strategy involves complex coordination, it can be highly effective,
    especially when combined with IP rotation techniques. In real-world attacks, **botnets**
    are usually applied for this purpose. It’s a matter of sending a command to them
    and then the attack starts at the same time from multiple different geographic
    locations. If you don’t know much about botnets, I shared a reference in the *Further
    reading* section. Look when you can. It’s unmissable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种成功规避速率限制的方法是将请求分配到多个服务器或设备上。如果NGINX按IP地址跟踪请求数量，利用多个具有唯一IP的服务器发送请求可以帮助分散负载，并减少触发速率限制的风险。虽然这个策略涉及复杂的协调，但它可能非常有效，尤其是在结合IP轮换技术时。在现实攻击中，**僵尸网络**通常用于此目的。只需向它们发送一个命令，然后攻击就会从多个不同的地理位置同时开始。如果你对僵尸网络不太了解，我在*进一步阅读*部分提供了参考，找时间看看。这是不可错过的。
- en: Carefully examining how NGINX responds to requests exceeding rate limits can
    provide valuable insights into potential circumvention strategies. For instance,
    if the response headers suggest NGINX utilizes a fixed window counter for rate
    limiting, strategically sending requests just after the window resets can maximize
    request capacity. Automated tools can be used to monitor the timing and patterns
    of rate limits, adjusting request timing accordingly to exploit this window.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查NGINX如何响应超过速率限制的请求，可以提供有关潜在规避策略的有价值的见解。例如，如果响应头表明NGINX使用固定窗口计数器进行速率限制，那么在窗口重置后策略性地发送请求可以最大化请求容量。可以使用自动化工具来监控速率限制的时机和模式，并根据需要调整请求时机，以利用这个窗口。
- en: 'Time for action! Consider the following code. By switching the source IP address,
    we are sending different delayed requests to the `/``users` route:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 行动时刻到！考虑以下代码。通过切换源IP地址，我们向`/users`路由发送不同的延迟请求：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code simulates five different users. There’s a 1-second delay between
    each request and, when it fails, we add a 60-second (a.k.a. 1 minute) delay. We
    can adjust both timers, so they stay at the edge of the NGINX’s control. You can
    see that we are dispatching a total of 50 (10 times 5) requests in total, which
    would hit NGINX’s protection 9 times (remember that it allows a maximum burst
    of 5 requests). The key point here is the delay we are putting between every request.
    After running this code, you will receive successful outputs for all the requests
    (part of the output omitted for brevity):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码模拟了五个不同的用户。每个请求之间有1秒的延迟，当请求失败时，我们添加60秒（即1分钟）的延迟。我们可以调整这两个计时器，使它们保持在NGINX控制的边缘。你可以看到我们总共发出了50个请求（10次乘以5），这会触发NGINX的保护9次（记住，它允许最多5个请求的突发）。这里的关键是我们在每个请求之间设置的延迟。运行此代码后，所有请求都会收到成功的响应（为简洁起见，部分输出省略）：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: NGINX’s error log has no new lines since all requests were sent and received.
    We can confirm that by checking Mockoon’s logs as well. Hence, we can conclude
    that by sourcing the requests from different IP addresses with small delays between
    them and bypassing the rate-limiting imposed by NGINX. As a future exercise for
    your environment, tweak the timers and the `nginx.conf` file to see the behavior
    with different values. Don’t forget to restart the service to apply the changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX的错误日志没有新行，因为所有请求都已发送并接收。我们还可以通过检查Mockoon的日志来确认这一点。因此，我们可以得出结论，通过从不同的IP地址发起请求，并在请求之间设置小的延迟，可以绕过NGINX施加的速率限制。作为你环境中的未来练习，可以调整计时器和`nginx.conf`文件，看看不同值下的行为。别忘了重新启动服务以应用更改。
- en: If an API provides multiple endpoints that can achieve similar results, alternating
    between them can help avoid exceeding rate limits on any single endpoint. This
    strategy depends on the API’s design, but it can be effective if rate limits are
    configured on a per-endpoint basis.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个API提供多个端点可以实现相似的结果，交替使用这些端点可以帮助避免在单个端点上超过速率限制。这个策略取决于API的设计，但如果速率限制是按端点配置的，那么它可能非常有效。
- en: Sometimes, simply modifying how requests are made can be enough to evade rate
    limiting. This could involve batching several operations into a single request
    or spreading out requests that typically occur in rapid succession over a longer
    duration. APIs that offer endpoints capable of fetching or updating numerous resources
    in a single request can be particularly beneficial in such scenarios.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，简单地修改请求方式就足以避开速率限制。这可能包括将多个操作批量成一个请求，或者将通常会迅速连续发生的请求分散到更长的时间段内。提供能够在单次请求中获取或更新多个资源的
    API，在这种情况下特别有用。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this more practical chapter, we had good coverage on DoS and DDoS, which
    can be used to discover vulnerabilities on target API endpoints. We then moved
    forward and learned how we detect when rate-limiting controls are in place (they
    can filter DoS attacks). We finished the chapter by crafting some Python code
    that, by imposing delays between requests and changing the source IP addresses,
    successfully bypassed the rate-limiting mechanism that was previously blocking
    them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一更具实践性的章节中，我们深入探讨了 DoS 和 DDoS 攻击，这些技术可以用来发现目标 API 端点的漏洞。接着，我们学习了如何检测速率限制控制是否已到位（这些控制能够过滤
    DoS 攻击）。最后，我们通过编写 Python 代码，成功绕过了之前阻止我们的速率限制机制，这一过程通过在请求之间添加延时并更换源 IP 地址完成。
- en: In the next chapter, we will start a new part where we will discover advanced
    topics on pentesting APIs. We begin by understanding how successful invasions
    can cause data exposure and sensitive information leakage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始新的内容，探索关于渗透测试 API 的高级话题。我们将从理解成功的入侵如何导致数据暴露和敏感信息泄露开始。
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The attack against Google services: [https://cloud.google.com/blog/products/identity-security/identifying-and-protecting-against-the-largest-ddos-attacks](https://cloud.google.com/blog/products/identity-security/identifying-and-protecting-against-the-largest-ddos-attacks)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '针对 Google 服务的攻击: [https://cloud.google.com/blog/products/identity-security/identifying-and-protecting-against-the-largest-ddos-attacks](https://cloud.google.com/blog/products/identity-security/identifying-and-protecting-against-the-largest-ddos-attacks)'
- en: 'AWS suffering a giant DDoS attack: [https://aws-shield-tlr.s3.amazonaws.com/2020-Q1_AWS_Shield_TLR.pdf](https://aws-shield-tlr.s3.amazonaws.com/2020-Q1_AWS_Shield_TLR.pdf)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AWS 遭遇巨型 DDoS 攻击: [https://aws-shield-tlr.s3.amazonaws.com/2020-Q1_AWS_Shield_TLR.pdf](https://aws-shield-tlr.s3.amazonaws.com/2020-Q1_AWS_Shield_TLR.pdf)'
- en: 'The Memcached vulnerability that affected GitHub with DDoS: [https://github.blog/2018-03-01-ddos-incident-report/](https://github.blog/2018-03-01-ddos-incident-report/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '影响 GitHub 的 Memcached 漏洞与 DDoS 攻击: [https://github.blog/2018-03-01-ddos-incident-report/](https://github.blog/2018-03-01-ddos-incident-report/)'
- en: 'Create Mock APIs with Mockoon: [https://mockoon.com/](https://mockoon.com/)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 Mockoon 创建模拟 API: [https://mockoon.com/](https://mockoon.com/)'
- en: 'ApacheBench, a website/API performance tool: [https://httpd.apache.org/docs/current/programs/ab.html](https://httpd.apache.org/docs/current/programs/ab.html)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ApacheBench，网站/API 性能测试工具: [https://httpd.apache.org/docs/current/programs/ab.html](https://httpd.apache.org/docs/current/programs/ab.html)'
- en: 'The Scapy Python library: [https://pypi.org/project/scapy/](https://pypi.org/project/scapy/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Scapy Python 库: [https://pypi.org/project/scapy/](https://pypi.org/project/scapy/)'
- en: '`hping3`: [https://linux.die.net/man/8/hping3](https://linux.die.net/man/8/hping3)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hping3`: [https://linux.die.net/man/8/hping3](https://linux.die.net/man/8/hping3)'
- en: '*What is API* *Throttling?*: [https://www.tibco.com/glossary/what-is-api-throttling](https://www.tibco.com/glossary/what-is-api-throttling)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是 API* *限流？*： [https://www.tibco.com/glossary/what-is-api-throttling](https://www.tibco.com/glossary/what-is-api-throttling)'
- en: 'NGINX as a reverse proxy: [https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/](https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NGINX 作为反向代理: [https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/](https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/)'
- en: 'Envoy, another open-source proxy offering: [https://www.envoyproxy.io/](https://www.envoyproxy.io/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Envoy，另一个开源代理服务： [https://www.envoyproxy.io/](https://www.envoyproxy.io/)
- en: '*Study of Botnets and their Threats to Internet* *Security*: [https://www.researchgate.net/publication/227859109_Study_of_Botnets_and_their_threats_to_Internet_Security](https://www.researchgate.net/publication/227859109_Study_of_Botnets_and_their_threats_to_Internet_Security)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*僵尸网络及其对互联网* *安全的威胁*： [https://www.researchgate.net/publication/227859109_Study_of_Botnets_and_their_threats_to_Internet_Security](https://www.researchgate.net/publication/227859109_Study_of_Botnets_and_their_threats_to_Internet_Security)'
- en: 'More information on DoS and DDoS attacks: [https://subscription.packtpub.com/book/programming/9781838645649/8/ch08lvl1sec02/denial-of-service-dos-and-distributed-denial-of-service-ddos-attacks](https://subscription.packtpub.com/book/programming/9781838645649/8/ch08lvl1sec02/denial-of-service-dos-and-distributed-denial-of-service-ddos-attacks)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于DoS和DDoS攻击的信息：[https://subscription.packtpub.com/book/programming/9781838645649/8/ch08lvl1sec02/denial-of-service-dos-and-distributed-denial-of-service-ddos-attacks](https://subscription.packtpub.com/book/programming/9781838645649/8/ch08lvl1sec02/denial-of-service-dos-and-distributed-denial-of-service-ddos-attacks)
- en: 'Building RESTful Python web services, which various good tips on creating APIs,
    including imposing throttling to requests: [https://www.packtpub.com/en-th/product/building-restful-python-web-services-9781786462251](https://www.packtpub.com/en-th/product/building-restful-python-web-services-9781786462251)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建RESTful Python Web服务，提供了关于创建API的各种有用技巧，包括对请求实施限流：[https://www.packtpub.com/en-th/product/building-restful-python-web-services-9781786462251](https://www.packtpub.com/en-th/product/building-restful-python-web-services-9781786462251)
- en: 'Part 4: API Advanced Topics'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：API高级主题
- en: You can achieve good attack rates with the topics covered in *Part 3*. They
    are foundational but still very effective. However, there are some situations
    in which you have to make use of something more sophisticated. We are talking
    about advanced attack techniques, which are covered in this part. You will be
    presented with ways in which to detect data exposure and leakage. You will also
    learn what API business logic is and how you can leverage bad implementations
    of it to gain unauthorized access and do unauthorized actions. As was the case
    with *Part 3*, you will be presented with some recommendations on how to avoid
    problems with this critical part of any API.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*第3部分*中涉及的主题来实现较好的攻击效果。它们是基础性的，但依然非常有效。然而，有些情况下你需要使用更复杂的技术。我们这里谈论的是高级攻击技巧，这些将在本部分中进行讲解。你将了解如何检测数据曝光和泄露。你还将学习什么是API业务逻辑，以及如何利用其错误实现来获得未授权的访问和执行未授权的操作。与*第3部分*类似，本部分也会给出一些建议，帮助你避免出现API中这一关键部分的问题。
- en: 'This section contains the following chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 8*](B19657_08.xhtml#_idTextAnchor131), *Data Exposure and Sensitive
    Information Leakage*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19657_08.xhtml#_idTextAnchor131)，*数据曝光和敏感信息泄露*'
- en: '[*Chapter 9*](B19657_09.xhtml#_idTextAnchor141), *API Abuse and Business Logic
    Testing*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19657_09.xhtml#_idTextAnchor141)，*API滥用与业务逻辑测试*'
