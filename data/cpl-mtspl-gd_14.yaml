- en: Porting Exploits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植利用
- en: 'In the previous chapter, we discussed how to write exploits in Metasploit.
    However, we do not need to create an exploit for particular software in cases
    where a public exploit is already available. A publicly available exploit might
    be in a different programming language such as Perl, Python, C, or others. Let''s
    now discover some strategies for porting exploits to the Metasploit framework
    in a variety of different programming languages. This mechanism enables us to
    transform existing exploits into Metasploit-compatible exploits, thus saving time
    and giving us the ability to switch payloads on the fly. By the end of this chapter,
    we will have learned about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了如何在Metasploit中编写利用。然而，在已经有公开利用的情况下，我们不需要为特定软件创建利用。公开可用的利用可能是Perl、Python、C或其他不同编程语言中的。现在让我们发现一些将利用移植到Metasploit框架中的策略。这种机制使我们能够将现有利用转换为与Metasploit兼容的利用，从而节省时间并使我们能够随时切换有效载荷。在本章结束时，我们将了解以下主题：
- en: Porting exploits from various programming languages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种编程语言移植利用
- en: Discovering the essentials from standalone exploits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从独立利用中发现基本要素
- en: Creating Metasploit modules from existing standalone scanners/tool scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有独立扫描器/工具脚本创建Metasploit模块
- en: Porting scripts into the Metasploit framework is an easy job if we can figure
    out which essentials from the existing exploits can be used in Metasploit.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够找出现有利用中哪些基本要素可以在Metasploit中使用，那么将脚本移植到Metasploit框架中就是一项简单的工作。
- en: This idea of porting exploits into Metasploit saves time by making standalone
    scripts workable on a wide range of networks rather than a single system. Also,
    it makes a penetration test more organized due to every exploit being accessible
    from Metasploit. Let's understand how we can achieve portability using Metasploit
    in the upcoming sections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将利用移植到Metasploit的这一想法通过使独立脚本能够在广泛的网络上运行而不仅仅是单个系统上，从而节省时间。此外，由于每个利用都可以从Metasploit中访问，这使得渗透测试更有组织性。让我们了解如何在即将到来的章节中使用Metasploit实现可移植性。
- en: Importing a stack-based buffer overflow exploit
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入基于堆栈的缓冲区溢出利用
- en: 'In the upcoming example, we will see how we can import an exploit written in
    Python to Metasploit. The publicly available exploit can be downloaded from: [https://www.exploit-db.com/exploits/31255/](https://www.exploit-db.com/exploits/31255/).
    Let''s analyze the exploit as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的示例中，我们将看到如何将用Python编写的利用导入Metasploit。公开可用的利用可以从以下网址下载：[https://www.exploit-db.com/exploits/31255/](https://www.exploit-db.com/exploits/31255/)。让我们按照以下方式分析利用：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This straightforward exploit logs into the PCMAN FTP 2.0 software on port `21`
    using anonymous credentials and exploits the software using the `CWD` command.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的利用通过匿名凭据登录到端口`21`上的PCMAN FTP 2.0软件，并使用`CWD`命令利用软件。
- en: 'The entire process of the previous exploit can be broken down into the following
    set of points:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个利用的整个过程可以分解为以下一系列要点：
- en: Store username, password, and host in `fuser`, `pass`, and `host` variables.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户名、密码和主机存储在`fuser`、`pass`和`host`变量中。
- en: Assign the `junk` variable with `2008` A characters. Here, `2008` is the offset
    to overwrite EIP.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`junk`变量分配为`2008`个A字符。这里，`2008`是覆盖EIP的偏移量。
- en: Assign the JMP ESP address to the `espaddress` variable. Here, `espaddress 0x71ab9372`
    is the target return address.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JMP ESP地址分配给`espaddress`变量。这里，`espaddress 0x71ab9372`是目标返回地址。
- en: Store 10 NOPs in the `nops` variable.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`nops`变量中存储10个NOPs。
- en: Store the payload for executing the calculator in the `shellcode` variable.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行计算器的有效载荷存储在`shellcode`变量中。
- en: Concatenate `junk`, `espaddress`, `nops`, and `shellcode` and store them in
    the `sploit` variable.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`junk`、`espaddress`、`nops`和`shellcode`连接起来，并将它们存储在`sploit`变量中。
- en: Set up a socket using `s.socket(s.AF_INET,s.SOCK_STREAM)` and connect to the
    host using `connect((host,21))` on port 21.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`s.socket(s.AF_INET,s.SOCK_STREAM)`建立套接字，并使用`connect((host,21))`连接到端口21的主机。
- en: Supply the `fuser` and `fpass` using `USER` and `PASS` to log in to the target
    successfully.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`USER`和`PASS`提供`fuser`和`fpass`以成功登录到目标。
- en: Issue the `CWD` command followed by the `sploit` variable. This will cause the
    EIP overwrite at an offset of `2008` and pop up the calculator application.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出`CWD`命令，然后跟上`sploit`变量。这将导致在偏移量为`2008`处覆盖EIP，并弹出计算器应用程序。
- en: 'Let''s try executing the exploit and analyze the results as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试执行利用并分析结果如下：
- en: '![](img/2167f364-4221-4433-8a30-d9a6e721d154.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2167f364-4221-4433-8a30-d9a6e721d154.png)'
- en: The original exploit takes the username, password, and host from the command
    line. However, we modified the mechanism with fixed hardcoded values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 原始利用从命令行获取用户名、密码和主机。然而，我们修改了机制，使用了固定的硬编码值。
- en: 'As soon as we executed the exploit, the following screen showed up:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了利用，就会出现以下屏幕：
- en: '![](img/13f57961-9c6e-4e48-a1ea-33d9ee9819cc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13f57961-9c6e-4e48-a1ea-33d9ee9819cc.png)'
- en: We can see that the calculator application has popped up, which states that
    the exploit is working correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到计算器应用程序已经弹出，这表明利用正在正确工作。
- en: Gathering the essentials
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集基本要素
- en: 'Let''s find out what essential values we need to take from the preceding exploit
    to generate an equivalent module in Metasploit from the following table:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出从前面的利用中需要获取哪些基本值，以便从下表中生成Metasploit中等效模块：
- en: '| **Serial Number** | **Variables** | **Values** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **序列号** | **变量** | **值** |'
- en: '| 1 | Offset value | `2008` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 偏移值 | `2008` |'
- en: '| 2 | Target return/jump address/value found in executable modules using JMP
    ESP search | `0x71AB9372` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 使用JMP ESP搜索在可执行模块中找到的目标返回/跳转地址/值 | `0x71AB9372` |'
- en: '| 3 | Target port | `21` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 目标端口 | `21` |'
- en: '| 4 | Number of leading NOP bytes to the shellcode to remove irregularities
    | `10` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 用于删除不规则性的前导NOP字节到shellcode的数量 | `10` |'
- en: '| 5 | Logic | The `CWD` command followed by junk data of 2008 bytes, followed
    by EIP, NOPs, and shellcode |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 逻辑 | `CWD`命令后跟着2008字节的垃圾数据，然后是EIP、NOPs和shellcode |'
- en: We have all the information required to build a Metasploit module. In the next
    section, we will see how Metasploit aids FTP processes and how easy it is to create
    an exploit module in Metasploit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有构建Metasploit模块所需的所有信息。在下一节中，我们将看到Metasploit如何辅助FTP进程以及在Metasploit中创建利用模块有多么容易。
- en: Generating a Metasploit module
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个Metasploit模块
- en: The best way to start building a Metasploit module is to copy an existing similar
    module and make changes to it. However, a `Mona.py` script can also generate Metasploit-specific
    modules on the fly. We will see how to generate quick exploits using `Mona.py`
    script in the latter sections of the book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Metasploit模块的最佳方法是复制现有的类似模块并对其进行更改。但是，`Mona.py`脚本也可以动态生成特定于Metasploit的模块。我们将在本书的后面部分看到如何使用`Mona.py`脚本生成快速利用。
- en: 'Let''s now see the equivalent code of the exploit in Metasploit as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下Metasploit中利用的等效代码：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous chapter, we worked on many exploit modules. This exploit is
    no different. We started by including all the required libraries and the `ftp.rb`
    library from the `/lib/msf/core/exploit` directory. Next, we assigned all the
    necessary information in the `initialize` section. Gathering the essentials from
    the exploit, we assigned `Ret` with the return address and set the `Offset` as
    `2008`. We also declared the value for the `FTPPASS` option as `''anonymous''`.
    Let''s see the next section of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们处理了许多利用模块。这个利用也不例外。我们首先包含了所有必需的库和`/lib/msf/core/exploit`目录中的`ftp.rb`库。接下来，在`initialize`部分中分配了所有必要的信息。从利用中收集必要的信息后，我们将`Ret`分配为返回地址，并将`Offset`设置为`2008`。我们还将`FTPPASS`选项的值声明为`'anonymous'`。让我们看看下一节代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `connect_login` method will connect to the target and try performing a login
    to the software using the anonymous credentials we supplied. But wait! When did
    we supply the credentials? The `FTPUSER` and `FTPPASS` options for the module
    are enabled automatically by including the FTP library. The default value for
    `FTPUSER` is `anonymous`. However, for `FTPPASS`, we supplied the value as `anonymous`
    in the `register_options` already.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect_login`方法将连接到目标并尝试使用我们提供的匿名凭据登录软件。但等等！我们什么时候提供了凭据？模块的`FTPUSER`和`FTPPASS`选项会自动启用，包括FTP库。`FTPUSER`的默认值是`anonymous`。但是，对于`FTPPASS`，我们已经在`register_options`中提供了值`anonymous`。'
- en: Next, we use `rand_text_alpha` to generate the junk of `2008` using the value
    of `Offset` from the `Targets` field, and then store it in the `sploit` variable.
    We also save the value of `Ret` from the `Targets` field in little-endian format,
    using a `pack('V')` function in the `sploit` variable. Concatenating NOPs generated
    by the `make_nop` function with the shellcode, we store it to the `sploit` variable.
    Our input data is ready to be supplied.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`rand_text_alpha`生成`2008`的垃圾数据，使用`Targets`字段中的`Offset`值，并将其存储在`sploit`变量中。我们还使用`pack('V')`函数将`Targets`字段中的`Ret`值以小端格式存储在`sploit`变量中。将`make_nop`函数生成的NOP连接到shellcode中，我们将其存储到`sploit`变量中。我们的输入数据已经准备好供应。
- en: 'Next, we just send the data in the `sploit` variable to the target in the `CWD`
    command using the `send_cmd` function from the FTP library. So, how is Metasploit
    different? Let''s see:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需使用FTP库中的`send_cmd`函数将`sploit`变量中的数据发送到`CWD`命令的目标。那么，Metasploit有什么不同之处呢？让我们看看：
- en: We didn't need to create junk data because the `rand_text_aplha` function did
    it for us.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要创建垃圾数据，因为`rand_text_aplha`函数已经为我们完成了。
- en: We didn't need to provide the `Ret` address in the little-endian format because
    the `pack('V')` function helped us transform it.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要以小端格式提供`Ret`地址，因为`pack('V')`函数帮助我们转换了它。
- en: We never needed to manually specify NOPs as `make_nops` did it for us automatically.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从未需要手动指定NOP，因为`make_nops`会自动为我们完成。
- en: We did not need to supply any hardcoded shellcode since we can decide and change
    the payload on the runtime. This saves time by eliminating manual changes to the
    shellcode.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要提供任何硬编码的shellcode，因为我们可以在运行时决定和更改有效载荷。这样可以节省时间，消除了对shellcode的手动更改。
- en: We simply leveraged the FTP library to create and connect the socket.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简单地利用FTP库创建并连接套接字。
- en: Most importantly, we didn't need to connect and log in using manual commands
    because Metasploit did it for us using a single method, that is, `connect_login`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，我们不需要使用手动命令连接和登录，因为Metasploit使用单个方法`connect_login`为我们完成了这些。
- en: Exploiting the target application with Metasploit
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Metasploit对目标应用程序
- en: 'We saw how beneficial the use of Metasploit over existing exploits is. Let''s
    exploit the application and analyze the results:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到使用Metasploit比现有的利用更有益。让我们利用应用程序并分析结果：
- en: '![](img/dade4e48-05f5-4b43-879d-808fcfc4b1db.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dade4e48-05f5-4b43-879d-808fcfc4b1db.png)'
- en: 'We can see that `FTPPASS` and `FTPUSER` already have the values set as `anonymous`.
    Let''s supply `RHOST` and the payload type to exploit the target machine as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`FTPPASS`和`FTPUSER`已经设置为`anonymous`。让我们按照以下方式提供`RHOST`和有效载荷类型来利用目标机器：
- en: '![](img/526769ad-65ee-4cc0-8748-fb6ed698e058.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/526769ad-65ee-4cc0-8748-fb6ed698e058.png)'
- en: We can see that our exploit executed successfully. Metasploit also provided
    some additional features, which makes exploitation more intelligent. We will look
    at these features in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的利用成功执行。Metasploit还提供了一些额外的功能，使利用更加智能。我们将在下一节看到这些功能。
- en: Implementing a check method for exploits in Metasploit
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Metasploit中实现利用的检查方法
- en: 'It is possible, in Metasploit, to check for the vulnerable version before exploiting
    the vulnerable application. This is very important since if the version of the
    application running at the target is not vulnerable, it may crash the application
    and the possibility of exploiting the target becomes nil. Let''s write an example
    check code for the application we exploited in the previous section as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metasploit中，可以在利用易受攻击的应用程序之前检查易受攻击的版本。这非常重要，因为如果目标运行的应用程序版本不易受攻击，可能会导致应用程序崩溃，利用目标的可能性变为零。让我们编写一个示例检查代码，检查我们在上一节中利用的应用程序的版本。
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We begin the `check` method by issuing a call to the `connect_login` method.
    This will initiate a connection to the target. If the connection is successful
    and the application returns the banner, we match it to the banner of the vulnerable
    application using a regex expression. If the banner matches, we mark the application
    as vulnerable using `Exploit::Checkcode::Appears`. However, if we are not able
    to authenticate but the banner is correct, we return the same `Exploit::Checkcode::Appears`
    value, which denotes the application as vulnerable. In case all of these checks
    fail, we return `Exploit::CheckCode::Safe` to mark the application as not vulnerable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`connect_login`方法开始`check`方法。这将建立与目标的连接。如果连接成功并且应用程序返回横幅，我们将使用正则表达式将其与受影响的应用程序的横幅进行匹配。如果匹配成功，我们将使用`Exploit::Checkcode::Appears`标记应用程序为易受攻击。但是，如果我们无法进行身份验证但横幅是正确的，我们将返回相同的`Exploit::Checkcode::Appears`值，表示应用程序易受攻击。如果所有这些检查都失败，我们将返回`Exploit::CheckCode::Safe`，标记应用程序为不易受攻击。
- en: 'Let''s see if the application is vulnerable or not by issuing a `check` command
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出`check`命令，让我们看看应用程序是否易受攻击：
- en: '![](img/104c9107-d4f9-41c9-8fd3-c546231d8ae3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/104c9107-d4f9-41c9-8fd3-c546231d8ae3.png)'
- en: We can see that the application is vulnerable. We can proceed to the exploitation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到应用程序是易受攻击的。我们可以继续进行利用。
- en: For more information on implementing the `check` method, refer to: [https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实现`check`方法的更多信息，请参阅：[https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method)。
- en: Importing web-based RCE into Metasploit
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基于Web的RCE导入Metasploit
- en: In this section, we will look at how we can import web application exploits
    into Metasploit. Our entire focus throughout this chapter will be to grasp essential
    functions equivalent to those used in different programming languages. In this
    example, we will look at the PHP utility belt remote code execution vulnerability
    disclosed on 8 December 2015\. The vulnerable application can be downloaded from: [https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip](https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何将Web应用程序漏洞导入Metasploit。本章的重点将是掌握与不同编程语言中使用的基本功能相当的功能。在本例中，我们将看看2015年12月8日披露的PHP实用工具包远程代码执行漏洞。可从以下网址下载受影响的应用程序：[https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip](https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip)。
- en: 'The remote code execution vulnerability lies in the code parameter of a `POST`
    request, which, when manipulated using specially crafted data, can lead to the
    execution of server-side code. Let''s see how we can exploit this vulnerability
    manually as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码执行漏洞位于`POST`请求的`code`参数中，当使用特制数据操纵时，可能导致服务器端代码的执行。让我们看看如何手动利用这个漏洞：
- en: '![](img/4d544578-7e5a-447e-aed6-15e04c2f6f11.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d544578-7e5a-447e-aed6-15e04c2f6f11.png)'
- en: The command we used in the preceding screenshot is `fwrite`, which writes data
    to a file. We used `fwrite` to open a file called `info.php` in the writable mode.
    We wrote `<?php $a = "net user"; echo shell_exec($a);?>` to the file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的屏幕截图中使用的命令是`fwrite`，它用于将数据写入文件。我们使用`fwrite`以可写模式打开名为`info.php`的文件。我们向文件中写入`<?php
    $a = "net user"; echo shell_exec($a);?>`。
- en: When our command runs, it will create a new file called `info.php` and will
    put the PHP content into this file. Next, we just need to browse to the `info.php`
    file, where the result of the command can be seen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的命令运行时，它将创建一个名为`info.php`的新文件，并将PHP内容放入该文件。接下来，我们只需要浏览`info.php`文件，就可以看到命令的结果。
- en: 'Let''s browse to the `info.php` file as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式浏览`info.php`文件：
- en: '![](img/4b694398-d3b8-424e-a4ce-a4e7f2255d57.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b694398-d3b8-424e-a4ce-a4e7f2255d57.png)'
- en: We can see that all the user accounts are listed on the `info.php` page. To
    write a Metasploit module for the PHP belt remote code execution vulnerability,
    we are required to make GET/POST requests to the page. We will need to make a
    request where we POST our malicious data onto the vulnerable server and potentially
    get meterpreter access.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有用户帐户都列在`info.php`页面上。要为PHP工具包远程代码执行漏洞编写Metasploit模块，我们需要向页面发出GET/POST请求。我们需要发出一个请求，在该请求中，我们将我们的恶意数据POST到易受攻击的服务器上，并可能获得meterpreter访问。
- en: Gathering the essentials
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集必要的信息
- en: The most important things to do while exploiting a web-based bug in Metasploit
    are to figure out the web methods, figure out the ways of using those methods,
    and figure out what parameters to pass to those methods. Moreover, another thing
    that we need to know is the exact path of the file that is vulnerable to the attack.
    In this case, we know that the vulnerability is present in the `CODE` parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metasploit中利用基于Web的漏洞时，最重要的事情是弄清楚Web方法，弄清楚使用这些方法的方式，以及弄清楚要传递给这些方法的参数。此外，我们需要知道的另一件事是受攻击的文件的确切路径。在这种情况下，我们知道漏洞存在于`CODE`参数中。
- en: Grasping the important web functions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握重要的Web功能
- en: The important web methods in the context of web applications are located in
    the `client.rb` library file under `/lib/msf/core/exploit/http`, which further
    links to `client.rb` and the `client_request.rb` file under `/lib/rex/proto/http`,
    where core variables and methods related to `GET` and `POST` requests are located.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的上下文中，重要的Web方法位于`/lib/msf/core/exploit/http`下的`client.rb`库文件中，进一步链接到`/lib/rex/proto/http`下的`client.rb`和`client_request.rb`文件，其中包含与`GET`和`POST`请求相关的核心变量和方法。
- en: 'The following methods from the `/lib/msf/core/exploit/http/client.rb` library
    file can be used to create HTTP requests:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`/lib/msf/core/exploit/http/client.rb`库文件中的以下方法可用于创建HTTP请求：'
- en: '![](img/ee7dc12f-ae07-400b-9995-596ac1b8ff56.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee7dc12f-ae07-400b-9995-596ac1b8ff56.png)'
- en: The `send_request_raw` and `send_request_cgi` methods are relevant when making
    a HTTP-based request, but in a different context.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_request_raw`和`send_request_cgi`方法在不同的上下文中进行HTTP请求时是相关的。'
- en: We have `send_request_cgi`, which offers much more flexibility than the traditional
    `send_request_raw` function in some cases, whereas `send_request_raw` helps to
    make more straightforward connections. We will discuss more on these methods in
    the upcoming sections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`send_request_cgi`，在某些情况下比传统的`send_request_raw`函数提供了更多的灵活性，而`send_request_raw`有助于建立更直接的连接。我们将在接下来的部分讨论这些方法。
- en: 'To understand what values we need to pass to these functions, we need to investigate
    the `REX` library. The `REX` library presents the following headers relevant to
    the request types:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们需要传递给这些函数的数值，我们需要调查`REX`库。`REX`库提供了与请求类型相关的以下标头：
- en: '![](img/a1ae8b68-eddd-4e6e-b464-3bbaa675cbf9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1ae8b68-eddd-4e6e-b464-3bbaa675cbf9.png)'
- en: We can pass a variety of values related to our requests by using the preceding
    parameters. One such example is setting our specific cookie and a host of other
    parameters of our choice. Let's keep things simple and focus on the `URI` parameter,
    that is, the path of the exploitable web file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前述参数，我们可以传递与我们的请求相关的各种值。一个例子是设置我们特定的cookie和我们选择的其他参数。让我们保持简单，专注于`URI`参数，即可利用的Web文件的路径。
- en: The `method` parameter specifies that it is either a `GET` or a `POST` type
    request. We will make use of these while fetching/posting data to the target.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`method`参数指定它是`GET`还是`POST`类型的请求。在获取/发布数据到目标时，我们将使用这些。'
- en: The essentials of the GET/POST method
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET/POST方法的基本要点
- en: The `GET` method will request data or a web page from a specified resource and
    use it to browse web pages. On the other hand, the `POST` command sends the data
    from a form or a specific value to the resource for further processing. Now, this
    comes in handy when writing exploits that are web-based. The HTTP library simplifies
    posting particular queries or data to the specified pages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法将请求数据或来自指定资源的网页，并用它来浏览网页。另一方面，`POST`命令将来自表单或特定值的数据发送到资源进行进一步处理。现在，在编写基于Web的利用时，这非常方便。HTTP库简化了将特定查询或数据发布到指定页面。'
- en: 'Let''s see what we need to perform in this exploit:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要在这个利用中执行的操作：
- en: Create a `POST` request
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`POST`请求
- en: Send our payload to the vulnerable application using the `CODE` parameter
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CODE`参数将我们的有效载荷发送到易受攻击的应用程序
- en: Get Meterpreter access to the target
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取目标的Meterpreter访问权限
- en: Perform a few post exploitation functions
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些后期利用功能
- en: We are clear on the tasks that we need to perform. Let's take a further step
    and generate a compatible matching exploit, and confirm that it's working.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚我们需要执行的任务。让我们进一步迈出一步，生成一个兼容的匹配利用，并确认它是否有效。
- en: Importing an HTTP exploit into Metasploit
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTTP利用导入Metasploit
- en: 'Let''s write the exploit for the PHP utility belt remote code execution vulnerability
    in Metasploit as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式编写Metasploit中PHP实用程序皮带远程代码执行漏洞的利用：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that we have declared all the required libraries and provided the
    necessary information in the initialize section. Since we are exploiting a PHP-based
    vulnerability, we choose the platform as PHP. We set `DisableNops` to true to
    turn off `NOP` usage in the payload since the exploit targets remote code execution
    vulnerability in a web application rather than a software-based vulnerability.
    We know that the vulnerability lies in the `ajax.php` file. Therefore, we declared
    the value of `TARGETURI` to the `ajax.php` file. We also created a new string
    variable called `CHECKURI`, which will help us create a check method for the exploit.
    Let''s look at the next part of the exploit:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们已经声明了所有必需的库，并在初始化部分提供了必要的信息。由于我们正在利用基于PHP的漏洞，我们选择平台为PHP。我们将`DisableNops`设置为true，以关闭有效载荷中的`NOP`使用，因为利用针对的是Web应用程序中的远程代码执行漏洞，而不是基于软件的漏洞。我们知道漏洞存在于`ajax.php`文件中。因此，我们将`TARGETURI`的值声明为`ajax.php`文件。我们还创建了一个名为`CHECKURI`的新字符串变量，它将帮助我们为利用创建一个检查方法。让我们看一下利用的下一部分：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the `send_request_cgi` method to accommodate the `POST` requests in
    an efficient way. We set the value of method as `POST`, URI as the target URI
    in the normalized format, and the value of the `POST` parameter `CODE` as `fwrite(fopen('info.php','w'),'<?php
    echo phpinfo();?>');`. This payload will create a new file called `info.php` while
    writing the code which, when executed, will display a PHP information page. We
    created another request for fetching the contents of the `info.php` file we just
    created. We did this using the `send_request_raw` technique and setting the method
    as `GET`. The `CHECKURI` variable, which we created earlier, will serve as the
    URI for this request.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`send_request_cgi`方法以高效的方式容纳`POST`请求。我们将方法的值设置为`POST`，将URI设置为规范化格式中的目标URI，并将`POST`参数`CODE`的值设置为`fwrite(fopen('info.php','w'),'<?php
    echo phpinfo();?>');`。这个有效载荷将创建一个名为`info.php`的新文件，同时编写代码，当执行时将显示一个PHP信息页面。我们创建了另一个请求，用于获取我们刚刚创建的`info.php`文件的内容。我们使用`send_request_raw`技术并将方法设置为`GET`来执行此操作。我们之前创建的`CHECKURI`变量将作为此请求的URI。
- en: 'We can see that we stored the result of the request in the `resp` variable.
    Next, we match the body of `resp` to the `phpinfo()` expression. If the result
    is true, it will denote that the `info.php` file was created successfully onto
    the target and the value of `Exploit::CheckCode::Vulnerable` will return to the
    user, which will display a message marking the target as vulnerable. Otherwise,
    it will mark the target as safe using `Exploit::CheckCode::Safe`. Let''s now jump
    into the exploit method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们将请求的结果存储在`resp`变量中。接下来，我们将`resp`的主体与`phpinfo()`表达式进行匹配。如果结果为真，将表示`info.php`文件已成功创建到目标上，并且`Exploit::CheckCode::Vulnerable`的值将返回给用户，显示标记目标为易受攻击的消息。否则，它将使用`Exploit::CheckCode::Safe`将目标标记为安全。现在让我们进入利用方法：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see we just created a simple `POST` request with our payload in the
    code parameter. As soon as it executes on the target, we get PHP Meterpreter access.
    Let''s see this exploit in action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们刚刚创建了一个带有我们有效载荷的简单`POST`请求。一旦它在目标上执行，我们就会获得PHP Meterpreter访问权限。让我们看看这个利用的效果：
- en: '![](img/8b55d368-febe-452a-98e2-fab97148a29f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b55d368-febe-452a-98e2-fab97148a29f.png)'
- en: We can see that we have Meterpreter access on the target. We have successfully
    converted remote code execution vulnerability into a working exploit in Metasploit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们已经在目标机器上获得了Meterpreter访问权限。我们已成功将远程代码执行漏洞转换为Metasploit中的可工作利用。
- en: Official Metasploit modules for the PHP utility belt already exists. You can
    download the exploit from: [https://www.exploit-db.com/exploits/39554/](https://www.exploit-db.com/exploits/39554/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Metasploit模块已经存在于PHP实用工具包中。您可以从以下链接下载利用：[https://www.exploit-db.com/exploits/39554/](https://www.exploit-db.com/exploits/39554/)。
- en: Importing TCP server/browser-based exploits into Metasploit
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将TCP服务器/基于浏览器的利用导入Metasploit
- en: In the following section, we will see how we can import browser-based or TCP
    server-based exploits in Metasploit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何将基于浏览器或TCP服务器的利用导入Metasploit。
- en: 'During an application test or a penetration test, we might encounter software
    that may fail to parse data from a request/response and end up crashing. Let''s
    see an example of an application that has vulnerability when parsing data:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序测试或渗透测试期间，我们可能会遇到无法解析请求/响应数据并最终崩溃的软件。让我们看一个在解析数据时存在漏洞的应用程序的例子：
- en: '![](img/7db3f606-a65b-424e-b98c-1170c42baf3e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7db3f606-a65b-424e-b98c-1170c42baf3e.png)'
- en: 'The application used in this example is BSplayer 2.68\. We can see that we
    have a Python exploit listening on port `81`. The vulnerability lies in parsing
    the remote server''s response when a user tries to play a video from a URL. Let''s
    see what happens when we try to stream content from our listener on port `81`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的应用程序是BSplayer 2.68。我们可以看到我们有一个监听端口`81`的Python利用。当用户尝试从URL播放视频时，漏洞在解析远程服务器的响应时出现。让我们看看当我们尝试从端口`81`上的监听器中流式传输内容时会发生什么：
- en: '![](img/cd716a16-ebc1-470d-a30c-e13b7ecf3684.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd716a16-ebc1-470d-a30c-e13b7ecf3684.png)'
- en: We can see the calculator application popping up, which denotes that the exploit
    is working successfully.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到计算器应用程序弹出，这表明利用成功运行。
- en: Download the Python exploit for BSplayer 2.68 from: [https://www.exploit-db.com/exploits/36477/](https://www.exploit-db.com/exploits/36477/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载BSplayer 2.68的Python利用：[https://www.exploit-db.com/exploits/36477/](https://www.exploit-db.com/exploits/36477/)。
- en: 'Let''s see the exploit code and gather essential information from it to build
    the Metasploit module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下利用代码，并收集构建Metasploit模块所需的基本信息：
- en: '![](img/b6674a0f-3c2a-4a48-9719-879662dc9dfd.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6674a0f-3c2a-4a48-9719-879662dc9dfd.png)'
- en: The exploit is straightforward. However, the author of the exploit has used
    the backward jumping technique to find the shellcode that was delivered by the
    payload. This technique is used to countermeasure space restrictions. Another
    thing to note here is that the author has sent the malicious buffer twice to execute
    the payload due to the nature of the vulnerability. Let's try building a table
    in the next section with all the data we require to convert this exploit into
    a Metasploit-compatible module.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个利用很简单。然而，利用的作者使用了向后跳转技术来找到由有效载荷传递的shellcode。这种技术用于对抗空间限制。这里需要注意的另一件事是，作者发送了恶意缓冲区两次来执行有效载荷，这是由于漏洞的性质。让我们尝试在下一节中建立一个表，列出我们转换这个利用为Metasploit兼容模块所需的所有数据。
- en: Gathering the essentials
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集基本要素
- en: 'Let''s look at the following table that highlights all the necessary values
    and their usage:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下表，突出显示了所有必要的值及其用法：
- en: '| **Serial number** | **Variable** | **Value** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **序列号** | **变量** | **值** |'
- en: '| 1 | Offset value | `2048` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 偏移值 | `2048` |'
- en: '| 2 | Known location in memory containing POP-POP-RETN series of instructions/P-P-R
    address | `0x0000583b` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 内存中已知包含POP-POP-RETN系列指令/P-P-R地址的位置 | `0x0000583b` |'
- en: '| 3 | Backward jump/long jump to find the shellcode | `\xe9\x85\xe9\xff\xff`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 向后跳转/长跳转以找到shellcode | `\xe9\x85\xe9\xff\xff` |'
- en: '| 4 | Short jump/pointer to the next SEH frame | `\xeb\xf9\x90\x90` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 短跳转/指向下一个SEH帧的指针 | `\xeb\xf9\x90\x90` |'
- en: We now have all the essentials to build the Metasploit module for the BSplayer
    2.68 application. We can see that the author has placed the shellcode precisely
    after `2048` NOPs. However, this does not mean that the actual offset value is
    `2048`. The author of the exploit has placed it before the SEH overwrite because
    there might be no space left for the shellcode. However, we will take this value
    as the offset, since we will follow the exact procedure from the original exploit.
    Additionally, `\xcc` is a breakpoint opcode, but in this exploit, it has been
    used as padding. The `jmplong` variable stores the backward jump to the shellcode
    since there are space constraints. The `nseh` variable stores the address of the
    next frame, which is nothing but a short jump, as we discussed in the previous
    chapter. The `seh` variable stores the address of the `P/P/R` instruction sequence.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有构建BSplayer 2.68应用的Metasploit模块的所有基本要素。我们可以看到作者在`2048` NOP之后精确放置了shellcode。然而，这并不意味着实际的偏移值是`2048`。利用的作者将其放置在SEH覆盖之前，因为可能没有空间留给shellcode。然而，我们将采用这个值作为偏移量，因为我们将按照原始利用的确切过程进行。此外，`\xcc`是一个断点操作码，但在这个利用中，它被用作填充。`jmplong`变量存储了向后跳转到shellcode，因为存在空间限制。`nseh`变量存储了下一个帧的地址，这只是一个短跳转，正如我们在上一章中讨论的那样。`seh`变量存储了`P/P/R`指令序列的地址。
- en: An important point to note here is that in this scenario, we need the target
    to make a connection to our exploit server, rather than us trying to reach the
    target machine. Hence, our exploit server should always listen for incoming connections
    and, based on the request, it should deliver the malicious content.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下需要注意的一个重要点是，我们需要目标机器连接到我们的利用服务器，而不是我们试图连接到目标机器。因此，我们的利用服务器应该始终监听传入的连接，并根据请求传递恶意内容。
- en: Generating the Metasploit module
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Metasploit模块
- en: 'Let''s start the coding part of our exploit in Metasploit:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在Metasploit中编写我们的漏洞的编码部分：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Having worked with so many exploits, we can see that the preceding code section
    is no different, with the exception of the TCP server library file from `/lib/msf/core/exploit/tcp_server.rb`.
    The TCP server library provides all the necessary methods required for handling
    incoming requests and processing them in various ways. Inclusion of this library
    enables additional options such as `SRVHOST`, `SRVPORT`, and `SSL`. Let''s look
    at the remaining part of the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与许多漏洞一起工作，我们可以看到前面的代码部分并无不同，除了来自`/lib/msf/core/exploit/tcp_server.rb`的TCP服务器库文件。TCP服务器库提供了处理传入请求并以各种方式处理它们所需的所有必要方法。包含此库使得额外选项如`SRVHOST`、`SRVPORT`和`SSL`成为可能。让我们看看代码的剩余部分：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that we have no exploit method with this type of exploit. However,
    we have the `on_client_connect`, `on_client_data`, and `on_client_disconnect`
    methods. The most useful and the easiest is the `on_client_connect` method. This
    method is fired as soon as a client connects to the exploit server on the chosen
    `SRVHOST` and `SRVPORT`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们没有这种类型漏洞的漏洞方法。但是，我们有`on_client_connect`、`on_client_data`和`on_client_disconnect`方法。最有用且最简单的是`on_client_connect`方法。一旦客户端连接到所选的`SRVHOST`和`SRVPORT`上的漏洞服务器，此方法将被触发。
- en: We can see that we created NOPs in the Metasploit way using `make_nops` and
    embedded the payload using `payload.encoded`, thus eliminating the use of hardcoded
    payloads. We assembled the rest of the `sploit` variable using a similar method
    to the one used for the original exploit. However, to send the malicious data
    back to the target when requested, we have used `client.put()`, which will respond
    with our chosen data to the target. Since the exploit requires the data to be
    sent twice to the target, we have used `client.get_once` to ensure that the data
    is transmitted twice instead of being merged into a single unit. Sending the data
    twice to the target, we fire the handler that actively looks for incoming sessions
    from successful exploits. In the end, we close the connection to the target by
    issuing a `service.client_close` call.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们使用`make_nops`以Metasploit的方式创建了NOPs，并使用`payload.encoded`嵌入了有效载荷，从而消除了硬编码有效载荷的使用。我们使用了类似于原始漏洞的方法组装了`sploit`变量的其余部分。然而，为了在请求时将恶意数据发送回目标，我们使用了`client.put()`，它将以我们选择的数据回应目标。由于漏洞需要将数据两次发送到目标，我们使用了`client.get_once`来确保数据被发送两次，而不是合并成单个单元。将数据两次发送到目标，我们触发了主动寻找来自成功利用的传入会话的处理程序。最后，我们通过发出`service.client_close`调用来关闭与目标的连接。
- en: We can see that we have used the `client` object in our code. This is because
    the incoming request from a particular target will be considered as a separate
    object and it will also allow multiple targets to connect at the same time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们在代码中使用了`client`对象。这是因为来自特定目标的传入请求将被视为单独的对象，并且还将允许多个目标同时连接。
- en: 'Let''s see our Metasploit module in action:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的Metasploit模块的运行情况：
- en: '![](img/724811da-24b6-42b5-a4e6-8abdb9895c45.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/724811da-24b6-42b5-a4e6-8abdb9895c45.png)'
- en: 'Let''s connect to the exploit server on port `8080` from BSplayer 2.8 as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从BSplayer 2.8连接到端口`8080`上的漏洞服务器，方法如下：
- en: '![](img/273b6582-a87e-408e-8bae-3b0031ac184d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273b6582-a87e-408e-8bae-3b0031ac184d.png)'
- en: 'As soon as a connection attempt is made to our exploit handler, the Meterpreter
    payload is delivered to the target, and we are presented with the following screen:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有连接尝试连接到我们的漏洞处理程序，Meterpreter有效载荷将传递到目标，并且我们将看到以下屏幕：
- en: '![](img/58eb7755-4617-4b6b-a4ab-79a918e32311.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58eb7755-4617-4b6b-a4ab-79a918e32311.png)'
- en: Jackpot! The Meterpreter shell is now accessible. We successfully wrote an exploit
    server module in Metasploit using TCP server libraries. In Metasploit, we can
    also establish HTTP server functionalities using HTTP server libraries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 中奖！Meterpreter shell现在可访问。我们成功地使用TCP服务器库在Metasploit中编写了一个漏洞服务器模块。在Metasploit中，我们还可以使用HTTP服务器库建立HTTP服务器功能。
- en: For more on HTTP server functions, refer to: [https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb](https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多HTTP服务器功能，请参阅：[https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb](https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb)。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Covering the brainstorming exercises of porting exploits, we have now developed
    approaches to import various kinds of exploits in Metasploit. After going through
    this chapter, we have learned how we can port exploits of different kinds into
    the framework with ease. In this chapter, we have developed mechanisms to figure
    out the essentials from a standalone exploit. We saw various HTTP functions and
    their use in exploitation. We have also refreshed our knowledge of SEH-based exploits
    and how exploit servers are built.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在移植漏洞的头脑风暴练习中，我们现在已经开发了在Metasploit中导入各种漏洞的方法。通过阅读本章，我们学会了如何轻松地将不同类型的漏洞移植到框架中。在本章中，我们开发了从独立漏洞中找出必要要素的机制。我们看到了各种HTTP功能及其在利用中的用法。我们还复习了基于SEH的漏洞利用以及如何构建漏洞服务器。
- en: 'You can try your hands at the following exercises:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试以下练习：
- en: Port 10 exploits to Metasploit from: [https://exploit-db.com/](https://exploit-db.com/)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从以下网站将10个漏洞移植到Metasploit：[https://exploit-db.com/](https://exploit-db.com/)
- en: Work on at least 3 browser exploits and port them to Metasploit
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少开发3个浏览器漏洞并将它们移植到Metasploit
- en: Try creating your own custom shellcode module and port it to Metasploit
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建自己的自定义shellcode模块并将其移植到Metasploit
- en: So, by now, we have covered most of the exploit writing exercises. In the next
    chapter, we will see how we can leverage Metasploit to carry out penetration testing
    on various services, including VOIP, DBMS, SCADA, and much more.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了大部分漏洞编写练习。在下一章中，我们将看到如何利用Metasploit对各种服务进行渗透测试，包括VOIP、DBMS、SCADA等。
