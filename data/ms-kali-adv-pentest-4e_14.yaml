- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Embedded Devices and RFID Hacking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式设备与RFID攻击
- en: The embedded systems market has been given a real boost by the adoption of the
    **Internet of Things** (**IoT**) by consumers. Modern connected embedded devices
    are becoming more attractive and are widely deployed across many big corporations,
    **Small Offices/Home Offices** (**SOHOs**), and **Small and Medium-sized Businesses**
    (**SMB**) and are being directly utilized by global household consumers. As per
    [www.statista.com](http://www.statista.com), connected IoT devices have grown
    from 15.41 billion devices in 2015 to 35.82 billion devices in 2021, and there
    are expected to be 75.44 billion devices by 2025\. In the same way, threats have
    grown, and the security of these devices has become the biggest area of concern
    to manufacturers and consumers. A recent good example of this is the vulnerabilities
    found in Realtek chipsets (CVE-2021-35395) that affected 65+ vendors that produce
    smart devices. The way the attacks originated indicates that they might have been
    done by the same attackers that created the Mirai botnet attack that left most
    of the US east coast without internet in 2016.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统市场受到了消费者采用**物联网**（**IoT**）的巨大推动。现代联网嵌入式设备变得越来越有吸引力，并广泛部署于许多大公司、**小型办公室/家庭办公室**（**SOHO**）、**中小型企业**（**SMB**），并被全球家庭消费者直接使用。根据[www.statista.com](http://www.statista.com)，联网物联网设备从2015年的15.41亿台增长到2021年的35.82亿台，预计到2025年将达到75.44亿台。同样，威胁也在增长，这些设备的安全性已成为制造商和消费者最关注的领域。一个最近的典型例子是发现了Realtek芯片组中的漏洞（CVE-2021-35395），该漏洞影响了65多个生产智能设备的供应商。这些攻击的来源表明，它们可能是由与2016年使美国东海岸大部分地区断网的Mirai僵尸网络攻击相同的攻击者所发起。
- en: In this chapter, we will cover the basics of embedded systems and the role of
    peripherals and explore the different tools and techniques that can be employed
    to perform a traditional hardware/firmware penetration test or product evaluation
    of a given device using Kali Linux. We will also set up ChameleonMini to emulate
    an NFC card and replay the stored memory contents to bypass any physical access
    control during a red teaming exercise or physical penetration testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍嵌入式系统的基础知识、外设的角色，并探索可以用于执行传统硬件/固件渗透测试或使用Kali Linux进行给定设备产品评估的不同工具和技术。我们还将设置ChameleonMini，以模拟NFC卡并重放存储的内存内容，以绕过任何物理访问控制，在红队演习或物理渗透测试中进行测试。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Embedded systems and hardware architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式系统和硬件架构
- en: UART serial buses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UART串行总线
- en: USB JTAG
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB JTAG
- en: Unpacking firmware and common bootloaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包固件和常见的引导加载程序
- en: RFID hacking using ChameleonMini
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ChameleonMini进行RFID攻击
- en: Embedded systems and hardware architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统和硬件架构
- en: An embedded system is a combination of hardware and software that is designed
    to perform a specific task. The embedded hardware is usually based on a microcontroller
    and microprocessors. In this section, we will take a quick look at the different
    architectural elements of an embedded system, including memory and communication
    between these devices. Pretty much everything that we use on a day-to-day basis
    is an embedded device, including mobile phones, DVD players, GPS systems, and
    intelligent voice assistants such as Alexa and other hardware-based solutions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统是由硬件和软件组合而成，旨在执行特定任务。嵌入式硬件通常基于微控制器和微处理器。在本节中，我们将快速了解嵌入式系统的不同架构元素，包括内存和这些设备之间的通信。几乎我们日常使用的所有设备都是嵌入式设备，包括手机、DVD播放器、GPS系统和智能语音助手，如Alexa和其他基于硬件的解决方案。
- en: Embedded system basic architecture
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式系统基本架构
- en: 'The basic architecture of an embedded system typically includes a hardware
    and software component. *Figure 14.1* depicts the typical architecture components
    of a simple embedded device:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统的基本架构通常包括硬件和软件组件。*图14.1* 描绘了一个简单嵌入式设备的典型架构组件：
- en: '![Diagram  Description automatically generated](../Images/B17765_14_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图示 说明自动生成](../Images/B17765_14_01.png)'
- en: 'Figure 14.1: Basic embedded system architecture'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：基本的嵌入式系统架构
- en: 'The components of an embeddedsystemare as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统的组件如下：
- en: '**Software**: This is the custom application to control the device and its
    features; mostly a web application to configure or update the device.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件**：这是用于控制设备及其功能的定制应用程序；通常是一个用于配置或更新设备的Web应用程序。'
- en: '**Microprocessor or microcontroller**: Typical embedded devices are based around
    the microprocessor and microcontroller. The only difference between a microcontroller
    and a microprocessor is that microprocessors do not have RAM/ROM, which needs
    to be added externally. Most of the embedded devices/systems today utilize microcontrollers
    that have a CPU and a fixed amount of RAM/ROM.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微处理器或微控制器**：典型的嵌入式设备以微处理器和微控制器为基础。微控制器和微处理器的唯一区别在于，微处理器没有内置的 RAM/ROM，必须外部添加。如今，大多数嵌入式设备/系统都使用包含
    CPU 和固定容量的 RAM/ROM 的微控制器。'
- en: '**Hardware**: This includes a peripheral device with chipsets, processors such
    as ARM (most widely deployed), MIPS, Ambarella, Axis CRIS, Atmel AVR, Intel 8051,
    or Motorola power microcontrollers.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件**：这包括带有芯片组的外部设备，如 ARM（最广泛部署）、MIPS、Ambarella、Axis CRIS、Atmel AVR、Intel
    8051 或 Motorola 功率微控制器。'
- en: '**Embedded operating system**: Most embedded systems are Linux-based, and they
    are **real-time operating systems** (**RTOSes**) customized for the device. There
    might be some questions raised in the tester’s mind, such as what is the difference
    between the operating system and the firmware? The firmware allows device manufacturers
    to use general-purpose programmable chips instead of custom-purpose hardware.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式操作系统**：大多数嵌入式系统基于 Linux，并且它们是为设备定制的**实时操作系统**（**RTOSes**）。测试人员可能会产生一些疑问，比如操作系统和固件之间有什么区别？固件使设备制造商能够使用通用的可编程芯片，而不是定制的硬件。'
- en: Understanding firmware
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解固件
- en: In electronic systems and computing, firmware is software that can connect to
    specific hardware that provides low-level control. Every device comes with its
    own firmware from the product’s manufacturer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子系统和计算中，固件是能够连接特定硬件并提供低级控制的软件。每个设备都由产品制造商提供自己的固件。
- en: 'The following list of categories and types of devices are those that typically
    come with custom firmware, and they are mostly Linux. The following list is not
    exhaustive in any way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通常配备定制固件的设备类别和类型，且大多数是基于 Linux 的。以下列表并不完全：
- en: '![](../Images/B17765_14_02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_02.png)'
- en: 'Figure 14.2: Different types of devices'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：不同类型的设备
- en: 'The following table lists the types of memory utilized in most embedded devices:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了大多数嵌入式设备中使用的内存类型：
- en: '| **Type of memory** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **内存类型** | **描述** |'
- en: '| **DRAM** (**Dynamic Random-Access Memory**) | This is volatile memory that
    can be accessed in both read and write mode. It is fast and will need access to
    the memory contents. DRAM is the reason to employ caching mechanisms in some architectures.
    The DRAM memory access is timed at the very early stages of the bootloader. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **DRAM**（**动态随机存取内存**） | 这是一种可以在读写模式下访问的易失性内存。它速度快，且需要访问内存内容。DRAM 是一些架构中采用缓存机制的原因之一。在启动加载程序的初期阶段，DRAM
    内存访问是有时间限制的。 |'
- en: '| **SRAM** (**Static Random-Access Memory**) | This is volatile memory similar
    to DRAM that can be accessed in read and write mode. It is faster than DRAM. Mostly,
    small levels of SRAM that are less than 1 MB will be included on the device (due
    to commercial reasons). |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **SRAM**（**静态随机存取内存**） | 这是一种类似于 DRAM 的易失性内存，可以以读写模式访问，速度比 DRAM 快。通常，设备中包含的
    SRAM 容量较小，通常少于 1 MB（出于商业原因）。 |'
- en: '| **ROM** (**Read-Only Memory**) | This is non-volatile memory that can only
    be read. A mask bootloader is one example of a ROM in embedded devices. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **ROM**（**只读内存**） | 这是一种只能读取的非易失性内存。掩码启动加载程序就是嵌入式设备中的 ROM 示例。 |'
- en: '| **Memory-Mapped NOR Flash** | This is non-volatile memory that can be accessed
    in read/write mode. This is used during boot code. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **内存映射 NOR Flash** | 这是一种可以以读/写模式访问的非易失性内存，通常在启动代码时使用。 |'
- en: '| **NAND Flash** | This is a type of non-volatile storage technology that does
    not require power to retain data. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **NAND Flash** | 这是一种非易失性存储技术，断电后仍能保留数据。 |'
- en: '| **SD** (**Secure Digital**) **Card** | This is a non-volatile memory card
    format used in portable devices. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **SD**（**Secure Digital**）**卡** | 这是一种用于便携设备的非易失性存储卡格式。 |'
- en: 'Table 14.1: Different types of memory'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1：不同类型的内存
- en: Different types of firmware
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同类型的固件
- en: 'Pretty much all embedded devices are powered by different firmware depending
    on their complexities. Embedded systems that perform heavy tasks definitely need
    a full operating system such as Linux or Windows NT. The following is a non-exhaustive
    list of operating systems that are normally found during firmware analysis:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有嵌入式设备都由不同的固件驱动，具体取决于其复杂性。执行重型任务的嵌入式系统肯定需要像 Linux 或 Windows NT 这样的完整操作系统。以下是在固件分析期间通常发现的操作系统的非尽述列表：
- en: '**Ambarella**: An embedded operating system mostly used in video cameras, drones,
    and so on.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ambarella**：主要用于视频摄像机、无人机等的嵌入式操作系统。'
- en: '**Cisco IOS**: Cisco’s Internetwork operating system.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**思科 IOS**：思科的企业级互联网操作系统。'
- en: '**DOS**: A disk operating system that is considered obsolete. But testers never
    know what they will find during an assessment.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOS**：被认为已过时的磁盘操作系统。但在评估期间，测试人员永远不知道会发现什么。'
- en: '**eCos (Embedded Configurable Operating System)**: This is an open-source real-time
    operating system from the eCos community.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eCos（嵌入式可配置操作系统）**：这是来自 eCos 社区的开源实时操作系统。'
- en: '**Junos OS or JunOS**: This is Juniper Networks’ custom operating system based
    on FreeBSD for its router devices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Junos OS 或 JunOS**：这是 Juniper Networks 针对其路由器设备基于 FreeBSD 的定制操作系统。'
- en: '**L4 microkernel family**: These are second-generation microkernels that look
    like Unix-like operating systems.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L4 微内核家族**：这些是第二代微内核，看起来像类 Unix 操作系统。'
- en: '**VxWorks/Wind River**: A popular proprietary real-time operating system.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VxWorks/Wind River**：一种流行的专有实时操作系统。'
- en: '**Windows CE/NT**: The operating system for Microsoft-enabled embedded compact
    devices; very rare to find on a device.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows CE/NT**：微软启用的嵌入式紧凑设备操作系统；在设备上很难找到。'
- en: 'It is important to understand the difference between the firmware and the operating
    system. *Table 14.2* provides the basic differences:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 了解固件与操作系统之间的区别非常重要。 *表 14.2* 提供了基本的区别：
- en: '| **Firmware** | **Operating System** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **固件** | **操作系统** |'
- en: '| It is always fixed data/code that is embedded in any peripheral device or
    electronic appliance. | It is system software that is designed to provide an environment
    to facilitate multiple programs; it acts as a foundational layer. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 它始终是嵌入在任何外围设备或电子设备中的固定数据/代码。 | 它是设计为提供多程序环境的系统软件；它充当基础层。 |'
- en: '| It resides in non-volatile memory (ROM), for example, BIOS, keyboards, refrigerators,
    and washing machines. | It resides on disk, for example, Microsoft Windows, Google
    Android, and Apple iOS/macOS. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 它驻留在非易失性存储器（ROM）中，例如 BIOS、键盘、冰箱和洗衣机。 | 它驻留在磁盘上，例如 Microsoft Windows、Google
    Android 和 Apple iOS/macOS。 |'
- en: '| It is a low-level operation and is mostly used for a single purpose. | It
    is a high-level interface and a multi-purpose system that allows different kinds
    of software to run on multiple hardware. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 它是低级操作，主要用于单一目的。 | 它是高级接口和多用途系统，允许不同类型的软件在多个硬件上运行。 |'
- en: 'Table 14.2: Firmware versus operating systems'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2：固件与操作系统
- en: Understanding bootloaders
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解引导加载程序
- en: 'Every device has a bootloader. Bootloaders are nothing but the first piece
    of software that gets loaded and executed after the mask ROM bootloader. They
    are primarily put in place to load parts of an operating system into the memory
    and ensure the system is loaded in the defined state for the kernel. Some bootloaders
    have a two-step approach; in these scenarios, only step one will know how to load
    the second step, while the second step will provide access to filesystems, and
    so on. The following is a list of the bootloaders we have encountered during a
    product evaluation so far:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有一个引导加载程序。引导加载程序仅仅是在掩码 ROM 引导加载程序之后加载和执行的第一个软件部分。它们主要用于将操作系统的部分加载到内存中，并确保系统在内核定义状态下加载。一些引导加载程序采用两步方法；在这些场景中，只有第一步会知道如何加载第二步，而第二步将提供对文件系统的访问等。以下是到目前为止在产品评估中遇到的引导加载程序的列表：
- en: '`U-Boot`: Stands for universal boot—this is open source and pretty much available
    in all the architecture (68k, ARM, Blackfin, MicroBlaze, MIPS, Nios, SuperH, PPC,
    RISC-V, and x86).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U-Boot`：通用启动加载器，这是开源的，几乎在所有架构（68k、ARM、Blackfin、MicroBlaze、MIPS、Nios、SuperH、PPC、RISC-V
    和 x86）中都可以使用。'
- en: '`RedBoot`: Uses the eCos real-time operating system hardware abstraction layer
    to provide bootstrap firmware for embedded systems.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedBoot`：使用 eCos 实时操作系统硬件抽象层为嵌入式系统提供引导固件。'
- en: '`BareBox`: Another open-source, primary bootloader used in embedded devices.
    It supports RM, Blackfin, MIPS, Nios II, and x86.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BareBox`：另一个开源的主要引导加载程序，广泛用于嵌入式设备。它支持 RM、Blackfin、MIPS、Nios II 和 x86。'
- en: Common tools
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用工具
- en: 'The following list of tools can be utilized while debugging or reverse engineering
    a device’s firmware. Some of these tools are available as toolkits with Kali Linux:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具列表可以在调试或反向工程设备固件时使用。部分工具可以作为 Kali Linux 工具包使用：
- en: '**binwalk**: This is a reverse engineering tool that can perform analysis and
    extraction of any image or binary files. It is scriptable and you can add custom
    modules of the specific firmware.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**binwalk**：这是一种反向工程工具，可以对任何镜像或二进制文件进行分析和提取。它支持脚本化，且可以添加特定固件的自定义模块。'
- en: '**firmware-mod-kit**: This is a collection of toolkits that includes multiple
    scripts and utilities that can be handy during an assessment to extract and rebuild
    Linux-based firmware images. Testers can also reconstruct or deconstruct a firmware
    image.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**firmware-mod-kit**：这是一个工具包的集合，包含多个脚本和实用工具，在评估过程中可以用于提取和重建基于 Linux 的固件镜像。测试人员还可以重构或解构固件镜像。'
- en: '**ERESI framework**: This is a software interface with a multi-architecture
    binary analysis framework to perform reverse engineering and manipulation of programs.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ERESI 框架**：这是一个多架构二进制分析框架的软件接口，用于执行程序的反向工程和操作。'
- en: '**cnu-fpu**: Cisco IP phones’ firmware pack/unpacker. This can be found at
    [https://github.com/kbdfck/cnu-fpu](https://github.com/kbdfck/cnu-fpu).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cnu-fpu**：Cisco IP 电话固件打包/解包工具。可以在[https://github.com/kbdfck/cnu-fpu](https://github.com/kbdfck/cnu-fpu)找到。'
- en: '**ardrone-tool**: This tool handles all the Parrot format files and also allows
    users to flash through USB and load new firmware. It is available at [https://github.com/scorp2kk/ardrone-tool](https://github.com/scorp2kk/ardrone-tool).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ardrone-tool**：该工具处理所有 Parrot 格式文件，并允许用户通过 USB 刷写并加载新固件。可以在[https://github.com/scorp2kk/ardrone-tool](https://github.com/scorp2kk/ardrone-tool)找到。'
- en: Firmware unpacking and updating
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件解包和更新
- en: 'With a basic understanding of the bootloaders and different types of firmware,
    we will explore how to unpack some firmware and update it with our custom firmware
    on a Cisco Meraki MR18 wireless access point (an embedded device with Cisco firmware).
    Most of the time, during hardware penetration testing, the firmware images will
    not include all the files to construct a complete embedded system. Typically,
    we find the following in each embedded device:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本了解引导加载程序和不同类型的固件后，我们将探索如何解包一些固件，并在 Cisco Meraki MR18 无线接入点（一个具有 Cisco 固件的嵌入式设备）上使用自定义固件进行更新。在硬件渗透测试中，大多数固件镜像通常不包含构建完整嵌入式系统所需的所有文件。通常我们在每个嵌入式设备中发现以下内容：
- en: Bootloader (1st/2nd stage)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序（1 阶/2 阶）
- en: Kernel
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: Filesystem images
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统镜像
- en: User-land binaries
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间二进制文件
- en: Resources and support files
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源和支持文件
- en: Web server/web interface
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器/网页界面
- en: Modern embedded devices prevent the installation of different operating systems
    using their own firmware, therefore to upgrade the device to a customizable operating
    system, we will utilize OpenWRT, which is open-source firmware for residential
    gateways, originally created for Linksys WRT54G wireless routers. It has grown
    into an embedded Linux distribution and now supports a wide range of devices.
    With the device restrictions, to perform the upgrade or update it requires a JTAG
    (which stands for Joint Test Action Group, an industry standard for verifying
    designs and testing printed circuit boards after manufacture).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现代嵌入式设备通过其固件阻止安装不同的操作系统，因此要将设备升级到可定制的操作系统，我们将使用 OpenWRT，这是一个为住宅网关创建的开源固件，最初为
    Linksys WRT54G 无线路由器开发。它已经发展成一个嵌入式 Linux 发行版，并且现在支持多种设备。由于设备的限制，要执行升级或更新，通常需要使用
    JTAG（即联合测试行动组，工业标准，用于验证设计并在生产后测试印刷电路板）。
- en: JTAG can be used more from a **TAP** (**Test Access Port**) perspective no matter
    how restricted the device is. The manufacturer will usually leave either a serial
    port or a few TAPs. In our experience, if serial access is not yielding good results
    or the device is too locked down, it might be easier to go for a JTAG port (but
    this is not always the case as the device might be completely locked down).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG 可以更多地从 **TAP**（**测试访问端口**）的角度来使用，无论设备有多么受限。制造商通常会留有串口或几个 TAP。在我们的经验中，如果串行访问未能产生良好的结果，或者设备锁定得太严格，那么可能更容易使用
    JTAG 端口（但这并不总是如此，因为设备可能完全被锁定）。
- en: JTAG architecture is specified by the chip maker and, in most cases, even with
    a daisy-chained JTAG. The JTAG follows the main chipset’s specifications for command
    and control. All the products are assigned with an FCC ID that provides the device’s
    details. The FCC ID can be searched by visiting [https://www.fcc.gov/oet/ea/fccid](https://www.fcc.gov/oet/ea/fccid).
    We must get the right voltage or we will end up either breaking the device or
    making the hardware faulty. Once the type of JTAG architecture has been identified,
    we can start looking at the specifications and commands that are required to configure
    the connection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG 架构由芯片制造商指定，在大多数情况下，即使是链式连接的 JTAG，JTAG 也遵循主芯片组的命令和控制规范。所有产品都分配了一个 FCC ID，用于提供设备的详细信息。你可以通过访问
    [https://www.fcc.gov/oet/ea/fccid](https://www.fcc.gov/oet/ea/fccid) 查找 FCC ID。我们必须获得正确的电压，否则我们可能会损坏设备或导致硬件故障。一旦确定了
    JTAG 架构类型，我们就可以开始查看配置连接所需的规格和命令。
- en: 'We will utilize the **USB JTAG NT** tool, which is preconfigured with a list
    of devices and different categories and types. This tool can be directly downloaded
    from [https://www.usbjtag.com/filedownload/](https://www.usbjtag.com/filedownload/)
    and we will be utilizing the USB JTAG NT cable for this example. As a key first
    step, the USB end of the USB JTAG cable must be connected to our Kali Linux and
    the JTAG end to the circuit board of the device (for more information on how to
    find the right pins to connect, refer to [https://blog.senr.io/blog/jtag-explained](https://blog.senr.io/blog/jtag-explained)).
    The physical connection to the router will look like *Figure 14.3*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预配置了设备列表、不同类别和类型的**USB JTAG NT**工具。这个工具可以直接从 [https://www.usbjtag.com/filedownload/](https://www.usbjtag.com/filedownload/)
    下载，我们将在这个例子中使用 USB JTAG NT 电缆。作为第一步，USB JTAG 电缆的 USB 端必须连接到我们的 Kali Linux 设备，而
    JTAG 端则连接到设备的电路板（有关如何找到正确的连接引脚，请参考 [https://blog.senr.io/blog/jtag-explained](https://blog.senr.io/blog/jtag-explained)）。与路由器的物理连接将如*图
    14.3*所示：
- en: '![](../Images/B17765_14_03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_03.png)'
- en: 'Figure 14.3: USB JTAG NT cable connecting to the Cisco Meraki router'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：USB JTAG NT 电缆连接到 Cisco Meraki 路由器
- en: 'Since USB JTAG NT heavily relies on QTLib libraries, to successfully run this
    tool on Kali Linux, the following steps are involved:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 USB JTAG NT 严重依赖 QTLib 库，为了在 Kali Linux 上成功运行此工具，需要执行以下步骤：
- en: Download the USB JTAG NT from [https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php](https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php](https://www.usbjtag.com/filedownload/usbjtagnt-for-linux64.php)
    下载 USB JTAG NT。
- en: Download the QTLib from [https://www.usbjtag.com/filedownload/library-for-linux64.php](https://www.usbjtag.com/filedownload/library-for-linux64.php).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.usbjtag.com/filedownload/library-for-linux64.php](https://www.usbjtag.com/filedownload/library-for-linux64.php)
    下载 QTLib。
- en: Unzip the archive files by running `tar xvf <nameofthefile.tar>`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `tar xvf <nameofthefile.tar>` 解压存档文件。
- en: Ensure you set the QT library path by running `export LD_LIBRARY_PATH=/home/kali/Downloads/QtLib`
    (if you have downloaded the files to a different folder ensure that reflects in
    the path).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过运行 `export LD_LIBRARY_PATH=/home/kali/Downloads/QtLib` 设置 QT 库路径（如果你将文件下载到其他文件夹，确保路径反映出这个位置）。
- en: Finally, launch the application by running `./USBJTAGNT` in the terminal. Then,
    you should successfully be able to launch the application without any problems,
    as shown in *Figure 14.4*:![Graphical user interface, text, application, chat
    or text message  Description automatically generated](../Images/B17765_14_04.png)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在终端中运行 `./USBJTAGNT` 启动应用程序。然后，你应该能够顺利启动应用程序，不会遇到任何问题，如*图 14.4*所示：![图形用户界面，文本，应用程序，聊天或文本消息
    说明自动生成](../Images/B17765_14_04.png)
- en: 'Figure 14.4: Successfully loading USB JTAG NT in Kali Linux'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.4：在 Kali Linux 中成功加载 USB JTAG NT
- en: 'Once you select the **Category**, **Protocol** type, and **Target select**,
    we will set **Router** as the **Category**, **EJTAG** as the **Protocol**, and
    then select the model of the router for the target. We will utilize OpenWRT to
    load into the hardware. If the connected JTAG physically works fine, then we are
    good to debug the device, as shown in *Figure 14.5*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了**类别**、**协议**类型和**目标选择**，我们将设置**路由器**为**类别**，**EJTAG**为**协议**，然后选择路由器的型号作为目标。我们将利用
    OpenWRT 将其加载到硬件中。如果连接的 JTAG 物理上工作正常，那么我们就可以开始调试设备，如*图 14.5*所示：
- en: '![](../Images/B17765_14_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_05.png)'
- en: 'Figure 14.5: Flushing and installing OpenWRT to the device'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：将 OpenWRT 刷入并安装到设备上
- en: The `program` command is utilized to flush the **OEM** (**Original Equipment
    Manufacturer**) operating system. Once the program is complete, we can upload
    a new `.bin` file to the device, which will load OpenWRT to the selected router
    and have full privileges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`program`命令用于刷新**OEM**（**原始设备制造商**）操作系统。一旦程序完成，我们可以将新的`.bin`文件上传到设备，这将加载OpenWRT到所选的路由器并赋予完全权限。'
- en: Once the flush is complete and OpenWRT is loaded, we can verify the communication
    to the device by direct SSH access root privileges by running `ssh root@192.168.1.1`
    from the Kali Linux terminal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦刷新完成并加载了OpenWRT，我们可以通过直接SSH访问root权限来验证与设备的通信，方法是从Kali Linux终端运行`ssh root@192.168.1.1`。
- en: 'With Windows, you can utilize PuTTY to access the device with default gateway
    IP (`192.168.1.1`) as shown in *Figure 14.6* (ensure you have a physical Ethernet
    cable connected to your router and laptop and set a static IP to your device):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以使用PuTTY通过默认网关IP（`192.168.1.1`）访问设备，如*图14.6*所示（确保你已将物理以太网线连接到路由器和笔记本，并为设备设置静态IP）：
- en: '![](../Images/B17765_14_06.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_06.png)'
- en: 'Figure 14.6: Connecting to the device using PuTTY to the Meraki wireless access
    point with root and no password'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：通过PuTTY连接到Meraki无线接入点，使用root账号且没有密码
- en: Introduction to RouterSploit Framework
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterSploit框架介绍
- en: Similar to the Metasploit Framework, Threat9’s (https://www.threat9.com) RouterSploit
    Framework is an open-source exploitation framework used to exploit embedded devices
    (specifically routers). The tool can be installed on Kali by running `sudo apt
    install routersploit` from the terminal. The latest version of RouterSploit is
    3.4.1, and it comes with 132 known exploits and 4 different scanners, depending
    on the device type. This entire section can be performed by a mobile device as
    we know we can install the Kali on any Android phone as described in the *Kali
    on Android (non-rooted phones)* section in *Chapter 1*, *Goal-Based Penetration
    Testing*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Metasploit框架，Threat9的（https://www.threat9.com）RouterSploit框架是一个开源的漏洞利用框架，用于攻击嵌入式设备（特别是路由器）。该工具可以通过在终端运行`sudo
    apt install routersploit`来安装在Kali中。RouterSploit的最新版本是3.4.1，并且它带有132个已知的漏洞利用程序和4种不同的扫描器，具体取决于设备类型。我们知道这个过程可以通过移动设备完成，因为我们可以按照《第1章
    目标导向渗透测试》中*安卓手机上安装Kali（无root权限手机）*的说明，在任何安卓手机上安装Kali。
- en: 'The following are the modules of RouterSploit:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是RouterSploit的模块：
- en: '`exploits`: A module that contacts all the identified vulnerabilities'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exploits`：一个用于攻击所有已识别漏洞的模块'
- en: '`creds`: A module to test for login credentials with predefined usernames and
    passwords'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creds`：一个用于测试登录凭证的模块，具有预定义的用户名和密码'
- en: '`scanners`: A module that runs the scanning with the preconfigured list of
    vulnerabilities'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanners`：一个运行扫描的模块，使用预配置的漏洞列表'
- en: '`payloads`: A module to generate payloads according to the device type'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payloads`：一个根据设备类型生成负载的模块'
- en: '`generic/encoders`: A module that includes the generic payloads and encoders'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic/encoders`：一个包含通用负载和编码器的模块'
- en: 'In the following example, we will go ahead and use RouterSploit’s scanner function
    to identify if the router (DLink) that we have connected to is vulnerable to any
    known vulnerabilities or not. We will use `scanners/autopwn` against our router
    that is running on `192.168.0.1`, as shown in *Figure 14.7*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用RouterSploit的扫描器功能来识别我们连接的路由器（DLink）是否存在已知漏洞。我们将对运行在`192.168.0.1`上的路由器使用`scanners/autopwn`，如*图14.7*所示：
- en: '![Text  Description automatically generated](../Images/B17765_14_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![文本说明自动生成](../Images/B17765_14_07.png)'
- en: 'Figure 14.7: Using Routersploit to exploit a DLink router'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：使用RouterSploit利用DLink路由器漏洞
- en: 'The scanner will run 132 exploits from the `exploits` module. Since we have
    utilized `autopwn`, by the end of the scan you should be able to see the list
    of vulnerabilities that our router is vulnerable to, as shown in *Figure 14.8*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器将从`exploits`模块运行132个漏洞利用程序。由于我们已经使用了`autopwn`，扫描结束时你应该能够看到我们的路由器所存在的漏洞列表，如*图14.8*所示：
- en: '![](../Images/B17765_14_08.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_08.png)'
- en: 'Figure 14.8: Output of the autopwn module with a list of exploitable vulnerabilities'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：autopwn模块的输出，显示可被利用的漏洞列表
- en: 'Once `autopwn` is run, you should be able to see the vulnerabilities that can
    be exploited. In this case, we know the device is vulnerable to two different
    exploits, so let’s go ahead and use the exploit by running:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行`autopwn`，你应该能够看到可以被利用的漏洞。在这个例子中，我们知道该设备存在两个不同的漏洞，所以我们将继续使用漏洞利用程序，运行：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This exploit does **Local File Inclusion** (**LFI**) and reaches the `httaccess`
    file and extracts the username and password. A successful exploit should result
    in login information, as shown in *Figure 14.9*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞利用了**本地文件包含**（**LFI**）并访问`httaccess`文件，提取用户名和密码。成功的漏洞利用应该会导致登录信息，如*图14.9*所示：
- en: '![Text  Description automatically generated](../Images/B17765_14_09.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![文本 描述自动生成](../Images/B17765_14_09.png)'
- en: 'Figure 14.9: Successfully extracting the password from the router using RouterSploit'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：成功提取路由器密码，使用RouterSploit
- en: 'Let’s try the other vulnerability to bypass the authentication, without having
    to log in with valid credentials by manipulating the URLs. We can exploit the
    router by running `routersploit`, as shown in *Figure 14.10*; in the case of a
    router running on port `443`, set the `ssl` value to `true`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一种漏洞，通过操控URL绕过身份验证，无需使用有效凭据登录。我们可以通过运行`routersploit`来利用路由器，如*图14.10*所示；在路由器运行在`443`端口的情况下，将`ssl`值设置为`true`：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Text  Description automatically generated](../Images/B17765_14_10.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![文本 描述自动生成](../Images/B17765_14_10.png)'
- en: 'Figure 14.10: Running the authentication bypass module in RouterSploit'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：在RouterSploit中运行身份验证绕过模块
- en: 'Finally, the URL can be utilized to access the router web interface, which
    will allow direct access to the setup page, as shown in *Figure 14.11*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，URL可以用于访问路由器的网页界面，从而允许直接访问设置页面，如*图14.11*所示：
- en: '![Graphical user interface, website  Description automatically generated](../Images/B17765_14_11.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站 描述自动生成](../Images/B17765_14_11.png)'
- en: 'Figure 14.11: Accessing the router settings without any authentication'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：无需任何身份验证即可访问路由器设置
- en: We have explored RouterSploit to take advantage of the vulnerable routers. Attackers
    can use a simple non-rooted Android device to perform these attacks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了RouterSploit，利用了易受攻击的路由器。攻击者可以使用一个简单的非root安卓设备来执行这些攻击。
- en: If you’re tasked to perform hardware pen testing on a newly designed hardware,
    the following section provides a brief methodology that can be used by attackers
    to get a root shell on a router using a UART device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的任务是对新设计的硬件进行硬件渗透测试，以下部分提供了一种简要方法，攻击者可以使用UART设备在路由器上获取root shell。
- en: UART
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UART
- en: '**UART** stands for **Universal Asynchronous Receiver/Transmitter**. It is
    one of the first modes of communication to computers. It goes back to 1960 when
    it was used to connect minicomputers for teletypewriter machines (teletypes).
    The main purpose of UARTs is to transmit and receive the serial data just like
    a standalone integrated circuit; it is not a protocol like **SPI** (**Serial Peripheral
    Interface**) or **I2C** (**Inter-Integrated Circuit**). It is typically used by
    manufacturers to connect microcontrollers to store and load programs. Every UART
    device has advantages and disadvantages. The following are the advantages of UART:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**UART** 代表 **通用异步接收器/发送器**。它是最早用于计算机通信的模式之一。追溯到1960年，当时它被用来连接迷你计算机与电传打字机（电传）。UART的主要目的是像独立的集成电路一样传输和接收串行数据；它不是像
    **SPI** (**串行外设接口**) 或 **I2C** (**集成电路间接口**) 这样的协议。制造商通常使用它将微控制器连接到存储和加载程序。每个UART设备都有优缺点。以下是UART的优点：'
- en: It has only two wires, so it’s pretty straightforward. One is transmit (TX),
    and the other is receive (RX).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有两根线，所以相当简单。一根是发送（TX），另一根是接收（RX）。
- en: There is no need for a clock signal.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需时钟信号。
- en: Error checking can be performed by a parity bit.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过奇偶校验位进行错误检查。
- en: If both sides are set up, then the structure of the data packet can be changed.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两端都设置好了，则数据包的结构可以更改。
- en: It’s widely used due to the availability of its documentation throughout the
    internet.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它广泛使用，因为互联网上有大量文档可供查阅。
- en: 'It has the following limitations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它有以下限制：
- en: 'Testers cannot increase the data frame: it will be limited to 9 bits at most'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试人员无法增加数据帧：最多只能限制为9位
- en: There is no way to set up multiple slave or master systems
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法设置多个从设备或主设备系统
- en: UART baud rates must be within 10%
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UART波特率必须在10%以内
- en: In this section, we will be using the **USB to** **TTL** (**Transistor/Transistor
    Logic**) adapter to perform UART communication by connecting to the serial port
    of the device’s circuit board.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 **USB到** **TTL**（**晶体管/晶体管逻辑**）适配器，通过连接到设备电路板的串行端口来进行UART通信。
- en: 'These adapters typically include four ports:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器通常包括四个端口：
- en: '**GND**: Ground (0V) supply'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GND**：接地（0V）电源'
- en: '**VCC**: Voltage power supply, 3.3V (default) or 5V'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VCC**：电压电源，3.3V（默认）或5V'
- en: '**TX**: Serial transmit'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TX**：串行传输'
- en: '**RX**: Serial receive'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RX**：串行接收'
- en: One big challenge attackers face during a hardware hack is to identify the right
    serial ports. This could be done by using a multimeter to read the voltage output
    to confirm the TX (typically, the voltage will keep fluctuating when the device
    is powered on), RX (initially it will fluctuate, but will be constant after a
    point), and GND (zero voltage).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者在硬件攻击中面临的一个大挑战是识别正确的串口。这可以通过使用万用表读取电压输出，以确认TX（通常当设备开机时，电压会不断波动）、RX（最初波动，但会在某个时刻稳定）、和GND（零电压）来完成。
- en: 'In this example, we will use a well-known wireless access point (Cisco Meraki
    MR18) and connect the UART to the TTL device to communicate to the hardware directly,
    as shown in *Figure 14.12*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用一个知名的无线接入点（Cisco Meraki MR18），并将UART连接到TTL设备，以便直接与硬件通信，如*图14.12*所示：
- en: '![](../Images/B17765_14_12.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_12.png)'
- en: 'Figure 14.12: Connecting the UART to Cisco Meraki MR18 wireless access point'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：将UART连接到Cisco Meraki MR18无线接入点
- en: When the right TX/RX and ground are identified (to identify the right UART pins,
    look for 3 or 4 pins next to each other; however, this might change based on the
    type of device), we can use Kali Linux to learn about the device that is currently
    connected by running the `baudrate.py` Python file ([https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py](https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确的TX/RX和地线被识别出来时（要识别正确的UART引脚，可以找到相邻的3到4个引脚；不过，这可能会根据设备的类型而有所不同），我们可以使用Kali
    Linux通过运行`baudrate.py` Python文件 ([https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py](https://github.com/PacktPublishing/Mastering-Kali-Linux-for-Advanced-Penetration-Testing-4E/blob/main/Chapter%2014/Baudrate.py))来了解当前连接的设备。
- en: 'If the serial device is connected, you should be able to see the following
    screen in your Kali without any issues. Most of the time, configuring a baud rate
    of 115,200 works for routers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果串口设备已经连接，你应该能够在Kali中看到以下界面，且没有任何问题。大多数时候，配置115,200波特率对于路由器来说是有效的：
- en: '![](../Images/B17765_14_13.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_13.png)'
- en: 'Figure 14.13: Successfully connecting to the device with a 115,200 baud rate
    using the Python script'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：使用Python脚本以115,200波特率成功连接到设备
- en: 'Once the device is successfully read by our Kali Linux, we can start interacting
    with the device by running `screen /dev/ttyUSB0 115200` in the command line, which
    should directly provide shell access, as shown in *Figure 14.14*. Testers have
    to note that in this example, we have used a known router that provides straight
    root access, which might not be the same with other devices. Devices manufactured
    recently will prompt a user to enter their username and password:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备成功被我们的Kali Linux读取，我们就可以通过在命令行中运行`screen /dev/ttyUSB0 115200`开始与设备交互，这应该会直接提供shell访问，如*图14.14*所示。测试人员需要注意，在这个例子中，我们使用的是一台已知的路由器，它提供了直接的root权限，这在其他设备上可能并不相同。最近制造的设备会提示用户输入用户名和密码：
- en: '![](../Images/B17765_14_14.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_14.png)'
- en: 'Figure 14.14: Accessing the device using the screen command'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：使用screen命令访问设备
- en: 'It is always useful to understand a device from the debug logs: we have seen
    hardcoded credentials in plenty of IoT devices. We have learned how to connect
    to a device using a UART cable and communicate to the device as a highly privileged
    user. In the next section, we will explore cloning an RFID, which can be utilized
    during physical pen testing or a red team exercise.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理解设备的调试日志总是很有用的：我们在很多IoT设备中看到了硬编码的凭证。我们已经学会如何使用UART电缆连接到设备，并作为一个高权限用户与设备进行通信。在下一节中，我们将探索克隆RFID，这可以在物理渗透测试或红队演练中使用。
- en: Cloning RFID using ChameleonMini
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ChameleonMini克隆RFID
- en: '**RFID** stands for **Radio Frequency Identification**, which utilizes radio
    waves to identify items. At a minimum, the RFID system contains a tag, a reader,
    and an antenna. There are active and passive RFID tags. Active RFID tags contain
    their own power source, giving them the ability to broadcast with a read range
    of up to 100 meters. Passive RFID tags do not have their own power source. Instead,
    they are powered by electromagnetic energy transmitted from the RFID reader.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**RFID** 代表 **射频识别**，它利用无线电波来识别物品。最基本的 RFID 系统包含标签、读卡器和天线。RFID 标签有主动标签和被动标签之分。主动
    RFID 标签含有自己的电源，能够广播信号，读取范围可达 100 米。被动 RFID 标签没有自己的电源，而是通过 RFID 读卡器传输的电磁能量供电。'
- en: '**NFC** stands for **Near-Field Communication**, which is a subset of RFID
    but with a high frequency. Both NFC and RFID operate at 13.56 MHz. NFC is also
    designed to run as an NFC reader and NFC tag, which is a unique feature of NFC
    devices that allows them to communicate with peers. In this section, we will explore
    one of the devices that comes in handy during physical pen testing/social engineering
    or a red team exercise to achieve a set objective. For example, if you are signed
    up to showcase the real threats of an organization that includes gaining access
    to an organization’s office premises or data centers or boardrooms, you can use
    ChameleonMini to store six different UIDs in a credit-card-sized portable device:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFC** 代表 **近场通信**，它是 RFID 的一个子集，但具有更高的频率。NFC 和 RFID 都在 13.56 MHz 频率下工作。NFC
    还被设计为可以作为 NFC 读卡器和 NFC 标签运行，这是 NFC 设备的一项独特功能，允许它们与其他设备进行通信。在本节中，我们将探索一种在物理渗透测试/社交工程或红队演练中非常实用的设备，用于实现特定目标。例如，如果你报名展示某个组织的真实威胁，包括获得该组织办公场所、数据中心或董事会会议室的访问权限，你可以使用
    ChameleonMini 在一个信用卡大小的便携设备中存储六个不同的 UID：'
- en: '![](../Images/B17765_14_15.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_15.png)'
- en: 'Figure 14.15: ChameleonMini device/card cloner'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：ChameleonMini 设备/卡片克隆器
- en: The ChameleonMini is a device created by ProxGrind, designed to analyze the
    security issues around NFC to emulate and clone contactless cards, read RFID tags,
    and also sniff RF data. For developers, it is freely programmable. This device
    can be purchased online at [https://lab401.com/](https://lab401.com/). In this
    example, we have used ProxGrind ChameleonMini RevG to demonstrate cloning a UID.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ChameleonMini 是由 ProxGrind 创建的一款设备，旨在分析 NFC 安全问题，用于模拟和克隆非接触式卡片、读取 RFID 标签，并且还可以嗅探
    RF 数据。对于开发者而言，这款设备是可自由编程的。此设备可以在网上购买，网址为 [https://lab401.com/](https://lab401.com/)。在本例中，我们使用了
    ProxGrind ChameleonMini RevG 来演示克隆 UID。
- en: 'In Kali Linux, we can validate the device by directly connecting with the USB.
    The `lsusb` command should display the ChameleonMini as MCS, and every serial
    device connected to Kali Linux will be listed in `/dev/`. In this case, our device
    is visible as a serial port named `ttyACM0`, as shown in *Figure 14.16*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali Linux 中，我们可以通过直接连接 USB 来验证设备。`lsusb` 命令应显示 ChameleonMini 为 MCS，且所有连接到
    Kali Linux 的串口设备都会列出在 `/dev/` 中。在这种情况下，我们的设备显示为名为 `ttyACM0` 的串口，如 *图 14.16* 所示：
- en: '![](../Images/B17765_14_16.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_16.png)'
- en: 'Figure 14.16: Identifying the device in Kali Linux'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：在 Kali Linux 中识别设备
- en: 'We can communicate with the serial port directly using `picocom` by running
    `picocom --baud 115200 --echo /dev/ttyACM0` as shown in *Figure 14.17*. `picocom`
    can be installed by running `apt-get install picocom`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `picocom --baud 115200 --echo /dev/ttyACM0` 来直接与串口通信，如 *图 14.17* 所示。可以通过运行
    `apt-get install picocom` 来安装 `picocom`：
- en: '![](../Images/B17765_14_17.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_17.png)'
- en: 'Figure 14.17: Connecting to the device using picocom at a baud rate of 115,200'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：以 115,200 波特率通过 picocom 连接设备
- en: 'You will require the card that you want to clone. You can use a one-step action
    to clone the card by placing it on the ChameleonMini. Type `CLONE` and the job
    is done, as shown in *Figure 14.18*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要想要克隆的卡片。你可以通过将卡片放置在 ChameleonMini 上，执行一步操作来克隆卡片。输入 `CLONE`，任务就完成了，如 *图 14.18*
    所示：
- en: '![A picture containing chart  Description automatically generated](../Images/B17765_14_18.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![A picture containing chart  Description automatically generated](../Images/B17765_14_18.png)'
- en: 'Figure 14.18: Successfully cloning a card with the configuration'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：成功克隆卡片并完成配置
- en: 'The following details provide the manual way of doing it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是手动操作的详细步骤：
- en: 'Using the command line, do the following:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行，执行以下操作：
- en: Once the serial port communication is established between Kali Linux and the
    device, type the `HELP` command to display all the available commands for ChameleonMini.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦Kali Linux和设备之间建立了串口通信，输入`HELP`命令以显示ChameleonMini的所有可用命令。
- en: ChameleonMini comes with eight slots, each of which can act as an individual
    NFC card. The slots can be set by using the `SETTINGS=` command. For example,
    we can set the slot to `2` by typing the `settings=2` command; it should return
    `100:OK`.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChameleonMini配有八个插槽，每个插槽都可以作为独立的NFC卡使用。可以通过使用`SETTINGS=`命令来设置插槽。例如，我们可以通过输入`settings=2`命令将插槽设置为2；它应该返回`100:OK`。
- en: 'Run `CONFIG?` to see the current configuration. The new device should return
    the following:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`CONFIG?`以查看当前配置。新设备应该返回以下内容：
- en: '[PRE2]'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next step is to place the card reader into *reader* mode. This can be achieved
    by typing `CONFIG=ISO14443A_READER`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将卡片读取器设置为*reader*模式。可以通过输入`CONFIG=ISO14443A_READER`来实现。
- en: Now we can place the card that needs to be cloned in the card reader and type
    the `Identify` command.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将需要克隆的卡片放入卡片读取器中，并输入`Identify`命令。
- en: 'Once you identify the type of the card, you can set the configuration using
    the `CONFIG` command: in our case, it is MIFARE Classic 1K, so we will run `CONFIG=`
    `MF_CLASSIC_1K`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦识别出卡片类型，就可以使用`CONFIG`命令设置配置：在我们的案例中，它是MIFARE Classic 1K，因此我们将运行`CONFIG=` `MF_CLASSIC_1K`。
- en: Now we have set the configuration, we can steal the UID from the card and then
    add it to our ChameleonMini by running `UID=CARD NUMBER`, as shown in *Figure
    14.19*:![](../Images/B17765_14_19.png)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好配置，可以通过运行`UID=CARD NUMBER`命令从卡片中获取UID，然后将其添加到我们的ChameleonMini中，如*图14.19*所示：![](../Images/B17765_14_19.png)
- en: 'Figure 14.19: Cloning the card manually'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.19：手动克隆卡片
- en: We are now all set to use the ChameleonMini as a card.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经准备好将ChameleonMini用作卡片。
- en: 'Pentesters can also pre-program this to perform the cloning tasks with the
    use of two buttons on the device while on the move. For example, during social
    engineering, while the testers talk to the victim company’s staff, they click
    the button and clone their (NFC) ID cards. This can be performed by the following
    commands:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渗透测试人员还可以预编程此设备，通过设备上的两个按钮执行克隆任务。例如，在进行社会工程学测试时，当测试人员与目标公司员工交谈时，他们按下按钮并克隆其(NFC)身份证卡。这可以通过以下命令来执行：
- en: '`LBUTTON=CLONE`: This will set a click of the left-hand button to clone the
    card.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LBUTTON=CLONE`：这将设置左键单击以克隆卡片。'
- en: '`RBUTTON=CYCLE_SETTINGS`: This will set a click of the right button to rotate
    the slots. For example, if CARD A is cloned to slot 1 and you wanted to clone
    another card, this can be performed by clicking the right-hand button, which will
    move the CARD A details to slot 2\. Then, you can go ahead and press the left-hand
    button to clone the new card.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RBUTTON=CYCLE_SETTINGS`：这将设置右键单击以旋转插槽。例如，如果卡片A被克隆到插槽1，并且你想克隆另一张卡片，可以通过点击右键来执行此操作，这会将卡片A的详细信息移到插槽2。然后，你可以继续按左键来克隆新卡片。'
- en: Other tools
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are other tools, such as HackRF One, which is a software-defined radio
    that can also be utilized by pentesters to perform any kind of radio sniffing
    or transmission of your own signals, or even replay the captured radio packets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具，例如HackRF One，它是一种软件定义无线电，也可以被渗透测试人员用来执行任何类型的射频嗅探或传输你自己的信号，甚至重新播放捕获的无线电数据包。
- en: 'We will take a brief example of sniffing a radio frequency in Kali Linux using
    HackRF One SDR. HackRF libraries need to be installed by running `sudo apt install
    hackrf gqrx-sdr` in the terminal. Testers should be able to identify the device
    by running `sudo hackrf_info` from the terminal. If the device is recognized,
    you should be able to see the following screenshot with the details of firmware,
    part ID, and so on:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍如何使用HackRF One SDR在Kali Linux中嗅探射频。需要通过在终端中运行`sudo apt install hackrf
    gqrx-sdr`来安装HackRF库。测试人员应该能够通过在终端运行`sudo hackrf_info`来识别设备。如果设备被识别，你应该能够看到以下截图，显示固件、部件ID等详细信息：
- en: '![](../Images/B17765_14_20.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_20.png)'
- en: 'Figure 14.20: Reading the HackRF device in Kali Linux'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20：在Kali Linux中读取HackRF设备
- en: 'Pentesters can utilize the `kalibrate` tool to scan any GSM base stations.
    This tool can be downloaded from [https://github.com/scateu/kalibrate-hackrf](https://github.com/scateu/kalibrate-hackrf)
    and can be built using the following commands:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员可以利用`kalibrate`工具扫描任何GSM基站。该工具可以从[https://github.com/scateu/kalibrate-hackrf](https://github.com/scateu/kalibrate-hackrf)下载，并可以通过以下命令构建：
- en: '[PRE3]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the installation is complete, `sudo kal` will be the tool to utilize to
    scan a specific band. We will be utilizing the root terminal to run the commands
    since it has to invoke the hardware, and we can run the tool by mentioning the
    frequency (`kal –s GSM900`), as shown in *Figure 14.21*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，`sudo kal`将是用来扫描特定频段的工具。我们将使用root终端运行命令，因为它必须调用硬件，可以通过指定频率来运行工具（`kal
    –s GSM900`），如*图 14.21*所示：
- en: '![](../Images/B17765_14_21.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/B17765_14_21.png)'
- en: 'Figure 14.21: Scanning the GSM channels using HackRF within Kali Linux'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21：使用HackRF在Kali Linux中扫描GSM频道
- en: If the testers can identify the type of peripherals during an on-site assessment
    and find that the company is utilizing certain vulnerable hardware, then they
    can also utilize Crazyradio PA, a long-range 2.4 GHz USB radio dongle that can
    deliver a payload to any computer that is using the vulnerable device through
    radio wireless signals.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试人员在现场评估期间能够识别外设类型，并发现公司使用了某些易受攻击的硬件，那么他们也可以利用Crazyradio PA，这是一款长程2.4 GHz
    USB无线电接收器，可以通过无线电信号将有效负载传输到使用易受攻击设备的任何计算机上。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a quick journey into basic embedded systems and their
    architecture, and we learned about different types of firmware, bootloaders, UART,
    radio sniffing, and common tools that can be utilized during hardware hacking.
    We also learned how to unpack firmware and load new firmware on a router using
    USB JTAG NT. Additionally, we explored using RouterSploit to identify the specific
    vulnerabilities in the embedded devices. Finally, we learned how to clone a physical
    RFID/NFC card using a ChameleonMini, which can be utilized during red teaming
    exercises.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们简要介绍了基本的嵌入式系统及其架构，并了解了不同类型的固件、引导加载程序、UART、无线电嗅探以及在硬件攻击中可以使用的常见工具。我们还学习了如何解包固件并使用USB
    JTAG NT在路由器上加载新固件。此外，我们探讨了如何使用RouterSploit来识别嵌入式设备的特定漏洞。最后，我们学习了如何使用ChameleonMini克隆物理RFID/NFC卡，这可以在红队演练中使用。
- en: We hope this book has helped you to understand the fundamental risks and how
    attackers use these tools to compromise networks/devices within a few seconds,
    and how you can use the same tools and techniques to understand your infrastructure’s
    vulnerabilities, as well as the importance of remediation and patch management
    before your own infrastructure is compromised. On that note, this chapter concludes
    *Mastering Kali Linux for Advanced Penetration Testing – Fourth Edition*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这本书帮助你理解基本的风险，以及攻击者如何利用这些工具在几秒钟内危害网络/设备，此外，你也可以使用相同的工具和技术来了解你的基础设施的漏洞，以及在你的基础设施被攻破之前，修复和补丁管理的重要性。关于这一点，本章结束了*《Kali
    Linux高级渗透测试指南（第四版）》*。
