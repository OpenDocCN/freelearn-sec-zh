- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Authentication and Authorization Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权测试
- en: Assuming you read the previous chapter or already have knowledge about **Application
    Programming Interface** (**API**) reconnaissance, it’s now time to dive deeper
    into pentesting the API. In the previous chapter, we worked through a crAPI challenge
    by accessing data from objects that belong to other users. This data was supposed
    to be protected, but crAPI didn’t do it correctly. This was an authorization flaw.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经阅读了上一章或者对**应用程序编程接口**（**API**）侦察有所了解，现在是时候深入进行 API 渗透测试了。在上一章中，我们通过访问属于其他用户的对象中的数据来完成了一个
    crAPI 挑战。这些数据应该受到保护，但 crAPI 没有正确地执行。这是一个授权缺陷。
- en: We need to investigate how APIs establish some of their most fundamental security
    mechanisms, which are how they authenticate and authorize their users. We will
    use the term **AuthN** to refer to **authentication** and **AuthZ** to refer to
    **authorization** just to shorten the words; this is a common practice in the
    literature. Weak AuthN mechanisms can usually be discovered during the initial
    stage of our work, which we covered in the previous chapter. After some interactions
    and analysis, we can discover the data structures an API applies and then spot
    weak AuthZ controls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调查 API 如何建立其最基本的安全机制，即如何认证和授权用户。我们将使用术语**AuthN**来指代**认证**，使用**AuthZ**来指代**授权**，以便简化这些词汇；这在文献中是一个常见做法。弱认证机制通常可以在我们工作初期发现，这一部分内容在上一章已经讲解过。经过一些交互和分析后，我们可以发现
    API 所应用的数据结构，然后发现弱授权控制。
- en: In this chapter, you will learn about both topics in more depth, not only analyzing
    how they are presented by APIs but also understanding best practices for configuring
    and implementing them to protect the app environment. Weak or poorly implemented
    AuthN and/or AuthZ guardrails can compromise the whole application, not just the
    API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将更深入地学习这两个话题，不仅分析它们如何被 API 展示，还将理解配置和实施它们的最佳实践，以保护应用环境。弱或实现不当的认证和/或授权防护措施可能会危及整个应用程序，而不仅仅是
    API。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要话题：
- en: Examining authentication mechanisms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查认证机制
- en: Testing for weak credentials and default accounts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试弱凭证和默认账户
- en: Exploring authorization mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索授权机制
- en: Bypassing access controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过访问控制
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll leverage the same environment as the one described in [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042).
    In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same
    tools we used before, especially the crAPI project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用与[*第3章*](B19657_03.xhtml#_idTextAnchor042)中描述的相同环境。总的来说，你需要一个类型 2 的虚拟化管理程序，如
    VirtualBox，以及我们之前使用的相同工具，特别是 crAPI 项目。
- en: Examining authentication mechanisms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查认证机制
- en: There are various APIs on the internet that work without a need for previous
    AuthN, mainly for read-only operations. A good example of such a use case is the
    **Comprehensive Knowledge Archive Network** (**CKAN**) framework ([https://ckan.org/](https://ckan.org/)).
    It’s an open source project that makes it easier for companies and governments
    to publish data on the internet. Entirely written in Python, the framework has
    a RESTful API with both read and write operations. Since CKAN was designed to
    help *open data* initiatives, having read access to data served by portals supported
    by it is expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上有许多 API 在不需要前期认证的情况下工作，主要用于只读操作。一个典型的例子是**综合知识档案网络**（**CKAN**）框架（[https://ckan.org/](https://ckan.org/)）。这是一个开源项目，旨在帮助企业和政府在互联网上发布数据。整个框架使用
    Python 编写，具有一个 RESTful API，支持读写操作。由于 CKAN 被设计用来帮助*开放数据*倡议，因此拥有对其所提供的数据的读取访问权限是预期中的。
- en: There is also a fair amount of API endpoints that work without AuthN. In the
    previous chapter, we mentioned the OSINT Framework, a website that curates a list
    of other **Open Source Intelligence** (**OSINT**) websites, tools, and blogs.
    You will find a couple of utilities, such as IP location and geo-location, that
    work on the internet completely for free and without previous AuthN. In such cases,
    only read operations are allowed and the services’ owners should protect their
    backends against inadvertent attempts to access protected data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也有不少 API 端点不需要认证（AuthN）。在上一章中，我们提到了 OSINT Framework，这是一个策划其他**开源情报**（**OSINT**）网站、工具和博客的列表网站。你会发现一些工具，例如
    IP 位置和地理位置查询，它们完全免费且不需要事先认证就能在互联网上使用。在这种情况下，仅允许读取操作，服务提供者应保护其后台，防止未经授权的数据访问尝试。
- en: 'Sooner or later, an API might need an AuthN mechanism. We will explain the
    different AuthN mechanisms one by one. Currently, the following ones are the most
    common when implementing APIs, especially RESTful APIs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，API 可能需要一种认证机制（AuthN）。我们将逐一解释不同的认证机制。目前，以下是实现 API 时最常见的几种认证方式，特别是 RESTful
    API：
- en: '**API keys**: Unique identifiers issued to applications for AuthN. Public cloud
    providers may give you one or two such keys to allow you to identify yourself
    (or some code) while interacting with the provider via their APIs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 密钥**：为应用程序颁发的唯一标识符，用于认证（AuthN）。公共云提供商可能会给你一到两个这样的密钥，以便你在通过 API 与提供商交互时能够识别自己（或某些代码）。'
- en: '**Basic AuthN**: Transmits the username and password in Base64 encoding (not
    recommended for sensitive data). Many people still confuse encoding with encryption.
    It doesn’t matter if the text looks like complete nonsense; there’s no security
    in simply encoding data. Even when basic AuthN happens using an encrypted channel,
    as a TLS connection, this should be avoided at all costs.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础认证（Basic AuthN）**：通过 Base64 编码传输用户名和密码（不推荐用于敏感数据）。许多人仍然将编码与加密混淆。即使文本看起来像是完全无意义的，单纯的编码数据并没有安全性。即便基本认证是在加密通道上进行的，如
    TLS 连接，仍应尽量避免使用这种方式。'
- en: '**OAuth**: Open standard for AuthZ, delegating access without sharing credentials.
    Also called a bearer token, OAuth 2.0 provides a token-based AuthN mechanism.
    The client obtains a token from an AuthZ server and includes it in API requests.
    **OpenID Connect** (**OIDC**) is an AuthN layer built on top of OAuth. OIDC enhances
    OAuth by adding an identity layer, allowing clients to verify the identity of
    the end user.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth**：一种开放标准，用于授权（AuthZ），在不共享凭据的情况下委托访问。也称为持有者令牌（bearer token），OAuth 2.0
    提供了基于令牌的认证机制（AuthN）。客户端从授权服务器获取令牌，并将其包含在 API 请求中。**OpenID Connect**（**OIDC**）是建立在
    OAuth 之上的认证层（AuthN）。OIDC 通过添加身份层增强了 OAuth，使客户端能够验证最终用户的身份。'
- en: '**Session tokens**: Used to maintain an authenticated state after initial login.
    They are like temporary keys generated after you log in, stored in your browser
    or website code. They identify you to online platforms without constant logins
    and offer convenience and security benefits.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话令牌**：用于在初次登录后维持已认证状态。它们像是登录后生成的临时密钥，存储在你的浏览器或网站代码中。它们在不需要频繁登录的情况下帮助你在在线平台上进行身份识别，同时提供便利和安全性。'
- en: '**JSON Web Tokens (JWTs)**: Self-contained tokens carrying user information
    and claims. This is a compact, URL-safe means of representing claims between two
    parties. They are often used as bearer tokens in AuthN. JWTs are often passed
    in headers or as query parameters.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON Web 令牌（JWTs）**：自包含的令牌，携带用户信息和声明。这是一种紧凑、URL 安全的方式，用于表示两个方之间的声明。它们通常作为持有者令牌（bearer
    tokens）用于认证（AuthN）。JWTs 常通过请求头或查询参数传递。'
- en: Let’s delve deeper into each of these methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些方法的细节。
- en: API keys
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 密钥
- en: API keys are a form of AuthN used to control access to APIs. They are strings
    of characters, usually generated by the API provider, and act as a token to authenticate
    and authorize requests made by a client (an application, user, or another service)
    to the API server. They are unique strings of characters that act as digital identifiers,
    granting applications access to APIs. They serve as a basic AuthN mechanism, ensuring
    only authorized users can access sensitive data or functionality. As mentioned
    before, this is one of the ways public cloud providers choose to establish AuthN
    in their platforms, usually implemented when customers are writing applications
    to interact with their APIs or when using their CLI tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥是一种身份验证（AuthN）形式，用于控制对API的访问。它们是字符字符串，通常由API提供商生成，作为令牌来验证和授权客户端（应用程序、用户或其他服务）向API服务器发送的请求。它们是唯一的字符字符串，充当数字标识符，允许应用程序访问API。它们作为基本的身份验证机制，确保只有授权用户才能访问敏感数据或功能。正如前面提到的，这也是公共云提供商在其平台中选择建立身份验证的方式之一，通常在客户编写与API交互的应用程序或使用CLI工具时实现。
- en: 'API keys can be generated as single keys or pairs of keys (more common). When
    presented as pairs, one of the keys represents the login/username whereas the
    other works like a password. The keys are internally associated with an actual
    username. You may ask yourself, what’s the reason for having another pair of credentials
    if the well-known username/password method would sort out the AuthN part? It’s
    simple: while a username can only have a single active password, the same username
    can have multiple attached API keys that could in turn have different permissions
    bound to them (AuthZ). Another difference has to do with the essence of the concept.
    API keys allow *applications* to interact with APIs, and username/password credential
    pairs are meant to be used by *people*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥可以作为单个密钥或密钥对（更常见）生成。当以密钥对的形式呈现时，其中一个密钥代表登录名/用户名，而另一个则像密码一样工作。这些密钥与实际用户名在内部关联。你可能会问，为什么需要一对额外的凭证，而知名的用户名/密码方法就能解决身份验证（AuthN）问题？其实很简单：虽然一个用户名只能有一个活动密码，但同一个用户名可以有多个附加的API密钥，并且这些密钥可以绑定不同的权限（身份授权，AuthZ）。另一个区别在于概念的本质。API密钥允许*应用程序*与API进行交互，而用户名/密码凭证对则是供*人类*使用的。
- en: 'To work, API keys need to be provided in all requests. There are various strategies
    to handle such keys. Some utilities store them in clear-text configuration files
    and load them to memory, whereas others simply create environment variables to
    store the contents. Storage of the keys is exactly the preferred way to discover
    them. Now and then, developers leak them to public repositories or even hardcode
    them in HTML or JavaScript files. You can leverage some tools to help you with
    this step, such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用API密钥，必须在所有请求中提供它们。处理这些密钥的策略有很多。一些工具将它们存储在明文配置文件中并加载到内存中，而另一些则简单地创建环境变量来存储内容。密钥的存储方式正是发现它们的首选方法。开发人员时不时会将密钥泄露到公共代码库中，或者将其硬编码到HTML或JavaScript文件中。你可以利用一些工具来帮助你完成这一步骤，以下是一些示例：
- en: '**badsecrets** ([https://github.com/blacklanternsecurity/badsecrets](https://github.com/blacklanternsecurity/badsecrets)):
    Library to look for secrets in many different platforms.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**badsecrets** ([https://github.com/blacklanternsecurity/badsecrets](https://github.com/blacklanternsecurity/badsecrets)):
    用于在多个不同平台上查找密钥的库。'
- en: '**Gitleaks** ([https://gitleaks.io/](https://gitleaks.io/)): Maybe the most
    popular tool to find keys in Git-like repositories, directories, and files.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gitleaks** ([https://gitleaks.io/](https://gitleaks.io/)): 可能是最受欢迎的工具，用于在类似Git的代码库、目录和文件中查找密钥。'
- en: '**KeyFinder** ([https://github.com/momenbasel/KeyFinder](https://github.com/momenbasel/KeyFinder)):
    Chrome extension to find keys while browsing the web.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KeyFinder** ([https://github.com/momenbasel/KeyFinder](https://github.com/momenbasel/KeyFinder)):
    Chrome扩展程序，用于在浏览网页时查找密钥。'
- en: '**Keyhacks** ([https://github.com/streaak/keyhacks](https://github.com/streaak/keyhacks)):
    Public repository with keys discovered in various bug bounty programs. Helps you
    check whether they are valid after the programs have ended. This tool has a ChatGPT
    Plus version: https://chat.openai.com/g/g-JaNIbfsRt-keyhacks-gpt.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keyhacks** ([https://github.com/streaak/keyhacks](https://github.com/streaak/keyhacks)):
    包含在各种漏洞赏金计划中发现的密钥的公共代码库。帮助你检查这些密钥在计划结束后是否有效。此工具有ChatGPT Plus版本：https://chat.openai.com/g/g-JaNIbfsRt-keyhacks-gpt。'
- en: '**Mantra** ([https://github.com/MrEmpy/mantra](https://github.com/MrEmpy/mantra)):
    Search for keys in HTML and JavaScript files.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mantra** ([https://github.com/MrEmpy/mantra](https://github.com/MrEmpy/mantra)):
    在HTML和JavaScript文件中查找密钥。'
- en: '**Nuclei Templates** ([https://github.com/projectdiscovery/nuclei-templates](https://github.com/projectdiscovery/nuclei-templates)):
    You can use this to test the same keys against various API endpoints.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nuclei Templates** ([https://github.com/projectdiscovery/nuclei-templates](https://github.com/projectdiscovery/nuclei-templates)):
    你可以使用它对各种 API 端点测试相同的密钥。'
- en: '**Secrets Patterns DB** ([https://github.com/mazen160/secrets-patterns-db](https://github.com/mazen160/secrets-patterns-db)):
    A regular expressions database that can be used by other tools, such as TruffleHog,
    to look for key, token, or password patterns in various types of files.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secrets Patterns DB** ([https://github.com/mazen160/secrets-patterns-db](https://github.com/mazen160/secrets-patterns-db)):
    一个正则表达式数据库，可以被其他工具使用，例如 TruffleHog，用于在各种类型的文件中查找密钥、令牌或密码模式。'
- en: '**TruffleHog** ([https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)):
    A Swiss army knife that looks for secrets and keys in many places, including GitHub
    repos, and container images.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TruffleHog** ([https://github.com/trufflesecurity/truffleHog](https://github.com/trufflesecurity/truffleHog)):
    一个瑞士军刀工具，可以在许多地方查找密钥和秘密，包括 GitHub 仓库和容器镜像。'
- en: 'Some of these tools run as containers, some are libraries you can leverage
    to empower your own code, and some are command-line utilities. You won’t have
    trouble finding other similar tools, including for pentesting distros such as
    Kali Linux. Let’s make a quick test with TruffleHog against some of my personal
    GitHub repositories. First, we’ll use the tool alone and then we’ll add Secrets
    Patterns DB. To leverage Secrets Patterns DB, we first need to use it to create
    a regex JSON patterns file. Let’s run the tool first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具有的以容器形式运行，有的作为库可以用来增强你自己的代码，有的则是命令行工具。你不会难以找到其他类似的工具，包括 Kali Linux 等渗透测试发行版。让我们先用
    TruffleHog 对我的一些个人 GitHub 仓库做一个快速测试。首先，我们将单独使用该工具，然后添加 Secrets Patterns DB。为了使用
    Secrets Patterns DB，我们首先需要用它创建一个正则表达式 JSON 模式文件。让我们先运行工具：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s leverage Secrets Pattern DB and run it again:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用 Secrets Pattern DB 并重新运行它：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Thankfully, no secret has been found so far. As a side note, after generating
    the `regex.json` file you see in the preceding output, I had issues with a couple
    of the populated regular expressions. Maybe it had to do with some missing update
    on Secrets Patterns DB, since it mentions TruffleHog version 2 but this tool is
    already on version 3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，到目前为止没有发现任何秘密。顺便提一句，在生成上面输出中的 `regex.json` 文件后，我遇到了一些已填充的正则表达式问题。也许是因为
    Secrets Patterns DB 中某些更新丢失了，因为它提到的是 TruffleHog 版本 2，而该工具已经是版本 3。
- en: Basic authentication
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: This is possibly one of the easiest AuthN methods to detect when in place. Every
    time you try to access a website and the browser shows you a dialog box asking
    you for a credential pair, that’s basic AuthN. When a web client accesses a server
    that requires basic AuthN, all requests are provided with an `Authorization` header
    that is filled with the username and the password separated by a colon, all encoded
    in Base64.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能最容易被检测到的 AuthN 方法之一。每次你尝试访问一个网站，浏览器显示一个对话框请求你输入凭证对时，那就是基本身份验证。当一个 Web 客户端访问一个需要基本身份验证的服务器时，所有请求都会提供一个
    `Authorization` 头部，里面包含用户名和密码，中间用冒号分隔，所有内容都经过 Base64 编码。
- en: 'An example request would be something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例请求可能是这样的：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the server receives it, a simple Base64-decoding operation takes place
    to check whether the credentials are valid. When the AuthN passes, the server
    responds with the request; otherwise, it sends a 401 code for an unauthorized
    operation. Here, there are other factors that should be considered: how securely
    is such a user database stored and handled? Are the credentials even encrypted
    at rest? Is there some kind of hashing or salting mechanism to generate or double-check
    the validity of the passwords?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到请求时，进行一个简单的 Base64 解码操作，以检查凭证是否有效。当身份验证通过时，服务器响应请求；否则，发送一个 401 代码表示未授权操作。在这里，还有一些其他因素需要考虑：这样的用户数据库是如何安全存储和处理的？凭证在存储时是否加密？是否有某种哈希或加盐机制来生成或再次验证密码的有效性？
- en: And how can you realize when this type of AuthN is being used? Simple. The first
    method is through analyzing the requests. The presence of the `Authorization`
    keyword makes this clear. The responses can also denote its presence. Depending
    on how the server was implemented, you may receive the `WWW-Authenticate` header.
    Finally, if the connection is not protected via TLS, any network inspection tool,
    such as Wireshark, will disclose the AuthN type. Some very old web servers can
    even include the username and password as part of the query string itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何识别何时使用这种AuthN？很简单。第一种方法是通过分析请求。`Authorization`关键字的存在就能明确表示。响应也可以表明其存在。根据服务器的实现方式，你可能会收到`WWW-Authenticate`头。最后，如果连接没有通过TLS加密保护，任何网络检查工具，如Wireshark，都会披露AuthN类型。一些非常旧的Web服务器甚至可能将用户名和密码包含在查询字符串本身中。
- en: Some ways to attack basic AuthN environments are through **Man-in-the-Middle**
    (**MiTM**) attacks when no TLS is applied or via brute force, by trying to systematically
    guess the credential pair, or even by applying some social engineering such as
    phishing. In fact, basic AuthN is so unsecure and old that you may not find many
    API endpoints out there running it. Nevertheless, in some searches I carried out
    while writing this chapter, I found some documentation explaining how to configure
    products such as WSO2 ([https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/](https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/))
    and Apigee’s Edge API ([https://docs.apigee.com/api-platform/system-administration/basic-auth](https://docs.apigee.com/api-platform/system-administration/basic-auth)).
    Daunting…
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击基本身份验证（AuthN）环境的一些方式包括通过**中间人攻击**（**MiTM**）来进行，尤其是在未应用TLS的情况下，或通过暴力破解系统，尝试系统地猜测凭证对，甚至通过社会工程学攻击，如钓鱼攻击。事实上，基本的AuthN非常不安全且过时，因此你可能不会在很多API端点上看到它。然而，在我撰写本章时进行的一些搜索中，我发现了一些文档，解释了如何配置像WSO2这样的产品（[https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/](https://apim.docs.wso2.com/en/3.0.0/learn/design-api/endpoints/endpoint-security/basic-auth/)）以及Apigee的Edge
    API（[https://docs.apigee.com/api-platform/system-administration/basic-auth](https://docs.apigee.com/api-platform/system-administration/basic-auth)）。令人望而生畏……
- en: OAuth
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth
- en: This is possibly one of the most used AuthN mechanisms on the web nowadays.
    OAuth is key to enable you, for example, to log in to your preferred game platform
    without having to create a credential pair by simply leveraging some existing
    external credential, such as the one you use to access your Google, Facebook,
    or Apple accounts, for example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是当前网络上最常用的AuthN机制之一。OAuth是实现这一点的关键，例如，它允许你登录到你喜欢的游戏平台，而无需创建凭证对，只需利用一些现有的外部凭证，例如你用来访问Google、Facebook或Apple账户的凭证。
- en: OAuth has two versions released so far. Version 1.0 was published in 2010 and
    introduced the core concepts of token-based AuthN. It relies on the use of cryptographic
    signatures to secure communications. OAuth 2.0 was published in 2012 and is the
    most recent version since then. It is a significant evolution from OAuth 1.0,
    introducing a more simplified and flexible AuthZ framework. It relies on tokens,
    including access tokens and refresh tokens, to grant access and manage permissions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth至今发布了两个版本。版本1.0于2010年发布，并引入了基于令牌的AuthN核心概念。它依赖于使用加密签名来保护通信。OAuth 2.0于2012年发布，是自那时以来的最新版本。它是OAuth
    1.0的重要演变，引入了更简化和灵活的授权框架。它依赖于令牌，包括访问令牌和刷新令牌，用于授予访问权限和管理权限。
- en: 'Some key components need to be mentioned:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键组件需要提及：
- en: '**Resource owner**: The entity that owns the resource, typically the end user.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：拥有资源的实体，通常是最终用户。'
- en: '**Client**: The application or service that wants to access the user’s resources.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：希望访问用户资源的应用程序或服务。'
- en: '**Authorization server**: Manages the authorization process and issues access
    tokens after successful AuthN.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：管理授权过程，并在成功进行身份验证后发放访问令牌。'
- en: '**Resource server**: Hosts the protected resources (e.g., user photos) that
    the client wants to access.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：托管客户端希望访问的受保护资源（例如用户照片）。'
- en: '**Access token**: A credential representing the resource owner’s AuthZ.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：表示资源所有者授权的凭证。'
- en: '**Refresh token**: A credential used to obtain a new access token when the
    current one expires.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新令牌**：一种用于在当前访问令牌过期时获取新访问令牌的凭证。'
- en: 'There are a couple of ways we can detect when OAuth is being used by an API
    endpoint. The documentation is the first place to go and will save you time. Additionally,
    the presence of `Authorization: Bearer <token>` or `Authorization: Bearer <token
    type> <token>` will also reveal the AuthN type. Finally, you can adopt the generic
    *trial-and-error* method to send some dummy requests with invalid tokens and capture
    the outputs. The crAPI project does not make use of this. Instead, it applies
    something very similar that we will cover in the next section.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过几种方式检测 API 端点是否使用 OAuth。文档是最先要查看的地方，并且可以节省时间。此外，`Authorization: Bearer
    <token>` 或 `Authorization: Bearer <token type> <token>` 的存在也会揭示认证类型。最后，您可以采用通用的
    *试错* 方法，发送一些包含无效令牌的虚拟请求并捕获输出。crAPI 项目没有使用这种方法，而是采用了一种类似的方法，我们将在下一节中讨论。'
- en: One of the purposes of applying OAuth to a web application is to allow the user
    to leverage **Single Sign-On** (**SSO**). So, by having a single place to store
    the user’s credentials, there’s a single point that needs to be cared about encryption
    at rest at least for the users’ database. Then, by making use of a secure way
    to communicate the credentials, the same person can seamlessly log in to several
    different applications without needing to provide their credential pair every
    time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将 OAuth 应用于 Web 应用程序的目的之一是允许用户使用 **单点登录**（**SSO**）。通过在一个地方存储用户的凭证，至少对于用户的数据库来说，这个地方需要特别关注加密保护。然后，通过使用安全的方式传输凭证，相同的用户可以无缝地登录到多个不同的应用程序，而无需每次都提供凭证对。
- en: 'In the OAuth architecture, the **Identity Provider** (**IdP**) is the element
    responsible for storing and managing the credential pair. The OAuth 2.0 specification
    has a couple of different flows to provide a grant (a way to release an access
    token to the requesting application). When working on the application’s integration
    with the IdP, the developer needs to choose between the different flows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OAuth 架构中，**身份提供者**（**IdP**）是负责存储和管理凭证对的元素。OAuth 2.0 规范有几种不同的授权流程（即授予请求访问令牌给请求应用程序的方式）。在与
    IdP 集成时，开发者需要在不同的流程之间做出选择：
- en: '**Authorization Code Grant (ACG) flow**: This is commonly the best option since
    it includes a double-checking step. It requires a backend server and does some
    HTTP 302 redirection to a redirection endpoint where some code is provided. The
    app developer needs to confirm that the IdP’s provided endpoint is the same as
    the one that was used by the user.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权码授权（ACG）流程**：通常这是最佳选择，因为它包含了双重验证步骤。它需要一个后端服务器，并进行一些 HTTP 302 重定向到重定向端点，提供一些代码。应用程序开发者需要确认
    IdP 提供的端点与用户所使用的端点相同。'
- en: '**Implicit Grant Flow (IGF)**: Also known as client-side-only flow, this is
    the second most common option. In this case, there is no backend server. The app
    communicates directly with the IdP. User credentials are provided to get an OAuth
    access token. There is no client ID because it can be easily spoofed.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式授权流程（IGF）**：也称为仅客户端流程，这是第二常见的选项。在这种情况下，没有后端服务器。应用程序直接与身份提供者（IdP）通信。用户凭证被提供以获取
    OAuth 访问令牌。由于客户端 ID 容易被伪造，因此没有客户端 ID。'
- en: '**Client Credentials Grant (CCG) flow**: This is a niche use case and is rarely
    used. CCG can be used when the client application has resources with a service
    provider that are owned and consumed by the client application itself, and not
    by the end user. With CCG, the client app requests an access token on its own
    behalf, and then subsequently uses that access token to access protected resources
    it needs.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端凭证授权（CCG）流程**：这是一个小众的使用场景，通常不常见。CCG 可以在客户端应用程序拥有并使用与服务提供商的资源时使用，这些资源由客户端应用程序本身拥有和消费，而不是由最终用户拥有和消费。在
    CCG 流程中，客户端应用程序代表自己请求访问令牌，然后随后使用该访问令牌来访问它所需的受保护资源。'
- en: '**Password Grant flow**: This should not be used whatsoever. It’s very simple
    since it only requires that the demanding service informs the username and password
    through a regular POST request. This method is not allowed according to the OAuth
    2.0 Security Best Practices (link in the *Further* *reading* section).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码授权流程**：绝对不应该使用此流程。它非常简单，因为只需要通过常规的 POST 请求传递用户名和密码。根据 OAuth 2.0 安全最佳实践（见
    *进一步* *阅读* 部分的链接），此方法是不允许的。'
- en: There are some OAuth misconfigurations that could lead us to be successful in
    an attack against applications leveraging such a mechanism. The client ID and
    client secret should never be made available to end users. They should be protected
    just like a credential because they could allow a malicious customer to make calls
    to the IdP on behalf of a legitimate app and therefore impersonate the legitimate
    app. For OAuth 2.0, this by itself doesn’t allow for user impersonation because
    the attacker would still need access to user credentials. However, a malicious
    user could build a cloned application that gathers the credentials of users. This
    attack could be even easier by forming clickable links and putting them into a
    forum or email (with those links going back to an attacker’s backend server that
    has been configured with a stolen client ID/client secret).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 OAuth 配置错误可能导致我们成功攻击利用这种机制的应用程序。客户端 ID 和客户端密钥绝不应暴露给最终用户。它们应该像凭证一样受到保护，因为它们可能允许恶意用户代表合法的应用程序调用身份提供者
    (IdP)，从而冒充该合法应用程序。对于 OAuth 2.0，仅凭此并不能实现用户冒充，因为攻击者仍然需要获取用户凭证。然而，恶意用户可以构建一个克隆的应用程序，收集用户凭证。通过生成可点击的链接并将其放入论坛或邮件中（这些链接指向攻击者配置了被盗客户端
    ID/客户端密钥的后端服务器），此攻击会变得更加容易。
- en: 'One common attack against an OAuth-powered API is brute force. crAPI does not
    leverage such a mechanism, but let’s see what we can get with some simple Python
    code interacting with the vehicles’ parts website. The code was adapted from Tescum
    ([https://github.com/akimbo7/Tescum](https://github.com/akimbo7/Tescum)) and is
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种针对 OAuth 授权 API 的常见攻击方式是暴力破解。crAPI 并未采用这种机制，但让我们通过一些简单的 Python 代码与车辆部件网站进行交互，看看我们能得到什么。该代码改编自
    Tescum ([https://github.com/akimbo7/Tescum](https://github.com/akimbo7/Tescum))，具体如下：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now some explanations. This code would better run with threads as the original,
    but it only worked once on my test system! This aside, the previous version works
    well, and I added a time sleeping line to avoid overloading crAPI’s endpoint.
    During some login activities, I realized all bearer tokens started with `eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ`.
    Hence, this was assigned to a variable. This represents, in part, `{"alg":"RS256"}`
    after decoding from Base64\. The rest of the token is a random sequence of letters,
    digits, and the symbols `-`, `.`, and `_`. Some of the iterations generate less
    probable valid tokens, such as the ones ending with a sequence of two underscores,
    whereas others are more similar. You can run this thousands of times without success
    but eventually, it will succeed. It’s a simple suggestion for a brute-force script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做些解释。这个代码最好像原始版本那样使用线程运行，但在我的测试系统上只成功运行过一次！撇开这个不谈，之前的版本运行良好，我添加了一行睡眠时间来避免过度加载
    crAPI 的端点。在一些登录活动中，我发现所有的 bearer token 都以 `eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ` 开头。因此，我将其分配给一个变量。这部分解码后代表
    `{"alg":"RS256"}`，是从 Base64 解码得到的。令牌的其余部分是由字母、数字以及符号 `-`、`.` 和 `_` 组成的随机序列。某些迭代会生成不太可能有效的令牌，例如以一对下划线结尾的令牌，而其他的则更相似。你可以尝试数千次而没有成功，但最终它会成功。这是一个简单的暴力破解脚本建议。
- en: Some applications have simpler token life cycle management, storing them on
    a local database and never rotating or expiring them. While convenient, since
    it makes the code smaller and easier to maintain, it has inherent security problems.
    Depending on how protected the storage location is, this database could be leaked
    or exfiltrated because of an attack, and then all the application’s users’ credentials
    would be available. Not frequently rotating tokens is also a bad habit because
    some users may choose to locally store them in unsafe ways, which would make them
    available to a handful of client-side attacks, including phishing variations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序有更简单的令牌生命周期管理，将令牌存储在本地数据库中，并且从不轮换或过期。虽然这种做法方便，因为它让代码更简洁、更易于维护，但也存在固有的安全问题。根据存储位置的保护程度，这个数据库可能会因为攻击而被泄露或外泄，从而使应用程序所有用户的凭证暴露。令牌不经常轮换也是一个不良习惯，因为某些用户可能会选择以不安全的方式将其本地存储，这将使它们容易受到一些客户端攻击，包括钓鱼攻击的变种。
- en: 'OAuth is not exactly failproof. In late 2023, a failure in Google’s OAuth implementation
    was disclosed to the public many days after the company was notified and supposedly,
    they did not take any further action to fix it. The problem lies in how Google
    handles email addresses on its accounts, allowing different mailboxes with the
    same domain name to submit the same claim. The explanation is available here:
    [https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth并非绝对安全。 2023年末，有关Google OAuth实现的故障被披露给公众，该公司在被通知后多天未采取进一步的修复措施。 问题出在Google如何处理其帐户上的电子邮件地址，允许具有相同域名的不同邮箱提交相同的声明。
    解释在这里提供：[https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/](https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/)。
- en: Session tokens
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话令牌
- en: Session tokens have been a fundamental component of web security, evolving in
    tandem with the growth of web applications. Their history can be traced to the
    need to maintain user states securely across multiple interactions with a web
    server. A session token is a unique identifier assigned to a user upon successful
    AuthN. It serves as a reference to the user’s session data stored on the server.
    Typically, a session token is generated after the user logs in, and it is sent
    back to the client, often as a cookie. Subsequent requests from the client include
    this token, allowing the server to identify the user and retrieve their session
    data. This mechanism helps maintain stateful interactions in stateless HTTP, enhancing
    user experience and security.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 会话令牌一直是Web安全的基本组成部分，与Web应用程序的增长同步发展。 它们的历史可以追溯到在与Web服务器的多次交互中安全地维护用户状态的需求。 会话令牌是在成功的AuthN之后分配给用户的唯一标识符。
    它作为引用存储在服务器上的用户会话数据。 通常，用户登录后会生成会话令牌，并作为cookie发送回客户端。 客户端的后续请求包括此令牌，允许服务器识别用户并检索其会话数据。
    此机制有助于在无状态的HTTP中维护有状态的交互，增强用户体验和安全性。
- en: 'In a typical scenario, after a user logs in to a web application, a session
    token is generated, securely stored on the server, and sent to the client. This
    token is then included in subsequent requests, enabling the server to associate
    requests with a specific user’s session and deliver personalized content or maintain
    user-specific settings. Detecting the use of session tokens involves inspecting
    the communication between the client and the server. They are commonly found in
    HTTP cookies, identifiable by names such as `session_id` or `access_token`. Additionally,
    examining the headers of HTTP requests may reveal the presence of session tokens.
    Let’s observe how such tokens could be generated with a sample Flask application:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型情况下，用户登录到Web应用程序后，会生成一个会话令牌，并安全地存储在服务器上，然后发送到客户端。 这个令牌随后包含在后续的请求中，使服务器能够将请求与特定用户的会话关联起来，并提供个性化内容或维护用户特定的设置。
    检测会话令牌的使用涉及检查客户端和服务器之间的通信。 它们通常在HTTP cookie中找到，通过名称如`session_id`或`access_token`识别。
    此外，检查HTTP请求的标头可能会显示会话令牌的存在。 让我们通过一个示例Flask应用程序观察如何生成这样的令牌：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can interact with this application via Postman or, more simply, with a
    couple of `curl` commands. The app is waiting for a POST request as the login
    and subsequent GET requests. The login body must be provided in JSON format, so
    we need to instruct `curl` accordingly. Also, to guarantee the session cookie
    is correctly stored locally, we use the `--``cookie-jar` option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过Postman与此应用程序进行交互，或者更简单地使用几个`curl`命令。 应用程序正在等待POST请求作为登录和后续的GET请求。 登录体必须以JSON格式提供，因此我们需要相应地指示`curl`。
    另外，为了确保会话cookie正确地存储在本地，我们使用`--cookie-jar`选项：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `cookie.txt` file will have contents like these (font size reduced to facilitate
    comprehension):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie.txt`文件的内容将如下所示（字体大小缩小以便理解）：'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Session tokens are vulnerable to attacks if not handled securely. Common attacks
    include **session hijacking**, where an attacker steals a user’s session token
    and impersonates them. **Session fixation** is another threat, involving an attacker
    forcing a user to use a specific session token. You can easily discover whether
    some API endpoint is using this mechanism by using the developer mode of your
    preferred web browser. crAPI, for example, does not use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未能安全处理，会话令牌容易受到攻击。 常见的攻击包括**会话劫持**，其中攻击者窃取用户的会话令牌并冒充他们。 **会话固定**是另一种威胁，涉及攻击者强制用户使用特定的会话令牌。
    您可以通过使用首选Web浏览器的开发者模式轻松发现某些API端点是否使用此机制。 例如，crAPI不使用它。
- en: 'In this implementation we provided, the cookie was signed with the key present
    in the very beginning of the application’s source code. There is a very handy
    tool written in Golang called CookieMonster ([https://github.com/iangcarroll/cookiemonster](https://github.com/iangcarroll/cookiemonster))
    that you can leverage to discover this key. It makes use of a default wordlist
    but also supports your own list, which grants it an interesting power. Let’s test
    it with the cookie that was generated by our sample app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供的这个实现中，cookie是用应用程序源代码一开始的密钥签名的。有一个非常实用的用Go语言编写的工具叫做CookieMonster（[https://github.com/iangcarroll/cookiemonster](https://github.com/iangcarroll/cookiemonster)），你可以利用它来发现这个密钥。它使用一个默认的字典，但也支持你自己的字典，这赋予了它非常强大的功能。让我们用我们示例应用程序生成的cookie进行测试：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And *voilà*! The tool also has a convenient feature to resign cookies, which
    you can use to circumvent the API’s AuthZ mechanism by creating your own cookie
    with the corresponding token without having to authenticate first. However, it
    currently only works for Django apps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*瞧！* 该工具还有一个方便的功能，用于重新签发cookie，你可以利用它通过创建一个包含相应令牌的cookie来绕过API的授权（AuthZ）机制，而无需先进行认证。然而，目前它仅适用于Django应用程序：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JSON Web Tokens (JWTs)
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON Web Tokens（JWT）
- en: JWTs are one of the most modern ways to authenticate and authorize applications
    and users on the web. They emerged at the beginning of the 2010s and were developed
    as a proposal to the increasing number of applications showing up in the mobile
    arena. This universe has an inherent demand for secure AuthN and AuthZ mechanisms.
    JWTs are different from the previous methods we talked about since they decouple
    the user identity from server sessions. They offer a more secure way to carry
    the necessary data to different systems and applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JWT（JSON Web Tokens）是目前用于在网络上验证和授权应用程序及用户的最现代化方式之一。它们出现在2010年代初期，作为对移动领域日益增多的应用程序数量的提案。这一领域天生就有对安全的认证（AuthN）和授权（AuthZ）机制的需求。JWT与我们之前讨论的其他方法不同，因为它将用户身份与服务器会话解耦。它们提供了一种更安全的方式来将必要的数据传递到不同的系统和应用程序中。
- en: 'Every JWT has three parts:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JWT都有三个部分：
- en: '**Header**: Contains metadata about the token, including its format and signing
    algorithm.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：包含关于令牌的元数据，包括其格式和签名算法。'
- en: '**Payload**: Holds the actual claims about the user, such as username, roles,
    and permissions. This data is typically encoded in JSON format.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：包含关于用户的实际声明，如用户名、角色和权限。这些数据通常以JSON格式进行编码。'
- en: '**Signature**: A unique cryptographic fingerprint generated using a secret
    key, ensuring the token’s integrity and authenticity.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：使用密钥生成的独特加密指纹，确保令牌的完整性和真实性。'
- en: 'When you log in to a JWT-enabled system, the server generates a JWT containing
    your claims and signs it with a secret key. This token is then sent to your browser
    and securely stored. With every subsequent request, the browser automatically
    sends the token to the server. The server verifies the signature and decodes the
    payload, granting access based on the user’s claims. To detect the use of JWTs
    in an API endpoint, inspect the headers of incoming requests. JWTs are commonly
    transmitted in the `Authorization` header using the `Bearer` scheme, such as `Authorization:
    Bearer <token>`. This is the case with crAPI. Additionally, APIs might include
    information in their documentation or response headers indicating the use of JWTs
    for AuthN.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '当你登录到一个启用了JWT的系统时，服务器会生成一个包含你声明的JWT，并使用一个密钥对其进行签名。这个令牌随后会发送到你的浏览器并安全存储。每次后续请求时，浏览器会自动将令牌发送到服务器。服务器验证签名并解码有效载荷，基于用户的声明授予访问权限。要检测API端点中JWT的使用，可以检查传入请求的头部。JWT通常会通过`Authorization`头部，使用`Bearer`方案进行传输，如`Authorization:
    Bearer <token>`。crAPI便是如此。此外，API文档或响应头部可能会包含信息，指示使用JWT进行认证（AuthN）。'
- en: There are two tools that you should consider when dealing with JWTs. The first
    one is [https://jwt.io/](https://jwt.io/). The header, payload, and signature
    are highlighted in different colors to facilitate comprehension. Using Postman,
    `curl`, or the developer tools of your web browser, log in to crAPI and obtain
    the token that is generated as a response to a successful AuthN attempt (*Figure
    4**.1*). Store it somewhere.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理JWT时，有两个工具你应该考虑。第一个是[https://jwt.io/](https://jwt.io/)。头部、有效载荷和签名被用不同的颜色突出显示，以便于理解。通过使用Postman、`curl`或你的网页浏览器的开发者工具，登录到crAPI并获取生成的令牌，作为成功认证尝试的响应（*图4.1*）。将其存储在某个地方。
- en: '![Figure 4.1 – crAPI token generated after a successful login](img/B19657_04_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – crAPI成功登录后生成的令牌](img/B19657_04_01.jpg)'
- en: Figure 4.1 – crAPI token generated after a successful login
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 成功登录后生成的crAPI令牌
- en: 'Copy the token into the **Encoded** section of the JWT.io website. This will
    reveal all the details about the token, including which algorithm was used to
    generate it. Now, download the second tool, JWT Toolkit v2, available at [https://github.com/ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool).
    This is a Python script that can carry out several different tasks related to
    JWTs. Let’s see what it says about our recently copied token (part of the command
    was omitted for brevity):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将令牌复制到JWT.io网站的**Encoded**部分。这将显示关于令牌的所有细节，包括用于生成它的算法。现在，下载第二个工具JWT Toolkit
    v2，地址是[https://github.com/ticarpi/jwt_tool](https://github.com/ticarpi/jwt_tool)。这是一个Python脚本，可以执行与JWT相关的多种任务。让我们看看它对我们最近复制的令牌说了什么（部分命令已省略，简化演示）：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see the token was signed with RS256 and that there are four values in
    its payload: the `sub` (usually, the username), a role, and two timestamps, when
    the token was issued and its expiration date. JWTs may be signed using several
    algorithms, but it’s commonly more seen in one of these fashions: either with
    HS or without HS. The ones starting with HS are the most vulnerable simply because
    they are symmetric signing methods. They use **Hash-Based Message Authentication
    Code** (**HMAC**) combined with a **Secure Hash Algorithm** (**SHA**) hash. Because
    they are symmetric methods, it becomes more difficult to protect and share the
    signing key in scenarios when lots of peers are talking to each other. And, of
    course, once the key is compromised, a token can be forged and the AuthN/AuthZ
    system would not realize the difference from a legitimate token.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到令牌是使用RS256签名的，并且其负载中有四个值：`sub`（通常是用户名）、一个角色和两个时间戳，分别表示令牌的发行时间和过期时间。JWT可以使用多种算法进行签名，但通常见到的是以下两种方式之一：使用HS或不使用HS。以HS开头的JWT最容易受到攻击，因为它们是对称签名方法。它们使用**基于哈希的消息认证码**（**HMAC**）结合**安全哈希算法**（**SHA**）哈希。由于它们是对称方法，在多个对等方相互通信的场景中，保护和共享签名密钥变得更加困难。当然，一旦密钥被泄露，就可以伪造令牌，且AuthN/AuthZ系统无法识别与合法令牌的区别。
- en: On the other hand, RS-like JWTs use the **Rivest-Shamir-Adleman** (**RSA**)
    asymmetric algorithm, where the server signs the token with the private key and
    publishes the corresponding public key to allow the token verification by third
    parties. The system is as secure as the mechanisms applied to protect the private
    key. Obviously, these tokens are more secure, but their generation and verification
    might be slower since an asymmetric algorithm is in place.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类似RS的JWT使用**Rivest-Shamir-Adleman**（**RSA**）非对称算法，服务器使用私钥签署令牌，并发布相应的公钥以便第三方验证令牌。该系统的安全性取决于用于保护私钥的机制。显然，这些令牌更安全，但由于使用了非对称算法，其生成和验证可能会较慢。
- en: 'However, even systems with RS implementations might be vulnerable to JWT attacks.
    There are a couple of ways to test whether there is some flaw. Making use of our
    friend `jwt_tool`, let’s run it against our crAPI deployment just to see whether
    it can find some vulnerability. After recording the AuthZ token you received when
    logging in, type the following (single line). `/workshop/api/shop/products` is
    a crAPI endpoint:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是采用RS实现的系统，也可能会受到JWT攻击的威胁。有几种方法可以测试是否存在漏洞。借助我们的朋友`jwt_tool`，我们可以对crAPI部署进行测试，看看它是否能发现漏洞。在记录下你登录时收到的AuthZ令牌后，输入以下命令（单行命令）。`/workshop/api/shop/products`是crAPI的一个端点：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: No vulnerabilities were found. The tool was not successful while attacking the
    original token. It suggests using `hashcat` to try some brute-force attack. You
    may try it, but you’ll find out that hashcat complains about the token size, saying
    it’s too big.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发现漏洞。工具在攻击原始令牌时未成功。它建议使用`hashcat`尝试一些暴力破解攻击。你可以试试看，但会发现hashcat会抱怨令牌的大小，表示它太大。
- en: 'APIs that implement JWTs may have an endpoint available at `/.well-known/jwks.json`
    or `/jwks.json`. The sole purpose of such endpoints is to publicize the public
    keys used to sign the tokens generated by the API. `http://localhost:8888/.well-known/jwks.json`)
    and copy its contents. It is a JSON structure with a series of keys and values,
    something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现JWT的API可能在`/.well-known/jwks.json`或`/jwks.json`路径下提供一个端点。这些端点的唯一目的是公开用于签署API生成的令牌的公钥。你可以访问`http://localhost:8888/.well-known/jwks.json`并复制其内容。它是一个JSON结构，包含一系列的键和值，类似于这样：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We know that the user’s role is `user`, which makes us infer that this is a
    regular powerless persona. Our job now is to forge a token that makes this user
    an admin on crAPI. We can’t use the `-C` option of `jwt_tool` to crack the token
    since it was not signed with an HMAC algorithm. If a regular user’s role is called
    `user`, maybe an admin role is `admin`. We will check whether crAPI is vulnerable
    to the key confusion vulnerability, which consists of deceiving the web server
    by providing HS256 as a signing algorithm and checking whether the server’s token
    verification function is naïve enough to treat the provided public key as the
    HMAC secret. For the next test, you should consider using **Burp Suite** and installing
    the **JWT** and **JWT Editor** extensions. We will do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道用户的角色是`user`，这使我们推测这是一个普通的无权角色。我们的任务现在是伪造一个令牌，使该用户成为crAPI的管理员。由于该令牌不是使用HMAC算法签名的，因此我们不能使用`jwt_tool`的`-C`选项来破解令牌。如果普通用户的角色被称为`user`，也许管理员角色是`admin`。我们将检查crAPI是否容易受到密钥混淆漏洞的攻击，即通过提供HS256作为签名算法来欺骗Web服务器，并检查服务器的令牌验证功能是否足够天真，将提供的公钥当作HMAC密钥。接下来的测试，你应该考虑使用**Burp
    Suite**并安装**JWT**和**JWT Editor**扩展。我们将进行以下操作：
- en: Obtain the server’s public key (which we’ve already got).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务器的公钥（我们已经获得）。
- en: Convert the key into an appropriate format.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密钥转换为适当的格式。
- en: Forge a new JWT by setting the “alg” header to HS256.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将“alg”头设置为HS256，生成一个新的JWT。
- en: Sign the new token with HS256 and use the public key as the symmetric secret.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HS256签署新的令牌，并将公钥用作对称密钥。
- en: 'Just follow this sequence of steps, and you will be good:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只需按照以下步骤操作，就可以完成：
- en: Open Burp Suite and install the previously mentioned extensions. You can do
    this via the **Extensions** | **BApp** **Store** tabs.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Burp Suite并安装前述的扩展。你可以通过**Extensions** | **BApp** **Store**选项卡进行安装。
- en: Click on the **JWT Editor** extension and then click on **New** **RSA Key**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**JWT Editor**扩展，然后点击**New** **RSA Key**。
- en: On this window, paste the JWKS contents inside the `key` block (when pasting,
    suppress the `keys` part and the surrounding curly brackets).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此窗口中，将JWKS内容粘贴到`key`块内（粘贴时，抑制`keys`部分和周围的花括号）。
- en: Next, select the **PEM** radio button. This will reveal the public key in PEM
    format.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**PEM**单选按钮。这将显示PEM格式的公钥。
- en: Copy this text and click the **OK** button.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制此文本并点击**OK**按钮。
- en: Move to the **Decoder** extension, paste the PEM public key, click the **Encode
    as…** button, and choose **Base64**. Copy the results.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Decoder**扩展，粘贴PEM公钥，点击**Encode as...**按钮，然后选择**Base64**。复制结果。
- en: Return to the **JWT Editor** extension and click on **New Symmetric Key**. This
    will open a window with **Random secret** selected by default.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**JWT Editor**扩展并点击**New Symmetric Key**。这将打开一个窗口，默认选中**Random secret**选项。
- en: Just click on the **Generate** button.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需点击**Generate**按钮。
- en: Replace the contents of the `k` parameter with the text you copied from the
    **Decoder** extension.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用从**Decoder**扩展复制的文本替换`k`参数的内容。
- en: Click **OK**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**OK**。
- en: Configure your web browser to use Burp Suite as a proxy. By default, Burp Suite
    runs on localhost port `8080`, but this is adjustable. Log in to crAPI with a
    valid username and password. This will generate a valid token. Switch to the `/identity/api/v2/vehicle/vehicles`.
    Select this request, right-click on it, and choose **Send to repeater**. Open
    **Repeater**. You will see the **JSON Web Tokens** tab beside the **Raw** and
    **Hex** tabs. Click on it. Change the algorithm to **HS256** and the role to **admin**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的Web浏览器，将Burp Suite用作代理。默认情况下，Burp Suite在localhost端口`8080`上运行，但可以调整。用有效的用户名和密码登录到crAPI。这将生成一个有效的令牌。切换到`/identity/api/v2/vehicle/vehicles`。选择此请求，右键点击它，选择**Send
    to repeater**。打开**Repeater**。你将在**Raw**和**Hex**标签旁边看到**JSON Web Tokens**标签。点击它。将算法更改为**HS256**，将角色更改为**admin**。
- en: 'Now click on the `/workshop/api/shop/products`, and send the request. It fails
    with an `Invalid JWT Token` message. This probably means the JWT implementation
    of crAPI is not vulnerable to the key confusion vulnerability. However, if you
    change the endpoint to `/identity/api/v2/user/dashboard`, crAPI will return a
    valid response with a JSON structure stating our original role (*Figure 4**.2*):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击`/workshop/api/shop/products`，并发送请求。它会以`Invalid JWT Token`消息失败。这可能意味着crAPI的JWT实现没有受到密钥混淆漏洞的影响。但是，如果你将端点更改为`/identity/api/v2/user/dashboard`，crAPI将返回一个有效的响应，并提供一个包含我们原始角色的JSON结构（*图4.2*）：
- en: '![Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint
    only](img/B19657_04_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – crAPI仅接受伪造的令牌用于用户仪表板端点](img/B19657_04_02.jpg)'
- en: Figure 4.2 – crAPI accepting the forged token for the user dashboard endpoint
    only
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – crAPI仅接受伪造的令牌用于用户仪表板端点
- en: Session tokens, bearer tokens, and JWTs serve similar purposes but differ in
    their implementations. Session tokens are typically stored on the server, and
    their corresponding data is stored on the server side. Bearer tokens are self-contained,
    often used in OAuth for API AuthZ, while JWTs are a type of bearer token with
    additional features such as claims and digital signatures, making them versatile
    for secure data exchange. Session tokens are more closely tied to user sessions
    and are often used in web applications to maintain user state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 会话令牌、承载令牌和JWT在目的上相似，但在实现上有所不同。会话令牌通常存储在服务器上，其对应的数据也存储在服务器端。承载令牌是自包含的，通常用于OAuth进行API授权，而JWT是一种承载令牌，具有额外的特性，如声明和数字签名，使其在安全数据交换中更为多用途。会话令牌与用户会话紧密相关，常用于Web应用程序中以维持用户状态。
- en: In essence, while session tokens are specific to user sessions in web applications,
    bearer tokens and JWTs are broader concepts used for various AuthN and AuthZ purposes,
    each offering unique advantages and considerations in different contexts. Understanding
    their characteristics is crucial for secure and effective implementation in web
    development and API security.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，虽然会话令牌是特定于Web应用程序中的用户会话的，但承载令牌和JWT是用于各种身份认证（AuthN）和授权（AuthZ）目的的更广泛的概念，每种都有其独特的优势和注意事项，在不同的上下文中需要做出权衡。理解它们的特点对于Web开发和API安全中的安全有效实现至关重要。
- en: In the next section, we will look at how we can discover and implement AuthN
    and AuthZ with weak credentials and default accounts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何发现并实现使用弱凭证和默认账户的身份认证和授权。
- en: Testing for weak credentials and default accounts
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试弱凭证和默认账户
- en: When reading this section’s title, as an attentive reader, you probably drew
    a parallel with several routers, access points, network bridges, and an infinite
    number of **Internet of Things** (**IoT**) devices that are out there. Unfortunately,
    depending on the customer’s needs, they are just briefly configured and put to
    work, almost as a “plug-and-play” box. As a matter of fact, some are designed
    to be installed in exactly this way. The problem is that some of those types of
    equipment are somehow meant to be intelligent, which would require more complex
    software running and the **requirement for credentials**. As many users/customers
    simply don’t care about how the product works, a complete universe of possibilities
    opens up to explore default credentials.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本节标题时，作为一个细心的读者，你可能会联想到许多路由器、接入点、网络桥接设备，以及无数的**物联网**（**IoT**）设备。遗憾的是，根据客户需求，这些设备通常只是被简单配置后投入使用，几乎就像一个“即插即用”的盒子。实际上，一些设备设计的初衷正是如此。问题在于，这些设备中的某些类型实际上是被设计为智能设备，这就需要运行更复杂的软件以及**凭证要求**。由于许多用户/客户根本不关心产品如何工作，探索默认凭证的可能性几乎是无限的。
- en: The same can happen with APIs. Sometimes, the developer forgets to delete a
    credential pair used just for testing, sometimes it’s hardcoded somewhere in the
    code, which resides in a public repository, and sometimes powerful permissions
    are assigned to these credentials, which is the worst thing that can happen on
    an API. In other scenarios, the default accounts are not there, but the credentials,
    purposefully or not – yes, sometimes there could be malicious intent – are weak
    in the sense of being poorly secure. Simple and/or short passwords, badly implemented
    pseudorandom number generators, small seeds and salts, vulnerable hashing, and
    encryption algorithms, to name a few, are some examples of how weak credentials
    may be created and spread.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情也可能发生在API上。有时，开发者忘记删除仅用于测试的凭证对，有时凭证是硬编码在代码中的，而这些代码存储在公开的代码库中，还有时这些凭证被赋予了强大的权限，这是API中最糟糕的情况。其他情况下，默认账户可能并不存在，但凭证无论是有意的还是无意的——是的，有时可能带有恶意意图——它们的安全性较差。简单和/或短的密码、糟糕实现的伪随机数生成器、小的种子和盐值、脆弱的哈希算法和加密算法，都是弱凭证创建和传播的示例。
- en: Brute-force attacks
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴力攻击
- en: This is possibly the first topic that comes up in any discussion about application
    credentials. If you search Google for something such as *the most used passwords*
    or *common passwords*, or combinations of such terms, you will be surprised by
    the number of results. In the *Further reading* section of this chapter, you’ll
    find a list of catalogs of passwords, some of them with gigs of size, that can
    be leveraged.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何关于应用程序凭证讨论中可能会首先出现的话题。如果你在 Google 上搜索类似于 *最常用的密码* 或 *常见密码*，或者这些词汇的组合，你会对搜索结果的数量感到惊讶。在本章的
    *进一步阅读* 部分，你会找到一些密码目录的列表，其中有些目录的大小达到吉字节，可以用来进行测试。
- en: 'In the context of API pentesting, brute-force attacks target AuthN endpoints
    where credentials are required for access. You may automate the process using
    specialized tools that streamline the brute-force process by enabling you to specify
    username and password lists, target endpoints, and define attack parameters. Some
    tools that will be very handy are hashcat, Medusa, and Hydra. Let’s first try
    to use Hydra against crAPI. But first, we need to understand how crAPI handles
    AuthN attempts. Either using Burp Suite or ZAP, or even the developer tools of
    your web browser, open the login page and type in any email address and password.
    crAPI will obviously reject your attempt, but the important part is how the request
    is sent. You will discover something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 渗透测试的上下文中，暴力破解攻击针对的是需要凭证进行访问的 AuthN 端点。你可以使用专门的工具来自动化这个过程，这些工具可以简化暴力破解过程，允许你指定用户名和密码列表、目标端点，并定义攻击参数。一些非常有用的工具包括
    hashcat、Medusa 和 Hydra。让我们先尝试使用 Hydra 对 crAPI 进行攻击。但在此之前，我们需要了解 crAPI 如何处理 AuthN
    尝试。可以使用 Burp Suite、ZAP，或者你的浏览器的开发者工具，打开登录页面并输入任何电子邮件地址和密码。crAPI 会显然拒绝你的尝试，但重要的是请求是如何发送的。你将会发现类似以下内容：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to respect several of these fields when applying Hydra so crAPI’s backend
    can correctly process our attempts. The application is expecting the input to
    be in JSON format. Likewise, the error output will be in JSON as well:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Hydra 时，我们需要遵守其中的多个字段，以便 crAPI 的后台能够正确处理我们的尝试。应用程序期望输入为 JSON 格式。同样，错误输出也会是
    JSON 格式：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, try this with a valid credential pair and observe the corresponding response.
    The answer is the JWT among other parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用有效的凭证对进行测试，并观察相应的响应。答案是 JWT 及其他参数：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, pick all the request parameters that were sent as part of the successful
    login activity. You’ll need almost all of them to build the command. Regardless
    of the tool you used to capture the request, you’ll have the following parameters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择所有作为成功登录活动一部分发送的请求参数。你几乎需要所有这些参数来构建命令。不管你使用了什么工具来捕获请求，你都会得到以下参数：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Hydra parallelizes the brute-force attempts for the sake of optimizing your
    search. Considering `admin` as a possible username (Hydra replaces `http` with
    `http-get` or `http-post`, depending on the type of verb you want to use), and
    a text file with passwords (`passlist.txt`), run the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Hydra 会并行化暴力破解尝试，以优化你的搜索。假设 `admin` 是一个可能的用户名（Hydra 会根据你选择的动词类型将 `http` 替换为
    `http-get` 或 `http-post`），并使用一个包含密码的文本文件（`passlist.txt`），执行以下命令：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s explain some of the parameters first:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先解释一些参数：
- en: '`-l`: Expects you to provide the sole username to test against'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`：要求你提供唯一的用户名以进行测试。'
- en: '`-v`/`-V`: Activates the verbose mode'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`/`-V`：启用详细模式。'
- en: '`-P`: Expects a password list file to be provided'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`：要求提供一个密码列表文件。'
- en: '`-s`: If the target is not using one of the default ports (`80` or `443`),
    you need to specify the port'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：如果目标没有使用默认端口（`80` 或 `443`），你需要指定端口。'
- en: '`http-post`: The Hydra module to use'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-post`：需要使用的 Hydra 模块。'
- en: Everything inside the double quotes is either part of the headers or the request
    body. The `"/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}"`
    part comprises the API endpoint plus the JSON structure crAPI expects to receive.
    Here, `^USER^` is replaced by the login name you provided with `-l`, whereas `^PASS^`
    is replaced with the passwords inside the `passlist.txt` file, one per attempt.
    After this, we specified what is expected to be received with a successful attempt
    (the `S` key). As we can see, when a successful login happens, we get access to
    a lot of data, including a `token` word followed by the corresponding JWT. All
    elements beginning with `H=` are part of the header. Also, observe the backslash
    character (`\`). It serves to escape the immediately following character so Hydra
    can process it rather than thinking it is, for example, the closing quote mark
    of the request or a semicolon separator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号中的所有内容要么是标题的一部分，要么是请求体的一部分。`"/identity/api/auth/login:{\"email\"\:\"^USER^\",\"password\"\:\"^PASS^\"}"`
    部分包括了 API 端点以及 crAPI 期望接收的 JSON 结构。在这里，`^USER^` 会被你通过 `-l` 提供的登录名替换，而 `^PASS^`
    会被 `passlist.txt` 文件中的密码逐一替换。接着，我们指定了在登录成功时期望接收到的内容（`S` 键）。如我们所见，当成功登录时，我们能够访问大量数据，包括一个
    `token` 字样，后跟相应的 JWT。所有以 `H=` 开头的元素都是头部的一部分。此外，请注意反斜杠字符（`\`）。它用于转义紧随其后的字符，以便 Hydra
    能够正确处理，而不是将其误认为请求的结束引号或分号分隔符。
- en: 'We have found nothing so far. Let’s try with a login file instead, where there
    will be several usernames. This file has lines such as `admin`, `administrator`,
    `Administrator`, `admin123`, and `4dm1n`. Of course, the more lines you have in
    both files, the lengthier the task will be. Better to leave this running while
    you do something else. Hydra also allows you to specify how many threads you’d
    like to run at the same time. The following command fits in a single line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们什么也没有找到。让我们改用一个包含多个用户名的登录文件来尝试。这个文件包含如 `admin`、`administrator`、`Administrator`、`admin123`
    和 `4dm1n` 这样的行。当然，文件中行数越多，任务就会越长。最好在进行其他操作时让它继续运行。Hydra 还允许你指定希望同时运行的线程数。以下命令可以写成一行：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Observe the parallel threads (16 by default) running the attack:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 观察并行线程（默认 16 个）正在执行攻击：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The tool managed to find a valid username/password pair:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具成功找到了一个有效的用户名/密码组合：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Bear in mind that methods like the one used by Hydra can be detected by the
    API backend itself or more easily by some other protection layer, such as a WAF.
    The tool generates thousands or even millions of requests to the target endpoint,
    which could be measured and blocked by API endpoints that have rate-limiting protections.
    Let’s check, for example, how a crAPI log entry looks like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，像 Hydra 使用的方法可能会被 API 后端本身检测到，或者更容易被其他保护层，如 WAF，检测到。该工具会生成成千上万甚至百万次请求发送到目标端点，这些请求可能会被启用了速率限制保护的
    API 端点进行衡量和阻止。让我们检查一下，举个例子，crAPI 日志条目是如何显示的：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To circumvent this, you should run multiple instances of Hydra from different
    IP addresses. Either launch several containers, preferably with separate network
    segments, or create a controlled environment with spoofed IP addresses. Of course,
    never spoof valid IP addresses on the internet. We are security professionals,
    not criminals.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规避这一点，你应该从不同的 IP 地址运行多个 Hydra 实例。可以启动多个容器，最好使用独立的网络段，或者创建一个具有伪造 IP 地址的受控环境。当然，切记不要在互联网上伪造有效的
    IP 地址。我们是安全专家，不是罪犯。
- en: Other valid tools for brute-force explorations are Medusa and ncracker. However,
    these were not as successful on the tests that I conducted to write this chapter,
    or they did not have the same kind of performance as Hydra. You must never forget
    the wordlists when running these types of attacks. Combining them and mixing and
    matching them are all valid ways of getting closer to the credentials some API
    endpoint apply.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有效的暴力破解工具包括 Medusa 和 ncracker。然而，在我为撰写本章所做的测试中，它们并不如 Hydra 成功，或者它们的性能没有 Hydra
    好。运行这些类型的攻击时，千万不要忘记使用字典文件。将它们结合使用、混合搭配是接近某些 API 端点凭证的有效方式。
- en: 'There’s a very interesting utility called **Common User Passwords Profiler**
    (**CUPP**; [https://github.com/Mebus/cupp](https://github.com/Mebus/cupp)). It
    facilitates downloading big password lists from the internet. It also has an interactive
    mode that creates lists based on questions it asks you about the target/victim.
    An advantage is that this Python code does not require any third-party module,
    allowing you to explore it right after downloading it. Let’s carry out a test
    with crAPI. We’ll download default usernames and passwords from AlectoDB (currently
    consolidated under [https://github.com/yangbh/Hammer/tree/master/lib/cupp](https://github.com/yangbh/Hammer/tree/master/lib/cupp)).
    Clone CUPP’s repository and type the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有趣的工具叫做**常见用户密码分析器**（**CUPP**；[https://github.com/Mebus/cupp](https://github.com/Mebus/cupp)）。它可以帮助你从互联网上下载大型密码列表。它还有一个交互模式，会根据你回答的问题来生成针对目标/受害者的密码列表。一个优点是，这段Python代码不需要任何第三方模块，下载后你就可以直接使用。我们来对crAPI进行测试。我们将从AlectoDB下载默认的用户名和密码（目前已合并至[https://github.com/yangbh/Hammer/tree/master/lib/cupp](https://github.com/yangbh/Hammer/tree/master/lib/cupp)）。克隆CUPP的仓库，并输入以下命令：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You just got the two text files with usernames and passwords. You’ll see more
    about this topic in [*Chapter 6*](B19657_06.xhtml#_idTextAnchor102), *Error Handling
    and Exception Testing*, but there’s another tool called `Wfuzz` ([https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz))
    that you can install in multiple ways and helps with carrying out brute-force
    attacks leveraging password lists. I installed it through `pip` and tested it
    against crAPI with the just downloaded usernames and passwords. The results follow:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚获得了包含用户名和密码的两个文本文件。你将在[*第6章*](B19657_06.xhtml#_idTextAnchor102)《错误处理与异常测试》中了解更多相关内容，但还有一个名为`Wfuzz`的工具（[https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)），你可以通过多种方式安装它，帮助进行利用密码列表进行暴力破解攻击。我通过`pip`安装了它，并使用刚下载的用户名和密码对crAPI进行了测试。以下是结果：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Observe the request numbers in the `ID` column. They are not in order. That’s
    because `Wfuzz` organizes them in different threads so multiple requests can be
    sent at once. We didn’t manage to find a match on this attempt, but this does
    not reduce the tool’s effectiveness. You can combine it with other wordlists.
    `Wfuzz` is very convenient as it attempts multiple combinations of usernames and
    passwords against the target and shows all successful attempts. Of course, if
    you already know either the username or the password, this will tremendously reduce
    the program’s effort. A reference to a list of links can be found at the end of
    the chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`ID`列中的请求编号。它们并不是按顺序排列的。原因是`Wfuzz`将它们组织在不同的线程中，这样可以一次发送多个请求。我们这次没有找到匹配的结果，但这并不影响工具的有效性。你可以将它与其他词典结合使用。`Wfuzz`非常方便，因为它会尝试多种用户名和密码组合，并显示所有成功的尝试。当然，如果你已经知道用户名或密码之一，这将大大减少程序的工作量。关于链接列表的参考，可以在章节末尾找到。
- en: Common credentials and default accounts
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见凭据和默认账户
- en: You may use the knowledge you acquired in the previous chapter, on topics such
    as OSINT techniques and other enumeration tips, to get your hands on some default
    API credentials. The API documentation itself is a valid source for default credentials.
    In your pentesting endeavors, you may discover a website leveraging a backend
    with a marketplace API provider. Some providers have default credentials, including
    administrative ones, for their products. Hence, by either inspecting the documentation
    or other active or passive methods, you may discover a couple of credential pairs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用在上一章中获得的知识，例如OSINT技巧和其他枚举方法，来获得一些默认的API凭据。API文档本身是默认凭据的有效来源。在你的渗透测试工作中，你可能会发现一个利用市场API提供商后端的网站。一些提供商的产品有默认凭据，包括管理员凭据。因此，借助检查文档或其他主动或被动方法，你可能会发现一对凭据。
- en: Using the same approach as the previous sub-section, start by googling *default
    passwords* or *common passwords*. A list generated in 2024 is available at the
    end of the chapter. Some system administrators still run their API backends with
    default admin usernames such as `admin` or `administrator`. Even websites running
    popular `admin` or `administrator` would be the superuser’s username. Localized
    versions of it, such as `administrador`, are also valid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与前一小节相同的方法，首先在Google上搜索*默认密码*或*常见密码*。在本章末尾可以找到2024年生成的密码列表。一些系统管理员仍然使用默认的管理员用户名，如`admin`或`administrator`来运行他们的API后台。即使是运行流行的`admin`或`administrator`网站，它们也可能是超级用户的用户名。其本地化版本，如`administrador`，也是有效的。
- en: 'Of course, you can use Hydra, Medusa, or Burp Suite, with its `repeater` or
    `intruder` features, or even do this via your web browser, but you can also automate
    your effort by crafting a script with a simple loop such as the following one:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用Hydra、Medusa或Burp Suite的`repeater`或`intruder`功能，甚至通过网页浏览器来做这件事，但你也可以通过编写一个简单的循环脚本来自动化你的工作，比如以下这个：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, the `wordlist` filename is put inside the `$passwords`
    variable. Then, I set the `$MAXWAIT` variable to `2`. Inside the `while` loop,
    I executed the `curl` command and appended its output inside the `output.txt`
    file. Then, I put the code to sleep for a random number of seconds between 0 and
    2\. The `$RANDOM` variable is built into Bash and returns a random integer between
    0 and 32,767\. That integer is then divided by `$MAXWAIT` and the remainder is
    the number of seconds to put the script to sleep. This is just to avoid being
    throttled by some API rate-limiting control. The script finished with the end
    of the `while` loop reading the `wordlist.txt` file line by line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`wordlist`文件名被放入`$passwords`变量中。然后，我将`$MAXWAIT`变量设置为`2`。在`while`循环内，我执行了`curl`命令，并将其输出附加到`output.txt`文件中。然后，我让代码休眠一个介于0到2秒之间的随机数。`$RANDOM`变量是Bash内置的，返回一个介于0到32,767之间的随机整数。该整数然后被`$MAXWAIT`除，余数就是脚本休眠的秒数。这只是为了避免被某些API的速率限制控制限制。脚本在`while`循环结束时读取`wordlist.txt`文件并逐行处理。
- en: Doing the opposite is also valid, and is a technique called **password spraying**.
    It consists of testing a single password or a small set of passwords against multiple
    user accounts. It is quite useful for applications that generate the same initial
    password for all users and suggest users change the password after the first login.
    Solely relying on the human factor is not exactly a security best practice. To
    carry out password spraying, there are some tools, such as CrackMapExec, Patator,
    and Metasploit (which is an umbrella tool with tons of plugins). Let’s consider
    Patator for this task.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 做相反的操作也是有效的，这是一种叫做**密码喷洒**的技术。它的工作原理是针对多个用户账户测试一个单一密码或一小组密码。它对于那些为所有用户生成相同初始密码并建议用户在第一次登录后更改密码的应用程序非常有用。单纯依赖人类因素并不完全符合安全最佳实践。要进行密码喷洒，可以使用一些工具，如CrackMapExec、Patator和Metasploit（它是一个包含众多插件的工具）。让我们考虑使用Patator来完成这个任务。
- en: If you are following this chapter after having installed the lab environment
    mentioned in [*Chapter 2*](B19657_02.xhtml#_idTextAnchor028), getting Patator
    running on top of Ubuntu is as straightforward as running `sudo apt-get update`;
    `sudo apt-get install patator`. Just be mindful that this is a package with lots
    of dependencies. When I wrote this chapter, the software and its dependencies
    were consuming around 300 MB of disk space.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装了本章提到的实验环境后跟随本章，那么在Ubuntu上运行Patator就像执行`sudo apt-get update`；`sudo apt-get
    install patator`一样简单。只需注意，这个包有很多依赖项。当我编写本章时，软件及其依赖项大约占用300MB的磁盘空间。
- en: 'After digging a lot and discovering that version 0.9 of Patator (the one used
    to write this chapter) seems to not correctly handle HTTP request headers, I ended
    up with the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入挖掘并发现版本0.9的Patator（用于编写本章的版本）似乎无法正确处理HTTP请求头后，我最终得到了以下结果：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Just to keep things consistent, the preceding command was typed on a single
    line. Now, let me explain to you all the parameters that are not self-explanatory:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了保持一致性，前面的命令是单行输入的。现在，让我解释一下所有不太直观的参数：
- en: '`http_fuzz`: Patator has a considerable number of modules. This is the one
    to play with HTTP targets. As we were trying to authenticate against crAPI (an
    HTTP REST API implementation), it is the best choice.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http_fuzz`：Patator有很多模块，这是用于处理HTTP目标的模块。由于我们尝试对crAPI（一个HTTP REST API实现）进行身份验证，它是最佳选择。'
- en: '`method=POST`: We need to tell `http_fuzz` which HTTP method we will use. To
    authenticate, crAPI expects the request to be sent using POST.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method=POST`：我们需要告诉 `http_fuzz` 使用哪种 HTTP 方法。为了进行身份验证，crAPI 期望请求使用 POST 方法发送。'
- en: '`resolve=domain:127.0.0.1`: This parameter needed to be added because Patator
    was getting confused with the URL. Since my crAPI implementation is running on
    my localhost, I’m just telling Patator that, when resolving the hostname, consider
    it as `127.0.0.1`. I know, it’s nonsense, but it was the way I found to make Patator
    work with my localhost URL.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolve=domain:127.0.0.1`：需要添加这个参数，因为 Patator 在处理 URL 时有些困惑。由于我的 crAPI 实现运行在本地主机上，我只是告诉
    Patator 在解析主机名时，将其视为 `127.0.0.1`。我知道这看起来不合逻辑，但这是我找到的让 Patator 与本地主机 URL 配合工作的方式。'
- en: '`autourl_encode=0`: Instructs Patator to encode all the body’s characters before
    sending the request. This is incredibly useful especially when you are dealing
    with non-alphanumeric characters, such as the ones used by the JSON structure
    explained in the next point.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autourl_encode=0`：指示 Patator 在发送请求之前对所有请求体中的字符进行编码。这在处理非字母数字字符时非常有用，比如接下来会解释的
    JSON 结构中使用的字符。'
- en: '`body=''{"email": "FILE0", "password": "Admin!123"}''`: This is the JSON structure
    representing the login. I put the default crAPI admin password for the sake of
    showing you what happens when the tool is successful. `FILE0` indicates that the
    email will be replaced with the lines of a file that will be later specified.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body=''{"email": "FILE0", "password": "Admin!123"}''`：这是表示登录的 JSON 结构。我使用了默认的
    crAPI 管理员密码来演示当工具成功时的情况。`FILE0` 表示邮箱地址会被后面指定的文件中的行替换。'
- en: '`0=./userlist.txt`: This matches the previous `FILE0` item. The `userlist.txt`
    file contains all usernames, one per line, taking the role of the login credential.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0=./userlist.txt`：这对应之前的 `FILE0` 项。`userlist.txt` 文件包含了所有用户名，每行一个，作为登录凭据。'
- en: '`header=@fuzzerheader.txt`: The `fuzzerheader.txt` file contains the required
    headers for the crAPI login request to work. This will change depending on how
    your target API endpoint was written and, as we discussed before, you need to
    enumerate the endpoint first so you can get to know its details.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header=@fuzzerheader.txt`：`fuzzerheader.txt` 文件包含了 crAPI 登录请求所需的头信息。这个内容会根据目标
    API 端点的实现而有所不同，正如我们之前讨论过的，首先你需要枚举该端点，了解其细节。'
- en: 'The `userlist.txt` file contents are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`userlist.txt` 文件内容如下：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And the `fuzzerheader.txt` file has the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`fuzzerheader.txt` 文件包含如下内容：'
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Observe the columned output of the Patator command previously executed. Each
    line corresponds to one of the combinations of username and password. In this
    example, a single password was considered, but you can alternatively use another
    text file (such as a wordlist) to feed the tool. In the `code` section, you can
    see the HTTP code sent as a response. The `size:clen` column shows the number
    of characters received in the response: the total size and the content length,
    respectively. The latter is the one that interests us. Time is self-explanatory.
    `Candidate` assumes each combination of username and password. If we were trying
    multiple passwords, the lines would be something such as `username:password`.
    `Num` corresponds to the combination number. Observe Patator does not necessarily
    follow the order in the `userlist.txt` file. Although `admin@domain.com` is on
    the first line, it shows up as on the third output line. Finally, the message
    with the code again.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 观察之前执行的 Patator 命令的列状输出。每一行对应用户名和密码的一个组合。在这个例子中，只考虑了一个密码，但你也可以使用另一个文本文件（如字典文件）来提供给工具。在
    `code` 部分，你可以看到作为响应发送的 HTTP 代码。`size:clen` 列显示了响应中接收到的字符数：分别是总大小和内容长度。后者才是我们关心的。时间一目了然。`Candidate`
    假设每一个用户名和密码组合。如果我们尝试多个密码，行内容会是类似 `username:password` 的形式。`Num` 对应组合的编号。观察到 Patator
    并不一定按 `userlist.txt` 文件中的顺序执行。虽然 `admin@domain.com` 在第一行，但它出现在第三行的输出中。最后再次显示的是带有代码的消息。
- en: We are looking for the 200 codes, which denote the attempt was successful. In
    our case, it happened on the fourth output line, where `size` was substantially
    bigger compared to the other lines. Nevertheless, the size difference alone does
    not state anything at all. You should focus on all lines with the `200 response`
    code. Be warned that false positives can also happen. Hence, separate all usernames
    and passwords whose attempts seem to have been successful and investigate more.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在寻找 200 响应码，这表示尝试是成功的。在我们的案例中，它发生在第四行输出中，其中 `size` 相比其他行大得多。然而，仅仅通过大小差异并不能说明任何问题。你应该关注所有带有
    `200 响应` 码的行。请注意，也可能会出现假阳性。因此，将所有看似成功的用户名和密码分开，进一步调查。
- en: In the next section, we will go through the AuthZ mechanisms of an API.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 API 的 AuthZ 机制。
- en: Exploring authorization mechanisms
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索授权机制
- en: So, we’ve played with the AuthN part, but that’s just part of the party. After
    gaining access to the system, we need to have enough power to do a number of things
    a regular user could not do. However, it’s worth mentioning that even a regular
    user may have read-only access to sensitive data or other users’ data, depending
    on how the API’s AuthZ controls were implemented.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经玩过了 AuthN 部分，但这只是整个过程的一部分。在获得系统访问权限后，我们需要拥有足够的权限去做一些普通用户无法做到的事情。然而，值得提到的是，即使是普通用户，也可能根据
    API 的 AuthZ 控制实施方式，具有只读权限访问敏感数据或其他用户的数据。
- en: 'Exploring AuthZ mechanisms during API pentesting is crucial for identifying
    potential security vulnerabilities and ensuring that only authorized users or
    clients can access protected resources. AuthZ mechanisms define the rules and
    policies that govern access to API endpoints, data, and functionalities, and testing
    these mechanisms helps assess their effectiveness in enforcing access controls
    and preventing unauthorized access. Before going further into how we can explore
    API AuthZ mechanisms, we need to understand what they are. AuthZ mechanisms are
    controls that specify what exactly a user can and cannot do once they are authenticated.
    The most used methods as of the time of writing are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 渗透测试过程中，探索 AuthZ 机制对于识别潜在的安全漏洞并确保只有授权用户或客户端能够访问受保护的资源至关重要。AuthZ 机制定义了管理访问
    API 端点、数据和功能的规则和策略，测试这些机制有助于评估其在执行访问控制和防止未授权访问方面的有效性。在进一步探讨如何探索 API 的 AuthZ 机制之前，我们需要了解它们是什么。AuthZ
    机制是指定一旦用户认证后，用户可以做什么和不能做什么的控制方式。截止到目前，最常用的方法如下：
- en: '**Role-Based Access Control (RBAC)**: Each valid user in the system is assigned
    one or more roles that in turn dictate which actions are allowed. Depending on
    how the system was designed, some actions can also be explicitly denied. Once
    such a mechanism is detected, you can try to discover which roles exist and craft
    a way to bypass/invalidate the control. A real-world example would be a company
    whose employees belonging to the human resources department (role) would have
    access to payroll data whereas all others (excluding the board, of course) wouldn’t.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制 (RBAC)**：系统中的每个有效用户都会被分配一个或多个角色，这些角色决定了哪些操作是被允许的。根据系统的设计，某些操作也可能会被明确拒绝。一旦检测到这样的机制，你可以尝试发现存在哪些角色，并设计绕过/使控制失效的方法。一个现实的例子是，一家公司中属于人力资源部门（角色）的员工将能访问工资单数据，而其他员工（当然不包括董事会成员）则无法访问。'
- en: '**Attribute-Based Access Control (ABAC)**: Combines parameters or attributes
    that are assigned to the user, the resource they are trying to access, and even
    the environment where the resource is physically or logically defined or located.
    This is a control usually applied by public cloud players, where such attributes
    are often called “labels” or “tags” (not to be confused with smart tokens or tags).
    They comprise key-value pairs where the cloud’s sysadmin can assign them to different
    users and resources to better group the assets. Permissions can be set based on
    such tags. You can try to manipulate or inject attributes to gain unauthorized
    access. A real-world example would be contractors that do service on an institution.
    Once they present themselves wearing the uniforms (tags) their companies provide,
    they are granted access to areas assigned to their contracting companies. However,
    each contractor can only access the areas designated for the company they were
    hired from. When another contractor working for the same company is eventually
    added or replaces a previous one, the new contractor must receive an analogous
    uniform. By wearing another contractor’s uniform, you may enter their company’s
    area possibly unnoticed.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制（ABAC）**：结合分配给用户、他们试图访问的资源以及资源所在的物理或逻辑环境的参数或属性。这是通常由公共云服务提供商应用的一种控制方式，这些属性通常被称为“标签”或“标记”（不要与智能令牌或标签混淆）。它们由键值对组成，云系统管理员可以将其分配给不同的用户和资源，以更好地对资产进行分组。权限可以根据这些标签来设置。您可以尝试操纵或注入属性以获得未经授权的访问。一个现实世界的例子是在机构提供服务的承包商。一旦他们穿着公司提供的制服（标签），他们就被授予进入被分配给其承包公司的区域的权限。然而，每个承包商只能访问为其被聘用的公司指定的区域。当另一位为同一家公司工作的承包商最终被添加或取代之前的承包商时，新的承包商必须获得类似的制服。通过穿着另一位承包商的制服，您可能进入他们公司的区域，可能不会被注意到。'
- en: '**OAuth scopes**: We already covered what OAuth is and the power it provides
    to an API. In this context, scopes define the specific access levels or resources
    a user is authorized to request. A real-world example could be a military facility,
    where officers of different ranks would work together. Nevertheless, the context
    of information a major receives is higher than a captain’s, which is higher than
    a lieutenant’s, and so on and so forth. Impersonating an officer (bypassing a
    context) would give you access to restricted/privileged information.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth范围**：我们已经讨论了OAuth及其为API提供的功能。在这种情况下，范围定义用户被授权请求的具体访问级别或资源。一个现实世界的例子可能是军事设施，各级军官将共同工作。然而，上尉收到的信息的上下文要高于中尉的，后者高于上尉的，依此类推。冒充军官（绕过上下文）将使您能够访问受限/特权信息。'
- en: Let’s look at each of them in more detail.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每一个。
- en: Role-based access control
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Let’s suppose the system you are testing and trying to explore applies such
    a mechanism. crAPI does that, right? Do you remember when we were forging tokens
    pretending to have the `ROLE_ADMIN` role instead of `ROLE_USER`?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在测试和尝试探索的系统应用了这种机制。crAPI是这样的，对吧？还记得我们曾伪造令牌，假装拥有`ROLE_ADMIN`角色而不是`ROLE_USER`吗？
- en: In the realm of API security, RBAC plays a crucial role in safeguarding access
    to sensitive data and functionalities. This approach grants permissions based
    on predefined roles assigned to users or groups, ensuring that individuals only
    have the level of access necessary for their designated tasks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在API安全领域，RBAC在保护对敏感数据和功能的访问中发挥着关键作用。这种方法基于为用户或群组分配的预定义角色授予权限，确保个体仅具备其指定任务所需的访问级别。
- en: 'RBAC operates on three core components:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC操作基于三个核心组件：
- en: '`admin`, `editor`, `reader`, or `guest`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin`、`editor`、`reader`或`guest`。'
- en: '**Users**: Individual entities interacting with the API, typically identified
    through usernames, IDs, or other unique identifiers.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：与API交互的个体实体，通常通过用户名、ID或其他唯一标识符进行识别。'
- en: '**Permissions**: Granular actions users can perform on API resources, such
    as **Create, Read, Update, or** **Delete** (**CRUD**).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**：用户可以对API资源执行的粒度操作，如**创建、读取、更新或删除**（CRUD）。'
- en: Users first authenticate themselves with the API, providing credentials such
    as usernames and passwords or tokens. Based on the authenticated user, the system
    determines their assigned role(s). When a user requests access to a specific API
    resource, the system verifies whether their associated role(s) possess the necessary
    permissions for the requested action. If the user’s role has the required permission,
    access is granted; otherwise, it’s denied, and an appropriate error message is
    returned.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首先通过API进行身份验证，提供诸如用户名、密码或令牌等凭据。根据验证过的用户，系统确定其分配的角色。当用户请求访问特定的API资源时，系统会验证其相关角色是否具有所请求操作所需的权限。如果用户的角色具有所需权限，则授予访问权限；否则，拒绝访问，并返回相应的错误消息。
- en: 'Some benefits of RBAC are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC的一些优点如下：
- en: '**Granular access control**: Enables fine-grained control over API access by
    tailoring permissions to specific roles.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度访问控制**：通过根据特定角色定制权限，实现对API访问的精细控制。'
- en: '**Reduced complexity**: Simplifies access management by grouping similar permissions
    under roles.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少复杂性**：通过将相似的权限归类到角色中，简化访问管理。'
- en: '**Improved security**: Minimizes the risk of unauthorized access by restricting
    actions based on user roles.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全性**：通过基于用户角色限制操作，最小化未经授权访问的风险。'
- en: Some examples of public APIs using RBAC include cloud storage APIs where granting
    read/write access to specific folders or files is based on user roles; social
    media APIs that allow users to post, edit, or delete content based on their account
    type (admin, moderator, or regular user); and e-commerce APIs that control access
    to product information, order management, and pricing data based on user roles
    (customer, vendor, or administrator).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RBAC的公共API示例包括云存储API，其中授予特定文件夹或文件的读/写访问权限是基于用户角色的；社交媒体API，允许用户根据其账户类型（管理员、版主或普通用户）发布、编辑或删除内容；以及电子商务API，基于用户角色（客户、供应商或管理员）控制对产品信息、订单管理和定价数据的访问。
- en: Attribute-based access control
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于属性的访问控制
- en: ABAC goes further into the way access control works. Instead of simply relying
    on roles and their permissions, it offers a more nuanced and adaptable approach
    specifically suited for complex API environments. For example, healthcare APIs
    control access to sensitive patient data based on user roles, data sensitivity
    level, and access location. Financial APIs grant AuthZ for financial transactions
    based on user identity, account type, transaction amount, and time of day. IoT
    APIs enable secure device access and data exchange based on device type, location,
    and specific permissions associated with the device.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ABAC深入探讨了访问控制的工作方式。它不仅仅依赖于角色及其权限，而是提供了一种更加细致和灵活的方法，特别适用于复杂的API环境。例如，医疗API根据用户角色、数据敏感度等级和访问位置来控制对敏感病人数据的访问。金融API基于用户身份、账户类型、交易金额和时间来授予财务交易的授权。物联网（IoT）API基于设备类型、位置以及与设备相关的特定权限来启用安全的设备访问和数据交换。
- en: 'Besides relying solely on predefined, and sometimes custom, roles, ABAC evaluates
    various attributes associated with different entities involved in an access request:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了仅仅依赖预定义的、有时是自定义的角色外，ABAC还会评估与访问请求中不同实体相关的各种属性：
- en: '**Subject**: The user or entity requesting access (e.g., username, IP address,
    or device type).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：请求访问的用户或实体（例如，用户名、IP地址或设备类型）。'
- en: '**Resource**: The API resource being accessed (e.g., data object or endpoint
    URL).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：被访问的API资源（例如，数据对象或端点URL）。'
- en: '**Action**: The operation being attempted (e.g., read, write, or delete).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：正在尝试的操作（例如，读取、写入或删除）。'
- en: '**Environment**: Contextual factors such as time, location, or specific conditions
    (e.g., emergency access).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：上下文因素，如时间、位置或特定条件（例如，紧急访问）。'
- en: '**Attributes**: Additional data points associated with any of the preceding
    entities (e.g., user department, resource sensitivity level, or time of day).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：与任何前述实体相关的额外数据点（例如，用户部门、资源敏感度等级或时间）。'
- en: When a user interacts with the API, the system gathers relevant attributes from
    all involved entities. After that, the system evaluates predefined access control
    policies against the gathered attributes. These policies define conditions under
    which specific actions are permitted or denied. Finally, based on the policy evaluation
    outcome, access is either granted or denied.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与 API 进行交互时，系统会收集所有相关实体的属性。之后，系统会根据收集到的属性评估预定义的访问控制策略。这些策略定义了在特定条件下，某些操作是否被允许或拒绝。最后，根据策略评估结果，系统将决定是否授予访问权限。
- en: Some benefits of applying ABAC include granular and flexible control, which
    enables highly granular access control by considering various attributes beyond
    just roles, dynamic and adaptable policies that can be dynamically adjusted based
    on changing attributes, making it suitable for complex and evolving environments,
    and reduced misconfigurations, which, by focusing on specific attributes and conditions,
    mitigates the risk of misconfigured roles.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 ABAC 的一些好处包括细粒度和灵活的控制，通过考虑除角色之外的各种属性，实现高度细化的访问控制；动态和可调整的策略，可以根据属性变化动态调整，适用于复杂和不断变化的环境；以及减少配置错误，通过关注特定属性和条件，降低角色配置错误的风险。
- en: '**Amazon Web Services** (**AWS**), for example, has a specific API for their
    resource group tagging, allowing a customer or partner to interact with their
    cloud resources by creating, attaching, updating, or deleting tags accordingly.
    Those tags can then be checked against an AWS IAM policy further on the cloud
    access control policy.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**Amazon Web Services**（**AWS**）为其资源组标签提供了特定的 API，允许客户或合作伙伴通过创建、附加、更新或删除标签与其云资源进行交互。然后，这些标签可以进一步与
    AWS IAM 策略进行检查，以符合云访问控制策略。
- en: OAuth scopes
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 范围
- en: OAuth scopes are somewhat like attributes in ABAC-backed APIs in the sense that
    they also apply labels. They act as mechanisms that define the specific permissions
    an application can request and, consequently, the level of access it receives
    to an API’s resources. OAuth scopes are essentially strings that represent specific
    sets of permissions associated with an API. When an application requests access
    to an API using OAuth, it specifies the desired scopes within its AuthZ request.
    The AuthZ server then evaluates these requested scopes against the application’s
    registered permissions and grants an access token with the corresponding level
    of access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 范围在某些方面类似于 ABAC 支持的 API 中的属性，因为它们也应用标签。它们作为定义应用程序可以请求的特定权限的机制，进而决定它在 API
    资源上的访问级别。OAuth 范围本质上是表示与 API 相关的一组特定权限的字符串。当应用程序使用 OAuth 请求 API 访问时，它会在其 AuthZ
    请求中指定所需的范围。然后，AuthZ 服务器会根据应用程序注册的权限评估这些请求的范围，并授予相应访问级别的访问令牌。
- en: 'From this, we can derive at least the following immediate benefits of leveraging
    OAuth scopes for an API:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以得出至少以下几种利用 OAuth 范围进行 API 访问的直接好处：
- en: '**Granular control**: Enables precise control over API access by allowing applications
    to request only the specific permissions they require.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度控制**：通过允许应用程序仅请求其所需的特定权限，实现对 API 访问的精确控制。'
- en: '**Reduced risk**: Mitigates the risk of unauthorized access by limiting the
    scope of an application’s access token.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少风险**：通过限制应用程序访问令牌的范围，降低未经授权访问的风险。'
- en: '**Improved transparency**: Provides clear visibility into the permissions granted
    to each application, enhancing accountability and trust.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高透明度**：为每个应用程序提供清晰的权限可见性，从而增强问责制和信任。'
- en: Numerous different scopes can be created on an API to fulfill specific needs.
    Some types of scopes an API can leverage are **read-only** (allows an application
    to read data from specific API resources but not modify or delete them), **write-only**
    (grants an application the ability to create or update data within the API but
    not read existing information), **full access** (provides comprehensive access
    to all API resources, including read, write, and delete capabilities), **user-specific**
    (defines permissions based on the user associated with the application, enabling
    granular control within specific user contexts), and **resource-specific** (limits
    access to specific resources within the API, allowing applications to access only
    the data they need).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 API 上创建许多不同的范围来满足特定需求。API 可以利用的某些范围类型包括 **只读**（允许应用程序从特定 API 资源中读取数据，但不能修改或删除数据）、**只写**（授予应用程序创建或更新
    API 中数据的能力，但不能读取现有信息）、**完全访问**（提供对所有 API 资源的全面访问，包括读取、写入和删除权限）、**用户特定**（根据与应用程序关联的用户定义权限，从而在特定用户上下文中进行精细控制）和
    **资源特定**（限制对 API 中特定资源的访问，允许应用程序仅访问所需的数据）。
- en: 'The following Python code block shows some dummy examples of handling OAuth
    scopes on an API:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Python 代码块展示了处理 API 上 OAuth 范围的一些示例：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last portion of the code shows an easy way to leverage Flask’s OAuth library.
    Flask is a framework that makes it easier to build Python backend applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分展示了利用 Flask OAuth 库的简便方法。Flask 是一个使构建 Python 后端应用程序更容易的框架。
- en: Some widely known APIs that use OAuth scopes include Google Drive, GitHub, X
    (previously Twitter), Dropbox, and Facebook/Meta.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一些广为人知的使用 OAuth 范围的 API 包括 Google Drive、GitHub、X（前身为 Twitter）、Dropbox 和 Facebook/Meta。
- en: Next, let’s learn how to circumvent access controls.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何绕过访问控制。
- en: Bypassing access controls
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过访问控制
- en: To be successful in bypassing access controls, you have to either explore misconfigurations
    or lack of configurations in APIs, or even some backend logic flaw. All mentioned
    AuthZ mechanisms are strong, but the way they were implemented on an API endpoint
    may make them useless, or at least vulnerable to some attempts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功绕过访问控制，你必须要么探索 API 中的配置错误或缺失的配置，要么发现一些后端逻辑缺陷。所有提到的 AuthZ 机制都很强大，但它们在 API
    端点上的实现方式可能使它们变得无效，或至少对某些尝试存在漏洞。
- en: 'For the sake of illustrating this, let’s propose three different scenarios
    where you have, respectively, RBAC, ABAC, and OAuth scopes in place. Let’s understand
    how some exploits could be exercised. For RBAC, suppose you have an API that manages
    employee data, with different roles such as `employee` and `admin`. The `admin`
    role has access to all employee records, while the `employee` role can only access
    their own record. However, the API doesn’t properly validate the user’s role during
    certain operations. In other words, the following are the case:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们提出三个不同的场景，分别有 RBAC、ABAC 和 OAuth 范围的设置。我们来了解一些攻击是如何进行的。对于 RBAC，假设你有一个管理员工数据的
    API，具有不同的角色，如 `employee` 和 `admin`。`admin` 角色可以访问所有员工记录，而 `employee` 角色只能访问自己的记录。然而，API
    在某些操作过程中没有正确验证用户的角色。换句话说，以下是这种情况：
- en: As an employee, you’re only supposed to access your own data. However, you notice
    that the API doesn’t check your role when updating your personal information.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名员工，你应该仅能访问自己的数据。然而，你注意到在更新个人信息时，API 并未检查你的角色。
- en: By modifying the API request to impersonate an admin user, you’re able to gain
    access to and modify any employee’s data, bypassing the intended RBAC controls.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改 API 请求以模拟管理员用户，你可以访问并修改任何员工的数据，从而绕过预定的 RBAC 控制。
- en: 'An excerpt of some vulnerable Python code is shown here. Observe the logic:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一段易受攻击的 Python 代码片段。请观察其逻辑：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code simply fetches the role provided by the requestor from the headers
    without further checking whether such a claim is legitimate. Hence, in this case,
    once you submit a request with `user_role` as `admin`, you’ll receive full privileges
    on the API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码仅从请求头中获取请求者提供的角色，而未进一步检查该声明是否合法。因此，在这种情况下，一旦你提交一个 `user_role` 为 `admin` 的请求，你就会获得
    API 的全部权限。
- en: Now, moving on to ABAC, consider an API for an online banking application where
    access to financial transactions is controlled based on the user’s account type
    (e.g., standard or premium) and the transaction amount. However, due to a flaw
    in the attribute validation logic, an attacker can manipulate the transaction
    amount attribute to execute high-value transactions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 ABAC，考虑一个在线银行应用的 API，其中财务交易的访问是基于用户账户类型（如标准账户或高级账户）和交易金额来控制的。然而，由于属性验证逻辑中的缺陷，攻击者可以操控交易金额属性来执行高价值交易。
- en: 'Observe an example of vulnerable code written in Python to represent this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一个用 Python 编写的易受攻击的代码示例来表示这一点：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, the `initiate_transaction` endpoint is intended to restrict
    high-value transactions for standard account types. However, the code fails to
    properly validate the transaction amount, allowing an attacker to manipulate the
    amount and bypass ABAC controls. Observe that, using an analogous approach to
    RBAC, the validation code is simply relying on what is claimed by the requestor.
    In this case, should you send any account type different than `standard`, you
    would be able to process the transaction regardless of its amount.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`initiate_transaction` 端点的目的是限制标准账户类型的高价值交易。然而，代码未能正确验证交易金额，导致攻击者能够操控金额并绕过
    ABAC 控制。请注意，采用类似于 RBAC 的方式，验证代码仅仅依赖请求者声明的信息。在这种情况下，如果你发送任何与 `standard` 不同的账户类型，便能够处理该交易，无论其金额如何。
- en: Finally, let’s see a way that would make OAuth scopes vulnerable to exploitation.
    Suppose you have an API that provides access to user profile information, with
    different scopes such as `read_profile` and `write_profile`. However, due to a
    misconfiguration in the OAuth server, the access token issued to a user contains
    unintended scopes, enabling unauthorized access to sensitive resources.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一种可能使 OAuth 范围易受攻击的方式。假设你有一个 API 提供访问用户个人信息的功能，并且有不同的范围，如 `read_profile`
    和 `write_profile`。然而，由于 OAuth 服务器的错误配置，分配给用户的访问令牌包含了不应有的范围，从而允许未经授权访问敏感资源。
- en: 'Look at the vulnerable code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个易受攻击的代码：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, the `get_profile` endpoint is supposed to restrict access
    to users with the `read_profile` scope. However, the code incorrectly assumes
    that the access token scopes are trusted without proper validation, allowing an
    attacker to manipulate the token and bypass OAuth scope restrictions. In summary,
    if as part of the AuthZ token you send a claim for a privileged scope, you would
    achieve success with this backend code in place. There are two other topics that
    we can’t forget to mention. They are known by their acronyms: BOLA and BFLA.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`get_profile` 端点本应限制只有具有 `read_profile` 范围的用户才能访问。然而，代码错误地假设访问令牌的范围是可信的，且没有进行适当的验证，这使得攻击者能够操控令牌并绕过
    OAuth 范围限制。总之，如果在 AuthZ 令牌中发送了一个特权范围的声明，在这个后端代码的配合下，你将能够成功执行操作。还有两个我们不能忘记提及的话题，它们通常被简称为
    BOLA 和 BFLA。
- en: Broken Object Level Authorization (BOLA)
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被破坏的对象级授权（BOLA）
- en: This consists of a security vulnerability that is present when an API does not
    correctly apply AuthZ verifications before effectively allowing access to objects
    and resources. This usually happens when an API solely relies on user input (such
    as object IDs) without checking whether the user providing them actually has permission
    to access such IDs. You can exploit this by manipulating inputs to achieve unauthorized
    access to data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种安全漏洞，当一个 API 在有效地允许访问对象和资源之前没有正确地应用 AuthZ 验证时，便会出现这种情况。通常发生在一个 API 完全依赖用户输入（如对象
    ID），而没有检查提供这些 ID 的用户是否真的有权限访问这些 ID 时。你可以通过操控输入来实现未经授权的数据访问。
- en: 'To exemplify this, let’s consider a scenario where an API endpoint retrieves
    user details based on a user ID. If the endpoint does not check whether the authenticated
    user has access to the required ID or not, a pentester can provide any valid user
    ID to get other users’ data. This situation may be quite dangerous when the vulnerable
    API (or the application behind it) handles sensitive data, such as financial or
    health records. When BOLA is present on an application or API code, you can enumerate
    object IDs and access unauthorized data. Observe the following Python code, which
    has a BOLA vulnerability:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，假设一个API端点根据用户ID检索用户详细信息。如果该端点没有检查经过身份验证的用户是否有权访问所需的ID，渗透测试人员可以提供任何有效的用户ID来获取其他用户的数据。当受影响的API（或其背后的应用程序）处理敏感数据时，比如财务或健康记录，这种情况可能非常危险。当BOLA（Broken
    Object Level Authorization）出现在应用程序或API代码中时，您可以枚举对象ID并访问未经授权的数据。观察下面的Python代码，它存在BOLA漏洞：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Any authenticated user can access other users’ details by simply providing
    their ID. Now observe an example of a change that removes the vulnerability:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 任何经过身份验证的用户都可以通过提供他们的ID来访问其他用户的详细信息。现在观察一个删除漏洞的示例代码更改：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Observe the `get_user_by_id` function returning `None` if an invalid user ID
    is provided. Let’s move on to BFLA next.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`get_user_by_id`函数，当提供无效用户ID时返回`None`。接下来我们看一下BFLA。
- en: Broken Function Level Authorization (BFLA)
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误的功能级别授权（BFLA）
- en: This occurs when an API or the application behind it does not correctly apply
    AuthZ checks to its functions and actions, which allows attackers to run functions
    or access resources they don’t have permission to. This vulnerability usually
    shows up when there are no access control policies or they lack sophistication,
    and the application trusts user roles or privileges without properly verifying
    them before allowing function executions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当API或其背后的应用程序没有正确应用AuthZ检查到其函数和操作时，就会发生这种情况，这允许攻击者执行他们没有权限的功能或访问他们没有权限的资源。这个漏洞通常出现在没有访问控制策略或策略缺乏复杂性的情况下，应用程序在没有正确验证用户角色或权限的前提下，信任这些角色或权限并允许执行功能。
- en: 'For example, consider an API that provides functionalities not properly restricted
    to authorized users. If a pentester with lower permissions can run tasks such
    as creating or changing users, the whole API security may be compromised. Even
    new administrators could be created by such a pentester. Observe the following
    Golang code, which uses BFLA:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个API，它提供的功能没有正确限制为授权用户。如果一个权限较低的渗透测试人员可以执行诸如创建或更改用户等任务，那么整个API的安全性可能会受到威胁。甚至新管理员也可以由这样的渗透测试人员创建。观察下面的Golang代码，它使用了BFLA：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Any user could access the `/admin/create_user` endpoint to create a new user.
    Now look at a suggestion of code to remove the vulnerability:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户都可以访问`/admin/create_user`端点来创建新用户。现在看看一个建议的代码来修复这个漏洞：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You just learned how to identify and fix, with straightforward code changes,
    one of the most dangerous vulnerabilities that affect APIs. The `getCurrentUser`
    and `requireAdminRole` functions were implemented to reinforce protection on the
    AuthZ logic.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何通过简单的代码修改来识别和修复影响API的最危险漏洞之一。`getCurrentUser`和`requireAdminRole`函数的实现是为了加强AuthZ逻辑的保护。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered additional topics relating to an API pentest. We have looked
    at both the AuthN and AuthZ mechanisms, their details, and ways they can present
    themselves as vulnerable enough to be exploitable. You also learned about weak
    API credentials and default accounts, along with techniques to discover and leverage
    them as part of your attack. These constitute a very important part of any API
    pentest since other stages, such as persistence, lateral movement, and data exfiltration
    all depend on the successful exploitation of AuthN and AuthZ.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了与API渗透测试相关的其他话题。我们研究了AuthN和AuthZ机制，它们的细节，以及它们如何可能表现得足够脆弱，从而被利用。你还学习了弱API凭证和默认账户，以及如何发现和利用它们作为攻击的一部分。这些构成了任何API渗透测试中非常重要的一部分，因为其他阶段，如持久性、横向移动和数据外泄，都依赖于成功利用AuthN和AuthZ。
- en: In the next chapter, which also starts *Part 3* of this book, you will be introduced
    to injection attacks and validation testing. The damage such attacks can cause
    can be massive and successfully protecting against them by implementing a correct
    user input validation is key. See you there!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，本书的*第三部分*也将介绍注入攻击和验证测试。这些攻击可能造成的损害是巨大的，通过实施正确的用户输入验证来成功防御它们是至关重要的。到时候见！
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'CKAN, a Python framework to support open data websites: [https://ckan.org/](https://ckan.org/)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CKAN，一个支持开放数据网站的Python框架：[https://ckan.org/](https://ckan.org/)
- en: 'Open Data Handbook, explaining basic concepts around open data: [https://opendatahandbook.org/guide/en/](https://opendatahandbook.org/guide/en/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放数据手册，解释关于开放数据的基本概念：[https://opendatahandbook.org/guide/en/](https://opendatahandbook.org/guide/en/)
- en: 'OAuth 2.0 Security Best Practices: [https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0安全最佳实践：[https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- en: 'More OAuth grant flows and some graphics: [https://frontegg.com/blog/oauth-grant-types](https://frontegg.com/blog/oauth-grant-types)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多OAuth授权流及一些图示：[https://frontegg.com/blog/oauth-grant-types](https://frontegg.com/blog/oauth-grant-types)
- en: 'Exploring CookieMonster: [https://ian.sh/cookiemonster](https://ian.sh/cookiemonster)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索CookieMonster：[https://ian.sh/cookiemonster](https://ian.sh/cookiemonster)
- en: 'RFC 7517, which defines JSON Web Keys: [https://datatracker.ietf.org/doc/html/rfc7517](https://datatracker.ietf.org/doc/html/rfc7517)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 7517，定义了JSON Web密钥：[https://datatracker.ietf.org/doc/html/rfc7517](https://datatracker.ietf.org/doc/html/rfc7517)
- en: 'JWT Cracker, a tool written in C to crack JWTs with brute force: [https://github.com/brendan-rius/c-jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT破解器，一个用C语言编写的暴力破解JWT的工具：[https://github.com/brendan-rius/c-jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)
- en: 'A curated list of tools and lists for cracking systems: [https://github.com/n0kovo/awesome-password-cracking](https://github.com/n0kovo/awesome-password-cracking)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份精心策划的破解系统工具和列表：[https://github.com/n0kovo/awesome-password-cracking](https://github.com/n0kovo/awesome-password-cracking)
- en: '*Top 200 Most Common* *Passwords*: [https://nordpass.com/most-common-passwords-list/](https://nordpass.com/most-common-passwords-list/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最常见的200个* *密码*：[https://nordpass.com/most-common-passwords-list/](https://nordpass.com/most-common-passwords-list/)'
- en: 'Mentalist, a tool to create your own password lists: [https://github.com/sc0tfree/mentalist](https://github.com/sc0tfree/mentalist)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mentalist，一个用于创建自定义密码列表的工具：[https://github.com/sc0tfree/mentalist](https://github.com/sc0tfree/mentalist)
- en: 'Patator – a brute-force attacker with fuzzing and password spraying features:
    [https://salsa.debian.org/pkg-security-team/patator](https://salsa.debian.org/pkg-security-team/patator)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Patator – 一个具有模糊测试和密码喷洒功能的暴力破解攻击工具：[https://salsa.debian.org/pkg-security-team/patator](https://salsa.debian.org/pkg-security-team/patator)
- en: '*AWS Resource Group Tagging API* *Reference*: [https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AWS资源组标签API* *参考文档*：[https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/overview.html)'
- en: 'Part 3: API Basic Attacks'
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：API基本攻击
- en: Now that you have been introduced to basic attacks in *Part 2*, it’s time to
    move on and increase your knowledge of more types of attacks. In this part, you
    will learn about techniques that you must not ignore while targeting APIs. We
    will discuss adapted SQL and NoSQL injection attacks, the problems caused by bad
    user input sanitization, what happens when an error is not correctly handled,
    and finally, the feared denial-of-service attack. You will also be presented with
    some ways to block or at least reduce the chances of such attacks being successful.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了*第二部分*中的基本攻击，接下来是时候继续扩展您对更多攻击类型的了解了。在这一部分，您将学习一些在攻击API时不可忽视的技术。我们将讨论适应性的SQL和NoSQL注入攻击、糟糕的用户输入清理带来的问题、错误处理不当的后果，以及最后备受忌惮的拒绝服务攻击。我们还将为您介绍一些阻止或至少减少此类攻击成功机会的方法。
- en: 'This section contains the following chapters:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 5*](B19657_05.xhtml#_idTextAnchor078), *Injection Attacks and Validation
    Testing*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19657_05.xhtml#_idTextAnchor078)，*注入攻击与验证测试*'
- en: '[*Chapter 6*](B19657_06.xhtml#_idTextAnchor102), *Error Handling and Exception
    Testing*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19657_06.xhtml#_idTextAnchor102)，*错误处理与异常测试*'
- en: '[*Chapter 7*](B19657_07.xhtml#_idTextAnchor110), *Denial of Service and Rate-Limiting
    Testing*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19657_07.xhtml#_idTextAnchor110)，*拒绝服务与速率限制测试*'
