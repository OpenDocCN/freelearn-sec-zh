- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Exploring PowerShell Remote Management Technologies and PowerShell Remoting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 PowerShell 远程管理技术和 PowerShell 远程
- en: 'As one of the main purposes of PowerShell is automating administration tasks,
    **PowerShell remoting** (**PSRemoting**) plays a big part in administrating multiple
    computers at the same time: using only a single command, you can run the same
    command line on hundreds of computers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 PowerShell 的主要用途之一是自动化管理任务，**PowerShell 远程**（**PSRemoting**）在同时管理多台计算机时扮演着重要角色：只需一条命令，你就可以在数百台计算机上执行相同的命令行。
- en: 'But similar to when you work with individual computers, PSRemoting is only
    as secure as your configuration: if you don’t lock the door of your house, burglars
    can break into it.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但与使用单独的计算机时类似，PSRemoting 的安全性取决于你的配置：如果你不锁好房门，窃贼是可以闯入的。
- en: 'And that’s the same case for computers, as well as for PSRemoting: if you don’t
    harden your configuration and use insecure settings, attackers can leverage that
    and use your computers against you.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于计算机，以及 PSRemoting：如果你没有加固配置并使用不安全的设置，攻击者可以利用这些漏洞，将你的计算机反过来用作攻击工具。
- en: In this chapter, you will not only learn the basics of PSRemoting and how to
    enable and configure it – you will also discover the best practices for maintaining
    a secure PSRemoting configuration. While PSRemoting is inherently secure, there
    are still measures you can take to ensure that your configuration remains secure.
    We will explore these measures in detail to help you keep your PSRemoting setup
    secure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你不仅会学习 PSRemoting 的基础知识以及如何启用和配置它——你还会发现如何保持安全的 PSRemoting 配置的最佳实践。尽管 PSRemoting
    本身是安全的，但你仍然可以采取一些措施，确保配置保持安全。我们将详细探讨这些措施，帮助你保持 PSRemoting 设置的安全。
- en: We will also see what PSRemoting network traffic looks like, depending on what
    authentication protocol is used. Lastly, you will learn how to configure it, what
    configurations to avoid, and how to use PSRemoting to execute commands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到 PSRemoting 网络流量的表现，取决于所使用的身份验证协议。最后，你将学习如何配置它，避免哪些配置，以及如何使用 PSRemoting
    执行命令。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Working remotely with PowerShell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 远程工作
- en: Enabling PowerShell remoting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 PowerShell 远程
- en: PowerShell endpoints (session configurations)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 端点（会话配置）
- en: PowerShell remoting authentication and security considerations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 远程身份验证和安全性考虑
- en: Executing commands using PowerShell remoting
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 远程执行命令
- en: Working with PowerShell remoting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 远程工作
- en: PowerShell remoting best practices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 远程最佳实践
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: PowerShell 7.3 and above
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 7.3 及以上版本
- en: Visual Studio Code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Wireshark
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark
- en: A test lab with a domain controller and one or more test machines
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含域控制器和一台或多台测试机器的测试实验室
- en: 'Access to the GitHub repository for **Chapter03**: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三章**的 GitHub 仓库访问链接：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03)'
- en: Working remotely with PowerShell
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerShell 远程工作
- en: 'PowerShell was designed to automate administration tasks and simplify the lives
    of system administrators. Remote management was a part of this plan from the very
    beginning, as outlined by Jeffrey Snover in the Monad Manifesto from 2002: [https://www.jsnover.com/blog/2011/10/01/monad-manifesto/](https://www.jsnover.com/blog/2011/10/01/monad-manifesto/).
    However, to ship version 1.0 promptly, some features, including PSRemoting, were
    not included until later versions. PSRemoting was officially introduced in version
    2.0 and further improved in version 3.0.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 旨在自动化管理任务，并简化系统管理员的工作。远程管理从一开始就是这一计划的一部分，正如 Jeffrey Snover 在 2002
    年的《Monad 宣言》中所概述的：[https://www.jsnover.com/blog/2011/10/01/monad-manifesto/](https://www.jsnover.com/blog/2011/10/01/monad-manifesto/)。然而，为了尽快发布版本
    1.0，某些功能（包括 PSRemoting）未包含在内，直到后来的版本才加入。PSRemoting 在 2.0 版本中正式推出，并在 3.0 版本中得到了进一步改进。
- en: It quickly became one of the most important core functionalities and nowadays
    supports many other functions within PowerShell, such as workflows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它迅速成为最重要的核心功能之一，现在支持 PowerShell 中的许多其他功能，如工作流。
- en: While PSRemoting can work with a variety of authentication methods, the default
    protocol for domain authentication is Kerberos. This is the most secure and commonly
    used method of authentication in Active Directory environments, which is where
    most people using PSRemoting are likely to be operating. So, when Kerberos is
    not available, PSRemoting will fall back to NTLM to also support workgroup authentication.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PSRemoting 可以与多种身份验证方法一起使用，但域身份验证的默认协议是 Kerberos。这是 Active Directory 环境中最安全且最常用的身份验证方法，而大多数使用
    PSRemoting 的人很可能都在这种环境下操作。因此，当 Kerberos 不可用时，PSRemoting 会回退到 NTLM，以支持工作组身份验证。
- en: Windows PowerShell supports remoting over different technologies. By default,
    PSRemoting uses **Windows Remote Management (WinRM)** as its transport protocol.
    However, it’s important to note that WinRM is just one of several protocols that
    can be used to support remote management in PowerShell. PSRemoting itself is a
    specific protocol (**PSRP**) that governs the way that PowerShell manages input,
    output, data streams, object serialization, and more. PSRP can be supported over
    a variety of transports, including **WS-Management (WS-Man)**, **Secure Shell
    (SSH)**, **Hyper-V VMBus**, and others. While **Windows Management Instrumentation
    (WMI)** and **Remote Procedure Call (RPC)** are remote management technologies
    that can be used with PowerShell, they are not considered part of the PSRemoting
    protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell 支持通过不同技术进行远程管理。默认情况下，PSRemoting 使用 **Windows 远程管理（WinRM）**
    作为传输协议。然而，值得注意的是，WinRM 只是多种可用于支持 PowerShell 远程管理的协议之一。PSRemoting 本身是一个特定的协议（**PSRP**），它规定了
    PowerShell 如何管理输入、输出、数据流、对象序列化等内容。PSRP 可以通过多种传输方式进行支持，包括 **WS-Management（WS-Man）**、**安全外壳（SSH）**、**Hyper-V
    虚拟机总线（VMBus）** 等。虽然 **Windows 管理工具（WMI）** 和 **远程过程调用（RPC）** 是可以与 PowerShell 一起使用的远程管理技术，但它们不被视为
    PSRemoting 协议的一部分。
- en: 'This difference between those remote management technologies is also reflected
    in the protocol that’s being used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些远程管理技术之间的区别也体现在所使用的协议上：
- en: '![Table 3.1 – Overview of connection methods and protocols used](image/B16679_03_Table_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.1 – 连接方法和使用的协议概述](image/B16679_03_Table_001.jpg)'
- en: Table 3.1 – Overview of connection methods and protocols used
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 连接方法和使用的协议概述
- en: PSRemoting is only enabled in Windows Server 2012 R2 and above and only connections
    from members of the Administrators group are allowed by default. However, PowerShell
    Core provides support for several remote management protocols, including WMI,
    Web-Services Management (WS-Management), and SSH remoting. It’s important to note
    that PowerShell Core doesn’t support RPC connections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PSRemoting 仅在 Windows Server 2012 R2 及更高版本中启用，且默认情况下仅允许来自管理员组成员的连接。然而，PowerShell
    Core 支持多种远程管理协议，包括 WMI、Web 服务管理（WS-Management）和 SSH 远程管理。需要注意的是，PowerShell Core
    不支持 RPC 连接。
- en: PowerShell remoting using WinRM
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WinRM 进行 PowerShell 远程管理
- en: '**DMTF** (formerly known as the **Distributed Management Task Force**) is a
    non-profit organization that defines open manageability standards, such as the
    Common Information Model (CIM), and also WS-Management.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**DMTF**（前身为 **分布式管理工作组**）是一个非盈利组织，定义了开放的可管理性标准，如通用信息模型（CIM），以及 WS-Management。'
- en: WS-Management defines a **Simple Object Access Protocol** (**SOAP**)-based protocol
    that can be used to manage servers and web services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: WS-Management 定义了一种基于 **简单对象访问协议（SOAP）** 的协议，可以用于管理服务器和 Web 服务。
- en: Microsoft’s implementation of WS-Management is **WinRM**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 WS-Management 实现是 **WinRM**。
- en: As soon as you attempt to establish a PSRemoting connection, the WinRM client
    sends SOAP messages within the WS-Management protocol over **HTTP** or **HTTPS**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您尝试建立 PSRemoting 连接，WinRM 客户端将在 **HTTP** 或 **HTTPS** 上通过 WS-Management 协议发送
    SOAP 消息。
- en: 'PSRemoting, when using WinRM, listens on the following ports:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 WinRM 时，PSRemoting 监听以下端口：
- en: '**HTTP**: **5985**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**: **5985**'
- en: '**HTTPS**: **5986**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTPS**: **5986**'
- en: Regardless of whether HTTP or HTTPS is used, PSRemoting traffic is always encrypted
    after the authentication process – depending on which protocol is used for authentication.
    You can read more about the different authentication protocols in the *Authentication*
    section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用 HTTP 还是 HTTPS，PSRemoting 流量在身份验证过程后始终会被加密 —— 具体取决于用于身份验证的协议。您可以在 *身份验证*
    部分阅读更多有关不同身份验证协议的信息。
- en: On the remote host, the WinRM service runs and is configured to have one or
    more listeners (HTTP or HTTPS). Each listener waits for incoming HTTP/HTTPS traffic
    sent through the WS-Management protocol.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程主机上，WinRM服务运行并配置为有一个或多个监听器（HTTP或HTTPS）。每个监听器都会等待通过WS-Management协议发送的HTTP/HTTPS流量。
- en: 'Once traffic is received, the WinRM service determines which PowerShell endpoint
    or application the traffic is meant for and forwards it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到流量，WinRM服务会判断流量是要发送到哪个PowerShell端点或应用程序，并转发它：
- en: '![Figure 3.1 – How WinRM and WS-Management are used to connect via PSRemoting](image/B16679_03_001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 如何通过PSRemoting使用WinRM和WS-Management进行连接](image/B16679_03_001.jpg)'
- en: Figure 3.1 – How WinRM and WS-Management are used to connect via PSRemoting
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 如何通过PSRemoting使用WinRM和WS-Management进行连接
- en: In general, this diagram has been abstracted to simplify your understanding
    of how WinRM works. **PowerShell.exe** is not called; instead, the **Wsmprovhost.exe**
    process is, which runs PSRemoting connections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这张图已被抽象化，以简化你对WinRM工作原理的理解。**PowerShell.exe**并没有被调用；相反，调用的是**Wsmprovhost.exe**进程，它运行PSRemoting连接。
- en: As WinRM and WS-Management are the default when establishing remote connections,
    this chapter will mostly focus on those technologies. But for completeness, I
    will shortly introduce all other possible remoting technologies in this section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WinRM和WS-Management是建立远程连接时的默认选项，本章将主要聚焦于这些技术。为了完整性，本节会简要介绍所有其他可能的远程技术。
- en: 'If you would like to learn about WinRM and WS-Management in more depth, I recommend
    visiting the following sources:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望更深入了解WinRM和WS-Management，我推荐访问以下资源：
- en: '[https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture](https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture](https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture)'
- en: '[https://github.com/devops-collective-inc/secrets-of-powershell-remoting](https://github.com/devops-collective-inc/secrets-of-powershell-remoting)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/devops-collective-inc/secrets-of-powershell-remoting](https://github.com/devops-collective-inc/secrets-of-powershell-remoting)'
- en: Windows Management Instrumentation (WMI) and Common Information Model (CIM)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows管理工具（WMI）和通用信息模型（CIM）
- en: '**WMI** is Microsoft’s implementation of CIM, an open standard designed by
    DMTF.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**WMI**是微软实现的CIM（由DMTF设计的开放标准）。'
- en: WMI was introduced with Windows NT 4.0 and was included in the Windows operating
    system starting with Windows 2000\. It is still present in all modern systems,
    including Windows 10 and Windows Server 2019.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: WMI是在Windows NT 4.0中引入的，并从Windows 2000开始被包括在Windows操作系统中。它仍然存在于所有现代系统中，包括Windows
    10和Windows Server 2019。
- en: CIM defines how IT system elements are represented as objects and how they relate
    to each other. This should offer a good way to manage IT systems, regardless of
    the manufacturer or platform.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CIM定义了IT系统元素如何表示为对象以及它们之间的关系。这为管理IT系统提供了一种很好的方式，不论制造商或平台如何。
- en: WMI relies on the **Distributed Component Object Model** (**DCOM**) and RPC,
    which is the underlying mechanism behind DCOM, to communicate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: WMI依赖于**分布式组件对象模型**（**DCOM**）和RPC，后者是DCOM背后的基础机制，用于进行通信。
- en: DCOM was created to let the **Component Object Model** (**COM**) communicate
    over the network and is the predecessor of .NET Remoting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DCOM是为使**组件对象模型**（**COM**）能够在网络上进行通信而创建的，它是.NET Remoting的前身。
- en: This section will give you only a basic overview of the WMI and CIM cmdlets
    to fulfill your understanding of the remote management technologies in this chapter.
    You will learn more about COM, WMI, and CIM in [*Chapter 5*](B16679_05_Final_PD.xhtml#_idTextAnchor110),
    *PowerShell Is Powerful – System and* *API Access*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要概述WMI和CIM的cmdlet，帮助你理解本章中的远程管理技术。你将会在[*第5章*](B16679_05_Final_PD.xhtml#_idTextAnchor110)中学到更多关于COM、WMI和CIM的内容，*PowerShell
    强大 – 系统与* *API 访问*。
- en: WMI cmdlets
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WMI cmdlet
- en: WMI cmdlets were deprecated starting with PowerShell Core 6 and should not be
    used in newer versions of PowerShell. However, it’s important to note that they
    are still supported in certain older versions of PowerShell, such as PowerShell
    5.1 on Windows 10, and will continue to be supported for the support life of those
    operating systems. If possible, use the newer CIM cmdlets instead, since they
    can be used on Windows and non-Windows operating systems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PowerShell Core 6 开始，WMI cmdlet 被弃用，不应在 PowerShell 的新版本中使用。然而，值得注意的是，它们仍然在某些较旧版本的
    PowerShell 中得到支持，例如 Windows 10 上的 PowerShell 5.1，并将在这些操作系统的支持生命周期内继续受到支持。如果可能，请改用较新的
    CIM cmdlet，因为它们可以在 Windows 和非 Windows 操作系统上使用。
- en: First, let’s have a look at how to work with the deprecated, but still present,
    WMI cmdlets.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用已经弃用，但仍然存在的 WMI cmdlet。
- en: 'To find all the cmdlets and functions that have the **wmi** string included
    in their name, leverage the **Get-Command** cmdlet. With the **-CommandType**
    parameter, you can specify what kind of commands you want to look for. In this
    example, I am searching for cmdlets and functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有名称中包含**wmi**字符串的 cmdlet 和函数，可以使用**Get-Command** cmdlet。通过使用**-CommandType**参数，可以指定要查找的命令类型。在此示例中，我正在搜索
    cmdlet 和函数：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An example of how to work with WMI is via the **Get-WmiObject** cmdlet. Using
    this cmdlet, you can query local and remote computers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用 WMI 的示例是通过**Get-WmiObject** cmdlet。使用这个 cmdlet，你可以查询本地和远程计算机。
- en: 'You can use the **-List** parameter to retrieve all available WMI classes on
    your computer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**-List**参数来检索计算机上所有可用的 WMI 类：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s an example of how to use **Get-WmiObject** to retrieve information about
    Windows services on your local computer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用**Get-WmiObject**来检索本地计算机上 Windows 服务信息的示例：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Not only can you query your local computer, but you can also query a remote
    computer by using the **-ComputerName** parameter, followed by the name of the
    remote computer. The following example shows how to retrieve the same information
    from the **PSSec-PC02** remote computer:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以查询本地计算机，还可以通过使用**-ComputerName**参数来查询远程计算机，后跟远程计算机的名称。以下示例展示了如何从**PSSec-PC02**远程计算机获取相同的信息：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code returns a list of all services that are available on the
    remote computer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回了远程计算机上所有可用服务的列表。
- en: 'By using the **-Query** parameter, you can even specify the query that should
    be run against the CIM database of the specified computer. The following command
    only retrieves all services with the name **WinRM**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**-Query**参数，你甚至可以指定要针对指定计算机的 CIM 数据库执行的查询。以下命令仅检索所有名称为**WinRM**的服务：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we run the specified **select * from win32_service where name='WinRM'**
    query remotely on **PSSec-PC02**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们在**PSSec-PC02**远程计算机上运行了指定的**select * from win32_service where name='WinRM'**查询。
- en: Using PowerShell WMI cmdlets, you can also call WMI methods, delete objects,
    and much more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell WMI cmdlet，你还可以调用 WMI 方法，删除对象，以及更多操作。
- en: Did you know?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: 'RPC, on which WMI relies, is no longer supported in PowerShell Core 6\. This
    is due in part to PowerShell’s goal of cross-platform compatibility: from PowerShell
    version 7 and above, RPC is only supported on machines running the Windows operating
    system.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RPC，WMI 所依赖的技术，在 PowerShell Core 6 中不再受到支持。这部分原因是 PowerShell 追求跨平台兼容性：从 PowerShell
    7 版本及以上，RPC 仅在运行 Windows 操作系统的机器上受到支持。
- en: CIM cmdlets
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CIM cmdlet
- en: With PowerShell 3.0, which came with Windows Server 2012 and Windows 8, a new
    set of cmdlets were introduced to manage objects that were compliant with the
    CIM and WS-Man standards.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 3.0（随 Windows Server 2012 和 Windows 8 一起发布），引入了一套新的 cmdlet，用于管理符合
    CIM 和 WS-Man 标准的对象。
- en: At some point, the WMI cmdlets drifted away from the DMTF standards, which prevented
    cross-platform management. So, Microsoft moved back to being compliant with the
    DMTF CIM standards by publishing the new CIM cmdlets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一度，WMI cmdlet 偏离了 DMTF 标准，这阻止了跨平台管理。因此，微软通过发布新的 CIM cmdlet，重新遵循 DMTF CIM 标准。
- en: 'To find out all CIM-related cmdlets, you can leverage the **Get-Command** cmdlet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有与 CIM 相关的 cmdlet，可以使用**Get-Command** cmdlet：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we are looking for all cmdlets and functions that have **cim**
    in their name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们正在寻找名称中包含**cim**的所有 cmdlet 和函数。
- en: You can find an overview of all the currently available CIM cmdlets to interact
    with the CIM servers at [https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/](https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/](https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/)找到与
    CIM 服务器交互的所有当前可用 CIM cmdlet 的概述。
- en: Open Management Infrastructure (OMI)
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放管理基础设施（OMI）
- en: To help with a cross-platform managing approach, Microsoft created the **Open
    Management Infrastructure** (**OMI**) in 2012 (https://github.com/Microsoft/omi),
    but it never really became that popular and isn’t used broadly anymore. Therefore,
    Microsoft decided to add support for SSH remoting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现跨平台管理方法，微软于2012年创建了**开放管理基础设施**（**OMI**）（https://github.com/Microsoft/omi），但它从未真正流行起来，也不再广泛使用。因此，微软决定增加对
    SSH 远程管理的支持。
- en: PowerShell remoting using SSH
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SSH 进行 PowerShell 远程管理
- en: To enable PSRemoting between Windows and Linux hosts, Microsoft added support
    for PSRemoting over **SSH** with PowerShell 6.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Windows 和 Linux 主机之间启用 PSRemoting，微软在 PowerShell 6 中添加了对通过 **SSH** 进行 PSRemoting
    的支持。
- en: PSRemoting via SSH requirements
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SSH 进行 PSRemoting 的要求
- en: To use PSRemoting via SSH, *PowerShell version 6 or above* and *SSH* need to
    be installed on all computers. Starting from Windows 10 version 1809 and Windows
    Server 2019, OpenSSH for Windows was integrated into the Windows operating system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用通过 SSH 的 PSRemoting，需要在所有计算机上安装*PowerShell 版本 6 或更高版本*和*SSH*。从 Windows 10
    版本 1809 和 Windows Server 2019 开始，OpenSSH for Windows 已集成到 Windows 操作系统中。
- en: PowerShell remoting on Linux
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 上的 PowerShell 远程管理
- en: 'As a first step, to use PowerShell on Linux, install PowerShell Core by following
    the steps for your operating system, which you can find in the official PowerShell
    Core documentation: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要在 Linux 上使用 PowerShell，请按照您的操作系统的步骤安装 PowerShell Core，您可以在官方 PowerShell
    Core 文档中找到：[https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux)。
- en: In my demo lab, I have a Debian 10 server installed. So, the steps may vary,
    depending on the operating system that is used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的演示实验室中，我安装了 Debian 10 服务器。因此，步骤可能会有所不同，具体取决于所使用的操作系统。
- en: 'Configure **/etc/ssh/sshd_config** with the editor of your choice. In my example,
    I am using **vi**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的编辑器配置**/etc/ssh/sshd_config**。在我的示例中，我使用**vi**：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, add a PowerShell subsystem entry to your configuration:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在配置中添加一个 PowerShell 子系统条目：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In Linux systems, the PowerShell executable is typically located at **/usr/bin/pwsh**
    by default. Please make sure you adjust this part if you installed PowerShell
    in a different location.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，默认情况下，PowerShell 可执行文件通常位于**/usr/bin/pwsh**。请确保如果您在不同位置安装了 PowerShell，则调整此部分。
- en: 'To allow users to log on remotely using SSH, configure **PasswordAuthentication**
    and/or **PubkeyAuthentication**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户远程使用 SSH 登录，请配置**PasswordAuthentication**和/或**PubkeyAuthentication**：
- en: 'If you want to allow authentication using a username and a password, set **PasswordAuthentication**
    to **yes**:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想允许使用用户名和密码进行身份验证，请将**PasswordAuthentication**设置为**yes**：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to enable a more secure method, set **PubkeyAuthentication** to
    **yes**:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想启用更安全的方法，请将**PubkeyAuthentication**设置为**yes**：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**PubkeyAuthentication**, which stands for **public key authentication**, is
    a method of authentication that relies on a generated key pair: a private and
    a public key is generated. While the **private key** is kept safe on the user’s
    computer, the **public key** is entered on a remote server.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**PubkeyAuthentication**，代表**公钥身份验证**，是一种依赖于生成的密钥对的身份验证方法：生成一个私钥和一个公钥。而**私钥**被安全地保存在用户的计算机上，**公钥**则输入到远程服务器上。'
- en: When the user authenticates using this private key, the server can verify the
    user’s identity using their public key. A public key can only be used to verify
    the authenticity of the private key or to encrypt data that only the private key
    can encrypt.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用此私钥进行身份验证时，服务器可以使用其公钥验证用户的身份。公钥只能用于验证私钥的真实性或加密只有私钥可以加密的数据。
- en: Using public key authentication for remote access not only protects against
    the risk of password attacks such as brute-force and dictionary attacks but also
    offers an additional layer of security in case the server gets compromised. In
    such cases, only the public key can be extracted while the private key remains
    safe. As the public key alone is not enough to authenticate, this method provides
    better security than using a username and password, as passwords can be extracted
    and reused if the server is compromised.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥认证进行远程访问不仅能防止暴力破解和字典攻击等密码攻击的风险，还能在服务器遭到攻破时提供额外的安全层。在这种情况下，只有公钥可以被提取，而私钥则保持安全。由于仅有公钥不足以进行认证，因此该方法提供的安全性优于使用用户名和密码，因为如果服务器被攻破，密码会被提取并重复使用。
- en: You can learn how to generate a key pair using the **ssh-keygen** tool at https://www.ssh.com/ssh/keygen/.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 https://www.ssh.com/ssh/keygen/ 学习如何使用 **ssh-keygen** 工具生成密钥对。
- en: 'If you are interested in how public key authentication works, you can read
    more about it on the official SSH website: [https://www.ssh.com/ssh/public-key-authentication](https://www.ssh.com/ssh/public-key-authentication).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对公钥认证的工作原理感兴趣，可以在官方的 SSH 网站上了解更多：[https://www.ssh.com/ssh/public-key-authentication](https://www.ssh.com/ssh/public-key-authentication)。
- en: 'Of course, both authentication mechanisms can be configured at the same time,
    but if you use **PubkeyAuthentication** and no other user connects using their
    username and password, you should use **PubkeyAuthentication** only:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，两个认证机制可以同时配置，但如果你使用 **PubkeyAuthentication** 并且没有其他用户使用用户名和密码连接，你应该仅使用 **PubkeyAuthentication**：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to learn more about the different options of the **sshd** configuration
    file, I highly recommend that you look at the **man** **pages**: https://manpages.debian.org/jessie/openssh-server/sshd_config.5.en.html.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 **sshd** 配置文件的不同选项，我强烈建议你查看 **man** **pages**：[https://manpages.debian.org/jessie/openssh-server/sshd_config.5.en.html](https://manpages.debian.org/jessie/openssh-server/sshd_config.5.en.html)。
- en: Man pages
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Man 页面
- en: '**Man** stands for **manual**. Man pages are used to get more information about
    a Linux/UNIX command or configuration file and can be compared to the Help system
    in PowerShell.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Man** 代表 **manual**。Man 页面用于获取有关 Linux/UNIX 命令或配置文件的更多信息，可以将其与 PowerShell
    中的帮助系统进行比较。'
- en: 'Restart the **ssh** service:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 **ssh** 服务：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The updated configuration is loaded into memory to activate the changes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的配置会加载到内存中以激活更改。
- en: PowerShell remoting on macOS
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell 远程管理 macOS
- en: 'To enable PSRemoting over SSH to manage macOS systems, the steps are quite
    similar to those when enabling PSRemoting on a Linux system: the biggest difference
    is that the configuration files are in a different location.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 SSH 启用 PSRemoting 以管理 macOS 系统，步骤与在 Linux 系统上启用 PSRemoting 相似：最大的不同之处在于配置文件位于不同的位置。
- en: 'First, you need to install PowerShell Core on the macOS systems that you want
    to manage remotely: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在想要远程管理的 macOS 系统上安装 PowerShell Core：[https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos)。
- en: 'Edit the **ssh** configuration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 **ssh** 配置：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a subsystem entry for PowerShell:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为 PowerShell 创建子系统条目：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, define what kind of authentication you want to configure for this machine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义你希望为此机器配置的认证类型：
- en: 'Username and password:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名和密码：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Public key authentication:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥认证：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To learn more about the options that can be configured in the **sshd** configuration,
    have a look at the *PowerShell remoting on Linux* section that we covered previously.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于可以在 **sshd** 配置中配置的选项，请查看我们之前讨论的 *PowerShell 远程管理 Linux* 部分。
- en: 'Restart the **ssh** service to load the new configuration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 **ssh** 服务以加载新配置：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The service will restart and the new configuration will be active.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将重启，新的配置将生效。
- en: PowerShell remoting via SSH on Windows
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 SSH 在 Windows 上进行 PowerShell 远程管理
- en: Of course, it is also possible to manage Windows systems via SSH, but in this
    book, I will use PSRemoting via WinRM in all of my examples as this is the default
    setting on Windows systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以通过 SSH 管理 Windows 系统，但在本书中，我将使用通过 WinRM 的 PSRemoting 作为所有示例的方式，因为这是 Windows
    系统上的默认设置。
- en: 'However, if you want to enable PSRemoting via SSH on your Windows systems,
    make sure you install OpenSSH and follow the instructions on how to set up PSRemoting
    over SSH on Windows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想通过 SSH 在 Windows 系统上启用 PSRemoting，请确保安装了 OpenSSH，并按照如何在 Windows 上通过 SSH
    设置 PSRemoting 的说明操作：
- en: '[https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview)'
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer)'
- en: Did you know?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: PSRemoting via SSH does not support remote endpoint configuration, nor **Just
    Enough** **Administration** (**JEA**).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SSH 使用 PSRemoting 不支持远程端点配置，也不支持 **Just Enough** **Administration** (**JEA**)。
- en: Enabling PowerShell remoting
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 PowerShell 远程管理
- en: 'There are different ways to enable PSRemoting for your system(s). If you only
    work with a few machines in your lab, you might want to enable it manually. But
    as soon as you want to enable PSRemoting in a big environment, you might want
    to enable and configure PSRemoting centrally. In this section, we will have a
    look at both methods. The following table provides an overview of which method
    takes which configuration actions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以为你的系统启用 PSRemoting。如果你只在实验室里操作几台机器，你可能想手动启用它。但一旦你希望在一个大型环境中启用 PSRemoting，你可能希望集中启用并配置
    PSRemoting。在本节中，我们将探讨这两种方法。以下表格提供了每种方法执行的配置操作概览：
- en: '![Table 3.2 – Enabling PSRemoting – different methods](image/B16679_03_Table_002.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.2 – 启用 PSRemoting – 不同方法](image/B16679_03_Table_002.jpg)'
- en: Table 3.2 – Enabling PSRemoting – different methods
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 – 启用 PSRemoting – 不同方法
- en: Please note that the **Enable-PSRemoting** method is a subpart of the manual
    configuration; to configure HTTP and HTTPS listeners, additional steps must be
    taken. Let’s explore what is needed to manually configure PSRemoting, which could
    be useful in a test scenario, for example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**Enable-PSRemoting** 方法是手动配置的一个子部分；要配置 HTTP 和 HTTPS 监听器，必须采取额外的步骤。我们来探讨一下手动配置
    PSRemoting 所需的内容，这在测试场景中可能会很有用。
- en: Enabling PowerShell remoting manually
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动启用 PowerShell 远程管理
- en: 'If you want to enable PSRemoting on a single machine, this can be done manually
    by using the **Enable-PSRemoting** command on an elevated shell:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在单台机器上启用 PSRemoting，可以通过在提升权限的命令行界面上使用 **Enable-PSRemoting** 命令手动完成：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the command ran successfully, so PSRemoting was enabled on
    this machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，命令成功执行，因此 PSRemoting 在这台机器上被启用。
- en: If you’re wondering about the difference between **Enable-PSRemoting** and **winrm
    quickconfig**, the truth is that there is not much difference technically. **Enable-PSRemoting**
    already incorporates all the actions performed by **winrm quickconfig**, but with
    additional environment changes specific to Windows PowerShell. So, to put it simply,
    running **Enable-PSRemoting** is sufficient, and you can skip running **winrm
    quickconfig**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 **Enable-PSRemoting** 和 **winrm quickconfig** 之间的区别，事实上，技术上并没有太大区别。**Enable-PSRemoting**
    已经包含了 **winrm quickconfig** 执行的所有操作，但还增加了特定于 Windows PowerShell 的环境更改。因此，简而言之，运行
    **Enable-PSRemoting** 就足够了，你可以跳过运行 **winrm quickconfig**。
- en: Set-WSManQuickConfig error message
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Set-WSManQuickConfig 错误信息
- en: 'Depending on your network configuration, an error message may be shown if you
    try to enable PSRemoting manually:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的网络配置，如果你尝试手动启用 PSRemoting，可能会显示错误信息：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This error message was generated by the **Set-WSManQuickConfig** command, which
    is called during the process of enabling PSRemoting.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该错误信息是由 **Set-WSManQuickConfig** 命令生成的，该命令在启用 PSRemoting 过程中被调用。
- en: 'This message is shown if one network connection is set to public because, by
    default, PSRemoting is not allowed on networks that were defined as public networks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个网络连接设置为公用网络，将显示此消息，因为默认情况下，PSRemoting 不允许在定义为公用网络的网络上使用：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To avoid this error, there are two options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免此错误，有两个选项：
- en: Configure the network profile as a private network.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网络配置文件设置为私有网络。
- en: Enforce **Enable-PSRemoting** so that the network profile check is skipped.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行 **Enable-PSRemoting**，以便跳过网络配置文件检查。
- en: 'If you are certain that the network profile is not a public one and instead
    a network that you trust, you can configure it as a private network:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确定网络配置文件不是公共网络，而是您信任的网络，可以将其配置为私有网络：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you don’t want to configure the network as a trusted, private network, you
    can enforce skipping the network profile check by adding the **-****SkipNetworkProfileCheck**
    parameter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想将网络配置为受信任的私有网络，可以通过添加**-****SkipNetworkProfileCheck**参数来强制跳过网络配置文件检查：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Having PSRemoting enabled on public network-connected computers puts your computer
    at significant risk, so be careful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到公共网络连接的计算机上启用PSRemoting会使您的计算机面临重大风险，所以要小心。
- en: Checking your WinRM configuration
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查您的WinRM配置
- en: 'After enabling PSRemoting and WinRM, you might want to check the current WinRM
    configuration. You can achieve this using **winrm** **get winrm/config**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 启用PSRemoting和WinRM后，您可能希望检查当前的WinRM配置。您可以使用**winrm** **get winrm/config**来实现这一点：
- en: '![Figure 3.2 – Verifying your local WinRM configuration](image/B16679_03_002.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 - 验证本地WinRM配置](image/B16679_03_002.jpg)'
- en: Figure 3.2 – Verifying your local WinRM configuration
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 验证本地WinRM配置
- en: You can find all the configured options in the displayed output. The **winrm
    get winrm/config** command provides a summary of the WinRM configuration settings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在显示的输出中找到所有配置的选项。**winrm get winrm/config**命令提供了WinRM配置设置的摘要。
- en: 'To change your local WinRM configuration, you can use the **set** option:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改本地WinRM配置，可以使用**set**选项：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Alternatively, you can use the **wsman:\** PowerShell drive to access and modify
    specific items in the configuration. Using the **wsman:\** provider allows you
    to access and modify specific items of the WinRM configuration in a more intuitive
    and cmdlet-like way, with the added benefit of built-in help and documentation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用**wsman:\** PowerShell驱动器访问和修改配置中的特定项。使用**wsman:\**提供程序允许您以更直观和类似cmdlet的方式访问和修改WinRM配置的特定项，并带有内置的帮助和文档。
- en: 'To change your local WinRM configuration, you can use the **Set-Item** cmdlet
    with the **wsman:\** provider to access and modify the WinRM configuration items.
    For example, to disable the use of unencrypted traffic, you can run the following
    command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改本地WinRM配置，您可以使用**Set-Item** cmdlet与**wsman:\**提供程序访问和修改WinRM配置项。例如，要禁用未加密流量的使用，可以运行以下命令：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we are configuring the WinRM service to *not* allow unencrypted
    connections. You can use a similar syntax to also configure other WinRM options
    – just make sure you provide the entire path to the setting in the tree, as well
    as the option and the value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们正在配置WinRM服务*不*允许未加密的连接。您可以使用类似的语法来配置其他WinRM选项 - 只需确保提供设置树中的整个路径，以及选项和值。
- en: Trusted hosts
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受信任的主机
- en: If you are connecting to a machine that is not domain-joined, which might be
    the reason why you configure it manually, Kerberos authentication is not an option
    and the NTLM protocol should be used for authentication instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您连接到未加入域的计算机，这可能是您手动配置的原因，那么Kerberos身份验证不是一个选项，应该使用NTLM协议进行身份验证。
- en: In this case, you need to configure the remote machine to be considered a trusted
    host in **WS-Man** on your local device; otherwise, the connection will fail.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您需要在本地设备上的**WS-Man**中将远程机器配置为受信任的主机；否则，连接将失败。
- en: 'To configure **TrustedHosts** for a remote host, you can use the **Set-Item**
    cmdlet, along with the **wsman:\localhost\client\TrustedHosts** path. By default,
    this value is empty, so you need to add the IP address or domain name of the remote
    host. To add a new value without replacing the existing ones, use the **-Concatenate**
    switch, as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要为远程主机配置**TrustedHosts**，可以使用**Set-Item** cmdlet，以及**wsman:\localhost\client\TrustedHosts**路径。默认情况下，此值为空，因此您需要添加远程主机的IP地址或域名。要添加新值而不替换现有值，请使用**-Concatenate**开关，如下所示：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will append the specified IP address to the existing list of **TrustedHosts**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将将指定的IP地址附加到现有的**TrustedHosts**列表中。
- en: 'To verify that your changes were applied, you can use the **Get-Item** cmdlet
    to display the current **TrustedHosts** configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的更改是否已应用，可以使用**Get-Item** cmdlet显示当前的**TrustedHosts**配置：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding example shows that the host with an IP address of **172.29.0.12**
    has been configured as a trusted host on the local machine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，具有IP地址**172.29.0.12**的主机已在本地机器上配置为受信任的主机。
- en: It is also a good practice to audit the **TrustedHosts** list to detect any
    unauthorized changes. This can help in detecting tampering attempts on your system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 审核**TrustedHosts**列表以检测任何未经授权的更改也是一种好做法。这有助于检测系统上的篡改尝试。
- en: Connecting via HTTPS
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过HTTPS连接
- en: Optionally, you can also configure a certificate to encrypt the traffic over
    **HTTPS**. To ensure secure PSRemoting, it is recommended that you configure a
    certificate to encrypt the traffic over HTTPS, especially in scenarios where Kerberos
    is not available for server identity verification. Although PSRemoting traffic
    is encrypted by default, encryption can be removed, and basic authentication can
    be enforced easily (see the *PowerShell remoting authentication and security considerations*
    section). Configuring a certificate adds another layer of security to your environment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你还可以配置一个证书来加密**HTTPS**上的流量。为了确保PSRemoting的安全，建议配置一个证书来加密HTTPS流量，特别是在Kerberos不可用于服务器身份验证的情况下。尽管PSRemoting流量默认是加密的，但加密可以被移除，且可以轻松强制执行基本认证（参见*PowerShell远程认证与安全性注意事项*部分）。配置证书为你的环境添加了额外的安全层。
- en: Therefore, to provide an extra layer of security, it can make sense to issue
    a certificate and enable **WinRM** **via SSL**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了提供额外的安全性，发布证书并通过SSL启用**WinRM**是有意义的。
- en: If you haven’t purchased a publicly signed SSL certificate from a valid **certificate
    authority** (**CA**), you can create a **self-signed certificate** to get started.
    However, if you’re using this for workgroup remoting, you can also use an **internal
    CA**. This can provide additional security and trust since you have a trusted
    source within the organization sign the certificate.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有从有效的**证书颁发机构**（**CA**）购买公开签名的SSL证书，你可以创建一个**自签名证书**来开始使用。然而，如果你是在工作组远程访问中使用它，你也可以使用**内部CA**。这样可以提供额外的安全性和信任，因为你有一个组织内部的受信任源来签署证书。
- en: This section only covers how to issue and configure a self-signed certificate.
    So, make sure you adjust the steps if you are using a publicly signed certificate
    or an internal CA.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅涵盖如何发布和配置自签名证书。因此，如果你使用的是公开签名证书或内部CA，请确保调整步骤。
- en: 'First, let’s get a self-signed certificate! This step is very easy if you are
    working on Windows Server 2012 and above – you can leverage the **New-SelfSignedCertificate**
    cmdlet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取一个自签名证书！如果你使用的是Windows Server 2012及以上版本，这一步非常简单 —— 你可以利用**New-SelfSignedCertificate**
    cmdlet：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Make sure that the value provided via the **-DnsName** parameter matches the
    hostname and that a matching DNS record exists in your DNS server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保通过**-DnsName**参数提供的值与主机名匹配，并且在你的DNS服务器中存在匹配的DNS记录。
- en: 'Add an HTTPS listener:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 添加HTTPS监听器：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, make sure you add an exception for the firewall. The default port
    for WinRM over HTTPS is **5986**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保为防火墙添加例外。WinRM通过HTTPS的默认端口是**5986**：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To clarify, it’s important to note that using the **-Profile Any** option opens
    WinRM to public or unidentified networks. If you’re not in a test environment,
    make sure you use the appropriate profile options, such as **Domain**, **Private**,
    or **Public**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，重要的是要注意，使用**-Profile Any**选项会将WinRM开放到公共或未识别的网络。如果你不在测试环境中，请确保使用适当的配置文件选项，如**Domain**、**Private**或**Public**。
- en: 'If you want to ensure that only HTTPS is used, remove WinRM’s HTTP listener:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望确保仅使用HTTPS，则删除WinRM的HTTP监听器：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Additionally, you may want to check and remove any existing firewall exceptions
    for HTTP traffic that were configured. This step is not necessary if you did not
    configure any exceptions previously.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能需要检查并删除任何已配置的HTTP流量的防火墙例外。如果你之前没有配置任何例外，则此步骤不必要。
- en: 'In some cases, you may want to move the WinRM listener to a different port.
    This can be useful if your firewall setup does not allow port **5986** or if you
    want to use a non-standard port for security reasons. To move the WinRM listener
    to a different port, use the **Set-Item** cmdlet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望将WinRM监听器移动到不同的端口。如果你的防火墙设置不允许端口**5986**，或者你想出于安全原因使用非标准端口，这将是有用的。要将WinRM监听器移动到不同的端口，请使用**Set-Item**
    cmdlet：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Replace **<ListenerName>** with the name of the listener that you want to edit
    and replace **<PortNumber>** with the port number that you want to configure.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将**<ListenerName>**替换为你想要编辑的监听器名称，并将**<PortNumber>**替换为你想要配置的端口号。
- en: Next, we’ll import our certificate. However, before doing so, it’s important
    to understand that certificates generated through tools such as **New-SelfSignedCertificate**
    already have usage restrictions built into them to ensure they are only valid
    for client and server authentication. If you’re using a certificate generated
    through another tool (for example, an internal PKI), it’s important to make sure
    that it also has these usage restrictions. Additionally, ensure that the root
    certificate is protected properly since attackers can use it to forge SSL certificates
    for trusted websites.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入证书。然而，在此之前，了解一些关键点非常重要：通过 **New-SelfSignedCertificate** 等工具生成的证书已经内置了使用限制，确保它们仅用于客户端和服务器认证。如果您使用的是通过其他工具生成的证书（例如，内部
    PKI），请确保它也有这些使用限制。此外，确保根证书得到了妥善保护，因为攻击者可以利用它伪造受信任网站的 SSL 证书。
- en: 'Once you have the appropriate certificate, copy it to a secure location on
    the computer from where you want to connect to the remote machine (such as **C:\tmp\cert**
    in our example), and then import it into the local certificate store:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有适当的证书，将其复制到您希望从中连接远程计算机的计算机上的安全位置（例如，在我们的示例中是 **C:\tmp\cert**），然后将其导入本地证书存储区：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Specify the credentials that you want to use to log in and enter your session.
    The **-UseSSL** parameter indicates that your connection will be encrypted using
    SSL:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您想用来登录并进入会话的凭据。**-UseSSL** 参数表示您的连接将使用 SSL 进行加密：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Of course, you still have to enter credentials to sign in to the machine remotely.
    The certificate only guarantees the authenticity of the remote computer and helps
    establish the encrypted connection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您仍然需要输入凭据才能远程登录计算机。证书仅确保远程计算机的真实性，并帮助建立加密连接。
- en: Configuring PowerShell Remoting via Group Policy
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过组策略配置 PowerShell 远程管理
- en: When working with multiple servers, you may not want to enable PSRemoting manually
    on each machine, so Group Policy is the tool of your choice.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多台服务器时，您可能不希望在每台计算机上手动启用 PSRemoting，因此组策略是您的首选工具。
- en: Using Group Policy, you can configure multiple machines using a single **Group
    Policy** **Object** (**GPO**).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组策略，您可以使用一个 **组策略对象** (**GPO**) 配置多台计算机。
- en: 'To get started, create a new GPO: open **Group Policy Management**, right-click
    on the **Organizational Unit** (**OU**) in which you want to create the new GPO,
    and select **Create a GPO in this domain, and Link** **it here…**.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个新的 GPO：打开 **组策略管理**，右键点击您希望创建新 GPO 的 **组织单位** (**OU**)，然后选择 **在此域中创建
    GPO，并在此处链接**。
- en: GPO is only a tool to configure your machines – it doesn’t start services. Therefore,
    you still need to find a solution to reboot all configured servers or start the
    WinRM service on all servers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: GPO 仅仅是一个配置工具——它不会启动服务。因此，您仍然需要找到一种方法来重新启动所有已配置的服务器或在所有服务器上启动 WinRM 服务。
- en: 'If you want to enable PSRemoting remotely, Lee Holmes has written a great script
    that leverages WMI connections (which most systems support): [http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting](http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望启用远程 PSRemoting，Lee Holmes 编写了一个非常实用的脚本，该脚本利用 WMI 连接（大多数系统都支持）：[http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting](http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting)。
- en: Allowing WinRM
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许 WinRM
- en: In the newly created GPO, navigate to **Computer Configuration** | **Policies**
    | **Administrative Templates** | **Windows Components** | **Windows Remote Management**
    | **WinRM Service** and set the **Allow remote server management through WinRM**
    policy to **Enabled**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的 GPO 中，导航到 **计算机配置** | **策略** | **管理模板** | **Windows 组件** | **Windows 远程管理**
    | **WinRM 服务**，并将 **允许通过 WinRM 进行远程服务器管理** 策略设置为 **启用**。
- en: In this policy, you can define the IPv4 and IPv6 filters. If you don’t use a
    protocol (for example, IPv6), then leave it empty so that users can’t connect
    to WinRM using this particular protocol.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在此策略中，您可以定义 IPv4 和 IPv6 过滤器。如果您不使用某种协议（例如，IPv6），则可以将其留空，以防止用户通过该协议连接到 WinRM。
- en: To allow connections, you can use the wildcard character, *****, an IP, or an
    IP range.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许连接，您可以使用通配符字符 *****、IP 地址或 IP 范围。
- en: When working with customers or in my demo labs, I learned that the most common
    reason for errors occurring regarding why WinRM did not work was using an IP or
    an IP range when configuring this setting.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在与客户合作或在我的演示实验室中，我发现发生 WinRM 无法工作的错误时，最常见的原因是配置此设置时使用了 IP 或 IP 范围。
- en: 'Therefore, nowadays, I use the wildcard character, *****, *but only* in combination
    with a **firewall IP restriction**, to secure my setup. We will configure the
    firewall IP restriction later in this section (see *Creating a* *firewall rule*):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，时至今日，我只在与**防火墙 IP 限制**结合使用时，才使用通配符（*****）来保护我的设置。我们将在本节稍后配置防火墙 IP 限制（见*创建防火墙规则*）：
- en: '![Figure 3.3 – Configuring Allow remote server management through WinRM](image/B16679_03_003.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 配置允许通过 WinRM 进行远程服务器管理](image/B16679_03_003.jpg)'
- en: Figure 3.3 – Configuring Allow remote server management through WinRM
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 配置允许通过 WinRM 进行远程服务器管理
- en: Caution!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！
- en: Only use the wildcard (*****) configuration if you wish to restrict via a firewall
    rule that remote IPs are allowed to connect to.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在您希望通过防火墙规则限制允许远程 IP 连接时，才使用通配符（*****）配置。
- en: Configuring the WinRM service to start automatically
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 WinRM 服务为自动启动
- en: 'To configure the WinRM service so that it starts automatically, follow these
    steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 WinRM 服务使其自动启动，请按以下步骤操作：
- en: Use the same GPO and navigate to **Computer Configuration** | **Policies** |
    **Windows Settings** | **Security Settings** | **System Services**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的 GPO，并导航到**计算机配置** | **策略** | **Windows 设置** | **安全设置** | **系统服务**。
- en: Select and configure the **Windows Remote Management (WS** **Management)** setting.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并配置**Windows 远程管理（WS 管理）**设置。
- en: A new window will open. Check the **Define this policy setting** option and
    set the service startup mode to **Automatic**.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打开一个新窗口。勾选**定义此策略设置**选项，并将服务启动模式设置为**自动**。
- en: 'Confirm your configuration by clicking **OK**:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**确定**按钮确认您的配置：
- en: '![Figure 3.4 – Configuring the Windows Remote Management service so that it
    starts automatically](image/B16679_03_004.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 配置 Windows 远程管理服务，使其自动启动](image/B16679_03_004.jpg)'
- en: Figure 3.4 – Configuring the Windows Remote Management service so that it starts
    automatically
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 配置 Windows 远程管理服务，使其自动启动
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This setting only configures the service to start automatically, which usually
    happens when your computer starts. It does not start the service for you, so make
    sure that you reboot your computer (or start the service manually) so that the
    WinRM service starts automatically.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置仅配置服务为自动启动，通常在计算机启动时发生。它不会为您启动服务，因此请确保重新启动计算机（或手动启动服务），以便 WinRM 服务自动启动。
- en: Creating a firewall rule
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建防火墙规则
- en: 'To configure the settings of the firewall, follow these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置防火墙设置，请按照以下步骤操作：
- en: Navigate to **Computer Configuration** | **Policies** | **Windows Settings**
    | **Security Settings** | **Windows Defender Firewall with Advanced Security**
    | **Windows Defender Firewall with Advanced Security** | **Inbound Rules**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**计算机配置** | **策略** | **Windows 设置** | **安全设置** | **Windows Defender 防火墙（高级安全性）**
    | **Windows Defender 防火墙（高级安全性）** | **入站规则**。
- en: Create a new inbound rule using the wizard.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用向导创建一个新的入站规则。
- en: 'Check the **Predefined** option and select **Windows** **Remote Management**:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**预定义**选项，并选择**Windows 远程管理**：
- en: '![Figure 3.5 – Creating a predefined Windows Remote Management firewall rule](image/B16679_03_005.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 创建预定义的 Windows 远程管理防火墙规则](image/B16679_03_005.jpg)'
- en: Figure 3.5 – Creating a predefined Windows Remote Management firewall rule
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 创建预定义的 Windows 远程管理防火墙规则
- en: 'Click **Next** and remove the **Public** firewall profile by deselecting the
    option shown in the following screenshot:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，并通过取消选择下图中显示的选项来移除**公共**防火墙配置文件：
- en: '![Figure 3.6 – Deselecting the public network profile](image/B16679_03_006.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 取消选择公共网络配置文件](image/B16679_03_006.jpg)'
- en: Figure 3.6 – Deselecting the public network profile
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 取消选择公共网络配置文件
- en: 'Finally, select **Allow the connection** before confirming your configuration
    by clicking the **Finish** button:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择**允许连接**，然后点击**完成**按钮确认配置：
- en: '![Figure 3.7 – Allow the connection](image/B16679_03_007.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 允许连接](image/B16679_03_007.jpg)'
- en: Figure 3.7 – Allow the connection
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 允许连接
- en: 'The new rule will be created, and shown in your GPO:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 新规则将被创建，并显示在您的 GPO 中：
- en: '![Figure 3.8 – Displaying the new inbound firewall rule](image/B16679_03_008.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.8 – 显示新的入站防火墙规则](image/B16679_03_008.jpg)'
- en: Figure 3.8 – Displaying the new inbound firewall rule
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 显示新的入站防火墙规则
- en: Before exiting the GPO configuration, make sure you open your newly created
    firewall rule once again by double-clicking it. The **Windows Remote Management
    (HTTP-In) Properties** window will open.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出GPO配置之前，确保通过双击重新打开新创建的防火墙规则。将打开**Windows远程管理（HTTP-In）属性**窗口。
- en: 'Optional: if your machines reside in the same domain, navigate to the **Advanced**
    tab and deselect the **Private** profile to make sure that a remote connection
    using WinRM is only allowed within the **Domain** network profile:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选：如果您的计算机位于同一个域中，请导航到**Advanced**选项卡，并取消选择**Private**配置文件，以确保仅允许使用WinRM进行远程连接在**Domain**网络配置文件中：
- en: '![Figure 3.9 – Only allowing WinRM within the Domain network profile](image/B16679_03_009.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.9 – 仅允许在域网络配置文件中使用WinRM](image/B16679_03_009.jpg)'
- en: Figure 3.9 – Only allowing WinRM within the Domain network profile
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 仅允许在域网络配置文件中使用WinRM
- en: 'Then, navigate to the **Scope** tab and add all remote IP addresses from which
    it should be allowed to access the computer remotely. For instance, if you have
    a management subnet on your network, you can add the IP addresses within that
    subnet to the list:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到**Scope**选项卡，并添加允许从中远程访问计算机的所有远程IP地址。例如，如果您的网络上有一个管理子网，可以将该子网中的IP地址添加到列表中：
- en: '![Figure 3.10 – Configuring which remote IP addresses are allowed to connect](image/B16679_03_010.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.10 – 配置允许连接的远程IP地址](image/B16679_03_010.jpg)'
- en: Figure 3.10 – Configuring which remote IP addresses are allowed to connect
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 配置允许连接的远程IP地址
- en: In the best case, allow only a hardened, secure management system to manage
    systems via PSRemoting.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，只允许一个经过加固和安全管理的系统通过PSRemoting管理系统。
- en: 'Use the clean source principle to build the management system and use the recommended
    privileged access model to access it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用清洁的源原则构建管理系统，并使用推荐的特权访问模型进行访问：
- en: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle](https://learn.microsoft.com/zh-cn/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle)'
- en: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/security/privileged-access-workstations/privileged-access-access-model](https://learn.microsoft.com/zh-cn/security/privileged-access-workstations/privileged-access-access-model)'
- en: PowerShell endpoints (session configurations)
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell端点（会话配置）
- en: In this chapter, you might have read the term **endpoint** several times.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您可能已经多次读到**端点**一词。
- en: 'If we are talking about endpoints, we are not talking about one computer: PSRemoting
    is designed to work with multiple endpoints on a computer.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论端点，我们不是在谈论一个计算机：PSRemoting设计用于在计算机上使用多个端点。
- en: But what exactly is an endpoint?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但是端点到底是什么？
- en: When we are talking about PowerShell endpoints, *each endpoint is a session
    configuration*, which you can configure to offer certain services or which you
    can also restrict.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论PowerShell端点时，*每个端点都是一个会话配置*，您可以配置为提供某些服务或限制某些服务。
- en: So, every time we run **Invoke-Command** or enter a PowerShell session, we are
    connecting to an endpoint (also known as a remote session configuration).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次运行**Invoke-Command**或进入PowerShell会话时，我们都是在连接到一个端点（也称为远程会话配置）。
- en: Sessions that offer fewer cmdlets, functions, and features, as those that are
    usually available if no restrictions are in place, are called **constrained endpoints**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置限制，则提供更少的cmdlet、函数和功能的会话称为**受限制的端点**。
- en: Before we enable PSRemoting, no endpoint will have been configured on the computer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用PSRemoting之前，计算机上将没有配置任何端点。
- en: 'You can see all the available session configurations by running the **Get-PSSessionConfiguration**
    command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行**Get-PSSessionConfiguration**命令查看所有可用的会话配置。
- en: '![Figure 3.11 – No endpoint is shown when PSRemoting is not enabled](image/B16679_03_011.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3.11 – 当未启用PSRemoting时不显示端点](image/B16679_03_011.jpg)'
- en: Figure 3.11 – No endpoint is shown when PSRemoting is not enabled
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 当未启用 PSRemoting 时，未显示任何端点
- en: When PSRemoting is not enabled on a computer, no endpoint will be shown. This
    is because the WinRM service, which is responsible for PSRemoting, is not started
    by default. However, once the WinRM service is started, the endpoints are already
    configured and ready to use, but not exposed and cannot be connected to until
    PSRemoting is enabled.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机上未启用 PSRemoting 时，不会显示任何端点。这是因为负责 PSRemoting 的 WinRM 服务默认未启动。然而，一旦启动 WinRM
    服务，端点已经配置好并准备使用，但在启用 PSRemoting 之前不会暴露，也无法连接。
- en: 'Enabling PSRemoting using **Enable-PSRemoting**, as we did in the previous
    section, creates all default session configurations, which are necessary to connect
    to this endpoint via PSRemoting:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Enable-PSRemoting** 启用 PSRemoting，正如我们在上一节中所做的那样，会创建所有默认的会话配置，这些配置对于通过
    PSRemoting 连接到此端点是必要的：
- en: '![Figure 3.12 – After enabling PSRemoting, we can see all the prepopulated
    endpoints](image/B16679_03_012.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 启用 PSRemoting 后，我们可以看到所有预填充的端点](image/B16679_03_012.jpg)'
- en: Figure 3.12 – After enabling PSRemoting, we can see all the prepopulated endpoints
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 启用 PSRemoting 后，我们可以看到所有预填充的端点
- en: 'Typically, in Windows PowerShell 3.0 and above, there are three default preconfigured
    endpoints on client systems:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 Windows PowerShell 3.0 及以上版本中，客户端系统上会有三个默认预配置的端点：
- en: '**microsoft.powershell**: This is the standard endpoint and is used for PSRemoting
    connections if not specified otherwise'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**microsoft.powershell**：这是标准端点，默认情况下用于 PSRemoting 连接，除非另行指定'
- en: '**microsoft.powershell32**: This is a 32-bit endpoint that’s optional if you’re
    running a 64-bit operating system'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**microsoft.powershell32**：这是一个 32 位端点，如果您使用的是 64 位操作系统，则此端点为可选项。'
- en: '**microsoft.powershell.workflow**: This endpoint is for PowerShell workflows
    – h[ttps://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019](https://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**microsoft.powershell.workflow**：此端点用于 PowerShell 工作流 – [https://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019](https://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019)'
- en: )
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'On *server systems*, there’s typically a fourth session configuration that’s
    predefined:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在*服务器系统*中，通常会有一个预定义的第四会话配置：
- en: '**microsoft.windows.servermanagerworkflows**: This endpoint is for Server Manager
    workflows – https://docs.microsoft.com/en-us/windows-server/administration/server-manager/server-manager'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**microsoft.windows.servermanagerworkflows**：此端点用于服务器管理器工作流 – https://docs.microsoft.com/en-us/windows-server/administration/server-manager/server-manager'
- en: Every computer will show different default endpoints. In the preceding example,
    I ran the command on a Windows 10 client, which will show fewer endpoints than,
    for example, Windows Server 2019.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每台计算机会显示不同的默认端点。在上面的示例中，我在一台 Windows 10 客户端上运行命令，这将显示比 Windows Server 2019 更少的端点。
- en: Connecting to a specified endpoint
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到指定的端点
- en: 'By default, the **microsoft.powershell** endpoint is used for all PSRemoting
    connections. But if you want to connect to another specified endpoint, you can
    do this by using the **-****ConfigurationName** parameter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**microsoft.powershell** 端点用于所有 PSRemoting 连接。但如果您希望连接到另一个指定的端点，您可以使用
    **-ConfigurationName** 参数来实现：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The specified configuration can be either the name of another default or a custom
    endpoint.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的配置可以是另一个默认端点的名称，也可以是自定义端点。
- en: Creating a custom endpoint – a peek into JEA
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义端点——JEA 概览
- en: 'Creating a custom endpoint (also known as **Just Enough Administration** or
    **JEA**) allows you to define a restricted administrative environment for delegated
    administration. With JEA, you can define a set of approved commands and parameters
    that are allowed to be executed on specific machines by specific users. This enables
    you to give users just enough permissions to perform their job duties, without
    granting them full administrative access. It is a great way to secure your remote
    connections:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义端点（也称为**仅足够的管理**或**JEA**）允许您为委派的管理定义一个受限的管理环境。通过 JEA，您可以定义一组批准的命令和参数，允许特定用户在特定计算机上执行。这使您能够为用户提供执行工作职责所需的最低权限，而不授予他们完全的管理权限。这是保护远程连接的好方法：
- en: You can restrict the session so that only predefined commands will be run.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以限制会话，只运行预定义的命令。
- en: You can enable transcription so that every command that is executed in this
    session is logged.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以启用记录功能，以便记录在此会话中执行的每个命令。
- en: You can specify a security descriptor (SDDL) to determine who is allowed to
    connect and who isn’t.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以指定一个安全描述符（SDDL）来确定谁可以连接，谁不能连接。
- en: You can configure scripts and modules that will be automatically loaded as soon
    as the connection to this endpoint is established.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以配置脚本和模块，这些脚本和模块将在与此端点建立连接后自动加载。
- en: You can even specify that another account is used to run your commands in this
    session on the endpoint.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至可以指定使用另一个账户来在端点上运行此会话中的命令。
- en: 'To create and activate an endpoint, two steps need to be followed:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和激活端点，需要遵循两个步骤：
- en: Creating a session configuration file
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建会话配置文件
- en: Registering the session as a new endpoint
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会话注册为新的端点
- en: Creating a session configuration file
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建会话配置文件
- en: 'Using **New-PSSessionConfigurationFile**, you can create an empty skeleton
    session configuration file. You need to specify the path where the configuration
    file will be saved, so the **-Path** parameter is mandatory. A session configuration
    file ends with the **.pssc** filename extension, so make sure you name the file
    accordingly:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**New-PSSessionConfigurationFile**，你可以创建一个空的骨架会话配置文件。你需要指定配置文件将保存的路径，因此**-Path**参数是必需的。会话配置文件以**.pssc**文件扩展名结尾，所以请确保文件命名正确：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have a look at the official documentation for more information: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看官方文档以获取更多信息：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile)。
- en: 'You can either generate an empty session configuration file and populate it
    later using an editor or you can use the **New-PSSessionConfigurationFile** parameters
    to directly generate the file with all its defined configuration options:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以生成一个空的会话配置文件，然后稍后使用编辑器填写它，或者你也可以使用**New-PSSessionConfigurationFile**参数直接生成包含所有已定义配置选项的文件：
- en: '![Figure 3.13 – New-PSSessionConfigurationFile parameters](image/B16679_03_013.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – New-PSSessionConfigurationFile 参数](image/B16679_03_013.jpg)'
- en: Figure 3.13 – New-PSSessionConfigurationFile parameters
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – New-PSSessionConfigurationFile 参数
- en: 'For this example, we will create a session configuration file for a **RestrictedRemoteServer**
    session:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将为**RestrictedRemoteServer**会话创建一个会话配置文件：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By using **-SessionType RestrictedRemoteServer**, only the most important commands
    are being imported into this session, such as **Exit-PSSession**, **Get-Command**,
    **Get-FormatData**, **Get-Help**, **Measure-Object**, **Out-Default**, and **Select-Object**.
    If you want to allow other commands in this session, they need to be configured
    in the role capability file, which we will discuss in detail in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278),
    *Language Modes and Just Enough* *Administration (JEA)*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**-SessionType RestrictedRemoteServer**，只有最重要的命令会被导入到此会话中，如**Exit-PSSession**、**Get-Command**、**Get-FormatData**、**Get-Help**、**Measure-Object**、**Out-Default**和**Select-Object**。如果你希望在此会话中允许其他命令，它们需要在角色能力文件中进行配置，我们将在[*第10章*](B16679_10_Final_PD.xhtml#_idTextAnchor278)中详细讨论，*语言模式和足够的*
    *管理（JEA）*。
- en: Registering the session as a new endpoint
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将会话注册为新的端点
- en: After creating the session configuration file, you must register it as an endpoint
    by utilizing the **Register-PSSessionConfiguration** command.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建会话配置文件后，你必须通过使用**Register-PSSessionConfiguration**命令将其注册为端点。
- en: 'When utilizing the mandatory **-Name** parameter, make sure you only specify
    the name of the session configuration file, without including the filename extension:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用必需的**-Name**参数时，请确保只指定会话配置文件的名称，不包括文件扩展名：
- en: '[PRE36]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The session configuration will be registered, and a new endpoint will be created.
    Sometimes, it might be necessary to restart the WinRM service after registering
    an endpoint:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 会话配置将被注册，并且一个新的端点将被创建。有时，在注册端点后，可能需要重启WinRM服务：
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using **Get-PSSessionConfiguration**, you can verify that the endpoint was created.
    If you specify the endpoint name using the **-Name** parameter, as in the preceding
    example, you will only get the information relevant to the specified endpoint.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Get-PSSessionConfiguration**，你可以验证端点是否已创建。如果你使用**-Name**参数指定端点名称，如前面的示例所示，你将只获得与指定端点相关的信息。
- en: We will have a deeper look into the possible session configuration and registering
    parameters in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278), *Language
    Modes and Just Enough* *Administration (JEA)*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第10章*](B16679_10_Final_PD.xhtml#_idTextAnchor278)《语言模式与恰到好处的管理（JEA）》中深入探讨可能的会话配置和注册参数。
- en: PowerShell remoting authentication and security considerations
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 远程认证和安全性注意事项
- en: PSRemoting traffic is encrypted by default – regardless of whether a connection
    was initiated via HTTP or HTTPS. The underlying protocol that’s used is WS-Man,
    which is decoupled to allow it to be used more broadly. PSRemoting uses an authentication
    protocol, such as Kerberos or NTLM, to authenticate the session traffic, and SSL/TLS
    is used to encrypt the session traffic, regardless of whether the connection was
    initiated via HTTP or HTTPS.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PSRemoting 流量是加密的——无论连接是通过 HTTP 还是 HTTPS 发起。所使用的底层协议是 WS-Man，它是解耦的，可以更广泛地使用。PSRemoting
    使用认证协议，如 Kerberos 或 NTLM，来验证会话流量，SSL/TLS 用于加密会话流量，无论连接是通过 HTTP 还是 HTTPS 发起的。
- en: But similar to every other computer, PSRemoting is only as secure as the computer
    that’s been configured. And if you don’t secure your administrator’s credentials,
    an attacker can extract and use them against you.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但与其他计算机类似，PSRemoting 的安全性取决于已配置的计算机。如果你不保护管理员的凭证，攻击者可以提取并利用它们对付你。
- en: Therefore, you should also put effort into hardening your infrastructure and
    securing your most valuable identities. You will learn more about Active Directory
    security and credential hygiene in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150),
    *Active Directory – Attacks and Mitigations*, and learn more about what mitigations
    you can put in place in *Part 3*, *Securing PowerShell – Effective Mitigations*
    *in Detail*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你也应该努力加强基础设施的安全性，并保护你最重要的身份。你将在[*第6章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)《Active
    Directory – 攻击与缓解》中了解更多关于 Active Directory 安全性和凭证管理的内容，并在*第3部分*《保护 PowerShell
    – 有效的缓解措施*详细讲解*中了解更多你可以采取的缓解措施。
- en: It’s important to understand that enabling PSRemoting does not automatically
    ensure a secure environment. As with any remote management technology, it’s critical
    to harden your systems and take appropriate security measures to protect against
    potential threats. This applies not only to PSRemoting but also to other remote
    management technologies, such as RDP. By investing time and effort into securing
    your systems and environment, you can mitigate potential risks and better protect
    your organization’s assets.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 了解启用 PSRemoting 并不会自动确保环境的安全非常重要。与任何远程管理技术一样，关键在于加固你的系统并采取适当的安全措施，以防范潜在的威胁。这不仅适用于
    PSRemoting，还适用于其他远程管理技术，如 RDP。通过投入时间和精力来保护你的系统和环境，你可以降低潜在风险，更好地保护组织的资产。
- en: First, let’s have a look at how authentication is used within PSRemoting.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在 PSRemoting 中如何使用认证。
- en: Authentication
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: By default, WinRM uses **Kerberos** for authentication and falls back to **NTLM**
    in case Kerberos authentication is not possible.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WinRM 使用**Kerberos**进行认证，若 Kerberos 认证不可用，则回退使用**NTLM**。
- en: When used within a domain, Kerberos is the standard to authenticate. To use
    Kerberos for authentication in PSRemoting, ensure that both the client and server
    computers are connected to the same domain and that the DNS names have been properly
    configured and are reachable. It’s also important to note that from a Kerberos
    perspective, the server must be registered in Active Directory.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在域中使用时，Kerberos 是认证的标准。要在 PSRemoting 中使用 Kerberos 认证，确保客户端和服务器计算机连接到同一域，并且 DNS
    名称已正确配置且可达。还需要注意的是，从 Kerberos 的角度来看，服务器必须在 Active Directory 中注册。
- en: 'In general, you can specify which protocol should be used when connecting to
    a remote computer:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以指定连接远程计算机时应该使用哪种协议：
- en: '[PRE38]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When establishing a PSRemoting session, if the **-Authentication** parameter
    is not specified, the default value of **Default** is used, which is equal to
    the **Negotiate** value. This means that the client and server negotiate the best
    authentication protocol to use based on what is supported by both systems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立 PSRemoting 会话时，如果没有指定**-Authentication**参数，则使用默认值**Default**，该值等于**Negotiate**。这意味着客户端和服务器根据双方系统支持的认证协议协商使用最佳的认证协议。
- en: 'Typically, *Kerberos* is the preferred protocol, but if it’s not available
    or supported, the system will fall back to using *NTLM*. More information about
    **Negotiate** can be found in the Microsoft documentation for Negotiate in Win32
    applications: [https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate](https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，*Kerberos* 是首选协议，但如果不可用或不被支持，系统将回退使用 *NTLM*。关于 **Negotiate** 的更多信息可以在微软文档中找到，详见
    Win32 应用程序中的 Negotiate：[https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate](https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate)。
- en: What are the circumstances for an NTLM fallback?
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么情况下会回退到 NTLM？
- en: PSRemoting was designed to work with Active Directory, so Kerberos is the preferred
    authentication protocol. But in some cases, Kerberos authentication is not possible
    and NTLM is used.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: PSRemoting 设计时是为了与 Active Directory 配合使用，因此 Kerberos 是首选的身份验证协议。但在某些情况下，Kerberos
    身份验证不可用，此时将使用 NTLM。
- en: '**Kerberos**:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kerberos**：'
- en: Computers are joined to the same domain or are both within domains that trust
    each other.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机已加入相同的域，或者它们都位于相互信任的域内。
- en: The client can resolve the server’s hostname or IP address.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端能够解析服务器的主机名或 IP 地址。
- en: The server has a valid **Service Principal Name** (**SPN**) registered in Active
    Directory. The SPN matches the target you are connecting to.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器在 Active Directory 中注册了有效的 **服务主体名称**（**SPN**）。该 SPN 与你连接的目标匹配。
- en: '**NTLM**:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTLM**：'
- en: Commonly used to connect to non-domain-joined workstations
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用于连接非域加入的工作站
- en: If IP addresses are used instead of DNS names
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用的是 IP 地址而不是 DNS 名称
- en: 'To connect to the **PSSec-PC01** computer via Kerberos, we can use the following
    command:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Kerberos 连接到 **PSSec-PC01** 计算机，我们可以使用以下命令：
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If no credentials were explicitly specified, if the current user has permission
    to access the remote computer, and if the remote computer is configured to accept
    Kerberos authentication, the connection will be established automatically without
    the need to provide any explicit credentials. This is one of the benefits of using
    Kerberos authentication, as the authentication process is implicit and seamless
    for the user.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确指定凭据，并且当前用户有权限访问远程计算机，同时远程计算机已配置为接受 Kerberos 身份验证，则连接会自动建立，无需提供任何明确的凭据。这是使用
    Kerberos 身份验证的一个优势，因为身份验证过程对于用户来说是隐式和无缝的。
- en: 'If the current user does not have permission to access the remote computer,
    we can also specify explicitly which credentials should be used with the **-Credential**
    parameter. To simplify testing, we use **Get-Credential** to prompt for the credentials
    and store them in the **$cred** secure string:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前用户没有权限访问远程计算机，我们还可以明确指定应使用的凭据，方法是使用 **-Credential** 参数。为了简化测试，我们使用 **Get-Credential**
    来提示输入凭据，并将其存储在 **$cred** 安全字符串中：
- en: '[PRE40]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we connect via Kerberos:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过 Kerberos 进行连接：
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you capture the traffic using Wireshark, you will see that WinRM includes
    Kerberos as its **content-type** as part of its protocol, indicating that Kerberos
    was used for authentication. While the actual Kerberos traffic itself may not
    be visible in the HTTP packet, the use of Kerberos for authentication can still
    be confirmed by examining the headers in the WinRM traffic. Additionally, you
    can see that the entire HTTP session is encrypted, providing an added layer of
    security:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Wireshark 捕获流量，你会看到 WinRM 在其协议中将 Kerberos 包含为 **content-type**，这表明 Kerberos
    被用于身份验证。虽然实际的 Kerberos 流量可能不会在 HTTP 数据包中直接显示，但通过检查 WinRM 流量中的报文头，仍然可以确认使用了 Kerberos
    进行身份验证。此外，你还可以看到整个 HTTP 会话是加密的，提供了额外的安全保障：
- en: '![Figure 3.14 – WinRM HTTP traffic captured with Wireshark](image/B16679_03_014.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 使用 Wireshark 捕获的 WinRM HTTP 流量](image/B16679_03_014.jpg)'
- en: Figure 3.14 – WinRM HTTP traffic captured with Wireshark
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 使用 Wireshark 捕获的 WinRM HTTP 流量
- en: As you can see, a session to **PSSec-PC01** has been established over port **5985**
    (WinRM over HTTP), using PowerShell version 5.1.17763.1490\. The request was sent
    via WS-Man.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，已经通过端口 **5985**（WinRM over HTTP）与 **PSSec-PC01** 建立了会话，使用的是 PowerShell
    版本 5.1.17763.1490。请求是通过 WS-Man 发送的。
- en: Once the initial authentication process is complete, WinRM proceeds to encrypt
    all ongoing communication to maintain the security of the data being exchanged
    between the client and server. When establishing a connection over HTTPS, the
    TLS protocol is utilized to negotiate the encryption method used for data transportation.
    In the case of an HTTP connection, the encryption that’s utilized for message-level
    encryption is determined by the initial authentication protocol used.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始身份验证过程完成，WinRM 会继续加密所有后续通信，以确保客户端和服务器之间交换的数据的安全性。当通过 HTTPS 建立连接时，TLS 协议将用于协商用于数据传输的加密方式。如果是
    HTTP 连接，则用于消息级加密的加密方式由初始身份验证协议决定。
- en: 'The level of encryption provided by each authentication protocol is as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 各种身份验证协议提供的加密级别如下：
- en: '**Basic authentication**: No encryption.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本身份验证**：没有加密。'
- en: '**NTLM authentication**: RC4 cipher with a 128-bit key.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NTLM 身份验证**：使用 RC4 算法和 128 位密钥。'
- en: '**Kerberos authentication**: **etype** in the TGS ticket determines the encryption.
    On modern systems, this is typically AES-256.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kerberos 身份验证**：TGS 票据中的 **etype** 决定了加密方式。在现代系统中，这通常是 AES-256。'
- en: '**CredSSP authentication**: The TLS cipher suite that was negotiated in the
    handshake will be used.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CredSSP 身份验证**：将在握手过程中协商的 TLS 密码套件被使用。'
- en: 'Note that while the HTTP protocol is used as the connection protocol, the content
    is encrypted using the appropriate encryption mechanism based on the initial authentication
    protocol used. A common misconception about PSRemoting is that a connection using
    WinRM over HTTP is not encrypted. However, as you can see in the following screenshot,
    this is not the case:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管使用的是 HTTP 协议作为连接协议，但内容是根据初始身份验证协议使用适当的加密机制进行加密的。关于 PSRemoting 的一个常见误解是，使用
    WinRM 通过 HTTP 连接时没有加密。然而，正如你在下图所看到的，事实并非如此：
- en: '![Figure 3.15 – Kerberos TCP stream captured with Wireshark](image/B16679_03_015.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 使用 Wireshark 捕获的 Kerberos TCP 流](image/B16679_03_015.jpg)'
- en: Figure 3.15 – Kerberos TCP stream captured with Wireshark
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 使用 Wireshark 捕获的 Kerberos TCP 流
- en: If DNS names are not working and if both hosts are not joined to the same domain,
    NTLM will be used as a fallback option.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 DNS 名称无法正常工作，并且两个主机不在同一域内，则 NTLM 将作为回退选项使用。
- en: 'If you are connecting to a remote computer in the same domain, with working
    DNS names, NTLM is still used to connect if the host IP address is specified instead
    of the hostname:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在连接同一域内的远程计算机，并且 DNS 名称正常工作，当指定主机的 IP 地址而非主机名时，仍然会使用 NTLM 进行连接：
- en: '[PRE42]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Capturing the traffic with Wireshark once more reveals that NTLM was used to
    authenticate and that the traffic is encrypted as well:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 Wireshark 捕获流量显示，NTLM 被用于身份验证，并且流量也被加密了：
- en: '![Figure 3.16 – NTLM traffic captured with Wireshark](image/B16679_03_016.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 使用 Wireshark 捕获的 NTLM 流量](image/B16679_03_016.jpg)'
- en: Figure 3.16 – NTLM traffic captured with Wireshark
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 使用 Wireshark 捕获的 NTLM 流量
- en: Similar to connecting with Kerberos, you can see that a connection is established
    to the host, **172.29.0.12**, using WinRM over HTTP (port **5985**). But this
    time, NTLM is used instead of Kerberos to negotiate the session. Using NTLM, you
    can even capture the hostname, the username, the domain name, and the challenge,
    which is used for authentication.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用 Kerberos 连接，你可以看到与主机 **172.29.0.12** 的连接是通过 HTTP（端口 **5985**）使用 WinRM
    建立的。但这次，使用 NTLM 代替 Kerberos 来协商会话。使用 NTLM，你甚至可以捕获主机名、用户名、域名和挑战，这些信息用于身份验证。
- en: 'Going deeper into the TCP stream, it becomes evident that the communication
    is once again encrypted, even when NTLM is used, as shown in the following screenshot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 深入查看 TCP 流时，可以明显看到即使使用 NTLM，通信也是加密的，如下图所示：
- en: '![Figure 3.17 – NTLM TCP stream captured with Wireshark](image/B16679_03_017.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 使用 Wireshark 捕获的 NTLM TCP 流](image/B16679_03_017.jpg)'
- en: Figure 3.17 – NTLM TCP stream captured with Wireshark
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 使用 Wireshark 捕获的 NTLM TCP 流
- en: When using NTLM authentication, please note that PSRemoting only works if the
    remote host was added to the **TrustedHosts** list.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NTLM 身份验证时，请注意，PSRemoting 仅在远程主机已添加到 **TrustedHosts** 列表中时才能正常工作。
- en: When using NTLM authentication, it’s important to understand the limitations
    of the **TrustedHosts** list. While adding a remote host to the **TrustedHosts**
    list can help you catch your mistakes, it’s not a reliable way to ensure secure
    communication. This is because NTLM can’t guarantee that you are connecting to
    the intended remote host, which makes using **TrustedHosts** misleading. It’s
    important to note that the main weakness of NTLM is its inability to verify the
    identity of the remote host. Therefore, even with **TrustedHosts**, NTLM connections
    shouldn’t be considered more trustworthy.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NTLM 身份验证时，了解**受信主机**列表的限制非常重要。虽然将远程主机添加到**受信主机**列表可以帮助你发现错误，但它并不是确保安全通信的可靠方法。这是因为
    NTLM 无法保证你正在连接到预定的远程主机，这使得使用**受信主机**具有误导性。值得注意的是，NTLM 的主要弱点在于它无法验证远程主机的身份。因此，即使使用了**受信主机**，NTLM
    连接也不应被视为更可信。
- en: 'If the host is not specified as a trusted host and if the credentials are not
    explicitly provided (like we did when using **-Credential $cred**), establishing
    a remote session or running commands remotely will fail and show an error message:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机没有被指定为受信主机，并且没有明确提供凭据（就像我们在使用**-Credential $cred**时做的那样），则建立远程会话或远程运行命令将失败，并显示错误信息：
- en: '[PRE43]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Kerberos and NTLM are not the only authentication protocols, but they are the
    most secure compared with others. Let’s have a look at what other methods exist
    and how you can enforce them.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Kerberos 和 NTLM 并不是唯一的身份验证协议，但与其他协议相比，它们是最安全的。让我们看看还有哪些其他方法，并了解如何强制执行它们。
- en: Authentication protocols
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证协议
- en: Of course, it is also possible to configure which authentication method should
    be used by specifying the **-****Authentication** parameter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以通过指定**-****身份验证**参数来配置应使用哪种身份验证方法。
- en: Authentication protocols
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证协议
- en: If it is possible to use Kerberos authentication, you should always use Kerberos,
    as this protocol provides most security features.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以使用 Kerberos 身份验证，应该始终使用 Kerberos，因为该协议提供了大部分安全功能。
- en: Proceed to [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150), *Active
    Directory – Attacks and Mitigation*, to learn more about authentication and how
    Kerberos and NTLM work.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读[*第 6 章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)，*活动目录 – 攻击与缓解*，了解更多关于身份验证的内容以及
    Kerberos 和 NTLM 的工作原理。
- en: 'The following are all accepted values for the **-****Authentication** parameter:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有接受的**-****身份验证**参数的值：
- en: '**Default**: This is the default value. Here, **Negotiate** will be used.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：这是默认值。在这里，将使用**协商**。'
- en: '**Basic**: Basic authentication is used to authenticate, using the HTTP protocol,
    but does not provide security by itself – neither for the data, which is transported
    in cleartext over the network, nor for the credentials. However, when paired with
    TLS, this can still be a reasonably secure mechanism and is commonly used by many
    websites.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本**：基本身份验证用于通过 HTTP 协议进行身份验证，但本身并不提供安全性——既不保护通过网络以明文传输的数据，也不保护凭据。然而，当与 TLS
    配合使用时，这仍然是一种相对安全的机制，许多网站通常会使用它。'
- en: As the credentials are only encoded using Base64 encoding, the encryption can
    easily be reversed and the credentials can be extracted in cleartext.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于凭据仅使用 Base64 编码，编码可以很容易地被逆向解码，凭据也可以以明文形式提取出来。
- en: This authentication does not provide confidentially for the provided credentials
    if they’re not encrypted with **SSL**/**TLS**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果凭据没有使用**SSL**/**TLS**加密，这种身份验证无法为提供的凭据提供机密性。
- en: '**Credssp**: Using the **CredSSP** authentication, the user’s credentials will
    be provided by PowerShell from the client to the remote server to authenticate
    the user. This mode is particularly useful in situations where you need the remote
    session to be able to authenticate as you for further network hops. After this
    authentication, the credentials are passed between the client and server in an
    encrypted format to maintain security.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Credssp**：使用**CredSSP**身份验证，PowerShell 会从客户端将用户凭据提供给远程服务器以进行身份验证。此模式在需要远程会话能够像你一样进行身份验证以便进行进一步的网络跳转时特别有用。在此身份验证之后，凭据以加密格式在客户端和服务器之间传递，以保持安全性。'
- en: When using the CredSSP authentication mechanism, PowerShell passes the user’s
    full credentials to the remote server for authentication. This means that if you
    connect to a compromised machine, an adversary can extract your credentials directly
    from memory. It’s important to note that this is the default authentication mechanism
    of RDP, making PSRemoting a more secure alternative.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CredSSP身份验证机制时，PowerShell将用户的完整凭据传递给远程服务器进行身份验证。这意味着，如果你连接到一个被攻破的机器，攻击者可以直接从内存中提取你的凭据。需要注意的是，这是RDP的默认身份验证机制，使得PSRemoting成为一个更安全的替代方案。
- en: '**Digest**: Digest authentication is one of the methods a web server can use
    for authentication. The username and password are hashed using **MD5** cryptography
    algorithms before they’re sent over the network using the **HTTP** protocol. Before
    hashing, a nonce is added to avoid replay attacks.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Digest**：摘要认证是Web服务器可以使用的一种身份验证方法。在发送数据之前，用户名和密码会使用**MD5**加密算法进行哈希处理，并通过**HTTP**协议进行传输。在哈希处理之前，会添加一个nonce值以避免重放攻击。'
- en: It does not provide strong authentication compared to other authentication protocols
    (for example, key-based ones), but it is still stronger than weaker authentication
    mechanisms and should be considered as a replacement for weak basic authentication.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他身份验证协议（例如基于密钥的身份验证）相比，它并不提供强大的身份验证，但它仍然比较弱的身份验证机制更强，应该作为弱基本认证的替代方案考虑。
- en: '**Kerberos**: This form of authentication uses the Kerberos protocol. Kerberos
    is the standard to authenticate in a domain and provides the highest security.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kerberos**：这种身份验证方式使用Kerberos协议。Kerberos是域认证的标准，并提供最高级别的安全性。'
- en: '**Negotiate**: This option allows the client to negotiate the authentication.
    When a domain account is used, the authentication will be via Kerberos; with a
    local account, it falls back to NTLM.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Negotiate**：此选项允许客户端协商身份验证。当使用域账户时，身份验证将通过Kerberos进行；使用本地账户时，将回退到NTLM。'
- en: '**NegotiateWithImplicitCredential**: This option uses the current user’s credentials
    to authenticate (run as).'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NegotiateWithImplicitCredential**：此选项使用当前用户的凭据进行身份验证（以当前用户身份运行）。'
- en: These authentication mechanisms can be used within all PSRemoting cmdlets.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这些身份验证机制可以在所有PSRemoting cmdlet中使用。
- en: 'They are also specified in the **AuthenticationMechanism** **enum**, which
    is defined in Microsoft docs: https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.runspaces.authenticationmechanism.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也在**AuthenticationMechanism** **枚举**中进行了指定，该枚举在微软文档中定义：https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.runspaces.authenticationmechanism。
- en: It’s important to note that PowerShell considers some authentication mechanisms
    as potentially dangerous and may show error messages if you try to use them. In
    such cases, you would need to explicitly override these errors to proceed with
    the dangerous authentication mechanism.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，PowerShell将一些身份验证机制视为潜在危险，并且如果你尝试使用它们，可能会显示错误消息。在这种情况下，你需要明确地覆盖这些错误，才能继续使用这些危险的身份验证机制。
- en: Basic authentication security considerations
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证安全考虑事项
- en: If used without any additional encryption layers, basic authentication is not
    secure. In this section we are going to explore a very good example of why you
    should not use basic authentication or why you should always encrypt your communication
    using **Transport Layer Security** (**TLS**) if you have to use basic authentication.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在没有其他加密层的情况下使用，基本认证是不安全的。在本节中，我们将探讨一个非常好的例子，说明为什么你不应使用基本认证，或者如果必须使用基本认证时，为什么你应该始终加密你的通信，使用**传输层安全性**（**TLS**）。
- en: Caution!
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！
- en: Do not configure this in your production environment as this configuration is
    highly insecure and is only shown for testing purposes. You will compromise yourself
    if you use this configuration!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产环境中配置此设置，因为该配置非常不安全，仅用于测试目的。如果你使用此配置，你将会使自己处于危险之中！
- en: If you want to configure your **test environment** to use basic authentication
    and allow unencrypted traffic, you need to configure your WinRM configuration
    to allow basic authentication, as well as unencrypted traffic.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想配置**测试环境**以使用基本认证并允许未加密的流量，你需要配置你的WinRM设置，以允许基本认证和未加密流量。
- en: In this example, **PSSec-PC01** is the remote host to which we want to connect
    using unencrypted traffic and basic authentication. We will connect from a management
    machine, which will be **PSSec-PC02**.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**PSSec-PC01**是我们要连接的远程主机，使用未加密流量和基本认证进行连接。我们将从管理机器**PSSec-PC02**连接。
- en: 'When we try to authenticate from **PSSec-PC02** to **PSSec-PC01** (the IP address
    is **172.29.0.12**) using the **-Authentication Basic** parameter, we get a message
    stating that we need to provide a username and a password to authenticate using
    basic authentication:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试从**PSSec-PC02**连接到**PSSec-PC01**（IP地址为**172.29.0.12**）时，使用**-Authentication
    Basic**参数时，我们会收到一条消息，提示我们需要提供用户名和密码，以便使用基本身份验证：
- en: '![Figure 3.18 – Error messages are shown if an insecure authentication mechanism
    is used](image/B16679_03_018.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 如果使用不安全的身份验证机制，将显示错误消息](image/B16679_03_018.jpg)'
- en: Figure 3.18 – Error messages are shown if an insecure authentication mechanism
    is used
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 如果使用不安全的身份验证机制，将显示错误消息
- en: Once we provide these credentials, we are still not able to authenticate and
    get another error message stating that access has been denied. The reason for
    this is that **basic** authentication is an insecure authentication mechanism
    if it’s not protected by TLS. Therefore, PSRemoting does not allow you to connect
    using this insecure authentication mechanism if you don’t configure it explicitly.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了这些凭据，我们仍然无法进行身份验证，并且会收到一条错误消息，指出访问被拒绝。原因是**基本**身份验证在没有TLS保护的情况下是一种不安全的身份验证机制。因此，PSRemoting不允许在未明确配置的情况下使用这种不安全的身份验证机制连接。
- en: 'So, let’s configure basic authentication explicitly in our demo setup, knowing
    that we will weaken our configuration on purpose. First, allow unencrypted traffic
    on **PSSec-PC01**:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在演示设置中明确配置基本身份验证，知道我们会故意削弱配置。首先，允许**PSSec-PC01**上的未加密流量：
- en: '[PRE44]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Remember to differentiate between **service** and **client** configuration.
    As we want to connect to **PSSec-PC01**, we will connect to the WinRM service,
    so we are configuring **service**.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住区分**服务**和**客户端**配置。由于我们想连接到**PSSec-PC01**，我们将连接到WinRM服务，因此我们正在配置**服务**。
- en: 'Next, configure basic authentication to be allowed:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置允许基本身份验证：
- en: '[PRE45]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After making changes to the WinRM configuration, it is important to restart
    the WinRM service for the new configuration to take effect:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在对WinRM配置进行更改后，重新启动WinRM服务以使新配置生效非常重要：
- en: '[PRE46]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let’s configure **PSSec-PC02** to establish unencrypted connections to
    other devices using basic authentication.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置**PSSec-PC02**，以便使用基本身份验证建立与其他设备的未加密连接。
- en: 'First, we must configure the client so that unencrypted connections can be
    initialized:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须配置客户端，以便能够初始化未加密的连接：
- en: '[PRE47]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we must make sure that the client is allowed to establish connections
    using basic authentication:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须确保客户端允许使用基本身份验证建立连接：
- en: '[PRE48]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, restart the WinRM service to load the new configuration:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重新启动WinRM服务以加载新配置：
- en: '[PRE49]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, this configuration exposes your devices and makes them vulnerable. Specifically,
    it exposes your credentials to potential attackers who could intercept network
    traffic while you connect to your machines. This could allow an attacker to gain
    unauthorized access to your systems and potentially compromise sensitive data
    or perform malicious actions.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这种配置会暴露您的设备，并使它们变得脆弱。具体来说，它暴露了您的凭据，可能会被潜在的攻击者拦截连接时的网络流量。这可能允许攻击者未经授权访问您的系统，并可能危及敏感数据或执行恶意操作。
- en: Therefore, we apply this configuration only in a test environment. In productive
    environments, it’s important to take appropriate security measures, such as enabling
    encryption and using secure authentication protocols, to protect your devices
    and data.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仅在测试环境中应用此配置。在生产环境中，重要的是采取适当的安全措施，例如启用加密和使用安全的身份验证协议，以保护您的设备和数据。
- en: As soon as we have our vulnerable configuration in place, it’s time to connect
    using basic authentication. I have added a local user called **PSSec** on **PSSec-PC01**,
    which I will use in this example.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置好脆弱的配置，就该使用基本身份验证进行连接了。我在**PSSec-PC01**上添加了一个名为**PSSec**的本地用户，接下来将在本示例中使用它。
- en: 'Let’s connect from **PSSec-PC02** to **PSSec-PC01** (the IP address is **172.29.0.12**)
    by using the **-Authentication** parameter while specifying **Basic**, as well
    as the credentials for the **PSSec** user:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**PSSec-PC02**连接到**PSSec-PC01**（IP地址为**172.29.0.12**），使用**-Authentication**参数并指定**Basic**，同时提供**PSSec**用户的凭据：
- en: '[PRE50]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The session is being established. If I track the traffic using Wireshark, I
    will see the SOAP requests that are being made. Even worse, I can see the **Authorization**
    header, which exposes the Base64-encrypted username and password:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 正在建立会话。如果我使用Wireshark追踪流量，我将看到正在进行的SOAP请求。更糟糕的是，我能看到**Authorization**头部，其中暴露了Base64加密的用户名和密码：
- en: '![Figure 3.19 – Wireshark capture of authenticating using unencrypted basic
    authentication](image/B16679_03_019.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 使用未加密的基本身份验证进行身份验证的Wireshark捕获](image/B16679_03_019.jpg)'
- en: Figure 3.19 – Wireshark capture of authenticating using unencrypted basic authentication
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 使用未加密的基本身份验证进行身份验证的Wireshark捕获
- en: 'Base64 can be easily decrypted, for example, with PowerShell itself:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Base64可以很容易地解密，例如，使用PowerShell本身：
- en: "![Figure 3.20 – Decrypting Base6\uFEFF4-encrypted credentials](image/B16679_03_020.jpg)"
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 解密Base64加密的凭据](image/B16679_03_020.jpg)'
- en: Figure 3.20 – Decrypting Base64-encrypted credentials
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 解密Base64加密的凭据
- en: So, an attacker can easily find out that the password of the **PSSec** user
    is **PS-SecRockz1234!** and can either inject the session as a man in the middle
    or use the password to impersonate the **PSSec** user – a great start when they’re
    attacking the entire environment.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，攻击者很容易发现**PSSec**用户的密码是**PS-SecRockz1234!**，并可以通过中间人攻击注入会话，或使用该密码冒充**PSSec**用户——这是他们攻击整个环境的一个很好的起点。
- en: I hope I made the risks of basic authentication and unencrypted sessions more
    transparent so that you will try this configuration in test environments only
    – and avoid it in production.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我能够使基本身份验证和未加密会话的风险更加透明，以便你只在测试环境中尝试此配置——并避免在生产环境中使用。
- en: PowerShell remoting and credential theft
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell远程操作与凭据窃取
- en: 'Depending on the authentication method that is used, credentials can be entered
    into the remote system, which can be stolen by an adversary. If you are interested
    in learning more about **credential theft** and mitigations, the *Mitigating Pass-the-Hash
    (PtH) Attacks and Other Credential Theft* white papers are a valuable resource:
    [https://www.microsoft.com/en-us/download/details.aspx?id=36036](https://www.microsoft.com/en-us/download/details.aspx?id=36036).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的身份验证方法，凭据可能被输入到远程系统中，且这些凭据可能被敌对方窃取。如果你有兴趣了解更多关于**凭据窃取**及其缓解措施的内容，*缓解Pass-the-Hash
    (PtH) 攻击与其他凭据窃取*白皮书是一个宝贵的资源：[https://www.microsoft.com/en-us/download/details.aspx?id=36036](https://www.microsoft.com/en-us/download/details.aspx?id=36036)。
- en: By default, PSRemoting does not leave credentials on the target system, which
    makes PowerShell an awesome administration tool.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PSRemoting不会将凭据保留在目标系统上，这使得PowerShell成为一个出色的管理工具。
- en: But if, for example, PSRemoting with CredSSP is used, the credentials enter
    the remote system, where they can be extracted and used to impersonate identities.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果例如使用带有CredSSP的PSRemoting，凭据会进入远程系统，在那里它们可以被提取并用于冒充身份。
- en: Keep in mind that when using CredSSP as an authentication mechanism, the credentials
    used to authenticate to the remote system are cached on that system. While this
    is convenient for single sign-on purposes, it also makes those cached credentials
    vulnerable to theft. If you can avoid it, do not use CredSSP as an authentication
    mechanism. But if you choose to use CredSSP, it is recommended that you enable
    Credential Guard to help mitigate this risk.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当使用CredSSP作为身份验证机制时，用于身份验证的凭据会被缓存到远程系统中。虽然这对于单点登录很方便，但也使得这些缓存的凭据容易被窃取。如果可以避免，请不要使用CredSSP作为身份验证机制。但如果你选择使用CredSSP，建议启用Credential
    Guard来帮助减轻这一风险。
- en: We will have a closer look at authentication and how the infamous pass-the-hash
    attack works in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150), *Active
    Directory – Attacks* *and Mitigation*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更加深入地探讨身份验证，以及臭名昭著的Pass-the-Hash攻击如何工作，内容可以参考[*第6章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)，*Active
    Directory – 攻击* *与缓解*。
- en: Executing commands using PowerShell remoting
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PowerShell远程操作执行命令
- en: Sometimes, you may want to run a command remotely but have not configured PSRemoting.
    Some cmdlets provide built-in remoting technologies that can be leveraged.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要远程运行一个命令，但尚未配置PSRemoting。一些cmdlet提供了内置的远程技术，可以加以利用。
- en: 'All commands that offer a built-in remoting technology have one thing in common:
    typically, they all have a parameter called **-ComputerName** to specify the remote
    endpoint.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提供内置远程技术的命令都有一个共同点：通常，它们都有一个名为**-ComputerName**的参数，用于指定远程端点。
- en: 'To get a list of locally available commands that have the option to run tasks
    remotely, use the **Get-Command -CommandType Cmdlet -ParameterName** **ComputerName**
    command:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取本地可用命令的列表，这些命令支持远程执行任务，请使用**Get-Command -CommandType Cmdlet -ParameterName**
    **ComputerName**命令：
- en: '[PRE51]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Please note that this list is not complete.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此列表并不完整。
- en: Cmdlets with a **-ComputerName** parameter do not necessarily use WinRM. Some
    use WMI, many others use RPC – it depends on the underlying technology of the
    cmdlet.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 带有**-ComputerName**参数的 cmdlet 不一定使用 WinRM。有些使用 WMI，许多其他使用 RPC —— 这取决于 cmdlet
    的底层技术。
- en: 'As every cmdlet has an underlying protocol, its firewall configuration and
    services need to be configured accordingly. This could mean a big management overhead.
    So, when managing environments remotely, it makes sense to configure PSRemoting
    accordingly: using WinRM is firewall-friendly and easier to configure and maintain.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 cmdlet 都有一个底层协议，它的防火墙配置和服务需要相应地进行配置。这可能意味着较大的管理开销。因此，在远程管理环境时，最好根据需要配置
    PSRemoting：使用 WinRM 是防火墙友好且更易于配置和维护的。
- en: Do not be confused!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆！
- en: PSRemoting should not be confused with using the **-ComputerName** parameter
    of a cmdlet to execute it on a remote computer. They are distinct approaches with
    different capabilities and usage scenarios. Those cmdlets that utilize the **-ComputerName**
    parameter rely on their underlying protocols, which often need a separate firewall
    exception rule to run.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: PSRemoting 不应与使用 cmdlet 的**-ComputerName**参数在远程计算机上执行命令混淆。这是两种不同的方式，具有不同的能力和使用场景。那些使用**-ComputerName**参数的
    cmdlet 依赖于其底层协议，这些协议通常需要单独的防火墙例外规则才能运行。
- en: Executing single commands and script blocks
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行单个命令和脚本块
- en: 'You can *execute a single command* or *entire script blocks* on a remote or
    local computer using the **Invoke-Command** cmdlet:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Invoke-Command** cmdlet *在远程或本地计算机上执行单个命令*或*整个脚本块*：
- en: '[PRE52]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following example shows how to restart the printer spooler on the **PSSec-PC01**
    remote computer, which is displaying verbose output:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示如何重启**PSSec-PC01**远程计算机上的打印机后台处理程序，并显示详细输出：
- en: '[PRE53]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Invoke-Command** is a great option for running local scripts and commands
    on a remote computer.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**Invoke-Command**是运行本地脚本和命令到远程计算机的一个很好的选择。'
- en: 'If you don’t want to copy the same scripts to your remote machine(s), you can
    use **Invoke-Command** with the **-FilePath** parameter to *run the local script
    on the* *remote system*:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想将相同的脚本复制到远程机器上，可以使用**Invoke-Command**和**-FilePath**参数来*在远程系统上运行本地脚本*：
- en: '[PRE54]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When using the **-FilePath** parameter with **Invoke-Command**, it is important
    to keep in mind that any dependencies required by the script (such as other scripts
    or commands) must also be present on the remote system. Otherwise, the script
    will not run as expected.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**-FilePath**参数和**Invoke-Command**时，重要的是要记住，脚本所需的任何依赖项（如其他脚本或命令）也必须存在于远程系统上，否则脚本将无法按预期运行。
- en: 'You can also *execute commands on multiple systems* – just specify all the
    remote systems that you want to execute your command or script on in the **-ComputerName**
    parameter. The following command restarts the print spooler on **PSSec-PC01**
    and **PSSec-PC02**:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以*在多个系统上执行命令* – 只需在**-ComputerName**参数中指定你希望执行命令或脚本的所有远程系统。以下命令会重启**PSSec-PC01**和**PSSec-PC02**上的打印机后台处理程序：
- en: '[PRE55]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Please have a look at the official PowerShell documentation to learn all options
    that **Invoke-Command** has to offer: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command).'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看官方 PowerShell 文档，了解**Invoke-Command**所提供的所有选项：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command)。
- en: Working with PowerShell sessions
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PowerShell 会话
- en: The **-Session** parameter indicates that a cmdlet or function supports sessions
    within PSRemoting.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**-Session**参数表示 cmdlet 或函数支持 PSRemoting 中的会话。'
- en: 'To find all locally available commands that support the **-Session** parameter,
    you can use the **Get-Command -ParameterName** **session** command:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有支持**-Session**参数的本地可用命令，可以使用**Get-Command -ParameterName** **session**命令：
- en: '![Figure 3.21 – All commands that provide a session parameter](image/B16679_03_021.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 提供会话参数的所有命令](image/B16679_03_021.jpg)'
- en: Figure 3.21 – All commands that provide a session parameter
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 提供会话参数的所有命令
- en: All local commands that provide a **-Session** parameter will be shown.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提供**-Session**参数的本地命令都会显示。
- en: Interactive sessions
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式会话
- en: 'By leveraging the **Enter-PSSession** command, you can initiate an interactive
    session. Once the session has been established, you can work on the remote system’s
    shell:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用**Enter-PSSession**命令，你可以启动一个交互式会话。一旦会话建立，你可以在远程系统的 shell 上进行操作：
- en: '![Figure 3.22 – Entering a PowerShell session, executing a command, and exiting
    the session](image/B16679_03_022.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – 进入 PowerShell 会话，执行命令并退出会话](image/B16679_03_022.jpg)'
- en: Figure 3.22 – Entering a PowerShell session, executing a command, and exiting
    the session
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 进入 PowerShell 会话，执行命令并退出会话
- en: Once your work is finished, use **Exit-PSSession** to close the session and
    the remote connection.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作完成，使用**Exit-PSSession**来关闭会话和远程连接。
- en: Persistent sessions
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久会话
- en: The **New-PSSession** cmdlet can be utilized to establish a persistent session.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**New-PSSession** cmdlet可以用来建立一个持久会话。'
- en: As in a former example, we use **Get-Credential** once more to store our credentials
    as a secure string in the **$****cred** variable.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们再次使用**Get-Credential**将我们的凭证作为安全字符串存储在**$****cred**变量中。
- en: 'Using the following command, we create two sessions for the **PSSec-PC01**
    and **PSSec-PC01** remote computers to execute commands:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，我们为**PSSec-PC01**和**PSSec-PC01**远程计算机创建两个会话来执行命令：
- en: '[PRE56]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To display all active sessions, you can use the **Get-PSSession** command:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示所有活动的会话，你可以使用**Get-PSSession**命令：
- en: '![Figure 3.23 – Creating persistent sessions and displaying them](image/B16679_03_023.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – 创建持久会话并显示它们](image/B16679_03_023.jpg)'
- en: Figure 3.23 – Creating persistent sessions and displaying them
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 创建持久会话并显示它们
- en: Now, you can use the **$sessions** variable to run commands in all remote computer
    sessions that you’ve specified.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用**$sessions**变量，在你指定的所有远程计算机会话中运行命令。
- en: 'A common use case is to check whether all security updates were applied to
    your remote computers. In this case, we want to check whether the **KB5023773**
    hotfix is installed on all remote computers. We also don’t want any error messages
    to be displayed if the hotfix was not found, so we will use the **-ErrorAction
    SilentlyContinue** parameter in our code snippet:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的使用案例是检查所有远程计算机是否都应用了所有安全更新。在这种情况下，我们要检查是否所有远程计算机都安装了**KB5023773**热修复程序。我们也不希望在找不到热修复程序时显示任何错误信息，因此我们将在代码片段中使用**-ErrorAction
    SilentlyContinue**参数：
- en: '[PRE57]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is the output we get after running this command:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们运行该命令后的输出：
- en: '![Figure 3.24 – Running a command in all specified sessions](image/B16679_03_024.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – 在所有指定的会话中运行命令](image/B16679_03_024.jpg)'
- en: Figure 3.24 – Running a command in all specified sessions
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 在所有指定的会话中运行命令
- en: As it turns out, the hotfix is only installed on **PSSec-PC01** but is missing
    on the second computer, **PSSec-02**.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，热修复程序仅安装在**PSSec-PC01**上，而第二台计算机**PSSec-02**上没有安装。
- en: 'To act on this and install the missing update, we can either send more commands
    directly into the session or we can enter the session interactively by specifying
    the session ID – that is, **Enter-PSSession -****Id 2**:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作并安装缺失的更新，我们可以直接在会话中发送更多命令，或者可以通过指定会话 ID 交互式地进入会话——即**Enter-PSSession -****Id
    2**：
- en: '![Figure 3.25 – Entering a persistent session, running a command, and exiting
    it again](image/B16679_03_025.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25 – 进入持久会话，运行命令并再次退出](image/B16679_03_025.jpg)'
- en: Figure 3.25 – Entering a persistent session, running a command, and exiting
    it again
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – 进入持久会话，运行命令并再次退出
- en: 'Now that we have entered the session, we can run the **Get-WindowsUpdate**
    command to install the missing update. Please note that this command is not available
    by default and requires you to install the **PSWindowsUpdate** module:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入会话，可以运行**Get-WindowsUpdate**命令来安装缺失的更新。请注意，这个命令默认不可用，需要你安装**PSWindowsUpdate**模块：
- en: '[PRE58]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After our command has run, we can exit the session using **Exit-PSSession**,
    which only disconnects us from the session but leaves the session open.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的命令执行完毕后，我们可以使用**Exit-PSSession**退出会话，这只会使我们与会话断开连接，但会话仍然保持开启。
- en: Note
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using an interactive session, all executed modules, such as **PSWindowsUpdate**,
    need to be installed on the remote system. If you use **Invoke-Command** to run
    commands in a persistent session, the module only needs to be installed on the
    computer that you use to run the commands:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用交互式会话，所有执行的模块（如 **PSWindowsUpdate**）需要安装在远程系统上。如果使用 **Invoke-Command** 在持久会话中运行命令，则只需要在运行命令的计算机上安装该模块：
- en: '**Invoke-Command – Session $sessions -ScriptBlock { Get-WindowsUpdate -Install
    -****KBArticleID ‘KB5023773’}**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**Invoke-Command – Session $sessions -ScriptBlock { Get-WindowsUpdate -Install
    -****KBArticleID ‘KB5023773’}**'
- en: 'If we check for **KB5023773** after some time, we will see that the update
    was installed:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们过一段时间后检查 **KB5023773**，我们会看到更新已经安装：
- en: '![Figure 3.26 – The update was installed successfully](image/B16679_03_026.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26 – 更新成功安装](image/B16679_03_026.jpg)'
- en: Figure 3.26 – The update was installed successfully
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 更新成功安装
- en: 'As soon as we are finished with our work and if we don’t need our sessions
    anymore, we can remove them using the **Remove-PSSession** command:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成工作且不再需要会话时，可以使用 **Remove-PSSession** 命令将其移除：
- en: 'Here, we can use the **$sessions** variable, which we specified earlier:'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用之前指定的 **$sessions** 变量：
- en: '[PRE59]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, we can remove a single session by using the **-****id** parameter:'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用 **-****id** 参数来移除单个会话：
- en: '[PRE60]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After removing one or all session(s), you can use **Get-PSSession** to verify
    this:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 移除一个或所有会话后，可以使用 **Get-PSSession** 来验证这一点：
- en: '![Figure 3.27 – Removing all persistent sessions](image/B16679_03_027.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.27 – 移除所有持久会话](image/B16679_03_027.jpg)'
- en: Figure 3.27 – Removing all persistent sessions
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – 移除所有持久会话
- en: Executing commands using PSRemoting can simplify your daily administration workload
    immensely. Now that you have learned the basics, you can combine it with your
    PowerShell scripting knowledge. What problems will you solve and what tasks will
    you automate?
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PSRemoting 执行命令可以极大简化日常管理工作。现在，您已经掌握了基本知识，可以将其与您的 PowerShell 脚本知识相结合。您将解决哪些问题，并自动化哪些任务？
- en: Best practices
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: To ensure optimal security and performance when using PSRemoting, it’s important
    to follow the best practices enforced by the product. These practices are designed
    to minimize the risk of security breaches and ensure that your remote management
    tasks run smoothly.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在使用 PSRemoting 时的最佳安全性和性能，遵循产品强制执行的最佳实践至关重要。这些实践旨在减少安全漏洞的风险，并确保远程管理任务顺利运行。
- en: '**Authentication**:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**：'
- en: If possible, use only Kerberos or NTLM authentication.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，仅使用 Kerberos 或 NTLM 认证。
- en: Avoid CredSSP and basic authentication whenever possible.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免使用 CredSSP 和基本身份验证。
- en: In the best case, restrict the usage of all other authentication mechanisms
    besides Kerberos/NTLM.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳情况下，限制使用除了 Kerberos/NTLM 之外的所有其他认证机制。
- en: SSH remoting – configure public key authentication and keep the private key
    protected.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH 远程访问 – 配置公钥认证并保护私钥。
- en: '**Limit connections**:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制连接**：'
- en: Limit connections via firewall from a management subnet (hardware and software
    if possible/available).
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过防火墙限制来自管理子网的连接（如果可能，使用硬件和软件）。
- en: PSRemoting’s default firewall policies differ based on the network profile.
    In a **Domain**, **Workgroup**, or **Private** network profile, PSRemoting is
    available to all by default (assuming they have valid credentials). In a **Public**
    profile, PSRemoting refuses to listen to that adapter by default. If you force
    it to, the network rule will limit access to only systems on the same network
    subnet.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: PSRemoting 的默认防火墙策略根据网络配置文件有所不同。在 **域**、**工作组** 或 **私有** 网络配置文件中，PSRemoting
    默认对所有人开放（假设他们拥有有效凭证）。在 **公共** 配置文件中，PSRemoting 默认拒绝监听该适配器。如果强制启用，网络规则将限制访问仅限于同一网络子网的系统。
- en: Use a secure management system to manage systems via PSRemoting. Consider limiting
    connections from a management **virtual network** (**VNet**) if you have one,
    which also applies to other management protocols such as RDP, WMI, CIM, and others.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的管理系统通过 PSRemoting 管理系统。如果有管理 **虚拟网络**（**VNet**），考虑限制来自该网络的连接，这同样适用于其他管理协议，如
    RDP、WMI、CIM 等。
- en: 'Use a secure management system to manage systems via PSRemoting. Use the clean
    source principle to build the management system and use the recommended privileged
    access model:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的管理系统通过 PSRemoting 管理系统。使用清晰源原则来构建管理系统，并使用推荐的特权访问模型：
- en: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle)'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle)'
- en: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model)'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model](https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model)'
- en: '**Restrict sessions**:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制会话**：'
- en: Use constrained language and JEA.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用受限语言和JEA。
- en: You will learn more about JEA, constrained language, session security, and SDDLs
    in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278), *Language Modes
    and Just Enough* *Administration (JEA).*
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在[*第10章*](B16679_10_Final_PD.xhtml#_idTextAnchor278)，“*语言模式与足够的管理（JEA）*”中深入了解JEA、受限语言、会话安全性和SDDLs。
- en: '**Audit** **insecure settings**:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**审计不安全设置**：'
- en: Use the WinRM group policy to enforce secure PSRemoting settings on all managed
    systems, including encryption and authentication requirements.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WinRM组策略在所有受管理系统上强制执行安全的PSRemoting设置，包括加密和身份验证要求。
- en: '**Get-Item WSMan:\localhost\Client\AllowUnencrypted**: This setting should
    *not* be set to **$true**.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-Item WSMan:\localhost\Client\AllowUnencrypted**：此设置*不*应设置为**$true**。'
- en: 'Audit insecure WinRM settings regularly to ensure compliance with security
    policies:'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审计不安全的WinRM设置，以确保符合安全政策：
- en: '[PRE61]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Eventually, use **Desired State Configuration** (**DSC**) to audit and apply
    your settings.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，使用**所需状态配置**（**DSC**）来审计并应用你的设置。
- en: '**And all other mitigation methods mentioned in the previous chapter, especially**
    **the following**:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**以及前一章中提到的所有其他缓解方法，特别是** **以下内容**：'
- en: Enable logging and transcription and monitor event logs. You can read more about
    this in [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090), *Detection –
    Auditing* *and Monitoring*.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用日志记录和转录，并监控事件日志。你可以在[*第4章*](B16679_04_Final_PD.xhtml#_idTextAnchor090)，“*检测
    - 审计与监控*”中阅读更多相关内容。
- en: Eliminate unnecessary local and domain administrators
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除不必要的本地和域管理员。
- en: Enable and enforce script signing. You will learn more about script signing
    in [*Chapter 11*](B16679_11_Final_PD.xhtml#_idTextAnchor306), *AppLocker, Application
    Control, and* *Code Signing*.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用并强制执行脚本签名。你将在[*第11章*](B16679_11_Final_PD.xhtml#_idTextAnchor306)，“*AppLocker、应用控制和代码签名*”中进一步了解脚本签名。
- en: Configure **DSC** to harden your systems and control your system configuration.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置**DSC**来加固你的系统并控制系统配置。
- en: PSRemoting is a great way to administrate your systems efficiently. Of course,
    it is only as secure as you configure it to be. If the right configuration is
    in place, administration via PSRemoting is even more secure than logging in interactively.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: PSRemoting是一种高效管理系统的好方法。当然，它的安全性取决于你的配置。如果配置得当，通过PSRemoting进行管理比交互式登录更安全。
- en: Summary
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should be familiar with how to use PowerShell
    remotely, using PSRemoting. You learned what options exist in PowerShell to establish
    remote connections, which enables you to not only manage Windows machines but
    also other operating systems, such as macOS and Linux.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该熟悉如何使用PSRemoting远程使用PowerShell。你学习了PowerShell中用于建立远程连接的选项，这使你不仅能够管理Windows机器，还能管理其他操作系统，如macOS和Linux。
- en: You also learned what endpoints are and can create basic custom endpoints. You
    will strengthen this ability later in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278),
    *Language Modes and Just Enough Administration (JEA)*, but you already know the
    basics.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了什么是端点，并且能够创建基本的自定义端点。你将在[*第10章*](B16679_10_Final_PD.xhtml#_idTextAnchor278)，“*语言模式与足够的管理（JEA）*”中进一步加强这项能力，但你已经掌握了基础知识。
- en: Then, you learned a lot about authentication protocols that can be used and
    even more about security considerations when working with those protocols. You
    should also be aware of how easily an adversary can obtain decrypted credentials
    if a weak authentication protocol is used.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了很多可以使用的身份验证协议，还了解了使用这些协议时的安全考虑。你还应该意识到，如果使用弱身份验证协议，攻击者能够轻易地获得解密后的凭据。
- en: You should now be able to configure PSRemoting manually and centrally, which
    helps you set up your initial PSRemoting configuration in your production environment.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够手动和集中配置 PSRemoting，这有助于你在生产环境中设置初始的 PSRemoting 配置。
- en: Last but not least, you learned how to execute commands using PSRemoting, which
    enables you to not only run one command on one device – you can also automate
    your tedious administration tasks.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你学习了如何使用 PSRemoting 执行命令，这使得你不仅可以在一个设备上运行一个命令，还可以自动化繁琐的管理任务。
- en: When working with PowerShell – either remotely or locally – auditing and monitoring
    are very important topics. Using transcriptions and event logging helps the Blue
    Team detect adversaries and protect their environment.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PowerShell 时——无论是远程还是本地——审计和监控是非常重要的课题。使用转录和事件日志有助于蓝队发现对手并保护其环境。
- en: Therefore, now that you are familiar with PSRemoting, we’ll look at detection
    and logging within PowerShell in the next chapter.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经熟悉了 PSRemoting，我们将在下一章讨论 PowerShell 中的检测和日志记录。
- en: Further reading
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to explore some of the topics that were mentioned in this chapter,
    take a look at these resources.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步探索本章提到的一些话题，可以查看这些资源。
- en: '**Authentication**:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**：'
- en: 'RFC 2617 – HTTP authentication (basic and digest authentication): [https://tools.ietf.org/html/rfc2617](https://tools.ietf.org/html/rfc2617)'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 2617 – HTTP 认证（基本认证和摘要认证）：[https://tools.ietf.org/html/rfc2617](https://tools.ietf.org/html/rfc2617)
- en: '**Credential Security Support Provider** (**CredSSP**) protocol:'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭据安全支持提供程序**（**CredSSP**）协议：'
- en: '[https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30)'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30)'
- en: '[https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP](https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP)'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP](https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP)'
- en: 'Public key authentication:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥认证：
- en: '[https://en.wikipedia.org/wiki/Public-key_cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Public-key_cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)'
- en: '[https://www.ssh.com/ssh/public-key-authentication](https://www.ssh.com/ssh/public-key-authentication)'
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ssh.com/ssh/public-key-authentication](https://www.ssh.com/ssh/public-key-authentication)'
- en: '**CIM**:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**CIM**：'
- en: 'CIM cmdlets: [https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/](https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIM cmdlet：[https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/](https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/)
- en: 'CIM standard by DMTF: [https://www.dmtf.org/standards/cim](https://www.dmtf.org/standards/cim)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMTF 的 CIM 标准：[https://www.dmtf.org/standards/cim](https://www.dmtf.org/standards/cim)
- en: '**DCOM**:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**DCOM**：'
- en: '**DCOM** remote protocol: [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DCOM** 远程协议：[https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0)'
- en: '**OMI**:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**OMI**：'
- en: 'Open Management Infrastructure (OMI): [https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/](https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放管理基础设施（OMI）：[https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/](https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/)
- en: '**Other** **useful resources**:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他** **有用资源**：'
- en: 'New-NetFirewallRule: [https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule](https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule)'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: New-NetFirewallRule：[https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule](https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule)
- en: '**PowerShell remoting**:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**PowerShell 远程管理**：'
- en: '[MS-PSRP]: PowerShell remoting protocol: [https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec)'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MS-PSRP]：PowerShell 远程协议：[https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec)'
- en: 'Running Remote Commands: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '运行远程命令: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands)'
- en: 'WS-Man Remoting in PowerShell Core: [https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3)'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell Core 中的 WS-Man 远程操作: [https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3)'
- en: 'WS-Man specifications by DMTF: [https://www.dmtf.org/standards/ws-man](https://www.dmtf.org/standards/ws-man)'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DMTF 的 WS-Man 规范: [https://www.dmtf.org/standards/ws-man](https://www.dmtf.org/standards/ws-man)'
- en: 'WinRM security: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'WinRM 安全性: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity)'
- en: 'PowerShell endpoints: [https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/](https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/)'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell 端点: [https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/](https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/)'
- en: 'PSRemoting over SSH: https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通过 SSH 的 PSRemoting: https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core'
- en: 'The second hop: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop)'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二跳: [https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop)'
- en: '**WMI**:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**WMI**:'
- en: 'Get-WmiObject: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject)'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Get-WmiObject: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject)'
- en: 'Invoke-WmiMethod: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod)'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Invoke-WmiMethod: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod)'
- en: 'Register-WmiEvent: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Register-WmiEvent: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent)'
- en: )
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Remove-WmiObject: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Remove-WmiObject: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject)'
- en: )
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Set-WmiInstance: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Set-WmiInstance: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance)'
- en: )
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**WS-Man**:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**WS-Man**:'
- en: 'WS-Man standard by DMTF: [https://www.dmtf.org/standards/ws-man](https://www.dmtf.org/standards/ws-man'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DMTF 的 WS-Man 标准: [https://www.dmtf.org/standards/ws-man](https://www.dmtf.org/standards/ws-man)'
- en: )
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'WS-Management Remoting in PowerShell Core: https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PowerShell Core 中的 WS-Management 远程操作: https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core'
- en: 'You can also find all the links mentioned in this chapter in the GitHub repository
    for [*Chapter 3*](B16679_03_Final_PD.xhtml#_idTextAnchor064) – there’s no need
    to manually type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md).'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 仓库中找到本章提到的所有链接，链接位于[*第三章*](B16679_03_Final_PD.xhtml#_idTextAnchor064)
    – 无需手动输入每个链接：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md)。
