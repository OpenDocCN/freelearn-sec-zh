- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Injection Attacks and Validation Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入攻击和验证测试
- en: We are starting a new part of the book. So far, you have had an introduction
    to API security, how we can acquire more data about the target – with the important
    reconnaissance and information gathering chapter – and learned ways to test both
    authentication and authorization mechanisms most APIs implement nowadays. Now,
    it’s time to dive deeper into the waters of attacks. This part starts with injection
    and validation (or the lack of it) testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始书中的新部分。到目前为止，你已经了解了 API 安全的介绍，如何收集更多目标数据——通过重要的侦察与信息收集章节——并学习了测试大多数现代
    API 所实施的认证与授权机制的方法。现在，是时候深入探讨攻击领域了。本部分从注入攻击和验证（或缺乏验证）测试开始。
- en: These kinds of attacks are not new at all, but it’s impressive how often they
    show up in media headlines around the world, affecting pretty much all kinds and
    sizes of companies. Hopefully, you already know they are not limited to **Structured
    Query Language** (**SQL**), but if you don’t, that’s perfectly fine, as you will
    learn about them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这类攻击并不新鲜，但它们在全球媒体头条中出现的频率令人印象深刻，几乎影响到各类公司。希望你已经知道，这些攻击不限于**结构化查询语言**（**SQL**），但如果你还不清楚，也没关系，因为你将在本书中学到这些内容。
- en: In this chapter, we start with an introduction of what exactly injection attacks
    are and which kinds of vulnerabilities can arise from a lack of attention to them.
    We then do some practical exercises with both SQL-related and NoSQL-related attacks,
    and we finish the chapter with a discussion about user input and the importance
    of validating it and sanitizing it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍什么是注入攻击，以及缺乏对其关注可能导致哪些漏洞。接下来，我们会进行一些实际操作，涉及 SQL 相关和 NoSQL 相关的攻击，最后我们将讨论用户输入及其验证和清理的重要性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding injection vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解注入漏洞
- en: Testing for SQL injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 SQL 注入
- en: Testing for NoSQL injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 NoSQL 注入
- en: Validating and sanitizing user input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和清理用户输入
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll leverage the same environment as the one pointed out in [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042).
    In summary, you’ll need a type 2 hypervisor, such as VirtualBox, and the same
    tools we used before – especially the **Completely Ridiculous API** (**crAPI**)
    project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[**第 3 章**](B19657_03.xhtml#_idTextAnchor042)相同的环境。总结来说，你将需要一个类型 2 的虚拟化管理程序，如
    VirtualBox，以及我们之前使用的相同工具——尤其是**完全荒谬的 API**（**crAPI**）项目。
- en: Understanding injection vulnerabilities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解注入漏洞
- en: Injection attacks are pretty easy to understand and sometimes to execute as
    well. They simply consist of inserting unexpected data, usually crafted commands
    or keywords, inside an input that should only contain specific data, such as a
    username and/or a corresponding password. By leveraging different formats, such
    as another encoding, or by adding commands to the input, a badly implemented API’s
    backend would inadvertently execute those commands or try to interpret the exceptional
    encoding, which could cause general failure and possible data leakage.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击相对容易理解，有时也很容易执行。它们仅仅是将意外的数据（通常是精心构造的命令或关键字）插入到本应只包含特定数据（如用户名和/或相应密码）的输入中。通过利用不同的格式，如另一种编码方式，或通过在输入中添加命令，错误实现的
    API 后端可能会不小心执行这些命令，或尝试解释异常的编码，这可能导致系统故障以及可能的数据泄露。
- en: The possibly most famous variation of this attack affects SQL databases, and
    they are frequently called **SQLi** (“**i**” for **injection**) attacks. This
    happens because many publicly available applications and API endpoints interact
    with relational databases on their backend’s infrastructure. On the other hand,
    some other applications make use of unstructured data, which makes them candidates
    for NoSQL databases. But even so, the latter ones are also susceptible to the
    threat.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最著名的这种攻击变种影响的是 SQL 数据库，它们通常被称为**SQLi**（“**i**”代表**注入**）攻击。这是因为许多公开可用的应用程序和
    API 接口与后端基础设施上的关系型数据库进行交互。另一方面，某些其他应用程序则使用非结构化数据，这使它们成为 NoSQL 数据库的候选者。即便如此，后者同样也容易受到此类威胁。
- en: You can inject code or spurious data either by building a request you’ll send
    to an API endpoint or by filling fields on a form that expects you, for example,
    to provide a comment on some product or service you recently acquired. Imagine
    for a moment that among your comments with satisfaction on buying that new video
    game, you add something such as “*DROP DATABASE products;*”. When the API endpoint
    code reads that comment, instead of returning it as an answer to a request, it
    will instead execute it and erase the entire `products` database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过构建发送到API端点的请求，或通过填写表单中的字段来注入代码或虚假数据。例如，表单可能要求您提供关于最近购买的某个产品或服务的评论。假设您在表单中写了一个满意的评论，但在评论中添加了类似“*DROP
    DATABASE products;*”的内容。当API端点代码读取该评论时，它不会把评论作为响应返回，而是会执行它，删除整个`products`数据库。
- en: 'There are other types of injection attacks besides SQL and NoSQL, such as the
    following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SQL和NoSQL注入攻击外，还有其他类型的注入攻击，例如：
- en: '**Lightweight Directory Access Protocol (LDAP) injection**: This attack targets
    LDAP servers used for authentication and authorization. If an API endpoint interacts
    with LDAP for user login, an attacker could inject malicious code into username
    or password fields. This code could exploit vulnerabilities in how the API constructs
    LDAP queries, potentially allowing the attacker to bypass authentication, steal
    user credentials from the directory server, or disrupt directory services, impacting
    user access to various systems. Mitigating LDAP injection requires ensuring proper
    input validation and escaping of special characters within user-supplied credentials
    before constructing LDAP queries.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级目录访问协议（LDAP）注入**：此攻击针对用于身份验证和授权的LDAP服务器。如果API端点与LDAP交互以进行用户登录，攻击者可能会将恶意代码注入用户名或密码字段。这些代码可能利用API在构建LDAP查询时的漏洞，从而可能让攻击者绕过身份验证、窃取目录服务器中的用户凭据，或干扰目录服务，影响用户对各种系统的访问。防止LDAP注入攻击需要确保对用户提供的凭据进行适当的输入验证，并在构建LDAP查询之前对特殊字符进行转义。'
- en: '**GraphQL injection**: With the growing popularity of GraphQL APIs, attackers
    are devising ways to exploit vulnerabilities in how these APIs handle user input.
    Malicious queries can exploit weaknesses in query validation to gain unauthorized
    access to data, manipulate data returned by the API, or even trigger **denial-of-service**
    (**DoS**) attacks by crafting complex and resource-intensive queries. Preventing
    GraphQL injection requires implementing robust input validation techniques for
    all user-supplied data within GraphQL queries and enforcing query complexity limitations
    to prevent resource exhaustion attacks.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL注入**：随着GraphQL API的日益流行，攻击者正在设计利用这些API处理用户输入时的漏洞。恶意查询可以利用查询验证中的弱点，获取未经授权的数据、操控API返回的数据，甚至通过构造复杂且资源消耗大的查询来触发**拒绝服务**（**DoS**）攻击。防止GraphQL注入需要对所有用户提供的数据在GraphQL查询中实施强有力的输入验证技术，并强制执行查询复杂度限制，以防止资源耗尽攻击。'
- en: 'Over the last few years, there have been several reports covering injection
    attacks and their damage to companies and their customers. In 2017, the Equifax
    data breach, one of the largest data breaches in history, was caused by a vulnerability
    in an Apache Struts application. Struts is a web application framework used in
    several applications on the internet. This vulnerability allowed attackers to
    execute SQL injection attacks and steal the personal information of over 147 million
    individuals. In *Figure 5**.1*, you see a small, compiled list of some news covering
    injection attacks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，已有多篇报道涉及注入攻击及其对公司和客户的危害。2017年，历史上最大的泄露事件之一——Equifax数据泄露，正是由于Apache Struts应用程序中的一个漏洞所导致。Struts是一个用于多个互联网应用程序的Web应用框架。这个漏洞让攻击者能够执行SQL注入攻击，并窃取超过1.47亿人的个人信息。在*图5.1*中，您可以看到一些关于注入攻击的新闻摘要：
- en: '![Figure 5.1 – News about injection attacks](img/B19657_05_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 关于注入攻击的新闻](img/B19657_05_01.jpg)'
- en: Figure 5.1 – News about injection attacks
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 关于注入攻击的新闻
- en: Injection can also happen in **graphical user interface** (**GUI**) scenarios.
    Another vulnerability affecting Apache Struts was discovered in 2018\. This vulnerability
    allowed attackers to execute remote code injection attacks through the Struts
    REST API. Recorded under *CVE-2018-11776*, it affected millions of web applications
    worldwide and underscored the importance of securing API endpoints against injection
    attacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注入攻击也可能发生在**图形用户界面**（**GUI**）场景中。2018 年，发现了影响 Apache Struts 的另一个漏洞。该漏洞允许攻击者通过
    Struts REST API 执行远程代码注入攻击。此漏洞在 *CVE-2018-11776* 中记录，影响了全球数百万个 Web 应用程序，并强调了保护
    API 端点免受注入攻击的重要性。
- en: '**XML External Entity** (**XXE**) injection is another injection attack vector
    that targets APIs parsing XML input. In 2019, Atlassian, the player behind some
    widely used applications such as Jira suite, Confluence, and Bitbucket, was affected
    by a vulnerability that targeted its Jira Service Management Data Center and Jira
    Service Management Server solutions. Detailed on *CVE-2019-13990*, this vulnerability
    allowed authenticated users to initiate XXE attacks through job descriptions.
    The vulnerable code was located on a specific third-party component: Terracotta
    Quartz Scheduler.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML 外部实体**（**XXE**）注入是另一种注入攻击方式，针对解析 XML 输入的 API。在 2019 年，Atlassian（背后有一些广泛使用的应用程序，如
    Jira 套件、Confluence 和 Bitbucket）遭遇了一个漏洞，影响了其 Jira Service Management Data Center
    和 Jira Service Management Server 解决方案。该漏洞在 *CVE-2019-13990* 中进行了详细描述，允许经过身份验证的用户通过职位描述发起
    XXE 攻击。该漏洞代码位于一个特定的第三方组件：Terracotta Quartz Scheduler。'
- en: NoSQL injection targets NoSQL databases by crafting especially prepared queries
    to aim sometimes undiscovered and sometimes widely known vulnerabilities in query
    parsing and execution. In 2020, a security researcher discovered a NoSQL injection
    vulnerability in a popular **mobile backend-as-a-service** (**MBaaS**) platform,
    Firebase. During an Android analysis as part of a bug bounty program, they discovered
    how attackers could bypass authentication and access sensitive user data stored
    in Firebase databases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 注入通过精心设计的查询，针对 NoSQL 数据库，旨在利用查询解析和执行中的一些已知或未知漏洞。在 2020 年，一位安全研究人员在一个流行的**移动后端即服务**（**MBaaS**）平台
    Firebase 中发现了 NoSQL 注入漏洞。在一次 Android 分析中，作为漏洞赏金计划的一部分，他们发现攻击者可以绕过身份验证并访问存储在 Firebase
    数据库中的敏感用户数据。
- en: Beyond traditional injection attacks, command injection (and its counterpart,
    OS command injection) vulnerabilities in API endpoints can also lead to severe
    security breaches, and not even cyber security players are safe from this way
    of intruding into a system. Fortinet got caught with *CVE-2023-36553* when its
    FortiSIEM (**security information and event management**, or **SIEM**) platform
    had a vulnerability that allowed attackers to inject commands in API requests.
    In the same year, it was Palo Alto’s turn. One of its firewalls was discovered
    to be vulnerable to an API command injection vulnerability, allowing authenticated
    API users to inject commands on the device’s operating system, PAN-OS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的注入攻击外，API 端点中的命令注入（及其对应的操作系统命令注入）漏洞也可能导致严重的安全漏洞，甚至连网络安全公司也难以避免这种侵入方式。Fortinet
    因其 FortiSIEM（**安全信息和事件管理**，或 **SIEM**）平台中的漏洞而受到攻击，该漏洞允许攻击者在 API 请求中注入命令。同年，Palo
    Alto 也遭遇了类似问题。其防火墙中的一个漏洞被发现存在 API 命令注入漏洞，允许经过身份验证的 API 用户在设备操作系统 PAN-OS 上注入命令。
- en: API injection attacks highlight the importance of implementing robust input
    validation and sanitization mechanisms in API endpoints. By validating and sanitizing
    user input, developers can prevent injection attacks and mitigate the risk of
    data breaches and unauthorized access. Additionally, organizations should regularly
    perform security assessments and penetration testing to identify and remediate
    vulnerabilities in their API infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: API 注入攻击突显了在 API 端点中实施强健输入验证和清理机制的重要性。通过验证和清理用户输入，开发人员可以防止注入攻击并降低数据泄露和未经授权访问的风险。此外，组织应定期进行安全评估和渗透测试，以识别并修复
    API 基础设施中的漏洞。
- en: Time for practice! Let’s see how injection works in practical terms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 练习时间！让我们看看注入攻击在实际中的运作方式。
- en: Testing for SQL injection
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 注入测试
- en: 'OK – now that you know the major types of injection attacks, let’s explore
    the one that is possibly the oldest while, at the same time, the most applied
    nowadays: injection on SQL databases. This kind of attack can vary from a very
    simple `OR` clause as part of user input to the complexity and sophistication
    of union and hidden union attacks, where multiple SQL statements can be combined
    to form an *explosive* payload. The first step, though, is not to attack the database
    behind the API endpoint but to fingerprint it. This can substantially reduce your
    effort in selecting techniques. By trying with some random input, you can force
    an unprepared API to return useful database error messages. Some engines reveal
    themselves in such error messages.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经了解了主要的注入攻击类型，让我们来探讨一种可能是最古老但如今仍最常见的攻击方式：SQL 数据库上的注入攻击。这种攻击可以从简单的 `OR`
    子句开始，作为用户输入的一部分，到联合攻击和隐藏联合攻击的复杂性和精密度，其中多个 SQL 语句可以结合形成 *爆炸性* 负载。然而，第一步并不是直接攻击
    API 端点背后的数据库，而是进行指纹识别。这可以大大减少选择技术时的工作量。通过尝试一些随机输入，你可以迫使一个没有准备好的 API 返回有用的数据库错误消息。一些数据库引擎在这些错误消息中会暴露自身信息。
- en: 'The following snippet shows a typical error message from Microsoft SQL Server:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段显示了来自 Microsoft SQL Server 的典型错误消息：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Likewise, the following snippet contains an error message from MariaDB or its
    “cousin” MySQL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下代码段包含来自 MariaDB 或其“亲戚”MySQL 的错误消息：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is an error message from an Oracle Database server. This product throws
    codes starting with `ORA`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Oracle 数据库服务器的错误消息。这个产品抛出的代码以 `ORA` 开头：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, this is an example of a message displayed by PostgreSQL when something
    goes wrong:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 PostgreSQL 出现问题时显示的消息示例：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we will cover the most prevalent types of SQL injection attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍最常见的 SQL 注入攻击类型。
- en: Classic SQL injection
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典 SQL 注入
- en: Pretty much all attempts to insert commands into SQL instructions will happen
    with the `SELECT` directive. This is because one of the main objectives is to
    exfiltrate data from the database. You either want the whole user list with their
    passwords (hashed or not) or the details about its internal structures, such as
    the number of tables, the database schema, an order list with their values and
    delivery addresses, and so on and so forth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有尝试将命令插入 SQL 指令的操作都会使用 `SELECT` 指令。这是因为其中一个主要目标是从数据库中提取数据。你可能想要获取完整的用户列表及其密码（无论是否加密），或有关其内部结构的详细信息，如表的数量、数据库架构、包含其值和配送地址的订单列表等。
- en: 'Imagine an online store where you can search for items. This search feature
    might have a security weakness. When you type in your search term, the system
    builds a special message (such as a coded instruction) to ask the database to
    find matching products. This particular way of building the message could be vulnerable
    to manipulation. Let’s take a closer look at an example of such a message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在线商店，你可以在其中搜索商品。这个搜索功能可能存在安全弱点。当你输入搜索词时，系统会构建一条特殊消息（如编码指令）来请求数据库查找匹配的商品。构建消息的这种方式可能容易受到操控。让我们仔细看看这样一条消息的例子：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `$user_input` variable represents what the user typed in a form field on
    the frontend component of this web application. It could be data sent to an API
    endpoint via a `POST` or `PUT` request as well. Without doing the required validation
    or sanitization, an injection can easily happen. Instead of providing some search
    text, the user could send the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`$user_input` 变量代表用户在此 web 应用程序的前端组件中表单字段中输入的内容。它也可以是通过 `POST` 或 `PUT` 请求发送到
    API 端点的数据。如果没有进行必要的验证或清理，注入攻击很容易发生。用户可能会发送以下内容，而不是提供某些搜索文本：'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will make the final query the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使最终的查询变为以下内容：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With a logical `OR` operator whose second operand always evaluates as `true`,
    it doesn’t matter what the first part of the query (the user verification) is.
    The `–` part is understood as a comment, which means the SQL engine will ignore
    everything else after it. Some database engines use `/*` as the sequence to start
    a comment. In logical terms, it would be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑 `OR` 运算符，其第二个操作数总是求值为 `true`，无论查询的第一部分（用户验证）是什么，都没有关系。`–` 部分被理解为注释，这意味着
    SQL 引擎会忽略它之后的所有内容。一些数据库引擎使用 `/*` 作为注释的起始标记。从逻辑角度看，它大致相当于这样：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this simple joke, you would get the entire `products` database. If the
    API endpoint or application leverages the same input to carry out some other tasks,
    such as updating another database or deleting items, the damage can be even worse.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的笑话，你可以获取整个`products`数据库。如果 API 端点或应用程序利用相同的输入执行其他任务，比如更新另一个数据库或删除项目，损害可能会更加严重。
- en: Stacked SQL injection
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套 SQL 注入
- en: Instead of classic SQL injection attacks, attackers can use a more advanced
    technique called stacked (or chained) SQL injection. This is like giving multiple
    orders at once in a restaurant. With stacked attacks, attackers trick the API
    endpoint into running several database instructions at the same time. This lets
    them achieve more complex goals, such as manipulating data or gaining more access
    within the system. These attacks are especially risky because they allow you to
    perform powerful actions on the database and potentially become a more powerful
    user within the endpoint.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以使用比经典 SQL 注入攻击更先进的技术，称为堆叠（或链式）SQL 注入。这就像在餐厅一次性给出多个订单一样。通过堆叠攻击，攻击者欺骗 API
    端点同时执行多个数据库指令，这让他们能够实现更复杂的目标，如篡改数据或在系统内获得更多权限。这些攻击尤其危险，因为它们允许你对数据库执行强有力的操作，并可能成为端点内更强大的用户。
- en: 'Let’s leverage the same command of the previous section. Suppose the target
    API endpoint sends the following query to the backend database:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用上一节中的相同命令。假设目标 API 端点向后台数据库发送以下查询：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s spice this up just a little with this as the `$``user_input` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微加点料，把它作为 `$``user_input` 变量：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will make the final query the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使最终的查询变成如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An SQL engine that receives such a query will interpret the semicolon sign as
    the end of the command and will execute the subsequent command, which inserts
    a new username and password into the `users` table. Should you be successful,
    you now have a credential pair to access the API endpoint and dive deeper into
    your pentesting activities…
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到此类查询的 SQL 引擎将把分号符号解释为命令的结束，并执行随后的命令，该命令会将一个新的用户名和密码插入到 `users` 表中。如果成功的话，你现在就有了一对凭据，可以访问
    API 端点，并深入进行渗透测试活动……
- en: Union SQL injection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合 SQL 注入
- en: Union SQL injection attacks are a sophisticated exploitation technique that
    manipulates the structure of SQL queries to extract additional information from
    a database. This type of attack leverages the SQL `UNION` operator to combine
    the results of two or more `SELECT` queries into a single result set, allowing
    you to retrieve data from database tables they would not typically have access
    to. Union SQL injection attacks are particularly dangerous as they can lead to
    unauthorized data access, data leakage, and even full database compromise if not
    properly mitigated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 联合 SQL 注入攻击是一种复杂的利用技术，它操控 SQL 查询的结构，以从数据库中提取额外的信息。这种类型的攻击利用 SQL `UNION` 操作符，将两个或多个
    `SELECT` 查询的结果合并成一个单一的结果集，从而使你能够从通常没有权限访问的数据库表中检索数据。联合 SQL 注入攻击尤其危险，因为它们可能导致未经授权的数据访问、数据泄露，甚至如果没有正确缓解，可能会完全破坏数据库。
- en: 'Suppose your target API endpoint accepts `GET` requests. To request details
    about a product, for example, the request could be something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的目标 API 端点接受 `GET` 请求。例如，要请求某个产品的详细信息，请求可能是这样的：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, `$id` could be some numeric or alphanumeric value. Behind the scenes,
    the endpoint would craft a corresponding `SELECT` statement to pass it over to
    the database, such as the ones you’ve seen in the preceding sections. Now, let’s
    replace the content of `$id` with an especially crafted sequence:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$id` 可能是某个数字或字母数字值。在后台，端点会构造一个相应的 `SELECT` 语句并将其传递给数据库，像你在前面部分看到的那样。现在，让我们将
    `$id` 的内容替换为一个特别设计的序列：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This would result in the following `GET` request:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下 `GET` 请求：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Without proper validation, the endpoint would be deceived into building the
    expected `SELECT` statement with `$prod_id` equals `50`, but also sending a second
    unpredicted `SELECT` statement that would retrieve all items from the `orders`
    table. This happens because the endpoint is simply picking the value of `$prod_id`
    and passing it to the `SELECT` command without even validating if it is in an
    expected shape. The `ALL` keyword plays an important role here. Some applications
    may use the `DISTINCT` keyword when selecting items from a database. This is,
    first, to avoid excessive network communication between endpoint and database,
    and second, to not retrieve duplicate items. When preceded by `ALL`, a `SELECT`
    statement will retrieve all items regardless of `DISTINCT`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的验证，端点将被欺骗构建出预期的 `SELECT` 语句，其中 `$prod_id` 等于 `50`，但同时发送一个第二个未预测到的 `SELECT`
    语句，检索 `orders` 表中的所有项。这是因为端点只是选择了 `$prod_id` 的值，并将其传递给 `SELECT` 命令，而没有验证它是否符合预期格式。`ALL`
    关键字在这里起到了重要作用。有些应用在从数据库中选择项时可能会使用 `DISTINCT` 关键字。首先，这是为了避免端点与数据库之间的过多网络通信；其次，是为了避免检索重复的项目。当
    `ALL` 位于前面时，`SELECT` 语句将检索所有项目，而不管是否有 `DISTINCT`。
- en: Hidden union SQL injection
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏联合 SQL 注入
- en: Union SQL injection vulnerabilities present a substantial risk to the security
    of APIs. However, when attackers conceal their malicious intent within seemingly
    innocuous user input, the threat becomes even more insidious. This is where hidden
    union SQL injection emerges as a significant concern. Hidden union SQL injection
    extends the principles of conventional union attacks. You can exploit weaknesses
    in API endpoints but elevate the level of deceit. By meticulously devising malicious
    payloads that camouflage your final intention within the guise of legitimate user
    input, you can complicate detection and mitigation efforts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 联合 SQL 注入漏洞对 API 安全构成了重大风险。然而，当攻击者将恶意意图隐藏在看似无害的用户输入中时，威胁就变得更加隐蔽。这就是隐藏联合 SQL
    注入成为一个重要关注点的原因。隐藏联合 SQL 注入延伸了传统联合攻击的原理。你可以利用 API 端点的弱点，但提升欺骗的层级。通过精心设计恶意有效载荷，将最终意图伪装成合法的用户输入，你可以使得检测和缓解工作变得更加复杂。
- en: The malevolent code seems benign when embedded within user input, rendering
    it challenging to spot during cursory examination. As a matter of fact, a poorly
    configured **web application firewall** (**WAF**) may ignore this attack. Moreover,
    extracted confidential data is frequently discreetly embedded within the API response,
    possibly melding with genuine information. This deceptive strategy complicates
    the detection of dubious activities and necessitates careful examination of API
    queries and responses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码嵌入在用户输入中时看似无害，使得在粗略检查时难以发现。事实上，一个配置不当的**Web 应用防火墙**（**WAF**）可能会忽略这种攻击。此外，提取的机密数据通常会悄悄嵌入
    API 响应中，可能与真实信息混合在一起。这种欺骗性策略使得检测可疑活动变得更加困难，必须仔细检查 API 查询和响应。
- en: 'Suppose our target API endpoint accepts `POST` requests and responds with product
    data retrieved from the backend database. One possible scenario would be the following
    structure passed as a parameter to the endpoint:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标 API 端点接受 `POST` 请求并响应从后台数据库检索到的产品数据。一个可能的场景是将以下结构作为参数传递给端点：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would become a legit `SQL SELECT` statement to bring 10 clothing products
    at most. With a hidden union attack, we would change this structure to look something
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为一个合法的 `SQL SELECT` 语句，最多返回 10 件服装产品。通过隐藏联合攻击，我们可以将这个结构改为类似如下的形式：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Observe the first change was to replace single quotes with double quotes for
    the value of `category`. This is to allow single quotes further on. The attack
    is then embedded between the parentheses. By sending this `SELECT` statement,
    we are requesting to receive information about both the admin user and the database
    engine version from a special table called `information_schema.tables`. And again,
    the `--` part has the same effect as the previous examples. The `version()` function
    returns details about the database engine, and the `LIMIT` keyword limits the
    answer to one row, to avoid the response being blocked by some rate-limiting/throttling
    mechanism.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到第一个变化是将 `category` 的值中的单引号替换为双引号。这是为了允许后续使用单引号。攻击代码随后嵌入括号中。通过发送这个 `SELECT`
    语句，我们请求从一个名为 `information_schema.tables` 的特殊表中获取关于管理员用户和数据库引擎版本的信息。再一次，`--` 部分和之前的例子一样起到了注释作用。`version()`
    函数返回关于数据库引擎的详细信息，而 `LIMIT` 关键字将回答限制为一行，以避免响应被某些速率限制/节流机制拦截。
- en: Boolean SQL injection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔型 SQL 注入
- en: 'This technique is very useful when, while exploiting an SQL database backing
    an API endpoint, the returned error messages are too generic. For example, when
    asking for some non-existing product or user, the endpoint simply returns a 404
    error code and no further information. By sending some simple queries whose answers
    could be only `true` or `false`, you can check if the database is vulnerable to
    SQL injection and then create more directed attacks on it. Consider the following
    endpoint that accepts `GET` requests:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在利用 SQL 数据库支持 API 端点时，如果返回的错误信息过于通用，这个技巧非常有用。例如，当请求某个不存在的产品或用户时，端点仅返回 404
    错误代码，而没有更多信息。通过发送一些简单的查询，返回值仅可能是 `true` 或 `false`，你可以检查数据库是否容易受到 SQL 注入攻击，然后对其进行更有针对性的攻击。考虑以下接受
    `GET` 请求的端点：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By slightly changing it to the following, you can check what would be the answer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微修改为以下内容，你可以检查将会得到什么样的答案：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would obviously never work. The point here is not to get access to data
    on the very first attempt. We are fingerprinting how the database serving the
    API endpoint behaves. Now, you switch the second part of the statement to a valid
    value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然永远不会成功。这里的重点不是在第一次尝试时就获得数据。我们的目的是识别支持 API 端点的数据库如何响应。现在，你将语句的第二部分更改为一个有效的值：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I didn’t say this before since it’s too obvious, but you need to capture all
    output that’s sent by the endpoint as the responses to your requests. Everything
    is important since a small piece of data can constitute a vital part of understanding
    the target. If the answer to the previous query (`1=1`) is different from the
    other query (`1=2`), you will conclude the database is vulnerable to SQL injection.
    In other words, the endpoint is not correctly sanitizing the input before sending
    it to the database. Some administrators simply configure their endpoints or web
    applications to provide generic error messages hoping that by obscuring them this
    way, they are protecting their environments. Big mistake…
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有说这个，因为它太显而易见了，但你需要捕获由端点发送的所有输出作为你请求的响应。每一部分数据都很重要，因为一个小片段的数据可能构成理解目标的关键部分。如果前一个查询（`1=1`）的答案与另一个查询（`1=2`）不同，你将得出数据库容易受到
    SQL 注入攻击的结论。换句话说，端点在将输入发送到数据库之前没有正确清理。某些管理员只是配置他们的端点或 Web 应用程序提供通用的错误信息，认为通过这种方式模糊化错误信息，可以保护他们的环境。大错特错……
- en: 'You can power up this technique by making use of some functions that are common
    to several database engines. The following functions are your friends:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过利用一些多个数据库引擎常见的函数来增强这一技术。以下函数是你的朋友：
- en: '`ASCII(character)`: Returns an integer value (the ASCII code) corresponding
    to the provided character.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASCII(character)`：返回提供的字符对应的整数值（ASCII 码）。'
- en: '`LENGTH(string)`: Returns the length of the provided string in bytes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LENGTH(string)`：返回提供的字符串的字节长度。'
- en: '`SUBSTRING(string, initial character, number of characters)`: Returns the partial
    string captured from the provided string, beginning on the initial character position
    with a total length of the number of characters. Consider 0 as the position of
    the initial character.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBSTRING(string, initial character, number of characters)`：返回从提供的字符串中截取的部分字符串，从初始字符位置开始，总长度为指定字符数。考虑
    0 为初始字符的位置。'
- en: 'Let your imagination fly. The query we sent before can be boosted with some
    discovery attempts. Consider you want to retrieve all usernames whose lengths
    are less than or equal to 10\. You can craft a query such as this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的想象力飞扬。我们之前发送的查询可以通过一些发现尝试进一步增强。假设你想获取所有长度小于或等于 10 的用户名。你可以构造类似这样的查询：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can automate this by mixing and matching these functions, such as trying
    to guess the admin’s username. Do you realize the potential of this technique?
    By combining patience, imagination, and a vulnerable API endpoint, you can extract
    lots of data. In the next section, we will exploit SQL injection on crAPI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过混合和匹配这些功能来自动化操作，例如尝试猜测管理员的用户名。你意识到这种技术的潜力了吗？通过结合耐心、想象力和易受攻击的 API 端点，你可以提取大量数据。在接下来的章节中，我们将在
    crAPI 上利用 SQL 注入。
- en: Exploiting SQL injection on a vulnerable API
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在一个易受攻击的 API 上利用 SQL 注入
- en: 'For this exercise, we will leverage a lightweight and effective Python application
    embedded with some vulnerabilities, including SQL injection: `python vAPI.py -p
    <port>`. Just select a port not used by other tools, such as Burp Suite, **Open
    Worldwide Application Security Project Zed Attack Proxy** (**OWASP ZAP**), or
    WebGoat.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个轻量且高效的 Python 应用程序，其中嵌入了一些漏洞，包括 SQL 注入：`python vAPI.py -p <port>`。只需选择一个不被其他工具占用的端口，例如
    Burp Suite、**开放全球应用安全项目 Zed 攻击代理**（**OWASP ZAP**）或 WebGoat。
- en: Let’s also use our other friends, Burp Suite and Postman, to help us with this
    quest. Launch Burp Suite and start a new project with the defaults. Also, start
    Postman. You will need to either configure your operating system to use Burp as
    the proxy or configure Postman itself to do it. I recommend going with the second
    option for the sake of avoiding breaking other tests you may be doing in your
    system. In Postman, click **File** | **Settings** and choose **Proxy**. Then,
    make sure **Use system proxy** is disabled and enable **Use custom proxy configuration**.
    Select at least the **HTTP** proxy type and provide the hostname and port where
    Burp is listening for requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也使用其他工具，Burp Suite 和 Postman，来帮助我们完成这个任务。启动 Burp Suite 并使用默认设置创建一个新项目。同时启动
    Postman。你需要配置操作系统以使用 Burp 作为代理，或者配置 Postman 本身来做这件事。我建议选择第二种方法，以避免破坏系统中其他正在进行的测试。在
    Postman 中，点击 **文件** | **设置** 并选择 **代理**。然后，确保禁用 **使用系统代理**，并启用 **使用自定义代理配置**。选择至少
    **HTTP** 代理类型，并提供 Burp 监听请求的主机名和端口。
- en: 'vAPI has documentation written using the OpenAPI format. It’s represented by
    the `openapi/vAPI.yaml` path. Since it’s a small application, it’s OK to directly
    open and read this document. On the other hand, if you’d prefer to read it as
    an HTML file, there’s a very convenient Python code that can convert it for you.
    The utility can be found here: [https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3](https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3).
    You will verify there are a couple of endpoints accepting both `GET` and `POST`
    requests. After analyzing the available endpoints, it seems we start with the
    `/tokens` endpoint, and by providing a valid credential pair, you can receive
    a valid token. Start the application using some free port, such as `8000`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: vAPI 有使用 OpenAPI 格式编写的文档。它位于 `openapi/vAPI.yaml` 路径下。由于这是一个小型应用程序，直接打开并阅读此文档是可以的。另一方面，如果你更喜欢将其作为
    HTML 文件阅读，有一个非常方便的 Python 代码可以为你转换它。这个工具可以在这里找到：[https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3](https://gist.github.com/oseiskar/dbd51a3727fc96dcf5ed189fca491fb3)。你会验证到，有几个端点同时接受
    `GET` 和 `POST` 请求。在分析可用端点后，似乎我们从 `/tokens` 端点开始，通过提供有效的凭证对，你可以收到一个有效的令牌。使用某个空闲端口启动应用程序，例如
    `8000`：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we have no idea of what the usernames and passwords are, let’s use a creative
    combination of such by crafting a request with Postman:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道用户名和密码是什么，让我们通过使用 Postman 精心构造请求，利用创意组合这些信息：
- en: '![Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint](img/B19657_05_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 发送 POST 请求到 vAPI 的 /tokens 端点](img/B19657_05_02.jpg)'
- en: Figure 5.2 – Sending a POST request to vAPI’s /tokens endpoint
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 发送 POST 请求到 vAPI 的 /tokens 端点
- en: 'We obviously received an error message. Now, go to Burp Suite to check the
    HTTP connection history. Locate the request to `/tokens`, right-click on it (still
    on the `§`. This will be used to instruct the tool about which portions of subsequent
    requests will change during the attack:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然收到了一个错误信息。现在，进入 Burp Suite 查看 HTTP 连接历史记录。找到对 `/tokens` 的请求，右键点击它（仍然在 `§`
    上）。这将用于指示工具哪些部分的后续请求将在攻击过程中发生变化：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Set **Attack type** as **Sniper**. Now, move to the **Payloads** subsection.
    Set **Payload type** as **Simple list** and click on the **Load…** button on the
    block that says **Payload settings [Simple list]**. You can load multiple files
    at once. Do this if you have more than one list. Deselect the last checkmark that
    says **URL encode these characters**. This will avoid unnecessary encoding when
    submitting the payloads to the target. Finally, click on **Start Attack**. In
    real life, if your target is protected by some rate-limiting or anti-DoS control,
    you may receive some blocks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将**攻击类型**设置为**狙击手**。现在，移动到**有效载荷**子章节。将**有效载荷类型**设置为**简单列表**，然后点击标记为**有效载荷设置
    [简单列表]**的块中的**加载…**按钮。你可以一次加载多个文件。如果你有多个列表，可以这样做。取消选择最后一个复选框，文本为**URL 编码这些字符**。这样可以避免在提交有效载荷到目标时进行不必要的编码。最后，点击**开始攻击**。在现实中，如果你的目标受到速率限制或反
    DoS 控制的保护，可能会收到一些阻塞。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using the Community Edition of Burp Suite, this may take a while
    since the Intruder functionality has been reduced in features and attacks are
    locally time throttled. You may realize an interval of around 5 seconds between
    each payload.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Burp Suite 的社区版，这可能需要一些时间，因为 Intruder 功能已减少，攻击会在本地时间受到限制。你可能会发现每个有效载荷之间大约有
    5 秒钟的间隔。
- en: 'Hopefully, with some patience and luck, you will be successful in this. Actually,
    after some time, we managed to find a valid username. When analyzing Intruder’s
    outputs, look for the ones with the `200 code`. We had lots of this kind of code
    in our practical example. In *Figure 5**.3*, you can spot the success of our SQL
    injection attack against crAPI. We discovered a valid user ID and username:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 希望有些耐心和运气，你会成功的。实际上，在一些时间后，我们成功找到了一个有效的用户名。在分析 Intruder 输出时，寻找带有 `200 代码`的结果。我们在实际例子中得到了很多这样的代码。在*图
    5.3*中，你可以看到我们针对 crAPI 进行 SQL 注入攻击的成功。我们发现了有效的用户 ID 和用户名：
- en: '![Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair](img/B19657_05_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – vAPI 易受 SQL 注入攻击，并暴露了有效的凭证对](img/B19657_05_03.jpg)'
- en: Figure 5.3 – vAPI vulnerable to SQL injection and reveals a valid credential
    pair
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – vAPI 易受 SQL 注入攻击，并暴露了有效的凭证对
- en: 'A token is provided as part of the response. You can leverage it, for example,
    to change the user’s password through the `/user` endpoint. Let’s use this same
    endpoint to obtain the user’s password, using the token extracted in our attack:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中提供了一个令牌。你可以利用它，例如，通过 `/user` 端点更改用户的密码。让我们使用这个相同的端点来获取用户密码，使用我们在攻击中提取的令牌：
- en: '![Figure 5.4 – Obtaining the user’s password after gaining access to a valid
    token](img/B19657_05_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 获取用户密码，在获取有效令牌后](img/B19657_05_04.jpg)'
- en: Figure 5.4 – Obtaining the user’s password after gaining access to a valid token
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 获取用户密码，在获取有效令牌后
- en: You can explore this application more and possibly get more data with further
    injection attacks. In the next section, let’s learn some NoSQL injection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步探索这个应用，可能通过进一步的注入攻击获取更多的数据。在接下来的章节中，我们将学习一些 NoSQL 注入。
- en: Testing for NoSQL injection
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 NoSQL 注入
- en: We have covered a reasonable ground of SQL injection attacks, but the fact is
    there is a considerable number of applications (and API endpoints) on the internet
    that need to handle unstructured data, such as documents, emails, social media
    posts, images, and audio and video files. For these use cases, relational databases
    are not the best choice since not all elements inside such databases have direct
    relationships, which would cause its management an unfair task. Carlo Strozzi
    introduced the concept of NoSQL databases in 1998 with his Strozzi NoSQL **open
    source software** (**OSS**) proposal. Since then, we’ve seen the release of many
    awesome products out there, such as MongoDB, Apache Cassandra, and Neo4j, just
    to name a few.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 SQL 注入攻击的合理范围，但事实上，互联网上有大量需要处理非结构化数据（如文档、电子邮件、社交媒体帖子、图像以及音频和视频文件）的应用程序（和
    API 端点）。对于这些使用案例，关系数据库并不是最佳选择，因为这些数据库中的所有元素并非都有直接关系，这将使得其管理变得不公平。Carlo Strozzi
    在 1998 年提出了 NoSQL 数据库的概念，并提出了 Strozzi NoSQL **开源软件**（**OSS**）的建议。从那时起，我们见证了许多出色的产品发布，如
    MongoDB、Apache Cassandra 和 Neo4j，仅举几例。
- en: 'As these databases, as their type implies, are not SQL ones, they do not use
    SQL for making queries or responding to them. Hence, our SQL injection techniques
    do not work here. We need to approach them in another way. In this scenario, there
    are basically three types of attacks that we can leverage to achieve success:
    **syntax injection**, **object injection**, and **operator injection**. Let’s
    separately cover each of them.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据库，顾名思义，并不是 SQL 数据库，它们不会使用 SQL 来进行查询或响应查询。因此，我们的 SQL 注入技术在这里不起作用。我们需要用另一种方式进行处理。在这种情况下，基本上有三种攻击方式可以利用以达到成功：**语法注入**、**对象注入**和**操作符注入**。让我们分别讨论每一种。
- en: Syntax injection
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法注入
- en: Syntax injection stands out as the prevalent form of NoSQL injection. In this
    type of attack, the pentester embeds harmful code within user input, which the
    API then integrates into a NoSQL query. This injected code has the potential to
    disrupt the syntax of the query, evade filters, or even trigger the execution
    of unauthorized commands within the database.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 语法注入是 NoSQL 注入中最常见的攻击方式。在这种攻击类型中，渗透测试者将有害代码嵌入到用户输入中，API 随后将其整合到 NoSQL 查询中。这个注入的代码可能会破坏查询的语法，绕过过滤器，甚至触发数据库中未授权命令的执行。
- en: The core concept of a NoSQL syntax injection attack revolves around manipulating
    user input. The pentester crafts malicious code and injects it into parameters
    that are then incorporated into the NoSQL query by the vulnerable API. One common
    scenario where NoSQL syntax injection attacks occur is in API endpoints that handle
    user authentication. For instance, an API might have a login endpoint where users
    submit their credentials for authentication. If the API uses a NoSQL database
    to store user data and does not properly sanitize user input, attackers can inject
    malicious code into the login credentials to bypass authentication checks or gain
    unauthorized access to user accounts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 语法注入攻击的核心概念围绕着操控用户输入展开。渗透测试者编写恶意代码，并将其注入到作为参数的用户输入中，然后这些参数被脆弱的 API 纳入
    NoSQL 查询中。NoSQL 语法注入攻击常发生在处理用户身份验证的 API 端点中。例如，某个 API 可能有一个登录端点，用户提交凭证以进行身份验证。如果
    API 使用 NoSQL 数据库存储用户数据，并且没有正确地对用户输入进行清洗，攻击者就可以将恶意代码注入到登录凭证中，从而绕过身份验证检查或获取未授权的用户账户访问权限。
- en: In a NoSQL syntax injection attack, you as a pentester can leverage various
    techniques to evade detection and achieve your objectives. For example, you might
    use wildcard characters, regular expressions, or other syntax manipulation techniques
    to craft payloads that disrupt the query’s structure or evade input validation
    mechanisms. By carefully constructing their payloads, you can exploit vulnerabilities
    in the API endpoint and compromise the integrity and confidentiality of the database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NoSQL 语法注入攻击中，作为渗透测试者，你可以利用各种技术来避开检测并达成目标。例如，你可能会使用通配符字符、正则表达式或其他语法操控技术来编写负载，扰乱查询的结构或绕过输入验证机制。通过精心构建负载，你可以利用
    API 端点的漏洞，破坏数据库的完整性和机密性。
- en: 'Here’s how it works. Consider an API endpoint that does user authentication
    with the help of a NoSQL database. The endpoint accepts `GET` requests in the
    following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的呢？假设一个 API 端点使用 NoSQL 数据库进行用户身份验证。该端点接受 `GET` 请求，格式如下：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Internally, the API endpoint translates the request into a NoSQL query like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，API 端点将请求转换为类似以下的 NoSQL 查询：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Observe that there was absolutely no validation or filtering of the input provided
    by the requester, neither on the username nor on the password fields. We have
    a candidate for a NoSQL syntax injection attack! We could slightly change this
    request to something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提供的输入（包括用户名和密码字段）没有经过任何验证或过滤。我们有了进行 NoSQL 语法注入攻击的机会！我们可以稍微修改此请求，例如如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We just manipulated the query to use a regular expression that represents any
    username and any password (`.` matches any character and `*` matches 0 or more
    occurrences of the preceding character). We just bypassed the authentication control
    of the endpoint…
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚修改了查询，使用了一个正则表达式，表示任何用户名和任何密码（` .` 匹配任意字符，`*` 匹配前一个字符出现 0 次或多次）。我们刚刚绕过了端点的身份验证控制…
- en: Object injection
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象注入
- en: NoSQL object injection attacks pose a distinct threat to APIs that interact
    with these types of databases. Unlike traditional NoSQL attacks that target the
    raw query itself, object injection attacks exploit weaknesses in how APIs handle
    user-provided data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL对象注入攻击对与这些类型的数据库交互的API构成了独特的威胁。与传统的NoSQL攻击直接攻击原始查询不同，对象注入攻击利用了API在处理用户提供的数据时的弱点。
- en: Imagine an API uses a secret language (serialization) to convert user data into
    a format the NoSQL database understands. You as a pentester can exploit vulnerabilities
    in this translation process. You could craft malicious data that, when *translated*
    (deserialized) by the API, manipulates internal object structures. This can lead
    to unexpected consequences, potentially allowing you to run unauthorized code
    or access sensitive data you shouldn’t.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个API使用一种秘密语言（序列化）将用户数据转换为NoSQL数据库能够理解的格式。作为渗透测试者，你可以利用这个转换过程中的漏洞。你可以构造恶意数据，当这些数据被API*翻译*（反序列化）时，操纵内部的对象结构。这可能导致意外后果，甚至可能允许你运行未授权的代码或访问你不该接触的敏感数据。
- en: A common scenario involves APIs that serialize user-supplied data (such as JSON)
    before storing it in the NoSQL database. If the API doesn’t check the data carefully
    before translation, a pentester can sneak in malicious objects that exploit weaknesses
    in the deserialization process. Think of it like tricking the translator into
    saying something completely different than what you intended. This allows you
    to gain an unfair advantage within the system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的场景是，API在将用户提供的数据（如JSON）存储到NoSQL数据库之前会先进行序列化。如果API在翻译之前没有仔细检查数据，渗透测试者就可以悄悄插入恶意对象，利用反序列化过程中的弱点。可以把它想象成诱骗翻译人员说出完全不同于你原本想说的内容。这使得你能够在系统中获得不正当的优势。
- en: 'As an example, we can consider an API endpoint that allows users to filter
    products based on price and category. The following JavaScript code shows a possible
    query that this endpoint could build to send to the database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以考虑一个允许用户根据价格和类别筛选产品的API端点。以下JavaScript代码展示了该端点可能构建的查询，发送到数据库：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `filterObject` constant receives data directly provided by the requester
    (`minPrice` and `category`). This is then used on the `db.products.find` query.
    Continuing with our example, a valid `GET` request to select products with a minimum
    price of 100 and belonging to the `furniture` category would be the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterObject`常量直接接收请求者提供的数据（`minPrice`和`category`）。然后，它被用于`db.products.find`查询。继续我们的示例，一个有效的`GET`请求，选择最低价格为100且属于`furniture`类别的产品将是以下内容：'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It doesn’t matter if it’s a `GET` or `POST` request. The same approach can
    be used for pretty much any verb here. How can we transform this into an object
    injection attack? Simple. We insert an initially unexpected object as part of
    the query. With this, the endpoint will grant us admin access besides checking
    the original product’s category. Look at the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是`GET`请求还是`POST`请求，都没关系。几乎可以使用相同的方法来处理任何请求方式。我们如何将其转化为对象注入攻击呢？很简单。我们将一个最初未被预料到的对象作为查询的一部分插入。这样，端点将在检查原始产品的类别之外，授予我们管理员访问权限。请看以下示例：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the endpoint is not correctly configured to sanitize this input, admin access
    to the database could be granted, and then other stages of the attack could happen.
    The `isAdmin` object was not intended to be part of a legitimate query, but because
    I previously knew that this database would accept it as a possible parameter (of
    course, after doing my enumeration/fingerprinting tasks), I’m a bit safer to assume
    it will work. The success of a NoSQL object injection attack largely depends on
    how the API handles user-supplied objects and incorporates them into its operations.
    Nevertheless, the fundamental concept of altering object structure to achieve
    unauthorized access or tamper with data holds true across different NoSQL database
    platforms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端点没有正确配置以清理这些输入，可能会授予数据库的管理员访问权限，然后攻击的其他阶段就会发生。`isAdmin`对象本不应作为合法查询的一部分，但因为我之前知道这个数据库会接受它作为一个可能的参数（当然，这是在我进行枚举/指纹识别工作之后得出的结论），所以我有些可以放心假设它会生效。NoSQL对象注入攻击的成功在很大程度上取决于API如何处理用户提供的对象并将其纳入操作中。然而，改变对象结构以实现未授权访问或篡改数据的基本概念，在不同的NoSQL数据库平台中都是成立的。
- en: Operator injection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符注入
- en: At this stage, you may have already deduced we are talking about inserting NoSQL
    operators as part of this sort of attack. Yeah – I was quite a Captain Obvious
    here, but consider this an attempt to give you some relaxation after this massive
    reading. Fortunately, you already have access to a small yet useful table with
    some operators that could be leveraged here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，你可能已经推测到我们在谈论在此类攻击中插入 NoSQL 操作符。是的——我这次确实像个显而易见的“显而易见队长”，但请将此视为在这次长篇阅读后给你带来的一点轻松。幸运的是，你已经可以访问到一个小而实用的表格，其中列出了可以在这里利用的一些操作符。
- en: NoSQL databases offer a tempting combination of power and flexibility, but they
    also introduce new security challenges. NoSQL operator injection attacks lurk
    in the shadows, waiting to exploit APIs that interact with these databases. These
    attacks target vulnerabilities in APIs that build queries “on the fly” based on
    user input. Devious attackers can then inject specially crafted data to manipulate
    how the database interprets the query. This attack has some similarities with
    syntax injection; however, this one is not breaking the initially predicted syntax
    of a query but just twisting it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库提供了强大且灵活的组合，但它们也带来了新的安全挑战。NoSQL 操作符注入攻击潜伏在阴影中，等待利用与这些数据库交互的 API。这些攻击瞄准了基于用户输入“动态生成”查询的
    API 中的漏洞。狡猾的攻击者可以注入特制数据来操控数据库如何解释查询。此攻击与语法注入有些相似；然而，攻击者并不是打破查询的最初预测语法，而是扭曲它。
- en: 'Imagine an API that allows users to search for products based on various filters,
    such as price or category, as we’ve previously seen. The API might construct a
    NoSQL query that dynamically incorporates user-supplied values. Here’s the problem:
    if the API doesn’t carefully check this user input, you can sneak in malicious
    operators. These operators, which are normally used for legitimate filtering,
    can be twisted to alter the query’s logic entirely. Think of it like someone manipulating
    the search bar on a library website to return unexpected results. Sounds familiar?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个允许用户根据各种筛选条件（例如价格或类别）搜索产品的 API，正如我们之前所见。该 API 可能会构建一个 NoSQL 查询，动态地将用户提供的值纳入其中。问题在于：如果
    API 没有仔细检查这些用户输入，你就可以悄悄地插入恶意操作符。这些操作符通常用于合法的筛选，但可以被扭曲，从而完全改变查询的逻辑。想象一下，有人操控图书馆网站上的搜索框来返回意想不到的结果。听起来像吗？
- en: 'Let’s keep with our example of a website that provides products that in turn
    are organized into categories. An endpoint to show all products belonging to the
    `tools` category could be something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用之前的网站示例，该网站提供的产品按类别组织。一个展示所有属于`tools`类别的产品的端点可能像下面这样：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This translates into the following NoSQL query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就转化为以下 NoSQL 查询：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Simple, yet powerful. Now, suppose the user I’m using to interact with this
    endpoint does not have access to see products belonging to other categories, but
    the endpoint is not fully applying this control. So, how could I bypass it? Take
    a look:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 简单却强大。现在，假设我用于与此端点交互的用户没有权限查看属于其他类别的产品，但该端点并未完全应用此控制。那么，我该如何绕过它呢？看看这个：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `$ne` part corresponds to a NoSQL operator that means “not equal.” So,
    we are asking the API endpoint to show all products whose categories are not `tools`.
    Fantastic, isn’t it?! I’ve provided a list of MongoDB operators for your convenience.
    Observe not all NoSQL databases follow the same rule, so you can either try to
    fingerprint the backend database or combine operators from different database
    engines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ne` 部分对应一个 NoSQL 操作符，表示“不等于”。因此，我们要求 API 端点显示所有类别不为 `tools` 的产品。棒极了，是吧？！为了方便你，我提供了一份
    MongoDB 操作符的列表。请注意，并非所有 NoSQL 数据库都遵循相同的规则，因此你可以尝试识别后端数据库，或结合不同数据库引擎的操作符：'
- en: '| **Operator** | **Meaning** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **含义** |'
- en: '| `$``eq` | Matches values that are equal to a specified value |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `$``eq` | 匹配等于指定值的值 |'
- en: '| `$``ne` | Matches all values that are not equal to a specified value |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `$``ne` | 匹配所有不等于指定值的值 |'
- en: '| `$``gt` | Matches values that are greater than a specified value |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `$``gt` | 匹配大于指定值的值 |'
- en: '| `$``gte` | Matches values that are greater than or equal to a specified value
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `$``gte` | 匹配大于或等于指定值的值 |'
- en: '| `$``in` | Matches any of the values specified in an array |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `$``in` | 匹配数组中指定的任意值 |'
- en: '| `$``lt` | Matches values that are less than a specified value |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `$``lt` | 匹配小于指定值的值 |'
- en: '| `$``lte` | Matches values that are less than or equal to a specified value
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `$``lte` | 匹配小于或等于指定值的值 |'
- en: '| `$``nin` | Matches none of the values specified in an array |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `$``nin` | 匹配数组中指定的值之外的任何值 |'
- en: 'Table 5.1 – MongoDB comparison operators (Source: MongoDB official documentation)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – MongoDB 比较操作符（来源：MongoDB 官方文档）
- en: Now, let’s take a look at this in practice with an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个练习来看一下实际操作。
- en: Exploiting NoSQL injection on crAPI
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 crAPI 上利用 NoSQL 注入
- en: 'It’s time to get back to our old friend, crAPI. We well know it exposes a considerable
    number of endpoints, so let’s verify if there’s one we can pick to exercise this.
    Start your crAPI instance. Let’s also use our other friend, Burp Suite, to help
    us with this quest. Launch Burp Suite and start a new project with the defaults.
    You will need to use Burp’s browser in your lab since all services are listening
    locally (`localhost`). Access crAPI. If you still don’t have an account, create
    one by following the straightforward process. After logging in, go to the **Shop**
    area, as shown in *Figure 5**.5*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到我们的老朋友 crAPI 了。我们都知道它暴露了大量的端点，因此让我们验证一下是否有一个可以用来进行练习的端点。启动你的 crAPI 实例。我们还将使用另一个朋友——Burp
    Suite 来帮助我们完成这项任务。启动 Burp Suite，并使用默认设置开始一个新项目。你需要在实验室中使用 Burp 的浏览器，因为所有服务都是在本地监听的（`localhost`）。访问
    crAPI。如果你还没有账户，按照简单的流程创建一个。登录后，进入 **商店** 区域，如 *图 5.5* 所示：
- en: '![Figure 5.5 – crAPI’s Shop area](img/B19657_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – crAPI 的商店区域](img/B19657_05_05.jpg)'
- en: Figure 5.5 – crAPI’s Shop area
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – crAPI 的商店区域
- en: 'Observe our initial balance: $100\. Our objective here is to buy an item for
    less than what it really costs or increase our balance. If we have a coupon, we
    can add its code using the corresponding button. The point is, we don’t have any
    code – yet… Click on the **Add Coupons** button and type anything. You will receive
    an error message:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们的初始余额：$100。我们的目标是以低于实际成本的价格购买商品或增加我们的余额。如果我们有优惠券，我们可以通过相应的按钮添加其代码。问题是，我们还没有任何代码——但很快就会有...
    点击 **添加优惠券** 按钮并输入任意内容。你会收到一个错误消息：
- en: '![Figure 5.6 – Invalid coupon code](img/B19657_05_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 无效的优惠券代码](img/B19657_05_06.jpg)'
- en: Figure 5.6 – Invalid coupon code
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 无效的优惠券代码
- en: 'This part of crAPI uses a NoSQL database (MongoDB, to be more precise) to store
    the coupons. Now, go to Burp Suite to check the HTTP connection history. The last
    item will show you which endpoint crAPI is using to check this code. You will
    realize it is `/community/api/v2/coupon/validate-coupon`. We also confirm the
    endpoint returns a 500 error code with an empty JSON structure. Now, let’s use
    another resource of Burp to help us discover crAPI’s coupons. *Figure 5**.7* shows
    an example of sending a request to the coupon validation endpoint:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: crAPI 的这一部分使用了 NoSQL 数据库（更准确地说是 MongoDB）来存储优惠券。现在，转到 Burp Suite 查看 HTTP 连接历史。最后一项将显示
    crAPI 用来验证该代码的端点。你会发现它是 `/community/api/v2/coupon/validate-coupon`。我们还确认该端点返回了一个
    500 错误代码，并且是一个空的 JSON 结构。现在，让我们使用 Burp 的另一个资源来帮助我们发现 crAPI 的优惠券。*图 5.7* 显示了一个示例，展示了发送请求到优惠券验证端点的操作：
- en: '![Figure 5.7 – crAPI’s coupon validation endpoint](img/B19657_05_07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – crAPI 的优惠券验证端点](img/B19657_05_07.jpg)'
- en: Figure 5.7 – crAPI’s coupon validation endpoint
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – crAPI 的优惠券验证端点
- en: 'We’ll do something similar to what we did with the vAPI Python application
    in the SQL injection section. Right-click on this coupon validation request (still
    on the **HTTP history** tab) and select **Send to Intruder**, then move to this
    section of the tool. The first subsection you’ll see is **Positions**. Observe
    the request structure is a simple JSON structure with a single key and value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做一些类似于在 SQL 注入部分中使用 vAPI Python 应用程序的操作。右键点击这个优惠券验证请求（仍然在 **HTTP 历史** 标签页中），选择
    **发送到 Intruder**，然后进入该工具的这个部分。你将看到的第一个子部分是 **Positions**。观察请求结构，它是一个简单的 JSON 结构，包含一个键值对：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We want to fuzz the `"blabla"` part with lots of junk that will be pulled from
    the payload list. Select this whole `"blabla"` text, *including the double quotes*,
    and click on the `§`. Set **Attack type** as **Sniper**. Now, move to the **Payloads**
    subsection. Set **Payload type** as **Simple** and click on the **Load…** button
    on the block that says **Payload settings [Simple list]**. You can load multiple
    files at once. Do this if you have more than one. Deselect the last checkmark
    that says **URL encode these characters**. This will avoid unnecessary encoding
    when submitting the payloads to the target. Finally, click on **Start Attack**.
    Remember – Burp Community may take more time as the Intruder feature has intentionally
    received some delays between sent payloads.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对“`blabla`”部分进行模糊测试，加入大量从有效负载列表中拉取的垃圾数据。选择整个“`blabla`”文本，*包括双引号*，然后点击`§`。将**攻击类型**设置为**Sniper**。接下来，移动到**有效负载**子部分。将**有效负载类型**设置为**简单**，然后点击**加载…**按钮，进入标记为**有效负载设置[简单列表]**的块。你可以一次加载多个文件。如果有多个文件，执行此操作。取消选择最后一个选框，标记为**URL编码这些字符**。这将避免在提交有效负载时进行不必要的编码。最后，点击**开始攻击**。记住——Burp
    Community可能会花更多时间，因为Intruder功能有意在发送有效负载之间加入了一些延迟。
- en: 'Again, switch to the `200 code`, like the one on the following screenshot,
    which will disclose a coupon code to you. The `TRAC075` code means $75:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次切换到`200代码`，如下面截图所示，它会向你显示一个优惠券代码。`TRAC075`代码代表75美元：
- en: "![Figure 5.8 – crAPI disclosing a coupon code after \uFEFFa NoSQL injection\
    \ attack](img/B19657_05_08.jpg)"
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – crAPI在NoSQL注入攻击后泄露优惠券代码](img/B19657_05_08.jpg)'
- en: Figure 5.8 – crAPI disclosing a coupon code after a NoSQL injection attack
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – crAPI在NoSQL注入攻击后泄露优惠券代码
- en: Pick this coupon and add it to the corresponding area of the website. It will
    be accepted, and your balance will increase, as shown in *Figure 5**.9*. Lucky,
    lucky!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个优惠券并将其添加到网站的相应区域。它会被接受，你的余额将增加，如*图 5.9*所示。幸运，幸运！
- en: '![Figure 5.9 – Valid coupon code added](img/B19657_05_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 添加有效的优惠券代码](img/B19657_05_09.jpg)'
- en: Figure 5.9 – Valid coupon code added
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 添加有效的优惠券代码
- en: You can see your balance has increased by $75, as shown in *Figure* *5**.10*.
    Rich!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到余额增加了75美元，如*图* *5.10*所示。富有了！
- en: '![Figure 5.10 – Balance increase after the coupon code was added](img/B19657_05_10.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 添加优惠券代码后的余额增加](img/B19657_05_10.jpg)'
- en: Figure 5.10 – Balance increase after the coupon code was added
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 添加优惠券代码后的余额增加
- en: Congratulations! You will never have to spend more for a single product on crAPI’s
    shop. Sorry – just another terrible icebreaker. The list of payloads I used for
    this attack can be easily found in the references that I put in the *Further reading*
    section. Do not forget to check them as there is a vast amount of material that
    you can use in your pentesting endeavors. Next, we will learn about user input
    validation and sanitization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你再也不用为crAPI商店中的任何单一产品支付更多费用了。抱歉——只是另一个糟糕的破冰段子。我在*进一步阅读*部分提供的参考资料中，列出了我为这次攻击使用的有效负载清单。别忘了检查它们，因为其中有大量可以用于渗透测试的资料。接下来，我们将学习用户输入验证和清理。
- en: Validating and sanitizing user input
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和清理用户输入
- en: At this stage, I’m sure you are more than aware that the core success of injection
    attacks lies in the reduced (or lack of) sanitizing of what a user provides to
    an API endpoint or web application. When building secure APIs, validating and
    sanitizing user input is paramount for thwarting attacks. As a penetration tester,
    understanding these techniques is crucial for identifying vulnerabilities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我相信你已经深刻意识到，注入攻击的核心成功之处在于对用户提供给API端点或Web应用程序的数据没有进行充分（或根本没有）清理。构建安全的API时，验证和清理用户输入至关重要，它可以有效抵御攻击。作为渗透测试人员，理解这些技术对于识别漏洞至关重要。
- en: When users sign up, input validation acts as a vigilant gatekeeper, guaranteeing
    the information they provide adheres to specific guidelines and is suitable for
    processing. It meticulously examines the format, length, and content of crucial
    fields such as usernames, email addresses, and passwords. Open source powerhouses
    such as OWASP **Enterprise Security API** (**ESAPI**) offer dependable validation
    tools for diverse user input types. Imagine wielding ESAPI’s validation functions
    to ensure usernames are composed solely of letters and numbers, adhering to a
    predefined length limit. Similarly, you can verify email addresses conform to
    a legitimate format and that passwords satisfy complexity mandates, such as minimum
    length and the inclusion of special characters. This robust approach safeguards
    a system from potentially harmful or nonsensical data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注册时，输入验证充当着一个警觉的守门员，确保他们提供的信息符合特定的准则并且适合处理。它仔细检查用户名、电子邮件地址和密码等关键信息字段的格式、长度和内容。像
    OWASP **企业安全 API** (**ESAPI**) 这样的开源工具提供了可靠的验证工具，适用于不同类型的用户输入。试想使用 ESAPI 的验证功能来确保用户名仅由字母和数字组成，并符合预定的长度限制。类似地，你可以验证电子邮件地址是否符合合法格式，并确保密码满足复杂性要求，比如最小长度和包含特殊字符。通过这种强有力的方法，可以有效防止潜在有害或无意义的数据。
- en: 'There are at least five points that deserve attention from any API developer.
    You as a pentester should obviously check the absence of any of them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有五个点是每个 API 开发者都应关注的。作为渗透测试人员，你显然应该检查它们是否存在任何遗漏：
- en: '`@` and `.`), and usernames free of special characters that might disrupt the
    system. However, these safeguards can sometimes be flawed. Tools such as OWASP
    ZAP and Burp Suite empower pentesters to become stealthy middlemen, intercepting
    and dissecting communication (HTTP requests) between the user and the API.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 和 `.`），以及避免使用可能干扰系统的特殊字符的用户名。然而，这些防护措施有时可能存在缺陷。像 OWASP ZAP 和 Burp Suite
    这样的工具使渗透测试人员能够成为隐形中介，拦截并剖析用户与 API 之间的通信（HTTP 请求）。'
- en: '**Sanitizing query parameters for search queries**: APIs that empower users
    to unearth products by name or category require careful attention to sanitizing
    query parameters. This crucial step involves purging or transforming special characters
    that could potentially be exploited to manipulate the database query lurking beneath
    the surface. Tools such as SQLMap and NoSQLMap act as digital probes to reveal
    vulnerabilities in these queries. These tools can be employed to test for weaknesses
    susceptible to SQL and NoSQL injection attacks. By implementing robust input sanitization,
    such attacks can become ineffective and safeguard the integrity of the underlying
    database.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理查询参数以处理搜索查询**：允许用户通过名称或类别查找产品的 API 需要特别注意清理查询参数。这一步骤至关重要，涉及删除或转换可能被用来操控数据库查询的特殊字符。像
    SQLMap 和 NoSQLMap 这样的工具充当数字探针，揭示这些查询中的漏洞。通过使用这些工具可以测试是否存在 SQL 和 NoSQL 注入攻击的漏洞。通过实施强有力的输入清理措施，这类攻击将失效，从而保护底层数据库的完整性。'
- en: '**Validating file uploads**: Imagine an API that welcomes user-uploaded files,
    perhaps images or essential documents. However, lurking within this seemingly
    harmless functionality lies the potential for malicious activity. To fortify this
    API, robust input validation is paramount. It should act as a vigilant inspector,
    scrutinizing file types to ensure only permitted formats (such as images) are
    allowed. Additionally, size limitations must be enforced to prevent DoS attacks
    through massive file uploads. Malware detection mechanisms should be employed
    to identify and reject any malicious files that might attempt to infiltrate the
    system.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证文件上传**：想象一个允许用户上传文件的 API，也许是图片或重要文档。然而，在这个看似无害的功能背后，潜藏着恶意活动的潜力。为了增强这个 API
    的安全性，强有力的输入验证至关重要。它应该充当一个警觉的检查员，审查文件类型，确保只允许特定格式（如图片）。此外，必须强制文件大小限制，以防止通过大文件上传发起的
    DoS 攻击。还应采用恶意软件检测机制，识别并拒绝任何可能试图渗透系统的恶意文件。'
- en: Furthermore, filenames themselves require sanitization. This crucial step thwarts
    “directory traversal attacks” – a technique where pentesters exploit vulnerabilities
    in file naming conventions to access unauthorized parts of the system. Tools such
    as OWASP ZAP and Nikto act as invaluable allies for security professionals, enabling
    them to simulate attacks and pinpoint weaknesses in the file upload functionality,
    especially those arising from inadequate input validation.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，文件名本身也需要进行净化。这个关键步骤可以防止“目录遍历攻击”——一种渗透测试者利用文件命名规则中的漏洞，访问系统未授权部分的技术。像OWASP
    ZAP和Nikto这样的工具是安全专业人员的宝贵盟友，帮助他们模拟攻击并识别文件上传功能中的漏洞，特别是由于输入验证不充分所带来的问题。
- en: '`validator.js` for JavaScript or Django’s built-in form validation for Python
    offer invaluable assistance in implementing robust input validation for numeric
    input. These tools empower developers to establish clear guidelines for acceptable
    numerical ranges, preventing **out-of-bounds** (**OOB**) errors and maintaining
    data integrity within the API.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validator.js`（适用于JavaScript）或Django内置的表单验证（适用于Python）为实施强健的数字输入验证提供了宝贵的帮助。这些工具使开发者能够为可接受的数字范围设定明确的指导原则，防止**越界**（**OOB**）错误，并保持API中的数据完整性。'
- en: '**Sanitizing HTML input to prevent cross-site scripting (XSS) attacks**: Certain
    APIs allow users to contribute HTML content, such as comments or product descriptions.
    This seemingly innocuous functionality can be weaponized by attackers if proper
    safeguards are not in place. Malicious actors might attempt to inject malevolent
    scripts (XSS attacks) within the HTML, potentially hijacking user sessions, stealing
    data, or redirecting users to malicious websites. To thwart these attacks, sanitization
    is a critical defense mechanism.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**净化HTML输入以防止跨站脚本（XSS）攻击**：某些API允许用户提交HTML内容，如评论或产品描述。如果没有适当的防护，这种看似无害的功能可能被攻击者利用。恶意行为者可能试图在HTML中注入恶意脚本（XSS攻击），从而可能劫持用户会话、窃取数据或将用户重定向到恶意网站。为了防止这些攻击，净化是一个关键的防御机制。'
- en: This process involves either transforming (escaping) or entirely removing potentially
    harmful HTML tags and attributes, rendering them inert and incapable of executing
    malicious code. Fortunately, open source libraries such as DOMPurify for JavaScript
    and Bleach for Python come to the rescue. These tools empower developers to effectively
    sanitize HTML input, neutralizing XSS vulnerabilities and safeguarding the integrity
    of the API and its users.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个过程涉及转换（转义）或完全移除潜在的恶意HTML标签和属性，使其失效，无法执行恶意代码。幸运的是，像DOMPurify（适用于JavaScript）和Bleach（适用于Python）这样的开源库为开发者提供了帮助。这些工具使开发人员能够有效地净化HTML输入，消除XSS漏洞，保护API及其用户的完整性。
- en: Let’s take a closer look at each of these use cases.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下这些用例。
- en: Input validation for user registration
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户注册的输入验证
- en: During user registration, input validation acts as a vigilant security checkpoint,
    guaranteeing the information users provide adheres to predefined standards and
    is suitable for processing without compromising system security. This meticulous
    process involves examining the format, length, and content of crucial fields such
    as usernames, email addresses, and passwords. Powerful tools such as OWASP ESAPI
    offer an arsenal of validation functions. Think of them as skilled guards, each
    with a specific expertise. One guard ensures usernames are built solely with letters
    and numbers, adhering to a length restriction. Another verifies email addresses
    following a legitimate format, while a third enforces password complexity, demanding
    a minimum length and the inclusion of special characters. By implementing these
    rigorous checks, you effectively filter out nonsensical or potentially malicious
    data that could be used by attackers to exploit vulnerabilities. Thorough input
    validation is the cornerstone of secure user registration. It builds a fortified
    wall around your system, safeguarding it from a multitude of security threats
    and ensuring the smooth operation of your kingdom (API and application).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户注册过程中，输入验证充当了一个警惕的安全检查点，确保用户提供的信息符合预定义的标准，并且适合处理而不会危及系统安全。这个细致的过程包括检查诸如用户名、电子邮件地址和密码等重要字段的格式、长度和内容等。像
    OWASP ESAPI 这样的强大工具提供了一整套验证功能。可以把它们看作是训练有素的守卫，每个守卫都有特定的专长。一名守卫确保用户名只由字母和数字组成，并符合长度限制。另一名守卫验证电子邮件地址是否符合合法格式，而第三名守卫执行密码复杂性要求，要求密码具有最小长度并包含特殊字符。通过实施这些严格的检查，你有效地过滤掉了那些不合理或潜在恶意的数据，这些数据可能被攻击者利用来利用系统漏洞。彻底的输入验证是安全用户注册的基石。它为你的系统构筑了坚固的防护墙，保护它免受多种安全威胁，确保你的王国（API
    和应用程序）的顺利运行。
- en: 'Even nowadays, Java is a prominent programming language, and it’s not difficult
    to find web applications and API endpoints built upon it. Let’s consider the following
    excerpt of Java code that shows an example of OWASP ESAPI in action:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，Java 仍然是一个重要的编程语言，不难找到基于它构建的 Web 应用程序和 API 端点。让我们看看下面的 Java 代码片段，它展示了
    OWASP ESAPI 的实际应用：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, two classes, `ESAPI` itself and `ValidationException` from the
    `errors` package, are leveraged. Observe that a username is only considered valid
    when the `ESAPI.validator()` function states so.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，使用了两个类，`ESAPI` 本身和来自 `errors` 包的 `ValidationException`。请注意，只有当 `ESAPI.validator()`
    函数确认用户名有效时，才视为有效。
- en: Sanitizing query parameters
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理查询参数
- en: Sanitizing query parameters is a critical defense mechanism for APIs that interact
    with databases. Without proper sanitization, attackers can exploit vulnerabilities
    known as SQL injection to manipulate database queries. These malicious actors
    might use tools such as SQLMap to automate the process, sending a barrage of crafted
    strings (payloads) through query parameters. These payloads can potentially trick
    the database into executing unintended actions, such as stealing sensitive data
    or disrupting operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 清理查询参数是与数据库交互的 API 关键的防御机制。如果没有适当的清理，攻击者可以利用称为 SQL 注入的漏洞来操控数据库查询。这些恶意行为者可能使用像
    SQLMap 这样的工具来自动化这一过程，通过查询参数发送一连串精心构造的字符串（有效载荷）。这些有效载荷可能会诱使数据库执行意外的操作，比如窃取敏感数据或扰乱操作。
- en: Fortunately, we have powerful tools at our disposal to combat this threat. Input
    sanitization techniques, such as parameterized queries, act as a shield against
    such attacks. Parameterized queries separate the data (user input) from the actual
    SQL statement, preventing malicious code from being injected. Frameworks such
    as Flask in Python offer built-in support for parameterized queries. By embracing
    this approach, you can confidently execute SQL queries without exposing your application
    to the dangers of SQL injection, safeguarding the integrity of your database and
    user information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有强大的工具可以用来对抗这一威胁。输入清理技术，例如参数化查询，充当了防御这种攻击的盾牌。参数化查询将数据（用户输入）与实际的 SQL 语句分开，防止恶意代码被注入。像
    Python 中的 Flask 这样的框架提供了对参数化查询的内置支持。通过采用这种方法，你可以自信地执行 SQL 查询，而无需将应用程序暴露于 SQL 注入的危险之中，保护数据库和用户信息的完整性。
- en: 'The following code portion contains a Flask application interacting with an
    SQLite3 database. Instead of directly passing the input to the database, it first
    hardcodes the table name into the SQL statement and applies the `?` symbol:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码部分包含了一个Flask应用程序，它与SQLite3数据库进行交互。它不是直接将输入传递到数据库，而是先将表名硬编码到SQL语句中，并应用`?`符号：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the `q` query parameter is sanitized by using parameterized
    queries (`?`), ensuring that any malicious input provided by the user is properly
    escaped and doesn’t interfere with the SQL query execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`q`查询参数通过使用参数化查询（`?`）进行了清理，确保用户提供的任何恶意输入都被正确转义，不会干扰SQL查询的执行。
- en: Validating file uploads
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件上传验证
- en: File uploads offer a convenient functionality for users, but they can also be
    a gateway for attackers. Malicious actors might attempt to upload files disguised
    as harmless images or documents, but in reality, these files could be malicious
    scripts or executables capable of compromising the entire server. To prevent such
    attacks, robust input validation is essential. This process meticulously examines
    uploaded files, ensuring they adhere to predefined security standards.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传为用户提供了便捷的功能，但也可能成为攻击者的入口。恶意攻击者可能试图上传伪装成无害图片或文档的文件，但实际上，这些文件可能是恶意脚本或可执行文件，能够危及整个服务器。为了防止此类攻击，强有力的输入验证至关重要。这个过程会仔细检查上传的文件，确保它们符合预定义的安全标准。
- en: 'Validation focuses on two key aspects: file type and size. Only authorized
    file types, such as images or documents, should be allowed. Open source libraries
    such as **Apache Commons FileUpload** for Java come to the rescue, offering a
    suite of tools for validating uploads. These tools can check file extensions against
    a whitelist, verify content types to ensure they match the expected format, and
    enforce size limitations to prevent DoS attacks through massive uploads. By implementing
    these safeguards, you can effectively disarm these “digital bombs” disguised as
    file uploads, safeguarding your server and user data.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 验证重点关注两个关键方面：文件类型和大小。只应允许授权的文件类型，如图片或文档。像**Apache Commons FileUpload**这样的开源库可以提供帮助，提供一整套工具来验证上传。这些工具可以检查文件扩展名是否符合白名单，验证内容类型是否符合预期格式，并执行大小限制，以防止通过大规模上传发起的DoS攻击。通过实施这些防护措施，您可以有效解除这些伪装成文件上传的“数字炸弹”，保护您的服务器和用户数据。
- en: 'The following Java code exemplifies how files sent as input to an API endpoint
    can be correctly validated before being effectively processed by the backend,
    including an eventual database:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java代码示例演示了如何在将文件发送到API端点之前正确验证它们，以确保在后台有效处理之前，包括最终的数据库操作：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this code snippet, Apache Commons FileUpload is used to parse the file upload
    request, and then validation checks can be performed on the filename, content
    type, and size to ensure that only safe files are accepted for upload.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，使用了Apache Commons FileUpload来解析文件上传请求，然后可以对文件名、内容类型和大小进行验证检查，以确保只接收安全的文件进行上传。
- en: Input validation for numeric input
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值输入的验证
- en: When dealing with numeric input from users, ensuring the data adheres to the
    expected format and remains within acceptable boundaries is critical. Unchecked
    numeric input can introduce vulnerabilities such as buffer overflows or arithmetic
    overflows, potentially leading to unexpected program behavior, crashes, or even
    system compromise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户的数值输入时，确保数据符合预期格式并保持在可接受范围内至关重要。未经检查的数值输入可能会引入漏洞，例如缓冲区溢出或算术溢出，从而导致程序行为异常、崩溃，甚至系统被攻破。
- en: Open source libraries such as Apache Commons Validator for Java come to the
    rescue by offering a powerful arsenal for validating numeric input. These libraries
    provide functions specifically designed to handle different numeric data types
    – integers, floats, and more. Developers can leverage these functions to define
    clear constraints, such as minimum and maximum values, for acceptable user input.
    By implementing such validation, we can effectively “tame” numeric input, preventing
    errors and safeguarding the API endpoint from vulnerabilities that could be exploited
    by malicious actors. This ensures the endpoint processes data as intended and
    maintains its overall stability and security.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Apache Commons Validator 这样的开源库为 Java 提供了强大的工具，用于验证数字输入。这些库提供了专门处理不同数字数据类型（整数、浮点数等）的函数。开发者可以利用这些函数来定义可接受用户输入的明确约束，例如最小值和最大值。通过实现这样的验证，我们可以有效地“驯服”数字输入，防止错误并保护
    API 接口免受恶意攻击者利用的漏洞。这确保了接口按预期处理数据，并保持其整体稳定性和安全性。
- en: 'Look at how Apache Commons Validator for Java can be applied to sanitize user
    input:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下如何将 Apache Commons Validator for Java 应用于清理用户输入：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code snippet, Apache Commons Validator’s `FloatValidator` class is used
    to validate a float input against the `US` locale, ensuring that the input string
    represents a valid floating-point number.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码示例中，使用了 Apache Commons Validator 的 `FloatValidator` 类来验证一个浮动输入，确保输入字符串符合
    `US` 区域设置的有效浮点数标准。
- en: Sanitizing HTML input to prevent XSS attacks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理 HTML 输入以防止 XSS 攻击
- en: Imagine a scenario where untamed user input is directly inserted into a web
    page. This seemingly harmless practice creates a vulnerability known as XSS. Malicious
    actors can exploit XSS to plant hidden “*bombs*” within their input – malicious
    scripts disguised as regular text. Once the page renders, these scripts can detonate,
    stealing sensitive user information (such as session cookies) or performing unauthorized
    actions on the user’s behalf.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，用户输入未经处理地直接插入到网页中。这种看似无害的做法会创建一个被称为 XSS（跨站脚本攻击）的漏洞。恶意攻击者可以利用 XSS 在其输入中植入隐藏的“*炸弹*”——伪装成普通文本的恶意脚本。一旦页面渲染，这些脚本就会引爆，窃取敏感的用户信息（如会话
    cookie），或代表用户执行未授权的操作。
- en: To prevent such attacks, we rely on a technique called HTML escaping. This process
    involves encoding special characters within user input before displaying them
    on the web page. By encoding these characters, we effectively disarm the bombs
    and render them harmless. Open source libraries such as **OWASP Java Encoder**
    provide valuable utilities for HTML escaping. By leveraging these tools, developers
    can effectively sanitize user input, closing the door on XSS vulnerabilities and
    safeguarding user data and the API endpoint functionality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止此类攻击，我们依赖一种名为 HTML 转义的技术。该过程涉及在显示到网页之前对用户输入中的特殊字符进行编码。通过编码这些字符，我们可以有效地解除“炸弹”，使其变得无害。像
    **OWASP Java Encoder** 这样的开源库提供了用于 HTML 转义的有价值工具。通过利用这些工具，开发者可以有效地清理用户输入，堵住 XSS
    漏洞的大门，从而保护用户数据和 API 接口功能。
- en: 'The following code portion shows an example of how HTML input can be sanitized
    with the use of OWASP Java Encoder:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用 OWASP Java Encoder 来清理 HTML 输入：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, OWASP Java Encode’s `Encode.forHtml` method is used to sanitize
    HTML input by encoding special characters such as `<`, `>`, and `&`, thus preventing
    them from being interpreted as HTML tags or script elements by the browser.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，OWASP Java Encoder 的 `Encode.forHtml` 方法用于通过编码特殊字符（如 `<`、`>` 和 `&`）来清理
    HTML 输入，从而防止它们被浏览器解释为 HTML 标签或脚本元素。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we talked about injection attacks for both worlds, SQL and
    NoSQL, how they can be perpetrated, and the types of damage they can cause on
    an end system serving an API endpoint. We learned the different types of injection
    attacks, and we did two exercises, one with crAPI and another with a vulnerable
    Python application, each one showing how both types of databases can be hit by
    injecting commands or spurious/unpredicted data. We finished the chapter with
    a discussion about validating and sanitizing user input, which intends to either
    remove or at least reduce the success ratio of injection attacks. Code excerpts
    were also provided so that you could have a taste of how this works on real applications
    out there.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了 SQL 和 NoSQL 两种数据库的注入攻击，如何进行这些攻击，以及它们可能对提供 API 端点的最终系统造成的损害类型。我们了解了不同类型的注入攻击，并进行了一些练习，其中一个是使用
    crAPI，另一个是使用一个脆弱的 Python 应用程序，每个练习都展示了如何通过注入命令或虚假/无法预测的数据攻击这两种类型的数据库。我们在本章结束时讨论了验证和清理用户输入，这旨在去除或至少减少注入攻击的成功率。还提供了代码片段，以便你能了解这在现实应用中如何运作。
- en: In the next chapter, we’ll talk about error handling and exception testing.
    This content is as important as anything else since we’ll see that a badly treated
    exception or error can disclose valuable information about the API or the application
    behind it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论错误处理和异常测试。这一内容与其他任何内容一样重要，因为我们将看到，一个处理不当的异常或错误可能会泄露有关 API 或其背后应用的宝贵信息。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Equifax data breach: [https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know](https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Equifax 数据泄露：[https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know](https://consumer.ftc.gov/consumer-alerts/2019/07/equifax-data-breach-settlement-what-you-should-know)
- en: 'Firebase NoSQL vulnerability: [https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/](https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase NoSQL 漏洞： [https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/](https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/)
- en: '**Common Vulnerabilities and Exposures** (**CVE**) reporting the Apache Structs
    vulnerability: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见漏洞与暴露** (**CVE**) 报告的 Apache Structs 漏洞： [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11776)'
- en: 'Atlassian XXE vulnerability: [https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html](https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atlassian XXE 漏洞： [https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html](https://confluence.atlassian.com/security/cve-2019-13990-xxe-xml-external-entity-injection-vulnerability-in-jira-service-management-data-center-and-jira-service-management-server-1295385959.html)
- en: 'FortiSIEM *CVE-2023-36553* MITRE record: [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FortiSIEM *CVE-2023-36553* MITRE 记录：[https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-36553)
- en: 'FortiSIEM *CVE-2023-36553* **National Institute of Standards and Technology**
    (**NIST**) notice: [https://nvd.nist.gov/vuln/detail/CVE-2023-36553](https://nvd.nist.gov/vuln/detail/CVE-2023-36553)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FortiSIEM *CVE-2023-36553* **国家标准与技术研究院** (**NIST**) 通知：[https://nvd.nist.gov/vuln/detail/CVE-2023-36553](https://nvd.nist.gov/vuln/detail/CVE-2023-36553)
- en: Palo Alto OS command injection vulnerability – [https://security.paloaltonetworks.com/CVE-2023-6792](https://security.paloaltonetworks.com/CVE-2023-6792)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Palo Alto 操作系统命令注入漏洞 – [https://security.paloaltonetworks.com/CVE-2023-6792](https://security.paloaltonetworks.com/CVE-2023-6792)
- en: '*BleepingComputer* – *Hackers steal data of 2 million in SQL injection, XSS*
    *attacks*: [https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/](https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BleepingComputer* – *黑客通过 SQL 注入和 XSS 攻击窃取 200 万条数据*：[https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/](https://www.bleepingcomputer.com/news/security/hackers-steal-data-of-2-million-in-sql-injection-xss-attacks/)'
- en: '*PortSwigger* – *Car companies massively exposed to web* *vulnerabilities*:
    [https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities](https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PortSwigger* — *汽车公司大量暴露于网络* *漏洞*：[https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities](https://portswigger.net/daily-swig/car-companies-massively-exposed-to-web-vulnerabilities)'
- en: '*The Hacker News* – *New Hacker Group ‘GambleForce’ Targeting APAC Firms Using
    SQL Injection* *Attacks*: [https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html](https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The Hacker News* — *新的黑客团体‘GambleForce’通过SQL注入* *攻击瞄准亚太地区公司*：[https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html](https://thehackernews.com/2023/12/new-hacker-group-gambleforce-tageting.html)'
- en: '*PayloadsAllTheThings* (massive list of injection payloads): [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PayloadsAllTheThings*（大量注入载荷的列表）：[https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
- en: 'SQL injection payload list: [https://github.com/payloadbox/sql-injection-payload-list](https://github.com/payloadbox/sql-injection-payload-list)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL注入载荷列表：[https://github.com/payloadbox/sql-injection-payload-list](https://github.com/payloadbox/sql-injection-payload-list)
- en: 'All-in-one fuzzing wordlist for SQL injection: [https://github.com/PenTestical/sqli](https://github.com/PenTestical/sqli)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全能SQL注入模糊测试词表：[https://github.com/PenTestical/sqli](https://github.com/PenTestical/sqli)
- en: 'vAPI Python application: [https://github.com/michealkeines/Vulnerable-API](https://github.com/michealkeines/Vulnerable-API)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vAPI Python应用：[https://github.com/michealkeines/Vulnerable-API](https://github.com/michealkeines/Vulnerable-API)
- en: '*An Exploration of Finding Aid Technologies and NoSQL Databases* – scientific
    article with an introduction to NoSQL databases: [https://ojs.library.ubc.ca/index.php/seealso/article/view/186333](https://ojs.library.ubc.ca/index.php/seealso/article/view/186333)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*探索查找辅助技术和NoSQL数据库* — 一篇关于NoSQL数据库的科学文章：[https://ojs.library.ubc.ca/index.php/seealso/article/view/186333](https://ojs.library.ubc.ca/index.php/seealso/article/view/186333)'
- en: 'MongoDB query operators: [https://www.mongodb.com/docs/manual/reference/operator/query/](https://www.mongodb.com/docs/manual/reference/operator/query/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB查询操作符：[https://www.mongodb.com/docs/manual/reference/operator/query/](https://www.mongodb.com/docs/manual/reference/operator/query/)
- en: 'OWASP ESAPI, a library that provides secure methods for sanitizing user input:
    [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP ESAPI，一个提供安全清理用户输入方法的库：[https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)
- en: 'SQLMap, a tool to automate pentesting on relational databases: [https://sqlmap.org/](https://sqlmap.org/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLMap，一个自动化渗透测试关系型数据库的工具：[https://sqlmap.org/](https://sqlmap.org/)
- en: 'NoSQLMap – The SQLMap cousin, dedicated to automating pentesting and auditing
    on non-relational databases: [https://github.com/codingo/NoSQLMap](https://github.com/codingo/NoSQLMap)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQLMap – SQLMap的“表亲”，专门用于自动化渗透测试和非关系型数据库的审计：[https://github.com/codingo/NoSQLMap](https://github.com/codingo/NoSQLMap)
- en: 'Nikto, a useful utility to discover vulnerabilities in web servers, including
    outdated software and misconfigured interfaces: [https://github.com/sullo/nikto](https://github.com/sullo/nikto)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nikto，一个有用的工具，用于发现Web服务器中的漏洞，包括过时的软件和配置错误的接口：[https://github.com/sullo/nikto](https://github.com/sullo/nikto)
- en: '`validator.js` for JavaScript, which validates and sanitizes string inputs:
    [https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validator.js` for JavaScript，一个验证和清理字符串输入的工具：[https://www.npmjs.com/package/validator](https://www.npmjs.com/package/validator)'
- en: 'DOMPurify for JavaScript, a tool for sanitizing **Document Object Model** (**DOM**)
    HTML forms: [https://github.com/cure53/DOMPurify](https://github.com/cure53/DOMPurify)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOMPurify for JavaScript，一个用于清理**文档对象模型**（**DOM**）HTML表单的工具：[https://github.com/cure53/DOMPurify](https://github.com/cure53/DOMPurify)
- en: 'Apache Commons FileUpload Validator for Java, a library to sanitize files before
    considering them valid inputs: [https://commons.apache.org/proper/commons-fileupload/](https://commons.apache.org/proper/commons-fileupload/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Commons FileUpload Validator for Java，一个用于在将文件视为有效输入之前清理文件的库：[https://commons.apache.org/proper/commons-fileupload/](https://commons.apache.org/proper/commons-fileupload/)
- en: 'OWASP Java Encoder, a class that can be leveraged to encode HTML input and
    reduce chances of XSS attacks: [https://owasp.org/www-project-java-encoder/](https://owasp.org/www-project-java-encoder/)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP Java Encoder，一个可以用于对HTML输入进行编码并减少XSS攻击机会的类：[https://owasp.org/www-project-java-encoder/](https://owasp.org/www-project-java-encoder/)
- en: 'OWASP ESAPI: [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OWASP ESAPI: [https://owasp.org/www-project-enterprise-security-api/](https://owasp.org/www-project-enterprise-security-api/)'
