- en: Web Application Scanning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用扫描
- en: 'This chapter contains the following recipes for performing web application
    vulnerability scanning:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下用于执行Web应用程序漏洞扫描的食谱：
- en: Web application scanning with Nikto
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nikto进行Web应用扫描
- en: SSL/TLS scanning with SSLScan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSLScan进行SSL/TLS扫描
- en: SSL/TLS scanning with SSLyze
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSLyze进行SSL/TLS扫描
- en: GET method SQL injection with sqlmap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sqlmap进行GET方法SQL注入
- en: POST method SQL injection with sqlmap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sqlmap进行POST方法SQL注入
- en: Requesting a capture SQL injection with sqlmap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sqlmap捕获SQL注入
- en: Automating CSRF testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化CSRF测试
- en: Validating command-injection vulnerabilities with HTTP traffic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP流量验证命令注入漏洞
- en: Validating command-injection vulnerabilities with ICMP traffic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ICMP流量验证命令注入漏洞
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In recent years, we have seen increasing media coverage about major corporate
    and government data breaches, and as general awareness of security has increased,
    it has become more and more difficult to infiltrate an organization's networks
    by exploiting standard perimeter services. Publicly known vulnerabilities associated
    with these services are often quickly patched and leave little available attack
    surface. On the contrary, web applications often contain custom code that usually
    does not undergo the same amount of public scrutiny that a network service from
    an independent vendor does. Web applications are often the weakest point on an
    organization's perimeter, and as such, appropriate scanning and evaluation of
    these services is critical.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们看到越来越多的媒体报道有关大型公司和政府数据泄露的事件，随着安全意识的普及，利用标准外围服务渗透一个组织的网络变得越来越困难。与这些服务相关的已知公开漏洞通常会迅速得到修补，攻击面变得非常小。相反，Web应用程序通常包含自定义代码，这些代码通常不会像独立供应商的网络服务那样接受相同程度的公共审查。Web应用程序通常是组织外围的薄弱环节，因此，对这些服务进行适当的扫描和评估至关重要。
- en: Prior to addressing each of the listed recipes specifically, we will discuss
    some general information regarding sqlmap. The sqlmap is an integrated command-line
    tool in Kali Linux that drastically reduces the amount of effort required to exploit
    SQL injection vulnerabilities, by automating the entire process. The sqlmap works
    by submitting requests from a large list of known SQL injection queries. It has
    been highly optimized over the years to intelligently modify injection attempts
    based on the responses from previous queries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体讨论每个食谱之前，我们将讨论一些关于sqlmap的常见信息。sqlmap是Kali Linux中的一个集成命令行工具，通过自动化整个过程，大大减少了利用SQL注入漏洞所需的努力。sqlmap通过提交一个包含大量已知SQL注入查询的请求列表来工作。它经过多年的高度优化，能够根据之前查询的响应智能地修改注入尝试。
- en: Web application scanning with Nikto
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nikto进行Web应用扫描
- en: Nikto is a command-line tool in Kali Linux that can be used to evaluate a web
    application for known security issues. Nikto spiders through a target application
    and also makes numerous preconfigured requests, attempting to identify potentially
    dangerous scripts and files that exist on an application. In this recipe, we will
    discuss how to run Nikto against a web application and how to interpret the results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto是Kali Linux中的一个命令行工具，可以用于评估Web应用程序的已知安全问题。Nikto会通过目标应用程序进行爬取，并发送多个预配置的请求，尝试识别应用程序中可能存在的危险脚本和文件。在本部分中，我们将讨论如何使用Nikto对Web应用程序进行扫描，并如何解读扫描结果。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Nikto to perform web application analysis against a target, you will
    need to have a remote system that is running one or more web applications. In
    the examples provided, an instance of Metasploitable2 is used to perform this
    task. Metasploitable2 has several preinstalled vulnerable web applications running
    on the TCP port `80`. For more information on setting up Metasploitable2, refer
    to the *Installing Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Nikto对目标进行Web应用分析，你需要一个远程系统，该系统正在运行一个或多个Web应用程序。在提供的示例中，使用Metasploitable2实例来执行此任务。Metasploitable2在TCP端口`80`上运行多个预安装的易受攻击的Web应用程序。有关设置Metasploitable2的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*部分，*入门*。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s perform web application scanning using Nikto:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Nikto进行Web应用扫描：
- en: The syntax and usage complexity associated with running Nikto largely depends
    on the nature of the application that it is being run against. To see an overview
    of the usage and syntax of this tool, use the `nikto -help` command.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Nikto 的语法和使用复杂性主要取决于所扫描应用程序的性质。要查看该工具的用法和语法概览，可以使用 `nikto -help` 命令。
- en: 'In the first example provided, a scan is performed against `google.com`. The
    `-host` argument can be used to specify the hostname value of the target to be
    scanned. The `-port` option defines the port that the web service is running on.
    The `-ssl` option instructs Nikto to establish an SSL/TLS session with the target
    web server before scanning, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个提供的示例中，对 `google.com` 执行了扫描。`-host` 参数可以用来指定要扫描的目标的主机名值。`-port` 选项定义了 Web
    服务运行的端口。`-ssl` 选项指示 Nikto 在扫描之前与目标 Web 服务器建立 SSL/TLS 会话，如下所示：
- en: '![](../images/00043.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00043.jpeg)'
- en: Alternatively, the `-host` argument can also be used to define the IP address
    value for the target system to be scanned. The `-nossl` argument can be used to
    instruct Nikto to not use any transport-layer security.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，`-host` 参数也可以用来定义目标系统的 IP 地址值，以供扫描。`-nossl` 参数可以用来指示 Nikto 不使用任何传输层安全。
- en: 'The `-vhost` option can be used to specify the value of the host header in
    HTTP requests. This can be particularly helpful in any case where multiple virtual
    hostnames are hosted on a single IP address. Have a look at the following example:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-vhost` 选项可用于指定 HTTP 请求中主机头的值。这在多个虚拟主机名托管在同一 IP 地址上的情况下尤其有用。请看下面的示例：'
- en: '![](../images/00383.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00383.jpeg)'
- en: 'In the following example, a Nikto scan is performed against the web service
    hosted on the Metasploitable2 system. The `-port` argument is not used because
    the web service is hosted on the TCP port `80`, which is the default scan port
    for Nikto. Additionally, the `-nossl` argument is not used because by default,
    Nikto will not attempt an SSL/TLS connection over port `80`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的示例中，执行了针对 Metasploitable2 系统上托管的 Web 服务的 Nikto 扫描。由于该 Web 服务托管在 TCP 端口 `80`
    上，这是 Nikto 的默认扫描端口，因此没有使用 `-port` 参数。此外，由于默认情况下，Nikto 不会尝试通过端口 `80` 进行 SSL/TLS
    连接，因此也没有使用 `-nossl` 参数：
- en: '![](../images/00113.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00113.jpeg)'
- en: The results from the Nikto scan of the Metasploitable2 web service display some
    of the items that are frequently identified by Nikto. These items include risky
    HTTP methods, default installation files, exposed directory listings, sensitive
    information disclosure, and files to which access should be restricted. Awareness
    of these files can often be useful in looking to gain access to or identifying
    vulnerabilities on a server.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nikto 扫描 Metasploitable2 网络服务的结果显示了一些经常被 Nikto 识别的项目。这些项目包括危险的 HTTP 方法、默认安装文件、暴露的目录列表、敏感信息泄露以及应限制访问的文件。了解这些文件在尝试获取服务器访问权限或识别漏洞时常常非常有用。
- en: How it works…
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理……
- en: Nikto identifies potentially interesting files by referencing the `robots.txt`
    file, by spidering the surface of the application, and by cycling through a list
    of known files that contain sensitive information, vulnerable content, or should
    be access restricted because of the nature of the content and/or functionality
    presented by them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto 通过引用 `robots.txt` 文件、爬取应用程序的表面以及循环检查已知包含敏感信息、易受攻击的内容或因内容和/或功能性质而应限制访问的文件列表，来识别潜在的有趣文件。
- en: SSL/TLS scanning with SSLScan
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSLScan 进行 SSL/TLS 扫描
- en: '**SSLScan** is an integrated command-line tool in Kali Linux that can be used
    to evaluate the security of the SSL/TLS support of a remote web service. In this
    recipe, we will discuss how to run SSLScan against a web application and how to
    interpret and/or manipulate the output results.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLScan** 是 Kali Linux 中的一个集成命令行工具，可以用来评估远程网络服务的 SSL/TLS 支持的安全性。在本例中，我们将讨论如何对
    Web 应用程序运行 SSLScan，并且如何解读和/或处理输出结果。'
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use SSLScan to perform SSL/TLS analysis against a target, you will need to
    have a remote system that is running a web service with SSL or TLS enabled. In
    the examples provided, a combination of Google and an instance of Metasploitable2
    is used to perform this task. For more information on setting up Metasploitable2,
    refer to the *Installing Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SSLScan 对目标执行 SSL/TLS 分析，你需要拥有一台运行了启用 SSL 或 TLS 的 Web 服务的远程系统。在提供的示例中，我们使用
    Google 和 Metasploitable2 实例的组合来执行此任务。有关如何设置 Metasploitable2 的更多信息，请参阅 [第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 配方，*入门指南*。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following steps will guide you to perform SSL/TLS scanning with SSLScan:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你使用 SSLScan 执行 SSL/TLS 扫描：
- en: 'SSLScan can be an effective tool to perform streamlined analysis of the SSL/TLS
    configurations of a target web server. To perform a basic scan against a web server
    with a registered domain name, merely pass it the name of the domain as an argument,
    as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSLScan 可以作为一个有效的工具，用于对目标 Web 服务器的 SSL/TLS 配置进行简化分析。要对具有注册域名的 Web 服务器执行基本扫描，只需将域名作为参数传递，如下所示：
- en: '![](../images/00170.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00170.jpeg)'
- en: 'When executed, SSLScan will quickly cycle through connections to the target
    server and enumerate accepted ciphers, preferred cipher suites, and SSL certificate
    information. It is possible to use `grep` to restrict the output to necessary
    information. In the following example, the `grep` command is used to only view
    accepted ciphers:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行时，SSLScan 会快速循环通过与目标服务器的连接，并列出接受的加密算法、首选的加密套件和 SSL 证书信息。可以使用 `grep` 来限制输出为必要信息。在以下示例中，使用
    `grep` 命令仅查看接受的加密算法：
- en: '![](../images/00182.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00182.jpeg)'
- en: 'Multiple `grep` functions can be piped together to limit the output as much
    as desired. By using multiple piped `grep` requests, the output in the following
    example is limited to 256-bit ciphers that were accepted by the target service:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将多个 `grep` 函数通过管道连接在一起，以尽可能限制输出。通过使用多个管道 `grep` 请求，以下示例中的输出将限制为目标服务接受的 256
    位加密算法：
- en: '![](../images/00390.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00390.jpeg)'
- en: One unique function that SSLScan provides is the implementation of the STARTTLS
    request in SMTP. This allows SSLScan to easily and effectively test the transport-layer
    security of a mail service by using the `--starttls` argument and then specifying
    the target IP address and port.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSLScan 提供的一个独特功能是实现 SMTP 中的 STARTTLS 请求。这使得 SSLScan 可以通过使用 `--starttls` 参数，轻松有效地测试邮件服务的传输层安全性，并指定目标的
    IP 地址和端口。
- en: 'In the following example, we use SSLScan to determine whether the SMTP service
    integrated into Metasploitable2 supports any weak ciphers and checks vulnerability
    to heartbleed:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 SSLScan 来确定集成在 Metasploitable2 中的 SMTP 服务是否支持任何弱加密算法，并检查其是否存在 Heartbleed
    漏洞：
- en: '![](../images/00256.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00256.jpeg)'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: SSL/TLS sessions are generally established by negotiations between a client
    and server. These negotiations consider the configured cipher preferences of each
    and attempt to determine the most secure solution that is supported by both parties.
    SSLScan works by cycling through a list of known ciphers and key lengths and attempting
    to negotiate a session with the remote server using each configuration. This allows
    SSLScan to enumerate supported ciphers and keys.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SSL/TLS 会话通常通过客户端和服务器之间的协商来建立。这些协商会考虑到每方的加密算法偏好，并尝试确定双方都支持的最安全的解决方案。SSLScan
    通过循环遍历已知的加密算法和密钥长度列表，并使用每种配置尝试与远程服务器协商会话。这样，SSLScan 可以列出支持的加密算法和密钥。
- en: SSL/TLS scanning with SSLyze
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSLyze 进行 SSL/TLS 扫描
- en: '**SSLyze** is an integrated command-line tool in Kali Linux that can be used
    to evaluate the security of the SSL/TLS support of a remote web service. In this
    recipe, we will discuss how to run SSLyze against a web application and how to
    interpret and/or manipulate the output results.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSLyze** 是 Kali Linux 中的一个集成命令行工具，可以用来评估远程 Web 服务的 SSL/TLS 支持的安全性。在本配方中，我们将讨论如何运行
    SSLyze 对 Web 应用进行扫描，以及如何解释和/或处理输出结果。'
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use SSLyze to perform SSL/TLS analysis against a target, you will need to
    have a remote system that is running a web service with SSL or TLS enabled. In
    the examples provided, a combination of Google and an instance of Metasploitable2
    is used to perform this task. For more information on setting up Metasploitable2,
    refer to the *Installing Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SSLyze 对目标执行 SSL/TLS 分析，您需要有一个运行着启用 SSL 或 TLS 的 Web 服务的远程系统。在提供的示例中，结合了
    Google 和 Metasploitable2 实例来执行此任务。有关设置 Metasploitable2 的更多信息，请参考 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 配方，*入门*。
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s interpret and manipulate the output results using the SSLyze by running
    it against a web application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行 SSLyze 对 Web 应用程序进行测试，来解释和操作输出结果：
- en: 'Another tool that performs a thorough sweep and analyzes the SSL/TLS configurations
    of a target service is SSLyze. To perform the majority of the basic tests in SSLyze,
    arguments should include the target server and the `--regular` argument. This
    includes tests for SSLv2, SSLv3, TLSv1, renegotiation, resumption, certificate
    information, HTTP GET response status codes, and compression support, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个执行全面扫描并分析目标服务的 SSL/TLS 配置的工具是 SSLyze。要执行 SSLyze 中的大多数基本测试，参数应包括目标服务器和 `--regular`
    参数。这包括测试 SSLv2、SSLv3、TLSv1、重新协商、恢复、证书信息、HTTP GET 响应状态码以及压缩支持，如下所示：
- en: '![](../images/00393.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00393.jpeg)'
- en: 'Alternatively, a single version of TLS or SSL can be tested to enumerate the
    supported ciphers associated with that version. In the following example, SSLyze
    is used to enumerate the supported TLSv1.2 ciphers, and it then uses the `grep` command
    to extract only 256-bit ciphers:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，可以仅测试单个版本的 TLS 或 SSL 来列举与该版本相关的支持的密码套件。在以下示例中，使用 SSLyze 列举支持的 TLSv1.2 密码套件，然后使用
    `grep` 命令仅提取 256 位的密码套件：
- en: '![](../images/00331.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00331.jpeg)'
- en: 'One very helpful feature that SSLyze supports is testing for zlib compression.
    This compression, if enabled, is directly associated with an information leakage
    vulnerability known as **Compression Ratio Info-leak Made Easy** (**CRIME**).
    This test can be performed using the `--compression` argument, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSLyze 支持的一个非常有用的功能是测试 zlib 压缩。如果启用了该压缩，它与一种信息泄露漏洞直接相关，称为 **压缩比信息泄漏使得攻击变得简单**（**CRIME**）。可以通过以下
    `--compression` 参数执行此测试：
- en: '![](../images/00395.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00395.jpeg)'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: SSL/TLS sessions are generally established by negotiations between a client
    and server. These negotiations consider the configured cipher preferences of each
    and attempt to determine the most secure solution that is supported by both parties.
    SSLyze works by cycling through a list of known ciphers and key lengths and attempting
    to negotiate a session with the remote server using each configuration. This allows
    SSLyze to enumerate supported ciphers and keys.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SSL/TLS 会话通常通过客户端和服务器之间的协商建立。这些协商会考虑每个端的配置密码套件偏好，并尝试确定双方都支持的最安全的解决方案。SSLyze
    通过遍历已知的密码套件和密钥长度列表，并尝试使用每种配置与远程服务器协商会话，从而工作。这使得 SSLyze 能够列举支持的密码套件和密钥。
- en: GET method SQL injection with sqlmap
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 sqlmap 进行 GET 方法 SQL 注入测试
- en: Web applications frequently accept arguments within a supplied URL. These parameters
    are generally transmitted back to the web server in the HTTP GET method requests.
    If any of these parameter values are then included in a query statement to a backend
    database, an SQL injection vulnerability could exist. In this recipe, we will
    discuss how to use the `sqlmap` command to automate the testing of the HTTP GET
    method request parameters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序经常在提供的 URL 中接受参数。这些参数通常会通过 HTTP GET 方法请求返回给 Web 服务器。如果这些参数值随后被包含在对后端数据库的查询语句中，则可能存在
    SQL 注入漏洞。在此配方中，我们将讨论如何使用 `sqlmap` 命令来自动化测试 HTTP GET 方法请求参数。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use `sqlmap` to perform SQL injection against a target, you will need to
    have a remote system that is running one or more web applications that are vulnerable
    to SQL injection. In the examples provided, an instance of Metasploitable2 is
    used to perform this task. Metasploitable2 has several preinstalled vulnerable
    web applications running on the TCP port `80`. For more information on setting
    up Metasploitable2, refer to the *Installing Metasploitable2* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`sqlmap`执行针对目标的SQL注入，您需要有一个运行着一个或多个易受SQL注入攻击的Web应用程序的远程系统。在提供的示例中，使用了Metasploitable2实例来执行此任务。Metasploitable2上预装了多个易受攻击的Web应用程序，运行在TCP端口`80`上。有关设置Metasploitable2的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*配方，*入门指南*。
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s test the HTTP GET method request parameters using the `sqlmap` command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`sqlmap`命令测试HTTP GET方法的请求参数：
- en: To use `sqlmap` to test the HTTP GET method parameters, you will need to use
    the `-u` argument and the URL to be tested. This URL should include any GET method
    parameters.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`sqlmap`测试HTTP GET方法的参数，您需要使用`-u`参数和要测试的URL。该URL应包含任何GET方法的参数。
- en: 'Additionally, if the web content is only accessible to an established session,
    the cookie values that correspond to that session should be supplied with the
    `--cookie` argument, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果Web内容仅对已建立会话可访问，则应使用`--cookie`参数提供与该会话相对应的Cookie值，如下所示：
- en: '![](../images/00422.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00422.jpeg)'
- en: In the example provided, a risk value of `3` and a level value of `5` were used.
    These values define the riskiness and the thoroughness of the tests performed,
    respectively. For more detailed information on risk and level, refer the `sqlmap`
    man pages or the `help` file.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，使用了风险值`3`和级别值`5`。这些值分别定义了测试的风险性和彻底性。有关风险和级别的详细信息，请参考`sqlmap`的手册页或`help`文件。
- en: When running this test, `sqlmap` quickly identified the backend database as
    MySQL, and other tests were skipped. If no action is specified, `sqlmap` will
    merely determine whether any of the tested parameters are vulnerable, as shown
    in the previous example.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行此测试时，`sqlmap`快速识别出后台数据库为MySQL，并跳过了其他测试。如果没有指定操作，`sqlmap`仅会确定是否有任何测试的参数存在漏洞，如前面的示例所示。
- en: 'After a series of injection attempts, `sqlmap` has determined that the `id`
    parameter is vulnerable to multiple types of SQL injection. After confirming the
    vulnerability, action can be taken in `sqlmap` to start extracting information
    from the backend database, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过一系列的注入尝试后，`sqlmap`确定`id`参数存在多种SQL注入漏洞。在确认漏洞后，可以在`sqlmap`中采取措施，开始从后台数据库中提取信息，如下所示：
- en: '![](../images/00398.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00398.jpeg)'
- en: In the example provided, the `--dbs` argument is used to enumerate all available
    databases that are accessible via an SQL injection. Judging by name, it appears
    that only one of the listed databases directly corresponds to the DVWA application.
    We can then focus our subsequent action against that database directly.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，使用了`--dbs`参数列举了所有可通过SQL注入访问的数据库。从名称上看，似乎只有列出的一个数据库直接对应于DVWA应用程序。我们可以将后续操作集中在该数据库上。
- en: 'To extract the table names of all the tables in the DVWA database, we can use
    the `--tables` argument to instruct `sqlmap` to extract the table names and then
    use the `-D` argument to specify the database (`dvwa`) from which to extract the
    names, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取DVWA数据库中所有表的表名，我们可以使用`--tables`参数指示`sqlmap`提取表名，然后使用`-D`参数指定要提取名称的数据库（`dvwa`），如下所示：
- en: '![](../images/00498.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00498.jpeg)'
- en: By doing this, we can see that there are two tables present in the DVWA database.
    These tables include `guestbook` and `users`. It is often worth the effort to
    extract the contents from user tables in databases, as these often have usernames
    and associated password hashes in their contents.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以看到DVWA数据库中有两个表。这些表包括`guestbook`和`users`。从数据库中的用户表中提取内容通常是值得的，因为这些表通常包含用户名和相关的密码哈希值。
- en: 'To extract the contents from one of the identified tables, we can use the `--dump`
    argument and then the `-D` argument to specify the database, and the `-T` argument
    to specify the table from which to extract the contents, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取已识别表中的内容，我们可以使用`--dump`参数，然后使用`-D`参数指定数据库，使用`-T`参数指定要提取内容的表，如下所示：
- en: '![](../images/00246.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00246.jpeg)'
- en: 'The table and its contents are output as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表及其内容的输出如下：
- en: '![](../images/00564.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00564.jpeg)'
- en: Upon identifying that there are password hashes in the contents of the table,
    `sqlmap` will provide the option of using the integrated password cracker to perform
    a dictionary attack against the enumerated password hashes. This can be performed
    using a built-in word list, a custom word list, or a series of word lists.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在识别到表中的内容包含密码哈希时，`sqlmap`会提供使用集成密码破解器对枚举出的密码哈希执行字典攻击的选项。这可以通过使用内置的词汇表、自定义词汇表或一系列词汇表来完成。
- en: After performing the dictionary attack, we can see the contents of the table
    to include the user ID, the username, the location of the user's avatar image,
    the MD5 hash, the appended cleartext value of that hash, and then the first and
    last name.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行字典攻击后，我们可以看到表中的内容，包括用户ID、用户名、用户头像图片的位置、MD5哈希、该哈希的附加明文值以及用户的名字和姓氏。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Sqlmap works by submitting requests from a large list of known SQL injection
    queries. It has been highly optimized over the years to intelligently modify injection
    attempts based on the responses from previous queries. Performing SQL injection
    on HTTP GET parameters is as easy as modifying the content passed through the
    requested URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Sqlmap通过从大量已知的SQL注入查询列表中提交请求来工作。多年来，它已被高度优化，可以根据之前查询的响应智能地修改注入尝试。在HTTP GET参数上执行SQL注入就像修改通过请求URL传递的内容一样简单。
- en: POST method SQL injection with sqlmap
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sqlmap进行POST方法SQL注入
- en: Sqlmap is an integrated command-line tool in Kali Linux that drastically reduces
    the amount of effort required to manually exploit SQL injection vulnerabilities
    by automating the entire process. In this recipe, we will discuss how to use the `sqlmap` command
    to automate the testing of HTTP POST method request parameters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Sqlmap是Kali Linux中的一款集成命令行工具，能够显著减少手动利用SQL注入漏洞所需的工作量，通过自动化整个过程。在本食谱中，我们将讨论如何使用`sqlmap`命令自动化测试HTTP
    POST方法请求参数。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To use the `sqlmap` command to perform SQL injection against a target, you will
    need to have a remote system that is running one or more web applications that
    are vulnerable to SQL injection. In the examples provided, an instance of Metasploitable2
    is used to perform this task. Metasploitable2 has several preinstalled vulnerable
    web applications running on the TCP port `80`. For more information on setting
    up Metasploitable2, refer to the *Installing Metasploitable2* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`sqlmap`命令对目标执行SQL注入攻击，您需要有一个远程系统，该系统运行着一个或多个易受SQL注入攻击的Web应用程序。在提供的示例中，使用的是Metasploitable2实例来执行此任务。Metasploitable2上安装了多个易受攻击的Web应用程序，运行在TCP端口`80`上。有关如何设置Metasploitable2的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*食谱，*入门指南*。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'Let''s automate the testing of HTTP POST method request parameters using the
    `sqlmap` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`sqlmap`命令自动化测试HTTP POST方法请求参数：
- en: To perform an SQL injection attack on a service using the HTTP POST method,
    we will need to define the string of POST parameters using the `--data` argument.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对使用HTTP POST方法的服务执行SQL注入攻击，我们需要使用`--data`参数定义POST参数的字符串。
- en: 'The login application in Mutillidae offers a login interface that transmits
    a username and password over the POST method. This will be our target for our
    SQL injection attack. Have a look at the following example:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mutillidae中的登录应用程序提供了一个登录界面，通过POST方法传输用户名和密码。这将是我们SQL注入攻击的目标。请看以下示例：
- en: '![](../images/00405.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00405.jpeg)'
- en: 'The output of `sqlmap` has been truncated for space, following we can see the
    continuation of sqlmap''s output to include vulnerabilities found:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap`的输出已被截断以节省空间，接下来我们可以看到`sqlmap`输出的继续内容，其中包括发现的漏洞：'
- en: '![](../images/00627.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00627.jpeg)'
- en: If no action is specified, `sqlmap` will merely determine whether any of the
    tested parameters are vulnerable, as shown in the previous example. After a series
    of injection attempts, `sqlmap` has determined that the username POST parameter
    is vulnerable to both boolean-blind and error-based injection techniques.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有指定任何操作，`sqlmap`将仅仅确定所测试的参数是否存在漏洞，如前面的示例所示。经过一系列注入尝试，`sqlmap`已确定用户名POST参数容易受到布尔盲注和基于错误的注入技术的攻击。
- en: 'After confirming the vulnerability, actions can be taken in `sqlmap` to start
    extracting information from the backend database, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认漏洞后，可以在 `sqlmap` 中采取相应的操作，开始从后端数据库中提取信息，如下所示：
- en: '![](../images/00410.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00410.jpeg)'
- en: 'The output of the `sqlmap` command has been truncated. In the next screenshot,
    we see more of the output generated by the command, including available databases:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令的输出已被截断。在下一个截图中，我们看到了更多命令输出内容，包括可用的数据库：'
- en: '![](../images/00674.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00674.jpeg)'
- en: In the example provided, the `--dbs` argument is used to enumerate all available
    databases that are accessible via SQL injection. We can then focus our subsequent
    actions against a specific database directly.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，使用了 `--dbs` 参数来列出所有可通过 SQL 注入访问的数据库。然后，我们可以直接针对特定数据库集中执行后续操作。
- en: 'To extract the table names of all the tables in the `owasp10` database, we
    can use the `--tables` argument to instruct `sqlmap` to extract the table names
    and then use the `-D` argument to specify the database (`owasp10`) from which
    to extract the names, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取 `owasp10` 数据库中所有表格的表名，我们可以使用 `--tables` 参数来指示 `sqlmap` 提取表名，然后使用 `-D` 参数指定要从中提取表名的数据库（`owasp10`），如下所示：
- en: '![](../images/00414.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00414.jpeg)'
- en: 'The output of the `sqlmap` command has been truncated. In the following screenshot,
    we can see the tables associated with the `owasp10` database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令的输出已被截断。在以下截图中，我们可以看到与 `owasp10` 数据库相关的表格：'
- en: '![](../images/00061.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00061.jpeg)'
- en: By doing this, we can see that there are six tables present in the `owasp10`
    database. These tables are `accounts`, `blog_table`, `captured_data`, `credit_cards`,
    `hitlog`, and `pen_test_tools`. The obvious table name that will probably catch
    the eye of most of us is the `credit_cards` table.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以看到 `owasp10` 数据库中存在六个表格。这些表格分别是 `accounts`、`blog_table`、`captured_data`、`credit_cards`、`hitlog`
    和 `pen_test_tools`。最引人注目的表格名可能是 `credit_cards`。
- en: 'To extract the contents from one of the identified tables, we can use the `--dump`
    argument and then the `-D` argument to specify the database, and the `-T` argument
    to specify the table from which to extract the contents, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取已识别表格中的内容，我们可以使用 `--dump` 参数，然后使用 `-D` 参数指定数据库，使用 `-T` 参数指定要提取内容的表格，如下所示：
- en: '![](../images/00416.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00416.jpeg)'
- en: 'The `sqlmap` command''s output has been truncated. In the next screenshot,
    we see the contents of the `credit_cards` table in the `owasp10` database:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令的输出已被截断。在下一个截图中，我们看到 `owasp10` 数据库中 `credit_cards` 表格的内容：'
- en: '![](../images/00572.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00572.jpeg)'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理……
- en: "The `sqlmap` command works by submitting requests from a large list of known\
    \ SQL injection queries. It has been highly optimized over the years to intelligently\
    \ modify injection attempts based on the responses from previous queries. Performing\
    \ SQL injection on HTTP POST method parameters is done by manipulating the data\
    \ that is appended to the end of a POST \Lmethod request."
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令通过提交来自已知 SQL 注入查询的大量请求来工作。它经过多年优化，能够根据先前查询的响应智能地修改注入尝试。在 HTTP POST
    方法的参数上执行 SQL 注入是通过操控附加到 POST 方法请求末尾的数据来实现的。'
- en: Requesting a capture SQL injection with sqlmap
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求使用 sqlmap 捕获 SQL 注入
- en: To simplify the process of using the `sqlmap` command, it is possible to use
    a captured request from Burp Suite and execute `sqlmap` with all the parameters
    and configurations defined within. In this recipe, we will discuss how to use
    `sqlmap` to test the parameters associated with a provided request capture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用 `sqlmap` 命令的过程，可以使用来自 Burp Suite 的捕获请求，并执行带有所有已定义参数和配置的 `sqlmap`。在本指南中，我们将讨论如何使用
    `sqlmap` 来测试与提供的请求捕获相关的参数。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备
- en: To use `sqlmap` to perform SQL injection against a target, you will need to
    have a remote system that is running one or more web applications that are vulnerable
    to SQL injection. In the examples provided, an instance of Metasploitable2 is
    used to perform this task. Metasploitable2 has several preinstalled vulnerable
    web applications running on the TCP port `80`. For more information on setting
    up Metasploitable2, refer to the *Installing Metasploitable2* recipe in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `sqlmap` 执行 SQL 注入攻击，你需要一个远程系统，该系统运行着一个或多个易受 SQL 注入攻击的 Web 应用程序。在所提供的示例中，使用了
    Metasploitable2 实例来执行此任务。Metasploitable2 在 TCP 端口 `80` 上运行着多个预安装的易受攻击的 Web 应用程序。有关设置
    Metasploitable2 的更多信息，请参考 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)
    中的 *安装 Metasploitable2* 章节，*入门*。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The following steps will guide you to capture SQL injection with the help of
    `sqlmap` command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你如何借助 `sqlmap` 命令捕获 SQL 注入攻击：
- en: 'To use a request capture with `sqlmap`, it must first be saved in text format.
    To do this, right-click on the request content in Burp Suite and then select Copy
    to file. Once it''s saved, you can verify the contents of the file by browsing
    to the directory and using the `cat` command, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `sqlmap` 进行请求捕获，首先必须将请求保存为文本格式。为此，在 Burp Suite 中右击请求内容，然后选择“复制到文件”。保存后，你可以通过浏览目录并使用
    `cat` 命令来验证文件内容，如下所示：
- en: '![](../images/00418.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00418.jpeg)'
- en: 'To use the request capture, use `sqlmap` with the `-r` argument and the value
    of the absolute path of the file. Using this method often drastically reduces
    the amount of information that needs to be provided in the `sqlmap` command, as
    much of the information that would otherwise be provided is included in the request.
    Have a look at the following example:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用请求捕获，请使用带有 `-r` 参数和文件绝对路径值的 `sqlmap`。这种方法通常大大减少了需要在 `sqlmap` 命令中提供的信息量，因为大部分原本需要提供的信息已包含在请求中。请查看以下示例：
- en: '![](../images/00204.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00204.jpeg)'
- en: 'In the example provided, no cookie values need to be passed to `sqlmap` because
    the cookie values are already identified in the captured request. When `sqlmap`
    is launched, the cookie values in the capture will be automatically used in all
    requests, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所提供的示例中，不需要将 cookie 值传递给 `sqlmap`，因为 cookie 值已经在捕获的请求中识别出来。当启动 `sqlmap` 时，捕获中的
    cookie 值将自动在所有请求中使用，如下所示：
- en: '![](../images/00337.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00337.jpeg)'
- en: The `sqlmap` command is able to test all GET method parameters identified in
    the request capture. Here, we can see that the `id` parameter is vulnerable to
    several SQL injection techniques.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令能够测试请求捕获中识别到的所有 GET 方法参数。在这里，我们可以看到 `id` 参数容易受到多种 SQL 注入技术的攻击。'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `sqlmap` command is able to accept a captured request by parsing through
    the contents of that request and identifying any testable parameters for evaluation.
    This effectively allows `sqlmap` to be launched without expending the additional
    effort of transcribing all of the parameters necessary to perform the attack.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 命令能够通过解析请求的内容并识别任何可测试的参数来接受捕获的请求。这使得可以在不需要额外努力转录执行攻击所需的所有参数的情况下启动
    `sqlmap`。'
- en: Automating CSRF testing
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化 CSRF 测试
- en: '**Cross-site request forgery** (**CSRF**) is one of the most commonly misunderstood
    web application vulnerabilities. Nonetheless, failure to properly identify such
    vulnerabilities can pose a serious risk to a web application and its users. In
    this recipe, we will discuss how to test for CSRF vulnerabilities in both GET
    and POST method parameters.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）是最常被误解的 Web 应用程序漏洞之一。尽管如此，未能正确识别此类漏洞可能对 Web 应用程序及其用户构成严重风险。在本教程中，我们将讨论如何测试
    GET 和 POST 方法参数中的 CSRF 漏洞。'
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To perform CSRF testing against a target, you will need to have a remote system
    that is running one or more web applications that are vulnerable to CSRF. In the
    examples provided, an instance of Metasploitable2 is used to perform this task.
    Metasploitable2 has several preinstalled vulnerable web applications running on
    the TCP port `80`. For more information on setting up Metasploitable2, refer to
    the *Installing Metasploitable2* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要对目标进行 CSRF 测试，您需要有一个远程系统，运行一个或多个易受 CSRF 攻击的 Web 应用。在提供的示例中，使用了 Metasploitable2
    实例来执行这项任务。Metasploitable2 上预装了多个易受攻击的 Web 应用，运行在 TCP 端口 `80` 上。有关如何设置 Metasploitable2
    的更多信息，请参考 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的 *安装
    Metasploitable2* 配方，*入门* 部分。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps we will be automating CSRF testing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤中，我们将自动化进行 CSRF 测试：
- en: 'CSRF is a vulnerability that can be present in both GET and POST method transactions.
    DVWA offers a good example of a GET method CSRF vulnerability. The application
    allows the users to update their password by submitting the new value twice via
    the GET method parameters, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSRF 是一种可以在 GET 和 POST 方法的交易中都存在的漏洞。DVWA 提供了一个很好的 GET 方法 CSRF 漏洞的示例。该应用允许用户通过
    GET 方法参数提交新密码两次来更新密码，如下所示：
- en: '![](../images/00275.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00275.jpeg)'
- en: Because of a lack of CSRF controls, it is easy to exploit this vulnerability.
    If a user of the web application can be tricked into accessing a URL with preconfigured
    values for the `password_new` and `password_conf` parameters, an attacker could
    force the victim to change the password to one of the attacker's choice.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于缺乏 CSRF 控制，利用这个漏洞非常容易。如果能够让 Web 应用的用户被诱导访问一个 URL，其中预设了 `password_new` 和 `password_conf`
    参数的值，那么攻击者就能强制受害者将密码更改为攻击者指定的密码。
- en: The following URL is an example of this exploit. If this link were followed
    by the victim, their password would be changed to `compromised`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 URL 就是这个漏洞利用的一个示例。如果受害者点击此链接，他们的密码将被更改为 `compromised`。
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, it is rarely this simple to exploit a CSRF vulnerability. This is
    because most developers are at least security-conscious enough to not perform
    secure transactions using GET method parameters. A good example of an application
    that is vulnerable to the POST method CSRF is the blog functionality of the Mutillidae
    application, which is shown as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，利用 CSRF 漏洞通常并不像想象中那样简单。这是因为大多数开发者至少会足够关注安全，不会使用 GET 方法参数进行安全交易。一个很好的例子是 Mutillidae
    应用程序中的博客功能，它易受 POST 方法 CSRF 攻击，具体如下所示：
- en: '![](../images/00161.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00161.jpeg)'
- en: 'In the previous request, we can see that the contents of the blog entry submitted
    by an authenticated user are sent via the `blog_entry` POST method parameter.
    To exploit the lack of CSRF controls, an attacker would need to craft a malicious
    web page that would cause the victim to submit the desired parameters. The following
    is an example of a POST method CSRF attack:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的请求中，我们可以看到已认证用户提交的博客条目内容是通过 `blog_entry` POST 方法参数发送的。为了利用缺乏 CSRF 控制的漏洞，攻击者需要制作一个恶意网页，导致受害者提交所需的参数。以下是一个
    POST 方法 CSRF 攻击的示例：
- en: '![](../images/00424.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00424.jpeg)'
- en: 'The malicious web page uses an HTML form that returns to the vulnerable server
    with several hidden input fields that correspond to the same inputs required for
    the submission of a blog entry request in the Mutillidae application. Additionally,
    JavaScript is used to submit the form. All of this will happen without any action
    performed on the part of the victim. Consider the following example:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意网页使用一个 HTML 表单，返回到易受攻击的服务器，表单中包含多个隐藏的输入字段，这些字段与 Mutillidae 应用程序中提交博客条目请求所需的输入字段相对应。此外，还使用了
    JavaScript 来提交表单。所有这些操作将在受害者不进行任何操作的情况下发生。请看以下示例：
- en: '![](../images/00377.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00377.jpeg)'
- en: 'To deploy this malicious web content, it should be moved to the web root directory.
    In Kali Linux, the default Apache web root directory is `/var/www/`. Also, ensure
    that the Apache2 service is running. Have a look at the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署这些恶意网页内容，应将其移动到 Web 根目录。在 Kali Linux 中，默认的 Apache Web 根目录是 `/var/www/`。此外，确保
    Apache2 服务正在运行。请查看以下截图：
- en: '![](../images/00370.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00370.jpeg)'
- en: When an authenticated victim browses to the malicious page, the victim is automatically
    redirected to the Mutillidae blog application and the blog post HACKED is submitted.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个已验证的受害者访问恶意页面时，受害者会被自动重定向到 Mutillidae 博客应用程序，并提交博客文章《HACKED》。
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: CSRF occurs because the request is ultimately made by the victim user's session.
    It is an attack that exploits the trust that a victim's browser has established
    with a remote web service. In the case of the GET method CSRF, a victim is enticed
    to access a URL that contains the parameters that define the terms of the malicious
    transaction. In the case of the POST method CSRF, the victim is enticed to browse
    to a web page that defines the parameters that are then forwarded on to the vulnerable
    server, by the victim's browser, to perform the malicious transaction. In either
    case, the transaction is performed because the request originates from the browser
    of the victim, who has already established a trusted session with the vulnerable
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF（跨站请求伪造）发生的原因是请求最终是由受害者用户的会话发起的。这是一种利用受害者的浏览器与远程 web 服务之间建立的信任的攻击。在 GET
    方法的 CSRF 攻击中，受害者被诱使访问一个 URL，该 URL 包含定义恶意交易条款的参数。在 POST 方法的 CSRF 攻击中，受害者被诱使浏览到一个
    web 页面，该页面定义的参数随后会通过受害者的浏览器转发到易受攻击的服务器，执行恶意交易。无论哪种情况，交易都会执行，因为请求来自受害者的浏览器，而受害者的浏览器已经与易受攻击的应用程序建立了可信会话。
- en: Validating command-injection vulnerabilities with HTTP traffic
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 流量验证命令注入漏洞
- en: Command injection is probably the most dangerous of all known web application
    attack vectors. Most attackers seek to exploit vulnerabilities in the hope that
    they will ultimately find a way to execute arbitrary commands on the underlying
    operating system. Command-execution vulnerabilities provide that capability without
    any additional steps. In this recipe, we will discuss how to use web server logs
    or custom web service scripts to confirm command-execution vulnerabilities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入可能是所有已知 web 应用程序攻击向量中最危险的。大多数攻击者试图利用漏洞，希望最终能找到在底层操作系统上执行任意命令的方法。命令执行漏洞提供了这种能力，无需额外的步骤。在本配方中，我们将讨论如何使用
    web 服务器日志或自定义 web 服务脚本来确认命令执行漏洞。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To perform command-injection testing against a target using HTTP request confirmation,
    you will need to have a remote system that is running one or more web applications
    that are vulnerable to command injection. In the examples provided, an instance
    of Metasploitable2 is used to perform this task. Metasploitable2 has several preinstalled
    vulnerable web applications running on the TCP port `80`. For more information
    on setting up Metasploitable2, refer to the *Installing Metasploitable2* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*. Additionally, this section will require a script to be written to the
    filesystem using a text editor such as Vim or GNU nano. For more information on
    writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe in
    [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 HTTP 请求确认对目标进行命令注入测试，你需要有一个远程系统，该系统运行着一个或多个易受命令注入攻击的 web 应用程序。在提供的示例中，使用了
    Metasploitable2 实例来执行此任务。Metasploitable2 上有多个预安装的易受攻击的 web 应用程序，运行在 TCP 端口 `80`
    上。有关设置 Metasploitable2 的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 章节，*入门*。此外，本节还需要编写一个脚本，将其写入文件系统，可以使用像 Vim 或 GNU nano 这样的文本编辑器。有关编写脚本的更多信息，请参阅
    [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的 *使用文本编辑器（Vim 和
    GNU nano）* 章节，*入门*。
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s validate command-injection vulnerabilities with HTTP traffic:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 HTTP 流量验证命令注入漏洞：
- en: It is possible to validate a command injection vulnerability in a web application
    by executing commands that will force the backend system to interact with a web
    server that you own.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过执行一些命令来验证 web 应用程序中的命令注入漏洞，这些命令将迫使后端系统与你拥有的 web 服务器进行交互。
- en: 'The logs can be easily examined for evidence that the vulnerable server has
    interacted with it. Alternatively, a custom script can be written that will generate
    an ad hoc web service that can listen for external connections and print the requests
    received. The following is an example of a Python script that will do just that:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以轻松检查日志，寻找易受攻击的服务器与其交互的证据。或者，可以编写一个自定义脚本，生成一个临时的 web 服务，监听外部连接并打印收到的请求。以下是一个
    Python 脚本示例，它可以执行此操作：
- en: '[PRE1]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the script has been executed, we need to force the target server to interact
    with the listening service to confirm the command-injection vulnerability. The
    DVWA application has a `ping` utility that can be used to ping a provided IP address.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本执行完毕，我们需要强制目标服务器与监听服务进行交互，以确认命令注入漏洞。DVWA 应用程序有一个 `ping` 工具，可以用来 ping 提供的
    IP 地址。
- en: "The user input is directly passed to a system call and can be modified to execute\
    \ arbitrary commands in the underlying operating system. We can append multiple\
    \ commands using a semicolon followed by \Leach subsequent command, as shown in\
    \ the following screenshot:"
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入会直接传递给系统调用，并且可以被修改以执行底层操作系统中的任意命令。我们可以使用分号将多个命令连接起来，并跟随每个后续命令，如下截图所示：
- en: '![](../images/00604.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00604.jpeg)'
- en: 'In the example provided, input was given to ping `127.0.0.1` and perform a
    `wget` request on `http://172.16.69.133:8000`. The `wget` request corresponds
    to the ad hoc listening Python service. After submitting the input, we can verify
    that the command was executed by referring to the output of the script, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，输入被用来 ping `127.0.0.1` 并执行对 `http://172.16.69.133:8000` 的 `wget` 请求。`wget`
    请求对应的是临时监听的 Python 服务。提交输入后，我们可以通过查看脚本的输出，验证命令是否已经执行，如下所示：
- en: '![](../images/00432.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00432.jpeg)'
- en: Here, we can see that a connection was received from the target web server and
    that the user agent used to access the web service was `wget`. The `curl` command
    is another alternative that could be used if `wget` is not installed.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到从目标 Web 服务器接收到了连接，并且用于访问 Web 服务的用户代理是 `wget`。如果 `wget` 未安装，`curl`
    命令是另一种可以使用的替代方法。
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This Python script works to confirm command-injection vulnerabilities because
    it proves that commands can be executed from the target server via an injected
    payload from a different system. It is highly unlikely that a similar request
    would be performed at the same time that the payload was injected to the server.
    However, even if there is a concern that the payload was not the true source of
    the detected traffic, multiple attempts could easily be made to eliminate the
    concern of false positives.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Python 脚本用于确认命令注入漏洞，因为它证明了命令可以通过来自不同系统的注入有效负载从目标服务器执行。几乎不可能在注入有效负载到服务器的同时执行类似的请求。然而，即使有担心有效负载不是检测到的流量的真正来源，也可以通过多次尝试轻松消除误报的疑虑。
- en: Validating command-injection vulnerabilities with ICMP traffic
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ICMP 流量验证命令注入漏洞
- en: "Command injection is likely the most dangerous of all known web application\
    \ attack vectors. Most attackers seek to exploit vulnerabilities in the hope that\
    \ they will ultimately find a way to execute arbitrary commands on the underlying\
    \ operating system. Command-execution vulnerabilities provide that capability\
    \ without any additional steps. In this recipe, we will discuss how to write a\
    \ custom script for validating remote code-execution vulnerabilities \Lwith ICMP\
    \ traffic."
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入可能是所有已知的 web 应用攻击向量中最危险的。大多数攻击者都试图利用漏洞，期望最终找到一种在底层操作系统上执行任意命令的方法。命令执行漏洞提供了这一能力，而无需任何额外的步骤。在这个教程中，我们将讨论如何编写自定义脚本来验证使用
    ICMP 流量的远程代码执行漏洞。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To perform command-injection testing against a target using ICMP echo request
    confirmation, you will need to have a remote system that is running one or more
    web applications that are vulnerable to command injection. In the examples provided,
    an instance of Metasploitable2 is used to perform this task. Metasploitable2 has
    several preinstalled vulnerable web applications running on the TCP port `80`.
    For more information on setting up Metasploitable2, refer to the *Installing Metasploitable2*
    recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*. Additionally, this section will require a script to be written to the
    filesystem using a text editor such as Vim or GNU nano. For more information on
    writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe in
    [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用ICMP回显请求确认对目标进行命令注入测试，您需要有一个远程系统，该系统运行着一个或多个易受命令注入漏洞的Web应用程序。在提供的示例中，使用了Metasploitable2实例来执行此任务。Metasploitable2预安装了多个易受攻击的Web应用程序，这些应用程序运行在TCP端口`80`上。有关设置Metasploitable2的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*配方，*入门*部分。此外，本节将需要使用文本编辑器（如Vim或GNU
    nano）编写脚本到文件系统中。有关编写脚本的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*使用文本编辑器（Vim和GNU
    nano）*配方，*入门*部分。
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps we will be creating a custom script for validating remote
    code-execution vulnerabilities with ICMP traffic:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将创建一个自定义脚本，通过ICMP流量验证远程代码执行漏洞：
- en: 'It is possible to validate a command-injection vulnerability in a web application
    by executing commands that will force the backend system to send ICMP traffic
    to a listening service. The received ICMP echo requests can be used to identify
    vulnerable systems. The following is an example of a Python script that uses the
    Scapy library to do just that:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行将强制后端系统向监听服务发送ICMP流量的命令，可以验证Web应用程序中的命令注入漏洞。接收到的ICMP回显请求可用于识别易受攻击的系统。以下是一个使用Scapy库的Python脚本示例，用于执行此操作：
- en: '[PRE2]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the ICMP listener has been executed, we need to attempt to launch an ICMP
    echo request from the vulnerable server to our listening service. This can be
    done by injecting a `ping` command into the user input that is vulnerable to command
    injection.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行完ICMP监听器后，我们需要尝试从易受攻击的服务器向我们的监听服务发起ICMP回显请求。这可以通过向易受攻击的用户输入中注入`ping`命令来完成。
- en: 'In Mutillidae, there is a vulnerable function that performs DNS enumeration
    by passing user input to a direct system call. A separate ping request can be
    appended to the user input by using a semicolon, as shown in the following screenshot:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mutillidae中，有一个易受攻击的函数，通过将用户输入传递到直接的系统调用来执行DNS枚举。可以通过使用分号将单独的ping请求附加到用户输入中，如下图所示：
- en: '![](../images/00516.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00516.jpeg)'
- en: 'Assuming that the server is vulnerable to command injection, the Python listener
    should indicate that the ICMP echo request was received and that the target server
    is likely to be vulnerable, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设服务器易受命令注入攻击，Python监听器应该显示ICMP回显请求已被接收，并且目标服务器可能存在漏洞，具体如下：
- en: '![](../images/00544.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00544.jpeg)'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: "This Python script works to confirm command-injection vulnerabilities because\
    \ it proves that commands can be executed from the target server via an injected\
    \ payload from a different system. It is highly unlikely that a similar request\
    \ would be performed at the same time that the payload was injected to the server.\
    \ However, even if there is a concern that the payload was not the true source\
    \ of the detected traffic, multiple attempts could easily be performed \Lto eliminate\
    \ the concern of false positives."
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python脚本能够确认命令注入漏洞，因为它证明了通过来自不同系统的注入有效载荷，可以从目标服务器执行命令。虽然在注入有效载荷的同时执行类似请求的可能性极低，但即使担心检测到的流量不是由有效载荷引起的，通过多次尝试也可以轻松消除假阳性问题。
