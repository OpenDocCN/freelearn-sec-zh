- en: Chapter 7. Automated Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章 自动化测试
- en: In this chapter, we'll be making our life a bit easier when looking at applications
    through an attack proxy. Extending functionality through open-source plugins can
    save precious time on short-term engagements and make sure we don't miss any low-hanging
    fruit. There are always areas where we can automate something and make the whole
    penetration testing process a bit more efficient. Luckily, we don't have to write
    everything from scratch, as the hacking community has a solution for almost any
    automation problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过攻击代理使我们的工作变得更加轻松。通过开源插件扩展功能可以节省短期项目中的宝贵时间，并确保我们不会错过任何轻松的漏洞。总有一些领域可以自动化，从而使整个渗透测试过程更加高效。幸运的是，我们不需要从头开始编写一切，因为黑客社区几乎为任何自动化问题都提供了解决方案。
- en: In previous chapters, we've discussed out-of-band exploitation and here we will
    go through using Burp's cloud server to automate this type of vulnerability discovery.
    We will also look at deploying our own instance of the Burp Collaborator server
    in the cloud or on premises for greater control during an assessment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了带外漏洞利用，在这里我们将通过使用 Burp 的云服务器来自动化这种类型的漏洞发现。我们还将讨论如何在云端或本地部署我们自己的 Burp
    Collaborator 服务器实例，以便在评估过程中获得更大的控制权。
- en: 'This chapter will expose you to valuable tools and by the end, you should be
    able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍一些有价值的工具，最终你应该能够：
- en: Extend the attack proxy to automate tedious tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展攻击代理以自动化繁琐的任务
- en: Configure Burp to use the public Collaborator instance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Burp 使用公共 Collaborator 实例
- en: Deploy our own Collaborator instance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署我们自己的 Collaborator 实例
- en: Extending Burp
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Burp
- en: Burp Suite is a fantastic attack proxy and it comes with some great features
    straight out of the box. As mentioned in previous chapters, Intruder is a flexible
    brute-forcing tool, Repeater allows us to inspect and fine-tune attacks, and Decoder
    streamlines data manipulation. What makes Burp great is the ability to expand
    functionality through community-developed and community-maintained extensions.
    PortSwigger, the creator of Burp Suite, also maintains an online directory for
    extensions called the **BApp Store**. The BApp Store can be accessed via the Extender
    tab in Burp Suite.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 是一个出色的攻击代理，它开箱即用就提供了一些很棒的功能。如前几章所述，Intruder 是一个灵活的暴力破解工具，Repeater
    允许我们检查和微调攻击，Decoder 简化了数据操作。Burp 的出色之处在于它可以通过社区开发和维护的扩展来扩展功能。Burp Suite 的创建者 PortSwigger
    还维护了一个在线扩展目录，叫做 **BApp 商店**。BApp 商店可以通过 Burp Suite 中的 Extender 标签访问。
- en: '![Extending Burp](graphics/B09238_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 Burp](graphics/B09238_07_01.jpg)'
- en: 'Figure 7.1: The BApp Store'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：BApp 商店
- en: With extensions, we can passively check for outdated libraries, custom build
    sqlmap command-lines, and quickly check for authentication or authorization vulnerabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展，我们可以被动地检查过时的库，定制构建 sqlmap 命令行，并快速检查身份验证或授权漏洞。
- en: Burp extensions are typically written in either Java, Python, or Ruby. Since
    Burp is a Java application, Java extensions will work straight out of the box.
    For extensions written in Python or Ruby, we need to point Burp Suite to both
    **Jython** and **JRuby** interfaces. Python and Ruby are very powerful languages
    and some might argue simpler to develop than Java. The BApp Store is mostly extensions
    written in Java and Jython, but the occasional JRuby requirement will come up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Burp 扩展通常使用 Java、Python 或 Ruby 编写。由于 Burp 是一个 Java 应用程序，Java 扩展可以直接开箱即用。对于用
    Python 或 Ruby 编写的扩展，我们需要让 Burp Suite 指向 **Jython** 和 **JRuby** 接口。Python 和 Ruby
    是非常强大的语言，有些人可能认为它们比 Java 更简单易用。BApp 商店主要是用 Java 和 Jython 编写的扩展，但偶尔也会有 JRuby 的需求。
- en: '**Additional Scanner Checks**, for example, is an extension written in Python.
    As the name implies, this extension will augment the Burp Scanner module, with
    a few extra checks. Before we can install it, however, Burp will prompt us to
    download Jython. This means that the Extender Python environment was not configured
    properly yet, which is common among new installations of Burp Suite.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加扫描器检查**，例如，是一个用 Python 编写的扩展。顾名思义，该扩展将增强 Burp 扫描器模块，增加一些额外的检查。然而，在我们安装它之前，Burp
    会提示我们下载 Jython。这意味着 Extender 的 Python 环境尚未正确配置，这在新的 Burp Suite 安装中是很常见的。'
- en: We can find Additional Scanner Checks in the BApp Store with the **Install**
    button greyed out. The **BApp Store** page presents us with an option to go and
    download Jython.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 BApp 商店找到附加扫描器检查，且 **安装** 按钮会被灰显。**BApp 商店** 页面向我们提供了下载 Jython 的选项。
- en: '![Extending Burp](graphics/B09238_07_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 Burp](graphics/B09238_07_02.jpg)'
- en: 'Figure 7.2: Burp Suite BApp Store page for Additional Scanner Checks'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：Burp Suite BApp 商店页面，提供附加扫描器检查
- en: The process to setup Burp for Jython and JRuby is straightforward. Both library
    implementations come in standalone JAR files, which can be loaded straight into Burp.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Burp 以支持 Jython 和 JRuby 的过程非常简单。两种库实现均以独立 JAR 文件的形式提供，可以直接加载到 Burp 中。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Jython is available on [http://www.jython.org/downloads.html](http://www.jython.org/downloads.html)
    as a standalone JAR file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Jython 可通过 [http://www.jython.org/downloads.html](http://www.jython.org/downloads.html)
    作为独立 JAR 文件下载。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JRuby is available on [http://jruby.org/download](http://jruby.org/download)
    as a complete JAR file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JRuby 可通过 [http://jruby.org/download](http://jruby.org/download) 作为完整的 JAR 文件下载。
- en: 'In the **Options** tab of the Extender module, we can specify the freshly downloaded
    standalone Jython and JRuby JAR files:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Extender 模块的 **选项** 标签中，我们可以指定刚刚下载的独立 Jython 和 JRuby JAR 文件：
- en: '![Extending Burp](graphics/B09238_07_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 Burp](graphics/B09238_07_03.jpg)'
- en: 'Figure 7.3: Configuring Jython and JRuby environments'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：配置 Jython 和 JRuby 环境
- en: 'With the environment properly configured, the BApp Store should now let us
    install the Additional Scanner Checks extension. Hitting the **Refresh list**
    button should pick up the configuration changes and enable the **Install** button:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 环境配置正确后，BApp 商店现在应该允许我们安装附加扫描器检查扩展。点击 **刷新列表** 按钮应能更新配置更改并启用 **安装** 按钮：
- en: '![Extending Burp](graphics/B09238_07_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 Burp](graphics/B09238_07_04.jpg)'
- en: 'Figure 7.4: The Install button is enabled after configuring environment prerequisites'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：配置环境前提条件后启用安装按钮
- en: Authentication and authorization abuse
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证和授权滥用
- en: 'One of the most tedious application security tests is an authentication or
    authorization check. The basic steps to verify for this type of vulnerability
    go something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最繁琐的应用安全测试之一是身份验证或授权检查。验证此类漏洞的基本步骤大致如下：
- en: Authenticate with a known-good account
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个已知的有效账户进行身份验证
- en: Capture the session ID
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获会话 ID
- en: Crawl the application with this session ID
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该会话 ID 爬取应用程序
- en: Open a new application session
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的应用程序会话
- en: Authenticate with a separate known-good account
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个单独的已知有效账户进行身份验证
- en: Capture the session ID
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获会话 ID
- en: 'Replay the crawl with the new session ID:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的会话 ID 重播爬虫：
- en: Check for vertical or horizontal escalation
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查垂直或水平提升漏洞
- en: 'Replay the crawl anonymously, without a session ID:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名重播爬虫，不使用会话 ID：
- en: Check for authentication bypass issues
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查身份验证绕过问题
- en: To do this manually is a bit of a nightmare and wastes precious time. Thankfully,
    within the BApp Store, an extension is available to help automate most of this
    and alert us of any potential issues as early as step 3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行此操作有点像噩梦，且浪费宝贵时间。幸运的是，在 BApp 商店中，有一个扩展可以帮助自动化大部分操作，并在第 3 步早期警告我们任何潜在问题。
- en: '**Autorize** will do the heavy lifting for us and we can quickly install it
    through the Burp Suite interface.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Autorize** 将为我们完成繁重的工作，我们可以通过 Burp Suite 界面快速安装它。'
- en: '![Authentication and authorization abuse](graphics/B09238_07_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![身份验证和授权滥用](graphics/B09238_07_05.jpg)'
- en: 'Figure 7.5: Autorize in the BApp Store'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：BApp 商店中的 Autorize
- en: Simply put, once configured, Autorize will replay each request we make to the
    application two more times and compare the response to the original request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，一旦配置完成，Autorize 将重播我们对应用程序发出的每个请求两次，并将响应与原始请求进行比较。
- en: The first replayed request will contain the session ID of a second known-good
    account, while the second replayed request will be an anonymous request. The response
    for the original request should succeed, while the two others should fail, prompting
    a separate response, a `403` perhaps, or at the very least modifying the body
    of the response to inform of an authorization error. Autorize will look at the
    two responses and alert accordingly. If the first replayed request's response
    matches the original request's response, this would mean both accounts can access
    the page. If this is an administrative portal and only one of the accounts is
    an administrator, we've just found a serious authorization problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重放的请求将包含第二个已知正常账户的会话ID，而第二个重放的请求将是一个匿名请求。原始请求的响应应该成功，而另外两个请求应失败，提示一个独立的响应，可能是`403`，或者至少修改响应体以告知授权错误。Autorize将查看这两个响应并根据情况发出警报。如果第一个重放请求的响应与原始请求的响应匹配，这意味着两个账户都能访问该页面。如果这是一个管理门户，并且只有一个账户是管理员，那么我们就发现了一个严重的授权问题。
- en: Autorize can also help us find more serious vulnerabilities with the second
    replayed request, which removes the `Cookie` header, making it an anonymous request.
    If this request's response matches the original's, an authentication bypass issue
    is present in the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Autorize还可以帮助我们通过第二个重放请求发现更严重的漏洞，该请求删除了`Cookie`头，变成了一个匿名请求。如果这个请求的响应与原始请求的响应匹配，说明应用存在身份验证绕过问题。
- en: The Autorize flow
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权（Autorize）流程
- en: 'A new request is made through the attack proxy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过攻击代理发起一个新的请求：
- en: Replace the `Cookie` header with the other session ID
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一个会话ID替换`Cookie`头
- en: 'Replay the request:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重放请求：
- en: Does the response match the original request's? Alert [**Bypassed!**]
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是否与原始请求的响应匹配？警报[**已绕过！**]
- en: Remove the `Cookie` header
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Cookie`头
- en: 'Replay the request:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重放请求：
- en: Does the response match the original request's? Alert [**Bypassed!**]
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是否与原始请求的响应匹配？警报[**已绕过！**]
- en: Once installed, Autorize has to be configured with the proper `Cookie` header
    in order for it to be able to identify issues in the target application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，Autorize必须配置正确的`Cookie`头，以便能够识别目标应用中的问题。
- en: First, we need to capture the `Cookie` header and the session ID for a user
    with low privileges. This can be captured by opening a new browsing session and
    looking at the server response. We will be traversing the application using an
    administrative account.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要捕获一个低权限用户的`Cookie`头和会话ID。这可以通过打开一个新的浏览会话并查看服务器响应来捕获。我们将使用一个管理员账户浏览该应用。
- en: 'After logging in with the low-privileged account, we can grab the session value
    from any of the requests to the application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用低权限账户登录后，我们可以从任何请求中获取会话值：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's a good idea to grab the whole `Cookie` header, as some applications use
    more than just one cookie to track the user session.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最好抓取整个`Cookie`头，因为一些应用不仅使用一个Cookie来跟踪用户会话。
- en: 'In the **Autorize** tab, we can enter this value in the **Configuration** section:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Autorize**标签中，我们可以在**配置**部分输入这个值：
- en: '![The Autorize flow](graphics/B09238_07_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Autorize流程](graphics/B09238_07_06.jpg)'
- en: 'Figure 7.6: The Autorize tab and Configuration screen'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：授权（Autorize）标签和配置界面
- en: It's also a good idea to modify Autorize's interception filters to only target
    our in-scope application. The browser can make hundreds of requests to external
    or third-party applications during a normal crawl session. We don't want to generate
    three times the traffic for out-of-scope items.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最好修改Autorize的拦截过滤器，只针对我们目标应用进行操作。浏览器在正常的爬行会话期间可能会向外部或第三方应用发出数百个请求。我们不希望为超出范围的项目生成三倍的流量。
- en: 'Autorize will start replaying requests once we click the enable button:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击启用按钮，Autorize将开始重放请求：
- en: '![The Autorize flow](graphics/B09238_07_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Autorize流程](graphics/B09238_07_07.jpg)'
- en: 'Figure 7.7: The Autorize Cookie configuration pane'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：Autorize Cookie配置面板
- en: Once we've configured the `Cookie` value, we can authenticate to the application
    with a high-privileged user account and browse the administrative panel. All subsequent
    requests will be tested with the low-privilege and anonymous sessions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了`Cookie`值，我们就可以使用高权限用户账户对应用进行身份验证并浏览管理面板。所有后续请求将使用低权限和匿名会话进行测试。
- en: Clicking through the administration panel, Autorize was able to detect a vertical
    privilege escalation in the `/admin/submit.php` page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击管理面板，Autorize能够检测到`/admin/submit.php`页面中的纵向权限提升。
- en: '![The Autorize flow](graphics/B09238_07_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Autorize 流程](graphics/B09238_07_08.jpg)'
- en: 'Figure 7.8: Autorize detected an issue'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：Autorize 检测到一个问题
- en: It appears that while this page is hidden from regular users by a `403` error
    in the admin panel entry point, it is accessible directly and only checks whether
    the user is logged in, and not whether they have administrative privileges.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来虽然这个页面在管理员面板入口点被 `403` 错误隐藏，无法被普通用户访问，但它是可以直接访问的，并且只检查用户是否已登录，而不检查他们是否拥有管理员权限。
- en: We didn't have to laboriously sift through all requests we've made, change the
    session ID, and replay them. Autorize did it for us and the end result is an interesting
    authorization abuse vulnerability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要辛苦地筛选我们发送的所有请求，修改会话 ID，并重新播放它们。Autorize 为我们做了这些，最终的结果是一个有趣的授权滥用漏洞。
- en: The Swiss Army knife
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瑞士军刀
- en: One of the more common tasks you'll find yourself doing is generating custom
    wordlists based on some target-specific data. This increases your chance of success
    but is also kind of tedious. It can be scripted with something like Python, but
    why not do it in Burp directly?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常遇到的一个常见任务是基于一些特定目标数据生成自定义词典。这会提高你的成功几率，但也有点乏味。可以用类似 Python 的脚本来完成，但为什么不直接在
    Burp 中完成呢？
- en: Another common task I find myself doing is launching sqlmap attacks against
    a particular URL within the application. Authenticated SQL injection attacks require
    that we send the session cookies on the command-line, and for attacks over `POST`,
    this can make building the sqlmap command-line labor-intensive. CO2 is a Burp
    Suite plugin that provides several enhancements to the attack proxy that integrate
    well with the rest of the user interface and can create a nice flow between other
    tools and the Burp.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见任务是，我经常对应用中的特定 URL 发起 sqlmap 攻击。身份验证 SQL 注入攻击要求我们在命令行中发送会话 cookies，而对于
    `POST` 请求，这会让构建 sqlmap 命令行变得繁琐。CO2 是一个 Burp Suite 插件，它为攻击代理提供了若干增强功能，能够与其他用户界面部分良好集成，并且可以在其他工具与
    Burp 之间创建一个顺畅的工作流程。
- en: I've said this before but as penetration testers and red teamers, we know time
    is not a luxury we share with the bad guys. Engagements are often time-sensitive
    and resources are stretched thin. Copying and pasting the `Cookie` header from
    Burp into the terminal to launch a sqlmap attack doesn't seem like a big deal,
    but it adds up. What if the target application has several potential SQL injection
    points? What if you're testing three or four different applications that do not
    share the same login credentials? Automation makes life easier and makes us more
    efficient.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，作为渗透测试员和红队成员，我们知道时间不是我们和坏人共同拥有的奢侈品。参与的工作通常是时间敏感的，而且资源非常紧张。从 Burp 中复制并粘贴
    `Cookie` 头到终端发起 sqlmap 攻击似乎没什么大不了，但积少成多。如果目标应用有多个潜在的 SQL 注入点怎么办？如果你正在测试三四个不同的应用，并且它们没有共享相同的登录凭证呢？自动化让生活更轻松，让我们更高效。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The CO2 plugin can be downloaded from the BApp Store or from GitHub at [https://github.com/portswigger/co2](https://github.com/portswigger/co2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CO2 插件可以从 BApp Store 或者 GitHub 下载，网址是 [https://github.com/portswigger/co2](https://github.com/portswigger/co2)。
- en: Installing CO2 is as easy as any other BApp Store plugin and it adds a few options
    to the context menu in the Target, Proxy, Scanner, and other modules. Many of
    the requests made through Burp can be sent directly to a few of the CO2 components.
    Doing so will fill in most of the required parameters, saving us time and reducing
    the potential for human error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CO2 和其他 BApp Store 插件一样简单，它会在 Target、Proxy、Scanner 以及其他模块的上下文菜单中添加一些选项。通过
    Burp 发出的许多请求可以直接发送到 CO2 的一些组件。这样做会自动填写大部分必需的参数，节省时间并减少人为错误的可能性。
- en: sqlmap helper
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlmap 帮助器
- en: 'CO2 provides a sqlmap wrapper within the Burp user interface aptly titled **SQLMapper**.
    If we spot a potential injection point, or perhaps Burp''s active scanner notified
    us of a SQL injection vulnerability, we can send the request straight to CO2''s
    SQLMapper component using the context menu:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: CO2 在 Burp 用户界面中提供了一个 sqlmap 封装器，名为 **SQLMapper**。如果我们发现了潜在的注入点，或者可能是 Burp 的主动扫描器通知我们有
    SQL 注入漏洞，我们可以通过上下文菜单将请求直接发送到 CO2 的 SQLMapper 组件：
- en: '![sqlmap helper](graphics/B09238_07_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![sqlmap 帮助器](graphics/B09238_07_09.jpg)'
- en: 'Figure 7.9: Sending the request to SQLMapper''s context menu from CO2'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：从 CO2 发送请求到 SQLMapper 的上下文菜单
- en: In the CO2 extension tab, the SQLMapper section should be prepopulated with
    some of the values from the selected URL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CO2 扩展选项卡中，SQLMapper 部分应该会自动填充从所选 URL 获取的一些值。
- en: At this point, we can configure the component to point to the appropriate `sqlmap`
    script and `python` binary.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以配置组件，指向适当的 `sqlmap` 脚本和 `python` 可执行文件。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Kali distribution comes with a fairly recent version of sqlmap already installed,
    but the latest and greatest code can be cloned from GitHub at [https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 发行版已经安装了相对较新的 sqlmap 版本，但最新的代码可以从 GitHub 克隆，地址是 [https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)。
- en: The **Config** button will allow us to point CO2 to the right binaries to execute
    sqlmap from the user interface. The **Run** button will spawn a new terminal with
    sqlmap and all of the options passed in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置** 按钮将允许我们将 CO2 指向正确的可执行文件，从用户界面执行 sqlmap。**运行** 按钮将启动一个新的终端，运行 sqlmap
    并传递所有选项。'
- en: '![sqlmap helper](graphics/B09238_07_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![sqlmap 帮助](graphics/B09238_07_10.jpg)'
- en: 'Figure 7.10: CO2 SQLMap config popup'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：CO2 SQLMap 配置弹窗
- en: On Kali, the sqlmap tool is located in the `/usr/bin` folder and does not have
    the `.py` extension. If you're working with the bleeding edge from the GitHub
    repository, you may want to specify the full path.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上，sqlmap 工具位于 `/usr/bin` 文件夹中，并且没有 `.py` 扩展名。如果你正在使用 GitHub 仓库中的最新版本，可能需要指定完整路径。
- en: 'First, we can clone the latest and greatest sqlmap code from GitHub using the
    `git clone` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `git clone` 命令从 GitHub 克隆最新的 sqlmap 代码：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `sqlmap.py` script will be in the cloned `sqlmap` directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap.py` 脚本将位于克隆的 `sqlmap` 目录中：'
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: sqlmap is a full-featured tool with a ton of options to modify everything from
    the user agent, to the injection technique, and even the level of aggression of
    each probe. Typically, we'd have to look through the tool documentation to find
    that one switch we need, but with CO2's SQLMapper plugin, we can find what we
    need at a glance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap 是一款功能强大的工具，拥有大量选项，可以修改从用户代理到注入技术，甚至是每个探针的攻击性级别。通常情况下，我们需要查阅工具文档以找到所需的开关，但借助
    CO2 的 SQLMapper 插件，我们可以一目了然地找到需要的选项。
- en: As we select the appropriate options and fill in the blanks, CO2 builds a sqlmap
    command, which we can either run through the user interface, or copy and run directly
    in a terminal of our choice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择适当的选项并填写空白时，CO2 会构建一个 sqlmap 命令，我们可以通过用户界面运行它，或者直接复制并在我们选择的终端中运行。
- en: '![sqlmap helper](graphics/B09238_07_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![sqlmap 帮助](graphics/B09238_07_11.jpg)'
- en: 'Figure 7.11: CO2''s SQLMapper plugin'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：CO2 的 SQLMapper 插件
- en: 'The **Run** button will launch a new terminal window and start sqlmap with
    the selected options:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行** 按钮将启动一个新的终端窗口，并以选定的选项启动 sqlmap：'
- en: '![sqlmap helper](graphics/B09238_07_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![sqlmap 帮助](graphics/B09238_07_12.jpg)'
- en: 'Figure 7.12: sqlmap running with the selected options'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：sqlmap 运行并使用已选择的选项
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'sqlmap will save the session of each attack in a folder under the home directory:
    `~/.sqlmap/output/[target]`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap 将把每次攻击的会话保存在主目录下的文件夹中：`~/.sqlmap/output/[target]`
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Web shells
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web Shells
- en: The CO2 Swiss Army knife also provides an easy way to generate web shells for
    a number of server-side languages. If we manage to upload a shell to one of these
    boxes, we need a simple, somewhat secure shell to escalate privileges and ultimately
    reach our goal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CO2 瑞士军刀还提供了一个简单的方法，可以为多种服务器端语言生成 Web Shell。如果我们成功地将一个 Shell 上传到其中一台机器，我们就需要一个简单的、较为安全的
    Shell 来提升权限，最终达到我们的目标。
- en: Cue **Laudanum**, a collection of basic web shells for a variety of backends,
    supporting ASP, JSP, ASPX, Java, and PHP. Laudanum also allows us to specify a
    random connection token and restrict access by IP. These shells do allow for remote
    code execution and it makes sense to protect them until a more robust reverse
    shell can be established.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 **Laudanum**，这是一个包含多种后端基本 Web Shell 的集合，支持 ASP、JSP、ASPX、Java 和 PHP。Laudanum
    还允许我们指定一个随机连接令牌，并按 IP 限制访问。这些 Shell 允许远程代码执行，因此在建立更强大的反向 Shell 之前，保护它们是很有意义的。
- en: In the Laudanum component of CO2, we can specify the type of shell we'd like
    to setup, the IPs that will be allowed to connect, and a randomized token used
    for a bit more protection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CO2 的 Laudanum 组件中，我们可以指定希望设置的 Shell 类型、允许连接的 IP 地址，以及用于提供更多保护的随机化令牌。
- en: 'The process to generate a shell is simple. First, we open the **Laudanum**
    tab in CO2 and:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 Shell 的过程很简单。首先，我们打开 CO2 中的 **Laudanum** 标签页，然后：
- en: 'Select the type of shell:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Shell 类型：
- en: '**PHP Shell** in this scenario'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此场景中的 **PHP Shell**
- en: 'A comma-separated list of IPs, without spaces:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用逗号分隔的 IP 列表，不包含空格：
- en: '`127.0.0.1,192.168.1.123`'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1,192.168.1.123`'
- en: 'Click the **Gen New Token** button for a random token value:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成新令牌**按钮获取一个随机的令牌值：
- en: '![Web shells](graphics/B09238_07_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Web shells](graphics/B09238_07_13.jpg)'
- en: 'Figure 7.13: The Laudanum CO2 plugin'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：Laudanum CO2 插件
- en: 'To save the file somewhere on disk, click the **Generate File** button. The
    contents of the generated shell will look like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件保存在磁盘上的某个位置，点击**生成文件**按钮。生成的 shell 内容将如下所示：
- en: '![Web shells](graphics/B09238_07_14.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Web shells](graphics/B09238_07_14.jpg)'
- en: 'Figure 7.14: The Laudanum shell source code'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14：Laudanum shell 源代码
- en: Once uploaded to the target, to access the shell we have to make sure our external
    IP matches one of the whitelisted IPs and we also have to specify the randomly
    generated token for every request.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传到目标，访问 shell 时我们必须确保我们的外部 IP 与白名单中的一个 IP 匹配，并且每个请求还必须指定随机生成的令牌。
- en: We can pass this token using the `laudtoken` URL parameter and the command to execute
    via `laudcmd`. Values for these parameters can also be passed via `POST`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `laudtoken` URL 参数传递此令牌，并通过 `laudcmd` 执行命令。这些参数的值也可以通过 `POST` 传递。
- en: It should be noted that even with the correct token in the URL, a request from
    an unknown IP will be rejected with a `404` response.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，即使 URL 中的令牌正确，来自未知 IP 的请求也会被 `404` 响应拒绝。
- en: Here, we test a simple web request from a Windows machine using PowerShell's
    `Invoke-WebRequest` commandlet. Since the request is not coming from a known IP (one
    we've specified during the creation of the shell), the request is denied.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 PowerShell 的 `Invoke-WebRequest` 命令来测试来自 Windows 机器的简单 web 请求。由于请求不是来自已知的
    IP（即我们在创建 shell 时指定的 IP），因此请求被拒绝。
- en: '![Web shells](graphics/B09238_07_15.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Web shells](graphics/B09238_07_15.jpg)'
- en: 'Figure 7.15: Rejected shell request from unknown IP'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15：来自未知 IP 的被拒绝的 shell 请求
- en: Our client will appreciate the extra security checks; after all, we are here
    to find vulnerabilities and not introduce new ones. It should go without saying,
    but this is not foolproof; this file should be purged during cleanup just like
    any other artifact we drop on the target.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端会赞赏这些额外的安全检查；毕竟，我们的目的是发现漏洞，而不是引入新的漏洞。不言而喻，这并不是万无一失的；这个文件应该像我们丢在目标上的任何其他痕迹一样，在清理时被清除。
- en: With the proper external IP and the token in hand, we can gain control of the
    shell using Burp Suite's Repeater module.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确的外部 IP 和令牌，我们可以使用 Burp Suite 的 Repeater 模块控制 shell。
- en: To issue a request, we can fill in the minimum `GET` request headers, as shown
    in the following screenshot. What we need to configure is the **Target**, in the
    top-right corner of the **Repeater** tab; the URL requested via `GET`; and the
    values for the `laudtoken` and `laudcmd`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出请求，我们可以填写最小的 `GET` 请求头，如下截图所示。我们需要配置的是**目标**，在**Repeater**标签的右上角；通过 `GET`
    请求的 URL；以及 `laudtoken` 和 `laudcmd` 的值。
- en: '![Web shells](graphics/B09238_07_16.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Web shells](graphics/B09238_07_16.jpg)'
- en: 'Figure 7.16: Successfully accessing the protected Laudanum shell'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：成功访问受保护的 Laudanum shell
- en: Obfuscating code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆代码
- en: The Laudanum shell generated by CO2 in the previous section worked just fine,
    but if a defender looks a little too closely at the source code, it will definitely
    raise some red flags. Ideally, we want to keep the file size as small as possible
    and try to make the code more difficult to analyze. The comments, the properly
    indented code, and descriptive variable names make figuring out what `ads.php`
    actually does a breeze.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中由 CO2 生成的 Laudanum shell 工作得非常好，但如果防守者稍微仔细查看源代码，肯定会引起一些警觉。理想情况下，我们希望保持文件大小尽可能小，并且尽量让代码更难分析。注释、正确缩进的代码以及描述性的变量名使得弄清楚
    `ads.php` 实际做什么变得轻而易举。
- en: Let's make analysis a bit more complicated. Code obfuscators are commonly used
    in digital rights management software, anti-piracy modules, and of course, malware.
    While no code obfuscator will stop an experienced reverse engineer, it certainly
    does slow things down; perhaps long enough for us to move on to another server
    or application, but at least long enough to evade antivirus signatures. Ideally,
    we remove the comments, rename the variables, and try to hide the shell's actual
    functionality, but it's not a good idea to do this manually. Human error can introduce
    code issues and obfuscation can cause more problems than it solves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让分析变得更加复杂。代码混淆器通常用于数字版权管理软件、反盗版模块，以及当然，恶意软件。虽然没有任何代码混淆器能阻止经验丰富的逆向工程师，但它确实会减缓进程；也许足够长的时间让我们转移到另一台服务器或应用程序，但至少足够长的时间来躲避病毒扫描的特征码。理想情况下，我们删除注释，重命名变量，并尽量隐藏
    shell 的实际功能，但手动进行这些操作并不明智。人为错误可能引入代码问题，混淆反而可能导致更多的问题。
- en: Obfuscators will transform the source code of an application (or in our case,
    web shell) into a compact mess of code, stripped of comments, with random names
    for variables, making it difficult to analyze. The beauty of this is that even
    if the code is mangled and hard to comprehend by humans, the parser or compiler
    will not care that much, as long as it is syntactically correct. The application
    should have no issue running properly obfuscated code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆器将应用程序（或在我们的例子中，Web shell）的源代码转换为紧凑的代码块，去除注释，变量名称随机，使得分析变得困难。这样做的好处是，即使代码被混淆且难以被人类理解，只要语法正确，解析器或编译器并不在乎。应用程序应该可以正常运行混淆后的代码。
- en: There are source code obfuscators for almost every programming language out
    there. To obfuscate PHP, we can use naneau's fantastic application, PHP Obfuscator,
    an easy-to-use command-line utility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种编程语言都有相应的源代码混淆器。为了混淆 PHP，我们可以使用 naneau 的绝妙应用 PHP Obfuscator，这是一个易于使用的命令行工具。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PHP Obfuscator can be cloned from [https://github.com/naneau/php-obfuscator](https://github.com/naneau/php-obfuscator).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PHP Obfuscator 可以从 [https://github.com/naneau/php-obfuscator](https://github.com/naneau/php-obfuscator)
    克隆。
- en: 'We will store the application in `~/tools/phpobfs` and clone it from GitHub
    with `git clone`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把应用程序存储在`~/tools/phpobfs`目录中，并通过`git clone`从 GitHub 克隆它：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'PHP Obfuscator requires composer, which can be quickly installed on Kali or
    similar distributions using `apt-get install`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 混淆器需要 composer，可以通过在 Kali 或类似的发行版上使用`apt-get install`快速安装：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the newly cloned `phpobfs` directory, we can issue a `composer install`
    command to generate an `obfuscate` tool in the `bin` folder:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在新克隆的`phpobfs`目录中，我们可以发出`composer install`命令来在`bin`文件夹中生成一个`obfuscate`工具：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If everything ran successfully, we should have an executable script in `bin`
    called `obfuscate`, which we can use to mangle our Laudanum shell.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切运行成功，我们应该会在`bin`文件夹中得到一个可执行脚本`obfuscate`，我们可以用它来混淆我们的 Laudanum shell。
- en: 'We can call the `obfuscate` tool with the `obfuscate` parameter, and pass in
    the file to mangle, as well as the output directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有`obfuscate`参数的`obfuscate`工具，并传入要混淆的文件以及输出目录：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we inspect the newly obfuscated `ads.php` file, we now see this blob of
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查新混淆后的`ads.php`文件，现在我们看到的是这块混乱的代码：
- en: '![Obfuscating code](graphics/B09238_07_17.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![混淆代码](graphics/B09238_07_17.jpg)'
- en: 'Figure 7.17: Obfuscated Laudanum shell'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：混淆后的 Laudanum shell
- en: 'Some strings are still visible and we can see the IPs and token values are
    still intact. The variables are changed to non-descriptive random words, the comments
    are gone, and the result is really compact. The difference in size between the
    two shells is also significant:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符串仍然可见，我们可以看到 IP 和令牌值仍然完好无损。变量被更改为非描述性的随机单词，注释被去除，结果非常紧凑。两个 shell 之间的大小差异也很明显：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's not foolproof, but it should let us fly under the radar a bit longer. PHP
    Obfuscate should work on all PHP code, including shells you may choose to write
    yourself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是万无一失的，但应该能让我们在雷达下飞得更久。PHP Obfuscate 应该适用于所有 PHP 代码，包括你可能自己编写的 shell。
- en: Burp Collaborator
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Burp Collaborator
- en: In the previous chapter, we looked at finding obscure vulnerabilities in applications
    that may not be obvious to attackers. If the application does not flinch when
    we feed it unexpected input, it could be that it is not vulnerable and the code
    properly validates input, but it could also mean that a vulnerability exists but
    it's hidden. To identify these types of vulnerabilities, we passed in a payload
    that forced the application to connect back to our C2 server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了如何发现应用程序中不易被攻击者察觉的隐蔽漏洞。如果应用程序在我们输入意外数据时没有反应，可能是因为它没有漏洞且代码正确地验证了输入，但也可能意味着存在漏洞，只是它被隐藏了。为了识别这类漏洞，我们传入一个有效载荷，强制应用程序连接回我们的
    C2 服务器。
- en: This is a very useful technique, but the process was manual. We passed in custom
    payloads and waited for a ping from the server to confirm the existence of a vulnerability.
    Most application assessments are time-limited and manually checking each input
    on a large attack surface is not realistic. We have to automate this process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常有用的技术，但过程是手动的。我们传入自定义的有效载荷，并等待服务器的回传，以确认漏洞的存在。大多数应用程序评估是有限时的，在一个庞大的攻击面上手动检查每个输入是不现实的。我们必须自动化这个过程。
- en: Luckily, the professional version of Burp Suite allows us to use a Collaborator
    server infrastructure to help automate finding vulnerabilities out-of-band.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Burp Suite 的专业版允许我们使用 Collaborator 服务器基础设施来帮助自动化发现离带外漏洞。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The free version does not support Collaborator; however, [Chapter 6](ch06.html
    "Chapter 6. Out-of-Band Exploitation"), *Out-of-Band Exploitation*, described
    the process and how to build a C2 infrastructure that can be used for the same
    purpose.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 免费版不支持 Collaborator；然而，[第 6 章](ch06.html "第 6 章. 离带外利用")，*离带外利用*，描述了该过程以及如何构建一个可以用于相同目的的
    C2 基础设施。
- en: The Collaborator server is similar to the C2 server we set up in [Chapter 6](ch06.html
    "Chapter 6. Out-of-Band Exploitation"), *Out-of-Band Exploitation*, but has a
    few more bells and whistles. Notably, it integrates with Burp's Scanner module
    to check for these hard-to-find vulnerabilities automatically. It's also less
    prone to false positives than the more manual approach.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 服务器类似于我们在 [第 6 章](ch06.html "第 6 章. 离带外利用")，*离带外利用*，中设置的 C2 服务器，但有一些额外的功能。特别是，它与
    Burp 的扫描模块集成，能自动检查这些难以发现的漏洞。与更手动的方法相比，它也更不容易出现误报。
- en: The Collaborator setting can be found under the **Project options** tab and
    can be either disabled or enabled to use the default server or a private instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 设置可以在 **项目选项** 标签下找到，可以禁用或启用以使用默认服务器或私有实例。
- en: 'Collaborator, at a high-level, works like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 高级别上，Collaborator 工作方式如下：
- en: 'Burp scanner generates a payload to detect SQL injection:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Burp 扫描器生成了一个有效载荷来检测 SQL 注入：
- en: '[PRE9]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The application asynchronously executes the SQL query
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序异步执行 SQL 查询
- en: The SQL injection is successful
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL 注入成功
- en: The SQL server attempts to list the SMB share on the randomly generated `burpcollaborator.net`
    domain
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL 服务器尝试列出随机生成的 `burpcollaborator.net` 域上的 SMB 共享
- en: 'A DNS lookup is performed:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行了 DNS 查找：
- en: Collaborator server logs this DNS request attempt
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Collaborator 服务器记录了这个 DNS 请求尝试
- en: 'An SMB connection is made and dummy data is returned:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功建立 SMB 连接并返回虚拟数据：
- en: Collaborator server logs this SMB connection attempt as well
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Collaborator 服务器也记录了这个 SMB 连接尝试
- en: The Burp client checks in with the Collaborator server
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Burp 客户端与 Collaborator 服务器进行通信
- en: 'The Collaborator server reports two issues:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Collaborator 服务器报告了两个问题：
- en: An out-of-band DNS request was made
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出了一个离带外的 DNS 请求
- en: An out-of-band service interaction for SMB was observed
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察到一个离带外的 SMB 服务交互
- en: The beauty of Collaborator is that the randomly generated unique domain can
    actually be linked to a specific request made by the scanner. This tells us exactly
    which URL and which parameter is vulnerable to SQL injection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 的优势在于，随机生成的唯一域名实际上可以与扫描器发出的特定请求关联。这能准确地告诉我们哪个 URL 和哪个参数易受 SQL 注入攻击。
- en: Public Collaborator server
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共 Collaborator 服务器
- en: The default Collaborator server is an instance operated by PortSwigger, the
    Burp Suite developers. It resides on [burpcollaborator.net](http://burpcollaborator.net)
    and support is built into Burp.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Collaborator 服务器是由 Burp Suite 开发者 PortSwigger 操作的实例。它位于 [burpcollaborator.net](http://burpcollaborator.net)，并且
    Burp 中内置了支持。
- en: As you'd expect, the default Collaborator instance is accessible by everyone
    with a copy of the professional version of Burp and resources are shared among
    all its users. From a privacy perspective, users cannot see each other's Collaborator
    requests. Each payload is unique and crafted by Burp Suite for every request.
    The communication is encrypted and a unique, per-user secret is required to retrieve
    any data from the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，默认的 Collaborator 实例可以被所有拥有 Burp 专业版副本的用户访问，资源在所有用户之间共享。从隐私角度看，用户无法看到彼此的
    Collaborator 请求。每个有效载荷都是唯一的，由 Burp Suite 为每个请求单独生成。通信是加密的，且需要一个唯一的、每个用户专属的密钥才能从服务器中检索任何数据。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Burp Collaborator takes several steps to ensure the data is safe. You can read
    more about the whole process on [https://portswigger.net/burp/help/collaborator](https://portswigger.net/burp/help/collaborator).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Collaborator 采取了几个步骤以确保数据的安全。你可以在 [https://portswigger.net/burp/help/collaborator](https://portswigger.net/burp/help/collaborator)
    上阅读更多关于整个过程的内容。
- en: 'To enable Collaborator, we can navigate to the **Misc** tab under **Project
    options** and select the **Use the default Collaborator server** radial button,
    as shown:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Collaborator，我们可以进入**项目选项**下的**Misc**标签，选择**使用默认 Collaborator 服务器**单选按钮，如下所示：
- en: '![Public Collaborator server](graphics/B09238_07_18.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![公共 Collaborator 服务器](graphics/B09238_07_18.jpg)'
- en: 'Figure 7.18: Configuring the Burp Collaborator server'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：配置 Burp Collaborator 服务器
- en: 'To use the public server, no further information is needed. We can issue a
    health check to see whether the Burp Suite client can reach it before we begin
    the test, by clicking the **Run health check…** button on the configuration page.
    A new window will popup and display the ongoing health check, with the status
    for each check, as shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用公共服务器，不需要更多的信息。我们可以通过点击配置页面上的**运行健康检查...**按钮，来发起一次健康检查，看看 Burp Suite 客户端是否可以连接到该服务器，开始测试之前。一个新窗口将弹出并显示正在进行的健康检查，每个检查的状态如下所示：
- en: '![Public Collaborator server](graphics/B09238_07_19.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![公共 Collaborator 服务器](graphics/B09238_07_19.jpg)'
- en: 'Figure 7.19: Burp Collaborator health check'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19：Burp Collaborator 健康检查
- en: SMTP connection issues are common if you're behind an ISP that still blocks
    outgoing connections on ports used by spam bots. Chances are that your target
    is not on a domestic ISP and these types of restrictions are not in place, at
    least not at the ISP level. Egress filtering can hinder out-of-band discovery,
    which is where a private instance on the LAN comes in handy. We discuss deploying
    a private Collaborator server later in the chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络环境是由仍然阻止垃圾邮件机器人使用的端口进行外发连接的 ISP 提供的，SMTP 连接问题是很常见的。你的目标可能并不在国内的 ISP 上，这类限制可能并不存在，至少在
    ISP 层级上是如此。外发过滤可能会阻碍带外发现，在这种情况下，局域网上的私有实例就派上用场了。我们将在本章后面讨论如何部署一个私有 Collaborator
    服务器。
- en: Service interaction
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务交互
- en: To see Collaborator in action, we can point the Burp Active Scanner to a vulnerable
    application and wait for it to execute one of the payloads generated, and perform
    a connect back to the public Collaborator server [burpcollaborator.net](http://burpcollaborator.net).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Collaborator 的实际操作，我们可以将 Burp Active Scanner 指向一个易受攻击的应用程序，并等待它执行生成的某个有效载荷，并进行回连至公共
    Collaborator 服务器 [burpcollaborator.net](http://burpcollaborator.net)。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Damn Vulnerable Web Application is a good testing bed for Collaborator:
    [http://www.dvwa.co.uk/](http://www.dvwa.co.uk/).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Damn Vulnerable Web Application** 是测试 Collaborator 的一个很好的平台：[http://www.dvwa.co.uk/](http://www.dvwa.co.uk/)。'
- en: '![Service interaction](graphics/B09238_07_20.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![服务交互](graphics/B09238_07_20.jpg)'
- en: 'Figure 7.20: Out-of-band vulnerabilities detected by Collaborator'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20：Collaborator 检测到的带外漏洞
- en: The Burp Suite client will check in periodically with the Collaborator server
    to ask about any recorded connections. In the preceding case, we can see that
    the application, vulnerable to command injection, was tricked into connecting
    to the Collaborator cloud instance by performing a DNS lookup on a unique domain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 客户端将定期与 Collaborator 服务器通信，询问是否有任何已记录的连接。在前面的例子中，我们可以看到，受命令注入漏洞影响的应用程序，通过对一个独特域名执行
    DNS 查找，被诱骗连接到 Collaborator 云实例。
- en: The Collaborator server intercepted this DNS request from the vulnerable application,
    recorded it, and notified us. Our Burp Suite client linked the service interaction
    reported by Collaborator to a specific request and highlighted it for easy review.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 服务器拦截了来自漏洞应用程序的 DNS 请求，记录了它，并通知了我们。我们的 Burp Suite 客户端将 Collaborator
    报告的服务交互与一个特定请求关联，并突出显示，方便我们查看。
- en: This was all done automatically in the background. With Collaborator's help,
    we can cover a large attack surface and find obscure bugs quickly and efficiently.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在后台自动完成的。有了 Collaborator 的帮助，我们可以覆盖大范围的攻击面，并快速高效地找到一些难以察觉的漏洞。
- en: Burp Collaborator client
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Burp Collaborator 客户端
- en: In certain situations, relying on Burp's Active Scanner to find these issues
    may not be sufficient. Suppose we may suspect a particular component of the target
    application is vulnerable to a blind SQL injection or stored XSS attack.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，依赖 Burp 的主动扫描器发现这些问题可能不足够。假设我们怀疑目标应用程序的某个组件容易受到盲注或存储型 XSS 攻击。
- en: In order for the exploit to trigger, it would have to be wrapped in some type
    of encoding or encryption, and passed to the application to be later decoded,
    or decrypted and executed. Burp's Active Scanner would not be able to confirm
    this vulnerability because it is not aware of the custom requirements for the
    payload delivery.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发漏洞利用，它必须被包装在某种编码或加密格式中，并传递给应用程序，稍后进行解码、解密并执行。Burp 的主动扫描器无法确认这个漏洞，因为它不了解有效载荷交付的自定义要求。
- en: The good news is that we can still leverage Collaborator to help us identify
    vulnerabilities in these difficult-to-reach areas of the application. Burp Suite
    also comes bundled with the Collaborator client, which can generate a number of these
    unique domains to be used in a custom Intruder attack.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们仍然可以利用 Collaborator 来帮助我们识别应用程序中这些难以触及区域的漏洞。Burp Suite 还捆绑了 Collaborator
    客户端，它可以生成多个用于自定义 Intruder 攻击的唯一域名。
- en: 'The Collaborator client can be launched from the Burp menu:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 Burp 菜单启动 Collaborator 客户端：
- en: '![Burp Collaborator client](graphics/B09238_07_21.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Collaborator 客户端](graphics/B09238_07_21.jpg)'
- en: 'Figure 7.21: Launch Collaborator client from the Burp menu'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21：从 Burp 菜单启动 Collaborator 客户端
- en: To generate unique domains for use in custom payloads, enter the desired number
    and click **Copy to clipboard**. Burp will add the newline-separated domains to
    the clipboard for further processing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成用于自定义有效载荷的唯一域名，输入所需的数量并点击 **复制到剪贴板**。Burp 会将这些域名按换行符分隔，添加到剪贴板，以供后续处理。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once you close the Collaborator client window, the domains generated will be
    invalidated and you may not be able to detect out-of-band service interactions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你关闭 Collaborator 客户端窗口，生成的域名将失效，你可能无法检测到带外服务交互。
- en: '![Burp Collaborator client](graphics/B09238_07_22.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Collaborator 客户端](graphics/B09238_07_22.jpg)'
- en: 'Figure 7.22: Burp Collaborator client window'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22：Burp Collaborator 客户端窗口
- en: We can grab one of these domains and feed it to our custom attack. The application
    accepts the request but does not respond with any data. Our payload is a simple
    XSS payload designed to create an `iframe` that navigates to the domain generated
    by the Collaborator client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取其中一个域名并将其提供给我们的自定义攻击。应用程序接受该请求，但没有返回任何数据。我们的有效载荷是一个简单的 XSS 有效载荷，旨在创建一个
    `iframe`，该 `iframe` 导航到由 Collaborator 客户端生成的域名。
- en: '[PRE10]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the application is vulnerable, this exploit will spawn a new HTML `iframe`,
    which will connect back to a server we control, confirming the existence of a
    vulnerability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序存在漏洞，这个漏洞利用将生成一个新的 HTML `iframe`，它会连接回我们控制的服务器，从而确认漏洞的存在。
- en: '![Burp Collaborator client](graphics/B09238_07_23.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Collaborator 客户端](graphics/B09238_07_23.jpg)'
- en: 'Figure 7.23: Submitting the Collaborator domain in an XSS payload'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23：在 XSS 有效载荷中提交 Collaborator 域名
- en: We hope that this payload is executed at some point, perhaps when an administrator
    navigates to the page responsible for handling these requests. If the application
    is vulnerable, the `iframe` will attempt to navigate to the injected URL.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个有效载荷在某个时刻被执行，或许是在管理员访问负责处理这些请求的页面时。如果应用程序存在漏洞，`iframe` 将尝试导航到注入的 URL。
- en: 'This has the following side effects:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下副作用：
- en: A DNS request is made to the `src` domain
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `src` 域发送 DNS 请求
- en: An HTTP request is made to the IP associated with the `src` domain
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向与 `src` 域关联的 IP 发送 HTTP 请求
- en: 'The Collaborator client will poll the server every 60 seconds by default but
    can be forced to check at any point. If a victim triggers exploit, Collaborator
    will let us know:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Collaborator 客户端每 60 秒轮询一次服务器，但也可以在任何时候强制检查。如果受害者触发了漏洞利用，Collaborator
    会通知我们：
- en: '![Burp Collaborator client](graphics/B09238_07_24.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Collaborator 客户端](graphics/B09238_07_24.jpg)'
- en: 'Figure 7.24: Collaborator client shows service interaction'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24：Collaborator 客户端显示服务交互
- en: It appears that the payload was executed successfully and with Collaborator's
    help, we now have proof.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有效载荷已成功执行，在 Collaborator 的帮助下，我们现在有了证据。
- en: Private Collaborator server
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私人 Collaborator 服务器
- en: There are benefits to running our own instance of Collaborator. A private instance
    is useful for tests where the target cannot reach the internet, or for the extra-paranoid
    client who would prefer to take third-parties out of the equation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们自己的 Collaborator 实例有很多好处。私人实例对于目标无法访问互联网的测试非常有用，或者对于极度谨慎的客户来说，选择将第三方排除在外也是一种理想选择。
- en: 'There''s also something to be said about stealth: outbound connections to a
    [burpcollaborator.net](http://burpcollaborator.net) domain may raise some eyebrows.
    A less conspicuous domain may be better suited for some engagements. I realize
    the domain we''re about to use for our private instance, `c2.spider.ml`, is not
    much better, but we''ll roll with it for the demo''s sake.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，关于隐蔽性也有必要提及：向 [burpcollaborator.net](http://burpcollaborator.net) 域发出的外向连接可能会引起注意。对于某些任务，使用一个不那么显眼的域可能会更合适。我意识到我们即将为私人实例使用的域
    `c2.spider.ml` 也不是特别理想，但为了演示的方便，我们就使用它吧。
- en: The Collaborator server has many of the same requirements as the C2 server we
    set up in the previous chapter. The only difference is the Burp server will run
    its own services for DNS, HTTP, and SMTP, and we will not need INetSim.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 服务器有很多与我们在前一章节中设置的 C2 服务器相同的要求。唯一的区别是 Burp 服务器将自行运行 DNS、HTTP 和
    SMTP 服务，因此我们不需要 INetSim。
- en: We have already delegated control of `c2.spider.ml` to our cloud instance on
    which the Collaborator server will run. The DNS service should be able to respond
    to all incoming DNS requests for any subdomain belonging to `c2.spider.ml`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `c2.spider.ml` 的控制权委托给我们的云实例，Collaborator 服务器将在该实例上运行。DNS 服务应该能够响应任何属于
    `c2.spider.ml` 子域的传入 DNS 请求。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Collaborator can be a bit memory hungry and a micro-cloud instance may not be
    enough for a production deployment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 可能有些耗费内存，微型云实例可能不足以进行生产部署。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first time you run the Collaborator server, it will prompt you to enter
    your license in order to perform activation. This value is stored in `~/.java/.userPrefs/burp/prefs.xml`
    so make sure that this file is properly protected and is not world-readable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行 Collaborator 服务器时，它会提示你输入许可证以进行激活。此值存储在 `~/.java/.userPrefs/burp/prefs.xml`
    中，因此确保此文件已得到妥善保护，且不可公开读取。
- en: 'The Collaborator server is actually built into the Burp Suite attack proxy.
    We can copy the Burp Suite Professional JAR file and launch it from the command-line
    with the `--collaborator-server` switch:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Collaborator 服务器实际上是内置在 Burp Suite 攻击代理中的。我们可以复制 Burp Suite Professional JAR
    文件，并通过命令行使用 `--collaborator-server` 开关启动它：
- en: '[PRE11]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, the Collaborator server is running with default configuration.
    We will need to specify some custom options to get the most out of the private
    instance. The configuration file is a simple text file in JSON format, with a
    few options to specify listening ports, DNS authoritative zones, and SSL configuration
    options. We can create this file anywhere on disk and reference it later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Collaborator 服务器正在使用默认配置运行。我们需要指定一些自定义选项，以便充分利用私人实例。配置文件是一个简单的 JSON 格式文本文件，包含几个选项来指定监听端口、DNS
    权威区域和 SSL 配置选项。我们可以将该文件创建在磁盘上的任何位置，并稍后引用它。
- en: '[PRE12]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You'll notice we had to specify the domain we'll be using along with our public
    IP address. The log level is set to `DEBUG` until we can confirm the server is
    functioning properly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们必须指定将使用的域名以及我们的公共 IP 地址。日志级别设置为 `DEBUG`，直到我们确认服务器正常运行。
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good idea to filter incoming traffic to these ports and whitelist your
    and your target's external IPs only.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最好对这些端口的传入流量进行过滤，并仅将你和目标的外部 IP 地址列入白名单。
- en: Now that the server is online, we can modify the **Project options** and point
    to our private server, `c2.spider.ml`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器已经上线，我们可以修改 **项目选项**，并指向我们的私人服务器 `c2.spider.ml`。
- en: '![Private Collaborator server](graphics/B09238_07_25.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![私人 Collaborator 服务器](graphics/B09238_07_25.jpg)'
- en: 'Figure 7.25: Private Collaborator server configuration'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25：私人 Collaborator 服务器配置
- en: 'Using the **Run health check…** button, we should be able to force some interaction
    with the new Collaborator server:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **运行健康检查…** 按钮，我们应该能够强制与新 Collaborator 服务器进行一些交互：
- en: '![Private Collaborator server](graphics/B09238_07_26.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![私人 Collaborator 服务器](graphics/B09238_07_26.jpg)'
- en: 'Figure 7.26: Burp Collaborator health check'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26：Burp Collaborator 健康检查
- en: 'The server console log will reflect our connection attempts:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器控制台日志将反映我们的连接尝试：
- en: '[PRE14]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The SMTP and SMTPS checks may fail depending on your ISP's firewall, but enterprise
    clients should be able to reach it. The important part is the DNS configuration.
    If the target can resolve the randomly generated subdomain for `c2.spider.ml`,
    they should be able to connect outbound if no other egress filtering takes place.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 和 SMTPS 检查可能会因为你的 ISP 防火墙而失败，但企业客户应该能够访问。重要的部分是 DNS 配置。如果目标能够解析 `c2.spider.ml`
    的随机生成子域名，那么如果没有其他出站过滤，他们应该能够建立外向连接。
- en: You'll also notice that the enforced HTTPS connection failed as well. This is
    because by default, Collaborator uses a self-signed wildcard certificate to handle
    encrypted HTTP connections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到强制的 HTTPS 连接也失败了。这是因为默认情况下，Collaborator 使用自签名的通配符证书来处理加密的 HTTP 连接。
- en: To get around this issue for targets whose trusted root certificate authorities
    we don't control, we'd have to install a certificate signed by a public certificate
    authority.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，对于我们无法控制的目标信任的根证书颁发机构，我们需要安装一个由公共证书颁发机构签署的证书。
- en: 'The `config.json` would be modified slightly to point Collaborator to this
    certificate and its private key:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.json` 将稍作修改，指向 Collaborator 使用这个证书及其私钥：'
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a subdirectory called `keys`, we'd have to drop the PKCS 8-encoded private
    key, the corresponding publicly signed certificate, and any intermediate authority
    certificates we may need to sever in order for the certificate chain to validate.
    In the previous chapter, we were able to generate certificates for our C2 domain,
    which we can use and play here as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 `keys` 的子目录中，我们需要放置 PKCS 8 编码的私钥、相应的公签证书以及任何中间证书颁发机构证书，这些证书我们可能需要断开以便证书链能够验证。在前一章中，我们成功生成了
    C2 域的证书，可以在这里继续使用。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showcased a number of tools and techniques that work together to
    make an otherwise-tedious part of the engagement seamless. Burp Suite, or the
    free alternative OWASP ZAP, both provide ways to extend functionality and make
    quick work of repetitive tasks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了一些工具和技术，它们协同工作，使得原本繁琐的环节变得顺畅。Burp Suite 或免费的替代工具 OWASP ZAP，都提供了扩展功能的方式，并且可以快速完成重复性任务。
- en: We've also looked at an easy way to obfuscate code that may end up on a target
    system. When dropping a custom shell on a server, it's a good idea to hide its
    true function. A passing blue teamer may not look twice if the code looks overly
    complex. We've used tools to quickly transform our generated backdoor into a less conspicuous
    output.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了一种简单的方法，用来混淆可能最终出现在目标系统上的代码。当在服务器上放置自定义 shell 时，最好隐藏其真实功能。如果代码看起来过于复杂，路过的蓝队成员可能不会多看一眼。我们使用了一些工具，快速将生成的后门转化为一个不那么显眼的输出。
- en: Finally, building on the previous chapter's out-of-band vulnerability discovery
    techniques, we leveraged Burp's Collaborator server to streamline the whole process.
    Collaborator is an indispensable tool and, if possible, should always be enabled
    when attacking web applications. In the next chapter, we will switch gears and
    look at exploiting an interesting class of vulnerabilities related to object serialization.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，基于前一章中提到的带外漏洞发现技术，我们利用 Burp 的 Collaborator 服务器来简化整个过程。Collaborator 是一个不可或缺的工具，如果可能，应该在攻击
    Web 应用时始终启用。在下一章中，我们将切换话题，研究如何利用与对象序列化相关的有趣漏洞类别。
- en: In the next chapter, we will switch gears and look at an increasingly common
    vulnerability type, which could be devastating if exploited successfully. Deserialization
    attacks are here to stay and we will dig a bit deeper into how they work and how
    to exploit them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将切换话题，研究一种越来越常见的漏洞类型，如果成功利用，可能会带来毁灭性的后果。反序列化攻击将长期存在，我们将深入了解它们是如何工作的以及如何利用它们。
