- en: Catch Me If You Can!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追捕我吧！
- en: In today's world, bypassing and hijacking software is all over the internet.
    However, clear usage and execution is what makes you a good amateur hacker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界里，绕过和劫持软件在互联网上到处都是。然而，明确的使用和执行方式才是让你成为一名优秀的业余黑客的关键。
- en: This can be achieved by choosing your tools correctly and following the necessary
    processes to complete the tasks at hand impeccably.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过正确选择工具并遵循必要的过程，完美地完成手头的任务来实现。
- en: 'In this chapter, we''ll cover the following topics to help you achieve this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，帮助你实现这一目标：
- en: Bypassing host-based firewalls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过基于主机的防火墙
- en: Hijacking IE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 劫持IE
- en: Bypassing repudiation filtering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过拒绝过滤
- en: Interacting with SourceForge
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SourceForge互动
- en: Interacting with Google Forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Google Forms互动
- en: Bypassing botnet filtering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过僵尸网络过滤
- en: Bypassing IPS with handmade XOR encryption
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用手工XOR加密绕过IPS
- en: Bypassing host-based firewalls
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过基于主机的防火墙
- en: In all our previous chapters, we assumed that any process on the target machine
    can initiate a session to the internet without any restrictions. Now, in many
    enterprise networks, they don't rely on the built-in Windows Firewall. Instead,
    they use an advanced host-based firewall to limit what process can initiate a
    session to the internet, just like how the access lists work. So, for instance,
    let's assume that the system administrator has allowed only some business-needed
    processes to access the internet. For example, let's say that the system administrator
    allowed the Windows update and the antivirus update, as well as the most common
    browsers, such as Chrome, Internet Explorer, and Firefox. So, only these processes
    are allowed to reach over the internet; any other process will be blocked. By
    implementing such a policy, our backdoor has no chance to survive since it won't
    be listed in the administrator list by default. Eventually, we don't get any shell
    to the attacker machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有章节中，我们假设目标机器上的任何进程都可以在没有任何限制的情况下启动与互联网的连接。现在，在许多企业网络中，他们不再依赖内置的Windows防火墙。相反，他们使用高级的基于主机的防火墙来限制哪些进程可以启动与互联网的连接，就像访问控制列表（ACL）一样工作。因此，假设系统管理员只允许一些业务所需的进程访问互联网。例如，假设系统管理员允许Windows更新和杀毒软件更新，以及常见的浏览器，如Chrome、Internet
    Explorer和Firefox。因此，只有这些进程被允许访问互联网，其他任何进程都会被阻止。通过实施这样的策略，我们的后门无法存活，因为它默认不会列入管理员的允许列表。最终，我们无法获得对攻击者机器的shell。
- en: However, if we find a way to somehow control **Internet Explorer** (**IE**)
    on our behalf using our Python script and then force it to connect to our Kali
    HTTP server in the background and transfer commands back and forth, then we can
    bypass the host-based firewall policy here. Microsoft offers **Component Object
    Model** (**COM**) to enable interprocess communication and programmatically create
    an object to control and automate multiple Microsoft products, such as Outlook,
    Internet Explorer, Word, and Excel. Internet Explorer is a built-in browser in
    all Windows versions; so, it should be available all the time in our target and
    is usually whitelisted to security administrators as it is considered as a backup
    browser in case other browsers fail. Another benefit of making Internet Explorer
    initiate the connection on our behalf is if the target was using an internal proxy
    before connecting to the internet, then you don't have to worry about knowing
    the proxy information as Internet Explorer will take care of this on our behalf.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们找到一种方法，能够利用我们的Python脚本某种方式控制**Internet Explorer**（**IE**），然后迫使它在后台连接到我们的Kali
    HTTP服务器并来回传输命令，那么我们就能绕过基于主机的防火墙策略。微软提供了**组件对象模型**（**COM**），以支持进程间通信，并通过编程方式创建对象来控制和自动化多个微软产品，如Outlook、Internet
    Explorer、Word和Excel。Internet Explorer是所有Windows版本中内置的浏览器；因此，它应该始终可用，并且通常被安全管理员列为白名单中的备份浏览器，以防其他浏览器无法使用。让Internet
    Explorer代替我们发起连接的另一个好处是，如果目标在连接互联网之前使用了内部代理，那么你不必担心知道代理信息，因为Internet Explorer会为我们处理这一切。
- en: So, what we'll do here is we'll assume that the host-based firewall only allows
    some process such as antivirus, Firefox, Internet Explorer, or Windows Update,
    and nothing else. In response to this, in our Python script, we will define a
    COM object to control Internet Explorer. Then, we will make Internet Explorer
    navigate to our HTTP server, which is located on the Kali machine, and get the
    command to execute it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在这里做的是假设主机防火墙只允许某些进程，如杀毒软件、Firefox、Internet Explorer或Windows更新，其他的都不允许。为此，在我们的Python脚本中，我们将定义一个COM对象来控制Internet
    Explorer。然后，我们将让Internet Explorer导航到我们位于Kali机器上的HTTP服务器，并获取需要执行的命令。
- en: Once we get the command that we need to execute, we will initiate a subprocess.
    We retrieve the command to EXE. Then, using the COM object, we will take it back
    using our Python script and initiate the `cmd.exe` as a subprocess. The result
    for the command, using the COM object we will pass it to Internet Explorer and
    then post it to our website, which is located on the Kali machine here. If you
    remember, this technique is very similar to our previous HTTP reverse shell, but
    the key difference here is that we use Internet Explorer as our web client instead
    of using the `requests` library, as we did earlier. The end result, from the host-based
    firewall's perspective, is that the Python script did not initiate any session
    to the outside world, it was Internet Explorer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到需要执行的命令，我们将启动一个子进程。我们检索命令并传递给EXE。然后，使用COM对象，我们将通过Python脚本将其返回并启动`cmd.exe`作为子进程。使用COM对象获取的命令结果，我们会将其传递给Internet
    Explorer，然后将其发布到我们位于Kali机器上的网站。如果你记得，这种技术与我们之前的HTTP反向Shell非常相似，但这里的关键区别是我们使用Internet
    Explorer作为我们的Web客户端，而不是像之前那样使用`requests`库。从主机防火墙的角度来看，最终的结果是，Python脚本并没有启动任何外部会话，而是Internet
    Explorer启动了会话。
- en: The following link will provide more insight on COM protocol:  [http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm.](http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将提供有关COM协议的更多信息：[http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm](http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm)
- en: Hijacking IE
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 劫持IE
- en: 'As always, coding with Python will make your life much easier. Now, to use
    COM in Python, you just need a Python for Windows or `pywin` library. Since we''ve
    already installed this library while creating our previous key-logger, we won''t
    cover that again here. Now, let''s jump to the coding part:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，使用Python编程将使你的生活更加轻松。现在，要在Python中使用COM，你只需要安装Python for Windows或`pywin`库。由于我们在创建之前的键盘记录器时已经安装了这个库，这里就不再详细讲解了。现在，让我们进入编码部分：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we start by creating an `InternetExplorer` object instance and set the
    Visible option to 0, which means that Internet Explorer will run in the background.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过创建一个`InternetExplorer`对象实例并将Visible选项设置为0，意味着Internet Explorer将在后台运行。
- en: If we set the value to 1, then Internet Explorer window will show up to the
    target desktop and this is something we don't want.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将值设置为1，那么Internet Explorer窗口将显示到目标桌面上，这是我们不希望发生的。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we start by going into an infinite loop, and navigate to our Kali IP address.
    We will wait for the browser to finish loading. If the browser doesn't load the
    page entirely, we will sleep for one second. Note that, when the browser has finished
    loading, `ReadyState` will have a value of `4` and the second loop will be terminated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始进入一个无限循环，并导航到我们的Kali IP地址。我们将等待浏览器完成加载。如果浏览器没有完全加载页面，我们会休眠一秒钟。请注意，当浏览器加载完成时，`ReadyState`的值为`4`，此时第二个循环将被终止。
- en: Next, we retrieve the HTML page into a variable called `command`; then, we convert
    the HTML entities into `unicode`. Finally, we encode the command into ASCII string
    and ignore any exception, which may have occurred while doing so. The final result
    will be the command that we should execute and we will print it out. As with our
    previous shells, if we get a `terminate` command from the Kali machine, we will
    quit Internet Explorer instance and `break` the loop. If the command was not terminated,
    then we inject the command into a shell and store the result in a variable called
    `Data`. Now, in order to submit or post the `Data` using the COM technique, it
    requires to `buffer` the `Data` first, and we used a built-in Python `buffer()`
    function to do so. Then, at the end, we post the command execution result along
    with the `POST` parameters, which we defined earlier. We have never used `Flags`
    or `TargetFrame`, so we set them to their default values. The main parameter here
    is the `dURL`, which defines the destination URL that we wish to submit the data
    for.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将HTML页面加载到一个名为`command`的变量中；然后，我们将HTML实体转换为`unicode`。最后，我们将命令编码为ASCII字符串，并忽略在此过程中可能发生的任何异常。最终结果将是我们应该执行的命令，并且我们会将其打印出来。与我们之前的Shell一样，如果我们从Kali机器获得`terminate`命令，我们将退出Internet
    Explorer实例并`break`循环。如果命令没有终止，我们就将命令注入到Shell中，并将结果存储在一个名为`Data`的变量中。现在，为了使用COM技术提交或发布`Data`，首先需要对`Data`进行`buffer`处理，我们使用了Python内置的`buffer()`函数来实现这一点。最后，我们将命令执行结果与之前定义的`POST`参数一起提交。我们从未使用过`Flags`或`TargetFrame`，所以我们将它们设置为默认值。这里的主要参数是`dURL`，它定义了我们希望提交数据的目标URL。
- en: 'Let''s jump to the attacker side a little bit and here we had the exact HTTP
    web server that we used earlier in our HTTP reverse shell. After starting the
    script on the target side, Internet Explorer will start in the background, as
    we can see from the Windows Task Manager''s Processes tab in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微跳到攻击者的一方，这里我们使用的正是之前在HTTP反向Shell中使用的那个HTTP Web服务器。启动目标端脚本后，Internet Explorer将在后台启动，正如我们从以下截图中的Windows任务管理器的进程标签可以看到的那样：
- en: '![](../images/00050.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00050.jpeg)'
- en: 'As you can see, it''s totally invisible to the user. The IE is running, but
    as we can see, the GUI is not showing up in the Applications tab. On executing `ipconfig`
    on the Kali machine, at the victim side, we get the `ipconfig` command. Let''s
    go for directories and other commands. You can also perform a quick `ping 10.10.10.100`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它对用户完全不可见。IE正在运行，但正如我们所看到的，GUI并没有出现在应用程序标签中。在受害者端的Kali机器上执行`ipconfig`命令时，我们获得了`ipconfig`命令的输出。接下来，我们可以访问目录以及执行其他命令。你还可以执行一个快速的`ping
    10.10.10.100`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The outputs will be similar to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We got our shell fully functional here. So, one more time, let''s just explain
    what just happened here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Shell已经完全可用了。那么，再次解释一下刚刚发生了什么：
- en: Our Python script has initiated an Internet Explorer process in the background
    and we have used Internet Explorer to navigate to our command and control the
    server on the Kali side.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的Python脚本在后台启动了Internet Explorer进程，并且我们使用Internet Explorer导航到Kali端的命令和控制服务器。
- en: Then, we transferred the data using `GET` and `POST` back and forth between
    them.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过`GET`和`POST`方法在它们之间来回传输数据。
- en: Now, at the end, note that it's not only limited to a shell. You can also transfer
    files and submit data using COM protocol.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，最后注意，这不仅限于一个Shell。你还可以通过COM协议传输文件和提交数据。
- en: We will leave it to you to discover the other features that you can do with
    a COM protocol.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将留给你去发现使用COM协议时可以做的其他功能。
- en: Bypassing reputation filtering in next generation firewalls
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过下一代防火墙中的信誉过滤
- en: Next-generation firewalls are all-in-one firewalls. They have all the security
    features, such as IPS, antivirus, anti-spam, and reputation filtering, in a single
    box. In this section, we will discuss a major security feature, which can prevent
    us from getting our shell on our target. Now, let's assume that we were able to
    plant our Python reverse shell successfully on our target machine. Now, in a traditional
    firewall, if the **access control list** (**ACL**) was allowing the traffic to
    the outside, then we will get our shell back successfully. But if the firewall
    was doing reputation filtering, then what will happen is that once the client
    initiates a session back to our Kali machine and reaches the firewall, the firewall
    will do a lookup and check on the destination IP. Then, it checks whether the
    destination IP belongs to a malicious site. This checking is based on an IP pool,
    which is a list of an IP that the firewall will download from the vendor database.
    So, if this is a Cisco firewall, it will use a Cisco database. If this firewall
    was a Palo Alto, it would use a Palo Alto pool. This database or a pool contains
    a large list of IPs with its reputation rank.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一代防火墙是集成式防火墙。它们在一个设备中具备所有安全功能，如 IPS、杀毒、反垃圾邮件和信誉过滤等。在这一部分中，我们将讨论一个重要的安全功能，它可以防止我们在目标上成功获取
    shell。现在，假设我们已经成功在目标机器上植入了 Python 反向 shell。现在，在传统防火墙中，如果**访问控制列表**（**ACL**）允许外部流量，则我们会成功获取到
    shell。但如果防火墙正在进行信誉过滤，那么一旦客户端发起会话并返回到我们的 Kali 机器并到达防火墙时，防火墙将进行查找并检查目标 IP。然后，它会检查目标
    IP 是否属于恶意网站。这个检查是基于 IP 池进行的，IP 池是防火墙从厂商数据库下载的 IP 列表。因此，如果是 Cisco 防火墙，它会使用 Cisco
    数据库。如果是 Palo Alto 防火墙，它会使用 Palo Alto 池。这个数据库或池包含了大量带有信誉排名的 IP 列表。
- en: For example, let's say in the IP or in the database we have an IP of `1.1.1.1`
    and it has a rank of `10`, which means it can totally be trusted. Also, we have
    an IP of `2.2.2.2`, which has a low rank of `2`. This means that it has been reported
    as a malicious IP. Let's say that the attacker IP address was `3.3.3.3`. When
    the initiated session reaches the firewall with the destination IP address of
    `3.3.3.3`, if this IP was not whitelisted and has a low rank in the IP database,
    then the firewall will drop the traffic and log the decision to the administrator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在 IP 或数据库中有一个 IP 地址 `1.1.1.1`，它的排名为 `10`，意味着它完全可以信任。同时，我们还有一个 IP 地址 `2.2.2.2`，它的排名较低为
    `2`，这意味着它被报告为恶意 IP。假设攻击者的 IP 地址是 `3.3.3.3`。当发起的会话到达防火墙，并且目标 IP 地址为 `3.3.3.3` 时，如果这个
    IP 没有被列入白名单，并且在 IP 数据库中的排名较低，那么防火墙将丢弃该流量，并将此决策记录到管理员日志中。
- en: The idea here is to use a server or website such as Google Forms to submit a
    text or maybe to use SourceForge to upload the files. The benefit of doing so
    is, firstly, these two servers or services are very well-known and have a high
    reputation rank out of `10`. So, we are expecting to see [https://www.google.com](https://www.google.com)
    or Google Forms in the IP pool or on the IP database with a rank of `10`. Secondly,
    it may have never been flagged as suspicious to the security administrator or
    to anyone watching the traffic in real time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是使用像 Google Forms 这样的服务器或网站提交文本，或者可能使用 SourceForge 上传文件。这样做的好处是，首先，这两个服务器或服务都非常知名，且在
    `10` 分制中的信誉排名很高。因此，我们预计会在 IP 池或 IP 数据库中看到[https://www.google.com](https://www.google.com)或
    Google Forms，且其排名为 `10`。其次，它可能从未被安全管理员或实时监控流量的人员标记为可疑。
- en: Interacting with SourceForge
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 SourceForge 互动
- en: In this section, we will see how easily we can upload files to SourceForge.
    SourceForge is usually whitelisted from the reputation filtering perspective and
    probably never looked by security administrators. SourceForge provides multiple
    ways to interact with its repository. We will be using SCP, which is transferring
    the file over an SSH session. Now, creating an account in SourceForge is easy
    and hence we will skip this part. Before we start, take a minute and read the
    SourceForge documentation for using SCP and the format needed, [https://sourceforge.net/p/forge/documentation/SCP/](https://sourceforge.net/p/forge/documentation/SCP/).
    I'll log into my account, which I have already created and proceed to my profile.
    There, I have created a project called `Test` with zero files currently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何轻松地将文件上传到 SourceForge。从声誉过滤的角度来看，SourceForge通常是白名单的，可能从未被安全管理员关注过。SourceForge提供多种与其存储库交互的方式。我们将使用SCP，这是通过SSH会话传输文件。现在，在
    SourceForge 创建帐户很容易，因此我们将跳过这部分。在开始之前，花一分钟阅读 SourceForge 有关使用SCP和所需格式的文档，[https://sourceforge.net/p/forge/documentation/SCP/](https://sourceforge.net/p/forge/documentation/SCP/)。我将登录我的账户，我已经创建了一个名为`Test`的项目，目前没有任何文件。
- en: 'Let''s go to the coding part right now. We will be using two libraries to get
    our job done:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们立即进入编码部分。我们将使用两个库来完成我们的工作：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first library is `paramiko`.  `paramiko` is a Python implementation of the
    SSHv2 protocol, providing both client and server functionality. The `scp` is a
    higher library built over `paramiko` that is used to transfer the file in just
    a matter of a single line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个库是`paramiko`。`paramiko`是 SSHv2 协议的 Python 实现，提供客户端和服务器功能。`scp`是在`paramiko`之上构建的更高级库，用于在一行代码中传输文件。
- en: Before using any of these libraries, a prerequisite library called `PyCrypto` has
    to be installed first from [http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto). The
    steps are rather straight forward.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些库之前，必须首先安装一个名为`PyCrypto`的先决条件库，从[http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto)下载。步骤非常简单。
- en: 'The next step is to install `paramiko` using the `pip` command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`pip`命令安装`paramiko`：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last step is to install the `scp` library. If you face any problems with
    the library setup script, simply copy the library manually into Python site-packages
    directory. Simply paste the scp script by navigating to Python27 | Lib | site-packages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是安装`scp`库。如果在库设置脚本中遇到任何问题，只需将库手动复制到Python site-packages目录中。只需通过导航到Python27
    | Lib | site-packages粘贴scp脚本。
- en: 'Lets look into rest of the script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看剩下的脚本：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, our script will start with creating an `ssh_client` instance using the `paramiko.SSHClient()`
    class. Now, when you connect to an SSH server for the first time and if the SSH
    server keys are not stored on the client side, you will get a warning message
    saying that the server keys are not cached in the system; it will prompt you to
    accept these keys.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的脚本将从使用`paramiko.SSHClient()`类创建一个`ssh_client`实例开始。现在，当您第一次连接到 SSH 服务器并且如果
    SSH 服务器密钥未存储在客户端端，您将收到一个警告消息，指出服务器密钥未缓存在系统中；它将提示您接受这些密钥。
- en: 'Open PuTTY software, connect to the SourceForge server with `web.sourceforge.net`
    as the hostname, port `22`, and protocol SSH. Now, click on Open:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 PuTTY 软件，使用`web.sourceforge.net`作为主机名，端口`22`，协议为 SSH 连接到 SourceForge 服务器。现在，点击打开：
- en: '![](../images/00051.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00051.jpeg)'
- en: We will get a warning pop up because the keys are not cached in the system.
    Now, since we perform an automation, we will inform `Paramiko` to accept these
    keys for the first time without interrupting the session or prompting the user
    for it. This will be done via  `client.set_missing_host_key_policy`, then `AutoAddPolicy()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到一个警告弹出窗口，因为密钥未缓存在系统中。现在，由于我们执行自动化，我们将通知`Paramiko`在第一次接受这些密钥时不中断会话或提示用户。这将通过`client.set_missing_host_key_policy`，然后`AutoAddPolicy()`完成。
- en: The next step in the code block is to define the SourceForge server name that
    we want to connect and upload our file to. Also, we provide the login credentials.
    After providing `username` and `password`, we will authenticate ourselves to the
    SourceForge server. After a successful authentication, the SSH session ID will
    be passed to the `SCPClient()` function and the `get_transport()` function will
    return the session ID for us. Now, after performing this step, all we have to
    do is specify the file path that we want to exfiltrate and upload it to our repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块中的下一步是定义我们要连接的 SourceForge 服务器名称，并上传我们的文件。我们还提供了登录凭据。在提供了 `username` 和 `password`
    后，我们将通过 SourceForge 服务器进行身份验证。身份验证成功后，SSH 会话 ID 将传递给 `SCPClient()` 函数，并且 `get_transport()`
    函数将返回该会话 ID。完成此步骤后，我们所要做的就是指定要导出的文件路径，并将其上传到我们的仓库。
- en: In this example, I have used Module 5 or the `M5.pdf` file. So, we will use
    the `put()` function from the SCP to perform the upload and in the end we will
    close the session using the `.close()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了第 5 模块或 `M5.pdf` 文件。因此，我们将使用 SCP 中的 `put()` 函数来执行上传，最后通过 `.close()`
    函数关闭会话。
- en: 'After running the script, we will get a successful authentication message as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，我们将收到以下成功认证信息：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s jump to the attacker side and verify that we got the file. First,
    install FileZilla FTP client to access our repository:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到攻击者端，验证我们是否得到了文件。首先，安装 FileZilla FTP 客户端来访问我们的仓库：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the software by running `filezilla` and enter the name of the server/hostname,
    username, password, and port number, as entered previously in the script to log
    into your account. A warning message will be presented because we have logged
    in for the first time, and if we scroll a little bit we can see that we got our
    file. `M5` has been uploaded here successfully as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`filezilla`打开软件，并输入先前在脚本中输入的服务器名称/主机名、用户名、密码和端口号，以登录您的帐户。由于这是第一次登录，会出现警告信息，如果我们稍微向下滚动，就可以看到文件已经成功上传。`M5`
    文件已经成功上传，以下截图显示了这一点：
- en: '![](../images/00052.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00052.jpeg)'
- en: Try to download this file by right-clicking on the filename and selecting Download.
    The console prints that the file has been transferred successfully in the absence
    of errors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过右键点击文件名并选择“下载”来下载此文件。如果没有错误，控制台会显示文件已成功传输。
- en: Now, repeat the preceding steps for a `.txt` extension to check whether you're
    successful. Refresh the attacker side and view the contents. Make sure to remove
    the files from your SourceForge repository once the penetration testing assessment
    is finished.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重复上述步骤，使用 `.txt` 扩展名检查是否成功。刷新攻击者侧并查看内容。渗透测试评估完成后，请确保从 SourceForge 仓库中删除文件。
- en: Interacting with Google Forms
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Google Forms 互动
- en: 'In the previous section, we have seen how we can exfiltrate data into the SourceForge
    website. Now, we will use Google Forms to submit normal text. Note that this text
    could be a command execution output for our shell. The point here is, similar
    to SourceForge, Google Forms has a pretty high reputation rank. Follow these steps
    to get started:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们已经看到如何将数据导出到 SourceForge 网站。现在，我们将使用 Google Forms 提交普通文本。请注意，这些文本可能是我们
    Shell 的命令执行输出。这里的关键点是，类似 SourceForge，Google Forms 也有相当高的信誉排名。按照以下步骤开始：
- en: Log in to Google Forms
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 Google Forms
- en: Create a new Google form by clicking Start a new form
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始新表单”创建一个新的 Google 表单
- en: Type the Question as `Isn't Python awesome?`
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将问题输入为 `Python 不是很酷吗？`
- en: In the Response tab keep the default name for the spreadsheet
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“响应”选项卡中，保留电子表格的默认名称
- en: Change type of the Question to Paragraph from the default Multiple choice
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将问题类型从默认的“多项选择”更改为“段落”
- en: Once the form is created, click on Send
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表单后，点击“发送”
- en: Copy the link that is provided to a Notepad or a text file
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提供的链接复制到记事本或文本文件中
- en: Go to the link we copied and submit a trivial text
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问我们复制的链接并提交一个简单的文本
- en: Check the response in the Google Sheet that we created, which will be in your
    Google Drive by this time
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们创建的 Google Sheet 中的响应，到那时它将存储在您的 Google Drive 中
- en: 'Now, we will code a Python script that will submit text data from the target
    side into our Google Form and the best part here is that we can accomplish that
    without having to log in into a Google account. Now, as usual, the best Python
    library to interact with web is `requests`and we have used `requests` in the previous
    sections:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个 Python 脚本，将目标端的文本数据提交到我们的 Google 表单，最棒的是，我们可以在不登录 Google 账户的情况下完成这项工作。像往常一样，最适合与网页交互的
    Python 库是 `requests`，我们在前面的章节中已经使用过 `requests`：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once again, the installation is quite easy: it''s just `pip install requests`.
    Now, what we see here is the `requests` documentation for submitting an HTML form-encoded
    `POST` request:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，安装非常简单：只需执行 `pip install requests`。现在，我们看到的是 `requests` 文档，用于提交 HTML 表单编码的
    `POST` 请求：
- en: '![](../images/00053.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00053.jpeg)'
- en: Now, as per the documentation, we first define the URL for the submit form and,
    in our case, it's the Google form URL. And the second parameter is our data in
    a dictionary format, where we have a `key` and a corresponding value. Keep in
    mind that the `key` is the form name and its value is our text data that we want
    to send.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据文档，我们首先定义提交表单的 URL，在我们的例子中，就是 Google 表单的 URL。第二个参数是我们的数据，以字典格式呈现，其中我们有一个
    `key` 和对应的值。请记住，`key` 是表单名称，而它的值是我们要发送的文本数据。
- en: 'Let''s jump to our Google form link to discover the form name, which will be
    our `key` in the dictionary. Open the source code of the form that we created
    and, in HTML, search for the `Python` string. If you take a close look, you will
    catch the HTML form name for submitting a text. In our case, the form name which
    comes as the value of `<textarea name>` is `entry.1542374001`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到 Google 表单链接，找出表单名称，这将是我们字典中的 `key`。打开我们创建的表单的源代码，在 HTML 中搜索 `Python`
    字符串。如果仔细查看，你会发现提交文本的 HTML 表单名称。在我们的例子中，作为 `<textarea name>` 的值，表单名称是 `entry.1542374001`：
- en: '![](../images/00054.gif)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00054.gif)'
- en: At this point, we have discovered the `key` name, which is what we need to automate
    the process. Remember that the value is the data that we want to send or submit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里为止，我们已经发现了 `key` 名称，这就是我们需要用来自动化这个过程的东西。记住，值是我们想要发送或提交的数据。
- en: 'Copy the form name on a Notepad file for now. Then, we have to go to the previous `Interacting
    with Google Forms` script and fill this information over there. First copy, the
    URL of the form and assign it to the `url` variable below the `import requests`
    line and, at the end, append `/formResponse` after removing the `/viewform` part
    from the URL. Put the form name, `entry.1542374001` , as the key and the data
    for now will be `Hello From Python`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先将表单名称复制到记事本文件中。接着，我们需要返回到之前的`与 Google 表单交互`脚本并在其中填入这些信息。首先复制表单的 URL，并将其赋值给
    `import requests` 行下方的 `url` 变量，最后，去掉 URL 中的 `/viewform` 部分，并在末尾添加 `/formResponse`。将表单名称
    `entry.1542374001` 作为键，暂时将数据设为 `Hello From Python`：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the script. At this point, we have everything in place. Let's run the script
    and if everything is working fine as expected, we should see `Hello From Python`
    added in our form response.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。到目前为止，我们已经准备好了所有内容。让我们运行脚本，如果一切正常如预期，我们应该会在表单响应中看到 `Hello From Python`
    被添加进去。
- en: In the next section, we will see how we can use this script in real world penetration
    testing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将展示如何在实际的渗透测试中使用这个脚本。
- en: Bypassing botnet filtering
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过僵尸网络过滤
- en: 'If you have read the previous sections in order, then at this point you should
    be able to grab a command over Twitter without the need to log into Twitter and
    submit a text into a Google form, also without logging into the Google account.
    Lastly, you should be able to upload files to SourceForge. So, you might be asking:
    what can a hacker do with these services?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照顺序阅读了前面的章节，那么到这一点，你应该能够在不登录 Twitter 和提交文本到 Google 表单的情况下，掌握 Twitter 的命令操作，同时也无需登录
    Google 账户。最后，你应该能够将文件上传到 SourceForge。那么，你可能会问：黑客能用这些服务做什么？
- en: Well, they can send a command such as `ipconfig` as a tweet and then they can
    make multiple infected targets to parse the tweet and execute the commands. After
    executing the commands, we get the execution results, which can be submitted to
    a Google form. Alternatively, if the command syntax or format was containing the
    `grab` keyword, then the target will upload the files into our SourceForge repository.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，他们可以像发布推文一样发送 `ipconfig` 命令，然后让多个感染的目标解析这条推文并执行命令。执行命令后，我们可以将执行结果提交到 Google
    表单。或者，如果命令语法或格式包含 `grab` 关键字，那么目标将会把文件上传到我们的 SourceForge 仓库。
- en: Now, in modern firewalls, the botnet filtering feature is looking for a certain
    criteria or parameter, like the application or protocol being used by the modern
    botnets such as IRC, Dynamic DNS, as well as the number of sessions created from
    the inside to the outside host. All of these will be considered by the modern
    or next-generation firewall to check whether this traffic belonged to a botnet
    or not. Also, there is no need to mention that the reputation filtering is also
    a part of these inspections and filtering.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在现代防火墙中，僵尸网络过滤功能会根据某些标准或参数进行查找，例如现代僵尸网络使用的应用程序或协议，如 IRC、动态 DNS，以及从内部到外部主机创建的会话数量。所有这些都会被现代或下一代防火墙考虑，用来检查这些流量是否属于僵尸网络。此外，不需要多提的是，声誉过滤也是这些检查和过滤的一部分。
- en: The benefits for building a botnet based on well-known servers are that first,
    we don't use IRC channels or Dynamic DNS. Next, we don't have to interact or have
    a direct interaction with the attacker machine. The last point is that all of
    these servers or services are well known and trusted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于知名服务器构建僵尸网络的好处是，首先，我们不使用 IRC 渠道或动态 DNS。接下来，我们不需要与攻击者机器进行直接互动或交互。最后，所有这些服务器或服务都是知名且可信的。
- en: If you do abuse these services and use them out of the lab environment, you
    are violating the terms and agreement, and eventually you will be prosecuted to
    the full extent of law accordingly as per the jurisdiction prevalent in the concerned
    region.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滥用这些服务并在实验室环境之外使用它们，你将违反服务条款和协议，最终根据相关地区的司法管辖区，你将受到法律的追诉。
- en: Keep in mind that my point here is to open your eyes to similar types of attacks,
    so you can be aware of them. So, what I want you to do is challenge yourself and
    try to combine and squeeze all of these scripts into one advanced shell and then
    try to infect multiple virtual machines running Windows 7 within your home lab
    environment. After that, or finally, you will be able to control them and exfiltrate
    data. The last point which we didn't mention up to this section is the encryption.
    In the next section, we will see how easily to build XOR encryption and mask our
    clear-text traffic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我的目的是让你意识到类似类型的攻击，这样你就能警惕它们。所以，我希望你挑战自己，尝试将所有这些脚本合并并压缩成一个高级 Shell，然后尝试在你的家庭实验室环境中感染多台运行
    Windows 7 的虚拟机。之后，或者最后，你将能够控制它们并提取数据。我们在本节中没有提到的最后一点是加密。在下一节中，我们将看到如何轻松地构建 XOR
    加密并掩盖我们的明文流量。
- en: Bypassing IPS with handmade XOR encryption
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手工 XOR 加密绕过 IPS
- en: In this section, we will build a simple XOR encryption in Python. Now, traffic
    encryption is one of the most powerful techniques to evade network analyzer or
    IPS sensors but first, before jumping into the coding part, let's have a quick
    overview on how these devices work in the first place.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将用 Python 构建一个简单的 XOR 加密。现在，流量加密是避开网络分析器或 IPS 传感器的最强大技术之一，但在开始编码之前，让我们先快速了解这些设备最初是如何工作的。
- en: 'Generally speaking, these devices can operate in two modes: the first mode,
    which is the **signature-based mode**, where it inspects the packet parameters
    and data payloads, which are passing through the sensor. Then, similar to an antivirus,
    it checks whether there is any match against its signature database and based
    on the action specified for the matched rule, it may drop or log the traffic.
    The second mode is **behavior-based** or **anomaly-based**, where you install
    the IPS in the network and it will learn the types of the protocol, as well as
    the packet rate passing through the sensor. Then, it''ll build its database or
    its baseline database based on the current network traffic.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这些设备可以在两种模式下运行：第一种模式是**基于签名的模式**，它会检查通过传感器的包参数和数据负载。然后，类似于杀毒软件，它检查是否与其签名数据库有任何匹配，并根据匹配规则指定的操作，可能会丢弃或记录流量。第二种模式是**基于行为**或**基于异常**的模式，在这种模式下，你将
    IPS 安装在网络中，它会学习协议类型以及通过传感器的包速率。然后，它会基于当前的网络流量建立其数据库或基线数据库。
- en: For instance, in a network, let's say that we have 50 PCs that usually use SSH
    to access a remote server. If the IPS is behavior-based, it will learn that on
    average we have 50 SSH sessions and it will create a baseline for this. Later
    on, if any PC has used Telnet, then the IPS will consider this protocol as a suspicious
    activity and may drop the bucket. Although the Telnet session is a legitimate
    one, but since the IPS during the learning phase did not notice any Telnet session,
    it won't be included in the IPS baseline and this incorrect behavior is called
    **false positive**. This is why behavior-based IPSes are not frequently used due
    to these false positives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个网络中，假设我们有50台PC通常使用SSH访问远程服务器。如果IPS是基于行为的，它会学习到平均而言我们有50个SSH会话，并会为此创建基线。后来，如果某台PC使用了Telnet，IPS会认为这个协议是可疑活动，并可能丢弃这个连接。尽管Telnet会话是合法的，但由于IPS在学习阶段没有注意到任何Telnet会话，它不会把它包含在IPS基线中，这种错误的行为被称为**误报**。这就是为什么基于行为的IPS不常使用的原因，因为它们经常出现误报。
- en: 'Now, we will code a very simple XOR encryption to mask our data payload. You''re
    probably thinking: why an XOR encryption? Why not create a SSH or HTTPs shell,
    since these protocols provide encryption by design? Well, I do not recommend this
    because, in many enterprise networks, you may find your target has installed a
    decryption device where it can terminate the SSL and SSH. So basically, once the
    traffic comes into this device, it will convert or remove the encryption from
    these protocols and convert it into clear text before passing it to the IPS sensor
    for inspection. Technically, you won''t have an end-to-end encryption shell and
    if you shall face this decrypter device, you won''t have any added value.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个非常简单的XOR加密来掩码我们的数据负载。你可能会想：为什么是XOR加密？为什么不创建一个SSH或HTTPS shell，因为这些协议本身就提供加密？嗯，我不推荐这样做，因为在许多企业网络中，你可能会发现目标安装了一个解密设备，它可以终止SSL和SSH加密。基本上，一旦流量进入该设备，它会转换或移除这些协议的加密，并在将其传递到IPS传感器进行检查之前，将其转换为明文。技术上来说，你不会拥有端到端加密的shell，如果你遇到这个解密设备，你就没有任何附加值。
- en: Many modern firewalls or next-generation firewalls can terminate the SSL and
    SSH encryption for inspection purposes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代防火墙或下一代防火墙可以终止SSL和SSH加密进行检查。
- en: 'Let''s jump to the coding part:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到编码部分：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look into the first section. We will generate a random key, which will
    be used for XOR encryption. Now, our key should be complex enough and match the
    following criteria: it should contain lowercase, uppercase, digits, and special
    characters here. Now, the `for` loop at the end defines the key size. The key
    size is 1 KB, which, if you remember in our TCP shell, matches the TCP socket
    size. The empty string `.join` at the start will put the result for the random
    strings into a sequence and finally, we will store it in a `key` variable. So,
    all in all, the `for` loop will generate `1024` random strings, which match our
    criteria, and the `.join` is used to gather these strings into a sequence.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下第一部分。我们将生成一个随机密钥，用于XOR加密。现在，我们的密钥应该足够复杂，并满足以下标准：它应包含小写字母、大写字母、数字和特殊字符。现在，最后的`for`循环定义了密钥的大小。密钥的大小是1
    KB，这在我们的TCP shell中，如果你记得的话，与TCP套接字大小相匹配。开始的空字符串`.join`将把随机字符串的结果放入一个序列，最后我们将其存储在`key`变量中。总的来说，`for`循环将生成`1024`个符合我们标准的随机字符串，而`.join`用于将这些字符串汇集成一个序列。
- en: 'On running the code, a key for length `1024` will be generated that we can
    use for encryption. If you run the script one more time, you will get a totally
    different key with the same size:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，将生成一个长度为`1024`的密钥，我们可以用来进行加密。如果你再运行一次脚本，你会得到一个完全不同但大小相同的密钥：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the second part of XOR encryption, keep in mind that the key size should
    be equal to or greater than the clear-text message. We will pass two values to
    the dedicated function `str_xor()`. The first parameter, `s1`, is the message
    that we want to encrypt or decrypt and the second parameter, `s2`, is the XOR
    key. Notice that the same `key` is used for both the encryption and decryption
    processes. Also, the message could be the encrypted message that we want to decrypt
    or the clear-text message that we want to encrypt. So, the XOR operation is exactly
    the same when we encrypt or decrypt. The only difference is that when we encrypt,
    we pass the message in a clear text and when we want to decrypt, we pass the encrypted
    message. The following line from the `XOR Encryption` script does both the XOR
    encryption and decryption for us:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XOR 加密的第二部分，请记住密钥的大小应该等于或大于明文消息。我们将两个值传递给专用函数 `str_xor()`。第一个参数 `s1` 是我们要加密或解密的消息，第二个参数
    `s2` 是 XOR 密钥。请注意，使用相同的 `key` 进行加密和解密。消息可以是我们想要解密的加密消息，也可以是我们想要加密的明文消息。因此，XOR
    操作在加密和解密时是完全相同的。唯一的区别是，在加密时，我们传递明文消息，而在解密时，我们传递加密消息。以下这行来自 `XOR Encryption` 脚本的代码会为我们同时执行加密和解密：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, first, we split the message and the XOR key to a list of character pairs
    in a tuples format. Next, we will go through each tuple and convert them into
    integers using the `ord()` function. Now, once they're converted into integers,
    we can perform an exclusive XOR on them. Then, in the last part, we will convert
    the result back to ASCII, using the character or the `chr()`, function. In the
    end, we will merge the resulting array of characters as a sequence, using the
    `.join()` function here. So, in summary, we will print the clear-text message
    then the encrypted version, and finally, the decrypted one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先，我们将消息和 XOR 密钥分割为一对对字符的列表，格式为元组。接下来，我们将遍历每个元组，并使用 `ord()` 函数将其转换为整数。现在，一旦它们转换为整数，我们就可以对它们执行排他性
    XOR 操作。然后，在最后部分，我们将使用字符函数 `chr()` 将结果转换回 ASCII。最后，我们将通过 `.join()` 函数将结果字符数组合并成一个序列。所以，总结起来，我们将首先打印明文消息，然后是加密后的版本，最后是解密后的消息。
- en: After running the script, you'll see in the output the XOR key, the message
    that we passed, the encrypted message, and the decrypted message.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你将在输出中看到 XOR 密钥、我们传递的消息、加密后的消息以及解密后的消息。
- en: Each time we run the script, a new key will be generated and hence a new encrypted
    message will show up.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行脚本时，都会生成一个新的密钥，因此会显示一个新的加密消息。
- en: Once you generate your XOR key, make sure that the same key is hardcoded into
    your Kali server script and the Windows backdoor; otherwise, you won't be able
    to decrypt your messages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了 XOR 密钥，请确保将相同的密钥硬编码到你的 Kali 服务器脚本和 Windows 后门中，否则你将无法解密你的消息。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered a wide range of topics ranging from bypassing
    firewalls to interacting with websites. We've performed these tasks after usage
    of various tools and different methodologies, which enabled us to attack the victim
    machine with our attacker machine or encrypt and decrypt our messages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从绕过防火墙到与网站交互的广泛话题。我们在使用各种工具和不同方法的基础上，完成了这些任务，从而能够通过攻击者机器攻击受害者机器或加密解密我们的消息。
- en: In this next chapter, we'll cover privilege escalations pertaining to weak service
    file permissions, preparing vulnerable software, breaching legitimate windows
    service via a backdoor, and creating a new admin account.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论与弱服务文件权限相关的特权提升，准备易受攻击的软件，通过后门侵入合法的 Windows 服务，以及创建新的管理员账户。
