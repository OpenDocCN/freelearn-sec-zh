- en: Patching Legacy Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修补遗留代码
- en: A few years ago, I had an opportunity to work on an interesting project--I was
    contacted by a business owner who was left with an unusable executable, locked
    by a disgraceful developer who took the money and disappeared. Having no source
    code, the only option was to patch the executable in order to change the execution
    flow and bypass the lock.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我有机会参与一个有趣的项目——我接到了一个商家老板的电话，他因一个可悲的开发者锁死了可用的可执行文件，而该开发者拿了钱就消失了。由于没有源代码，唯一的选择是修补可执行文件，以更改执行流程并绕过锁定。
- en: 'Unfortunately, this is not an isolated case. It happens quite often that an
    old tool, which has been around for years (if not decades), needs to be slightly
    changed and then... well, then there are at least two options:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不是一个孤立的案例。老旧工具经常出现需要稍微更改的情况（即使已经存在多年，甚至几十年），然后……嗯，至少有两个选择：
- en: The source code has been lost and there is no way to rebuild the executable
    after applying changes.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码丢失，无法在应用更改后重新构建可执行文件。
- en: The source code is there, but it appears to be so old that it cannot even be
    compiled with modern compilers without rewriting it almost from scratch. In this
    case, even if rewriting is not a big issue, the possibility of libraries used
    with the software being incompatible with modern compilers or their output, which
    would make the whole project significantly more complicated, is still there.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码存在，但似乎已经老旧到无法用现代编译器编译，几乎需要从头重写。在这种情况下，即使重写不是大问题，但与软件一起使用的库可能与现代编译器或其输出不兼容，这将使整个项目变得更加复杂，问题依然存在。
- en: Depending on the complexity of changes that are needed to be applied, simply
    patching the binary executable file with new code may be a sufficient option as
    it is definitely simpler to put a few bytes in a hex editor rather than reverse-engineer
    a tool (either its binary form or old source code, which may no longer be supported
    by compilers) and rewrite it from scratch.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要应用的更改复杂度，直接用新代码修补二进制可执行文件可能是一个足够的选择，因为将几个字节放入十六进制编辑器要比逆向工程一个工具（无论是其二进制形式还是已经不再被编译器支持的旧源代码）并从头重写它更简单。
- en: In this chapter, we will consider a very simplistic example of an executable
    that needs a security fix. We will create the executable ourselves for both Windows
    and Linux, and we'll, first of all, examine the options and then apply a binary
    patch. As we will be targeting two platforms, we will address the formats of PE
    and ELF files where needed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑一个非常简单的可执行文件示例，目标是进行安全修复。我们将分别为 Windows 和 Linux 创建可执行文件，并首先研究可用的选项，然后应用二进制补丁。由于我们将面向两个平台，我们将在需要时讨论
    PE 和 ELF 文件格式。
- en: The executable
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可执行文件
- en: 'As was mentioned earlier, we have to create the executable first. It appeared
    to be a relatively hard task to find a real-life example simple enough to fit
    the chapter, so the decision was made to take a real-life problem and wrap it
    with simplistic code. We will write the code for our executable in C and compile
    with Visual Studio 2017 when on Windows and GCC when on Linux. The code will be
    as simple as this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们必须首先创建可执行文件。寻找一个足够简单、贴合本章内容的现实示例似乎是一个相对困难的任务，因此我们决定采用一个现实中的问题，并用简化的代码进行封装。我们将用
    C 语言编写可执行文件的代码，并在 Windows 上使用 Visual Studio 2017 编译，在 Linux 上使用 GCC 编译。代码将简单如以下所示：
- en: '![](img/a728544b-33d1-406a-b721-52d8b4d9b39f.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a728544b-33d1-406a-b721-52d8b4d9b39f.png)'
- en: As we may see, the only thing this code is capable of is reading user input
    as a string into a 128-byte buffer, allocating an internal buffer specifically
    for the input string, copying the input string there, and printing it from the
    internal buffer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这段代码唯一能够做的，就是将用户输入作为字符串读取到一个 128 字节的缓冲区中，为输入字符串分配一个内部缓冲区，将输入字符串复制到其中，并从内部缓冲区打印它。
- en: Create a new solution in Visual Studio 2017, name it `Legacy`, and fill the
    preceding illustrated code to its `main.cpp` file. Personally, I prefer to use
    the `.c` extension when writing in C and set the Compile As option (which can
    be found by navigating to Configuration Properties | C/C++ | Advanced in the project
    properties window) to C.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2017 中创建一个新的解决方案，命名为`Legacy`，并将前面展示的代码填入其`main.cpp`文件。个人来说，我更喜欢在编写
    C 代码时使用 `.c` 扩展名，并将“编译方式”选项（可以在项目属性窗口中通过导航到配置属性 | C/C++ | 高级找到）设置为 C。
- en: 'The process of building the executable out of the preceding code is quite straightforward,
    except for one detail with Visual Studio 2017\. As we are attempting to fake a
    `Legacy` executable, we need to disable Linker''s Dynamic Base option. While in
    Visual Studio, right-click on the project and select Properties. The following
    screenshot illustrates where the Dynamic Base option may be found:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码构建成可执行文件的过程非常简单，除了一个关于 Visual Studio 2017 的细节。当我们尝试伪造一个`Legacy`可执行文件时，我们需要禁用链接器的动态基址选项。在
    Visual Studio 中，右键点击项目并选择“属性”。以下截图展示了动态基址选项的位置：
- en: '![](img/60ce97b7-f1f3-4ab5-b224-c724373126f4.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60ce97b7-f1f3-4ab5-b224-c724373126f4.png)'
- en: Once this option has been disabled, simply click on Build or Build All.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦禁用此选项，只需点击“构建”或“全部构建”即可。
- en: 'On Linux, however, we may simply build the executable the usual way by entering
    one of the following commands in the terminal (ignore the warning for now):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Linux 上，我们可以通过在终端输入以下命令之一，像往常一样构建可执行文件（现在先忽略警告）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we will begin by patching the Windows executable first, then
    we will proceed to the Linux executable and see how the problem may be solved
    in the case of ELF. Oh, and most importantly; forget about the C sources and pretend
    that we do not have them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先修补 Windows 可执行文件，然后继续修补 Linux 可执行文件，并查看如何在 ELF 的情况下解决问题。哦，最重要的是；忘记
    C 源代码，假装我们没有它们。
- en: The issue
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Whether we try to run our executables on Windows or on Linux, we would hardly
    notice any problem, as the program asks for our name and then prints it back.
    This will keep working in a stable manner as long as the program does not encounter
    a name longer than 127 ASCII characters (the 128^(th) character is the terminating
    `NULL` value) and such names exist. Let''s try to run this executable (we are
    referring to the one built for Windows, but the same idea applies to the Linux
    executable too) and feed it with a long line of text, much longer than 127 characters.
    This is what will happen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们尝试在 Windows 还是 Linux 上运行我们的可执行文件，都几乎不会发现任何问题，因为程序会要求输入我们的名字并将其打印出来。只要程序没有遇到超过
    127 个 ASCII 字符的名字（第 128 个字符是结束的 `NULL` 值），这种方式将稳定工作，然而，确实存在这样的长名字。我们来试着运行这个可执行文件（我们指的是为
    Windows 构建的那个，但相同的原理也适用于 Linux 可执行文件），并输入一长串文本，远远超过 127 个字符。结果会是这样：
- en: '![](img/a2459d93-d1f0-4f4b-8f48-7024aae02352.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2459d93-d1f0-4f4b-8f48-7024aae02352.png)'
- en: The reason for this message is the `gets()` function. If C is not your language
    of choice, you may be unaware of the fact that this function does not check the
    length of the input, which may lead to stack corruption in the best case (just
    like what caused the preceding message to appear) and is a vulnerability inviting
    specially crafted exploits in the worst case. Luckily, the solution for the `gets()`
    problem is quite simple; the call to `gets()` has to be replaced by a call to
    the `fgets()` function. Should we have sources, this would be a one minute fix,
    but we don't (at least we are pretending we don't have them).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息的原因是 `gets()` 函数。如果 C 不是你首选的语言，你可能不知道这个函数不会检查输入的长度，这可能导致堆栈破坏（至少像前面那条消息的出现一样），在最坏的情况下，这也是一个漏洞，容易受到精心制作的攻击。幸运的是，解决
    `gets()` 问题的方法非常简单；必须将对 `gets()` 的调用替换为对 `fgets()` 函数的调用。如果我们有源代码，这将是一个一分钟的修复，但我们没有（至少我们假装没有它们）。
- en: However, the solution we will shortly implement is not complex. All we need
    is a disassembler (preferably IDA Pro), a hex editor, and, of course, Flat Assembler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们稍后实现的解决方案并不复杂。我们只需要一个反汇编器（最好是 IDA Pro）、一个十六进制编辑器，当然还有 Flat Assembler。
- en: PE files
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE 文件
- en: In order to successfully implement a patch, we need to understand the PE file
    format (PE stands for portable executable). While a detailed specification may
    be obtained at this URL, [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx),
    we only need to understand a few things about the format and be able to manually
    parse its basic structure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功地实现补丁，我们需要了解 PE 文件格式（PE 代表便携式可执行文件）。虽然可以通过此 URL 获取详细的规格：[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)，但我们只需要了解格式的几个关键点，并能够手动解析其基本结构。
- en: Headers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件
- en: A PE file contains several headers and the first one we encounter is the DOS
    header, which only contains two things that are interesting for us; the first
    is the `MZ` signature and the second is the offset of the file header, also known
    as the PE header (as it is preceded by the `PE\x0\x0` signature). The file header
    contains basic information about the file such as, for example, the number of
    sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PE文件包含多个头部，第一个我们遇到的是DOS头部，它仅包含对我们有用的两个内容；第一个是`MZ`签名，第二个是文件头的偏移量，也就是PE头（因为它之前有`PE\x0\x0`签名）。文件头包含关于文件的基本信息，例如节的数量。
- en: 'Following the PE header is the optional header, which, in turn, contains even
    more interesting information such as `ImageBase`, --the address at which the image
    (file) should preferably be loaded, --and `NumberOfRvaAndSizes`, and the latter
    is of special interest for us. The `NumberOfRvaAndSizes` field denotes the number
    of entries in the array of `IMAGE_DATA_DIRECTORY` entries immediately following
    the optional header. The `IMAGE_DATA_DIRECTORY` structure is defined as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随PE头之后的是可选头部，它包含更有趣的信息，如`ImageBase`——即图像（文件）应加载的首选地址——和`NumberOfRvaAndSizes`，后者对我们特别重要。`NumberOfRvaAndSizes`字段表示紧随可选头部之后的`IMAGE_DATA_DIRECTORY`条目数组中的条目数。`IMAGE_DATA_DIRECTORY`结构定义如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of these structures describes certain areas of the PE file. For example,
    `Import IMAGE_DATA_DIRECTORY`, the one we are particularly interested in, refers
    to information about functions not present in this file, but imported from dynamic
    link libraries.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个结构描述了PE文件的特定区域。例如，`Import IMAGE_DATA_DIRECTORY`，我们特别感兴趣的那个，指的是关于文件中没有的函数的信息，而这些函数是从动态链接库中导入的。
- en: The next would be an array of `IMAGE_SECTION_HEADER` structures, where each
    of the PE sections is described (we are given a section's file offset and size
    as well as its virtual address and virtual size, the size in memory, which may
    and most likely will be different from its size in the file).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`IMAGE_SECTION_HEADER`结构数组，其中描述了每个PE节（我们会得到节的文件偏移量和大小，以及它的虚拟地址和虚拟大小，即内存中的大小，通常与文件中的大小不同）。
- en: 'While I strongly encourage you to read the official specification, I would
    also suggest downloading and installing the best hex editor I have ever seen,
    --010 Editor (available at [https://www.sweetscape.com/010Editor/](https://www.sweetscape.com/010Editor/)).
    This powerful application, in addition to having builds for Windows, mac OS X,
    and Linux, supports templates for easier parsing of different binary formats and
    has a template for parsing of PE files. Take a look at the template''s output;
    --it makes understanding the PE format much easier. Here is how a PE file is displayed
    in 010 Editor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我强烈建议你阅读官方规格，我还建议下载并安装我见过的最好的十六进制编辑器——010 Editor（可以在[https://www.sweetscape.com/010Editor/](https://www.sweetscape.com/010Editor/)下载）。这个强大的应用程序除了支持Windows、macOS和Linux版本，还支持不同二进制格式的模板解析，并且有一个解析PE文件的模板。看看模板的输出——它使理解PE格式变得更加简单。以下是010
    Editor中PE文件的显示方式：
- en: '![](img/58b086a5-924f-4a78-a8c1-2acc74bc137a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58b086a5-924f-4a78-a8c1-2acc74bc137a.png)'
- en: Imports
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'The `gets()` function we are hunting for is dynamically linked from the `ucrtbased.dll`
    file, therefore we should check the import table for it. Using the 010 Editor
    to find and parse the import table, as we see in the following screenshot, is
    not difficult:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的`gets()`函数是从`ucrtbased.dll`文件动态链接的，因此我们应该在导入表中查找它。使用010 Editor来查找并解析导入表，就像我们在下面的截图中看到的那样，并不困难：
- en: '![](img/329cdb1a-6870-4543-8866-f36f789b6bee.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/329cdb1a-6870-4543-8866-f36f789b6bee.png)'
- en: Although it may be (and in fact is) an interesting process to manually parse
    a PE executable, it is much more convenient and easy to use one of the tools available
    out there. For example, IDA Pro would do all the dirty work for us.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管手动解析PE可执行文件可能是一个有趣的过程（事实上确实如此），但使用现有工具会更方便、更轻松。例如，IDA Pro可以为我们完成所有繁琐的工作。
- en: Gathering information
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集信息
- en: Load the `Legacy.exe` file into IDA Pro or any other disassembler of your choice
    as we will now start gathering information about what we have to do in order to
    patch the `Legacy.exe` file and force it to use `fgets()` instead of `gets()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Legacy.exe`文件加载到IDA Pro或任何你选择的反汇编工具中，我们将开始收集关于如何修补`Legacy.exe`文件的信息，并强制它使用`fgets()`代替`gets()`。
- en: Locating calls to gets()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位`gets()`调用
- en: 'We are lucky, in our case, that there is only one call to `gets()`, and we
    know that it should be somewhere around the call to `printf`, which prints the
    `Enter your name:` string. However, let''s take a look at the Strings window in
    IDA Pro:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，因为在我们的案例中，只有一个对`gets()`的调用，而且我们知道它应该出现在调用`printf`的附近，而`printf`打印出`Enter
    your name:`这段字符串。然而，让我们看看IDA Pro中的Strings窗口：
- en: '![](img/d3ee48f7-163f-475d-a788-f9d125d60767.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3ee48f7-163f-475d-a788-f9d125d60767.png)'
- en: 'Finding the string of interest takes a second in the worst case, and once found,
    we simply double-click on it and get to the `.rdata` section of the executable
    where we see the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，找到感兴趣的字符串只需要一秒钟，一旦找到，我们只需双击它，进入可执行文件的`.rdata`部分，在那里我们看到如下内容：
- en: '![](img/27fae41b-f98f-488b-aa63-c3bd8ac18a12.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27fae41b-f98f-488b-aa63-c3bd8ac18a12.png)'
- en: 'Double-clicking on `DATA XREF:` takes us to the place in the code where the
    string is being accessed from:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 双击`DATA XREF:`会带我们到代码中字符串被访问的位置：
- en: '![](img/77b20cb6-90d1-4516-9320-0fe55c872f3a.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77b20cb6-90d1-4516-9320-0fe55c872f3a.png)'
- en: 'Going down just five lines, we see the call to `j_gets`... Why `j_gets`, you
    may ask; aren''t we looking for the `gets()` function''s address and not for jumps
    to it? Of course we are looking for `gets()`; however, since there may have been
    more than one call to `gets()`, the compiler created a single "call hub" for this
    function so that any other code calling `gets()` would, in fact, call `j_gets`
    and then be directed to the real `gets()` function''s address in the import table.
    And this is what we see at the address of `j_gets`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动五行，我们看到对`j_gets`的调用……你可能会问，为什么是`j_gets`？我们不是在寻找`gets()`函数的地址，而是跳转到它吗？当然，我们是在寻找`gets()`；然而，由于可能有多个`gets()`的调用，编译器为此函数创建了一个单独的“调用中心”，这样任何其他调用`gets()`的代码实际上都会调用`j_gets`，然后被引导到实际的`gets()`函数地址，在导入表中。这就是我们在`j_gets`地址看到的内容：
- en: '![](img/f8690e74-895c-4fec-aa43-64b10ad66eae.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8690e74-895c-4fec-aa43-64b10ad66eae.png)'
- en: For now, we only have to take note of the address of the `call j_gets` instruction,
    which is `0x4117Ec`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要注意`call j_gets`指令的地址，它是`0x4117Ec`。
- en: Preparing for the patch
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为补丁做准备
- en: Unfortunately, we cannot simply redirect the call to `fgets()` instead of `j_gets`,
    because we do not have `fgets()` imported at all (as we are not using it in our
    C source) as well as due to the fact that `gets()` takes only one argument (as
    we see at the address `0x4117EB`-`cdecl` passing of a parameter), while `fgets()`
    expects three. Trying to patch the code in place so that it would pass three parameters
    is not possible without damaging the executable and rendering it unusable. This
    means that we need to find a place for shim code, which would add the two additional
    parameters and actually call `fgets()` (once we add it as an imported function).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能简单地将调用重定向到`fgets()`，而不是`j_gets`，因为我们根本没有导入`fgets()`（因为我们在C源代码中没有使用它），而且由于`gets()`只接受一个参数（如我们在地址`0x4117EB`处看到的`cdecl`传递的参数），而`fgets()`需要三个参数。尝试在原地修补代码，以使其传递三个参数是不可能的，这样会损坏可执行文件并使其无法使用。这意味着我们需要为shim代码找到一个位置，该代码将添加两个额外的参数并实际调用`fgets()`（一旦我们将其添加为导入函数）。
- en: 'Fortunately for us, PE sections in memory (and, in fact, in files too) occupy
    much more space than their actual content. This is true in our case as well and
    we need to find where the content of the `.text` section ends; for this reason
    we, first of all, look at where the next section begins, as shown in the following
    screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于我们来说，内存中的PE段（实际上，在文件中也是如此）占用的空间比它们的实际内容要大得多。在我们的例子中也是如此，我们需要找到`.text`段结束的位置；因此，首先我们查看下一个段的开始位置，如下图所示：
- en: '![](img/9deda949-ed11-4c95-83d0-18446fb3ff11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9deda949-ed11-4c95-83d0-18446fb3ff11.png)'
- en: 'As we see in the preceding screenshot, the next section is `.rdata` and the
    beginning of its content is highlighted. Once we are there, we begin to scroll
    up, till we see content other than zeros or `0xcc` bytes, as shown in the following
    screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中看到的，下一个段是`.rdata`，其内容的开始已被高亮显示。一旦我们到达那里，我们开始向上滚动，直到看到非零或`0xcc`字节的内容，如下图所示：
- en: '![](img/740aef78-6103-4a43-ad33-3c35f3dee7ed.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/740aef78-6103-4a43-ad33-3c35f3dee7ed.png)'
- en: 'We see that as the actual content''s last byte is at file offset `0x4196`,
    we have some spare space beginning with the file offset `0x4197`; however, it
    does not seem right to begin a procedure at an unaligned address, so let''s begin
    with the file offset `0x4198`. Just to be sure that we are at the right place,
    let''s compare the bytes with what we see in IDA Pro:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '我们看到实际内容的最后一个字节位于文件偏移 `0x4196`，因此从文件偏移 `0x4197` 开始有一些剩余空间；然而，从未对齐的地址开始执行一个过程似乎不太合适，所以我们决定从文件偏移
    `0x4198` 开始。为了确保我们在正确的位置，让我们将这些字节与 IDA Pro 中看到的内容进行对比：  '
- en: '![](img/11c13b61-c204-421c-9046-1d1e728659c5.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11c13b61-c204-421c-9046-1d1e728659c5.png)  '
- en: Eventually, we see that the bytes are the same and we may use the file offset
    `0x4198` (virtual address `0x414d98`) for our shim code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们看到字节相同，并且可以使用文件偏移 `0x4198`（虚拟地址 `0x414d98`）来放置我们的 shim 代码。
- en: Importing fgets()
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '导入 `fgets()`  '
- en: 'Before we begin the implementation of our patch, we still need to make the
    executable import `fgets()` instead of `gets()`. This appears to be quite easy.
    Let''s take a look at the content of the import table where the `gets()` function
    is imported:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们开始实现补丁之前，我们还需要使可执行文件导入 `fgets()` 而不是 `gets()`。这看起来相当简单。让我们看看导入表中 `gets()`
    函数的内容：  '
- en: '![](img/d1216e6a-1de8-4929-845a-7ab5d11f8ffb.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1216e6a-1de8-4929-845a-7ab5d11f8ffb.png)  '
- en: 'Having located the string, we may safely overwrite it with `fgets`. The explanation,
    looking at the following screenshot, makes it clear why such overwriting is safe
    in this specific case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '找到字符串后，我们可以安全地用 `fgets` 覆盖它。从以下截图可以看出，为什么在这种特定情况下覆盖是安全的：  '
- en: '![](img/3b66c681-22e8-4684-9980-4d62a3515c26.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b66c681-22e8-4684-9980-4d62a3515c26.png)  '
- en: The preceding screenshot shows `gets` being replaced by `fgets` already. We
    are lucky once more here because the `gets` string, which started at the file
    offset `0x7EF0`, did not end on an even boundary, so we had an extra zero at `0x7EF5`,
    thus leaving us enough space to overwrite `gets` with `fgets` and have the terminating
    `NULL` intact.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的截图显示了 `gets` 被替换为 `fgets`。我们在这里再次幸运，因为从文件偏移 `0x7EF0` 开始的 `gets` 字符串并未以偶数边界结束，因此我们在
    `0x7EF5` 处有一个额外的零，留出了足够的空间来将 `gets` 替换为 `fgets`，并且终止的 `NULL` 保持不变。  '
- en: Patching calls
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '补丁调用  '
- en: The next step would be patching calls to `gets()` and redirecting them to our
    shim. As we only have a single call to `gets()` (which is now a call to `fgets()`
    with an invalid number of parameters), we will patch the call itself. If we had
    multiple calls to `fgets()`, we would then patch the `jmp fgets` instruction rather
    than patching each and every call.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '下一步将是补丁 `gets()` 的调用，并将其重定向到我们的 shim。由于我们只有一个 `gets()` 的调用（现在是一个带有无效参数数量的 `fgets()`
    调用），我们将直接补丁这个调用。如果我们有多个 `fgets()` 调用，我们将补丁 `jmp fgets` 指令，而不是对每一个调用进行补丁。  '
- en: 'As we have already seen, the call is relative to `EIP`, so we have to calculate
    a new offset for the call so that it would call our shim code located at `0x414d98`.
    The formula is rather simple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们之前所看到的，调用是相对于 `EIP` 的，因此我们需要计算一个新的偏移量，使其调用我们位于 `0x414d98` 的代码。公式相当简单：  '
- en: '*new_offset = 0x414d98 - 0x4117EC - 5*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*new_offset = 0x414d98 - 0x4117EC - 5*  '
- en: Here, `0x4117EC` is the address of the call instruction and `5` is its length
    in bytes. We need to use this length of the call instruction as, at the time it
    is executed, the `EIP` already points at the instruction immediately following
    the call. The resulting offset would be `0x35A7`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，`0x4117EC` 是调用指令的地址，`5` 是其字节长度。我们需要使用该调用指令的长度，因为在执行时，`EIP` 已经指向紧接着调用后的指令。计算得到的偏移量为
    `0x35A7`。  '
- en: 'However, before we can apply this patch, we have to find the right place in
    the hex editor and we use a few bytes representing this call instruction and a
    few bytes that follow as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在我们应用这个补丁之前，我们必须在十六进制编辑器中找到正确的位置，并使用一些字节表示这个调用指令以及后面的几个字节，如以下截图所示：  '
- en: '![](img/fefdff4a-98f9-42bc-a858-9dbc13dc2092.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fefdff4a-98f9-42bc-a858-9dbc13dc2092.png)  '
- en: 'We used the `0xe8 0xf3 0xfa 0xff 0xff 0x83 0xc4 0x04` bytes for our search.
    Doing this, one has to make sure such a sequence of bytes appears only once in
    the search result. Here the `0xe8` is the call instruction and the `0xf3 0xfa
    0xff 0xff` bytes are the offset from the next instruction --`0xfffffaf3`. The
    following screenshot shows the offset patch being applied:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用了 `0xe8 0xf3 0xfa 0xff 0xff 0x83 0xc4 0x04` 字节进行搜索。这样做时，必须确保这样的字节序列在搜索结果中只出现一次。这里的
    `0xe8` 是调用指令，`0xf3 0xfa 0xff 0xff` 字节是下一条指令的偏移量——`0xfffffaf3`。以下截图展示了偏移补丁的应用：  '
- en: '![](img/4e30e86b-3c38-462d-8190-99555366649b.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e30e86b-3c38-462d-8190-99555366649b.png)'
- en: The offset is overwritten with `0x000035a7`. Now, the instruction at `0x4117ec`
    would call our shim code. But we still have to implement the shim code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量被`0x000035a7`覆盖。现在，`0x4117ec`处的指令将调用我们的 Shim 代码。但我们仍然需要实现 Shim 代码。
- en: Shim code
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shim 代码
- en: 'The code we are about to write will look a tiny bit different from the code
    we are used to as we are not expecting an executable file to be generated out
    of it; instead, we will generate a binary file containing a 32-bit procedure assumed
    to be loaded at a specific address, and that is what we are going to tell the
    compiler in the first two lines of our `patch.asm` source file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写的代码看起来会与我们通常编写的代码略有不同，因为我们并不期望从中生成一个可执行文件；相反，我们将生成一个包含假定会加载到特定地址的 32 位过程的二进制文件，这也是我们将在`patch.asm`源文件的前两行中告诉编译器的内容：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we will define two labels pointing at addresses outside our procedure.
    Fortunately, Flat Assembler allows us to define a label at an arbitrary address,
    like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义两个标签，指向我们过程外的地址。幸运的是，Flat Assembler 允许我们在任意地址定义一个标签，像这样：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After this, we are ready to begin our implementation of the actual shim code
    as a regular `cdecl` procedure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之后，我们就可以开始实现实际的 Shim 代码，作为一个常规的`cdecl`过程：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The implementation of the standard C library on Windows provides us with a
    function for determining pointers to streams based on their number. The function
    is `__iob_func(int)`. Luckily for us, our victim executable is importing this
    function from `ucrtbased.dll` as we can see in the Imports tab of IDA Pro (or
    in the 010 Editor too):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上的标准 C 库实现提供了一个根据流的编号来确定指针的函数。这个函数是`__iob_func(int)`。幸运的是，我们的目标可执行文件正在从`ucrtbased.dll`中导入这个函数，正如我们在
    IDA Pro 的 Imports 标签（或者在 010 Editor 中）看到的：
- en: '![](img/b9427232-540b-4faf-826d-374c7df66034.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9427232-540b-4faf-826d-374c7df66034.png)'
- en: 'Although the name differs a bit (prepended with `__acrt_`), this is the function
    we are interested in and it is located at the virtual address `0x41b180`. This
    is why we added the `__acrt_iob_func` label a few moments ago. Visiting that address,
    we may see that the address of the real `__acrt_iob_func` would be placed there
    after dynamic linking:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称有些不同（前面加了`__acrt_`），但这就是我们感兴趣的函数，它位于虚拟地址`0x41b180`。这也是我们几分钟前添加`__acrt_iob_func`标签的原因。访问这个地址后，我们可以看到在动态链接后，真正的`__acrt_iob_func`的地址会被放在那里：
- en: '![](img/4534f6dd-9bb0-43d9-a087-8d3cd26c585a.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4534f6dd-9bb0-43d9-a087-8d3cd26c585a.png)'
- en: 'In order to call this external function for getting the pointer to the `stdin`
    stream, we must remember that the `stdin` number is `0` and that imported functions
    are called indirectly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用这个外部函数以获取`stdin`流的指针，我们必须记住`stdin`的编号是`0`，并且导入的函数是间接调用的：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we are ready to forward the execution flow to `fgets()` and we do that
    in the following way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将执行流转发到`fgets()`，我们这样做：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code for the patch is ready. As simple as that (in this particular case).
    Compiling this code would generate a 35-bytes binary file containing raw binary
    code. This is the code seen in the hex editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁的代码已经准备好。就这么简单（在这个特定的案例中）。编译这段代码会生成一个包含原始二进制代码的 35 字节二进制文件。这是十六进制编辑器中看到的代码：
- en: '![](img/bde1ad36-c088-42f4-a7f0-5c66579d291e.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bde1ad36-c088-42f4-a7f0-5c66579d291e.png)'
- en: Applying the patch
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用补丁
- en: 'In the *Preparing for the patch* subsection of this chapter, we have already
    located the place where the patch should be applied in the hex editor, which is
    at the file offset `0x4198`. The application of the patch is rather simple --we
    copy the bytes from the `patch.bin` file into the executable at the aforementioned
    location and get the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*准备补丁*小节中，我们已经在十六进制编辑器中找到了补丁应用的位置，即文件偏移量`0x4198`。应用补丁非常简单——我们将`patch.bin`文件中的字节复制到可执行文件中的上述位置，并得到以下结果：
- en: '![](img/17f5709e-cdd6-448c-b3a1-251ebef2cac9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17f5709e-cdd6-448c-b3a1-251ebef2cac9.png)'
- en: 'Now save the file and we are done. The executable has been patched and would
    use `fgets()` instead of `gets()` from now on. We may check this by running the
    executable and feeding a very long string instead of a name:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，我们就完成了。可执行文件已经打上补丁，从现在开始将使用`fgets()`代替`gets()`。我们可以通过运行可执行文件并输入一个非常长的字符串代替名字来检查这一点：
- en: '![](img/2618a77d-2ead-479c-9916-08b62152c221.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2618a77d-2ead-479c-9916-08b62152c221.png)'
- en: As we see, such input no longer causes any error as with `fgets()` at most 127
    characters are read, thus keeping our stack safe, and we see the result in the
    preceding screenshot; --the output is truncated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种输入不再像`fgets()`那样导致错误，因为最多只会读取127个字符，从而保持了栈的安全性，我们在前面的截图中看到了结果；--输出被截断了。
- en: A complex scenario
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂场景
- en: We have just gone through a simplistic scenario of patching a PE executable;
    alas, real-life situations are rarely that simple and modifications are usually
    much more complex than simply importing a different function. Is there a way to
    statically patch executables in such cases? Of course there is. In fact, there
    are more than one. For example, one may patch a certain procedure within the file,
    thus altering the algorithm it implements. This is, however, only possible when
    the existing procedure occupies enough space for the new code. Another option
    is to add an executable section to a PE file, which is rather simple and deserves
    being examined here. The whole process contains five easy steps (six, --if modifying
    the `patch.asm` file counts) and we are going to cover them one by one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚经历了一个简单的PE可执行文件打补丁的场景；然而，现实生活中的情况很少如此简单，修改通常比简单地导入不同的函数复杂得多。在这种情况下，有没有办法静态地打补丁到可执行文件呢？当然有。实际上，不止一种方法。例如，可以对文件中的某个过程进行补丁，从而改变它实现的算法。然而，只有当现有过程占用了足够的空间来容纳新代码时，这种方法才可行。另一个选项是向PE文件中添加一个可执行部分，这个过程相当简单，值得在这里进行检查。整个过程包含五个简单的步骤（如果修改`patch.asm`文件算作第六步的话），我们将一一讲解。
- en: Preparing the patch
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备补丁
- en: This is the easiest step as we hardly have to do anything here. We already have
    a working patch code and the only important difference from the Assembly point
    of view is where the code is going to be placed in memory. We will be adding a
    new section right at the end of the victim executable, thus the loading address
    for the code (the `Virtual Address`) is calculated by the summation of `Virtual
    Address` and `Virtual Size` of the currently last section and rounding it up to
    the nearest multiple of `SectionAlignment`, which, in our case, would be `0x1D000
    + 0x43C = 0x1d43C`, rounded up to `0x1e000`. However, despite being called a virtual
    address, this value is in fact an offset from `ImageBase`, which is `0x400000`,
    thus the real virtual address would be `0x41e000`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的一步，因为我们几乎不需要做任何操作。我们已经有一个工作中的补丁代码，唯一的重要区别是从汇编角度来看，代码将放置在内存中的位置。我们将在目标可执行文件的末尾添加一个新部分，因此，代码的加载地址（即`Virtual
    Address`）是通过将当前最后一部分的`Virtual Address`和`Virtual Size`相加，并将结果四舍五入到最接近的`SectionAlignment`的倍数来计算的。在我们的情况下，`0x1D000
    + 0x43C = 0x1d43C`，四舍五入到`0x1e000`。然而，尽管它被称为虚拟地址，但实际上这个值是`ImageBase`的偏移量，而`ImageBase`是`0x400000`，因此真实的虚拟地址应为`0x41e000`。
- en: To put it simply, we only have to modify one line of `patch.asm`, --line number
    2, so that `org 0x414d98` would become `org 0x41e000`. The rest of the code remains
    the same.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们只需要修改`patch.asm`中的一行——第2行，将`org 0x414d98`改为`org 0x41e000`。其余代码保持不变。
- en: Adjusting file headers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整文件头
- en: Since we are about to append the section to an executable file, we need to make
    some changes to its headers so that they reflect the new reality. Let's open the
    `Legacy.exe` file in either the 010 Editor or any other hex editor you prefer
    and go through all its headers making modifications where necessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算将部分附加到一个可执行文件中，我们需要对其头部进行一些更改，以便它们能够反映新的实际情况。让我们在010编辑器或任何你喜欢的十六进制编辑器中打开`Legacy.exe`文件，并查看所有头部，在必要的地方进行修改。
- en: Before we proceed to update the file, we have to decide what would be the size
    of the new section in file (`SizeOfRawData`) and in memory (`VirtualSize`) in
    accordance with the `FileAlignment` and `SectionAlignment` values, respectively.
    Checking this values in the `IMAGE_OPTIONAL_HEADER32` structure, we see that the
    `FileAlignment` value is `0x200` and `SectionAlignment` is `0x1000`. Since the
    code we want to insert into the new section is tiny (only 35 bytes), we may proceed
    with minimum sizes, making the section's `SizeOfRawData = 0x200` and `VirtualSize
    = 0x1000`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新文件之前，我们必须根据`FileAlignment`和`SectionAlignment`的值分别决定文件中新部分的大小（`SizeOfRawData`）和内存中的大小（`VirtualSize`）。查看`IMAGE_OPTIONAL_HEADER32`结构中的这些值，我们发现`FileAlignment`的值是`0x200`，`SectionAlignment`的值是`0x1000`。由于我们要插入的新代码非常小（只有35字节），因此可以使用最小的大小，设定部分的`SizeOfRawData
    = 0x200`，`VirtualSize = 0x1000`。
- en: 'However, let''s proceed step by step and, as the first modification, adjust
    the `NumberOfSections` field of `IMAGE_FILE_HEADER` under `IMAGE_NT_HEADERS`,
    as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们一步步进行，作为第一步，调整`IMAGE_FILE_HEADER`下`IMAGE_NT_HEADERS`的`NumberOfSections`字段，如下图所示：
- en: '![](img/f345c8ca-b191-4a4a-be96-f1f5843b4b72.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f345c8ca-b191-4a4a-be96-f1f5843b4b72.png)'
- en: Originally, the file had seven sections and, as we are going to add another
    section, we change the `WORD NumberOfSections` value to `8h`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 原本，文件有七个节，随着我们将增加另一个节，我们将`WORD NumberOfSections`的值更改为`8h`。
- en: 'Once the `NumberOfSections` field has been updated, we proceed with updating
    the `SizeOfImage` field (which is the size of the executable image in memory)
    of the `IMAGE_OPTIONAL_HEADER32` header. The original value of the `SizeOfImage`
    field is `0x1E000` and, as our new section should occupy `0x1000` bytes in memory,
    we simply set `SizeOfImage` to `0x1F000`, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新了`NumberOfSections`字段，我们接着更新`IMAGE_OPTIONAL_HEADER32`头中的`SizeOfImage`字段（这是内存中可执行镜像的大小）。`SizeOfImage`字段的原始值是`0x1E000`，由于我们的新节应该占用`0x1000`字节的内存，我们简单地将`SizeOfImage`设置为`0x1F000`，如下面的截图所示：
- en: '![](img/50ad8ec5-4b97-4f8e-9f3b-508e9f2640bb.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50ad8ec5-4b97-4f8e-9f3b-508e9f2640bb.png)'
- en: Now comes a rather more interesting part --adding a section header. Section
    headers are located right after the array of `IMAGE_DATA_DIRECTORY` entries, which,
    in our case, is at the file offset of `0x1F0`. The last section header (for the
    `.rsrc` section) is located at the file offset `0x2E0` and we are going to insert
    our header right after starting at file offset `0x308`. In the case of this executable,
    we have plenty of spare bytes, so we may safely proceed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入一个更加有趣的部分——添加一个节头。节头位于`IMAGE_DATA_DIRECTORY`条目数组之后，在我们的例子中，位于文件偏移量`0x1F0`。最后一个节头（针对`.rsrc`节）位于文件偏移量`0x2E0`，我们将把我们的节头插入在其之后，起始于文件偏移量`0x308`。对于这个可执行文件，我们有足够的空闲字节，因此可以安全地继续。
- en: The first eight bytes of the section header contain the section's name and we
    will name our section `.patch`. The interesting fact about the section name field
    is that the name does not have to end with 0 (the `NULL` string terminator) and
    may occupy all eight bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 节头的前八个字节包含节的名称，我们将节命名为`.patch`。关于节名称字段的一个有趣的事实是，名称不必以0（`NULL`字符串终止符）结尾，并且可以占用所有八个字节。
- en: The next four byte are integers describing the virtual size of a section (how
    many bytes it would occupy in memory), which, as we have previously decided, is
    `0x1000` bytes (another interesting fact--we may set this field to 0 and it would
    still work well).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字节是描述节的虚拟大小的整数（它在内存中将占用多少字节），如我们之前决定的，虚拟大小是`0x1000`字节（另一个有趣的事实是——我们可以将此字段设置为0，它仍然能够正常工作）。
- en: The next field is a four bytes integer describing the `VirtualAddress` field
    of a section (where the section should be loaded at). The value for this field
    is the previous value of the `SizeOfImage` field, which was `0x1E000`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的字段是一个四字节整数，描述节的`VirtualAddress`字段（该节应该被加载到哪里）。该字段的值是之前`SizeOfImage`字段的值，即`0x1E000`。
- en: Following the `VirtualAddress` field, there is the `SizeOfRawData` field (4
    bytes as well), which we set to `0x200`, --the size of the new section in the
    file, --and
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随`VirtualAddress`字段之后的是`SizeOfRawData`字段（也是4个字节），我们将其设置为`0x200`——即文件中新节的大小——以及
- en: '`PointerToRawData`, which we set to the previous size of the file --`0x8E00`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointerToRawData`，我们将其设置为文件之前的大小——`0x8E00`。'
- en: The remaining fields are filled with zeros, except the last field, `Characteristics`,
    which we set to `0x60000020`, denoting the section as containing code and being
    executable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其余字段填充为零，除了最后一个字段`Characteristics`，我们将其设置为`0x60000020`，表示该节包含代码并且是可执行的。
- en: 'The section header you added should look like the one shown in the following
    screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的节头应该像下图所示：
- en: '![](img/e72d4d5b-359b-4be9-bd6d-8b4d49116ef8.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e72d4d5b-359b-4be9-bd6d-8b4d49116ef8.png)'
- en: Appending a new section
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新节
- en: There are just two more steps to take and the first of them would be appending
    the actual section data to the file. Scrolling the file to the end in a hex editor,
    we will see that the first available file offset to add bytes to is `0x8e00`,
    which is exactly the value we set the `PointerToRawData` field to.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个步骤，首先是将实际的节数据追加到文件中。在十六进制编辑器中滚动文件到末尾，我们会看到第一个可用的文件偏移量是`0x8e00`，这正是我们设置的`PointerToRawData`字段的值。
- en: 'We should append `0x200` bytes to the file, thus setting its size to `0x9000`,
    and fill the first 35 bytes of those `0x200` bytes with our code, as shown on
    the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将`0x200`字节附加到文件中，从而将其大小设置为`0x9000`，并用我们的代码填充这`0x200`字节的前35个字节，如下图所示：
- en: '![](img/61105c12-0e5b-4fff-a20c-f23eadabdf62.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61105c12-0e5b-4fff-a20c-f23eadabdf62.png)'
- en: Just one more step to take before we can actually run the executable, so let's
    not hesitate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一步，就可以实际运行可执行文件了，别犹豫了。
- en: Fixing the call instruction
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复调用指令
- en: 'All that is left to do is to fix the `call gets()` instruction so that it would
    point to our new code. We use the same binary string `0xE8 0xF3 0xFA 0xFF 0xFF
    0x83 0xC4 0x04` in order to locate the call we are interested in and replace the
    `0xF3 0xFA 0xFF 0xFF` bytes with `0x0F 0xC8 0x00 0x00`, which is the exact offset
    from the instruction following the call to our new section. The following screenshot
    illustrates precisely this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是修复`call gets()`指令，使其指向我们的新代码。我们使用相同的二进制字符串`0xE8 0xF3 0xFA 0xFF 0xFF 0x83
    0xC4 0x04`来定位我们感兴趣的调用，并将`0xF3 0xFA 0xFF 0xFF`字节替换为`0x0F 0xC8 0x00 0x00`，这是从调用后的指令到我们新部分的精确偏移。以下截图准确地展示了这一过程：
- en: '![](img/c7328faa-8728-43ee-8a9f-3d6cc71380cc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7328faa-8728-43ee-8a9f-3d6cc71380cc.png)'
- en: At last, save the file and try to launch it. If the patching has been done correctly,
    then you will see the same result as with the previous approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保存文件并尝试启动它。如果修补正确，你将看到与之前方法相同的结果。
- en: ELF executables
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF可执行文件
- en: Patching ELF executables is a bit more difficult than patching their PE counterparts
    as ELF files tend to have no spare space in their sections, thus leaving no other
    choice but to either add a section, which is not as simple as with PE files, or
    inject a shared object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 修补ELF可执行文件比修补PE可执行文件要困难一些，因为ELF文件通常在其节区中没有空闲空间，因此我们只能选择添加一个节区，这不像PE文件那样简单，或者注入共享对象。
- en: Adding a section requires a good knowledge of the ELF format (specifications
    can be found at [http://www.skyfree.org/linux/references/ELF_Format.pdf](http://www.skyfree.org/linux/references/ELF_Format.pdf)),
    which, although quite interesting, resides, in its fullness, outside the scope
    of this book. The most noticeable problem is in the way sections and headers are
    arranged within an ELF executable and in the way an ELF structure is treated by
    Linux, which makes it hard to append data as we did in the case of PE patching.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加节区需要对ELF格式有很好的了解（可以在[http://www.skyfree.org/linux/references/ELF_Format.pdf](http://www.skyfree.org/linux/references/ELF_Format.pdf)中找到相关规范），尽管这一内容非常有趣，但在本书的范围之外。最显著的问题是ELF可执行文件中节区和头部的排列方式，以及Linux如何处理ELF结构，这使得像我们在PE修补中那样附加数据变得非常困难。
- en: Injection of a shared object, on the other hand, is much simpler to implement
    and easy to use, so let's proceed this way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，注入共享对象要简单得多，实施起来也容易，因此我们将采用这种方式。
- en: LD_PRELOAD
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD`'
- en: The `LD_PRELOAD` environment variable is used by the Linux dynamic linker/loader
    `ld.so` and, if set, contains a list of shared objects to be loaded with the executable
    before any other shared object is loaded, including `libc.so`. This means that
    we may create a shared object, which would export a symbol named `gets`, and specify
    this shared object in `LD_PRELOAD`, which would guarantee, that if the executable
    we are attempting to run imports a symbol with the same name, our implementation
    of `gets` would be linked instead of the one from `libc.so`, which would be loaded
    afterward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD`环境变量由Linux动态链接器/加载器`ld.so`使用，如果设置了它，变量中将包含一个共享对象列表，这些共享对象会在任何其他共享对象之前与可执行文件一起加载，包括`libc.so`。这意味着我们可以创建一个共享对象，导出一个名为`gets`的符号，并将这个共享对象指定给`LD_PRELOAD`，这样如果我们尝试运行的可执行文件导入了一个同名符号，我们的`gets`实现就会被链接，而不是之后加载的`libc.so`中的实现。'
- en: A shared object
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个共享对象
- en: Right now, we are going to implement our own `gets()` procedure, which would,
    in fact, forward calls to `fgets()` just as our PE patch did. Unfortunately, Flat
    Assembler's support for ELF does not allow us to create shared objects in a simple
    way yet; therefore, we will create an object file and later link it with GCC as
    a shared object for a 32-bit system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现我们自己的`gets()`过程，它实际上会将调用转发给`fgets()`，就像我们之前修补PE文件时做的那样。不幸的是，Flat Assembler对ELF的支持目前还无法让我们简单地创建共享对象；因此，我们将创建一个目标文件，并稍后使用GCC将其作为32位系统的共享对象进行链接。
- en: 'The source code is, as usual, quite simple and intuitive:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码通常非常简单直观：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the preceding code as `fgets_patch.asm` and compile it with `fasm` or
    `fasm.x64`; this will result in the `fgets_patch.o` object file. Building a shared
    object out of this object file is as simple as running one of the following commands
    in the terminal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码保存为 `fgets_patch.asm`，并使用 `fasm` 或 `fasm.x64` 编译；这将生成 `fgets_patch.o`
    目标文件。将此目标文件构建为共享对象，方法就是在终端运行以下命令之一：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now test and run the legacy executable without the patch and feed it
    with a long string (140 bytes). Here is the result:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在没有补丁的情况下测试并运行旧版可执行文件，并使用一个长字符串（140 字节）进行输入。结果如下：
- en: '![](img/ca0ad6e2-02f2-4ed3-af77-c18f0c3acddb.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca0ad6e2-02f2-4ed3-af77-c18f0c3acddb.png)'
- en: 'As we can see, the stack was corrupted, which caused a segmentation fault (invalid
    memory access). Now we may try to run the same executable but set the `LD_PRELOAD`
    environment variable to `"./fgets_patch.so"`, thus forcing our shared object to
    be loaded before anything else when launching the `legacy` executable. The command
    line would then be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，栈被破坏，导致了段错误（无效的内存访问）。现在我们可以尝试运行相同的可执行文件，但将 `LD_PRELOAD` 环境变量设置为 `"./fgets_patch.so"`，从而在启动
    `legacy` 可执行文件时强制加载我们的共享对象。命令行将如下所示：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, we get the output just as expected, --truncated to 127 characters,
    --meaning that our implementation of `gets()` was linked by the dynamic linking
    process:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们得到了预期的输出——被截断到 127 个字符——这意味着我们的 `gets()` 实现通过动态链接过程进行了链接：
- en: '![](img/2326a414-067b-4d3a-9f35-0d05734a1091.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2326a414-067b-4d3a-9f35-0d05734a1091.png)'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Modification of existing executable code and/or running processes is a rather
    broad theme, which is very difficult to fit into a single chapter as it may itself
    deserve a separate book. It is, however, much more relevant to programming techniques,
    and operating systems in general, while we were trying to concentrate on the Assembly
    language.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有可执行代码和/或正在运行的进程是一个相当广泛的主题，十分难以在单一章节中涵盖，因为这个主题本身可能值得独立成书。然而，它与编程技术和操作系统的关系更为紧密，而我们试图专注于汇编语言。
- en: This chapter hardly covers the tip of the iceberg called modification of binary
    code (known as patching). The purpose was to demonstrate how easy and interesting
    the process may be, rather then covering each and every method in much detail.
    We have, however, acquired a general indication of where to go to when it comes
    to modification of code that cannot be simply rebuilt.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章几乎只是触及了所谓的二进制代码修改（即补丁）的冰山一角。目的在于展示这个过程是多么简单和有趣，而不是详细讨论每一种方法。然而，我们已经获得了一个大致的方向，当涉及到那些无法简单重建的代码修改时，应该去哪里。
- en: The method of code analysis was covered very superficially just to provide you
    with the general idea, just as the most part of the process of patching an application
    too, as the emphasis was on the implementation of patches themselves. My personal
    suggestion is --go and get acquainted with the format specs for both Windows PE
    executables and object files and Linux ELF. Even if you would never have to patch
    a single executable, you would then understand what happens on lower levels when
    you are coding in a higher-level languages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析的方法仅被表面性地涵盖，目的是为你提供一个大致的概念，应用程序补丁过程的大部分内容也是如此，因为重点是补丁的实现。我的个人建议是——去了解 Windows
    PE 可执行文件和目标文件格式规范，以及 Linux ELF。即使你永远不需要修改任何可执行文件，了解这些内容也能帮助你理解在高级语言编程时，底层发生了什么。
