- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Network and Infrastructure Pentesting with Bash
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 进行网络和基础设施的渗透测试
- en: This chapter explores how to use Bash for network and infrastructure pentesting.
    We’ll look at how Bash can be a powerful tool for probing network systems, identifying
    vulnerabilities, and simulating attack scenarios. You’ll gain a comprehensive
    understanding of how to use Bash for scanning, enumeration, and vulnerability
    assessment in an internal network environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何使用 Bash 进行网络和基础设施的渗透测试。我们将了解 Bash 如何成为探测网络系统、识别漏洞以及模拟攻击场景的强大工具。你将全面了解如何使用
    Bash 进行扫描、枚举和漏洞评估，尤其是在内部网络环境中。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Fundamentals of network pentesting with Bash
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bash 进行网络渗透测试的基本原理
- en: Advanced network scanning techniques in Bash
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 中的高级网络扫描技术
- en: Enumerating network services and protocols using Bash
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bash 枚举网络服务和协议
- en: Infrastructure vulnerability assessment with Bash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bash 进行基础设施漏洞评估
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along, at a minimum, you will need access to a Bash shell. To perform
    the demonstrated exercises, you will need to build the **Game of Active Directory**
    ( **GOAD** ) lab. You can find GOAD at [https://github.com/Orange-Cyberdefense/GOAD](https://github.com/Orange-Cyberdefense/GOAD)
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，至少你需要访问一个 Bash shell。为了执行示范的练习，你需要构建 **Active Directory 游戏**（**GOAD**）实验室。你可以在
    [https://github.com/Orange-Cyberdefense/GOAD](https://github.com/Orange-Cyberdefense/GOAD)
    找到 GOAD。
- en: GOAD is an Active Directory exploitation lab. If you’re not familiar with Active
    Directory, it’s a system for managing a large number of related Microsoft Windows
    systems. The default Windows and Active Directory configurations frequently have
    vulnerabilities that can be exploited. There are additional exploitable misconfigurations
    in the lab beyond default settings. The Active Directory vulnerabilities in the
    GOAD lab are frequently found on internal network pentests, making this one of
    the best labs for practice or for testing new pentest tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GOAD 是一个 Active Directory 漏洞利用实验室。如果你不熟悉 Active Directory，它是一个用于管理大量相关 Microsoft
    Windows 系统的系统。默认的 Windows 和 Active Directory 配置通常存在可被利用的漏洞。在实验室中，除了默认设置之外，还有更多的可利用配置错误。GOAD
    实验室中的 Active Directory 漏洞常常出现在内部网络渗透测试中，这使得它成为实践或测试新渗透工具的最佳实验室之一。
- en: I use Ludus to deploy my GOAD lab. I run a Ludus server, and on the client side
    (my laptop), I use the Ludus client to automate building, starting, and stopping
    my lab environment. Ludus makes it easy to automate lab deployment of complex
    network environments. I have deployed my Ludus range with both GOAD and Vulhub
    templates for a mix of internal network pentesting targets along with a mix of
    known vulnerable web applications. You can read more about Ludus at [https://docs.ludus.cloud](https://docs.ludus.cloud)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Ludus 来部署我的 GOAD 实验室。我运行一个 Ludus 服务器，在客户端（我的笔记本电脑）上，我使用 Ludus 客户端来自动化构建、启动和停止我的实验环境。Ludus
    使得自动化部署复杂网络环境变得容易。我已使用 GOAD 和 Vulhub 模板部署了我的 Ludus 环境，混合了内部网络渗透测试目标以及一些已知的易受攻击的
    Web 应用程序。你可以在 [https://docs.ludus.cloud](https://docs.ludus.cloud) 阅读更多关于 Ludus
    的内容。
- en: Which should you choose, GOAD or Ludus? GOAD must be installed on a Linux system,
    but you can continue to use that Linux system for other uses. The Ludus server
    requires installing it *bare metal* on a computer. After installing Ludus, you
    will not be able to use that computer for anything other than a virtual server.
    If you can, I recommend dedicating a computer to running Ludus and deploying GOAD
    from there. You will need a lab environment throughout your pentesting career,
    and Ludus makes running a lab environment easy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择 GOAD 还是 Ludus？GOAD 必须安装在 Linux 系统上，但你可以继续将该 Linux 系统用于其他用途。Ludus 服务器需要将其
    *裸机* 安装在一台计算机上。安装完 Ludus 后，你将无法将该计算机用于除虚拟服务器之外的任何其他用途。如果可以，我建议将一台计算机专门用于运行 Ludus，并从那里部署
    GOAD。你在渗透测试生涯中将需要一个实验环境，而 Ludus 使得运行实验环境变得简单。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10)
    .
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10)
    找到。
- en: 'Run the following commands to install the prerequisites in Kali:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令在 Kali 中安装所需的依赖：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install Greenbone Community Edition, formerly known as OpenVAS. The hardware
    or virtual hardware minimum requirements are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Greenbone Community Edition，之前称为 OpenVAS。硬件或虚拟硬件的最低要求如下：
- en: '**CPU** : 2 cores'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU** ：2 核'
- en: '**RAM** : 4 GB'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM** ：4 GB'
- en: '**Storage** : 20 GB'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储** ：20 GB'
- en: 'Run the following command to install and configure Greenbone:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以安装和配置 Greenbone：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make a note of the admin account password in the output. Once the setup completes,
    run the following command to ensure everything is in order:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中记下管理员帐户密码。设置完成后，运行以下命令以确保一切正常：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the output, if everything went well, you should see this at the end: **It
    seems like your GVM-[version] installation** **is OK.**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，如果一切顺利，你应该看到最后的内容：**It seems like your GVM-[version] installation** **is
    OK.**
- en: Fundamentals of network pentesting with Bash
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 进行网络渗透测试的基础
- en: Network pentesting, or pentesting, is a critical practice in cybersecurity.
    It involves simulating attacks on a network to identify vulnerabilities before
    malicious actors can exploit them. Various methodologies guide pentesters through
    this process, ensuring thorough and systematic assessments. Bash scripting, a
    powerful tool in the Unix/Linux environment, plays a significant role in automating
    and enhancing these methodologies. Let’s dive into the core methodologies of network
    pentesting and explore how Bash scripting can be leveraged effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网络渗透测试，或称渗透测试，是网络安全中的一项关键实践。它涉及模拟对网络的攻击，以便在恶意行为者利用漏洞之前识别这些漏洞。各种方法论指导渗透测试员完成这一过程，确保彻底和系统的评估。Bash
    脚本，在 Unix/Linux 环境中是一个强大的工具，在自动化和增强这些方法论方面发挥着重要作用。让我们深入探讨网络渗透测试的核心方法，并探索如何有效地利用
    Bash 脚本。
- en: Core methodologies in network pentesting
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络渗透测试的核心方法
- en: 'The core methodologies in network pentesting include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 网络渗透测试的核心方法包括以下内容：
- en: '**Reconnaissance** : Reconnaissance is the initial phase where information
    about the target network is gathered. This can be passive (e.g., searching public
    records) or active (e.g., scanning the network).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**侦察** ：侦察是获取目标网络信息的初始阶段。可以是被动的（例如，查找公开记录）或主动的（例如，扫描网络）。'
- en: '**Scanning** : In this phase, pentesters use tools to discover live hosts,
    open ports, and services running on the network. This helps in mapping the network
    and identifying potential entry points.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫描** ：在此阶段，渗透测试员使用工具发现活动主机、开放端口和网络上运行的服务。这有助于绘制网络图并识别潜在的入口点。'
- en: '**Enumeration** : Enumeration involves extracting more detailed information
    from the network, such as user accounts, machine names, and network shares. This
    phase builds on the data gathered during scanning.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**枚举** ：枚举涉及从网络中提取更详细的信息，例如用户帐户、计算机名称和网络共享。此阶段基于扫描过程中收集的数据。'
- en: '**Exploitation** : Here, pentesters attempt to exploit identified vulnerabilities
    to gain unauthorized access to systems or data. This phase tests the effectiveness
    of security measures in place.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**利用** ：在这一阶段，渗透测试员尝试利用已识别的漏洞，获得对系统或数据的未授权访问。此阶段测试现有安全措施的有效性。'
- en: '**Post-exploitation** : After gaining access, pentesters assess the extent
    of the breach, maintain access, and gather additional information. This phase
    helps in understanding the potential impact of an attack.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**后期利用** ：获得访问权限后，渗透测试员评估入侵的程度，保持访问权限，并收集更多信息。此阶段有助于理解攻击的潜在影响。'
- en: '**Reporting** : Finally, pentesters compile their findings into a report, detailing
    vulnerabilities, exploited weaknesses, and recommendations for remediation.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**报告** ：最后，渗透测试员将他们的发现汇总成报告，详细列出漏洞、利用的弱点以及修复建议。'
- en: We covered reconnaissance in [*Chapter 8*](B22229_08.xhtml#_idTextAnchor213)
    . This chapter will focus on scanning, enumeration, and exploitation. Post-exploitation
    and reporting will follow in later chapters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 8 章*](B22229_08.xhtml#_idTextAnchor213)中已经讨论了侦察。本章将重点介绍扫描、枚举和利用。后期利用和报告将在后续章节中进行讨论。
- en: Pentesters need to be able to hyper-focus on attention to detail to be effective.
    Pentests are usually time-boxed, meaning you have limited time between a scheduled
    start and stop date. The value of having Bash scripting skills is the time it
    saves. We want to automate running scanning and enumeration, saving us precious
    time to focus on the details output from our tools. This is where Bash scripting
    is valuable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员需要能够高度集中注意力，以便有效工作。渗透测试通常是有时间限制的，这意味着在预定的开始和结束日期之间你有有限的时间。掌握Bash脚本技能的价值在于它节省的时间。我们希望自动化运行扫描和枚举，这样我们就能节省宝贵的时间，专注于工具输出的细节。这就是Bash脚本的价值所在。
- en: During a pentest, we need to run a list of tools. Often, we must chain together
    the output of one tool with the input of another. This process usually involves
    transforming data, as we have seen in earlier chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试过程中，我们需要运行一系列工具。通常，我们必须将一个工具的输出与另一个工具的输入连接起来。这个过程通常涉及到数据转换，正如我们在前几章中看到的那样。
- en: Setting up the pentest environment
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置渗透测试环境
- en: My first step when starting a network pentest is to create a directory structure
    to hold the data. The top-level directory is the name of the pentest. In this
    case, I’ll call it **bashbook** . Then, I create directories under **bashbook**
    for logs, scans, and loot.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开始进行网络渗透测试时，我的第一步是创建一个目录结构来存放数据。顶级目录是渗透测试的名称。在这种情况下，我将其命名为**bashbook**。然后，在**bashbook**下创建日志、扫描和战利品的目录。
- en: '![Figure 10.1 – Network pentest directory structure example](image/B22229_10_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 网络渗透测试目录结构示例](image/B22229_10_01.jpg)'
- en: Figure 10.1 – Network pentest directory structure example
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 网络渗透测试目录结构示例
- en: Under the top-level directory, **bashbook** , I’ll create two files, **scope.txt**
    and **exclusions.txt** . The **scope.txt** file is where I list the IP or network
    addresses I’m authorized to test. The **exclusions.txt** file includes any IP
    addresses or hostnames that are off-limits. This way, if my authorized scope is
    the network address **10.2.10.0/24** but **10.2.10.13** is excluded, I can put
    that address in **exclusions.txt** to ensure I skip that address.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶级目录**bashbook**下，我将创建两个文件，**scope.txt**和**exclusions.txt**。**scope.txt**文件中列出我被授权测试的IP或网络地址。**exclusions.txt**文件中包括任何被排除的IP地址或主机名。这样，如果我的授权范围是网络地址**10.2.10.0/24**，但**10.2.10.13**被排除，我可以将该地址放入**exclusions.txt**文件中，以确保跳过该地址。
- en: The **logs** directory is where I’ll place a copy of the output of every command
    I run in the terminal. For terminal logging, I’m a huge fan of the **tee** command.
    There are methods to log all command-line activity to a single file, but I personally
    like to append the **tee** command to each command and save individual log files.
    This saves the output to a file that will have a date and time stamp and a meaningful
    filename. If my customer reports an outage and asks me what I was doing, I can
    look in my **logs** directory at the timestamps and provide an answer. Additionally,
    these log files are valuable in case I realize after testing ends that I’ve missed
    a screenshot for the report. I can simply **cat** the log file and take a screenshot.
    These log files will also be used when I need to parse data to discover all affected
    hosts for a report finding. To execute a command and see the output while saving
    the output to a file, use the Bash pipe symbol ( **|** ) between the command and
    **tee** .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**logs**目录是我将每个在终端运行的命令输出的副本存放的地方。对于终端日志记录，我非常喜欢**tee**命令。有一些方法可以将所有命令行活动记录到一个文件中，但我个人喜欢将**tee**命令附加到每个命令后，并保存单独的日志文件。这将输出保存到一个带有日期和时间戳的文件中，文件名也具有意义。如果我的客户报告出现故障并询问我在做什么，我可以查看**logs**目录中的时间戳并给出回答。此外，这些日志文件在我测试结束后如果发现遗漏了报告中的截图时也非常有用。我可以简单地**cat**日志文件并截图。这些日志文件还将在我需要解析数据以发现报告中所有受影响主机时使用。要执行命令并查看输出的同时将输出保存到文件中，可以在命令和**tee**之间使用Bash管道符号（**|**）。'
- en: 'Here is an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, I have a meaningful log filename with a timestamp and the output of my
    command for parsing later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我有了一个有意义的日志文件名，包含时间戳和我命令的输出，方便稍后进行解析。
- en: Tip
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you run another command and pipe it to **tee** and an existing filename,
    the file will be overwritten. To append to a file, use **tee -** **a [filename]**
    .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行另一个命令并将其通过管道传递给**tee**并指定一个现有的文件名，该文件将会被覆盖。要向文件追加内容，使用**tee -a [filename]**。
- en: Using tmux for persistent sessions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tmux进行持久会话
- en: 'Before we start hacking, I want to introduce you to another shell utility,
    **tmux** . Let’s take a look at the output of the **man** **tmux** command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始黑客之前，我想向你介绍另一个 shell 实用程序，**tmux** 。让我们看一下 **man tmux** 命令的输出：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason why **tmux** is so important to our work is that pentesters frequently
    work remotely and must connect to or through remote systems to do their work.
    For example, I work 100 percent remotely. When I perform an internal network pentest
    for a customer, I don’t go onsite. I ship a small computer such as an Intel NUC
    or a System76 Meerkat to my customer site. The customer plugs it into the network
    and turns it on. The device then connects to a bastion host on my team’s **network
    demilitarized zone** ( **DMZ** ) using the Wireguard protocol. I then use SSH
    with public and private keys to securely connect to my customer’s internal network
    through my Bastion host.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**tmux** 对我们的工作如此重要的原因在于，渗透测试人员经常远程工作，必须连接到远程系统或通过远程系统进行工作。例如，我百分之百远程工作。当我为客户执行内部网络渗透测试时，我不会亲自前往现场。我会将一台小型计算机，如
    Intel NUC 或 System76 Meerkat 发送到客户现场。客户将其连接到网络并打开电源。该设备然后使用 Wireguard 协议连接到我团队的
    **网络非军事区**（**DMZ**）上的堡垒主机。然后我使用带有公钥和私钥的 SSH 安全连接到我的客户内部网络通过我的堡垒主机。'
- en: After establishing my SSH session, I immediately start or resume a **tmux**
    session. You may be disconnected from a remote system while running a scan, or
    worse, after you’ve exploited a system and established a reverse shell. The **tmux**
    program keeps your shell session and running processes alive if you get disconnected.
    Without it, if you run a command and get disconnected from the SSH session, all
    running processes are killed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立 SSH 会话后，我立即启动或恢复一个 **tmux** 会话。在运行扫描时，您可能会从远程系统断开连接，或者更糟的是，在利用系统并建立反向 shell
    后断开连接。如果您没有 **tmux**，如果运行一个命令并从 SSH 会话断开连接，所有正在运行的进程都将被终止。
- en: 'Let’s explore how to use **tmux** . First, run **tmux** and start a new session:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用 **tmux** 。首先，运行 **tmux** 并启动一个新会话：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The session name is not required. You may also start a new session by simply
    entering **tmux** . If you work with others and are sharing a system, it’s a good
    idea to name your session.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 会话名称不是必需的。您也可以通过简单输入 **tmux** 来启动一个新会话。如果您与他人合作并共享系统，则给会话命名是个好主意。
- en: Now, our terminal window will have the name of the session and a single default
    window in the lower left-hand corner. The current window is denoted by the addition
    of the asterisk ( ***** ) at the end of the window name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的终端窗口将具有会话名称和左下角的单个默认窗口。当前窗口通过在窗口名称末尾添加星号（*）来表示。
- en: '![Figure 10.2 – A new tmux session status line is displayed](image/B22229_10_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 显示了一个新的 tmux 会话状态行](image/B22229_10_02.jpg)'
- en: Figure 10.2 – A new tmux session status line is displayed
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 显示了一个新的 tmux 会话状态行
- en: '**tmux** may be controlled from an attached client by using a key combination
    of a prefix key, *Ctrl* + *b* by default, followed by a command key. To detach
    from the **tmux** session, enter the key combination *Ctrl* + *b* , *d* . This
    means pressing and holding the *Ctrl* key ( *control* key on macOS keyboards),
    then pressing and releasing the *b* key, then releasing the *Ctrl* key and pressing
    the *d* key. When you reconnect to the SSH session, you reconnect to the session
    by entering **tmux a -t [session name]** . This means **tmux** will attach ( **a**
    ) to a target session ( **-t** ) followed by the session name.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**tmux** 可以通过使用默认的前缀键 *Ctrl* + *b*，然后是命令键，从附加的客户端控制。要从 **tmux** 会话中分离，输入键组合
    *Ctrl* + *b*，*d*。这意味着按住 *Ctrl* 键（macOS 键盘上的 *control* 键），然后按下并释放 *b* 键，然后释放 *Ctrl*
    键并按下 *d* 键。当您重新连接到 SSH 会话时，您可以通过输入 **tmux a -t [会话名称]** 重新连接到会话。这意味着 **tmux**
    将附加（**a**）到目标会话（**-t**），然后是会话名称。'
- en: Next, let’s create a new window by entering *Ctrl* + *b* , *c* .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过输入 *Ctrl* + *b* ，*c* 来创建一个新窗口。
- en: '![Figure 10.3 – A new window is created in the tmux session](image/B22229_10_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 在 tmux 会话中创建一个新窗口](image/B22229_10_03.jpg)'
- en: Figure 10.3 – A new window is created in the tmux session
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 在 tmux 会话中创建一个新窗口
- en: '**tmux** is able to rename windows based on the running command. However, if
    you want to manually rename a window, use the *Ctrl* + *b* , *,* (Press *Ctrl*
    + *b* key combination, release the keys, then press the *,* (comma) key) followed
    by the desired name and the *Enter* key. Notice that the current window is now
    named **foo** :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**tmux**能够根据运行的命令重命名窗口。但是，如果您想手动重命名窗口，请使用*Ctrl* + *b*，*，*（按下*Ctrl* + *b*组合键，释放键，然后按*，*（逗号）键），然后输入所需的名称和*Enter*键。请注意，当前窗口现在被命名为**foo**：'
- en: '![Figure 10.4 – The current window is renamed](image/B22229_10_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 当前窗口已重命名](image/B22229_10_04.jpg)'
- en: Figure 10.4 – The current window is renamed
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 当前窗口已重命名
- en: To switch between windows, press *Ctrl* + *b* + *n* to switch to the next window
    or *Ctrl* + *b* + *[window number]* to switch to a specific window. **tmux** can
    also split the terminal into multiple panes. To see the default hotkeys, enter
    **man tmux** in your Bash shell. If **tmux** is not already installed, you can
    install it with the **sudo apt update && sudo apt install** **tmux** command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在窗口之间切换，请按*Ctrl* + *b* + *n*切换到下一个窗口，或者*Ctrl* + *b* + *[窗口号]*切换到特定窗口。**tmux**还可以将终端分割成多个窗格。要查看默认热键，请在Bash
    shell中输入**man tmux**。如果尚未安装**tmux**，可以使用**sudo apt update && sudo apt install**
    **tmux**命令进行安装。
- en: Now that we have set up our pentest system and are familiar with the basic tools,
    let’s start scanning!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了渗透测试系统并熟悉了基本工具，让我们开始扫描吧！
- en: Basic network scanning with Nmap
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nmap进行基本网络扫描
- en: In [*Chapter 6*](B22229_06.xhtml#_idTextAnchor148) , you learned how to use
    Bash for very basic port scans. Those concepts are useful in situations where
    you’re in a limited network environment and cannot install standard scanning tools
    such as Nmap. However, a pure Bash port scanner would not be my first choice of
    tool when performing network pentesting scans. Here, we’ll start working with
    Nmap and Masscan.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B22229_06.xhtml#_idTextAnchor148)中，您学习了如何使用Bash进行非常基本的端口扫描。这些概念在您处于受限网络环境且无法安装标准扫描工具（如Nmap）的情况下非常有用。然而，在进行网络渗透测试扫描时，纯Bash端口扫描工具不会是我的首选工具。在这里，我们将开始使用Nmap和Masscan。
- en: 'The following command is an example of the most basic Nmap scan:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令是最基本的Nmap扫描示例：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the IP address in your GOAD environment may differ from the examples
    shown here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您的GOAD环境中的IP地址可能与此处显示的示例不同。
- en: 'The following figure shows the partial output from this scan:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了此扫描的部分输出：
- en: '![Figure 10.5 – Partial output from a basic Nmap TCP port scan](image/B22229_10_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 基本Nmap TCP端口扫描的部分输出](image/B22229_10_05.jpg)'
- en: Figure 10.5 – Partial output from a basic Nmap TCP port scan
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 基本Nmap TCP端口扫描的部分输出
- en: Notice that we have very basic information shown in the preceding figure. The
    output for each port lists services that are the defaults for the port number.
    Since we didn’t use any other scan flags, Nmap used a connect scan ( **-sT** )
    by default, and didn’t perform service fingerprinting, and the output wasn’t saved
    to a file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上图中显示了非常基本的信息。每个端口的输出列出了该端口号的默认服务。由于我们没有使用任何其他扫描标志，Nmap默认使用连接扫描（**-sT**），并且没有执行服务指纹识别，并且输出没有保存到文件中。
- en: 'The previous scan showed a default TCP scan. To scan UDP ports, use the **-sU**
    flag, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的扫描显示了默认的TCP扫描。要扫描UDP端口，请使用**-sU**标志，如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from the UDP scan can be seen in the following figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UDP扫描的输出可以在以下图中看到：
- en: '![Figure 10.6 – Partial output from a basic UDP port scan with Nmap](image/B22229_10_06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 使用Nmap进行基本UDP端口扫描的部分输出](image/B22229_10_06.jpg)'
- en: Figure 10.6 – Partial output from a basic UDP port scan with Nmap
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 使用Nmap进行基本UDP端口扫描的部分输出
- en: We’ll explore more advanced usage in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨更高级的用法。
- en: Fast network scanning with Masscan
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Masscan进行快速网络扫描
- en: Another popular port scanner is Masscan, which is an extremely fast port scanner.
    It can scan the whole internet in a matter of minutes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的端口扫描工具是Masscan，这是一个极快的端口扫描工具。它可以在几分钟内扫描整个互联网。
- en: Nmap is more full-featured than Masscan; however, Masscan has the capability
    to perform scans much faster by including a **--rate** option. Yes, Nmap also
    has the ability to tweak scan speed; however, Masscan can be much faster. Be careful
    with this option as you may overwhelm network devices such as routers and switches.
    When you have a *kickoff call* with project stakeholders before the pentest starts,
    you should ask whether you will be scanning through outdated network devices that
    may not be able to withstand high throughput.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 比 Masscan 功能更全面；但是，通过包括 **--rate** 选项，Masscan 可以执行更快的扫描。是的，Nmap 也可以调整扫描速度；但是，Masscan
    可能更快。请注意此选项，因为可能会压垮路由器和交换机等网络设备。在进行渗透测试开始前，与项目利益相关者进行 *启动会议* 时，应询问是否将扫描过时的网络设备，这些设备可能无法承受高吞吐量。
- en: 'A basic Masscan example can be found in the following figure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中可以找到基本的 Masscan 示例：
- en: '![Figure 10.7 – Partial output of an example Masscan scan](image/B22229_10_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 示例 Masscan 扫描的部分输出](image/B22229_10_07.jpg)'
- en: Figure 10.7 – Partial output of an example Masscan scan
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 示例 Masscan 扫描的部分输出
- en: 'On very large networks, I’ll frequently use Masscan to discover a list of live
    hosts, which are then fed to another more advanced scan. The following **masscan**
    command is what I use to discover live hosts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常大的网络上，我经常使用 Masscan 发现活动主机的列表，然后将其提供给另一个更高级的扫描。以下是我用来发现活动主机的 **masscan**
    命令：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break this down to understand it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解开来以理解它：
- en: '**-p 22,445** : On an internal network, every Linux host will have port **22**
    (SSH) exposed, and every Windows host will have port **445** ( SMB) exposed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p 22,445** ：在内部网络上，每个 Linux 主机将会暴露端口 **22**（SSH），每个 Windows 主机将会暴露端口 **445**（SMB）。'
- en: '**--open** : We specify **open** because don’t want to see closed or filtered
    ports.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--open** ：我们指定 **open**，因为我们不想看到关闭或筛选的端口。'
- en: '**-oL [outputfile]** : We specify the name of the file to save the results
    in list format. Other possible output formats include JSON, NDJSON, Grepable,
    Binary, XML, and Unicorn.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-oL [outputfile]** ：我们指定保存结果的文件名以列表格式。其他可能的输出格式包括 JSON、NDJSON、Grepable、Binary、XML
    和 Unicorn。'
- en: '**-iL [inputfile]** : We specify the **scope.txt** file containing the networks
    in scope.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-iL [inputfile]** ：我们指定包含在范围内网络的 **scope.txt** 文件。'
- en: '**--rate=5000** : This sends TCP *SYN* packets at a rate of 5,000 packets per
    second.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--rate=5000** ：这以每秒 5,000 个包的速率发送 TCP *SYN* 包。'
- en: 'On my lab network running GOAD and Vulhub, the output of my scan looks like
    the following figure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我运行 GOAD 和 Vulhub 的实验室网络上，我的扫描输出如下图所示：
- en: '![Figure 10.8 – Masscan host discovery output file content](image/B22229_10_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – Masscan 主机发现输出文件内容](image/B22229_10_08.jpg)'
- en: Figure 10.8 – Masscan host discovery output file content
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – Masscan 主机发现输出文件内容
- en: Processing scan results with Bash
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bash 处理扫描结果
- en: 'To display only live hosts, enter the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅显示活动主机，请输入以下命令：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the explanation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解释：
- en: '**''** : A single quote character starts and ends the **awk** command block.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**''** ：单引号字符开始并结束 **awk** 命令块。'
- en: '**$1 == "open"** : The first column is the word **open** , as seen in *Figure
    10* *.8* . Remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073) that
    **awk** splits columns on whitespace by default, which includes both spaces and
    tabs. If the columns were separated by tabs, this command would still work. Otherwise,
    include the **-F** option to specify a different field separator.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$1 == "open"** ：第一列是单词 **open**，如在 *图 10.8* 中所见。从 [*第 4 章*](B22229_04.xhtml#_idTextAnchor073)
    中记得，**awk** 默认在空白字符（包括空格和制表符）上分隔列。如果列用制表符分隔，该命令仍然有效。否则，包括 **-F** 选项指定不同的字段分隔符。'
- en: '**{ print $4 }** : Print the fourth column.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**{ print $4 }** ：打印第四列。'
- en: '**masscan.lst** : The Masscan output file that we want to parse using this
    command.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**masscan.lst** ：我们希望使用该命令解析的 Masscan 输出文件。'
- en: '**| sort -uV** : We pipe the **awk** command output to sort, specifying the
    **sort** options unique ( **-u** ) and version ( **-V** ).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**| sort -uV** ：我们将 **awk** 命令的输出导管到排序，指定排序选项为唯一（ **-u** ）和版本（ **-V** ）。'
- en: '**> livehosts.txt** : We redirect the output of the preceding commands from
    **stdout** to a file.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**> livehosts.txt** ：我们将前述命令的输出从 **stdout** 重定向到文件。'
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The **sort -V** (version) option is useful for sorting IP addresses and version
    numbers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**sort -V**（版本）选项对于排序 IP 地址和版本号很有用。'
- en: 'The output looks like the following if you remove the redirect to a file and
    print to **stdout** :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将输出移除到文件并打印到 **stdout**，输出如下所示：
- en: '![Figure 10.9 – Our unique sorted list of live IP addresses](image/B22229_10_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 我们唯一的已排序活跃 IP 地址列表](image/B22229_10_09.jpg)'
- en: Figure 10.9 – Our unique sorted list of live IP addresses
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 我们唯一的已排序活跃 IP 地址列表
- en: Comparing the output in *Figure 10* *.8* (unsorted) to *Figure 10* *.9* (sorted),
    you can see how the **sort -V** option is useful for sorting version numbers,
    IP addresses, or any string that is a combination of numbers separated by periods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将*图 10.8*（未排序）与*图 10.9*（已排序）中的输出进行比较，你可以看到**sort -V**选项对于排序版本号、IP 地址或任何由数字组成并以点分隔的字符串是非常有用的。
- en: Now, you have a list of live hosts, saving you valuable time when scanning very
    large networks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了一个活跃主机的列表，这在扫描非常大的网络时节省了宝贵的时间。
- en: Conclusion
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: This wraps up the section on the fundamentals of network pentesting with Bash.
    The foundation created by the concepts in this fundamental section, plus the previous
    work we covered in [*Chapter 6*](B22229_06.xhtml#_idTextAnchor148) on networking
    and basic port scans, will be used in the next section to learn about more advanced
    scanning techniques.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容总结了 Bash 网络渗透测试的基础知识。通过本节的基本概念，加上我们在[*第6章*](B22229_06.xhtml#_idTextAnchor148)中讨论的网络和基础端口扫描内容，下一节将学习更高级的扫描技术。
- en: Advanced network scanning techniques in Bash
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 中的高级网络扫描技术
- en: This section will go more in depth, demonstrating some of the most common advanced
    options of Nmap. Then, we’ll follow up with a primer on parsing the report output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将更深入地讲解，演示一些 Nmap 的最常用高级选项。然后，我们将继续讲解如何解析报告输出。
- en: 'This is the Nmap scan command I use most of ten for network pentesting:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在网络渗透测试中最常使用的 Nmap 扫描命令：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the explanation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: '**-sS** : *SYN* scan, or half-open scan. This sends only the first part of
    the TCP handshake and scans much faster than the default connect ( **-sT** ) scan,
    which completes the TCP three-way handshake.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-sS** ：*SYN* 扫描，或半开放扫描。这仅发送 TCP 握手的第一部分，扫描速度比默认的连接扫描（**-sT**）要快，后者完成了 TCP
    三次握手。'
- en: '**-sV** : A version scan fingerprints the service name and version instead
    of the default, which only prints the default service name associated with the
    port number.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-sV** ：版本扫描会指纹识别服务名称和版本，而不是默认的，仅打印与端口号关联的默认服务名称。'
- en: '**-sC** : Runs Nmap scripts against all open ports. The output of these scripts
    frequently reveals important or even exploitable information.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-sC** ：对所有开放端口运行 Nmap 脚本。这些脚本的输出通常会揭示出重要的信息，甚至是可利用的信息。'
- en: '**-p [port list]** : The list of ports to scan. These are port numbers that
    I have found to be the most common exploitable ports in my experience. If you’re
    scanning a single host or small number of hosts, or you absolutely must find every
    open port, use **-p-** instead, which is shorthand for all ports.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-p [端口列表]** ：要扫描的端口列表。这些是我根据经验发现最常见的可利用端口。如果你正在扫描单个主机或少量主机，或者你绝对需要找到所有开放端口，可以使用**-p-**，这是表示所有端口的简写。'
- en: '**--open** : Only record open ports; don’t show closed or filtered ports in
    the output.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--open** ：只记录开放端口；不显示输出中的关闭或过滤端口。'
- en: '**-oA [output file]** : The **A** option equates to all formats. If you named
    the output file **nmapquick** , you would find the following three output files
    in the current directory once the scan completes: **nmapquick.nmap** , **nmapquick.gnmap**
    , and **nmapquick.xml** .'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-oA [输出文件]** ：**A**选项代表所有格式。如果你将输出文件命名为**nmapquick**，扫描完成后你会在当前目录下找到以下三个输出文件：**nmapquick.nmap**，**nmapquick.gnmap**，和**nmapquick.xml**。'
- en: '**-iL [input file]** : The file containing the list of IP addresses, network
    addresses, or hostnames to scan.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-iL [输入文件]** ：包含要扫描的 IP 地址、网络地址或主机名的文件。'
- en: '**--exclude-file [exclude file]** : The file containing a list of IP addresses,
    network addresses, or hostnames to exclude from your scan. See the *Rules of Engagement*
    document for your pentest to find a list of any hosts to be excluded.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--exclude-file [排除文件]** ：包含要从扫描中排除的 IP 地址、网络地址或主机名的文件。请参见你的渗透测试的*参与规则*文档，查找任何需要排除的主机列表。'
- en: 'In the scan output, we examine one of the hosts in the following figure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描输出中，我们查看以下图中的一台主机：
- en: '![Figure 10.10 – The output of our scan on one host](image/B22229_10_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 我们对单个主机的扫描结果](image/B22229_10_10.jpg)'
- en: Figure 10.10 – The output of our scan on one host
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 我们对单个主机的扫描结果
- en: The Nmap script output can be seen by the dashed lines and the output they contain
    in the figure. This reveals the hostname and service versions. Additionally, we
    can guess that this is an Active Directory domain controller because it’s running
    Microsoft Windows, and ports **53** , **88** , **3268** , and **3269** are open.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 脚本输出可以通过虚线和它们包含的输出在图中看到。这显示了主机名和服务版本。此外，我们可以猜测这是一个活动目录域控制器，因为它运行 Microsoft
    Windows，并且端口**53**、**88**、**3268**和**3269**是开放的。
- en: 'Scanning can be a trade-off between fast and thorough. For example, in the
    scan that we ran last, which specified a limited number of common ports, the output
    for host **10.2.10.1** shows one open port, as seen in the following figure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描可能是快速和彻底之间的权衡。例如，在我们上次运行的扫描中，指定了有限数量的常见端口，对主机**10.2.10.1**的输出显示了一个开放端口，如下图所示：
- en: '![Figure 10.11 – Nmap scan output using a limited number of common ports](image/B22229_10_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 使用有限数量的常见端口进行 Nmap 扫描输出](image/B22229_10_11.jpg)'
- en: Figure 10.11 – Nmap scan output using a limited number of common ports
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 使用有限数量的常见端口进行 Nmap 扫描输出
- en: If we rescan this host using the **-p-** (all ports) option, we find that the
    host actually has seven open ports, some running vulnerable applications. This
    example illustrates the difference between fast and thorough scanning. What I
    normally do when testing small networks is scan all ports. If I’m testing a large
    network, I run one fast scan specifying a limited number of ports, and while I’m
    working through that scan result, I start a second scan running targeting all
    ports, which I expect to take a day or more to complete.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用**-p-**（所有端口）选项重新扫描此主机，我们会发现该主机实际上有七个开放端口，其中一些运行着易受攻击的应用程序。此示例说明了快速和彻底扫描之间的区别。在测试小型网络时，我通常会扫描所有端口。如果我要测试一个大型网络，我会运行一个快速扫描，指定一定数量的端口，并在处理扫描结果时，我会启动针对所有端口的第二次扫描，预计需要一天或更长的时间才能完成。
- en: Now that you have a firm grasp of different port scanning techniques, let’s
    move on to the next section and explore various exploitable network protocols.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对不同的端口扫描技术有了牢固的掌握，让我们继续下一节，探索各种可利用的网络协议。
- en: Enumerating network services and protocols using Bash
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 枚举网络服务和协议
- en: I perform a network packet capture on every internal network pentest. I’m looking
    for the default **Hot Standby Router Protocol** ( **HSRP** ) default password
    of **'cisco'** , DHCPv6 discovering broadcasts without a corresponding offer,
    and broadcast or multicast protocols such as LLMNR, NBT-NS, and MDNS, which can
    yield password hashes or be relayed to crack into other systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每次网络内扫描测试中都执行网络数据包捕获。我寻找默认的**热备用路由器协议**（**HSRP**）默认密码**'cisco'**，没有相应提供的 DHCPv6
    发现广播，以及广播或多播协议，如 LLMNR、NBT-NS 和 MDNS，这些协议可以生成密码哈希或被中继到其他系统进行破解。
- en: 'The following code can be found on this chapter’s GitHub page as **packetcap.sh**
    :'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码可以在本章的 GitHub 页面上找到，命名为**packetcap.sh**：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first block of code is the familiar shebang, followed by an **if** statement
    that prints usage information and exits if exactly one argument is not provided.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码块是熟悉的 shebang，后面是一个**if**语句，如果没有提供正好一个参数，就会打印使用信息并退出。
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This block of code lets the user know what’s happening before running tcpdump
    for two and a half minutes. After **sudo** , the **timeout 150** command preceding
    **tcpdump** runs **tcpdump** for 150 seconds and quits.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块让用户在运行 tcpdump 两分半钟之前知道发生了什么。在**sudo**之后，**tcpdump**之前的**timeout 150**命令运行**tcpdump**
    150秒然后退出。
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This block of code detects plaintext HSRP broadcasts using the default **'cisco'**
    password. If you have this password, you can poison the HSRP election process
    and take over as the default router, and execute a **Man-in-the-Middle** ( **MITM**
    ) attack on all traffic.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块检测使用默认**'cisco'**密码的明文 HSRP 广播。如果您知道此密码，您可以操纵 HSRP 选举过程并接管默认路由器，并对所有流量执行**中间人攻击**（**MITM**）。
- en: Tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you detect the default HSRP password in use on a network, I caution you to
    not attempt to execute an MITM attack on it. If you’re not on-site with the system
    running the attack and you lose your network connection, you may cause a denial
    of service to the network and you won’t be there to stop it. This is very risky
    to exploit. It’s best to report it and move on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在网络中检测到使用默认的 HSRP 密码，我建议您不要尝试对其执行 MITM 攻击。如果您不在现场与运行攻击的系统一起并且失去了网络连接，您可能会导致网络拒绝服务，而您也不在那里停止它。这是非常危险的利用。最好是报告并继续前进。
- en: 'In the next code block, we start testing for **IP version 6** ( **IPv6** )
    network traffic:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们开始测试 **IP 第六版** (**IPv6**) 网络流量：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This block of code tests for DHCPv6 traffic. If you see DHCPv6 discover broadcasts
    without a responding offer, the network is likely to be vulnerable to an attack
    where you can run the mitm6 tool and capture password hashes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这一代码块测试 DHCPv6 流量。如果你看到没有响应的 DHCPv6 discover 广播，网络很可能会受到攻击，可以运行 mitm6 工具并捕获密码哈希。
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This block of code runs the *Responder* tool in a subshell so that you won’t
    see the output. Then, it prints anything in the **Responder-Session** log. You
    may see password hashes or plaintext passwords in the output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这一代码块在子 Shell 中运行 *Responder* 工具，这样你就看不到输出。然后，它会打印 **Responder-Session** 日志中的任何内容。你可能会在输出中看到密码哈希或明文密码。
- en: 'The following figures show the script in action. This shows the start of the
    script output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了脚本执行的过程。这里显示了脚本输出的开始：
- en: '![Figure 10.12 – Starting the network sniffer script](image/B22229_10_12.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 启动网络嗅探脚本](image/B22229_10_12.jpg)'
- en: Figure 10.12 – Starting the network sniffer script
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 启动网络嗅探脚本
- en: Further down in the output, you see password hashes printed to the screen. This
    is an NTLMv2 password hash, which you should attempt to crack using **hashcat**
    . You can also reconfigure **Responder** and run it again along with **impacket-ntlmrelayx**
    to relay to other systems to run commands or dump credentials.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的后面，你会看到密码哈希打印到屏幕上。这是一个 NTLMv2 密码哈希，你应该尝试使用 **hashcat** 破解它。你也可以重新配置 **Responder**，然后重新运行它，并与
    **impacket-ntlmrelayx** 一起中继到其他系统，以运行命令或转储凭据。
- en: '![Figure 10.13 – Responder captures a password hash](image/B22229_10_13.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – Responder 捕获密码哈希](image/B22229_10_13.jpg)'
- en: Figure 10.13 – Responder captures a password hash
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – Responder 捕获密码哈希
- en: 'Next, let’s attempt to crack them using **hashcat** . Before running the following
    command, copy and save those hashes to a file. Next, run **hashcat** as shown
    in the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用 **hashcat** 破解它们。在运行以下命令之前，先将这些哈希复制并保存到一个文件中。然后，按以下命令运行 **hashcat**：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following figure shows that we cracked one of the password hashes!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们破解了其中一个密码哈希！
- en: '![Figure 10.14 – Hashcat is used to crack an NTLMv2 password hash](image/B22229_10_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 使用 Hashcat 破解 NTLMv2 密码哈希](image/B22229_10_14.jpg)'
- en: Figure 10.14 – Hashcat is used to crack an NTLMv2 password hash
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 使用 Hashcat 破解 NTLMv2 密码哈希
- en: Tip
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You aren’t limited to only cracking password hashes from these protocols; you
    can also relay them. Search the internet for **relay LLMNR** to find out more
    about the subject.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅局限于破解这些协议中的密码哈希；你还可以中继它们。搜索互联网了解更多关于 **relay LLMNR** 的信息。
- en: Don’t overlook these protocols on your network. While they aren’t listening
    services that you can point an exploit at and get a shell, they are *dangerous
    default* protocols that you’re likely to find broadcast on any Windows domain,
    and they are usually the fastest way to exploit systems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视你网络中的这些协议。虽然它们不是可以直接指向漏洞并获得 Shell 的监听服务，但它们是 *危险的默认* 协议，通常可以在任何 Windows
    域中广播，并且通常是攻击系统的最快方式。
- en: In the next section, we’ll explore using Bash with vulnerabi lity assessment
    and exploitation tools.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索如何使用 Bash 与漏洞评估和利用工具。
- en: Infrastructure vulnerability assessment with Bash
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 进行基础设施漏洞评估
- en: 'Assessing infrastructure vulnerabilities is a critical step in maintaining
    network security. With Bash, we can leverage powerful tools to automate network
    host discovery and vulnerability scanning, streamlining the assessment process.
    This section covers two essential techniques: identifying network hosts with NetExec
    and automating vulnerability scans using Greenbone. Each technique offers a practical
    approach to improving your security posture by reducing manual effort while enhancing
    efficiency and accuracy in detecting vulnerabilities.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 评估基础设施漏洞是保持网络安全的关键步骤。通过 Bash，我们可以利用强大的工具来自动化网络主机发现和漏洞扫描，简化评估过程。本节介绍了两种重要技术：使用
    NetExec 识别网络主机和使用 Greenbone 自动化漏洞扫描。每种技术都提供了一种务实的方式，通过减少人工操作、提高效率和准确性，改善你的安全态势。
- en: Enumerating network hosts with NetExec
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NetExec 枚举网络主机
- en: Starting from an unauthenticated perspective, we will examine TCP port **445**
    since it’s historically had a lot of vulnerabilities and can yield a lot of information.
    We will use the NetExec tool to enumerate network hosts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从未验证的角度出发，我们将检查 TCP 端口 **445**，因为它历来存在许多漏洞，并且可能提供大量信息。我们将使用 NetExec 工具来枚举网络主机。
- en: 'First, let’s attempt to use an SMB null session to enumerate SMB shares. Run
    the following command, replacing the network address with the a ppropriate address
    for your lab instance:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试使用 SMB 空会话枚举 SMB 共享。运行以下命令，将网络地址替换为您实验室实例的适当地址：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the explanation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释：
- en: '**netexec smb** : Here, we specify the protocol for NetExec to use. The **netexec**
    command has multi-protocol support, including SMB.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**netexec smb** : 在这里，我们指定 NetExec 要使用的协议。**netexec** 命令支持多种协议，包括 SMB。'
- en: '**10.2.10.0/24** : The target goes after **netexec** and the protocol. The
    target can be an IP address, hostname, network address, or a file containing targets
    (one per line).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10.2.10.0/24** : 目标位于 **netexec** 和协议后面。目标可以是 IP 地址、主机名、网络地址，或者包含目标的文件（每行一个目标）。'
- en: '**-u a -p ''''** : We specify a random username ( **a** ), followed by a blank
    password ( **''''** ).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-u a -p ''''** : 我们指定了一个随机用户名（**a**），后跟一个空密码（**''''**）。'
- en: '**--shares** : This is a **netexec** command to enumerate SMB shares.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--shares** : 这是一个 **netexec** 命令，用于枚举 SMB 共享。'
- en: 'The following figure shows the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了输出：
- en: '![Figure 10.15 – Performing SMB null session SMB share enumeration with NetExec.](image/B22229_10_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 使用 NetExec 执行 SMB 空会话 SMB 共享枚举。](image/B22229_10_15.jpg)'
- en: Figure 10.15 – Performing SMB null session SMB share enumeration with NetExec.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 使用 NetExec 执行 SMB 空会话 SMB 共享枚举。
- en: Note that this is a cropped screenshot and doesn’t show the hostname or IP address
    of each system. Without cropping the image, the text would be too small to read.
    Notice where we have read or write permissions in the preceding figure. In this
    case, I recommend taking the time to connect to these SMB shares and look for
    interesting information, such as passwords in files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个裁剪过的截图，并未显示每个系统的主机名或 IP 地址。如果不裁剪图片，文本会变得太小，难以阅读。请注意我们在前面的图中显示的读写权限。在这种情况下，我建议您花时间连接到这些
    SMB 共享并寻找有趣的信息，例如文件中的密码。
- en: 'Next, let’s attempt to use an SMB null session to enumerate users. Run the
    following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用 SMB 空会话枚举用户。运行以下命令：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only difference between this and the previous command is we’ve changed
    shares ( **--shares** ) to users ( **--users** ). We check the output and see
    we had no luck enumerating users. Before giving up, let’s r evise the command
    as follows and try again:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与之前的命令唯一的区别在于，我们将共享（**--shares**）改为用户（**--users**）。我们检查输出并发现我们在枚举用户时没有成功。在放弃之前，让我们按以下方式修改命令并再次尝试：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, instead of specifying a username, we’ve used a blank username.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，除了指定用户名，我们使用了一个空的用户名。
- en: '![Figure 10.16 – Using an SMB null session to list domain users](image/B22229_10_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 使用 SMB 空会话列出域用户](image/B22229_10_16.jpg)'
- en: Figure 10.16 – Using an SMB null session to list domain users
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 使用 SMB 空会话列出域用户
- en: So why did one method of specifying an invalid username fail and the other succeed?
    Without going too far off the track of our Bash topic, it’s due to how the libraries
    used in this tool authenticate to Microsoft Windows SMB shares. I’ll leave that
    as an exercise to you. I just want you to be aware of this quirk.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么指定一个无效用户名的某种方法失败了，而另一个成功了呢？不深入探讨我们 Bash 主题的前提下，这是因为该工具所使用的库如何验证 Microsoft
    Windows SMB 共享。这个问题留给你作为练习。我只是希望你注意到这个怪癖。
- en: 'Using these usernames, you can use NetExec to password spray common passwords
    and maybe you’ll get lucky. But do you really need to password spray? Go and take
    another look at *Figure 10* *.16* and check the **Description** column. Do you
    see the password for Samwell Tarly? You would be surprised how often this happens
    on the average corporate network! Many system administrators don’t realize that
    null sessions and unprivileged users can see this information. Let’s test this
    password, as seen in the next figure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些用户名，您可以使用 NetExec 执行密码喷射攻击，尝试常见密码，或许能幸运地猜中。但是，您真的需要进行密码喷射吗？去再看看 *图 10.16*，检查
    **描述** 列。你看到 Samwell Tarly 的密码了吗？你会惊讶地发现，普通企业网络中这种情况发生得多么频繁！许多系统管理员没有意识到，空会话和无权限用户可以看到这些信息。让我们测试这个密码，正如下图所示：
- en: '![Figure 10.17 – Testing credentials with NetExec](image/B22229_10_17.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 使用 NetExec 测试凭证](image/B22229_10_17.jpg)'
- en: Figure 10.17 – Testing credentials with NetExec
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 使用NetExec测试凭证
- en: In the preceding figure, we see that the credentials for Samwell Tarly are authenticated
    to three systems, but this account isn’t an administrator on any of them, otherwise,
    the output would show **Pwn3d!** . There’s a lot more we can do with these credentials.
    I’ll leave it as an exercise for you to run **netexec** with the **--help** and
    **-L** (list modules) options to explore the commands and modules available to
    you.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到Samwell Tarly的凭证已通过身份验证连接到三个系统，但该账户在任何系统上都不是管理员，否则输出将显示**Pwn3d!**。我们可以对这些凭证做更多的事情。我将留给你一个练习，使用**netexec**命令配合**--help**和**-L**（列出模块）选项来探索可用的命令和模块。
- en: Hint
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re following along in your own GOAD lab, take a look at the **petitpotam**
    SMB module.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的GOAD实验室中进行操作，查看一下**petitpotam** SMB模块。
- en: Next, we’ll dive into vulnerability scanning from the Bash shell.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨如何从Bash shell进行漏洞扫描。
- en: Automating vulnerability scanning with Greenbone
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Greenbone自动化漏洞扫描
- en: There are a number of top vulnerability scan products on the market. All have
    a web interface. However, you should learn how to automate these scans from the
    Bash shell to save yourself valuable time. When I was responsible for enterprise
    vulnerability scanning of a global corporation, I used Bash shell to interface
    with the scanner API to automate as much of my job as I could, including gathering
    statistics for custom reports.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多顶级的漏洞扫描产品，所有这些产品都有一个Web界面。然而，你应该学习如何从Bash shell自动化这些扫描，以节省宝贵的时间。当我负责全球公司企业漏洞扫描时，我使用Bash
    shell与扫描器API进行交互，尽可能地自动化我的工作，包括收集统计数据以生成自定义报告。
- en: We will use the Greenbone Community Edition, formerly known as OpenVAS. If you
    want to follow along in your own lab, you should first review the *Technical requirements*
    section if you have not already installed Greenbone.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Greenbone Community Edition，前身为OpenVAS。如果你想在自己的实验室中跟随操作，你应该首先查看*技术要求*部分，如果你还没有安装Greenbone的话。
- en: 'Create a scan target as shown here, replac ing the password and network with
    your own values:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建扫描目标，如图所示，将密码和网络替换为你自己的值：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of this command can be found in the following figure:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以在下图中找到：
- en: '![Figure 10.18 – Creating a scan target in GVM](image/B22229_10_18.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 在GVM中创建扫描目标](image/B22229_10_18.jpg)'
- en: Figure 10.18 – Creating a scan target in GVM
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 在GVM中创建扫描目标
- en: 'Copy the target ID output from creating a target to cr eate a task for a full
    and fast scan, as shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建目标时复制目标ID输出，创建一个用于快速完整扫描的任务，如下所示：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this command can be found in the following figure:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以在下图中找到：
- en: '![Figure 10.19 – A scan task is created in GVM for demonstration](image/B22229_10_19.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 在GVM中创建一个扫描任务进行演示](image/B22229_10_19.jpg)'
- en: Figure 10.19 – A scan task is created in GVM for demonstration
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 在GVM中创建一个扫描任务进行演示
- en: 'Start the task using the task I D found in the response from the previous command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个命令响应中的任务ID启动任务：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this command can be found in the following figure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以在下图中找到：
- en: "![Figure 10.20 – Starting a task in GVM\uFEFF\uFEFF](image/B22229_10_20.jpg)"
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 在GVM中启动任务](image/B22229_10_20.jpg)'
- en: Figure 10.20 – Starting a task in GVM
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 在GVM中启动任务
- en: 'Check the task status using the command as shown:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下命令检查任务状态：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of this command can be found in the following figure:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以在下图中找到：
- en: '![Figure 10.21 – Demonstrating checking the scan task status](image/B22229_10_21.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – 演示检查扫描任务状态](image/B22229_10_21.jpg)'
- en: Figure 10.21 – Demonstrating checking the scan task status
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 演示检查扫描任务状态
- en: 'Download the report using the report ID from the previous command output, as
    shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个命令输出中的报告ID下载报告，如下所示：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let’s create a script to automate this process and parse the report.
    The following code can be found in this chapter’s GitHub repository as **ch10_gvm_scan.sh**
    :'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个脚本来自动化这个过程并解析报告。以下代码可以在本章的GitHub仓库中找到，名为**ch10_gvm_scan.sh**：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding block of code begins with the familiar shebang line. It then checks
    to ensure the user running the script is the **_gvm** user, which is a user created
    during the **gvm** installation process. If not running as this user, the script
    exits.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块以熟悉的shebang行开始。接下来，它检查运行脚本的用户是否是**_gvm**用户，这是在**gvm**安装过程中创建的用户。如果不是以该用户身份运行，脚本将退出。
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The script will exit if there are less than two arguments.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数少于两个，脚本会退出。
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we assign the first argument to the **password** variable,
    and the second argument to the **target_host** variable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将第一个参数赋值给**password**变量，将第二个参数赋值给**target_host**变量。
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we’re simply replacing any **/** character in the target with an underscore.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅是将目标中的任何**/**字符替换为下划线。
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code block creates a target in the GVM system:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块在 GVM 系统中创建一个目标：
- en: It uses **gvm-cli** to send an XML request to create a target.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用**gvm-cli**发送 XML 请求来创建目标。
- en: The target is created with the specified name, host, and port range.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标通过指定的名称、主机和端口范围创建。
- en: It extracts the target ID from the response.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从响应中提取目标 ID。
- en: If target creation fails (empty **target_id** ), the script exits.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标创建失败（**target_id**为空），脚本会退出。
- en: 'The following code will create a scan task:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建一个扫描任务：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This section creates a task in the GVM system:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分在 GVM 系统中创建一个任务：
- en: It uses **gvm-cli** to send an XML request to create a task.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用**gvm-cli**发送 XML 请求来创建任务。
- en: The task is created with a name, comment, configuration, and the previously
    created target.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务创建时会包含名称、评论、配置以及之前创建的目标。
- en: It extracts the task ID from the response.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从响应中提取任务 ID。
- en: 'The **grep -o ''id="[^"]*"''** command searches for all occurrences of **pattern
    id="[^"]*"** in the input text and outputs only the matching parts:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**grep -o ''id="[^"]*"''** 命令会在输入文本中搜索所有出现的 **pattern id="[^"]*"**，并仅输出匹配的部分：'
- en: '**id="** matches the literal string, **id="**'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id="** 匹配字面字符串，**id="**。'
- en: '**[^"]*** matches zero or more characters that are not a double quote ( **"**
    ). **[^"]** is a negated character class meaning any character except **"** :'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**[^"]*** 匹配零个或多个不是双引号（**"**）的字符。**[^"]** 是一个否定字符类，意味着任何字符都可以是除**"**之外的字符。'
- en: '**"** matches the closing double quote'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"** 匹配关闭双引号。'
- en: If task creation fails (empty **task_id** ), the script exits.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任务创建失败（**task_id**为空），脚本会退出。
- en: 'Next, we need to start the scan, as shown in this code block:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要开始扫描，如下所示：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code starts the scan task using variables captured from previous
    commands and extracts **report_id** from the response:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用从之前的命令中捕获的变量启动扫描任务，并从响应中提取**report_id**：
- en: '**(?<=<report_id>).*?(?=</report_id>)** : This is the regular expression that
    is used.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(?<=<report_id>).*?(?=</report_id>)** : 这是使用的正则表达式。'
- en: '**(?<=<report_id>)** : This is a positive look-behind assertion.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(?<=<report_id>)** : 这是一个正向回溯断言。'
- en: '**(?<=...)** : This syntax specifies a look behind, which ensures that what
    precedes the current position in the string is the specified pattern, **<report_id>**
    .'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(?<=...)** : 该语法指定了一个向后查找，确保当前位置之前的内容是指定的模式，**<report_id>**。'
- en: '**<report_id>** : This is the literal string that must precede the match.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<report_id>** : 这是必须在匹配之前出现的字面字符串。'
- en: '**.*?** : This is a non-greedy match for any character sequence.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.*?** : 这是一个非贪婪匹配，匹配任何字符序列。'
- en: '**.** : This matches any character except a newline.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.** : 这匹配除换行符外的任何字符。'
- en: '***?** : This matches zero or more of the preceding elements ( **.** in this
    case), but in a non-greedy (or lazy) manner, meaning it will match as few characters
    as possible.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***?** : 这匹配零个或多个前面的元素（此处是**.**），但以非贪婪（或懒惰）的方式进行匹配，即它将尽可能少地匹配字符。'
- en: '**(?=</report_id>)** : This is a positive look-ahead assertion.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(?=</report_id>)** : 这是一个正向预查断言。'
- en: '**(?=...)** : This syntax specifies a look-ahead, which ensures that what follows
    the current position in the string is the specified pattern, **</report_id>**
    .'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(?=...)** : 该语法指定了一个向前查找，确保当前位置后面的内容是指定的模式，**</report_id>**。'
- en: '**</report_id>** : This is the literal string that must follow the match.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**</report_id>** : 这是必须紧随匹配后的字面字符串。'
- en: 'The next code section continuously checks for task completion every 60 seconds:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码部分每隔60秒检查一次任务是否完成：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code starts a **while** loop. The **gvm-cli** command output is
    printed in a line-by-line format by piping it to **xmlstarlet** , then saved to
    the **output** variable. If the output status confirms it’s completed, it breaks
    out of the loop. Otherwise, there is a one-minute pause before the loop repeats.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码开始了一个**while**循环。**gvm-cli**命令的输出通过管道传输给**xmlstarlet**逐行打印，并保存到**output**变量中。如果输出状态确认已完成，则退出循环。否则，程序会暂停一分钟后重新开始循环。
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code block requests the scan results (vulnerabilities) detected
    in the scan task. It pipes the output to **xmlstarlet** to parse the XML content
    and output the most interesting parts. Finally, it sorts based on the sixth column
    ( **severity** ) and prints the data fields with a tab ( **\** **t** ) separator:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块请求扫描任务中检测到的扫描结果（漏洞）。它将输出通过管道传递给**xmlstarlet**，以解析XML内容并输出最感兴趣的部分。最后，它根据第六列（**severity**）进行排序，并使用制表符（**\t**）分隔符打印数据字段：
- en: '**xmlstarlet** is a command-line tool for parsing, querying, transforming,
    and editing XML files. It can be used to extract specific data from XML documents,
    modify XML structures, and perform various other XML-related tasks.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xmlstarlet**是一个命令行工具，用于解析、查询、转换和编辑XML文件。它可以用来从XML文档中提取特定数据，修改XML结构，并执行各种与XML相关的任务。'
- en: '**sel -t** : This is short for *select* . It indicates that we are using the
    selection sub-command to query XML data. The **-t** stands for *template* . It
    is used to define the output template.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sel -t**：这是*select*的缩写。它表示我们正在使用选择子命令来查询XML数据。**-t**表示*template*。它用于定义输出模板。'
- en: '**-m "//result"** : This stands for *match* . It specifies an XPath expression
    to select nodes from the XML document.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-m "//result"**：这代表*match*。它指定一个XPath表达式，用于从XML文档中选择节点。'
- en: '**//result** : This XPath expression selects all result elements in the XML
    document, regardless of their location in the hierarchy.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**//result**：这个XPath表达式选择XML文档中所有的result元素，无论它们在层次结构中的位置如何。'
- en: '**sort -t''|'' -k6,6nr** : The **-k** option specifies the key (field) to sort
    by, and the **nr** suffix indicates the type of sorting (numerical and reverse
    order).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sort -t''|'' -k6,6nr**：**-k**选项指定要排序的关键字（字段），而**nr**后缀表示排序类型（数字排序并按逆序排列）。'
- en: '**-k6,6** : This option tells **sort** to use the sixth field as the key for
    sorting. The **6,6** syntax means it should start and stop sorting on the sixth
    field.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-k6,6**：此选项告诉**sort**使用第六个字段作为排序的关键字。**6,6**语法意味着它应从第六个字段开始并在第六个字段结束进行排序。'
- en: '**awk -F''|'' ''{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $5}''** : This
    code determines how the data is printed:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**awk -F''|'' ''{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $5}''**：这段代码确定了数据的打印方式：'
- en: '**-F** : This option tells **awk** to use a specific character as the field
    separator.'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-F**：此选项告诉**awk**使用特定字符作为字段分隔符。'
- en: '**''|''** : The pipe character is specified as the delimiter. This means **awk**
    will consider the text between pipe characters as separate fields.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**''|''**：管道符号被指定为分隔符。这意味着**awk**将把管道符号之间的文本视为独立的字段。'
- en: '**{ ... }** : Encloses the action to be performed on each input line.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**{ ... }**：包围要对每一行输入执行的操作。'
- en: '**printf** : A function in **awk** (and many programming languages) used for
    formatted output.'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**printf**：**awk**（以及许多编程语言）中的一个函数，用于格式化输出。'
- en: '**"%s\t%s\t%s\t%s\t%s\n"** : This format string tells **printf** to output
    five string fields ( **%s** ), each followed by a tab character ( **\t** ), and
    end the line with a newline character ( **\n** ).'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**"%s\t%s\t%s\t%s\t%s\n"**：这个格式字符串告诉**printf**输出五个字符串字段（**%s**），每个字段后跟一个制表符（**\t**），并以换行符（**\n**）结束这一行。'
- en: '**$1, $2, $3, $4, $5** : These are field variables in **awk** . **$1** refers
    to the first field, **$2** to the second field, and so on. Since the field separator
    is a pipe ( **|** ), these variables correspond to the data between the pipes.'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$1, $2, $3, $4, $5**：这些是**awk**中的字段变量。**$1**表示第一个字段，**$2**表示第二个字段，以此类推。由于字段分隔符是管道符（**|**），这些变量对应于管道符之间的数据。'
- en: 'The script must be run as the **_gvm** user. When we prefix each command with
    **sudo** inside the script, there’s enough time between some of the steps that
    it will prompt you for credentials while you’ve stepped away, unaware that it’s
    waiting for your input. Instead, we’ll run the script with **sudo -u _gvm** prefixed,
    so you’ll need to run the following comma nds to set up directory and file permissions
    before running the script:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本必须以**_gvm**用户身份运行。当我们在脚本中为每个命令加上**sudo**前缀时，由于某些步骤之间有足够的时间，系统会在你离开时提示你输入凭证，而你可能没有意识到它在等待你的输入。相反，我们将脚本前缀加上**sudo
    -u _gvm**，因此在运行脚本之前，你需要执行以下命令来设置目录和文件权限：
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s look at the explanation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看解释：
- en: We created a new directory using the **mkdir** command.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用**mkdir**命令创建了一个新目录。
- en: The script is copied to the new directory.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本被复制到新目录中。
- en: The directory permissions are changed to set user and group permissions to **7**
    . The number **7** for the user and group equates to read (4), write (2), and
    execute (1) ( *4 + 2 + 1 = 7* ), and the other permissions to read (4) and execute
    (1) ( *4 + 1 =* *5* ).
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录权限已更改，用户和组的权限设置为 **7**。用户和组的权限数字 **7** 代表读取 (4)、写入 (2) 和执行 (1)（*4 + 2 + 1
    = 7*），而其他权限设置为读取 (4) 和执行 (1)（*4 + 1 =* *5*）。
- en: Finally, the owner is changed recursively to the **kali** user and **_gvm**
    group on the new directory and everything inside the directory.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，所有者递归地更改为 **kali** 用户和 **_gvm** 组，适用于新目录及目录中的所有文件。
- en: 'The following figure demonstrates how to run the script and shows the script
    output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了如何运行脚本并展示了脚本输出：
- en: '![Figure 10.22 – The Greenbone scan script is demonstrated and shows the scan
    results](image/B22229_10_22.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 展示了 Greenbone 扫描脚本并显示扫描结果](image/B22229_10_22.jpg)'
- en: Figure 10.22 – The Greenbone scan script is demonstrated and shows the scan
    results
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 展示了 Greenbone 扫描脚本并显示扫描结果
- en: You can learn more about **gvm-cli** usage at https://docs.greenbone.net/GSM-Manual/gos-22.04/en/gmp.html#starting-a-scan-using-the-command-gvm-cli
    .
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 https://docs.greenbone.net/GSM-Manual/gos-22.04/en/gmp.html#starting-a-scan-using-the-command-gvm-cli
    学习更多关于 **gvm-cli** 的使用。
- en: This concludes the section where we focused on vulnerability scanning automation.
    Our attention and focus abilities are finite. Always automate the mundane, repeatable
    tasks so you have more time and the ability to focus on carefully reviewing scan
    results for the smallest details to uncover exploitable vulnerabilities.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本节结束时，我们重点讨论了漏洞扫描的自动化。我们的注意力和专注力是有限的。始终自动化那些琐碎、可重复的任务，这样你就能有更多时间专注于仔细审查扫描结果，发现可以利用的漏洞。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter explored the topic of using Bash scripting for network pentesting
    and automation. Port scanning was thoroughly explored, from basic command-line
    options through advanced techniques necessary to tune for speed and depth of results.
    We went through the discovery of common network protocols that are frequently
    exploited. Finally, we dived into the automation of network vulnerability scanning
    tools.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了使用 Bash 脚本进行网络渗透测试和自动化的主题。我们深入探讨了端口扫描，从基本的命令行选项到必要的高级技术，以优化结果的速度和深度。我们讨论了常见的网络协议的发现，这些协议常常被攻击者利用。最后，我们深入研究了网络漏洞扫描工具的自动化。
- en: The next chapter will focus on post-exploitation privilege escalation techniques
    in a Bash environment. When remote network services are exploited, they commonly
    result in a non-root shell. In [*Chapter 11*](B22229_11.xhtml#_idTextAnchor317)
    , we will dive in and explore how to enumerate Linux systems in a Bash shell to
    escalate our privileges for a complete system takeover.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将聚焦于 Bash 环境中的后渗透特权提升技术。当远程网络服务被利用时，通常会导致非 root 的 shell。在 [*第 11 章*](B22229_11.xhtml#_idTextAnchor317)
    中，我们将深入探讨如何在 Bash shell 中枚举 Linux 系统，以提升权限并完成系统接管。
