- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Computer Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机系统
- en: As we discussed in previous chapters, digital forensic investigators must control
    the environment they operate in. The diversity of computer hardware, operating
    systems, and filesystems requires the digital forensic investigator to have a
    firm understanding of all the different and potential configurations they may
    encounter. This requires the digital forensic investigator to have procedures
    or controls to protect the integrity of digital evidence and the processes used
    to examine it. If you do not understand the boot process and how the system reacts
    when it starts or which filesystem is used on storage devices, you could make
    a fatal mistake. In addition, you must understand how they work together. Failure
    to understand these essential components could lead you to alter the digital evidence.
    You will also find that you will be less effective when you testify in judicial
    or administrative proceedings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的那样，数字取证调查员必须控制他们所操作的环境。计算机硬件、操作系统和文件系统的多样性要求数字取证调查员对可能遇到的各种配置有深刻的理解。这要求数字取证调查员必须有保护数字证据及其检查过程完整性的程序或控制措施。如果你不了解启动过程以及系统启动时的反应，或者不清楚存储设备上使用的是哪种文件系统，你可能会犯下致命的错误。此外，你还必须了解它们是如何协同工作的。不了解这些基本组件可能会导致你篡改数字证据。你还会发现，当你在司法或行政程序中作证时，你的效果会大打折扣。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the boot process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解启动过程
- en: Understanding filesystems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件系统
- en: Understanding the NTFS filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解NTFS文件系统
- en: Understanding the boot process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解启动过程
- en: To control the environment as we start our investigation, we must understand
    the environment. Here, digital evidence is being stored, created, and accessed.
    In most cases, this will be a computer system. I use the term “computer system,”
    which comprises the operating system, the filesystem, and the hardware bundled
    together to create a computer. To be effective, you must understand the physical
    media the data is stored on, the filesystem used on the storage device, and how
    that data is tracked and accessed while on the storage device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制环境以开始我们的调查，我们必须理解该环境。在这里，数字证据被存储、创建和访问。在大多数情况下，这将是一个计算机系统。我使用“计算机系统”这个术语，它包括操作系统、文件系统和硬件，这些组成部分结合在一起，构成了一个计算机。为了有效工作，你必须理解数据存储介质、存储设备上使用的文件系统，以及数据在存储设备上是如何被跟踪和访问的。
- en: Once you understand the process, you can then implement controls to protect
    the integrity of the digital evidence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了这一过程，你就可以实施控制措施，以保护数字证据的完整性。
- en: So, what is the boot process? When you push the power button and electricity
    energizes the system, commands are issued. As it executes the commands, the system
    is taking steps (like on a ladder) to achieve the goal of a running operating
    system. If something breaks any of those steps, the system will not load.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是启动过程呢？当你按下电源按钮并且电流激活系统时，命令被发出。在执行这些命令时，系统像爬楼梯一样一步步地走向运行操作系统的目标。如果某个步骤出现故障，系统将无法加载。
- en: The first step is the **Power-On Self-Test** (**POST**); the CPU will access
    the **Read-Only Memory** (**ROM**) and the **Basic Input/Output System** (**BIOS**)
    and test essential motherboard functions. This is where you hear the beep sound
    when you turn the power on to the computer system. If there is an error, the system
    will notify you of the error through beep codes. If you do not have the motherboard
    manual, a Google search will help determine the meaning of the specific beep code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是**开机自检**（**POST**）；CPU将访问**只读存储器**（**ROM**）和**基本输入输出系统**（**BIOS**），并测试主板的基本功能。你在开机时听到的“滴”的声音就来源于此。如果发生错误，系统将通过蜂鸣代码通知你错误。如果没有主板手册，使用Google搜索即可帮助你确定具体蜂鸣代码的含义。
- en: Once the **POST** test has been successfully completed, the BIOS is activated
    and executed. Note that the system has not accessed the storage media. This is
    because all the program executions occur at the motherboard level and not in the
    storage devices. The user can access the BIOS by using the correct key combination
    displayed on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦**POST**测试成功完成，BIOS被激活并执行。请注意，系统尚未访问存储介质。这是因为所有程序执行都发生在主板级别，而非存储设备上。用户可以通过使用显示在屏幕上的正确按键组合来访问BIOS。
- en: '**Note**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The time allowed for you to hit the correct key can sometimes be relatively
    short. If you are unsuccessful, the system will continue booting and accessing
    the storage device. If you are trying to access the suspect’s computer system,
    disengage the storage devices if they are accessible before starting the process.
    This will ensure that you are not booting to the suspect’s storage device and
    destroying evidence.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您按正确按键的时间有时可能相对较短。如果您未成功，系统将继续启动并访问存储设备。如果您尝试访问嫌疑人的计算机系统，请在开始之前断开可访问的存储设备。这将确保您不会启动到嫌疑人的存储设备并破坏证据。
- en: 'The BIOS will have the basic information of the system: the amount of RAM,
    the type of CPU, information about the attached drives, and the system date and
    time. The easiest way to document this information is to photograph it as it is
    displayed on the screen. This is also where you can change the boot sequence.
    Typically, the system checks the CD/DVD first and then the designated hard drive.
    This is where you would be able to change the setting of the boot device when
    we create the boot media later in the chapter. Changing the boot device tells
    the BIOS to access the device we provide and not the suspect’s device.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 将包含系统的基本信息：RAM 的大小、CPU 的类型、附加驱动器的信息以及系统的日期和时间。记录这些信息的最简单方法是拍下它显示在屏幕上的照片。这也是您可以更改启动顺序的地方。通常，系统首先检查
    CD/DVD，然后是指定的硬盘。这也是我们稍后在本章中创建启动介质时可以更改启动设备设置的地方。更改启动设备告诉 BIOS 访问我们提供的设备，而不是嫌疑人的设备。
- en: 'In 2010, the BIOS function was replaced by the **Unified Extensible Firmware
    Interface** (**UEFI**). It provides the same service as the BIOS, but has been
    enhanced, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2010 年，BIOS 功能被 **统一可扩展固件接口** (**UEFI**) 取代。它提供与 BIOS 相同的服务，但进行了以下增强：
- en: By providing better security at the preboot process
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在预启动过程中提供更好的安全性
- en: Faster startup
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的启动
- en: Will support drives larger than 2 TB
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将支持大于 2 TB 的驱动器
- en: Support for 64-bit device drivers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 64 位设备驱动程序
- en: Support for the **GUID Partition Table** (**GPT**)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 **GUID 分区表** (**GPT**)
- en: The Secure Boot feature allows us to use authenticated operating systems when
    booting the computer system. This can be an issue if you attempt to use an alternative
    booting device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动功能允许我们在启动计算机系统时使用经过认证的操作系统。如果您尝试使用替代的启动设备，这可能会成为一个问题。
- en: 'As you can see in the following diagram, once the power is turned on and it
    has completed the POST test, depending on the system, it may boot with the BIOS,
    or it may boot with the UEFI scheme:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，一旦打开电源并完成 POST 测试，根据系统的不同，它可能会使用 BIOS 启动，或者可能会使用 UEFI 方案启动：
- en: '![Figure 4.1 – Boot process ](img/B18329_04_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 启动过程](img/B18329_04_01.png)'
- en: 'Figure 4.1: Boot process'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：启动过程
- en: The BIOS will look for the **Master Boot Record** (**MBR**) of the boot device.
    The MBR is located at sector zero and holds information about the partitions,
    the filesystems, and the boot loader code for the installed operating system.
    Once the MBR is found in the boot loader and activated, control is then passed
    over to the operating system to complete the booting process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 将查找引导设备的 **主引导记录** (**MBR**)。MBR 位于第零扇区，保存有关分区、文件系统以及已安装操作系统的引导加载程序代码的信息。一旦在引导加载程序中找到并激活
    MBR，控制权将交给操作系统以完成启动过程。
- en: The UEFI will look for the GPT; the GPT will have a protective MBR to ensure
    legacy systems will not mistakenly read this as being unpartitioned and overwrite
    the data. It will also contain the partition entries and backup partition table
    header. A GPT disk can contain up to 128 partitions for a Windows operating system.
    Like in the BIOS scheme, once the active partition and boot loader have been found,
    the operating system will take over the booting process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 会查找 GPT；GPT 会包含一个保护性 MBR，以确保旧系统不会错误地将其识别为未分区并覆盖数据。它还将包含分区条目和备份分区表头。Windows
    操作系统的 GPT 磁盘最多可以包含 128 个分区。与 BIOS 方案类似，一旦找到活动分区和引导加载程序，操作系统将接管启动过程。
- en: Since you now understand the boot process, we still want to control the boot
    environment by creating forensic boot media, which we will discuss next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了启动过程，我们仍然希望通过创建法医启动介质来控制启动环境，接下来我们将讨论这一部分。
- en: Forensic boot media
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法医启动介质
- en: It is a widespread practice to remove the hard drive from the system to create
    a forensic image. However, sometimes, the investigator cannot remove the storage
    device from the system, and they need to create a forensic image of the storage
    device. To accomplish this task, you need to use a bootable CD/DVD or USB device
    to create a forensic environment to create a forensic image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 移除系统硬盘以创建取证镜像是一种广泛使用的做法。然而，有时调查员无法从系统中移除存储设备，需要创建存储设备的取证镜像。为此，你需要使用可启动的 CD/DVD
    或 USB 设备来创建取证环境，并生成取证镜像。
- en: Using boot media, you will want to ensure that it will create that sound forensic
    environment and not cause any changes to the source device. As we discussed during
    the boot process, we want to intercept any potential changes to that source device,
    and we want to have the system boot inside an environment we control. While it
    is still possible to boot using a CD/DVD, finding systems without an optical drive
    is becoming more common. Without an optical drive, we must use a boot USB device
    to create a sound forensic environment to access the storage device.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启动介质时，你需要确保它能创建一个稳定的取证环境，而不会对源设备造成任何更改。正如我们在启动过程中讨论的，我们希望拦截任何可能对源设备的更改，并确保系统在我们控制的环境中启动。尽管仍然可以使用
    CD/DVD 启动，但没有光驱的系统变得越来越常见。没有光驱时，我们必须使用 USB 启动设备来创建一个可靠的取证环境，以访问存储设备。
- en: Linux is a standard operating system that is used to create a USB-based (live)
    operating system to create the forensic environment needed to examine these devices.
    As discussed in *Chapter 3*, *Acquisition of Evidence*, PALADIN is one such tool.
    It is freely available to download and purchase if you wish to have it preinstalled
    on a USB device. Sumuri also provides some limited technical support in the operation
    of PALADIN.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 是一种标准操作系统，通常用于创建基于 USB 的（实时）操作系统，以创建进行设备检查所需的取证环境。如*第 3 章*《证据采集》中所述，PALADIN
    就是其中一个工具。如果你希望将其预装在 USB 设备上，它可以免费下载和购买。Sumuri 还提供 PALADIN 操作的有限技术支持。
- en: There is also a Windows-based bootable environment known as **WinFE** (**Windows
    Forensic Environment**). WinFE was developed by Troy Larson in 2008 and has spawned
    other tools such as Mini-WinFE, which was developed by Brett Shavers and Misty
    ([http://reboot.pro/files/file/375-mini-winfe/](http://reboot.pro/files/file/375-mini-winfe/)).
    The benefit of using the Windows bootable environment is that you now have Windows-based
    forensic tools. It is possible to run X-Ways or FTK Imager from this secure environment.
    I would not recommend using a tool that is resource-heavy. What I mean is that
    some forensic suites such as EnCase Forensic or FTK require significant resources
    to run effectively. X-Ways can be run from a USB device, as can some artifact-specific
    tools like RegRipper.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种基于 Windows 的可启动环境，称为 **WinFE**（**Windows 取证环境**）。WinFE 是由 Troy Larson 于
    2008 年开发的，并且衍生出其他工具，例如由 Brett Shavers 和 Misty 开发的 Mini-WinFE（[http://reboot.pro/files/file/375-mini-winfe/](http://reboot.pro/files/file/375-mini-winfe/)）。使用
    Windows 可启动环境的好处是，你可以使用基于 Windows 的取证工具。在这个安全环境中，X-Ways 或 FTK Imager 是可以运行的。我不推荐使用资源占用较大的工具。我的意思是，一些取证套件，如
    EnCase Forensic 或 FTK，需要大量的资源才能有效运行。X-Ways 可以从 USB 设备上运行，一些特定工具如 RegRipper 也可以。
- en: As with any tool or procedure, you must validate it to ensure you are getting
    the expected results. This means that before you go out into the field and boot
    a suspect’s computer utilizing a forensic USB device, you must test it in the
    laboratory environment to ensure no changes are made.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何工具或程序一样，你必须验证它以确保得到预期的结果。这意味着，在你去现场利用取证 USB 设备启动嫌疑人计算机之前，你必须在实验室环境中进行测试，以确保不会做出任何更改。
- en: 'Some of the challenges that you, as the examiner, need to be concerned with
    when using a bootable USB device include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为检查员，在使用可启动 USB 设备时，需要关注的一些挑战包括以下几点：
- en: Ensuring the system will boot to the device and not the internal hard drive
    by changing the boot order in the BIOS
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保系统能够从设备启动，而不是从内部硬盘启动，需要在 BIOS 中更改启动顺序
- en: In some systems, it’s difficult to access the BIOS in the time provided during
    the boot process
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些系统中，在启动过程中很难在规定时间内访问 BIOS
- en: Ensuring the system can boot to a USB device – some older systems cannot
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保系统可以从 USB 设备启动——一些较老的系统无法支持
- en: Knowing which filesystems the bootable device can write-protect and which ones
    it cannot
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可启动设备能够写保护哪些文件系统，哪些文件系统不能写保护
- en: Dealing with the secure boot feature of the UEFI boot process
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理UEFI引导过程中的安全启动功能
- en: As mentioned earlier, secure boot is a security feature of the UEFI process
    that allows trusted operating systems to boot the system. Therefore, if we want
    to use a bootable forensic operating system, the secure boot feature must be disabled.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，安全启动是UEFI过程中的一个安全特性，允许受信任的操作系统启动系统。因此，如果我们要使用可引导的取证操作系统，必须禁用安全启动功能。
- en: You must enter the UEFI environment by pressing the catch key, such as *F2*
    or *F12* (this will vary depending on the computer manufacturer). Once you have
    entered the setup utility, navigate to the **Security** menu (this might vary
    depending on the computer manufacturer) and disable the secure boot option. Some
    Linux distributions and WinFE have received signed status and will boot a secure
    boot-enabled system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须通过按下快捷键进入UEFI环境，例如*F2*或*F12*（这取决于计算机制造商）。进入设置实用程序后，导航到**安全**菜单（这可能因计算机制造商而异），并禁用安全启动选项。一些Linux发行版和WinFE已获得签名状态，并能够在启用安全启动的系统上启动。
- en: You must document your steps as you go through this process. For example, if
    you miss hitting the catch key and start the boot process in the host operating
    system, you must document that it occurred. Even beginning a partial boot will
    change the timestamps and make entries in various logs in the operating system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，你必须记录你的步骤。例如，如果你错过了按下快捷键并开始了主操作系统的引导过程，你必须记录下这一事件。即使是开始部分引导，也会改变时间戳并在操作系统的各种日志中留下条目。
- en: Now that you understand what a bootable forensic device is let’s go ahead and
    create one in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了什么是可引导的取证设备，让我们在下一节中继续创建一个。
- en: Creating a bootable forensic device
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建可引导的取证设备
- en: To create a bootable forensic device, you will need a USB (I recommend using
    an 8 GB, or larger, device) and an ISO file for the operating system you wish
    to install. I will demonstrate using an ISO for PALADIN and free software called
    Rufus ([https:/rufus.ie/](https://rufus.ie/)). Rufus is a utility used to create
    bootable USB devices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可引导的取证设备，你需要一个USB设备（我建议使用8GB或更大的设备）以及一个你希望安装的操作系统的ISO文件。我将演示使用PALADIN的ISO和名为Rufus的免费软件（[https:/rufus.ie/](https://rufus.ie/)）。Rufus是一个用于创建可引导USB设备的工具。
- en: 'Once you download Rufus, execute the executable and the program will run:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Rufus后，执行可执行文件，程序将运行：
- en: '![Graphical user interface, application  Description automatically generated](img/B18329_04_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18329_04_02.png)'
- en: 'Figure 4.2: Rufus'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Rufus
- en: 'Something similar to the preceding screenshot (Rufus) will appear, and you
    will have to select the appropriate choice from the drop-down menus:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现类似上图（Rufus）的界面，你需要从下拉菜单中选择合适的选项：
- en: '**Device**: This is the destination. It is the USB device you want to host
    the bootable operating system on.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：这是目标位置。它是你希望托管可引导操作系统的USB设备。'
- en: '**Boot selection**: This will be the “live” operating system. Here, I am using
    an ISO file for PALADIN 7.04.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导选择**：这将是“实时”操作系统。在这里，我使用的是PALADIN 7.04的ISO文件。'
- en: '**Partition scheme**: You have a choice of using MBR or GPT. Using MBR will
    give you greater flexibility in the devices you can boot.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区方案**：你可以选择使用MBR或GPT。使用MBR将为你提供更大的设备引导灵活性。'
- en: '**Target system**: With the MBR selection for the partition scheme, you can
    use the device on either a BIOS or UEFI system. If you select GPT for the partition
    scheme, you can only target UEFI systems.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标系统**：选择MBR作为分区方案后，你可以在BIOS或UEFI系统上使用该设备。如果你选择GPT作为分区方案，则只能在UEFI系统上使用。'
- en: Under **Format Options**, accept the default values and then click on the **START**
    button. Once the program completes, you will have a fully functioning, bootable
    forensic environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**格式选项**下，接受默认值，然后点击**开始**按钮。一旦程序完成，你将拥有一个完全功能的可引导取证环境。
- en: We have created a forensic boot environment; let’s discuss the storage media
    you will encounter. We will now discuss hard drives.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个取证引导环境；现在让我们讨论你将遇到的存储介质。接下来我们将讨论硬盘。
- en: Hard drives
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬盘
- en: The term “physical drive storage device” refers to the hard disk drive itself.
    That is a physical device that contains platters or solid-state storage that holds
    data. The term “logical device/volume/partition” refers to the formatting of the
    physical device. A physical device can contain one or more logical devices/volumes/partitions.
    It is a common misconception that the term “C drive” refers to the physical device
    when, in actuality, it refers to a logical partition on the physical device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “物理驱动器存储设备”一词指的是硬盘驱动器本身。这是一个物理设备，包含盘片或固态存储，用于保存数据。而“逻辑设备/卷/分区”指的是物理设备的格式化。一个物理设备可以包含一个或多个逻辑设备/卷/分区。很多人误认为“C盘”指的是物理设备，但实际上，它指的是物理设备上的一个逻辑分区。
- en: Several components make up the interior of the hard drive (as shown in the following
    figure). If you were to open the case, you would find the hard drive comprised
    of one or more platters. One or more platters could be stacked together with a
    spindle in the center. The platters, made of a metal alloy or glass, are coated
    with a magnetic substance in which the heads magnetically encode information on
    the platters. The heads can write data on both sides of the platter. The spindles
    of the hard disk cause the disks to rotate at thousands of revolutions per minute;
    the faster the spindle causes the platters to spin, the higher the efficiency
    of accessing the data encoded on the platters. To read or write data to the platters,
    the heads are positioned less than **.1** microns from the platter’s surface.
    Additionally, the actuator controls the heads; it swings across the platter, placing
    the head in the correct position to read/write the data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘的内部由多个组件组成（如下图所示）。如果你打开硬盘外壳，你会发现硬盘由一个或多个盘片组成。一个或多个盘片可能会堆叠在一起，并且中央有一个主轴。盘片由金属合金或玻璃制成，表面涂有磁性物质，磁头通过磁性方式在盘片上编码信息。磁头可以在盘片的两面写入数据。硬盘的主轴使盘片以每分钟几千转的速度旋转；主轴旋转得越快，访问盘片上数据的效率就越高。为了读写盘片上的数据，磁头与盘片表面之间的距离小于**0.1**微米。此外，执行器控制磁头，它会在盘片上摆动，将磁头放置到正确的位置以进行数据的读取或写入。
- en: 'The storage devices are manufactured with tight tolerances and can be damaged
    by sudden sharp movement or a mechanical shock:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 存储设备的制造精度非常高，且在突发的剧烈移动或机械冲击下可能会损坏：
- en: '![A picture containing text  Description automatically generated](img/B18329_04_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![A picture containing text  Description automatically generated](img/B18329_04_03.png)'
- en: 'Figure 4.3: Hard drive'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：硬盘
- en: 'A hard drive can have different interfaces, for example, you may run into some
    of the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘可能会有不同的接口，例如，你可能会遇到以下几种：
- en: '**Small Computer System Interface (SCSI)**: An older standard that is typically
    seen in the corporate environment. Limited to 16 chained devices and will have
    a terminator at the end of the chain.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型计算机系统接口（SCSI）**：一种较旧的标准，通常在企业环境中使用。最多支持16个连接设备，并且链条末端会有终端装置。'
- en: '**Integrated Drive Electronics (IDE/EIDE)**: An old standard but may still
    be found in older consumer computer systems.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成驱动电子（IDE/EIDE）**：一种旧标准，但在一些老旧的消费类计算机系统中仍然可以找到。'
- en: '**Serial Advanced Technology Attachment (SATA)**: A current standard found
    in many consumer and commercial environments.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行高级技术附件（SATA）**：当前在许多消费类和商业环境中使用的标准。'
- en: '**Serial Attached SCSI (SAS)**: A current standard that is typically found
    in commercial environments.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行附加SCSI（SAS）**：一种当前标准，通常出现在商业环境中。'
- en: '**Solid state drives** (**SSDs**) are storage devices that contain no moving
    parts. Instead, they are made up of memory chips. As we discussed earlier, a traditional
    hard drive has several moving parts in which to read/write data to the spinning
    platters. With an SSD storage device, all the data is stored in memory chips,
    allowing for the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**固态硬盘**（**SSDs**）是没有任何活动部件的存储设备。它们由内存芯片组成。如我们之前讨论的，传统硬盘有多个活动部件，用于读取/写入数据到旋转的盘片上。而在SSD存储设备中，所有数据都存储在内存芯片中，从而带来了以下优点：'
- en: Less weight
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减轻重量
- en: Increased reliability
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可靠性
- en: Improved data access speed
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升数据访问速度
- en: Reduced power consumption
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低功耗
- en: 'For an SSD to function reliably, there are several operations controlled by
    the firmware of the device. These functions are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SSD能够可靠地工作，设备的固件会控制若干操作。这些功能如下：
- en: '**Wear leveling**: This spreads the writes across the different chips so that
    it uses the chips at the same rate.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磨损平衡**：这会将写入操作分布到不同的芯片上，从而使芯片的使用速率保持一致。'
- en: '**Trim**: This will wipe the unallocated space of the device.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修剪**：这将清除设备的未分配空间。'
- en: '**Garbage collection**: As the firmware scans the memory modules, it may identify
    pages within the data blocks that have been deleted. The firmware will move the
    allocated pages to a new block and will wipe the data block so that it can reuse
    the blocks. The firmware can only delete data in blocks.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收**：当固件扫描内存模块时，它可能会识别出数据块中已经删除的页面。固件将把已分配的页面移动到新的块，并清除数据块以便重新使用这些块。固件只能在块级别删除数据。'
- en: The real-world effect on forensics is that we can no longer recover data that
    is or was in unallocated space. Since these operations are conducted at the firmware
    layer, these operations start automatically as soon as power is given to the device.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对取证的实际影响是，我们无法再恢复处于或曾处于未分配空间中的数据。由于这些操作是在固件层进行的，一旦设备通电，这些操作就会自动启动。
- en: Drive geometry
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动器几何结构
- en: The drive geometry of a platter drive details how data is stored on the device;
    the drive geometry defines the number of heads, the number of tracks, the cylinders,
    and the sectors per track. The manufacturer performs what it refers to as a low-level
    format, which creates the basic structure of the disk by defining the sectors
    and tracks. A track is a circular path on the platter’s surface, as indicated
    in the following diagram. The red circle (**A**) is a single track, and each side
    of the platter will have its own set of tracks. They then subdivide the track
    into sectors. A sector (**B**) is the smallest storage unit on the device.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘驱动器几何结构详细说明了数据如何存储在设备上；驱动器几何结构定义了磁头的数量、轨道的数量、柱面以及每轨道的扇区数。制造商进行所谓的低级格式化，创建磁盘的基本结构，定义扇区和轨道。轨道是盘面表面上的圆形路径，如下图所示。红色圆圈（**A**）是单个轨道，每个盘面都有自己的轨道集合。然后，他们将轨道划分为扇区。一个扇区（**B**）是设备上的最小存储单位。
- en: 'Initially, a sector used to be 512 bytes in size; however, newer disks are
    being formatted with a sector size of 4,096 bytes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，扇区的大小是 512 字节；然而，新的磁盘正在使用 4,096 字节的扇区大小进行格式化：
- en: '![](img/B18329_04_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_04.png)'
- en: 'Figure 4.4: Drive diagram'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：驱动器示意图
- en: The platters have an addressing scheme to locate the data; originally, **Cylinder,
    Head, Sector** (**CHS**) was used. **Cylinder** refers to the vertical axis of
    the same sectors on all the platters. **Head** refers to the read/write heads;
    each platter has two heads. Finally, **sector** refers to the number of sectors
    per track. This addressing scheme worked for large-capacity hard drives; however,
    as the storage capacity increased, the CHS scheme could not scale because of file
    size limitations, so **Logical Block Addressing** (**LBA**) was created. With
    the LBA scheme, you can address the sectors with a sector number starting from
    zero.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘有一种寻址方案来定位数据；最初使用的是**柱面、磁头、扇区**（**CHS**）。**柱面**指的是所有磁盘上相同扇区的垂直轴。**磁头**指的是读写磁头；每个盘面有两个磁头。最后，**扇区**指的是每轨道的扇区数量。这个寻址方案适用于大容量硬盘；然而，随着存储容量的增加，由于文件大小的限制，CHS
    方案无法扩展，因此出现了**逻辑块寻址**（**LBA**）。通过 LBA 方案，你可以通过从零开始的扇区编号来寻址扇区。
- en: So, we have discussed the physical components of the device. We will now dive
    deeper and examine some of the internal aspects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经讨论了设备的物理组件。接下来，我们将深入探讨一些内部方面。
- en: MBR (Master Boot Record) partitions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MBR（主引导记录）分区
- en: Three steps are required before the computer system can use the storage device.
    First, we have discussed the low-level format conducted by the manufacturer, but
    now we will discuss partitioning.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统可以使用存储设备之前，需要进行三个步骤。首先，我们讨论了由制造商进行的低级格式化，但现在我们将讨论分区。
- en: Partitioning occurs when we divide the physical device into logical segments
    called “volumes.” With the MBR partitioning scheme, we are restricted to four
    primary partitions. For example, with one physical device, you can have a primary
    partition used to host the Windows operating system. You can also have a second
    primary partition that hosts a Linux operating system. Note that you must have
    a primary partition to boot into an operating system. When a user selects the
    booted operating system, this is known as the **active partition**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是指我们将物理设备划分为称为“卷”的逻辑片段。在 MBR 分区方案下，我们最多只能创建四个主分区。例如，在一个物理设备上，你可以创建一个主分区来承载
    Windows 操作系统，另一个主分区用来承载 Linux 操作系统。请注意，必须有一个主分区才能启动操作系统。当用户选择启动的操作系统时，这个分区就是**活动分区**。
- en: To get around the partition limit, developers created the extended partition.
    One of the four partition records is designated as an extended partition, which
    can then be divided into logical volumes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突破分区限制，开发人员创建了扩展分区。四个分区记录中的一个被指定为扩展分区，该分区可以进一步划分为逻辑卷。
- en: 'As we discussed previously, we can find the MBR at sector zero. The MBR contains
    the information needed by the system to boot. The MBR will be in sector zero,
    so it will be no longer than 512 bytes. The partition table will show us which
    partition is the active partition. Once the starting sector of the active partition
    is located, the boot process will continue:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，我们可以在零扇区找到 MBR。MBR 包含操作系统启动所需的信息。MBR 将位于零扇区，因此其大小不超过 512 字节。分区表会显示哪个分区是活动分区。一旦找到活动分区的起始扇区，启动过程将继续：
- en: '![](img/B18329_04_05.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_05.png)'
- en: 'Figure 4.5: MBR map'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：MBR 映射
- en: The preceding MBR map depicts sector zero of a hard disk. This is the MBR for
    the physical disk. The first 440 bytes are highlighted; this is the boot code.
    The next 4 bytes are the disk signature and identify the disk to the operating
    system. The following 64 bytes comprise the partition table. Each 16-byte entry
    refers to a specific partition. Remember, it restricts us to 4 primary partitions
    utilizing the MBR partitioning scheme. The final 2 bytes is the signature for
    the MBR. It identifies the ending of the MBR and will be the last 2 bytes of the
    sector.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 MBR 映射显示了硬盘的零扇区。这是物理磁盘的 MBR。前 440 字节已被高亮显示；这部分是启动代码。接下来的 4 字节是磁盘签名，用于将磁盘标识给操作系统。接下来的
    64 字节是分区表。每个 16 字节的条目都指向一个特定的分区。请记住，这将限制我们在使用 MBR 分区方案时只能创建 4 个主分区。最后的 2 字节是 MBR
    的签名，标识 MBR 的结束，它将是扇区的最后 2 字节。
- en: In the following table, I have extracted the four partition tables and reformatted
    the hex values for easier reading. The first byte will designate which partition
    is the active partition. A value of `x/80` identifies the active bootable partition.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，我提取了四个分区表并重新格式化了十六进制值，便于阅读。第一个字节将指示哪个分区是活动分区。`x/80` 的值表示活动的可启动分区。
- en: 'A value of `x/00` shows the non-active (bootable) partition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`x/00` 的值表示非活动（可启动）分区：'
- en: '![](img/B18329_04_06.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_06.png)'
- en: 'Figure 4.6: Partition tables'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：分区表
- en: Typically, you would see the first partition marked as the active partition;
    in this case, it is the second partition, which is bootable. The next 3 bytes
    represent a starting sector for the CHS calculation. So, when we examine the partition
    table, we can see that the physical device has partition 0 and partition 1\. The
    entries for partitions 2 and 3 are zeroed out. This tells us that there are only
    two partitions on this physical device.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会看到第一个分区被标记为活动分区；在这个例子中，它是第二个分区，表示它是可启动的。接下来的 3 字节表示 CHS 计算的起始扇区。因此，当我们检查分区表时，我们会看到物理设备上有分区
    0 和分区 1，分区 2 和分区 3 的条目为零。这意味着物理设备上只有两个分区。
- en: The fifth byte represents the filesystem on the partition. For partition 0,
    we can see the hex value of **DE,** which tells us that it is part of the Dell
    PowerEdge Server utilities. Partition 1 has a hex value of **07**, which shows
    the NTFS filesystem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字节表示分区上的文件系统。对于分区 0，我们可以看到 **DE** 的十六进制值，这表明它是戴尔 PowerEdge 服务器工具的一部分。分区 1
    的十六进制值为 **07**，表示 NTFS 文件系统。
- en: If I found the hexadecimal values of **05** or **0f**, that would show an extended
    partition. We would then have to look into the extended boot records of the extended
    partitions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我发现十六进制值为 **05** 或 **0f**，那将表示扩展分区。然后我们需要查看扩展分区的扩展引导记录。
- en: '**Note**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find a full list of partition identifiers at [https://www.win.tue.nl/~aeb/partitions/partition_types-1.html](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.win.tue.nl/~aeb/partitions/partition_types-1.html](https://www.win.tue.nl/~aeb/partitions/partition_types-1.html)找到分区标识符的完整列表。
- en: The next 3 bytes are the values for the ending sector of the CHS calculation.
    The next 4 bytes show the starting sector of the partition, and the last 4 bytes
    show the size of the partition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的3个字节是CHS计算中用于结束扇区的值。接下来的4个字节显示分区的起始扇区，最后4个字节显示分区的大小。
- en: The sector values used in the CHS calculation are legacy values for older storage
    devices. The values showing the start sector and the total number of sectors (partition
    size) are being used for the current drives using LBA.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在CHS计算中使用的扇区值是旧版存储设备的遗留值。显示起始扇区和总扇区数（分区大小）的值仍被用于当前使用LBA的驱动器。
- en: Each partition will have a **Volume Boot Record** (**VBR**) at sector zero of
    the partition. The system uses the VBR to boot the operating system in that volume.
    It is an operating system-specific artifact and is created when the partition
    is formatted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区的第一个扇区将包含**卷引导记录**（**VBR**）。系统使用VBR来引导该卷中的操作系统。它是操作系统特定的产物，并在分区格式化时创建。
- en: It will also appear on unpartitioned devices, such as removable media, for example,
    a USB or floppy disk.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它也会出现在未分区的设备上，例如可移动介质，比如USB驱动器或软盘。
- en: Primary partitions are not the only partitions that you may encounter; you can
    also encounter an extended partition, which is the subject of the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 主分区并不是你可能遇到的唯一分区；你还可能遇到扩展分区，这将是下一节的内容。
- en: Extended partitions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展分区
- en: The limitation of the MBR of only allowing four primary partitions resulted
    in the creation of the extended primary partition. Here, it takes the place of
    one (and only one) primary partition and enables the user to create additional
    logical partitions over the four primary partitions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: MBR的限制只能容纳四个主分区，因此产生了扩展主分区。在这里，它替代了一个（且仅一个）主分区，并使用户能够在四个主分区之上创建额外的逻辑分区。
- en: 'The following partition map illustrates the replacement of a primary partition
    with an extended partition:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个主分区被扩展分区替代的情况：
- en: '![](img/B18329_04_07.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_07.png)'
- en: 'Figure 4.7: Partition map'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：分区映射
- en: 'The following diagram shows the extended partition. Here, the user has created
    multiple logical partitions within the extended partition boundary:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了扩展分区。在这里，用户已经在扩展分区边界内创建了多个逻辑分区：
- en: '![Diagram  Description automatically generated](img/B18329_04_08.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B18329_04_08.png)'
- en: 'Figure 4.8: Extended partition map'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：扩展分区映射
- en: The extended partition will not have a VBR. It will have an **extended boot
    record** (**EBR**), which will point to the first extended logical partition.
    The first extended logical partition will contain information about itself and
    a pointer to the next extended logical partition. In effect, this will create
    a daisy chain of pointers from one extended logical partition to the next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展分区没有VBR。它将包含一个**扩展引导记录**（**EBR**），指向第一个扩展逻辑分区。第一个扩展逻辑分区将包含关于它本身的信息以及指向下一个扩展逻辑分区的指针。实际上，这将创建一个从一个扩展逻辑分区到下一个的指针链。
- en: We have now covered the aspects relating to the MBR; let’s now go over the GPT-formatted
    aspects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论完了与MBR相关的部分，接下来我们将讨论GPT格式的内容。
- en: GPT partitions
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPT分区
- en: A GUID is a **globally unique identifier** and uses a 128-bit hexadecimal value
    to identify different aspects of the computer system. A GUID comprises five groups
    and is formatted as `00112233-4455-6677-8899-aabbccddeeff`, and, while there is
    no central authority to ensure uniqueness, it is doubtful that you would get a
    repeating GUID.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GUID是**全局唯一标识符**，使用128位十六进制值来标识计算机系统的不同方面。一个GUID由五组组成，格式为`00112233-4455-6677-8899-aabbccddeeff`，虽然没有中央机构来确保唯一性，但可以说你不太可能得到重复的GUID。
- en: 'RFC 4122 defines the five different GUIDs as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 4122定义了五种不同的GUID，如下所示：
- en: '**Version 1**: Date-time and MAC address: The system generates this version
    using both the current time and client MAC address. This means that if you have
    a version 1 GUID, you can figure out when it was created by inspecting the timestamp
    value.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本1**：日期时间和MAC地址：系统通过当前时间和客户端MAC地址生成此版本。这意味着，如果你有一个版本1的GUID，你可以通过检查时间戳值来确定它的创建时间。'
- en: '**Version 2**: DCE security: This version isn’t explicitly defined in RFC 4122,
    so it doesn’t have to be generated by compliant generators. It is like a version
    1 GUID except that the first four bytes of the timestamp are replaced by the user’s
    POSIX UID or GID, and the upper byte of the clock sequence is replaced by either
    the POSIX UID or GID domain. (**UID** stands for **User Identifier**. **POSIX**
    stands for **Portable Operating System Interface**, which is a set of standards
    to ensure compatibility between operating systems.)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 2**：DCE 安全性：此版本在 RFC 4122 中未明确定义，因此不必由符合标准的生成器生成。它类似于版本 1 GUID，只是时间戳的前四个字节被用户的
    POSIX UID 或 GID 替代，时钟序列的高字节被 POSIX UID 或 GID 域替代。（**UID** 代表 **用户标识符**。**POSIX**
    代表 **可移植操作系统接口**，它是一组确保操作系统之间兼容性的标准。）'
- en: '**Version 3**: MD5 hash and namespace: This GUID is generated by taking a namespace
    (for example, a fully qualified domain name) and a name, converting it into bytes,
    concatenating it, and hashing it. Once it has specified the special bits such
    as version and variant, it then converts the resulting bytes into hexadecimal
    form. The special property regarding this version is that the GUIDs generated
    from the same name in the same namespace will be identical even if they were generated
    at different times.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 3**：MD5 哈希和命名空间：此 GUID 通过取一个命名空间（例如，完全限定的域名）和一个名称，将其转换为字节，进行连接，并进行哈希处理。确定了版本和变体等特殊位后，它会将结果字节转换为十六进制形式。关于此版本的特殊属性是，从同一命名空间中相同名称生成的
    GUID 即使在不同时间生成也将是相同的。'
- en: '**Version 4**: Random: The system creates this GUID using random numbers. Of
    the 128 bits in a GUID, it reserves 6 for special use (version + variant bits)
    giving us 122 bits that can be filled at random.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 4**：随机：系统使用随机数创建此 GUID。在 GUID 的 128 位中，保留了 6 位供特殊使用（版本 + 变体位），因此剩余的 122
    位可以随机填充。'
- en: '**Version 5**: SHA-1 hash and namespace: This version is identical to version
    3 except that SHA-1 is used in the hashing step in place of MD5.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 5**：SHA-1 哈希和命名空间：此版本与版本 3 相同，唯一的区别是哈希步骤中使用了 SHA-1，而不是 MD5。'
- en: The GPT is a partitioning scheme that is used for newer storage devices and
    is part of the new UEFI standard. The UEFI standard replaces the BIOS, while the
    GPT replaces the MBR partitioning scheme.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 是一种用于新型存储设备的分区方案，并且是新的 UEFI 标准的一部分。UEFI 标准替代了 BIOS，而 GPT 替代了 MBR 分区方案。
- en: 'The GPT petitioning scheme uses LBA, and a protective MBR is found in the physical
    sector zero. The protective MBR allows for some backward compatibility and helps
    to remove any issues when dealing with legacy utilities that do not recognize
    the GPT partitioning scheme. There is no boot code available in the protective
    MBR. As you can see in the following diagram, this is the first partition entry
    of the partition table of the protective MBR. The partition is identified by hex
    value **EE**, which shows it is a GPT partition disk, as shown in the following
    GPT hex:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 分区方案使用 LBA，并且在物理扇区零中可以找到保护 MBR。保护 MBR 允许一定的向后兼容性，并有助于消除在使用不识别 GPT 分区方案的传统工具时出现的任何问题。保护
    MBR 中没有可用的引导代码。如以下图所示，这是保护 MBR 分区表的第一个分区项。该分区由十六进制值**EE**标识，表示它是一个 GPT 分区磁盘，如下所示的
    GPT 十六进制：
- en: '![Figure 4.9 – GPT hex ](img/B18329_04_09.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – GPT 十六进制](img/B18329_04_09.png)'
- en: 'Figure 4.9: GPT hex'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：GPT 十六进制
- en: 'While the MBR contains the partition table within physical sector `0`, GPT
    houses the partition table header at physical sector `1`. The GPT header can be
    identified by the **EFI** signature of hexadecimal values `45 46 49 20 50 41 52
    54`, as shown in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MBR 包含物理扇区 `0` 中的分区表，但 GPT 将分区表头放置在物理扇区 `1` 中。GPT 头可以通过十六进制值 `45 46 49 20
    50 41 52 54` 的 **EFI** 标识符来识别，如下图所示：
- en: '![](img/B18329_04_10.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_10.png)'
- en: 'Figure 4.10: EFI PART'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：EFI 分区
- en: 'The following table shows the layout of the GPT header, which you can use to
    identify the layout of the desk:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 GPT 头的布局，您可以用它来识别磁盘的布局：
- en: '![Table  Description automatically generated](img/B18329_04_11.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18329_04_11.png)'
- en: 'Figure 4.11: GPT header format'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：GPT 头格式
- en: 'The GPT partition entries are typically found in physical sector `2`. The following
    diagram shows the GPT partition table entries:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 分区项通常位于物理扇区 `2` 中。下图显示了 GPT 分区表项：
- en: '![Chart  Description automatically generated with medium confidence](img/B18329_04_12.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成，置信度中等](img/B18329_04_12.png)'
- en: 'Figure 4.12: GPT sector 2'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：GPT扇区2
- en: 'Each partition entry is 128 bytes and provides information about the partitions.
    The following table shows the contents of the partition entries, which include
    the partition type GUID, the GUID that is unique to that specific partition, the
    starting and ending sectors, and the partition name in Unicode:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区条目为128字节，提供有关分区的信息。下表展示了分区条目的内容，包括分区类型GUID、该特定分区的唯一GUID、起始和结束扇区以及分区名称（以Unicode表示）：
- en: '![Figure 4.13 – GUID ](img/B18329_04_13.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – GUID](img/B18329_04_13.png)'
- en: 'Figure 4.13: GUID'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：GUID
- en: A partition should hold all the data on the disk within the partition’s boundaries;
    however, there are spaces on the disk outside of the normal partition boundaries
    where a technical user may hide data. We will discuss those areas next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分区应该存储磁盘内该分区边界内的所有数据；然而，磁盘上也有一些超出正常分区边界的空间，技术用户可以在这些区域中隐藏数据。接下来我们将讨论这些区域。
- en: Host Protected Area (HPA) and Device Configuration Overlay (DCO)
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机保护区域（HPA）和设备配置覆盖（DCO）
- en: HPA and DCO are hidden areas on the hard drive created by the manufacturers.
    The manufacturer uses the HPA to store recovery and diagnostics tools and it cannot
    be changed or accessed by the user. The DCO allows the manufacturer to use standard
    parts to build different products. It will enable the creation of a standard set
    of sectors on a component to achieve uniformity. For example, the manufacturer
    might use one set of parts to create a 500 GB hard drive, and while using the
    same components, it can also create a 600 GB hard drive. Once again, the user
    would usually not have access to this location. However, some utilities are freely
    available and could be used by a user to access these locations and store data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: HPA和DCO是硬盘上的隐藏区域，由制造商创建。制造商使用HPA来存储恢复和诊断工具，用户无法更改或访问这些工具。DCO允许制造商使用标准部件来制造不同的产品。它将使在组件上创建一组标准扇区成为可能，从而实现统一性。例如，制造商可能会使用一组部件来制造500
    GB的硬盘，而在使用相同组件的情况下，也能制造600 GB的硬盘。通常，用户无法访问这个位置。然而，一些工具是公开可用的，用户可以使用这些工具来访问这些位置并存储数据。
- en: 'The following screenshot shows you how an HPA may appear in X-Ways:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了HPA在X-Ways中的显示方式：
- en: '![](img/B18329_04_14.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_14.png)'
- en: 'Figure 4.14: HPA 1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：HPA 1
- en: 'The following screenshot shows you how an HPA may appear in FTK Imager:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了HPA在FTK Imager中的显示方式：
- en: '![](img/B18329_04_15.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_15.png)'
- en: 'Figure 4.15: HPA 2'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：HPA 2
- en: Let’s move on and discuss some potential filesystems that you may encounter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们继续讨论一些你可能会遇到的文件系统。
- en: Understanding filesystems
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解文件系统
- en: A hard drive can have multiple partitions on it, and, in each partition, there
    will be (in most cases) a filesystem. There might be hundreds of thousands to
    millions of files within a partition. The filesystem tracks where every file is
    and how much space is available within the partition boundaries.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个硬盘可以有多个分区，每个分区内通常（在大多数情况下）都有一个文件系统。一个分区中可能包含数十万到数百万个文件。文件系统跟踪每个文件的位置以及分区边界内可用的空间。
- en: We discussed sectors earlier in the *Hard drives* section; they are the smallest
    units available to store data. The filesystem stores data based on clusters. Clusters
    are comprised of one or more sectors. A cluster is the smallest allocation unit
    the filesystem can write to. There are many filesystems available, and some are
    restricted to specific operating systems unless the user enables drivers that
    will allow the operating system to read the filesystem.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*硬盘*部分中已经讨论过扇区；它们是存储数据的最小单位。文件系统基于簇来存储数据。簇由一个或多个扇区组成。簇是文件系统能够写入的最小分配单元。文件系统有很多种，一些文件系统仅限于特定操作系统，除非用户启用驱动程序，否则操作系统无法读取这些文件系统。
- en: We will now look at some of the common filesystems you may encounter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些你可能会遇到的常见文件系统。
- en: The FAT filesystem
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FAT文件系统
- en: The **File Allocation Table** (**FAT**) filesystem has been around since the
    early days of home computing, and it is one of the few filesystems that nearly
    all operating systems can read. It is the de facto standard filesystem for removable
    devices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件分配表**（**FAT**）文件系统自家庭计算机的早期便已存在，它是少数几种几乎所有操作系统都能读取的文件系统之一。它是可移动设备的事实标准文件系统。'
- en: 'As time has gone by, the FAT filesystem has gone through numerous changes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，FAT文件系统经历了许多变化：
- en: '**FAT12**: The first version was created in 1977 and used 12 bits (hence, the
    FAT12 designation) to address available clusters. This limited its use to only
    storage devices that could contain 4,096 clusters. It is rarely seen nowadays,
    but you might find it on a floppy diskette.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FAT12**：第一个版本创建于1977年，使用12位（因此称为FAT12）来寻址可用簇。这使得它只能用于包含4,096个簇的存储设备。如今很少见，但你可能会在软盘中找到它。'
- en: '**FAT16**: This was created in 1984 and used 16 bits (I see a pattern) to address
    the available clusters. It had the same issues as the FAT12, as it could not be
    scaled to be used with larger-capacity devices.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FAT16**：这是1984年创建的，使用16位（我看到一个规律）来寻址可用簇。它与FAT12有相同的问题，无法扩展到更大容量的设备上使用。'
- en: '**VFAT**: This was introduced with Windows 95 and added the Virtual File Allocation
    Table. It added the use of the **long filename** (**LFN**) and additional timestamps.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VFAT**：这是Windows 95引入的，并添加了虚拟文件分配表。它支持**长文件名**（**LFN**）和额外的时间戳。'
- en: '**FAT32**: This uses 28 bits to address available clusters, theoretically allowing
    for a maximum volume size of 2.2 TB. Microsoft implemented restrictions that limited
    the volume size to 32 GB with a maximum file size of 4 GB. It is still in use
    today and can be found on most removable devices.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FAT32**：此格式使用28位地址可用的簇，理论上最大卷大小为2.2 TB。微软实施了限制，将卷大小限制为32 GB，最大文件大小为4 GB。它至今仍在使用，并且可以在大多数可移动设备上找到。'
- en: We will discuss the FAT32 filesystem for the remainder of this section on the
    FAT filesystem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节剩余部分讨论FAT32文件系统。
- en: 'The FAT filesystem is laid out in two areas (as shown in the following diagram,
    Figure 4.16 – FAT areas):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: FAT文件系统分为两个区域（如以下图示所示，图4.16 – FAT区域）：
- en: '**System Area**: This stores the volume boot record and FAT tables'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统区**：这里存储卷启动记录和FAT表'
- en: '**Data Area**: This stores the root directory and files:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据区**：这里存储根目录和文件：'
- en: '![Figure 4.16 – FAT Areas ](img/B18329_04_16.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – FAT区域](img/B18329_04_16.png)'
- en: 'Figure 4.16: FAT areas'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：FAT区域
- en: Next, we will discuss what falls under **System Area**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论**系统区**中的内容。
- en: Boot record
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动记录
- en: 'We have the **VBR** in the system area. We can find it in logical sector 0
    (LS 0), the first sector within the partition boundaries. The boot process creates
    the VBR when the partition is formatted and contains information about the volume
    and boot code to continue the boot process for the operating system. If it is
    a primary partition, the VBR will consist of several sectors, typically sectors
    0, 1, and 2, with a backup in sectors 6, 7, and 8\. The VBR and backups are stored
    in a “reserve area,” which is typically 32 sectors before the first file allocation
    table begins:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在系统区有**VBR**。它位于逻辑扇区0（LS 0），即分区边界内的第一个扇区。启动过程在分区格式化时创建VBR，并包含有关卷和启动代码的信息，以继续操作系统的启动过程。如果它是主分区，VBR将由多个扇区组成，通常是扇区0、1和2，并在扇区6、7和8中有备份。VBR及其备份存储在“保留区域”，通常位于第一个文件分配表开始之前的32个扇区：
- en: '![](img/B18329_04_17.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_17.png)'
- en: 'Figure 4.17: VBR'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：VBR
- en: 'In the preceding diagram, we can see a volume boot sector, which helps to decipher
    the following information:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们可以看到一个卷启动扇区，它有助于解码以下信息：
- en: '`x00`: We will find the jump instructions for the system to continue booting'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x00`：我们将在此找到系统继续启动的跳转指令'
- en: '`x03`: The OEM ID shows which operating system was used to format the device'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x03`：OEM ID显示了用于格式化设备的操作系统'
- en: '`x0B`: Bytes per sector'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x0B`：每扇区字节数'
- en: '`x0E`: Number of reserve sectors'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x0E`：保留扇区的数量'
- en: '`x10`: Number of FATs (this should be 2)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x10`：FAT的数量（这应该是2）'
- en: '`x11`: Unused root entries (for FAT32, this should be 0 because the root directory
    is in the data area)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11`：未使用的根目录条目（对于FAT32，这应该是0，因为根目录存储在数据区）'
- en: '`x13`: Number of sectors (this will be 0 if the number of sectors exceeds 65,536)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x13`：扇区数（如果扇区数量超过65,536，则此值为0）'
- en: '`x15`: Media descriptor (`xF8` will show a hard disk, while `xF0` will show
    a removable device)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x15`：介质描述符（`xF8`表示硬盘，`xF0`表示可移动设备）'
- en: '`x16`: Number of sectors per FAT (for FAT32, this should be 0)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x16`：每个FAT的扇区数（对于FAT32，这应该是0）'
- en: '`x18`: Number of sectors per track (this should be 63 for hard disks)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x18`：每磁道扇区数（对于硬盘来说，这应该是63）'
- en: '`x1A`: Number of heads (this should be 255 for hard disks)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x1A`：磁头数（对于硬盘来说，这应该是255）'
- en: '`x1C`: Number of hidden sectors (the number of hidden sectors before the start
    of the FAT volume)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x1C`：隐藏扇区的数量（FAT卷开始前的隐藏扇区数量）'
- en: '`x20`: Number of total sectors (that is, the total sectors for the volume)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x20`：总扇区数（即卷的总扇区数）'
- en: '`x24`: Logical sectors per FAT'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x24`：每个FAT的逻辑扇区数'
- en: '`x28`: Extended flags'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x28`：扩展标志'
- en: '`x2A`: FAT version'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x2A`：FAT版本'
- en: '`x2C`: The starting root directory cluster (usually, cluster 2)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x2C`：根目录集群的起始位置（通常为集群2）'
- en: '`x30`: Location of the filesystem information sector (typically, this is set
    to 1)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x30`：文件系统信息扇区的位置（通常设置为1）'
- en: '`x32`: Location of the backup sector(s) (usually, this is set to 6)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x32`：备份扇区的位置（通常设置为6）'
- en: '`x34`: Reserved (set to 0)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x34`：保留（设置为0）'
- en: '`x40`: Physical drive number (`x80` for hard drives)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x40`：物理驱动器号（硬盘为`x80`）'
- en: '`x41`: Reserved'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x41`：保留'
- en: '`x42`: Extended boot signature (this should be `x29`)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x42`：扩展引导签名（应为`x29`）'
- en: '`x43`: Volume serial number (a 32-bit value is usually generated from the date
    and time; this can track removable devices)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x43`：卷标序列号（通常是从日期和时间生成的32位值；可以追踪可移动设备）'
- en: '`x47`: Volume label (this might not be accurate; different OSes may not use
    this field)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x47`：卷标（这可能不准确；不同的操作系统可能不使用此字段）'
- en: '`x52`: Filesystem type'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x52`：文件系统类型'
- en: Next, we will take a look at the file allocation table.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看文件分配表。
- en: File allocation table
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件分配表
- en: The next component of the FAT filesystem is the file allocation table, which
    immediately follows the VBR. There are two file allocation tables (FAT1 and FAT2)
    by default. FAT2 is a duplicate of FAT1.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: FAT文件系统的下一个组成部分是文件分配表，它紧接着VBR。默认情况下，有两个文件分配表（FAT1和FAT2）。FAT2是FAT1的副本。
- en: 'The purpose of the file allocation table is to track the clusters and track
    which files occupy which clusters. Each cluster is represented within the file
    allocation table starting with cluster 0\. The file allocation table uses 4 bytes
    (32 bits) per cluster entry. The file allocation table will use the following
    entries to represent the cluster’s current status:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 文件分配表的目的是追踪集群并追踪哪些文件占用了哪些集群。每个集群在文件分配表中以集群0开始表示。文件分配表每个集群条目使用4个字节（32位）。文件分配表将使用以下条目来表示集群的当前状态：
- en: '**Unallocated**: `x0000 0000`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未分配**：`x0000 0000`'
- en: '**Allocated**: The next cluster that is used by the file (for example, it represents
    cluster 7 as `x0700 0000`)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已分配**：文件使用的下一个集群（例如，它表示集群7为`x0700 0000`）'
- en: '**Allocated**: The last cluster that is used by the file (`xFFFF FFF8`)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已分配**：文件使用的最后一个集群（`xFFFF FFF8`）'
- en: '**Bad cluster**: Not available for use (`xFFFF FFF7`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坏集群**：不可用（`xFFFF FFF7`）'
- en: 'A cluster is the smallest allocation unit the filesystem can address. A sector
    is the smallest allocation unit on the disk. A cluster is made up of one or more
    sectors. It is very easy to get confused if you are co-mingling those terms. Consider
    the following cluster example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是文件系统能够寻址的最小分配单元。扇区是磁盘上的最小分配单元。一个集群由一个或多个扇区组成。如果你混淆了这两个术语，很容易产生困惑。考虑以下集群示例：
- en: '![Figure 4.18 – Cluster example ](img/B18329_04_18.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – 集群示例](img/B18329_04_18.png)'
- en: 'Figure 4.18: Cluster example'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：集群示例
- en: As users add files to the data area, the system will update the file allocation
    table. A file may occupy one or more clusters. Additionally, the clusters may
    not be sequential, so you could have the data of a file spread in different physical
    locations on the disk; we typically refer to this as fragmentation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用户向数据区添加文件，系统将更新文件分配表。一个文件可能占用一个或多个集群。此外，集群可能不是连续的，因此文件的数据可能分布在磁盘的不同物理位置；我们通常称之为碎片化。
- en: 'In the following diagram, we can see a representation of the file allocation
    table; in this scenario, we have a single file occupying three clusters: **Cluster
    4**, **Cluster 5**, and **Cluster 6**. You can see that **Cluster 4** is pointing
    to **Cluster 5** and **Cluster 5** is pointing to **Cluster 6**. **Cluster 6**
    has the hexadecimal value for **end of file** (**EOF**):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到文件分配表的表示；在此场景中，我们有一个文件占用了三个集群：**集群4**、**集群5**和**集群6**。你可以看到，**集群4**指向**集群5**，**集群5**指向**集群6**。**集群6**的十六进制值表示**文件结束**（**EOF**）：
- en: '![Figure 4.19 – Non-fragmented file entry ](img/B18329_04_19.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – 非碎片化的文件条目](img/B18329_04_19.png)'
- en: 'Figure 4.19: Non-fragmented file entry'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：非碎片化的文件条目
- en: In the following diagram, we can see a similar representation of the file allocation
    table with some changes. We now have two files, with File 1 occupying clusters
    **4** and **6**. We can see that **Cluster 4** is pointing to the next cluster
    containing the file data, which is **Cluster 6**. This is an example of file fragmentation.
    File 2 is wholly contained within the cluster boundaries of **Cluster 5**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图示中，我们可以看到文件分配表的类似表示，且做了一些修改。现在有两个文件，文件 1 占用了簇 **4** 和 **6**。我们可以看到，**簇 4**
    指向包含文件数据的下一个簇，即 **簇 6**。这是文件碎片化的一个示例。文件 2 完全包含在 **簇 5** 的边界内。
- en: '**Cluster 5** will not point to a subsequent cluster; instead, it has the EOF
    hexadecimal value:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**簇 5** 不会指向后续簇；相反，它具有 EOF 十六进制值：'
- en: '![Diagram  Description automatically generated](img/B18329_04_20.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图表 说明自动生成](img/B18329_04_20.png)'
- en: Figure 4.20:Fragmented file entry
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：碎片化文件条目
- en: We have covered the system area of the FAT; we will now discuss the data area
    of the FAT filesystem.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 FAT 的系统区，现在将讨论 FAT 文件系统的数据区。
- en: Data area
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据区
- en: The root directory is housed in the data area because, when the system stored
    it in the system area, it could not grow enough to work with larger-capacity devices.
    The critical component of the root directory is the directory entry. If there
    is a file, directory, or subdirectory, there will be a corresponding directory
    entry.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录存放在数据区，因为当系统将其存储在系统区时，它无法增长到足以与大容量设备配合使用。根目录的关键组成部分是目录项。如果有文件、目录或子目录，就会有相应的目录项。
- en: Each directory entry is 32 bytes in length and helps track the file’s name,
    starting cluster, and file size in bytes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录项的长度为 32 字节，帮助跟踪文件的名称、起始簇和文件大小（以字节为单位）。
- en: 'In the following diagram, we can see a FAT32 directory with multiple file entries.
    The filesystem will stop looking for file entries when it runs into a hexadecimal
    `00`, and all values following the hexadecimal `00` will be ignored:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图示中，我们可以看到一个包含多个文件条目的 FAT32 目录。当文件系统遇到十六进制 `00` 时，它会停止寻找文件条目，之后的所有值都将被忽略：
- en: '![](img/B18329_04_21.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_21.png)'
- en: 'Figure 4.21: FAT directory entry'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21：FAT 目录项
- en: 'In the following FAT directory map, we can see the layout of the directory
    entry and a **short filename** (**SFN**) directory entry with the specific offsets
    highlighted:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 FAT 目录映射中，我们可以看到目录项的布局，以及带有特定偏移量高亮显示的**短文件名**（**SFN**）目录项：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18329_04_22.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，表格 说明自动生成](img/B18329_04_22.png)'
- en: 'Figure 4.22: FAT directory map'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22：FAT 目录映射
- en: If the first byte is `xE5`, then the filesystem will consider that entry as
    deleted. The remaining bytes of the file or directory name will remain, as will
    the other metadata.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个字节是 `xE5`，则文件系统会将该条目视为已删除。文件或目录名称的其余字节将保留，其他元数据也会保留。
- en: 'The short filename must conform to the specifications as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 短文件名必须符合以下规范：
- en: Eight characters are allowed; if there are less than eight characters, then
    the name will be padded with `x20`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许八个字符；如果少于八个字符，则名称将用 `x20` 填充。
- en: Three characters are allocated for the file extension (if there are less than
    three characters, then the name will be padded with `x20`).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件扩展名分配三个字符（如果少于三个字符，则名称将用 `x20` 填充）。
- en: 'Spaces and the following characters are not permitted: **“+ * , . / : ; < =
    > ?[\]|**.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不允许使用空格和以下字符：**“+ * , . / : ; < = > ?[\]|**。'
- en: The directory entry will always be stored in uppercase. The attribute byte (offset
    `x0B`) is considered a packed byte, which means the different values have different
    meanings.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 目录项始终以大写字母存储。属性字节（偏移量 `x0B`）被视为打包字节，这意味着不同的值具有不同的含义。
- en: 'The following diagram shows that bit values in the `Attribute` flag can be
    combined, and the resulting hex value will reflect the combinations. If a file
    had the **READ ONLY** flag and the **HIDDEN** flag, then that would give us a
    value of `0000 0011`, and, when converted to hexadecimal, we get the value of
    `x03`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示，`属性` 标志中的位值可以组合，结果的十六进制值将反映这些组合。如果文件具有**只读**标志和**隐藏**标志，那么这将给我们一个值 `0000
    0011`，转换为十六进制后得到值 `x03`：
- en: '![Figure 4.23 – Packed byte ](img/B18329_04_23.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.23 – 打包字节](img/B18329_04_23.png)'
- en: 'Figure 4.23: Packed byte'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23：打包字节
- en: When we look at the example at the bottom of the preceding FAT directory map,
    we find the hexadecimal value of 20 at the offset `x0B`; when we convert the hexadecimal
    into binary, we get `0010 0000`. This tells us that the file is an archive.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看前面 FAT 目录映射底部的示例时，我们会发现在偏移位置`x0B`处有一个十六进制值为 20；当我们将该十六进制值转换为二进制时，得到 `0010
    0000`。这告诉我们该文件是一个归档文件。
- en: We can also encounter an **LFN**; the technique for handling an LFN is a little
    bit more complicated. We will discuss LFNs in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会遇到 **长文件名（LFN）**；处理长文件名的方法稍微复杂一些。我们将在下一节讨论 LFNs。
- en: Long filenames
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长文件名
- en: When a user creates an LFN, the system will generate an alias that conforms
    to the SFN standard. It will format the alias so that the first three characters
    will become the extension after the file extension dot. The first six characters
    will be converted to uppercase and used for the alias. The alias will then add
    a **~** character with a number following it. It will start with the number 1
    and increase incrementally if additional files have the same alias name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户创建一个长文件名（LFN）时，系统会生成一个符合 SFN 标准的别名。它会格式化这个别名，使得前 3 个字符会成为文件扩展名点后的扩展名。前 6
    个字符会转换为大写并用于别名。然后，别名会添加一个 **~** 字符，并跟随一个数字。如果有多个文件具有相同的别名，数字会从 1 开始并逐渐增加。
- en: 'The following diagram shows a directory entry for a file with an LFN; the filename
    is `long filename.txt`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个带有长文件名（LFN）的文件目录项；文件名为 `long filename.txt`：
- en: '![](img/B18329_04_24.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_24.png)'
- en: 'Figure 4.24: LFN'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24：长文件名（LFN）
- en: Since this is an LFN, the filesystem will create additional directory entries.
    In this specific case, there will be two additional directory entries to facilitate
    the use of the LFN. The first byte of each additional directory entry is the sequence
    byte. The right nibble is the sequence number. As we look at the directory entry
    depicted in the preceding diagram, the directory entry above the SFN entry has
    a hexadecimal value of `x01`. Here, the value of `1` tells us that this is the
    first value in the sequence. When we move up to the second directory entry, we
    can see that it has a hexadecimal value of `x42`, the right nibble informs us
    this is the second directory entry for this LFN file. The left nibble of the value,
    `4`, tells us this is the last directory entry for the file. In each of the LFN
    directory entries, you will find that the attribute byte is `x0F`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个长文件名（LFN），文件系统将创建额外的目录项。在这个特定的例子中，将会有两个额外的目录项来方便使用 LFN。每个额外目录项的第一个字节是序列字节。右边的半字节是序列号。我们看一下前面图示的目录项，SFN
    目录项上方的目录项的十六进制值为 `x01`。这里，`1` 的值告诉我们这是序列中的第一个值。当我们移动到第二个目录项时，可以看到它的十六进制值为 `x42`，右边的半字节告诉我们这是该
    LFN 文件的第二个目录项。值的左边半字节 `4` 告诉我们这是文件的最后一个目录项。在每个 LFN 目录项中，你会发现属性字节是 `x0F`。
- en: But what happens when a file is deleted? Well, you may be able to recover the
    file and its associated metadata. In the next section, we will discuss recovering
    deleted files.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但当一个文件被删除时会发生什么呢？你或许可以恢复文件及其相关的元数据。在接下来的部分，我们将讨论如何恢复已删除的文件。
- en: Recovering deleted files
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复已删除的文件
- en: When a file is deleted in the FAT filesystem, the data itself does not get changed.
    Instead, the first character of the directory entry will change to `xE5`, and
    the file allocation table entries are reset to `x00`. When the filesystem reads
    the directory entries and encounters `xE5`, it will skip that entry and read from
    the subsequent entries.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件在 FAT 文件系统中被删除时，数据本身不会被改变。相反，目录项的第一个字符会被改为 `xE5`，而文件分配表中的条目会被重置为 `x00`。当文件系统读取目录项并遇到
    `xE5` 时，它会跳过该条目，继续读取随后的条目。
- en: To recover deleted files, we need to reverse the filesystem’s process to delete
    the files. Remember, it has not changed the file contents, and they still physically
    reside in their assigned clusters. So we now need to reverse engineer the deletion
    and recreate the file entry and the entries in the file allocation table. To do
    this, we need to find the first cluster of the file, the file size, and the size
    of the clusters in the volume.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复已删除的文件，我们需要逆转文件系统删除文件的过程。记住，文件内容本身并没有改变，它们仍然物理地存储在它们分配的簇中。因此，我们现在需要逆向工程来恢复删除操作，并重新创建文件目录项以及文件分配表中的相关项。为此，我们需要找到文件的第一个簇、文件大小以及卷中簇的大小。
- en: In the following diagram, we have a directory entry showing that a file has
    been deleted. We can see `xE5` at the start of the directory entry. (Note that
    this will require the use of a hex editor to make the changes.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有一个目录项，显示文件已被删除。我们可以看到目录项的开始位置是`xE5`。（注意，这需要使用十六进制编辑器进行更改。）
- en: 'Then, we must determine the starting cluster, `x00``x08` (but shown as `x08
    x00` in the diagram). This value refers to cluster number 8\. Then, to determine
    the file size, take a look at the last 4 bytes, `x27 x00 x00 x00` (remember that
    the FAT filesystem stores data in little-endian, which means the least-significant
    byte is on the left, so we would read that value as `x00 x00 x00 x27`, and when
    we convert it into a decimal, we have a value of 39 bytes for the file size):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须确定起始簇，`x00``x08`（在图中显示为`x08 x00`）。这个值表示簇编号 8。接着，要确定文件大小，请查看最后 4 个字节，`x27
    x00 x00 x00`（记住 FAT 文件系统以小端格式存储数据，这意味着最不重要的字节在左边，所以我们读取该值为`x00 x00 x00 x27`，转换为十进制时，文件大小为
    39 字节）：
- en: '![](img/B18329_04_25.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_25.png)'
- en: 'Figure 4.25: Deleted entry'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25：已删除的条目
- en: 'Now we must determine how many sectors make up a cluster and what the sector
    size is. You will need to go to the boot record to get that information. The boot
    record shows us that there are 512 bytes per sector, and there are 8 sectors per
    cluster, which gives us a cluster size of 4,096 bytes (as shown in the following
    diagram):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须确定一个簇包含多少个扇区，以及每个扇区的大小。你需要去启动记录中获取这些信息。启动记录告诉我们每个扇区有 512 字节，每个簇有 8 个扇区，这样簇的大小为
    4,096 字节（如下图所示）：
- en: '![Figure 4.26 – Boot record ](img/B18329_04_26.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – 启动记录 ](img/B18329_04_26.png)'
- en: 'Figure 4.26: Boot record'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26：启动记录
- en: 'This means that our file will only occupy a single cluster. We then go to the
    file allocation table and look at the entry for cluster 8 and see that it is zeroed
    out:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的文件将只占用一个单独的簇。然后，我们转到文件分配表，查看簇 8 的条目，并看到它已被清零：
- en: '![](img/B18329_04_27.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_27.png)'
- en: 'Figure 4.27: Deleted FAT'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27：已删除的 FAT
- en: 'To recover the deleted file, perform the following steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复已删除的文件，执行以下步骤：
- en: You need to change the entry in the file allocation table from `x0000 0000`
    to `xFFFF FFF8` or `xFFFF FF0F`. If this were a larger file, you would need to
    change the file allocation table entry to point to the next cluster until you
    reach the last cluster and the end of the file size. As you are rechaining the
    entries, if you come to an entry marked as allocated when expecting to find the
    entry unallocated, you may be dealing with a fragmented file. Another alternative
    is when the clusters were made available to the filesystem. The system placed
    a new file in the now-available sectors, which would cause the data to be overwritten.
    There are not many options available if you run into either one of these situations.
    If the data is overwritten, then you are stuck. If it is fragmented, you must
    guess where the next cluster will be, which is not very likely with a large-capacity
    device.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将文件分配表中的条目从`x0000 0000`更改为`xFFFF FFF8`或`xFFFF FF0F`。如果这是一个较大的文件，你需要将文件分配表条目更改为指向下一个簇，直到你到达最后一个簇和文件大小的末尾。当你重新链接条目时，如果你发现一个标记为已分配的条目，而你本应找到未分配的条目，可能是你遇到了碎片化文件。另一种可能是，当簇被文件系统释放时，系统将新文件放入当前可用的扇区中，这会导致数据被覆盖。如果遇到这两种情况之一，你的选择不多。如果数据被覆盖，你将无法恢复。如果文件碎片化，你需要猜测下一个簇的位置，这在大容量设备上是不太可能的。
- en: The next step is to return to the directory entry and replace `xE5` with another
    character. When replacing the `xE5` character of the filename in the directory
    entry, be careful not to guess what the character is. If you select the incorrect
    character, you could change the meaning or create a bias with the new filename,
    which would be improper. When recovering a deleted file, it is recommended that
    you replace that first character with an underscore or a dash, so there is no
    misunderstanding about the filename.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是返回目录项，并将`xE5`替换为另一个字符。在替换目录项中文件名的`xE5`字符时，要小心不要猜测字符是什么。如果选择了不正确的字符，可能会改变文件名的含义或产生偏差，这样会不正确。在恢复已删除文件时，建议将第一个字符替换为下划线或短横线，以避免对文件名的误解。
- en: When recovering a file with an LFN, it is essential to relink the LFN to the
    SFN. This is because when the additional directories are created to accommodate
    the LFN, the system creates a checksum based on the data of the SFN. Therefore,
    when you change the `xE5` value on the SFN entry, you also want to use the same
    replacement character for the subsequent `xE5` entries for the LFN directory entries.
    You link the LFN to the SFN because the SFN directory entry contains information
    such as the date and time, the starting cluster, and the file size.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复具有LFN（长文件名）的文件时，必须将LFN重新链接到SFN（短文件名）。这是因为当为容纳LFN而创建额外的目录时，系统会根据SFN的数据创建一个校验和。因此，当你更改SFN条目上的`xE5`值时，你也需要对LFN目录条目的后续`xE5`值使用相同的替代字符。将LFN链接到SFN是因为SFN目录条目包含了诸如日期和时间、起始簇以及文件大小等信息。
- en: It is still possible to recover scraps of data that existed on the disk but
    no longer have any artifacts in the filesystem. This information will be stored
    in slack space, discussed in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有可能恢复磁盘上曾存在但在文件系统中不再有任何痕迹的数据。这些信息会存储在空闲空间中，稍后会在下一节中讨论。
- en: Slack space
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲空间
- en: Now is the time to bring up slack space. Remember that the smallest unit the
    filesystem can write to is a cluster and that clusters are made up of one or more
    sectors. I keep repeating this because I have seen people who are new to the field
    get confused about the difference between the two. This is important because files
    come in a variety of sizes; almost no files will conveniently fit within the cluster
    boundaries. So, you will have files that spill over into the next cluster. The
    space between the end of the logical file and the cluster boundary is called “file
    slack.” This slack space can contain data from the previous file. Until it is
    overwritten, that data will remain for you to examine.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提到空闲空间了。记住，文件系统可以写入的最小单位是簇，簇由一个或多个扇区组成。我一直重复这一点，是因为我见过许多新手对两者之间的区别感到困惑。这一点非常重要，因为文件的大小各异；几乎没有文件会恰好适合簇的边界。因此，你会遇到文件溢出到下一个簇的情况。逻辑文件的末尾与簇边界之间的空间被称为“文件空闲”。这个空闲空间可能包含来自前一个文件的数据。直到这些数据被覆盖，它们才会消失，留给你进行检查。
- en: You might find evidence of documents, digital images, chat history, or emails;
    any data that has been stored on the device, you may find remnants in slack space
    after the user has deleted the file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现文件、数字图像、聊天记录或电子邮件的痕迹；任何曾经存储在设备上的数据，在用户删除文件后，可能会在空闲空间中找到残留数据。
- en: This concludes the *FAT filesystems* section; next up is NTFS.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲解完毕，*FAT文件系统*部分结束；接下来是NTFS。
- en: Understanding the NTFS filesystem
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解NTFS文件系统
- en: The **New Technology File System** (**NTFS**) is the default filesystem for
    Microsoft Windows operating systems. FAT32 had some significant shortcomings,
    which required a more reliable and efficient filesystem, along with additional
    administrative improvements to help Microsoft remain viable in a corporate environment.
    They initially designed NTFS for a server environment; however, as the hard drive
    capacity has increased, it is now the default filesystem in the commercial and
    consumer market for the Windows operating system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**新技术文件系统**（**NTFS**）是Microsoft Windows操作系统的默认文件系统。FAT32存在一些显著的缺点，迫切需要一个更可靠和高效的文件系统，并且在管理上做出改进，以帮助Microsoft在企业环境中保持竞争力。他们最初为服务器环境设计了NTFS；然而，随着硬盘容量的增加，它现在成为Windows操作系统在商业和消费市场中的默认文件系统。'
- en: 'NTFS is far more complicated than the FAT filesystem; however, the overall
    purpose remains the same:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: NTFS比FAT文件系统复杂得多；然而，它的总体目的保持不变：
- en: To record the metadata of a file, that is, the filename, the date timestamps,
    and the file size
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录文件的元数据，即文件名、日期时间戳和文件大小
- en: To mark the clusters the file occupies
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记文件占用的簇
- en: To record which clusters are allocated and which clusters are unallocated
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录哪些簇已分配，哪些簇未分配
- en: 'The NTFS filesystem comprises the following system files:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: NTFS文件系统包括以下系统文件：
- en: '![](img/B18329_04_28.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_28.png)'
- en: 'Figure 4.28: NTFS table'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：NTFS表
- en: 'To identify a partition with NTFS, we need to look at the MBR or the GPT, depending
    on which formatting scheme was used. In the following diagram, we can see the
    MBR for the hard drive and the partition table highlighted after the boot code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别NTFS分区，我们需要查看MBR或GPT，这取决于使用了哪种格式化方案。在下图中，我们可以看到硬盘的MBR和在引导代码后高亮显示的分区表：
- en: '![](img/B18329_04_29.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_29.png)'
- en: 'Figure 4.29: NTFS MBR'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29：NTFS MBR
- en: Looking at the partition table, we can see that there is a single partition,
    and, at offset decimal `11` from the start of the partition table, we can see
    the hexadecimal value of `07`. As we discussed earlier in this chapter, this is
    the filesystem identification for NTFS.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 查看分区表时，我们可以看到有一个单一的分区，并且在分区表开始处偏移十进制 `11` 的位置，我们可以看到十六进制值 `07`。正如我们在本章前面讨论的那样，这是
    NTFS 的文件系统标识符。
- en: 'With an NTFS-formatted partition, there is no system or data area like we saw
    with a FAT-formatted partition. Everything in NTFS is considered a file to include
    the system data. When we look at the VBR, we can see that it contains information
    for the system to continue the boot process:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NTFS 格式化的分区中，我们看不到像 FAT 格式化分区那样的系统或数据区域。NTFS 中的一切都被视为文件，包括系统数据。当我们查看 VBR 时，可以看到它包含系统继续引导过程所需的信息：
- en: '![](img/B18329_04_30.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_30.png)'
- en: 'Figure 4.30: NTFS VBR'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30：NTFS VBR
- en: 'The information in the VBR is a file; the `$Boot` record contains all the information
    that we would expect to find in the VBR. The following `$Boot` diagram shows the
    data structure for the `$Boot` file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 中的信息是一个文件；`$Boot` 记录包含了我们在 VBR 中期望找到的所有信息。以下 `$Boot` 图示展示了 `$Boot` 文件的数据结构：
- en: '![](img/B18329_04_31.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_31.png)'
- en: 'Figure 4.31: $Boot record'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31：$Boot 记录
- en: Arguably, the most important system file in the NTFS filesystem is the `$MFT`
    (master file table). The MFT tracks all the files in the volume to include itself.
    It tracks each file within the MFT through file entries called a file record.
    Each file record is uniquely numbered and is 1,024 bytes. Each file record starts
    with a header, with the ASCII text **“FILE”**, and has an EOF marker of hexadecimal
    `FF FF FF FF`. A new file record is created when files are added to the volume.
    If a file has been deleted, the record will zero out and make it available for
    reuse. The MFT will look for an empty file record and use it before creating a
    new record. The file record can be reused rather quickly, which would overwrite
    the previous data in the file record.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，NTFS 文件系统中最重要的系统文件是 `$MFT`（主文件表）。MFT 跟踪卷中的所有文件，包括它自身。它通过称为文件记录的文件条目跟踪 MFT
    中的每个文件。每个文件记录都是唯一编号的，大小为 1,024 字节。每个文件记录以一个头部开始，头部包含 ASCII 文本 **“FILE”**，并具有十六进制的
    `FF FF FF FF` 作为 EOF 标记。当文件被添加到卷时，会创建一个新的文件记录。如果文件已被删除，该记录会被清零并准备好再次使用。MFT 会寻找一个空的文件记录并在创建新记录之前使用它。文件记录可以很快被重用，这会覆盖文件记录中的先前数据。
- en: 'As shown in the following NTFS file record example, we can see a file record
    and file header starting with the ASCII values of **FILE**. If the record were
    corrupted or had an error, you would see the ASCII value of **BAAD**. The file
    header is `56` bytes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的 NTFS 文件记录示例中，我们可以看到一个文件记录和文件头，文件头以 **FILE** 的 ASCII 值开始。如果记录已损坏或出现错误，你将看到
    **BAAD** 的 ASCII 值。文件头大小为 `56` 字节：
- en: '![](img/B18329_04_32.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_32.png)'
- en: 'Figure 4.32: NTFS file record'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32：NTFS 文件记录
- en: 'In the following NTFS file record map, we can see the data structure of a file
    record header:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 NTFS 文件记录映射中，我们可以看到文件记录头的数据信息结构：
- en: '![Figure 4.33 – NTFS file record map ](img/B18329_04_33.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.33 – NTFS 文件记录映射](img/B18329_04_33.png)'
- en: 'Figure 4.33: NTFS file record map'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33：NTFS 文件记录映射
- en: 'The file record also contains defined data blocks called file attributes. These
    store specific types of information about the file. The following file attributes
    table shows several common file attributes that you are likely to see in almost
    every record:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 文件记录还包含称为文件属性的已定义数据块。这些数据块存储关于文件的特定类型信息。以下文件属性表显示了在几乎每个记录中可能看到的几个常见文件属性：
- en: '![](img/B18329_04_34.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_34.png)'
- en: 'Figure 4.34: File attributes table'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34：文件属性表
- en: Let’s look at each of these attributes in detail.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些属性。
- en: '**$Standard_Information Attribute (0x10)**: The file attributes follow the
    file header and contain information about the file and, sometimes, the actual
    file itself. The following diagram depicts a file attribute. The first four bytes
    show the attribute type; in this case, it is the $10 Standard Information Attribute,
    which contains general information, flags, accessed, written, and created times,
    the owner, and security ID. It is identified by the hexadecimal header: `x/10
    00 00 00`. The file attribute map contains the decoded values:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$Standard_Information Attribute (0x10)`**：文件属性位于文件头之后，包含有关文件的信息，有时还包括实际文件本身。以下图示展示了文件属性。前四个字节表示属性类型；在本例中，它是`$10`标准信息属性，包含一般信息、标志、访问时间、写入时间、创建时间、所有者和安全ID。它通过十六进制头`x/10
    00 00 00`进行标识。文件属性映射包含解码后的值：'
- en: '![](img/B18329_04_35.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_35.png)'
- en: 'Figure 4.35: $Standard_Information Attribute'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：`$Standard_Information`属性
- en: 'Here is a map of the values you will find in the attribute:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在属性中找到的值的映射：
- en: '![Figure 4.36 – File attribute map ](img/B18329_04_36.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图4.36 – 文件属性映射](img/B18329_04_36.png)'
- en: 'Figure 4.36: File attribute map'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36：文件属性映射
- en: '**$File_Name Attribute (0x30)**: The next attribute is the `$30` File_Name
    Attribute. This attribute stores the name of the file attribute and is always
    resident. The maximum filename length is 255 Unicode characters. It is identified
    by the hexadecimal header of `x/ 30 00 00 00`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$File_Name Attribute (0x30)`**：下一个属性是`$30`文件名属性。此属性存储文件名，并且总是常驻的。文件名的最大长度为255个Unicode字符。它通过十六进制头`x/30
    00 00 00`进行标识：'
- en: '![](img/B18329_04_37.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_37.png)'
- en: 'Figure 4.37: $File_Name Attribute'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37：`$File_Name`属性
- en: 'The following is a map of the values you will find in the attribute:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在属性中找到的值的映射：
- en: '![Figure 4.38 – Filename attribute map ](img/B18329_04_38.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图4.38 – 文件名属性映射](img/B18329_04_38.png)'
- en: 'Figure 4.38: Filename attribute map'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：文件名属性映射
- en: '**$Data Attribute (0x80)**: The following attribute for this entry is the `$80`
    Data Attribute. The data attribute contains the file’s contents or points to where
    the contents are in the volume. This attribute is the file data itself.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$Data Attribute (0x80)`**：此条目的下一个属性是`$80`数据属性。数据属性包含文件的内容或指向卷中内容的指针。此属性即为文件数据本身。'
- en: If the data attribute is resident, we only see the attribute header and the
    resident content header. The resident content of the attribute is the file’s data.
    Only tiny files have a resident data attribute. We will discuss resident versus
    non-resident data later on in this chapter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据属性是常驻的，我们只会看到属性头和常驻内容头。属性的常驻内容即文件数据。只有小文件才会有常驻数据属性。我们将在本章后面讨论常驻数据与非常驻数据的区别。
- en: 'You may find multiple data attributes per file. In this record, the second
    $80 Data Attribute, Dropbox, has added some information to the file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件可能会有多个数据属性。在此记录中，第二个`$80`数据属性，Dropbox，已向文件添加了一些信息：
- en: '![](img/B18329_04_39.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_39.png)'
- en: 'Figure 4.39: $Data Attribute'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：`$Data`属性
- en: 'The following is a map of the values you will find in the attribute:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在属性中找到的值的映射：
- en: '![Figure 4.40 – Data attribute map ](img/B18329_04_40.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图4.40 – 数据属性映射](img/B18329_04_40.png)'
- en: 'Figure 4.40: Data attribute map'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：数据属性映射
- en: 'When examining the `$Data Attribute 0x80`, the filesystem may store the file’s
    contents within the MFT file record itself. Since the file record is 1,024 bytes
    long, it would have to be a tiny file. When the data content of the file fits
    within the file record, it is called “resident data”:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查`$Data Attribute 0x80`时，文件系统可能会将文件的内容存储在MFT文件记录中。由于文件记录为1,024字节，因此它必须是一个小文件。当文件的内容适合文件记录时，它被称为“常驻数据”：
- en: '![Graphical user interface, application  Description automatically generated](img/B18329_04_41.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序 描述自动生成](img/B18329_04_41.png)'
- en: 'Figure 4.41: Resident data file'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：常驻数据文件
- en: 'In the current example, we have a file named `resident.txt` that is 23 bytes.
    This is smaller than the 1,024 bytes of the file record. To look at the data of
    the file, we need to look at the `$Data Attribute 0x80` of the file record, as
    follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，我们有一个名为`resident.txt`的文件，大小为23字节。这比文件记录的1,024字节要小。要查看文件的数据，我们需要查看文件记录中的`$Data
    Attribute 0x80`，如下所示：
- en: '![](img/B18329_04_42.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_42.png)'
- en: 'Figure 4.42: Resident data example'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：常驻数据示例
- en: 'On examining the attribute, we can see the ASCII and hex representation of
    the file content we observed in the preceding resident data example. When dealing
    with a non-resident file, such as the one depicted in the following diagram, we
    can see that the `nonresident.txt` file, which is 145 KB in size, is larger than
    the 1,024-byte file record:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 检查属性时，我们可以看到在前面驻留数据示例中观察到的文件内容的 ASCII 和十六进制表示。当处理一个非驻留文件时，如下图所示，我们可以看到`nonresident.txt`文件，其大小为
    145 KB，超过了 1,024 字节的文件记录：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18329_04_43.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序 描述自动生成](img/B18329_04_43.png)'
- en: 'Figure 4.43: Non-resident data'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43：非驻留数据
- en: 'When you look at the `$Data Attribute 0x80` of the file, as shown in the preceding
    diagram, we do not see the contents of the file, but we have pointers to the location
    of the file within the volume boundaries. We consider this to be non-resident
    content. Once the content of the attribute becomes non-resident, it can never
    become resident again. We commonly refer to the pointers in the file record of
    the attribute as a “run list” for the data runs of the non-resident data:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看文件的`$Data Attribute 0x80`时，如前图所示，我们并没有看到文件的内容，而是看到了指向文件在卷边界内位置的指针。我们将其视为非驻留内容。一旦属性的内容变为非驻留，它将永远无法变为驻留内容。我们通常将文件记录中的属性指针称为“运行列表”，用于非驻留数据的运行：
- en: '![](img/B18329_04_44.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_44.png)'
- en: 'Figure 4.44: Non-resident data example'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.44：非驻留数据示例
- en: 'You can have a single data run, or multiple data runs, within the `$Data Attribute`
    `0x80`. Deciphering the run list for the data runs can be tricky. In the following
    run list, we have the `$Data Attribute 0x80` with two run lists:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$Data Attribute` `0x80`中，你可以有单个数据运行或多个数据运行。解读数据运行的运行列表可能是棘手的。在以下运行列表中，我们有`$Data
    Attribute 0x80`，其中包含两个运行列表：
- en: '![](img/B18329_04_45.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18329_04_45.png)'
- en: 'Figure 4.45: Run list'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.45：运行列表
- en: 'If the file is not fragmented, then you will have one run list pointing to
    the data run in the volume. If the file is fragmented (which is very common),
    then you will have multiple run lists providing information about the starting
    cluster for each fragment. I have taken the two run lists highlighted in the preceding
    list and created the following chart:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件没有碎片化，那么你将会有一个指向数据运行的运行列表。如果文件被碎片化（这非常常见），那么你将会有多个运行列表，提供每个碎片的起始簇的信息。我已经提取了前面列表中标出的两个运行列表，并创建了如下图表：
- en: '![Figure 4.46 – Run list map ](img/B18329_04_46.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.46 – 运行列表图](img/B18329_04_46.png)'
- en: 'Figure 4.46: Run list map'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.46：运行列表图
- en: The first run list comprises the hexadecimal values of `31 07 E8 E3 48`. Take
    the first byte of the header (`x/31`) and add the left and right nibbles (3+1
    = 4). 4 is the number of bytes in the run list entry (this is `x/07 E8 E3 48`).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个运行列表由十六进制值`31 07 E8 E3 48`组成。取头部的第一个字节（`x/31`），并加上左右半字节（3+1 = 4）。4 是运行列表条目的字节数（即`x/07
    E8 E3 48`）。
- en: The right nibble (`x/1`) tells us that 1 byte represents the number of clusters
    being used for this fragment. We find a value of `x/07` in the length field, which
    represents 7 clusters for this fragment. The left nibble (`x/3`) informs us that
    3 bytes (`x/E8 E3 48`) will represent the logical starter cluster of the fragment.
    At the end of the first run, we have a second run list of `x/31 14 44 47 17`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的半字节（`x/1`）告诉我们，1 个字节表示该碎片所使用的簇的数量。我们在长度字段中找到了`x/07`，这表示该碎片使用了 7 个簇。左边的半字节（`x/3`）告诉我们，3
    个字节（`x/E8 E3 48`）将表示碎片的逻辑起始簇。在第一个运行结束时，我们有一个第二个运行列表`x/31 14 44 47 17`。
- en: Like the prior run list, we take the first byte of the header (`x/31`) and add
    the left and right nibbles (3+1 = 4). 4 is the number of bytes in the run list
    entry (which is `x/14 44 47 17`). The right nibble (`x/1`) tells us that 1 byte
    represents the number of clusters being used for this fragment. We find a value
    of `x/14` in the length field, which represents 20 clusters for this fragment.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前的运行列表一样，我们取头部的第一个字节（`x/31`），并加上左右半字节（3+1 = 4）。4 就是运行列表条目的字节数（即`x/14 44 47
    17`）。右边的半字节（`x/1`）告诉我们，1 个字节表示该碎片所使用的簇的数量。我们在长度字段中找到了`x/14`，这表示该碎片使用了 20 个簇。
- en: The left nibble (`x/3`) informs us that 3 bytes (`x/44 47 17`) will represent
    the offset from the previous run list cluster. This process will keep going until
    the system hits `x/ 00 00 00 00`, which shows the end of the run lists.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的半字节（`x/3`）告诉我们，3个字节（`x/44 47 17`）将表示从前一个运行列表集群的偏移量。这个过程会一直进行，直到系统遇到 `x/ 00
    00 00 00`，这表示运行列表的结束。
- en: That concludes our adventure into the world of NTFS. If you find yourself with
    a headache, you are not alone! This is just the basics of the filesystem. You
    can find entire books that have been written about NTFS, if you want to go into
    much greater detail.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对NTFS世界的探险。如果你感到头疼，别担心，你并不孤单！这仅仅是文件系统的基础知识。如果你想深入了解，可以找到关于NTFS的整本书籍。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how physical disks are constructed and prepared
    in order to store data. We discussed different partition schemes and how they
    address the creation of logical partitions. We also learned how filesystems differ
    and how data is organized.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了物理磁盘如何构建和准备，以便存储数据。我们讨论了不同的分区方案及其如何处理逻辑分区的创建。我们还学习了文件系统的区别以及数据如何组织。
- en: In the next chapter, we will learn about the computer investigative process
    and how to analyze timelines, analyze media, and perform string searching for
    data.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习计算机调查过程，以及如何分析时间线、分析媒体和进行字符串搜索数据。
- en: Questions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Newer computer systems utilize the BIOS booting method.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新的计算机系统使用BIOS启动方法。
- en: 'True'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A UEFI-based computer system will utilize ____________ to boot from.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于UEFI的计算机系统将使用 ____________ 来启动。
- en: MBR
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MBR
- en: VBR
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: VBR
- en: GPT
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPT
- en: LSD
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: LSD
- en: A cluster is the smallest storage unit on a hard drive.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集群是硬盘上最小的存储单元。
- en: 'True'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: An MBR-formatted disk can have more than four primary partitions.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MBR格式的磁盘可以有超过四个主分区。
- en: 'True'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'A FAT32-formatted partition is laid out in two areas: a system area and a ___________
    area.'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FAT32格式的分区被划分为两个区域：一个是系统区域，另一个是 ___________ 区域。
- en: Disk
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁盘
- en: Doughnut
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆环
- en: Data
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据
- en: Designer
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计师
- en: In a FAT32-formatted partition, the root directory is in the system area.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在FAT32格式化的分区中，根目录位于系统区域。
- en: 'True'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: In a NTFS-formatted partition, the filename is stored in the _______________
    attribute.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在NTFS格式化的分区中，文件名存储在 _______________ 属性中。
- en: Standard information
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准信息
- en: Filename
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件名
- en: Data
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据
- en: Security descriptor
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全描述符
- en: The answers can be found at the end of the book under *Assessment*.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可以在书的最后部分的*评估*栏目中找到。
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度阅读
- en: Carrier, B. *File System Forensic Analysis*. Addison-Wesley, Reading, PA., Mar.
    2005 (available at [https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1](https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1)).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Carrier, B. *文件系统取证分析*。Addison-Wesley出版社，宾夕法尼亚州雷丁市，2005年3月（可通过[https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1](https://www.kobo.com/us/en/ebook/file-system-forensic-analysis-1)获得）。
- en: Join our community on Discord
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在Discord上的社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/CyberSec](https://packt.link/CyberSec)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/CyberSec](https://packt.link/CyberSec)'
- en: '![](img/QR_Code3852467292877112093.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code3852467292877112093.png)'
