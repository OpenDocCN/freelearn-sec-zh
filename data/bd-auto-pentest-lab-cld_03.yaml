- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Succeeding with Infrastructure as Code Tools and Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功使用基础设施即代码工具和策略
- en: In the previous chapter, we manually created our first vulnerable lab environment
    using the **AWS Management Console**. It probably took us about an hour and a
    half to set everything up. After completing the lab setup, it may have taken us
    an additional 30 minutes to test whether everything was (mis)configured as expected.
    What if we wanted to set up 10 lab environments similar to what we prepared in
    *[Chapter 2](B19755_02.xhtml)* for a security training course? *Do we really need
    around 20 hours to set all of these up?* In addition to this, remember that we
    only worked on a small component of an entire cloud penetration testing lab environment!
    Complete lab environments generally have about 5 to 10 times more resources compared
    to what we prepared in *[Chapter 2](B19755_02.xhtml)*. Assuming the complete environment
    is at least five times larger than what we initially prepared, and taking into
    account the need to create and delete the entire environment every time to manage
    costs, it is worth considering whether the manual setup process for these environments
    (which typically takes around 10 hours each) is truly necessary. That said, is
    there a better way to create and manage the cloud infrastructure resources for
    our penetration testing lab environments?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 **AWS 管理控制台** 手动创建了第一个易受攻击的实验环境。整个设置过程大约花了我们一个半小时。完成实验环境设置后，我们可能又花了30分钟来测试是否一切（误）配置正确。如果我们希望为一个安全培训课程设置10个与*[第2章](B19755_02.xhtml)*中相似的实验环境怎么办？*我们真的需要大约20小时才能完成这些设置吗？*此外，请记住，我们只完成了整个云渗透测试实验环境的一个小部分！完整的实验环境一般比我们在*[第2章](B19755_02.xhtml)*中准备的要多出5到10倍的资源。假设完整环境至少是我们最初准备的五倍大，并且考虑到每次都需要创建和删除整个环境以管理成本，那么是否手动设置这些实验环境（通常每个大约需要10小时）真的必要呢？话虽如此，是否有更好的方法来创建和管理我们的渗透测试实验环境的云基础设施资源？
- en: 'In this chapter, we will answer these questions by taking a closer look at
    how **Infrastructure as Code** (**IaC**) solves these challenges and requirements!
    That said, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过深入分析 **基础设施即代码**（**IaC**）如何解决这些挑战和需求，来回答这些问题！因此，我们将涵盖以下主题：
- en: Diving deeper into IaC tools and strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨 IaC 工具和策略
- en: Setting up Terraform in AWS CloudShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS CloudShell 中设置 Terraform
- en: Getting our feet wet with Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 起步
- en: Understanding the Terraform configuration language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Terraform 配置语言
- en: Building our vulnerable lab environment with Terraform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 构建我们的易受攻击的实验环境
- en: Configuring a Terraform backend with state locking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置带有状态锁定的 Terraform 后端
- en: Verifying the state-locking setup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证状态锁定设置
- en: The hands-on solutions in this chapter will equip you with the skills and confidence
    needed to convert existing cloud infrastructure resources into IaC configuration
    files. With these configuration files, we should be able to set up multiple penetration
    testing lab environments quickly within minutes using automated tools and services!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实践解决方案将为你提供将现有云基础设施资源转换为 IaC 配置文件所需的技能和信心。通过这些配置文件，我们应该能够使用自动化工具和服务在几分钟内快速设置多个渗透测试实验环境！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start, we must have the following ready:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们必须准备以下内容：
- en: '**Required**: The “target” AWS account used in *[Chapter 2](B19755_02.xhtml)*,
    which will contain the vulnerable environment and resources'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必需**：在*[第2章](B19755_02.xhtml)*中使用的“目标”AWS账户，将包含易受攻击的环境和资源'
- en: '**Optional**: A second AWS account (also used in *[Chapter 2](B19755_02.xhtml)*),
    which will serve as the “attacker’s account”'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选**：第二个 AWS 账户（同样在*[第2章](B19755_02.xhtml)*中使用），将作为“攻击者的账户”'
- en: 'In case you skipped *[Chapter 2](B19755_02.xhtml)*, *Preparing Our First Vulnerable
    Cloud Lab Environment*, feel free to create the AWS accounts using the following
    link: [https://aws.amazon.com/free/](https://aws.amazon.com/free/). You may proceed
    with the next steps once the accounts are ready.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了*[第2章](B19755_02.xhtml)*，*准备我们的第一个易受攻击的云实验环境*，可以通过以下链接创建 AWS 账户：[https://aws.amazon.com/free/](https://aws.amazon.com/free/)。账户创建好后，便可继续进行后续步骤。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter primarily focuses on using Terraform to build a sample vulnerable
    lab environment on AWS. Of course, we need to have our **Microsoft Azure** and
    **Google Cloud Platform** (**GCP**) accounts ready once we reach the hands-on
    portion of the succeeding chapters of this book (*[Chapter 4](B19755_04.xhtml)*
    onward). In the meantime, setting up two AWS accounts should do the trick for
    now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注使用Terraform在AWS上构建一个示例易受攻击的实验室环境。当然，一旦进入本书后续章节的动手部分（*第4章*及之后章节），我们需要准备好**Microsoft
    Azure**和**Google Cloud Platform**（**GCP**）账户。与此同时，当前设置两个AWS账户应该足够了。
- en: 'The source code and other files used for each chapter are available in this
    book’s GitHub repository:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书每章使用的源代码和其他文件可以在本书的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud)'
- en: Diving deeper into IaC tools and strategies
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探索IaC工具和策略
- en: Before we dive into the practical exercises in this chapter, we will first establish
    a clear understanding of IaC in this section and discuss how it can be harnessed
    for building complex penetration testing labs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章的实际练习之前，我们将首先在本节中明确理解IaC，并讨论如何利用它来构建复杂的渗透测试实验室。
- en: Demystifying IaC
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭开IaC的神秘面纱
- en: 'IaC is the practice and process of using code to provision and manage infrastructure
    resources. This code works similarly to how a blueprint of a house is used as
    a reference when building the actual house. The cool thing when dealing with IaC
    code is that the actual infrastructure resources are created and configured automatically
    from the code that represents the desired final state of the infrastructure. Behind
    the scenes, the IaC automation tools simply make use of the same set of APIs we
    would use when trying to automate specific processes. The process is illustrated
    in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IaC是通过代码来配置和管理基础设施资源的实践和过程。这些代码的工作原理类似于房屋蓝图在建造实际房屋时的参考作用。处理IaC代码的酷炫之处在于，实际的基础设施资源是根据表示所需最终状态的代码自动创建和配置的。在后台，IaC自动化工具实际上只是使用我们在尝试自动化特定流程时会使用的相同API集。这个过程在下图中进行了说明：
- en: '![](image/B19755_03_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_03_01.jpg)'
- en: Figure 3.1 – Using IaC tools and services to create and manage cloud resources
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 使用IaC工具和服务创建和管理云资源
- en: In *Figure 3**.1*, we can see that the same set of configuration files (representing
    the desired state) can be used to generate and configure multiple environments
    with the same set of resources and properties. For example, we can use IaC configuration
    files when provisioning and ensuring the consistency of development, staging,
    and production environments used by developers and engineers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.1*中，我们可以看到相同的配置文件集（表示所需的状态）可以用于生成和配置多个具有相同资源和属性的环境。例如，我们可以在配置和确保开发、预生产和生产环境的一致性时使用IaC配置文件，这些环境供开发人员和工程师使用。
- en: At this point, you might be wondering how configuration files are used to generate
    actual cloud infrastructure resources. Let’s start with a configuration file where
    a single resource is defined. This configuration file is then passed as input
    to the IaC tool, which then runs the code specified (an **imperative approach**)
    or, alternatively, “magically” converts the configuration code into actual infrastructure
    resources (a **declarative approach**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会好奇配置文件是如何用来生成实际的云基础设施资源的。让我们从定义单个资源的配置文件开始。这个配置文件随后作为输入传递给IaC工具，IaC工具根据指定的代码（**命令式方法**）执行，或者通过“魔法”将配置代码转换为实际的基础设施资源（**声明式方法**）。
- en: 'The following diagram depicts how IaC tools and services manage changes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了IaC工具和服务如何管理变更：
- en: '![](image/B19755_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_03_02.jpg)'
- en: Figure 3.2 – How IaC tools and services manage changes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – IaC工具和服务如何管理变更
- en: '*Assuming that we used the declarative approach to provision the initial set
    of cloud resources, can we modify the configuration code and use the IaC tool
    again to update the existing set of infrastructure resources?* Similar to what
    we have in *Figure 3**.2*, certain IaC tools can manage the changes for us automatically
    and generate an **execution plan** that modifies the infrastructure to reach the
    desired state as specified in the IaC configuration templates. These changes are
    then applied to the existing infrastructure resources.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设我们使用声明性方法来配置初始的云资源集，我们能否修改配置代码并再次使用 IaC 工具来更新现有的基础设施资源集？* 正如我们在*图 3.2*中所看到的那样，某些
    IaC 工具可以自动管理这些更改，并生成一个**执行计划**，该计划会修改基础设施，使其达到 IaC 配置模板中指定的期望状态。这些更改随后会应用于现有的基础设施资源。'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that IaC tools may either (1) perform in-place modifications
    in the infrastructure or (2) replace the entire infrastructure resources instead.
    This varies depending on the IaC tool, along with the type of change being performed.
    When working on resources deployed inside penetration testing lab environments,
    we generally want to replace the entire thing since old infrastructure resources
    may already be in an unstable or misconfigured state due to previous exploitation
    attempts and activities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，IaC 工具可能会（1）在基础设施中执行就地修改，或者（2）替换整个基础设施资源。这取决于所使用的 IaC 工具以及所进行的更改类型。在处理部署在渗透测试实验室环境中的资源时，我们通常希望替换整个资源，因为旧的基础设施资源可能由于先前的利用尝试和活动已经处于不稳定或配置错误的状态。
- en: Leveraging IaC for penetration testing labs
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 IaC 进行渗透测试实验室管理
- en: Now, let’s talk about why IaC mixes well with the preparation and management
    of penetration testing labs in the cloud. Creating and managing dedicated penetration
    testing lab environments in the cloud can be complex and time-consuming. Utilizing
    IaC can simplify this process and provide numerous benefits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论为什么 IaC 与云端渗透测试实验室的准备和管理相得益彰。创建和管理云端专用渗透测试实验室环境可能是复杂且耗时的。使用 IaC 可以简化这一过程，并带来许多好处。
- en: 'Here is a quick list of the advantages of using IaC when building penetration
    testing labs in the cloud:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 IaC 构建云端渗透测试实验室的一些优势：
- en: '**Faster deployment**: Since the configuration code contains the properties
    and desired state of the resources to be created, we can quickly create and destroy
    various lab resources through an automated process within seconds (to, at most,
    a few minutes). This helps us easily rebuild specific cloud infrastructure resources
    that require a “refresh” after a penetration testing lab activity or experiment
    (since these activities may intentionally or unintentionally leave some services
    or resources in an unstable or misconfigured state).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的部署**：由于配置代码包含了要创建的资源的属性和期望状态，我们可以通过自动化流程在几秒钟内（最多几分钟）快速创建和销毁各种实验室资源。这帮助我们在渗透测试实验室活动或实验后，轻松地重建需要“刷新”的特定云基础设施资源（因为这些活动可能会故意或无意中将某些服务或资源置于不稳定或配置错误的状态）。'
- en: '**Collaboration**: We can easily share the lab environment configuration and
    setup as code with other engineers. This allows for easier collaboration and discussion
    when troubleshooting security configuration settings of resources deployed inside
    penetration testing lab environments (that is, without having to share your entire
    cloud account).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：我们可以轻松地与其他工程师共享实验室环境的配置和设置代码。这使得在排查部署在渗透测试实验室环境中的资源的安全配置时，可以更轻松地进行协作和讨论（也就是说，无需分享整个云账户）。'
- en: '**Consistency**: If there are multiple vulnerable lab environments set up from
    a single instance of IaC configuration code, we only need to modify the IaC code
    once and apply the changes automatically to these lab environments. We can guarantee
    the repeatability of the infrastructure management process and ensure that the
    resource configuration and versions stay consistent every time we build our penetration
    testing lab environments. It is important to note that the exploitability of certain
    vulnerabilities and misconfigurations depends on the version of the applications
    and resources used.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：如果从单个IaC配置代码实例设置了多个易受攻击的实验室环境，我们只需修改IaC代码一次，并将更改自动应用于这些实验室环境。我们可以保证基础设施管理过程的重复性，并确保每次构建渗透测试实验室环境时，资源配置和版本保持一致。需要注意的是，某些漏洞和错误配置的可利用性取决于所使用的应用程序和资源的版本。'
- en: '**Transparency**: Auditing infrastructure configuration mistakes is easier
    since we can check the current configuration using the code representing the infrastructure.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明性**：由于我们可以使用表示基础设施的代码检查当前配置，审计基础设施配置错误变得更加容易。'
- en: '**Optimized**: Infrastructure cost management is easier since we can have our
    cloud resources turned off (or deleted) when nobody is using the penetration testing
    lab environments. Once the resources need to be created, it only takes a few minutes
    for the resources to be prepared from the infrastructure configuration code available.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化**：基础设施成本管理变得更加容易，因为我们可以在没有人使用渗透测试实验室环境时关闭（或删除）云资源。一旦需要创建资源，从现有的基础设施配置代码准备资源只需几分钟。'
- en: As we can see, IaC enables faster deployment of lab resources through an automated
    process, allowing for quick creation and destruction of resources within seconds
    to a few minutes. Collaboration is simplified as engineers can easily share lab
    environment configurations and setups as code, facilitating troubleshooting of
    security settings without sharing the entire cloud account. Additionally, IaC
    ensures consistency by modifying the code once to apply changes automatically
    to multiple lab environments, guaranteeing repeatability and maintaining consistent
    resource configurations and versions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，IaC通过自动化过程实现更快速的实验室资源部署，允许在几秒钟到几分钟内快速创建和销毁资源。协作变得更加简单，因为工程师可以轻松地以代码形式共享实验室环境配置和设置，从而促进了安全设置的故障排除，而无需共享整个云账户。此外，IaC通过修改代码一次并自动将更改应用于多个实验室环境，确保一致性，保证了重复性，并保持一致的资源配置和版本。
- en: With these points in mind, let’s proceed with best practices and strategies
    when using IaC solutions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些要点后，我们可以继续讨论在使用IaC解决方案时的最佳实践和策略。
- en: Embracing IaC best practices and strategies
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接纳IaC最佳实践和策略
- en: A variety of IaC tools have been used by developers and engineers these past
    couple of years to create and manage infrastructure. Some of the most popular
    ones include **Chef**, **Puppet**, **Vagrant**, **(R)?ex**, **SaltStack**, **Pulumi**,
    **Ansible**, **AWS Cloud Development Kit** (**AWS CDK**), **AWS CloudFormation**,
    **GCP Deployment Manager**, and **Azure Resource Manager**. Some of these tools
    (such as AWS CDK, AWS CloudFormation, GCP Deployment Manager, and Azure Resource
    Manager) have been built to automate the creation, configuration, and management
    of resources for specific cloud providers. The rest are cloud-agnostic—that is,
    these tools should work across multiple cloud platforms such as **AWS**, **Microsoft
    Azure**, and **GCP**. From this list, certain tools (such as Ansible, Chef, and
    Puppet) primarily focus on setting up applications and configuring *what’s inside
    a virtual machine*, while others (such as Terraform) primarily focus on deploying
    and provisioning cloud infrastructure resources from code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年里，开发人员和工程师使用了多种IaC工具来创建和管理基础设施。其中一些最流行的工具包括**Chef**、**Puppet**、**Vagrant**、**(R)?ex**、**SaltStack**、**Pulumi**、**Ansible**、**AWS
    Cloud Development Kit**（**AWS CDK**）、**AWS CloudFormation**、**GCP Deployment Manager**和**Azure
    Resource Manager**。其中一些工具（如AWS CDK、AWS CloudFormation、GCP Deployment Manager和Azure
    Resource Manager）是为特定云提供商自动化资源的创建、配置和管理而构建的。其余的则是云中立的——即这些工具应该能跨多个云平台（如**AWS**、**Microsoft
    Azure**和**GCP**）工作。在这个列表中，某些工具（如Ansible、Chef和Puppet）主要集中在设置应用程序和配置*虚拟机内部的内容*，而其他工具（如Terraform）主要专注于从代码中部署和提供云基础设施资源。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: We can use multiple tools at the same time when deploying, provisioning, and
    configuring infrastructure. For example, we can use Terraform along with Ansible
    to automate the deployment of cloud infrastructure resources along with the applications
    running inside virtual machines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在部署、配置和管理基础设施时同时使用多个工具。例如，我们可以将Terraform与Ansible结合使用，自动化部署云基础设施资源以及运行在虚拟机中的应用程序。
- en: 'Before we proceed with the next section, let’s discuss some strategies we can
    use when using IaC tools and services:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一部分之前，让我们讨论一下使用IaC工具和服务时可以采取的一些策略：
- en: We can use **version control systems** (for example, Git) to track and manage
    changes to the IaC configuration code used to manage and deploy our penetration
    testing lab environments. In addition to this, we can have a **Continuous Integration/Continuous
    Deployment** (**CI/CD**) pipeline automatically deploy the resources specified
    in the IaC files after changes in the code have been pushed to the code repository.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用**版本控制系统**（例如Git）来跟踪和管理用于管理和部署渗透测试实验室环境的IaC配置代码的变化。除此之外，我们还可以通过**持续集成/持续部署**（**CI/CD**）管道，在代码更改推送到代码仓库后，自动部署IaC文件中指定的资源。
- en: We can easily modularize and manage the different resource groups used in the
    lab environment by properly separating the code into multiple files. Once the
    components of the penetration testing labs have been modularized, we can easily
    generate different variations of vulnerable lab environments using the modules
    available.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将代码正确地拆分为多个文件，轻松模块化并管理实验室环境中使用的不同资源组。一旦渗透测试实验室的组件被模块化，我们就可以轻松地使用现有模块生成不同变种的漏洞实验环境。
- en: Cost plays a big factor in the design of penetration testing lab environments.
    IaC allows environment or cloud account owners to have cloud resources turned
    off (or non-existent) until they are needed. *Why?* Because IaC tools make it
    easy to create and bring resources back up from configuration files (generally
    within a matter of seconds or minutes). When designing and building penetration
    testing lab environments in the cloud, we also have the option whether we allow
    multiple users to share the same environment or have each user have their own
    dedicated environments (which could be more costly). With IaC, we can easily allow
    the second option to be cost-effective since we can just create and provision
    the infrastructure from a template when the user needs to use it. *What’s the
    disadvantage of the first option?* Since the lab is shared by multiple users,
    a certain user might encounter unexpected issues during the penetration testing
    process since the resources involved may already be misconfigured due to an action
    (or actions) performed by another user. If one of the users decides to refresh
    or rest the box, then any active work another user is doing will be reset as well.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本在渗透测试实验室环境设计中起着重要作用。基础设施即代码（IaC）允许环境或云账户的拥有者在需要时再启用（或根本没有）云资源。*为什么？* 因为IaC工具使得从配置文件（通常是几秒钟或几分钟内）创建和恢复资源变得非常简单。当我们在云中设计和构建渗透测试实验室环境时，我们还可以选择是否允许多个用户共享同一个环境，或者让每个用户拥有自己的专用环境（这可能会更昂贵）。使用IaC时，我们可以轻松地让第二个选项在成本上更具可行性，因为我们只需在用户需要时根据模板创建并配置基础设施。*第一个选项的缺点是什么？*
    由于实验室由多个用户共享，某些用户在渗透测试过程中可能会遇到意外问题，因为涉及的资源可能已经由于其他用户的某个操作（或多个操作）而配置错误。如果其中一个用户决定刷新或重置系统，那么另一个用户的任何正在进行的工作也会被重置。
- en: At this point, we should have a solid understanding of what IaC is and how we
    can leverage it to effectively manage penetration testing lab environments. In
    the next section, we’ll have our first look at one of the most popular IaC tools
    used by professionals globally.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们应该已经对IaC的概念和如何利用它有效管理渗透测试实验室环境有了充分的理解。在下一部分中，我们将首次介绍全球专业人士广泛使用的最流行的IaC工具之一。
- en: Setting up Terraform in AWS CloudShell
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS CloudShell中设置Terraform
- en: In this chapter, we will focus on using **Terraform** to provision and manage
    our cloud infrastructure. Terraform is an open source IaC tool created by **HashiCorp**.
    It’s one of the most powerful and most used IaC tools at the moment. It enables
    users to define and provision infrastructure resources using a high-level configuration
    language. By utilizing a simple, declarative, and intuitive syntax, this IaC tool
    simplifies the process of creating, updating, and versioning infrastructure, which
    provides a powerful way to automate infrastructure management.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍如何使用**Terraform**来配置和管理我们的云基础设施。Terraform 是一个由**HashiCorp**创建的开源基础设施即代码（IaC）工具。目前，它是最强大且最常用的
    IaC 工具之一。它使用户能够使用高级配置语言来定义和配置基础设施资源。通过采用简单、声明性和直观的语法，这个 IaC 工具简化了创建、更新和版本控制基础设施的过程，为自动化基础设施管理提供了强大的方法。
- en: 'Here’s an example of how Terraform code looks:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Terraform 代码的一个示例：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are simply defining a firewall rule (in GCP) that will allow us to
    initiate SSH connections (via port **22**) from our local machine to resources
    in the specified **Virtual Private Cloud** (**VPC**) network.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是定义了一个防火墙规则（在 GCP 中），它将允许我们从本地机器通过端口**22**发起 SSH 连接到指定的**虚拟私有云**（**VPC**）网络中的资源。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not worry if the sample Terraform code doesn’t make complete sense at the
    moment! In succeeding chapters of the book, we will dive deeper into how Terraform
    is used to manage penetration testing lab environment resources on cloud platforms
    such as AWS, Azure, and GCP. We will explore the concepts, syntax, and practical
    examples specific to these cloud providers, which will help us gain a clearer
    understanding of Terraform’s usage in real-world scenarios.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目前示例中的 Terraform 代码看起来不完全理解，也不用担心！在本书的后续章节中，我们将深入探讨如何使用 Terraform 管理云平台（如
    AWS、Azure 和 GCP）上的渗透测试实验室环境资源。我们将探讨这些云提供商的概念、语法和实际示例，帮助我们更清楚地理解 Terraform 在实际场景中的应用。
- en: As we can see in the sample code provided, the Terraform code used to build
    the vulnerable cloud infrastructure is **declarative** and self-documenting. Instead
    of focusing on *how* these infrastructure resources are prepared, we simply just
    need to specify the desired state, and Terraform takes care of the details to
    convert the current state into the desired state. Other tools utilize the **imperative**
    approach in automation, where engineers define the commands in order to reach
    the desired state. The advantage of the imperative approach in automation is the
    ability to have fine-grained control over the sequence of commands and actions
    taken to reach the desired state. This can be useful in complex scenarios that
    require specific scripting or procedural logic. This is in contrast with the **declarative**
    approach, where we just need to specify how the desired state of the infrastructure
    should look. We will primarily use the declarative approach in this book whenever
    we can. If you are just starting out with IaC and automation concepts, starting
    with the declarative approach in Terraform can provide a more intuitive and straightforward
    way to understand and manage infrastructure resources. That said, the declarative
    approach offers a clear and concise representation of the desired state, making
    it easier to learn and work with.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在提供的示例代码中看到的，构建易受攻击云基础设施的 Terraform 代码是**声明式**的，并且具有自文档化功能。我们无需关注这些基础设施资源是如何准备的，而只需要指定期望的状态，Terraform
    会处理细节，将当前状态转换为期望状态。其他工具则采用**命令式**方法进行自动化，工程师需要定义一系列命令来达到期望状态。命令式方法的优势在于可以精细控制命令和操作执行的顺序，以达到期望状态。这在需要特定脚本或程序逻辑的复杂场景中非常有用。这与**声明式**方法形成对比，声明式方法只需指定基础设施的期望状态是什么样的。我们将在本书中尽可能使用声明式方法。如果你刚刚开始接触基础设施即代码（IaC）和自动化的概念，使用
    Terraform 中的声明式方法可以提供一种更直观、更简洁的方式来理解和管理基础设施资源。也就是说，声明式方法提供了一个清晰简明的期望状态表示，使学习和使用变得更加容易。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that it is possible to use the imperative approach with Terraform using
    **CDK for Terraform** (**CDKTF**). For more information about CDKTF, feel free
    to check out the following link: [https://developer.hashicorp.com/terraform/cdktf](https://developer.hashicorp.com/terraform/cdktf).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用**CDK for Terraform**（**CDKTF**）时，可以采用命令式方法来使用 Terraform。有关 CDKTF 的更多信息，请随时访问以下链接：[https://developer.hashicorp.com/terraform/cdktf](https://developer.hashicorp.com/terraform/cdktf)。
- en: Of course, before we can use Terraform, we have to make sure that it is properly
    installed and set up in our environment! There are different ways to install Terraform.
    One way would be to use **tfenv** (**Terraform version manager**) to help us easily
    work with and manage different Terraform versions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在使用Terraform之前，我们必须确保它已经在我们的环境中正确安装和配置！有多种方式可以安装Terraform，其中一种方式是使用**tfenv**（**Terraform版本管理器**）来帮助我们轻松管理和使用不同版本的Terraform。
- en: 'In the next set of steps, we will set up and install Terraform in our AWS CloudShell
    environment using the Terraform version manager:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用Terraform版本管理器在AWS CloudShell环境中设置和安装Terraform：
- en: Open a new browser tab and then navigate to the AWS console. Type **shell**
    in the search bar and then select **CloudShell** from the list of results. Alternatively,
    you may simply locate and click the **CloudShell** button located in the upper-left
    corner of the AWS Management Console (near the region selection drop-down menu).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器标签页，然后导航到AWS控制台。在搜索框中输入**shell**，然后从搜索结果中选择**CloudShell**。或者，你也可以直接在AWS管理控制台的左上角找到并点击**CloudShell**按钮（靠近区域选择下拉菜单）。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Wait for around a minute or two for the AWS CloudShell environment to be ready.
    Given that the CloudShell environment offers a maximum of 1 GB disk space (per
    AWS region), it becomes necessary to monitor disk usage regularly using commands
    such as **df -h** (disk free) and **du -sh** (disk usage). These commands provide
    insights into the amount of disk space utilized and help determine whether we
    are approaching the 1 GB limit. By actively monitoring disk space, we can avoid
    potential storage constraints within the CloudShell environment. For more information,
    feel free to check out the following link: [https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html](https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 等待约一到两分钟，直到AWS CloudShell环境准备就绪。考虑到CloudShell环境每个AWS区域提供最大1 GB的磁盘空间，因此有必要定期使用**df
    -h**（磁盘可用空间）和**du -sh**（磁盘使用量）等命令监控磁盘使用情况。这些命令可以提供磁盘空间使用的详细信息，帮助我们判断是否接近1 GB的限制。通过积极监控磁盘空间，我们可以避免CloudShell环境中出现存储限制。欲了解更多信息，请访问以下链接：[https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html](https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html)。
- en: 'In the AWS CloudShell terminal (after the **$** sign), run the following **git
    clone** command to clone the **tfutils/tfenv** repository to our CloudShell environment:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS CloudShell终端（在**$**符号后）运行以下**git clone**命令，将**tfutils/tfenv**仓库克隆到我们的CloudShell环境中：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a **bin** directory (inside the user home directory) using the **mkdir**
    command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**mkdir**命令创建一个**bin**目录（位于用户主目录下）：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the **ls** command to list the files stored inside **~/.tfenv/bin/**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**ls**命令列出存储在**~/.tfenv/bin/**中的文件：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should yield a list of results similar to the following:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下的结果列表：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let’s use the **ln -s** command to create a soft symbolic link for the
    executable files stored inside **~/.tfenv/bin/**:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用**ln -s**命令为存储在**~/.tfenv/bin/**中的可执行文件创建一个软符号链接：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What are soft symbolic links?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是软符号链接？
- en: '**Soft symbolic links**, also known as **symlinks**, are special files in a
    filesystem that serve as pointers to other files or directories. They reference
    the target by its path and essentially create a shortcut to the target file or
    directory.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**软符号链接**，也称为**symlinks**，是文件系统中的特殊文件，充当指向其他文件或目录的指针。它们通过路径引用目标，实际上创建了一个指向目标文件或目录的快捷方式。'
- en: 'Use the **readlink** command to verify whether the previous command worked
    as expected:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**readlink**命令验证之前的命令是否按预期工作：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should yield the following output:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we used the **readlink** command to obtain the full paths of files in
    the **~/bin** directory by resolving the symbolic links and providing the absolute
    paths of each file.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用**readlink**命令通过解析符号链接并提供每个文件的绝对路径，获取**~/bin**目录中文件的完整路径。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since **~/bin** has already been added to **$PATH**, we should be able to use
    **terraform** and **tfenv** after running the **ln -s** command in the previous
    step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**~/bin**已经添加到**$PATH**中，因此在执行前一步中的**ln -s**命令后，我们应该能够使用**terraform**和**tfenv**。
- en: 'Let’s use the **tfenv install** command to install a specific version (**1.3.9**)
    of Terraform:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用**tfenv install**命令安装特定版本（**1.3.9**）的Terraform：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By running **tfenv install 1.3.9**, we instruct **tfenv** to download and set
    up Terraform version **1.3.9** on our system. This specific version will be installed
    in a separate directory, keeping it isolated from other installed versions of
    Terraform.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过运行 **tfenv install 1.3.9**，我们指示 **tfenv** 在我们的系统上下载并安装 Terraform 版本 **1.3.9**。这个特定版本将会安装在一个单独的目录中，确保它与其他已安装的
    Terraform 版本隔离开来。
- en: 'Next, let’s use the **tfenv use** command to switch to and use version **1.3.9**
    of Terraform:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 **tfenv use** 命令切换并使用 Terraform 版本 **1.3.9**：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we run this command, **tfenv** will configure our system to use Terraform
    version **1.3.9** for any subsequent Terraform commands executed in the current
    shell session or directory. This allows us to work with the features and functionality
    specific to this version.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，**tfenv** 将会配置我们的系统，在当前 shell 会话或目录中使用 Terraform 版本 **1.3.9** 来执行随后的任何
    Terraform 命令。这使我们能够使用特定版本的功能和特性。
- en: 'Finally, let’s check whether Terraform has been successfully installed using
    the following command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令检查 Terraform 是否已成功安装：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should yield the following output:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成以下输出：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This confirms that Terraform version **1.3.9** has been installed and is ready
    for use!
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确认了已经安装了 Terraform 版本 **1.3.9**，并且可以开始使用！
- en: Important note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By the time you read the book, a newer version of Terraform might already be
    available. However, it’s still recommended to use the version used in this chapter
    to avoid any issues with running the hands-on solutions and examples. Simply use
    the **tfenv** command to “time-travel” and use an older version of Terraform if
    needed. This will help make sure that all examples in this chapter will continue
    to work without issues. If a newer version of Terraform is available, you can
    always use the **tfenv** command to install and switch to that version if desired.
    This flexibility allows you to stay up to date with the latest features and improvements.
    However, it’s important to note that using the version specified in the book ensures
    consistency and avoids any potential compatibility issues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到你阅读这本书时，可能会有更新版本的 Terraform 可用。然而，仍然建议使用本章中使用的版本，以避免在运行实际操作的解决方案和示例时遇到问题。如果需要，你可以使用
    **tfenv** 命令进行“时间旅行”，切换到旧版本的 Terraform。这将确保本章中的所有示例继续正常工作。如果有更新版本的 Terraform 可用，你也可以使用
    **tfenv** 命令安装并切换到该版本。这种灵活性使你能够跟上最新的功能和改进。然而，值得注意的是，使用书中指定的版本可以确保一致性，避免潜在的兼容性问题。
- en: With Terraform set up in our AWS CloudShell environment, let’s proceed to the
    next section!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 AWS CloudShell 环境中设置好 Terraform 后，让我们继续进入下一节！
- en: Getting our feet wet with Terraform
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初探 Terraform
- en: In this section, we will provide a brief overview of the essential Terraform
    workflow and then move on to a “*Hello World*” example to test our setup.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将简要概述基本的 Terraform 工作流，然后进行一个 “*Hello World*” 示例，来测试我们的设置。
- en: Understanding the core Terraform workflow
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解核心的 Terraform 工作流
- en: 'It may take most of us around 2-4 weeks to learn a new tool, platform, or framework.
    However, it would probably take us just a few hours (to, at most, a few days)
    to learn Terraform since using it is straightforward and easy. When using Terraform,
    engineers generally follow a process similar to what we have in *Figure 3**.3*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数人来说，学习一个新工具、平台或框架可能需要大约 2 到 4 周的时间。然而，学习 Terraform 可能只需要几个小时（最多几天），因为它的使用非常直接且简单。在使用
    Terraform 时，工程师通常遵循一个类似于我们在 *图 3.3* 中看到的流程：
- en: '![](image/B19755_03_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_03_03.jpg)'
- en: Figure 3.3 – A common workflow when using Terraform to create and update resources
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 使用 Terraform 创建和更新资源时的常见工作流
- en: Once we have the configuration file (or files) ready, we simply run **terraform
    init** to initialize the Terraform environment. The **terraform init** command
    is usually executed when our environment has not been initialized yet or when
    additional files or plugins need to be downloaded. The next step involves using
    **terraform plan** to process the configuration code and generate an execution
    plan for us to review. Note that running the **terraform plan** command is not
    required but *recommended*. Finally, we can use **terraform apply** to implement
    the changes described in the execution plan.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了配置文件（或多个文件），我们只需运行 **terraform init** 来初始化 Terraform 环境。**terraform
    init** 命令通常在我们的环境尚未初始化时，或者需要下载额外的文件或插件时执行。接下来的步骤是使用 **terraform plan** 来处理配置代码并生成执行计划供我们审核。请注意，运行
    **terraform plan** 命令不是必需的，但 *推荐* 执行。最后，我们可以使用 **terraform apply** 来实施执行计划中描述的更改。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Running **terraform init** and **terraform plan** are generally *safe* commands
    to run since (1) these involve **idempotent** operations and (2) they won’t create/modify
    any infrastructure resources yet. In this context, idempotent means that executing
    these commands multiple times will have the *same* outcome without causing unintended
    side effects. This makes them suitable for safely initializing and planning infrastructure
    configurations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 **terraform init** 和 **terraform plan** 通常是 *安全* 的命令，因为（1）它们涉及 **幂等** 操作，（2）它们不会创建或修改任何基础设施资源。在这种情况下，幂等意味着多次执行这些命令将会有
    *相同* 的结果，而不会产生意外的副作用。这使得它们非常适合用于安全地初始化和规划基础设施配置。
- en: There are other commands we can use to help us perform specific tasks (for example,
    **terraform show**), but other than these three primary commands, one other command
    we need to know would be the **terraform destroy** command. Running this command
    would delete the resources created and managed using Terraform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他命令来帮助我们执行特定任务（例如，**terraform show**），但除了这三个主要命令外，另一个我们需要了解的命令是 **terraform
    destroy**。运行此命令将删除通过 Terraform 创建和管理的资源。
- en: Testing our Terraform setup with a Hello World example
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hello World 示例测试我们的 Terraform 设置
- en: 'Now that we have a good idea of how to use Terraform, let’s work on a very
    simple Terraform example, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何使用 Terraform 有了基本了解，接下来我们来做一个非常简单的 Terraform 示例，如下所示：
- en: 'Create a **hello_terraform** directory using the **mkdir** command. Navigate
    to the directory created using the **cd** command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **mkdir** 命令创建一个 **hello_terraform** 目录。然后使用 **cd** 命令进入创建的目录：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the **touch** command to create an empty **main.tf** file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **touch** 命令创建一个空的 **main.tf** 文件：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用 Vim 打开空的 **main.tf** 文件：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Learning how to use a command-line text editor such as Vim may be a bit daunting
    at first. However, you’ll see that Vim is relatively easy and fun to use once
    you get a hang of it!
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学习如何使用命令行文本编辑器，如 Vim，起初可能会有些令人畏惧。然而，一旦你熟悉了它，你会发现 Vim 相对容易使用且富有乐趣！
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入 **:set nu** 然后按下 *Enter* 键来显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按 *i* 切换到 **插入模式**，这样我们就可以编辑文件了。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **insert mode** in Vim allows us to type and make changes as we would in
    a regular text editor. In this mode, we can freely add, delete, or modify characters
    without affecting the surrounding text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 中的 **插入模式** 允许我们像在常规文本编辑器中一样输入和修改文本。在这个模式下，我们可以自由地添加、删除或修改字符，而不会影响周围的文本。
- en: 'Type or paste the following block of code into our **main.tf** file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码块输入或粘贴到我们的 **main.tf** 文件中：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we declare a **null_resource** resource, which is useful for actions and
    operations that do not involve the creation of resources. In this case, we’re
    using it to run a script or a command.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个 **null_resource** 资源，它对于不涉及资源创建的操作和任务非常有用。在这个案例中，我们用它来运行一个脚本或命令。
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes made to **main.tf** and then exit Vim as
    well.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Esc* 键切换到 **正常模式**。输入 **:wq!**，然后按 *Enter*。这将保存对 **main.tf** 所做的更改，并退出 Vim。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier, we described how the insert mode works in Vim. Now, let’s quickly talk
    about the normal mode. The **normal mode** allows us to navigate through text,
    execute commands, and perform various operations on the file. In this mode, specific
    keystrokes (such as **:wq!**) can be used to move the cursor, search for text,
    copy and paste, and perform editing actions such as deleting, replacing, and undoing
    changes. For instance, “**w**” represents the *write* command (which saves changes
    to the file), and “**q**” represents the *quit* command (which exits the editor).
    What’s the exclamation point (**!**) for? “**!**” is simply an optional modifier
    that forces the command to execute, even if there are unsaved changes along with
    other warnings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们描述了 Vim 中插入模式的工作原理。现在，让我们简要谈谈普通模式。**普通模式**允许我们在文本中导航、执行命令并对文件执行各种操作。在此模式下，可以使用特定的按键组合（如**:wq!**）来移动光标、搜索文本、复制和粘贴，并执行编辑操作，如删除、替换和撤销更改。例如，“**w**”表示*写入*命令（用于保存文件的更改），而“**q**”表示*退出*命令（用于退出编辑器）。感叹号（**!**）有什么用？“**!**”仅仅是一个可选修饰符，它强制命令执行，即使存在未保存的更改或其他警告。
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的**main.tf**文件已经准备好，让我们使用**terraform init**命令来初始化 Terraform 工作目录：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To help us have a better idea of what **terraform init** initialized and set
    up for us, let’s install the **tree** utility using the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地了解**terraform init**为我们初始化并设置了什么，让我们使用以下命令安装**tree**工具：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the **tree** utility installed, let’s use the **tree** command to help
    us check and visualize the directories and files in our current directory:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装了**tree**工具后，让我们使用**tree**命令帮助我们检查并可视化当前目录中的目录和文件：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should yield a tree similar to what we have in *Figure 3**.4*:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该生成一棵树，类似于我们在*图 3.4*中看到的内容：
- en: '![](image/B19755_03_04.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_04.jpg)'
- en: Figure 3.4 – Results after running the tree command
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.4 – 运行 tree 命令后的结果
- en: Here, we can see that after running **terraform init**, we suddenly have a **.terraform**
    directory with a tree structure of directories and file(s).
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在运行**terraform init**后，突然出现了一个**.terraform**目录，并且包含一个目录和文件的树状结构。
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行**terraform plan**，以预览 Terraform 将执行的更改：
- en: '[PRE19]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should yield a set of logs similar to what we have in the following block
    of log messages:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该生成一组日志，类似于我们在下面的日志信息块中看到的内容：
- en: '[PRE20]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have an **execution plan** that indicates which resources will be created
    (**1**), modified (**0**), or destroyed (**0**) once we run the **terraform apply**
    command in a later step.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个**执行计划**，它指示了在稍后的步骤中运行**terraform apply**命令后，将创建（**1**）、修改（**0**）或销毁（**0**）哪些资源。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Terraform’s execution plan is like a blueprint that outlines the steps and actions
    it will execute to achieve the desired infrastructure state (as defined in the
    Terraform configuration code). It is similar to how the SQL **EXPLAIN** command
    provides a detailed breakdown of how a database management system will execute
    a specific query. That said, given that Terraform abstracts what’s happening behind
    the scenes with its declarative syntax, the execution plan serves as a valuable
    mechanism for previewing changes that will be made to the infrastructure.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的执行计划就像是一个蓝图，概述了它将执行的步骤和操作，以实现所需的基础设施状态（如 Terraform 配置代码中所定义的）。它类似于
    SQL **EXPLAIN** 命令提供的详细分解，说明数据库管理系统如何执行特定查询。也就是说，考虑到 Terraform 通过其声明式语法抽象了幕后发生的事情，执行计划作为预览即将对基础设施进行的更改的有价值机制。
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，让我们使用**terraform apply**命令来实现通过运行**terraform plan**返回的执行计划中指定的更改：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should yield a set of logs similar to what we have in *Figure 3**.5*:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该生成一组日志，类似于我们在*图 3.5*中看到的内容：
- en: '![](image/B19755_03_05.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_05.jpg)'
- en: Figure 3.5 – Verification step after running the terraform apply command
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.5 – 运行 terraform apply 命令后的验证步骤
- en: 'During the verification step (that is, when you see an **Enter a value:** message),
    type in **yes** to proceed with the creation of a **hello.txt** file. After pressing
    the *Enter* key, we should get the following set of logs:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在验证步骤中（即，当您看到**Enter a value:**提示时），输入**yes**以继续创建**hello.txt**文件。按下*Enter*键后，我们应该看到以下一组日志：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we can see that our **terraform apply** command succeeded!
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的 **terraform apply** 命令已成功执行！
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Running the **terraform apply** command should execute **touch hello.txt** and
    create an empty **hello.txt** file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 **terraform apply** 命令应执行 **touch hello.txt** 并创建一个空的 **hello.txt** 文件。
- en: 'Before celebrating, let’s use the **ls** command to check whether our **hello.txt**
    file got created:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在庆祝之前，让我们使用 **ls** 命令检查我们的 **hello.txt** 文件是否已经创建：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should yield the following output:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该产生以下输出：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s inspect the **terraform.tfstate** file using the **cat** command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 **cat** 命令检查 **terraform.tfstate** 文件：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should give us a nested JSON structure similar to what we have in the
    following block:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该给我们一个类似于下面代码块的嵌套 JSON 结构：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have confirmed that Terraform has stored the information that represents
    the current set of infrastructure resources (managed by Terraform) inside the
    **terraform.tfstate** file.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经确认 Terraform 将表示当前基础设施资源集（由 Terraform 管理）的信息存储在 **terraform.tfstate**
    文件中。
- en: Important note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Terraform utilizes the **terraform.tfstate** file to keep track of the current
    state of the infrastructure. This file stores critical information such as resource
    IDs, dependencies, and metadata. Terraform makes use of this file when performing
    diff checks before infrastructure resources are created or modified. Make sure
    *not* to edit or delete the **terraform.tfstate** file in your working directory
    as this can lead to inconsistencies and potential errors in your Terraform workflow.
    In case you’ve accidentally deleted the **terraform.tfstate** file, do not panic
    as there are various ways to recover from this scenario! In addition to this,
    we can utilize **remote state backends** to store our state file securely and
    enable easier collaboration and disaster recovery as well. We will discuss this
    in more detail in the *Configuring a Terraform backend with state locking* section
    of this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 使用 **terraform.tfstate** 文件来跟踪基础设施的当前状态。该文件存储关键信息，例如资源 ID、依赖关系和元数据。在创建或修改基础设施资源之前，Terraform
    会使用此文件进行差异检查。确保*不要*编辑或删除工作目录中的 **terraform.tfstate** 文件，因为这可能导致不一致和潜在的错误。万一你不小心删除了
    **terraform.tfstate** 文件，不必惊慌，因为有多种方法可以从这种情况中恢复！此外，我们还可以使用 **远程状态后端** 来安全地存储状态文件，并使协作和灾难恢复更容易。我们将在本章的
    *配置具有状态锁定的 Terraform 后端* 部分详细讨论这个内容。
- en: 'Navigate to the user home directory using the **cd** command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **cd** 命令导航到用户的主目录：
- en: '[PRE27]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, let’s delete the **hello_terraform** directory (and everything inside
    it) using the **rm -****rf** command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用 **rm -rf** 命令删除 **hello_terraform** 目录（及其内部的所有内容）：
- en: '[PRE28]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will help free up some space since we only have a total of 1 GB of storage
    available in our CloudShell environment (for each AWS region). Note that it’s
    recommended to run **terraform destroy** first inside the **hello_terraform**
    directory before performing these types of deletion or cleanup steps (as we might
    accidentally delete the state file). Given that the only “infrastructure resource”
    we created is a **.txt** file, there’s no need to run **terraform destroy**.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将帮助释放一些空间，因为我们在 CloudShell 环境中总共有 1 GB 的存储空间（每个 AWS 区域）。请注意，建议在执行这些删除或清理步骤之前，先在
    **hello_terraform** 目录中运行 **terraform destroy**（因为我们可能会不小心删除状态文件）。鉴于我们创建的唯一“基础设施资源”是一个
    **.txt** 文件，因此不需要运行 **terraform destroy**。
- en: Important note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you require a dedicated environment specifically for utilizing Terraform
    in creating and managing infrastructure resources, you can explore **AWS Cloud9**
    and set up a development environment. This environment offers more disk space
    compared to CloudShell (currently at 1 GB only for each AWS region). Additionally,
    Cloud9 enables you to utilize a code editor for writing and modifying code, offering
    enhanced flexibility and convenience. It’s important to note that while AWS CloudShell
    is a free service provided by AWS, AWS Cloud9 may incur additional costs depending
    on your usage. While CloudShell offers a limited disk space of 1 GB, it is available
    at no extra charge. On the other hand, AWS Cloud9 may have associated costs based
    on usage and the instance type selected for the environment. Before opting for
    AWS Cloud9, it is advisable to review the pricing details and ensure that it aligns
    with your requirements and budget.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个专门的环境来创建和管理基础设施资源中使用 Terraform，您可以探索**AWS Cloud9**并设置开发环境。与 CloudShell（目前每个
    AWS 地区仅为 1 GB）相比，这种环境提供更多的磁盘空间。此外，Cloud9 允许您使用代码编辑器编写和修改代码，提供了增强的灵活性和便利性。需要注意的是，虽然
    AWS CloudShell 是 AWS 提供的免费服务，但 AWS Cloud9 可能会根据您的使用情况产生额外费用。虽然 CloudShell 提供了仅限于
    1 GB 的有限磁盘空间，并且不收取额外费用。另一方面，AWS Cloud9 可能根据环境选择的使用情况和实例类型而产生相关费用。在选择 AWS Cloud9
    之前，建议查看定价详细信息，并确保其符合您的要求和预算。
- en: '*Wasn’t that easy?* When learning Terraform (or any other new tool), it’s a
    good idea to start with simple and small examples similar to what we worked on
    in this section. In the next section, we’ll build on top of this simple example
    and work on a relatively longer Terraform configuration file.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*这不是很简单吗？* 当学习 Terraform（或任何其他新工具）时，建议从类似于本节中我们所使用的简单和小型示例开始。在下一节中，我们将在这个简单示例的基础上继续工作，并处理一个相对较长的
    Terraform 配置文件。'
- en: Understanding the Terraform configuration language
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 配置语言
- en: In this section, we will dive into the core aspects of Terraform’s configuration
    language and then proceed with working with relatively simple configuration code
    to equip us with the foundational knowledge needed to manage IaC with Terraform.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨 Terraform 配置语言的核心方面，然后继续使用相对简单的配置代码，为我们提供管理 Terraform 的 IaC 所需的基础知识。
- en: Demystifying commonly used Terraform configuration blocks
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭秘常用的 Terraform 配置块
- en: Understanding how to write and interpret Terraform configuration code is essential
    for effective infrastructure management. This knowledge allows us to customize
    and modify existing infrastructure resources created and managed using Terraform.
    It also enables us to troubleshoot issues more effectively and save time when
    resolving errors and blockers while using the IaC tool.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何编写和解释 Terraform 配置代码对于有效的基础设施管理至关重要。这些知识使我们能够自定义和修改使用 Terraform 创建和管理的现有基础设施资源。它还使我们能够在使用
    IaC 工具时更有效地解决问题和节省时间。
- en: '*So, where do we start?* For one thing, simple and complex Terraform configuration
    code generally makes use of the same set of elements and building blocks. This
    common foundation allows us to gradually build our understanding by starting with
    simple configurations and gradually progressing toward more complex scenarios.
    By mastering the fundamental elements, we can confidently navigate and interpret
    both simple and complex Terraform configuration code, enabling us to tackle a
    wide range of infrastructure management challenges effectively.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，我们从哪里开始呢？* 首先，简单和复杂的 Terraform 配置代码通常使用相同的元素和构建模块。这个共同的基础使我们能够通过从简单配置开始逐步向更复杂的场景发展来逐步建立我们的理解。通过掌握基本元素，我们可以自信地导航和解释简单和复杂的
    Terraform 配置代码，从而有效地解决各种基础设施管理挑战。'
- en: 'Before we work on the next hands-on example, let’s have a quick look at some
    of the elements we would generally see in a Terraform configuration file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行下一个实际操作示例之前，让我们快速查看一下在 Terraform 配置文件中通常会看到的一些元素：
- en: '**Resources**—These are code blocks used to define how infrastructure resources
    would be provisioned and configured. These blocks have the following structure:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源** — 这些是用来定义如何配置和配置基础设施资源的代码块。这些块具有以下结构：'
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A resource is configured using one or more arguments, where each argument is
    represented by a key-value pair. Depending on the specific resource being created,
    the arguments could include things such as region, instance type, subnet ID, and
    security groups, among others.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 资源是通过一个或多个参数进行配置的，每个参数由一个键值对表示。根据正在创建的具体资源，参数可能包括区域、实例类型、子网 ID、安全组等内容。
- en: 'Let’s look at a quick example of how to define a resource block for an Azure
    public IP address using Terraform:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们快速看一个如何使用 Terraform 定义 Azure 公共 IP 地址资源块的例子：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we specify various attributes, such as the resource group name obtained
    from a local variable, along with the allocation method set to **"Dynamic"**.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们指定了各种属性，如从本地变量获取的资源组名称，以及分配方法设置为 **"动态"**。
- en: '**Providers**—These are plugins that enable cloud platform and SaaS API interactions.
    These blocks have the following structure:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供程序**—这些是插件，使得云平台和 SaaS API 交互成为可能。它们的结构如下：'
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Providers can include **cloud service providers** (**CSPs**) such as AWS, Azure,
    and GCP, as well as other third-party providers. Depending on the specific provider
    being used, the arguments could include things such as access keys, region, and
    endpoints, among others.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供程序可以包括 **云服务提供商**（**CSPs**），如 AWS、Azure 和 GCP，以及其他第三方提供商。根据使用的具体提供程序，参数可能包括访问密钥、区域和端点等内容。
- en: 'Let’s look at a quick example of how to define a provider:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们快速看一个如何定义提供程序的例子：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By configuring this provider with the appropriate region, Terraform will be
    able to interact with AWS services within the specified region for resource provisioning
    and management.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用适当区域配置此提供程序，Terraform 将能够在指定区域内与 AWS 服务进行交互，用于资源的配置和管理。
- en: '**Data sources**—These are elements that allow us to query data at runtime.
    These blocks have the following structure:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据源**—这些是允许我们在运行时查询数据的元素。它们的结构如下：'
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The configuration for the data source depends on the specific data source being
    used and can include things such as queries, filters, and authentication information.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据源的配置取决于使用的具体数据源，可以包括查询、筛选条件和身份验证信息等内容。
- en: 'Let’s look at a quick example of how to define a data source:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们快速看一个如何定义数据源的例子：
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this data block, we can retrieve information about the IP ranges used by
    the AWS EC2 Instance Connect service in the specified region.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个数据块，我们可以获取指定区域内 AWS EC2 实例连接服务使用的 IP 范围的信息。
- en: '**Local values**—These are code blocks that allow us to assign and store static
    values for later use. These blocks have the following structure:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地值**—这些是代码块，允许我们分配和存储静态值以备后用。它们的结构如下：'
- en: '[PRE35]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expressions can be any valid Terraform expression, including other variables
    or functions. Using this code block, we can easily define local variables in our
    Terraform configuration to make our code more readable, maintainable, and reusable.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式可以是任何有效的 Terraform 表达式，包括其他变量或函数。通过这个代码块，我们可以轻松地在 Terraform 配置中定义本地变量，使我们的代码更加可读、易于维护和可重用。
- en: 'Let’s look at an example of how to define a few local variables:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看一个如何定义一些本地变量的例子：
- en: '[PRE36]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we simply define two local variables (**net_01** and **net_02**) with
    values equal to the **self_link** attribute values of the corresponding **google_compute_network**
    resources.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们简单地定义了两个本地变量（**net_01** 和 **net_02**），它们的值等于相应 **google_compute_network**
    资源的 **self_link** 属性值。
- en: '**Input variables**—These are code blocks that allow users to specify dynamic
    values. These blocks have the following structure:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入变量**—这些是代码块，允许用户指定动态值。它们的结构如下：'
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Variables in Terraform are used to parameterize the configuration, allowing
    code to be reused in different scenarios or environments.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Terraform 中的变量用于参数化配置，使得代码可以在不同的场景或环境中重用。
- en: 'Let’s look at a quick example of how to define a variable:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们快速看一个如何定义变量的例子：
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This variable can be utilized within the Terraform configuration to dynamically
    customize the instance name based on specific requirements.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个变量可以在 Terraform 配置中使用，根据特定需求动态定制实例名称。
- en: '**Output values**—These help return and print values as well as share values
    across modules. These blocks have the following structure:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出值**—这些帮助返回和打印值，并在模块之间共享值。它们的结构如下：'
- en: '[PRE39]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Outputs in Terraform are used to define values that are exposed to the user
    after the **terraform apply** operation is complete. The output can then be referenced
    in other parts of the configuration or in other configurations that use the current
    module as a dependency.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Terraform 中的输出用于定义在**terraform apply**操作完成后暴露给用户的值。该输出可以在配置的其他部分或使用当前模块作为依赖项的其他配置中引用。
- en: 'Let’s look at a quick example of this in action:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们快速看一个实际示例：
- en: '[PRE40]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we simply define an output block to retrieve the public IP address of
    a virtual machine (in Azure).
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们简单地定义一个输出块，以检索虚拟机（在 Azure 中）的公共 IP 地址。
- en: While there are certainly more Terraform elements to consider, the ones we’ve
    discussed should be enough for the time being. As you continue your Terraform
    journey, you can explore additional elements to expand your repertoire for managing
    infrastructure. Building upon the foundation we have established already, these
    elements will further enhance our ability to create various penetration testing
    labs in the cloud using Terraform.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Terraform 中确实有更多要考虑的元素，但我们讨论的这些元素应该足够了。随着你继续深入 Terraform，你可以探索更多的元素，扩展管理基础设施的能力。在我们已经建立的基础上，这些元素将进一步增强我们使用
    Terraform 在云中创建各种渗透测试实验室的能力。
- en: Working with simple Terraform configurations
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单的 Terraform 配置
- en: 'Now that we have a good idea of which blocks of code to expect in a Terraform
    configuration file, let’s proceed with the next example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了在 Terraform 配置文件中会遇到哪些代码块，让我们继续看下一个示例：
- en: 'Create a **basics** directory using the **mkdir** command. Navigate to the
    directory created using the **cd** command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**mkdir**命令创建一个**basics**目录。然后使用**cd**命令进入创建的目录：
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the **touch** command to create an empty **main.tf** file inside the **basics**
    directory:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**touch**命令在**basics**目录中创建一个空的**main.tf**文件：
- en: '[PRE42]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以使用 Vim 打开空的**main.tf**文件：
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**:set nu**，然后按*Enter*键显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按* i *键切换到**插入模式**，以便我们编辑文件。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you should have a better idea of how to use Vim. To switch to
    insert mode (assuming we’re currently in normal mode), simply press the *i* key.
    Then, to switch to normal mode, press the *Esc* key.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该对如何使用 Vim 有了更好的了解。要切换到插入模式（假设我们当前处于普通模式），只需按* i *键。然后，要切换回普通模式，按*Esc*键。
- en: 'Let’s start by declaring and configuring the AWS provider by typing (or pasting)
    the following block of code into our **main.tf** file:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过输入（或粘贴）以下代码块到我们的**main.tf**文件中来声明和配置 AWS 提供程序：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With this code block, Terraform is able to locate and use the required AWS provider
    for the specified version and source to provision and manage AWS resources in
    the specified region (**us-east-1**).
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这段代码，Terraform 能够定位并使用指定版本和来源的 AWS 提供程序，以在指定区域（**us-east-1**）中配置和管理 AWS 资源。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Terraform would automatically use the credentials configured in the
    CloudShell environment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Terraform 会自动使用在 CloudShell 环境中配置的凭证。
- en: 'Next, add the following code as well:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，还需要添加以下代码：
- en: '[PRE45]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This would give us access to the AWS canonical user ID (which is an alphanumeric
    value used when granting access to S3 buckets and objects) of the account used
    to run Terraform.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使我们能够访问运行 Terraform 的账户的 AWS 标准用户 ID（这是一个字母数字值，用于授予对 S3 存储桶和对象的访问权限）。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **AWS canonical user ID** (that is, the “obfuscated form” of the AWS account
    ID) is primarily used for operations related to object-level access control in
    Amazon S3\. When granting access permissions to S3 objects or buckets, this ID
    is used to specify who has the necessary permissions. Note that the AWS canonical
    user ID is different from the AWS account ID, which is a 12-digit number associated
    with each AWS account. For more information, feel free to check the following
    link: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS 规范用户 ID**（即 AWS 账户 ID 的“混淆形式”）主要用于 Amazon S3 中与对象级访问控制相关的操作。当授予 S3 对象或存储桶的访问权限时，此
    ID 用于指定谁拥有必要的权限。请注意，AWS 规范用户 ID 与 AWS 账户 ID 不同，后者是与每个 AWS 账户相关联的 12 位数字。有关更多信息，请查看以下链接：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html)。'
- en: 'Let’s also declare a few local variables, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也声明几个本地变量，如下所示：
- en: '[PRE46]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, let’s add the following code, which prints the **display_name** value
    of the canonical user ID of the AWS account we are using:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加以下代码，它将打印出我们正在使用的 AWS 账户的规范用户 ID 的 **display_name** 值：
- en: '[PRE47]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Esc* 键切换回正常模式。输入 **:wq!** 然后按 *Enter*。这将保存对 **main.tf** 文件所做的更改，并退出 Vim。
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 **main.tf** 文件已经准备好，让我们使用 **terraform init** 命令来初始化 Terraform 工作目录：
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should yield a set of logs similar to what is shown in the following set
    of log messages:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生类似于以下日志消息的日志输出：
- en: '[PRE49]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we can see that the relevant files and binaries have been downloaded from
    the Terraform Registry.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到相关的文件和二进制文件已经从 Terraform Registry 下载。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 **terraform plan** 来预览 Terraform 将执行的更改：
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the **terraform apply** command to implement the changes specified in the
    execution plan returned after running **terraform plan**:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **terraform apply** 命令来实施在运行 **terraform plan** 后返回的执行计划中的更改：
- en: '[PRE51]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that this time, we use the **-auto-approve** flag to skip the verification
    step, similar to what we encountered in the last section. Running the command
    should yield the following output:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这次我们使用了 **-auto-approve** 标志来跳过验证步骤，类似于上一节中遇到的情况。运行该命令应产生以下输出：
- en: '[PRE52]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*What happened here?* The code simply executed a command that printed the value
    of the **name** local value (that is, the display name of the canonical user).'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*这里发生了什么？* 代码只是执行了一个命令，打印出 **name** 本地值（即规范用户的显示名称）的值。'
- en: Important note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: We can see that when using the **terraform apply -auto-approve** command, the
    **-auto-approve** flag allows for automatic approval and execution of planned
    changes without user confirmation. The **-auto-approve** flag is valuable in non-interactive
    or automated scenarios as it eliminates the need for manual intervention. However,
    it is important to exercise caution when utilizing the **-auto-approve** flag
    as it bypasses confirmation prompts, and changes are immediately applied. Thoroughly
    reviewing Terraform code and changes prior to running **terraform apply** with
    **-auto-approve** is crucial to prevent unintended modifications to infrastructure.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当使用 **terraform apply -auto-approve** 命令时，**-auto-approve** 标志允许在没有用户确认的情况下自动批准并执行计划的更改。**-auto-approve**
    标志在非交互或自动化场景中非常有用，因为它消除了手动干预的需要。然而，使用 **-auto-approve** 标志时必须谨慎，因为它跳过了确认提示，且更改会立即应用。因此，在使用
    **-auto-approve** 执行 **terraform apply** 之前，务必仔细审核 Terraform 代码和更改，以避免对基础设施进行不必要的修改。
- en: 'Now, let’s perform a minor modification to the **main.tf** file. Run the following
    command again to open the empty **main.tf** file using Vim:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们对 **main.tf** 文件进行小幅修改。再次运行以下命令，使用 Vim 打开空的 **main.tf** 文件：
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以输入 **:set nu** 然后按 *Enter* 键来显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按 *i* 切换到 **插入模式**，以便我们可以编辑文件。
- en: 'Locate the following line using the arrow keys:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键定位以下行：
- en: '[PRE54]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once you’ve located the line in the previous code block, replace it with this:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦找到前面的代码块中的这一行，替换为以下内容：
- en: '[PRE55]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are planning to log and print the ID (instead of the **display_name**
    value) once when we run the **terraform apply** command in a later step.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们计划在后续步骤中运行**terraform apply**命令时，打印并记录ID（而不是**display_name**值）。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Esc*键以切换回正常模式。输入**:wq!**然后按*Enter*键。这将保存对**main.tf**所做的更改，并退出Vim。
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行**terraform plan**命令之前，我们先运行**terraform fmt**来格式化我们的Terraform代码：
- en: '[PRE56]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we are using **terraform fmt** to ensure a consistent coding style across
    all Terraform configuration files. This command scans the Terraform configuration
    files, adjusting indentation, spacing, and line breaks to match the official Terraform
    style guide.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用**terraform fmt**来确保所有Terraform配置文件遵循一致的编码风格。此命令会扫描Terraform配置文件，调整缩进、间距和换行符，以符合官方的Terraform风格指南。
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **terraform fmt** command automatically adjusts the indentation of blocks,
    statements, and expressions to ensure consistent alignment. It typically uses
    two spaces for each level of indentation. In addition to this, the command adds
    or removes spaces to maintain consistent spacing around operators, colons, commas,
    and other elements. For example, it ensures spaces are present before and after
    equals signs in variable assignments. Similarly, it inserts or removes line breaks
    to improve readability by introducing line breaks between resource blocks or variable
    declarations to make the code more visually structured. There are a few more formatting
    tweaks that **terraform fmt** applies, but these should do the trick for now.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**terraform fmt**命令会自动调整代码块、语句和表达式的缩进，以确保对齐一致。它通常为每一级缩进使用两个空格。除此之外，命令还会添加或删除空格，以保持操作符、冒号、逗号及其他元素周围的间距一致。例如，它会确保在变量赋值的等号前后都有空格。类似地，它会插入或删除换行符，通过在资源块或变量声明之间插入换行符来提高可读性，使代码更加结构化。**terraform
    fmt** 还会进行一些其他格式调整，但这些调整应该足够了。'
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行**terraform plan**以预览Terraform将要执行的更改：
- en: '[PRE57]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This should yield the following output:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成以下输出：
- en: '[PRE58]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It seems that changes are not detected when provisioner commands have been altered!
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 似乎在更改提供程序命令时未能检测到变化！
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here, Terraform is supposed to detect changes when altering provisioner commands
    within a resource block. However, in certain cases, modifications to provisioner
    commands may not be recognized as modifications by the IaC tool. Consequently,
    Terraform may not execute the updated provisioner commands, potentially leading
    to inconsistencies in the deployed infrastructure. For more information about
    this topic, feel free to check out the following link: [https://github.com/hashicorp/terraform/issues/14405](https://github.com/hashicorp/terraform/issues/14405).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Terraform应该在修改资源块中的提供程序命令时检测到变化。然而，在某些情况下，修改提供程序命令可能不会被基础设施即代码（IaC）工具识别为修改。因此，Terraform可能不会执行更新后的提供程序命令，可能导致部署的基础设施出现不一致。有关此主题的更多信息，请随时查看以下链接：[https://github.com/hashicorp/terraform/issues/14405](https://github.com/hashicorp/terraform/issues/14405)。
- en: 'To force the replacement of the resource(s) created, let’s use the **-replace**
    flag while running the **terraform** **apply** command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要强制替换已创建的资源，我们可以在运行**terraform** **apply**命令时使用**-replace**标志：
- en: '[PRE59]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This should yield the following set of logs:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成以下日志：
- en: '[PRE60]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we can see that the ID value has been logged after running the **terraform**
    **apply** command.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到ID值在运行**terraform** **apply**命令后被记录了下来。
- en: Note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*What happened here?* Here, we instructed Terraform to automatically apply
    changes without user confirmation, while specifically replacing the **null_resource.debug**
    resource. The **-replace=null_resource.debug** argument specifically targets the
    **null_resource.debug** resource, indicating that it should be replaced during
    the **apply** operation.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里发生了什么？* 在这里，我们指示Terraform自动应用更改，而无需用户确认，特别是替换**null_resource.debug**资源。**-replace=null_resource.debug**参数专门定位**null_resource.debug**资源，表示它应在**apply**操作期间被替换。'
- en: 'Navigate to the user home directory using the **cd** command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**cd**命令导航到用户的主目录：
- en: '[PRE61]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, let’s delete the **basics** directory (and everything inside it) using
    the **rm -****rf** command:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 **rm -rf** 命令删除 **basics** 目录（以及其中的所有内容）：
- en: '[PRE62]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will help free up some space since we need to manage the space available
    in our CloudShell environment.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样可以腾出一些空间，因为我们需要管理 CloudShell 环境中的可用空间。
- en: Great work completing our second Terraform example! At this point, we should
    have the confidence needed to work on more complex Terraform code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜完成我们的第二个 Terraform 示例！此时，我们应该已经具备了处理更复杂 Terraform 代码所需的信心。
- en: Building our vulnerable lab environment with Terraform
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 构建我们的易受攻击实验室环境
- en: The previous sections of this chapter allowed us to have a better understanding
    of how Terraform works. We worked with relatively simple examples, and it’s about
    time we worked on a relatively more complete and realistic example! That said,
    we will now use Terraform to automatically create and configure the vulnerable
    lab environment we manually prepared in *[Chapter 2](B19755_02.xhtml)*, *Preparing
    Our First Vulnerable Cloud Lab Environment*. By utilizing Terraform, we should
    be able to streamline the process of setting up the vulnerable lab environment
    that we previously prepared manually.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前几节帮助我们更好地理解了 Terraform 的工作原理。我们通过了相对简单的示例，现在是时候开始处理一个更完整、现实的示例了！也就是说，我们将使用
    Terraform 自动创建和配置我们在 *[第 2 章](B19755_02.xhtml)* 中手动准备的易受攻击的实验室环境，*准备我们的第一个易受攻击的云实验室环境*。通过利用
    Terraform，我们应该能够简化设置我们之前手动准备的易受攻击实验室环境的过程。
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*What happened again in* *[Chapter 2](B19755_02.xhtml)**?* In *[Chapter 2](B19755_02.xhtml)*,
    we manually created an empty S3 bucket through the AWS Management Console and
    configured it for static website hosting. We then modified the access control
    settings of the bucket to allow authenticated AWS users to list and retrieve objects.
    To complete the setup, we uploaded sample files to the S3 bucket.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* *[第 2 章](B19755_02.xhtml)**发生了什么？* 在 *[第 2 章](B19755_02.xhtml)* 中，我们通过
    AWS 管理控制台手动创建了一个空的 S3 存储桶，并将其配置为静态网站托管。然后，我们修改了存储桶的访问控制设置，允许经过身份验证的 AWS 用户列出并检索对象。为了完成设置，我们将示例文件上传到
    S3 存储桶。'
- en: 'That said, this section is composed of four subparts, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，本节由四个子部分组成，如下所示：
- en: '*Creating an S3 bucket* *with Terraform*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Terraform 创建 S3 存储桶*'
- en: '*Updating the security configuration of the* *S3 bucket*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新 S3 存储桶的安全配置*'
- en: '*Uploading files to the* *S3 bucket*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传文件到* *S3 存储桶*'
- en: '*Cleaning up and deleting the* *S3 bucket*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清理并删除* *S3 存储桶*'
- en: Without further ado, let’s begin!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 事不宜迟，让我们开始吧！
- en: Part 1 of 4 – Creating an S3 bucket with Terraform
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 部分 / 共 4 部分 – 使用 Terraform 创建 S3 存储桶
- en: 'Continuing where we left off in the previous section, let’s create a **basics**
    directory using the **mkdir** command, then proceed as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前一节的内容，让我们使用 **mkdir** 命令创建一个 **basics** 目录，然后按以下步骤操作：
- en: 'Navigate to the directory created using the **cd** command:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **cd** 命令导航到已创建的目录：
- en: '[PRE63]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use the **touch** command to create an empty **main.tf** file inside the **vulnerable_s3_lab**
    directory:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **touch** 命令在 **vulnerable_s3_lab** 目录中创建一个空的 **main.tf** 文件：
- en: '[PRE64]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用 Vim 打开空的 **main.tf** 文件：
- en: '[PRE65]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入 **:set nu** 然后按 *Enter* 键来显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按 *i* 切换到 **插入模式**，这样我们就可以编辑文件了。
- en: 'Type or paste the following block of code into our **main.tf** file:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 **main.tf** 文件中键入或粘贴以下代码块：
- en: '[PRE66]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, let’s declare an **aws_s3_bucket** resource by adding the following block
    of code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加以下代码块来声明一个 **aws_s3_bucket** 资源：
- en: '[PRE67]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Make sure to replace **<INSERT BUCKET NAME>** with a bucket name that is globally
    unique across all AWS users. If you are wondering what **force_destroy** does,
    it simply allows us to delete the S3 bucket along with all objects inside it without
    issues in a later step.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将 **<INSERT BUCKET NAME>** 替换为一个全球唯一的存储桶名称。如果你想知道 **force_destroy** 的作用，它只是允许我们在后续步骤中删除
    S3 存储桶及其所有对象，而不会遇到问题。
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For guidelines and rules on how to name S3 buckets, feel free to check out
    the following link: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解如何命名 S3 存储桶的指南和规则，欢迎查看以下链接：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html)。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Esc*键切换回正常模式。输入**:wq!**，然后按*Enter*键。这将保存对**main.tf**文件所做的更改，并退出Vim。
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的**main.tf**文件已准备好，让我们使用**terraform init**命令初始化Terraform工作目录：
- en: '[PRE68]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行**terraform plan**来预览Terraform将执行的更改：
- en: '[PRE69]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This should yield a set of logs similar to what we have in *Figure 3**.6*:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成一组日志，类似于我们在*图3.6*中看到的内容：
- en: '![](image/B19755_03_06.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_06.jpg)'
- en: Figure 3.6 – Logs generated after running the terraform plan command
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.6 - 运行terraform plan命令后生成的日志
- en: Here, we can see that the values of some of the properties will only be known
    after the **terraform apply** command is executed (that is, when the resource
    has been created).
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到某些属性的值只有在执行**terraform apply**命令后才会知道（也就是说，当资源被创建时）。
- en: Note
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Understanding that certain property values are determined only after executing
    the **terraform apply** command is crucial. This dynamic nature of property values
    allows Terraform to accurately reflect the state of resources once they are created.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 了解某些属性值只有在执行**terraform apply**命令后才会确定，这是至关重要的。属性值的这种动态特性使得Terraform能够准确反映资源创建后的状态。
- en: 'Use the **terraform apply** command to implement the changes specified in the
    execution plan returned after running **terraform plan**:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**terraform apply**命令来实现执行计划中指定的更改，该计划在运行**terraform plan**后返回：
- en: '[PRE70]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This should yield a set of logs showing that we’ve successfully created the
    S3 bucket.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会生成一组日志，显示我们已成功创建S3桶。
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to use **terraform show** to check the current configuration settings
    of our S3 bucket.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 随时使用**terraform show**检查我们S3桶的当前配置设置。
- en: 'Before we celebrate, let’s run the following to verify that our S3 bucket has
    been created:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们庆祝之前，让我们运行以下命令，验证S3桶是否已成功创建：
- en: '[PRE71]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Make sure to replace **<INSERT BUCKET NAME>** with the bucket name specified
    in the **main.tf** file (from a previous step in this section). This should yield
    an output with the following format:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<INSERT BUCKET NAME>**替换为在**main.tf**文件中指定的桶名称（来自本节前面的步骤）。这应该会生成一个格式如下的输出：
- en: '[PRE72]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If the bucket name you specified is **vuln-s3-abcdef-12345**, we should get
    an output with a format similar to **2023-10-01** **12:00:00 vuln-s3-abcdef-12345**.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你指定的桶名称是**vuln-s3-abcdef-12345**，我们应该得到一个类似于**2023-10-01** **12:00:00 vuln-s3-abcdef-12345**格式的输出。
- en: Part 2 of 4 – Updating the security configuration of the S3 bucket
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分，共4部分 - 更新S3桶的安全配置
- en: 'We’re just getting started! In the following steps, we’ll learn how to update
    the security configuration:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们才刚刚开始！在接下来的步骤中，我们将学习如何更新安全配置：
- en: 'Now, let’s run the following command to open the **main.tf** file again using
    Vim:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令，再次使用Vim打开**main.tf**文件：
- en: '[PRE73]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入**:set nu**，然后按*Enter*键以显示行号。
- en: Next, hold the *Shift* key and then press *g* to navigate to the last line.
    Press *o* afterward. This should insert a new line after the current line (along
    with switching to **insert mode**).
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按住*Shift*键，然后按*g*键跳转到最后一行。之后按*o*键。这应该会在当前行之后插入新的一行（并切换到**插入模式**）。
- en: 'Now that we’re in insert mode, let’s proceed by adding the following block
    of code to specify the public access block configuration for the S3 bucket:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们处于插入模式，接下来添加以下代码块，以指定S3桶的公共访问阻止配置：
- en: '[PRE74]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, the **block_public_acls**, **block_public_policy**, **ignore_public_acls**,
    and **restrict_public_buckets** attributes are set to **false**. This means that
    the S3 bucket does not block public **access control lists** (**ACLs**) or public
    policies, does not ignore public ACLs, and does not restrict public buckets.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，**block_public_acls**、**block_public_policy**、**ignore_public_acls**和**restrict_public_buckets**属性被设置为**false**。这意味着S3桶不会阻止公共**访问控制列表**（**ACLs**）或公共策略，不会忽略公共ACLs，并且不会限制公共桶。
- en: 'Let’s also add the following to specify ownership controls for the S3 bucket:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加以下内容，以指定S3桶的所有权控制：
- en: '[PRE75]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The ownership controls are set to **ObjectWriter**. This ensures that objects
    in the bucket can only be modified by the **Identity and Access Management** (**IAM**)
    user or role that uploaded them.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有权控制设置为**ObjectWriter**。这确保了只有上传对象的**身份与访问管理**（**IAM**）用户或角色才能修改存储桶中的对象。
- en: 'Next, let’s configure the S3 bucket for **static website hosting** by adding
    the following block of code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加以下代码块来配置S3存储桶以进行**静态网站托管**：
- en: '[PRE76]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s define an **aws_iam_policy_document** data source block as well:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也定义一个**aws_iam_policy_document**数据源块：
- en: '[PRE77]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The policy described in the block of code grants permission to AWS principals
    (that is, *any* AWS account or IAM user) to perform the **s3:GetObject** action
    on objects within an S3 bucket. The **resources** attribute specifies the **Amazon
    Resource Name** (**ARN**) of the S3 bucket, followed by a wildcard character (*****)
    to allow access to all objects within the bucket.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码块中描述的策略授予AWS主体（即*任何*AWS账户或IAM用户）执行**s3:GetObject**操作的权限，作用于S3存储桶中的对象。**resources**属性指定了S3存储桶的**Amazon资源名称**（**ARN**），后跟一个通配符字符（*****），以允许访问存储桶中的所有对象。
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering what a data source block is, it is simply a resource we
    can read data from. It allows us to retrieve information from existing resources
    or external systems. In addition to this, it acts as a *read-only* reference,
    providing valuable data that can be used in our configuration. We’ll see the data
    source block used in the succeeding set of steps.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想数据源块是什么，它只是一个我们可以读取数据的资源。它允许我们从现有资源或外部系统中检索信息。此外，它充当一个*只读*参考，提供可用于配置的有价值数据。我们将在接下来的步骤中看到数据源块的使用。
- en: 'Let’s also define **s3_policy** and **au_uri** local variables, which we will
    use in the succeeding configuration blocks:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还定义**s3_policy**和**au_uri**本地变量，这些变量将在随后的配置块中使用：
- en: '[PRE78]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, define an **aws_s3_bucket_policy** resource using the following block
    of code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码块定义一个**aws_s3_bucket_policy**资源：
- en: '[PRE79]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let’s define another data source block, as follows:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再定义另一个数据源块，如下所示：
- en: '[PRE80]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is the same data source block used in the previous section of this chapter.
    If you can’t remember what this is used for, this data source block will give
    us access to the AWS canonical user ID of the account used to run Terraform.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章前一部分中使用的相同数据源块。如果你不记得这个是用来做什么的，这个数据源块将让我们访问运行Terraform时使用的账户的AWS规范用户ID。
- en: 'Let’s define an **aws_s3_bucket_acl** resource as well to set the S3 bucket’s
    ACL configuration settings:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还定义一个**aws_s3_bucket_acl**资源，用于设置S3存储桶的ACL配置设置：
- en: '[PRE81]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This code block configures the ACL of an S3 bucket. The **aws_s3_bucket_acl**
    resource sets permissions for two grants: one for a canonical user with **FULL_CONTROL**
    permission, and another for a group with **READ** permission. Here, the **data.aws_canonical_user_id**
    data source returns the canonical user ID for the first grantee. The **local.au_uri**
    local value, on the other hand, returns the URI (referring to an AWS pre-defined
    group called **AuthenticatedUsers**) for the second grantee.'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个代码块配置了S3存储桶的ACL。**aws_s3_bucket_acl**资源为两个授权设置了权限：一个是授予具有**FULL_CONTROL**权限的规范用户，另一个是授予具有**READ**权限的组。这里，**data.aws_canonical_user_id**数据源返回第一个授权人的规范用户ID。而**local.au_uri**本地值则返回第二个授权人的URI（指向一个名为**AuthenticatedUsers**的AWS预定义组）。
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve probably noticed that our **main.tf** file has got longer. It’s important
    to note that we can divide and group the resources across different files. When
    we have multiple **.tf** files in the working directory, Terraform simply concatenates
    these files and proceeds with its usual set of infrastructure management operations.
    We won’t dive deep into the strategies and best practices in this chapter since
    we’ll tackle these in the succeeding chapters of this book as we build a variety
    of penetration testing lab environments in AWS, Azure, and GCP.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们的**main.tf**文件变长了。需要注意的是，我们可以将资源划分到不同的文件中并进行分组。当工作目录中有多个**.tf**文件时，Terraform会将这些文件简单地连接起来并继续执行它的常规基础设施管理操作。我们在本章中不会深入讨论这些策略和最佳实践，因为我们将在本书接下来的章节中介绍这些内容，同时构建多个AWS、Azure和GCP中的渗透测试实验室环境。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Esc*键切换回正常模式。键入**:wq!**，然后按*Enter*。这将保存对**main.tf**所做的更改，并退出Vim。
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行**terraform plan**命令之前，让我们运行**terraform fmt**来格式化我们的 Terraform 代码：
- en: '[PRE82]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we make use of **terraform fmt** to establish a consistent coding style
    across our Terraform configuration files. By analyzing the files, this command
    adjusts indentation, spacing, and line breaks to align with the prescribed Terraform
    style guide.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用**terraform fmt**来确保我们的 Terraform 配置文件采用一致的编码风格。通过分析文件，此命令调整缩进、间距和换行符，以符合指定的
    Terraform 风格指南。
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行**terraform plan**预览 Terraform 将执行的更改：
- en: '[PRE83]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This should yield an execution plan similar to what we have in *Figure 3**.7*:'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该生成类似于*图 3**.7*中的执行计划：
- en: '![](image/B19755_03_07.jpg)'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_07.jpg)'
- en: Figure 3.7 – Results after running the terraform plan command
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.7 – 运行 terraform plan 命令后的结果
- en: Here, we can see that the execution plan now includes the updates on the security
    configuration settings of our S3 bucket.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到执行计划现在包括了我们的 S3 存储桶安全配置设置的更新。
- en: 'With everything ready, let’s run the **terraform** **apply** command:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪，让我们运行**terraform** **apply**命令：
- en: '[PRE84]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Important note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you encounter issues running **terraform apply -auto-approve**, feel
    free to rerun the same command as this may solve these issues automatically without
    having to modify the Terraform code. For example, if you encounter an “**Error
    putting S3 policy: AccessDenied: Access Denied**” error message, simply run **terraform
    apply -auto-approve** again. Note that an alternative for resolving issues would
    be to delete the resources first using **terraform destroy -auto-approve** and
    then create the resources again with **terraform** **apply -auto-approve**.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您遇到运行**terraform apply -auto-approve**时出现问题，请随时重新运行相同的命令，这可能会自动解决这些问题，而无需修改
    Terraform 代码。例如，如果遇到“**Error putting S3 policy: AccessDenied: Access Denied**”错误消息，请简单地再次运行**terraform
    apply -auto-approve**。请注意，解决问题的另一种方法是首先使用**terraform destroy -auto-approve**删除资源，然后再使用**terraform
    apply -auto-approve**创建资源。'
- en: 'Now, let’s verify whether the ACL configuration for the bucket has been applied
    using the following command:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证是否已应用桶的 ACL 配置，使用以下命令：
- en: '[PRE85]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Make sure to replace **<INSERT BUCKET NAME>** with the name of your S3 bucket.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保用您的 S3 存储桶的名称替换**<INSERT BUCKET NAME>**。
- en: 'After running the command, we should get a JSON response similar to what we
    have in *Figure 3**.8*:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行命令后，我们应该会得到一个类似于*图 3**.8*的 JSON 响应：
- en: '![](image/B19755_03_08.jpg)'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_08.jpg)'
- en: Figure 3.8 – Results returned after running the aws s3api get-bucket-acl command
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.8 – 运行 aws s3api get-bucket-acl 命令后返回的结果
- en: Here, we can see that the new ACL configuration settings have been applied to
    our S3 bucket.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到新的 ACL 配置设置已应用到我们的 S3 存储桶。
- en: Part 3 of 4 – Uploading files to the S3 bucket
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分共 4 部分 – 向 S3 存储桶上传文件
- en: 'Next, let’s add files to the S3 bucket created previously, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按以下方式向之前创建的 S3 存储桶添加文件：
- en: 'Use the **touch** command to create an empty **upload.sh** file:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**touch**命令创建空的**upload.sh**文件：
- en: '[PRE86]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To make the **upload.sh script** file executable, run the following command
    as well:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使**upload.sh 脚本**文件可执行，请运行以下命令：
- en: '[PRE87]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Run the following command to open the empty **upload.sh** file using Vim:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令打开空的**upload.sh**文件，使用 Vim：
- en: '[PRE88]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**：set nu**然后按*Enter*键显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the **upload.sh**
    file.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*i*切换到**插入模式**，以便我们可以编辑**upload.sh**文件。
- en: 'Now that we are in insert mode, let’s proceed by adding the following block
    of code:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们处于插入模式中，让我们继续添加以下代码块：
- en: '[PRE89]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This set of commands simply (1) downloads a ZIP file from a GitHub repository
    containing a sample website and (2) uploads its contents to an Amazon S3 bucket.
    Make sure that the **SOURCE** variable value is correct by removing any extra
    spaces and checking if the download link is working when accessed directly using
    the browser.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此一组命令简单地 (1) 从 GitHub 存储库下载一个 ZIP 文件，其中包含一个示例网站，并且 (2) 将其内容上传到 Amazon S3 存储桶。确保**SOURCE**变量值正确，通过删除任何额外的空格并检查是否可以直接通过浏览器访问下载链接来验证。
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is the same set of terminal commands used in *[Chapter 2](B19755_02.xhtml)*,
    *Preparing Our First Vulnerable Cloud Lab Environment*, to upload files to our
    S3 bucket.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在*[第 2 章](B19755_02.xhtml)*中使用的相同一组终端命令，*准备我们的第一个易受攻击的云实验室环境*，用于将文件上传到我们的
    S3 存储桶。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **upload.sh** and then exit Vim as
    well.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Esc*键切换回正常模式。输入**:wq!**并按*Enter*键。这将保存对**upload.sh**所做的更改并退出Vim。
- en: 'Run the following command to open the **main.tf** file using Vim:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用Vim打开**main.tf**文件：
- en: '[PRE90]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Hold the *Shift* key and then press *g* to navigate to the last line. Press
    *o* afterward. This should insert a new line after the current line (along with
    switching to **insert mode**).
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Shift*键，然后按*g*键跳转到最后一行。之后按*o*键。这将会在当前行之后插入一个新行（并切换到**插入模式**）。
- en: 'Add the following block of code after the new line inserted in the previous
    step:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步插入的新行之后，添加以下代码块：
- en: '[PRE91]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, the **provisioner** block specifies that a **local-exec** provisioner
    will be used, and the **command** attribute specifies the shell command to be
    executed, which in this case is a shell script named **upload.sh**.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，**provisioner**块指定将使用**local-exec**提供者，**command**属性指定要执行的shell命令，在此情况下为名为**upload.sh**的shell脚本。
- en: Note
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the provisioner code in the preceding block of code can also be placed
    inside the **aws_s3_bucket** resource block or in other resource blocks (with
    a few minor modifications to get it working). For more information on how the
    **local-exec** provisioner works, feel free to check out the following link: [https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec](https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码块中，提供者代码也可以放在**aws_s3_bucket**资源块内，或者放在其他资源块中（只需做一些小修改即可使其工作）。有关**local-exec**提供者的更多信息，请随时查看以下链接：[https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec](https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec)。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Esc*键切换回正常模式。输入**:wq!**并按*Enter*键。这将保存对**main.tf**所做的更改并退出Vim。
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行**terraform plan**来预览Terraform将要执行的变更：
- en: '[PRE92]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This should give us an error message similar to what we have in *Figure 3**.9*:'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们类似于*图 3.9*中所示的错误消息：
- en: '![](image/B19755_03_09.jpg)'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_09.jpg)'
- en: Figure 3.9 – Inconsistent dependency lock file error
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.9 – 不一致的依赖锁定文件错误
- en: 'The **Inconsistent dependency lock file** error in Terraform typically occurs
    when there is a mismatch between the dependency lock file and the configuration
    files. This inconsistency can arise due to changes made to the configuration without
    updating the lock file accordingly. That said, to resolve the **Inconsistent dependency
    lock file** error, let’s use the following command again:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Terraform中的**Inconsistent dependency lock file**错误通常发生在依赖关系锁定文件与配置文件不匹配时。这种不一致可能是由于对配置做了更改，但没有相应地更新锁定文件所导致的。因此，为了解决**Inconsistent
    dependency lock file**错误，我们可以再次使用以下命令：
- en: '[PRE93]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will sync the lock file with the configuration, resolving any inconsistencies
    and ensuring consistent dependencies for the Terraform deployment.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将同步锁定文件与配置，解决任何不一致之处，并确保Terraform部署的依赖关系一致。
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行**terraform plan**来预览Terraform将要执行的变更：
- en: '[PRE94]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You should see the command succeed this time.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次你应该看到命令执行成功。
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备好后，让我们使用**terraform apply**命令来实现运行**terraform plan**后返回的执行计划中指定的更改：
- en: '[PRE95]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This should run the commands coded in the **upload.sh** script.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会运行**upload.sh**脚本中编码的命令。
- en: 'Let’s perform a few quick checks by running the **aws s3 ls** command, as follows:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行**aws s3 ls**命令进行一些快速检查，如下所示：
- en: '[PRE96]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This should list the objects stored in our S3 bucket.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会列出我们S3桶中存储的对象。
- en: Note
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to replace **<INSERT BUCKET NAME>** with the name of your S3 bucket
    before running the command.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令之前，请确保将**<INSERT BUCKET NAME>**替换为你的S3桶名称。
- en: 'Now, let’s use the **aws s3api get-bucket-website** command to check the static
    website hosting configuration:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用**aws s3api get-bucket-website**命令来检查静态网站托管配置：
- en: '[PRE97]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Make sure to replace **<INSERT BUCKET NAME>** with the bucket name specified
    in the **main.tf** file (from a previous step in this section). This should return
    the following output:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<INSERT BUCKET NAME>**替换为**main.tf**文件中指定的桶名称（来自本节前面的步骤）。这应该返回以下输出：
- en: '[PRE98]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This confirms that the static website hosting configuration is properly set
    up for the specified S3 bucket.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确认了为指定S3桶正确设置了静态网站托管配置。
- en: 'Let’s also check whether our static website hosting setup works by navigating
    to the following link:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过访问以下链接来检查我们的静态网站托管设置是否有效：
- en: '[PRE99]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Make sure to replace **<BUCKET NAME>** with the name of the S3 bucket we created.
    Do not forget to replace **<REGION>** with the region where the S3 bucket was
    created (for example, **us-east-1**) as well.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<BUCKET NAME>**替换为我们创建的S3桶的名称。别忘了将**<REGION>**替换为S3桶创建所在的区域（例如，**us-east-1**）。
- en: 'If everything went well, we should see a maintenance page similar to what is
    shown in *Figure 3**.10*:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能看到类似*图 3.10*所示的维护页面：
- en: '![](image/B19755_03_10.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_03_10.jpg)'
- en: Figure 3.10 – Verifying that the static website hosting setup is working
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 验证静态网站托管设置是否生效
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, the vulnerable lab environment similar to what we prepared in
    *[Chapter 2](B19755_02.xhtml)*, *Preparing Our First Vulnerable Cloud Lab Environment*,
    is ready! Feel free to test the security configuration of our lab environment
    by following the steps specified in the *Testing and hacking our first vulnerable
    environment* section of *[Chapter 2](B19755_02.xhtml)* (where we will need the
    second AWS account).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，类似于我们在*[第2章](B19755_02.xhtml)*中准备的易受攻击实验环境（*准备我们的第一个易受攻击云实验环境*），已经准备就绪！可以随意按照*[第2章](B19755_02.xhtml)*中*测试和黑客攻击我们的第一个易受攻击环境*部分的步骤测试我们实验环境的安全配置（在这里我们需要第二个AWS账户）。
- en: Part 4 of 4 – Cleaning up and deleting the S3 bucket
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分 共4部分 – 清理并删除S3桶
- en: 'Before we end this section, let’s clean up! Follow these steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们进行清理！请按照以下步骤操作：
- en: 'Use **terraform destroy** to clean up the resources we created earlier:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**terraform destroy**来清理我们之前创建的资源：
- en: '[PRE100]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: During the verification step (that is, when you see an **Enter a value:** message),
    type in **yes** to proceed with the deletion of the resources. After the resources
    are deleted, a backup file (**terraform.tfstate.backup**) containing a copy of
    the properties of the state file becomes available in the same directory.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在验证步骤（即，当你看到**Enter a value:**提示时），输入**yes**继续删除资源。资源删除后，会在同一目录中生成一个包含状态文件属性副本的备份文件（**terraform.tfstate.backup**）。
- en: 'You may use the **less** or **cat** command to check the properties stored
    in the **terraform.tfstate.backup** file. Alternatively, we can use the **terraform
    show** command on the **terraform.tfstate.backup** file to read its contents:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用**less**或**cat**命令来检查存储在**terraform.tfstate.backup**文件中的属性。或者，我们可以使用**terraform
    show**命令读取**terraform.tfstate.backup**文件的内容：
- en: '[PRE101]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This should yield an output similar to what we have in *Figure 3**.11*:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生类似于*图 3.11*的输出：
- en: '![](image/B19755_03_11.jpg)'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_11.jpg)'
- en: Figure 3.11 – Output after running terraform show
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.11 – 运行 terraform show 后的输出
- en: In case you are tempted to use **terraform show** to convert a state file into
    a config file (similar to what we code inside the **main.tf** file), it is important
    to note that the output we have in *Figure 3**.11* is not intended for direct
    programmatic consumption (as it is made available primarily for us humans to troubleshoot
    and inspect the state stored inside a file).
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有冲动使用**terraform show**将状态文件转换为配置文件（类似于我们在**main.tf**文件中编写的内容），那么需要注意的是，我们在*图
    3.11*中的输出并不是为了直接程序化使用（它主要是供我们人类排查故障和检查存储在文件中的状态）。
- en: Note
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you use **terraform show** (without any additional argument(s)), we should
    get an empty response since the resources have been deleted already at this point
    using **terraform destroy**.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用**terraform show**（不带任何额外参数），我们应该得到一个空响应，因为资源已经在此时通过**terraform destroy**被删除。
- en: Wow! We were able to successfully convert the manual steps from *[Chapter 2](B19755_02.xhtml)*
    into a single configuration file. At this point, if we want to create 10 clones
    of the S3 bucket (with all resources having the same set of properties and configuration
    settings except for the bucket name), we will just need a few minor modifications
    to what we have right now and then use Terraform to automatically create and configure
    the S3 resources for us.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们成功地将*【第2章】(B19755_02.xhtml)*中的手动步骤转换成了一个配置文件。此时，如果我们想要创建10个S3桶的克隆（所有资源具有相同的属性和配置设置，除了桶名称），我们只需对现有配置进行少许修改，然后使用
    Terraform 自动创建和配置 S3 资源。
- en: Configuring a Terraform backend with state locking
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置带状态锁定的 Terraform 后端
- en: In this section, we will explore how Terraform remote backends work and understand
    how state locking ensures the integrity and consistency of our infrastructure
    state when managing infrastructure deployments. Then, we will delve into the step-by-step
    process of configuring a remote backend to enable state locking.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨 Terraform 远程后端的工作原理，并了解状态锁定如何确保在管理基础设施部署时，基础设施状态的完整性和一致性。接着，我们将深入研究配置远程后端以启用状态锁定的逐步过程。
- en: Understanding Terraform remote backends
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Terraform 远程后端
- en: Up until this point, we have used the default **local backend**, which stores
    the state as a local file (that is, the **terraform.tfstate** file). This type
    of setup should be okay when only a single engineer is involved. Once another
    engineer wants to apply configuration changes to the same set of resources with
    Terraform, using a **remote backend** will make more sense since the second engineer
    needs to have access to the existing state file (used by the first engineer).
    In addition to this, we need to make sure that configuration changes to the same
    set of resources are not applied at the same time to prevent **race conditions,**
    which could lead to a corrupted state.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用默认的**本地后端**，它将状态存储为本地文件（即**terraform.tfstate**文件）。当只有一个工程师参与时，这种配置应该是可以的。一旦另一位工程师希望使用
    Terraform 对相同的资源集应用配置更改，使用**远程后端**将更加合理，因为第二位工程师需要访问现有的状态文件（由第一位工程师使用）。此外，我们需要确保同一资源集的配置更改不会同时应用，以防止**竞争条件**，这可能导致状态损坏。
- en: 'One of the best practices when using Terraform involves the usage of an external
    remote backend to store and lock the state (similar to what is shown in *Figure
    3**.12*):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 时的最佳实践之一是使用外部远程后端来存储和锁定状态（类似于*图 3.12*所示）：
- en: '![](image/B19755_03_12.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_03_12.jpg)'
- en: Figure 3.12 – Local versus remote backend
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 本地后端与远程后端
- en: This allows multiple engineers to work on the same set of resources without
    having to worry about corrupting the setup. Configuring the right backend is critical
    as the Terraform backend dictates how state is loaded, which in turn affects the
    resource creation and modification processes.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许多位工程师在同一资源集上工作，而无需担心破坏设置。配置正确的后端至关重要，因为 Terraform 后端决定了状态的加载方式，这反过来会影响资源的创建和修改过程。
- en: Note
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Carefully selecting and configuring the backend ensures secure collaboration,
    version control, and proper state management throughout the infrastructure life
    cycle. This enhances the reliability and scalability of the Terraform workflow
    for teams working on the same set of resources. For more information, feel free
    to check out the following link: [https://developer.hashicorp.com/terraform/language/settings/backends/configuration](https://developer.hashicorp.com/terraform/language/settings/backends/configuration).'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 精心选择和配置后端可以确保安全协作、版本控制和整个基础设施生命周期中的正确状态管理。这增强了 Terraform 工作流的可靠性和可扩展性，特别是对于在相同资源集上工作的团队。欲了解更多信息，请随时查看以下链接：[https://developer.hashicorp.com/terraform/language/settings/backends/configuration](https://developer.hashicorp.com/terraform/language/settings/backends/configuration)。
- en: That said, to address the challenges of collaboration and prevent potential
    conflicts, it is recommended to switch from the default local backend to a remote
    backend in Terraform. By using a remote backend, such as an S3 bucket, multiple
    engineers can securely access and modify the same state file. This facilitates
    coordination and ensures consistency when making configuration changes to shared
    resources. Additionally, utilizing a remote backend helps mitigate the risk of
    race conditions, as it provides a centralized mechanism for managing and locking
    the state, reducing the likelihood of encountering a corrupted state.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，为了解决协作中的挑战并防止潜在的冲突，建议将 Terraform 的默认本地后端切换到远程后端。通过使用远程后端，如 S3 存储桶，多个工程师可以安全地访问和修改同一个状态文件。这有助于协调，并确保在对共享资源进行配置更改时的一致性。此外，使用远程后端有助于缓解竞争条件的风险，因为它提供了一个集中式的机制来管理和锁定状态，从而降低了遇到损坏状态的可能性。
- en: Configuring a Terraform remote backend
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Terraform 远程后端
- en: '**State locking** plays a vital role in avoiding conflicts and race conditions.
    By allowing only one user or process to modify the state at any given time, it
    ensures integrity and synchronization across Terraform deployments. This mechanism
    is crucial for maintaining data consistency and preventing unwanted changes during
    collaborative infrastructure management.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态锁定** 在避免冲突和竞争条件方面起着至关重要的作用。通过允许每次只有一个用户或进程修改状态，它确保了 Terraform 部署中的完整性和同步性。此机制对于维护数据一致性和防止在协作的基础设施管理过程中发生不必要的更改至关重要。'
- en: When configuring state locking for a Terraform backend in an AWS cloud environment,
    it is common to use an S3 bucket and a DynamoDB table. The S3 bucket acts as secure
    storage for the Terraform state file, while the DynamoDB table serves as a distributed
    lock mechanism. With state locking, only one Terraform command can hold the lock
    at a time, and others wait until it’s released. This setup ensures consistency
    and prevents conflicts in collaborative or automated Terraform environments. We
    will label the S3 bucket **BACKEND_S3** and the DynamoDB table **BACKEND_TABLE**
    as we will refer to these resources multiple times in this chapter. Note that
    **BACKEND_S3** and **BACKEND_TABLE** are just arbitrary labels we will use in
    this chapter to make it easier for us to refer to the resources we will be creating
    in the succeeding set of steps. That said, these labels are different from the
    actual resource names of the cloud infrastructure resources.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 云环境中配置 Terraform 后端的状态锁定时，通常会使用 S3 存储桶和 DynamoDB 表。S3 存储桶作为 Terraform
    状态文件的安全存储，而 DynamoDB 表则充当分布式锁机制。通过状态锁定，只有一个 Terraform 命令能够在任何时刻持有锁，其他命令则等待直到锁被释放。此设置确保一致性，并防止在协作或自动化的
    Terraform 环境中发生冲突。我们将把 S3 存储桶标记为 **BACKEND_S3**，DynamoDB 表标记为 **BACKEND_TABLE**，因为我们将在本章中多次引用这些资源。请注意，**BACKEND_S3**
    和 **BACKEND_TABLE** 只是我们在本章中使用的任意标签，目的是方便我们引用将在接下来的步骤中创建的资源。也就是说，这些标签与云基础设施资源的实际名称不同。
- en: Note
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering what DynamoDB is, it is a fully managed NoSQL database
    service in AWS. In DynamoDB, tables consist of items and attributes. Each item
    represents a distinct piece of data, similar to a row in a traditional database.
    Items are composed of attributes, which are key-value pairs that store the actual
    data. One thing to note is that DynamoDB tables do not require a fixed schema,
    meaning each item can have a different set of attributes. To implement the distributed
    lock mechanism, Terraform utilizes the DynamoDB table by creating a unique item
    or record as a lock indicator. When a Terraform command attempts to acquire a
    lock, it checks whether the designated item exists. If it does not exist, the
    command adds the item to the DynamoDB table, indicating that it has acquired the
    lock. This prevents other Terraform commands from acquiring the lock concurrently.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想 DynamoDB 是什么，它是 AWS 中完全托管的 NoSQL 数据库服务。在 DynamoDB 中，表由项目和属性组成。每个项目代表一条独立的数据，类似于传统数据库中的一行。项目由属性组成，属性是存储实际数据的键值对。需要注意的是，DynamoDB
    表不要求固定的模式，这意味着每个项目可以有不同的属性集合。为了实现分布式锁机制，Terraform 通过创建一个唯一的项目或记录作为锁指示符，利用 DynamoDB
    表。当 Terraform 命令尝试获取锁时，它会检查指定的项目是否存在。如果项目不存在，该命令会将项目添加到 DynamoDB 表中，表示它已获取锁。这可以防止其他
    Terraform 命令同时获取锁。
- en: 'In the next set of steps, we will upgrade our setup by configuring a Terraform
    backend to store and lock state:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将通过配置 Terraform 后端来存储和锁定状态，从而升级我们的设置：
- en: 'Navigate to the home directory using the **cd** command, as follows:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **cd** 命令导航到主目录，如下所示：
- en: '[PRE102]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Let’s create a **backend** directory using the **mkdir** command. After creating
    the **backend** directory, let’s navigate to the directory using the **cd** command:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 **mkdir** 命令创建一个 **backend** 目录。创建好 **backend** 目录后，使用 **cd** 命令导航到该目录：
- en: '[PRE103]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, let’s use the **touch** command to create an empty **main.tf** file inside
    the **backend** directory:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 **touch** 命令在 **backend** 目录中创建一个空的 **main.tf** 文件：
- en: '[PRE104]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用 Vim 打开空的 **main.tf** 文件：
- en: '[PRE105]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入 **:set nu**，然后按 *Enter* 键来显示行号。
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按 *i* 键切换到 **插入模式**，这样我们就可以编辑文件了。
- en: 'Add the following block of code to our **main.tf** file:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码块添加到我们的 **main.tf** 文件中：
- en: '[PRE106]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next, let’s define a *new* **aws_s3_bucket** resource (for the backend). Note
    that this S3 bucket resource is different from the misconfigured S3 bucket used
    in our vulnerable lab environment:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个 *新的* **aws_s3_bucket** 资源（用于后端）。请注意，这个 S3 存储桶资源与我们在脆弱实验环境中使用的配置错误的
    S3 存储桶不同：
- en: '[PRE107]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, the **lifecycle** block includes a **prevent_destroy** attribute set to
    **true**, ensuring that the bucket cannot be destroyed accidentally. This means
    that the Terraform state file stored in this bucket is protected from being accidentally
    deleted.
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，**lifecycle** 块包括一个将 **prevent_destroy** 属性设置为 **true** 的配置，确保存储桶不会被意外销毁。这意味着存储在该存储桶中的
    Terraform 状态文件被保护，不会被意外删除。
- en: Important note
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Make sure to replace **<INSERT S3 BACKEND BUCKET NAME>** with a unique S3 bucket
    name (for example, **tf-remote-backend-abcdef-<random string>**). Note that at
    this point, this bucket should *not* exist yet as we have not executed the **terraform**
    **apply** command.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 **<INSERT S3 BACKEND BUCKET NAME>** 替换为一个唯一的 S3 存储桶名称（例如，**tf-remote-backend-abcdef-<random
    string>**）。请注意，此时该存储桶应当 *还不存在*，因为我们还没有执行 **terraform** **apply** 命令。
- en: 'Now, let’s add the following block of code to enable **bucket versioning**
    and configure **server-side encryption** for our S3 bucket:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加以下代码块，以启用 **存储桶版本控制** 并为我们的 S3 存储桶配置 **服务器端加密**：
- en: '[PRE108]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, bucket versioning and server-side encryption are used for the S3 bucket,
    which will store the Terraform remote state. Versioning ensures that previous
    versions of the remote state are retained, allowing for easy recovery in the event
    of accidental deletion or corruption. Server-side encryption, on the other hand,
    ensures that sensitive data in the remote state is encrypted at rest to add an
    extra layer of security.
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，为 S3 存储桶启用了存储桶版本控制和服务器端加密，这将用于存储 Terraform 的远程状态。版本控制确保保留远程状态的先前版本，从而在意外删除或损坏的情况下可以轻松恢复。另一方面，服务器端加密确保远程状态中的敏感数据在静态时被加密，以增加额外的安全层。
- en: 'Next, let’s define an **aws_dynamodb_table** resource using the following block
    of code (using the name of our S3 bucket for the name of our DynamoDB table):'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下代码块定义一个 **aws_dynamodb_table** 资源（使用我们的 S3 存储桶名称作为 DynamoDB 表的名称）：
- en: '[PRE109]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, **billing_mode** is set to **"PAY_PER_REQUEST"**, meaning that (1) we
    only pay for read and write requests to the table, and (2) there are no upfront
    costs or minimum fees.
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，**billing_mode** 设置为 **"PAY_PER_REQUEST"**，这意味着 (1) 我们只为对表的读写请求付费，(2) 没有预付费用或最低费用。
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Esc* 键切换回普通模式。输入 **:wq!**，然后按 *Enter* 键。这将保存对 **main.tf** 所做的更改，并退出 Vim。
- en: Note
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'At this point, we should have two **main.tf** files: (1) **~/vulnerable_s3_lab/main.tf**
    and (2) **~/backend/main.tf**.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们应该已经有两个 **main.tf** 文件：(1) **~/vulnerable_s3_lab/main.tf** 和 (2) **~/backend/main.tf**。
- en: 'Now that our **~/backend/main.tf** file is ready, let’s use the **terraform
    init** command to initialize the Terraform working directory:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的 **~/backend/main.tf** 文件已经准备好，接下来让我们使用 **terraform init** 命令初始化 Terraform
    工作目录：
- en: '[PRE110]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行 **terraform plan** 来预览 Terraform 要执行的更改：
- en: '[PRE111]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备好后，让我们使用 **terraform apply** 命令来实施在运行 **terraform plan** 后返回的执行计划中的更改：
- en: '[PRE112]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wait for a few minutes for this step to complete. After successfully running
    the **terraform apply** command, we should have a new S3 bucket and a new DynamoDB
    table. Let’s label these resources **BACKEND_S3** and **BACKEND_TABLE** respectively
    as we will refer to these resources multiple times in this chapter. Note that
    this S3 bucket will be used for the Terraform remote backend and is different
    from the intentionally misconfigured S3 bucket used for the vulnerable lab environment
    (which we will label **VULNERABLE_S3**). With the Terraform remote backend ready,
    we can now proceed with configuring our existing Terraform code to use this remote
    backend. Make sure to take note of the names of the AWS S3 bucket (**BACKEND_S3**)
    and DynamoDB table (**BACKEND_TABLE**) resources created after running the **terraform
    apply** command before proceeding. You may use the **terraform show** command
    to inspect the existing infrastructure resources managed by Terraform.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟让这一步完成。成功运行**terraform apply**命令后，我们应该有一个新的S3存储桶和一个新的DynamoDB表。让我们分别标记这些资源为**BACKEND_S3**和**BACKEND_TABLE**，因为我们将在本章中多次引用这些资源。请注意，这个S3存储桶将用于Terraform远程后端，与用于易受攻击实验环境的故意配置错误的S3存储桶（我们将标记为**VULNERABLE_S3**）不同。有了Terraform远程后端准备好后，我们现在可以继续配置我们现有的Terraform代码以使用这个远程后端。在继续之前，请确保在运行**terraform
    apply**命令后记下AWS S3存储桶（**BACKEND_S3**）和DynamoDB表（**BACKEND_TABLE**）资源的名称。您可以使用**terraform
    show**命令检查Terraform管理的现有基础设施资源。
- en: 'Navigate back to the **vulnerable_s3_lab** directory using the **cd** command:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**cd**命令返回到**vulnerable_s3_lab**目录：
- en: '[PRE113]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Run the following command to open the **main.tf** file using Vim:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用Vim打开**main.tf**文件：
- en: '[PRE114]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按下*i*切换到**插入模式**，以便我们可以编辑文件。
- en: 'Locate the following block of code using the arrow keys:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键定位以下代码块：
- en: '[PRE115]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Once you’ve located the previous block of code, update it with the following
    block of code:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到之前的代码块，请用以下代码块更新它：
- en: '[PRE116]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Make sure to replace **<INSERT BUCKET NAME>** and **<INSERT TABLE NAME>** with
    the S3 bucket (**BACKEND_S3**) and DynamoDB table (**BACKEND_TABLE**) names respectively.
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保用 S3 存储桶（**BACKEND_S3**）和 DynamoDB 表（**BACKEND_TABLE**）的名称替换**<INSERT BUCKET
    NAME>**和**<INSERT TABLE NAME>**。
- en: Important note
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Here, we will specify the resource names of the existing S3 bucket (labeled
    **BACKEND_S3**) and DynamoDB table (labeled **BACKEND_TABLE**) resources created
    in an earlier step for the Terraform remote backend setup. Note that **BACKEND_S3**
    and **BACKEND_TABLE** are just arbitrary labels we’ve used in this chapter to
    make it easier for us to refer to the resources we created in earlier steps. That
    said, these are *not* the resource names that will be used to replace **<INSERT
    BUCKET NAME>** and **<INSERT TABLE NAME>** in the code block. Feel free to run
    the **terraform show** command again inside the **~/backend** directory to get
    the resource names.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将指定在早期步骤中创建的现有S3存储桶（标记为**BACKEND_S3**）和DynamoDB表（标记为**BACKEND_TABLE**）资源的资源名称，用于Terraform远程后端设置。请注意，**BACKEND_S3**和**BACKEND_TABLE**只是我们在本章中使用的任意标签，以便我们更容易地引用我们在早期步骤中创建的资源。也就是说，这些并不是将在代码块中替换**<INSERT
    BUCKET NAME>**和**<INSERT TABLE NAME>**的资源名称。随时在**~/backend**目录中再次运行**terraform
    show**命令以获取资源名称。
- en: 'Now that our **~/vulnerable_s3_lab/main.tf** file has been updated, let’s run
    **terraform fmt** to format our Terraform code:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的**~/vulnerable_s3_lab/main.tf**文件已经更新，让我们运行**terraform fmt**来格式化我们的Terraform代码：
- en: '[PRE117]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here, we are using **terraform fmt** to ensure a consistent coding style across
    all Terraform configuration files.
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用**terraform fmt**来确保所有Terraform配置文件都具有一致的编码风格。
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用**terraform init**命令重新初始化Terraform工作目录：
- en: '[PRE118]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行**terraform plan**来预览Terraform将执行的更改：
- en: '[PRE119]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, let’s use the **terraform** **apply** command:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用**terraform apply**命令：
- en: '[PRE120]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This will create a misconfigured S3 bucket (labeled **VULNERABLE_S3**) for our
    vulnerable lab environment.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为我们的易受攻击实验环境创建一个配置错误的S3存储桶（标记为**VULNERABLE_S3**）。
- en: Important note
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In case you encounter issues running **terraform apply -auto-approve**, feel
    free to rerun the same command as this may solve these issues automatically without
    having to modify the Terraform code. Note that an alternative for resolving issues
    would be to delete the resources first using **terraform destroy -auto-approve**
    and then create the resources again with **terraform** **apply -auto-approve**.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行**terraform apply -auto-approve**时遇到问题，请随时重新运行相同命令，这可能会自动解决这些问题，而无需修改Terraform代码。请注意，解决问题的另一种方法是首先使用**terraform
    destroy -auto-approve**删除资源，然后再使用**terraform apply -auto-approve**创建资源。
- en: 'Before we celebrate, let’s verify whether the S3 bucket used for the backend
    (**BACKEND_S3**) has the **terraform.tfstate** file:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们庆祝之前，让我们验证一下用于后端（**BACKEND_S3**）的S3存储桶是否有**terraform.tfstate**文件：
- en: '[PRE121]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Make sure to replace **<S3 BACKEND BUCKET NAME>** with the name of the S3 bucket
    (labeled **BACKEND_S3**) used for the Terraform backend specified in our **~/****backend/main.tf**
    file.
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保用我们**~/****backend/main.tf**文件中指定的Terraform后端使用的S3存储桶（标记为**BACKEND_S3**）的名称替换**<S3
    BACKEND BUCKET NAME>**。
- en: 'After running the **aws s3 ls** command, we should get the following output:'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行**aws s3 ls**命令后，我们应该得到以下输出：
- en: '[PRE122]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This means that we have successfully reconfigured our Terraform code to store
    the state file inside an S3 bucket (instead of the local directory).
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们已成功重新配置了我们的Terraform代码，将状态文件存储在S3存储桶中（而不是本地目录）。
- en: Next, let’s open a new browser tab and navigate to the home page of the AWS
    Management Console.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们打开一个新的浏览器选项卡，导航到AWS管理控制台的主页。
- en: Note
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not close the browser tab where we are running commands inside the AWS CloudShell
    terminal.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 不要关闭我们在AWS CloudShell终端内运行命令的浏览器选项卡。
- en: Navigate to the DynamoDB console by typing **dynamodb** in the search bar and
    then selecting **DynamoDB** from the list of results. In the navigation pane on
    the left side of the DynamoDB console, choose **PartiQL editor**.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中键入**dynamodb**，然后从结果列表中选择**DynamoDB**，以进入DynamoDB控制台。在DynamoDB控制台左侧的导航窗格中，选择**PartiQL编辑器**。
- en: Note
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering what **PartiQL** is, it is simply a SQL-compatible query
    language for DynamoDB. With PartiQL, we can query our DynamoDB tables similarly
    to how we would query our SQL database tables. This allows us to leverage our
    existing SQL knowledge and skills when working with DynamoDB, making it easier
    to write and execute complex queries against our NoSQL data.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道**PartiQL**是什么，它只是DynamoDB的一个与SQL兼容的查询语言。使用PartiQL，我们可以类似于查询SQL数据库表的方式查询DynamoDB表。这使我们能够在处理DynamoDB时利用我们现有的SQL知识和技能，更容易地编写和执行复杂的NoSQL数据查询。
- en: 'Specify the following query in the PartiQL editor (text area):'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PartiQL编辑器（文本区域）中指定以下查询：
- en: '[PRE123]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Make sure to replace **<INSERT TABLE NAME>** with the name of the DynamoDB table
    (labeled **BACKEND_TABLE**) we created (using Terraform) in an earlier step in
    this section.
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保用我们在本节中早期步骤中使用Terraform创建的DynamoDB表的名称（标记为**BACKEND_TABLE**）替换**<INSERT TABLE
    NAME>**。
- en: Note
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to run the **terraform show** command again inside the **~/backend**
    directory to get the resource name of the DynamoDB table we labeled **BACKEND_TABLE**.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以在**~/backend**目录内再次运行**terraform show**命令，以获取我们标记为**BACKEND_TABLE**的DynamoDB表的资源名称。
- en: Click the **Run** button to execute the query.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮执行查询。
- en: Our query should return a single item where the **LockID** value is **<BACKEND_S3
    BUCKET NAME>/terraform/terraform.tfstate-md5**. This item should also have a randomly
    generated alphanumeric **Digest** value similar to **51f8a19d543d54b0481f1823b1784896**.
    This **digest** value is a representation of the Terraform state file’s content.
    It is used to detect changes in the state file and ensure consistency during operations
    such as **plan**, **apply**, and **destroy**. When we modify the infrastructure,
    Terraform will make changes to the state file, but the digest itself will not
    change unless the content of the state file has changed. That said, this value
    acts as a checksum or hash of the state file’s content, which allows Terraform
    to determine whether the state file has been modified externally (or whether there
    are concurrent modifications that may result in conflicts).
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的查询应返回一个项目，其中**LockID**值为**<BACKEND_S3 BUCKET NAME>/terraform/terraform.tfstate-md5**。该项目还应具有类似于**51f8a19d543d54b0481f1823b1784896**的随机生成的字母数字**Digest**值。这个**digest**值是Terraform状态文件内容的表示。它用于检测状态文件的更改，并确保在**plan**、**apply**和**destroy**等操作期间保持一致性。当我们修改基础架构时，Terraform将对状态文件进行更改，但除非状态文件的内容发生更改，否则摘要本身不会更改。也就是说，这个值充当状态文件内容的校验和或哈希，这使得Terraform能够确定状态文件是否已被外部修改（或是否存在可能导致冲突的并发修改）。
- en: 'Finally, navigate back to the CloudShell browser tab and then use the **terraform
    destroy** command to clean up the resources we created earlier:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回CloudShell浏览器选项卡，然后使用**terraform destroy**命令清理我们之前创建的资源：
- en: '[PRE124]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: During the verification step (that is, when you see **Enter a value:**), type
    in **yes** to proceed with the deletion of the resources.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在验证步骤（即看到**输入一个值：**时），输入**yes**以继续删除资源。
- en: Note
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The resources deleted in the last step do not include the Terraform backend
    resources (that is, **BACKEND_S3** and **BACKEND_TABLE**) as these resources were
    defined in **~/backend/main.tf**.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 上一步中删除的资源不包括Terraform后端资源（即**BACKEND_S3**和**BACKEND_TABLE**），因为这些资源是在**~/backend/main.tf**中定义的。
- en: We’re not done yet! In the next section, we will verify whether our state-locking
    setup is working.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！在下一节中，我们将验证我们的状态锁定设置是否有效。
- en: Verifying the state-locking setup
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证状态锁定设置
- en: Verifying the Terraform state-lock setup is crucial to ensure the integrity
    of our infrastructure management process. By verifying the state-lock setup, we
    can confirm that the distributed lock mechanism using S3 and DynamoDB from the
    previous section is functioning correctly. That said, what happens when two users
    attempt to run **terraform apply** almost at the same time? We will see what happens
    in the next set of steps!
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 验证Terraform状态锁定设置对于确保我们的基础架构管理过程的完整性至关重要。通过验证状态锁定设置，我们可以确认使用上一节中的S3和DynamoDB的分布式锁定机制是否正常运行。也就是说，当两个用户几乎同时运行**terraform
    apply**时会发生什么？我们将在接下来的步骤中看到发生了什么！
- en: Note
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This scenario of concurrent **terraform apply** commands highlights the importance
    of state locking to prevent conflicts and ensure data consistency. In this section,
    we will explore how Terraform manages state locks and handles concurrent operations.
    This will help us have a better understanding of the behavior and safeguards implemented
    by Terraform in such situations.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 并发**terraform apply**命令的这种情况突出了状态锁定的重要性，以防止冲突并确保数据一致性。在本节中，我们将探讨Terraform如何管理状态锁定并处理并发操作。这将帮助我们更好地理解Terraform在这种情况下实施的行为和保障措施。
- en: Part 1 of 4 – Adding a 60-second delay to the upload script
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分 - 向上传脚本添加60秒延迟
- en: 'Continuing from where we left off in the previous section, let’s navigate to
    the **vulnerable_s3_lab** directory using the **cd** command:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续从上一节结束的地方，让我们使用**cd**命令导航到**vulnerable_s3_lab**目录：
- en: '[PRE125]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Run the following command to open the **upload.sh** file using Vim:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以使用Vim打开**upload.sh**文件：
- en: '[PRE126]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**：set nu**，然后按下*Enter*键以显示行号。
- en: Use the arrow keys to put the cursor before the first character of the first
    line. After that, press *i* to switch to insert mode so that we can edit the file.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键将光标放在第一行的第一个字符之前。之后，按下*i*切换到插入模式，以便我们可以编辑文件。
- en: 'Add the following lines of code at the start of the **upload.sh** script:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**upload.sh**脚本的开头添加以下代码行：
- en: '[PRE127]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The 2 lines added at the start of the script should make the **upload.sh** script
    run 60 seconds longer. This should give us a few extra seconds to run the commands
    needed to verify whether the state-locking setup is working.
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在脚本开头添加的2行应使**upload.sh**脚本运行时间延长60秒。这应该给我们额外的几秒钟来运行所需的命令，以验证状态锁定设置是否正常工作。
- en: Press the *Esc* key to switch to normal mode. Type **:wq!**. Press *Enter* afterward.
    This will save the changes made to **upload.sh** and then exit Vim as well.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Esc*键切换到正常模式。输入**：wq!**。然后按*Enter*。这将保存对**upload.sh**所做的更改，然后退出Vim。
- en: 'Use the **cat** command (**cat upload.sh**) to verify our updated **upload.sh**
    file looks similar to what we have in the following block of code:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**cat**命令（**cat upload.sh**）验证我们更新的**upload.sh**文件看起来是否与以下代码块中的内容类似：
- en: '[PRE128]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, we basically have the same **upload.sh** file except that the first 2
    lines have been added to add a 60-second delay when running the script.
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们基本上有相同的**upload.sh**文件，只是在运行脚本时添加了前2行以增加60秒的延迟。
- en: Part 2 of 4 – Acquiring the state lock
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分4 – 获取状态锁
- en: Now, let’s split the CloudShell terminal screen vertically. Press the *Ctrl*
    key while pressing *b*. Release both keys and then press *%* (or *Shift* + *5*)
    after about half a second. This should create a vertical split similar to what
    we have in *Figure 3**.13*:![](image/B19755_03_13.jpg)
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在CloudShell终端屏幕上垂直分割。按住*Ctrl*键同时按下*b*键。释放两个键，然后在大约半秒后按下*%*（或*Shift* +
    *5*）。这应该创建一个类似于*图3**.13*中的垂直分割：![](image/B19755_03_13.jpg)
- en: Figure 3.13 – Vertical split in tmux
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.13 – **tmux**中的垂直分割
- en: Since AWS CloudShell comes pre-installed with **tmux**, we should be able to
    use the **tmux** commands directly without having to install the utility separately.
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于AWS CloudShell预先安装了**tmux**，我们应该能够直接使用**tmux**命令，而无需单独安装该实用程序。
- en: Note
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If this is your first time using **tmux**, do not worry as it may take a few
    tries before getting the key combinations right! Feel free to watch this tutorial
    video for more information on how to use **tmux**: [https://www.youtube.com/watch?v=Yl7NFenTgIo](https://www.youtube.com/watch?v=Yl7NFenTgIo).'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用**tmux**，不要担心，可能需要几次尝试才能掌握正确的按键组合！随时观看这个教程视频以获取有关如何使用**tmux**的更多信息：[https://www.youtube.com/watch?v=Yl7NFenTgIo](https://www.youtube.com/watch?v=Yl7NFenTgIo)。
- en: Let’s jump to the left pane. Press the *Ctrl* key while pressing *b*. Release
    both keys and then press the *left arrow* key after about half a second.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们跳到左窗格。按住*Ctrl*键同时按下*b*键。释放两个键，然后在大约半秒后按下*左箭头*键。
- en: 'Now, run the following command on the left pane:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在左窗格上运行以下命令：
- en: '[PRE129]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This should yield a set of logs similar to the logs generated after running
    the **terraform apply** command in the *Building our vulnerable lab environment
    with Terraform* section of this chapter. You may ignore any **AccessDenied** error
    messages as these can easily be solved by retrying the command in the left pane
    (which we don't need to do at this point).
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该产生一组类似于在本章*使用Terraform构建我们的易受攻击实验环境*部分运行**terraform apply**命令后生成的日志。您可以忽略任何**AccessDenied**错误消息，因为这些可以通过在左窗格中重试命令轻松解决（在这一点上我们不需要这样做）。
- en: Important note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Running the **terraform apply** command will acquire a state lock to ensure
    that concurrent operations do not modify the infrastructure state simultaneously.
    This lock is essential for maintaining consistency and preventing conflicts in
    collaborative or automated environments. By acquiring the lock before making any
    modifications, we ensure that multiple **terraform apply** commands wait for the
    lock to be released before proceeding. That said, do *not* wait for the **terraform
    apply** command to finish! Proceed to the next set of steps right after running
    the command on the left pane.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**terraform apply**命令将获取状态锁，以确保并发操作不会同时修改基础设施状态。这个锁对于保持一致性并防止协作或自动化环境中的冲突至关重要。通过在进行任何修改之前获取锁，我们确保多个**terraform
    apply**命令在继续之前等待锁被释放。也就是说，*不要*等待**terraform apply**命令完成！在在左窗格上运行命令后立即继续下一组步骤。
- en: Part 3 of 4 – Testing our state-lock setup
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分4 – 测试我们的状态锁设置
- en: To test our state-lock setup, we will run another **terraform apply** command
    while the first **terraform apply** command is still running. That said, let’s
    jump to the right pane. Press the *Ctrl* key while pressing *b*. Release both
    keys and then press the *right arrow* key after about half a second.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的状态锁设置，我们将在第一个**terraform apply**命令仍在运行时运行另一个**terraform apply**命令。也就是说，让我们跳到右窗格。按住*Ctrl*键同时按下*b*键。释放这两个键，然后在大约半秒后按下*右箭头*键。
- en: 'While the **terraform apply** command is running on the left pane, run the
    following command on the right pane:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当左窗格上运行**terraform apply**命令时，在右窗格上运行以下命令：
- en: '[PRE130]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This should give us an error similar to what is shown in *Figure 3**.14*:'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给我们一个类似于*图3**.14*所示的错误：
- en: '![](image/B19755_03_14.jpg)'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_03_14.jpg)'
- en: Figure 3.14 – Error acquiring the state lock
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.14 – 获取状态锁时出错
- en: This means that we can’t acquire a state lock at the moment while the first
    **terraform apply** command is still running (in the left pane). Once the command
    in the left pane succeeds (or fails due to an error), the state lock will be released.
    *Is this the expected behavior? YES!* By acquiring the state lock in an earlier
    step, we have ensured that only one **terraform apply** command can modify the
    state at a time. This sequential approach guarantees consistency and prevents
    race conditions. Therefore, it is normal for subsequent **terraform apply** commands
    to wait until the initial command completes and releases the state lock before
    proceeding.
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们在第一个**terraform apply**命令仍在运行时（在左窗格中）无法获取状态锁。一旦左窗格中的命令成功（或由于错误而失败），状态锁将被释放。*这是预期的行为吗？是的！*通过在较早的步骤中获取状态锁，我们确保只有一个**terraform
    apply**命令可以一次修改状态。这种顺序方法确保一致性并防止竞争条件。因此，正常情况下，后续的**terraform apply**命令会等待初始命令完成并释放状态锁，然后再继续。
- en: Of course, there will be cases where the state lock is not released automatically
    (most likely due to an unexpected issue). To resolve this issue, you may use **terraform
    force-unlock -force <ID>** to manually unlock the state. You can find the **ID**
    value in the **Lock Info** section of the error message (similar to what we have
    in *Figure 3**.14*).
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，会有一些情况下状态锁不会自动释放（很可能是由于意外问题）。要解决这个问题，你可以使用**terraform force-unlock -force
    <ID>**手动解锁状态。你可以在错误消息的**Lock Info**部分找到**ID**值（类似于我们在*图3**.14*中看到的）。
- en: Important note
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In case you missed the timing (that is, the **terraform apply** command in the
    left pane finished executing before you were able to run the **terraform apply**
    command in the right pane), feel free to destroy the created resources by running
    **terraform destroy -auto-approve** inside the **~/vulnerable_s3_lab** directory
    so that you can try repeating the last set of steps. You may also replace the
    60-second delay with a 120-second delay by modifying the **upload.sh** file to
    give you more time to jump between **tmux** panes.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了时机（也就是说，在你能够在右窗格运行**terraform apply**命令之前，左窗格中的命令已经执行完毕），请随时在**~/vulnerable_s3_lab**目录内运行**terraform
    destroy -auto-approve**来销毁创建的资源，这样你就可以尝试重复上一组步骤。你也可以通过修改**upload.sh**文件，将60秒的延迟替换为120秒的延迟，以便给你更多时间在**tmux**窗格之间切换。
- en: Part 4 of 4 – Cleaning up
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分4 – 清理工作
- en: 'With our state-lock verification experiment complete, let’s exit the **tmux**
    session on the right pane using the **exit** command:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们的状态锁验证实验完成，让我们使用**exit**命令退出右窗格上的**tmux**会话：
- en: '[PRE131]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This should leave us with a single pane (removing the vertical split).
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使我们只留下一个窗格（移除垂直分割）。
- en: 'Before we end this section, let’s use **terraform destroy** to clean up the
    resources we created earlier:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们使用**terraform destroy**清理之前创建的资源：
- en: '[PRE132]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: During the verification step (that is, when you see **Enter a value:**), type
    in **yes** to proceed with the deletion of the resources. This will delete the
    resources (primarily the S3 bucket labeled **VULNERABLE_S3**) specified in the
    **main.tf** file inside the **vulnerable_s3_lab** directory.
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在验证步骤中（也就是当你看到**输入一个值:**时），输入**yes**以继续删除资源。这将删除**vulnerable_s3_lab**目录内**main.tf**文件中指定的资源（主要是标记为**VULNERABLE_S3**的S3存储桶）。
- en: Note
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to delete the remaining S3 bucket (used as the remote state backend
    we labeled **BACKEND_S3**) along with the DynamoDB table (labeled **BACKEND_TABLE**)
    as well. We will leave this to you as an exercise.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 随意删除剩余的S3存储桶（用作我们标记为**BACKEND_S3**的远程状态后端）以及DynamoDB表（标记为**BACKEND_TABLE**）。我们将把这留给你作为练习。
- en: Wow! That was one productive and action-packed chapter! At this point, we should
    already have a good grasp of how we can utilize Terraform (along with IaC concepts
    and strategies) to create and configure cloud resources. In the succeeding chapters,
    we will dive deeper into how the things we learned in this chapter play a pivotal
    role in building penetration testing labs in the cloud.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一章真是充满了生产力和行动！到目前为止，我们应该已经很好地掌握了如何利用 Terraform（结合 IaC 概念和策略）来创建和配置云资源。在接下来的章节中，我们将更深入地探讨在本章中学到的内容如何在构建云端渗透测试实验室中发挥关键作用。
- en: Summary
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about how IaC can help us automatically prepare,
    configure, and manage our penetration testing lab environments in the cloud. We
    then used Terraform, one of the most powerful and most used IaC tools available,
    to create, modify, and delete cloud infrastructure resources. After setting up
    Terraform in our environment, we then proceeded with several hands-on examples
    to demonstrate the different capabilities of the tool. In addition to this, we
    rebuilt the vulnerable lab environment we prepared in *[Chapter 2](B19755_02.xhtml)*
    using Terraform (this time, automatically). Finally, we had a quick look at how
    to configure a Terraform backend with state locking to help prevent conflicts
    when multiple engineers are using Terraform to modify infrastructure resources.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了 IaC 如何帮助我们在云端自动准备、配置和管理渗透测试实验室环境。然后，我们使用了 Terraform，这个最强大和最常用的 IaC
    工具之一，来创建、修改和删除云基础设施资源。在我们的环境中设置好 Terraform 后，我们进行了几个实践示例，演示了该工具的不同功能。此外，我们还使用
    Terraform（这次是自动化的）重建了在 *[第2章](B19755_02.xhtml)* 中准备的脆弱实验室环境。最后，我们简要回顾了如何配置带有状态锁定的
    Terraform 后端，以帮助防止多个工程师在使用 Terraform 修改基础设施资源时发生冲突。
- en: In the next chapter, we’ll dive deep into the different strategies for isolating
    accounts and environments in the cloud. The information, along with the hands-on
    solutions in the next chapter, will help us secure and manage our penetration
    testing lab environments in the cloud properly.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在云端隔离账户和环境的不同策略。结合下一章的实践解决方案，这些信息将帮助我们妥善地保护和管理我们的云端渗透测试实验室环境。
- en: Further reading
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information on the topics covered in this chapter, feel free to check
    out the following resources:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多本章涉及的内容，请随时查阅以下资源：
- en: '*Finding the canonical user ID for your AWS* *account* ([https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html))'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找 AWS* *账户的规范用户 ID* ([https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html))'
- en: '*Terraform Language* *Documentation* ([https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language))'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform 语言* *文档* ([https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language))'
- en: '*Terraform—Remote* *State* ([https://developer.hashicorp.com/terraform/language/state/remote](https://developer.hashicorp.com/terraform/language/state/remote))'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform—远程* *状态* ([https://developer.hashicorp.com/terraform/language/state/remote](https://developer.hashicorp.com/terraform/language/state/remote))'
- en: '*Terraform—State* *Locking* ([https://developer.hashicorp.com/terraform/language/state/locking](https://developer.hashicorp.com/terraform/language/state/locking))'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform—状态* *锁定* ([https://developer.hashicorp.com/terraform/language/state/locking](https://developer.hashicorp.com/terraform/language/state/locking))'
- en: '*Terraform—Recovering from State* *Disasters* ([https://developer.hashicorp.com/terraform/cli/state/recover](https://developer.hashicorp.com/terraform/cli/state/recover))'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform—从状态* *灾难中恢复* ([https://developer.hashicorp.com/terraform/cli/state/recover](https://developer.hashicorp.com/terraform/cli/state/recover))'
- en: '*A Great Vim Cheat* *Sheet* ([https://vimsheet.com/](https://vimsheet.com/))'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一张超实用的 Vim 快捷键* *参考表* ([https://vimsheet.com/](https://vimsheet.com/))'
- en: '*Tmux Cheat Sheet & Quick* *Reference* ([https://tmuxcheatsheet.com/](https://tmuxcheatsheet.com/))'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tmux 快捷键表 & 快速* *参考* ([https://tmuxcheatsheet.com/](https://tmuxcheatsheet.com/))'
- en: 'Part 2: Setting Up Isolated Penetration Testing Lab Environments in the Cloud'
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：在云端搭建隔离渗透测试实验室环境
- en: In this part, you will learn how to build and automate isolated penetration
    testing lab environments on AWS, Azure, and GCP.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，您将学习如何在 AWS、Azure 和 GCP 上构建和自动化隔离的渗透测试实验室环境。
- en: 'This part contains the following chapters:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '*[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on GCP*'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第4章](B19755_04.xhtml)*，*在 GCP 上搭建隔离的渗透测试实验室环境*'
- en: '*[Chapter 5](B19755_05.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on Azure*'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第5章](B19755_05.xhtml)*，*在Azure上设置隔离的渗透测试实验环境*'
- en: '*[Chapter 6](B19755_06.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on AWS*'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第6章](B19755_06.xhtml)*，*在AWS上设置隔离的渗透测试实验环境*'
