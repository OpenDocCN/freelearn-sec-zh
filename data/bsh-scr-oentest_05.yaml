- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Regular Expressions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '**Regular expressions** , or **regex** , might seem daunting at first, but
    they’re an incredibly powerful tool for anyone working with text, especially in
    Bash scripting. This chapter is designed to ease you into the world of regex,
    starting from the basics and gradually moving to more complex patterns and techniques.
    Whether you’re looking to validate email addresses, search for specific patterns
    in log files, or automate text processing tasks, understanding regex is a game-changer.
    We’ll explore how to craft regex patterns, understand their structure, and apply
    them in practical scenarios. By the end of this chapter, you’ll not only be comfortable
    using regex but also appreciate how they can make your scripting tasks more efficient
    and versatile.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**，或称**regex**，刚开始可能看起来让人望而生畏，但它们对于任何处理文本的人来说，尤其是在 Bash 脚本中，是一个非常强大的工具。本章旨在帮助你逐步掌握正则表达式的世界，从基础知识开始，逐步深入到更复杂的模式和技术。无论你是想验证电子邮件地址、搜索日志文件中的特定模式，还是自动化文本处理任务，理解正则表达式将大大改变你的工作方式。我们将探索如何构建正则表达式模式，理解其结构，并将其应用于实际场景。到本章结束时，你不仅能熟练使用正则表达式，还能体会到它们如何使你的脚本任务更加高效和灵活。'
- en: This chapter builds on the topics you learned about in the previous chapter.
    Regex is frequently used together with variables and conditional statements. For
    example, you’re likely going to use a **while** loop to read in a line of data
    from **stdin** or from a file and assign the data you read to a variable. Then,
    you’re going to perform a regex on the variable data, and finally make a decision
    using a conditional statement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容建立在上一章学习的基础上。正则表达式常常与变量和条件语句一起使用。例如，你可能会使用一个**while**循环从**stdin**或文件中读取一行数据，并将读取的数据赋值给一个变量。然后，你将对该变量数据执行正则表达式，最后使用条件语句作出决策。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要主题：
- en: The basics of regex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式基础
- en: Advanced regex patterns and techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级正则表达式模式和技巧
- en: Demonstrating practical applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示实际应用
- en: Regex tips and best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式技巧和最佳实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is helpful but not required to be able to install a Kali virtual machine,
    as stated in [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017) .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B22229_01.xhtml#_idTextAnchor017)所述，能够安装 Kali 虚拟机是有帮助的，但不是必须的。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04)
    找到。
- en: The basics of regex
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式基础
- en: At their core, regex is a method for searching, matching, and manipulating text.
    Think of them as a sophisticated search tool that goes beyond the capabilities
    of the standard search feature in your text editor or word processor. Regex allows
    you to define patterns in text, making it possible to perform complex searches
    and edits with relative ease.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，正则表达式（regex）是一种搜索、匹配和操作文本的方法。可以把它们看作是一个复杂的搜索工具，超越了你在文本编辑器或文字处理软件中标准搜索功能的能力。正则表达式允许你在文本中定义模式，使得进行复杂的搜索和编辑变得相对简单。
- en: 'Regex is incredibly versatile. Here are just a few examples of what they can
    be used for:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式极其灵活。以下是它们可以用来做的几个例子：
- en: '**Data validation** : Ensuring that user input matches a specific format, such
    as email addresses or phone numbers'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据验证**：确保用户输入符合特定格式，例如电子邮件地址或电话号码'
- en: '**Data extraction** : Pulling specific pieces of information from a larger
    dataset, such as extracting all URLs from a web page'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据提取**：从更大的数据集提取特定的信息，例如从网页中提取所有 URL'
- en: '**Search and replace** : Finding and replacing text in a document based on
    patterns rather than exact matches'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索和替换**：基于模式而非精确匹配在文档中查找和替换文本'
- en: 'The regex alphabet consists of **characters** and **metacharacters** . Characters
    are just what you think: letters, numbers, and symbols that you’re trying to find
    in your text. Metacharacters, on the other hand, are the special sauce of regex.
    They’re symbols that have a special meaning, helping to define patterns. Some
    common metacharacters include **.** , ***** , **+** , **?** , **^** , **$** ,
    **[]** , **{n}** , **{n, m}** , **{n,}** , **(a|b)** , and **=~** .'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式字母表由**字符**和**元字符**组成。字符就是你想要在文本中查找的字母、数字和符号。另一方面，元字符是正则表达式的特殊“魔法”。它们是具有特殊含义的符号，帮助定义模式。一些常见的元字符包括**.**、*****、**+**、**?**、**^**、**$**、**[]**、**{n}**、**{n,m}**、**{n,}**、**(a|b)**和**=~**。
- en: In this section, I’ll be showing examples using the **grep** command. The **grep**
    command searches for patterns in files or piped input. You can learn more about
    **grep** by entering the **man** **grep** command.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我将展示使用**grep**命令的示例。**grep**命令用于在文件或管道输入中搜索模式。你可以通过输入**man grep**命令来了解更多关于**grep**的信息。
- en: 'The period ( **.** ) metacharacter matches any single character except newline,
    which is the end of a line and is represented by **\n** . One of the common ways
    I use **.** in regex is when parsing the output of a program and I want to eliminate
    blank lines. Just as **.** matches any character, when used by itself in a regex,
    its use removes any blank lines since there’s nothing to match. The following
    figure demonstrates that **.** matches any character. The matched text is highlighted
    in red font:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 句点（**.**）元字符匹配除了换行符以外的任何单个字符，换行符表示为**\n**。我在正则表达式中常用**.**的一个例子是，当解析程序的输出并且想要去除空白行时。正如**.**匹配任何字符，当它单独使用时，它会移除所有空白行，因为没有任何内容可以匹配。下图展示了**.**匹配任何字符的情况，匹配的文本以红色字体突出显示：
- en: '![Figure 4.1 – Matching non-blank lines using the period metacharacter](image/B22229_04_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 使用句点元字符匹配非空行](image/B22229_04_1.jpg)'
- en: Figure 4.1 – Matching non-blank lines using the period metacharacter
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 使用句点元字符匹配非空行
- en: As you can see, not only does the **.** metacharacter match any character (highlighted
    in red), but it also helps us to match only lines that aren’t blank.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**.** 元字符不仅匹配任何字符（以红色高亮显示），它还帮助我们仅匹配非空行。
- en: 'The asterisk ( ***** ) metacharacter matches zero or more occurrences of the
    preceding element. Imagine that you have a text file named **sample.txt** with
    various lines of text, and you’re interested in finding lines that match the **ho*p**
    pattern. The pattern should match lines with **hop** , **hoop** , **hooooop**
    , and so on. The content of the **sample.txt** file is shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（*****）元字符匹配前一个元素出现零次或多次。假设你有一个名为**sample.txt**的文本文件，里面包含多行文本，你想要查找匹配**ho*p**模式的行。这个模式应该匹配**hop**、**hoop**、**hooooop**等行。**sample.txt**文件的内容如下所示：
- en: '![Figure 4.2 – The content of the sample.txt file](image/B22229_04_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – sample.txt 文件的内容](image/B22229_04_2.jpg)'
- en: Figure 4.2 – The content of the sample.txt file
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – sample.txt 文件的内容
- en: Tip
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You must use the **grep** command with the **-E** option for extended regex,
    which allows you to use the ***** metacharacter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用带有**-E**选项的**grep**命令来进行扩展正则表达式，这样你才能使用*****元字符。
- en: 'This command tells **grep** to search within **sample.txt** for lines that
    match the **ho*p** pattern: **grep -E ''ho*p'' sample.txt** . The **-E** option
    is used to enable extended regex, which includes support for the ***** metacharacter,
    among other features. Otherwise, outside of a regex, ***** is called a **glob**
    character, as discussed in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034) .'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉**grep**在**sample.txt**中搜索匹配**ho*p**模式的行：**grep -E 'ho*p' sample.txt**。**-E**选项用于启用扩展正则表达式，支持包括*****元字符在内的多种功能。否则，外部正则表达式中，*****被称为**glob**字符，正如在[*第2章*](B22229_02.xhtml#_idTextAnchor034)中讨论的那样。
- en: 'The plus ( **+** ) metacharacter matches one or more occurrences of the preceding
    element. For example, if you’re analyzing log files for errors, a pattern such
    as **Error: +** could help you find lines where **Error:** is followed by one
    or more spaces, indicating the start of an error message. Without the **+** metacharacter,
    you’d either miss cases with multiple spaces or waste time sifting through irrelevant
    data.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '加号（**+**）元字符匹配前一个元素出现一次或多次。例如，如果你正在分析日志文件中的错误，可以使用**Error: +**模式帮助你找到**Error:**后跟一个或多个空格的行，表示错误信息的开始。如果没有**+**元字符，你就会错过多个空格的情况，或者浪费时间筛选无关的数据。'
- en: The question ( **?** ) metacharacter makes the preceding element optional. At
    its core, the **?** metacharacter represents optionality. It tells the regex engine
    to match the preceding element zero or one time. Simply put, it means that the
    character or pattern right before **?** might be there, but it’s OK if it’s not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 问号（**?**）元字符使得前面的元素变为可选。**?**元字符的核心含义是可选性。它告诉正则表达式引擎匹配前面的元素零次或一次。简单来说，它意味着紧跟在**?**前面的字符或模式可能出现，也可以不出现。
- en: This concept is easier to grasp with an example. Imagine that you’re tasked
    with processing log files. These logs follow a naming convention such as **app-log-2024.txt**
    , but sometimes, they include an extra identifier, such as **app-log-2024-debug.txt**
    . Using the **?** metacharacter allows your script to be more flexible. A pattern
    such as **app-log-2024(-debug)?.txt** can match both filenames, ensuring your
    script works seamlessly across different log types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念通过一个示例更容易理解。假设你需要处理日志文件。这些日志遵循如**app-log-2024.txt**这样的命名规范，但有时它们会包含一个额外的标识符，如**app-log-2024-debug.txt**。使用**?**元字符可以让你的脚本更加灵活。像**app-log-2024(-debug)?.txt**这样的模式就可以匹配这两个文件名，确保你的脚本在不同日志类型间无缝工作。
- en: The caret ( **^** ) metacharacter matches the start of a line. You might be
    wondering why you’d need to specify that something should be at the beginning
    of a line. It’s all about precision. In this example, if we didn’t use the **^**
    metacharacter and searched for **DONE** alone, we’d get any line containing **DONE**
    anywhere in the text – not just at the beginning. This could include lines where
    **DONE** appears in a note or reminder, not just as a task status marker.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 插入符号（**^**）元字符匹配行首。你可能会想，为什么需要指定某个内容必须出现在行的开头？这完全是为了精确。在这个例子中，如果我们不使用**^**元字符，仅仅搜索**DONE**，我们会得到文本中任何包含**DONE**的行——而不仅仅是行首的部分。这可能包括**DONE**出现在便签或提醒中的行，而不仅仅是任务状态标记。
- en: The dollar ( **$** ) metacharacter matches the end of a line.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号（**$**）元字符匹配行尾。
- en: 'The following is an example of matching using **$** :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用**$**匹配的示例：
- en: '![Figure 4.3 – Matching the end of a string using the $ metacharacter](image/B22229_04_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 使用$元字符匹配字符串的结尾](image/B22229_04_3.jpg)'
- en: Figure 4.3 – Matching the end of a string using the $ metacharacter
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 使用$元字符匹配字符串的结尾
- en: Bracket expressions ( **[ ]** ) match any single character within the brackets.
    You can perform a logical **NOT** expression by making the **^** symbol the first
    character in the list. That would result in matching characters that are not on
    the list. For example, if you wanted to match vowel characters, an appropriate
    bracket expression would be **[aeiou]** , whereas if you wanted to match consonants,
    you could use **[^aeiou]** .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 括号表达式（**[ ]**）匹配括号内的任何单个字符。你可以通过将**^**符号放在列表的第一个字符位置来执行逻辑**非**表达式。这样会匹配列表中不包含的字符。例如，如果你想匹配元音字符，适当的括号表达式是**[aeiou]**，而如果你想匹配辅音字符，可以使用**[^aeiou]**。
- en: 'Range expressions are frequently used inside bracket expressions to save you
    the time and effort of typing all subsequent characters or numbers in a range.
    For example, instead of typing the letters *a* through *z* inside brackets, you
    can use **[a-z]** as a handy shortcut. Similarly, for numbers, you can use a range
    such as **[1-10]** . The following figure demonstrates how bracket expressions
    work:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 范围表达式经常在括号表达式内使用，节省你输入所有后续字符或数字的时间和精力。例如，代替在括号内输入从*a*到*z*的字母，你可以使用**[a-z]**作为便捷的快捷方式。同样，对于数字，你可以使用类似**[1-10]**的范围。下图展示了括号表达式的工作原理：
- en: '![Figure 4.4 – Examples of using bracket expressions](image/B22229_04_4.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 使用括号表达式的示例](image/B22229_04_4.jpg)'
- en: Figure 4.4 – Examples of using bracket expressions
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 使用括号表达式的示例
- en: Bracket expressions are a valuable, time-saving regex feature!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 括号表达式是一个非常有价值且节省时间的正则表达式功能！
- en: 'The **{n}** metacharacter specifies that the preceding element is matched exactly
    *n* times. It can also be written as **{n, m}** or **{n,}** , meaning the preceding
    element is matched between **n** and **n** times, or is matched exactly **n**
    or more times, respectively. Let’s look at how this can be used:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**{n}**元字符指定前面的元素恰好匹配*n*次。它也可以写作**{n, m}** 或 **{n,}**，表示前面的元素匹配**n**到**m**次，或者恰好匹配**n**次或更多次。我们来看一下如何使用这个：'
- en: '![Figure 4.5 – An example showing how to match n or more times](image/B22229_04_5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 一个展示如何匹配n次或更多次的示例](image/B22229_04_5.jpg)'
- en: Figure 4.5 – An example showing how to match n or more times
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 一个示例，展示如何匹配n次或更多次
- en: The preceding figure shows that I specified that it must match **3** or more
    times for the **o** character. The word **hoooop** was the only match. Note that
    I had to include the **-E** argument in **grep** to enable extended regex capability,
    and had to escape the brackets with a backslash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示显示了我指定必须匹配**3**次或更多次字符**o**。单词**hoooop**是唯一的匹配项。请注意，我在**grep**中必须包含**-E**参数，以启用扩展正则表达式功能，并且必须使用反斜杠转义方括号。
- en: The **(a|b)** metacharacter matches either **a** or **b** .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**(a|b)** 元字符匹配**a**或**b**。'
- en: 'The **=~** match operator is typically used inside scripts. Let’s discuss the
    basic example shown in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**=~** 匹配操作符通常用于脚本中。让我们讨论下图所示的基本示例：'
- en: '![Figure 4.6 – An example demonstrating the match operator](image/B22229_04_6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 演示匹配操作符的示例](image/B22229_04_6.jpg)'
- en: Figure 4.6 – An example demonstrating the match operator
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 演示匹配操作符的示例
- en: If the string on the left-hand side of the **=~** operator matches the regex
    on the right, the expression evaluates to **true** , and the exit status of the
    **[[ ]]** bracket expression is 0 (zero). In Bash shell scripting, an exit status
    of 0 signifies success or **true** . An exit value of anything other than 0 signifies
    failure or **false** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧的字符串与右侧的正则表达式匹配，表达式的值为**true**，并且**[[ ]]**括号表达式的退出状态为0（零）。在Bash脚本中，退出状态为0表示成功或**true**，任何非0的退出值表示失败或**false**。
- en: In Bash scripting, **&&** and **||** are **logical operators** that are used
    within conditional expressions to combine multiple commands or conditions. Their
    usage is tied to the exit status of commands. Applied to the previous figure,
    if the match pattern finds a match on the input expression, it results in an exit
    status of 0, or true. If the string doesn’t match the regex, the expression evaluates
    to false, and the exit status of the **[[ ]]** expression is 1 (an exit status
    of 1 signifies failure or false). The **&&** operator passes the exit status to
    the following **||** expression, which can be thought of as **true** or **false**
    . If the expression was true, the statement on the left, **echo Match found!**
    , is executed. If false, the statement on the right, **echo "No match"** , is
    executed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash脚本中，**&&** 和 **||** 是**逻辑操作符**，用于条件表达式中组合多个命令或条件。它们的使用与命令的退出状态相关。应用到前面的示例中，如果匹配模式找到了输入表达式的匹配项，结果将是退出状态0，或为true。如果字符串与正则表达式不匹配，表达式值为false，**[[
    ]]**表达式的退出状态为1（退出状态1表示失败或false）。**&&** 操作符将退出状态传递给后续的**||**表达式，可以认为是**true** 或
    **false**。如果表达式为true，左侧的语句 **echo Match found!** 将被执行。如果为false，右侧的语句 **echo "No
    match"** 将被执行。
- en: Now that you’re familiar with metacharacters, let’s explore **character classes**
    , which provide handy shortcuts when using the bracket expressions we just covered.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了元字符，接下来让我们探索**字符类**，它们在使用我们刚刚介绍的括号表达式时提供了方便的快捷方式。
- en: Using character classes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字符类
- en: 'When used inside bracket expressions, character classes are a handy shortcut
    that simplifies regex:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号表达式中使用时，字符类是一个方便的快捷方式，可以简化正则表达式：
- en: '**[:alpha:]** : Alphabet characters'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:alpha:]** : 字母字符'
- en: '**[:alnum:]** : Alphanumeric characters'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:alnum:]** : 字母数字字符'
- en: '**[:digit:]** : The numbers 0 through 9'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:digit:]** : 数字 0 到 9'
- en: '**[:blank:]** : Spaces and tabs'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:blank:]** : 空格和制表符'
- en: '**[:cntrl:]** : Control characters'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:cntrl:]** : 控制字符'
- en: '**[:lower:]** : Lowercase letters'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:lower:]** : 小写字母'
- en: '**[:upper:]** : Uppercase letters'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:upper:]** : 大写字母'
- en: '**[:punct:]** : Punctuation characters'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:punct:]** : 标点符号'
- en: '**[:space:]** : Space characters, including space, tab, newline, vertical tab,
    form feed, and carriage return'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[:space:]** : 空格字符，包括空格、制表符、换行符、垂直制表符、换页符和回车符'
- en: Tip
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Character classes must be enclosed inside bracket expressions – for example,
    **[[:alpha:]]** .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类必须包含在括号表达式中——例如，**[[:alpha:]]**。
- en: Character classes are a time-saving shorthand that greatly simplifies the process
    of creating regex.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类是一种节省时间的简写方法，极大简化了创建正则表达式的过程。
- en: Flags – modifying your search
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志 – 修改你的搜索
- en: 'Regex allows you to modify your search with flags. These are usually single
    letters that change how the regex engine interprets your pattern. Here are some
    examples:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式允许你通过标志修改搜索方式。这些通常是单个字母，改变正则引擎如何解释你的模式。以下是一些例子：
- en: '**i** : Makes the search case-insensitive'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i** : 使搜索不区分大小写'
- en: '**g** : Performs a global search (finds all matches rather than stopping after
    the first match)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**g** ：执行全局搜索（找到所有匹配项，而不是在第一次匹配后停止）'
- en: '**m** : Multiline mode (changes the behavior of **^** and **$** to match the
    start and end of lines rather than the whole string)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**m** ：多行模式（改变 **^** 和 **$** 的行为，使其匹配行的开始和结束，而不是整个字符串）'
- en: This is not an exhaustive list. See [https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html)
    for more information. These flags can be used alone or in combination, depending
    on the requirements of the regex operation. The way to apply these flags varies
    slightly between tools, but they are usually appended to the regex pattern. Since
    their use is tool-dependent, I’ll show you examples of how they can be used when
    I present practical examples later in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽无遗的列表。更多信息请参见 [https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html)。这些标志可以单独使用，也可以组合使用，具体取决于正则表达式操作的需求。这些标志的应用方式在不同工具间略有不同，但通常是附加到正则表达式模式中的。由于它们的使用依赖于工具，稍后我在本章的实际示例中会展示它们如何使用。
- en: Now that you understand the basics of regex, let’s review some examples showing
    how they work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了正则表达式的基础，接下来让我们回顾一些示例，展示它们是如何工作的。
- en: Applying basic regex examples
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用基础正则表达式示例
- en: 'This example simply uses **grep** to match on the letter **t** . By default,
    **grep** performs a global search. Therefore, the **g** flag isn’t necessary:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例仅使用 **grep** 来匹配字母 **t**。默认情况下，**grep** 执行全局搜索。因此，**g** 标志不是必需的：
- en: '![Figure 4.7 – A basic grep on the t character](image/B22229_04_7.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 对 t 字符的基本 grep](image/B22229_04_7.jpg)'
- en: Figure 4.7 – A basic grep on the t character
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 对 t 字符的基本 grep
- en: 'This example matches all vowels:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例匹配所有元音：
- en: '![Figure 4.8 – A pattern that matches all vowels](image/B22229_04_8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 匹配所有元音的模式](image/B22229_04_8.jpg)'
- en: Figure 4.8 – A pattern that matches all vowels
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 匹配所有元音的模式
- en: 'This example matches all consonants. Remember that the **^** symbol takes on
    a different meaning inside of brackets. This essentially means that it matches
    any character not in the list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例匹配所有辅音。记住，**^** 符号在括号内有不同的含义。这实际上意味着它匹配列表中不包含的任何字符：
- en: '![Figure 4.9 – A pattern that matches all consonants](image/B22229_04_9.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 匹配所有辅音的模式](image/B22229_04_9.jpg)'
- en: Figure 4.9 – A pattern that matches all consonants
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 匹配所有辅音的模式
- en: Now, I’ll show you a slightly more advanced example. Can you spot the difference
    between the following two examples?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将展示一个稍微复杂一点的示例。你能发现下面两个示例之间的区别吗？
- en: '![Figure 4.10 – Two patterns used to demonstrate a subtle difference](image/B22229_04_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 用于演示微妙差异的两种模式](image/B22229_04_10.jpg)'
- en: Figure 4.10 – Two patterns used to demonstrate a subtle difference
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 用于演示微妙差异的两种模式
- en: The first pattern matches **t** followed by zero or more characters that are
    not **w** . It’s important to note that ***** applies to the **[^w]** part of
    the pattern, allowing for any sequence of characters that does not start with
    **w** immediately following **t** . Therefore, it matches everything, including
    the spaces, starting with **t** in **told** , and continues through the end of
    the input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式匹配 **t** 后跟零个或多个不是 **w** 的字符。重要的是要注意，***** 适用于模式的 **[^w]** 部分，允许任何不以 **w**
    开头的字符序列紧跟在 **t** 后面。因此，它匹配所有内容，包括 **told** 中的空格，并一直匹配到输入的末尾。
- en: The second pattern specifically looks for **t** followed by a single character
    that is not **w** , and then zero or more alphabetic characters. The inclusion
    of **[[:alpha:]]*** after **[^w]** means that after finding **t** followed by
    any non- **w** character, it matches only if the following characters are alphabetic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式专门寻找 **t** 后跟一个不是 **w** 的字符，然后是零个或多个字母字符。在 **[^w]** 后包含 **[[:alpha:]]***
    表示在找到 **t** 后跟任何非 **w** 字符时，只有当后续字符是字母时，才匹配。
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The examples in *Figure 4* *.10* show a backslash character escaping the asterisk.
    A small number of characters have special meaning. The following characters must
    be escaped with a backslash: **[\^$.|?*+()** .'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4* *.10* 中的示例展示了反斜杠字符用于转义星号。少数几个字符具有特殊意义。以下字符必须使用反斜杠进行转义：**[\^$.|?*+()**。'
- en: Now that you understand the basics, let’s get a taste of some advanced regex
    concepts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了基础知识，让我们来体验一些高级正则表达式概念。
- en: Advanced regex patterns and techniques
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级正则表达式模式和技巧
- en: In regex, using **capture groups** is like putting a part of your pattern into
    a box. Everything inside this box is treated as a single unit. You can apply quantifiers
    to it, look for repetitions, or even extract information from it. In Bash, you
    use parentheses, **()** , to create these groups.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，使用**捕获分组**就像是将模式的一部分放入一个框中。框内的所有内容都被视为一个单元。你可以对其应用量词，查找重复项，甚至提取其中的信息。在Bash中，你使用圆括号**()**来创建这些分组。
- en: '**Grouping** isn’t just about treating parts of your pattern as a single unit;
    it’s also about capturing information. When you group part of a regex pattern,
    Bash remembers what text matched that part of the pattern. This is incredibly
    useful for extracting information from strings.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**分组**不仅仅是将模式的部分视为一个单元；它还涉及到捕获信息。当你将正则表达式的一部分分组时，Bash会记住与该部分模式匹配的文本。这对于从字符串中提取信息非常有用。'
- en: 'Let’s say you’re working with log files and you want to extract timestamps.
    Your log lines might look something like this: **2023-04-01 12:00:00 Error: Something
    went wrong.** A regex pattern to match the timestamp could be **(\d{4}-\d{2}-\d{2}
    \d{2}:\d{2}:\d{2})** . Here, **\d** matches any digit, and **{n}** specifies how
    many times that element should repeat. The entire timestamp pattern is grouped,
    so you can extract it from the string easily.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理日志文件，并希望提取时间戳。你的日志行可能看起来像这样：**2023-04-01 12:00:00 错误：出现问题**。匹配时间戳的正则表达式模式可能是**(\d{4}-\d{2}-\d{2}
    \d{2}:\d{2}:\d{2})**。在这里，**\d**匹配任何数字，而**{n}**指定该元素应重复的次数。整个时间戳模式是分组的，因此你可以轻松地从字符串中提取出来。
- en: Let’s look at some practical examples to help you solidify your understanding
    of capture groups.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实际例子，帮助你巩固对捕获分组的理解。
- en: Practical example – extracting data using regex
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例——使用正则表达式提取数据
- en: 'Imagine you’re tasked with extracting usernames and their corresponding email
    addresses from a list. The list looks something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要从列表中提取用户名及其对应的电子邮件地址。列表看起来像这样：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You could use the following regex pattern to match and extract the usernames
    and email addresses:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下正则表达式模式来匹配并提取用户名和电子邮件地址：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, **[a-zA-Z0-9_]+** matches one or more alphanumeric characters or underscores
    (the username), and **[a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+** matches the email addresses.
    By grouping them, you can extract both the username and the email address separately.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**[a-zA-Z0-9_]+**匹配一个或多个字母数字字符或下划线（用户名），而**[a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+**匹配电子邮件地址。通过对它们进行分组，你可以分别提取用户名和电子邮件地址。
- en: For example, let’s say you have **I love apples and I love oranges** as a string
    and you want to find every instance of **I love** . In regex, you could write
    this pattern as **(I love)** . This tells Bash to treat **I love** as a single
    unit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有字符串**I love apples and I love oranges**，并且你想找到每个**I love**的实例。在正则表达式中，你可以写出这个模式：**(I
    love)**。这告诉Bash将**I love**视为一个单元。
- en: Regex grouping in Bash might seem complex at first glance, but once you understand
    the basics, it opens up a world of possibilities for string manipulation and data
    extraction. By breaking down patterns into manageable groups, you can simplify
    your scripts and make them more efficient. Remember, practice makes perfect. Start
    experimenting with regex grouping in your Bash scripts, and you’ll soon wonder
    how you ever managed without it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中使用正则表达式分组一开始可能显得复杂，但一旦你理解了基础，它会为字符串处理和数据提取打开一扇新的大门。通过将模式分解为可管理的组，你可以简化脚本并提高效率。记住，实践出真知。开始在Bash脚本中尝试正则表达式分组，你很快就会发现它的重要性。
- en: Next, we’ll expand on regex grouping by showing you how to use alternations
    to make your capture groups more powerful and flexible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过展示如何使用选择扩展正则表达式分组，使你的捕获分组更强大、更灵活。
- en: Utilizing alternations
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择
- en: Regex **alternation** is represented by the pipe symbol ( **|** ), which functions
    similarly to a logical OR. It allows you to specify multiple patterns within the
    same regex, offering a way to match one thing or another. Think of it as telling
    your script, “Hey, if you see this or that, consider it a match.”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的**选择**通过管道符号（**|**）表示，它的功能类似于逻辑“或”。它允许你在同一个正则表达式中指定多个模式，从而提供匹配某个或另一个内容的方式。可以将其理解为告诉你的脚本：“嘿，如果你看到这个或那个，认为它是匹配的。”
- en: 'Let’s say you’re writing a script that needs to process files with specific
    extensions. You’re interested in **.txt** and **.log** files but want to handle
    them using a single regex. Here’s how you could do it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个需要处理特定扩展名文件的脚本。你对**.txt**和**.log**文件感兴趣，但希望通过一个正则表达式来处理它们。你可以这样做：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example code can be found in the **ch04_regex_01.sh** file in this chapter’s
    folder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的**ch04_regex_01.sh**文件中找到。
- en: 'Running this example provides the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例会产生以下输出：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, **(txt|log\)$** is the regex pattern. The pipe symbol, **|**
    , separates the two alternatives, **txt** and **log** , while the backslashes,
    **\** , are used to escape characters that have special meanings in regex. The
    dollar sign, **$** , ensures that the pattern matches the end of the string, preventing
    false positives on files such as **example.txt.bak** .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，**(txt|log\)$**是正则表达式模式。管道符号**|**将两个选择项**txt**和**log**分隔开，而反斜杠**\**用于转义那些在正则表达式中有特殊意义的字符。美元符号**$**确保该模式匹配字符串的结尾，防止像**example.txt.bak**这样的文件出现误匹配。
- en: You might be wondering why bother with alternation when you could just write
    separate conditions for each case. The answer lies in simplicity and efficiency.
    Using alternation, you can consolidate multiple conditions into a single line
    of code, making your scripts cleaner and easier to maintain.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么要使用交替（alternation），而不直接为每个情况编写独立的条件？答案在于简洁性和效率。使用交替，你可以将多个条件合并成一行代码，使你的脚本更加简洁，便于维护。
- en: In scenarios where you’re matching against a long list of possibilities, alternation
    can significantly reduce the complexity of your code. Instead of having an unwieldy
    series of **if** statements or a cumbersome **case** statement, you can list all
    your options in one place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要匹配大量可能性时，交替可以显著减少代码的复杂性。与其拥有冗长的**if**语句或笨重的**case**语句，你可以将所有的选项列在一处。
- en: 'While alternation is powerful, it’s essential to use it wisely to avoid pitfalls.
    Here are a couple of tips to keep in mind:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然交替非常强大，但必须明智使用，以避免陷入误区。这里有一些提示供你参考：
- en: '**Be specific** : Regex patterns can sometimes match more than you intend.
    To prevent unexpected behavior, make your patterns as specific as possible.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体一点**：正则表达式模式有时可能会匹配到超出你预期的内容。为了避免意外行为，请尽量使你的模式尽可能具体。'
- en: '**Testing** : Always test your regex patterns with various inputs to ensure
    they behave as expected. Tools such as **grep** and online regex testers ( [https://regex101.com](https://regex101.com)
    ) can be invaluable for this.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：始终使用不同的输入测试你的正则表达式模式，以确保它们按预期行为运行。像**grep**这样的工具和在线正则表达式测试工具（[https://regex101.com](https://regex101.com)）对于此类测试非常有帮助。'
- en: Regex alternations in Bash scripting are like having a secret weapon in your
    arsenal. They allow you to write more concise, readable, and maintainable code
    by simplifying complex pattern-matching logic. Whether you’re a seasoned scripter
    or just starting, mastering alternations will undoubtedly make your scripting
    journey smoother and more enjoyable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 脚本中，正则表达式的交替（alternation）就像是你武器库中的一件秘密武器。它可以通过简化复杂的模式匹配逻辑，帮助你编写更加简洁、易读且易维护的代码。无论你是经验丰富的脚本编写者，还是刚刚入门，新掌握交替用法无疑会让你的脚本编写过程更加顺畅和愉快。
- en: Remember, the key to effective scripting is not just knowing what tools are
    available but understanding how to use them wisely. With regex alternations, you’re
    well-equipped to tackle a wide range of string-matching challenges.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，编写有效脚本的关键不仅仅是知道有哪些工具可用，更重要的是理解如何明智地使用它们。使用正则表达式交替，你将能够应对各种字符串匹配的挑战。
- en: Now that you have a good grasp of how regex works, let’s explore some practical
    regex applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对正则表达式的工作原理有了不错的掌握，我们来探索一些实际的正则表达式应用。
- en: Demonstrating practical applications
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示实际应用
- en: 'Here, I’m using various variables and arrays that were introduced in previous
    chapters. Let’s put this into practice with the following Bash script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了前面章节中介绍的各种变量和数组。让我们通过以下 Bash 脚本来实践一下：
- en: '![Figure 4.11 – Introducing BASH_REMATCH in a practical application](image/B22229_04_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 在实际应用中引入 BASH_REMATCH](image/B22229_04_11.jpg)'
- en: Figure 4.11 – Introducing BASH_REMATCH in a practical application
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 在实际应用中引入 BASH_REMATCH
- en: This example code can be found in the **ch04_regex_02.sh** file in this chapter’s
    folder. In this script, I declared the **user_list** variable on *line 3* . On
    *line 6* , I declared the **pattern** variable. On *line 8* , I started a **while**
    loop that reads each line of data from the **$** **user_list** variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch04_regex_02.sh** 文件中找到。在这个脚本中，我在 *第 3 行* 声明了 **user_list**
    变量。在 *第 6 行*，我声明了 **pattern** 变量。在 *第 8 行*，我启动了一个 **while** 循环，读取来自 **$** **user_list**
    变量的每一行数据。
- en: On *line 9* , I used the match operator, **=~** , to compare each line **($line**
    ) against our regex pattern ( **$pattern** ). These are referred to by the **$line**
    and **$pattern** variables, which are declared. When you use the match operator,
    the string on the left (represented by the **$line** variable) is matched against
    the regex pattern on the right. If the pattern matches, the expression returns
    true (0); otherwise, it returns false (1).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 行*，我使用了匹配操作符 **=~**，将每一行 **($line)** 与我们的正则表达式模式 (**$pattern**) 进行比较。这些通过
    **$line** 和 **$pattern** 变量引用，它们已经声明。使用匹配操作符时，左侧的字符串（由 **$line** 变量表示）将与右侧的正则表达式模式匹配。如果模式匹配，表达式返回
    true（0）；否则，返回 false（1）。
- en: 'First, the pattern captures a username using the relevant capture group: **([a-zA-Z0-9_]+)**
    . Remember, a capture group consists of parenthesis, **()** , surrounding a regex.
    Inside the capture group, we have a bracket expression that will match all alphanumeric
    characters, plus an underscore to match usernames. The second capture group matches
    an email address.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，模式通过相关的捕获组捕获用户名：**([a-zA-Z0-9_]+)**。记住，捕获组由圆括号**()**围绕一个正则表达式组成。在捕获组内，我们有一个字符集表达式，它将匹配所有字母数字字符，并加上下划线以匹配用户名。第二个捕获组匹配一个电子邮件地址。
- en: 'If a line matches, Bash populates an array called **BASH_REMATCH** with the
    captured groups. Here, **BASH_REMATCH[1]** contains the first captured group (the
    username), and **BASH_REMATCH[2]** contains the second group (the email address).
    Then, we print these out:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某一行匹配，Bash 会将捕获的组填充到一个名为 **BASH_REMATCH** 的数组中。在这里，**BASH_REMATCH[1]** 包含第一个捕获组（用户名），而
    **BASH_REMATCH[2]** 包含第二个组（电子邮件地址）。然后，我们将它们打印出来：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Did you spot where I could have made the capture groups easier to read and write?
    The first capture group, **([a-zA-Z0-9_]+)** , could have been simplified to **([[:alnum:]_]+)**
    , and the second capture group, **([a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+)** , could have
    been simplified to **([[alnum]_.]+@[[:alnum:]_.]+)** .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现我在哪儿可以使捕获组更容易阅读和编写吗？第一个捕获组 **([a-zA-Z0-9_]+)** 可以简化为 **([[:alnum:]_]+)**，而第二个捕获组
    **([a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+)** 可以简化为 **([[alnum]_.]+@[[:alnum:]_.]+)**。
- en: Matching IP addresses with grep
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 grep 匹配 IP 地址
- en: In this example, we’re going to look at a practical case involving a port scan
    to locate IP addresses with specific ports open. This is a common pentest task
    that is frequently used to produce a list of hosts to use with subsequent targeted
    scans, or for producing a list of affected hosts for a pentest finding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看一个实际的案例，涉及端口扫描以定位特定端口开放的 IP 地址。这是一个常见的渗透测试任务，通常用于生成主机列表，以便进行后续的目标扫描，或生成受影响主机的列表，用于渗透测试结果。
- en: 'Since this involves scanning your local network, make sure you have permission
    to scan the network if you don’t own it. I’ve included a sample Nmap scan file
    from my lab for your convenience in this book’s GitHub repository: **test_nmap.gnmap**
    .'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这涉及到扫描你的本地网络，确保你有权限扫描网络，如果你不拥有该网络。我已在本书的 GitHub 仓库中为方便起见，提供了一个来自我实验室的示例 Nmap
    扫描文件：**test_nmap.gnmap**。
- en: 'Use the following Nmap command to scan the network, replacing the network address
    with one applicable to your network address:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 Nmap 命令扫描网络，将网络地址替换为适合你网络的地址：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The scan command’s options specify greppable output, **-oG** , the output filename,
    **test_nmap.gnmap** , followed by the network address.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描命令的选项指定了可以用来过滤的输出 **-oG**，输出文件名为 **test_nmap.gnmap**，后面跟着网络地址。
- en: 'In my scan, one line of the scan that’s output from the **test_nmap.gnmap**
    file looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的扫描中，从 **test_nmap.gnmap** 文件输出的一行扫描结果如下所示：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we want to identify any host IP addresses with open **http** or **https**
    service ports. Execute the following command in the same directory as the **test_nmap.gnmap**
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要识别任何主机 IP 地址，其上开放了 **http** 或 **https** 服务端口。在与 **test_nmap.gnmap**
    文件位于同一目录下执行以下命令：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example code can be found in the **ch04_regex_03.sh** file in this chapter’s
    folder.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch04_regex_03.sh** 文件中找到。
- en: 'The preceding command uses **grep** to search for a regex of the literal (no
    metacharacters) text, **/open/tcp//http** . The output of that command is the
    full line of text of every line that includes that string. The pipe character,
    **|** , simply connects the output ( **stdout** ) of the first process with the
    input ( **stdin** ) of the next process. Then, the **-oE** arguments are provided
    with the **grep** command. The **-o** option means to output only the matching
    text instead of the full line, and the **-E** option enables the extended regex
    feature. Finally, the regex pattern for an IP address ends the command. The following
    output is produced by this command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用 **grep** 来搜索文字的正则表达式（没有元字符），**/open/tcp//http** 。该命令的输出是每一行包含该字符串的完整文本行。管道字符
    **|** 只是将第一个进程的输出 (**stdout**) 与下一个进程的输入 (**stdin**) 连接起来。然后，**-oE** 参数与 **grep**
    命令一起提供。**-o** 选项意味着只输出匹配的文本，而不是整行文本，**-E** 选项启用扩展正则表达式功能。最后，命令的末尾是一个用于匹配 IP 地址的正则表达式模式。该命令产生以下输出：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pipe character’s use to redirect output to the input of another process
    is a powerful feature that we’ll be using frequently in later chapters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 管道字符用于将输出重定向到另一个进程的输入，这是一个强大的功能，我们将在后面的章节中频繁使用。
- en: Using handy grep flags
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方便的 grep 标志
- en: While these **grep** flags are pretty simple, they’re also very handy. I use
    them frequently and want to share them with you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些 **grep** 标志非常简单，但它们也非常方便。我经常使用它们，并希望与大家分享。
- en: Something that I frequently do on internal network pentest is use any credentials
    that I’ve obtained to enumerate file shares that can be accessed with those credentials.
    In this example, I’m using NetExec to check for SMB file shares that are accessible
    with the credentials I have. You can find NetExec at [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)
    .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部网络渗透测试中，我经常做的一件事是使用我获得的任何凭证来枚举可以使用这些凭证访问的文件共享。在这个示例中，我使用 NetExec 来检查可以使用我拥有的凭证访问的
    SMB 文件共享。你可以在 [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)
    找到 NetExec。
- en: 'The following figure shows the output of a NetExec SMB file share enumeration
    scan:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 NetExec SMB 文件共享枚举扫描的输出：
- en: '![Figure 4.12 – NetExec SMB share enumeration scan](image/B22229_04_12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – NetExec SMB共享枚举扫描](image/B22229_04_12.jpg)'
- en: Figure 4.12 – NetExec SMB share enumeration scan
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – NetExec SMB共享枚举扫描
- en: The scan output was saved to a file, **nxc.log** . Let’s imagine that I’ve run
    this scan on a large network with hundreds or even thousands of hosts and I want
    to focus on finding those shares where I can either read or write to the share,
    but I don’t want to see any of the **IPC$** or **PRINT$** shares.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描结果已保存到文件 **nxc.log** 。假设我在一个包含数百甚至上千个主机的大型网络上运行了此扫描，并且我希望专注于寻找那些我可以读取或写入的共享，但我不想看到任何
    **IPC$** 或 **PRINT$** 共享。
- en: 'While there are regex patterns that could reasonably work here to match a combination
    of **READ** / **WRITE** , we want to keep this simple so that we don’t have to
    refer to our notes. The following command can accomplish this goal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有正则表达式模式可以合理地在这里匹配 **READ** / **WRITE** 的组合，但我们希望保持简单，以免频繁查阅笔记。以下命令可以完成这个目标：
- en: '![Figure 4.13 – Our grep flags simplify the task](image/B22229_04_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 我们的 grep 标志简化了任务](image/B22229_04_13.jpg)'
- en: Figure 4.13 – Our grep flags simplify the task
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 我们的 grep 标志简化了任务
- en: 'This example code can be found in the **ch04_regex_04.sh** file in this chapter’s
    folder. Let’s break down the sequence of commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例代码可以在本章文件夹中的 **ch04_regex_04.sh** 文件中找到。让我们分解一下这些命令的顺序：
- en: '**cat nxc.log** : This prints the output of the **nxc.log** file.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cat nxc.log** ：此命令打印 **nxc.log** 文件的输出。'
- en: '**|** : This connects the output of the **cat** command to the input of the
    **grep** command.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**|** ：这将 **cat** 命令的输出连接到 **grep** 命令的输入。'
- en: '**grep -e READ -e WRITE** : The **grep** **-e** flag specifies a pattern. More
    than one pattern can be used if you include additional **-e** flags. This will
    match if either or both of the words are found.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**grep -e READ -e WRITE** ：**grep** **-e** 标志指定一个模式。如果你包含额外的 **-e** 标志，可以使用多个模式。如果找到任一或两个单词，这将匹配成功。'
- en: '**grep -v …** : The **grep** **-v** flag means invert the match. This is similar
    to a logical **NOT** expression. In other words, filter out anything that matches
    this expression.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**grep -v …** ：**grep** **-v** 标志表示反转匹配。这类似于逻辑 **NOT** 表达式。换句话说，过滤掉任何与此表达式匹配的内容。'
- en: You will use these patterns frequently in your pentest career.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的渗透测试生涯中，你将经常使用这些模式。
- en: Redacting IP addresses
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏蔽 IP 地址
- en: While the following example demonstrates redacting IP addresses using the **sed**
    (stream editor) command, it can be adapted to other cases of mass editing text
    in a file or input stream.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 **sed**（流编辑器）命令编辑 IP 地址，但它也可以用于文件或输入流中的其他批量文本编辑。
- en: 'Let’s imagine that you want to redact the IP addresses in the **test_nmap.gnmap**
    file before you share it with someone. Again, we’ll use the regex for an IP address.
    However, this time, we’ll pipe the output to **sed** and redact all IP addresses.
    Run the following command in your Terminal:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在与别人共享 **test_nmap.gnmap** 文件之前，先对文件中的 IP 地址进行编辑。我们再次使用 IP 地址的正则表达式。不过，这一次，我们会将输出传递给
    **sed** 并编辑所有的 IP 地址。在终端中运行以下命令：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example code can be found in the **ch04_regex_05.sh** file in this chapter’s
    folder. The output should show that every IP address in the file has been redacted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch04_regex_05.sh** 文件中找到。输出应该显示文件中的每个 IP 地址已被编辑。
- en: So, what does this **sed** command do?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这条 **sed** 命令是做什么的呢？
- en: The **-E** option enables extended regex.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-E** 选项启用扩展正则表达式。'
- en: The command after **sed** is enclosed in single quotes.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sed** 后面的命令被单引号括起来。'
- en: After the **sed** command and arguments, you’ll see a pattern similar to **'s/MATCH/REPLACE/g'**
    .
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **sed** 命令和参数之后，你会看到类似 **'s/MATCH/REPLACE/g'** 的模式。
- en: The **s** option means search for anything (literal text or regex) between the
    next **/** characters (the **MATCH** text).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s** 选项表示查找下一个 **/** 字符之间的任何内容（**MATCH** 文本）。'
- en: Replace the matched text with the pattern between the next set of slash ( **/**
    ) characters (the **REPLACE** text).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用下一个斜杠（**/**）字符之间的模式（**REPLACE** 文本）替换匹配的文本。
- en: The **g** flag means to make it a **global** search and replace every occurrence.
    Otherwise, if the regex or literal string was matched twice on the same line,
    it would only perform the substitution on the first match.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**g** 标志表示进行 **全局** 查找，并替换每一个匹配项。否则，如果正则表达式或字面字符串在同一行中匹配了两次，它只会对第一个匹配项执行替换。'
- en: 'In this example, we didn’t edit the original file in place. We only edited
    the text output to the screen. There are two ways we could have edited and saved
    the text: by including the **sed -i** flag or by redirecting the output to a file.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有直接编辑原文件，只是编辑了屏幕上的文本输出。我们有两种方法可以编辑并保存文本：一种是包括 **sed -i** 标志，另一种是将输出重定向到文件。
- en: 'In the first case, edit the file in place by adding the **sed -** **i** flag:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，通过添加 **sed -** **i** 标志可以就地编辑文件：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example code can be found in the **ch04_regex_06.sh** file in this chapter’s
    folder. The other option omits the **-i** flag. It will preserve the original
    file and redirect the edited text to a new file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch04_regex_06.sh** 文件中找到。另一个选项是省略 **-i** 标志。它会保留原文件，并将编辑后的文本重定向到一个新文件中：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example code can be found in the **ch04_regex_07.sh** file in this chapter’s
    folder. The preceding command uses the **>** character to redirect the output
    to the filename that follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码可以在本章文件夹中的 **ch04_regex_07.sh** 文件中找到。上述命令使用 **>** 字符将输出重定向到随后的文件名。
- en: Tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using the **>** character to redirect output ( **stdout** ) to a file,
    it will overwrite the file if it exists. To append to an existing file instead
    of overwriting it, utilize **>>** in the command.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **>** 字符将输出（**stdout**）重定向到文件时，如果文件已存在，它将覆盖该文件。如果想要追加内容而不是覆盖，命令中应使用 **>>**。
- en: Next, let’s examine using **awk** for regex matching. Awk is much more than
    just a tool for regex; it’s a full-fledged programming language. Where it shines
    is when you’re sifting through tabular data (columns, tab, and comma-separated
    data). Before learning awk, I mistakenly believed it to be too complex and I would
    chain together multiple tools to do the same job, ultimately putting in more work
    than I would if I just used awk. I’ll be a bit brief in this chapter and stick
    to a few quick examples because we’ll be going more in depth in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看如何使用 **awk** 进行正则表达式匹配。Awk 不仅仅是一个正则表达式工具，它是一个完整的编程语言。它的优势在于当你在处理表格数据（列、制表符或逗号分隔的数据）时，能发挥巨大的作用。在学习
    awk 之前，我误以为它太复杂，常常将多个工具链在一起完成同样的工作，结果做了更多的工作，实际上如果直接使用 awk，反而省力。本章我会简要介绍几个快速的示例，更多深入的内容将在下一章中讲解。
- en: Awk programs can be a single line for quick one-off scripts, though they can
    be used in files for more complex use cases. The format of a one-line awk script
    is **awk 'pattern {action}'** . Either **pattern** or **action** may be omitted,
    but not both.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Awk程序可以是一行快速的一次性脚本，尽管它们也可以用于文件以处理更复杂的用例。一行awk脚本的格式是**awk '模式 {动作}'**。**模式**或**动作**可以省略一个，但不能同时省略。
- en: The default field separator is any whitespace, such as spaces or tabs. Multiple
    whitespace characters are treated as a single unit. This is very helpful as I
    used to use **tr -s ' '** to *squeeze* or combine multiple spaces into one before
    learning awk.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字段分隔符是任何空白字符，比如空格或制表符。多个空白字符被视为一个单元。这对我来说非常有帮助，因为在学习awk之前我习惯使用**tr -s ' '**来*压缩*或合并多个空格为一个。
- en: 'Before diving into our first awk example, let’s take a minute to understand
    common awk terms:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究我们的第一个awk示例之前，让我们花一分钟来了解常见的awk术语：
- en: '**Record** : Each line of an input file is referred to as a record.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**：输入文件的每一行被称为一个记录。'
- en: '**Field** : Each column is a field.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段**：每一列都是一个字段。'
- en: '**$n** : Each field (column). The whole record (line) is **$0** , the first
    field is **$1** , and so on.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$n**：每个字段（列）。整个记录（行）是**$0**，第一个字段是**$1**，依此类推。'
- en: '**$NF** : The number of fields in a record. It can also be used to refer to
    the last field.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$NF**：记录中的字段数。也可以用来指代最后一个字段。'
- en: '**$NR** : The number of records so far.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$NR**：到目前为止的记录数。'
- en: '**-F** : A field separator; this is a space by default. Remember, any number
    of consecutive spaces are combined. So, if the first two fields are separated
    by one or multiple spaces, **$1** and **$2** still refer to the first and second
    fields (columns).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-F**：字段分隔符；默认是一个空格。记住，任意数量的连续空格会被合并。因此，如果前两个字段由一个或多个空格分隔，**$1**和**$2**仍然指代第一个和第二个字段（列）。'
- en: 'In the following figure, you can see the output of the **ps -ef** command on
    my system. This is the data I’ll be using in the following examples:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到我系统上**ps -ef**命令的输出。这是我将在接下来的示例中使用的数据：
- en: '![Figure 4.14 – System processes are shown when using the ps command](image/B22229_04_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 使用ps命令显示系统进程](image/B22229_04_14.jpg)'
- en: Figure 4.14 – System processes are shown when using the ps command
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 使用ps命令显示系统进程
- en: 'In our first awk example, I’m simply going to print each record ( **line**
    ):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个awk示例中，我只是简单地打印每个记录（**行**）：
- en: '![Figure 4.15 – Printing the whole record using $0](image/B22229_04_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 使用$0打印整个记录](image/B22229_04_15.jpg)'
- en: Figure 4.15 – Printing the whole record using $0
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 使用$0打印整个记录
- en: This example code can be found in the **ch04_regex_08.sh** file in this chapter’s
    folder.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的代码可以在本章节文件夹中的**ch04_regex_08.sh**文件中找到。
- en: 'Next, we’re going to look at a more advanced example. In the following figure,
    I’m using a pattern and action. This example will match any process with a UID
    of **author** and print the CMD ( **$8** , or the 8 th field):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一个更高级的例子。在下图中，我使用了一个模式和动作。这个例子将匹配任何具有**author** UID的进程，并打印CMD（**$8**，或第8个字段）：
- en: '![Figure 4.16 – Printing the CMD of any process owned by author](image/B22229_04_16.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 打印任何由author拥有的进程的CMD](image/B22229_04_16.jpg)'
- en: Figure 4.16 – Printing the CMD of any process owned by author
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 打印任何由author拥有的进程的CMD
- en: This example code can be found in the **ch04_regex_09.sh** file in this chapter’s
    folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的代码可以在本章节文件夹中的**ch04_regex_09.sh**文件中找到。
- en: 'In our final awk example, we’re going to examine how to use regex and print
    the output with a custom separator:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一个awk示例中，我们将研究如何使用正则表达式并用自定义分隔符打印输出：
- en: '![Figure 4.17 – Using a regex and printing the custom output with awk](image/B22229_04_17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – 使用正则表达式并用awk打印自定义输出](image/B22229_04_17.jpg)'
- en: Figure 4.17 – Using a regex and printing the custom output with awk
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 使用正则表达式并用awk打印自定义输出
- en: This example code can be found in the **ch04_regex_10.sh** file in this chapter’s
    folder. In the preceding example, the regex in the pattern matches anything in
    the eighth field that starts with **[irq/** , followed by exactly two digits,
    followed by **-pciehp]** . For any matching records, the action prints the first
    and eighth fields, separated by **--->** instead of the default space.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的代码可以在本章节文件夹中的**ch04_regex_10.sh**文件中找到。在前面的示例中，模式中的正则表达式匹配第八个字段中以**[irq/**开头，后跟正好两位数字，后跟**-pciehp]**的内容。对于任何匹配的记录，动作打印第一个和第八个字段，用**--->**代替默认的空格分隔符。
- en: We’ve only scratched the surface of how to use awk. However, the concepts demonstrated
    here will solve the most common scripting tasks. We’ll explore this subject more
    in the next chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅触及了使用awk的表面。然而，这里展示的概念可以解决最常见的脚本任务。我们将在下一章深入探讨这一主题。
- en: Regex tips and best practices
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式技巧与最佳实践
- en: 'The following tips will help guide you through creating complex regex patterns:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下技巧将帮助你创建复杂的正则表达式模式：
- en: '**Start small** : Begin with simple patterns and gradually introduce more complexity.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从小开始**：从简单的模式入手，逐渐引入更多的复杂性。'
- en: '**Practice** : Use online regex testers to experiment with different patterns
    and flags.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**练习**：使用在线正则表达式测试工具，尝试不同的模式和标志。'
- en: '**Break it down** : When faced with a complex pattern, break it down into smaller
    parts to understand each component.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解**：面对复杂的模式时，把它分解成更小的部分，以便理解每个组成部分。'
- en: '**Refer to documentation** : Keep a cheat sheet or reference guide handy until
    you’re more comfortable with common patterns and metacharacters. While there are
    plenty of regex cheat sheets to be found online, I suggest that you make your
    own while reading this book and experimenting. I find that the act of making notes
    helps me commit difficult concepts to memory.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考文档**：保持一份备忘单或参考指南，直到你对常见模式和元字符更熟悉为止。虽然网上有很多正则表达式备忘单，但我建议你在阅读本书并进行实验时自己制作一份。我发现，做笔记的过程有助于我记住难以理解的概念。'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided an introduction to regex, followed by more advanced
    topics, including metacharacters and capture groups. Finally, we learned how to
    apply these techniques to real-world applications of Bash scripting that you will
    find useful for pentest ing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了正则表达式的基本概念，并进一步讲解了更高级的主题，包括元字符和捕获组。最后，我们学习了如何将这些技巧应用于Bash脚本的实际应用中，这对于渗透测试非常有用。
- en: Regex doesn’t have to be intimidating. With a basic understanding of characters,
    metacharacters, and flags, you’re well on your way to harnessing their power.
    Whether you’re editing text, analyzing data, or validating user input, regex can
    be an invaluable tool in your toolkit. Remember, like any skill, proficiency comes
    with practice. So, dive in, start experimenting, and soon they will become easy
    with a bit of practice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式并不需要让人害怕。通过对字符、元字符和标志的基本理解，你已经在掌握它们的道路上了。无论是编辑文本、分析数据还是验证用户输入，正则表达式都可以成为你工具箱中不可或缺的工具。记住，像任何技能一样，熟练掌握需要练习。所以，尽管去尝试，开始实验，很快你会发现它们变得简单易懂。
- en: In the next chapter, we’ll combine the regex concepts we learned in this chapter
    with common text parsing tools so that we can focus on common cybersecurity and
    pentest ing tasks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把本章学到的正则表达式概念与常见的文本解析工具结合起来，专注于常见的网络安全和渗透测试任务。
