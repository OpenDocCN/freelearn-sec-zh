- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Compromising Microsoft SQL Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 占领 Microsoft SQL Server
- en: This chapter will focus on a common and vital service of a typical Windows-based
    environment – Microsoft SQL Server. SQL Server is a relational database management
    system, similar to Oracle or MySQL. It is tightly integrated into Active Directory,
    allowing Windows authentication, the use of trust relationships, and much more.
    We will go through the usual attack steps, starting with the discovery and enumeration
    of instances in a target environment. A few different tools can help with these
    activities. Then, we will explore the ways to escalate privileges within SQL Server
    and then move on to run commands on the underlying operating system. This chapter
    will provide you with a solid understanding of lateral movement between database
    instances by abusing database links. Lastly, we will look at the ways to achieve
    persistence at the host and application levels utilizing what is available in
    SQL Server functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将聚焦于典型 Windows 环境中的一个常见且重要的服务——Microsoft SQL Server。SQL Server 是一个关系数据库管理系统，类似于
    Oracle 或 MySQL。它与 Active Directory 紧密集成，支持 Windows 身份验证、信任关系的使用等。我们将按照通常的攻击步骤，从目标环境中发现并枚举实例开始。许多不同的工具可以帮助完成这些活动。接着，我们将探索在
    SQL Server 中提升权限的方法，并进一步执行底层操作系统的命令。本章将为你提供通过滥用数据库链接在数据库实例之间进行横向移动的坚实理解。最后，我们将探讨如何利用
    SQL Server 功能实现主机和应用程序级别的持久性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction, discovery, and enumeration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍、发现和枚举
- en: Privilege escalation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限提升
- en: '**Operating system** (**OS**) command execution'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**（**OS**）命令执行'
- en: Lateral movement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向移动
- en: Persistence
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will need to have access to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要具备以下内容：
- en: VMware Workstation Pro or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU
    cores, and at least 55 GB of total space (more if you take snapshots)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware Workstation Pro 或 Oracle VirtualBox，至少需要 16 GB 的内存、8 个 CPU 核心以及至少 55
    GB 的总空间（如果你进行快照，所需空间会更多）
- en: A Linux-based operating system is strongly recommended
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈推荐使用基于 Linux 的操作系统
- en: From the GOADv2 project, we will use SRV02 and SRV03
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GOADv2 项目中，我们将使用 SRV02 和 SRV03
- en: Introduction, discovery, and enumeration
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍、发现和枚举
- en: In this section, we will start our journey in Microsoft SQL Server security
    assessment. We will briefly introduce you to SQL Server and then move on to the
    discovery process. A significant amount of the section will be a deep dive into
    the manual and automated aspects of the enumeration process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始对 Microsoft SQL Server 安全评估的旅程。我们将简要介绍 SQL Server，然后进入发现过程。本节的大部分内容将深入探讨枚举过程的手动和自动化方面。
- en: SQL Server introduction
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL Server 介绍
- en: Before we jump into the discovery topic, let’s start by looking at SQL Server
    functionality, fixed server roles, and security mechanisms. SQL Server is an application
    installed on the OS; in our case, we will focus only on Windows hosts. The server
    runs as a set of uniquely named Windows services in the context of the service
    account. The default listening TCP port is **1433**, and the UDP port is **1434**;
    however, if more services are running, the list of ports will be longer[1]. In
    order to get access to stored data, a user must pass authentication and authorization
    checks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索发现主题之前，先让我们看看 SQL Server 的功能、固定服务器角色和安全机制。SQL Server 是安装在操作系统上的应用程序；在我们的例子中，我们只关注
    Windows 主机。该服务器作为一组唯一命名的 Windows 服务在服务账户的上下文中运行。默认的监听 TCP 端口是 **1433**，UDP 端口是
    **1434**；然而，如果运行更多的服务，端口列表会更长[1]。为了访问存储的数据，用户必须通过身份验证和授权检查。
- en: Authentication verifies whether a user has enough permissions to log in to an
    instance. There are two authentication mechanisms – using either a Windows account
    or SQL Server login. The difference between these two mechanisms is in who handles
    the authentication – the domain controller or SQL Server itself. After login,
    an account will be assigned certain server-level roles, as defined during its
    creation. Think of these roles as Active Directory security groups. These roles
    are server-wide and can be fixed or user-defined. SQL Server 2022 has added 10
    new fixed roles[2] to the existing 9 from previous versions[3]. Fixed server role
    permissions can’t be changed, except for the “public” role. Authorization happens
    at a database level and determines what a user’s permissions on a database after
    logging in are. For this purpose, authentication accounts are mapped to database
    users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证用来验证用户是否有足够的权限登录实例。身份验证机制有两种——使用 Windows 账户或 SQL Server 登录。这两种机制的区别在于身份验证的处理者——是域控制器还是
    SQL Server 本身。登录后，账户将被分配一些在创建时定义的服务器级角色。可以将这些角色看作是 Active Directory 安全组。这些角色是服务器级别的，可以是固定的或用户定义的。SQL
    Server 2022 在先前版本的 9 个固定角色基础上增加了 10 个新固定角色[2]。固定服务器角色权限无法更改，除了“public”角色。授权发生在数据库级别，决定用户在登录后对数据库的权限。为此，认证账户将映射到数据库用户。
- en: 'There are five default databases:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个默认数据库：
- en: '**master** – stores system-level instance information'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**master** – 存储系统级别的实例信息'
- en: '**msdb** – required by SQL Server Agent to schedule jobs and alerts'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**msdb** – SQL Server Agent 用于调度作业和警报'
- en: '**model** – a template database, used to create new databases'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**model** – 模板数据库，用于创建新数据库'
- en: '**resource** – a read-only database that keeps **sys** schema objects'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**resource** – 只读数据库，保存 **sys** 模式对象'
- en: '**tempdb** – stores temporary objects and results'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tempdb** – 存储临时对象和结果'
- en: Now that we have the basic information about SQL Server, we can now move on
    to reconnaissance activities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 SQL Server 的基本信息，接下来我们可以进行侦察活动。
- en: Discovery
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现
- en: 'From an unauthenticated attacker perspective, to discover SQL Server, we need
    to perform a network port scan. Nmap, **PowerUpSQL**, **SQLCMD**, CrackMapExec,
    and the **mssql_ping** Metasploit module will assist in this activity. These tools
    query common ports, such as TCP **1433** and UDP **1434**, or pull and parse SPNs
    from a domain, such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从未认证的攻击者视角来看，要发现 SQL Server，我们需要进行网络端口扫描。Nmap、**PowerUpSQL**、**SQLCMD**、CrackMapExec
    和 **mssql_ping** Metasploit 模块将帮助进行这项活动。这些工具查询常见端口，如 TCP **1433** 和 UDP **1434**，或从域中提取并解析
    SPN，示例如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If an adversary has local access to the database server, simple service enumeration
    for the name starting with **MSSQL*** or querying the registry hive located in
    **HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\*** will reveal running database
    instances. PowerUpSQL does exactly the same with the **Get-SQLInstanceLocal**
    function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者拥有数据库服务器的本地访问权限，通过简单的服务枚举查找以**MSSQL***开头的名称，或查询位于**HKLM:\SOFTWARE\Microsoft\Microsoft
    SQL Server\***的注册表项，就能发现正在运行的数据库实例。PowerUpSQL 正是通过 **Get-SQLInstanceLocal** 函数实现相同功能的。
- en: 'A set of valid domain credentials will allow an attacker to perform forest-wide
    SPN scanning to detect running SQL Server instances. Throughout the chapter, examples
    will be shown with a recently released tool called **SQLRecon**[4] and good old
    **PowerUpSQL**[5]. Let us discover whether SQL Server is installed on the essos
    domain by executing three different commands that provide exactly the same result.
    It’s important to mention that **setspn** and SQLRecon use a current domain user
    context and run from a domain-joined computer. For a Python script from **impacket**,
    we can explicitly specify credentials while running it from Kali:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一组有效的域凭证将允许攻击者执行整个森林范围内的 SPN 扫描，以检测正在运行的 SQL Server 实例。在本章中，将通过一款新发布的工具 **SQLRecon**[4]
    和经典的 **PowerUpSQL**[5] 展示一些示例。让我们通过执行三条提供完全相同结果的命令，来发现 SQL Server 是否安装在 essos
    域上。值得注意的是，**setspn** 和 SQLRecon 使用当前域用户上下文，并且从域加入的计算机上运行。而对于 **impacket** 的 Python
    脚本，我们可以在 Kali 上运行时显式指定凭证：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'SQLRecon performs an LDAP query, looking for a user (**sAMAccountType=805306368**)
    with an SPN starting with **MSSQL*** (**servicePrincipalName=MSSQL***). The result
    of the discovery is shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SQLRecon 执行 LDAP 查询，查找一个具有 SPN 以 **MSSQL*** 开头的用户（**sAMAccountType=805306368**）（**servicePrincipalName=MSSQL***）。发现的结果如以下截图所示：
- en: '![Figure 9.1 – Discovered SQL Server instances](image/B18964_09_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 发现的 SQL Server 实例](image/B18964_09_01.jpg)'
- en: Figure 9.1 – Discovered SQL Server instances
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 发现的 SQL Server 实例
- en: An adversary can then try to log into the discovered instances using compromised
    domain or SQL Server user credentials. Another way to get an initial foothold
    in the SQL Server is to brute-force your way in.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者然后可以尝试使用被泄露的域或 SQL Server 用户凭证登录到发现的实例。获取 SQL Server 初始立足点的另一种方法是通过暴力破解。
- en: Brute force
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴力破解
- en: 'Dictionary attacks are noisy and must be executed with caution to avoid being
    locked out of target accounts. Nmap scripts, Metasploit modules, and PowerUpSQL
    functions can assist in such an activity. In PowerUpSQL[6], there are three functions
    that allow you to perform login attacks:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 字典攻击是非常嘈杂的，必须小心执行，以避免被锁定在目标账户之外。Nmap 脚本、Metasploit 模块和 PowerUpSQL 函数可以帮助执行此类活动。在
    PowerUpSQL[6] 中，有三个函数允许你进行登录攻击：
- en: '**Invoke-SQLAuditWeakLoginPw** – testing a username as password'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Invoke-SQLAuditWeakLoginPw** – 将用户名作为密码进行测试'
- en: '**Get-SQLConnectionTestThreaded** – logging in with a known username/password
    pair or as a current user'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-SQLConnectionTestThreaded** – 使用已知的用户名/密码对或作为当前用户进行登录'
- en: '**Get-SQLServerLoginDefaultPw** – checking for default passwords used by common
    applications, based on an instance name'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-SQLServerLoginDefaultPw** – 检查常见应用程序使用的默认密码，基于实例名称'
- en: '**CrackMapExec** also allows to you perform a password spray attack, using
    supplied username and password lists:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**CrackMapExec** 还允许你执行密码喷射攻击，使用提供的用户名和密码列表：'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s assume that an adversary has compromised or guessed the password of the
    user **jorah.mormont**. The following PowerUpSQL chained commands verify access
    to SQL Server instances as **jorah.mormont** and collect server information:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者已经入侵或猜测到了用户 **jorah.mormont** 的密码。以下 PowerUpSQL 链式命令验证以 **jorah.mormont**
    用户身份访问 SQL Server 实例并收集服务器信息：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command is shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下图所示：
- en: '![Figure 9.2 – SQL Server enumeration using PowerUpSQL](image/B18964_09_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 使用 PowerUpSQL 进行 SQL Server 枚举](image/B18964_09_02.jpg)'
- en: Figure 9.2 – SQL Server enumeration using PowerUpSQL
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 使用 PowerUpSQL 进行 SQL Server 枚举
- en: 'The **SQLRecon** command shows mapped roles as well:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLRecon** 命令也显示映射的角色：'
- en: '![Figure 9.3 – An initial foothold with a compromised user](image/B18964_09_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 使用被泄露的用户进行初始立足点](image/B18964_09_03.jpg)'
- en: Figure 9.3 – An initial foothold with a compromised user
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 使用被泄露的用户进行初始立足点
- en: 'After obtaining a foothold, an adversary can continue enumeration of other
    database users to identify a possible next target. There is a Metasploit module
    to enumerate SQL logins, called **admin/mssql/mssql_enum_sql_logins**, and PowerUpSQL
    has a **Get-SQLFuzzServerLogin** function. This function under the hood invokes
    the SQL Server **suser_name** function and iterates the principal ID value. A
    public role is enough to perform such an activity:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 获取立足点后，攻击者可以继续枚举其他数据库用户，以确定可能的下一个目标。Metasploit 有一个用于枚举 SQL 登录的模块，叫做 **admin/mssql/mssql_enum_sql_logins**，PowerUpSQL
    也有一个 **Get-SQLFuzzServerLogin** 函数。该函数在后台调用 SQL Server **suser_name** 函数，并迭代主
    ID 值。一个公共角色就足以执行此类活动：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下图所示：
- en: '![Figure 9.4 – All server logins for the instance](image/B18964_09_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 实例的所有服务器登录](image/B18964_09_04.jpg)'
- en: Figure 9.4 – All server logins for the instance
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 实例的所有服务器登录
- en: 'It is also possible to enumerate domain users with the **Get-SQLFuzzDomainAccount**
    function and Metasploit **admin/mssql/mssql_enum_domain_accounts** module. The
    idea is exactly the same, but this time, iteration goes over domain RIDs. The
    default end iteration value is 1,000; however, it can be modified for large environments
    with the **-EndId** option. It’s important to note that the LSA SID lookup requests
    (in our case, **lsa_lookupsids3**) that are utilized by this function will cause
    a lot of traffic for the domain controller in a short period of time:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 **Get-SQLFuzzDomainAccount** 函数和 Metasploit **admin/mssql/mssql_enum_domain_accounts**
    模块枚举域用户。思路完全相同，但这次迭代会遍历域 RID。默认的结束迭代值是 1,000；然而，对于大型环境，可以通过 **-EndId** 选项进行修改。需要注意的是，由此函数使用的
    LSA SID 查找请求（在我们的例子中是 **lsa_lookupsids3**）会在短时间内为域控制器造成大量流量：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result of the **Get-SQLFuzzDomainAccount** command is shown in the following
    screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Get-SQLFuzzDomainAccount** 命令的结果如下图所示：'
- en: '![Figure 9.5 – All domain groups and users](image/B18964_09_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 所有域组和用户](image/B18964_09_05.jpg)'
- en: Figure 9.5 – All domain groups and users
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 所有域组和用户
- en: The brute-force attack will leave traces in the Windows log with the event ID
    **18456**. The error text from the event helps to determine whether the attacker
    performed user enumeration or a password spray.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力破解攻击会在 Windows 日志中留下事件 ID **18456** 的痕迹。事件中的错误文本有助于确定攻击者是进行用户枚举还是密码喷射攻击。
- en: The next step for the attacker is to enumerate the database itself using acquired
    credentials.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的下一步是使用获得的凭证枚举数据库本身。
- en: Database enumeration
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库枚举
- en: 'Enumeration can be done with the help of tools such as SQLRecon or manually
    running queries, with a tool such as **HeidiSQL**[7] or Microsoft SQL Server Management
    Studio. Here is a set of common queries to get basic information about the database[8][9].
    You can run these queries in SQL SMS. The comments above the statements in the
    following screenshot aim to explain their purpose:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举可以通过使用像 SQLRecon 这样的工具或者手动运行查询来完成，使用如**HeidiSQL**[7]或 Microsoft SQL Server
    Management Studio 这样的工具。以下是一些常见的查询，用于获取数据库的基本信息[8][9]。你可以在 SQL SMS 中运行这些查询。下面截图中语句上方的注释旨在解释它们的目的：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the information from the preceding queries is significant; however, the
    most crucial information is the current user’s role, the linked servers, the logins
    available for impersonation, and our effective permissions on the server and database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前查询的所有信息都很重要；然而，最关键的信息是当前用户的角色、链接的服务器、可供冒充的登录账户，以及我们在服务器和数据库上的有效权限。
- en: SQLRecon has correspondent modules for enumeration. The tool supports five types
    of authentication, but we are only interested in three of them – a Windows token
    (**WinToken**), Windows Domain Credentials (**WinDomain**), and Local Credentials
    (**Local**). Let us enumerate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SQLRecon 有对应的枚举模块。该工具支持五种类型的身份验证，但我们只关心其中三种——Windows 令牌（**WinToken**）、Windows
    域凭证（**WinDomain**）和本地凭证（**Local**）。让我们开始枚举。
- en: 'For example, the following commands show the linked servers and accounts that
    can be impersonated by the current user (**khal.drogo**):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令显示了当前用户（**khal.drogo**）可以冒充的链接服务器和账户：
- en: '![Figure 9.6 – A list of the accounts that can be impersonated and the linked
    servers](image/B18964_09_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 可以被冒充的账户列表及其链接的服务器](image/B18964_09_06.jpg)'
- en: Figure 9.6 – A list of the accounts that can be impersonated and the linked
    servers
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 可以被冒充的账户列表及其链接的服务器
- en: To identify privilege escalation vectors, we can run PowerUpSQL functions such
    as **Invoke-SQLAudit** or **Invoke-SQLEscalatePriv**. However, let us cover the
    privilege escalation techniques available one by one in more detail in the following
    section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别权限提升的路径，我们可以运行 PowerUpSQL 函数，如**Invoke-SQLAudit**或**Invoke-SQLEscalatePriv**。然而，让我们在接下来的章节中逐一详细介绍可用的权限提升技术。
- en: Privilege escalation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限提升
- en: In the previous section, we saw a number of techniques for database enumeration.
    In this section, we will use gathered reconnaissance results for the user **khal.drogo**
    to identify privilege escalation paths on the database server. We will also practice
    escalating privileges from SQL Server to the host itself. At the end of this section,
    we will escalate to the **sysadmin** role from the user, with host local administrator
    privileges.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了多种数据库枚举技术。在本节中，我们将使用收集到的侦察结果，针对用户**khal.drogo**，识别数据库服务器上的权限提升路径。我们还将实践从
    SQL Server 提升权限到主机本身。在本节结束时，我们将从该用户提升到**sysadmin**角色，且拥有本地主机管理员权限。
- en: Impersonation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒充
- en: 'One of the most common privilege escalation vectors is user impersonation.
    This privilege allows the impersonation of another user or login in order to access
    resources on behalf of the impersonated user, without specifically granting rights[10].
    **sysadmin** has this permission for all databases, members of the **db_owner**
    role only have this permission in databases they own. We can check whether a current
    user is allowed to impersonate **sa** user login with the following query:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的权限提升路径之一是用户冒充。此权限允许冒充另一个用户或登录账户，以代表被冒充的用户访问资源，而无需专门授予权限[10]。**sysadmin**角色对所有数据库都有此权限，**db_owner**角色成员只在他们拥有的数据库中拥有此权限。我们可以通过以下查询检查当前用户是否被允许冒充**sa**用户登录：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Impersonation can happen on the server level (**EXECUTE AS LOGIN**) and on
    the database level (**EXECUTE AS USER**). Metasploit has a module named **admin/mssql/mssql_escalate_execute_as**
    that can be used to escalate privileges via impersonation. PowerUpSQL also has
    a function to identify an impersonation and exploit it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假冒可以发生在服务器级别（**EXECUTE AS LOGIN**）和数据库级别（**EXECUTE AS USER**）。Metasploit有一个名为**admin/mssql/mssql_escalate_execute_as**的模块，可以通过假冒提升权限。PowerUpSQL也有一个功能可以识别并利用假冒：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下面的截图所示：
- en: '![Figure 9.7 – Successful privilege escalation](image/B18964_09_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 成功的权限提升](image/B18964_09_07.jpg)'
- en: Figure 9.7 – Successful privilege escalation
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 成功的权限提升
- en: Clearly, it is vital to audit users with the impersonation privilege. The **Invoke-SQLAudit**
    function from PowerUpSQL lists all logins that can impersonate others. However,
    it cannot build a relationship graph, like BloodHound, and identify nested ones.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，审核具有假冒权限的用户至关重要。PowerUpSQL的**Invoke-SQLAudit**功能列出了所有可以假冒其他用户的登录名。然而，它无法构建关系图（如BloodHound那样）并识别嵌套的关系。
- en: TRUSTWORTHY misconfiguration
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受信任配置错误
- en: '**TRUSTWORTHY** is a database property that indicates that SQL Server trusts
    a database and its content. By default, this property is disabled and only can
    be enabled by **sysadmin**. If an adversary is a member of the **db_owner** role
    on a **TRUSTWORTHY** database that is owned by **sysadmin**, it is possible to
    elevate privileges. The attacker with the **db_owner** role can create a stored
    procedure so that it will be executed in the context of the database owner – **sysadmin**
    (**EXECUTE** **AS OWNER**)[11].'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**受信任**是一个数据库属性，表示SQL Server信任该数据库及其内容。默认情况下，此属性是禁用的，只有**sysadmin**才能启用。如果攻击者是一个**受信任**数据库中属于**db_owner**角色的成员，并且该数据库的所有者是**sysadmin**，那么就有可能提升权限。拥有**db_owner**角色的攻击者可以创建一个存储过程，使其在数据库所有者（**sysadmin**）的上下文中执行（**EXECUTE
    AS OWNER**）[11]。'
- en: 'Let’s set up this attack in our lab. The following code will create a database,
    set it as **TRUSTWORTHY**, create a login for **viserys.targaryen**, and grant
    him the **db_owner** role:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实验室中设置这个攻击。以下代码将创建一个数据库，将其设置为**受信任**，为**viserys.targaryen**创建一个登录，并授予他**db_owner**角色：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are ready to perform the attack. Firstly, let us identify **TRUSTWORTHY**
    databases. PowerUpSQL has a function, **Invoke-SQLAuditPrivTrustworthy**, for
    this task, or we can just run the following SQL query:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备执行攻击。首先，让我们识别**受信任**的数据库。PowerUpSQL有一个名为**Invoke-SQLAuditPrivTrustworthy**的功能可以完成此任务，或者我们可以直接运行以下SQL查询：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Secondly, we need to check the members of the **db_owner** role within a **TRUSTWORTHY**
    database:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要检查**受信任**数据库中**db_owner**角色的成员：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last step is to create a procedure and execute it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个存储过程并执行它：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An attack can be automated by using the Metasploit **auxiliary/admin/mssql/mssql_escalate_dbowner**
    module or the **Invoke-SqlServer-Escalate-DbOwner** script[12]. The result of
    the automated exploitation is shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用Metasploit的**auxiliary/admin/mssql/mssql_escalate_dbowner**模块或**Invoke-SqlServer-Escalate-DbOwner**脚本[12]来自动化攻击。自动化利用的结果如下面的截图所示：
- en: '![Figure 9.8 – Privilege escalation from db_owner to sysadmin](image/B18964_09_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 从db_owner到sysadmin的权限提升](image/B18964_09_08.jpg)'
- en: Figure 9.8 – Privilege escalation from db_owner to sysadmin
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 从db_owner到sysadmin的权限提升
- en: To prevent misconfiguration, it is recommended to either switch off the **TRUSTWORTHY**
    property or change the database owner to a low-privileged user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止配置错误，建议关闭**受信任**属性或将数据库所有者更改为低权限用户。
- en: Starting from the following section, we will gradually move from the database
    level to the operating system level.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下部分开始，我们将逐渐从数据库级别转向操作系统级别。
- en: UNC path injection
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNC路径注入
- en: '**Uniform Naming Convention** (**UNC**) paths can be used to access files on
    a remote server. There are two stored procedures that support UNC paths and can
    be executed with a public server role – **xp_dirtree** and **xp_fileexist**. A
    stored procedure is a logical unit that groups several SQL statements. The benefits
    of this are security, reusability, and performance. By executing one of these
    two procedures, the attacker forces the SQL Server service account to access and
    subsequently authenticate to a controlled resource. Then, the NTLMv2 challenge
    will be captured and relayed, or cracked by an adversary. The attack can be automated
    by using the Metasploit **auxiliary/admin/mssql/mssql_ntlm_stealer** module, the
    SQLRecon **smb** module, or the **Invoke-SQLUncPathInjection** function from PowerUpSQL.
    All of them essentially execute the following query:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一命名约定**（**UNC**）路径可以用于访问远程服务器上的文件。有两个存储过程支持 UNC 路径，并且可以通过公共服务器角色执行 – **xp_dirtree**
    和 **xp_fileexist**。存储过程是将多个 SQL 语句组合在一起的逻辑单元。这样做的好处包括安全性、可重用性和性能。通过执行这两个存储过程之一，攻击者迫使
    SQL Server 服务帐户访问并随后对受控资源进行身份验证。然后，NTLMv2 挑战将被捕获并转发，或由攻击者破解。通过使用 Metasploit 的
    **auxiliary/admin/mssql/mssql_ntlm_stealer** 模块、SQLRecon 的 **smb** 模块，或 PowerUpSQL
    中的 **Invoke-SQLUncPathInjection** 函数，可以自动化此攻击。它们本质上执行以下查询：'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The NTLMv2 challenge will be captured by Responder, as shown in the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: NTLMv2 挑战将被 Responder 捕获，如下图所示：
- en: '![Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured](image/B18964_09_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 已捕获 sql_svc 的 NTLMv2 挑战](image/B18964_09_09.jpg)'
- en: Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 已捕获 sql_svc 的 NTLMv2 挑战
- en: To eliminate this attack vector, it is recommended to revoke the execution of
    these procedures from a public role.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除此攻击向量，建议撤销公共角色执行这些过程的权限。
- en: There is another way to coerce authentication but, this time, as a machine account
    where SQL Server is installed[13]. After logging in to SQL Server Management Studio,
    an adversary restores a database from an XMLA file but points it to a controlled
    listener as a backup file location. Then, an adversary will capture the NTLMv2
    challenge.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种迫使身份验证的方式，但这次是作为安装了 SQL Server 的机器帐户[13]。在登录到 SQL Server Management Studio
    后，攻击者从 XMLA 文件恢复一个数据库，但将其指向一个受控监听器作为备份文件位置。然后，攻击者将捕获 NTLMv2 挑战。
- en: From a service account to SYSTEM
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务帐户到 SYSTEM
- en: 'Usually, a database service account has the **SeImpersonatePrivilege** permission.
    Abusing this permission allows us to elevate our privilege to SYSTEM. Depending
    on the version of the target operating system, various exploits are available.
    **JuicyPotato**[14] works for versions below Windows Server 2019, whereas RoguePotato,
    PrintSpoofer, SharpEfsPotato, and GodPotato[15] work for versions above as well.
    All exploits use various services during exploitation, but the main idea is to
    create a pipe, force a connection to it, and then impersonate the SYSTEM token.
    To execute further commands under the context of the service, we will run the
    following command in HeidiSQL, which will connect back to our Kali machine as
    user **sql_svc**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据库服务帐户拥有 **SeImpersonatePrivilege** 权限。滥用此权限可以将我们的权限提升至 SYSTEM。根据目标操作系统的版本，提供了不同的漏洞利用工具。**JuicyPotato**[14]
    适用于 Windows Server 2019 以下版本，而 RoguePotato、PrintSpoofer、SharpEfsPotato 和 GodPotato[15]
    适用于更高版本。所有漏洞利用都在利用过程中使用不同的服务，但主要思路是创建管道，强制连接，并伪装成 SYSTEM 令牌。为了在服务上下文中执行进一步的命令，我们将在
    HeidiSQL 中运行以下命令，这将作为 **sql_svc** 用户连接回我们的 Kali 主机：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Simply running the exploit grants us SYSTEM-level privileges:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行漏洞利用即可授予我们 SYSTEM 级别的权限：
- en: '![Figure 9.10 – The GodPotato exploit worked successfully](image/B18964_09_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – GodPotato 漏洞成功利用](image/B18964_09_10.jpg)'
- en: Figure 9.10 – The GodPotato exploit worked successfully
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – GodPotato 漏洞成功利用
- en: Microsoft has not released a fix for this privilege escalation vector.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 微软尚未发布针对该权限提升向量的修复。
- en: The following example will show how to obtain **sysadmin** privileges at the
    database level if an attacker is a local administrator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将展示如果攻击者是本地管理员，如何在数据库级别获取 **sysadmin** 权限。
- en: From a local administrator to sysadmin
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地管理员到 sysadmin
- en: Another possible situation is that an adversary has obtained a local administrator’s
    privileges on the database server. There are known ways how to get database **sysadmin**
    privileges as a next step[16]. One of the most common techniques is to impersonate
    a SQL Server service account because, by default, it has **sysadmin** privileges.
    PowerUpSQL has two impersonation functions called **Invoke-SQLImpersonateService**
    and **Invoke-SQLImpersonateServiceCmd**. Other techniques include reading LSA
    secrets with the help of Mimikatz, pulling SQL Server login password hashes, injecting
    DLL or shellcode into a process, or even running a database in single-user mode.
    A Metasploit module called **post/windows/manage/mssql_local_auth_bypass** combines
    getting **LocalSystem** privileges for an older SQL Server installation and migrating
    to a service process for a newer installations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的情况是，攻击者已获得数据库服务器的本地管理员权限。有已知的方法可以获取数据库**sysadmin**权限作为下一步[16]。最常见的技术之一是冒充
    SQL Server 服务帐户，因为默认情况下，它拥有**sysadmin**权限。PowerUpSQL 有两个冒充函数，分别是 **Invoke-SQLImpersonateService**
    和 **Invoke-SQLImpersonateServiceCmd**。其他技术包括借助 Mimikatz 读取 LSA 密钥、提取 SQL Server
    登录密码哈希、将 DLL 或 shellcode 注入进程，甚至运行数据库的单用户模式。一个名为 **post/windows/manage/mssql_local_auth_bypass**
    的 Metasploit 模块结合了为旧版 SQL Server 安装获取 **LocalSystem** 权限和迁移到新版 SQL Server 服务进程的能力。
- en: 'Running the following commands allows you to obtain **sysadmin** privileges
    and dump SQL Server login password hashes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令可以获得 **sysadmin** 权限并提取 SQL Server 登录密码哈希：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下截图中：
- en: '![Figure 9.11 – SQL Server login password hashes](image/B18964_09_11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – SQL Server 登录密码哈希](image/B18964_09_11.jpg)'
- en: Figure 9.11 – SQL Server login password hashes
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – SQL Server 登录密码哈希
- en: 'Apparently, there is another way to dump password hashes – by extracting them
    from a **master.mdf** file. XPN published a while ago some great research[17]
    that showed the internals of the **master.mdf** file and released the tool to
    extract password hashes[18]. This attack requires local administrator privileges.
    Firstly, we need to locate the **master.mdf** file and copy it using the RawCopy
    tool. This tool copies raw data from disk, so getting locked out of the **master.mdf**
    file by SQL Server will be bypassed. The PowerShell script uses **OrcaMDF** .NET
    libraries, so we need to load them too, and then dump the hashes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有另一种提取密码哈希的方法——从 **master.mdf** 文件中提取。XPN 之前发布了一些出色的研究[17]，展示了 **master.mdf**
    文件的内部结构，并发布了提取密码哈希的工具[18]。此攻击需要本地管理员权限。首先，我们需要定位 **master.mdf** 文件并使用 RawCopy
    工具将其复制。该工具从磁盘复制原始数据，因此可以绕过 SQL Server 锁定 **master.mdf** 文件的限制。PowerShell 脚本使用
    **OrcaMDF** .NET 库，因此我们还需要加载这些库，然后提取哈希：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding commands is shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![Figure 9.12 – The password hash of the SA SQL Server login](image/B18964_09_12.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – SA SQL Server 登录的密码哈希](image/B18964_09_12.jpg)'
- en: Figure 9.12 – The password hash of the SA SQL Server login
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – SA SQL Server 登录的密码哈希
- en: In the following section, we will examine multiple ways to run commands at the
    OS level.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将研究多种在操作系统级别执行命令的方法。
- en: OS command execution
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统命令执行
- en: In the upcoming sections, we will look at ways to execute OS system commands
    through SQL Server. To enable command execution, **sysadmin** privileges are required.
    Execution itself always happens in the context of a service account. An attacker
    does not need to know the hash or password of the SQL Server service or agent
    account. Let’s start by looking at built-in extended stored procedures.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨通过 SQL Server 执行操作系统命令的方法。要启用命令执行，必须拥有 **sysadmin** 权限。执行本身总是在服务帐户的上下文中进行。攻击者无需知道
    SQL Server 服务或代理帐户的哈希值或密码。让我们首先看看内置的扩展存储过程。
- en: xp_cmdshell
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xp_cmdshell
- en: '**xp_cmdshell** is probably the most well-known built-in extended stored procedure,
    which is disabled by default. Enabling it requires **sysadmin** privileges. There
    are a few functions in PowerUpSQL (**Invoke-SQLOSCmdExec** and **Invoke-SQLOSCmd**),
    SQLRecon (**EnableXp** and **XpCmd**), as well as the Metasploit **admin/mssql/mssql_exec**
    module that can automate this task. The manual query to install **xp_cmdshell**
    and enable it is shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**xp_cmdshell** 可能是最著名的内置扩展存储过程，它默认情况下是禁用的。启用它需要 **sysadmin** 权限。PowerUpSQL
    中有一些函数（**Invoke-SQLOSCmdExec** 和 **Invoke-SQLOSCmd**）、SQLRecon（**EnableXp** 和
    **XpCmd**）以及 Metasploit 中的 **admin/mssql/mssql_exec** 模块可以自动化此任务。安装并启用 **xp_cmdshell**
    的手动查询如下所示：'
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s important to mention that such an activity will create events with the
    ID **15457**, as the **sp_configure** procedure will have been used. The Windows
    event ID **15281** will be logged if the configuration attempt fails because the
    user does not have enough privileges.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的是，这样的活动将生成 ID 为 **15457** 的事件，因为 **sp_configure** 存储过程将被使用。如果配置尝试失败（因为用户权限不足），Windows
    事件 ID **15281** 将被记录。
- en: '![Figure 9.13 – A failed attempt to reconfigure xp_cmdshell](image/B18964_09_13.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 重新配置 xp_cmdshell 的失败尝试](image/B18964_09_13.jpg)'
- en: Figure 9.13 – A failed attempt to reconfigure xp_cmdshell
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 重新配置 xp_cmdshell 的失败尝试
- en: Also, there is a module in Metasploit (**exploit/windows/mssql/mssql_payload**)
    that will allow the execution of an arbitrary payload via **xp_cmdshell**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Metasploit 中有一个模块 (**exploit/windows/mssql/mssql_payload**) 可以通过 **xp_cmdshell**
    执行任意有效载荷。
- en: A custom extended stored procedure
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个自定义扩展存储过程
- en: Simply put, a custom extended stored procedure is an extension to SQL Server
    in the form of DLL. Sysadmin privileges are required to register each procedure
    inside the extension. A code sample for DLL can be found on GitHub[19]. It’s important
    to note that DLL and function names are case-sensitive and must be exactly the
    same.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，自定义扩展存储过程是 SQL Server 的一个 DLL 扩展。需要 Sysadmin 权限来注册每个存储过程到扩展中。DLL 的代码示例可以在
    GitHub 上找到[19]。需要注意的是，DLL 和函数名称是区分大小写的，必须完全相同。
- en: 'PowerUpSQL has a function called **Create-SQLFileXpDll** that will create a
    DLL for us. Then, we will register it, list the extended stored procedures to
    verify registration, and finally, execute our malicious extended procedure. The
    following commands replicate the process:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PowerUpSQL 有一个名为 **Create-SQLFileXpDll** 的函数，它将为我们创建一个 DLL。然后，我们将注册它，列出扩展存储过程以验证注册，最后执行我们的恶意扩展存储过程。以下命令复制了这个过程：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, the automatically PowerUpSQL created DLL did not execute on
    the target machine in the lab, even through the **rundll32** command. Surprisingly,
    the same DLL works fine on a Windows 10 machine, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，自动创建的 PowerUpSQL DLL 在实验室中的目标机器上并未执行，即使通过 **rundll32** 命令也是如此。令人惊讶的是，同样的
    DLL 在 Windows 10 机器上运行良好，如下所示：
- en: '![Figure 9.14 – DLL spawned a reverse shell](image/B18964_09_14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – DLL 生成了一个反向 shell](image/B18964_09_14.jpg)'
- en: Figure 9.14 – DLL spawned a reverse shell
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – DLL 生成了一个反向 shell
- en: 'The successful loaded DLL generates event ID **33090**, as shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 成功加载的 DLL 生成事件 ID **33090**，如下截图所示：
- en: '![Figure 9.15 – DLL was successfully loaded into memory](image/B18964_09_15.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – DLL 成功加载到内存中](image/B18964_09_15.jpg)'
- en: Figure 9.15 – DLL was successfully loaded into memory
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – DLL 成功加载到内存中
- en: The failed attempt will generate an error with ID **17750**. By correlating
    both events, it is possible to build detection around DLL names if there is a
    pre-defined list in an environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的尝试将生成 ID 为 **17750** 的错误。通过关联这两个事件，如果环境中有预定义的 DLL 名单，可以基于 DLL 名称构建检测。
- en: Custom CLR assemblies
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 CLR 程序集
- en: '**Common Language Runtime** (**CLR**) assembly is a .NET DLL that can be imported
    into SQL Server. After it is imported, DLL methods can be linked to stored procedures.
    In this scenario, an attack consists of two steps – enabling CLR and the actual
    execution. A nice step-by-step blog post detailing this was created by *NetSPI*[20].
    C# code is compiled in DLL and imported into SQL Server. The following queries
    allow you to execute the OS command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时** (**CLR**) 程序集是一个可以导入到 SQL Server 的 .NET DLL。导入后，DLL 方法可以链接到存储过程。在这种情况下，攻击分为两步——启用
    CLR 和实际执行。一个很好的分步博客帖子详细说明了这个过程，作者是 *NetSPI*[20]。C# 代码被编译成 DLL 并导入到 SQL Server。以下查询可以执行操作系统命令：'
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another advantage of this method is that it is possible to use a hex representation
    of the DLL purely in memory, without touching the disk.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的另一个优点是，可以仅在内存中使用 DLL 的十六进制表示，而不需要接触磁盘。
- en: There are two more considerations to keep in mind. This technique requires the
    **TRUSTWORTHY** property to be set, which is why we use the **msdb** database
    that has this property by default. Also, the **clr strict security** option was
    introduced by Microsoft[21]. By default, the **permission_set** option in **alter/create**
    assembly statements will be ignored. To switch it off, reconfiguration of CLR
    strict security is required through **sp_configure**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个需要注意的事项。此技术要求设置**TRUSTWORTHY**属性，这就是为什么我们使用默认具有此属性的**msdb**数据库。此外，**clr
    strict security**选项是微软引入的[21]。默认情况下，**alter/create**程序集语句中的**permission_set**选项将被忽略。要关闭此选项，需要通过**sp_configure**重新配置
    CLR 严格安全设置。
- en: 'For demonstration purposes, we will combine the use of SQLRecon and the **Create-SQLFileCLRDll**
    function from PowerUpSQL to obtain an interactive reverse shell. The very first
    step is to enable CLR with the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将结合使用 SQLRecon 和 PowerUpSQL 中的**Create-SQLFileCLRDll**函数来获得一个交互式反向 Shell。第一步是通过以下命令启用
    CLR：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we use the **Create-SQLFileCLRDll** function to generate code for a custom
    assembly:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用**Create-SQLFileCLRDll**函数生成自定义程序集的代码：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let us change the generated **.csc** file. The following code works perfectly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改生成的**.csc**文件。以下代码效果非常好：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following two commands will compile the code from above in DLL, and SQLRecon
    will automate the rest of the process:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个命令将编译上面的代码为 DLL，SQLRecon 将自动化其余的过程：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that SQLRecon bypasses the **clr strict security** option by adding assembly
    to trusted list:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SQLRecon 通过将程序集添加到信任列表来绕过**clr strict security**选项：
- en: '![Figure 9.16 – Custom CLR successfully executed a reverse shell](image/B18964_09_16.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 自定义 CLR 成功执行反向 Shell](image/B18964_09_16.jpg)'
- en: Figure 9.16 – Custom CLR successfully executed a reverse shell
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 自定义 CLR 成功执行反向 Shell
- en: 'As a result, we have an interactive shell on the target:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们在目标上获得了一个交互式 Shell：
- en: '![Figure 9.17 – An interactive reverse shell on the database server](image/B18964_09_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 数据库服务器上的交互式反向 Shell](image/B18964_09_17.jpg)'
- en: Figure 9.17 – An interactive reverse shell on the database server
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 数据库服务器上的交互式反向 Shell
- en: This functionality is also implemented in a Metasploit module called **exploit/windows/mssql/mssql_clr_payload**
    and in another PowerShell tool called **SeeCLRly**[22].
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能也在 Metasploit 模块**exploit/windows/mssql/mssql_clr_payload**和另一个 PowerShell
    工具**SeeCLRly**[22]中实现。
- en: In order to list and export existing CLR assemblies, the **Get-SQLStoredProcedureCLR**
    function was implemented in PowerUpSQL. We can then modify the exported CLR DLL
    by using the **dnSpy** decompiler and re-upload it, overwriting the existing one
    to achieve stealthy persistence.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出并导出现有的 CLR 程序集，PowerUpSQL 实现了**Get-SQLStoredProcedureCLR**函数。我们可以使用**dnSpy**反编译器修改导出的
    CLR DLL，然后重新上传它，覆盖现有的文件，以实现隐蔽持久化。
- en: Attack detection is possible via event ID **15457**, as an adversary must use
    **sp_configure**. Assembly creation will generate event ID **6299**, unloading
    the assembly will generate event ID **10310**, and the unload confirmation generate
    event ID **6290**. Correlating and chaining together these four events can help
    in the reliable detection of malicious activity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过事件 ID **15457**可以进行攻击检测，因为攻击者必须使用**sp_configure**。程序集创建将生成事件 ID **6299**，卸载程序集将生成事件
    ID **10310**，卸载确认将生成事件 ID **6290**。通过关联和串联这四个事件，可以帮助可靠地检测恶意活动。
- en: OLE automation procedures
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OLE 自动化过程
- en: '**Object Linking and Embedding** (**OLE**) technology allows you to link objects
    from one application to another. OLE automation procedures help SQL Server to
    use to interact with COM objects. The **Component Object Model** (**COM**) allows
    interaction between binary software components. OLE automation procedures use
    **odsole70.dll** to interact with the COM[23]. The following is a list of procedures
    that can be used for command execution:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象链接与嵌入**（**OLE**）技术允许你将一个应用程序中的对象链接到另一个应用程序中。OLE 自动化过程帮助 SQL Server 与 COM
    对象进行交互。**组件对象模型**（**COM**）允许二进制软件组件之间的交互。OLE 自动化过程通过**odsole70.dll**与 COM 进行交互[23]。以下是可以用于命令执行的过程列表：'
- en: '**sp_OACreate** – creates an OLE object instance'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_OACreate** – 创建一个 OLE 对象实例'
- en: '**sp_OAMethod** – calls an OLE object method'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_OAMethod** – 调用 OLE 对象方法'
- en: '**sp_OADestroy** – destroys a created OLE object'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_OADestroy** – 销毁一个创建的 OLE 对象'
- en: '**sp_OASetProperty** – sets an OLE object property'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_OASetProperty** – 设置 OLE 对象属性'
- en: 'Some practical OLE usage examples include creating a web shell on a web server,
    downloading malware, moving files around a filesystem, and executing commands.
    The **Invoke-SQLOSCmdCLR** function in PowerUpSQL will enable OLE automation,
    execute a command, read the command’s output from the temporary file, and then
    delete it. The Metasploit **admin/mssql/mssql_exec** module can be switched to
    use the **sp_OACreate** procedure as well. However, it will be up to an attacker
    on the method to retrieve results – for example, with the **OPENROWSET()** function.
    The following are commands to obtain an interactive reverse shell with the help
    of SQLRecon and **nc.exe**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实际的OLE使用示例包括在Web服务器上创建Web Shell、下载恶意软件、在文件系统中移动文件和执行命令。PowerUpSQL中的**Invoke-SQLOSCmdCLR**函数将启用OLE自动化，执行命令，从临时文件读取命令输出，然后删除该文件。Metasploit的**admin/mssql/mssql_exec**模块也可以切换到使用**sp_OACreate**过程。然而，是否能够获取结果将取决于攻击者使用的方法——例如，使用**OPENROWSET()**函数。以下是通过SQLRecon和**nc.exe**帮助获取交互式反向Shell的命令：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result of the successful execution is shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行的结果如下截图所示：
- en: '![Figure 9.18 – OS command execution through the OLE automation procedures](image/B18964_09_18.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 通过OLE自动化过程执行操作系统命令](image/B18964_09_18.jpg)'
- en: Figure 9.18 – OS command execution through the OLE automation procedures
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 通过OLE自动化过程执行操作系统命令
- en: 'The code to obtain a reverse shell manually is shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 手动获取反向Shell的代码如下所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with CLR execution, it is not possible to completely prevent this attack.
    It is recommended to keep OLE automation disabled and remove execution permissions
    on procedures stored by users. Detection is possible via **sp_configure** event
    monitoring on all the aforementioned execution methods. Additionally, event ID
    **33090** will be generated when **odsole70.dll** is loaded into memory, and event
    ID **8128** will be generated when **sp_OACreate** is executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与CLR执行一样，无法完全防止这种攻击。建议禁用OLE自动化，并移除用户存储过程的执行权限。可以通过对所有上述执行方法的**sp_configure**事件监控来进行检测。此外，当**odsole70.dll**加载到内存中时，事件ID
    **33090**将被生成，而当**sp_OACreate**被执行时，将生成事件ID **8128**。
- en: Agent jobs
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理作业
- en: 'SQL Server Agent is a Windows service that executes automated tasks. The agent
    job will run under the SQL Server Agent service, or it can utilize agent proxy
    capabilities, meaning that jobs will be run in different user contexts. The job
    can be manually started by the **sp_start_job** stored procedure, scheduled, or
    executed when a specific condition is met. To create a job, either a **sysadmin**
    role or **SQLAgentUserRole**, **SQLAgentReaderRole**, and **SQLAgentOperatorRole**
    fixed database roles in the **msdb** database are required. There are promising
    job types, such as CmdExec, PowerShell, ActiveX Script, and SQL Server Integrated
    Services, that allow command execution. The following steps are required to utilize
    a job functionality:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server Agent是一个Windows服务，用于执行自动化任务。代理作业将在SQL Server Agent服务下运行，或者可以利用代理代理功能，这意味着作业将在不同的用户上下文中运行。可以通过**sp_start_job**存储过程手动启动作业、安排作业或在特定条件满足时执行作业。要创建一个作业，需要**sysadmin**角色或**msdb**数据库中的**SQLAgentUserRole**、**SQLAgentReaderRole**和**SQLAgentOperatorRole**固定数据库角色。许多作业类型，如CmdExec、PowerShell、ActiveX脚本和SQL
    Server集成服务，支持命令执行。利用作业功能需要以下步骤：
- en: '**sp_add_job** – create a job'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_add_job** – 创建一个作业'
- en: '**sp_add_jobstep** – add a job step'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_add_jobstep** – 添加作业步骤'
- en: '**sp_start_job** – run a job'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_start_job** – 运行一个作业'
- en: '**sp_delete_job** – delete a job'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp_delete_job** – 删除作业'
- en: 'A great demonstration of the step-by-step job creation for PowerShell was shown
    in an Optiv blog post[24]. Let us create a job for CmdExec to obtain a reverse
    shell:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Optiv博客文章[24]中展示了一个逐步创建PowerShell作业的精彩示例。让我们为CmdExec创建一个作业以获取反向Shell：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Unfortunately, this code will not run in our lab because SQL Server Agent service
    cannot be started. The reason for this is that Agent jobs are supported only in
    paid MS SQL Server versions, not in Express. However, it is good to show such
    attack vector as well. As usual, there is a function in PowerUpSQL (**Invoke-SQLOSCmdAgentJob)**
    and two modules in SQLRecon (**AgentStatus** and **AgentCmd**) to automate the
    task. Instead of creating a new job, the attacker can add a step to an existing
    one. To list all jobs, there is the **Get-SQLAgentJob** function in PowerUpSQL
    or the following query:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码在我们的实验室中无法运行，因为SQL Server Agent服务无法启动。原因是Agent作业仅在付费版MS SQL Server中支持，而在Express版中不支持。然而，展示这种攻击向量也是很有意义的。像往常一样，PowerUpSQL中有一个函数（**Invoke-SQLOSCmdAgentJob**）和SQLRecon中的两个模块（**AgentStatus**和**AgentCmd**）可以自动化该任务。攻击者可以通过添加一个步骤到现有作业中，而不是创建一个新的作业。要列出所有作业，可以使用PowerUpSQL中的**Get-SQLAgentJob**函数或以下查询：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Prevention recommendations including disabling the SQL Server Agent service
    if it is not used and limiting users with **SQLAgentUserRole**, **SQLAgentReaderRole**,
    and **SQLAgentOperatorRole** fixed database roles.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 预防建议包括禁用SQL Server Agent服务（如果没有使用的话），并限制具有**SQLAgentUserRole**、**SQLAgentReaderRole**和**SQLAgentOperatorRole**固定数据库角色的用户。
- en: External scripts
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部脚本
- en: There is another way to run commands with the help of the Machine Learning Services
    feature. It gives you the ability to run R and Python scripts. Installation of
    this feature requires a paid version of the SQL Server. In our case, we will use
    the free Express version and just briefly go through available ways to run commands.
    First of all, to enable external scripts, **sysadmin** privileges are required,
    together with server-level changes (**sp_configure 'external scripts enabled'**).
    Both languages have a wide variety of ways to run arbitrary code, ranging from
    UNC path injection to full interactive shell. Some interesting examples can be
    found in[25] and in[26]. The **Invoke-SQLOSCmdR** and **Invoke-SQLOSCmdPython**
    functions from PowerUpSQL can also automate the exploitation process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以借助机器学习服务功能运行命令。它使你能够运行R和Python脚本。安装此功能需要SQL Server的付费版本。在我们的例子中，我们将使用免费的Express版本，并简要了解可用的运行命令的方法。首先，要启用外部脚本，需要**sysadmin**权限，并进行服务器级别的更改（**sp_configure
    'external scripts enabled'**）。这两种语言有许多运行任意代码的方法，从UNC路径注入到完全交互式Shell。一些有趣的示例可以在[25]和[26]中找到。PowerUpSQL中的**Invoke-SQLOSCmdR**和**Invoke-SQLOSCmdPython**函数也可以自动化利用过程。
- en: In the following section, we will examine ways in which an attacker can move
    laterally on the domain and database levels in the target environment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨攻击者如何在目标环境的域和数据库层面进行横向移动。
- en: Lateral movement
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 横向移动
- en: As we saw in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093), it is crucial
    to understand how an adversary can abuse legitimate applications and protocols
    to expand inside the target environment. SQL Server also broadens lateral movement
    scenarios via two techniques. One is common and called shared service accounts.
    The other one is specific only to SQL Server – abusing database links. We will
    quickly explore the first one and focus on the second. We will examine how to
    do enumeration on linked servers, execute code, and extract clear-text hardcoded
    credentials.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第5章*](B18964_05.xhtml#_idTextAnchor093)中看到的，理解攻击者如何滥用合法的应用程序和协议以在目标环境内扩展是至关重要的。SQL
    Server还通过两种技术拓宽了横向移动的场景。一种是常见的，叫做共享服务账户。另一种则是SQL Server特有的——滥用数据库链接。我们将快速探讨第一个方法，重点关注第二种方法。我们将检查如何对链接服务器进行枚举、执行代码并提取明文硬编码凭证。
- en: Shared service accounts
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享服务账户
- en: Using shared service accounts across an environment may lead to disastrous consequences.
    If a service account is compromised via Kerberoasting, UNC path injection, or
    any other way, it means that all instances using this account are compromised.
    Moreover, the service account by default has **sysadmin** privileges on the database
    and SQL Server levels, but it also may have extensive privileges on the underlying
    OS. To prevent such a powerful lateral move, all service accounts should be unique
    across the environment, with gMSA in use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个环境中使用共享服务账户可能会导致灾难性的后果。如果一个服务账户通过Kerberoasting、UNC路径注入或其他任何方式被攻破，这意味着所有使用该账户的实例都会被攻破。此外，服务账户默认在数据库和SQL
    Server级别具有**sysadmin**权限，并且可能在底层操作系统上具有广泛的权限。为了防止这种强大的横向移动，所有服务账户应在整个环境中保持唯一，并使用gMSA。
- en: Database links
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库链接
- en: What are database links? In simple terms, they are a persistent connection between
    two or more servers. They allow you to access external data sources and, if the
    source is a SQL Server, also execute stored procedures. Links work even across
    forest trusts and can sometimes be the only way to get a foothold in another domain
    or forest. There are two ways links can be configured – with a current logged-in
    user context or hardcoded credentials. Queries on the linked server are executed
    as a user whose credentials were used to configure the link. Effectively, it is
    impersonation. Links can be crawled, meaning that an adversary can jump consequently
    from one SQL Server to another. We need to understand who we are, perform enumeration,
    and look for privilege escalation or lateral movement options.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是数据库链接？简单来说，它是两个或多个服务器之间的持久连接。它们允许你访问外部数据源，并且如果源是SQL Server，还可以执行存储过程。链接即使跨越森林信任，也能正常工作，有时它可能是进入另一个域或森林的唯一途径。链接的配置方式有两种——使用当前登录用户的上下文或硬编码凭据。对链接服务器的查询是以用于配置链接的用户凭据执行的。实际上，这是冒充用户。链接可以被爬取，意味着攻击者可以从一个SQL
    Server跳到另一个SQL Server。我们需要了解我们是谁，进行枚举，并寻找权限提升或横向移动的选项。
- en: An ideal attacking scenario is to identify linked servers, check user account
    privileges on them, verify the **RPC Out** value, and enable **xp_cmdshell** to
    obtain command execution. **RPC Out** allows you to run stored procedures on the
    specified linked server and can only be enabled with **sysadmin** privileges,
    using the **sp_serveroption** procedure. If **RPC Out** is disabled, it will be
    impossible to enable **xp_cmdshell** on the linked server, even with **sysadmin**
    privileges. The reason for this is that queries running via **openquery()** do
    not require **RECONFIGURE** to be run.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的攻击场景是识别链接服务器，检查用户帐户权限，验证**RPC Out**值，并启用**xp_cmdshell**以获得命令执行权限。**RPC Out**允许在指定的链接服务器上运行存储过程，并且只能通过**sysadmin**权限启用，使用**sp_serveroption**过程。如果**RPC
    Out**被禁用，即使拥有**sysadmin**权限，也无法在链接服务器上启用**xp_cmdshell**。原因是，通过**openquery()**运行的查询不需要执行**RECONFIGURE**。
- en: 'PowerUpSQL has two functions (**Get-SQLServerLink** and **Get-SQLServerLinkCrawl**)
    that help to identify links. Metasploit has its own module called **exploit/windows/mssql/mssql_linkcrawler**
    that can deploy payloads in a fully automated way. The attack steps are as follows:
    find the linked server, enumerate it, understand the login context, and then escalate
    privileges and/or move them laterally.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: PowerUpSQL有两个功能（**Get-SQLServerLink**和**Get-SQLServerLinkCrawl**）可以帮助识别链接。Metasploit有自己的模块，叫做**exploit/windows/mssql/mssql_linkcrawler**，可以完全自动化地部署有效载荷。攻击步骤如下：找到链接服务器，枚举它，了解登录上下文，然后提升权限和/或进行横向移动。
- en: 'We will use SQLRecon for the rest of this section. I logged in as **jon.snow**
    to perform all the aforementioned actions with the following commands:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中使用SQLRecon。我以**jon.snow**身份登录，使用以下命令执行上述所有操作：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output of the commands executed on the linked server:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行在链接服务器上的命令输出：
- en: '![Figure 9.19 – Linked server enumeration](image/B18964_09_19.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 链接服务器枚举](image/B18964_09_19.jpg)'
- en: Figure 9.19 – Linked server enumeration
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 链接服务器枚举
- en: 'The successful command execution gave us an interactive shell on the target:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的命令执行为我们提供了目标的交互式Shell：
- en: '![Figure 9.20 – An interactive reverse shell on the linked server](image/B18964_09_20.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20 – 链接服务器上的交互式反向Shell](image/B18964_09_20.jpg)'
- en: Figure 9.20 – An interactive reverse shell on the linked server
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 链接服务器上的交互式反向Shell
- en: At the beginning of this section, we mentioned hardcoded credentials. If SQL
    Server credentials are used to create links, they are stored in an encrypted format
    and, therefore, can be pulled in clear text[27]. Successful extraction requires
    **sysadmin** privileges for all database instances on a **Dedicated Administrative
    Connection** (**DAC**) and local administrative privileges on the server itself
    to get access to entropy bytes in the registry. These bytes are used to strengthen
    encryption and are stored in the registry. The script pulls data from a few tables
    as well. If everything works as expected, you will extract clear-text passwords.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我们提到过硬编码凭据。如果 SQL Server 凭据用于创建链接，这些凭据会以加密格式存储，因此可以以明文形式提取[27]。成功提取要求在
    **专用管理连接**（**DAC**）上的所有数据库实例中拥有 **sysadmin** 权限，并且在服务器本地具有管理员权限，以访问注册表中的熵字节。这些字节用于加强加密并存储在注册表中。该脚本还会从几个表中提取数据。如果一切顺利，你将提取到明文密码。
- en: 'One more interesting use of linked servers is LDAP enumeration via OpenQuery[28].
    We will need a set of valid domain credentials before we start. They can be obtained
    by cracking the NTLMv2 challenge after a UNC path injection attack or by simply
    utilizing the domain account of the SQL service. The idea is to establish an **Active
    Directory Service Interface** (**ADSI**) linked server and run LDAP queries via
    OpenQuery:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的使用场景是通过 OpenQuery 进行 LDAP 枚举[28]。在开始之前，我们需要一组有效的域凭据。可以通过破解 NTLMv2 挑战，进行
    UNC 路径注入攻击后获得，或者简单地利用 SQL 服务的域帐户。基本思想是建立一个 **Active Directory 服务接口**（**ADSI**）链接服务器，并通过
    OpenQuery 执行 LDAP 查询：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如以下截图所示：
- en: '![Figure 9.21 – Domain user enumeration via OpenQuery](image/B18964_09_21.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 通过 OpenQuery 进行域用户枚举](image/B18964_09_21.jpg)'
- en: Figure 9.21 – Domain user enumeration via OpenQuery
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 通过 OpenQuery 进行域用户枚举
- en: To prevent link abuse, remove unused links and check chained links as well.
    Ensure that links are not configured with **sysadmin** or overly permissive privileges.
    Consider disabling **RPC Out** as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止链接滥用，移除未使用的链接，并检查链式链接。确保链接没有配置 **sysadmin** 或过于宽松的权限。考虑禁用 **RPC Out**。
- en: The following section will show how persistence can be achieved at the SQL Server
    and OS levels by using legitimate functionality from SQL Server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将展示如何通过使用 SQL Server 的合法功能，在 SQL Server 和操作系统层面实现持久性。
- en: Persistence
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性
- en: Now that we know about persistence on domain and domain controller levels, why
    bother with SQL Server? Most detective controls are implemented at the OS level.
    Database audits are not so common and thorough. A SQL Server service account may
    have extensive permissions on the OS, giving an attacker an excellent hideout,
    as all questionable actions will be logged as they were performed by the service
    account. Lastly, even if auditing and monitoring are enabled on busy databases,
    it is difficult to differentiate legitimate activities from malicious ones. We
    will start with the most noisy and unsafe way to achieve persistence at the OS
    level via autoruns, moving toward the SQL Server level, with startup procedures
    and triggers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了域和域控制器级别的持久性，为什么还要关心 SQL Server 呢？大多数侦测控制措施是在操作系统层面实现的，而数据库审计则不太常见且不够彻底。SQL
    Server 服务帐户可能在操作系统上拥有广泛的权限，这为攻击者提供了一个绝佳的藏身之处，因为所有可疑的操作都会被记录为由服务帐户执行的。最后，即使在繁忙的数据库上启用了审计和监控，也很难将合法活动与恶意活动区分开。我们将从通过自动运行在操作系统层面实现持久性的最吵杂且不安全的方式开始，然后逐步过渡到
    SQL Server 层面，使用启动程序和触发器。
- en: File and registry autoruns
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和注册表自动运行
- en: These two methods are very OpSec-unsafe, as the **Startup** folder and registry
    keys are often monitored by security solutions, such as Sysmon and EDR. There
    is a slight chance that writing a file in such locations using a SQL Server service
    account will be treated as legitimate behavior. Again, it is highly not recommended.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在操作安全性上非常不安全，因为 **Startup** 文件夹和注册表项通常会被安全解决方案（如 Sysmon 和 EDR）监控。在这些位置写入文件，使用
    SQL Server 服务帐户，可能会被视为合法行为。再说一次，强烈不推荐这么做。
- en: 'We will start by writing a file to the **Startup** folder. If the SQL Server
    service account is configured with extensive permissions on the host, it is possible
    to put the file in a folder of a high-privileged user, or even for all users.
    The OLE automation procedure must be enabled beforehand. The following code creates
    a batch file in the **sql_svc** **Startup** folder that will make a connection
    back to our machine:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从写入文件到 **Startup** 文件夹开始。如果 SQL Server 服务帐户在主机上配置了广泛的权限，便可以将文件放入具有高权限用户的文件夹，甚至是所有用户的文件夹。必须提前启用
    OLE 自动化过程。以下代码将在 **sql_svc** 的 **Startup** 文件夹中创建一个批处理文件，该文件将与我们的机器建立连接：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On the next login of **sql_svc**, we receive the connection back, as shown
    in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **sql_svc** 的下次登录时，我们会收到连接，如下图所示：
- en: '![Figure 9.22 – The reverse shell from the file in the Startup folder](image/B18964_09_22.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 来自启动文件夹中文件的反向 shell](image/B18964_09_22.jpg)'
- en: Figure 9.22 – The reverse shell from the file in the Startup folder
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 来自启动文件夹中文件的反向 shell
- en: 'SQL Server also allows you to interact with the registry using stored procedures
    – **xp_regwrite**, **xp_regread**, and **xp_regdeletekey**. Executing these procedures
    requires **sysadmin** privileges. However, at the OS level, this is not enough
    – for example, writing to **HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    hive** requires local administrative privileges. PowerUpSQL has three functions
    that use the registry for persistence:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 还允许你通过存储过程与注册表交互——**xp_regwrite**、**xp_regread** 和 **xp_regdeletekey**。执行这些存储过程需要**sysadmin**权限。然而，在操作系统层面，这还不够——例如，写入
    **HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run hive** 需要本地管理员权限。PowerUpSQL
    有三个使用注册表来实现持久化的功能：
- en: '**Get-SQLPersistRegDebugger** – setting a custom debugger for accessibility
    options'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-SQLPersistRegDebugger** – 为辅助功能选项设置自定义调试器'
- en: '**Get-SQLPersistRegRun** – writing a payload in the autorun key'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-SQLPersistRegRun** – 在自动运行键中写入有效载荷'
- en: '**Get-SQLRecoverPwAutoLogon** – reading autologin passwords'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Get-SQLRecoverPwAutoLogon** – 读取自动登录密码'
- en: Now, let us examine some more OpSec safe options for persistence at the database
    level.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些在数据库级别持久化的更加安全的 OpSec 选项。
- en: Startup stored procedures
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动存储过程
- en: 'As you can guess from the name of this type of procedure, it runs when SQL
    Server starts or restarts. All such procedures run under the **sa** login, must
    be owned by **sa**, and must be in the master database. To mark a procedure for
    automated execution, **sysadmin** privileges are required, but not necessary **sa**.
    Procedures cannot accept any input/output parameters. The following code creates
    our malicious procedure (**sp_rev_shell**), marks it for automated execution,
    and lists automatically executed stored procedures:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这种类型的过程名称中可以猜到的，它会在 SQL Server 启动或重启时运行。所有此类过程都在 **sa** 登录下运行，必须由 **sa**
    拥有，并且必须位于 master 数据库中。为了标记一个过程为自动执行，**sysadmin** 权限是必需的，但不一定是 **sa**。过程不能接受任何输入/输出参数。以下代码创建了我们的恶意过程（**sp_rev_shell**），标记其为自动执行，并列出自动执行的存储过程：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the SQL Server service restart, the reverse shell was executed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 服务重启后，反向 shell 被执行：
- en: '![Figure 9.23 – Persistence via a startup stored procedure](image/B18964_09_23.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 通过启动存储过程实现持久化](image/B18964_09_23.jpg)'
- en: Figure 9.23 – Persistence via a startup stored procedure
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 通过启动存储过程实现持久化
- en: 'There is also a PowerShell script that automates these actions[30]. It incorporates
    three persistence scenarios – creating a new SQL Server **sysadmin** login, creating
    a Windows local administrator account, and running a PowerShell command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 PowerShell 脚本，自动化这些操作[30]。它包含三种持久化场景——创建一个新的 SQL Server **sysadmin** 登录，创建一个
    Windows 本地管理员帐户，以及运行 PowerShell 命令：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of the script execution is shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行结果如下所示：
- en: '![Figure 9.24 – Fully automated sysadmin user creation](image/B18964_09_24.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 完全自动化的 sysadmin 用户创建](image/B18964_09_24.jpg)'
- en: Figure 9.24 – Fully automated sysadmin user creation
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 完全自动化的 sysadmin 用户创建
- en: The main disadvantage of this method is that we must wait for the maintenance
    of the SQL Server. NetSPI’s blog post[29] shows how to enable server- and database-level
    audit features. They detect the use of the **sp_procoption** procedure (event
    ID **33205**), the launch of a malicious startup procedure (event ID **17135**),
    and a new SQL Server login with **sysadmin** privileges (event ID **33205**).
    Lastly, if an adversary decides to change or delete audit settings, event ID **33205**
    will be generated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是我们必须等待 SQL Server 的维护。NetSPI 的博客文章[29]展示了如何启用服务器级别和数据库级别的审计功能。它们可以检测使用**sp_procoption**过程（事件
    ID **33205**）、启动恶意启动过程（事件 ID **17135**）以及使用 **sysadmin** 权限的 SQL Server 新登录（事件
    ID **33205**）。最后，如果攻击者决定更改或删除审计设置，事件 ID **33205** 将会生成。
- en: Malicious triggers
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶意触发器
- en: 'What is a trigger? According to Microsoft, “*a trigger is a special type of
    stored procedure that automatically runs when an event occurs in the database
    server*”[31]. There are three types of triggers, which differ based on the execution
    condition:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是触发器？根据 Microsoft 的定义，“*触发器是一种特殊类型的存储过程，当数据库服务器中发生某个事件时，它会自动运行*”[31]。触发器有三种类型，依据执行条件的不同而有所区别：
- en: '**Data Definition Language** (**DDL**) – **CREATE**, **ALTER**, and **DROP**
    statements'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据定义语言**（**DDL**）– **CREATE**、**ALTER** 和 **DROP** 语句'
- en: '**Data Manipulation Language** (**DML**) – **INSERT**, **UPDATE**, and **DELETE**
    statements'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据操作语言**（**DML**）– **INSERT**、**UPDATE** 和 **DELETE** 语句'
- en: '**Logon triggers** – an on-logon event'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录触发器** – 一个登录事件'
- en: 'A DDL trigger applies at the server and database levels. There are tons of
    DDL events and event groups[32] that can be used to create a trigger. Some of
    them can happen every few minutes in busy environments, so choose wisely. Trigger
    creation is as simple as the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: DDL 触发器适用于服务器和数据库级别。有很多 DDL 事件和事件组[32]可以用来创建触发器。在繁忙的环境中，有些事件可能每隔几分钟就会发生，因此需要谨慎选择。触发器的创建就像下面的代码一样简单：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'DML triggers work only at the database level. We will choose a statement and
    table. The important caveat is that users working with the target table may not
    have enough permissions for actions such as running **xp_cmdshell**. NetSPI in
    their blog[33] advises to either grant an **sa** impersonation permission for
    all users or use a proxy account for **xp_cmdshell** execution. The following
    code will create a DML trigger:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: DML 触发器仅在数据库级别工作。我们将选择一个语句和表。一个重要的警告是，与目标表一起工作的用户可能没有足够的权限执行诸如运行 **xp_cmdshell**
    之类的操作。NetSPI 在其博客[33]中建议，应该为所有用户授予 **sa** 模拟权限，或者使用代理账户执行 **xp_cmdshell**。以下代码将创建一个
    DML 触发器：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Logon triggers are used to prevent users from logging in depending on certain
    conditions. Instead of using a real user login, an attacker can create a low-privileged
    fake account and utilize it when persistence is required. The code for such a
    trigger is self-explanatory:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 登录触发器用于根据特定条件防止用户登录。攻击者可以创建一个低权限的假账户，并在需要保持持久性时使用它，而不是使用真实的用户登录。这样的触发器代码不言自明：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Trying to log in with a fake account will trigger the connection but also leave
    an error in the log, with the event ID **17892**. With enabled audit features,
    trigger creation code will be fully logged in the event ID **33205**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用假账户登录会触发连接，但也会在日志中留下一个错误，事件 ID 为**17892**。启用审计功能后，触发器创建代码将在事件 ID **33205**
    中完全记录。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In conclusion, there are many reasons for an adversary to choose SQL Server
    as a valuable target. We saw in practice how to perform enumeration against a
    database server. We deep-dived into various privilege escalation techniques, not
    focusing only on the database level. By gradually migrating from a low-privileged
    public account to **SYSTEM**, we covered the attacker’s kill chain. Then, many
    techniques for OS command execution were demonstrated in order to help us understand
    how tightly applications can be integrated with a host OS. Furthermore, we saw
    how database links can be abused by an adversary for lateral movement if they
    are not configured correctly. Finally, persistence techniques were discussed at
    the OS and database levels. A deeper understanding of available database functionality
    can give one party an advantage over the other.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，有很多原因让对手选择 SQL Server 作为一个有价值的目标。我们通过实践演示了如何对数据库服务器进行枚举。我们深入探讨了各种权限提升技巧，不仅仅局限于数据库级别。通过从一个低权限的公共账户逐步迁移到**SYSTEM**，我们涵盖了攻击者的“杀链”。接着，演示了多种操作系统命令执行技巧，以帮助我们理解应用程序与宿主操作系统的集成程度。此外，我们还看到，如果数据库链接配置不当，攻击者可能会利用这些链接进行横向移动。最后，我们讨论了操作系统和数据库层面的持久化技术。对可用数据库功能的深入理解，可能会使一方相对于另一方占据优势。
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些进一步学习的资料，帮助你更深入理解本章中涉及的攻击：
- en: 'SQL Server network ports: [https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/](https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/)'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SQL Server 网络端口: [https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/](https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/)'
- en: 'SQL Server 2022 new fixed server-level roles: [https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16)'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SQL Server 2022 新的固定服务器级角色: [https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16)'
- en: 'Pre-SQL Server 2022 fixed server-level roles: [https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/](https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/)'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SQL Server 2022 之前的固定服务器级角色: [https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/](https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/)'
- en: 'SQLRecon tool: [https://github.com/skahwah/SQLRecon](https://github.com/skahwah/SQLRecon)'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SQLRecon 工具: [https://github.com/skahwah/SQLRecon](https://github.com/skahwah/SQLRecon)'
- en: 'PowerUpSQL tool: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL)'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'PowerUpSQL 工具: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL)'
- en: 'PowerUpSQL Cheat Sheet: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'PowerUpSQL备忘单: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)'
- en: 'HeidiSQL tool: https://www.heidisql.com/'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'HeidiSQL 工具: https://www.heidisql.com/'
- en: 'MS SQL Server enumeration: https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server#common-enumeration'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'MS SQL Server 枚举: https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server#common-enumeration'
- en: 'MS SQL Server enumeration 2: https://ppn.snovvcrash.rocks/pentest/infrastructure/dbms/mssql#enumeration'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'MS SQL Server 枚举 2: https://ppn.snovvcrash.rocks/pentest/infrastructure/dbms/mssql#enumeration'
- en: 'User impersonation: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '用户伪装: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/'
- en: 'Attacking (un)trustworthy databases: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '攻击（不）可信的数据库: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/'
- en: 'Escalating from a **db_owner** script: https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从**db_owner**脚本提升权限: https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1'
- en: 'MS SQL Coerce: https://github.com/p0dalirius/MSSQL-Analysis-Coerce'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'MS SQL Coerce: https://github.com/p0dalirius/MSSQL-Analysis-Coerce'
- en: 'JuicyPotato: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'JuicyPotato: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato'
- en: 'RoguePotato, PrintSpoofer, SharpEfsPotato, and GodPotato: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'RoguePotato, PrintSpoofer, SharpEfsPotato 和 GodPotato: [https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer)'
- en: 'Obtaining SQL Server **sysadmin** privileges from a local administrator: https://www.netspi.com/blog/technical/network-penetration-testing/get-sql-server-sysadmin-privileges-local-admin-powerupsql/'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从本地管理员获取 SQL Server **sysadmin** 权限: [https://www.netspi.com/blog/technical/network-penetration-testing/get-sql-server-sysadmin-privileges-local-admin-powerupsql/](https://www.netspi.com/blog/technical/network-penetration-testing/get-sql-server-sysadmin-privileges-local-admin-powerupsql/)'
- en: 'Extracting SQL Server hashes from a **master.mdf** file: https://xpnsec.tumblr.com/post/145350063196/reading-mdf-hashes-with-powershell'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从 **master.mdf** 文件中提取 SQL Server 哈希值: [https://xpnsec.tumblr.com/post/145350063196/reading-mdf-hashes-with-powershell](https://xpnsec.tumblr.com/post/145350063196/reading-mdf-hashes-with-powershell)'
- en: '**Invoke-MDFHashes**: https://github.com/xpn/Powershell-PostExploitation/tree/master/Invoke-MDFHashes'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Invoke-MDFHashes**: [https://github.com/xpn/Powershell-PostExploitation/tree/master/Invoke-MDFHashes](https://github.com/xpn/Powershell-PostExploitation/tree/master/Invoke-MDFHashes)'
- en: 'Custom extended stored procedure DLL template: https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/xp_evil_template.cpp'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '自定义扩展存储过程 DLL 模板: [https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/xp_evil_template.cpp](https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/xp_evil_template.cpp)'
- en: 'SQL Server CLR assemblies: https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SQL Server CLR 程序集: [https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/](https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/)'
- en: 'CLR strict security: https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-ver16'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'CLR 严格安全性: [https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-ver16)'
- en: 'SeeCLRly tool: https://github.com/sekirkity/SeeCLRly'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SeeCLRly 工具: [https://github.com/sekirkity/SeeCLRly](https://github.com/sekirkity/SeeCLRly)'
- en: 'Exploit OLE Automation: https://www.imperva.com/blog/how-to-exploit-sql-server-using-ole-automation/'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '利用 OLE 自动化: [https://www.imperva.com/blog/how-to-exploit-sql-server-using-ole-automation/](https://www.imperva.com/blog/how-to-exploit-sql-server-using-ole-automation/)'
- en: 'Agent job command execution: https://www.optiv.com/explore-optiv-insights/blog/mssql-agent-jobs-command-execution'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '代理作业命令执行: [https://www.optiv.com/explore-optiv-insights/blog/mssql-agent-jobs-command-execution](https://www.optiv.com/explore-optiv-insights/blog/mssql-agent-jobs-command-execution)'
- en: 'External script execution: https://cheats.philkeeble.com/active-directory/mssql#external-scripts'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '外部脚本执行: [https://cheats.philkeeble.com/active-directory/mssql#external-scripts](https://cheats.philkeeble.com/active-directory/mssql#external-scripts)'
- en: '*Beyond xp_cmdshell* by*nullbind*: https://www.slideshare.net/nullbind/beyond-xpcmdshell-owning-the-empire-through-sql-server'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Beyond xp_cmdshell* 由 *nullbind* 提供: [https://www.slideshare.net/nullbind/beyond-xpcmdshell-owning-the-empire-through-sql-server](https://www.slideshare.net/nullbind/beyond-xpcmdshell-owning-the-empire-through-sql-server)'
- en: 'Decrypting linked server passwords: https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '解密链接服务器密码: [https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/](https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/)'
- en: 'LDAP enumeration via OpenQuery: https://keramas.github.io/2020/03/28/mssql-ad-enumeration2.xhtml'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过 OpenQuery 进行 LDAP 枚举: [https://keramas.github.io/2020/03/28/mssql-ad-enumeration2.xhtml](https://keramas.github.io/2020/03/28/mssql-ad-enumeration2.xhtml)'
- en: 'Persistence via startup stored procedures: https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-persistence-part-1-startup-stored-procedures/'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过启动存储过程保持持久性: [https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-persistence-part-1-startup-stored-procedures/](https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-persistence-part-1-startup-stored-procedures/)'
- en: '**Invoke-SqlServer-Persist-StartupSp** script: https://github.com/NetSPI/PowerUpSQL/blob/master/scripts/pending/Invoke-SqlServer-Persist-StartupSp.psm1'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Invoke-SqlServer-Persist-StartupSp** 脚本: [https://github.com/NetSPI/PowerUpSQL/blob/master/scripts/pending/Invoke-SqlServer-Persist-StartupSp.psm1](https://github.com/NetSPI/PowerUpSQL/blob/master/scripts/pending/Invoke-SqlServer-Persist-StartupSp.psm1)'
- en: 'Triggers: https://learn.microsoft.com/en-us/sql/t-sql/statements/create-trigger-transact-sql?view=sql-server-ver16'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '触发器: [https://learn.microsoft.com/en-us/sql/t-sql/statements/create-trigger-transact-sql?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-trigger-transact-sql?view=sql-server-ver16)'
- en: 'DDL event groups: https://learn.microsoft.com/en-us/sql/relational-databases/triggers/ddl-event-groups?view=sql-server-ver16'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'DDL 事件组: [https://learn.microsoft.com/en-us/sql/relational-databases/triggers/ddl-event-groups?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/relational-databases/triggers/ddl-event-groups?view=sql-server-ver16)'
- en: 'Persistence via triggers: https://www.netspi.com/blog/technical/network-penetration-testing/maintaining-persistence-via-sql-server-part-2-triggers/'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过触发器保持持久性: [https://www.netspi.com/blog/technical/network-penetration-testing/maintaining-persistence-via-sql-server-part-2-triggers/](https://www.netspi.com/blog/technical/network-penetration-testing/maintaining-persistence-via-sql-server-part-2-triggers/)'
