- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Reconnaissance and Information Gathering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侦察和信息收集
- en: Previous chapters introduced you to Bash scripting concepts. In some cases,
    we ran applications that were not made with Bash. In those cases, we used Bash
    to execute programs, pipe data between applications, or parse the output of these
    tools. As we progress further into this book, we will be demonstrating less pure
    Bash and more on using Bash to execute our pentesting tools, automate them, and
    parse their output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章向你介绍了Bash脚本编写的概念。在某些情况下，我们运行的应用程序并不是用Bash编写的。在这些情况下，我们使用Bash来执行程序，在应用程序之间传递数据，或解析这些工具的输出。随着我们在本书中的进展，我们将展示更少的纯Bash，更多地使用Bash来执行我们的渗透测试工具，自动化它们，并解析它们的输出。
- en: 'In this chapter, we dive into the essential first step of any pentest: reconnaissance.
    You’ll learn how to discover email addresses and assets owned by your target organization
    using various tools and techniques. This foundational knowledge will set the stage
    for more active assessments in later chapters.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了任何渗透测试的基本第一步：侦察。你将学习如何使用各种工具和技术发现目标组织拥有的电子邮件地址和资产。这些基础知识将为后续章节中更积极的评估奠定基础。
- en: Important note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t expect this and the following chapters to be a thorough reference on performing
    pentesting. I will not be demonstrating every step, technique, and tool here.
    This book is meant to teach you how to augment your pentests with Bash scripting,
    not how to do pentesting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望本章和后续章节是有关进行渗透测试的全面参考。我不会在这里演示每一步、技术和工具。这本书旨在教你如何用Bash脚本增强你的渗透测试，而不是如何进行渗透测试。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to reconnaissance with Bash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用Bash进行侦察
- en: Formatting usernames and email addresses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化用户名和电子邮件地址
- en: Using Bash for DNS enumeration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bash进行DNS枚举
- en: Using Bash to identify web applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bash识别Web应用程序
- en: By the end of this chapter, you’ll be proficient with using Bash with **Open
    source intelligence** ( **OSINT** ) tools and sources to discover domain names,
    email addresses, and IP addresses of your target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将能够熟练使用Bash与**开源情报**（**OSINT**）工具和来源，发现目标的域名、电子邮件地址和IP地址。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The main prerequisite is that you started reading from [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017)
    and have access to a Bash shell. If you aren’t using Kali Linux, you will likely
    find it more difficult to follow along. One script detailed later in this chapter
    requires a ProjectDiscovery Chaos API key ( [https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)
    ), which can be obtained for free at the time of writing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的先决条件是你从[*第1章*](B22229_01.xhtml#_idTextAnchor017)开始阅读，并且可以访问Bash shell。如果你没有使用Kali
    Linux，那么你可能会发现跟随更加困难。本章后面详细介绍的一个脚本需要一个ProjectDiscovery Chaos API密钥（[https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)），可以在撰写时免费获取。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08)
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08)找到。
- en: 'Install the prerequisites in Kali Linux using the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在Kali Linux中安装先决条件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You must also have Golang and the Chaos client installed. Installing Golang
    was documented fully in [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017) . You
    can install the Chaos client with the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须安装Golang和Chaos客户端。在[*第1章*](B22229_01.xhtml#_idTextAnchor017)中有完整的Golang安装文档。你可以使用以下命令安装Chaos客户端：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Introducing reconnaissance with Bash
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍使用Bash进行侦察
- en: The urge to jump straight to scanning and hacking can be hard to overcome when
    you’re passionate about pentesting. I’ve lost count of the number of times in
    my career that I’ve done a less than thorough job of reconnaissance before jumping
    to active scanning only to later hit a wall. That’s when I find that circling
    back to the recon phase and finding some juicy nuggets is the key to success.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对渗透测试充满热情时，直接进行扫描和攻击的冲动可能很难克服。在我的职业生涯中，有很多次我在进行主动扫描之前没有做到彻底的侦察工作，后来遇到了困难。这时，我发现回到侦察阶段，找到一些有价值的信息是成功的关键。
- en: One pentest I did years ago stands out in my memories above the rest. I was
    pentesting a simple web page with a login form. Nothing else was in scope. I wasn’t
    given any credentials. If I managed to find working credentials or bypass the
    login form, it was game over.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前我做过的一次渗透测试在我的记忆中脱颖而出。我当时正在对一个简单的带有登录表单的网页进行渗透测试。没有其他内容在范围内。我没有获得任何凭据。如果我设法找到有效的凭据或绕过登录表单，那就游戏结束。
- en: I thoroughly attacked the login form for three days and had nothing to show
    for it. That’s when I circled back to reconnaissance. I ended up finding that
    the company had a GitHub account with some public repositories. One of those repositories
    contained credentials hidden in old commits. The credentials had been removed,
    but Git maintains versioning and history, which allowed me to pull them out and
    use them. After logging in and being redirected, I found myself in complete control
    of a financial application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我彻底攻击了登录表单三天，却一无所获。这时我回到了侦察阶段。最终我发现公司有一个GitHub账户，其中包含一些公共存储库。其中一个存储库包含在旧提交中隐藏的凭据。这些凭据已被删除，但Git保留了版本和历史记录，这使我能够提取并使用它们。登录并被重定向后，我发现自己完全控制了一个财务应用程序。
- en: Every type of pentest depends on doing research before attacking the target.
    The most successful physical pentest I’ve done was successful because we researched
    our target company employees and found high-resolution photos of employee events
    on social media, which helped us to create very convincing clones of their badges.
    While our badges wouldn’t open doors with electronic badge readers, together with
    our confidence and pretext (the story we told the employees to explain why we
    were visiting), we convinced employees to give us access. On a wireless pentest
    of the same company, we were able to access their employee wireless network from
    the parking lot because we first checked their social media and websites and used
    Bash to make a wordlist of words and terms to use for password cracking.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每种渗透测试都取决于在攻击目标之前进行研究。我做过的最成功的物理渗透测试之所以成功，是因为我们研究了目标公司的员工，并在社交媒体上找到了员工活动的高分辨率照片，这帮助我们制作了非常逼真的员工工牌副本。虽然我们的工牌无法通过电子工牌读卡器打开门，但结合我们的信心和借口（我们告诉员工为什么要访问的故事），我们说服员工给予我们访问权限。在同一家公司的无线渗透测试中，我们能够从停车场访问他们的员工无线网络，因为我们首先检查了他们的社交媒体和网站，并使用Bash制作了用于密码破解的单词和术语列表。
- en: OSINT is the process of collecting and analyzing information from publicly available
    sources to produce actionable intelligence. This type of intelligence gathering
    leverages data from various media, including the internet, social networks, public
    records, and news reports. OSINT can aid in a wide range of activities, from national
    security to cybersecurity, providing valuable insights without the need for illicit
    methods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OSINT是从公开来源收集和分析信息以产生可操作情报的过程。这种情报收集利用了来自各种媒体的数据，包括互联网、社交网络、公共记录和新闻报道。OSINT可以在从国家安全到网络安全的各种活动中提供有价值的见解，而无需使用非法方法。
- en: The importance of OSINT lies in its ability to offer a comprehensive view of
    a target’s available information, which can be critical in both offensive and
    defensive security measures. For security pentests, OSINT helps identify potential
    vulnerabilities, gather details about the target’s infrastructure, and understand
    the organizational and personal behaviors that might be exploited by malicious
    actors. The insights gained through OSINT enable testers to emulate potential
    real-world attacks more effectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OSINT的重要性在于其能够提供目标可用信息的全面视图，这对于攻击性和防御性安全措施都至关重要。对于安全渗透测试，OSINT有助于识别潜在的漏洞，收集有关目标基础设施的详细信息，并了解可能被恶意行为者利用的组织和个人行为。通过OSINT获得的见解使测试人员能够更有效地模拟潜在的现实世界攻击。
- en: In preparation for a security pentest, the types of data gathered during OSINT
    include domain and IP address information, employee details, email addresses,
    social media profiles, document metadata, network configurations, and software
    versions. This information helps build a detailed profile of the target, uncovering
    entry points that might be exploited for unauthorized access or data breaches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行安全渗透测试之前，OSINT期间收集的数据类型包括域名和IP地址信息、员工详细信息、电子邮件地址、社交媒体资料、文档元数据、网络配置和软件版本。这些信息有助于构建目标的详细资料，揭示可能被利用进行未经授权访问或数据泄露的入口点。
- en: In the next section, we’ll dive in by learning how to use Bash scripting to
    format usernames and passwords. These skills will be very useful in various pentesting
    scenarios, such as phishing and password spraying.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过学习如何使用 Bash 脚本来格式化用户名和密码来深入了解。这些技能在各种渗透测试场景中非常有用，比如钓鱼和密码喷洒。
- en: Formatting usernames and email addresses
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化用户名和电子邮件地址
- en: There are a few scenarios in pentesting where you’ll need to enumerate usernames
    and email addresses. You may need them for phishing, password spraying, or enumerating
    valid accounts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，有一些情景需要枚举用户名和电子邮件地址。你可能需要它们用于钓鱼、密码喷洒或枚举有效账户。
- en: If you want to follow along while you perform this exercise, go to [https://hunter.io](https://hunter.io)
    and register for a free account. This is a website for finding company employee
    names and email addresses. After logging in to your free account, click the drop-down
    arrow beside your name in the top-right corner and then click on **API** in the
    menu.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在执行这个练习时跟着做，去 [https://hunter.io](https://hunter.io) 注册一个免费账户。这是一个用于查找公司员工姓名和电子邮件地址的网站。登录到你的免费账户后，在右上角的名字旁边点击下拉箭头，然后在菜单中点击
    **API**。
- en: '![Figure 8.1 – Selecting API from the hunter.io menu](image/B22229_08_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 从 hunter.io 菜单中选择 API](image/B22229_08_1.jpg)'
- en: Figure 8.1 – Selecting API from the hunter.io menu
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 从 hunter.io 菜单中选择 API
- en: 'On this page, you’ll find example commands for various types of API searches.
    Under **Domain Search** , click the **Copy** button. Enter the following command
    in your terminal, substituting **[redacted]** with your own API key :'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，你会找到各种类型 API 搜索的示例命令。在 **域名搜索** 下，点击 **复制** 按钮。在你的终端中输入以下命令，用你自己的 API
    密钥替换 **[redacted]**：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the URL, you can see **domain=stripe.com** . Obviously, you will want to
    change the domain to match your target.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中，你可以看到 **domain=stripe.com** 。显然，你会想要将域名更改为符合你的目标。
- en: Critical
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Stripe is used as an example in this text only because the [hunter.io](http://hunter.io)
    website API page included it as an example. *Do not* hack anyone if you don’t
    have written permission. Not only is it illegal and unethical, but you’ll probably
    end up in prison when you get caught.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中仅以 Stripe 作为示例，因为 [hunter.io](http://hunter.io) 网站的 API 页面中包含了它作为示例。如果没有书面许可，请不要攻击任何人。这不仅是非法和不道德的，而且当你被抓到时，你可能最终会坐牢。
- en: 'Next, **cat** the text file to the terminal so we can get a look at the output
    format. The first level of JSON data is **data** , as shown in the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**cat** 文本文件到终端，这样我们就可以查看输出格式。JSON 数据的第一级是 **data** ，如下图所示：
- en: '![Figure 8.2 – JSON first-level data](image/B22229_08_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – JSON 第一级数据](image/B22229_08_2.jpg)'
- en: Figure 8.2 – JSON first-level data
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – JSON 第一级数据
- en: The absolute simplest **jq** filter is **jq .** . This filter takes its input
    and produces the same value as the output. The data that we want to access is
    nested under **data** . Therefore, our **jq** query will start with **.data[]**
    . Enter the following command and see that everything contained in **data** is
    output, **cat employees.txt | jq -r '.data[]'** . The **-r** argument simply tells
    **jq** to output raw data without escapes and quotes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 **jq** 过滤器是 **jq .** 。这个过滤器将输入作为输出产生相同的值。我们想要访问的数据是嵌套在 **data** 下面的。因此，我们的
    **jq** 查询将以 **.data[]** 开头。输入以下命令并查看包含在 **data** 中的所有内容的输出，**cat employees.txt
    | jq -r '.data[]'** 。**-r** 参数只是告诉 **jq** 输出原始数据，不带转义和引号。
- en: 'If you look at the information nested under **data** , you’ll find that employee
    email addresses, names, and positions are nested under **emails** . Building on
    our earlier query, the next command will be **cat employees.txt | jq -r ''.data.emails[]''**
    . Do you notice a pattern here? When you want to access nested data using **jq**
    , start with a **.** symbol and the first field you want to access, followed by
    square brackets, **.first_level[]** . If you want to access data nested one level
    deeper, use **.first_level.second_level[]** . In this particular case, we want
    to access the **value** (email address), **first_name** , **last_name** , and
    **position** fields, which are nested under **.data.emails[]** . Therefore, our
    **jq** query wi ll be **.data.emails[] | [.value, .first_name, .last_name, .position]**
    , as shown in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看嵌套在**data**下的信息，你会发现员工的电子邮件地址、姓名和职位被嵌套在**emails**下。基于我们之前的查询，接下来的命令将是**cat
    employees.txt | jq -r '.data.emails[]'**。你注意到这里有什么规律吗？当你想通过**jq**访问嵌套数据时，首先使用**.**符号并指定你要访问的第一个字段，然后使用方括号**.first_level[]**。如果你想访问更深一层的嵌套数据，则使用**.first_level.second_level[]**。在这个特定的例子中，我们想访问**value**（电子邮件地址）、**first_name**、**last_name**和**position**字段，这些字段嵌套在**.data.emails[]**下。因此，我们的**jq**查询将是**.data.emails[]
    | [.value, .first_name, .last_name, .position]**，如下面的图所示：
- en: '![Figure 8.3 – Our jq query to access email addresses and employee information](image/B22229_08_3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 我们的jq查询访问电子邮件地址和员工信息](image/B22229_08_3.jpg)'
- en: Figure 8.3 – Our jq query to access email addresses and employee information
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 我们的jq查询访问电子邮件地址和员工信息
- en: 'Now that we have the information we need, the next step is to get it into a
    format that’s easier to work with, such as **tab-separated values** ( **TSV**
    ). Let’s check the manual for **jq** to find out how to make this transformation.
    Enter the **man jq** command in your terminal. The **jq** program has many options,
    but if you keep scrolling far enough, you’ll find a section named **Format strings
    and escaping** . In this section, we find that **Comma-Separated Values** ( **CSV**
    ) and TSV are **@csv** and **@tsv** . All that’s needed now is to pipe the previous
    query to **@tsv** , as shown in the following figure. Make sure that your pipe
    character and **@tsv** are enclosed inside the single quotes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了所需的信息，接下来的步骤是将其转化为更易于操作的格式，例如**制表符分隔值**（**TSV**）。让我们查阅**jq**的手册，看看如何进行这种转换。在终端输入**man
    jq**命令。**jq**程序有很多选项，但如果你继续滚动，你会找到一个名为**格式字符串和转义**的部分。在这一部分，我们发现**逗号分隔值**（**CSV**）和TSV分别对应**@csv**和**@tsv**。现在只需要将之前的查询管道传送到**@tsv**，如下面的图所示。确保你的管道符号和**@tsv**都被单引号包围：
- en: '![Figure 8.4 – Our final jq query extracts the needed data](image/B22229_08_4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 我们的最终jq查询提取了所需的数据](image/B22229_08_4.jpg)'
- en: Figure 8.4 – Our final jq query extracts the needed data
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 我们的最终jq查询提取了所需的数据
- en: 'If we were authorized to do so and wanted to use this data for password spraying
    a login form on a website, we can guess that most likely their internal Active
    Directory domain user account is named the same as in their email address before
    the domain, **@stripe.com** . However, as a pentester, you will need to know how
    to take first and last names and reformat them in different formats, such as **first.last**
    , **f.last** , **first_last** , and so on. Notice that in the data in *Figure
    8* *.4* , the first and last names are in columns 2 and 3. Let’s create a simple
    one-line script that will build on the previous command and take the first and
    last names and print them as first initial and last name:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有权限并且想要使用这些数据进行密码喷洒攻击网站的登录表单，我们可以推测，他们的内部Active Directory域用户账户很可能与电子邮件地址中**@stripe.com**之前的部分相同。然而，作为一名渗透测试员，你需要知道如何将名字和姓氏转换为不同的格式，例如**first.last**、**f.last**、**first_last**等。注意在*图
    8* *4* 中，名字和姓氏分别位于第2列和第3列。让我们创建一个简单的单行脚本，基于之前的命令，将名字和姓氏格式化为名字的首字母加姓氏：
- en: '![Figure 8.5 – Formatting usernames as first initial, last name](image/B22229_08_5.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 将用户名格式化为名字首字母+姓氏](image/B22229_08_5.jpg)'
- en: Figure 8.5 – Formatting usernames as first initial, last name
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 将用户名格式化为名字首字母+姓氏
- en: 'Here is a full explanation of the **awk** command inside single quotes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**awk**命令的完整解释（使用单引号）：
- en: '**awk ''pattern {action}''** : You may remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073)
    that **awk** commands are in the format of pattern and action. The pattern is
    optional. The action is mandatory.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**awk ''pattern {action}''**：你可能还记得在 [*第 4 章*](B22229_04.xhtml#_idTextAnchor073)
    中，**awk** 命令的格式是模式和动作。模式是可选的，动作是必须的。'
- en: '**print tolower()** : This may be obvious. It prints the output in all lowercase.
    Inside this **awk** function, we’re printing the first initial of **first_name**
    (second field or **$2** ) followed by the **last_name** (third field or **$3**
    ).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**print tolower()**：这可能是显而易见的。它将输出打印为全小写。在这个 **awk** 函数内部，我们打印 **first_name**（第二个字段或
    **$2**）的第一个字母，后跟 **last_name**（第三个字段或 **$3**）。'
- en: '**(substr($2,1,1)** : Here, we’re making a substring of the data consisting
    of the second field ( **$2** ), **first_name** , starting with the first character
    and ending with the first character ( **1,1** ). If we wanted to use the first
    two characters of the first name, the **substr** command would be **substr($2,1,2)**
    .'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(substr($2,1,1)**：在这里，我们正在对数据进行子字符串操作，数据由第二个字段（**$2**）组成，**first_name**，从第一个字符开始，结束于第一个字符（**1,1**）。如果我们想使用名字的前两个字符，**substr**
    命令应该是 **substr($2,1,2)**。'
- en: If you want to print the username as **first_last** , use the **awk '{print
    tolower($1 "_" $2)}'** command to insert a specific character between first and
    last names.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将用户名打印为 **first_last**，可以使用 **awk '{print tolower($1 "_" $2)}'** 命令，在名字和姓氏之间插入特定字符。
- en: As a pentester, you should always use the right tool for the job. Earlier in
    your career, you’re more likely to be running tools made by someone else. These
    tools are frequently written in Python or C languages. When performing OSINT,
    many of the tools are written in Python. Regardless of which tool you use and
    the language it’s written in, eventually, you’ll need to filter and format data
    input or output from your tools. That’s where the concepts in this chapter will
    save you significant time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你应该始终使用合适的工具来完成任务。在你职业生涯的早期，你更可能使用别人开发的工具。这些工具通常是用 Python 或 C 语言编写的。在进行
    OSINT（开放源信息收集）时，许多工具是用 Python 编写的。不管你使用哪个工具，或者它是用什么语言写的，最终你都会需要过滤和格式化从工具中输入或输出的数据。正是这一章的概念将为你节省大量时间。
- en: In the next section, we’ll explore using Bash with DNS enumeration to discover
    targets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索如何使用 Bash 进行 DNS 枚举以发现目标。
- en: Using Bash for DNS enumeration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bash 进行 DNS 枚举
- en: As a pentester, you will typically be provided with a defined scope. The scope
    is what you’re allowed to test. It will usually be provided as a list of IP addresses,
    network addresses, domain names, URLs, or a combination of these. On the other
    hand, you may also be tasked with discovering assets owned by the company.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你通常会得到一个定义好的范围。范围就是你被允许测试的内容。通常它会以 IP 地址、网络地址、域名、URL 或这些的组合形式提供给你。另一方面，你也可能需要发现公司拥有的资产。
- en: In my earlier years as a pentester before I got into consulting, I spent a lot
    of time enumerating DNS to discover new assets for a company that was global and
    acquired a lot of smaller companies. I spent months discovering IP addresses,
    applications, and domain names owned by our acquisitions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为渗透测试员的早期阶段，在我开始做咨询工作之前，我花了大量时间进行 DNS 枚举，发现属于某个全球公司并收购了许多小公司的新资产。我花了几个月的时间发现我们收购的公司的
    IP 地址、应用程序和域名。
- en: 'First, it’s essential to make sure we’re on the same page regarding terminology
    for domain names. We need to quickly cover the difference between top-level domains,
    root domains, and subdomains. I’ll use **www.example.com** for this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保我们在域名术语上达成一致非常重要。我们需要快速了解顶级域名、根域名和子域名之间的区别。我将使用 **www.example.com** 作为这个例子的域名：
- en: '**com** : This is the **top-level** **domain** ( **TLD** )'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**com**：这是 **顶级域名**（**TLD**）。'
- en: '**example** : This is the root domain'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**example**：这是根域名'
- en: '**www** : This is the subdomain'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**www**：这是子域名'
- en: With the terminology out of the way, let’s look at the methodology to discover
    additional root domains that are related to a known root domain.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在澄清术语之后，让我们看看如何发现与已知根域名相关的其他根域名的方法。
- en: Expanding the scope using Bash
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bash 扩展范围
- en: This section is dedicated to starting with a company’s domain name and discovering
    related assets exposed to the internet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容专注于从公司的域名开始，发现暴露在互联网上的相关资产。
- en: Many companies use Microsoft 365. If a company is enrolled as a Microsoft tenant
    with **Microsoft Defender for Identity** ( **MDI** ), the following script will
    discover the tenant name and enumerate all domains enrolled in the same tenant.
    This has been a very effective way to start with a simple domain name and discover
    related domains owned by the same entity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司使用Microsoft 365。如果公司已注册为拥有**Microsoft Defender for Identity**（**MDI**）的Microsoft租户，则以下脚本将发现租户名称并枚举所有在同一租户下注册的域。这是从简单域名开始，发现同一实体所有相关域名的有效方法。
- en: 'The script requires a domain as input. You can find it in this chapter’s folder
    in the GitHub repository as **ch08_check_mdi.sh** . I’m going to split up the
    code into smaller chunks to explain each part as we go. It will be helpful to
    have the script in GitHub open on your computer monitor to compare to the following
    code narrative:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本需要一个域名作为输入。你可以在本章的文件夹中找到它，GitHub仓库中的文件名是**ch08_check_mdi.sh**。我将把代码分成更小的块，以便逐步解释每个部分。在阅读以下代码描述时，打开GitHub中的脚本进行对比将非常有帮助：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we start out with our familiar **shebang** , followed
    by the opening block of the **get_domains** function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从熟悉的**shebang**开始，后面跟着**get_domains**函数的开头部分。
- en: 'Here, we create a **domain** variable from the first command-line argument:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从第一个命令行参数创建一个**domain**变量：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following code block, we create the XML body of the HTTP request as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们创建了HTTP请求的XML主体，如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, I created the **Simple Object Access Protocol** ( **SOAP**
    ) request body with the input domain, **$1** .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我使用输入域**$1**创建了**Simple Object Access Protocol**（**SOAP**）请求主体。
- en: 'In the following code, I have used command expansion ( **$()** ) to perform
    the HTTP **POST** request using **curl** and store the response in the **response**
    variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我使用命令扩展（**$()**）通过**curl**执行HTTP **POST**请求，并将响应存储在**response**变量中：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The **body** variable containing the SOAP request body is expanded in the **POST**
    data. The request is sent to the Autodiscover service for Microsoft 365.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 包含SOAP请求主体的**body**变量在**POST**数据中被展开。请求被发送到Microsoft 365的自动发现服务。
- en: The following code checks whether the response is empty ( **-z** , zero-length)
    and exits if true. An **exit** code that’s non-zero indicates that the process
    terminated with an error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查响应是否为空（**-z**，零长度），如果是则退出。非零的**exit**代码表示进程以错误终止。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code parses the XML response to extract domain names using the
    **xmllint** application and stores the result in the **domains** variable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用**xmllint**应用程序解析XML响应，提取域名并将结果存储在**domains**变量中：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following code exits if no domains are found in the response.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在响应中未找到任何域时退出：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following code, we print the found domains:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们打印出找到的域名：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The **tr** command substitutes the first value with the second value; in this
    case, a space, **' '** , is replaced with a newline, **'\n'** .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**tr**命令将第一个值替换为第二个值；在这种情况下，空格**'' ''**被替换为换行符**''\n''**。'
- en: The following code extracts the tenant name from the found domains.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从找到的域中提取租户名称：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **tenant** variable is assigned the result of the **domains** variable with
    spaces substituted with a newline ( **tr ' ' '\n'** ). Then, it finds ( **grep**
    ) any line that contains **onmicrosoft.com** . That data is piped to **head -n
    1** , which selects the first line of data, then pipes the result to the **cut**
    command, which essentially splits the data on the period character and selects
    the first field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**tenant**变量被赋值为将**domains**变量中的空格替换为换行符（**tr '' '' ''\n''**）后的结果。然后，它通过**grep**查找包含**onmicrosoft.com**的任何行。该数据被传递给**head
    -n 1**，选取第一行数据，然后将结果传递给**cut**命令，基本上是通过句点字符分割数据并选择第一个字段。'
- en: 'The following code exits if no tenant is found:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在未找到租户时退出：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code prints the found tenant name:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码打印找到的租户名称：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following code calls the **check_mdi** function with the tenant name. The
    closing brace ends the **get_domains** function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码调用**check_mdi**函数，并传入租户名称。闭括号结束**get_domains**函数。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following code, I declare the **check_mdi** function to identify MDI
    usage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我声明了**check_mdi**函数以识别MDI使用情况：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code appends the MDI domain suffix to the tenant name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将MDI域名后缀追加到租户名称中：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code runs **dig** to check whether the MDI instance exists for
    the tenant domain:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码运行**dig**命令检查租户域名是否存在MDI实例：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It prints a positive message if the MDI instance is found. Otherwise, it prints
    a negative message if no MDI instance is found. The closing brace ends the **check_mdi**
    function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到MDI实例，它将打印一条正面消息。如果没有找到MDI实例，则打印一条负面消息。闭合大括号标志着**check_mdi**函数的结束。
- en: The following code checks whether the correct number of arguments is provided
    and whether the first argument is **-d** . The logical **or** ( **||** ) operation
    means if the number of command-line arguments is not equal to two, or the first
    argument is not equal to **-d** , then print the usage banner and exit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查是否提供了正确数量的参数，并且第一个参数是否为**-d**。逻辑**或**（**||**）操作意味着如果命令行参数的数量不等于两个，或者第一个参数不等于**-d**，则打印用法横幅并退出。
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following code declares the **domain** argument from user input.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了用户输入的**domain**参数。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following code calls the **get_domains** function with the provided domain.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码调用**get_domains**函数，并传入提供的域名。
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run this script with a well-known domain, you will find a lesser-known
    domain in the output. Essentially, this script helps you cross-reference domains
    owned by the same entity:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个知名的域名运行此脚本，你将在输出中发现一个不太为人所知的域名。实质上，这个脚本帮助你交叉参考由同一实体拥有的域名：
- en: '![Figure 8.6 – Running check_mdi on the cdw.com domain](image/B22229_08_6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 在cdw.com域上运行check_mdi](image/B22229_08_6.jpg)'
- en: Figure 8.6 – Running check_mdi on the cdw.com domain
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 在cdw.com域上运行check_mdi
- en: The script output shown in the preceding figure demonstrates how our Bash script
    discovered many subdomains related to the target domain, greatly expanding our
    target footprint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的脚本输出展示了我们的Bash脚本如何发现与目标域名相关的多个子域，从而大大扩展了我们的目标足迹。
- en: Automating subdomain enumeration with Bash
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bash自动化子域名枚举
- en: Next, I’m going to share some of the Bash functions I keep in my **.bashrc**
    file. I use these functions on external pentests to allow me to quickly perform
    common reconnaissance tasks that I run before port and vulnerability scanning.
    First, I will list the code in small sections and explain them as I go. Finally,
    I’ll show you how I use these functions together to enumerate DNS and the output.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将分享一些我保存在**.bashrc**文件中的Bash函数。我在外部渗透测试中使用这些函数，以便在进行端口和漏洞扫描之前，快速执行一些常见的侦察任务。首先，我会将代码分成小部分列出，并在过程中进行解释。最后，我将展示如何将这些函数结合使用，以枚举DNS及其输出。
- en: 'The first function is named **mdi** and you’ve already seen it in the **ch08_check_mdi.sh**
    script shown earlier in this chapter. I’m going to include only the part that
    has changed from **ch08_check_mdi.sh** . The example code can be found in the
    **ch08_mdi_function.sh** file in this chapter’s folder in the GitHub repository:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数名为**mdi**，你已经在本章前面展示的**ch08_check_mdi.sh**脚本中见过它。我将只包括与**ch08_check_mdi.sh**中不同的部分。示例代码可以在GitHub代码库本章文件夹中的**ch08_mdi_function.sh**文件中找到：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, I start by declaring a function named **mdi** . I nested
    all of the earlier code inside a **while** loop, which reads from standard input
    ( **stdin** ). This is required to read piped input, allowing us to pipe data
    between our functions. The **IFS=** code preserves newlines, which is necessary
    when your input contains multiple lines. You can pipe a single domain name or
    a line-separated list of domain names to this function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我首先声明了一个名为**mdi**的函数。我将所有先前的代码嵌套在一个**while**循环内，该循环从标准输入（**stdin**）读取。这是读取管道输入所必需的，允许我们在函数之间传递数据。**IFS=**代码用于保留换行符，这在输入包含多行时是必需的。你可以将单个域名或以换行分隔的域名列表传递给此函数。
- en: 'The next function is **rootdomain** . This function takes a subdomain as input
    and returns the root domain. For example, if you provide an input of **www.example.com**
    , the output will be **example.com** . This function is used to take a root domain
    from a subdomain, which I can then send to other functions to find more subdomains.
    The example code can be found in the **ch08_rootdomain_function.sh** file in this
    chapter’s folder in the GitHub repository:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是**rootdomain**。这个函数接受一个子域作为输入，并返回根域名。例如，如果你提供输入**www.example.com**，输出将是**example.com**。此函数用于从子域名中提取根域名，之后我可以将其发送给其他函数以查找更多子域。示例代码可以在GitHub代码库本章文件夹中的**ch08_rootdomain_function.sh**文件中找到：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, I first declare the function name, followed by a comment
    explaining the purpose, input, and output of the script.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我首先声明了函数名称，接着是一个注释，解释了脚本的目的、输入和输出。
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line starts a **while** loop that reads input line by line. **IFS=** sets
    the **internal field separator** to nothing, which prevents leading/trailing whitespace
    from being trimmed. **read -r** reads a line from standard input into the variable
    line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行开始了一个 **while** 循环，逐行读取输入。**IFS=** 将 **internal field separator** 设置为空，以防止去除前后空格。**read
    -r** 从标准输入读取一行并将其存入变量 line 中。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This line echoes the current line (subdomain) and pipes it to **awk** . The
    **-F.** option tells **awk** to use the period ( **.** ) as the field separator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行回显当前行（子域名）并将其传递给 **awk**。**-F.** 选项告诉 **awk** 使用句点（**.**）作为字段分隔符。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This opens the block of the **awk** script.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这开启了 **awk** 脚本的代码块。
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line splits the current line ( **$0** ) into an array named **parts** using
    the period ( **.** ) as the delimiter. The **n** variable stores the number of
    elements in the array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将当前行（**$0**）按句点（**.**）分隔成一个名为 **parts** 的数组。**n** 变量存储数组中的元素个数。
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This condition checks whether the domain has at least three parts and whether
    the second-to-last part matches a common second-level domain (e.g., **com** ,
    **net** , **org** , **co** , **gov** , **edu** , **mil** , or **int** ) followed
    by a two-letter country code (e.g., **uk** , **us** , or **de** ).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该条件检查域名是否至少包含三个部分，并且倒数第二部分是否匹配常见的二级域名（例如 **com**，**net**，**org**，**co**，**gov**，**edu**，**mil**
    或 **int**），后面跟着一个两位数的国家代码（例如 **uk**，**us** 或 **de**）。
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the condition is true, this line prints the root domain, which consists of
    the third-to-last, second-to-last, and last parts of the array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，这一行会打印根域名，它由倒数第三、倒数第二和最后一部分组成。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This condition checks whether the domain has at least two parts ( e.g., **example.com**
    ).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该条件检查域名是否至少包含两个部分（例如 **example.com**）。
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the condition is true, this line prints the root domain, which consists of
    the second-to-last and last parts of the array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，这一行会打印根域名，它由数组的倒数第二部分和最后一部分组成。
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If none of the preceding conditions are met (e.g., the input is a single-label
    domain), this line prints the original input.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有满足上述条件（例如，输入的是单标签域名），这一行会打印原始输入。
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code closes the **if** block, then closes the **awk** block. Notice
    that when the curly bracket closes the **if** block, there is no **fi** keyword
    like a Bash **if** statement. **awk** has a slightly different syntax for **if**
    blocks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码关闭了 **if** 块，然后关闭了 **awk** 块。请注意，当花括号关闭 **if** 块时，并没有像 Bash **if** 语句那样出现
    **fi** 关键字。**awk** 对 **if** 块的语法稍有不同。
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This closes the **while** loop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这关闭了 **while** 循环。
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This bracket closes the function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个括号关闭了函数。
- en: The **resolve** function takes a domain name as input and returns an IP address.
    The example code can be found in the **ch08_resolve_function.sh** file in this
    chapter’s folder in the GitHub repository.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolve** 函数以域名为输入并返回一个 IP 地址。示例代码可以在本章文件夹中的 **ch08_resolve_function.sh**
    文件中找到，该文件位于 GitHub 仓库中。'
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code is the start of the function and a comment that describes what the
    function does: it takes a domain as input and returns its corresponding IP address.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是函数的开始，并包含一个注释，描述了函数的作用：它接受一个域名作为输入并返回其对应的 IP 地址。
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This line starts a **while** loop that reads input line by line. **IFS=** sets
    the internal field separator to nothing, which prevents leading/trailing whitespace
    from being trimmed. **read -r** reads a line from standard input into the variable
    line.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行开始了一个 **while** 循环，逐行读取输入。**IFS=** 将内部字段分隔符设置为空，以防止去除前后空格。**read -r** 从标准输入读取一行并将其存入变量
    line 中。
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**dig** is a DNS lookup utility. The **+short** option makes the output concise
    by only printing the IP addresses or CNAME records. **$line** is the domain name
    read from input.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**dig** 是一个 DNS 查询工具。**+short** 选项使输出简洁，仅打印 IP 地址或 CNAME 记录。**$line** 是从输入中读取的域名。'
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**done** closes the **while** loop’s **do** block. **return 0** signifies to
    a calling script or function that the script completed successfully.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**done** 关闭了 **while** 循环的 **do** 块。**return 0** 表示脚本成功完成，并向调用脚本或函数返回状态。'
- en: 'The **org** function takes an IP address as input and returns the **OrgName**
    value found in the Whois output. This information tells us who owns the network.
    The example code can be found in the **ch08_org_function.sh** file in this chapter’s
    folder in the GitHub repository:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**org** 函数以 IP 地址为输入，并返回在 Whois 输出中找到的 **OrgName** 值。此信息告诉我们谁拥有该网络。示例代码可以在本章文件夹中的
    **ch08_org_function.sh** 文件中找到，该文件位于 GitHub 仓库中：'
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The start of the function through to the start of the **while** loop is virtually
    the same as in previous scripts. The line beginning with **whois** runs the **whois**
    command using the IP address sent as input to the function, runs **grep** to find
    the line containing **OrgName** , runs the **tr -s ' '** command to squeeze multiple
    spaces into a single space, and then pipes the output to the **cut** command,
    which specifies a space as a delimiter and selects the second field through the
    end of input. The **tr** program is very handy for squeezing multiple spaces into
    a single space, but you can also use it to replace one character with another.
    The **cut** program specifies a delimiter ( **-d** ) followed by the field to
    cut.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数的开始到**while**循环的开始，几乎与之前的脚本相同。以**whois**开头的行使用输入到函数中的 IP 地址运行**whois**命令，接着使用**grep**查找包含**OrgName**的行，运行**tr
    -s ' '**命令将多个空格压缩为一个空格，然后将输出传递给**cut**命令，指定空格为分隔符并选择第二个字段直到输入的末尾。**tr**程序非常适合将多个空格压缩为一个空格，但你也可以用它来将一个字符替换为另一个字符。**cut**程序指定分隔符（**-d**），后跟要切割的字段。
- en: The last function ties the other functions together. It performs domain and
    subdomain enumeration and prints subdomains, the IP address, and **OrgName** .
    It will also find any related root domains and enumerate their subdomains if the
    input domain is part of a Microsoft 365 tenant with MDI. This will significantly
    enhance subdomain discovery. I tested the Chaos API alone with a particular domain
    and it returned 553 live subdomains. When I ran this function and used MDI results
    to expand the scope to related domains hosted by the same company, it returned
    3,682 live subdomains.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将其他函数结合在一起。它执行域名和子域名枚举，并打印子域名、IP 地址和**OrgName**。如果输入的域名是包含 MDI 的 Microsoft
    365 租户的一部分，它还将查找任何相关的根域并枚举它们的子域名。这将显著增强子域名发现的能力。我单独使用 Chaos API 测试了一个特定的域名，它返回了
    553 个活动子域名。当我运行这个函数并使用 MDI 结果将范围扩展到由同一家公司托管的相关域时，它返回了 3,682 个活动子域名。
- en: 'The example code can be found in the **ch08_dnsrecon_function.sh** file in
    this chapter’s folder in the GitHub repository. The script requires a ProjectDiscovery
    Chaos API key ( [https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)
    ), which can be obtained for free at the time of writing. Chaos is the most complete
    source of DNS data that I’ve found:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在本章文件夹中的**ch08_dnsrecon_function.sh**文件中找到，文件位于 GitHub 仓库中。该脚本需要一个 ProjectDiscovery
    Chaos API 密钥（[https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)），该密钥可以在写作时免费获取。Chaos
    是我找到的最完整的 DNS 数据源：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Print the usage information and exit if one command-line argument is not included.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有包含一个命令行参数，则打印用法信息并退出。
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Check whether the Chaos API key is set in an environment variable. You should
    have a line in your **.bashrc** file that looks like **CHAOS_KEY=[key value]**
    . After you edit your **.bashrc** file to add the API key, you’ll need to make
    it recognized using the **source ~/.** **bashrc** command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否在环境变量中设置了 Chaos API 密钥。你应该在你的**.bashrc**文件中有一行看起来像**CHAOS_KEY=[key value]**。在你编辑**.bashrc**文件以添加
    API 密钥后，你需要使用**source ~/.bashrc**命令使其生效。
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, I have declared local variables. It’s not strictly necessary to declare
    the variable ahead of its use, I did so based on personal preference. Declaring
    variables as **local** ensures that their scope is limited to the function in
    which they are defined, which helps to avoid potential conflicts with global variables
    or variables in other functions. This is critical when the variable is in a function
    in your **.bashrc** file to prevent collisions with other variables since these
    functions are available to everything in your Bash shell.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我声明了局部变量。虽然不严格要求在使用之前声明变量，但我根据个人偏好这么做。将变量声明为**local**可以确保它们的作用范围仅限于定义它们的函数，这有助于避免与全局变量或其他函数中的变量发生潜在冲突。当变量位于**.bashrc**文件中的函数时，这一点尤其重要，以防与其他变量发生冲突，因为这些函数在你的
    Bash shell 中对所有内容都可用。
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, I passed the **domain** variable to the **mdi** function to get the list
    of related domains. Because the **mdi** function is designed to accept input from
    **stdin** ( **echo example.com | mdi** ) instead of being passed as a function
    argument ( **mdi example.com** ), it must be called as shown with three **<**
    characters. In Bash, **<<<** is known as the **here-string** operator. It is used
    to pass a string directly as input to a command, rather than reading from a file
    or standard input. This operator essentially provides a quick way to feed a single
    line of text to a command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我将**domain**变量传递给**mdi**函数以获取相关域名列表。由于**mdi**函数设计为接受来自**stdin**的输入（**echo
    example.com | mdi**），而不是作为函数参数传递（**mdi example.com**），因此必须按照示例中所示的方式调用，并使用三个**<**字符。在Bash中，**<<<**是**here-string**运算符，用于将一个字符串直接传递给命令作为输入，而不是从文件或标准输入中读取。这个运算符基本上提供了一种快速将单行文本传递给命令的方式。
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If no domains are returned from the **mdi** function, pass the input domain
    directly to the Chaos API and assign the output to the **domains** variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**mdi**函数没有返回域名，将输入的域名直接传递给Chaos API，并将输出赋值给**domains**变量。
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This part pipes the content of the **mdi_result** variable line by line to the
    code inside the **do** / **done** block. The line of data (a domain) is passed
    to the **rootdomain** function. If the line of data is **www.example.com** , this
    function would return **example.com** . It then passes this root domain to the
    Chaos API call and assigns the result to the **chaos_domains** variable. Finally,
    the list of subdomains returned from the API call is appended to the list of domains
    in the **domains** variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将**mdi_result**变量的内容逐行传递给**do** / **done**块中的代码。每一行数据（一个域名）都传递给**rootdomain**函数。如果数据行是**www.example.com**，这个函数将返回**example.com**。然后，它将根域名传递给Chaos
    API调用，并将结果赋值给**chaos_domains**变量。最后，从API调用返回的子域名列表将附加到**domains**变量中的域名列表上。
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This section of code ensures that blank lines are removed ( **grep .** returns
    non-blank lines), removes any wildcard domains ( **grep -v \*** ), and then removes
    duplicates ( **sort -u** ).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确保移除空行（**grep .**返回非空行），去除任何通配符域名（**grep -v \***），然后去除重复项（**sort -u**）。
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code passes each line of data in the **domains** variable to the **do**
    / **done** code block. The **IFS=** part ensures that line endings remain intact.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将**domains**变量中的每一行数据传递给**do** / **done**代码块。**IFS=**部分确保行尾符号保持不变。
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code passes each domain in the **domains** variable to the **resolve**
    function, which returns an IP address and stores it in the **ip** variable. If
    the **ip** variable is zero-length, **-z** (the domain name could not be resolved
    to an IP address), it returns **true** and the **continue** keyword short-circuits
    the current iteration of the loop and skips to the next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将**domains**变量中的每个域名传递给**resolve**函数，后者返回一个IP地址并将其存储在**ip**变量中。如果**ip**变量为空（**-z**，域名无法解析为IP地址），则返回**true**，并且**continue**关键字将短路当前的循环迭代，跳到下一次迭代。
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the domain name has successfully resolved to an IP address, the data is printed
    as **Domain;IP;Org** . I chose semicolons for the field separator because the
    **org** value may contain spaces and commas.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果域名成功解析为IP地址，数据将以**Domain;IP;Org**的格式输出。我选择使用分号作为字段分隔符，因为**org**值可能包含空格和逗号。
- en: 'The **dnsrecon** function is called on the command line as **dnsrecon example.com**
    . The following is an example of the output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**dnsrecon**函数在命令行中以**dnsrecon example.com**的形式调用。以下是输出示例：'
- en: '![Figure 8.7 – The dnsrecon function output](image/B22229_08_7.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – dnsrecon 函数输出](image/B22229_08_7.jpg)'
- en: Figure 8.7 – The dnsrecon function output
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – dnsrecon 函数输出
- en: The output in the preceding figure shows that our Bash script has provided us
    with more targets, and contains information that we can use to determine whether
    the discovered domains are in scope by IP address.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示中的输出显示我们的Bash脚本为我们提供了更多的目标，并包含了可以用来判断发现的域名是否在IP地址范围内的信息。
- en: Next, we need to discuss how web applications use domain names to determine
    which application to serve to a website visitor. This is critical to your success.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要讨论Web应用程序如何使用域名来确定为网站访问者提供哪个应用程序。这对你的成功至关重要。
- en: Using Bash to identify web applications
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bash识别Web应用程序
- en: As a consultant pentester who is provided a list of IP or network addresses
    by an external customer, you may fall into a bad habit of just testing defined
    IP or network addresses and not performing enough OSINT to discover all domain
    names. I did this myself when I was a junior pentester and have also witnessed
    this from people I have mentored. The reason why this is not ideal is because
    of how web applications behave when requesting a website using an IP address versus
    a domain name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名咨询渗透测试人员，如果你收到外部客户提供的 IP 或网络地址列表，你可能会养成只测试已定义的 IP 或网络地址，而没有进行足够的 OSINT 来发现所有域名的坏习惯。我在刚做渗透测试时也曾犯过这个错误，并且我也见过我指导的人这样做。之所以这样做不理想，是因为使用
    IP 地址和域名访问网站时，Web 应用的行为是不同的。
- en: A web server hosting multiple applications, load balancer, or reverse proxy
    will return the default site when an IP address is in the URL or HTTP **HOST**
    header. Unbeknown to you, there may be additional websites hosted on that IP address
    and you absolutely will miss out on finding vulnerable applications if you don’t
    perform DNS enumeration and test applicable domain names. You can read more about
    the HTTP **HOST** header at [https://portswigger.net/web-security/host-header](https://portswigger.net/web-security/host-header)
    .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 托管多个应用程序的 Web 服务器、负载均衡器或反向代理，在 URL 或 HTTP **HOST** 头中使用 IP 地址时会返回默认站点。你可能不知道，实际上该
    IP 地址上可能托管有其他网站，如果不进行 DNS 枚举并测试相关的域名，你绝对会错过发现易受攻击应用的机会。你可以在 [https://portswigger.net/web-security/host-header](https://portswigger.net/web-security/host-header)
    上阅读更多关于 HTTP **HOST** 头的信息。
- en: 'Here’s a relevant example. OWASP Juice Shop is an intentionally vulnerable
    website. You can find an example hosted at [https://demo.owasp-juice.shop/#/](https://demo.owasp-juice.shop/#/)
    . If you ping that hostname, you see the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个相关的例子。OWASP Juice Shop 是一个故意设计的易受攻击网站。你可以在 [https://demo.owasp-juice.shop/#/](https://demo.owasp-juice.shop/#/)
    找到一个例子。如果你 ping 测试这个主机名，你会看到以下内容：
- en: '![Figure 8.8 – Pinging OWASP Juice Shop demo](image/B22229_08_8.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – Ping 测试 OWASP Juice Shop 演示](image/B22229_08_8.jpg)'
- en: Figure 8.8 – Pinging OWASP Juice Shop demo
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – Ping 测试 OWASP Juice Shop 演示
- en: 'If you were provided with the IP address **81.169.145.156** in scope and scanned
    that IP and didn’t perform subdomain enumeration, you would visit that site in
    your browser and see **Not Found** :'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到了范围内的 IP 地址 **81.169.145.156** 并扫描了这个 IP 地址，但没有进行子域名枚举，你会在浏览器中访问该网站并看到
    **未找到**：
- en: '![Figure 8.9 – Visiting a website via the IP address](image/B22229_08_9.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 通过 IP 地址访问网站](image/B22229_08_9.jpg)'
- en: Figure 8.9 – Visiting a website via the IP address
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 通过 IP 地址访问网站
- en: 'In the preceding figure, I have highlighted the relevant parts for you. I requested
    a web page via the IP address. You may see this response and think that this IP
    address and port aren’t interesting and move on. However, if you visit the domain
    name, you see the following website, which contains many vulnerabilities:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我为你高亮了相关部分。我通过 IP 地址请求了一个网页。你可能会看到这个响应并认为这个 IP 地址和端口并不有趣，便继续前进。然而，如果你访问该域名，你会看到以下网站，这个网站包含了许多漏洞：
- en: '![Figure 8.10 – OWASP Juice Shop, a vulnerable web application](image/B22229_08_10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – OWASP Juice Shop，一个易受攻击的 Web 应用](image/B22229_08_10.jpg)'
- en: Figure 8.10 – OWASP Juice Shop, a vulnerable web application
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – OWASP Juice Shop，一个易受攻击的 Web 应用
- en: Before you start scanning your scoped IP addresses or network addresses, take
    the time to fully enumerate DNS first using the tools and techniques shown next.
    Then, append the discovered domain names that resolve to the scoped IP addresses
    to the end of your scope file. I can’t stress enough how important this is. It
    could very well be the difference between a zero-finding pentest report (not to
    mention the risk of the customer getting breached due to your oversight) and finding
    high-impact vulnerabilities. If you simply paste the list of network or IP addresses
    into a vulnerability scanner and then think there’s nothing to exploit based on
    the scan results, you will overlook exploitable findings.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始扫描你的范围内的 IP 地址或网络地址之前，先花时间使用接下来展示的工具和技术，彻底枚举 DNS。然后，将解析到范围内 IP 地址的发现域名附加到你的范围文件的末尾。我无法强调这一点有多重要。这可能是导致零漏洞渗透测试报告（更不用说客户因为你的疏忽而被攻破的风险）与发现高影响漏洞之间的差异。如果你仅仅将网络或
    IP 地址列表粘贴到漏洞扫描器中，然后根据扫描结果认为没有什么可以利用的漏洞，那么你就会忽视那些可以被利用的漏洞。
- en: Now that you have a better understanding of how web applications use the **HOST**
    header, in the next section, we’ll examine how to discover the application root
    or subdomains served by a web server on any particular IP address. Having this
    information will be critical to our success when scanning IP or network addresses.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你更好地理解了Web应用程序如何使用**HOST**头部，在下一节中，我们将探讨如何发现任何特定IP地址上的Web服务器所提供的应用程序根目录或子域。获得这些信息对于我们在扫描IP或网络地址时的成功至关重要。
- en: Using Bash for certificate enumeration
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bash进行证书枚举
- en: I performed this one external network pentest that had many thousands of live
    IP addresses in scope. One of the problems I ran into was that I was given large
    network blocks and needed to take the live IP addresses and discover hostnames
    before I could properly scan the web servers. Remember earlier in this chapter
    where I demonstrated how the web page you see may be different when you request
    the website via IP address versus hostname?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我进行过一次外部网络渗透测试，测试范围内有成千上万的活动IP地址。我遇到的一个问题是，我被分配了大块网络地址，需要从这些IP地址中发现主机名，才能正确地扫描Web服务器。还记得本章早些时候，我演示了当你通过IP地址和主机名请求网站时，你看到的网页可能会有所不同吗？
- en: Many thousands of those IP addresses were resolved to random subdomains in DNS,
    and they were usually proxy servers placed in front of a server pool. We also
    knew that the customer was using a **content delivery network** ( **CDN** ) in
    front of their websites, and traffic was filtered by a **web application firewall**
    ( **WAF** ), which blocked attempts to scan the sites. Furthermore, if we requested
    a website via domain name, the domain names resolved to an IP address residing
    on the CDN and the CDN IP addresses were not in scope so we couldn’t attack them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那些IP地址中的许多被解析为DNS中的随机子域，它们通常是作为代理服务器，位于服务器池前面。我们还知道客户在其网站前使用了**内容分发网络**（**CDN**），并且流量经过**Web应用防火墙**（**WAF**）的过滤，阻止了扫描网站的尝试。此外，如果我们通过域名请求网站，域名会解析到一个位于CDN上的IP地址，而这些CDN
    IP地址不在攻击范围内，因此我们无法攻击它们。
- en: Fortunately for me, the customer wasn’t filtering incoming traffic to allow
    only source IP addresses of the CDN provider. At that point, what I needed to
    do was discover which website was being hosted on each IP address and then override
    DNS so that I could manually map domain names to IP addresses. This would allow
    me to access the web applications directly. I came up with a crafty way to discover
    which websites were hosted on those IP addresses and bypass the CDN WAFs at the
    same time. I found that the Nuclei ( [https://github.com/projectdiscovery/nuclei](https://github.com/projectdiscovery/nuclei)
    ) vulnerability scanner has a template for discovering DNS names associated with
    **Transport Layer Security** ( **TLS** ) certificates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，客户没有过滤传入流量，只允许CDN提供商的源IP地址。此时，我需要做的是发现每个IP地址上托管的网站，然后覆盖DNS，以便我可以手动将域名映射到IP地址。这将让我能够直接访问Web应用程序。我想出了一个巧妙的方法来发现这些IP地址上托管的网站，并同时绕过CDN的WAF。我发现Nuclei（[https://github.com/projectdiscovery/nuclei](https://github.com/projectdiscovery/nuclei)）漏洞扫描器有一个模板，可以用来发现与**传输层安全性**（**TLS**）证书相关的DNS名称。
- en: TLS certificates are digital certificates that authenticate the identity of
    a website and enable an encrypted connection. They contain information about the
    certificate holder, the certificate’s public key, and the digital signature of
    the issuing **certificate authority** ( **CA** ). The TLS **Subject Alternative
    Name** ( **SAN** ) is an extension to the X.509 specification that allows users
    to specify additional hostnames for a single SSL/TLS certificate. This means a
    single certificate can secure multiple domains and subdomains, simplifying certificate
    management and reducing costs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: TLS证书是用于验证网站身份并启用加密连接的数字证书。它们包含证书持有者的信息、证书的公钥以及颁发**证书颁发机构**（**CA**）的数字签名。TLS
    **主题备用名称**（**SAN**）是X.509规范的一个扩展，它允许用户为单个SSL/TLS证书指定其他主机名。这意味着一个证书可以保护多个域名和子域，从而简化证书管理并降低成本。
- en: 'The Nuclei vulnerability scanner has a scan template that extracts TLS SANs
    from the digital certificate. First, I scanned the list of live IP addresses with
    Nuclei. Here’s an example of using the Nuclei **ssl-dns-names** template to scan
    a network address that was in scope for the Hyatt Hotels bug bounty program (
    [https://hackerone.com/hyatt/policy_scopes](https://hackerone.com/hyatt/policy_scopes)
    ) at the time of writing:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Nuclei 漏洞扫描器有一个扫描模板，可以从数字证书中提取 TLS SAN。首先，我使用 Nuclei 扫描了活动 IP 地址列表。以下是使用 Nuclei
    **ssl-dns-names** 模板扫描一个在撰写时属于 Hyatt Hotels 漏洞奖励计划范围内的网络地址（[https://hackerone.com/hyatt/policy_scopes](https://hackerone.com/hyatt/policy_scopes)
    ）的示例：
- en: '![Figure 8.11 – Scanning a network for TLS certificate SANs](image/B22229_08_11.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 扫描网络中的 TLS 证书 SAN](image/B22229_08_11.jpg)'
- en: Figure 8.11 – Scanning a network for TLS certificate SANs
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 扫描网络中的 TLS 证书 SAN
- en: Make sure you add the **-o [filename]** option to the Nuclei scan command seen
    in *Figure 8* *.11* to save the output to a file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 *图 8.11* 中看到的 Nuclei 扫描命令中添加 **-o [filename]** 选项，以将输出保存到文件中。
- en: Now that we have this output, the next step is to clean it up and reformat it
    for our **hosts** file. The **hosts** file is a simple text file that maps hostnames
    to IP addresses. It’s an essential part of the networking stack in any operating
    system, including Linux. You can view the contents of your **hosts** file by entering
    the **cat /** **etc/hosts** command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个输出，下一步是清理它并重新格式化为我们 **hosts** 文件的格式。**hosts** 文件是一个简单的文本文件，用于将主机名映射到
    IP 地址。它是任何操作系统中网络堆栈的核心部分，包括 Linux。你可以通过输入 **cat /** **etc/hosts** 命令查看 **hosts**
    文件的内容。
- en: Before moving on, it’s important to understand how DNS works in regard to the
    **hosts** file. On a Linux system, when you use a domain name for network communications,
    your computer must resolve the domain name to an IP address. At a very basic level,
    when you use a domain name to communicate with other hosts over the network, the
    first step is for your computer to check its own hostname for a match. Next, it
    checks for an entry in the **hosts** file. If that doesn’t resolve the hostname,
    it communicates with the DNS server in your network interface configuration. Essentially,
    hardcoding a domain name to an IP address in your **hosts** file overrides DNS.
    Microsoft Windows also uses a **hosts** file for the same purpose, although it’s
    in a different location.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，理解 DNS 在 **hosts** 文件中的工作原理非常重要。在 Linux 系统中，当你使用域名进行网络通信时，计算机必须将域名解析为
    IP 地址。从最基本的层面来说，当你使用域名与其他主机进行网络通信时，第一步是计算机检查自己的主机名是否匹配。接下来，它会检查 **hosts** 文件中的条目。如果没有解析出主机名，它会与网络接口配置中的
    DNS 服务器通信。本质上，在 **hosts** 文件中将域名硬编码到 IP 地址会覆盖 DNS。Microsoft Windows 也使用 **hosts**
    文件来执行相同的操作，尽管它的位置不同。
- en: 'The following screenshot shows the contents of my **hosts** file before making
    any modifications:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我在进行任何修改前的 **hosts** 文件内容：
- en: '![Figure 8.12 – The content of my /etc/hosts file](image/B22229_08_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 我的 /etc/hosts 文件内容](image/B22229_08_12.jpg)'
- en: Figure 8.12 – The content of my /etc/hosts file
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 我的 /etc/hosts 文件内容
- en: The **hosts** file entries start on a new line with an IP address, followed
    by either tabs or spaces, followed by one or more domain names. You can use tabs
    or spaces, just be consistent. Now that you understand the **hosts** files, let’s
    move on and learn how to reformat the data from the Nuclei scan for insertion
    into our **hosts** file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**hosts** 文件中的条目从新的一行开始，先是一个 IP 地址，接着是制表符或空格，最后是一个或多个域名。你可以使用制表符或空格，只要保持一致。现在你已经理解了
    **hosts** 文件的结构，接下来我们将学习如何将 Nuclei 扫描的数据重新格式化，以便插入到我们的 **hosts** 文件中。'
- en: 'The following code will take a filename as the only command-line argument and
    output lines you can copy and paste into your **hosts** file. The code is thoroughly
    commented to explain what each part does. The example code can be found in the
    **ch08_nuclei.sh** file in this chapter’s folder in the GitHub repository. I’m
    going to split up the code into smaller chunks to explain each part as we go.
    It will be helpful to have the script in GitHub open on your screen to compare
    to the following code narrative:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将文件名作为唯一的命令行参数，并输出你可以复制并粘贴到 **hosts** 文件中的行。代码进行了详细注释，解释了每个部分的功能。示例代码可以在本章
    GitHub 仓库中的 **ch08_nuclei.sh** 文件中找到。我将把代码分成小块，逐一解释。打开 GitHub 上的脚本进行对照将会对理解以下代码叙述有所帮助：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If a file path isn’t passed on the command line, print usage and abort. It first
    checks whether the number of arguments ( **$#** ) is not equal ( **-ne** ) to
    **1** . If the statement in square brackets is true, then echo the description
    of th e script and usage example and exit.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行没有传递文件路径，则打印使用说明并中止。首先检查参数数量（**$#**）是否不等于（**-ne**）**1**。如果方括号中的条件为真，则回显脚本描述和使用示例并退出。
- en: 'In the following code, I pipe the file content to the cut command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我将文件内容通过管道传递给 cut 命令：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The **cut** command uses a space as delimiter from the 4th field to the end
    of line. The output is piped to the next command. A backslash ( **\** ) at the
    end of a line continues the command on to the next line.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**cut** 命令使用空格作为分隔符，从第 4 个字段到行末。输出通过管道传递到下一个命令。行尾的反斜杠（**\**）将命令延续到下一行。'
- en: 'In the following code, multi-part (6) sed commands are separated by semi-colon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，多个（6个） sed 命令通过分号分隔：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Only the beginning and end of the series of sed commands are enclosed in single
    quotes.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅系列 sed 命令的开始和结束部分用单引号括起来。
- en: '**s/:443//** : Removes the string **:443** from the input.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/:443//** ：从输入中移除字符串 **:443**。'
- en: '**s/\[//g** : Removes all occurrences of the [ character from the input. The
    **g** at the end means *global* , so it applies the substitution to all matches
    in each line.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/\[//g** ：从输入中移除所有 **[** 字符。末尾的 **g** 表示 *全局*，即它会对每行中的所有匹配项应用替换。'
- en: '**s/\]//g** : Removes all occurrences of the **]** character from the input
    (global). The **]** character must be escaped ( **\** ).'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/\]//g** ：从输入中移除所有 **]** 字符（全局替换）。**]** 字符必须使用反斜杠进行转义（**\**）。'
- en: '**s/"//g** : Removes all occurrences of the double quote ( **"** ) character
    from the input (global).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/"//g** ：从输入中移除所有双引号（**"**）字符（全局替换）。'
- en: '**s/,/ /g** : Replaces all occurrences of the comma ( **,** ) character with
    a space (global).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/,/ /g** ：将所有逗号（**,**）字符替换为空格（全局替换）。'
- en: '**s/ \*\.[^ ]*//g** : This expression typically removes wildcard subdomain
    entries like ***.example.com** (global). It removes any space followed by ***.**
    (escaped) and any sequence of non-space characters. Remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073)
    that the **^** character can have multiple meanings. Outside of square brackets
    it matches the beginning of a word or line. Inside of square brackets it negates
    the following characters. In this case, it’s saying *do not* *match spaces* .'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s/ \*\.[^ ]*//g** ：此表达式通常移除通配符子域条目，如 ***.example.com**（全局替换）。它会移除任何空格后跟的
    ***.**（已转义）以及任何非空格字符的序列。记住，在 [*第 4 章*](B22229_04.xhtml#_idTextAnchor073) 中，**^**
    字符可以有多种含义。在方括号外，它匹配单词或行的开头；在方括号内，它否定后续字符。在这种情况下，它表示 *不匹配空格*。'
- en: '**| \** : Finally, the resulting output is piped ( **|** ) to the sort command
    that follows. The backslash ( **\** ) character allows the command to continue
    on the next line.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**| \** ：最终，生成的输出通过管道（**|**）传递到后续的 sort 命令。反斜杠（**\**）字符允许命令继续到下一行。'
- en: 'The input is sorted uniquely ( **-u** ), as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是唯一排序的（**-u**），如图所示：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The data is sorted on the second field through the end of line ( **-k2** ).
    If we did not want to sort on the second field to the end of the line and instead
    wanted to sort only the second field, we would have used **-k2,2** . The numbers
    represent the *start* and *stop* fields, which are delimited with spaces by default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 数据根据第二个字段到行末进行排序（**-k2**）。如果我们不想对第二个字段到行末进行排序，而是仅对第二个字段进行排序，那么我们会使用 **-k2,2**。这些数字表示
    *开始* 和 *结束* 字段，默认情况下，它们由空格分隔。
- en: Again, the output is piped to the next command and the backslash continues the
    command to the next line.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，输出通过管道传递到下一个命令，反斜杠将命令继续到下一行。
- en: 'The following code starts an **awk** code block before initializing the **new_line**
    variable as an empty string:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在初始化 **new_line** 变量为空字符串之前，启动了一个 **awk** 代码块：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the last line of the preceding code we start a for loop inside the **awk**
    code block that iterates over all fields in the current record. Here’s a breakdown
    of that line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码的最后一行，我们在 **awk** 代码块内启动一个 for 循环，遍历当前记录中的所有字段。以下是该行的拆解：
- en: '**i = 1** : Initializes the **i** variable to **1**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i = 1** ：初始化 **i** 变量为 **1**'
- en: '**i <= NF** : **i** is less than or equal to the number of fields ( **NF**
    )'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i <= NF** ：**i** 小于或等于字段的数量（**NF**）'
- en: '**i++** : Increment **i** and repeat the loop'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i++** ：递增 **i** 并重复循环'
- en: 'The following code skips any wildcard domains. Wildcard domains are those that
    have an asterisk ( ***** ):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码跳过任何通配符域名。通配符域名是指带有星号（*****）的域名：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, if the current value of **i** does not contain an asterisk
    ( ***** ), concatenate it to **new_line** with a space.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，如果**i**的当前值不包含星号（*****），则将其与空格连接到**new_line**。
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, the closing brace ( **}** ) ends the **for** loop.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，右大括号（**}**）结束了**for**循环。
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding line of code uses the **sub** function to trim trailing spaces.
    The usage of **sub** is **sub(regex, replacement, target)** . The **target** value
    is optional, and when not included, it defaults to the entire current record (
    **$0** ).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行使用**sub**函数来修剪尾部的空格。**sub**的用法是**sub(regex, replacement, target)**。**target**值是可选的，如果不包含，则默认是整个当前记录（**$0**）。
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code splits **new_line** into an array called **fields** using
    a space as the delimiter, then prints the new line only if it contains more than
    one column.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将**new_line**拆分成一个名为**fields**的数组，使用空格作为分隔符，然后仅在包含超过一列时打印新行。
- en: 'The output of this script is shown in the following figure. If you copy and
    paste the output into your **hosts** file, it will override DNS when resolving
    a hostname:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的输出如图所示。如果你将输出复制并粘贴到你的**hosts**文件中，它将在解析主机名时覆盖DNS：
- en: '![Figure 8.13 – The output of the ch08_nuclei_01.sh script](image/B22229_08_13.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – ch08_nuclei_01.sh脚本的输出](image/B22229_08_13.jpg)'
- en: Figure 8.13 – The output of the ch08_nuclei_01.sh script
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – ch08_nuclei_01.sh脚本的输出
- en: You may ask why I put so much work into making a script to create three lines
    instead of just copying and pasting. Remember, this exercise began as an example
    of a challenge I solved during an external pentest that had thousands of live
    hosts in scope and the script printed hundreds of lines to add to my **hosts**
    file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我花这么多功夫去写一个脚本来创建三行，而不是直接复制粘贴。记住，这个练习最初是我在一次外部渗透测试中解决的一个挑战的例子，当时测试范围内有成千上万的活跃主机，脚本会打印出数百行，以便添加到我的**hosts**文件中。
- en: After adding the script output to my **hosts** file, when I scan those domain
    names, I can be sure that the names are resolving to the IP address that I choose,
    instead of resolving to the IP address of a CDN protected by a WAF.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本输出添加到我的**hosts**文件后，当我扫描这些域名时，我可以确保这些名称解析到我选择的IP地址，而不是解析到一个由WAF保护的CDN的IP地址。
- en: Using Bash to format vulnerability scan targets
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bash格式化漏洞扫描目标
- en: In the previous sections, you learned about HTTP **HOST** headers, TLS certificate
    SANs, and the **hosts** file. You also learned how to parse a Nuclei scan report
    and format the data for use in your **hosts** file. Related to this theme, you
    may also need to convince your vulnerability scanner to override DNS when scanning
    targets.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了关于HTTP **HOST**头部、TLS证书SAN和**hosts**文件的内容。你还学习了如何解析Nuclei扫描报告并将数据格式化为可以在**hosts**文件中使用的形式。与此相关，你可能还需要说服你的漏洞扫描器在扫描目标时覆盖DNS。
- en: 'Nessus ( [https://www.tenable.com/products/nessus](https://www.tenable.com/products/nessus)
    ) is a vulnerability scanner in common use by system administrators and security
    professionals. On the same pentest where I needed to override DNS and add subdomains
    parsed from a Nuclei scan to my **hosts** file, I needed to accomplish the same
    task for my Nessus scan. I eventually learned that Nessus doesn’t use the **hosts**
    file to resolve domain names. However, I did learn that Nessus does allow you
    to override DNS by specifying targets in the format **server1.example.com[192.168.1.1]**
    . The following code will take the output of the **ch08_nuclei_01.sh** script
    and convert it to the Nessus format. The example code can be found in the **ch08_nessus.sh**
    file in this chapter’s folder in the GitHub repository:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus（[https://www.tenable.com/products/nessus](https://www.tenable.com/products/nessus)）是系统管理员和安全专业人员常用的漏洞扫描器。在同一次我需要覆盖DNS并将从Nuclei扫描中解析出的子域添加到**hosts**文件的渗透测试中，我也需要为Nessus扫描完成相同的任务。我最终了解到Nessus并不使用**hosts**文件来解析域名。然而，我确实学到Nessus允许你通过指定目标格式为**server1.example.com[192.168.1.1]**来覆盖DNS。以下代码将获取**ch08_nuclei_01.sh**脚本的输出，并将其转换为Nessus格式。示例代码可以在本章节文件夹中的**ch08_nessus.sh**文件中找到，该文件位于GitHub仓库中：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This code simply checks to ensure that there is exactly one command-line argument
    passed to the script. If not one argument is entered, print the usage and exit.
    An **exit** code of anything other than zero is considered an error. This is important
    when your script logic must determine whether a previous command or script was
    completed successfully before running the next one.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地检查是否有正好一个命令行参数传递给脚本。如果没有传入一个参数，则打印用法并退出。任何非零的**exit**代码都视为错误。当你的脚本逻辑需要确定前一个命令或脚本是否成功执行后再运行下一个命令时，这一点非常重要。
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code creates an array to track unique hostnames.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了一个数组，用来跟踪唯一的主机名。
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code reads the file and processes each line.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码读取文件并处理每一行。
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code reads each line of input and uses **cut** to select the fourth field,
    the IP address. This results in an IP address and port that are separated by a
    colon. The last **cut** statement separates the two, selects the IP address, and
    assigns it to the **ip** variable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码读取每一行输入，使用 **cut** 选择第四个字段，即 IP 地址。结果是一个由冒号分隔的 IP 地址和端口。最后的 **cut** 语句将两者分开，选择
    IP 地址并将其赋值给 **ip** 变量。
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This line cuts the data into fields separated by spaces and selects the fifth
    field. It then selects the data inside square brackets and assigns it to the **hostnames**
    variable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将数据按空格分隔为字段，并选择第五个字段。然后选择方括号内的数据并将其赋值给 **hostnames** 变量。
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This line sets the comma as the field separator and reads each hostname into
    the **ADDR** array.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将逗号设置为字段分隔符，并将每个主机名读取到 **ADDR** 数组中。
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This code removes leading and trailing spaces from the hostname. By default,
    **xargs** trims leading and trailing whitespace and reduces any sequence of whitespace
    characters to a single space.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码移除主机名的前导和尾随空格。默认情况下，**xargs** 会修剪前导和尾随空白，并将任何空白字符序列减少为单个空格。
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code checks whether the first character of the hostname is not
    an asterisk.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码检查主机名的第一个字符是否不是星号。
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This code checks whether the value of the **hostname** variable is not present
    in the **seen_hostnames** array.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查**hostname**变量的值是否不存在于**seen_hostnames**数组中。
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This code adds the hostname to the **seen_hostnames** array if the preceding
    **if** statement evaluates to **true** (the **hostname** variable value is not
    in the **seen_hostnames** array).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如果前面的 **if** 语句评估为 **true**（**hostname** 变量值不在 **seen_hostnames** 数组中），则将主机名添加到
    **seen_hostnames** 数组中。
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This code prints the hostname and IP in the desired format, then closes the
    **if** / **fi** and **do** / **done** code blocks. The **done < "$1"** code passes
    the command-line argument to the code block as input.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印所需格式的主机名和 IP，然后关闭 **if** / **fi** 和 **do** / **done** 代码块。**done < "$1"**
    代码将命令行参数作为输入传递给代码块。
- en: 'The output of this script can be copied into a Nessus scan target list. The
    output is shown in the following figure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的输出可以复制到 Nessus 扫描目标列表中，输出如图所示：
- en: '![Figure 8.14 – The output of the Nessus script](image/B22229_08_14.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – Nessus 脚本的输出](image/B22229_08_14.jpg)'
- en: Figure 8.14 – The output of the Nessus script
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – Nessus 脚本的输出
- en: This will allow you to make Nessus override DNS to scan by hostname resolved
    to the IP address that you specify.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你让 Nessus 覆盖 DNS，通过解析到你指定的 IP 地址的主机名进行扫描。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the critical phase of reconnaissance and
    information gathering, focusing on how to discover various assets owned by the
    target organization. This chapter equipped you with the knowledge and tools to
    perform thorough reconnaissance using Bash scripting, which sets the foundation
    for subsequent active assessment stages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了侦察和信息收集的关键阶段，重点讲解了如何发现目标组织拥有的各种资产。本章为你提供了使用 Bash 脚本进行彻底侦察的知识和工具，为后续的主动评估阶段奠定了基础。
- en: Building on the reconnaissance skills acquired in this chapter, [*Chapter 9*](B22229_09.xhtml#_idTextAnchor241)
    will guide you through the application of Bash scripting in web application pentesting.
    As web applications are often key targets due to their accessibility and potential
    vulnerabilities, this chapter will focus on various techniques to identify, exploit,
    and document security weaknesses in web applications using Bash and related tools.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 基于本章所学的侦查技能，[*第9章*](B22229_09.xhtml#_idTextAnchor241)将引导你了解如何在网页应用渗透测试中应用Bash脚本。由于网页应用通常是由于其可访问性和潜在漏洞而成为关键目标，本章将重点介绍使用Bash及相关工具识别、利用和记录网页应用中的安全弱点的各种技术。
