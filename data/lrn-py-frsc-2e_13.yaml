- en: Coming Full Circle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整回顾
- en: In this chapter, we will revisit the scripts we've built in the previous chapters
    to create a prototype forensic framework. This framework will accept an input
    directory, such as the root folder of a mounted image, and run our plugins against
    the files to return a series of spreadsheet reports for each plugin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾前几章中构建的脚本，以创建一个原型取证框架。该框架将接受一个输入目录，例如已挂载镜像的根文件夹，并针对文件运行我们的插件，以返回每个插件的系列电子表格报告。
- en: Up to this point, we've developed standalone scripts in each chapter, never
    building upon the work in the previous chapters. By developing a framework, we
    will illustrate how to bring these scripts together and execute them in one context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在每一章中都开发了独立的脚本，从未在前一章的工作基础上进行扩展。通过开发一个框架，我们将演示如何将这些脚本整合在一起，并在一个上下文中执行它们。
- en: In [Chapter 8](5844a835-314a-474b-9c28-60880408629d.xhtml), *The Media Age*,
    we created a miniature framework for parsing various types of embedded metadata.
    We will borrow from that design and add object-oriented programming to it. Using
    classes simplifies our framework by creating an abstract object for plugins and
    writers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](5844a835-314a-474b-9c28-60880408629d.xhtml)《媒体时代》中，我们创建了一个用于解析各种类型嵌入式元数据的迷你框架。我们将借鉴该设计，并在其基础上加入面向对象编程。使用类简化了我们的框架，通过为插件和编写器创建抽象对象。
- en: Additionally, in our framework, we will showcase the use of a few external libraries
    that serve an aesthetic purpose rather than functional. These are colorama and
    FIGlet, which allow us to easily print colored text to standard out and create
    ASCII art, respectively. In addition, our framework  requires all of the third-party
    modules that we used in the previous chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的框架中，我们将展示一些外部库的使用，这些库主要服务于美学目的，而非功能性。这些库包括colorama和FIGlet，分别允许我们轻松地将彩色文本打印到标准输出并创建ASCII艺术。此外，我们的框架还要求使用我们在前几章中使用的所有第三方模块。
- en: 'The following topics will be discussed in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Framework fundamentals, challenges, and structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架基础、挑战和结构
- en: Adding aesthetic touches to our programs with Colorama and FIGlet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Colorama和FIGlet为我们的程序增添美学元素
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在Python 2.7.15和Python 3.7.1版本中进行开发和测试。
- en: Frameworks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架
- en: Why build a framework? The question could be, why develop a script at all? Frequently,
    we perform the same series of steps for a given piece of evidence. For example,
    we commonly prepare reports for LNK, prefetch, and jumplist files, examine registry
    keys, and establish external device and network activity to answer forensic questions.
    As we've seen, we can develop a script to parse these artifacts for us and display
    the data in a format that's conducive for rapid analysis. Why not write a series
    of scripts, each responsible for one artifact, and then control them with a singular
    script, to execute all at once and hence further automate our analysis?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要构建框架？这个问题可能是，为什么要开发脚本？通常，我们会对给定的证据执行相同的步骤。例如，我们常常为LNK、prefetch和jumplist文件准备报告，检查注册表键，并确定外部设备和网络活动以回答取证问题。正如我们所看到的，我们可以开发一个脚本来解析这些工件，并以有助于快速分析的格式显示数据。为什么不编写一系列脚本，每个脚本负责一个工件，然后通过一个脚本来控制它们，一次性执行，从而进一步自动化我们的分析呢？
- en: A framework can be developed to run a series of scripts and parse multiple artifacts
    at once. The output of such a framework could be a series of analysis-ready spreadsheets.
    This allows the examiner to skip the same tedious series of steps and start answering
    meaningful questions about the evidence.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个框架可以开发成一次性运行一系列脚本并同时解析多个工件。此类框架的输出可能是一系列分析就绪的电子表格。这样，检查员可以跳过同样繁琐的步骤，直接开始回答有关证据的有意义问题。
- en: 'Frameworks typically have three main components:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通常包含三个主要组件：
- en: A main controller
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主控制器
- en: Plugins
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Writers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写者
- en: The main controller isn't very different from our `main()` functions and essentially
    calls a series of plugins on some input, which parse specific artifacts, store
    the returned results, and then send the results to a writer for output. Our plugins
    are scripts that perform a specific task, for example, a script that parses `UserAssist`
    artifacts. Writers, similar to our `csv_writer()` functions, take the output from
    our plugins and write it out to disk. While this seems like a fairly straightforward
    process, developing frameworks is more complex than developing a single script.
    This is because we have to worry about building a simple yet efficient structure
    and keeping data standardized between plugins.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主控制器与我们的`main()`函数并没有太大区别，基本上是对一些输入调用一系列插件，这些插件解析特定的工件，存储返回的结果，然后将结果发送到写入程序进行输出。我们的插件是执行特定任务的脚本，例如一个解析`UserAssist`工件的脚本。与我们的`csv_writer()`函数类似，写入程序接受插件的输出并将其写入磁盘。尽管这个过程看起来相当直接，但开发框架比开发单个脚本要复杂得多。原因在于，我们需要担心构建一个既简洁又高效的结构，同时保持插件之间的数据标准化。
- en: Building a framework to last
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个持久的框架
- en: A challenge when developing frameworks is how to keep the code simple and efficient
    while continuously adding more functionality to the framework. You might find
    that while the structure of the framework made sense initially, it doesn't support
    the needs of your increasingly complex framework, requiring you to rethink and
    rebuild the internals of the framework. Unfortunately, there's no magical way
    to future-proof your framework and will likely require multiple revisions during
    its development cycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发框架时的一个挑战是如何在不断增加更多功能的同时，保持代码的简洁和高效。你可能会发现，尽管框架的结构最初看起来合理，但它并不支持你日益复杂的需求，这就要求你重新考虑并重建框架的内部结构。不幸的是，没有任何神奇的方法能够使框架在未来不出问题，通常在开发周期中会进行多次修订。
- en: This is no different from normal script development. In the early chapters of
    this book, we iterated through multiple versions of a script. We did this to illustrate
    the iterative build process you'll discover during development. This same iterative
    process can be applied at a larger scale for frameworks. While we are not highlighting
    that process in this chapter, keep in mind that you may need to rewrite the framework
    developed here might need to be rewritten if more plugins are later added and 
    efficiency starts to lag. Development by iteration allows us to continuously improve
    on our original design to create a stable and efficient program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这与普通脚本开发没有什么不同。在本书的早期章节中，我们迭代了多个版本的脚本。这样做是为了说明你在开发过程中会发现的迭代构建过程。这个相同的迭代过程也可以在框架的开发中大规模应用。虽然我们在这一章中没有强调这个过程，但请记住，如果以后添加更多插件，效率开始下降，你可能需要重写这里开发的框架。通过迭代开发，我们能够不断改进原始设计，打造出一个稳定且高效的程序。
- en: Data standardization
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据标准化
- en: One of the biggest challenges when developing a framework is data standardization.
    What that means is standardizing the input and output data for each plugin to
    keep things simple. For example, imagine one plugin that returns a list of dictionaries
    and another that returns just a list. To process these results correctly, you
    would need to include logic in your writers to handle both scenarios. It pays
    to implement each plugin in such a way that they return the same data structures.
    This helps keep your code simple by minimizing additional logic for a variety
    of special cases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发框架时最大的挑战之一就是数据标准化。意思是要标准化每个插件的输入输出数据，以保持简单性。例如，假设有一个插件返回一个字典列表，而另一个插件仅返回一个列表。为了正确处理这些结果，你需要在写入程序中加入逻辑，以处理这两种情况。通过使每个插件返回相同的数据结构，可以简化代码，减少处理各种特殊情况所需的额外逻辑。
- en: That said, there may very well be special scenarios you need to consider for
    each plugin. In our framework, for example, we'll see that some plugins return
    a list of dictionaries, whereas others return a single dictionary. Consider `setupapi_parser.py`
    from [Chapter 3](f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml), *Parsing Text Files*—for
    a moment, it can identify multiple distinct USB devices and generate a dictionary
    for each one, whereas our `exif_parser.py` only returns one dictionary containing
    the embedded metadata within a single file. In this case, rather than trying to
    rewrite the plugins to comply with our rule, we leverage logic to handle additional
    recursion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，可能会有一些特殊场景需要你为每个插件考虑。在我们的框架中，例如，我们会看到有些插件返回的是字典的列表，而有些插件返回的是单个字典。考虑一下[第3章](f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml)中的`setupapi_parser.py`，*解析文本文件*——它能够识别多个不同的USB设备，并为每个设备生成一个字典，而我们的`exif_parser.py`只返回一个字典，其中包含单个文件中的嵌入式元数据。在这种情况下，我们不需要重写插件来遵循我们的规则，而是通过逻辑来处理额外的递归。
- en: Forensic frameworks
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法医框架
- en: 'There are a lot of forensic frameworks and plenty of these are open source,
    allowing anyone to contribute to their development. These frameworks are great,
    not only to contribute to, but to see how experienced developers structure their
    frameworks. Some popular open source forensic frameworks include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多法医框架，其中很多都是开源的，允许任何人参与它们的开发。这些框架非常好，不仅可以贡献代码，还可以学习经验丰富的开发者是如何构建框架的。一些流行的开源法医框架包括以下内容：
- en: '**Volatility**: A memory forensic framework ([http://github.com/volatilityfoundation/volatility](http://github.com/volatilityfoundation/volatility))'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Volatility**：一个内存法医框架（[http://github.com/volatilityfoundation/volatility](http://github.com/volatilityfoundation/volatility)）'
- en: '**Plaso**: A artifact timelining tool ([http://github.com/log2timeline/plaso](http://github.com/log2timeline/plaso))'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Plaso**：一个伪造时间轴工具（[http://github.com/log2timeline/plaso](http://github.com/log2timeline/plaso)）'
- en: '**GRR ( short for Google Rapid Response)**: An agent-based analysis and response
    framework for remote forensic analysis ([http://github.com/google/grr](http://github.com/google/grr))'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRR（Google Rapid Response的简称）**：一种基于代理的远程法医分析和响应框架（[http://github.com/google/grr](http://github.com/google/grr)）'
- en: Contributing on an actively developing project, whether it's a framework or
    not, is a great way of actively learning good programming techniques and developing
    connections for collaboration on future projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个积极开发的项目中贡献代码，无论这个项目是否是框架，都是学习良好的编程技巧和发展未来项目协作关系的好方法。
- en: Make sure to read contribution rules before developing for any project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何项目开发之前，一定要阅读贡献规则。
- en: 'Enough has been said about frameworks: let''s discuss the third-party modules
    we''ll use to enhance the aesthetics of our framework.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 已经讨论了很多关于框架的内容，现在让我们来讨论一下我们将使用的第三方模块，来增强我们框架的美观性。
- en: Colorama
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Colorama
- en: 'The `colorama` module (version 0.4.1) allows us to easily create colored Terminal
    text. We''re going to use this to highlight good and bad events to the user. For
    example, when a plugin completes without errors, we display that with a green
    font. Similarly, we will print encountered errors in red. The colorama module
    can be installed with pip:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorama`模块（版本0.4.1）允许我们轻松创建带颜色的终端文本。我们将使用它来向用户突出显示好坏事件。例如，当一个插件无错误地完成时，我们会用绿色字体显示它。类似地，我们会用红色字体打印遇到的错误。可以使用pip安装colorama模块：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Traditionally, printing colored text to the Terminal is achieved by a series
    of escape characters on Linux or macOS systems. This, however, won''t work for
    Windows operating systems. The following are examples of ANSI escape characters
    being used to create colored text in Linux or macOS Terminals:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在Linux或macOS系统上，打印彩色文本是通过一系列转义字符实现的。然而，这对于Windows操作系统不起作用。以下是在Linux或macOS终端中使用ANSI转义字符来创建彩色文本的示例：
- en: '![](img/a30091c6-ff83-4ba5-9608-ddce5b4a343c.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a30091c6-ff83-4ba5-9608-ddce5b4a343c.png)'
- en: The color format is the escape character, `\033`, followed by an open bracket
    and then the desired color code. We can change the background color in addition
    to the foreground color and even do both at the same time by separating the codes
    with a semicolon. The color code, `31m`, sets the foreground text to red. The
    color code, `47m`, sets the background to white. Notice in the second example,
    in the preceding screenshot, `m` designates the end of the color codes and should
    therefore only follow the final color code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色格式是转义字符`\033`，后跟一个左括号，然后是所需的颜色代码。我们不仅可以更改前景色，还可以更改背景色，甚至可以同时更改这两者，通过用分号分隔代码来实现。颜色代码`31m`将前景文本设置为红色。颜色代码`47m`将背景设置为白色。在第二个示例中，在前面的截图中，`m`指定了颜色代码的结束，因此它应该仅跟在最后一个颜色代码后面。
- en: 'We can use the `colorama` and `call` built-in variables, which are aliases
    for the desired ANSI codes. This makes our code more readable and best of all
    works with Windows Command Prompts after calling `colorama.init()` at the beginning
    of your script:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置变量`colorama`和`call`，它们是所需ANSI代码的别名。这使我们的代码更具可读性，而且最重要的是，在调用`colorama.init()`后，它与Windows命令提示符兼容：
- en: '![](img/9233c4f6-e48e-4673-b06d-289ae393dcb2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9233c4f6-e48e-4673-b06d-289ae393dcb2.png)'
- en: 'The `colorama` module has three main formatting options: `Fore`, `Back`, and
    `Style`. These allow us to make changes to the foreground or background text color
    and its style, respectively. The colors available for the foreground and background
    include: black, red, green, yellow, blue, magenta, cyan, and white.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`colorama`模块有三个主要的格式化选项：`Fore`、`Back`和`Style`。这些选项分别允许我们更改前景或背景文本的颜色及其样式。前景色和背景色的可用颜色包括：黑色、红色、绿色、黄色、蓝色、洋红色、青色和白色。'
- en: It's possible to change other text properties using ANSI escape characters,
    such as if we wanted to make the text dimmer or brighter. ANSI color codes and
    other information on the `colorama` library is available at  [https://pypi.python.org/pypi/colorama](https://pypi.python.org/pypi/colorama).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ANSI转义字符，我们还可以更改其他文本属性，例如将文本变暗或变亮。关于ANSI颜色代码和`colorama`库的更多信息，请访问[https://pypi.python.org/pypi/colorama](https://pypi.python.org/pypi/colorama)。
- en: FIGlet
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIGlet
- en: 'FIGlet, and its Python extension, `pyfiglet` (version 0.8.post0), is a simple
    way of generating ASCII art. All we need to do is supply FIGlet with a string
    of our choice and a font style, which dictates the design of our text. We''ll
    use this module to print the title of our framework at the beginning of the program''s
    execution to give it some personality. We can use pip to install pyfiglet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FIGlet及其Python扩展`pyfiglet`（版本0.8.post0）是生成ASCII艺术的简单方法。我们只需向FIGlet提供一个我们选择的字符串和一个字体样式，后者决定了文本的设计。我们将使用此模块在程序执行开始时打印框架的标题，以赋予其个性。我们可以使用pip来安装pyfiglet：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use FIGlet, we need to create a FIGlet object and specify the type of font
    we would like to use. We then call the object''s `renderText` method, along with
    the string to style. A full list of fonts is available at [http://www.figlet.org/examples.html](http://www.figlet.org/examples.html):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用FIGlet，我们需要创建一个FIGlet对象，并指定我们希望使用的字体类型。然后，我们调用该对象的`renderText`方法，并传入要进行样式化的字符串。字体的完整列表可以在[http://www.figlet.org/examples.html](http://www.figlet.org/examples.html)找到：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the necessary third-party modules introduced, let's start walking through
    the framework code itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引入所需的第三方模块后，我们开始逐步讲解框架代码本身。
- en: Exploring the framework – framework.py
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索框架 – framework.py
- en: Our framework takes some input directory, recursively indexes all of its files,
    runs a series of plugins to identify forensic artifacts, and then writes a series
    of reports into a specified output directory. The idea is that the examiner could
    mount a `.E01` or `.dd` file using a tool such as FTK Imager and then run the
    framework against the mounted directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架接受一个输入目录，递归索引所有文件，运行一系列插件以识别取证文物，然后将一系列报告写入指定的输出目录。这个理念是，检查人员可以使用FTK Imager等工具挂载`.E01`或`.dd`文件，然后将框架应用于挂载的目录。
- en: 'The layout of a framework is an important first step in achieving a simplistic
    design. We recommend placing writers and plugins in appropriately labeled subdirectories
    under the framework controller. Our framework is laid out in the following manner:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的布局是实现简洁设计的重要第一步。我们建议将写作人员和插件放在框架控制器下适当标记的子目录中。我们的框架布局如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `framework.py` script contains the main logic of our framework-handling
    the input and output values for all of our plugins. The `requirements.txt` file
    contains one third-party module on each line used by the framework. In this format,
    we can use this file with `pip` to install all of the listed modules. `pip` will
    attempts to install the latest version of the module unless a version is specified
    immediately following the module name and two equal to signs (that is, `colorama==0.4.1`).
    We can install third-party modules from our `requirements.txt` file using the
    following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的`framework.py`脚本包含了框架的主要逻辑——处理所有插件的输入和输出值。`requirements.txt`文件包含每一行框架使用的第三方模块。采用这种格式，我们可以使用`pip`安装所有列出的模块。`pip`会尝试安装模块的最新版本，除非在模块名称后立即指定了版本，并使用两个等号（例如，`colorama==0.4.1`）。我们可以通过以下代码从`requirements.txt`文件安装第三方模块：  '
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The plugins and writers are stored in their own respective directories with
    an `__init__.py` file to ensure that Python can find the directory. Within the
    plugins directory are seven initial plugins our framework will support. The plugins
    we''ll include are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '插件和写入器存储在各自的目录中，并有一个`__init__.py`文件，以确保Python能够找到该目录。在插件目录中，我们的框架将支持七个初始插件。我们将包括以下插件：  '
- en: The EXIF, ID3, and Office embedded metadata parsers from [Chapter 8](5844a835-314a-474b-9c28-60880408629d.xhtml), *The
    Media Age*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '来自[第8章](5844a835-314a-474b-9c28-60880408629d.xhtml)的EXIF、ID3和Office嵌入式元数据解析器，*媒体时代*  '
- en: The PST parser from [Chapter 11](90da6f73-2678-4460-8cfb-b388db40a6c3.xhtml), *Parsing
    Outlook PST Containers*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '来自[第11章](90da6f73-2678-4460-8cfb-b388db40a6c3.xhtml)的PST解析器，*解析Outlook PST容器*  '
- en: The Setupapi parser from [Chapter 3](f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml), *Parsing
    Text Files*
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '来自[第3章](f5b49c85-69ce-4f37-b62d-7f2934e8d30e.xhtml)的Setupapi解析器，*解析文本文件*  '
- en: The UserAssist parser from [Chapter 6](59414e87-5820-4942-bd47-aba762dd9f14.xhtml), *Extracting
    Artifacts from Binary Files*
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '来自[第6章](59414e87-5820-4942-bd47-aba762dd9f14.xhtml)的UserAssist解析器，*从二进制文件中提取工件*  '
- en: The WAL file parser from [Chapter 12](f4d95d98-e057-4ad3-b737-4fd72a810e27.xhtml), *Recovering
    Transient Database Records*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '来自[第12章](f4d95d98-e057-4ad3-b737-4fd72a810e27.xhtml)的WAL文件解析器，*恢复临时数据库记录*  '
- en: 'There''s also a `helper` directory containing some helper scripts that are
    required by some of the plugins. There are currently three supported output formats
    for our framework: CSV, XLSX, and KML. Only the `exif` plugin will make use of
    `kml_writer` to create a Google Earth map with plotted EXIF GPS data, as we saw
    in [Chapter 8](5844a835-314a-474b-9c28-60880408629d.xhtml), *The Media Age*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一个`helper`目录，包含一些插件所需的辅助脚本。目前，我们的框架支持三种输出格式：CSV、XLSX和KML。只有`exif`插件会使用`kml_writer`来创建带有EXIF
    GPS数据的Google Earth地图，正如我们在[第8章](5844a835-314a-474b-9c28-60880408629d.xhtml)中看到的，*媒体时代*。  '
- en: Now that we understand the how, why, and layout of our framework, let's dig
    into some code. On lines 2 through 11, we import the modules we plan to use. Note
    that this is only the list of modules that are required in this immediate script.
    It doesn't include the dependencies required by the various plugins. Plugin-specific
    imports are made in their respective scripts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们了解了框架的工作原理、原因和布局，让我们深入看看一些代码。在第2行到第11行之间，我们导入了我们计划使用的模块。请注意，这仅是当前脚本所需的模块列表，未包括各种插件所需的依赖项。插件特定的导入将在各自的脚本中完成。  '
- en: 'Most of these imports should look familiar from the previous chapters, with
    the exception of the new additions of `colorama` and `pyfiglet`. On lines 7 and
    8, we import our plugins and writers subdirectories, which contain the scripts
    for our plugins and writers. The `colorama.init()` call on line 13 is a prerequisite
    that allows us to print colored text to the Windows Command Prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新增的`colorama`和`pyfiglet`之外，之前章节中的大部分导入应该都很熟悉。在第7行和第8行，我们导入了插件和写入器子目录，这些目录包含了插件和写入器的脚本。第13行的`colorama.init()`调用是一个前提，允许我们在Windows命令提示符中打印彩色文本：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On line 49, we define our `Framework` class. This class will contain a variety
    of methods, all of which handle the initialization and execution of the framework.
    The `run()` method acts as our typical main function and calls the `_list_files()`
    and `_run_plugins()` methods. The `_list_files()` method walks through files in
    the user-supplied directory and, based upon the name or extension, adds the file
    to a plugin-specific processing list. Then, the `_run_plugins()` method takes
    these lists and executes each plugin, stores the results, and calls the appropriate
    writer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第49行，我们定义了`Framework`类。该类包含多种方法，所有这些方法都处理框架的初始化和执行。`run()`方法充当我们的典型主函数，并调用`_list_files()`和`_run_plugins()`方法。`_list_files()`方法会遍历用户提供目录中的文件，并根据文件名或扩展名，将文件添加到特定插件的处理列表中。然后，`_run_plugins()`方法将这些列表传递给每个插件执行，存储结果，并调用相应的写入器：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the `Framework` class are two subclasses: `Plugin` and `Writer`. The
    `Plugin` class is responsible for actually running the plugin, logging when it
    completes, and sending data to be written. The `run()` method repeatedly executes
    each function for every file in the plugin''s processing list. It appends the
    returned data to a list, mapped to the key in a dictionary. This dictionary also
    stores the desired field names for the spreadsheet. The `write()` method creates
    the plugin specific output directory and, based on the type of output specified,
    makes appropriate calls to the `Writer` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Framework`类中，有两个子类：`Plugin`和`Writer`。`Plugin`类负责实际运行插件，记录插件完成的日志，并将数据发送以供写入。`run()`方法会对插件处理列表中的每个文件反复执行每个函数。它将返回的数据附加到一个列表中，并将其映射到字典中的键。这个字典还存储着电子表格所需的字段名称。`write()`方法会创建特定插件的输出目录，并根据指定的输出类型，适当地调用`Writer`类：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Writer` class is the simplest class of the three. Its `run()` method simply
    executes the desired writers with the correct input:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer`类是三者中最简单的类。它的`run()`方法只是简单地执行所需的写入器并提供正确的输入：'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As with all of our scripts, we use `argparse` to handle command-line switches.
    On lines 285 and 287, we create two positional arguments for our input and output
    directories. The two optional arguments on lines 288 and 290 specify XLSX output
    and the desired log path, respectively:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们所有的脚本一样，我们使用`argparse`来处理命令行选项。在第285和287行，我们为输入和输出目录创建了两个位置参数。在第288和290行的两个可选参数分别指定了XLSX输出和所需的日志路径：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see our first use of the `colorama` library on line 297\. If the supplied
    input and output directories are files, we print a red error message to the console.
    For the rest of our framework, we use error messages displayed in red text and
    success messages in green:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第297行看到首次使用`colorama`库。如果提供的输入和输出目录是文件，我们会向控制台打印一条红色的错误信息。对于框架的其余部分，我们使用红色文本显示错误信息，使用绿色文本显示成功信息：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On line 300, we check whether the optional directory path was supplied for
    the log file. If so, we create these directories (if they don''t exist), and store
    the filename for the log in the `log_path` variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第300行，我们检查是否提供了日志文件的可选目录路径。如果提供了，我们会创建这些目录（如果它们不存在），并将日志文件的文件名存储在`log_path`变量中：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On lines 307 and 309, we create our `Framework` object and then call its `run()`
    method. We pass the following arguments into the `Framework` constructor to instantiate
    the object: `INPUT_DIR`, `OUTPUT_DIR`, `log_path`, and `excel`. In the next section,
    we inspect the `Framework` class in greater detail:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第307和309行，我们创建了`Framework`对象，并调用了它的`run()`方法。我们将以下参数传递给`Framework`构造函数以实例化该对象：`INPUT_DIR`、`OUTPUT_DIR`、`log_path`和`excel`。在下一节中，我们将更详细地检查`Framework`类：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following flow chart highlights how the different methods in the `framework.py`
    script interact. Keep in mind that this flow chart only shows interactions within
    the immediate script and doesn''t account for the various plugin, writer, and
    utility scripts:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下流程图突出显示了`framework.py`脚本中不同方法的交互方式。请记住，这个流程图只展示了脚本内部的交互，并没有考虑到各种插件、写入器和工具脚本：
- en: '![](img/97d8fbb0-fb28-4318-9f48-7421e0049564.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d8fbb0-fb28-4318-9f48-7421e0049564.png)'
- en: Exploring the Framework object
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Framework对象
- en: 'We developed our framework with an object-oriented programming design in mind.
    This allows us to create compartmentalized and reusable objects. Within our `Framework`
    object are the `Plugin` and `Writer` objects, which we explored in the proceeding
    sections. The `Framework` class is defined on line 49 and extends the `object`
    class. In Python 2.X, inheriting from an object that replaces the previous tradition
    of inheriting nothing has become standard in Python 3.X:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计我们的框架时采用面向对象的编程设计。这使我们能够创建分隔和可重用的对象。在我们的 `Framework` 对象中包含 `Plugin` 和 `Writer`
    对象，在接下来的章节中我们将对其进行探讨。`Framework` 类定义在第 49 行，并且扩展了 `object` 类。在 Python 2.X 中，从一个
    `object` 继承取代了之前传统上的空继承，这在 Python 3.X 中已成为标准：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Understanding the Framework __init__() constructor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解框架的 `__init__()` 构造函数
- en: 'The `__init__()` method for the framework is defined on line 51\. In this constructor,
    we assign the arguments passed to the constructor as instance variables. We also
    configure the logging module on line 55\. Let''s look at the `run()` method, which,
    as we saw, is called immediately after the `Framework` object is instantiated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的 `__init__()` 方法在第 51 行定义。在这个构造函数中，我们将传递给构造函数的参数赋值为实例变量。我们还在第 55 行配置了日志模块。让我们看一下
    `run()` 方法，在我们看到的情况下，它是在 `Framework` 对象实例化后立即调用的：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the Framework run() method
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建框架的 `run()` 方法
- en: 'The `run()` method, defined on line 61, executes the entire logic of our framework
    in a few lines of code. Lines 62 through 68 simply print and log startup information
    for debugging purposes. Notice the use of `Figlet` on lines 65 and 66 to print
    our framework''s title to the console:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 方法定义在第 61 行，用几行代码执行我们框架的整体逻辑。第 62 到 68 行仅用于打印和记录调试目的的启动信息。请注意，在第 65
    和 66 行使用 `Figlet` 打印我们框架的标题到控制台：'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On line 69, we check to see whether the output directory exists. If it doesn''t,
    we create it using the `os.makedirs()` method. Finally, on lines 71 and 72, we
    call the `_list_files()` and `_run_plugins()` methods to index the input directory
    files and run our plugins against them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 69 行，我们检查输出目录是否存在。如果不存在，我们使用 `os.makedirs()` 方法创建它。最后，在第 71 和 72 行，我们调用 `_list_files()`
    和 `_run_plugins()` 方法对输入目录文件进行索引，并运行我们的插件：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Iterating through files with the Framework _list_files() method
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架的 `_list_files()` 方法迭代文件
- en: The `_list_files()` method is used to iterate through each file in the input
    directory recursively. It stores the files into a processing list for a plugin
    based on the file's name or extension. One drawback to this approach is that we're
    relying on file extensions to be correct rather than using the file signatures
    themselves. We could implement this functionality into the framework by using
    struct to check each file's signature, as we've done in the previous chapters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`_list_files()` 方法用于递归遍历输入目录中的每个文件。它将文件存储到处理列表中，供基于文件名或扩展名的插件使用。这种方法的一个缺点是，我们依赖于文件扩展名是否正确，而不是使用文件的签名本身。我们可以通过使用
    struct 在框架中实现这个功能，就像我们在前几章中所做的那样。'
- en: Notice that the `_list_files()` method has a single leading underscore. This
    is Python's way of declaring an internal method. What it means here is that we're
    declaring that the `_list_files()` method shouldn't be imported and, generally,
    shouldn't be directly called by the user. For instance, we should not call `Framework`. `_list_files()`
    on our `Framework` object after we instantiated it on line 309\. Instead, we can
    call the `run()` method, which in turn calls the `_list_files()` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`_list_files()` 方法前面有一个单个下划线。这是 Python 中声明内部方法的方式。这里的意思是，我们声明 `_list_files()`
    方法不应该被导入，一般情况下也不应该由用户直接调用。例如，在第 309 行实例化我们的 `Framework` 对象后，我们不应该调用 `Framework`
    的 `_list_files()`。相反，我们可以调用 `run()` 方法，该方法又会调用 `_list_files()` 方法。
- en: 'The `_list_files()` method is defined on line 74 and prints and logs the current
    execution status. On lines 79 through 85, we create a series of lists specific
    to each plugin. These lists are used to store any file identified as compatible
    with a plugin for later processing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`_list_files()` 方法在第 74 行定义，并打印和记录当前的执行状态。在第 79 到 85 行，我们创建了一系列针对每个插件特定的列表。这些列表用于存储任何与插件兼容的文件，以便稍后处理：'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Starting on line 87, we use the `os.walk()` method that we used in the previous
    chapters to iterate over the input directory. For each file, we create two variables,
    one for the name of the current file and another for the extension of the current
    file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从第87行开始，我们使用`os.walk()`方法（我们在前几章中使用过）来遍历输入目录。对于每个文件，我们创建两个变量，一个存储当前文件的名称，另一个存储当前文件的扩展名：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using our `current_file` and `ext` variables, we use a series of conditional
    statements to identify files for our plugins. For example, on line 96, we check
    whether the file contains `ntuser.dat` in its name as this most likely identifies
    it as a user's registry hive and is appended to our `userassist_files` list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`current_file`和`ext`变量，我们使用一系列条件语句来识别插件需要处理的文件。例如，在第96行，我们检查文件名中是否包含`ntuser.dat`，因为这很可能表明它是一个用户的注册表配置单元，并且会被添加到我们的`userassist_files`列表中。
- en: 'Similarly, on line 100, anything ending in `.jpeg` or `.jpg` is most likely
    a photo with EXIF embedded metadata and is appended to our `exif_metadata` list.
    If the current file doesn''t meet any of our requirements, then we can''t parse
    it with our current plugins, and we use `continue` to start the next loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在第100行，任何以`.jpeg`或`.jpg`结尾的文件很可能是带有嵌入式EXIF元数据的照片，并且会被添加到我们的`exif_metadata`列表中。如果当前文件不符合任何要求，那么我们无法使用当前的插件解析它，我们将使用`continue`开始下一个循环：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Developing the Framework _run_plugins() method
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发框架的_run_plugins()方法
- en: The `_run_plugins()` is another internal method and handles the logic for calling
    each plugin and then sending the returned results to the appropriate writer. There
    are two twists in handling each plugin. We highlight these different twists for
    two plugins. We won't cover the other five plugins to cut down on explaining the
    same code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`_run_plugins()`是另一个内部方法，处理调用每个插件的逻辑，然后将返回的结果发送到相应的写入器。处理每个插件时有两个关键的变化。我们在两个插件中强调了这些不同的变化。我们不会涵盖其他五个插件，以减少解释相同代码的重复。'
- en: The first plugin example is the `wal_crawler` plugin. On line 117, we check
    whether we need to create a `Plugin` object for the `wal_crawler` at all because
    if the `wal_files` list is empty, there'll be nothing to run the plugin against.
    If it isn't empty, we create a `Plugin` object on line 118.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个插件示例是`wal_crawler`插件。在第117行，我们检查是否需要为`wal_crawler`创建`Plugin`对象，因为如果`wal_files`列表为空，就没有东西可以对插件进行操作。如果不为空，我们将在第118行创建一个`Plugin`对象。
- en: Next, we create `wal_output`, which stores our plugin's output directory. On
    line 121, we call the `run()` method of the `Plugin` class and then, based on
    whether the `excel` output option is specified, `write()` the results of the plugin,
    passing along the `excel` keyword argument, if necessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`wal_output`，它存储我们插件的输出目录。在第121行，我们调用`Plugin`类的`run()`方法，然后根据是否指定了`excel`输出选项，使用`write()`方法写入插件结果，并在必要时传递`excel`关键字参数。
- en: 'Recall that the `wal_crawler` script returns a list of dictionaries where each
    dictionary contains a cells worth of data. When we call the plugin, we put the
    results in yet another list. By default, the writers expect just a list of dictionaries
    to iterate over and write the appropriate report. Because we append a list of
    dictionaries to yet another list, we need to tell the writer that it needs another
    `for` loop to access the list of dictionaries. We do this by passing the recursion
    keyword argument to the plugin''s `write()` method. We set the `recursion` value
    to `1`,  to mark it as enabled:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`wal_crawler`脚本返回一个包含字典的列表，每个字典包含一行数据。当我们调用插件时，我们将结果放入另一个列表中。默认情况下，写入器只期望一个字典列表来遍历并写入相应的报告。由于我们将字典列表添加到另一个列表中，因此我们需要告诉写入器它需要另一个`for`循环来访问字典列表。我们通过将递归关键字参数传递给插件的`write()`方法来实现这一点。我们将`recursion`值设置为`1`，以标记它已启用：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unlike in the previous example, our ID3 metadata script returns a single dictionary,
    which is appended to a list. In these scenarios, we don't need to specify the
    `recursion` keyword argument, as seen on lines 190 and 193\. Beyond this single
    difference, the plugin is handled in the same fashion as the previous plugin.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例不同，我们的ID3元数据脚本返回一个单一的字典，该字典会被添加到一个列表中。在这些情况下，我们不需要指定`recursion`关键字参数，如第190行和193行所示。除了这一点不同，插件的处理方式与前一个插件相同。
- en: Remember one goal of our framework is to be able to disable or add a new plugin
    in as few lines of code as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们框架的目标之一是能够以尽可能少的代码行禁用或添加新的插件。
- en: 'This increases the simplicity of the framework, making it far easier to maintain.
    We''ve tried to maintain that here by keeping the logic consistent and using keyword
    arguments to handle slight variations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这提高了框架的简洁性，使得它更容易维护。我们通过保持逻辑一致性并使用关键字参数来处理微小的变化，努力保持这一点：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exploring the Plugin object
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Plugin 对象
- en: 'On line 207, we have the beginning of the `Plugin` subclass. This class contains
    the `run()` and `write()` methods, which are used to handle the execution of each
    plugin as well as the calls to the writers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 207 行，我们看到了 `Plugin` 子类的开始。这个类包含了 `run()` 和 `write()` 方法，这些方法用于处理每个插件的执行以及对写入器的调用：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Understanding the Plugin __init__() constructor
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Plugin 的 `__init__()` 构造函数
- en: 'The `Plugin` constructor method is fairly straightforward. We create instance
    variables for the plugin name, the files to process, the log, and a dictionary
    containing the results of the plugin. The results dictionary contains a data list,
    which stores the actual results returned from each plugin call. The headers key
    will eventually have a list storing the field names to use in the writers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plugin` 构造方法非常简单。我们为插件名称、待处理文件、日志以及一个包含插件结果的字典创建实例变量。结果字典包含一个数据列表，该列表存储每次插件调用返回的实际结果。`headers`
    键最终将包含一个列表，存储在写入器中使用的字段名：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Working with the Plugin run() method
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Plugin 的 `run()` 方法
- en: The `run()` method defined on line 215 is responsible for executing the plugin
    against each file stored in the plugin's list. In addition, this method prints
    out various status messages pertaining to the execution of the plugin.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 215 行定义的 `run()` 方法负责在插件列表中的每个文件上执行插件。此外，该方法会打印出与插件执行相关的各种状态消息。
- en: 'The function argument passed into the `run()` method is the name of the entry-point
    method in the plugin. We call this entry-point for each file in the plugin''s
    file list. For example, the `wal_crawler` plugin''s entry-point method is `plugins.wal_crawler.main`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `run()` 方法的函数参数是插件中的入口方法名称。我们为插件文件列表中的每个文件调用这个入口方法。例如，`wal_crawler` 插件的入口方法是
    `plugins.wal_crawler.main`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On line 220, we begin to iterate through each file in the plugin's file list.
    On line 222, we call the function variable and supply it with the file to process.
    This restricts all of our plugins to comply with a single file as its input. Some
    of the modifications we made to our existing plugins involved modifying their
    required arguments to work within the bounds of the framework. For example, in
    the previous chapters, we may have passed in an output file or directory as one
    of the script's arguments. However, now, the writers, a separate part of the framework,
    handle the output and so the plugins only need to focus on processing and returning
    the data to the framework.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 220 行，我们开始遍历插件文件列表中的每个文件。在第 222 行，我们调用函数变量，并将文件作为参数传递给它进行处理。这将所有插件限制为单一文件输入。我们对现有插件所做的一些修改，涉及到调整它们的必需参数，使其能够在框架的限制范围内工作。例如，在前面的章节中，我们可能会将输出文件或目录作为脚本的参数之一传递。然而现在，写入器作为框架的一个独立部分处理输出，因此插件只需要专注于处理数据并将其返回给框架。
- en: Notice that the function call is wrapped around try and except. In the plugins
    themselves, you can see that we raise `TypeError` when we encounter an error in
    the plugin; in the case of an error, the plugin logs the actual error while the
    framework continues to process the next file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数调用被包裹在 `try` 和 `except` 中。在插件本身中，我们可以看到当插件出现错误时会抛出 `TypeError`；在发生错误时，插件会记录实际错误，同时框架会继续处理下一个文件。
- en: 'On lines 223 and 224, we append the returned results from the plugin to the
    data list and set the headers for the plugin. The returned headers list is a constant
    list of field names that''s set whenever the plugin returns successfully:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 223 和 224 行，我们将插件返回的结果附加到数据列表中，并为插件设置 `headers`。返回的 `headers` 列表是一个常量字段名列表，每当插件成功返回时都会设置：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, on lines 231 through 234, we print out and log the successful completion
    of the plugin, including the current time to the user:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第 231 到 234 行，我们打印并记录插件的成功完成，包括当前时间：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Handling output with the Plugin write() method
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Plugin 的 `write()` 方法处理输出
- en: 'The `write()` method is first defined on line 236\. This method creates the
    plugin-specific output directory and call the appropriate writer to create the
    plugin report. On lines 241 and 242, after printing out a status message to the
    user, we create the plugin output directory if it doesn''t already exist:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()`方法首先在第236行定义。此方法创建插件特定的输出目录，并调用适当的写入器来生成插件报告。在第241和242行，在向用户打印状态消息后，如果插件输出目录尚不存在，则创建该目录：'
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On line 243, we check to see whether the `excel` keyword argument was specified
    in the function call. If it was, we call `xlsx_writer` and pass the output directory,
    the desired filename, field names, and the data to write.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第243行，我们检查`excel`关键字参数是否在函数调用中指定。如果指定了，我们调用`xlsx_writer`并传递输出目录、所需的文件名、字段名和要写入的数据。
- en: 'If the `excel` keyword argument isn''t supplied, the default `csv_writer` is
    called instead. This function takes the same arguments as `xlsx_writer`. On line 253,
    we check whether the plugin name is `exif_metadata`. If so, we call `kml_writer`
    to plot the Google Earth GPS data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`excel`关键字参数，则调用默认的`csv_writer`。此函数与`xlsx_writer`具有相同的参数。在第253行，我们检查插件名称是否为`exif_metadata`。如果是，我们调用`kml_writer`来绘制Google
    Earth的GPS数据：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Exploring the Writer object
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Writer对象
- en: 'The `Writer` object is defined on line 258\. This class is responsible for
    creating the report for each plugin. The class has one main method, `run()`, which
    simply calls the writer that was described in the `plugin.write` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer`对象在第258行定义。此类负责为每个插件创建报告。该类有一个主要方法`run()`，它简单地调用在`plugin.write`方法中描述的写入器：'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Understanding the Writer __init__() constructor
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Writer的__init__()构造函数
- en: 'The constructor method instantiates session variables, including the output
    filename of the report, the header, and the data to be written. If the `recursion`
    keyword argument is present, we set the session variable before calling the `run()`
    method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 构造方法实例化会话变量，包括报告的输出文件名、表头和要写入的数据。如果存在`recursion`关键字参数，我们在调用`run()`方法之前设置会话变量：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Understanding the Writer run() method
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Writer的run()方法
- en: 'The `run()` method is very straightforward. Based on whether recursion was
    specified, we call the specified writer, passing along the `recursion` keyword
    argument:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法非常直接。根据是否指定了递归，我们调用指定的写入器，并传递`recursion`关键字参数：'
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our Final CSV writer – csv_writer.py
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的最终CSV写入器 – csv_writer.py
- en: 'Each writer essentially works in the same manner. Let''s briefly discuss the
    `csv_writer` method before discussing the more complex `xlsx_writer` script. Depending
    on whether the framework is run with Python 2.X or 3.X, we import the native `csv`
    or `unicodecsv` modules to handle Unicode strings. The `unicodecsv` module was
    first introduced in [Chapter 5](a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml), *Databases
    in Python*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个写入器的工作方式基本相同。在讨论更复杂的`xlsx_writer`脚本之前，让我们简要讨论一下`csv_writer`方法。根据框架是使用Python
    2.X还是3.X运行，我们导入原生的`csv`或`unicodecsv`模块来处理Unicode字符串。`unicodecsv`模块首次出现在[第5章](a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml)，*Python中的数据库*中：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our writer is very simple. On line 61, we create a `csv.DictWriter` object
    and pass it the output filename and headers list. As always, we indicate to the
    writer to ignore the case where they are keys that are not specified in the supplied
    headers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的写入器非常简单。在第61行，我们创建一个`csv.DictWriter`对象，并传入输出文件名和表头列表。像往常一样，我们指示写入器忽略那些在提供的表头中没有指定的键：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the `DictWriter` object created, we can use the built-in `writerheader()`
    method to write our field names as the first row of the spreadsheet. Notice that
    we wrap this in a try and except, something we haven''t done in the past. Imagine
    a scenario where there''s only one file for a plugin to process and it encounters
    and error and returns prematurely. In this case, the headers list will be none,
    which will cause an error. This last check allows us to exit writing invalid output
    files for this scenario:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`DictWriter`对象后，我们可以使用内置的`writerheader()`方法将字段名作为电子表格的第一行写入。请注意，我们将其包装在try和except中，这是我们以前没有做过的。假设有一个插件需要处理的文件，并且在处理中遇到错误并提前返回。在这种情况下，表头列表将为None，这会导致错误。这个最后的检查可以让我们避免在这种情况下写入无效的输出文件：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, on line 73, if the `recursion` keyword argument was supplied, we use
    two `for` loops before calling the `writerow` method on the dictionaries. Otherwise,
    on line 79, we only need to use one `for` loop to access the data to write:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第73行，如果提供了`recursion`关键字参数，我们在调用字典的`writerow`方法之前使用两个`for`循环。否则，在第79行，我们只需使用一个`for`循环来访问数据并进行写入：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The writer – xlsx_writer.py
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入器 – xlsx_writer.py
- en: 'The `xlsx_writer` function is a slightly modified version of `xlsx_writer`,
    which we created in [Chapter 6](59414e87-5820-4942-bd47-aba762dd9f14.xhtml), *Extracting
    Artifacts from Binary Files*. We use the same `xlsxwriter` third-party module
    to handle the excel output. On line 32, we use list comprehension to create a
    list of capitalized alphabetical characters from `A` to `Z`. We''re going to use
    this list to designate the column letter based on the supplied headers length.
    This method works as long as there are less than 26 field names, which for the
    current set of plugins is true:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlsx_writer`函数是`xlsx_writer`的略微修改版本，我们在[第6章](59414e87-5820-4942-bd47-aba762dd9f14.xhtml)，*从二进制文件中提取文档*中创建了它。我们使用相同的`xlsxwriter`第三方模块来处理Excel输出。在第32行，我们使用列表推导式创建一个包含从`A`到`Z`的大写字母的列表。我们将使用此列表根据提供的字段头长度指定列字母。此方法在字段名称少于26个时有效，对于当前插件集是成立的：'
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On line 44, we create the `xlsxwriter` workbook and supply the output filename
    to save it as. Before going any further, we check whether the supplied headers
    are equal to none. This check is necessary, just as in `csv_writer`, to avoid
    writing invalid data from a bad call to the writer. On line 52, we set `title_length`
    equal to the letter that the right-most column will be, in case there are more
    than 26 columns. We''ve currently set the right-most value to be `Z`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第44行，我们创建`xlsxwriter`工作簿并提供输出文件名以保存。在继续之前，我们检查提供的头部是否为空。这个检查是必要的，正如在`csv_writer`中一样，避免因为错误的写入器调用而写入无效数据。在第52行，我们将`title_length`设置为最右侧列的字母，以防有超过26列的情况。目前，我们将最右侧的值设置为`Z`：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, on line 56, we create our worksheet. In a similar fashion to the `csv_writer`
    function, if recursion is specified, we loop through the list, adding a worksheet
    for each additional list to prevent them from writing over each other. We then
    use list comprehension to quickly order the dictionary values based on the order
    of the field names. In `csv_writer`, the `writerow` method from the `DictWriter`
    object orders the data automatically. For `xlsx_writer`, we need to use list comprehension
    to recreate that same effect:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第56行，我们创建工作表。与`csv_writer`函数类似，如果指定了递归，我们将遍历列表，为每个额外的列表添加一个工作表，以防止它们相互覆盖。然后，我们使用列表推导式根据字段名称的顺序快速排序字典值。在`csv_writer`中，`DictWriter`对象的`writerow`方法会自动对数据进行排序。对于`xlsx_writer`，我们需要使用列表推导式来重新创建相同的效果：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On line 69, we create a table from `A3` to `XY`, where `X` is the alphabet
    character representing the length of the field names list and `Y` is the length
    of the `output_data` list. For example, if we have a dataset that has six field
    names and 10 entries, we want our table to span from `A3` to `F13`. In addition,
    we pass along the ordered data and specify each column using list comprehension
    once again to specify a dictionary with one key-value pair for each header:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第69行，我们创建一个从`A3`到`XY`的表格，其中`X`是表示字段名称列表长度的字母字符，`Y`是`output_data`列表的长度。例如，如果我们有一个数据集，包含六个字段名称和10个条目，我们希望表格从`A3`到`F13`。此外，我们将排序后的数据传递给表格，并再次使用列表推导式指定每一列，确保每个标题对应一个键值对的字典：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On line 74, we handle the scenario where we don''t supply the `recursion` keyword
    argument. In this case, we handle the same execution minus the additional `for`
    loop. Lastly, on line 84, we close the workbook:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第74行，我们处理没有提供`recursion`关键字参数的情况。在这种情况下，我们处理相同的执行流程，只是没有额外的`for`循环。最后，在第84行，我们关闭工作簿：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `add_worksheet()` method is called on lines 56 and 61\. This function is
    used to create the worksheet and writes the first two rows of the spreadsheet.
    On line 96, we create the `title_format` style, which contains the text properties
    we want for our two title rows. On lines 101 and 103, we create both of our title
    rows. Currently, the values of these title rows are hardcoded but could be programmed
    into the framework by adding them as optional switches in `argparse`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_worksheet()`方法在第56行和第61行被调用。这个函数用于创建工作表并写入电子表格的前两行。在第96行，我们创建了`title_format`样式，其中包含我们想要的两个标题行的文本属性。在第101行和第103行，我们创建了这两行标题。目前，这些标题行的值是硬编码的，但可以通过将它们作为可选开关添加到`argparse`中，编程到框架中：'
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Changes made to plugins
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对插件所做的更改
- en: We've discussed the framework, its subclasses, and the two main writer scripts.
    What about the changes we had to make to the plugin scripts from previous chapters?
    For the most part, their core functionality is unchanged. Modifications we made
    include removing printing and logging statements, deleting the `argparse` and
    log setup sections, and removing unnecessary functions such as the script's output
    writer (since the framework handles that).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了框架、它的子类和两个主要的写入脚本。那么我们在前几章中对插件脚本所做的修改呢？大部分情况下，它们的核心功能没有变化。我们所做的修改包括删除打印和日志语句，删除`argparse`和日志设置部分，以及删除一些不必要的函数，例如脚本的输出写入器（因为框架已经处理了这个问题）。
- en: Instead of walking through each plugin, we invite you to view the source files
    yourself and compare. You'll see that these files are mostly the same from the
    previous scripts. Keep in mind that when we originally wrote these scripts, we
    had it in the back of our minds that they would eventually be added to a framework.
    While the similarity between the framework and non-framework versions of the scripts
    was intentional, it was necessary to still make modifications to get everything
    working correctly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不逐一讲解每个插件，而是邀请你自己查看源文件并进行对比。你会发现这些文件与前面的脚本大致相同。请记住，当我们最初编写这些脚本时，我们心里已经预想到它们最终会被添加到框架中。虽然框架版本和非框架版本的脚本之间的相似性是故意为之，但仍然需要进行修改才能使一切正常工作。
- en: Executing the framework
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行框架
- en: 'To run the framework, at a minimum, we need to supply an input and output directory.
    Optionally, we can provide arguments for the desired log output path and enable
    XLSX output rather than the default CSV. The first example and the following screenshot
    highlight the minimum arguments to run the framework. The second example shows
    the additional switches we can call with our framework:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行框架，最少需要提供输入和输出目录。可选地，我们还可以提供日志输出路径参数，并启用XLSX输出，而不是默认的CSV输出。第一个示例和随后的截图突出显示了运行框架所需的最小参数。第二个示例展示了我们可以在框架中调用的额外开关：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Upon running the framework, the user will be presented with a variety of output
    text detailing the execution status of the framework:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行框架后，用户将看到各种输出文本，详细说明框架的执行状态：
- en: '![](img/61a8605b-78c2-4f27-b25a-6620e3231008.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61a8605b-78c2-4f27-b25a-6620e3231008.png)'
- en: 'As each plugin successfully processes, a report is generated in the plugin''s
    output folder. We decided to organize the output by storing each plugin report
    in a separate folder to allow the examiner to drill down to their plugin of interest
    easily:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个插件成功处理时，都会在该插件的输出文件夹中生成报告。我们决定通过将每个插件报告存储在单独的文件夹中来组织输出，以便检查人员可以轻松地查看自己感兴趣的插件：
- en: '![](img/6cbccc55-d556-47ca-8de1-5a0d4d095883.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cbccc55-d556-47ca-8de1-5a0d4d095883.png)'
- en: Additional challenges
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加挑战
- en: There are a lot of potential opportunities for improvement with our framework.
    Obviously, we could continue to add more plugins and writers to the framework.
    For example, while we have the beginning of USB device artifacts with the `Setupapi`
    plugin, it could be expanded by parsing various USB pertinent registry keys using
    the `Registry` module from [Chapter 6](59414e87-5820-4942-bd47-aba762dd9f14.xhtml), *Extracting
    Artifacts from Binary Files*. Alternatively, consider adding other scripts we've
    already created. For instance, it might be useful to generate an active file listing
    using the script from [Chapter 5](a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml), *Databases
    in Python*. This would allow us to monitor what files have been processed by the
    framework.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架有很多潜在的改进机会。显然，我们可以继续为框架添加更多插件和写入器。例如，虽然我们通过`Setupapi`插件已经实现了USB设备的基本证据，但可以通过使用[第6章](59414e87-5820-4942-bd47-aba762dd9f14.xhtml)中的`Registry`模块解析各种与USB相关的注册表项来扩展它，*从二进制文件中提取证据*。或者，可以考虑添加我们已经创建的其他脚本。例如，使用[第5章](a4ae250a-8aa8-49b9-8fd6-0cac51975f11.xhtml)中的脚本生成活动文件列表可能会很有用，*Python中的数据库*。这将使我们能够监控框架已处理的文件。
- en: Additionally, adding novel sources of user activity artifacts, such as a prefetch
    parser would enhance the intrinsic value of the framework. The file format for
    prefetch files is described at [http://forensicswiki.org/wiki/Windows_Prefetch_File_Format](http://forensicswiki.org/wiki/Windows_Prefetch_File_Format).
    As with any binary file, we recommend using the struct module to parse the file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加新的用户活动证据源，例如预取解析器，将增强框架的内在价值。预取文件的文件格式可以在[http://forensicswiki.org/wiki/Windows_Prefetch_File_Format](http://forensicswiki.org/wiki/Windows_Prefetch_File_Format)中找到。与任何二进制文件一样，我们建议使用`struct`模块来解析该文件。
- en: Finally, for those looking for a challenge, consider adding `E01` and `dd` support
    by using `libewf` ([https://github.com/libyal/libewf](https://github.com/libyal/libewf))
    or `libtsk` ([https://github.com/py4n6/pytsk](https://github.com/py4n6/pytsk)).
    This would get rid of the need to mount the image file before running the framework
    against it. This would be more of an undertaking and will likely require a rewrite
    of the framework. However, the harder the challenge, the more you'll get out of
    it once complete.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于那些寻求挑战的人，可以考虑通过使用`libewf` ([https://github.com/libyal/libewf](https://github.com/libyal/libewf))
    或 `libtsk` ([https://github.com/py4n6/pytsk](https://github.com/py4n6/pytsk))来添加对`E01`和`dd`的支持。这将无需在运行框架之前挂载镜像文件。这将是一个较为艰巨的任务，可能需要重写框架。然而，挑战越大，完成后你得到的收获也会越多。
- en: An example of this implementation is available in the Python Digital Forensics
    Cookbook by Packt, which is available at [https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook](https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的示例可在Packt出版的《Python数字取证手册》中找到，链接为[https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook](https://www.packtpub.com/networking-and-servers/python-digital-forensics-cookbook)。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This is the final chapter, where we learned how to develop our own forensic
    framework using scripts we've previously built. This is the first step to building
    your very own automated forensic solution, greatly increasing your lunch break,
    or for the more serious, efficiency. We've learned how to balance code complexity
    with efficiency to develop a sustainable framework to help us to answer investigative
    questions. The code for this project can be downloaded from GitHub or Packt, as
    described in the *Preface*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章，我们在这里学习了如何利用之前编写的脚本开发自己的取证框架。这是建立你自己的自动化取证解决方案的第一步，大大提升你的午休时间，或者对于更为严谨的用户，提升效率。我们学会了如何平衡代码复杂性和效率，开发一个可持续的框架来帮助我们回答调查性问题。该项目的代码可以从GitHub或Packt下载，具体内容见*前言*。
- en: At the outset of this book, we wanted to teach investigators the advantages
    of Python by showing increasingly complex scripts. Throughout this process, we've
    introduced common techniques, best practices, and a myriad of first and third-party
    modules. We hope that, at this point, you're comfortable with developing your
    own scripts and understand the fundamentals of Python and are well on your way
    to becoming a forensic developer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本书开头时，我们希望通过展示越来越复杂的脚本来教会调查员Python的优势。在这个过程中，我们介绍了常见的技术、最佳实践以及大量的第一方和第三方模块。我们希望，在这个阶段，你已经能够开发自己的脚本，理解Python的基本知识，并且已经在成为一名取证开发者的道路上迈出了坚实的步伐。
- en: As we close out of this book, we wanted to list a few recommendations. If you
    haven't done so, please attempt to solve the various challenges. Some are fairly
    straightforward while others are more difficult, but in any case, they will help
    you develop your skills further. Additionally, go beyond just following along
    with the code provided with this book. Find a problem or task that's frequently
    encountered and script it from scratch. And, as always, ask friends, use the internet,
    read additional books, and collaborate with others to continue learning. Our capacity
    to learn is only waylaid by our lack of effort to pursue it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这本书时，我们想列出一些建议。如果您还没有这样做，请尝试解决各种挑战。有些问题很简单，而其他一些则更具挑战性，但无论如何，它们都将帮助您进一步发展技能。此外，不要仅仅是跟随本书提供的代码。找到一个经常遇到的问题或任务，并从头开始编写脚本。还有，像往常一样，请朋友帮忙，使用互联网，阅读更多书籍，并与他人合作继续学习。我们学习的能力只会因我们追求学习的努力不足而受到阻碍。
