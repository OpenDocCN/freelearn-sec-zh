- en: The Exploit Formulation Process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用公式化过程
- en: This chapter is all about creating exploit modules and helping to understand
    how inbuilt Metasploit utilities can improve the creation process. In this chapter,
    we will cover various exemplar vulnerabilities, and we will try to develop approaches
    and methods to exploit these vulnerabilities. In addition to that, our primary
    focus will be on building exploit modules for Metasploit. We will also cover a
    wide variety of tools that will aid writing exploits in Metasploit. An essential
    aspect of exploit writing is the computer architecture. If we do not include the
    basics of the architecture, we will not be able to understand how exploits work
    at the lower levels. Therefore, let's first start a discussion about the system
    architecture and the essentials required to write exploits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要是关于创建利用模块，并帮助理解内置的Metasploit实用程序如何改进创建过程。在本章中，我们将涵盖各种示例漏洞，并尝试开发利用这些漏洞的方法和方法。除此之外，我们的主要重点将放在为Metasploit构建利用模块上。我们还将涵盖各种工具，这些工具将有助于在Metasploit中编写利用程序。编写利用程序的一个重要方面是计算机体系结构。如果我们不包括体系结构的基础知识，我们将无法理解利用程序在较低层次上的工作方式。因此，让我们首先讨论一下系统体系结构和编写利用程序所需的基本要素。
- en: 'By the end of this chapter, we will know more about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将更多地了解以下主题：
- en: The stages of exploit development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用程序开发的阶段
- en: The parameters to be considered while writing exploits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写利用程序时需要考虑的参数
- en: How various registers work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种寄存器的工作原理
- en: How to fuzz software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何模糊软件
- en: How to write exploits in the Metasploit framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Metasploit框架中编写利用程序
- en: Bypassing protection mechanisms using Metasploit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Metasploit绕过保护机制
- en: The absolute basics of exploitation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用程序的绝对基础知识
- en: In this section, we will look at the most critical components required for exploitation.
    We will discuss a wide variety of registers supported in different architectures.
    We will also discuss the **Extended Instruction Pointer** (**EIP**) and **Extended
    Stack Pointer** (**ESP**), and their importance in writing exploits. We will also
    look at **No Operation** (**NOP**) and **Jump** (**JMP**) instructions and their
    significance in writing exploits for various software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下利用所需的最关键组件。我们将讨论在不同体系结构中支持的各种寄存器。我们还将讨论**扩展指令指针**（**EIP**）和**扩展堆栈指针**（**ESP**），以及它们在编写利用程序中的重要性。我们还将研究**无操作**（**NOP**）和**跳转**（**JMP**）指令，以及它们在编写各种软件的利用程序中的重要性。
- en: The basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Let's cover the basics that are necessary when learning about exploit writing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解编写利用程序时必要的基础知识。
- en: 'The following terms are based on the hardware, software, and security perspectives
    in exploit development:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下术语基于硬件、软件和安全角度来看待利用程序开发：
- en: '**Register**: This is an area on the processor used to store information. Also,
    the processor leverages registers to handle process execution, memory manipulation,
    API calls, and so on.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器**：这是处理器上用于存储信息的区域。此外，处理器利用寄存器来处理进程执行、内存操作、API调用等。'
- en: '**x86**: This is a family of system architectures that are found mostly on
    Intel-based systems and are generally 32-bit systems, while x64 are 64-bit systems.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x86**：这是一类系统体系结构，主要出现在基于英特尔的系统上，通常是32位系统，而x64是64位系统。'
- en: '**Assembly language**: This is a low-level programming language with simple
    operations. However, reading an assembly code and maintaining it is a tough nut
    to crack.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编语言**：这是一种具有简单操作的低级编程语言。然而，阅读汇编代码并维护它是一件难事。'
- en: '**Buffer**: A buffer is a fixed memory holder in a program, and it stores data
    onto the stack or heap, depending upon the type of memory they hold.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区**：缓冲区是程序中的固定内存持有者，根据它们所持有的内存类型，它们将数据存储到堆栈或堆中。'
- en: '**Debugger**: Debuggers allow step-by-step analysis of executables, including
    stopping, restarting, breaking, and manipulating process memory, registers, stacks,
    and so on. The widely-used debuggers are the Immunity Debugger, GDB, and OllyDbg.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器**：调试器允许对可执行文件进行逐步分析，包括停止、重新启动、中断和操纵进程内存、寄存器、堆栈等。广泛使用的调试器包括Immunity Debugger、GDB和OllyDbg。'
- en: '**Shellcode**: This is the machine language used to execute on the target system.
    Historically, it was used to run a shell process, granting the attacker access
    to the system. So, shellcode is a set of instructions a processor understands.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shellcode**：这是用于在目标系统上执行的机器语言。在历史上，它被用于运行一个shell进程，使攻击者能够访问系统。因此，shellcode是处理器理解的一组指令。'
- en: '**Stack**: This acts as a placeholder for data and uses the **Last-In-First-Out**
    (**LIFO**) method for storage, which means the last inserted data is the first
    to be removed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**：这充当数据的占位符，并使用**后进先出**（**LIFO**）方法进行存储，这意味着最后插入的数据首先被移除。'
- en: '**Heap**: Heap is a memory region primarily used for dynamic allocation. Unlike
    the stack, we can allocate and free and block at any given time.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：堆是主要用于动态分配的内存区域。与堆栈不同，我们可以在任何给定时间分配、释放和阻塞。'
- en: '**Buffer overflow**: This means that there is more data supplied in the buffer
    than its capacity.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**：这意味着提供给缓冲区的数据超过了其容量。'
- en: '**Format string bugs**: These are bugs related to the print statements in context
    with a file or console, which, when given a variable set of data, may disclose
    valuable information regarding the program.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式字符串错误：这些是与文件或控制台中的打印语句相关的错误，当给定一组变量数据时，可能会透露有关程序的有价值的信息。
- en: '**System calls**: These are calls to a system-level method invoked by a program
    under execution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统调用**：这些是由正在执行的程序调用的系统级方法。'
- en: The architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 体系结构
- en: The architecture defines how the various components of a system are organized.
    Let's understand the necessary components first, and then we will dive deep into
    the advanced stages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 体系结构定义了系统各个组件的组织方式。让我们先了解必要的组件，然后我们将深入研究高级阶段。
- en: System organization basics
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统组织基础知识
- en: 'Before we start writing programs and performing other tasks, such as debugging,
    let''s understand how the components are organized in the system with the help
    of the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写程序和执行其他任务，比如调试之前，让我们通过以下图表来了解系统中组件的组织结构：
- en: '![](img/bc9235d5-26d0-472c-a611-2d94613b1920.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc9235d5-26d0-472c-a611-2d94613b1920.png)'
- en: We can see clearly that every primary component in the system is connected using
    the **System bus**. Therefore, every communication that takes place between the
    **CPU**, **Memory**, and **I/O devices** is via the **System bus**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到系统中的每个主要组件都是通过系统总线连接的。因此，CPU、内存和I/O设备之间的所有通信都是通过系统总线进行的。
- en: 'The CPU is the central processing unit in the system, and it is indeed the
    most vital component in the system. So, let''s see how things are organized in
    the CPU by understanding the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CPU是系统中的中央处理单元，确实是系统中最重要的组件。因此，让我们通过以下图表来了解CPU中的组织结构：
- en: '![](img/d2d85356-7201-4345-a86f-af4dd66ef920.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d85356-7201-4345-a86f-af4dd66ef920.png)'
- en: 'The preceding diagram shows the basic structure of a **CPU** with components
    such as **Control Unit** (**CU**), **Execution Unit** (**EU**) **Registers**,
    and **Flags**. Let''s get to know what these components are, as explained in the
    following table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了CPU的基本结构，包括控制单元（CU）、执行单元（EU）、寄存器和标志等组件。让我们通过下表来了解这些组件是什么：
- en: '| **Components** | **Working** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '**组件** | **工作** '
- en: '| Control unit | The control unit is responsible for receiving and decoding
    the instruction and stores data in the memory |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: 控制单元 | 控制单元负责接收和解码指令，并将数据存储在内存中。
- en: '| Execution unit | The execution unit is a place where the actual execution
    takes place |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: 执行单元 | 执行单元是实际执行发生的地方。
- en: '| Registers | Registers are placeholder memory variables that aid the execution
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: 寄存器 | 寄存器是占位内存变量，有助于执行。
- en: '| Flags | These are used to indicate events when the execution is taking place
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: Flags | 这些用于指示执行过程中发生的事件。
- en: Registers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器
- en: 'Registers are high-speed computer memory components. They are also listed on
    the top of the speed chart of the memory hierarchy. We measure a register by the
    number of bits they can hold; for example, an 8-bit register and a 32-bit register
    hold 8 bits and 32 bits of memory, respectively. **General Purpose**, **Segment**,
    **EFLAGS**, and **index registers** are the different types of relevant registers
    we have in the system. They are responsible for performing almost every function
    in the system, as they hold all the values to be processed. Let''s look at their
    types:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是高速计算机内存组件。它们也位于内存层次结构的速度图表的顶部。我们通过它们可以容纳的位数来衡量寄存器；例如，一个8位寄存器和一个32位寄存器分别可以容纳8位和32位的内存。**通用目的**、**段**、**EFLAGS**和**索引寄存器**是系统中不同类型的相关寄存器。它们负责执行系统中几乎每个功能，因为它们保存了所有要处理的值。让我们来看看它们的类型：
- en: '| **Registers** | **Purpose** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '**寄存器** | **目的** '
- en: '| EAX | This is an accumulator and used to store data and operands. It is 32
    bits in size. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: EAX | 这是一个累加器，用于存储数据和操作数。大小为32位。
- en: '| EBX | This is the base register and a pointer to the data. It is 32 bits
    in size. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: EBX | 这是基址寄存器，指向数据的指针。大小为32位。
- en: '| ECX | This is a counter, and it is used for looping purposes. It is 32 bits
    in size. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: ECX | 这是一个计数器，用于循环目的。大小为32位。
- en: '| EDX | This is a data register and stores the I/O pointer. It is 32 bits in
    size. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: EDX | 这是一个数据寄存器，存储I/O指针。大小为32位。
- en: '| ESI/EDI | These are index registers that serve as data pointers for memory
    operations. They are also 32 bits in size. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: ESI/EDI | 这些是用作内存操作数据指针的索引寄存器。它们也是32位大小。
- en: '| ESP | This register points to the top of the stack, and its value is changed
    when an item is either pushed or popped from the stack. It is 32 bits in size.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: ESP | 这个寄存器指向栈顶，当栈中有数据被推入或弹出时，它的值会发生变化。大小为32位。
- en: '| EBP | This is the stack data pointer register and is 32 bits in size. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: EBP | 这是堆栈数据指针寄存器，大小为32位。
- en: '| EIP | This is the instruction pointer, which is 32 bits in size, and is the
    most crucial pointer in this chapter. It also holds the address of the next instruction
    to be executed. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: EIP | 这是指令指针，大小为32位，在本章中是最关键的指针。它还保存着下一条要执行的指令的地址。
- en: '| SS, DSES, CS, FS, and GS | These are the segment registers. They are 16 bits
    in size. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: SS、DSES、CS、FS和GS | 这些是段寄存器，大小为16位。
- en: You can read more about the basics of the architecture and the uses of various
    system calls and instructions for exploitation at: [http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址了解有关架构基础知识和各种系统调用和利用指令的更多信息：[http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86)。
- en: Exploiting stack-based buffer overflows with Metasploit
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit利用基于栈的缓冲区溢出
- en: 'The buffer overflow vulnerability is an anomaly, where, while writing data
    to the buffer, it overruns the buffer size and overwrites the memory addresses.
    An elementary example of a buffer overflow is shown in the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出漏洞是一种异常情况，当向缓冲区写入数据时，它超出了缓冲区的大小并覆盖了内存地址。以下图表显示了缓冲区溢出的一个基本示例：
- en: '![](img/8d93ff26-46d3-446d-b98f-0f845634725c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d93ff26-46d3-446d-b98f-0f845634725c.png)'
- en: The left side of the preceding diagram shows what an application looks like.
    However, the right side denotes the application's behavior when a buffer overflow
    condition is met.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表的左侧显示了应用程序的外观。然而，右侧表示了应用程序在满足缓冲区溢出条件时的行为。
- en: So, how can we take advantage of buffer overflow vulnerability? The answer is
    straightforward. If we know the exact amount of data that will overwrite everything
    just before the start of the EIP (Instruction Pointer), we can put anything in
    the EIP and control the address of the next instruction to be processed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何利用缓冲区溢出漏洞呢？答案很简单。如果我们知道将覆盖EIP（指令指针）开始之前的一切的确切数据量，我们可以将任何内容放入EIP并控制下一条指令的地址。
- en: Therefore, the first thing is to figure out an exact number of bytes that are
    good enough to fill everything before the start of the EIP. We will see in the
    upcoming sections how we can find the exact number of bytes using Metasploit utilities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先要找出足够好的字节数，以填充EIP开始之前的所有内容。在接下来的部分中，我们将看到如何使用Metasploit实用程序找到确切的字节数。
- en: Crashing the vulnerable application
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 崩溃易受攻击的应用程序
- en: 'We will use a custom-made vulnerable application that uses unsafe functions.
    Let''s try running the application from the command shell, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个使用不安全函数的自定义易受攻击的应用程序。让我们尝试从命令shell中运行该应用程序，如下所示：
- en: '![](img/f0567bb0-648f-46f5-aeac-807ee2a49771.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0567bb0-648f-46f5-aeac-807ee2a49771.png)'
- en: 'We can see that this is a small example application, which listens on TCP port
    `200`. We will connect to this application via Telnet on port `200` and supply
    random data to it, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是一个小型示例应用程序，它监听TCP端口`200`。我们将通过Telnet连接到该应用程序的端口`200`并向其提供随机数据，如下面的屏幕截图所示：
- en: '![](img/e0087caa-4393-4a14-9ba4-16fb025e7d5f.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0087caa-4393-4a14-9ba4-16fb025e7d5f.png)'
- en: 'After we provide the data, we will see that the connection to the target is
    lost. This is because the application server has crashed. Let''s see what it looks
    like on the target''s system:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供数据之后，我们会看到与目标的连接丢失。这是因为应用程序服务器崩溃了。让我们看看目标系统上的情况：
- en: '![](img/a50dc75e-760d-4511-a698-519e918086c4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a50dc75e-760d-4511-a698-519e918086c4.png)'
- en: 'On investigating the error report by clicking click here, we can see the following
    information:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击此处查看错误报告，我们可以看到以下信息：
- en: '![](img/dbaf1619-08ff-4ff7-8788-417dc810fcd9.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbaf1619-08ff-4ff7-8788-417dc810fcd9.png)'
- en: The cause of the crash was that the application failed to process the address
    of the next instruction, located at 41414141\. Does this ring any bells? The value
    41 is the hexadecimal representation of character A. What happened is that our
    input, extending through the boundary of the buffer, went on to overwrite the
    EIP register. Therefore, since the address of the next instruction was overwritten,
    the program tried finding the address of the next instruction at 41414141, which
    was not a valid address. Hence, it crashed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃的原因是应用程序未能处理下一条指令的地址，位于41414141。这有什么提示吗？值41是字符A的十六进制表示。发生的情况是我们的输入越过了缓冲区的边界，继续覆盖了EIP寄存器。因此，由于下一条指令的地址被覆盖，程序尝试在41414141处找到下一条指令的地址，这不是有效地址。因此，它崩溃了。
- en: Download the example application we used in the example from: [http://redstack.net/blog/category/How%20To.html](http://redstack.net/blog/category/How%20To.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下网址下载我们在示例中使用的示例应用程序：[http://redstack.net/blog/category/How%20To.html](http://redstack.net/blog/category/How%20To.html)。
- en: Building the exploit base
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建利用基础
- en: 'To exploit the app and gain access to the target system, we need to know about
    the things listed in the following table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用该应用程序并访问目标系统，我们需要了解以下表中列出的内容：
- en: '| **Component** | **Use** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **用途** |'
- en: '| Offset | We crashed the application in the previous section. However, to
    exploit the application, we will need the exact size of the input that is good
    enough to fill the space + the EBP register, so that whatever we provide after
    our input goes directly into the EIP register. We refer to the amount of data
    that is good enough to land us right before the EIP register as the offset. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: 在上一节中，我们崩溃了应用程序。然而，为了利用该应用程序，我们需要知道足够填充空间和EBP寄存器的输入的确切大小，这样我们提供的任何内容都会直接进入EIP寄存器。我们将足够好以使我们正好在EIP寄存器之前的数据量称为偏移量。
- en: '| Jump address/Ret | This is the actual address to overwrite in the EIP register.
    To clarify, this is the address of a JMP ESP instruction from a DLL file that
    helps to jump to the payload. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 跳转地址/Ret | 这是要在EIP寄存器中覆盖的实际地址。澄清一下，这是来自DLL文件的JMP ESP指令的地址，它有助于跳转到有效负载。'
- en: '| Bad characters | Bad characters are those that can lead to the termination
    of a payload. Suppose a shellcode containing null bytes (0x00) is sent over the
    network. It will terminate the buffer prematurely, causing unexpected results.
    Bad characters should be avoided. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 坏字符 | 坏字符是可能导致有效负载终止的字符。假设包含空字节（0x00）的shellcode被发送到网络上。它将过早终止缓冲区，导致意外结果。应避免使用坏字符。'
- en: 'Let''s understand the exploitation part of this application with the help of
    the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表来了解该应用程序的利用部分：
- en: '![](img/598f5a96-1a5f-4d6b-8cc5-33002b0f9466.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/598f5a96-1a5f-4d6b-8cc5-33002b0f9466.png)'
- en: 'Looking at the preceding diagram, we have to perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的图表，我们必须执行以下步骤：
- en: Overwrite the buffer and EBP register with the user input just before the start
    of the EIP register. The value that's good enough will be the offset value.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用用户输入覆盖缓冲区和EBP寄存器，就在EIP寄存器开始之前。足够好的值将是偏移值。
- en: Overwrite the ESP with the JMP ESP address from the relevant DLL.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用相关DLL中的JMP ESP地址覆盖ESP。
- en: Supply some padding before the payload to remove irregularities.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有效负载之前提供一些填充以消除不规则性。
- en: Finally, supply the shellcode to be executed.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提供要执行的shellcode。
- en: In the upcoming section, we will look at all these steps in detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将详细介绍所有这些步骤。
- en: Calculating the offset
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算偏移量
- en: As we saw in the preceding section, the first step in exploitation is to find
    out the offset. Metasploit aids this process by using two different tools, called
    `pattern_create` and `pattern_offset`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，利用的第一步是找出偏移量。Metasploit通过使用两个不同的工具`pattern_create`和`pattern_offset`来辅助这个过程。
- en: Using the pattern_create tool
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pattern_create工具
- en: 'We saw in the previous section that we were able to crash the application by
    supplying a random amount of `A` characters. However, we''ve learned that to build
    a working exploit, we need to figure out the exact number of these characters.
    Metasploit''s inbuilt tool, `pattern_create`, does this for us in no time. It
    generates patterns that can be supplied instead of `A` characters and, based on
    the value which overwrote the EIP register, we can quickly figure out the exact
    number of bytes using its counterpart tool, `pattern_offset`. Let''s see how we
    can do that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们发现通过提供随机数量的`A`字符，我们能够使应用程序崩溃。然而，我们已经学到，要构建一个有效的利用程序，我们需要找出这些字符的确切数量。Metasploit内置的工具`pattern_create`可以在短时间内为我们完成这项工作。它生成的模式可以供应用程序使用，而不是`A`字符，并且根据覆盖EIP寄存器的值，我们可以使用其对应的工具`pattern_offset`快速找出确切的字节数。让我们看看如何做到这一点：
- en: '![](img/c8e0706f-008d-491f-ae8b-1b3502f68cc4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8e0706f-008d-491f-ae8b-1b3502f68cc4.png)'
- en: 'We can see that running the `pattern_create.rb` script from the `/tools/exploit/`
    directory for a pattern of 1,000 bytes will generate the preceding output. This
    output can be fed to the vulnerable application, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`/tools/exploit/`目录中运行`pattern_create.rb`脚本生成了1000字节的模式。这个输出可以提供给有漏洞的应用程序，如下所示：
- en: '![](img/fdc96fa9-7533-49ea-84d4-52c26de6ad52.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdc96fa9-7533-49ea-84d4-52c26de6ad52.png)'
- en: 'Looking at the target''s endpoint, we can see the offset value, as shown in
    the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看目标端点，我们可以看到偏移值，如下截图所示：
- en: '![](img/0cb70ce2-876e-416b-a126-8b4b4a78be52.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cb70ce2-876e-416b-a126-8b4b4a78be52.png)'
- en: We have 72413372 as the address that overwrote the EIP register.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有72413372作为覆盖EIP寄存器的地址。
- en: Using the pattern_offset tool
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pattern_offset工具
- en: 'In the preceding section, we overwrote the EIP address with 72413372\. Let''s
    figure out the exact number of bytes required to overwrite the EIP with the `pattern_offset`
    tool. This tool takes two arguments; the first one is the address and the second
    one is the length, which was `1000`, as generated using `pattern_create`. Let''s
    find out the offset, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们用72413372覆盖了EIP地址。让我们使用`pattern_offset`工具找出覆盖EIP所需的确切字节数。这个工具需要两个参数；第一个是地址，第二个是长度，使用`pattern_create`生成的长度为`1000`。让我们找出偏移量，如下所示：
- en: '![](img/6b37cb6a-cc58-4840-a757-2b77a1283c02.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b37cb6a-cc58-4840-a757-2b77a1283c02.png)'
- en: The exact match is found to be at 520\. Therefore, any 4 bytes after 520 characters
    becomes the contents of the EIP register.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确切匹配在520处找到。因此，在520个字符后的任何4个字节都成为EIP寄存器的内容。
- en: Finding the JMP ESP address
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找JMP ESP地址
- en: 'Let''s review the diagram we used to understand the exploitation again, as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看我们用来理解利用的图表，如下所示：
- en: '![](img/240fc9e7-88f7-4b82-8d0c-145b0168ce87.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/240fc9e7-88f7-4b82-8d0c-145b0168ce87.png)'
- en: We completed the first step in the preceding diagram. Our next task is to find
    the JMP ESP address. We require the address of a JMP ESP instruction because our
    payload will be loaded to the ESP register and we cannot merely point to the payload
    after overwriting the buffer. Hence, we will require the address of a JMP ESP
    instruction from an external DLL, which will ask the program to make a jump to
    the content of the ESP that is at the start of our payload.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了前面图表中的第一步。我们的下一个任务是找到JMP ESP地址。我们需要JMP ESP指令的地址，因为我们的有效载荷将加载到ESP寄存器中，我们不能仅仅在覆盖缓冲区后指向有效载荷。因此，我们需要来自外部DLL的JMP
    ESP指令的地址，该指令将要求程序跳转到我们有效载荷开头处的ESP内容。
- en: To find the jump address, we will require a debugger so that we can see which
    DLL files are loaded with the vulnerable application. The best choice, in my opinion,
    is the Immunity Debugger. The Immunity Debugger comes with a ton of plugins that
    aid exploit writing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到跳转地址，我们将需要一个调试器，以便我们可以看到有漏洞的应用程序加载了哪些DLL文件。在我看来，最好的选择是Immunity Debugger。Immunity
    Debugger带有大量插件，可以帮助编写利用程序。
- en: Using the Immunity Debugger to find executable modules
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Immunity Debugger查找可执行模块
- en: The Immunity Debugger is an application that helps us find out the behavior
    of an application at runtime. It also helps us to identify flaws, the value of
    registers, reverse engineer the application, and so on. Analyzing the application
    in the Immunity Debugger will not only help us understand the values contained
    in the various registers better, but will also tell us about a variety of information
    about the target application, such as the instruction where the crash took place
    and the executable modules linked to an executable file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Immunity Debugger是一个帮助我们在运行时了解应用程序行为的应用程序。它还可以帮助我们识别缺陷、寄存器的值、反向工程应用程序等。在Immunity
    Debugger中分析应用程序不仅有助于我们更好地理解各种寄存器中包含的值，还会告诉我们有关目标应用程序的各种信息，比如崩溃发生的指令和与可执行文件链接的可执行模块。
- en: 'An executable can be loaded into the Immunity Debugger directly by selecting
    Open from the File menu. We can also attach a running app by attaching its process
    to the Immunity Debugger by choosing the Attach option from the File menu. When
    we navigate to File | Attach, it will present us with the list of running processes
    on the target system. We just need to select the appropriate process. However,
    a significant point here is that when a process attaches to the Immunity Debugger,
    by default, it lands in a paused state. Therefore, make sure you press the Play
    button to change the state of the process from the paused to the running state.
    Let''s visualize how we can attach a process to the Immunity Debugger:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从文件菜单中选择“打开”直接将可执行文件加载到Immunity Debugger中。我们也可以通过选择“附加”选项将正在运行的应用程序附加到Immunity
    Debugger中。当我们导航到文件|附加时，它会向我们呈现目标系统上正在运行的进程列表。我们只需要选择适当的进程。然而，这里有一个重要的问题，当一个进程附加到Immunity
    Debugger时，默认情况下，它会处于暂停状态。因此，请确保按下播放按钮，将进程的状态从暂停状态更改为运行状态。让我们看看如何将进程附加到Immunity
    Debugger：
- en: '![](img/83c1ae4f-49e1-43b4-8cf6-55da312fbf12.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83c1ae4f-49e1-43b4-8cf6-55da312fbf12.png)'
- en: 'After pressing the Attach button, let''s see which DLL files are loaded with
    the vulnerable application by navigating to View and selecting the Executable
    modules option. We will be presented with the following list of DLL files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按下附加按钮后，让我们看看哪些DLL文件加载到有漏洞的应用程序中，方法是导航到“查看”并选择“可执行模块”选项。我们将看到以下DLL文件列表：
- en: '![](img/2455a72c-d8d8-4834-a8fe-6c0df10f7e60.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2455a72c-d8d8-4834-a8fe-6c0df10f7e60.png)'
- en: Now that we have the list of DLL files, we need to find the JMP ESP address
    from one of them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了DLL文件的列表，我们需要从其中一个文件中找到JMP ESP地址。
- en: Using msfpescan
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msfpescan
- en: In the previous section, we found the DLL modules associated with the vulnerable
    application. Either we can use the Immunity Debugger to find the address of the
    JMP ESP instructions, which is a lengthy and time-consuming process, or we can
    use `msfpescan` to search the addresses for the JMP ESP instructions from a DLL
    file, which is a much faster process and eliminates manual searching.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们找到了与有漏洞的应用程序相关联的DLL模块。我们可以使用Immunity Debugger来查找JMP ESP指令的地址，这是一个冗长而耗时的过程，或者我们可以使用`msfpescan`从DLL文件中搜索JMP
    ESP指令的地址，这是一个更快的过程，消除了手动搜索的步骤。
- en: 'Running `msfpescan` gives us the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`msfpescan`给我们以下输出：
- en: '![](img/639fd66e-cae6-4834-b35e-6907671bc9cd.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/639fd66e-cae6-4834-b35e-6907671bc9cd.png)'
- en: Utilities such as `msfbinscan `and `msfrop` may not be present in the default
    Metasploit installation that is shipped with Kali Linux. Switch to Ubuntu and
    install Metasploit manually to obtain these utilities.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`msfbinscan`和`msfrop`之类的实用程序可能不会出现在默认的Kali Linux中随Metasploit一起安装的版本中。切换到Ubuntu并手动安装Metasploit以获取这些实用程序。
- en: 'We can perform a variety of tasks such as finding the POP-POP-RET instruction
    addresses for SEH-based buffer overflows, displaying the code at a particular
    address, and much more with `msfpescan`. We just need to find the address of the
    JMP ESP instruction. We can achieve this by using the `-j` switch, followed by
    the register name, which is ESP. Let''s begin the search on the `ws2_32.dll` file
    to find the JMP ESP address:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行各种任务，比如找到基于SEH的缓冲区溢出的POP-POP-RET指令地址，显示特定地址处的代码等等，都可以通过`msfpescan`来完成。我们只需要找到JMP
    ESP指令的地址。我们可以使用`-j`开关，后面跟着寄存器名称ESP来实现这一点。让我们从`ws2_32.dll`文件开始搜索JMP ESP地址：
- en: '![](img/b26e3564-30b2-4b31-8912-04fc3352baa8.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b26e3564-30b2-4b31-8912-04fc3352baa8.png)'
- en: The result of the command returned `0x71ab9372`. This is the address of the
    JMP ESP instruction in the `ws2_32.dll` file. We just need to overwrite the EIP
    register with this address to make a jump of execution to the shellcode that resides
    in the ESP register.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果返回了`0x71ab9372`。这是`ws2_32.dll`文件中JMP ESP指令的地址。我们只需要用这个地址覆盖EIP寄存器，以便执行跳转到ESP寄存器中的shellcode。
- en: Stuffing the space
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充空间
- en: 'Let''s revise the exploitation diagram and understand where exactly we lie
    in the exploitation process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改利用图并了解我们在利用过程中的确切位置：
- en: '![](img/34cc8528-2fa8-4f2f-a270-0d14fecf206d.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34cc8528-2fa8-4f2f-a270-0d14fecf206d.png)'
- en: We have completed the second step. However, a significant point here is that
    sometimes the first few bytes of the shellcode may get stripped off due to irregularities,
    and the shellcode may not get executed. In such situations, we shall pad the shellcode
    with prefixed NOPs so that the execution of the shellcode can take place flawlessly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第二步。然而，这里有一个重要的问题，有时shellcode的前几个字节可能会被剥离，导致shellcode无法执行。在这种情况下，我们应该用前缀NOP填充shellcode，以便shellcode的执行可以无缝进行。
- en: Suppose we send `ABCDEF` to the ESP, but when we analyze it using the Immunity
    Debugger, we get the contents as `DEF` only. In this case, we have three missing
    characters. Therefore, we shall pad the payload with three NOP bytes or other
    random data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`ABCDEF`发送到ESP，但是当我们使用Immunity Debugger进行分析时，我们只得到了`DEF`的内容。在这种情况下，我们缺少了三个字符。因此，我们需要用三个NOP字节或其他随机数据填充有效负载。
- en: 'Let''s see if we need to pad the shellcode for this vulnerable application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否需要为这个有漏洞的应用程序填充shellcode：
- en: '![](img/a0b9fe00-925e-4eb7-8284-38bee07a7a7b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0b9fe00-925e-4eb7-8284-38bee07a7a7b.png)'
- en: 'In the preceding screenshot, we created data based on the values we have for
    the buffer size. We know that the offset is `520`. Therefore, we supplied `520`
    followed by the JMP ESP address in little-endian format, which is accompanied
    by random text; that is, `ABCDEF`. Once we send this data, we analyze the ESP
    register in the Immunity Debugger, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们根据缓冲区大小的值创建了数据。我们知道偏移量是`520`。因此，我们提供了`520`，然后是JMP ESP地址，以小端格式呈现，随后是随机文本`ABCDEF`。一旦我们发送了这些数据，我们就可以在Immunity
    Debugger中分析ESP寄存器，如下所示：
- en: '![](img/788e7c69-e7f1-4db2-ba1c-6f2611b9a263.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/788e7c69-e7f1-4db2-ba1c-6f2611b9a263.png)'
- en: We can see that the letter `A` from the random text `ABCDEF` is missing. Hence,
    we just need a single byte padding to achieve alignment. It is an excellent practice
    to pad the space before shellcode with a few extra NOPs to avoid issues with shellcode
    decoding and irregularities.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到随机文本`ABCDEF`中缺少了字母`A`。因此，我们只需要一个字节的填充来实现对齐。在shellcode之前用一些额外的NOP进行填充是一个很好的做法，以避免shellcode解码和不规则性问题。
- en: Relevance of NOPs
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NOP的相关性
- en: NOPs or NOP-sled are No Operation instructions that merely slide the program
    execution to the next memory address. We use NOPs to reach the desired place in
    the memory addresses. We supply NOPs commonly before the start of the shellcode
    to ensure its successful execution in the memory while performing no operations
    and just sliding through the memory addresses. The `\x90` instruction represents
    a NOP instruction in the hexadecimal format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: NOP或NOP-sled是无操作指令，仅仅将程序执行滑动到下一个内存地址。我们使用NOP来到达内存地址中的所需位置。我们通常在shellcode开始之前提供NOP，以确保在内存中成功执行，同时不执行任何操作，只是在内存地址中滑动。十六进制格式中的`\x90`指令代表NOP指令。
- en: Determining bad characters
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定坏字符
- en: Sometimes it may happen that after setting up everything correctly for exploitation,
    we may never get to exploit the system. Alternatively, it might happen that our
    exploit executed successfully, but the payload fails to run. This can happen in
    cases where the data supplied in the exploit is either truncated or improperly
    parsed by the target system, causing unexpected behavior. This will make the entire
    exploit unusable, and we will struggle to get the shell or Meterpreter onto the
    system. In this case, we need to determine the bad characters that are preventing
    the execution. We can avoid such situations by finding matching similar exploit
    modules and use the bad characters from them in our exploit module.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使为利用正确设置了一切，我们可能永远无法利用系统。或者，可能会发生我们的利用成功执行，但有效载荷无法运行的情况。这可能发生在目标系统对利用中提供的数据进行截断或不正确解析，导致意外行为的情况下。这将使整个利用无法使用，我们将努力将shell或Meterpreter放入系统中。在这种情况下，我们需要确定阻止执行的坏字符。我们可以通过查找匹配的类似利用模块并在我们的利用模块中使用这些坏字符来避免这种情况。
- en: 'We need to define these bad characters in the `Payload` section of the exploit.
    Let''s see an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在利用的`Payload`部分定义这些坏字符。让我们看一个例子：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding section is taken from the `freeftpd_user.rb` file under `/exploit/windows/ftp`.
    The options listed suggests that the space of the payload should be less than
    `800` bytes and the payload should avoid using `0x00`, `0x20`, `0x0a`, and `0x0d`,
    which are null byte, space, line feed, and carriage return, respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述部分摘自`/exploit/windows/ftp`目录下的`freeftpd_user.rb`文件。列出的选项表明有效载荷的空间应小于`800`字节，并且有效载荷应避免使用`0x00`、`0x20`、`0x0a`和`0x0d`，分别是空字节、空格、换行和回车。
- en: More information on finding bad characters can be found at: [http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/](http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有关查找坏字符的更多信息，请访问：[http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/](http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/)。
- en: Determining space limitations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定空间限制
- en: The `Space` variable in the `Payload field` defines the total size reserved
    for the shellcode. We need to assign enough space for the `Payload` to fit in.
    If the `Payload` is large and the space allocated is less than the shellcode of
    the payload, it will not execute. Also, while writing custom exploits, the shellcode
    should be as small as possible. We may have a situation where the available space
    is only for 200 bytes, but the available shellcode needs at least 800 bytes of
    space. In this situation, we can fit a small first stage shellcode within the
    buffer, which will execute and download the second, larger stage to complete the
    exploitation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Payload字段`中的`Space`变量定义了用于shellcode的总大小。我们需要为`Payload`分配足够的空间。如果`Payload`很大，而分配的空间小于有效载荷的shellcode，它将无法执行。此外，在编写自定义利用时，shellcode应尽可能小。我们可能会遇到这样的情况，即可用空间仅为200字节，但可用shellcode至少需要800字节的空间。在这种情况下，我们可以将一个较小的第一阶段shellcode放入缓冲区中，它将执行并下载第二个更大的阶段以完成利用。'
- en: For smaller shellcode for various payloads, visit: [http://shell-storm.org/shellcode/](http://shell-storm.org/shellcode/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种有效载荷的较小shellcode，请访问：[http://shell-storm.org/shellcode/](http://shell-storm.org/shellcode/)。
- en: Writing the Metasploit exploit module
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Metasploit利用模块
- en: 'Let''s review our exploitation process diagram and check if we are good to
    finalize the module or not:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的利用过程图表，并检查我们是否可以完成模块：
- en: '![](img/b076501b-a46d-4a63-91ea-1e5a96a8bf9a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b076501b-a46d-4a63-91ea-1e5a96a8bf9a.png)'
- en: 'We can see that we have all the essentials for developing the Metasploit module.
    This is because the payload generation is automated in Metasploit and can be changed
    on the fly as well. So, let''s get started:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们拥有开发Metasploit模块的所有基本要素。这是因为在Metasploit中，有效载荷生成是自动化的，并且也可以随时更改。所以，让我们开始吧：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before starting with the code, let''s have a look at the libraries we used
    in this module:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，让我们看一下我们在这个模块中使用的库：
- en: '| **Include statement** | **Path** | **Usage** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **包含语句** | **路径** | **用途** |'
- en: '| `Msf::Exploit::Remote::Tcp` | `/lib/msf/core/exploit/tcp.rb` | The TCP library
    file provides basic TCP functions, such as connect, disconnect, write data, and
    so on |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `Msf::Exploit::Remote::Tcp` | `/lib/msf/core/exploit/tcp.rb` | TCP库文件提供基本的TCP功能，如连接、断开连接、写入数据等'
- en: 'In the same way as we built modules in [Chapter 12](32de9df6-2753-4075-8f9c-cbf119522ded.xhtml),
    *Reinventing Metasploit*, the exploit modules begin by including the necessary
    library paths and then including the required files from those paths. We define
    the type of module to be `Msf::Exploit::Remote`, meaning a remote exploit. Next,
    we have the `initialize` constructor method, in which we define the name, description,
    author information, and so on. However, we can see plenty of new declarations
    in the `initialize` method. Let''s see what they are:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第12章](32de9df6-2753-4075-8f9c-cbf119522ded.xhtml)中构建模块的方式相同，*重新发明Metasploit*，利用模块首先包括必要的库路径，然后包括来自这些路径的所需文件。我们将模块类型定义为`Msf::Exploit::Remote`，表示远程利用。接下来，我们有`initialize`构造方法，在其中定义了名称、描述、作者信息等。然而，我们可以看到`initialize`方法中有大量新的声明。让我们看看它们是什么：
- en: '| **Declaration** | **Value** | **Usage** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '**声明** | **值** | **用法**'
- en: '| `Platform` | `win` | Defines the type of platform the exploit is going to
    target. The value win denotes that the exploit will be usable on Windows-based
    operating systems. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`平台` | `win` | 定义了利用将要针对的平台类型。win表示利用将可用于基于Windows的操作系统。'
- en: '| `disclosure date` | `Mar 04 2018` | The date of disclosure of the vulnerability.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`披露日期` | `2018年3月4日` | 漏洞披露的日期。'
- en: '| `Targets` | `Ret` | The `Ret` field for a particular OS defines the JMP ESP
    address we found in the previous section. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`目标` | `Ret` | 特定操作系统的`Ret`字段定义了我们在前一节中找到的JMP ESP地址。'
- en: '| `0x71AB9372` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`0x71AB9372`'
- en: '| `Targets` | `Offset` | The `Offset` field for a particular OS defines the
    number of bytes required to fill the buffer just before overwriting the EIP. We
    found this value in the previous section. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`目标` | `Offset` | 特定操作系统的`Offset`字段定义了在覆盖EIP之前填充缓冲区所需的字节数。我们在前一节中找到了这个值。'
- en: '| `520` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`520`'
- en: '| `Payload` | `space` | The `space` variable in the payload declaration defines
    the amount of maximum space the payload can use. This is relatively important
    since sometimes we have insufficient space to load our shellcode. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`有效载荷` | `空间` | 在有效载荷声明中，`空间`变量定义了有效载荷可以使用的最大空间量。这相对重要，因为有时我们的空间不足以加载我们的shellcode。'
- en: '| `1000` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`1000`'
- en: '| `Payload` | `BadChars` | The `BadChars` variable in the payload declaration
    defines the bad characters to avoid in the payload generation process. The practice
    of declaring bad characters will ensure stability and removal of bytes that may
    cause the application to crash or no execution of the payload to take place. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '`有效载荷` | `BadChars` | 在有效载荷声明中，`BadChars`变量定义了在有效载荷生成过程中要避免的不良字符。声明不良字符的做法将确保稳定性，并删除可能导致应用程序崩溃或无法执行有效载荷的字节。'
- en: '| `\x00\xff` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '`\x00\xff`'
- en: 'We also define the default port for the exploit module as `200` in the `register_options`
    section. Let''s have a look at the remaining code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`register_options`部分将利用模块的默认端口定义为`200`。让我们来看看剩下的代码：
- en: '[PRE2]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s understand some of the important functions used in the preceding code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些在前面的代码中使用的重要函数：
- en: '| **Function** | **Library** | **Usage** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '**函数** | **库** | **用法**'
- en: '| `make_nops` | `/lib/msf/core/exploit.rb` | This method is used to create
    `n` number of NOPs by passing `n` as the count |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`make_nops` | `/lib/msf/core/exploit.rb` | 此方法用于通过传递`n`作为计数来创建`n`个NOP'
- en: '| `Connect` | `/lib/msf/core/exploit/tcp.rb` | This method is called to make
    a connection to the target |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '`连接` | `/lib/msf/core/exploit/tcp.rb` | 调用此方法来与目标建立连接'
- en: '| `disconnect` | `/lib/msf/core/exploit/tcp.rb` | This method is called to
    disconnect an existing connection to the target |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`断开连接` | `/lib/msf/core/exploit/tcp.rb` | 调用此方法来断开与目标的现有连接'
- en: '| `handler` | `/lib/msf/core/exploit.rb` | This passes the connection to the
    associated payload handler to check if the exploit succeeded and a connection
    is established |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`处理程序` | `/lib/msf/core/exploit.rb` | 将连接传递给相关的有效载荷处理程序，以检查是否成功利用了漏洞并建立了连接'
- en: We saw in the previous section that the `run` method is used as the default
    method for auxiliary modules. However, for the exploits, the `exploit` method
    is considered the default main method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中看到，`run`方法被用作辅助模块的默认方法。然而，对于利用，`exploit`方法被认为是默认的主要方法。
- en: We begin by connecting to the target using `connect`. Using the `make_nops`
    function, we created 520 NOPs by passing the `Offset` field of the `target` declaration
    that we defined in the `initialize` section. We stored these 520 NOPs in the `buf`
    variable. In the next instruction, we appended the JMP ESP address to `buf` by
    fetching its value from the `Ret` field of the `target` declaration. Using `pack('V')`,
    we get the little endian format for the address. Along with the `Ret` address,
    we append a few NOPs to serve as padding before the shellcode. One of the advantages
    of using Metasploit is being able to switch the payload on the fly. Therefore,
    simply appending the payload using `payload.encoded` will add the currently selected
    payload to the `buf` variable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`connect`连接到目标。使用`make_nops`函数，我们通过传递我们在`initialize`部分中定义的`target`声明的`Offset`字段，创建了520个NOP。我们将这520个NOP存储在`buf`变量中。在下一条指令中，我们通过从`target`声明的`Ret`字段中获取其值，将JMP
    ESP地址附加到`buf`中。使用`pack('V')`，我们得到了地址的小端格式。除了`Ret`地址，我们还附加了一些NOP作为shellcode之前的填充。使用Metasploit的一个优点是能够在运行时切换有效载荷。因此，简单地使用`payload.encoded`附加有效载荷将当前选择的有效载荷添加到`buf`变量中。
- en: 'Next, we directly send the value of `buf` to the connected target using `sock.put`.
    We run the handler method to check if the target was exploited successfully and
    if a connection was established to it or not. Finally, we just disconnect from
    the target using `disconnect`. Let''s see if we can exploit the service or not:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们直接使用`sock.put`将`buf`的值发送到连接的目标。我们运行处理程序方法来检查目标是否成功被利用，以及是否与其建立了连接。最后，我们使用`disconnect`从目标断开连接。让我们看看我们是否能够利用服务：
- en: '![](img/af70490a-44be-467f-8139-b0928c768820.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af70490a-44be-467f-8139-b0928c768820.png)'
- en: 'We set the required options and payload as `windows/meterpreter/bind_tcp`,
    which denotes a direct connection to the target. We can see that, initially, our
    exploit completed, but no session was created. At this point, we change bad characters
    from `\x00\xff` to `\x00\x0a\x0d\x20` by editing the exploit code, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置所需的选项和有效载荷为`windows/meterpreter/bind_tcp`，表示直接连接到目标。最初，我们可以看到我们的利用完成了，但没有创建会话。在这一点上，我们通过编辑利用代码将坏字符从`\x00\xff`更改为`\x00\x0a\x0d\x20`，如下所示：
- en: '![](img/4dc4b10e-30bb-4d09-ae86-622b70595b79.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dc4b10e-30bb-4d09-ae86-622b70595b79.png)'
- en: We can modify a module directly from Metasploit using the `edit` command. By
    default, the file will load in the VI editor. However, if you are no better than
    me, you will stick to the nano editor and make the changes. Once we change the
    module, it has to be reloaded to Metasploit. For the module we are currently working
    with, we can reload it using the `reload` command, as shown in the previous image.
    Rerunning the module, we got Meterpreter access to the target with ease. Now that
    we've completed the first exploit module successfully, we will jump into a slightly
    more advanced exploit module in the next example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`edit`命令直接从Metasploit修改模块。默认情况下，文件将在VI编辑器中加载。但是，如果你不比我更好，你会坚持使用nano编辑器进行更改。一旦我们更改了模块，就必须重新加载到Metasploit中。对于我们当前正在使用的模块，我们可以使用`reload`命令重新加载，如前面的图像所示。重新运行模块，我们轻松地获得了对目标的Meterpreter访问。现在我们已经成功完成了第一个利用模块，我们将在下一个示例中跳转到一个稍微更高级的利用模块。
- en: Exploiting SEH-based buffer overflows with Metasploit
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit利用基于SEH的缓冲区溢出
- en: 'Exception handlers are code modules that catch exceptions and errors generated
    during the execution of the program. This allows the program to continue execution
    instead of crashing. Windows operating systems have default exception handlers,
    and we see them generally when an application crashes and throws a pop-up that
    says *XYZ program has encountered an error and needed to close*. When the program
    generates an exception, the equivalent address of the catch code is loaded and
    called from the stack. However, if we somehow manage to overwrite the address
    in the stack for the catch code of the handler, we will be able to control the
    application. Let''s see how things are arranged in a stack when an application
    is implemented with exception handlers:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理程序是捕获程序执行过程中生成的异常和错误的代码模块。这使得程序可以继续执行而不会崩溃。Windows操作系统具有默认的异常处理程序，通常在应用程序崩溃并抛出一个弹出窗口时看到它们，上面写着*XYZ程序遇到错误并需要关闭*。当程序生成异常时，相应的catch代码的地址将从堆栈中加载并调用。然而，如果我们设法覆盖处理程序的catch代码在堆栈中的地址，我们将能够控制应用程序。让我们看看当应用程序实现异常处理程序时，堆栈中的排列情况：
- en: '![](img/a93d591e-bf18-4ce8-95b5-59c5e4f1d09d.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a93d591e-bf18-4ce8-95b5-59c5e4f1d09d.png)'
- en: 'In the preceding diagram, we can see that we have the address of the catch
    block in the stack. We can also see, on the right side, that when we feed enough
    input to the program, it overwrites the address of the catch block in the stack
    as well. Therefore, we can easily find out the offset value for overwriting the
    address of the catch block using the `pattern_create` and `pattern_offset` tools
    in Metasploit. Let''s see an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到堆栈中catch块的地址。我们还可以看到，在右侧，当我们向程序提供足够的输入时，它也会覆盖堆栈中catch块的地址。因此，我们可以很容易地通过Metasploit中的`pattern_create`和`pattern_offset`工具找到覆盖catch块地址的偏移值。让我们看一个例子：
- en: '![](img/f377ffa0-29fa-4d39-842e-a897144ddb6b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f377ffa0-29fa-4d39-842e-a897144ddb6b.png)'
- en: 'We create a pattern of `4000` characters and send it to the target using the
    `TELNET` command. Let''s see the application''s stack in the Immunity Debugger:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`4000`个字符的模式，并使用`TELNET`命令将其发送到目标。让我们在Immunity Debugger中查看应用程序的堆栈：
- en: '![](img/40c9658d-6cf6-40f4-a9f2-4990837bfb63.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40c9658d-6cf6-40f4-a9f2-4990837bfb63.png)'
- en: 'We can see in the application''s stack pane that the address of the SE handler
    was overwritten with `45346E45`. Let''s use `pattern_offset` to find the exact
    offset, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到应用程序的堆栈窗格中，SE处理程序的地址被覆盖为`45346E45`。让我们使用`pattern_offset`找到确切的偏移量，如下所示：
- en: '![](img/764f935e-f9f6-473d-9893-984703abe76d.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/764f935e-f9f6-473d-9893-984703abe76d.png)'
- en: 'We can see that the correct match is at `3522`. However, a significant point
    to note here is that according to the design of an SEH frame, we have the following
    components:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到正确的匹配在`3522`处。然而，这里需要注意的一个重要点是，根据SEH帧的设计，我们有以下组件：
- en: '![](img/1e4a5343-310c-4ade-b579-4d81a3afb6ab.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e4a5343-310c-4ade-b579-4d81a3afb6ab.png)'
- en: 'An SEH record contains the first `4` bytes as the address of the next SEH handler
    and the next `4` bytes as the address of the catch block. An application may have
    multiple exception handlers. Therefore, a particular SEH record stores the first
    4 bytes as the address of the next SEH record. Let''s see how we can take advantage
    of SEH records:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SEH记录包含前`4`个字节作为下一个SEH处理程序的地址，下一个`4`个字节作为catch块的地址。一个应用程序可能有多个异常处理程序。因此，特定的SEH记录将前4个字节存储为下一个SEH记录的地址。让我们看看如何利用SEH记录：
- en: We will cause an exception in the application so that a call is made to the
    exception handler.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在应用程序中引发异常，以便调用异常处理程序。
- en: We will overwrite the address of the catch handler field with the address of
    a POP/POP/RETN instruction. This is because we need to switch the execution to
    the address of the next SEH frame (4 bytes before the address of the catch handler).
    We will use POP/POP/RET because the memory address where the call to the catch
    block is saved is stored in the stack and the address of the pointer to the next
    handler is at ESP+8 (the ESP is referred as the top of the stack). Therefore,
    two POP operations will redirect the execution to the start of 4 byte which are
    the address of the next SEH record.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用POP/POP/RETN指令的地址来覆盖catch处理程序字段的地址。这是因为我们需要将执行切换到下一个SEH帧的地址（在catch处理程序地址的前4个字节）。我们将使用POP/POP/RET，因为调用catch块的内存地址保存在堆栈中，下一个处理程序的指针地址在ESP+8（ESP被称为堆栈的顶部）。因此，两个POP操作将重定向执行到下一个SEH记录的开始的4个字节的地址。
- en: While supplying the input in the very first step, we will overwrite the address
    of the next SEH frame with the JMP instruction to our payload. Therefore, when
    the second step completes, the execution will make a jump of a specified number
    of bytes to the shellcode.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中提供输入时，我们将使用JMP指令覆盖下一个SEH帧的地址到我们的有效载荷。因此，当第二步完成时，执行将跳转指定字节数到shellcode。
- en: Successfully jumping to the shellcode will execute the payload and we will gain
    access to the target.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功跳转到shellcode将执行有效载荷，我们将获得对目标的访问权限。
- en: 'Let''s understand these steps with the help of the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表来理解这些步骤：
- en: '![](img/339c6f70-ba02-46a6-ad7a-344b7c570e10.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/339c6f70-ba02-46a6-ad7a-344b7c570e10.png)'
- en: In the preceding diagram, when an exception occurs, it calls the address of
    the handler (already overwritten with the address of the POP/POP/RET instruction).
    This causes the execution of POP/POP/RET and redirects the execution to the address
    of the next SEH record (already overwritten with a short jump). Therefore, when
    the JMP executes, it points to the shellcode, and the application treats it as
    another SEH record.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，当发生异常时，它调用处理程序的地址（已经被POP/POP/RET指令的地址覆盖）。这会导致执行POP/POP/RET并将执行重定向到下一个SEH记录的地址（已经被短跳转覆盖）。因此，当JMP执行时，它指向shellcode，并且应用程序将其视为另一个SEH记录。
- en: Building the exploit base
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建利用基础
- en: 'Now that we have familiarized ourselves with the basics, let''s see what essentials
    we need to develop a working exploit for SEH-based vulnerabilities:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了基础知识，让我们看看我们需要为SEH-based漏洞开发一个工作利用所需的基本要素：
- en: '| **Component** | **Use** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **用途** |'
- en: '| Offset | In this module, the offset will refer to the exact size of input
    that is good enough to overwrite the address of the catch block. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量 | 在这个模块中，偏移量将指的是足够覆盖catch块地址的输入的确切大小。'
- en: '| POP/POP/RET address | This is the address of a POP-POP-RET sequence from
    the DLL. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| POP/POP/RET地址 | 这是来自DLL的POP-POP-RET序列的地址。'
- en: '| Short jump instruction | To move to the start of shellcode, we will need
    to make a short jump of a specified number of bytes. Hence, a short jump instruction
    will be required. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 短跳转指令 | 为了移动到shellcode的开始，我们需要进行指定字节数的短跳转。因此，我们需要一个短跳转指令。'
- en: We already know that we require a payload, a set of bad characters to prevent,
    space considerations, and so on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们需要一个有效载荷，一组要防止的坏字符，空间考虑等等。
- en: Calculating the offset
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算偏移量
- en: The Easy File Sharing Web Server 7.2 application is a web server that has a
    vulnerability in the request handling sections, where a malicious HEAD request
    can cause an overflow in the buffer and overwrite the address in the SEH chain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Easy File Sharing Web Server 7.2应用程序是一个Web服务器，在请求处理部分存在漏洞，恶意的HEAD请求可以导致缓冲区溢出并覆盖SEH链中的地址。
- en: Using the pattern_create tool
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pattern_create工具
- en: 'We will find the offset using the `pattern_create` and `pattern_offset` tools,
    as we did previously while attaching the vulnerable application to the debugger.
    Let''s see how we can achieve this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pattern_create`和`pattern_offset`工具来找到偏移量，就像我们之前在将有漏洞的应用程序附加到调试器时所做的那样。让我们看看我们如何做到这一点：
- en: '![](img/2b5a05e9-2bed-4b4d-b1e7-5bf685cabcdd.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b5a05e9-2bed-4b4d-b1e7-5bf685cabcdd.png)'
- en: 'We created a pattern of `10000` characters. Now, let''s feed the pattern to
    the application on port `80` and analyze its behavior in the Immunity Debugger.
    We will see that the application halts. Let''s see the SEH chains by navigating
    to View from the menu bar and selecting SEH chain:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含`10000`个字符的模式。现在，让我们将模式提供给端口`80`上的应用程序，并在Immunity Debugger中分析其行为。我们会看到应用程序停止运行。让我们通过导航到菜单栏中的View并选择SEH链来查看SEH链：
- en: '![](img/b5e5dc8f-caef-43ed-bb4c-e23a77d16928.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e5dc8f-caef-43ed-bb4c-e23a77d16928.png)'
- en: 'Clicking on the SEH chain option, we will be able to see the overridden catch
    block address and the address of the next SEH record fields overridden with the
    data we supplied:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 点击SEH链选项，我们将能够看到被覆盖的catch块地址和下一个SEH记录地址被我们提供的数据覆盖：
- en: '![](img/271c5654-7c49-4d54-842d-b9c23a143982.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/271c5654-7c49-4d54-842d-b9c23a143982.png)'
- en: Using the pattern_offset tool
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pattern_offset工具
- en: 'Let''s find the offset to the address of the next SEH frame and the offset
    to the address of the catch block, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到下一个SEH帧地址和catch块地址的偏移量，如下所示：
- en: '![](img/ea02cb23-da13-4881-85a4-461d33998a83.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea02cb23-da13-4881-85a4-461d33998a83.png)'
- en: We can see that the 4 bytes containing the memory address to the next SEH record
    starts from `4061` bytes and the offset to the catch block begins right after
    those 4 bytes; that is, from `4065`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到包含下一个SEH记录的内存地址的4个字节从`4061`字节开始，而catch块的偏移量则从这4个字节之后开始；也就是从`4065`开始。
- en: Finding the POP/POP/RET address
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找POP/POP/RET地址
- en: As discussed previously, we will require the address to the POP/POP/RET instruction
    to load the address in the next SEH frame record and jump to the payload. We know
    that we need to load the address from an external DLL file. However, most of the
    latest operating systems compile their DLL files with SafeSEH protection. Therefore,
    we will require the address of the POP/POP/RET instruction from a DLL module,
    which is not implemented with the SafeSEH mechanism.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论过，我们需要地址到POP/POP/RET指令来加载地址到下一个SEH帧记录并跳转到有效载荷。我们知道我们需要从外部DLL文件加载地址。然而，大多数最新的操作系统都使用SafeSEH保护编译他们的DLL文件。因此，我们需要从一个没有实现SafeSEH机制的DLL模块中获取POP/POP/RET指令的地址。
- en: The example application crashes on the following `HEAD` request; that is, `HEAD`
    followed by the junk pattern created by the `pattern_create` tool, which is followed
    by `HTTP/1.0rnrn`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序在以下`HEAD`请求上崩溃；即`HEAD`后面是由`pattern_create`工具创建的垃圾模式，然后是`HTTP/1.0rnrn`。
- en: The Mona script
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mona脚本
- en: The Mona script is a Python-driven plugin for the Immunity Debugger and provides
    a variety of options for exploitation. The script can be downloaded from: [https://github.com/corelan/mona/blob/master/mona.py](https://github.com/corelan/mona/blob/master/mona.py).
    It is easy to install the script by placing it into the `\Program Files\Immunity
    Inc\Immunity Debugger\PyCommands` directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Mona脚本是Immunity Debugger的Python驱动插件，提供了各种利用选项。该脚本可以从以下网址下载：[https://github.com/corelan/mona/blob/master/mona.py](https://github.com/corelan/mona/blob/master/mona.py)。将脚本放入`\Program
    Files\Immunity Inc\Immunity Debugger\PyCommands`目录中即可轻松安装。
- en: 'Now let''s analyze the DLL files by using Mona and running the `!mona modules`
    command, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Mona并运行`!mona modules`命令来分析DLL文件，如下：
- en: '![](img/5de60269-f16b-4189-9753-d8c23383de07.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5de60269-f16b-4189-9753-d8c23383de07.png)'
- en: We can see from the preceding screenshot that we have very few DLL files, which
    are not implemented with the SafeSEH mechanism. Let's use these files to find
    the relevant address of the POP/POP/RET instruction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，我们只有很少的没有实现SafeSEH机制的DLL文件。让我们使用这些文件来找到POP/POP/RET指令的相关地址。
- en: More information on the Mona script can be found at: [https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Mona脚本的更多信息，请访问：[https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/)。
- en: Using msfpescan
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msfpescan
- en: 'We can easily find the POP/POP/RET instruction sequence with `msfpescan` using
    the `-s` switch. Let''s use it on the `ImageLoad.dll` file, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`msfpescan`的`-s`开关轻松找到`ImageLoad.dll`文件中的POP/POP/RET指令序列。让我们使用它。
- en: '![](img/5ad5e795-2155-47f0-b223-6c82bd0e9d4d.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ad5e795-2155-47f0-b223-6c82bd0e9d4d.png)'
- en: 'Let''s use a safe address, eliminating any address that can cause issues with
    the HTTP protocol, such as the consecutive repetition of zeros, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个安全地址，消除可能导致HTTP协议问题的地址，比如连续重复的零，如下：
- en: '![](img/71da2ab5-e7dc-4092-9ce3-df3e361b7481.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71da2ab5-e7dc-4092-9ce3-df3e361b7481.png)'
- en: We will use `0x10019798` as the POP/POP/RET address. We now have two critical
    components for writing the exploit, which are the offset and the address to be
    loaded into the catch block, which is the address of our POP/POP/RET instruction.
    We only need the instruction for the short jump, which is to be loaded into the
    address of the next SEH record that will help us to jump to the shellcode. Metasploit
    libraries will provide us with the short jump instruction using inbuilt functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`0x10019798`作为POP/POP/RET地址。现在我们已经有了撰写利用程序的两个关键组件，即偏移量和要加载到catch块中的地址，即我们的POP/POP/RET指令的地址。我们只需要短跳转的指令，这将被加载到下一个SEH记录的地址，这将帮助我们跳转到shellcode。Metasploit库将使用内置函数为我们提供短跳转指令。
- en: Writing the Metasploit SEH exploit module
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Metasploit SEH利用模块
- en: 'Now that we have all the important data for exploiting the target application,
    let''s go ahead and create an exploit module in Metasploit, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了利用目标应用程序的所有重要数据，让我们继续在Metasploit中创建一个利用模块，如下：
- en: '[PRE3]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Having worked with the header part of various modules, we start by including
    the required sections of the library files. Next, we define the class and the
    module type as we did in the previous modules. We begin the `initialize` section
    by defining the name, description, author information, license information, payload
    options, disclosure date, and default target. We use the address of the POP/POP/RET
    instruction in the `Ret` return address variable and `Offset` as `4061` under
    the `Targets` field. We have used `4061` instead of `4065` because Metasploit
    will automatically generate the short jump instruction to the shellcode; therefore,
    we will start 4 bytes before `4065` bytes so that the short jump can be placed
    into the carrier for the address of the next SEH record.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理各种模块的头部部分后，我们开始包含库文件的所需部分。接下来，我们定义类和模块类型，就像我们在之前的模块中所做的那样。我们通过定义名称、描述、作者信息、许可信息、有效载荷选项、披露日期和默认目标来开始`initialize`部分。我们在`Ret`返回地址变量和`Offset`字段下使用`4061`作为POP/POP/RET指令的地址。我们使用`4061`而不是`4065`，因为Metasploit将自动生成短跳转指令到shellcode；因此，我们将从`4065`字节前开始4个字节，以便将短跳转放入载体中，以用于下一个SEH记录的地址。
- en: 'Before moving further, let''s have a look at the essential functions we are
    going to use in the module. We''ve already seen the usage of `make_nops`, `connect`,
    `disconnect`, and `handler`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看一下我们将在模块中使用的重要函数。我们已经看到了`make_nops`、`connect`、`disconnect`和`handler`的用法：
- en: '| **Function** | **Library** | **Usage** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **库** | **用法** |'
- en: '| `generate_seh_record()` | `/lib/msf/core/exploit/seh.rb` | The library mixin
    provides ways to generate SEH records. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `generate_seh_record()` | `/lib/msf/core/exploit/seh.rb` | 这个库提供了生成SEH记录的方法。|'
- en: 'Let''s continue with the code, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写代码，如下：
- en: '[PRE4]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `exploit` function starts by connecting to the target. Next, it generates
    a malicious `HEAD` request by appending `4061` NOPs to the `HEAD` request. Next,
    the `generate_seh_record()` function generates an `8` byte `SEH` record, where
    the first 4 bytes form the instruction to jump to the payload. Generally, these
    4 bytes contain instructions such as `\xeb\x0A\x90\x90`, where `\xeb` denotes
    a jump instruction, `\x0A` denotes the `12` bytes to jump, and the `\x90\x90 NOP`
    instruction completes the 4 bytes as padding.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`exploit`函数首先通过连接到目标开始。接下来，它通过在`HEAD`请求中附加`4061`个NOP生成一个恶意的`HEAD`请求。接下来，`generate_seh_record()`函数生成一个`8`字节的`SEH`记录，其中前4个字节形成了跳转到有效载荷的指令。通常，这4个字节包含诸如`\xeb\x0A\x90\x90`的指令，其中`\xeb`表示跳转指令，`\x0A`表示要跳转的`12`字节，而`\x90\x90
    NOP`指令则作为填充完成了4个字节。'
- en: Using the NASM shell for writing assembly instructions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NASM shell编写汇编指令
- en: Metasploit provides an excellent utility for writing short assembly code using
    the NASM shell. We wrote a small assembly code in the previous section, `\xeb\x0a`,
    which denoted a short jump of 12 bytes. However, after eliminating the use of
    searching the internet or toggling through assembly op-codes, we can use the NASM
    shell to write assembly code with ease.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit提供了一个使用NASM shell编写短汇编代码的绝佳工具。在上一节中，我们编写了一个小的汇编代码`\xeb\x0a`，它表示了一个12字节的短跳转。然而，在消除了搜索互联网或切换汇编操作码的使用后，我们可以使用NASM
    shell轻松编写汇编代码。
- en: 'In the previous example, we had a simple assembly call, which was `JMP SHORT
    12`. However, we did not know what op-codes match this instruction. Therefore,
    let''s use the NASM shell and find out, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个简单的汇编调用，即`JMP SHORT 12`。然而，我们不知道与此指令匹配的操作码是什么。因此，让我们使用NASM shell来找出，如下所示：
- en: '![](img/6f8fe2cf-7991-429b-aaeb-734accd15ea4.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f8fe2cf-7991-429b-aaeb-734accd15ea4.png)'
- en: We can see in the preceding screenshot that we launched `nasm_shell.rb` from
    the `/usr/share/Metasploit-framework/tools/exploit` directory and simply typed
    in the command that generated the same op-code, `EB0A`, which we discussed earlier.
    Hence, we can utilize the NASM shell in all our upcoming exploit examples and
    practical exercises to reduce effort and save a great deal of time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们从`/usr/share/Metasploit-framework/tools/exploit`目录中启动了`nasm_shell.rb`，然后简单地输入了生成相同操作码`EB0A`的命令，这是我们之前讨论过的。因此，我们可以在所有即将到来的利用示例和实际练习中使用NASM
    shell，以减少工作量并节省大量时间。
- en: Coming back to the topic, Metasploit allowed us to skip the task of providing
    the jump instruction and the number of bytes to the payload using the `generate_seh_record()`
    function. Next, we simply provided some padding before the payload to overcome
    any irregularities and follow with the payload. We simply completed the request
    using `HTTP/1.0\r\n\r\n` in the header. Finally, we sent the data stored in the
    variable weapon to the target and called the handler method to check if the attempt
    was successful, and we were given access to the target.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 回到主题，Metasploit允许我们跳过提供跳转指令和字节数到有效载荷的任务，使用`generate_seh_record()`函数。接下来，我们只需在有效载荷之前提供一些填充以克服任何不规则性，并跟随有效载荷。最后，我们在头部使用`HTTP/1.0\r\n\r\n`完成请求。最后，我们将存储在变量weapon中的数据发送到目标，并调用处理程序方法来检查尝试是否成功，并且我们获得了对目标的访问权限。
- en: 'Let''s try running the module and analyze the behavior, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行模块并分析行为，如下所示：
- en: '![](img/76cda35c-2294-4901-9ef5-29553e382704.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76cda35c-2294-4901-9ef5-29553e382704.png)'
- en: 'Let''s set all the required options for the module and run the `exploit` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为模块设置所有必需的选项，并运行`exploit`命令：
- en: '![](img/6617dc64-4149-4132-8cee-8ddf1250432f.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6617dc64-4149-4132-8cee-8ddf1250432f.png)'
- en: Bang! We successfully exploited the target, which is a Windows 7 system. We
    saw how easy it is to create SEH modules in Metasploit. In the next section, we
    will take a deeper dive into advanced modules that bypass security mechanisms
    such as DEP.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！我们成功地利用了目标，这是一个Windows 7系统。我们看到了在Metasploit中创建SEH模块是多么容易。在下一节中，我们将深入研究绕过DEP等安全机制的高级模块。
- en: Refer to [https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler](https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler) for
    more information on the SEH mixin.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SEH mixin的更多信息，请参阅[https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler](https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler)。
- en: Bypassing DEP in Metasploit modules
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过Metasploit模块中的DEP
- en: '**Data Execution Prevention** (**DEP**) is a protection mechanism that marks
    specific areas of memory as non-executable, causing no execution of shellcode
    when it comes to exploitation. Therefore, even if we can overwrite the EIP register
    and point the ESP to the start of the shellcode, we will not be able to execute
    our payloads. This is because DEP prevents the execution of data in the writable
    areas of the memory, such as stack and heap. In this case, we will need to use
    existing instructions that are in the executable regions to achieve the desired
    functionality. We can do this by putting all the executable instructions in such
    an order that jumping to the shellcode becomes viable.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据执行防护**（**DEP**）是一种保护机制，它将特定内存区域标记为不可执行，导致在利用时不执行shellcode。因此，即使我们可以覆盖EIP寄存器并将ESP指向shellcode的起始位置，我们也无法执行我们的有效载荷。这是因为DEP防止在内存的可写区域（如堆栈和堆）中执行数据。在这种情况下，我们需要使用可执行区域中的现有指令来实现所需的功能。我们可以通过将所有可执行指令按照一定顺序排列，使得跳转到shellcode成为可能。'
- en: The technique for bypassing DEP is called **Return Oriented Programming** (**ROP**).
    ROP differs from an ordinary stack overflow, where overwriting the EIP and calling
    the jump to the shellcode is only required. When DEP is enabled, we cannot do
    that since the data in the stack is non-executable. Here, instead of jumping to
    the shellcode, we will call the first ROP gadget, and these gadgets should be
    set up in such a way that they form a chained structure, where one gadget returns
    to the next one without ever executing any code from the stack.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过DEP的技术称为**返回导向编程**（**ROP**）。ROP与普通的堆栈溢出不同，普通的堆栈溢出只需要覆盖EIP并调用跳转到shellcode。当DEP启用时，我们无法这样做，因为堆栈中的数据是不可执行的。在这里，我们将调用第一个ROP小工具，而不是跳转到shellcode，这些小工具应该被设置成这样的结构，它们形成一个链接结构，其中一个小工具返回到下一个小工具，而不会执行任何来自堆栈的代码。
- en: In the upcoming sections, we will see how we can find ROP gadgets, which are
    instructions that can perform operations over registers followed by a return (`RET`)
    instruction. The best way to find ROP gadgets is to look for them in loaded modules
    (DLLs). The combination of such gadgets formed together that takes one address
    after the other from the stack and returns to the next one are called ROP chains.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何找到ROP小工具，这些指令可以执行寄存器上的操作，然后返回（`RET`）指令。找到ROP小工具的最佳方法是在加载的模块（DLL）中寻找它们。这些小工具的组合形成了一个链式结构，从堆栈中依次取出一个地址并返回到下一个地址，这些链式结构被称为ROP链。
- en: 'We have an example application that is vulnerable to stack overflow. The offset
    value for overwriting EIP is 2006\. Let''s see what happens when we exploit this
    application using Metasploit:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个易受堆栈溢出攻击的示例应用程序。用于覆盖EIP的偏移值为2006。让我们看看当我们使用Metasploit利用这个应用程序时会发生什么：
- en: '![](img/a8257a82-1559-485b-81b8-51473cb4d7e4.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8257a82-1559-485b-81b8-51473cb4d7e4.png)'
- en: 'We can see that we got a Meterpreter shell with ease. Let''s turn on DEP in
    Windows by navigating to the advanced system properties from the system properties,
    as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们轻松地获得了一个Meterpreter shell。让我们通过从系统属性中导航到高级系统属性来在Windows中启用DEP，如下所示：
- en: '![](img/1fd448d5-a14e-40ed-8c4d-4bdb79ffa9e7.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fd448d5-a14e-40ed-8c4d-4bdb79ffa9e7.png)'
- en: 'We turned on DEP by selecting Turn on DEP for all programs and services except
    those I select. Let''s restart our system and retry exploiting the same vulnerability,
    as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择对所有程序和服务启用DEP，除了我选择的那些，来启用DEP。让我们重新启动系统，并尝试利用相同的漏洞，如下所示：
- en: '![](img/d19ebd28-fd05-4b24-af6a-2ef5a65a4d5d.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d19ebd28-fd05-4b24-af6a-2ef5a65a4d5d.png)'
- en: We can see that our exploit failed because the shellcode was not executed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的利用失败了，因为shellcode没有被执行。
- en: You can download the example application from: [http://www.thegreycorner.com/2010/12/introducing-vulnserver.html](http://www.thegreycorner.com/2010/12/introducing-vulnserver.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下网址下载示例应用程序：[http://www.thegreycorner.com/2010/12/introducing-vulnserver.html](http://www.thegreycorner.com/2010/12/introducing-vulnserver.html)。
- en: 'In the upcoming sections, we will see how we can bypass limitations posed by
    DEP using Metasploit and gain access to the protected systems. Let''s keep DEP
    enabled, attach the same vulnerable application to the debugger, and check its
    executable modules, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何使用Metasploit绕过DEP的限制，并访问受保护的系统。让我们保持DEP启用，将相同的易受攻击的应用程序附加到调试器，并检查其可执行模块，如下所示：
- en: '![](img/df7cc20b-64f2-411f-8dac-997886a437c8.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df7cc20b-64f2-411f-8dac-997886a437c8.png)'
- en: Using the Mona script, as we did previously, we can find information about all
    the modules using the `!mona modules` command. However, to build ROP chains, we
    need to find all the executable ROP gadgets within these DLL files.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mona脚本，就像我们之前做的那样，我们可以使用`!mona modules`命令找到所有模块的信息。然而，要构建ROP链，我们需要在这些DLL文件中找到所有可执行的ROP小工具。
- en: Using msfrop to find ROP gadgets
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msfrop查找ROP小工具
- en: 'Metasploit provides a very convenient tool to find ROP gadgets: `msfrop`. It
    not only enables us to list all the ROP gadgets but also allows us to search through
    those gadgets to find the appropriate gadgets for our required actions. Let''s
    say we need to see all the gadgets that can help us to perform a pop operation
    over the `ECX` register. We can do this using `msfrop`, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit提供了一个非常方便的工具来查找ROP小工具：`msfrop`。它不仅使我们能够列出所有的ROP小工具，还允许我们通过这些小工具来寻找我们所需操作的适当小工具。假设我们需要查看所有可以帮助我们执行对`ECX`寄存器的弹出操作的小工具。我们可以使用`msfrop`来做到这一点，如下所示：
- en: '![](img/b26f0e56-3daf-4848-a42b-0e3289dfe707.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b26f0e56-3daf-4848-a42b-0e3289dfe707.png)'
- en: 'As soon as we provide the `-s` switch for searching and `-v` for verbose output,
    we start getting a list of all the gadgets where the POP ECX instruction is used.
    Let''s see the results:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们为搜索提供了`-s`开关，并为详细输出提供了`-v`，我们就开始获得所有使用POP ECX指令的小工具的列表。让我们看看结果：
- en: '![](img/cae599b6-1754-4486-915b-d67b673fecec.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cae599b6-1754-4486-915b-d67b673fecec.png)'
- en: 'We can see that we have various gadgets that can perform the POP ECX task with
    ease. However, to build a successful Metasploit module that can exploit the target
    application in the presence of DEP, we need to develop a chain of these ROP gadgets
    without executing anything from the stack. Let''s understand the ROP bypass for
    DEP through the following diagram:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们有各种各样的小工具可以轻松执行POP ECX任务。然而，要构建一个成功的Metasploit模块，可以在DEP存在的情况下利用目标应用程序，我们需要开发一系列这些ROP小工具，而不执行任何来自堆栈的内容。让我们通过以下图表了解DEP的ROP绕过：
- en: '![](img/9ae8c704-8223-47e1-a1a1-8414361dc207.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ae8c704-8223-47e1-a1a1-8414361dc207.png)'
- en: On the left side, we have the layout for a standard application. In the middle,
    we have an application that is attacked using a buffer overflow vulnerability,
    causing the overwrite of the EIP register. On the right, we have the mechanism
    for the DEP bypass, where instead of overwriting EIP with the JMP ESP address,
    we overwrite it with the address of the ROP gadget, followed by another ROP gadget,
    and so on until the execution of the shellcode is achieved.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有一个标准应用程序的布局。在中间，我们有一个使用缓冲区溢出漏洞受到攻击的应用程序，导致EIP寄存器被覆盖。在右侧，我们有DEP绕过的机制，我们不是用JMP
    ESP地址覆盖EIP，而是用ROP gadget的地址覆盖它，然后是另一个ROP gadget，依此类推，直到执行shellcode。
- en: How will the execution of instructions bypass hardware-enabled DEP protection?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 指令执行如何绕过硬件启用的DEP保护？
- en: 'The answer is simple. The trick is to chain these ROP gadgets to call a `VirtualProtect()`
    function, which is a memory protection function used to make the stack executable
    so that the shellcode can execute. Let''s look at the steps we need to perform
    to get the exploit to work under DEP protection:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单。诀窍在于将这些ROP gadgets链接起来调用`VirtualProtect()`函数，这是一个用于使堆栈可执行的内存保护函数，以便shellcode可以执行。让我们看看我们需要执行哪些步骤才能使利用在DEP保护下工作：
- en: Find the offset to the EIP register
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到EIP寄存器的偏移量
- en: Overwrite the register with the first ROP gadget
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用第一个ROP gadget覆盖寄存器
- en: Continue overwriting with the rest of the gadgets until the shellcode becomes
    executable
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续用其余的gadgets覆盖，直到shellcode变得可执行
- en: Execute the shellcode
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行shellcode
- en: Using Mona to create ROP chains
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mona创建ROP链
- en: 'Using the Mona script from the Immunity Debugger, we can find ROP gadgets.
    However, it also provides functionality to create an entire ROP chain by itself,
    as shown in the following screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Immunity Debugger的Mona脚本，我们可以找到ROP gadgets。然而，它还提供了自己创建整个ROP链的功能，如下图所示：
- en: '![](img/488269bb-b3c7-4609-b3de-0c7cbb5f008a.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/488269bb-b3c7-4609-b3de-0c7cbb5f008a.png)'
- en: 'Using the `!mona rop -m *.dll -cp nonull` command in the Immunity Debugger''s
    console, we can find all the relevant information about the ROP gadgets. We can
    see that we have the following files generated by the Mona script:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Immunity Debugger的控制台中使用`!mona rop -m *.dll -cp nonull`命令，我们可以找到关于ROP gadgets的所有相关信息。我们可以看到Mona脚本生成了以下文件：
- en: '![](img/fb4f21a9-c0ad-43e5-99dd-cdeb145d080b.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb4f21a9-c0ad-43e5-99dd-cdeb145d080b.png)'
- en: Interestingly, we have a file called `rop_chains.txt`, which contains the entire
    chain that can be used directly in the exploit module. This file contains the
    ROP chains created in Python, C, and Ruby for use in Metasploit already. All we
    need to do is copy the ROP chain into our exploit, and we are good to go.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们有一个名为`rop_chains.txt`的文件，其中包含可以直接在利用模块中使用的整个链。该文件包含了在Python、C和Ruby中创建的用于Metasploit的ROP链。我们只需要将ROP链复制到我们的利用中，就可以了。
- en: 'To create a ROP chain for triggering the `VirtualProtect()` function, we need
    the following setup of registers:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为触发`VirtualProtect()`函数创建ROP链，我们需要以下寄存器的设置：
- en: '![](img/a949b3aa-4cb1-4243-99c3-5745db324264.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a949b3aa-4cb1-4243-99c3-5745db324264.png)'
- en: 'Let''s see the ROP chain created by the Mona script, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下Mona脚本创建的ROP链，如下所示：
- en: '![](img/80399eaa-788b-46d3-9749-d46e0614de54.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80399eaa-788b-46d3-9749-d46e0614de54.png)'
- en: We have a complete `create_rop_chain` function in the `rop_chains.txt` file
    for Metasploit. We merely need to copy this function to our exploit.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`rop_chains.txt`文件中有一个完整的`create_rop_chain`函数，用于Metasploit。我们只需要将这个函数复制到我们的利用中。
- en: Writing the Metasploit exploit module for DEP bypass
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写DEP绕过的Metasploit利用模块
- en: 'In this section, we will write the DEP bypass exploit for the same vulnerable
    application in which we exploited the stack overflow vulnerability, and the exploit
    failed when DEP was enabled. The application runs on TCP port `9999`. So, let''s
    quickly build a module and try bypassing DEP on the same application:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为同一个易受攻击的应用程序编写DEP绕过利用，我们在利用栈溢出漏洞时失败了，因为DEP已启用。该应用程序在TCP端口`9999`上运行。因此，让我们快速构建一个模块，并尝试在同一应用程序上绕过DEP：
- en: '[PRE5]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have written numerous modules, and are quite familiar with the required
    libraries and the initialization section. Additionally, we do not need a return
    address since we are using ROP chains that automatically build mechanisms to jump
    to the shellcode. Let''s focus on the exploit section:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了许多模块，并对所需的库和初始化部分非常熟悉。此外，我们不需要返回地址，因为我们使用的是自动构建机制跳转到shellcode的ROP链。让我们专注于利用部分：
- en: '[PRE6]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that we copied the entire `create_rop_chain` function from the `rop_chains.txt`
    file generated by the Mona script to our exploit.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将Mona脚本生成的`rop_chains.txt`文件中的整个`create_rop_chain`函数复制到了我们的利用中。
- en: We begin the exploit method by connecting to the target. Then, we call the `create_rop_chain`
    function and store the entire chain in a variable called `rop_chain`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过连接到目标开始利用方法。然后，我们调用`create_rop_chain`函数，并将整个链存储在一个名为`rop_chain`的变量中。
- en: Next, we create a random text of `2006` characters using the `rand_text_alpha_upper`
    function and store it into a variable called `junk`. The vulnerability in the
    application lies in the execution of the `TRUN` command. Therefore, we create
    a new variable called `buf` and store the `TRUN` command, followed by the `junk`
    variable that holds `2006` random characters, followed by our `rop_chain`. We
    also add some padding and, finally, the shellcode to the `buf` variable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`rand_text_alpha_upper`函数创建一个包含`2006`个字符的随机文本，并将其存储在一个名为`junk`的变量中。该应用程序的漏洞在于执行`TRUN`命令。因此，我们创建一个名为`buf`的新变量，并存储`TRUN`命令，后跟包含`2006`个随机字符的`junk`变量，再跟我们的`rop_chain`。我们还添加了一些填充，最后将shellcode添加到`buf`变量中。
- en: Next, we just put the `buf` variable onto the communication channel `sock.put`
    method. Finally, we just call the handler to check for successful exploitation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需将`buf`变量放到通信通道`sock.put`方法中。最后，我们只需调用处理程序来检查是否成功利用。
- en: 'Let''s run this module and check if we can exploit the system or not:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个模块，看看我们是否能够利用系统：
- en: '![](img/671993e2-7b00-4d79-b1ab-68672df8b82b.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/671993e2-7b00-4d79-b1ab-68672df8b82b.png)'
- en: Bingo! We made it through the DEP protection with ease. We can now perform post-exploitation
    on the compromised target.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们轻松地通过了DEP保护。现在我们可以对受损目标进行后期利用。
- en: Other protection mechanisms
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他保护机制
- en: Throughout this chapter, we developed exploits based on stack-based vulnerabilities
    and in our journey of exploitation, we bypassed SEH and DEP protection mechanisms.
    There are many more protection techniques, such as **Address Space Layout Randomization**
    (**ASLR**), **stack cookies**, **SafeSEH**, **SEHOP**, and many others. We will
    see bypass techniques for these techniques in the upcoming sections of the book.
    However, these techniques will require an excellent understanding of assembly,
    opcodes, and debugging.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基于基于堆栈的漏洞开发了利用程序，在我们的利用过程中，我们绕过了SEH和DEP保护机制。还有许多其他保护技术，如地址空间布局随机化（ASLR）、堆栈cookie、SafeSEH、SEHOP等。我们将在本书的后续部分中看到这些技术的绕过技术。然而，这些技术将需要对汇编、操作码和调试有出色的理解。
- en: Refer to an excellent tutorial on bypassing protection mechanisms at: [https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/](https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 参考一篇关于绕过保护机制的优秀教程：[https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/](https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/)。
- en: For more information on debugging, refer to: [http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有关调试的更多信息，请参考：[http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/)。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by covering the essentials of assembly in the context
    of exploit writing in Metasploit, the general concepts, and their importance in
    exploitation. We covered details of stack-based overflows, SEH-based stack overflows,
    and bypasses for protection mechanisms such as DEP in depth. We included various
    handy tools in Metasploit that aid the process of exploitation. We also looked
    at the importance of bad characters and space limitations.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了在Metasploit中编写利用程序的汇编基础知识，一般概念以及它们在利用中的重要性。我们深入讨论了基于堆栈的溢出、基于SEH的堆栈溢出以及绕过DEP等保护机制的细节。我们还介绍了Metasploit中各种方便的工具，以帮助利用过程。我们还看了坏字符和空间限制的重要性。
- en: Now, we can perform tasks such as writing exploits for software in Metasploit
    with the help of supporting tools, determining essential registers, methods to
    overwrite them, and defeating sophisticated protection mechanisms.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以借助支持工具执行诸如在Metasploit中编写软件的利用之类的任务，确定必要的寄存器，覆盖它们的方法，并打败复杂的保护机制。
- en: 'Feel free to perform the following set of exercises before proceeding with
    the next chapter:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一章之前，可以尝试完成以下一组练习：
- en: Try finding exploits on exploit-db.com which work only on Windows XP systems
    and make them usable on Windows 7/8/8.1
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在exploit-db.com上找到仅适用于Windows XP系统的利用程序，并使其在Windows 7/8/8.1上可用
- en: Take at least 3 POC exploits from [https://exploit-db.com/](https://exploit-db.com/)
    and convert them to a fully capable Metasploit exploit module
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://exploit-db.com/](https://exploit-db.com/)中至少获取3个POC利用程序，并将它们转换为完全可用的Metasploit利用模块
- en: Start making contributions to Metasploit's GitHub repository and fork the main
    instance
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始向Metasploit的GitHub存储库做出贡献，并fork主要实例
- en: In the next chapter, we will look at publicly available exploits that are currently
    not available in Metasploit. We will try porting them to the Metasploit framework.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看目前在Metasploit中尚不可用的公开可用的利用程序。我们将尝试将它们移植到Metasploit框架中。
