- en: Uncovering Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭开时间的面纱
- en: Timestamps are stored in a wide variety of formats unique to the operating system
    or application responsible for their generation. In forensics, converting these
    timestamps can be an important aspect of an investigation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳以多种格式存储，这些格式通常是由负责生成它们的操作系统或应用程序所独有的。在取证中，转换这些时间戳可能是调查的重要部分。
- en: As an example, we may aggregate converted timestamps and create a combined timeline
    of events to determine a sequence of actions across mediums. This evaluation of
    time can help us establish whether actions are within a defined scope and provide
    insights into the relationship between two events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以汇总转换后的时间戳，创建一个综合事件时间线，确定跨平台的动作顺序。这种时间评估有助于我们判断行动是否在定义的范围内，并为我们提供关于两个事件之间关系的洞察。
- en: To decipher these formatted timestamps, we can use tools to interpret the raw
    values and convert them into human-readable time. Most forensic tools perform
    this operation silently as they parse known artifact structures (similarly to
    how our scripts often parse Unix timestamps).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解读这些格式化的时间戳，我们可以使用工具来解释原始值，并将其转换为人类可读的时间。大多数取证工具在解析已知的伪造数据结构时都会默默地执行此操作（类似于我们的脚本经常解析
    Unix 时间戳的方式）。
- en: In some cases, we don't have tools that properly or uniformly handle specific
    timestamps and will have to rely on our ingenuity to decipher the time value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们没有能够正确或统一处理特定时间戳的工具，必须依靠我们的聪明才智来解读时间值。
- en: We'll use common libraries to interpret timestamps from user input and transform
    them into the desired formats. Using the TkInter library, we'll design a **Graphical
    User Interface** (**GUI**) that the user will interface with to display date information.
    We'll use a Python class to better organize our GUI and handle events such as
    when a user clicks a button on the GUI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用常见的库来解析用户输入的时间戳，并将其转换为所需的格式。利用 TkInter 库，我们将设计一个**图形用户界面**（**GUI**），用户可以通过该界面展示日期信息。我们将使用
    Python 类来更好地组织我们的 GUI，并处理诸如用户点击 GUI 上按钮等事件。
- en: 'In this chapter, we''ll build a graphic interface that converts timestamps
    between machine- and human-readable formats with the help of the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个图形界面，借助以下主题将时间戳在机器可读格式和人类可读格式之间进行转换。
- en: The creation of cross-platform GUIs in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中创建跨平台的图形用户界面
- en: The conversion of common raw timestamp values between machine- and human-readable
    formats
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见原始时间戳值在机器可读格式和人类可读格式之间的转换。
- en: The basics of Python class design and implementation, allowing the flexible
    addition of more time formats
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 类设计与实现的基础，允许灵活地添加更多时间格式。
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码在 Python 2.7.15 和 Python 3.7.1 环境下开发并测试。
- en: About timestamps
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于时间戳
- en: 'Timestamp formats often boil down to two components: a reference point and
    a convention or algorithm used to represent the amount of time that has passed
    from the said reference point. Documentation exists for most timestamps and can
    help us to determine the best means to convert raw time data into a human-readable
    timestamp.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳格式通常归结为两个组成部分：一个参考点和用来表示从该参考点起已过的时间量的约定或算法。大多数时间戳都有相应的文档，可以帮助我们确定将原始时间数据转换为人类可读时间戳的最佳方式。
- en: As mentioned in the introduction, there is a wide array of timestamp formats,
    some of which we've already encountered, such as Unix time and Windows FILETIME.
    This makes the conversion process more difficult as the forensic scripts we develop
    may need to be prepared to process multiple time formats.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，时间戳格式种类繁多，其中一些我们已经遇到过，如 Unix 时间和 Windows FILETIME。这使得转换过程变得更加复杂，因为我们开发的取证脚本可能需要准备好处理多种时间格式。
- en: Python has several standard libraries bundled in the distribution that can help
    us convert timestamps. We've used the `datetime` module before to properly handle
    time values and store them within a Python object. We'll introduce two new libraries—`time`,
    which is part of the standard library, and the third-party `dateutil` module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 附带了几个标准库，可以帮助我们转换时间戳。我们以前使用过 `datetime` 模块来正确处理时间值并将其存储在 Python 对象中。我们将介绍两个新库——`time`（它是标准库的一部分）和第三方库
    `dateutil`。
- en: We can download and install `dateutil` (version 2.7.5) by running `pip install
    python-dateutil==2.7.5`. This library will be used to parse strings into `datetime`
    objects. The `parser()` method from the `dateutil` library takes a string as input
    and attempts to automatically convert it into a `datetime` object. Unlike the
    `strptime()` method, which requires explicit declaration of the format of the
    timestamp, the `dateutil.parser` converts timestamps of varying formats without
    requiring input from the developer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`pip install python-dateutil==2.7.5`来下载并安装`dateutil`（版本2.7.5）。这个库将用于将字符串解析为`datetime`对象。`dateutil`库中的`parser()`方法接受一个字符串作为输入，并尝试自动将其转换为`datetime`对象。与`strptime()`方法不同，后者需要显式声明时间戳的格式，`dateutil.parser`可以将不同格式的时间戳转换为`datetime`对象，而无需开发者输入。
- en: 'An example string could be `Tuesday December 8th, 2015 at 6:04 PM` or `12/08/2015
    18:04`, and both would be converted by the `parser()` method into the same `datetime`
    object. The following code block demonstrates this functionality, and works in
    both Python 2.7.15 and Python 3.7.1:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例字符串可以是`2015年12月8日星期二 18:04` 或 `12/08/2015 18:04`，这两者都会被`parser()`方法转换成相同的`datetime`对象。下面的代码块演示了这一功能，适用于Python
    2.7.15和Python 3.7.1：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the first line of the code block, we import the `dateutil` parser and create
    an alias, `duparser`, as the function name parser is a generic term that could
    possibly collide with another variable or function. We then call the `parse()`
    method and pass a string representing a timestamp. Assigning this parsed value
    to the variable, `d`, we view its ISO format using the `isoformat()` function.
    We repeat these steps with a second timestamp in a different format and observe
    the same end result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块的第一行，我们导入`dateutil`解析器并创建一个别名`duparser`，因为`parser`这个函数名是通用术语，可能会与其他变量或函数冲突。然后，我们调用`parse()`方法并传递一个表示时间戳的字符串。将解析后的值赋给变量`d`，我们使用`isoformat()`函数查看其ISO格式。接着，我们用第二个格式不同的时间戳重复这些步骤，观察到相同的结果。
- en: Please refer to the documentation for additional details on the `parse()` method
    at [http://dateutil.readthedocs.org/en/latest/parser.html](http://dateutil.readthedocs.org/en/latest/parser.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考文档，获取有关`parse()`方法的更多细节，访问 [http://dateutil.readthedocs.org/en/latest/parser.html](http://dateutil.readthedocs.org/en/latest/parser.html)。
- en: What's an epoch?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是纪元？
- en: An *epoch* is a point in time, marked as the origin of time for a given time
    format, and is usually used as a reference point to track movement through time.
    While we'll omit any philosophical discussion associated with measuring time,
    we'll use and reference an epoch as the starting point for a given time format
    in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*纪元*是一个时间点，被标记为给定时间格式的起始时间，通常用作跟踪时间流逝的参考点。尽管我们在这里省略了任何与时间度量相关的哲学讨论，但我们将在本章中使用并参考纪元作为给定时间格式的起点。'
- en: 'There''re two major epoch times associated with most timestamps: `1970-01-01
    00:00:00` and `1601-01-01 00:00:00`. The first, starting in 1970, is traditionally
    referred to as POSIX time as it''s a common timestamp in Unix and Unix-like systems.
    In most Unix systems, timestamps are measured as seconds elapsed since POSIX time.
    This carries over to some applications as well, and variations exist that use
    milliseconds since the same epoch.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时间戳关联着两个主要的纪元时间：`1970-01-01 00:00:00` 和 `1601-01-01 00:00:00`。第一个纪元从1970年开始，传统上被称为POSIX时间，因为它是Unix及类Unix系统中常见的时间戳。在大多数Unix系统中，时间戳是从POSIX时间开始计算的秒数。这个概念也延伸到了某些应用中，存在使用从同一纪元起的毫秒数的变种。
- en: The second noted epoch, based in 1601, is commonly found on Windows-based systems
    and is used because it was the start of the first 400-year cycle of the Gregorian
    calendar to include leap years. The 400-year cycle starting in 1601 is the first
    cycle where digital files existed, and so this value became another common epoch.
    It's common to see Windows system timestamps as a count of 100-nanosecond segments
    since that epoch. This value will often be stored in hex or as an integer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个纪元，基于1601年，通常出现在基于Windows的系统中，之所以使用这个时间点，是因为它是格里高利历中第一个包含闰年的400年周期的起始点。1601年开始的400年周期是第一个存在数字文件的周期，因此这个值成为另一个常见的纪元。在Windows系统中，常见的时间戳是从这个纪元起计算的100纳秒时间段的计数。这个值通常以十六进制或整数形式存储。
- en: The next code block describes the process used to convert timestamps of different
    epochs. As we've seen in previous chapters, we can use the `datetime` module's
    `fromtimestamp()` method to convert Unix timestamps because it uses the 1970 epoch.
    For 1601-based timestamps, we'll need to convert them before using the `fromtimestamp()`
    function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块描述了将不同纪元的时间戳进行转换的过程。正如我们在前面的章节中所看到的，我们可以使用`datetime`模块的`fromtimestamp()`方法来转换Unix时间戳，因为它使用的是1970年纪元。对于基于1601年的时间戳，我们需要在使用`fromtimestamp()`函数之前先进行转换。
- en: To make this conversion easier, let's calculate the constant between these dates
    and use that constant to convert between the two epochs. On the first line, we
    import the `datetime` library. Next, we subtract the two timestamps to determine
    the time delta between `1970-01-01` and `1601-01-01`. This statement produces
    a `datetime.timedelta` object, which stores the difference in time as a count
    of days, seconds, and microseconds between the two values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个转换过程，我们来计算这两个日期之间的常数，并利用这个常数在两个纪元之间进行转换。在第一行，我们导入`datetime`库。接下来，我们将两个时间戳相减，以确定`1970-01-01`和`1601-01-01`之间的时间差。这个语句生成一个`datetime.timedelta`对象，存储两个值之间以天、秒和微秒计的时间差。
- en: 'In this instance, the difference between the 1970 and 1601 timestamps is exactly
    134,774 days. We need to convert this into a microsecond timestamp to be able
    to accurately leverage it in our conversions. Therefore, in the third line, we
    convert the count of days (`time_diff.days`) into microseconds by multiplying
    it by `86400000000` (the product of *24 hours x 60 minutes x 60 seconds x 1,000,000
    microseconds*) and print the constant value of `11644473600000000`. Take a look
    at the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，1970年和1601年时间戳之间的差值恰好是134,774天。我们需要将这个差值转换成微秒时间戳，以便能够在转换中准确地使用它。因此，在第三行中，我们将天数（`time_diff.days`）转换为微秒，通过将其乘以`86400000000`（*24小时
    x 60分钟 x 60秒 x 1,000,000微秒*的积）并打印常数值`11644473600000000`。请查看以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this value, we can convert timestamps between both epochs and properly
    ingest 1601-based epoch timestamps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个值，我们就可以在这两个纪元之间转换时间戳，并正确处理基于1601年的纪元时间戳。
- en: Using a GUI
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GUI
- en: In this chapter, we'll use a GUI to convert timestamps between raw and human-readable
    formats. Timestamp conversion is a useful excuse to explore programming GUIs as
    it offers a solution to a common investigative activity. By using a GUI, we greatly
    increase the usability of our script among those deterred by the Command Prompt,
    with all of its arguments and switches.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用GUI将时间戳在原始格式和人类可读格式之间进行转换。时间戳转换是一个很好的借口来探索编程GUI，因为它提供了一个解决常见调查活动的方案。通过使用GUI，我们大大提高了脚本的可用性，尤其是对于那些被命令提示符及其各种参数和开关所吓退的用户。
- en: There are many options for GUI development in Python, though, in this chapter,
    we'll focus on TkInter. The TkInter library is a cross-platform GUI development
    library for Python that hooks into the operating system's `Tcl`/`Tk` library found
    on Windows, macOS, and several Linux platforms.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多GUI开发的选项，但在本章中，我们将重点介绍TkInter。TkInter库是一个跨平台的Python GUI开发库，它与操作系统的`Tcl`/`Tk`库结合使用，支持Windows、macOS以及多个Linux平台。
- en: This cross-platform framework allows us to build a common interface that's platform-independent.
    Although TkInter GUIs may not look the most modern, they allow us to rapidly build
    a functional interface to interact with, in a relatively simple manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跨平台框架允许我们构建一个平台无关的通用界面。虽然TkInter的GUI界面可能看起来不那么现代，但它们让我们能够以相对简单的方式快速构建一个功能性界面进行交互。
- en: We'll only be covering the basics of GUI development with TkInter here. Further
    information can be found online or in books dedicated to the topic that cover
    the development process and specific features related to developing with TkInter
    in more detail. The [https://www.python.org/](https://www.python.org/) website
    has an extensive list of resources for learning and using TkInter at [https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只会介绍TkInter GUI开发的基础知识。有关更详细的信息，可以通过在线资源或专门讲解TkInter开发过程和特定功能的书籍找到。在 [https://www.python.org/](https://www.python.org/) 网站上有一个详细的资源列表，可以学习和使用TkInter，更多信息请见 [https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)。
- en: Basics of TkInter objects
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TkInter对象的基础知识
- en: 'We''ll use a few different features of TkInter to display our GUI. The first
    item every TkInter GUI needs is a root window, also known as the master, which
    acts as the top-level parent to any other items we add to the GUI. Within this
    window, we''ll combine several objects that allow the user to interact with our
    interface, such as the `Label`, `Entry`, and `Button` items:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TkInter的几个不同功能来展示我们的GUI。每个TkInter GUI需要的第一个元素是根窗口，也叫做主窗口，它作为我们添加到GUI中的任何其他元素的顶级父窗口。在这个窗口中，我们将结合多个对象来允许用户与我们的界面进行互动，例如`Label`、`Entry`和`Button`等元素：
- en: The `Label` object allows us to place text labels that cannot be edited on the
    interface. This allows us to add titles or provide a description for objects that
    indicate what should be written to or displayed in the field.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`对象允许我们在界面上放置无法编辑的文本标签。这使得我们可以添加标题或为指示应写入或显示到字段中的对象提供描述。'
- en: The `Entry` object allows the user to enter a single line of text as input to
    the application.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry`对象允许用户输入一行文本作为应用程序的输入。'
- en: The `Button` object allows us to execute commands when pressed. In our case,
    the button will call the appropriate function to convert a timestamp of the specific
    format and update the interface with the returned value.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`对象允许我们在按下时执行命令。在我们的例子中，按钮将调用适当的函数来转换特定格式的时间戳，并使用返回值更新界面。'
- en: Using these three features, we've already introduced all of the GUI elements
    needed for our interface. There're many more objects available for use and they
    can be found in greater detail in the TkInter documentation at [https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个功能，我们已经介绍了界面所需的所有GUI元素。还有更多可用的对象，详细信息可以在TkInter文档中找到，网址为[https://docs.python.org/3/library/tkinter.html](https://docs.python.org/3/library/tkinter.html)。
- en: 'We''ll be writing our code in a way that works with both Python 2 and Python
    3\. For this reason, in Python 2 (for example, version 2.7.15), we''ll import
    `Tkinter` as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以兼容Python 2和Python 3的方式编写代码。因此，在Python 2（例如，版本2.7.15）中，我们将按如下方式导入`Tkinter`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Python 3, for example, version 3.7.1, we''ll instead import it as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 3，例如版本3.7.1，我们将按如下方式导入：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To condense this, we can instead use the `sys` module to detect the Python
    version and import the proper module, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，我们可以使用`sys`模块来检测Python版本并导入相应的模块，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing the TkInter GUI
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现TkInter GUI
- en: This section illustrates a simple example of creating a TkInter GUI. In the
    first seven lines, we import the two modules we'll need to create our interface.
    This import method, while complex, allows us to import these two modules in a
    Python 2- or Python 3-specific way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了一个创建TkInter GUI的简单示例。在前七行中，我们导入了创建界面所需的两个模块。这种导入方式虽然复杂，但可以让我们以Python 2或Python
    3特定的方式导入这两个模块。
- en: The first module imports all of the default objects needed for the TkInter GUI
    design. The `ttk` module imports the themed TkInter pack, which applies additional
    formatting to the interface depending on the host operating system and is a simple
    way to improve the overall look of our interface. In the last line, we create
    our root window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模块导入了所有TkInter GUI设计所需的默认对象。`ttk`模块导入了主题TkInter包，根据主机操作系统应用额外的界面格式化，是改善界面外观的简单方法。在最后一行，我们创建了根窗口。
- en: 'When typed into a Python interpreter, the execution of the last line should
    display a blank 200 pixel × 200 pixel square window in the top-left of your screen.
    The dimensions and location are a default setting that can be modified. See the
    following code block:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Python解释器中输入时，执行最后一行应显示一个空白的200像素×200像素的方形窗口，位于屏幕的左上角。尺寸和位置是默认设置，可以修改。请参见以下代码块：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot displays a TkInter root window created when executing
    the code block on a macOS system:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在macOS系统上执行代码块时创建的TkInter根窗口：
- en: '![](img/a0086a92-5426-4b23-b56e-a362f2462909.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0086a92-5426-4b23-b56e-a362f2462909.png)'
- en: 'With the root window created, we can begin to add items to the interface. A
    good first item is a label. In the code block mentioned later, we add a label
    from the themed `ttk` pack to the window:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建根窗口后，我们可以开始向界面添加元素。一个好的开始元素是标签。在后面提到的代码块中，我们将从主题`ttk`包中添加一个标签到窗口：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Label` parameter requires two arguments: the parent window it should be
    displayed on and the text to display. Additional attributes can be assigned to
    the label such as fonts and text size.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label` 参数需要两个参数：要显示的父窗口和显示的文本。可以为标签分配其他属性，如字体和文本大小。'
- en: Note that, after executing the first line of the code block, the window doesn't
    update. Instead, we must specify how we want to display the object within the
    window with one of the available geometry managers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在执行代码块的第一行后，窗口不会更新。相反，我们必须指定如何在窗口内显示对象，使用其中一个可用的布局管理器。
- en: 'TkInter uses geometry managers to determine the placement of objects within
    the window. There''re three common managers: `grid`, `pack`, and `place`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TkInter 使用布局管理器来确定对象在窗口中的位置。常见的布局管理器有三种：`grid`、`pack` 和 `place`。
- en: The `grid` geometry manager places elements based on a row and column specification
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid` 布局管理器根据行和列的规范来放置元素。'
- en: The `pack` geometry manager is simpler and will place elements next to each
    other, either vertically or horizontally depending on a specified configuration
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack` 布局管理器更简单，它将元素彼此放置，无论是垂直还是水平，具体取决于指定的配置。'
- en: Finally, the `place` geometry manager uses *x* and *y* coordinates to place
    elements and requires the most effort to maintain and design
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`place` 布局管理器使用 *x* 和 *y* 坐标来放置元素，并且需要最多的维护和设计工作。
- en: 'For this example, we chose to use the `pack` method as seen on the second line
    of the code block. Once we describe which geometry manager to use, our interface
    is updated with the label:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们选择使用 `pack` 方法，如代码块的第二行所示。一旦我们描述了要使用的布局管理器，界面会更新，并显示标签：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot reflects the addition of the label to our GUI:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了将标签添加到我们的 GUI 中的效果：
- en: '![](img/56703f87-63e8-455d-9545-db2801e8fd93.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56703f87-63e8-455d-9545-db2801e8fd93.png)'
- en: As seen in the preceding screenshot, the root window has shrunk to fit the size
    of its elements. At this point, we can resize the window by dragging the edges
    to shrink or grow the size of the main window.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，根窗口已经缩小以适应其元素的大小。此时，我们可以通过拖动边缘来调整窗口的大小，缩小或增大主窗口的尺寸。
- en: Let's add some space around our `Label` object. We can accomplish this by using
    two different techniques. The first adds padding around the `Label` object, using
    the `.config()` method. To add padding, we must provide a tuple of padding, in
    pixels, for the *x* and *y* axis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Label` 对象周围添加一些空间。我们可以通过两种不同的技术来实现。第一种方法是在 `Label` 对象周围添加内边距，使用 `.config()`
    方法。为了添加内边距，我们必须为 *x* 和 *y* 轴提供一个像素值的元组。
- en: 'In the example, we add a 10-pixel padding on both the *x* and *y *axes. When
    the following line is executed, it''ll automatically update in the GUI since the
    geometry manager is already configured:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们在 *x* 和 *y* 轴上都添加了 10 像素的内边距。当执行以下行时，它会在 GUI 中自动更新，因为布局管理器已经配置好：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The padding is shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内边距显示在以下截图中：
- en: '![](img/4f642c0a-eec7-4b71-9fe7-1580d538c3a2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f642c0a-eec7-4b71-9fe7-1580d538c3a2.png)'
- en: This only adds padding around the label itself and not the entirety of the root
    window. To change the dimensions of the root window, we need to call the `geometry()`
    method and provide the width, height, position from the left of the screen, and
    position from the top of the screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是为标签本身添加了内边距，而不是整个根窗口。要更改根窗口的尺寸，我们需要调用 `geometry()` 方法，并提供宽度、高度、距离屏幕左侧的距离和距离屏幕顶部的距离。
- en: 'In the following example, we''ll set the dimensions to 200 pixels wide by 100
    pixels high with an offset 30 pixels from the left of the screen and 60 pixels
    from the top of the screen:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将设置宽度为 200 像素，高度为 100 像素，距离屏幕左侧 30 像素，距离屏幕顶部 60 像素的偏移量：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The new resolution of the GUI is displayed in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 GUI 分辨率显示在以下截图中：
- en: '![](img/5eb7c94c-cbb8-4383-a1bb-fda167e633bc.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eb7c94c-cbb8-4383-a1bb-fda167e633bc.png)'
- en: Depending on your operating system, the default colors within the GUI may vary
    due to the available theme packs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统，GUI 中的默认颜色可能会因可用的主题包而有所不同。
- en: 'Let''s introduce the other two GUI elements we''ll use, `Entry` and `Button`.
    We''ll now initialize the `Entry` object, which will allow a user to enter text
    that we can capture and use in the program. In the first line, we initialize a
    `StringVar()` variable, which we''ll use with the `Entry` object. Unlike prior
    scripts, we need to set up special variables that can respond to the event-driven
    nature of GUI interfaces:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一下其他两个我们将使用的GUI元素：`Entry`和`Button`。现在我们将初始化`Entry`对象，它允许用户输入文本，程序可以捕获并使用这些文本。在第一行中，我们初始化了一个`StringVar()`变量，它将与`Entry`对象一起使用。与之前的脚本不同，我们需要设置特定的变量，以响应GUI接口的事件驱动特性：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'TkInter supports a variety of special variables such as the `StringVar()` function
    for strings, `BooleanVar()` for Booleans, `DoubleVar()` for floats, and `IntVar()`
    for integers. Each of these objects allows for values to be set using the `set()`
    method and retrieved using the `get()` method. The preceding code shows the initialization
    of the `StringVar()`, setting it to a default value, assigning it to a created
    `Entry` element, and packing it into the root window. Finally, we can gather the
    input from the user via the `get()` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TkInter支持多种特殊变量，例如用于字符串的`StringVar()`函数、用于布尔值的`BooleanVar()`、用于浮动数值的`DoubleVar()`，以及用于整数的`IntVar()`。每个这些对象都允许通过`set()`方法设置值，并通过`get()`方法获取值。上述代码展示了`StringVar()`的初始化，将其设置为默认值，并将其分配给创建的`Entry`元素，然后将其打包到根窗口中。最后，我们可以通过`get()`方法获取用户输入：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following two consecutive screenshots show the updates to the GUI with
    the new code block we''ve implemented:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个连续的截图展示了我们实现的新代码块对GUI的更新：
- en: '![](img/b04742d7-c0c7-40c1-a53e-af9e54bc8f45.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b04742d7-c0c7-40c1-a53e-af9e54bc8f45.png)'
- en: 'The preceding screenshot shows the default text in the `Entry` box, whereas
    the following screenshot shows what it looks like with modified values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图展示了`Entry`框中的默认文本，而下面的截图展示了修改值后的样子：
- en: '![](img/a7d2b484-88fd-4073-8c3f-bfe05ce16828.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7d2b484-88fd-4073-8c3f-bfe05ce16828.png)'
- en: Please note that we wrote `Hello World!` into the `Entry` object before executing
    the `text.get()` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在执行`text.get()`方法之前，将`Hello World!`写入了`Entry`对象中。
- en: The `Button` object is used to initiate an event when the button is clicked.
    To set an action into motion, we need a function to call.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`对象用于在点击按钮时触发事件。为了启动操作，我们需要调用一个函数。'
- en: 'In the next example, we define the `clicked()` function, which prints a string
    as seen in the following code block. After this function, we define the button
    using the `ttk` theme pack, setting the button text to `Go` and the `command`
    parameter of the function name. After packing the button into the root window,
    we can click on it and see the statement printed in the Terminal, as seen on the
    last line of our following code block. Although this functionality isn''t very
    useful, it demonstrates how a button calls an action. Our script will demonstrate
    further uses for the `Button` object and its command parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们定义了`clicked()`函数，它会打印一个字符串，如以下代码块所示。在这个函数之后，我们使用`ttk`主题包定义了按钮，将按钮文本设置为`Go`，并将函数名作为`command`参数。将按钮打包到根窗口后，我们可以点击它，并在终端中看到打印的语句，如下面代码块的最后一行所示。虽然这个功能不是非常实用，但它演示了按钮如何调用一个操作。我们的脚本将进一步展示`Button`对象及其命令参数的用途：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The addition of this button is shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此按钮的效果如下截图所示：
- en: '![](img/f2fb6d53-b7d4-447c-b330-e65f5996d548.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2fb6d53-b7d4-447c-b330-e65f5996d548.png)'
- en: Using frame objects
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架对象
- en: TkInter provides another object we'll use named `frame`. Frames are containers
    we can place information in and that and provide additional organization. We'll
    have two frames in our final interface. The first is an input frame containing
    all of the objects that a user will interact with, and the second is our output
    frame that will display all of the information processed by the script. In the
    final code of this chapter, the two `frame` objects will be children to the root
    window and act as parents to the `Label`, `Entry`, and/or `Button` objects within
    them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TkInter提供了另一个我们将使用的对象，名为`frame`。框架是我们可以放置信息的容器，它提供了额外的组织结构。在我们的最终界面中，将有两个框架。第一个是输入框架，包含所有用户交互的对象；第二个是输出框架，显示脚本处理的所有信息。在本章的最终代码中，两个`frame`对象将是根窗口的子对象，并充当其中`Label`、`Entry`和/或`Button`对象的父对象。
- en: Another benefit of the `frame` object is that each one can use its own geometry
    manager. Since each parent object can use only a single geometry manager, this
    allows us to leverage several different managers within our overall GUI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame`对象的另一个好处是，每个框架可以使用自己的几何管理器。由于每个父对象只能使用一个几何管理器，这使得我们可以在整个GUI中使用多个不同的管理器。'
- en: In our script, we'll use the `pack()` manager to organize the frames in the
    root window and the `grid()` manager to organize elements within each frame.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将使用`pack()`管理器来组织根窗口中的框架，并使用`grid()`管理器来组织每个框架内的元素。
- en: Using classes in TkInter
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TkInter中使用类
- en: We're yet to directly use classes in this book; however, it's the preferred
    way to design a GUI. A class allows us to build an object that can hold functions
    and attributes. In fact, we've often used classes without knowing it. Objects
    we're familiar with, such as `datetime` objects, are classes that contain functions
    and attributes available to them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们尚未直接使用类；然而，类是设计GUI的首选方式。类允许我们构建一个可以包含函数和属性的对象。事实上，我们经常在不自觉中使用类。我们熟悉的对象，如`datetime`对象，就是包含函数和属性的类。
- en: Classes, despite not being featured heavily in this book, may confuse new developers
    but are recommended for more advanced scripts. We'll briefly cover classes in
    this chapter and recommend further research into classes as your understanding
    of Python grows. The items we cover with classes are specific to the GUI example
    in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中类的内容并不多，但它们可能会让新开发者感到困惑，但对于更高级的脚本来说，它们是推荐的。我们将在本章简要介绍类，并建议随着你对Python的理解加深，进一步研究类。本章中涉及的类内容仅限于GUI示例。
- en: A class is defined with a similar syntax to a function, where we use the `class`
    keyword in lieu of `def`. Once defined, we nest functions inside the `constructor`
    class to make these functions callable from a `class` object. These nested functions
    are called methods and are synonymous with the methods we have called from libraries.
    A method allows us to execute code just like a function. We have primarily, up
    to this point, used the terms method and function interchangeably. We apologize;
    this was done so as to not bore you and ourselves with the same word over and
    over again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义语法与函数类似，我们使用`class`关键字代替`def`。一旦定义类，我们将函数嵌套在`constructor`类中，以使这些函数可以通过`class`对象调用。这些嵌套的函数称为方法，与我们从库中调用的方法是同义的。方法允许我们像函数一样执行代码。到目前为止，我们主要是将方法和函数交替使用。对此我们表示歉意，这样做是为了避免让你和我们都厌烦重复相同的词汇。
- en: So far, classes sound like nothing more than a collection of functions. So what
    gives? The true value of a class is that we can create multiple instances of the
    same class and assign separate values to each instance. To further extend this,
    we can run our predefined methods on each instance separately. Say, for example,
    we have a time class where each time has an associated `datetime` variable. Some
    of these we may decide to convert into UTC while leaving others in their current
    time zone. This isolation is what makes designing code within a class valuable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，类看起来不过是函数的集合。那么到底是什么原因呢？类的真正价值在于，我们可以创建同一个类的多个实例，并为每个实例分配不同的值。进一步来说，我们可以对每个实例单独运行预定义的方法。举个例子，假设我们有一个时间类，其中每个时间都有一个关联的`datetime`变量。我们可能决定将其中一些转换为UTC时间，而将其他保持在当前时区。这种隔离性使得在类中设计代码变得非常有价值。
- en: Classes are great for GUI design because they allow us to pass values across
    functions without additional duplicative arguments. This is accomplished with
    the `self` keyword, which allows us to specify values within a class that're portable
    within the class instance and all of its methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类在GUI设计中非常有用，因为它们允许我们在函数之间传递值，而不需要额外的重复参数。这是通过`self`关键字实现的，它允许我们在类中指定可在类实例及其所有方法中使用的值。
- en: In the next example, we create a class, named `SampleClass`, which inherits
    from the object. This is the basic setup for a class definition, and while there
    are more parameters available, we'll focus on the basics for this chapter. On
    line 2, we define our first method named, `__init__()`, which is a special function.
    You may notice that it has double leading and trailing underscores like the `if
    __name__ == '__main__'` statements we have created in our scripts. If an `__init__()`
    method exists within a class, it'll be executed at the initialization of the class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们创建了一个名为`SampleClass`的类，它继承自`object`。这是类定义的基本设置，虽然还有更多可用的参数，但我们将在本章中专注于基础内容。在第2行，我们定义了第一个名为`__init__()`的方法，这是一个特殊的函数。你可能会注意到，它有双前导和尾部下划线，类似于我们在脚本中创建的`if
    __name__ == '__main__'`语句。如果类中存在`__init__()`方法，它将在类初始化时执行。
- en: 'In the example, we define the `__init__()` method, passing `self` and `init_cost`
    as arguments. The `self` argument must be the first argument of any method and
    allows us to reference the values stored under the keyword, `self`. Following
    this, `init_cost` is a variable that must be set when the class is first called
    by the user. On line 3, we assign the value of the user-provided `init_cost` to
    `self.cost`. It''s a convention to assign arguments (besides `self`) for class
    instantiation into class variables. On line 4, we define the second method, `number_of_nickels()`,
    and pass the `self` value as its only argument. On line 5, we complete the class
    by returning an integer of `self.cost * 20`, as shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们定义了`__init__()`方法，传递`self`和`init_cost`作为参数。`self`参数必须是任何方法的第一个参数，并允许我们引用存储在`self`关键字下的值。接下来，`init_cost`是一个变量，必须在类首次被用户调用时设置。在第3行，我们将用户提供的`init_cost`值赋给`self.cost`。将参数（除了`self`）赋值为类实例化时的类变量是一种惯例。在第4行，我们定义了第二个方法`number_of_nickels()`，并将`self`值作为其唯一参数。在第5行，我们通过返回`self.cost
    * 20`的整数来完成类的定义，如下所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we initialize `s1` as an instance of our `SampleClass` class with the
    initial value of `24.60`. Then, we call its value by using the `s1.cost` attribute.
    The `s1` variable refers to an instance of `SampleClass` and grants us access
    to the methods and values within the class. We call the `number_of_nickels()`
    method on `s1` and change its stored value to `15`, which updates the results
    of the `number_of_nickels()` method. Next, we define `s2` and assign a different
    value to it. Even though we run the same methods, we''re only able to view the
    data in relation to the specific class instance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`s1`初始化为`SampleClass`类的一个实例，并将初始值设置为`24.60`。然后，我们通过使用`s1.cost`属性来调用它的值。`s1`变量引用了`SampleClass`的一个实例，并授予我们访问类内方法和值的权限。我们在`s1`上调用`number_of_nickels()`方法，并将其存储的值更改为`15`，这会更新`number_of_nickels()`方法的结果。接着，我们定义了`s2`并为其分配了不同的值。即使我们运行相同的方法，我们也只能查看与特定类实例相关的数据：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Developing the date decoder GUI – date_decoder.py
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发日期解码器GUI - date_decoder.py
- en: 'This script was tested in both Python 2.7.15 and 3.7.1 and uses the python-dateutil
    (version 2.7.5) third-party library which can be installed with `pip` like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本已在Python 2.7.15和3.7.1版本中进行了测试，并使用了`python-dateutil`（版本2.7.5）第三方库，可以通过以下命令使用`pip`进行安装：
- en: '`pip install python-dateutil==2.7.5`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install python-dateutil==2.7.5`'
- en: After this introduction to timestamps, GUI development, and Python classes,
    let's begin developing our `date_decoder.py` script. We'll design a GUI with two
    primary functionalities that the end user will interact with.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完时间戳、GUI开发和Python类之后，让我们开始开发`date_decoder.py`脚本。我们将设计一个具有两个主要功能的GUI，供最终用户进行交互。
- en: First, the GUI allows the user to enter a timestamp from an artifact in native
    format and convert it into a human-readable time. The second feature allows the
    user to enter a human-readable timestamp and select an option to convert it into
    the respective machine time. To build this, we'll use an entry box, several labels,
    and different types of button for the user to interact with the interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，GUI允许用户输入来自文物的时间戳原生格式，并将其转换为人类可读的时间。第二个功能允许用户输入人类可读的时间戳，并选择一个选项将其转换为相应的机器时间。为了构建这个功能，我们将使用一个输入框、几个标签以及不同类型的按钮供用户与界面进行交互。
- en: All dates processed with this code assume local machine time for the time zone.
    Please ensure you convert all timestamp sources into a uniform time zone to simplify
    the analysis.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通过此代码处理的日期都假定使用本地机器时间作为时区。请确保将所有时间戳来源转换为统一的时区，以简化分析。
- en: 'As with our other scripts, this code starts with our import statements followed
    by authorship details. After importing `datetime` and `logging`, we import TkInter and
    theme resource modules using our Python 2 and Python 3 conditional. We then import
    `dateutil`, which, as discussed, will handle date interpretation and conversion
    operations. We then set up our script license, documentation, and logging values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他脚本一样，代码从导入语句开始，后跟作者信息。在导入`datetime`和`logging`之后，我们根据Python 2和Python 3的条件导入TkInter和主题资源模块。然后我们导入`dateutil`，正如之前讨论的，它将处理日期解析和转换操作。接着我们设置脚本的许可协议、文档和日志记录值：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We begin by defining the properties of our GUI, such as the dimensions, background,
    and title of the window, and create the root window. After configuring the base
    of the GUI, we populate our GUI with the desired widgets we've discussed. Once
    we've designed the interface, we create methods to handle events, such as converting
    timestamps and showing the results in the GUI. Instead of our typical `main()`
    functions, we instead create an instance of this class that'll launch the GUI
    window when executed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了GUI的属性，如窗口的尺寸、背景和标题，并创建了根窗口。在配置完GUI的基础设置后，我们用之前讨论的控件填充GUI。界面设计完成后，我们创建处理事件的方法，如转换时间戳并将结果显示在GUI中。我们没有使用通常的`main()`函数，而是创建了这个类的实例，它将在执行时启动GUI窗口。
- en: 'Our code starts with the declaration of our `DateDecoder` class and its `__init__()`
    method. This method doesn''t require any parameters to be passed by the user since
    we''ll be accepting all of our input values and settings through the GUI. The
    next function we define will be our `run()` controller on line 74\. This controller
    calls functions that design the GUI and then launches the said GUI:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从声明`DateDecoder`类及其`__init__()`方法开始。该方法不需要传递任何参数，因为我们将通过GUI接收所有输入值和设置。接下来定义的函数是第74行的`run()`控制器。这个控制器调用设计GUI的函数，并启动该GUI：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To display the GUI in a structured manner, we need to divide our GUI into functional
    units. With the methods on lines 84 and 119, we create our input and output frames
    that make up our GUI. These frames contain widgets pertinent to their action and
    are governed by their own geometry:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以结构化的方式展示GUI，我们需要将GUI分成多个功能单元。在第84和119行的方法中，我们创建了组成GUI的输入和输出框架。这些框架包含与其功能相关的控件，并且由自己的几何布局控制：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the design of our interface established, we can focus on the functions
    that handle logic operations and events when buttons are clicked. The `convert()`
    method is used to call timestamp converters to interpret the value as a date.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 界面设计完成后，我们可以专注于处理逻辑操作和按钮点击事件的功能。`convert()` 方法用于调用时间戳转换器，将值解析为日期。
- en: 'These converters are specific to each of the supported timestamps and are defined
    on lines 175, 203, and 239\. Our last class method, `output()`, is used to update
    the interface. This may be misleading as the previous `output()` functions in
    our scripts have generally created some kind of report. In this case, we''ll be
    using our output function to update the GUI with our results, to display the information
    to the user in an organized and helpful manner:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些转换器是针对每个受支持的时间戳定义的，定义在第175、203和239行。我们的最后一个类方法`output()`用于更新界面。这个方法可能会让人误解，因为我们脚本中的之前的`output()`函数通常会创建某种报告。在这个例子中，我们将使用这个`output()`方法来更新GUI，向用户展示信息，以一种有组织且有帮助的方式：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unlike in previous chapters, this function has no need to handle command-line
    arguments. We do, however, still set up logging and then instantiate and run our
    GUI. In addition, starting on line 202, we initialize a logger using our basic
    logging convention. We hard-code the path to the log file as no command-line arguments
    are passed to this script. On lines 211 and 212, the class is initialized and
    then the `run()` method is called in order for our GUI to be created and displayed
    to the user, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章不同，这个函数不需要处理命令行参数。然而，我们仍然设置了日志记录，并实例化并运行我们的图形用户界面（GUI）。此外，从第202行开始，我们使用基本的日志记录约定初始化一个日志记录器。由于没有传递命令行参数给该脚本，我们将日志文件路径硬编码。在第211和212行，初始化类并调用`run()`方法，以便创建并显示我们的GUI，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ve split our flowchart into two screenshots, due to its width. The first
    screenshot shows the flow for setting up the `DateDecoder` class and the initial
    `run()` call, which creates our frames:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流程图过宽，我们将其拆分为两张截图。第一张截图展示了设置`DateDecoder`类和初始`run()`调用的流程，后者创建了我们的框架：
- en: '![](img/8c62754e-4882-4165-86cb-6b51cd050f3b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c62754e-4882-4165-86cb-6b51cd050f3b.png)'
- en: 'The second screenshot displays the flow for the operational code, where our
    converter function calls the specific time-converting function and then our `output()`
    function to display it to the user:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张截图显示了操作代码的流程，其中我们的转换函数调用特定的时间转换函数，然后调用我们的`output()`函数将其显示给用户：
- en: '![](img/c1d70252-399a-49d3-b824-6e25463917ac.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d70252-399a-49d3-b824-6e25463917ac.png)'
- en: The DateDecoder class setup and __init__() method
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DateDecoder 类的设置和`__init__()`方法
- en: 'We initialize our class using the `class` keyword, followed by the class name,
    and passing the `object` argument as seen on line 49\. It''s best practice to
    name classes using the camelCase convention and methods with underscores to prevent
    confusion. On line 50, we define the `__init__()` special method described earlier
    with only the `self` parameter. This class doesn''t require any user input at
    initialization, so we don''t need to concern ourselves with adding additional
    arguments. Take a look at the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`class`关键字初始化我们的类，后跟类名，并将`object`参数作为第49行所示的参数传递。最佳实践是使用 camelCase 约定命名类，并使用下划线命名方法以避免混淆。在第50行，我们定义了前面描述的`__init__()`特殊方法，只有`self`参数。此类在初始化时不需要任何用户输入，因此我们不需要考虑添加额外的参数。请看以下代码：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On line 60, we create the root window of the GUI and assign it to a value within
    the `self` object. This allows us to reference it and any other object created
    with `self` in other methods within the class without needing to pass it as an
    argument, since the `self` parameter stores values for use throughout the class
    instance. On line 61, we define the size of the window as 500 pixels wide, 180
    pixels high, and offset by 40 pixels on both the top and left sides of the screen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第60行，我们创建了 GUI 的根窗口，并将其赋值给`self`对象内的一个值。这使我们能够在类中的其他方法中引用它和使用`self`创建的任何其他对象，而无需将其作为参数传递，因为`self`参数存储了整个类实例中可用的值。在第61行，我们定义了窗口的大小，宽度为500像素，高度为180像素，并在屏幕的顶部和左侧各偏移了40像素。
- en: 'To improve the look of the interface, we''ve added the background color to
    reflect the theme shown on macOS, though this can be set to any hexadecimal color
    as seen on line 62\. Finally, we modify the title property of the root, giving
    it a name that displays on top of the GUI''s window:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善界面的外观，我们已经添加了背景颜色以反映 macOS 上显示的主题，尽管这可以设置为任何十六进制颜色，如第62行所示。最后，我们修改了根窗口的标题属性，给它一个显示在
    GUI 窗口顶部的名称：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the initial GUI definition, we need to set the base values for important
    variables. While this isn''t required, it''s often best practice to create shared
    values in the `__init__()` method and define them with default values. After we
    define three class variables that will store our processed time values, we also
    define the epoch constants for 1601- and 1970-based timestamps. The code is as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 GUI 定义之后，我们需要为重要变量设置基础值。虽然这不是必需的，但通常最好的做法是在`__init__()`方法中创建共享值，并使用默认值定义它们。在定义将存储我们处理过的时间值的三个类变量后，我们还定义了基于1601年和1970年的时间戳的时代常量。代码如下：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `__init__()` method should be used to initialize of class attributes. In
    some situations, you may want this class to also run the primary operations of
    the class, but we'll not be implementing that functionality in our code. We separate
    the runtime operations into a new method named `run()` to allow us to start operations
    specific to running the main code. This allows users to change class configuration
    information before launching GUI.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法应该用于初始化类属性。在某些情况下，您可能希望该类还运行类的主要操作，但我们不会在我们的代码中实现该功能。我们将运行时操作分离到一个名为`run()`的新方法中，以允许我们启动特定于运行主代码的操作。这允许用户在启动
    GUI 之前更改类配置信息。'
- en: Executing the run() method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 run() 方法
- en: 'The following method is very short, consisting of function calls to other methods
    we''ll discuss shortly. This includes building the input and output frames for
    the GUI and starting the main event listener loop. Because the class has already
    initialized the variables found in the `__init__()` method, we can reference these
    objects in a safe manner as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法非常简短，由对我们稍后讨论的其他方法的函数调用组成。这包括为 GUI 构建输入和输出帧以及启动主事件监听器循环。由于类已经初始化了`__init__()`方法中找到的变量，我们可以安全地引用这些对象，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing the build_input_frame() method
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 build_input_frame() 方法
- en: 'The `build_input_frame()` method is the first instance of the `frame` widget
    and is defined on lines 90 through 92\. In a similar manner to how we defined
    this element in an earlier example, we call the themed `frame` widget and pass
    the `self.root` object as the parent window for this frame. On line 91, we add
    `30` pixels of padding along the *x *axis around the frame before using the `pack()`
    geometry manager on line 92\. Because we can only use one geometry manager per
    window or frame, we must now use the `pack()` manager on any additional frames
    or widgets added to the `root` object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_input_frame()`方法是`frame`小部件的第一次实例化，定义在第90到92行。与我们在早期示例中定义此元素的方式类似，我们调用了主题化的`frame`小部件，并将`self.root`对象作为此框架的父级窗口。在第91行，我们在框架的*X*轴周围添加了`30`像素的填充，然后在第92行使用`pack()`几何管理器。由于每个窗口或框架只能使用一个几何管理器，因此我们现在必须在添加到`root`对象的任何附加框架或小部件上使用`pack()`管理器：'
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After creating the frame, we begin to add widgets to the frame for the user
    input. On line 95, we create a label using the new `input_frame` as the parent,
    with the text, `Enter Time Value`. This label is placed on the first row and column
    of the grid. With the grid manager, the first location will be the top-left location
    and all other elements will fit around it. Because we don''t have any need to
    call this label at a later point, we don''t assign it to a variable and can call
    the `.grid()` method immediately to add it to our GUI:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建框架后，我们开始向框架中添加小部件以供用户输入。在第95行，我们使用新的`input_frame`作为父级创建一个标签，文本为`Enter Time
    Value`。此标签被放置在网格的第一行和第一列。使用网格管理器时，第一个位置将是左上角位置，其他所有元素将围绕它布局。由于我们之后不需要调用这个标签，所以不将其分配给变量，而是可以直接调用`.grid()`方法将其添加到我们的GUI中：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On line 98, we initialize `StringVar()`, which we use to store the input from
    the user as a string. We'll need to reference this object and information throughout
    our code, so we'll want this to be assigned to the object, `self.input_time`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第98行，我们初始化`StringVar()`，该变量用于存储用户输入的字符串。我们将在代码的各个地方引用此对象和信息，因此希望将其分配给对象`self.input_time`。
- en: 'On line 99 we create another widget, this time `Entry`, and once again will
    not assign it to a variable since we''ll not need to manipulate this element after
    creation. The information we''ll need from this element will be stored in the
    `self.input_time` variable. To instruct the `Entry` object to store the values
    in this object, we must pass the object name as the `textvariable` parameter.
    We also specify the width of the field as 25 characters, add it to the GUI with
    the `grid()` call, and place it one column over from the label:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第99行，我们创建另一个小部件，这次是`Entry`，并且同样不将其分配给变量，因为在创建后我们不需要操作该元素。我们需要从该元素获取的信息将存储在`self.input_time`变量中。为了指示`Entry`对象将值存储在此对象中，我们必须将对象名称作为`textvariable`参数传递。我们还将字段的宽度指定为25个字符，使用`grid()`方法将其添加到GUI中，并将其放置在标签的下一列：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Following the creation of the input area, we must provide the user with options
    for specifying the input type. This allows the user to select whether the source
    is a machine-readable or human-readable format. We create another `StringVar()`
    variable to hold the value of the user's selection.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建输入区域后，我们必须为用户提供选项，以便指定输入类型。这使得用户可以选择源是机器可读格式还是人类可读格式。我们创建另一个`StringVar()`变量来保存用户选择的值。
- en: Since we want the default action to convert raw timestamps into formatted ones,
    we call the `set()` method on the `self.time_type` variable on line 104 to auto-select
    the `raw` radio button created on line 106.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望默认操作是将原始时间戳转换为格式化时间戳，我们在第104行调用`set()`方法，在`self.time_type`变量上自动选择第106行创建的`raw`单选按钮。
- en: 'On line 106, we create the first radio button, passing the input frame as the
    parent, the radio button label set to `Raw Value`, and the variable that''ll reflect
    whether the user has selected the radio button or not to `self.time_type`. Finally,
    we display this button using the grid manager. On line 110, we create the second
    radio button whose text and value are set to reflect the formatted timestamp input.
    In addition, we place this radio button on the same row in the adjacent column
    as the first radio button. Take a look at the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第106行，我们创建第一个单选按钮，将输入框架作为父级，单选按钮标签设置为`Raw Value`，并将反映用户是否选择了该单选按钮的变量设置为`self.time_type`。最后，我们使用网格管理器显示此按钮。在第110行，我们创建第二个单选按钮，文本和值设置为反映格式化的时间戳输入。此外，我们将此单选按钮放置在与第一个单选按钮相邻的同一行的列中。请查看以下代码：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we build the button used to submit the data from the `Entry` field
    for processing. This button setup is similar to the other widgets with the addition
    of the command keyword, which, when clicked, executes the specified method. We
    then assign the `convert()` method as the button click action.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建用于提交来自 `Entry` 字段的数据进行处理的按钮。该按钮的设置与其他小部件类似，唯一不同的是添加了 `command` 关键字，当按钮被点击时，它会执行指定的方法。然后，我们将
    `convert()` 方法分配为按钮的点击动作。
- en: 'This method is started without any additional arguments supplied, as they''re
    stored within the `self` property. We add this element to the interface via the
    grid manager, using the `columnspan` attribute to have the information spread
    across two or more columns. We also use the `pady` (pad *y*) attribute to provide
    some vertical space between the input field and the button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在没有额外参数的情况下启动，因为它们被存储在 `self` 属性中。我们通过网格管理器将此元素添加到界面中，使用 `columnspan` 属性将信息跨越两个或更多列。我们还使用
    `pady`（垂直间距）属性在输入字段和按钮之间提供一些垂直空间：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Creating the build_output_frame() method
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `build_output_frame()` 方法
- en: 'The output frame design is similar to that of the input frame. One difference
    is that we''ll need to save the widgets to variables to ensure that we can update
    them as we process date values. After the definition of the method and docstring,
    we create `output_frame` and configure the height and width of the frame. Because
    we used the `pack()` manager for the root, we must continue to use it to add this
    frame to the root windows of the GUI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出框架的设计类似于输入框架。不同之处在于，我们需要将小部件保存到变量中，以确保在处理日期值时可以更新它们。在方法和文档字符串定义之后，我们创建 `output_frame`
    并配置框架的高度和宽度。因为我们在根窗口中使用了 `pack()` 管理器，所以必须继续使用它将该框架添加到 GUI 的根窗口中：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After initialization, we add various widgets to `output_frame`. All of the output
    widgets are labels as they allow us to easily display a string value to the user
    without additional overhead. Another method for accomplishing this task would
    be to place the output in text entry boxes and mark them as read-only. Alternatively,
    we could create a single large text area for easy copying by the user. Both of
    these are challenges specified at the end of this chapter for additional experimentation
    on your own GUI implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化之后，我们向 `output_frame` 添加各种小部件。所有输出小部件都是标签，因为它们允许我们轻松地向用户显示字符串值，而不会增加额外的负担。完成此任务的另一种方法是将输出放入文本输入框中并将其标记为只读。或者，我们可以创建一个大型文本区域，方便用户复制。两者都是本章末尾指定的挑战，供您在自己的
    GUI 实现中进行更多实验。
- en: 'The first label element is titled `Conversion Results`, and is centered using
    the `pack(fill=X)` method on line 134\. This fills the area along the *x *axis
    and stacks all packed sibling elements vertically. After creating the label on
    line 131, we configure the font size using the `config()` method and pass a tuple
    to the `font` keyword. This argument expects the first element to be a font name
    and the second a font size. By omitting the font name, we leave it as the default
    and modify only the size:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标签元素名为 `转换结果`，并通过 `pack(fill=X)` 方法在第 134 行居中。此方法填充 *x* 轴的区域，并垂直堆叠所有已打包的兄弟元素。在第
    131 行创建标签后，我们使用 `config()` 方法配置字体大小，并将一个元组传递给 `font` 关键字。此参数的第一个元素应该是字体名称，第二个元素是字体大小。如果省略字体名称，我们将保留默认字体，并仅修改大小：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following three labels represent the results for each of the supported
    timestamps. All three use the output frame as their parent window and set their
    text to reflect the timestamp type and the default `N/A` value. Finally, each
    of the labels calls the `pack(fill=X)` method to properly center and stack the
    values within the frame. We must assign these three labels to variables so we
    can update their values to reflect the converted timestamps after processing.
    The labels are set here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个标签代表支持的每个时间戳的结果。所有三个标签都将输出框架作为它们的父窗口，并将其文本设置为反映时间戳类型以及默认的 `N/A` 值。最后，每个标签都调用
    `pack(fill=X)` 方法，以便在框架内正确居中和垂直排列值。我们必须将这三个标签分配给变量，以便在处理后更新它们的值，反映转换后的时间戳。标签在此处设置：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Building the convert() method
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 `convert()` 方法
- en: 'Once the user clicks on the button in the input frame, the `convert()` method
    is called. This method is responsible for validating the input, calling the converters,
    and writing the results to the labels built in the previous section. This method,
    if you will, replaces what would usually be our `main()` method. After the initial
    definition and docstring, we log the timestamp and format (raw or formatted) provided
    by the user. This helps keep track of any activity and troubleshoot any errors
    that may occur:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击输入框中的按钮，`convert()` 方法就会被调用。这个方法负责验证输入、调用转换器，并将结果写入上一节中构建的标签中。可以说，这个方法替代了通常的
    `main()` 方法。在初步定义和文档字符串之后，我们记录了用户提供的时间戳和格式（原始或格式化）。这有助于跟踪活动并排查可能出现的错误：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, on lines 163 through 165, we reset the values of the three timestamp
    variables to `N/A` to clear any residual values when the application is run again.
    We then call the three methods that handle the timestamp conversion on lines 168
    through 170\. These methods are independent and will update the values for the
    three timestamp parameters without us needing to return any values or pass arguments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第 163 行到第 165 行之间，我们将三个时间戳变量的值重置为 `N/A`，以清除当应用程序重新运行时可能存在的任何残留值。然后，我们在第
    168 行到第 170 行调用了处理时间戳转换的三个方法。这些方法是独立的，它们会更新三个时间戳参数的值，而不需要我们返回任何值或传递参数。
- en: 'As you can see, the `self` keyword really helps to make classes simple by providing
    access to shared class variables. On line 173, we call the `output()` method to
    write the newly converted formats to the GUI:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`self` 关键字确实帮助我们简化了类的定义，因为它提供了访问共享类变量的方式。在第 173 行，我们调用了 `output()` 方法，将新转换的格式写入到图形界面中：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Defining the convert_unix_seconds() method
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 `convert_unix_seconds()` 方法
- en: The Unix timestamp is the most straightforward of the three timestamps that
    we'll convert in this chapter. On lines 175 through 179, we define the method
    and its docstrings before stepping into an `if` statement. The `if` statement
    on line 180 evaluates whether the value of the radio button described earlier
    is equal to the `raw` string or `formatted`. If it's set to `raw`, we'll parse
    the timestamp as a count of seconds since `1970-01-01 00:00:00.0000000`. This
    is relatively simple because this is the epoch used by the `datetime.datetime.fromtimestamp()`
    method. In this case, we only have to convert the input into a float as seen on
    lines 182 and 183 before conversion.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 时间戳是我们在本章中转换的三种时间戳中最直接的一种。在第 175 行到第 179 行之间，我们定义了方法及其文档字符串，然后进入了一个 `if`
    语句。第 180 行的 `if` 语句判断之前描述的单选按钮的值是否等于 `raw` 字符串或 `formatted`。如果设置为 `raw`，我们将解析时间戳为自
    `1970-01-01 00:00:00.0000000` 以来的秒数。这相对简单，因为这是 `datetime.datetime.fromtimestamp()`
    方法使用的纪元。在这种情况下，我们只需将输入转换为浮动数值，如第 182 行和第 183 行所示，再进行转换。
- en: 'Afterward, on lines 183 and 184, we format the newly formed `datetime` object
    as a string in the `YYYY-MM-DD HH:MM:SS` format. The logic on line 182 is wrapped
    in a try-except statement to catch any bugs and report them to the log file and
    to the user interface in a simplified form. This allows us to test each formula
    when a date is entered. Line 188 outlines that the conversion error will be displayed
    when we are unsuccessful in converting the timestamp. This will alert the user
    that there was an error and allow them to determine whether it''s anticipated
    or not:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第 183 行和第 184 行之间，我们将新创建的 `datetime` 对象格式化为 `YYYY-MM-DD HH:MM:SS` 格式的字符串。第
    182 行的逻辑被包裹在一个 try-except 语句中，以捕获任何错误并将其报告到日志文件和用户界面中，以简化的形式显示出来。这使得我们能够在输入日期时测试每个公式。第
    188 行概述了当我们无法成功转换时间戳时，转换错误将被显示出来。这将提醒用户发生了错误，并让他们判断是否是预期的错误。
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the timestamp is a formatted value, we need to first parse the input before
    attempting to convert it into a Unix timestamp, as it may not follow the intended
    format. Once converted by `dateutil.parser`, we can use the predefined epoch object
    to calculate the delta in seconds between the timestamp and epoch on lines 195
    through 197\. If an error occurs, it will be caught as in the prior `if` statement,
    logged, and displayed to the user, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间戳是格式化值，我们首先需要解析输入，然后尝试将其转换为 Unix 时间戳，因为它可能不符合预期格式。一旦通过 `dateutil.parser`
    进行转换，我们就可以使用预定义的纪元对象计算时间戳与纪元之间的秒数差异，如第 195 行到第 197 行所示。如果发生错误，它将像前面的 `if` 语句一样被捕获，记录下来并显示给用户，如下所示：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Conversion using the convert_win_filetime_64() method
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `convert_win_filetime_64()` 方法进行转换
- en: The conversion of Microsoft Windows FILETIME values is a little more complicated
    as it uses the `1601-01-01 00:00:00` value for epoch and counts time since then
    in 100-nanosecond blocks. To properly convert this timestamp, we have to take
    a few extra steps over the previous section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows的FILETIME值的转换稍微复杂一些，因为它使用`1601-01-01 00:00:00`作为纪元，并从那个时间点起以100纳秒为单位计时。为了正确转换这个时间戳，我们需要比前面的部分多进行几个步骤。
- en: This method starts the same as the last, including the `if`-`else` syntax to
    identify the timestamp type. If it's a raw format, we must convert the input from
    a hexadecimal string into a base 10 decimal using the `int(value, 16)` typecast
    seen on lines 210 and 211\. This allows us to tell `int()` to convert a base 16
    value into decimal (base 10). Base 16 values are often referred to as hexadecimal
    values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与上一个方法相同，包含`if`-`else`语法来识别时间戳类型。如果是原始格式，我们必须将输入的十六进制字符串转换为基于10的十进制数，这在第210和211行通过`int(value,
    16)`类型转换实现。这允许我们告诉`int()`将基数为16的值转换为十进制（基数为10）。基数为16的值通常被称为十六进制值。
- en: 'Once converted, the integer is a count of 100-nanosecond groups since the epoch
    so all we have to do is convert the microseconds into a `datetime` value then
    add the epoch `datetime` object. On lines 212 through 214, we use the `datetime.timedelta()`
    method to generate an object that can be used to add to the epoch `datetime`.
    Once the conversion is complete, we need to format the `datetime` object as a
    time string and assign it to the corresponding label. The error handling is the
    same as the prior converter and will display conversion errors as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦转换，整数就表示自纪元以来100纳秒为单位的时间，因此我们所要做的就是将微秒转换为`datetime`值，然后加上纪元的`datetime`对象。在第212到214行，我们使用`datetime.timedelta()`方法生成一个可以用于添加到纪元`datetime`的对象。一旦转换完成，我们需要将`datetime`对象格式化为时间字符串，并将其赋值给相应的标签。错误处理与之前的转换器相同，转换错误将显示如下：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the input timestamp is a formatted value, we need to reverse this conversion.
    We were able to take some shortcuts before on line 212 using the `datetime.timedelta()`
    method. When moving in the other direction, we need to manually calculate the
    microseconds count before converting it into hex.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的时间戳是格式化的值，我们需要反向转换。我们之前在第212行使用`datetime.timedelta()`方法时采取了一些捷径。当反向转换时，我们需要手动计算微秒数，然后再转换为十六进制。
- en: 'First, on line 225, we convert the data from a string into a `datetime` object
    so we can begin to process the values. From here, we subtract the epoch value
    from the converted time. After subtraction, we convert the `datetime.timedelta`
    object into microsecond values from the three stored values. We need to multiply
    the seconds by one million and the days by 86.4 billion to convert each value
    into microseconds. Finally, on lines 229 through 231, we''re almost ready to convert
    our timestamp after adding all three values together:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第225行，我们将数据从字符串转换为`datetime`对象，以便开始处理这些值。然后，我们从转换后的时间中减去纪元值。减法之后，我们将`datetime.timedelta`对象转换为微秒值，基于存储的三个值。我们需要将秒数乘以一百万，将天数乘以864亿，以将每个值转换为微秒。最后，在第229到231行，我们几乎准备好将时间戳转换，经过加和这三个值之后：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On lines 232 and 233, we perform the conversion, by casting the innermost layer,
    `calculated_time`, into an integer. In the integer state, it's multiplied by 10
    to convert into a count of groups of 100 nanoseconds before conversion into hex
    with the `hex()` typecast. Since the code requires the output to be a string,
    we cast the hex value to a string as seen in the outside wrap on line 232 before
    assigning it to the `self.processed_windows_filetime_64` variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第232和233行，我们通过将最内层的`calculated_time`转换为整数来执行转换。在整数状态下，它会乘以10，转换为100纳秒组数，然后通过`hex()`类型转换将其转换为十六进制。由于代码要求输出为字符串，我们将十六进制值转换为字符串，如第232行的外部包装所示，然后将其赋值给`self.processed_windows_filetime_64`变量。
- en: 'Similar to the other conversion functions, we add in error handling to the
    converter on lines 234 through 237:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他转换函数类似，我们在第234到237行将错误处理加入到转换器中：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Converting with the convert_chrome_time() method
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用convert_chrome_time()方法进行转换
- en: The last of our showcased timestamps is the Google Chrome timestamp, which is
    similar to both of the previously mentioned timestamps. This timestamp is the
    number of microseconds since the `1601-01-01 00:00:00` epoch. We'll leverage the
    earlier-defined `self.unix_epcoh_offset` value to help in conversion. On line
    248, we begin to convert the raw timestamp through a series of functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的最后一个时间戳是Google Chrome时间戳，它与之前提到的两个时间戳类似。这个时间戳是自`1601-01-01 00:00:00`纪元以来的微秒数。我们将利用前面定义的`self.unix_epcoh_offset`值来帮助转换。在第248行，我们开始通过一系列函数转换原始时间戳。
- en: 'First, we convert the timestamp into a float and subtract the 1601 epoch constant.
    Next, we divide the value by one million to convert the value from microseconds
    into seconds so that the `datetime.datetime.fromtimestamp()` method can interpret
    the value properly. Finally, on line 251, we format `converted_time` to a string
    using the `strftime()` function. On lines 253 through 255, we handle exceptions
    that may occur from invalid values as seen in previous sections, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将时间戳转换为浮动数，并减去1601纪元常量。接下来，我们将该值除以一百万，将微秒转换为秒，以便`datetime.datetime.fromtimestamp()`方法可以正确地解释该值。最后，在第251行，我们使用`strftime()`函数将`converted_time`格式化为字符串。在第253到255行，我们处理可能由于无效值而引发的异常，正如之前部分所示：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When a formatted value is passed as an input, we must reverse the process. As
    in our other functions, we convert the input to a `datetime` object from a string
    using the `duparser.parse()` method. Once converted, we calculate the number of
    seconds by adding the 1601 epoch constant to the `total_seconds()` method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递一个格式化的值作为输入时，我们必须逆转该过程。与其他函数一样，我们使用`duparser.parse()`方法将输入从字符串转换为`datetime`对象。一旦转换完成，我们通过将1601纪元常量加到`total_seconds()`方法来计算秒数。
- en: 'This count of seconds is multiplied by one million to convert it into microseconds.
    Once calculated, we can cast this integer value into a string that will be displayed
    in our GUI. In the event that any errors arise, we catch them on line 264 through
    266 in the same way as with previous methods:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些秒数会乘以一百万，转换为微秒。计算完成后，我们可以将该整数值转换为字符串，并在我们的GUI中显示。如果发生任何错误，我们会在第264到266行捕获它们，就像之前的方法一样：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Designing the output method
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计输出方法
- en: The last method of the class is the `output()` method, and it updates the labels
    found on the bottom frame of the GUI. This simple construct allows us to evaluate
    processed values and display them if they're string values. As seen on line 273,
    following the definition of the method and docstring, we check whether the `self.processed_unix_seconds`
    value is of the string type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的最后一个方法是`output()`方法，它更新了GUI底部框架上的标签。这个简单的结构允许我们评估处理后的值，并在它们是字符串类型时显示出来。正如第273行所见，在方法定义和文档字符串之后，我们检查`self.processed_unix_seconds`的值是否为字符串类型。
- en: 'If it is, then we update the label by calling the `text` attribute as a dictionary
    key as seen on lines 274 and 275\. This could also be accomplished via the use
    of the `config()` method, though in this instance it''s simpler to define it in
    this manner. When this property is changed, the label is immediately updated as
    the element has already been set by a geometry manager. This behavior is repeated
    for each label to be updated, as seen on lines 277 through 283:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是字符串类型，则我们通过调用`text`属性作为字典键来更新标签，如第274行和275行所示。这也可以通过使用`config()`方法来实现，但在此实例中，使用这种方式更简单。当该属性发生变化时，标签会立即更新，因为该元素已经由几何管理器设置。这个行为会对每个需要更新的标签重复，如第277行到283行所示：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Running the script
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'With the complete code, we can execute the GUI and begin to convert dates from
    machine- to human-readable and vice versa. As seen in the following screenshot,
    the finished GUI reflects our design goal and allows the user to easily interact
    and process dates:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整代码后，我们可以执行GUI并开始将日期从机器格式转换为人类可读格式，反之亦然。正如下面的截图所示，完成的GUI反映了我们的设计目标，并允许用户轻松地交互和处理日期：
- en: '![](img/dffb48b8-0436-4ba8-9d3a-fcf1d08e40e8.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dffb48b8-0436-4ba8-9d3a-fcf1d08e40e8.png)'
- en: 'The preceding screenshot also shows us entering a formatted time value and
    getting all three converted raw timestamps back from our functions. Next, we provide
    a raw input in the Unix seconds format and can see that our Unix seconds parser
    returned the correct date:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图还展示了我们输入一个格式化的时间值，并从我们的函数中获取三个转换后的原始时间戳。接下来，我们提供一个Unix秒格式的原始输入，并可以看到我们的Unix秒解析器返回了正确的日期：
- en: '![](img/87c3f71c-7585-412f-a8d3-56396478b67b.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87c3f71c-7585-412f-a8d3-56396478b67b.png)'
- en: Additional challenges
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外挑战
- en: This script introduced GUIs and some of the methods available to us via the
    TkInter module for converting timestamps. This script can be extended in many
    ways. We recommend the following challenges for those wishing to gain a better
    understanding of GUI development in Python.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本脚本介绍了 GUI 以及我们通过 TkInter 模块可用的一些时间戳转换方法。这个脚本可以通过多种方式进行扩展。我们建议那些希望更好地了解 Python
    中 GUI 开发的人尝试以下挑战。
- en: As mentioned in this chapter, we only specify the conversion of three formats
    that're commonly seen in forensics and use several different methods to provide
    conversion. Try to add support for the FAT directory timestamp entry into the
    script, providing conversion into and from the raw format. This script is designed
    such that adding additional formatters is as simple as defining raw and formatted
    handlers, adding the labels to our output frame, and appending the method name
    to `convert()`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所述，我们只指定了三种在法医领域常见的格式的转换，并使用几种不同的方法提供转换。尝试为 FAT 目录时间戳条目添加支持，将其转换为原始格式和从原始格式转换。该脚本的设计使得添加额外的格式化器变得非常简单，只需定义原始和格式化的处理程序，添加标签到输出框架，并将方法名添加到
    `convert()` 中。
- en: In addition, consider replacing the output labels with entry fields so the user
    can copy and paste the results. A hint for this challenge is to look at the `set()`
    and `read-only` properties of the `Entry` widget.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以考虑将输出标签替换为输入字段，以便用户可以复制和粘贴结果。这个挑战的提示是查看 `Entry` 小部件的 `set()` 和 `read-only`
    属性。
- en: The last challenge we present allows the user to specify a time zone, either
    from the command-line or the GUI interface. The `pytz` library may be of great
    use for this task.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的最后一个挑战让用户可以指定一个时区，既可以通过命令行也可以通过 GUI 界面。`pytz` 库可能在这个任务中派上大用场。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how to convert between machine- and human-readable
    timestamps and display that information in GUI. The primary goal of a forensic
    developer is to be capable of facilitating rapid design and deployment of tools
    that provide insight into investigations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讲解了如何在机器可读和人类可读的时间戳之间进行转换，并在 GUI 中显示这些信息。法医开发者的主要目标是能够快速设计和部署能够为调查提供洞察的工具。
- en: However, in this chapter, we focused a bit more on the end user by spending
    a little extra time on building a nice interface for the user to operate and interact
    with. The code for this project can be downloaded from GitHub or Packt, as described
    in the *Preface*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这一章中，我们更多地关注了最终用户，花了一些额外的时间为用户构建了一个便于操作和互动的漂亮界面。本项目的代码可以从 GitHub 或 Packt
    下载，如 *前言* 中所述。
- en: In the next chapter, we'll explore triaging systems and how to collect essential
    live and volatile data from a system using Python.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨分诊系统，以及如何使用 Python 从系统中收集重要的实时和易变数据。
