- en: Buffer Overflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Exploiting stack-based buffer overflows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用基于堆栈的缓冲区溢出
- en: Exploiting buffer overflow on real software
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用真实软件的缓冲区溢出
- en: SEH bypass
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEH绕过
- en: Exploiting egg hunters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用egg hunters
- en: An overview of ASLR and NX bypass
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASLR和NX绕过的概述
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In a software program, buffer overflow occurs when a program, while writing
    data to a buffer, overruns the buffer size allocated and starts overwriting data
    to adjacent memory locations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件程序中，当程序在向缓冲区写入数据时，超出了分配的缓冲区大小，并开始向相邻的内存位置覆盖数据时，就会发生缓冲区溢出。
- en: A buffer can be considered a temporary area in the memory allocated to a program
    to store and retrieve data when needed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可以被认为是分配给程序的内存中的临时区域，用于在需要时存储和检索数据。
- en: Buffer overflows have been known to be exploited since long back.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来已知缓冲区溢出已被利用。
- en: When exploiting buffer overflows, our main focus is on overwriting some control
    information so that the flow of control of the program changes, which will allow
    our code to take control of the program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用缓冲区溢出时，我们的主要关注点是覆盖一些控制信息，以便程序的控制流发生变化，这将允许我们的代码控制程序。
- en: 'Here is a diagram that will give us a basic idea of an overflow happening in
    a buffer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个图表，将给我们一个关于缓冲区溢出发生的基本概念：
- en: '![](img/edcf143a-1eb8-44ce-b001-e0f59b5f229c.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edcf143a-1eb8-44ce-b001-e0f59b5f229c.png)'
- en: From the preceding diagram, we can assume this is what a program looks like.
    Since it is a stack, it starts from bottom and moves toward the top of the stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以假设这就是一个程序的样子。因为它是一个堆栈，它从底部开始，向堆栈的顶部移动。
- en: Seeing the preceding diagram, we also notice that the program has a fixed buffer
    to store 16 letters/bytes of data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们还注意到程序有一个固定的缓冲区来存储16个字母/字节的数据。
- en: We first enter the 8 characters (*1 char=1 byte*); on the right-hand side of
    the diagram, we can see that they have been written in the buffer of the program's
    memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先输入8个字符（*1个字符=1个字节*）；在图表的右侧，我们可以看到它们已经被写入程序内存的缓冲区中。
- en: 'Let''s see what happens when we write 20 characters into the program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们向程序写入20个字符时会发生什么：
- en: '![](img/5f33b307-ee03-4cb4-8ed2-f4d10fc4b5b1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f33b307-ee03-4cb4-8ed2-f4d10fc4b5b1.png)'
- en: 'Source: http://www.cbi.umn.edu/'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：http://www.cbi.umn.edu/
- en: We can see that data is correctly written upto 16 characters, but the last 4
    characters have now gone out of the buffer and have overwritten the values stored
    in the **Return Address** of the program. This is where a classic buffer overflow
    occurs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据被正确地写入了16个字符，但最后的4个字符现在已经超出了缓冲区，并覆盖了程序的**返回地址**中存储的值。这就是经典的缓冲区溢出发生的地方。
- en: 'Let''s look at a live example; we will take a sample code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际例子；我们将使用一个示例代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding program simply takes an input at runtime and copies it into a
    variable called `buffer`. We can see that the size of the variable buffer is set
    to `5`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序简单地在运行时接受一个输入，并将其复制到一个名为`buffer`的变量中。我们可以看到变量缓冲区的大小设置为`5`。
- en: 'We now compile it using this command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用这个命令进行编译：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to be careful as `gcc` by default has inbuilt security features, which
    prevent buffer overflows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心，因为`gcc`默认具有内置的安全功能，可以防止缓冲区溢出。
- en: 'We run the program using this command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个命令运行程序：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see that it has stored the data and we get the output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它已经存储了数据，我们得到了输出。
- en: 'Let''s now run this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这个：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will see the program exits as a segmentation fault. This is the enabled security
    feature of `gcc`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到程序以分段错误退出。这是`gcc`的启用安全功能。
- en: We will learn more about the return address in the next recipe. However, overwriting
    the return address with our own code can cause a program to behave differently
    from its usual execution and helps us in exploiting the vulnerability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更多地了解返回地址。然而，用我们自己的代码覆盖返回地址可以导致程序的行为与通常执行不同，并帮助我们利用这个漏洞。
- en: Fuzzing is the easiest way to discover buffer overflows in a program. There
    are various fuzzers available in Kali, or we can write a custom script to make
    our own, depending on the type of program we have.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试是发现程序中缓冲区溢出最简单的方法。Kali中有各种模糊测试工具，或者我们可以根据程序类型编写自定义脚本。
- en: Once fuzzing is done and a crash occurs, our next step is to debug the program
    to find the exact part where a program crashes and how we can use it to our advantage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模糊测试完成并发生崩溃，我们的下一步是调试程序，找到程序崩溃的确切部分以及如何利用它来获利。
- en: Again, there are multiple debuggers available online. My personal favorite for
    Windows is Immunity Debugger (Immunity Inc.). Kali also comes with an inbuilt
    debugger, GDB. It is a command-line debugger.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在线也有多个调试器可用。我个人在Windows上最喜欢的是Immunity Debugger（Immunity Inc.）。Kali也带有一个内置的调试器GDB。这是一个命令行调试器。
- en: Before we jump any further into more exciting topics, note that there are two
    types of overflows that usually happen in a program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨更激动人心的话题之前，请注意通常在程序中会发生两种类型的溢出。
- en: 'There are mainly two types of buffer overflows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种类型的缓冲区溢出：
- en: Stack-based overflows
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于堆栈的溢出
- en: Heap-based overflows
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于堆栈的溢出
- en: We will be covering these in more detail in the later part of the chapter. For
    now, let's clear up some basics, that will help us in exploiting overflow vulnerabilities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面更详细地涵盖这些内容。现在，让我们澄清一些基础知识，这将帮助我们利用溢出漏洞。
- en: Exploiting stack-based buffer overflows
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用基于堆栈的缓冲区溢出
- en: Now that our basics are clear, let's move on to the exploitation of stack-based
    buffer overflows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的基础知识已经清楚，让我们继续学习基于堆栈的缓冲区溢出的利用。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps demonstrate the stack-based buffer overflow:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了基于堆栈的缓冲区溢出：
- en: 'Let''s take a look at another simple C program:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看另一个简单的C程序：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This program uses a vulnerable method `strcyp()`. We save the program to a file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用了一个有漏洞的方法`strcyp()`。我们将程序保存到一个文件中。
- en: 'We then compile the program with `gcc` using the `fno-stack-protector` and
    `execstack`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`gcc`编译程序，使用`fno-stack-protector`和`execstack`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we turn off address space randomization using this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们关闭地址空间随机化：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we open our program in `gdb` using this command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令在`gdb`中打开我们的程序：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/bc9e7142-0794-46bb-bdf8-322a513388d9.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc9e7142-0794-46bb-bdf8-322a513388d9.png)'
- en: 'Next, we supply our input using Python using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用Python使用以下命令输入我们的输入：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/985cb9a0-5002-4993-8d7c-8a3e7d86131f.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/985cb9a0-5002-4993-8d7c-8a3e7d86131f.png)'
- en: We can see that the program crashed and it shows error `0x41414141`. This just
    means that the character we entered, `A`, has overwritten the EIP.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到程序崩溃并显示错误`0x41414141`。这意味着我们输入的字符`A`覆盖了EIP。
- en: 'We confirm it by typing `i r`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过输入`i r`来确认：
- en: '![](img/572fdc5f-2ff5-4bba-b6b4-48eef12325d2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/572fdc5f-2ff5-4bba-b6b4-48eef12325d2.png)'
- en: This shows us that the value of the EIP register has been successfully overwritten.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉我们EIP寄存器的值已经成功被覆盖。
- en: Next, we find the exact byte that overwrites the EIP. We can do this by entering
    different characters in our program and then checking which of them overwrites
    the EIP.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们找到覆盖EIP的确切字节。我们可以通过在程序中输入不同的字符，然后检查哪个字符覆盖了EIP来做到这一点。
- en: 'So we run the program again, this time, with different characters:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们再次运行程序，这次使用不同的字符：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/4d8bbcd1-9a6d-4e1f-99a5-b262105e0777.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d8bbcd1-9a6d-4e1f-99a5-b262105e0777.png)'
- en: This time, we see that the EIP has the value `CCCC`. This implies that the bytes
    we need are somewhere in the last 25 characters we supply.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，我们看到EIP的值是`CCCC`。这意味着我们需要的字节在我们提供的最后25个字符中的某个位置。
- en: 'We similarly try different combinations of 124 characters until we have the
    position of the exact 4 characters that overwrite the EIP:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们尝试不同组合的124个字符，直到找到确切覆盖EIP的4个字符的位置：
- en: '![](img/691d6b8d-bcf4-4aa5-8019-8f9c0dd9c747.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/691d6b8d-bcf4-4aa5-8019-8f9c0dd9c747.png)'
- en: Now, since we have found the exact location of the EIP, and in order to perform
    a successful exploitation, we need to overwrite these 4 bytes with the memory
    address where we will store our shellcode. We have about 100 bytes in the memory
    where `A` is stored currently, which is more than enough for our shellcode. So,
    we need to add breakpoints in our debugger, where it will stop before jumping
    to the next instruction.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，既然我们已经找到了EIP的确切位置，并且为了执行成功的利用，我们需要用我们将存储shellcode的内存地址覆盖这4个字节。我们的内存中有大约100个字节，其中当前存储着`A`，这对我们的shellcode来说已经足够了。因此，我们需要在调试器中添加断点，在跳转到下一条指令之前停下来。
- en: 'We list the program using the `list 8` command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`list 8`命令列出程序：
- en: '![](img/8a365f60-2e6a-4b5a-bfd1-75914c58fb8b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a365f60-2e6a-4b5a-bfd1-75914c58fb8b.png)'
- en: And we add our breakpoints in the line where the function is called and after
    it is called using `b <linenumber>`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在调用函数的行和调用后使用`b <linenumber>`添加我们的断点。
- en: 'Now we run the program again, and it will stop at the breakpoint:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次运行程序，它将在断点处停止：
- en: '![](img/42088718-8f43-41a1-b036-46c996900a12.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42088718-8f43-41a1-b036-46c996900a12.png)'
- en: We press `c` to continue.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按下`c`以继续。
- en: 'Now let''s see the `esp` (stack pointer) register:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下`esp`（堆栈指针）寄存器：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/d1300130-681f-494a-8359-b08e0d3730e9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1300130-681f-494a-8359-b08e0d3730e9.png)'
- en: This will show us 16 bytes after the `esp` register, and on the left-hand side
    column, we will see the memory address corresponding to the data being stored.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向我们展示`esp`寄存器之后的16个字节，在左侧列中，我们将看到与存储的数据对应的内存地址。
- en: 'Here, we see that data starts at address `0xbffff190`. We note the next memory
    address, `0xbfff1a0`. This is the address we will use to write in the EIP. When
    the program overwrites the EIP, it will make it jump to this address, where our
    shellcode will be stored:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们看到数据从地址`0xbffff190`开始。我们注意到下一个内存地址`0xbfff1a0`。这是我们将用来写入EIP的地址。当程序覆盖EIP时，它将使其跳转到这个地址，我们的shellcode将存储在这里：
- en: '![](img/e448340f-ef70-4c50-8128-34e5fff7bfec.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e448340f-ef70-4c50-8128-34e5fff7bfec.png)'
- en: 'Let''s try to open a shell by exploiting the overflow. We can find the shellcode
    that will execute a shell for us on Google:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试通过利用溢出来打开一个shell。我们可以在Google上找到将为我们执行shell的shellcode：
- en: '![](img/c42bb2b9-3caa-4f65-8a04-43f7eff0c8e1.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c42bb2b9-3caa-4f65-8a04-43f7eff0c8e1.png)'
- en: We have 100 bytes and our shellcode is 24 bytes. We can use this one in our
    exploit.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有100个字节，我们的shellcode是24个字节。我们可以在我们的利用中使用这个。
- en: 'Now we simply replace the `A`s with the `76` no op assembly instruction (`0x90`)
    and the rest of the 24 bytes with the shellcode, then the `B`s with the memory
    address we want the EIP to point to, and `C`s with the no op code again. This
    should look something like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们简单地用`90` no op汇编指令（`0x90`）替换`A`，并用shellcode替换其余的24个字节，然后用我们希望EIP指向的内存地址替换`B`，用no
    op代码替换`C`。这应该看起来像这样：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s rerun the program and pass this as an input:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行程序并将其作为输入：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We type `c` to continue from breakpoints, and once execution is done, we will
    have our shell executed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入`c`以从断点继续，一旦执行完成，我们的shell就会被执行。
- en: Exploiting buffer overflow on real software
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用真实软件的缓冲区溢出
- en: You have learned the basics of exploitation earlier. Now let's try these on
    some of the software already exploited long ago and with public exploits available.
    In this recipe, you will learn about publicly available exploits for old software
    and create your own version of the exploit for it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前已经学习了利用的基础知识。现在让我们尝试在一些早已被利用并且有公开利用的软件上进行尝试。在这个示例中，您将了解旧软件的公开利用以及为其创建自己版本的利用。
- en: Before we begin, we will need an old version of a Windows OS (preferably, Windows
    XP) and a debugger for Windows. I have used Immunity Debugger and an old software
    with a known buffer overflow vulnerability. We will use *Easy RM to MP3 Converter*.
    This version had a buffer overflow vulnerability in playing large M3U files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要一个旧版本的Windows操作系统（最好是Windows XP）和一个Windows调试器。我使用了Immunity Debugger和一个已知的缓冲区溢出漏洞的旧软件。我们将使用*Easy
    RM to MP3 Converter*。这个版本在播放大型M3U文件时存在缓冲区溢出漏洞。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The free version of Immunity Debugger can be downloaded at [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'Immunity Debugger的免费版本可以在[https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/)上下载。 '
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the given steps to learn about it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤来学习：
- en: Next, we download and install our MP3 converter on the machine.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们下载并在机器上安装我们的MP3转换器。
- en: This converter had a vulnerability in playing M3U files. The software crashed
    when a large file was opened for conversion with it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个转换器在播放M3U文件时存在漏洞。当使用它打开一个大文件进行转换时，软件会崩溃。
- en: 'Let''s create a file with about 30,000 `A`s written into it and save it as
    `<filename>.m3u`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个文件，里面写入大约30,000个`A`，并将其保存为`<filename>.m3u`：
- en: '![](img/2237b2f9-0aa0-4912-80e7-01c65bcc2b91.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2237b2f9-0aa0-4912-80e7-01c65bcc2b91.png)'
- en: 'We then drag and drop the file into the player, and we will see that it crashes:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件拖放到播放器中，我们会看到它崩溃了：
- en: '![](img/24084d91-a809-4a7c-a5e6-bb289d7855aa.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24084d91-a809-4a7c-a5e6-bb289d7855aa.png)'
- en: Now we need to find the exact number of bytes that cause the crash.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要找到导致崩溃的确切字节数。
- en: 'Typing so many `A`s manually in a file will take a lot of time, so we write
    a simple Python program to do that for us:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中手动输入这么多`A`将会花费很长时间，所以我们写一个简单的Python程序来代替我们做这件事：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we play around with bytes to find the exact value of the crash.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们玩弄字节，找到崩溃的确切值。
- en: 'In our case, it came out to be 26,105 as the program did not crash at 26,104
    bytes:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于程序在26,104字节处没有崩溃，所以它的长度是26,105：
- en: '![](img/ff14a5e0-2a9f-4c2a-8ac8-4b2cf31e5ee6.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff14a5e0-2a9f-4c2a-8ac8-4b2cf31e5ee6.png)'
- en: 'Now, we run our debugger and attach our running converter program to it by
    navigating to File | Attach:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行我们的调试器，并通过导航到File | Attach将正在运行的转换程序附加到它：
- en: '![](img/d6ee96ff-ee75-41e1-9695-f6e2d1bb137d.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6ee96ff-ee75-41e1-9695-f6e2d1bb137d.png)'
- en: 'Then, we select the process name from the list of running programs:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从正在运行的程序列表中选择进程名称：
- en: '![](img/37bb1dd1-3b80-4193-8bc9-d4198c05a5e5.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37bb1dd1-3b80-4193-8bc9-d4198c05a5e5.png)'
- en: 'Once it is attached, we open our M3U file in the program. We will see a warning
    in the status bar of the debugger. We simply click on continue by pressing the
    *F9* key or clicking on the play button from the top menu bar:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦附加成功，我们就在程序中打开我们的M3U文件。我们将在调试器的状态栏中看到一个警告。我们只需按下*F9*键或点击顶部菜单栏上的播放按钮继续：
- en: '![](img/2b1bd8d3-d2fb-4640-8104-cbfe0677069d.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b1bd8d3-d2fb-4640-8104-cbfe0677069d.png)'
- en: 'We will see that the EIP was overwritten with `A`s and the program crashed:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会看到EIP被`A`覆盖，并且程序崩溃了：
- en: '![](img/57f2063e-3b69-42d4-a4ce-3df272fdadad.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f2063e-3b69-42d4-a4ce-3df272fdadad.png)'
- en: Now we need to find the exact 4 bytes that cause the crash. We will use the
    script from Kali known as *pattern create*. It generates a unique pattern for
    the number of bytes we want.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要找到导致崩溃的确切4个字节。我们将使用Kali中称为*pattern create*的脚本。它会为我们想要的字节数生成一个唯一的模式。
- en: 'We can find the path of the script using the locate command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用locate命令找到脚本的路径：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/c52b2870-f2a2-42dd-91f8-51a6a93423f0.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c52b2870-f2a2-42dd-91f8-51a6a93423f0.png)'
- en: 'Now that we have the path, we run the script and pass the number of bytes:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了路径，我们运行脚本并传递字节数：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We used 5,000 because we already know it will not crash at 25,000, so we only
    create a pattern for the next 5,000 bytes.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用5,000是因为我们已经知道它不会在25,000处崩溃，所以我们只为接下来的5,000字节创建一个模式。
- en: We have our unique pattern. We now paste this in our M3U file along with 25,000
    `A`s.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有了我们的唯一模式。我们现在将其粘贴到我们的M3U文件中，再加上25,000个`A`。
- en: 'We open up our application and attach the process to our debugger:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开我们的应用程序，并将进程附加到我们的调试器上：
- en: '![](img/9da7ca5f-52ae-4996-abf2-c5e624cfe55c.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9da7ca5f-52ae-4996-abf2-c5e624cfe55c.png)'
- en: We then drag and drop our M3U file into the program.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将我们的M3U文件拖放到程序中。
- en: It crashes and we have our EIP overwritten with 42386b42.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它崩溃了，我们的EIP被42386b42覆盖了。
- en: 'Metasploit has another great script to find the location of the offset:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metasploit有另一个很棒的脚本来找到偏移的位置：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we have the offset match at `1104`; adding it to the 25,000 `A`s, we now
    know that EIP is overwritten after 26,104 bytes:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在`1104`处找到了偏移匹配；将其加到25,000个`A`上，我们现在知道EIP在26,104字节后被覆盖：
- en: '![](img/a66fd3d6-f421-4b69-8373-154c3d24ad26.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a66fd3d6-f421-4b69-8373-154c3d24ad26.png)'
- en: Next, we need to find out a reliable way of jumping to the shellcode. We do
    this by simply writing extra random characters into the stack after EIP, making
    sure the shellcode we write will be written properly into the memory.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到一个可靠的方法来跳转到shellcode。我们通过在EIP之后简单地写入额外的随机字符到堆栈中，确保我们写入的shellcode将被正确地写入内存。
- en: We run the program, attach it to the debugger, and let it crash.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行程序，将其附加到调试器，并让它崩溃。
- en: 'We will see the EIP has been overwritten successfully. In the window in the
    bottom-right corner, we right-click and select Go to ESP:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到EIP已经成功被覆盖。在右下角的窗口中，我们右键单击并选择Go to ESP：
- en: '![](img/fc1958bb-6806-4d8b-993e-5d8e1efda69c.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc1958bb-6806-4d8b-993e-5d8e1efda69c.png)'
- en: 'Here, we notice that the ESP actually starts from the 5th byte. To make sure
    our shellcode is executed properly, we now need to make sure shellcode starts
    after 4 bytes. We can insert four NOPs to fix this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们注意到ESP实际上是从第5个字节开始的。为了确保我们的shellcode能够正确执行，我们现在需要确保shellcode在4个字节之后开始。我们可以插入四个NOP来修复这个问题：
- en: '![](img/23e8cfb9-541d-4e8e-8896-63b9bdec3c24.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e8cfb9-541d-4e8e-8896-63b9bdec3c24.png)'
- en: 'Since we have control over EIP, there are multiple ways to execute our shellcode,
    and we will cover two of them here. The first one is simple: we find the `jmp
    esp` instruction in the code and overwrite the address with it. To do that, we
    right-click and navigate to Search for | All commands in all modules:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们控制了EIP，有多种方法可以执行我们的shellcode，我们将在这里介绍其中两种。第一种方法很简单：我们在代码中找到`jmp esp`指令并用它覆盖地址。要做到这一点，我们右键单击并导航到搜索
    | 所有模块中的所有命令：
- en: '![](img/f18c4ddb-e46a-4e5f-aec8-1f44eb248d02.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f18c4ddb-e46a-4e5f-aec8-1f44eb248d02.png)'
- en: 'We type the `jmp esp` instruction:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们输入`jmp esp`指令：
- en: '![](img/919c5b9a-9e80-4612-913d-db6e215b8f8e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/919c5b9a-9e80-4612-913d-db6e215b8f8e.png)'
- en: In the results box, we see our instruction, and we copy the address for our
    exploit.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果框中，我们看到我们的指令，并复制地址用于我们的利用。
- en: '![](img/976f95ba-72d9-4eff-b9be-673c1aeca92e.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/976f95ba-72d9-4eff-b9be-673c1aeca92e.png)'
- en: 'Let''s write an exploit now. The basic concept would be `junk bytes + address
    of jump ESP + NOP bytes + Shellcode`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写一个利用。基本概念将是`垃圾字节 + 跳转ESP的地址 + NOP字节 + Shellcode`：
- en: '![](img/505d2867-3bd2-4f61-b10e-fa7058d6d247.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/505d2867-3bd2-4f61-b10e-fa7058d6d247.png)'
- en: 'We can generate the shellcode of the calculator:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以生成计算器的shellcode：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we run the exploit, and we should see the calculator open once the program
    crashes!
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行利用，当程序崩溃时，我们应该看到计算器打开！
- en: '![](img/f66e9a99-f581-456c-95d9-a005e49b0e74.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f66e9a99-f581-456c-95d9-a005e49b0e74.png)'
- en: Let's try another method; suppose there are no `jmp` esps available for us to
    use. In this case, we can use `push esp` and then use the `ret` instruction, which
    will move the pointer to the top of the stack and then call the `esp`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试另一种方法；假设没有`jmp` esps可供我们使用。在这种情况下，我们可以使用`push esp`，然后使用`ret`指令，它将将指针移动到堆栈的顶部，然后调用`esp`。
- en: We follow the same steps until *step 25*. Then, we right-click and go to Search
    for | All sequences in all modules.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遵循相同的步骤直到*步骤25*。然后，我们右键单击并转到搜索 | 所有模块中的所有序列。
- en: 'Here, we type `push esp ret`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们输入`push esp ret`：
- en: '![](img/bb49615b-16b0-447a-bbba-38ac7012266e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb49615b-16b0-447a-bbba-38ac7012266e.png)'
- en: 'In the result, we see we have the sequence in the address: `018F1D88`.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果中，我们看到地址中有序列：`018F1D88`。
- en: 'Now we simply replace the EIP address in our exploit code with this and run
    the exploit, and we should have a calculator open up:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需用我们的利用代码中的EIP地址替换它并运行利用，我们应该打开一个计算器：
- en: '![](img/b6a07761-4b4d-4742-b69f-aa38900d5c6c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6a07761-4b4d-4742-b69f-aa38900d5c6c.png)'
- en: SEH bypass
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SEH绕过
- en: Before we start, we need to understand what SEH is. **SEH** stands for **structured
    exception handling**. We may have often seen programs popping up an error saying
    the *software has encountered a problem and needs to close*. This basically means
    it's the default exception handler of Windows kicking in.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要了解SEH是什么。**SEH**代表**结构化异常处理**。我们可能经常看到程序弹出一个错误，说*软件遇到问题需要关闭*。这基本上意味着Windows的默认异常处理程序开始起作用。
- en: 'SEH handlers can be considered the block of `try` and `catch` statements that
    are executed in order when there''s an exception in the program. This is what
    a typical SEH chain would look like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SEH处理程序可以被认为是在程序中出现异常时按顺序执行的`try`和`catch`语句块。这是典型的SEH链的样子：
- en: '![](img/6f9ef080-d0b9-4e2f-86c9-86aafce20782.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f9ef080-d0b9-4e2f-86c9-86aafce20782.png)'
- en: 'Source: https://www.corelan.be/wp-content/uploads/2009/07/image_thumb45.png'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.corelan.be/wp-content/uploads/2009/07/image_thumb45.png
- en: When an exception occurs, the SEH chain comes to the rescue and handles the
    exception based on its type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，SEH链会出手处理异常，根据其类型处理异常。
- en: 'So, when an illegal instruction occurs, the application gets a chance to handle
    the exception. If no exception handler is defined in the application, we will
    see an error shown by Windows: something like Send a report to Microsoft.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当发生非法指令时，应用程序有机会处理异常。如果应用程序中没有定义异常处理程序，我们将看到Windows显示的错误：类似于发送报告给Microsoft。
- en: To perform a successful exploitation of a program with the SEH handler, we first
    try to fill the stack with our buffer and then try to overwrite the memory address
    that stores the first SEH record chain. However, that is not enough; we need to
    generate an error as well, that will actually trigger the SEH handler and then
    we will be able to gain complete control over the execution flow of the program.
    An easy way is to keep filling the stack all the way down, which will create an
    exception to be handled, and since we already have control over the first SEH
    record, we will be able to exploit it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功利用具有SEH处理程序的程序，我们首先尝试用我们的缓冲区填充堆栈，然后尝试覆盖存储第一个SEH记录链的内存地址。然而，这还不够；我们还需要生成一个错误，这将实际触发SEH处理程序，然后我们将能够完全控制程序的执行流程。一个简单的方法是一直填充堆栈，直到底部，这将创建一个需要处理的异常，而且由于我们已经控制了第一个SEH记录，我们将能够利用它。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this recipe, you will learn how to do this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何做到这一点：
- en: Let's download a program called AntServer. It has a lot of public exploits available,
    and we will try to build our own exploit for it.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们下载一个名为AntServer的程序。它有很多公开的漏洞利用可用，我们将尝试为其构建我们自己的利用。
- en: We will install it on the Windows XP SP2 machine that we used in the previous
    recipe.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其安装在我们在上一个教程中使用的Windows XP SP2机器上。
- en: 'AntServer had a vulnerability that could be triggered by sending a long USV
    request to the AntServer running on port `6600`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AntServer存在一个漏洞，可以通过向运行在端口`6600`上的AntServer发送一个长的USV请求来触发：
- en: '![](img/ea4fd8f1-96bc-4169-b405-16cdfaa4739f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea4fd8f1-96bc-4169-b405-16cdfaa4739f.png)'
- en: 'Let''s run the AntServer by opening the software and navigating to Server |
    Run Service Control...:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过打开软件并导航到服务器 | 运行服务控制...来运行AntServer：
- en: '![](img/110334f7-16d2-4b7d-9747-fe7014451572.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/110334f7-16d2-4b7d-9747-fe7014451572.png)'
- en: 'Now let''s write a simple Python script, that will send a large request to
    this server on port `6600`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写一个简单的Python脚本，将一个大请求发送到端口`6600`的服务器：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Coming back to the Windows machine, let's start Immunity Debugger and attach
    the process `AntServer.exe` to it. And then, click on `Run`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Windows机器，让我们启动Immunity Debugger并将进程`AntServer.exe`附加到它上。然后，点击`Run`。
- en: 'Once the program is running, we run our Python script from Kali, and in our
    Debugger, we will see a violation error. However, our EIP has not been overwritten
    yet:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦程序运行，我们从Kali运行我们的Python脚本，在我们的调试器中，我们会看到一个违规错误。然而，我们的EIP还没有被覆盖：
- en: '![](img/76b1c96e-24e2-4ee9-8a55-2bf78cd130bc.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76b1c96e-24e2-4ee9-8a55-2bf78cd130bc.png)'
- en: 'In the File menu in the debugger, we go to View | SEH chain. Here, we will
    see that the address has been overwritten by `AAAA`. Now we press *Shift*+ *F9*
    to pass an exception to the program. We will see that the EIP has been overwritten,
    and we get an error:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调试器的文件菜单中，我们转到查看| SEH链。在这里，我们会看到地址已被`AAAA`覆盖。现在我们按*Shift*+ *F9*将一个异常传递给程序。我们会看到EIP已经被覆盖，并且我们会收到一个错误：
- en: '![](img/77e531fa-d148-4908-9c41-8ad662900580.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77e531fa-d148-4908-9c41-8ad662900580.png)'
- en: We will also notice that the other register values have now become zero. This
    zeroing of registers was introduced in Windows XP SP1 and later in order to make
    SEH exploitation more difficult.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还会注意到其他寄存器的值现在已经变为零。这种寄存器清零是在Windows XP SP1及以后引入的，以使SEH利用变得更加困难。
- en: We are using Windows XP SP2\. It has a feature called **SAFESEH**. When this
    option is enabled in the module, only the memory addresses listed on the registered
    SEH handlers list can be used, which means if we use any address that is not on
    the list, from a module compiled with `/SAFESEH ON`, the SEH address will not
    be used by the Windows exception handler and the SEH overwrite will fail.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用Windows XP SP2。它有一个名为**SAFESEH**的功能。当这个选项在模块中启用时，只有注册的SEH处理程序列表中列出的内存地址才能被使用，这意味着如果我们使用任何不在列表上的地址，来自使用`/SAFESEH
    ON`编译的模块，SEH地址将不会被Windows异常处理程序使用，SEH覆盖将失败。
- en: 'There are a few ways to bypass this, and this is one of them: using an overwrite
    address from a module that was not compiled with the `/SAFESEH ON` or `IMAGE_DLLCHARACTERISTICS_NO_SEH`
    options.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以绕过这个问题，这是其中一种：使用一个没有使用`/SAFESEH ON`或`IMAGE_DLLCHARACTERISTICS_NO_SEH`选项编译的模块的覆盖地址。
- en: 'To find that, we will use a plugin called **mona** for Immunity Debugger. It
    can be downloaded from [https://github.com/corelan/mona](https://github.com/corelan/mona):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找到这个，我们将使用一个名为**mona**的Immunity Debugger插件。它可以从[https://github.com/corelan/mona](https://github.com/corelan/mona)下载：
- en: '![](img/a4e6fef0-c9bd-4a0a-ab80-631458aa0a24.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4e6fef0-c9bd-4a0a-ab80-631458aa0a24.png)'
- en: We simply copy the Python file into the `PyCommands` folder of the Immunity
    application.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需将Python文件复制到Immunity应用程序的`PyCommands`文件夹中。
- en: 'Let''s move on to making the exploit. We have seen that the EIP has already
    been overwritten. Now we will try to find the exact bytes at which the crash occurs
    using the pattern create script in Kali Linux:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续制作利用程序。我们已经看到EIP已经被覆盖。现在我们将尝试使用Kali Linux中的模式创建脚本找到崩溃发生的确切字节：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/2a92070e-e7f6-4ebc-8139-733ababfc285.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a92070e-e7f6-4ebc-8139-733ababfc285.png)'
- en: 'The code should be something like this:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码应该是这样的：
- en: '![](img/79e71616-6b73-4c64-8b4a-8c51bfda71b0.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79e71616-6b73-4c64-8b4a-8c51bfda71b0.png)'
- en: We now run this file, and in Immunity Debugger, we will see the access violation
    error. We now go to View | SEH chain.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们运行这个文件，在Immunity Debugger中，我们会看到访问违规错误。现在我们去查看| SEH链。
- en: 'We will see that our SEH has been overwritten with bytes. We copy the `42326742`
    value and find its location using the `pattern_offset` script in Kali:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会看到我们的SEH已经被覆盖了。我们复制`42326742`的值，并使用Kali中的`pattern_offset`脚本找到它的位置：
- en: '![](img/627727a0-1665-449e-b580-bf31f157d06f.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/627727a0-1665-449e-b580-bf31f157d06f.png)'
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](img/09a3a41d-f031-4c46-b222-106ce855f3e9.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a3a41d-f031-4c46-b222-106ce855f3e9.png)'
- en: We will see that the offset is `966` bytes at which the handler is overwritten.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会看到偏移量为`966`字节，处理程序被覆盖的位置。
- en: 'Now let''s modify our exploit a bit and see what happens. We have `966` bytes;
    we will use `962` bytes of As and 4 bytes of breakpoint and 4 with Bs and the
    rest of the bytes with Cs to see what happens:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们稍微修改我们的利用程序，看看会发生什么。我们有`966`字节；我们将使用`962`字节的A和4字节的断点，再用4个B，剩下的字节用C来看看会发生什么：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We run this and view the SEH chain. Here, we will notice an interesting thing:
    the first 4 breakpoints we added have actually overwritten a memory address, and
    the next 4 have been overwritten into our SEH handler:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行这个并查看SEH链。在这里，我们会注意到一个有趣的事情：我们添加的前4个断点实际上已经覆盖了一个内存地址，接下来的4个已经被覆盖到我们的SEH处理程序中：
- en: '![](img/9923fd87-3710-4aa9-ac11-2a4873962b40.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9923fd87-3710-4aa9-ac11-2a4873962b40.png)'
- en: This happens as the SEH is a pointer that points to the memory address where
    the code is stored when an exception occurs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为SEH是一个指针，指向发生异常时代码存储的内存地址。
- en: Let's pass the exception to the program and we will see that EIP has been overwritten,
    but when we look in the memory, we will see that our Cs have been written approximately
    6 bytes after our Bs in the memory. We can use a `POP RET` followed by a short
    `JUMP` code to jump to our shellcode.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将异常传递给程序，我们会看到EIP已经被覆盖，但当我们查看内存时，我们会看到我们的Cs在内存中的Bs之后大约写入了6个字节。我们可以使用`POP
    RET`后跟一个短的`JUMP`代码来跳转到我们的shellcode。
- en: 'We type the `!safeseh` command in the debugger''s console:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在调试器的控制台中输入`!safeseh`命令：
- en: '![](img/e5fe1f24-019f-47fb-b5ac-841de81bcc5e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5fe1f24-019f-47fb-b5ac-841de81bcc5e.png)'
- en: 'This will show us the list of all DLLs that are not compiled using `SAFESEH/ON`.
    In the log window, we will see the list of the functions:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示所有未使用`SAFESEH/ON`编译的DLL的列表。在日志窗口中，我们将看到函数的列表：
- en: '![](img/6732dd8a-5f97-4211-97bb-3ba05ebc9e64.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6732dd8a-5f97-4211-97bb-3ba05ebc9e64.png)'
- en: Let's use a DLL `vbajet32.dll`. Our goal is to find a `POP POP RET` sequence
    in the DLL, that we can use to bypass SEH.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个名为`vbajet32.dll`的DLL。我们的目标是在DLL中找到一个`POP POP RET`序列，我们可以用它来绕过SEH。
- en: 'We find our DLL on the Windows machine and copy it to Kali. Kali has another
    great tool known as `msfpescan`, that can be used to find the `POP POP RET` sequence
    in the DLL:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Windows机器上找到我们的DLL并将其复制到Kali。Kali还有另一个很棒的工具，称为`msfpescan`，可以用来在DLL中查找`POP
    POP RET`序列：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/227092fd-5f40-4a32-b23e-d3b72b31bfb9.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/227092fd-5f40-4a32-b23e-d3b72b31bfb9.png)'
- en: Here, we have the address for all the `POP POP RET` sequences in the `.dll`.
    We will use the first one, `0x0f9a1f0b`. We also need a short `JUMP` code, that
    will cause a jump to our shellcode or Cs stored in the memory.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们有所有`.dll`中`POP POP RET`序列的地址。我们将使用第一个`0x0f9a1f0b`。我们还需要一个短的`JUMP`代码，它将导致跳转到我们的shellcode或存储在内存中的Cs。
- en: Short `JUMP` is `\xeb\x06`, where `06` is the number of bytes we need to jump.
    We are still 2 bytes short of the 4-byte address space and we can use 2 NOPs.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短`JUMP`是`\xeb\x06`，其中`06`是我们需要跳转的字节数。我们仍然缺少4字节地址空间的2个字节，我们可以使用2个NOPs。
- en: 'Let''s create a shellcode; since we are sending this over HTTP, we need to
    make sure we avoid bad characters. We will use msfvenom:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个shellcode；因为我们将通过HTTP发送这个shellcode，所以我们需要确保避免坏字符。我们将使用msfvenom：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/4a72551c-1e19-414f-a9f1-33d95e744367.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a72551c-1e19-414f-a9f1-33d95e744367.png)'
- en: 'We will put everything in the exploit, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把所有东西放在利用中，如下所示：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/7a5ad769-7b63-423a-8e12-8068eeaf83ec.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a5ad769-7b63-423a-8e12-8068eeaf83ec.png)'
- en: 'Let''s run this without the debugger this time. We will open our handler in
    Kali, and we should have meterpreter access:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们不使用调试器运行。我们将在Kali中打开我们的处理程序，然后我们应该有meterpreter访问：
- en: '![](img/44862fbb-f064-4d32-b21d-026f52f9e59d.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44862fbb-f064-4d32-b21d-026f52f9e59d.png)'
- en: See also
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/)'
- en: '[http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/](http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/](http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/)'
- en: Exploiting egg hunters
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用蛋猎手
- en: Egg hunting is used when there is not enough space in the memory to place our
    shellcode consecutively. Using this technique, we prefix a unique tag with our
    shellcode and then the egg hunter will basically search for that tag in the memory
    and execute the shellcode.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存中没有足够的空间连续放置我们的shellcode时，就会使用蛋猎手。使用这种技术，我们在我们的shellcode前面加上一个唯一的标签，然后蛋猎手基本上会在内存中搜索该标签并执行shellcode。
- en: 'The egg hunter contains a set of programming instructions; it is not much different
    from shellcode. There are multiple egg hunters available. You can learn more about
    them and how they work with this paper by skape: [http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋猎手包含一组编程指令；它与shellcode并没有太大的不同。有多种蛋猎手可用。您可以通过skape的这篇论文了解更多关于它们以及它们如何工作的信息：[http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf)。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will try to make an exploit with an egg hunter for the same software we
    used in the previous recipe. The logic behind the exploitation would be something
    similar to what is shown in the following diagram:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用一个蛋猎手为我们在上一个教程中使用的相同软件制作一个漏洞利用。利用的逻辑将类似于以下图表所示的内容：
- en: '![](img/3eba1c6c-372e-4d0e-850e-96b87d14b964.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eba1c6c-372e-4d0e-850e-96b87d14b964.png)'
- en: Our aim is to overwrite the **nSEH** and then **SEH** in order to make it jump
    to the egg hunter shellcode, which, when executed, will find and execute our shellcode
    in the memory.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是覆盖**nSEH**，然后**SEH**，以便它跳转到蛋猎手shellcode，当执行时，将在内存中找到并执行我们的shellcode。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Following are the steps that demonstrate the use of the egg hunter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示使用蛋猎手的步骤：
- en: 'We start the software on Windows XP and attach it to the debugger:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Windows XP上启动软件并将其附加到调试器：
- en: '![](img/a58a884f-8baa-43f0-b726-980a8d468454.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a58a884f-8baa-43f0-b726-980a8d468454.png)'
- en: We already know the crash bytes and the address to bypass the SAFESEH.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经知道了崩溃字节和绕过SAFESEH的地址。
- en: Now we need to add our egg hunter and then use it to jump to our shellcode.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加我们的蛋猎手，然后使用它来跳转到我们的shellcode。
- en: As we know, the egg hunter is a shellcode and the basic rule for using a shellcode
    is to make sure it does not have any bad characters.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所知，蛋猎手是一种shellcode，使用shellcode的基本规则是确保它没有任何坏字符。
- en: 'Let''s look at the previous exploit we made:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们之前制作的漏洞利用：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's consider that the shellcode isn't actually after the 6 bytes of jump we
    made in the memory. In this situation, we can use an egg hunter to make a reliable
    exploit for the software.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设shellcode实际上并不在我们在内存中制作的6字节跳转之后。在这种情况下，我们可以使用蛋猎手为软件制作一个可靠的利用。
- en: Now it may sound easy, but there are some complications. We need our final exploit
    to follow the flow like we mentioned in the diagram, but we also need to make
    sure we have enough NOPs in the code to ensure the exploit.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在听起来可能很容易，但也有一些复杂之处。我们需要我们的最终利用程序遵循我们在图表中提到的流程，但我们还需要确保代码中有足够的NOPs来确保利用。
- en: 'This is what our exploit flow should look like, as in our case, we had enough
    memory to have the shellcode. But in other cases, we may not have so much memory,
    or our shellcode may be stored somewhere else in the memory. In those cases, we
    can go for egg hunting, which we will cover in the later recipe:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的利用流程应该如下所示，就像我们的情况一样，我们有足够的内存来存放shellcode。但在其他情况下，我们可能没有那么多内存，或者我们的shellcode可能存储在内存的其他地方。在这些情况下，我们可以使用蛋猎手，我们将在后面的教程中介绍：
- en: '![](img/98bb2d9f-1042-4142-a474-9d170c4f0a7f.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98bb2d9f-1042-4142-a474-9d170c4f0a7f.png)'
- en: 'Following the preceding flow diagram, our shellcode would look something like
    this:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的流程图，我们的shellcode看起来应该是这样的：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We go ahead and save it as `script.py` and run it using `python script.py`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续将其保存为`script.py`并使用`python script.py`运行它。
- en: And, we should have our meterpreter session waiting for us.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而且，我们应该有一个等待我们的meterpreter会话。
- en: The exploit code we wrote may not work in the exact same way on every system
    because there are multiple dependencies depending on the OS version, software
    version, and so on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的利用代码可能无法在每个系统上以完全相同的方式工作，因为有多个依赖项取决于操作系统版本、软件版本等。
- en: See also
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/](https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/](https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/)'
- en: '[http://www.fuzzysecurity.com/tutorials/expDev/4.html](http://www.fuzzysecurity.com/tutorials/expDev/4.html)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.fuzzysecurity.com/tutorials/expDev/4.html](http://www.fuzzysecurity.com/tutorials/expDev/4.html)'
- en: An overview of ASLR and NX bypass
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASLR和NX绕过概述
- en: '**Address Space Layout Randomization** (**ASLR**) was introduced in 2001 by
    PaX project as a Linux patch and was integrated into Windows Vista and later OS.
    It is a memory protection that protects against buffer overflows by randomizing
    the location where executables are loaded in the memory. **Data Execution Prevention**
    (**DEP**) or **no-execute** (**NX**) was also introduced with Internet Explorer
    7 on Windows Vista, and it helps prevent buffer overflows by blocking code execution
    from the memory, which is marked as non-executable.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址空间布局随机化**（**ASLR**）于2001年由PaX项目作为Linux补丁引入，并集成到Windows Vista和后来的操作系统中。这是一种内存保护，通过随机化可执行文件在内存中加载的位置，可以防止缓冲区溢出。**数据执行防护**（**DEP**）或**不执行**（**NX**）也是在Windows
    Vista上的Internet Explorer 7中引入的，它通过阻止从内存中标记为不可执行的代码执行来防止缓冲区溢出。'
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We need to first evade ASLR. There are basically two ways in which ASLR can
    be bypassed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要规避ASLR。基本上有两种方式可以绕过ASLR：
- en: 'We look for any anti-ASLR modules being loaded in the memory. We will have
    the base address of any module at a fixed location. From here, we can use the
    **Return Oriented Programming** (**ROP**) approach. We will basically use small
    parts of code followed by a return instruction and chain everything to get the
    desired result:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们寻找在内存中加载的任何反ASLR模块。我们将在固定位置上有任何模块的基地址。从这里，我们可以使用**返回导向编程**（**ROP**）方法。我们基本上使用代码的小部分，然后是返回指令，并链式连接所有内容以获得所需的结果：
- en: '![](img/84aa6fc8-e246-4289-ae33-e655f26d184b.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84aa6fc8-e246-4289-ae33-e655f26d184b.png)'
- en: 'Source: https://www.slideshare.net/dataera/remix-ondemand-live-randomization-finegrained-live-aslr-during-runtime'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：https://www.slideshare.net/dataera/remix-ondemand-live-randomization-finegrained-live-aslr-during-runtime
- en: We get pointer leak/memory leak here, and we adjust the offset to grab the base
    address of the module whose pointer gets leaked.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里获得指针泄漏/内存泄漏，并调整偏移量以获取泄漏指针的模块的基地址。
- en: Next, we need to bypass the NX/DEP. To do this, we use a well-known *ret-to-libc*
    attack (in Linux) or ROP chaining (in Windows).This method allows us to use `libc`
    functions to perform the task we would have done with our shellcode.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要绕过NX/DEP。为此，我们使用众所周知的*ret-to-libc*攻击（在Linux中）或ROP链接（在Windows中）。这种方法允许我们使用`libc`函数来执行我们本来会用shellcode完成的任务。
- en: There's another method used for bypassing ASLR in 32-bit systems since 32 bit
    is a comparatively small address space compared to 64-bit systems. This makes
    the range of randomization smaller and feasible to brute force.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一种用于绕过32位系统中ASLR的方法，因为32位与64位系统相比具有相对较小的地址空间。这使得随机化范围较小且可行于暴力破解。
- en: This is pretty much the basic concept behind bypassing ASLR and DEP. There are
    many more advanced ways of writing exploits, and as the patches are applied, every
    day new methods are discovered to bypass those.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这基本上是绕过ASLR和DEP的基本概念。还有许多更高级的编写利用程序的方法，随着补丁的应用，每天都会发现新的绕过方法。
- en: See also
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/](https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/](https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/)'
- en: '[http://taishi8117.github.io/2015/11/11/stack-bof-2/](http://taishi8117.github.io/2015/11/11/stack-bof-2/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://taishi8117.github.io/2015/11/11/stack-bof-2/](http://taishi8117.github.io/2015/11/11/stack-bof-2/)'
- en: '[https://www.exploit-db.com/docs/17914.pdf](https://www.exploit-db.com/docs/17914.pdf)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.exploit-db.com/docs/17914.pdf](https://www.exploit-db.com/docs/17914.pdf)'
- en: '[http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html](http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html](http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html)'
- en: '[https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/](https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/](https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/)'
