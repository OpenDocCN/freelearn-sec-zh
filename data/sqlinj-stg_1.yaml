- en: '*Chapter 4*: Attacking Web, Mobile, and IoT Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：攻击Web、移动和物联网应用程序'
- en: Here we are at the fun part of our journey—the core of the practical section
    of this book. So far, we have looked at both the basics and the mechanics of SQL
    injection, including a glimpse of what a successful SQL injection attack can do.
    We also provided a safe and controlled environment that anyone can experience,
    at their own pace, of what a SQL injection attack consists of.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了旅程的有趣部分——本书实践部分的核心。到目前为止，我们已经了解了SQL注入的基础和原理，包括成功的SQL注入攻击可能带来的效果。我们还提供了一个安全受控的环境，任何人都可以按自己的节奏体验SQL注入攻击的组成部分。
- en: In this chapter, we will deal with SQL injection attacks against traditional
    web applications, which is the most common scenario, using both manual and automated
    techniques, relying on the toolset that we discussed in the previous chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论针对传统Web应用程序的SQL注入攻击，这是最常见的攻击场景，使用手动和自动化技术，依赖我们在上一章中讨论的工具集。
- en: 'This chapter is split into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下几个部分：
- en: '**Attacking traditional web applications – manual techniques**: This section
    shows SQL injection attacks performed manually against the vulnerable web applications
    contained in the OWASP **Broken Web Applications** (**BWA**) virtual web server.
    These attacks will be familiar to you, as they are similar to what you''ve already
    encountered in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031),
    *Manipulating SQL – Exploiting SQL Injection*. However, here, we will try a more
    realistic approach by guiding you through the steps that an attacker would follow.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击传统Web应用程序 - 手动技术**：本节展示了针对OWASP **Broken Web Applications** (**BWA**) 虚拟Web服务器中的易受攻击Web应用程序手动执行的SQL注入攻击。你已经在[*第2章*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031)中遇到过类似的内容，*SQL注入操作
    - 利用SQL注入*。不过，在这里，我们将通过引导你逐步了解攻击者会如何进行，来尝试一种更现实的方法。'
- en: '**Attacking traditional web applications– automated techniques**: Once again,
    our target will consist of web applications included within the OWASP BWA project.
    This time, though, we will show the capabilities of automated tools for SQL injection,
    which are used by attackers (and security professionals alike) for efficiency
    purposes.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击传统Web应用程序 - 自动化技术**：我们的目标将依然是包含在OWASP BWA项目中的Web应用程序。不过这一次，我们将展示自动化SQL注入工具的能力，这些工具被攻击者（以及安全专业人员）用于提高效率。'
- en: '**Attacking mobile targets**: In this section, we will look at how mobile applications
    can also be vulnerable to SQL injection attacks, showing practical examples.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击移动目标**：本节将探讨移动应用程序如何也可能容易受到SQL注入攻击，并展示实际的示例。'
- en: '**Attacking IoT targets**: SQL databases can be vulnerable to SQL injection
    whatever the context they find themselves in. The IoT world is no exception. We
    are showing here an attack scenario that could interest IoT systems.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击物联网目标**：无论在何种上下文中，SQL数据库都可能遭受SQL注入攻击。物联网世界也不例外。我们在这里展示一个可能对物联网系统感兴趣的攻击场景。'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this very practical chapter, we strongly recommend that you familiarize
    yourself with the main tools involved. We recommend the following resources, including
    the references from the previous chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一非常实用的章节，我们强烈建议你熟悉主要的相关工具。我们推荐以下资源，包括上一章的参考资料：
- en: https://[www](https://www.virtualbox.org/).virtualbox.org/
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://[www](https://www.virtualbox.org/).virtualbox.org/
- en: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
- en: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
- en: '[https://developer.android.com/studio](https://developer.android.com/studio)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/studio](https://developer.android.com/studio)'
- en: '[https://www.eclipse.org/](https://www.eclipse.org/downloads/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.eclipse.org/](https://www.eclipse.org/downloads/)'
- en: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
- en: '[https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)'
- en: '[https://www.zaproxy.org/](https://www.zaproxy.org/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.zaproxy.org/](https://www.zaproxy.org/)'
- en: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/32d3s2b](https://bit.ly/32d3s2b
    )'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下视频，观看代码实践：[https://bit.ly/32d3s2b](https://bit.ly/32d3s2b)
- en: Attacking traditional web applications– manual techniques
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击传统的 Web 应用程序–手动技术
- en: 'Let''s begin with manual attacks against OWASP BWA web applications. We already
    found, in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031), *Manipulating
    SQL – Exploiting SQL Injection*, an easy attack point for extracting information
    through SQL injection, but we will pretend that each application is independent
    and does not share the same instance of MySQL. For this reason, we will not consider
    the OWASP Vicnum application for this purpose, as it would make things too easy
    for us. Each application will be considered as a separate target so that we can
    explore the intrinsic vulnerabilities residing in them. In this section, we will
    perform SQL attacks against three of the OWASP BWA applications: **Mutillidae
    II**, **Magical Code Injection Rainbow**, and **Peruggia**, putting in practice
    what you have learned so far in a guided setting.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对 OWASP BWA Web 应用程序的手动攻击开始。在[*第 2 章*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031)中，我们已经发现了一个通过
    SQL 注入提取信息的简单攻击点——*操纵 SQL – 利用 SQL 注入*，但我们将假设每个应用程序都是独立的，并且没有共享 MySQL 实例。因此，我们不会考虑
    OWASP Vicnum 应用程序，因为这会让我们太轻松。每个应用程序都将被视为独立的目标，这样我们就可以探索其中的内在漏洞。在本节中，我们将对 OWASP
    BWA 的三个应用程序进行 SQL 攻击：**Mutillidae II**、**Magical Code Injection Rainbow** 和 **Peruggia**，并在引导环境中实践到目前为止所学的内容。
- en: Attacking Mutillidae II
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击 Mutillidae II
- en: 'Our first target is kind of a warm-up—**Mutillidae II** is an application designed
    to provide a test environment for SQL injection using an educational approach,
    also providing some hints about possible attacks that can be executed. You can
    access the SQL Injection section by going through the drop-down menu on the left
    (**OWASP 2013** | **A1 - injection (SQL)**):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个目标有点像热身——**Mutillidae II** 是一个设计用于提供 SQL 注入测试环境的应用程序，采用教育性方法，同时提供一些有关可能执行的攻击的提示。您可以通过左侧的下拉菜单进入
    SQL 注入部分 (**OWASP 2013** | **A1 - 注入（SQL）**)：
- en: '![Figure 4.1 – SQL data extraction page in Mutillidae II'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – Mutillidae II 中的 SQL 数据提取页面'
- en: '](image/B15632_04_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_001.jpg)'
- en: Figure 4.1 – SQL data extraction page in Mutillidae II
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Mutillidae II 中的 SQL 数据提取页面
- en: Let's now demonstrate how to attack this web application in its SQL injection-vulnerable
    web forms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们展示如何攻击这个 Web 应用程序中的 SQL 注入漏洞表单。
- en: Extracting data with SQL injection
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 SQL 注入提取数据
- en: 'Let''s go to the specific page for data extraction with SQL injection testing
    provided by Mutillidae II, following the drop-down menu. First and foremost, we
    will perform the first step in any SQL injection attack: checking whether any
    input validation is present by inserting the most basic injection character—the
    single quote—in the **Name** field:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下拉菜单进入 Mutillidae II 提供的 SQL 注入测试数据提取页面。首先，我们将执行 SQL 注入攻击的第一步：通过在 **Name**
    字段插入最基本的注入字符——单引号，检查是否存在输入验证：
- en: '![Figure 4.2 – SQL data extraction page in Mutillidae II: web form'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – Mutillidae II 中的 SQL 数据提取页面：Web 表单'
- en: '](image/B15632_04_002.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_002.jpg)'
- en: 'Figure 4.2 – SQL data extraction page in Mutillidae II: web form'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Mutillidae II 中的 SQL 数据提取页面：Web 表单
- en: 'Just inserting SQL injection enabling characters can be enough to prove the
    presence of a SQL injection vulnerability. If we have a SQL error, it means that
    the input is interpreted, thus making the query syntax incorrect. After inserting
    the single quote, we do, in fact, get a SQL syntax error:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仅插入 SQL 注入启用字符就足以证明 SQL 注入漏洞的存在。如果出现 SQL 错误，意味着输入被解释，导致查询语法错误。插入单引号后，我们确实得到了
    SQL 语法错误：
- en: '![Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – Mutillidae II 提供的错误信息可视化（0 安全性）'
- en: '](image/B15632_04_003.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_003.jpg)'
- en: Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Mutillidae II 提供的错误信息可视化（0 安全性）
- en: 'In the case of Mutillidae II set at the lowest security level, the error information
    is complete, and also helps us to visualize the complete error information. Let''s
    increase the security level using the **Toggle Security** option, by clicking
    on it once and applying client-side security:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mutillidae II 设置为最低安全级别的情况下，错误信息是完整的，还帮助我们可视化完整的错误信息。让我们通过点击 **Toggle Security**
    选项一次并应用客户端安全性来提高安全级别：
- en: '![Figure 4.4 – Example of client-side control in Mutillidae II'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – Mutillidae II 中的客户端控制示例'
- en: '](image/B15632_04_004.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_004.jpg)'
- en: Figure 4.4 – Example of client-side control in Mutillidae II
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Mutillidae II 中的客户端控制示例
- en: In this case, client-side controls have been applied, preventing blank input
    fields and blocking suspicious characters if both fields are filled, such as inserting
    **' -- -** as the username and any character as the password (such input should,
    if no security controls are applied, entirely ignore what's after the single quote
    character).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用了客户端控制，防止了空输入字段并阻止了可疑字符，前提是两个字段都已填写，例如将**' -- -**作为用户名，并将任何字符作为密码（如果没有应用安全控制，则该输入应完全忽略单引号字符后的内容）。
- en: However, client-side controls are not enough to prevent SQL injection. What
    if we bypass them by using, for example, the parameters in the URL address? (Yes,
    this login happens using **GET** requests by sending data in the URL as input
    parameters.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端控制不足以防止 SQL 注入。假设我们通过使用 URL 地址中的参数来绕过它们怎么办？（是的，登录是通过**GET**请求进行的，通过将数据作为输入参数发送到
    URL 中。）
- en: Let's modify the page URL in the following way. Here, we have a normal URL for
    this page, with **a** as the username and **b** as the p[assword:](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下方式修改页面 URL。在这里，我们有一个正常的页面 URL，用户名为**a**，密码为**b**：[密码：](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)
- en: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Accoun](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)t+Details'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Accoun](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)t+Details'
- en: We are just adding a single quote instead of the [username:](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username='&password=b&user-info-php-submit-button=View+Account+Details)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在 [用户名：](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username='&password=b&user-info-php-submit-button=View+Account+Details)处添加了一个单引号
- en: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Accou](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Account+Details)nt+Details'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Accou](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Account+Details)nt+Details'
- en: 'This triggers another error message, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这会触发另一个错误信息，如下所示：
- en: '![Figure 4.5 – Error message visualization provided by Mutillidae II (client-side
    security)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – Mutillidae II 提供的错误信息可视化（客户端安全性）'
- en: '](image/B15632_04_005.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_005.jpg)'
- en: Figure 4.5 – Error message visualization provided by Mutillidae II (client-side
    security)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Mutillidae II 提供的错误信息可视化（客户端安全性）
- en: Keep in mind that, if this was a **POST** request instead of **GET**, modifying
    the request fields would have been enough to cause a SQL injection. This points
    to the importance of having server-side security controls in place. This is the
    only way to ensure that input is properly handled, independent of the means of
    injection.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果这是**POST**请求而不是**GET**，仅修改请求字段就足以引发 SQL 注入。这突显了服务器端安全控制的重要性。这是确保输入被正确处理的唯一方法，无论注入方式如何。
- en: Therefore, we have proved that the page is vulnerable to SQL injection. The
    input is interpreted as SQL syntax, causing a syntax error due to the incorrect
    statement. The error message also leaks some important information regarding the
    query structure, which could be used to our advantage, and the presence of an
    **accounts** table with fields named **username** and **password**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们证明了该页面易受 SQL 注入攻击。输入被解释为 SQL 语法，由于语句不正确导致语法错误。错误信息还泄露了一些关于查询结构的重要信息，这些信息可以被用来对我们有利，且揭示了一个名为**accounts**的表，其中有**username**和**password**字段。
- en: Let's go a little further with data extraction, shall we? Once we've seen that
    SQL injection is possible, we can try and see whether other techniques work so
    that we can extract data. In a greedy approach, we will now try to see whether
    tautologies work or not.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步进行数据提取，好吗？既然我们已经看到 SQL 注入是可能的，我们可以尝试看看其他技术是否有效，从而提取数据。在一种贪婪的方式下，我们现在尝试查看同义反复（tautologies）是否有效。
- en: 'Let''s try the infamous **'' or 1=1 -- -** string in the username field (in
    the case of client-side security, we would need to edit the parameters just like
    in the previous example without actually using the form). This attempt leads to
    the result in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在用户名字段中输入臭名昭著的 **' or 1=1 -- -** 字符串（如果是客户端安全问题，我们需要像之前的例子那样编辑参数，而不是实际使用表单）。这个尝试会导致以下截图中的结果：
- en: '![Figure 4.6 – Result page for all of the account information records'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 所有账户信息记录的结果页面'
- en: '](image/B15632_04_006.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_006.jpg)'
- en: Figure 4.6 – Result page for all of the account information records
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 所有账户信息记录的结果页面
- en: Using this tautology, we have found the complete login information for all application
    users. At this point, an attacker could gain administrator (**admin**) access
    to the application, with potentially terrible consequences.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个同义命题，我们已经找到了所有应用程序用户的完整登录信息。此时，攻击者可以获得管理员（**admin**）权限，可能会导致严重后果。
- en: So, the application was vulnerable to probably the most powerful SQL injection
    attack to extract information. Let's pretend that this attack was blocked by the
    web application and try a more subtle approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，应用程序很可能对提取信息的 SQL 注入攻击存在漏洞。我们假设这个攻击已被 Web 应用程序阻止，并尝试一种更微妙的方法。
- en: 'We will now try to extract database versioning information using a **UNION**
    query. We need to implement a trial-and-error approach in order to see how many
    columns, and which columns, are shown by the application. We''re saving you this
    process: inserting **'' UNION SELECT 1,@@VERSION,3,4,5,6,7 -- -** will work, as,
    apparently, the **accounts** table (we know its name due to the error information)
    has 7 columns, and the application only shows columns 2, 3, and 4:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试使用 **UNION** 查询提取数据库版本信息。我们需要通过反复试验的方法来查看应用程序显示了多少列，以及哪些列被显示。我们为您节省了这个过程：插入
    **' UNION SELECT 1,@@VERSION,3,4,5,6,7 -- -** 将会有效，因为显然，**accounts** 表（我们通过错误信息知道了它的名称）有
    7 列，而应用程序只显示了列 2、3 和 4：
- en: '![Figure 4.7 – Results page for a UNION query to display the system version'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 使用 UNION 查询显示系统版本的结果页面'
- en: '](image/B15632_04_007.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_007.jpg)'
- en: Figure 4.7 – Results page for a UNION query to display the system version
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 使用 UNION 查询显示系统版本的结果页面
- en: At this point, we discovered not only the versioning of the system but also
    the total number of columns in the **accounts** table, as the original query selected
    all of the fields (**SELECT ***) for that table.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们不仅发现了系统的版本信息，还发现了 **accounts** 表中列的总数，因为原始查询为该表选择了所有字段（**SELECT ***）。
- en: 'We should now be able to extract information about the database schema. We
    already know the database is MySQL from the error messages and the versioning
    information. So, let''s ask for the schema names in the database schema, as discussed
    in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031), *Manipulating
    SQL – Exploiting SQL Injection*. Using the same trick as before, by showing the
    information we need in the second field, we can extract the schema names contained
    in the database:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够提取数据库架构的信息。我们已经通过错误信息和版本信息知道数据库是 MySQL。所以，让我们按照 [*第 2 章*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031)中讨论的内容，要求获取数据库架构中的架构名称，*SQL
    注入攻击 – 利用 SQL 注入*。使用和之前相同的技巧，通过在第二个字段中显示我们需要的信息，我们可以提取数据库中包含的架构名称：
- en: '![Figure 4.8 – Schema names extraction'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 架构名称提取'
- en: '](image/B15632_04_008.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_008.jpg)'
- en: Figure 4.8 – Schema names extraction
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 架构名称提取
- en: We can now move on to the next section of Mutillidae II SQL injection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续进行 Mutillidae II SQL 注入的下一部分。
- en: Bypassing authentication with SQL injection
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过身份验证的 SQL 注入
- en: 'This section is about bypassing the login screen of the Mutillidae II web application.
    You can access this section from the same drop-down menu, as shown in the previous
    section:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分内容关于绕过 Mutillidae II Web 应用程序的登录屏幕。您可以通过与上一部分相同的下拉菜单访问此部分：
- en: '![ Figure 4.9 – SQL data extraction page in Mutillidae II'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![ 图 4.9 – Mutillidae II 中的 SQL 数据提取页面'
- en: '](image/B15632_04_009.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_009.jpg)'
- en: Figure 4.9 – SQL data extraction page in Mutillidae II
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Mutillidae II 中的 SQL 数据提取页面
- en: 'We will now face a typical login web form that requires authenticating with
    both **Username** and **Password**. Let''s first check whether this form is vulnerable
    to SQL injection by triggering some errors using SQL characters, such as single
    quotes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将面对一个典型的登录网页表单，需要用**用户名**和**密码**进行身份验证。首先，让我们通过触发一些错误来检查这个表单是否容易受到 SQL 注入攻击，方法是使用
    SQL 字符，如单引号：
- en: '![Figure 4.10 – The Mutillidae II login page showing an undisclosed error'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – Mutillidae II 登录页面显示未公开的错误'
- en: '](image/B15632_04_010.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_010.jpg)'
- en: Figure 4.10 – The Mutillidae II login page showing an undisclosed error
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – Mutillidae II 登录页面显示未公开的错误
- en: This time, we can tell that an error has occurred. However, the application
    doesn't show (in accordance with the known best practices) the complete error
    information. Nevertheless, we know that the form is vulnerable, as the response
    differs if the wrong account information is used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们可以判断发生了错误。然而，应用程序没有显示（根据已知的最佳实践）完整的错误信息。尽管如此，我们知道表单存在漏洞，因为如果使用错误的账户信息，响应会有所不同。
- en: 'We have already extracted the login information from the previous section,
    so we will try the **admin** access using known credentials:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一节提取了登录信息，因此我们将尝试使用已知的凭据进行**admin**访问：
- en: '![Figure 4.11 – Admin access success'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 管理员访问成功'
- en: '](image/B15632_04_011.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_011.jpg)'
- en: Figure 4.11 – Admin access success
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 管理员访问成功
- en: 'We can also check whether the form is vulnerable to a tautology attack, thus
    granting us access. Let''s try inserting the **'' OR 1=1 -- -** string in the
    **Username** field:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查该表单是否容易受到伪命题攻击，从而让我们获得访问权限。让我们尝试在**用户名**字段中插入**' OR 1=1 -- -** 字符串：
- en: '![Figure 4.12 – Tautology login attempt'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 伪命题登录尝试'
- en: '](image/B15632_04_012.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_012.jpg)'
- en: Figure 4.12 – Tautology login attempt
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 伪命题登录尝试
- en: This authentication bypass attack will also succeed, granting us access once
    again as the **admin** account. Keep in mind that, even if we can authenticate
    as any account in the system, attackers will try to obtain the highest level of
    privilege possible (after all, most applications allow for the creation of user-level
    accounts).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个身份验证绕过攻击也会成功，重新授予我们管理员**admin**账户的访问权限。请记住，即使我们能作为系统中的任何账户进行身份验证，攻击者也会尽力获取尽可能高的权限（毕竟，大多数应用程序允许创建用户级账户）。
- en: Let's now move on to the last SQL injection form type for this application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨这个应用程序的最后一种 SQL 注入形式。
- en: SQL injection in INSERT statements
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INSERT 语句中的 SQL 注入
- en: 'So far, we''ve looked at SQL injection only in **SELECT** statements. Mutillidae
    II offers an account creation page that is linked to an **INSERT** statement in
    order to add new records to the accounts table of the database. It also offers
    two other pages with the capability of adding data to the database. However, we
    will only cover this page in this section, so as not to take too much from other
    topics. Feel free to explore the other two on your own:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅在**SELECT**语句中研究了 SQL 注入。Mutillidae II 提供了一个账户创建页面，该页面与一个**INSERT**语句相关联，用于将新记录添加到数据库的账户表中。它还提供了另外两个可以向数据库添加数据的页面。然而，我们在本节中仅讨论这个页面，以免占用其他话题的篇幅。欢迎你自己探索其他两个页面：
- en: '![Figure 4.13 – Accessing the account creation page'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 访问账户创建页面'
- en: '](image/B15632_04_013.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_013.jpg)'
- en: Figure 4.13 – Accessing the account creation page
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 访问账户创建页面
- en: 'The account creation page is not supposed to return any records, as its primary
    purpose is to (yes—you guessed it) add users to the accounts table of the database.
    Therefore, it looks like a nice place to try blind SQL injection in this context:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 账户创建页面不应该返回任何记录，因为其主要目的是（没错，你猜对了）将用户添加到数据库的账户表中。因此，在这个上下文中，它看起来是一个尝试盲注 SQL 注入的好地方：
- en: '![Figure 4.14 – Account creation form'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 账户创建表单'
- en: '](image/B15632_04_014.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_014.jpg)'
- en: Figure 4.14 – Account creation form
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 账户创建表单
- en: 'First, we can trigger an error message to check the query syntax and examine
    where we could inject our commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以触发错误信息，检查查询语法，并检查我们可以在哪里注入命令：
- en: '![Figure 4.15 – Error message for inserting a single quote as the username'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 插入单引号作为用户名的错误信息'
- en: '](image/B15632_04_015.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_015.jpg)'
- en: Figure 4.15 – Error message for inserting a single quote as the username
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 插入单引号作为用户名的错误信息
- en: 'We now have the query structure so that we can alter the command through SQL
    syntax. One example could be to retrieve sensitive information using subqueries
    with the help of **SELECT** statements. Let''s try creating a user with the MySQL
    root account password as a signature. We will first try the **test'',''test'',(SELECT
    password FROM mysql.user WHERE user=''root''))-- -** payload in the username field
    to obtain this result:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了查询结构，这样我们就可以通过 SQL 语法来修改命令。一个例子可能是通过使用 **SELECT** 语句的子查询来检索敏感信息。让我们尝试使用
    MySQL 根账户密码作为签名创建一个用户。我们将首先尝试在用户名字段中使用 **test','test',(SELECT password FROM mysql.user
    WHERE user='root'))-- -** 载荷，以获得以下结果：
- en: '![Figure 4.16 – MySQL error; the subquery returns more than one result'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – MySQL 错误；子查询返回多个结果'
- en: '](image/B15632_04_016.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_016.jpg)'
- en: Figure 4.16 – MySQL error; the subquery returns more than one result
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – MySQL 错误；子查询返回多个结果
- en: 'Here, the **SELECT** query apparently returned more rows than we thought. To
    solve this problem, we need a way to view a single result. A trivial solution
    is through the **LIMIT 1** clause at the end of the **SELECT** query, which is
    used for limiting the results to only one, resulting in a success. Let''s use
    the login panel to finally check our value using our newly created credentials:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**SELECT** 查询显然返回的行数比我们预期的更多。为了解决这个问题，我们需要一种方法来查看单个结果。一种简单的解决方案是在 **SELECT**
    查询的末尾使用 **LIMIT 1** 子句，它用于将结果限制为仅一个，从而实现成功。让我们使用登录面板，最终通过我们新创建的凭据来检查我们的值：
- en: '![Figure 4.17 – The Mutillidae II upper panel after successful authentication'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – 通过成功身份验证后的 Mutillidae II 上方面板'
- en: '](image/B15632_04_017.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_017.jpg)'
- en: Figure 4.17 – The Mutillidae II upper panel after successful authentication
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 通过成功身份验证后的 Mutillidae II 上方面板
- en: Here, an attacker could have used the registration form to retrieve sensitive
    information (in this case, the password hash for the MySQL root account). This
    is despite it not being a query designed to return data. This example was to show
    how SQL injection can provide attackers with versatile tools, as long as the attacker
    knows the appropriate SQL syntax.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，攻击者可以使用注册表单来检索敏感信息（在这种情况下，是 MySQL 根账户的密码哈希）。即使它不是一个设计用来返回数据的查询，这也能实现。这个例子是为了展示
    SQL 注入如何为攻击者提供多种工具，只要攻击者知道合适的 SQL 语法。
- en: 'We can now approach the next web application of our crash course: the Magical
    Code Injection Rainbow.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入我们的速成课程的下一个 Web 应用程序：Magical Code Injection Rainbow。
- en: The Magical Code Injection Rainbow
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Magical Code Injection Rainbow
- en: 'With the **Magical Code Injection Rainbow**, we have an application designed
    for training in code injection. We are interested in the SQL part, aptly named
    **SQLol**, which also provides examples including some server-side defenses. This
    time, we will be going through the first six challenges provided by this application
    and providing solutions for each. Feel free to try them (or the following ones)
    on your own. At this point, with the help of the MySQL documentation, you should
    be able to complete them using what you have learned in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020),
    *Structured Query Language for SQL Injection*, and [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031),
    *Manipulating SQL – Exploiting SQL Injection*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Magical Code Injection Rainbow** 中，我们有一个用于代码注入训练的应用程序。我们关注的是 SQL 部分，恰当地命名为
    **SQLol**，它还提供了一些包括服务器端防御的示例。这一次，我们将通过这个应用程序提供的前六个挑战，并为每个挑战提供解决方案。随时可以自己尝试这些（或接下来的挑战）。此时，在
    MySQL 文档的帮助下，您应该能够利用在 [*第 1 章*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020)
    中学到的知识，完成它们，*SQL 注入的结构化查询语言*，以及 [*第 2 章*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031)，*操控
    SQL – 利用 SQL 注入*：
- en: '![Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – Magical Code Injection Rainbow SQLol - 挑战界面'
- en: '](image/B15632_04_018.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_018.jpg)'
- en: Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – Magical Code Injection Rainbow SQLol - 挑战界面
- en: Access the challenges by selecting **SQLol** from the home screen, and then
    selecting **Challenges**. You will always have a single text field to insert the
    payload into, so you know that's the only way to insert SQL payloads.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从主屏幕选择 **SQLol**，然后选择 **Challenges** 来访问这些挑战。你将始终有一个文本字段用于插入载荷，因此你知道那是插入 SQL
    载荷的唯一方式。
- en: Challenge 0 – Hello, world!
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 0 – 你好，世界！
- en: This is the most basic challenge in the list. Here, you need to return all of
    the usernames from the user table of the database using a **SELECT** query, and
    perform the injection in the **WHERE** clause. This is a typical setting for the
    **SELECT** queries that we've seen so far.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是列表中最基本的挑战。在这里，您需要使用 **SELECT** 查询从数据库的用户表返回所有用户名，并在 **WHERE** 子句中执行注入。这是我们迄今为止看到的
    **SELECT** 查询的典型设置。
- en: This is pretty simple to do. It's enough to provide a condition where the **WHERE**
    condition is always true, and we know the exact way to do tautologies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做到。只需提供一个总是为真的条件，并且我们知道如何进行类推。
- en: 'Our payload will be **'' OR 1=1 -- -**, resulting in our desired output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的有效负载将是 **' OR 1=1 -- -**，导致我们期望的输出：
- en: '![Figure 4.19 – SQLol challenge 0 results'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.19 – SQLol 挑战 0 结果'
- en: '](image/B15632_04_019.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_019.jpg)'
- en: Figure 4.19 – SQLol challenge 0 results
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.19 – SQLol 挑战 0 结果
- en: This was pretty easy, right? We just returned all of the usernames with the
    simplest SQL injection possible. Let's now move on to the second challenge.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，对吧？我们只是以可能的最简单的SQL注入方式返回了所有用户名。现在让我们继续进行第二个挑战。
- en: Challenge 1 – SQL injection 101
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 1 – SQL 注入 101
- en: 'This is also a fairly simple challenge; that said, it requires a bit of reconnaissance
    in order to discover the query structure. This time, we need to find the table
    containing the social security numbers that are present in the database and return
    the full content in the query output. Once again, we are dealing with a **SELECT**
    query and injecting in the **WHERE** clause:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个相当简单的挑战；话虽如此，它需要一些侦察，以便发现查询结构。这一次，我们需要找到包含数据库中存在的社会安全号码的表，并在查询输出中返回完整内容。再次，我们使用
    **SELECT** 查询，并在 **WHERE** 子句中进行注入：
- en: First, we need to uncover what the social security number table is called. To
    do this, we need to check the MySQL **information_schema** table using **UNION**
    queries. We first need to find the table name with the **' UNION SELECT table_name
    FROM information_schema.tables -- -** payload. Alternatively, we could also refine
    the search by adding clauses such as **LIKE** with certain desired characteristics
    (for example, **WHERE table_name LIKE ' %ssn%'** for table names containing **ssn**):![Figure
    4.20 – SQLol challenge 1 results
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要找出社会安全号码表的名称。为此，我们需要使用 **UNION** 查询检查 MySQL 的 **information_schema**
    表。我们首先需要使用 **' UNION SELECT table_name FROM information_schema.tables -- -** 有效负载找到表名。或者，我们还可以通过添加诸如
    **LIKE** 等带有特定期望特征的子句（例如，对于包含 **ssn** 的表名，使用 **WHERE table_name LIKE '%ssn%'**）来细化搜索：![Figure
    4.20 – SQLol 挑战 1 结果
- en: '](image/B15632_04_020.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_020.jpg)'
- en: Figure 4.20 – SQLol challenge 1 results
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 4.20 – SQLol 挑战 1 结果
- en: At this point, we need to extract the column names from the table using the
    **' UNION SELECT column_name FROM information_schema.columns WHERE table_name='ssn'
    -- -** payload:![Figure 4.21 – SQLol challenge 1 results
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们需要使用 **' UNION SELECT column_name FROM information_schema.columns WHERE
    table_name='ssn' -- -** 有效负载从表中提取列名：![Figure 4.21 – SQLol 挑战 1 结果
- en: '](image/B15632_04_021.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_021.jpg)'
- en: Figure 4.21 – SQLol challenge 1 results
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 4.21 – SQLol 挑战 1 结果
- en: 'Now we just have to query the **ssn** table for each field one at a time. Alternatively,
    we could use a more elegant solution with the **CONCAT()** operator:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需逐个字段查询 **ssn** 表。或者，我们可以使用更加优雅的解决方案，即 **CONCAT()** 运算符：
- en: '![Figure 4.22 – SQLol challenge 1 final results'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.22 – SQLol 挑战 1 最终结果'
- en: '](image/B15632_04_022.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_022.jpg)'
- en: Figure 4.22 – SQLol challenge 1 final results
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.22 – SQLol 挑战 1 最终结果
- en: Here, we have the social security numbers for all users in one place. Let's
    move on to the third challenge.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有所有用户的社会安全号码集中在一个地方。让我们继续进行第三个挑战。
- en: Challenge 2 – The Failure of Quote Filters
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 2 – 单引号过滤的失败
- en: 'This challenge is a carbon copy of the previous one but with a twist: the single
    quote character, which is the most common enabler for SQL, is entirely ignored
    from the query string, rendering the attack that we just performed ineffective.
    However, the sanitization measure just ignores the character at the input level.
    But what if it''s still evaluated by the database at runtime? Consider the following
    steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战与前一个挑战几乎一模一样，但有一个小变化：单引号字符，这是SQL中最常见的激活器，完全从查询字符串中忽略，使我们刚刚执行的攻击失效。然而，净化措施只是在输入级别忽略了字符。但是，如果它在运行时被数据库评估怎么办？考虑以下步骤：
- en: 'Let''s use the **CHAR(27) UNION SELECT 1 -- -** payload to add the value of
    **1** to the end of the query. **CHAR()** is a function, supported in MySQL, that
    translates a number to its ASCII character equivalent. In this case, it is the
    single quote:![Figure 4.23 – SQLol challenge 2: defeating single quote escaping'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用**CHAR(27) UNION SELECT 1 -- -** 负载将**1**的值添加到查询末尾。**CHAR()**是 MySQL 中支持的一个函数，用于将数字转换为其
    ASCII 字符等效值。在这种情况下，它是单引号：![图 4.23 – SQLol 挑战 2：击败单引号转义
- en: '](image/B15632_04_023.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_023.jpg)'
- en: 'Figure 4.23 – SQLol challenge 2: defeating single quote escaping'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.23 – SQLol 挑战 2：击败单引号转义
- en: 'At this point, we can perform the challenge 1 attack by substituting the single
    quote with **CHAR(27)**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以通过用**CHAR(27)**替代单引号来执行挑战 1 攻击：
- en: '![Figure 4.24 – SQLol challenge 2 final results'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.24 – SQLol 挑战 2 最终结果'
- en: '](image/B15632_04_024.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_024.jpg)'
- en: Figure 4.24 – SQLol challenge 2 final results
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – SQLol 挑战 2 最终结果
- en: Let's now move on to the next challenge.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个挑战。
- en: Challenge 3 – Death Row
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 3 – 死囚
- en: This challenge is another clone of the first challenge. However, this time,
    it will only show one result at a time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战是第一个挑战的另一个克隆版本。不同之处在于，这次它每次只会显示一个结果。
- en: Luckily, we already know the contents of the table, so we will skip to the final
    step of the attack, directly moving to the approach required for this specific
    challenge.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经知道表的内容，因此可以跳到攻击的最后一步，直接进入此特定挑战所需的方法。
- en: 'We can try the same payload. However, this time, add **LIMIT 1** to the end
    to ensure our SQL query returns only one result, independent of the application
    server measures applied to this challenge, and then use **OFFSET** to go through
    each result one at a time. The resulting payload for returning only the second
    result will, therefore, be **'' UNION SELECT CONCAT(name, " ", ssn) FROM ssn LIMIT
    1 OFFSET 1-- -**, as **OFFSET** starts from **0** for the first result and increases
    by one for each subsequent row:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试相同的负载。然而，这次，在末尾添加**LIMIT 1**，确保我们的 SQL 查询仅返回一个结果，无论应用服务器为此挑战所采取的措施如何，然后使用**OFFSET**逐个查看每个结果。因此，返回第二个结果的负载将是**'
    UNION SELECT CONCAT(name, " ", ssn) FROM ssn LIMIT 1 OFFSET 1-- -**，因为**OFFSET**从**0**开始表示第一个结果，并且对于每一行后续结果递增：
- en: '![Figure 4.25 – The second result of SQLol challenge 3'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.25 – SQLol 挑战 3 的第二个结果'
- en: '](image/B15632_04_025.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_025.jpg)'
- en: Figure 4.25 – The second result of SQLol challenge 3
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – SQLol 挑战 3 的第二个结果
- en: We can now move on to the next challenge.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续下一个挑战。
- en: Challenge 4 – War on Error
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 4 – 错误战争
- en: This challenge is another clone of the social security number challenge. However,
    this time, the output will not be visualized. The challenge consists of extracting
    information using only the verbose error messages provided, without the blind
    SQL injection techniques.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战是社会保障号挑战的另一个克隆版本。不过，这次输出不会以可视化方式呈现。这个挑战的目的是仅通过提供的详细错误信息提取信息，而不使用盲目 SQL 注入技术。
- en: Our best bet is to show the query results inside an error message. One possible
    way to do this is through the use of expressions that evaluate some kind of non-strictly
    SQL syntax.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最好的方法是将查询结果显示在错误消息中。实现这一目标的一种可能方式是使用某种非严格 SQL 语法的表达式。
- en: An example of this is the **ExtractValue()** function, which extracts values
    from **XML** (the first argument) using the **XPATH** syntax (the second argument).
    We need to make sure there are no empty spaces in between, so as not to generate
    SQL syntax errors. Instead, we need to cause an XML evaluation error, possibly
    via the misconstruction of the **XPATH** syntax, and insert our SQL query inside
    of it. This is so that the SQL syntax is correctly evaluated and the query results
    are leaked in the error message.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是**ExtractValue()**函数，它从**XML**（第一个参数）中提取值，使用**XPATH**语法（第二个参数）。我们需要确保其中没有空格，以免产生
    SQL 语法错误。相反，我们需要通过错误构造的**XPATH**语法引发 XML 评估错误，并将我们的 SQL 查询插入其中。这样可以确保 SQL 语法正确评估，查询结果会在错误消息中泄露。
- en: 'We will try the following payload. Note that since we can only view one result
    at a time, we need the **LIMIT 1** clause when changing the offset each time:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试以下负载。请注意，由于每次只能查看一个结果，我们需要在每次更改偏移量时使用**LIMIT 1**子句：
- en: '''AND ExtractValue(''randomxml'',CONCAT(''='',(SELECT CONCAT(name,''-'',ssn)
    FROM ssn LIMIT 1 OFFSET 0)))=''x'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '''AND ExtractValue(''randomxml'',CONCAT(''='',(SELECT CONCAT(name,''-'',ssn)
    FROM ssn LIMIT 1 OFFSET 0)))=''x'
- en: 'The payload worked as intended, and the query result is shown as an **XPATH**
    syntax error. We only need to iterate the query with all of the remaining offsets,
    and we can extract the entirety of the table''s contents through error messages:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷按预期工作，查询结果显示为 **XPATH** 语法错误。我们只需迭代查询与所有剩余的偏移量，并且可以通过错误消息提取整个表的内容：
- en: '![Figure 4.26 – SQLol challenge 4 result'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.26 – SQLol 挑战 4 结果'
- en: '](image/B15632_04_026.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_026.jpg)'
- en: Figure 4.26 – SQLol challenge 4 result
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – SQLol 挑战 4 结果
- en: Now that we have demonstrated this interesting attack method, let's finally
    move on to our last challenge from this application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了这种有趣的攻击方法，最后让我们进入这个应用程序中的最后一个挑战。
- en: Challenge 5 – Blind Luck
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战 5 – 盲目运气
- en: This final challenge is another social security number challenge. However, this
    time, both the output and error messages are not visualized. The challenge consists
    of extracting information using blind SQL injection techniques. To help us, we
    have Boolean results that tell us whether the query is successful (that is, whether
    it returns at least one record) or not.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终挑战是另一个社会保障号码挑战。然而，这次输出和错误信息没有可视化。挑战的内容是使用盲目 SQL 注入技术提取信息。为了帮助我们，我们有布尔结果来告诉我们查询是否成功（即，是否返回至少一条记录）。
- en: 'If we were to extract the information from the SSN table, then, this time,
    we would need to use inference techniques. Luckily, we don''t need to check for
    particularly cryptic clues in the response, since we can rely on the Boolean result.
    First, just to show the Boolean result, we will look for the **ssn** table by
    querying the **information_schema.tables** table. We will inject the **'' UNION
    SELECT table_name FROM information_schema.tables WHERE table_name=''ssn''-- -**
    payload to check for it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从 SSN 表中提取信息，那么这次我们需要使用推理技术。幸运的是，我们不需要检查响应中的特别难解的线索，因为我们可以依赖布尔结果。首先，为了显示布尔结果，我们将通过查询
    **information_schema.tables** 表来查找 **ssn** 表。我们将注入 **' UNION SELECT table_name
    FROM information_schema.tables WHERE table_name='ssn'-- -** 有效载荷来检查它：
- en: '![Figure 4.27 – SQLol challenge 5 Boolean result'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.27 – SQLol 挑战 5 布尔结果'
- en: '](image/B15632_04_027.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_027.jpg)'
- en: Figure 4.27 – SQLol challenge 5 Boolean result
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – SQLol 挑战 5 布尔结果
- en: Now that we know what a true result looks like, we can guess the output using
    checks. Since we need to reconstruct the data, we need a way to spot the content
    of the table using only Boolean answers. The most common technique we can use
    is to check for single characters using the **SUBSTRING(s, d, n)** function. This
    takes, given s tring **s**, the number (**n**) of characters after the position,
    **p**, of that string. **SUBSTRING('hello', 1, 1)** would return **h**, which
    is located at a **1** character distance after the first position (**1**).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么是真正的结果，我们可以通过检查来猜测输出。由于我们需要重建数据，我们需要一种仅通过布尔答案来识别表内容的方法。我们可以使用的最常见技术是通过
    **SUBSTRING(s, d, n)** 函数检查单个字符。该函数接受字符串 **s**，该字符串的 **n** 个字符，位置 **p**。**SUBSTRING('hello',
    1, 1)** 将返回 **h**，它位于第一个位置（**1**）后面 **1** 个字符的位置。
- en: 'For each record, we will check the characters of the fields one by one, using
    both the **SUBSTRING()** function and the **LIMIT 1 OFFSET** clause, as we need
    to check each record separately in order to infer them with certainty. This is
    definitely a long process, but we have another trick up our sleeve to speed it
    all up: **binary search**. We will use the **ASCII()** function, which returns
    the ASCII encoding number of a single character, and compare it each time with
    a number, which will be the pivot of our binary search. In the ASCII encoding,
    we have 255 possible values, so our optimal pivot will be the middle value (128).
    By comparing this with 128, we can tell whether the character belongs to the lower
    or upper part of the range, and we will split our possible range into two each
    time.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条记录，我们将逐个检查字段的字符，使用 **SUBSTRING()** 函数和 **LIMIT 1 OFFSET** 子句，因为我们需要单独检查每条记录，以便确定它们。这个过程确实很长，但我们还有一个加速整个过程的小技巧：**二分查找**。我们将使用
    **ASCII()** 函数，该函数返回单个字符的 ASCII 编码，并且每次与一个数字进行比较，这个数字将作为二分查找的枢轴。在 ASCII 编码中，我们有
    255 个可能的值，所以我们的最佳枢轴值将是中间值（128）。通过与 128 进行比较，我们可以知道该字符属于范围的下半部分还是上半部分，并且每次将可能的范围分为两部分。
- en: If, for example, our check tells us that the character's ASCII is equal or greater
    than 128, then next time we will try with 192 as the pivot. If not, we will go
    down to 64\. Each time, we will be splitting the range into two, thus drastically
    reducing the number of steps for guessing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的检查结果显示字符的 ASCII 值大于或等于 128，那么下次我们将尝试以 192 作为支点。如果不是，我们将降低到 64。每次，我们都会将范围分成两部分，从而大大减少猜测的步数。
- en: For this walk-through, once again, we will skip directly to the **ssn** table.
    However, for the complete attack, you should apply this method to all of the earlier
    discovery steps and the table fields too. We prefer to leave this up to the reader
    to decide.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次演练中，我们将直接跳到 **ssn** 表。然而，对于完整的攻击，你应该将这种方法应用于所有先前的发现步骤和表字段。我们更倾向于让读者自己决定这一点。
- en: 'Let''s try using the **'' OR ASCII(SUBSTRING((SELECT NAME FROM SSN LIMIT 1
    OFFSET 0),1,1)) >= 128 -- -** payload to apply this principle to our specific
    case, with number 128 as the pivot of our search:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 **' OR ASCII(SUBSTRING((SELECT NAME FROM SSN LIMIT 1 OFFSET 0),1,1))
    >= 128 -- -** 载荷，将这一原则应用到我们特定的案例中，使用 128 作为我们搜索的支点：
- en: '![Figure 4.28 – SQLol challenge 5 inference attempt; no results'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.28 – SQLol 挑战 5 推断尝试；无结果'
- en: '](image/B15632_04_028.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_028.jpg)'
- en: Figure 4.28 – SQLol challenge 5 inference attempt; no results
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – SQLol 挑战 5 推断尝试；无结果
- en: 'Here is the step-by-step iterative process for the binary search:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是二分查找的逐步迭代过程：
- en: With a false result, we can infer that our character belongs to the first 128
    (0 to 127) ASCII characters.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过错误结果，我们可以推断出我们的字符属于前 128 个（0 到 127）ASCII 字符。
- en: Using 64 (128/2) as the pivot for our binary search returns a true result. This
    means our character is within the range of 64 and 127.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 64（128/2）作为二分查找的支点返回了正确的结果。这意味着我们的字符在 64 和 127 之间。
- en: Pivot 96 (64 + 32) doesn't return any results, so we will try 80 (96-16). Still,
    there are no results.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 96（64 + 32）为支点没有返回任何结果，所以我们将尝试 80（96-16）。仍然没有结果。
- en: Our next attempt is 72 (80 - 8), which succeeds. This means we will try 76 (72
    + 4) next.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一个尝试是 72（80 - 8），成功了。这意味着接下来我们将尝试 76（72 + 4）。
- en: '76 fails, which means our number is within the range of 72 and 75\. At this
    point, we will try 72:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 76 失败，这意味着我们的数字在 72 和 75 之间。此时，我们将尝试 72：
- en: '![Figure 4.29 – Final step of inference; direct comparison (success)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 推断的最后一步；直接比较（成功）'
- en: '](image/B15632_04_029.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_029.jpg)'
- en: Figure 4.29 – Final step of inference; direct comparison (success)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 推断的最后一步；直接比较（成功）
- en: Following these steps, we know that the first character of the first record
    corresponds to the ASCII character of 72, which is capital **H** (the first letter
    of the name, **Herp Derper**, in the **ssn** table).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些步骤，我们知道第一条记录的第一个字符对应的 ASCII 字符是 72，即大写 **H**（**Herp Derper** 表中的名字首字母）。
- en: 'Finally, we can obtain all of the values from our table by applying the same
    principle for all characters of any entries and fields we want, and also use it
    for double-checking:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过对所有条目和字段的所有字符应用相同的原则，我们可以从表中获取所有值，并进行双重检查：
- en: '![Figure 4.30 – SQLol Challenge 5; inference double-check'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.30 – SQLol 挑战 5；推断复核'
- en: '](image/B15632_04_030.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_030.jpg)'
- en: Figure 4.30 – SQLol Challenge 5; inference double-check
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – SQLol 挑战 5；推断复核
- en: 'This concludes our guided tour through the SQL challenges of the Magical Code
    Injection Rainbow. We would love to go on with this fun walk-through, but we don''t
    want to give too much space to this application, so instead, we''ll focus on a
    wider range of targets. We will now proceed with our last OWASP BWA target for
    this section: the Peruggia web app.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们通过《魔法代码注入彩虹》中的 SQL 挑战的指导性介绍。我们很愿意继续这个有趣的演练，但不想给这个应用程序占用太多篇幅，因此接下来我们将聚焦于更广泛的目标。现在，我们将继续本节的最后一个
    OWASP BWA 目标：Peruggia 网络应用。
- en: Attacking Peruggia
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击 Peruggia
- en: 'As stated in [*Chapter 3*](B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050),
    *Setting Up the Environment*, Peruggia is a purposely vulnerable web app that
    mimics the behavior of a regular (despite possibly dated) web application. In
    this case, we won''t have tutorials or challenges, but it''s just us and the application,
    with no hints or help whatsoever:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [*第 3 章*](B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050) 《设置环境》中所述，*Peruggia
    是一个故意设置为易受攻击的 Web 应用程序，它模拟了一个常规的（尽管可能过时的）Web 应用程序的行为。* 在这种情况下，我们不会有教程或挑战，只有我们和应用程序，完全没有提示或帮助：
- en: '![Figure 4.31 – The Peruggia home screen'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31 – Peruggia 主屏幕'
- en: '](image/B15632_04_031.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_031.jpg)'
- en: Figure 4.31 – The Peruggia home screen
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – Peruggia 主界面
- en: Let's now look at how we can use SQL injection to attack this application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何利用 SQL 注入攻击这个应用程序。
- en: SQL injection in the login panel
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 注入在登录面板中的应用
- en: Our first stop is the login panel of the application. We can access it by clicking
    on **Login** at the top of the page. Here, we have a scenario where we don't have
    any output from our SQL injection attempts. In fact, no SQL errors are even displayed
    (as it should be in a secure application, after all).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一站是应用程序的登录面板。我们可以通过点击页面顶部的**登录**来访问它。在这里，我们遇到了一个情况，即我们的 SQL 注入尝试没有任何输出。事实上，甚至没有显示
    SQL 错误（毕竟，这应该是在安全应用程序中的表现）。
- en: Additionally, by examining the page and its response and interaction, we can't
    grasp any meaningful differences between a successful SQL injection attempt or
    an unsuccessful one. This means that we have no way of extracting information
    from the login form. The application enforces a good design principle in this
    case by not letting the database server communicate directly with the user. However,
    this is not enough. Even if the application does not let the database server expose
    query results, errors, or any other meaningful information, that does not mean
    it is not vulnerable to SQL injection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过检查页面及其响应和交互，我们无法从成功的 SQL 注入尝试与失败的 SQL 注入尝试中区分出任何有意义的差异。这意味着我们无法从登录表单中提取信息。该应用程序通过不允许数据库服务器与用户直接通信，在这种情况下执行了一个好的设计原则。然而，这还不够。即使应用程序不让数据库服务器暴露查询结果、错误或任何其他有意义的信息，这并不意味着它不容易受到
    SQL 注入攻击。
- en: 'Let''s attempt the most trivial SQL injection attack: a tautology. In most
    cases, an attempt like this would result in a total login bypass, granting us
    access to the application. In the following screenshot, we are attempting a tautology
    attack, as demonstrated in the previous applications:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试最简单的 SQL 注入攻击：同义命题攻击。在大多数情况下，像这样的攻击会导致完全绕过登录，从而使我们能够访问该应用程序。在以下截图中，我们正在尝试如前所示的同义命题攻击：
- en: '![Figure 4.32 – Peruggia login bypass attempt'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.32 – Peruggia 登录绕过尝试'
- en: '](image/B15632_04_032.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_032.jpg)'
- en: Figure 4.32 – Peruggia login bypass attempt
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – Peruggia 登录绕过尝试
- en: 'The tautology attack has succeeded. This not only means that the web application
    is vulnerable to SQL injection, but we can use the login screen to perform inference
    attacks. Whenever access is granted, this means that the Boolean check we are
    performing is true, as confirmed in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同义命题攻击已成功。这不仅意味着该 Web 应用程序容易受到 SQL 注入攻击，而且我们还可以利用登录界面进行推理攻击。每当成功登录时，这意味着我们执行的布尔检查为真，如下图所示：
- en: '![Figure 4.33 – Peruggia''s upper screen after a successful admin login'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.33 – 成功管理员登录后的 Peruggia 上层界面'
- en: '](image/B15632_04_033.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_033.jpg)'
- en: Figure 4.33 – Peruggia's upper screen after a successful admin login
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – 成功管理员登录后的 Peruggia 上层界面
- en: 'This means that, similarly to challenge 5 of the Magical Code Injection Rainbow
    SQLol, we can extract whatever information we want from the database. Let''s try
    the same double-check query we made at the end of challenge 5\. This time, we
    will extract data from a different schema, so we need to specify the schema of
    the table we are extracting data from:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，类似于《神奇代码注入彩虹 SQLol》挑战 5，我们可以从数据库中提取我们想要的任何信息。让我们尝试在挑战 5 结束时做的双重检查查询。这次，我们将从不同的模式中提取数据，因此我们需要指定我们要提取数据的表的模式：
- en: ''' OR (SELECT NAME FROM SQLOL.SSN LIMIT 1 OFFSET 0) = "Herp Derper" -- -'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ''' OR (SELECT NAME FROM SQLOL.SSN LIMIT 1 OFFSET 0) = "Herp Derper" -- -'
- en: This will grant us access, which means that the information we checked (again)
    is true. This can be done to apply inference techniques to the content of the
    database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们访问，这意味着我们检查的信息（再次）为真。通过这种方式，我们可以对数据库的内容应用推理技术。
- en: 'This example confirms the power of SQL injection as a flexible means to obtain
    all sorts of information from a database. This attempt could have also worked
    if we had created a new account legitimately. In Peruggia, we also have the **User**
    account, and the login bypass allows us to log in for every user that we want,
    as long as we specify it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子确认了 SQL 注入作为一种灵活手段，从数据库中获取各种信息的强大威力。即使我们合法创建了一个新账户，这次尝试也可能成功。在 Peruggia
    中，我们也有**用户**账户，登录绕过功能允许我们为每个用户登录，只要我们指定它：
- en: '![Figure 4.34– Peruggia login bypass example'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.34 – Peruggia 登录绕过示例'
- en: '](image/B15632_04_034.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_034.jpg)'
- en: Figure 4.34– Peruggia login bypass example
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34 – Peruggia 登录绕过示例
- en: The resulting query just checks for the **WHERE** condition. In this case, it
    is just the existence of a record with the username, **User**, as we cut the rest
    of the query as a comment. In the end, if this example of SQL injection is present,
    even if the results are not shown directly, the same principles of blind SQL injection
    and inference can be applied.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 结果查询仅检查 **WHERE** 条件。在这种情况下，它只是检查是否存在一个用户名为 **User** 的记录，因为我们将查询的其余部分作为注释处理。如果出现此
    SQL 注入示例，即使结果没有直接显示，盲注和推断的 SQL 注入原理仍然适用。
- en: SQL injection in the Add Comment page
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加评论页面中的 SQL 注入
- en: 'Besides the login screen, we also can try other parameters in the application.
    In Peruggia''s home screen, we can try accessing (unauthenticated) the comment
    section through the link marked **Comment on this picture**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了登录页面，我们还可以尝试在应用程序中测试其他参数。在 Peruggia 的主页上，我们可以通过标有 **Comment on this picture**
    的链接，尝试访问（未认证）评论区：
- en: '![Figure 4.35 – Peruggia''s Add Comment page (with URL)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.35 – Peruggia 的添加评论页面（带 URL）'
- en: '](image/B15632_04_035.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_035.jpg)'
- en: Figure 4.35 – Peruggia's Add Comment page (with URL)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.35 – Peruggia 的添加评论页面（带 URL）
- en: 'We have a **pic_id** parameter in the page URL, which we could try to manipulate.
    If we changed it to a nonexistent ID, such as **123456789**, we would visualize
    an empty picture:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面 URL 中有一个 **pic_id** 参数，我们可以尝试对其进行操作。如果我们将其更改为一个不存在的 ID，例如 **123456789**，我们将看到一个空图片：
- en: '![Figure 4.36 – Peruggia''s Add Comment page for nonexistent pictures'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.36 – Peruggia 的不存在图片的添加评论页面'
- en: '](image/B15632_04_036.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_036.jpg)'
- en: Figure 4.36 – Peruggia's Add Comment page for nonexistent pictures
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.36 – Peruggia 的不存在图片的添加评论页面
- en: 'Now we will try to insert the correct SQL syntax and see whether it''s evaluated
    by the application. Let''s try inserting **123456789 OR 1=1** into our address
    bar as the **pic_id** parameter. We can see that, even if we insert the wrong
    ID, we visualized the picture present with ID **1** anyway. This proves that the
    parameter evaluates SQL input, and, therefore, is vulnerable to SQL injection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试插入正确的 SQL 语法，看看它是否会被应用程序评估。让我们尝试将 **123456789 OR 1=1** 插入地址栏作为 **pic_id**
    参数。我们可以看到，即使我们插入了错误的 ID，我们依然能够看到 ID 为 **1** 的图片。这证明该参数会评估 SQL 输入，因此容易受到 SQL 注入攻击：
- en: '![Figure 4.37 – The pic_id parameter is vulnerable to SQL injection'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.37 – pic_id 参数易受 SQL 注入攻击'
- en: '](image/B15632_04_037.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_037.jpg)'
- en: Figure 4.37 – The pic_id parameter is vulnerable to SQL injection
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.37 – pic_id 参数易受 SQL 注入攻击
- en: 'At this point, using a trial-and-error approach, we can see whether we can
    visualize information from the database. We can try the **UNION** query techniques
    and guess the number of parameters in the underlying SQL query. We can assume
    that the picture ID corresponds to one of these parameters along with, possibly,
    the picture URL (we will see a broken picture icon in the case of a nonexistent
    ID) and **Uploaded By** displayed on the page. However, using the **123456789
    UNION SELECT 1,2,3** payload still returns the empty picture, probably due to
    a MySQL error. Let''s instead try using one more argument, with the **123456789
    UNION SELECT 1,2,3,4** payload:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，使用试错法，我们可以查看是否能够从数据库中可视化信息。我们可以尝试 **UNION** 查询技术，并猜测底层 SQL 查询中的参数个数。我们可以假设图片
    ID 是这些参数之一，并且可能还有图片 URL（如果是不存在的 ID，我们会看到一个损坏的图片图标）以及页面上显示的 **Uploaded By**。然而，使用
    **123456789 UNION SELECT 1,2,3** 载荷仍然返回空图片，可能是由于 MySQL 错误。让我们尝试再使用一个参数，使用 **123456789
    UNION SELECT 1,2,3,4** 载荷：
- en: '![Figure 4.38 – Successful UNION SQL injection'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.38 – 成功的 UNION SQL 注入'
- en: '](image/B15632_04_038.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_038.jpg)'
- en: Figure 4.38 – Successful UNION SQL injection
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.38 – 成功的 UNION SQL 注入
- en: 'At this point, we know that the underlying query has four arguments, and the
    fourth argument corresponds to the **Uploaded By** value on the page. We can use
    this query to extract all the information we like. As an example, we will try
    to extract the password for the admin account of the application. We could query
    the **information_schema** table to extract the schema of the application (Peruggia)
    and its tables to find the one that corresponds to its user information (users).
    We will then use the **123456789 UNION SELECT 1,2,username,password FROM users
    WHERE username=''admin''** payload to return the password for the account admin
    next to **Uploaded By** on the page:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道底层查询有四个参数，第四个参数对应页面上的**上传者（Uploaded By）**值。我们可以使用此查询提取所有我们想要的信息。举个例子，我们将尝试提取应用程序的管理员账户密码。我们可以查询**information_schema**表，提取应用程序（Peruggia）的架构及其表格，以找到与用户信息（users）对应的表格。然后，我们将使用**123456789
    UNION SELECT 1,2,username,password FROM users WHERE username='admin'** 负载来返回与页面上**上传者（Uploaded
    By）**旁边的管理员账户密码：
- en: '![Figure 4.39 – Admin password hash returned in the Add Comment page'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.39 – 在添加评论页面返回的管理员密码哈希'
- en: '](image/B15632_04_039.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_039.jpg)'
- en: Figure 4.39 – Admin password hash returned in the Add Comment page
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – 在添加评论页面返回的管理员密码哈希
- en: Of course, we could use the same field to return any information that we've
    seen so far, such as the password for the **root** MySQL account, the database
    system version, or any data belonging to other tables. This tutorial was primarily
    created to show the consequences and implications of manual SQL injection attacks
    (while also, of course, having fun trying these attacks in a safe and controlled
    environment).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用相同的字段返回到目前为止看到的任何信息，例如**root** MySQL账户的密码、数据库系统版本，或属于其他表格的任何数据。本教程主要是为了展示手动SQL注入攻击的后果和影响（同时当然也能在安全和可控的环境中尝试这些攻击，获得一些乐趣）。
- en: We will now move on to the second part of our practical section, showing what
    can be done with advanced and automated tools using Kali Linux.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进入实践部分的第二部分，展示使用Kali Linux中的高级和自动化工具能做些什么。
- en: Attacking traditional web applications – automated techniques
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击传统Web应用程序 – 自动化技术
- en: As we mentioned earlier, besides performing manual attack techniques to exploit
    SQL injection, it's possible to use specific software that can handle some of
    the tasks involved in SQL injection attacks, producing useful results in a timely
    manner. These tools are used by both attackers and security professionals alike,
    as they optimize operations and help to save a lot of time by simplifying the
    tasks we need to perform.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，除了执行手动攻击技巧来利用SQL注入外，还可以使用一些特定的软件来处理SQL注入攻击中的部分任务，及时产生有用的结果。这些工具被攻击者和安全专业人员同时使用，因为它们优化了操作，并通过简化我们需要执行的任务帮助节省大量时间。
- en: First, we will go through what is possible to do, in terms of SQL injection,
    with **Zed Attack Proxy** (**ZAP**), which is the attack proxy by OWASP.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍使用**Zed攻击代理（ZAP）**可以做什么，ZAP是OWASP的攻击代理。
- en: OWASP ZAP for SQL injection
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OWASP ZAP 用于SQL注入
- en: 'OWASP ZAP is a versatile tool that consists of an attack proxy—a piece of software
    that is used to intercept traffic in order to monitor it or modify it before it''s
    sent to an application—with other functionalities that help to automate the process.
    In this sense, through automation, this tool can be used to scan web applications
    for vulnerabilities by testing the response received against specific inputs.
    This scanning feature can be used to identify many types of vulnerabilities, including
    SQL injection. Let''s see it action, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP 是一款多功能工具，包括一个攻击代理—一种用于拦截流量的软件下载工具，可以监控或修改流量后再发送到应用程序—并具有其他帮助自动化过程的功能。从这个角度来说，通过自动化，这个工具可以用于扫描Web应用程序的漏洞，测试收到的响应与特定输入的匹配情况。这个扫描功能可以用来识别多种漏洞类型，包括SQL注入。接下来让我们看看它的实际操作，具体如下：
- en: First, let's start the software from our Kali Linux machine by typing **zaproxy**
    into our command line. This should load our graphic interface, allowing us to
    insert our target website in the panel on the right (**Quick Start**). We will
    select the **Automated Scan** mode so that we can test the automated capabilities
    of this tool:![Figure 4.40 – OWASP ZAP main screen
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过在Kali Linux机器的命令行输入**zaproxy**来启动软件。这应该会加载我们的图形界面，允许我们在右侧的面板（**快速启动**）中输入目标网站。我们将选择**自动扫描**模式，以便测试此工具的自动化功能：![图
    4.40 – OWASP ZAP 主界面
- en: '](image/B15632_04_040.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_040.jpg)'
- en: Figure 4.40 – OWASP ZAP main screen
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.40 – OWASP ZAP 主界面
- en: After selecting the **Automated Scan** option, we are prompted to insert our
    target URL for our tests to begin. We will insert the URL for the instance of
    the Peruggia web application, which is simple enough to show what ZAP is capable
    of:![Figure 4.41 – OWASP ZAP Automated Scan panel
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 **自动扫描** 选项后，系统提示我们插入目标 URL 以开始测试。我们将插入 Peruggia Web 应用程序的 URL，这是一个足够简单的实例，能够展示
    ZAP 的功能：![图 4.41 – OWASP ZAP 自动扫描面板
- en: '](image/B15632_04_041.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_041.jpg)'
- en: Figure 4.41 – OWASP ZAP Automated Scan panel
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.41 – OWASP ZAP 自动扫描面板
- en: 'After clicking on **Attack**, our automated scan will begin. First, OWASP ZAP
    will perform a spidering of the application, exploring the links of the application
    and checking the pages that can be explored, in a very period short time. The
    second step of this automated analysis is to activate the scanner module, which
    checks for vulnerabilities by sending specific data to the application, which
    correspond to the input. After a few seconds, we will get our results on the **Alerts**
    tab, as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **攻击** 后，我们的自动扫描将开始。首先，OWASP ZAP 会对应用程序进行蜘蛛扫描，探索应用程序的链接并检查可以探索的页面，所需时间非常短。自动分析的第二步是激活扫描器模块，它通过向应用程序发送特定的数据来检查漏洞，这些数据对应输入。几秒钟后，我们将在
    **警报** 标签上看到我们的结果，如下所示：
- en: '![Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.42 – OWASP ZAP 警报标签显示找到的问题'
- en: '](image/B15632_04_042.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_042.jpg)'
- en: Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.42 – OWASP ZAP 警报标签显示找到的问题
- en: OWASP ZAP identified the SQL injection vulnerability in both the **username**
    parameter and the **pic_id** parameter (like we did manually earlier) in just
    a few seconds. Of course, most of the time, the results of these automated scanners
    need to be validated manually, as the scanner indicates the possible presence
    of the SQL injection vulnerability based on the responses received. Despite the
    degree of uncertainty, this functionality returns an indication of such vulnerabilities
    in a matter of seconds along with others (such as **Cross-Site Scripting** and
    **Path Traversal**).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP 在几秒钟内就识别出了 **用户名** 参数和 **pic_id** 参数中的 SQL 注入漏洞（就像我们之前手动操作一样）。当然，大多数时候，这些自动化扫描器的结果需要手动验证，因为扫描器是根据接收到的响应来指示可能存在
    SQL 注入漏洞的。尽管存在一定的不确定性，这个功能仍能在几秒钟内返回类似的漏洞提示，以及其他漏洞（如 **跨站脚本** 和 **路径遍历**）。
- en: 'OWASP ZAP''s automated capabilities can also be used in your own browser. To
    do this, you need to set up your browser''s proxy as ZAP''s proxy (the default
    is **localhost** on port **8080**). Alternatively, you can launch a browser instance
    directly from ZAP''s interface, using the **Manual Explore** option from the main
    screen. This way, OWASP ZAP opens up a browser window on the specified URL:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP 的自动化功能也可以在你自己的浏览器中使用。为此，你需要将浏览器的代理设置为 ZAP 的代理（默认是 **localhost**，端口是
    **8080**）。或者，你可以直接从 ZAP 的界面启动一个浏览器实例，使用主界面上的 **手动探索** 选项。通过这种方式，OWASP ZAP 会在指定的
    URL 上打开一个浏览器窗口：
- en: '![Figure 4.43 – The OWASP ZAP Manual Explore panel'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.43 – OWASP ZAP 手动探索面板'
- en: '](image/B15632_04_043.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_043.jpg)'
- en: Figure 4.43 – The OWASP ZAP Manual Explore panel
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43 – OWASP ZAP 手动探索面板
- en: 'This way, once new pages are discovered, you can independently run ZAP''s **Spider**
    and **Scanner** modules on each request that is identified through manual exploration.
    While you''re exploring a website, the **Sites** tab gets updated with the pages
    you visit, showing the different requests sent:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，一旦发现新页面，你可以独立地对每个通过手动探索识别的请求运行 ZAP 的 **蜘蛛** 和 **扫描器** 模块。在你浏览网站时，**站点**
    标签会随着你访问的页面而更新，显示发送的不同请求：
- en: '![Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.44 – ZAP 提供的请求分析选项（攻击）'
- en: '](image/B15632_04_044.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_044.jpg)'
- en: Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.44 – ZAP 提供的请求分析选项（攻击）
- en: 'One of the most relevant modules, besides the two we''ve just described, is
    the Fuzzer module, which you can select by choosing **Fuzz…** from the **Attack**
    options. By choosing insertion points in a request, the Fuzzer module can try
    a set range of inputs to check for an unusual response. To use the Fuzzer module,
    you just need to select the part of input in which to inject the fuzzing, and
    then select the format and the actual input list. We will use strings of text
    with a word list made up of common SQL injection inputs. You can find many such
    word lists on the web, which you can easily copy and paste as your payload. Once
    done, you should be ready to launch your attack:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才描述的两个模块外，另一个非常相关的模块是 Fuzzer 模块，你可以通过选择**Fuzz…**选项来选择它。通过在请求中选择插入点，Fuzzer
    模块可以尝试一组输入范围，检查是否有异常响应。要使用 Fuzzer 模块，你只需要选择输入中进行模糊测试的部分，然后选择格式和实际的输入列表。我们将使用包含常见
    SQL 注入输入的字符串文本列表。你可以在网上找到许多这样的单词列表，复制粘贴作为你的有效载荷。一旦完成，你就可以准备好发起攻击了：
- en: '![Figure 4.45 – The Fuzzer window ready to start'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.45 – Fuzzer 窗口准备启动](image/B15632_04_047.jpg)'
- en: '](image/B15632_04_045.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_045.jpg)'
- en: Figure 4.45 – The Fuzzer window ready to start
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.45 – Fuzzer 窗口准备启动
- en: You can insert any list of inputs and also apply special encoding. This served
    as a demonstration in case you wish to attempt more customized attacks. However,
    keep in mind that the **Scanner** module already performs fuzzing attacks with
    common inputs, used for identifying common vulnerabilities.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以插入任何输入列表，并且可以应用特殊编码。这用于演示，如果你想尝试更自定义的攻击。不过，记住**扫描器**模块已经使用常见输入进行了模糊测试攻击，用于识别常见漏洞。
- en: After dealing with OWASP ZAP, which can be used to save time while examining
    web applications and spotting vulnerabilities in a reduced amount of time with
    respect to manual analysis, we will now move on to possibly the most famous tool
    for automated SQL injection; we'll be using the sqlmap command-line interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理过 OWASP ZAP 之后，这个工具可以帮助你节省时间，快速检查 Web 应用程序并发现漏洞，相比于手动分析，节省了大量时间，现在我们将进入自动化
    SQL 注入领域，使用最著名的工具之一 —— sqlmap 命令行界面。
- en: Automated SQL injection attacks using sqlmap
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sqlmap 进行自动化 SQL 注入攻击
- en: 'As mentioned earlier, sqlmap is a well-known utility within the software included
    in Kali Linux. While OWASP ZAP is a tool made for discovering and analyzing all
    sorts of vulnerabilities within a web application, sqlmap is designed specifically
    for SQL injection and provides many options for such attacks. It is, however,
    not very user friendly (as is the case for most of the command-line utilities
    available), so it''s best to view all of the available options using the complete
    help (**-hh**) option. You can do this by typing **sqlmap -hh** into the Kali
    Linux terminal:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，sqlmap 是 Kali Linux 中包含的软件工具之一，是一款非常著名的工具。虽然 OWASP ZAP 是用于发现和分析 Web 应用程序中各种漏洞的工具，但
    sqlmap 是专门为 SQL 注入设计的，并提供了许多用于此类攻击的选项。不过，它的用户界面并不友好（这也是大多数命令行工具的共同特点），因此最好使用完整的帮助（**-hh**）选项查看所有可用的选项。你可以在
    Kali Linux 终端中输入**sqlmap -hh**来查看：
- en: '![Figure 4.46 – sqlmap help output'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.46 – sqlmap 帮助输出](image/B15632_04_046.jpg)'
- en: '](image/B15632_04_046.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_046.jpg)'
- en: Figure 4.46 – sqlmap help output
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.46 – sqlmap 帮助输出
- en: 'Let''s try it against Peruggia again. First, let''s scan the **Add Comment**
    page to see whether sqlmap discovers the page is vulnerable. We will type **sqlmap
    -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"** in the terminal.
    sqlmap will ask us whether we want to try various attack techniques during execution.
    Since we are scanning the web page, we are interested in checking whether any
    attacks work, so we will answer **Y** or **N** depending on the request to perform
    all possible attacks. After a few seconds, we will get our final result:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次针对 Peruggia 进行测试。首先，我们扫描**添加评论**页面，看看 sqlmap 是否发现该页面存在漏洞。我们将在终端中输入**sqlmap
    -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"**。sqlmap 会询问我们是否要在执行过程中尝试不同的攻击技术。由于我们正在扫描网页，重点是检查是否有攻击有效，因此我们将根据请求选择是否执行所有可能的攻击，回答**Y**或**N**。几秒钟后，我们将得到最终结果：
- en: '![Figure 4.47 – sqlmap basic scan result'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.47 – sqlmap 基本扫描结果](image/B15632_04_045.jpg)'
- en: '](image/B15632_04_047.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_047.jpg)'
- en: Figure 4.47 – sqlmap basic scan result
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.47 – sqlmap 基本扫描结果
- en: Here, sqlmap has confirmed that Peruggia's **Add Comment** page is vulnerable
    to SQL injection, both by attempting time-based blind SQL injection and **UNION**
    queries. At this point, we know that the parameter is vulnerable, and we can dig
    deeper.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，sqlmap 已确认 Peruggia 的 **添加评论** 页面存在 SQL 注入漏洞，既通过基于时间的盲注，也通过 **UNION** 查询。此时，我们知道该参数存在漏洞，可以进一步挖掘。
- en: 'We will now use sqlmap for database enumeration. First, we will try to obtain
    all the databases from the server. To do so, we need to insert the following input
    into the terminal:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 sqlmap 进行数据库枚举。首先，我们将尝试从服务器获取所有数据库。为此，我们需要在终端输入以下内容：
- en: sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1" –-dbs
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1" –-dbs
- en: 'After running the command, we will get our results. This confirms our manual
    enumeration attempt, by listing all of the databases that are present on the server:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们将得到结果。这确认了我们手动枚举的尝试，通过列出服务器上所有的数据库：
- en: '![Figure 4.48 – sqlmap successful database enumeration attempt'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.48 – sqlmap 成功的数据库枚举尝试](image/B15632_04_050.jpg)'
- en: '](image/B15632_04_048.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_048.jpg)'
- en: Figure 4.48 – sqlmap successful database enumeration attempt
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.48 – sqlmap 成功的数据库枚举尝试
- en: 'Now, we can select a database to explore further. We can retrieve tables within
    one of them (Peruggia) by running sqlmap with the **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"
    –-tables -D peruggia** input:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择一个数据库进行进一步的探索。我们可以通过运行 sqlmap 并使用 **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"
    –-tables -D peruggia** 来提取其中一个数据库（Peruggia）中的表：
- en: '![Figure 4.49 – sqlmap extracting tables belonging to Peruggia''s database'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.49 – sqlmap 提取属于 Peruggia 数据库的表](image/B15632_04_048.jpg)'
- en: '](image/B15632_04_049.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_049.jpg)'
- en: Figure 4.49 – sqlmap extracting tables belonging to Peruggia's database
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.49 – sqlmap 提取属于 Peruggia 数据库的表
- en: At this point, since we have tables, we can proceed to extract all the information
    inside the table. We will use the dump functionality of sqlmap, which will extract
    the full content of a table. To do this, we need to use **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"
    –dump -D peruggia -T users** in the terminal for the full extraction of the **users**
    table. sqlmap also has a built-in password cracking module to check for password
    hashes, which we will use here.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，由于我们已经得到了表，我们可以继续提取表中的所有信息。我们将使用 sqlmap 的转储功能，该功能将提取表的完整内容。为此，我们需要在终端中使用
    **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1" –dump
    -D peruggia -T users** 来完整提取 **users** 表。sqlmap 还内置了一个密码破解模块，用于检查密码哈希值，我们将在这里使用它。
- en: 'The final result, complete with the passwords obtained from the stored hashes,
    will be displayed at the end of the output in a table-like format:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果，包括从存储的哈希值中获取的密码，将以类似表格的格式显示在输出的末尾：
- en: '![Figure 4.50 – Dumping the users table from the Peruggia database, complete
    with passwords'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.50 – 从 Peruggia 数据库转储用户表，包含密码](image/B15632_04_050.jpg)'
- en: '](image/B15632_04_050.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_050.jpg)'
- en: Figure 4.50 – Dumping the users table from the Peruggia database, complete with
    passwords
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.50 – 从 Peruggia 数据库转储用户表，包含密码
- en: 'Of course, besides supporting HTTP **GET** requests (such as in this example)
    sqlmap also supports **POST** requests with the **--data** option. In this way,
    we can also attack web pages containing forms. We will try an attack payload suggested
    by the **Mutillidae II** application hint section, just to show the functionality
    in an easy and replicable way:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了支持 HTTP **GET** 请求（如本例所示），sqlmap 还支持带有 **--data** 选项的 **POST** 请求。通过这种方式，我们还可以攻击包含表单的网页。我们将尝试一个由
    **Mutillidae II** 应用程序提示部分建议的攻击负载，以便以简单且可复制的方式展示其功能：
- en: sqlmap -u "http://192.168.56.101/mutillidae/index.php?page=view-someones-blog.php"
    --data="author=6C57C4B5-B341-4539-977B-7ACB9D42985A&view-someones-blog-php-submit-button=View+Blog+Entries"
    --level=1 --dump
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap -u "http://192.168.56.101/mutillidae/index.php?page=view-someones-blog.php"
    --data="author=6C57C4B5-B341-4539-977B-7ACB9D42985A&view-someones-blog-php-submit-button=View+Blog+Entries"
    --level=1 --dump
- en: 'The **--data** option is accompanied by the data to pass within the form for
    the request. This will result in a similar outcome with respect to the previous
    attacks made against **GET** requests. **POST** parameters can be extracted by
    examining valid requests and can be inserted as data. Be warned, however: due
    to the multiple parameters, this attack might take much longer than the previous
    ones.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**--data** 选项后跟数据，数据会传递到表单中作为请求的一部分。这将导致与之前针对 **GET** 请求进行的攻击相似的结果。可以通过检查有效请求来提取
    **POST** 参数，并将其插入为数据。然而，需要警告的是：由于参数众多，这种攻击可能比之前的攻击花费更多时间。'
- en: 'sqlmap results, including logs and dumps, are always saved in the filesystem,
    in a folder specified at the end of the sqlmap output (usually, **/home/<linux
    user>/.sqlmap/output**). This turns out to be very useful, especially in the case
    of a rich output (such as this one):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: sqlmap 结果，包括日志和转储文件，始终保存在文件系统中的一个文件夹中，该文件夹位置在 sqlmap 输出的末尾指定（通常是 **/home/<linux
    user>/.sqlmap/output**）。这非常有用，特别是在输出丰富的情况下（比如这个例子）：
- en: '![Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI
    text editor'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.51 – 在 CLI 文本编辑器中显示的基于 POST 的攻击的 sqlmap 结果'
- en: '](image/B15632_04_051.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_051.jpg)'
- en: Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI
    text editor
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.51 – 在 CLI 文本编辑器中显示的基于 POST 的攻击的 sqlmap 结果
- en: 'Database dumps are also saved—in CSV format—preserving the table-like structure
    that is typical of SQL:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库转储文件也以 CSV 格式保存，保持 SQL 特有的表格结构：
- en: '![Figure 4.52 – The resulting dump files from the last extraction'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.52 – 上次提取结果生成的转储文件'
- en: '](image/B15632_04_052.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_052.jpg)'
- en: Figure 4.52 – The resulting dump files from the last extraction
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.52 – 上次提取结果生成的转储文件
- en: In the end, sqlmap is a very useful tool for testing SQL injection, providing
    the capability of both scanning for possible SQL injection vulnerabilities and
    extracting data in an automated way, and even avoiding manual intervention altogether
    in some cases. Data is also conveniently saved in your filesystem for future reference,
    while the built-in password cracking module can crack passwords from stored hashes
    at runtime, by brute-forcing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，sqlmap 是一个非常有用的 SQL 注入测试工具，提供了扫描可能的 SQL 注入漏洞、自动化数据提取的能力，甚至在某些情况下可以完全避免手动干预。数据也会方便地保存在文件系统中以供将来参考，同时内置的密码破解模块可以通过暴力破解方式，在运行时从存储的哈希值中破解密码。
- en: This concludes our voyage through web application testing for SQL injection.
    We have explored manual techniques in great depth, while also examining possibilities
    for automated testing, showing how this can be convenient by saving precious time
    in testing operations.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对 SQL 注入 Web 应用程序测试之旅的结束。我们深入探讨了手动技术，同时也考察了自动化测试的可能性，展示了它如何通过节省宝贵的测试时间而显得如此便捷。
- en: We will now change the topic to discuss how SQL injection can be extended to
    other environments that are different from traditional web applications and can
    be accessed and explored through web browsers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将改变话题，讨论如何将 SQL 注入扩展到其他不同于传统 Web 应用程序的环境中，并通过 Web 浏览器进行访问和探索。
- en: Attacking mobile targets
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击移动目标
- en: Mobile applications are, as their name suggests, applications that reside, even
    partially, on mobile devices. This means that they differ, both in approach and
    execution, with respect to traditional web applications.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序顾名思义，是部分或全部驻留在移动设备上的应用程序。这意味着它们在方法和执行上与传统的 Web 应用程序有所不同。
- en: In traditional web applications, our main access is usually in the form of a
    web browser. This is so that the entire interface is rendered within it, and it
    is sent by servers in the form of an HTTP response containing all that is needed
    to visualize it as intended, including client-side code (such as JavaScript).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 Web 应用程序中，我们的主要访问方式通常是通过 Web 浏览器。这样，整个界面会在浏览器中渲染，并通过服务器以 HTTP 响应的形式发送，响应中包含所有必要的内容，以按预期方式进行可视化，其中包括客户端代码（如
    JavaScript）。
- en: 'Mobile applications have, as opposed to a browser that can interpret any HTTP
    response, a specific client residing on the mobile device itself. This already
    has all of the graphics and client-side code within it. This means that the communication
    between the client and the server in a mobile environment is usually more lightweight,
    that is, it only consists of the little information that is essential to communicate.
    This is where web services come into play: they represent a way to exchange only
    the information that is needed for an application to function.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序与可以解释任何 HTTP 响应的浏览器不同，它们有一个特定的客户端驻留在移动设备上。这个客户端已经包含了所有的图形和客户端代码。这意味着，在移动环境中，客户端和服务器之间的通信通常更轻量化，即只包含进行通信所需的最基本信息。这就是
    Web 服务发挥作用的地方：它们代表了一种只交换应用程序运行所需信息的方式。
- en: 'Let''s look at the web services in action. Mutillidae II gives us the option
    to test in the web service (**SOAP** or **Simple Object Access Protocol**) environment.
    Provided we send data in a format that the web service accepts, we can perform
    the same basic functionalities of the application. Let''s go to the **User Lookup
    (SQL)** page that we saw in Mutillidae II, and click on the **Switch to SOAP Web
    Service version** button:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Web 服务是如何运作的。Mutillidae II 让我们可以在 Web 服务（**SOAP** 或 **简单对象访问协议**）环境中进行测试。只要我们以
    Web 服务接受的格式发送数据，就可以执行应用程序的基本功能。让我们进入 Mutillidae II 中看到的**用户查找（SQL）**页面，并点击**切换到
    SOAP Web 服务版本**按钮：
- en: '![Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version
    button'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.53 – Mutillidae II 用户查找页面；注意 Web 服务版本按钮'
- en: '](image/B15632_04_053.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_053.jpg)'
- en: Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version
    button
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.53 – Mutillidae II 用户查找页面；注意 Web 服务版本按钮
- en: 'By clicking on the highlighted link, we will access a very minimal web page,
    consisting only of links to the **Web Service Declaration Language** (**WSDL**)—the
    language definition for our SOAP web service—and the functions supported by it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击高亮的链接，我们将访问一个非常简洁的网页，网页上仅包含指向**Web 服务声明语言**（**WSDL**）的链接——这是我们 SOAP Web
    服务的语言定义，以及它支持的功能：
- en: '![Figure 4.54 – Mutillidae II User Lookup Web Service page'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.54 – Mutillidae II 用户查找 Web 服务页面'
- en: '](image/B15632_04_054.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_054.jpg)'
- en: Figure 4.54 – Mutillidae II User Lookup Web Service page
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.54 – Mutillidae II 用户查找 Web 服务页面
- en: 'By clicking on each function, we can see the input and output information for
    each operation. We can interact with such web services by using specifically crafted
    requests in the language specified by the **WSDL**. For example, if we wanted
    to interact using the **getUser** function, we would need a request with the following
    body:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击每个功能，我们可以看到每个操作的输入和输出信息。我们可以使用根据**WSDL**中指定的语言精心编写的请求与这些 Web 服务进行交互。例如，如果我们想使用**getUser**功能进行交互，我们需要发送一个包含以下内容的请求体：
- en: <soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:ws-user-account">
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:ws-user-account">
- en: <soapenv:Header/>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <soapenv:Header/>
- en: <soapenv:Body>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <soapenv:Body>
- en: <urn:getUser soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <urn:getUser soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
- en: <username xsi:type="xsd:string">username_here</username>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <username xsi:type="xsd:string">username_here</username>
- en: </urn:getUser>
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: </urn:getUser>
- en: </soapenv:Body>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: </soapenv:Body>
- en: </soapenv:Envelope>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: </soapenv:Envelope>
- en: 'We will try using the **getUser** function to return all users with a tautology.
    We will insert the **'' OR 1=1 -- -** payload as the username to send (in place
    of **username_here** in the preceding request). We should get a similar response
    to the one obtained in the web app scenario:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用**getUser**功能，通过插入一个自我证明的**' OR 1=1 -- -**有效载荷作为用户名（在前面的请求中替换**username_here**），返回所有用户。我们应该得到与
    Web 应用场景中相似的响应：
- en: <accounts message="Results for ' OR 1=1 -- -">
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <accounts message="Results for ' OR 1=1 -- -">
- en: <account>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: <account>
- en: <username>admin</username>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <username>admin</username>
- en: <signature>g0t r00t?</signature>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <signature>g0t r00t?</signature>
- en: </account>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: </account>
- en: <account>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <account>
- en: <username>adrian</username>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <username>adrian</username>
- en: <signature>Zombie Films Rock!</signature>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: <signature>Zombie Films Rock!</signature>
- en: </account>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: </account>
- en: …
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: In this example, we've seen that web services, despite using a different means
    of communication with respect to traditional web applications, can still be vulnerable
    to SQL injection. We will now explore what this means for mobile applications
    specifically.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到 Web 服务，尽管使用不同的通信方式与传统的 Web 应用程序交互，但仍然可能容易受到 SQL 注入攻击。接下来，我们将探索这对移动应用程序意味着什么。
- en: 'Many mobile applications, much like web applications, rely on databases to
    store data permanently. Some of these have a SQLite database in the client itself.
    This, by best practice, should not contain sensitive information, as it can be
    extracted from the device itself. We are more interested in server-stored databases.
    In this case, they function identically to web applications, with the only difference
    being the means of sending and receiving information. You guessed it: mobile applications
    can be vulnerable to SQL injection too.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动应用程序，像 Web 应用程序一样，依赖数据库来永久存储数据。其中一些应用程序在客户端本身内嵌有 SQLite 数据库。根据最佳实践，该数据库不应包含敏感信息，因为这些信息可以从设备中提取出来。我们更关注的是服务器存储的数据库。在这种情况下，它们的功能与
    Web 应用程序完全相同，唯一的区别是发送和接收信息的方式。你猜对了：移动应用程序也可能容易受到 SQL 注入攻击。
- en: We have prepared an Android mobile application and a simple web service. We
    will guide you through the import and deployment process so that you can use them
    for testing too.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备了一个 Android 移动应用程序和一个简单的 Web 服务。我们将指导你完成导入和部署过程，以便你也可以用于测试。
- en: First, we need to configure and run the we[b service:](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置并运行 Web 服务：[点击这里查看 Web 服务](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)
- en: '[Download the web service application from GitHub, using this reposi](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)tory:
    https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies.
    You can find the web service in the **C4** subdirectory, inside **MasteringSQLInjection-WebServices**:![Figure
    4.55 – GitHub repository'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[从 GitHub 下载 Web 服务应用程序，使用这个仓库](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)：https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies。你可以在**C4**子目录中找到
    Web 服务，位于**MasteringSQLInjection-WebServices**目录内：![图 4.55 – GitHub 仓库'
- en: '](image/B15632_04_055.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_055.jpg)'
- en: Figure 4.55 – GitHub repository
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.55 – GitHub 仓库
- en: Open Eclipse and create a new **Dynamic Web Project** (**File** | **New** |
    **Dynamic Web Project**), then select the **New Runtime** option. Set the runtime
    by selecting, as **Target runtime**, **Apache Tomcat v9**. Then, click on **Finish**:![Figure
    4.56 – Creating a server runtime in new dynamic web project
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Eclipse，创建一个新的 **动态 Web 项目**（**文件** | **新建** | **动态 Web 项目**），然后选择 **新建运行时**
    选项。通过选择 **目标运行时** 为 **Apache Tomcat v9** 来设置运行时环境。然后，点击 **完成**：![图 4.56 – 在新的动态
    Web 项目中创建服务器运行时
- en: '](image/B15632_04_056.jpg)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_056.jpg)'
- en: Figure 4.56 – Creating a server runtime in new dynamic web project
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.56 – 在新的动态 Web 项目中创建服务器运行时
- en: Open the directory that you downloaded to your computer, go to the **src** folder,
    and drag and drop the files below the **src** folder in the **Java Resources**
    folder, which is contained in Eclipse's **Project Explorer** tab. Click on **OK**
    in the pop-up window:![Figure 4.57 – The src folder in Java Resources, in Eclipse
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你下载到电脑的目录，进入 **src** 文件夹，将文件拖放到 Eclipse 的 **项目资源管理器** 标签页中的 **Java Resources**
    文件夹下的 **src** 文件夹中。点击弹出窗口中的 **确定**：![图 4.57 – Eclipse 中 Java 资源的 src 文件夹
- en: '](image/B15632_04_057.jpg)'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_057.jpg)'
- en: Figure 4.57 – The src folder in Java Resources, in Eclipse
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.57 – Eclipse 中 Java 资源的 src 文件夹
- en: Double-click on the server in the **Servers** tab. Then, set port number **8081**
    in the configuration that opens. Save the settings by pressing *Ctrl* + *S*:![Figure
    4.58 – Setting up the server
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **服务器** 标签页中的服务器。然后，在弹出的配置中设置端口号为 **8081**。按 *Ctrl* + *S* 保存设置：![图 4.58 –
    设置服务器
- en: '](image/B15632_04_058.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_058.jpg)'
- en: Figure 4.58 – Setting up the server
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.58 – 设置服务器
- en: Now that you have your code and runtime, navigate to the **File** | **New**
    | **Web Service** option. Be sure to bring the two sliders up to **Test Client**
    and **Test Service**, respectively, in the interface. Keep everything else in
    their default settings:![Figure 4.59 – Setting up the web service (1)
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经有了代码和运行时环境，导航到 **文件** | **新建** | **Web 服务**选项。确保在界面中将两个滑块分别调至 **测试客户端**
    和 **测试服务**。其他所有设置保持默认：![图 4.59 – 设置 Web 服务 (1)
- en: '](image/B15632_04_059.jpg)'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_059.jpg)'
- en: Figure 4.59 – Setting up the web service (1)
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.59 – 设置 Web 服务 (1)
- en: Use the **Browse** button pointing at your package in the **Service implementation**
    field and implementation class (**com.packt.masteringsqlj.service.IOTMgmtServiceImplementation**),
    and then click on **Next**. Then, click on **Next** again:![Figure 4.60 – Setting
    up the web service (2)
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Browse** 按钮指向 **Service implementation** 字段中的包以及实现类（**com.packt.masteringsqlj.service.IOTMgmtServiceImplementation**），然后点击
    **Next**。再点击一次 **Next**：![图 4.60 – 设置 web 服务（2）
- en: '](image/B15632_04_060.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_060.jpg)'
- en: Figure 4.60 – Setting up the web service (2)
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.60 – 设置 web 服务（2）
- en: 'After a while, you''ll see a **Server startup** window. Click on **Start server**
    to finally start the server, then click on **Next**, and select **Launch** in
    the following window. Your web service should now start:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等片刻，你将看到一个 **Server startup** 窗口。点击 **Start server** 来启动服务器，然后点击 **Next**，在下一个窗口中选择
    **Launch**。你的 web 服务现在应该启动：
- en: '![Figure 4.61 – Server startup'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.61 – 服务器启动'
- en: '](image/B15632_04_061.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_061.jpg)'
- en: Figure 4.61 – Server startup
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.61 – 服务器启动
- en: 'After loading and setting up the web service, let''s load the application to
    our Android emulator using Android Studio:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 加载并设置好 web 服务后，让我们通过 Android Studio 将应用加载到 Android 模拟器中：
- en: You should already have the code from the repository you previously downloaded.
    This time, you can find it in the **MasteringSQLInjection-AndroidApp** subdirectory
    in **C4**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该已经有了之前下载的代码。这一次，你可以在 **C4** 中的 **MasteringSQLInjection-AndroidApp** 子目录下找到它。
- en: Open Android Studio. Select **Open an existing Android Studio project**. Select
    the downloaded folder when prompted:![Figure 4.62 – Android Studio startup instructions
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android Studio。选择 **Open an existing Android Studio project**。在提示时选择下载的文件夹：![图
    4.62 – Android Studio 启动说明
- en: '](image/B15632_04_062.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_062.jpg)'
- en: Figure 4.62 – Android Studio startup instructions
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.62 – Android Studio 启动说明
- en: From the newly started web service screen, take the **Endpoints** information
    from the **Actions** tab:![Figure 4.63 – Endpoint information of the web service
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新启动的 web 服务屏幕中，从 **Actions** 标签页中获取 **Endpoints** 信息：![图 4.63 – Web 服务的端点信息
- en: '](image/B15632_04_063.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_063.jpg)'
- en: Figure 4.63 – Endpoint information of the web service
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.63 – Web 服务的端点信息
- en: Copy the endpoint information in the **ENDPOINT** variable of the **Utils**
    class. Remember to change **localhost** to your computer's IP address:![Figure
    4.64 – Editing the Utils class
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Utils** 类中的 **ENDPOINT** 变量的端点信息复制过来。记得将 **localhost** 改成你电脑的 IP 地址：![图
    4.64 – 编辑 Utils 类
- en: '](image/B15632_04_064.jpg)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/B15632_04_064.jpg)'
- en: Figure 4.64 – Editing the Utils class
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.64 – 编辑 Utils 类
- en: 'Start the application by clicking on the run/play icon, as shown in the following
    screenshot:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击运行/播放图标来启动应用，如下截图所示：
- en: '![Figure 4.65 – The run icon in Android Studio'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.65 – Android Studio 中的运行图标'
- en: '](image/B15632_04_065.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_065.jpg)'
- en: Figure 4.65 – The run icon in Android Studio
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.65 – Android Studio 中的运行图标
- en: 'Now that we have our environment up and running, we can use our simple application
    and show SQL injection in a mobile setting:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建好了环境，可以使用我们简单的应用并展示 SQL 注入在移动环境中的应用：
- en: '![Figure 4.66 – Mobile application login screen'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.66 – 移动应用登录界面'
- en: '](image/B15632_04_066.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_066.jpg)'
- en: Figure 4.66 – Mobile application login screen
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.66 – 移动应用登录界面
- en: The application shows a rather simple login screen. We can try the tautology
    attack with our usual payload (**' OR 1=1 -- -**). This will grant us access.
    The reason for this is the same as the web service example we saw earlier; that
    is, because the underlying database (MySQL) does not apply any security measure,
    and it does not sanitize input on its own.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用展示了一个相当简单的登录界面。我们可以用常见的有效载荷（**' OR 1=1 -- -**）尝试进行自反攻击。这将让我们获得访问权限。原因和我们之前看到的
    web 服务示例相同；即，底层数据库（MySQL）没有应用任何安全措施，也没有对输入进行过滤。
- en: Now that we've demonstrated how SQL injection can impact mobile applications
    too, we will move on to the IoT environment. Keep the mobile application running
    it will be useful for our next attack scenario.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经演示了 SQL 注入如何影响移动应用，接下来我们将转向物联网环境。保持移动应用的运行，它将在我们下一个攻击场景中派上用场。
- en: Attacking IoT targets
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击物联网目标
- en: When dealing with IoT devices, we usually consider a complex environment in
    which these devices are usually at the outermost end of an interconnected network.
    We usually refer to small devices with low computational power—such as sensors,
    little appliances, and more—often running embedded systems with minimal functionality.
    This is because these devices are designed to perform very specialized tasks,
    which do not require complex operating systems. The result consists of small,
    handy devices that are always connected and are communicating with other devices,
    being other small IoT devices or servers, that might collect some kind of data,
    be it from measuring or input from the device itself.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理物联网设备时，我们通常考虑一个复杂的环境，这些设备通常位于互联网络的最外端。我们通常指的是低计算能力的小型设备——如传感器、小型家电等——这些设备通常运行嵌入式系统，功能极其简单。这是因为这些设备旨在执行非常专门的任务，这些任务不需要复杂的操作系统。结果是，形成了一些小巧、便捷的设备，这些设备始终在线，并且与其他设备进行通信，其他设备可以是小型物联网设备，也可以是服务器，这些设备可能会收集某种数据，无论是通过测量还是来自设备本身的输入。
- en: IoT has been a hot topic recently, and many are investing in these practical
    technologies, which help to integrate technology in the everyday world. However,
    at the same time, security has sometimes been neglected in these systems. This
    is probably due to the limited resources that are available on such devices. This
    includes the possibility that some devices that use information from a database
    can be, affected by SQL injection.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网最近成为了一个热门话题，许多人正在投资这些实用的技术，这些技术帮助将科技融入日常生活中。然而，与此同时，这些系统中的安全性有时被忽视。这可能是由于这些设备的资源有限。这包括一些使用数据库信息的设备，可能会受到
    SQL 注入攻击的影响。
- en: 'For this scenario, we will use our mobile application—the same that we used
    in the previous section—to interact with (hypothetical) IoT devices through a
    database running on a web server. In the IoT environment, the network is distributed,
    and instructions may come from different parts of a network, even a mobile device.
    The application, in fact, after a successful admin level login, will allow the
    authenticated user to modify the status of an IoT device that is connected to
    the application:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们将使用我们的移动应用程序——与前一部分中使用的相同——通过运行在 Web 服务器上的数据库与（假设的）物联网设备进行交互。在物联网环境中，网络是分布式的，指令可能来自网络的不同部分，甚至是移动设备。事实上，应用程序在成功的管理员级别登录后，将允许经过身份验证的用户修改与该应用程序连接的物联网设备的状态：
- en: '![Figure 4.67 – Status panel for our application'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.67 – 我们应用程序的状态面板'
- en: '](image/B15632_04_067.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_067.jpg)'
- en: Figure 4.67 – Status panel for our application
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.67 – 我们应用程序的状态面板
- en: 'Behind this panel, there is, of course, a SQL query. Once the query is sent,
    we can modify it similarly to how we did earlier, in the web service scenario.
    This time, we will insert **'', status =(SELECT password FROM iot_mgmt_system.user
    WHERE username=''admin'' LIMIT 1) --** (don''t forget the blank space at the end)
    to edit the status of the device, including relevant information (in this case,
    the password for the **admin** account of the mobile application):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个面板背后，当然有一个 SQL 查询。一旦查询被发送，我们可以像之前在 Web 服务场景中那样修改它。这次，我们将插入 **', status =(SELECT
    password FROM iot_mgmt_system.user WHERE username='admin' LIMIT 1) --**（别忘了末尾的空格）来编辑设备的状态，包含相关信息（在本例中，是移动应用程序的
    **admin** 账户的密码）：
- en: '![Figure 4.68 – Status changed by our payload'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.68 – 通过我们的有效载荷更改的状态'
- en: '](image/B15632_04_068.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15632_04_068.jpg)'
- en: Figure 4.68 – Status changed by our payload
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.68 – 通过我们的有效载荷更改的状态
- en: IoT devices could also be attacked in other ways. However, most of the time,
    these are in the realm of web application attacks—as devices can have a web interface
    for interacting with settings or configurations—or other traditional means, such
    as any computer system (for example, attacking open ports and services).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网设备也可能以其他方式受到攻击。然而，大多数时候，这些攻击属于 Web 应用攻击的范畴——因为设备可能有 Web 接口用于与设置或配置交互——或者是其他传统手段，例如攻击开放端口和服务等计算机系统。
- en: 'While our example is, of course, a simplified mock-up scenario, the message
    is always the same: if any application, be it web-based, mobile, or a web service,
    does not properly check for the input, the underlying database can be irremediably
    compromised.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的例子当然是一个简化的模拟场景，但信息始终是相同的：如果任何应用程序，无论是基于 Web 的、移动的，还是 Web 服务，在输入检查上没有做好充分的安全措施，那么底层的数据库就可能会不可挽回地被破坏。
- en: Imagine a scenario in which a controller sends non-sanitized SQL input to a
    server that controls critical devices, in a more realistic scenario. What if a
    malicious user could entirely alter the database, totally compromising its control
    functionality? In this way, the damage could be extended to the real world, as
    IoT can be responsible for performing tasks in critical environments such as smart
    cities, surveillance (for example, cameras), smart meters for critical infrastructure
    (for example, water distribution), or medical facilities.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，其中一个控制器向一个控制关键设备的服务器发送未经过滤的 SQL 输入，在更现实的场景中。如果恶意用户能够完全修改数据库，完全破坏其控制功能怎么办？以这种方式，损害可能扩展到现实世界，因为物联网（IoT）可以负责执行关键环境中的任务，比如智能城市、监控（例如，摄像头）、关键基础设施的智能计量（例如，水分配）或医疗设施。
- en: Important note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Practice these skills in controlled environments only, without involving third
    parties. The use of security tools and attack techniques is illegal without the
    consent of the owner of the targets, so you could get yourself in trouble if you
    try these techniques on websites or systems you don't own.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在受控环境中练习这些技能，不涉及第三方。未经目标所有者同意，使用安全工具和攻击技术是非法的，因此，如果你在自己不拥有的网站或系统上尝试这些技术，可能会让自己陷入麻烦。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, here we are at the end of this long and practical chapter. We've explored
    many different scenarios, applications, and attacks that are made possible by
    exploiting vulnerable application components that interact with SQL databases.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在来到了这个漫长而实用章节的结束。我们探索了通过利用与 SQL 数据库交互的易受攻击应用程序组件，可能发生的许多不同场景、应用和攻击。
- en: Mutillidae II gave us a glimpse of the basic attacks that can occur through
    SQL injection. Additionally, the Magical Code Injection Rainbow provided us with
    some challenges to wrap our heads around (which you could solve by applying what
    you've learned so far), sometimes, with twists. Finally, Peruggia helped us to
    apply our knowledge to a pseudo-realistic environment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Mutillidae II 给我们展示了通过 SQL 注入可能发生的基本攻击。此外，Magical Code Injection Rainbow 给我们带来了一些挑战，激发我们思考（你可以通过应用迄今为止学到的知识来解决这些问题），有时还会有一些变化。最后，Peruggia
    帮助我们将知识应用到一个伪现实的环境中。
- en: After dealing with manual SQL injection attacks, we learned what is possible
    using common software tools to automate SQL injection, both for scanning and attacking.
    We saw this with the Spider, Scan, and Fuzz modules of OWASP ZAP and sqlmap. We
    showed how manual intervention can be reduced significantly, improving efficiency
    for attackers and security testers alike (and demonstrating, once again, the importance
    of securing web applications that could be compromised in a matter of seconds).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理手动 SQL 注入攻击后，我们了解了使用常见软件工具自动化 SQL 注入的可能性，包括扫描和攻击。我们通过 OWASP ZAP 的 Spider、Scan
    和 Fuzz 模块以及 sqlmap 看到这一点。我们展示了如何大幅减少手动干预，提高攻击者和安全测试人员的效率（再次证明了确保 Web 应用程序安全的重要性，这些应用程序在几秒钟内可能会被攻破）。
- en: Finally, we looked at simple web service and mobile applications, where a SQL
    injection vulnerability can extend far beyond the concept of traditional web applications,
    ranging from mobile applications to even IoT devices, as long as they deal with
    SQL.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了简单的 Web 服务和移动应用程序，在这些应用程序中，SQL 注入漏洞的影响远远超出了传统 Web 应用程序的范围，涵盖了从移动应用程序到甚至
    IoT 设备，只要它们涉及 SQL。
- en: In the next chapter, we will see, more specifically, what can be done to secure
    web applications in general, and how attempts at performing SQL injection can
    be thwarted using various measures. We have already looked at several examples
    using the Magical Code Injection Rainbow, as some of the earlier challenges applied
    some (incomplete) measures. We will learn how, if done right, correct security
    measures can prevent this type of attack.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更具体地了解如何保护 Web 应用程序，如何通过各种措施来阻止 SQL 注入攻击。我们已经通过 Magical Code Injection
    Rainbow 看过一些示例，因为一些早期的挑战应用了一些（不完全的）措施。我们将学习如何通过正确的安全措施来防止此类攻击，如果做得正确，安全措施可以有效地防止这类攻击。
- en: Questions
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is binary search useful when performing blind SQL injection?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行盲注 SQL 注入时，为什么二分查找会有用？
- en: Do you know a way to perform data extraction through a SQL error?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道通过 SQL 错误进行数据提取的方法吗？
- en: Which OWASP ZAP tools can be used for automated SQL injection?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些 OWASP ZAP 工具可以用于自动化 SQL 注入？
- en: Can sqlmap be used to extract passwords from hashes?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: sqlmap 能否用来从哈希中提取密码？
- en: Is SQL injection limited to web applications? Name all the target typologies
    you've seen in this chapter.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL注入仅限于web应用程序吗？列出本章中提到的所有目标类型。
- en: Further reading
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To explore attack vectors an[d further research on **INSERT**, **UPDATE**, and
    **DELETE** statements, we suggest the foll](https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-and-delete/)ow[ing
    resources:](https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探讨攻击向量并进一步研究**INSERT**、**UPDATE**和**DELETE**语句，我们建议参考以下资源：[mysql注入：更新、插入和删除语句的进一步研究](https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-and-delete/)。
- en: '[https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-a](https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/)n[d-delete/](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-a](https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/)n[d-delete/](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)'
- en: '[https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-state](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)ments/'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-state](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)ments/'
- en: https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/
