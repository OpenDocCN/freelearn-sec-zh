- en: SQL Injection Vulnerabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入漏洞
- en: In this chapter, we are going to study **SQL Injection** (**SQLi**) vulnerabilities.
    To gain insight into these vulnerabilities, we will first learn about SQL, look
    at the reasons why we are studying SQL, and how
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究**SQL注入**（**SQLi**）漏洞。为了深入了解这些漏洞，我们将首先学习SQL，了解为什么我们要学习SQL，以及如何
- en: dangerous SQLi is exactly. Moving ahead, we will learn some techniques to discover
    SQL injections. Then, we will learn how we can bypass SQLi authorization and how
    to discover SQLi using the `GET` method. We will also see how we can work around
    SQL commands and discover tables using commands. In the `loadfile` section, we
    will see how we can implement SQLi on server files. Then, we are going to learn
    how we can use a tool called `sqlmap`. Finally, will look at techniques we can
    use to prevent dangerous SQL injections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 危险的SQLi究竟是什么。接下来，我们将学习一些发现SQL注入的技巧。然后，我们将学习如何绕过SQLi授权以及如何使用`GET`方法发现SQLi。我们还将看到如何绕过SQL命令，并使用命令发现表格。在`loadfile`部分，我们将看到如何在服务器文件上实现SQLi。接下来，我们将学习如何使用一个名为`sqlmap`的工具。最后，我们将探讨一些防止危险SQL注入的技术。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What is SQL?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是SQL？
- en: The dangers of SQLi
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLi的危险
- en: Discovering SQLi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现SQLi
- en: SQLi authorization bypass
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLi授权绕过
- en: Discovering SQL using the `GET` method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GET`方法发现SQL
- en: Basic `SELECT` statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的`SELECT`语句
- en: Discovering tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现表格
- en: Reading columns and their data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取列及其数据
- en: Reading and writing files on the server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上的文件读写
- en: The `sqlmap` tool
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlmap`工具'
- en: Preventing SQLi
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止SQLi
- en: What is SQL?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SQL？
- en: We are going to be learning about a popular type of vulnerability called SQLi.
    Before we discuss how it occurs and how to exploit it, let's first learn what
    SQL is. For example, if we are performing a pen test on a certain website, the
    chances are the website is a little bit bigger than other websites and so probably
    uses a database. Most websites, other than very simple ones use databases to store
    data, such as usernames, passwords, news articles, blog posts, pictures, and anything
    that happens on the website. The web application reads the database and then displays
    the data to us or to the users. When the user performs an action on the website,
    the application will either update, delete, or modify the data that exists in
    the database. This interaction between the web application and the database happens
    using a language called SQL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习一种叫做SQLi的常见漏洞类型。在讨论它是如何发生以及如何利用它之前，首先让我们了解一下SQL是什么。例如，如果我们在某个网站进行渗透测试，网站的规模可能比其他网站大一些，因此很可能使用了数据库。除了一些非常简单的网站，大多数网站都使用数据库来存储数据，比如用户名、密码、新闻文章、博客文章、图片，以及网站上的任何动态数据。Web应用程序读取数据库并将数据展示给我们或用户。当用户在网站上执行某个操作时，应用程序将更新、删除或修改数据库中已有的数据。这种Web应用程序与数据库之间的互动是通过一种叫做SQL的语言实现的。
- en: 'Let''s see what we mean by a database. This is just an example of a database;
    we are just going to log in to the database that is installed on our Metasploitable
    machine to see what''s being stored on it. We will not perform any hacking or
    anything fancy; we will just log in to MySQL and then we will input the username
    as `root`—Metasploitable doesn''t use a password for `root`, which is really bad,
    but obviously it''s a vulnerable system. We are just going to log in; we are not
    hacking anything or doing any SQL injections, we are just working on the Terminal
    for MySQL, which the web application would use to interact with the database.
    The following is the command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下数据库的含义。这只是一个数据库的示例；我们将登录到安装在我们的Metasploitable机器上的数据库，看看它存储了什么。我们不会进行任何黑客攻击或复杂的操作；我们只是登录到MySQL，然后输入用户名`root`—Metasploitable没有为`root`设置密码，这非常不安全，但显然这是一个易受攻击的系统。我们只是登录，不是进行任何黑客攻击，也不是进行SQL注入，只是在MySQL的终端上操作，Web应用程序会用这个终端与数据库进行交互。以下是命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the output of the command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令的输出：
- en: '![](assets/f095273e-4288-4d1e-8b2c-0e0bef3a8de1.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f095273e-4288-4d1e-8b2c-0e0bef3a8de1.png)'
- en: 'In this example, we are just trying to see what we mean by databases and what''s
    saved in them. Now, type in `show databases` and that will show us the databases
    that exist on our target server. In the following screenshot, we can see that
    we have the `information_schema` database, which is a default database that holds
    default information about all the other databases:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只是想看看我们所说的数据库是什么，以及它们存储了什么。现在，输入`show databases`，这将显示我们目标服务器上存在的数据库。在下图中，我们可以看到有一个`information_schema`数据库，它是一个默认数据库，包含关于所有其他数据库的默认信息：
- en: '![](assets/89a694ed-d3c1-4137-af3e-f25685013a8f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89a694ed-d3c1-4137-af3e-f25685013a8f.png)'
- en: It gets installed by default when we install MySQL, and the rest have been installed
    for each web application. We can see we have one for `tikiwiki` and one for `owasp10`. We
    also have one called `mysql`, another called `metasploit`, and one for `dvwa`,
    which is the one that we've been using for the web application. We can see that,
    for each web application, we have a database, which holds the information that
    is used by that web application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它在安装MySQL时默认安装，其他数据库则是为每个网络应用程序单独安装的。我们可以看到有一个` tikiwiki`，一个`owasp10`，还有一个`mysql`，另一个叫`metasploit`，以及一个`dvwa`，这就是我们用于网络应用程序的数据库。我们可以看到，对于每个网络应用程序，都有一个数据库，其中包含该应用程序使用的信息。
- en: 'Let''s see what''s inside the database. We are going to use the `owasp10` database.
    We will type the `Use owasp10` command in the Terminal to read the information
    from this table. Each database has a table, which contains information, so we
    launch the `show tables` command to see the tables that we have:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下数据库的内容。我们将使用`owasp10`数据库。我们将在终端输入`Use owasp10`命令，从这个表中读取信息。每个数据库都有一个表，其中包含信息，因此我们启动`show
    tables`命令来查看我们拥有的表：
- en: '![](assets/f04e0253-515b-4ea6-842f-b3cd9f82d87a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f04e0253-515b-4ea6-842f-b3cd9f82d87a.png)'
- en: We have a table for `accounts`, so we can assume that this table has information
    about the usernames, passwords, and users. We have a table called `blogs_table`,
    so it probably has the blog input, such as the posts and comments in there. We
    can see `captured_data` and `credit_cards`, so there's a table that contains credit
    card details. This is huge for shopping websites, they actually would have a `credit_cards`
    table and the information for the credit cards would be stored there. Basically,
    a database will store everything, all the data that is used on the website, because
    they doesn't get stored on files; it's not efficient.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`accounts`表，所以我们可以推测这个表包含关于用户名、密码和用户的信息。我们有一个名为`blogs_table`的表，可能包含博客输入信息，比如帖子和评论。我们还看到了`captured_data`和`credit_cards`，所以有一个表包含信用卡详情。对于购物网站来说，这一点非常重要，实际上他们会有一个`credit_cards`表，信用卡信息会存储在那里。基本上，数据库会存储所有的东西，网站上使用的所有数据，因为它们不会存储在文件中，这样效率更高。
- en: 'Let''s have a look at the `accounts` table; if we just type `select`, that
    is exactly how the web application will retrieve information from the database.
    The application can either select, update, or delete;  we are doing a `select`
    statement for our example. Again, this is not hacking—we are just going to `select` everything
    from the `accounts` table, with the command `select * from accounts`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`accounts`表；如果我们只输入`select`，这就是网络应用程序如何从数据库中检索信息的方式。应用程序可以选择、更新或删除；我们在这个示例中使用的是`select`语句。同样，这不是黑客攻击——我们只是执行一个`select`语句，从`accounts`表中选择所有内容，命令为`select
    * from accounts`：
- en: '![](assets/e3c052db-a887-423d-bcd9-a89e0077a99b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3c052db-a887-423d-bcd9-a89e0077a99b.png)'
- en: We have columns for the account ID, the username, the password, the signature
    for the user, and whether that user is an administrator. Now, the columns depend
    on the table, so the person who designs the database designs the table and the
    columns, and then the data gets inserted by the web application. We can see in
    the preceding screenshot that we have a user called `admin` and their password
    is `adminpass`. We can also see that we have a user called `adrian` and their
    password is `somepassword`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有账号ID、用户名、密码、用户签名和是否为管理员的列。现在，列的设置取决于表，因此设计数据库的人会设计表和列，然后数据由网络应用程序插入。我们可以在前面的截图中看到，有一个名为`admin`的用户，密码是`adminpass`。我们还可以看到有一个名为`adrian`的用户，密码是`somepassword`。
- en: This example is just to understand what databases look like and to get a feel
    for them; in later sections, we're going to try to exploit these databases and
    get access similar to this. So, here, we just logged in with a username and a
    password. Now, usually we wouldn't have access, and only the web admin would.
    In the upcoming sections, we're going to try to run some attacks in order to gain
    access, so that we'll have full control over the database in order to read and
    write (or modify) data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是为了让我们了解数据库长什么样，并感受一下它们；在后面的章节中，我们将尝试利用这些数据库，获取类似的访问权限。因此，在这里，我们只是用用户名和密码登录了。通常情况下，我们是无法访问的，只有网络管理员才能访问。在接下来的章节中，我们将尝试进行一些攻击，以获得访问权限，从而完全控制数据库，读取和写入（或修改）数据。
- en: The dangers of SQLi
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入的危险
- en: In this section of the chapter, we will focus on why SQL injections are so important
    and so dangerous. The reason is because they are found everywhere; a lot of big
    websites have these kind of exploits, such as Yahoo and Google. They're very hard
    to protect against and it's very easy to make a mistake and make these exploits
    available for misuse. The other reason that they're very dangerous is because
    they give the hacker access to the database. In many scenarios, if we find an
    SQLi, we don't need to upload a `PHP` shell or get a reverse connection. There
    is really no need to upload anything and increase the danger of being caught because,
    if we have access to the database, we pretty much have everything we need. We
    have usernames and passwords, and we can log in with a normal username and password
    as a normal user; if we are looking for sensitive data, we have access to credit
    cards. We can do pretty much anything we want, so there's really no point in trying
    to further exploit the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将重点讨论为什么SQL注入如此重要和危险。原因在于它们无处不在；很多大型网站都有这种漏洞，例如Yahoo和Google。它们非常难以防护，而且很容易犯错，导致这些漏洞被滥用。它们之所以危险的另一个原因是，因为它们让黑客获得数据库的访问权限。在许多场景中，如果我们发现了SQL注入漏洞，我们就不需要上传`PHP`
    shell或建立反向连接。其实没有必要上传任何东西，也不需要增加被抓住的风险，因为只要我们能够访问数据库，我们几乎就能得到我们需要的一切。我们可以获得用户名和密码，并可以使用普通的用户名和密码登录，作为普通用户；如果我们在寻找敏感数据，我们可以访问信用卡信息。我们几乎可以做任何想做的事情，所以实际上没有必要进一步利用系统。
- en: If we find an SQLi, that's great! That's all we need. In many scenarios, we
    use a PHP shell to gain access to the database and see whether we can read it.
    Say we managed to upload a PHP shell on the Metasploitable server, but then we
    couldn't access the database; there isn't much we can see. We can't see credit
    cards, usernames, and passwords; we do have control over the server, but we can't
    read information, so sometimes when we upload a PHP shell, the next step is to
    gain access to the database. SQL injections can be used to do many things, so
    if we manage to find one in a website that is not our target but is in the same
    server, then we can use it to read files outside the `/www/root` directory. Similar
    to file-inclusion vulnerabilities, we can use the admin account, and its username
    and password, to see whether we can upload some information. Usually the admin
    can upload a lot of things, so we can upload a PHP shell or a backdoor from there,
    and navigate to the target website or, in some cases, we can use an SQLi to upload
    a PHP shell. So, SQL injections can be used as file-inclusion vulnerabilities
    and file-upload vulnerabilities and they can also give us access to the whole
    database. That's why they are very dangerous and useful if we manage to find one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现了SQL注入漏洞，那太好了！这就是我们所需要的。在很多场景下，我们使用PHP shell来访问数据库，看看是否能够读取数据。假设我们成功地在Metasploitable服务器上上传了一个PHP
    shell，但随后却无法访问数据库；这时我们就无法看到什么。我们无法看到信用卡、用户名和密码；虽然我们已经控制了服务器，但却无法读取信息，所以有时候在上传PHP
    shell之后，下一步就是访问数据库。SQL注入可以做很多事情，因此如果我们在一个不是目标网站，但在同一服务器上的网站中找到了SQL注入漏洞，我们可以利用它读取`/www/root`目录之外的文件。类似于文件包含漏洞，我们可以利用管理员账户及其用户名和密码，看看是否能够上传一些信息。通常管理员可以上传很多东西，因此我们可以从这里上传一个PHP
    shell或后门，然后导航到目标网站，或者在某些情况下，我们可以使用SQL注入上传PHP shell。所以，SQL注入既可以作为文件包含漏洞和文件上传漏洞，也可以让我们访问整个数据库。这就是它们非常危险且有用的原因，如果我们能够找到一个SQL注入漏洞的话。
- en: Discovering SQLi
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现SQL注入
- en: 'Now, let''s try to discover some SQL injections. We need to browse through
    our target and try to break each page. Whenever we see a textbox or a parameter
    on the form, such as `page.php`, then something is equal to something; try to
    inject stuff there, try to use a single quote, try to use an and, or the `orderby`
    statement to break the page and make it look different. For example, we will be
    using the Mutillidae vulnerable website from Metasploit. We are going to go into
    the Login/Register page first, as we can see in the following screenshot, and
    it will ask us to log in. Now, the site is registered with your name so you can
    just click on Please register here and register:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试发现一些 SQL 注入漏洞。我们需要浏览目标网站，尝试突破每个页面。每当我们看到一个文本框或表单中的参数，比如 `page.php`，然后是
    something = something；就尝试在那里注入内容，尝试使用单引号，尝试使用 AND，或者使用 `orderby` 语句来破坏页面，使其显示不同的内容。例如，我们将使用
    Metasploit 的 Mutillidae 漏洞网站。我们首先进入登录/注册页面，如下图所示，它会要求我们登录。现在，网站已经注册了你的名字，所以你可以点击“请在这里注册”并完成注册：
- en: '![](assets/131e5aaf-bc9b-4f2f-819e-192815857c5c.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/131e5aaf-bc9b-4f2f-819e-192815857c5c.png)'
- en: 'After registering, go to the login page. At the moment, we are using the example
    of injecting into textboxes, so we can try to inject into the Name and into the
    Password textboxes. For example, suppose we put the Name as `zaid` and then a
    single quote mark (`''`) into Password, and click Login. As you can see in the
    following screenshot, there is an error being displayed to us and it doesn''t
    look like a normal error. It looks like it''s a database error, and usually you''d
    be very lucky to you get an error such as this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，进入登录页面。目前，我们正在使用向文本框注入的例子，所以我们可以尝试在 Name 和 Password 文本框中注入内容。例如，假设我们将 Name
    设置为 `zaid`，然后在 Password 中输入一个单引号 (`'`)，然后点击登录。如以下截图所示，出现了一个错误信息，它看起来不像普通的错误。它看起来像是一个数据库错误，通常你很幸运才能遇到这样的错误：
- en: '![](assets/fb21599c-3a8a-45c0-90c2-8f47ff3ef008.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb21599c-3a8a-45c0-90c2-8f47ff3ef008.png)'
- en: Usually the error won't be as informative as this; sometimes we will just see
    that the page is not acting as expected or sometimes it'll just be a page that
    does not look as it should. For example, if it's a news page, maybe the article
    will be missing or, if it's a blog, one of the posts will be missing, or different
    kinds of posts, so we need to keep an eye on what's changing. In this example,
    we are actually getting a really nice error; it's telling us which file it has,
    that there's an error in the statement—the error is near the quote mark that we
    added—and the statement that's been executed. This is really good for learning
    because now we can see the statement that the system is trying to run, and the
    system is trying to do `SELECT *`, so it's trying to select everything: `FROM
    accounts WHERE username='zaid' AND the password='''`. Note that the system, the
    web application, is already adding quote marks around the name. When we said `zaid`,
    it added `zaid` between two quotes and it added the single quote (`'`) that we
    added between another two quotes, so that's why we have three quotes. From this
    error, we can assume that 70% of the target website has an SQL injection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，错误信息不会像这样那么详细；有时我们只会看到页面没有按预期工作，或者页面看起来不对。例如，如果是新闻页面，可能会缺少文章；如果是博客，可能会有一篇帖子消失，或者不同类型的帖子消失，所以我们需要留意哪些部分发生了变化。在这个例子中，我们实际上得到了一个非常不错的错误；它告诉我们出现错误的文件，错误出现在我们添加的引号附近，执行的语句是什么。这对学习非常有帮助，因为现在我们可以看到系统正在尝试执行的语句，系统尝试执行
    `SELECT *`，所以它正在尝试选择所有内容：`FROM accounts WHERE username='zaid' AND password='''`。注意，系统，即网页应用程序，已经在名称周围添加了引号。当我们输入
    `zaid` 时，它在两个引号之间添加了 `zaid`，并且它将我们添加的单引号 (`'`) 放在另外两个引号之间，这就是为什么我们有三个引号。从这个错误中，我们可以推测目标网站有
    70% 可能存在 SQL 注入漏洞。
- en: 'We are still not sure whether it can execute what we want, so can we actually
    inject code and get it executed? Let''s see if this can be done; `username` is
    going to be `zaid` again, and we are going to put `password` as `123456`. Once
    this is done, just close down the site. We closed down the site because the current
    statement in the system is `Select * from accounts where username = ''zaid'' and
    password =''$PASSWORD''`, and it''s going to open a single quote by itself, followed
    by the `$PASSWORD`, which we will provide. So, we''re treating `password` as a
    variable; it takes in whatever we put in the Password textbox, and it replaces `$PASSWORD`,
    which is a variable. It takes whatever we put in the Password textbox and puts
    it between two single quotes, and that will be executed on the system. So, we
    will put `123456''`. We are going to add a quote ourselves, and the code is as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然不确定它是否能执行我们想要的内容，所以我们是否可以实际注入代码并让其执行？让我们看看是否可以做到；`username` 再次将是 `zaid`，我们将将
    `password` 设置为 `123456`。完成后，只需关闭网站。我们关闭了网站，因为系统中的当前语句是 `Select * from accounts
    where username = 'zaid' and password ='$PASSWORD'`，它将自动打开一个单引号，接着是 `$PASSWORD`，我们将提供它。因此，我们正在处理
    `password` 作为一个变量；它接受我们放入密码文本框的任何内容，并将其放置在两个单引号之间，然后在系统上执行。因此，我们将输入 `123456'`。我们将手动添加一个引号，代码如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The application is going to `select` from `accounts`, `password` is equal to
    `123456`, and we have two quotes at the end. Then, we are going to put `and 1=1`.
    We are just trying to see whether it''s going to execute what we want it to. Our
    statement is going to be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将从 `accounts` 中 `select`，其中 `password` 等于 `123456`，并且我们在末尾有两个引号。然后，我们将加入
    `and 1=1`。我们只是想看它是否会执行我们想要的内容。我们的语句将如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are going to insert `123456'' and 1=1` ourselves. The system is going to
    complain that we have an extra quote because we have inserted the password into
    the textbox our self; it''s going to say that there is an open quote and it never
    got closed. Now, we are going to add a comment and after we do so, everything
    that comes in after the comment will not be executed. We are going to use the
    hash (`#`) as the comment, so the system will ignore anything that comes in after
    the hash; it''s going to ignore the last quote that will be inserted by the command.
    So, our code is going to look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将手动插入 `123456' and 1=1`。系统会抱怨我们多了一个引号，因为我们手动将密码插入到文本框中；它会说有一个未闭合的引号。现在，我们将添加一条注释，在我们这样做之后，注释之后的所有内容都不会被执行。我们将使用井号
    (`#`) 作为注释，因此系统将忽略井号之后的任何内容；它将忽略命令插入的最后一个引号。因此，我们的代码将如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to paste the `123456 and 1=1#` password in the Password textbox and
    we should be able to log in as `zaid`, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将密码 `123456 and 1=1#` 粘贴到密码文本框中，并且应该能够作为 `zaid` 登录，如下面的屏幕截图所示：
- en: '![](assets/d2dc1d2e-d6a1-4c9c-b5f6-2be8a8508b6d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2dc1d2e-d6a1-4c9c-b5f6-2be8a8508b6d.png)'
- en: 'Let''s try something different: let''s try to add a false statement. We did
    `1=1` and that was correct and it executed what we wanted. Let''s try `1=2`, which
    is incorrect, so we have the right password and we have the right username, and
    we will add `1=2#` – this should be problematic because it''s `false`, `1` is
    not equal to `2`, and we are using `and`, so everything has to be true. It should
    give us an error even though we are going to put in the right username and the
    right password. So, we enter the Password as `123456 and 1=2#`, and it should
    give us an error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些不同的东西：让我们尝试添加一个错误的语句。我们做了 `1=1`，那是正确的，它执行了我们想要的内容。让我们尝试 `1=2`，这是错误的，所以我们有正确的密码和正确的用户名，并且我们将添加
    `1=2#` —— 这应该会有问题，因为它是 `false`，`1` 不等于 `2`，并且我们使用 `and`，所以一切都必须是真实的。即使我们输入正确的用户名和密码，它也应该给我们一个错误。因此，我们将
    `Password` 输入为 `123456 and 1=2#`，它应该给我们一个错误：
- en: '![](assets/4c920ef6-68b5-4686-afa9-d819c35748fa.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c920ef6-68b5-4686-afa9-d819c35748fa.png)'
- en: 'The site has given us an Authentication Error: Bad user name or password error,
    even though we are using the right password and username. This confirms that the
    website is actually injecting anything we want in the password, so we can use
    the `password` field to inject SQL code.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站给出了身份验证错误：用户名或密码错误，尽管我们使用了正确的密码和用户名。这证实了该网站实际上在密码中注入了我们想要的任何内容，因此我们可以使用 `password`
    字段来注入 SQL 代码。
- en: SQLi authorization bypass
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLi 授权绕过
- en: 'Now we know that we can put in any code we want and it''s going to be executed
    on the system. So, let''s have another look at the statement, which says `select
    * from accounts where username = username`, and `password = password`, which we
    put in the Password textbox. We will now see whether we can use that to log in
    without using a password, and we are going to be doing that with the admin. So, `username`
    is going to be `admin`, and we don''t know what `password` is for `admin`, so
    we are going to enter any random password, for example, `aaa`. In the code that
    we were previously running, we put `and 1=1`, now instead of `and`, we are going
    to say `or 1=1`. So, once we inject the command, it is going to let us log in
    without even knowing the password of `admin`. Our code is going to look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，我们可以输入任何代码，并且它会在系统上执行。那么，咱们再看看这个语句，它写的是`select * from accounts where
    username = username`，并且`password = password`，这些我们是放在密码文本框里的。接下来我们将看看，能不能在不使用密码的情况下登录，我们将用管理员账号进行测试。因此，`username`将是`admin`，而我们不知道`admin`的密码，所以我们输入一个随机密码，比如`aaa`。在我们之前运行的代码中，我们写了`and
    1=1`，现在我们把`and`换成`or 1=1`。所以，一旦我们注入这个命令，它就能让我们在不知道`admin`密码的情况下登录。我们的代码如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we log in using the `admin` Username and paste `aaa'' or 1=1` in the Password
    textbox, we can see that we logged in successfully and the signature for admin
    is Monkey!:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`admin`作为用户名，并在密码文本框中粘贴`aaa' or 1=1`时，我们可以看到成功登录了，管理员的签名是“Monkey!”：
- en: '![](assets/aa0b430f-aff2-435b-b7a4-20226ce78d6b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa0b430f-aff2-435b-b7a4-20226ce78d6b.png)'
- en: So, any time we have an `or` condition, if the `or` condition is true, everything
    is true—that's the way the `or` statement works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，只要我们有一个`or`条件，如果`or`条件为真，那么一切都为真——这就是`or`语句的工作原理。
- en: Bypassing logins can be done in many ways, depending on the code that's written
    on the page and how we are imagining the code. In a lot of cases, when we put
    in the single quote, we won't see the error message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过登录可以通过多种方式实现，具体取决于页面上编写的代码以及我们如何设想这段代码。在很多情况下，当我们输入单引号时，我们不会看到错误信息。
- en: So, we are going to show another example of bypassing. Instead of injecting
    the code, the `admin` parameter is injectable as well, as we saw when we put in
    the single quote, in exactly the same way as the `password` parameter, so we can
    inject code in `username` as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示另一个绕过的例子。除了注入代码外，`admin`参数也是可以注入的，正如我们在输入单引号时看到的，它和`password`参数一样，因此我们也可以在`username`中注入代码。
- en: Try to inject something in `username`; we are going to say `username` is equal
    to `admin`, then we are going to close the quote and add a comment. So, when we
    run the `select * from accounts where username = 'admin'#' and password='aaa'` statement,
    it's going to inject that in `username`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`username`中注入一些东西；我们将`username`设置为`admin`，然后关闭引号并添加一个注释。所以，当我们运行`select *
    from accounts where username = 'admin'#' and password='aaa'`这个语句时，它将注入到`username`中。
- en: 'It''s going to let me log in without even entering anything in the password
    field. So, we are going to put Username as `admin''#`, and then we can put in
    any Password we want to use. We are just going to put `1` and then log in; we
    can see we managed to log in as `admin`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它将允许我在密码字段中什么也不输入的情况下登录。因此，我们将用户名设置为`admin'#`，然后可以输入任何我们想用的密码。我们只输入`1`，然后登录；我们可以看到我们成功以`admin`身份登录：
- en: '![](assets/32e06529-9c0e-4ec0-a5c0-a96844b077fb.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32e06529-9c0e-4ec0-a5c0-a96844b077fb.png)'
- en: Again, this is black-box testing, so we don't really see the code. In many cases,
    we want to play around with it and see how it works, but the main thing we want
    to test is whether the SQLi exists and we do that using the method from the previous
    section. So, try single quotes, try the `and` statement, try a true `and` statement,
    such as `1=1`, and then a false `and` statement, such as `1=0` or `2=0`, and,
    if they work as expected, your target has an SQLi and you can start playing around
    with it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这是黑箱测试，所以我们并不真正看到代码。在许多情况下，我们希望进行尝试并观察它是如何工作的，但我们主要要测试的是SQL注入是否存在，我们使用前一节中的方法进行测试。所以，尝试单引号，尝试`and`语句，尝试一个真实的`and`语句，比如`1=1`，然后尝试一个假的`and`语句，比如`1=0`或者`2=0`，如果它们按预期工作，那么你的目标就有SQL注入漏洞，你可以开始玩弄它。
- en: Discovering an SQLi using the GET method
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现使用GET方法的SQL注入（SQLi）
- en: 'Now we will study an SQLi in a different file, on a different page, and see
    a few different things that we can do to exploit that vulnerability. So, first,
    go to the login page, which is in OWASP Top 10 | A1-Injection | SQL-Extract Data
    | User Info:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在不同的文件中研究一个SQLi，在不同的页面上看到一些不同的东西，我们可以利用这个漏洞。首先，转到登录页面，该页面位于OWASP十大 | A1-注入
    | SQL-提取数据 | 用户信息：
- en: '![](assets/411b57be-1245-4cff-bcdf-e8bc36c80c04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/411b57be-1245-4cff-bcdf-e8bc36c80c04.png)'
- en: 'In the previous section, we went to the login page by clicking on the Login/Register
    option on the page; this time we''re going to go through the User Info page, so
    the page will show us information about the user, provided we give the Name and
    Password. Enter all the credentials, such as `username` and `password`, and the
    page will show us all the `username` and `password` details and our signature,
    as shown:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们通过单击页面上的登录/注册选项进入了登录页面；这次我们将通过用户信息页面，因此页面将向我们显示有关用户的信息，只要我们提供姓名和密码。输入所有凭据，如`username`和`password`，页面将向我们显示所有`username`和`password`详细信息以及我们的签名，如下所示：
- en: '![](assets/41a31b53-f88f-41a0-bb08-308a57e7a349.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41a31b53-f88f-41a0-bb08-308a57e7a349.png)'
- en: 'The statement that''s been executed here is similar to what was executed when
    we logged in. As we can see in the following code, `select * from accounts where
    $USERNAME` is what we put in the `username` field, and `$PASSWORD` is what we
    put in the `password` field:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里执行的语句类似于我们登录时执行的语句。正如我们在以下代码中看到的那样，`select * from accounts where $USERNAME`是我们放入`username`字段中的内容，`$PASSWORD`是我们放入`password`字段中的内容：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we''re going to see a different way of exploiting this kind of vulnerability.
    In the previous section, we were doing it using a `POST` textbox, so whatever
    you put in the textbox was being posted to the web application using a `POST`
    method. Now, these vulnerabilities can exist in the `GET` method too, and what
    we mean by `GET` is that, when something is sent using `GET`, we will see it in
    the URL. So, if we look at the following URL, we see it''s being sent as `username=zaid&password=
    123456`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到一种利用这种漏洞的不同方式。在上一节中，我们是使用`POST`文本框来执行的，因此无论您在文本框中放入什么都将使用`POST`方法将其发布到Web应用程序。现在，这些漏洞也可能存在于`GET`方法中，我们所说的`GET`是指，当使用`GET`发送某些内容时，我们将在URL中看到它。因此，如果我们查看以下URL，我们将看到它被发送为`username=zaid&password=123456`：
- en: '![](assets/8fa6e038-3415-43d3-9019-84b560ee0957.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8fa6e038-3415-43d3-9019-84b560ee0957.png)'
- en: Copy the URL and we will start playing with it from the URL instead of on the
    web page. We just want to show a different example, because in many places there
    might not even be textboxes. It could be something such as `news.php`. In our
    example, it's `index.php`, and in our pen testing, you might see something such
    as `news.php` and `id=2`, and then we can try to inject it in there. So, we're
    going to be injecting things into the `username` field, and we will enter information
    in the URL. When we are doing our pen test, any time we see parameters such as `username`
    and `password`, we should try to inject them; any time we see `something.php`
    and then we have a parameter that equals something, always try to inject it in
    there and see if it works for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 复制URL，我们将从URL开始进行操作，而不是在网页上进行操作。我们只是想展示一个不同的例子，因为在许多地方甚至可能没有文本框。它可能是诸如`news.php`之类的东西。在我们的示例中，它是`index.php`，在我们的渗透测试中，您可能会看到诸如`news.php`和`id=2`之类的东西，然后我们可以尝试在其中注入。因此，我们将向`username`字段注入内容，并在URL中输入信息。当我们进行渗透测试时，每当看到诸如`username`和`password`之类的参数时，我们应该尝试注入它们；每当看到`something.php`然后我们有一个等于something的参数时，总是尝试在其中注入并查看是否适用于我们。
- en: 'We''ve also seen a way of discovering the injection using a quotation mark
    and an `and` statement. So we do a false `and`, and a true `and`, `and 1=1`, and
    then `and 1=2`, and if the server executes what we want, we''re going to know
    there''s an SQLi. We are going to see another way of discovering these exploits,
    by using the `order by` statement. The `order by` statement is used to limit the
    amount or the number of records that are going to be displayed onscreen. Our injection
    is going to do `order by 1`. If the injection exists, this should work because
    `order by 1`. There should be at least one record being selected in the page because
    we know this page is communicating with the database. So, `order by 1` should
    always work and return true or something we expect. We also need to add the comment
    and execute a code, so it''s exactly as before. Basically what''s going to happen
    on the database is that the code that will be executed on it will look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了使用引号和`and`语句发现注入的方法。因此，我们先进行一个错误的`and`，然后是一个正确的`and`，`and 1=1`，接着是`and
    1=2`，如果服务器执行了我们想要的操作，我们就知道有SQL注入漏洞。我们还将看到另一种发现这些漏洞的方法，那就是使用`order by`语句。`order
    by`语句用于限制屏幕上将显示的记录数量。我们的注入将执行`order by 1`。如果注入存在，这应该会成功，因为`order by 1`。页面应该至少选择一条记录，因为我们知道该页面正在与数据库通信。所以，`order
    by 1`应该始终有效并返回我们预期的结果。我们还需要添加注释并执行代码，和之前完全一样。基本上，数据库中执行的代码将如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The command for the URL will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: URL的命令将如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For this example, it''s going to be `select * from accounts where username
    = ''zaid''`, and note how a single quote (`''`) ends the statement; we''re going
    to do `order by 1`. The comment will tell the SQL interpreter to ignore anything
    that comes in after it, which is all of commands after hashtag (`#`). Copy the
    preceding code and paste it in the Name textbox of the login page. This will work,
    but we are just looking at a different way of doing it by injecting it through
    the browser. Another thing to note is that, when we are injecting stuff into the
    browser, the code should be encoded so, for example, the hashtag (`#`) sign should
    be written as `%23`. Spaces, for example, get converted to `%20`, and `%23` is
    the comment that we''re using, so we are going to copy that and replace our comment
    sign with it in the URL space. So, the URL changes to the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，查询将是`select * from accounts where username = 'zaid'`，注意单引号（`'`）结束了语句；我们将执行`order
    by 1`。评论将告诉SQL解释器忽略其后的所有内容，这些内容都是井号（`#`）后的命令。复制前面的代码并将其粘贴到登录页面的姓名文本框中。这是可行的，但我们只是通过浏览器注入它，查看另一种做法。另一个需要注意的点是，当我们将内容注入浏览器时，代码应该进行编码，因此，例如，井号（`#`）应该写成`%23`。空格将转换为`%20`，而`%23`是我们用作注释的符号，所以我们将复制它并在URL空间中替换掉我们的注释符号。于是，URL变更为以下内容：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Paste the URL in the address bar and hit *Enter*, and we will something that''s
    acceptable. Then it will show us the information about zaid, 123456, and and also
    the Signature, so it is ignoring the password, so the injection worked—it''s ordering
    by `1`, so it''s not showing any error:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将网址粘贴到地址栏并按下*回车*，然后我们会看到一个可接受的结果。接着它会显示关于zaid、123456和签名的信息，因此它忽略了密码，注入成功——它按`1`排序，因此没有显示任何错误：
- en: '![](assets/ade40e2a-d3ad-4177-afef-f4e23772fe6c.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ade40e2a-d3ad-4177-afef-f4e23772fe6c.png)'
- en: 'Let''s try to make `1` a very large number, for example, we can put `10000`
    or `100000` in the URL section. It will show us `1000000` records on the login
    page. The chances are the page will not display `1000000` records and there aren''t `1000000`
    records in the database, so when we execute it, we will see that there is an error.
    The error is in the order clause and there is an `Unknown` column for `1000000`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将`1`设置为一个非常大的数字，例如，我们可以在URL部分放入`10000`或`100000`。它将显示`1000000`条记录在登录页面上。可能页面不会显示`1000000`条记录，并且数据库中也没有`1000000`条记录，所以当我们执行时，会看到一个错误。错误发生在`order`子句中，`1000000`是一个未知的列：
- en: '![](assets/2d32d79d-f13c-4596-8b8a-96e5b848dd1a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d32d79d-f13c-4596-8b8a-96e5b848dd1a.png)'
- en: So, there aren't `1000000` columns in the database, and this is great because
    now we know that the database is executing what we want. So, when we told it to
    show `1` record, it show us one record, and when we told it to showed us a very
    large number of records, it complained about that, so it's obviously vulnerable
    to SQL injections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，数据库中没有 `1000000` 列，这非常好，因为现在我们知道数据库正在执行我们想要的操作。当我们告诉它显示 `1` 条记录时，它确实显示了一条记录，当我们告诉它显示大量记录时，它对此进行了抱怨，因此它显然对
    SQL 注入存在漏洞。
- en: Basic SELECT statements
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 SELECT 语句
- en: Let's try to determine how many columns are being selected into page in the
    preceding screenshot. How much information is being selected and displayed on
    the login page that we got when we fired the query in the previous section? To
    do that, we're going to use the `order by` statement. We used `order by 1` in
    the preceding section and that returned something acceptable, and `order by 1000000`
    gave us an error, so let's try `order by 10`; we will see that we still get an
    error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试确定在前面的截图中有多少列被选入页面。我们在前一部分执行查询时，在登录页面上选择并显示了多少信息？为了做到这一点，我们将使用 `order by`
    语句。在前一部分中，我们使用了 `order by 1`，这返回了一个可接受的结果，而 `order by 1000000` 给出了错误，所以我们尝试使用
    `order by 10`；我们将看到，依然会出现错误。
- en: 'Try an `order by 5` and we will see whether that it works. By performing this,
    we know that there are five columns being selected from a certain table, and it''s
    the `accounts` table, which is then displayed on the login page. Let''s build
    our own `select` statement and get it executed on the target computer. At the
    moment, the statement is `Select * from accounts where username = ''zaid''` and
    we''re doing `order by 1`. Let''s see whether we can fix that and get it to `select`
    something that we like. As we are trying to do multiple `select` statements and
    we''re trying to do it from the URL, we''re going to have to use a union and then
    we''re going to say `select`. In this web application, we know that there are
    five records being selected, so there are five columns that are being selected,
    so we''re doing `1,2,3,4,5`; let''s run the command in the URL and see what happens:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 `order by 5`，我们将看看它是否有效。通过执行这个操作，我们知道有五列是从某个表中被选中的，且这个表是 `accounts` 表，然后它显示在登录页面上。现在，让我们构建我们自己的
    `select` 语句，并在目标计算机上执行。此时，语句是 `Select * from accounts where username = 'zaid'`，并且我们正在使用
    `order by 1`。让我们看看是否可以修复它，并使它选择我们喜欢的内容。由于我们正在尝试进行多个 `select` 语句，并且我们打算从 URL 中进行操作，我们需要使用
    union，然后我们将说 `select`。在这个 web 应用中，我们知道有五条记录被选中，所以有五列被选中，因此我们正在执行 `1,2,3,4,5`；让我们在
    URL 中运行这个命令，看看会发生什么：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see that the selection was right and we got the first selection:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到选择是正确的，我们得到了第一次选择的结果：
- en: '![](assets/10d9c4a1-20d6-4719-a09d-0c7266989cea.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10d9c4a1-20d6-4719-a09d-0c7266989cea.png)'
- en: This line has done the first selection and then it did `union`, so it combined
    that selection with another selection and it showed us something else. As we can
    see in the preceding screenshot, we're only seeing 2, 3, and 4, which means that
    whatever value we enter instead of `2`, `3`, or `4`, or whatever we want to `select`.
    Is going to be displayed in the page if we put it in the URL, and we can see that
    we have results for `2`, so whatever you put in `2` will also be shown in the
    page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行完成了第一次选择，然后执行了 `union`，所以它将这个选择与另一个选择合并，并显示了其他内容。正如我们在前面的截图中看到的，我们只看到了 2、3
    和 4，这意味着无论我们在 `2`、`3` 或 `4` 位置输入什么值，或者我们想要 `select` 的内容，只要我们将其放入 URL 中，它就会显示在页面上，并且我们可以看到
    `2` 的结果，所以无论你在 `2` 中放入什么，都会显示在页面上。
- en: 'So, let''s try to see our database. Instead of `2` we''re going to say `database`,
    instead of `3` we''re going to say `username` or `user`, and instead of `4` we''re
    going to do `version`; this will `select` the current database, the current user
    privileges that we have, and the version of the database. So, let''s execute the
    following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试查看我们的数据库。我们将 `2` 改为 `database`，将 `3` 改为 `username` 或 `user`，将 `4` 改为
    `version`；这将 `select` 当前的数据库、我们当前拥有的用户权限和数据库的版本。于是，让我们执行以下命令：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The URL command changes as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: URL 命令的变化如下：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the command is in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下截图所示：
- en: '![](assets/104437f6-dc76-4701-b224-6276d8ea3a65.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/104437f6-dc76-4701-b224-6276d8ea3a65.png)'
- en: The Username is showing up as owasp10 and `2`, so `owasp` is the database that
    we're looking for. The current user that we're logged in as is root@localhost,
    so we're the `root` user. We injected the version and we can see this is the version
    of MySQL, so it's 5.0.51. We know that the database we're connected to is `owasp``10`.
    In most real-world scenarios, each database is assigned to a certain user, so
    you're usually only able to `select` details, tables, columns, and data located
    in this current database. However, we are logged in as `root` and the web application
    has been connected to the database as `root`, so we can access other databases,
    but this doesn't happen in real-world scenarios. Usually each user has their own
    database, so when they connect a web application to a database, they connect it
    to one database and therefore you won't to be able to access other databases.
    So, we're going to imagine that we only have access to `owasp10`, which is our
    current database for this current website, and that the password is `root@localhost`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名显示为owasp10和`2`，所以`owasp`是我们正在查找的数据库。我们当前以root@localhost身份登录，所以我们是`root`用户。我们注入了版本信息，并且可以看到这是MySQL的版本，版本号是5.0.51。我们知道我们连接的数据库是`owasp10`。在大多数实际场景中，每个数据库都会分配给某个特定用户，因此你通常只能`select`当前数据库中的详细信息、表格、列和数据。然而，我们以`root`身份登录，且Web应用程序已连接到数据库并使用`root`，所以我们可以访问其他数据库，但这在现实场景中并不常见。通常，每个用户都有自己的数据库，因此当他们将Web应用程序连接到数据库时，他们只会连接到一个数据库，因此你无法访问其他数据库。所以，我们假设我们仅能访问`owasp10`，这是当前网站的数据库，且密码为`root@localhost`。
- en: In the next section, we'll see how we can further exploit SQL injections and
    perform more powerful `select` statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何进一步利用SQL注入并执行更强大的`select`语句。
- en: Discovering tables
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现表格
- en: 'Now that we know our target database is called `owasp10`, let''s try to discover
    the tables that exist in that database. So, our `select` statement is `union select
    1, database(),user(),version(),5`. Delete `user()` and `version()`, or change
    it to `null` because we only want to `select` one thing now, and in `2`, we''re
    going to `select table_name` from the `information_schema` database. We know that
    `information_schema` is a default database created by MySQL and it contains information
    about all the other databases. We select `table_name` from `information_schema.` and
    after the dot, we put `tables`. Basically, we''re selecting a table called `tables`
    from a database called `information_schema`, and the column that we''re selecting
    is called `table_name`, so we are selecting `table_name` from the `information_schema` database
    from the `tables` table. The command is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道目标数据库叫做`owasp10`，让我们尝试发现该数据库中存在的表格。所以，我们的`select`语句是`union select 1, database(),user(),version(),5`。删除`user()`和`version()`，或者将它们改为`null`，因为我们现在只想`select`一项，并且在`2`中，我们将从`information_schema`数据库中`select
    table_name`。我们知道`information_schema`是MySQL创建的默认数据库，包含有关其他所有数据库的信息。我们从`information_schema`中选择`table_name`，点后跟`tables`。基本上，我们是在从名为`information_schema`的数据库中选择名为`tables`的表格，并且我们选择的列叫做`table_name`，所以我们是从`information_schema`数据库的`tables`表中选择`table_name`。命令如下：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The URL command changes as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: URL命令更改如下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the command to see whether we can get all the tables that exist in
    the `owasp10` database. We can see that we got 237 records; following are all
    the tables that we have access to:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令以查看我们是否能够获取`owasp10`数据库中所有现有的表格。我们可以看到我们得到了237条记录；以下是我们可以访问的所有表格：
- en: '![](assets/c8960776-f376-4ae1-9d76-7ba8ec3b9ff1.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8960776-f376-4ae1-9d76-7ba8ec3b9ff1.png)'
- en: We are logged in as `root`, therefore, we can see tables from other web applications,
    such as tikiwiki, but in real-world scenarios, we'll only see tables related to
    the current database, which is Mutillidae.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`root`身份登录，因此我们可以看到其他Web应用程序的表格，例如tikiwiki，但在现实场景中，我们通常只能看到与当前数据库（即Mutillidae）相关的表格。
- en: 'Now we are going to use a `where` clause and say `where table_schema = ''owasp10''`.
    We got the `owasp10` databases when we executed the command, so we got `owasp10`,
    which is the current database that Mutillidae is working on. We''re using the
    same statement: we''re selecting `table_name` from the `information_schema` table
    where `table_schema` is `owasp10`. The command is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要使用`where`子句并且说`where table_schema = 'owasp10'`。我们在执行命令时得到了`owasp10`数据库，所以我们得到了`owasp10`，这是Mutillidae正在使用的当前数据库。我们使用相同的语句：我们从`information_schema`表中选择`table_name`，其中`table_schema`为`owasp10`。命令如下：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The URL command changes as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: URL命令更改如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Execute it and, as we can see in the following screenshot, we only have the
    tables that we''re interested in:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它后，如下截图所示，我们只看到了我们感兴趣的表：
- en: '![](assets/7cd4232a-8e83-4099-af76-cda858ed94fb.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cd4232a-8e83-4099-af76-cda858ed94fb.png)'
- en: We have the `accounts`, `blogs_table`, `captured_data`, `credit_cards`, `hitlog`,
    and `pen_test_tools` tables. Now, in the *What is SQL?* section, we saw the content
    of the `owasp10` table and the preceding screenshot also shows the same tables
    of the `owasp` database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`accounts`、`blogs_table`、`captured_data`、`credit_cards`、`hitlog`和`pen_test_tools`等表。现在，在*什么是SQL？*部分，我们看到了`owasp10`表的内容，前面的截图也展示了`owasp`数据库中的相同表。
- en: Reading columns and their data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取列及其数据
- en: In this section, lets see whether we can `select` and have a look at all the
    details that exist within the `accounts` table. Let's see whether we can query
    the database and read the information stored in the `accounts` table. To do that,
    we need to know the names of the columns that exist within the `accounts` table
    because, if we look at the way we're using our statement, we're performing `union
    select table_name from information_schema.tables`, so we still don't know what
    columns exist in the `accounts` table. We can guess that there is a username and
    a password, but sometimes they could have different names, so we're going to see
    how we can `select` the columns for a certain table.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看是否可以`select`并查看`accounts`表中的所有详细信息。让我们检查一下是否能够查询数据库并读取`accounts`表中存储的信息。为此，我们需要知道`accounts`表中存在的列名，因为根据我们使用的语句，我们正在执行`union
    select table_name from information_schema.tables`，所以我们还不知道`accounts`表中有哪些列。我们可以猜测它有一个用户名和一个密码，但有时它们可能有不同的名称，所以我们将看看如何`select`某个表的列。
- en: 'The command is going to be very similar to the `tables` command we used in
    the preceding section, the only difference is instead of `table_name`, we''re
    going to type `column_name`, and instead of selecting it from `information_schema.tables`,
    we''re going to select it from `information_schema.columns`. We''re going to type
    `where table_name = ''accounts''`, because we''re only interested in the `accounts`
    table. If we wanted to get columns for another table, we just substitute `accounts `with
    the required table, or column, that we want. So, our command is going to be as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将与我们在前一节中使用的`tables`命令非常相似，唯一的区别是我们将`table_name`替换为`column_name`，并且不是从`information_schema.tables`中选择，而是从`information_schema.columns`中选择。我们将输入`where
    table_name = 'accounts'`，因为我们只对`accounts`表感兴趣。如果我们想获取其他表的列，只需将`accounts`替换为所需的表或列名即可。所以，我们的命令如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The URL command changes to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: URL命令变为以下内容：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The command should show us all the columns that exist within the `accounts`
    table. Run the command and, once we execute it in the address bar, we will see
    the same columns that we saw before when we saw the structure of the `accounts`
    database at the start of this chapter, and its `cid`, `username`, `password`,
    `mysignature`, and `is_admin` columns, as shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该显示`accounts`表中存在的所有列。运行命令后，当我们在地址栏中执行它时，我们将看到与本章开始时看到的`accounts`数据库结构相同的列，以及其`cid`、`username`、`password`、`mysignature`和`is_admin`列，如下图所示：
- en: '![](assets/59b0eb82-cff2-4768-b309-b2d50e507227.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59b0eb82-cff2-4768-b309-b2d50e507227.png)'
- en: 'Let''s take this one step further and `select` the `usernames` and `passwords` columns
    from the `accounts` table. So, again, the command is going to be very similar
    to what we''re running at the moment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，`select`出`accounts`表中的`usernames`和`passwords`列。因此，命令将与我们当前执行的非常相似：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, remember, we can''t select anything instead of `1` and `5` in the command
    because they never displayed for us on the screen. The only thing that displayed
    were `2`, `3`, and `4`, so we''re only substituting values for `2`, `3`, and `4`.
    Our URL command changes to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，我们不能在命令中选择除`1`和`5`之外的任何其他数字，因为它们从未在屏幕上显示给我们。唯一显示的数字是`2`、`3`和`4`，所以我们只需替换`2`、`3`和`4`的值。我们的URL命令变为以下内容：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''re selecting `username`, `password`, and `is_admin` columns from the `accounts` database,
    and it should return all the usernames and passwords that exist within the `accounts`
    table. As we can see in the following screenshot, we got all the usernames and
    passwords:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从`accounts`数据库中选择`username`、`password`和`is_admin`列，它应该返回`accounts`表中所有的用户名和密码。如以下截图所示，我们获得了所有的用户名和密码：
- en: '![](assets/4ae314a7-f781-4d52-a27a-85c32e50a4ff.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ae314a7-f781-4d52-a27a-85c32e50a4ff.png)'
- en: We have the `admin`, and the password is `adminpass`; we also have other usernames
    and their passwords. This is very useful because, on most websites, when we log
    in as `admin`, we have more privileges than a normal person, and then we have
    to be able to upload PHP shells or backdoors, viruses, whatever we want, and then
    further exploit the system. So, at the moment, we can actually log in with the
    `admin` username and the `adminpass` password, and it's going to accept that because
    it's correct. No matter how complicated the password, we're just going to be logged
    in because we're reading the password straight from the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`admin`用户名，密码是`adminpass`；我们还有其他用户名和密码。这非常有用，因为在大多数网站上，当我们以`admin`身份登录时，我们拥有比普通用户更多的权限，然后我们就可以上传PHP
    shell、后门、病毒，或者任何我们想要的东西，进而进一步利用系统。所以，此时我们实际上可以用`admin`用户名和`adminpass`密码登录，系统会接受这个登录，因为密码是正确的。不论密码多复杂，我们都会成功登录，因为我们直接从数据库中读取了密码。
- en: Reading and writing files on the server
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上读取和写入文件
- en: In this section, we will look at how we can use SQLi to read any file in the
    server. So, even if the file exists outside the `/www` directory, we'll be able
    to read it exactly as with a file-disclosure vulnerability, and we'll see how
    we can use it to write files and upload them to the system, just as with a file-upload
    vulnerability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨如何使用SQLi来读取服务器中的任何文件。所以，即使文件位于`/www`目录之外，我们也能像文件泄露漏洞一样精确地读取它，我们还将看到如何利用这一点写入文件并将其上传到系统，就像文件上传漏洞一样。
- en: 'First, let''s take a look at reading the file; we are going to set everything
    to `null`. So, our statement is going to be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何读取文件；我们将把所有设置为`null`。所以，我们的语句如下：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead of selecting a column or a table, we want to run a function called `load_file()`,
    and we are going to set the file that we want to load. We''re going to use the
    same file that we had a look at in the file-inclusion vulnerability, which was
    `/etc/passwd`. The URL command is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不选择列或表，而是希望运行一个名为`load_file()`的函数，然后我们将设置要加载的文件。我们将使用之前在文件包含漏洞中查看的相同文件，即`/etc/passwd`。URL命令如下：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the preceding URL, we can see from the following screenshot that we
    managed to read all the information and all the content of `/etc/passwd` file,
    even though it''s not in the web root:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的URL后，我们可以从以下截图中看到，我们成功读取了`/etc/passwd`文件的所有信息和内容，尽管它不在网站根目录中：
- en: '![](assets/7891021d-71f8-4ec2-a006-f5db0d61bd80.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7891021d-71f8-4ec2-a006-f5db0d61bd80.png)'
- en: It's stored in `/etc/passwd`, so we can read anything in the server from other
    websites, or other files, by specifying the full path of that file in the `load_file()`
    function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它存储在`/etc/passwd`中，因此我们可以通过在`load_file()`函数中指定该文件的完整路径，从其他网站或其他文件中读取服务器中的任何内容。
- en: 'Now, we are going write to the server. This is very useful because we will
    be able to write any code we want. We can write the code for a PHP script, we
    can even write code for a shell, a virus, or a PHP code to get a reverse connection—code that
    will basically just act like a file-upload vulnerability. To do that, we are going
    to write the code that we want here and we are going to call it `example example`.
    We''re going to use a function called `into outfile`, and then we''re going to
    specify where we want to store that file. In the best-case scenario, we will be
    able to write to our web root and that will mean that we can access the file through
    the browser and execute it, so we can upload a Weevely file and then connect to
    it. We''re going to save the file in the `/var/www/` directory (that''s our web
    root) so we''ll be able to access things through it, or you can put it in the `/var/www/mutillidae`
    directory. Make sure you set everything to `null` so that nothing gets written
    to the file except what you put in `2`, which is the `example example` text, and
    it''s going to be stored into a file in `/var/www/mutillidae/example.txt`. Following
    is the command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始写入服务器。这非常有用，因为我们将能够写入任何我们想要的代码。我们可以写入 PHP 脚本代码，甚至可以写入 shell、病毒或 PHP
    代码来获取反向连接——这些代码基本上就像是文件上传漏洞。为了做到这一点，我们将把我们想要的代码写在这里，并将其命名为`example example`。我们将使用一个名为`into
    outfile`的函数，然后指定我们想要将该文件存储的位置。在最佳情况下，我们将能够写入 web 根目录，这意味着我们可以通过浏览器访问该文件并执行它，然后上传
    Weevely 文件并连接到它。我们将把文件保存在`/var/www/`目录中（那是我们的 web 根目录），这样我们就可以通过它访问内容，或者你也可以把它放在`/var/www/mutillidae`目录中。确保将所有内容设置为`null`，这样除了你在`2`中输入的`example
    example`文本外，文件中不会写入任何其他内容，并且它将被存储在`/var/www/mutillidae/example.txt`文件中。以下是命令：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s try to run the statement. The URL command is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行该语句。URL 命令如下：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we see the following screenshot, we''ll know that the command didn''t work
    because SQL or MySQL is not allowed to create or write to the `/mutillidae` directory.
    The problem is that we don''t have permissions that allow us to write to the `/mutillidae` location:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到下面的截图，就会知道命令没有成功，因为 SQL 或 MySQL 不允许创建或写入`/mutillidae`目录。问题在于我们没有足够的权限来写入`/mutillidae`位置：
- en: '![](assets/1ab3102c-848a-4440-a2fb-214c6c152644.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ab3102c-848a-4440-a2fb-214c6c152644.png)'
- en: 'To test this exploit, we''re going to change this location to `/tmp` and running
    the code, and we will see that we can actually write to the `/tmp` directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个漏洞，我们将把位置更改为`/tmp`并运行代码，我们会看到实际上我们可以写入`/tmp`目录：
- en: '![](assets/473071a6-92b8-4cea-bd38-72af4dc1fdd7.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/473071a6-92b8-4cea-bd38-72af4dc1fdd7.png)'
- en: 'In the preceding screenshot, it displays error but if we list using `ls /tmp/`,
    we can see in the following screenshot that we have something called `example.txt`.
    If we try to read the file, we will see that it contains the content of our `select`
    command and the `example example` text written in the file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中显示了错误信息，但如果我们使用`ls /tmp/`命令列出文件，我们可以在下面的截图中看到一个名为`example.txt`的文件。如果我们尝试读取该文件，我们将看到它包含我们的`select`命令的内容以及文件中写入的`example
    example`文本：
- en: '![](assets/bb76ddca-3f29-4582-996f-103ef8c2661c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb76ddca-3f29-4582-996f-103ef8c2661c.png)'
- en: We can get rid of `admin` and `adminpass` by just putting in the wrong username
    and nothing will be displayed. The only thing that we will see is the output,
    which is `example example`. Again, this is only useful if we are able to write
    to our web server so we can access it, and then use our shell or our payload to
    further exploit the system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入错误的用户名来摆脱`admin`和`adminpass`，这时不会显示任何内容。我们唯一会看到的是输出，即`example example`。再次强调，这只有在我们能够写入我们的
    web 服务器并访问它时才有用，然后我们可以使用我们的 shell 或 payload 进一步利用该系统。
- en: The sqlmap tool
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sqlmap 工具
- en: In this section, we are going to learn about a tool called `sqlmap`, which allows
    us to do everything we've learned so far and even more. This tool can be used
    against MySQL databases, which is the one that we used in our examples. It can
    also be used against Microsoft SQL, Oracle, and other databases. The tool is very
    useful; sometimes the injections aren't as nice as the ones we've seen, and sometimes
    we only get one output for each record and we have to loop through all the output.
    The tool can automate that and just do everything for us, which is much easier
    and much simpler.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一个称为`sqlmap`的工具，它允许我们做到我们到目前为止学到的一切，甚至更多。这个工具可以针对MySQL数据库进行操作，这是我们示例中使用的数据库之一。它还可以针对Microsoft
    SQL、Oracle和其他数据库进行操作。这个工具非常有用；有时候注入并不像我们看到的那么好，有时我们每条记录只能得到一个输出，我们必须循环遍历所有输出。这个工具可以自动化这一过程，为我们做所有的事情，这样更容易更简单。
- en: 'This is the URL that we were using for the injection; `http://10.20.14.204/mutillidae/index.php?page=user-info.php&password=aaa&user-info-php-submit-button=View+Account+Details`.
    So, the URL is using the `user-info.php` page where the username is `admin`, and
    the password is `adminpass`. We don''t really need to use the username and password,
    so we can put anything there, just to assume that we don''t know the password
    and we''re only injecting SQL injections. Copy the URL and insert it into the
    following `sqlmap` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用于注入的URL：`http://10.20.14.204/mutillidae/index.php?page=user-info.php&password=aaa&user-info-php-submit-button=View+Account+Details`。因此，URL正在使用`user-info.php`页面，用户名为`admin`，密码为`adminpass`。我们实际上不需要使用用户名和密码，所以我们可以在那里放任何东西，只是假设我们不知道密码，我们只是在注入SQL注入。复制该URL并将其插入以下`sqlmap`命令中：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're using the `-u` option to specify the URL; make sure that you put the URL
    between two quotation marks so that it doesn't ignore anything between them. We
    have some signs and characters in the middle that we want to be treated as one
    URL.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`-u`选项来指定URL；确保将URL放在两个引号之间，以免忽略它们之间的任何内容。我们在中间有一些标志和字符，希望它们被视为一个URL。
- en: 'Hit *Enter*, and the tool will automatically look through all the parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*，工具将自动查看所有参数：
- en: '![](assets/8ac200ff-e701-4739-b3c6-596b236d22ca.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ac200ff-e701-4739-b3c6-596b236d22ca.png)'
- en: It's going to look through `user-info.php`, the username, and the password,
    to see whether any of them are injectable; once it does that, it's going to store
    it in its memory. So, it's going to know that if anything is injectable and then
    we'll be able to further exploit the target.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它将查看`user-info.php`中的用户名和密码，看看它们是否可注入；一旦完成，它将存储在内存中。因此，它将知道是否有什么可注入的，然后我们将能够进一步利用目标。
- en: 'As we can see in the following image, it thinks that our target could be MySQL
    or PostgreSQL, it''s asking us whether it should skip other tests, we''re going
    to say *yes* because we know it''s MySQL. Later it will ask us whether it should
    do all the tests for both databases, and we are going to say yes, assuming that
    we are not sure which one it is, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的图片中看到的那样，它认为我们的目标可能是MySQL或PostgreSQL，询问我们是否应该跳过其他测试，我们将会说*是*，因为我们知道它是MySQL。稍后它会问我们是否应该对这两个数据库做所有的测试，我们会说是，假设我们不确定到底是哪一个，如下面的截图所示：
- en: '![](assets/bd60de61-abd9-4014-b9d2-726ab7fabe9b.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bd60de61-abd9-4014-b9d2-726ab7fabe9b.png)'
- en: 'We know it''s MySQL but we are just going to let it do its thing, and we''ll
    see whether it can do it properly or not. It checks whether it''s PostgreSQL and
    we are assuming it''s going to, and then it''s going to know that it''s MySQL,
    it just found out that `username` seems to be injectable, and sure enough it''s
    telling us here that the `username` parameter is vulnerable and we can inject
    it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道它是MySQL，但我们只是让它自行处理，我们将看看它是否能正确地执行。它检查是否为PostgreSQL，我们假设它会这么做，然后它会知道这是MySQL，它刚刚发现`username`似乎是可注入的，确实在这里告诉我们`username`参数是有漏洞的，我们可以进行注入：
- en: '![](assets/660b6b4c-98e1-4f5b-bf7e-d08e0e8c014f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/660b6b4c-98e1-4f5b-bf7e-d08e0e8c014f.png)'
- en: 'So, it''s asking us whether we want to check the other parameters, we can say
    yes and let it do it, but we are going to say *no* because we don''t mind if it
    just uses the `username` for the injection:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它在问我们是否要检查其他参数，我们可以说是并让它执行，但我们将会说*否*，因为如果只是使用`username`进行注入，我们并不介意。
- en: '![](assets/06c9dfa7-abf3-4512-b7ed-18f29bc07892.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06c9dfa7-abf3-4512-b7ed-18f29bc07892.png)'
- en: Now, `sqlmap` knows that the target is injectable and that it's going to use
    the `username` parameter to inject. As we can see in the preceding screenshot,
    it's figured out that it's running `Linux Ubuntu`, it's using `PHP 5.2.4` with
    `Apache 2.2.8`, and it's using the `MySQL 5.0` server as the database server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sqlmap`知道目标是可注入的，它将使用`username`参数进行注入。正如我们在前面的截图中看到的，它已经确定正在运行`Linux Ubuntu`，正在使用`PHP
    5.2.4`，带有`Apache 2.2.8`，并且作为数据库服务器使用`MySQL 5.0`服务器。
- en: '`sqlmap` is a really big tool and, in this section, we are just going to take
    a quick look at some of the things it can do. I suggest you spend more time with
    it and see what else it can do.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap`是一个非常强大的工具，在本节中，我们只是快速看看它可以做些什么。我建议您花更多时间来研究它，看看它还能做什么。'
- en: 'So, let''s run `sqlmap --help`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们运行`sqlmap --help`：
- en: '![](assets/217b8f4f-711b-40e7-9576-1afa03a06cb7.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/217b8f4f-711b-40e7-9576-1afa03a06cb7.png)'
- en: 'Now let''s try to get `current-user` and `current-db`, so we''re going to use
    the same command that we used before. We''ll add to the command `-- dbs` to get
    the current databases:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试获取`current-user`和`current-db`，所以我们将使用之前使用过的相同命令。我们将在命令后添加`-- dbs`以获取当前数据库：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see in the following screenshot, we got all the databases that we
    needed. There''s `dvwa`, `information_schema`, `metasploit`, `mysql`, `owasp10`,
    and `tikiwiki`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的截图中看到的，我们获得了所有需要的数据库。有`dvwa`、`information_schema`、`metasploit`、`mysql`、`owasp10`和`tikiwiki`：
- en: '![](assets/0fd7cf5a-e104-4b3a-b250-e087411bd06b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0fd7cf5a-e104-4b3a-b250-e087411bd06b.png)'
- en: 'Now, if we run the same command replacing `--dbs` with `--current-user`, we
    can see that we are `root`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行相同的命令，将`--dbs`替换为`--current-user`，我们可以看到我们是`root`：
- en: '![](assets/30015ef0-8624-40f8-9408-f7c1a31350f8.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30015ef0-8624-40f8-9408-f7c1a31350f8.png)'
- en: 'And if we replace `--current-user` with `--current-db`, we''ll see that `owasp10`
    is our current database:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`--current-user`替换为`--current-db`，我们将看到`owasp10`是我们当前的数据库：
- en: '![](assets/c762126b-f5b2-4cd1-9f45-85f492670ffa.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c762126b-f5b2-4cd1-9f45-85f492670ffa.png)'
- en: 'So, now let''s try to get the tables for `owasp10`. We''re also going to use
    the `--tables` and `D` option to specify the database, and our database is going
    to be called `owasp10`, so the command is going to be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取`owasp10`的表格。我们还将使用`--tables`和`D`选项来指定数据库，我们的数据库将被称为`owasp10`，因此命令将如下所示：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see in the following screenshot, the command got us all the tables
    that exist in the `owasp10` database, such as, `accounts`, `blogs_table`, and
    `credit_cards` tables:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的截图中所见，该命令为我们获取了存在于`owasp10`数据库中的所有表，如`accounts`、`blogs_table`和`credit_cards`表：
- en: '![](assets/21a3210e-9329-4e67-b2c6-92ee0faebae0.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21a3210e-9329-4e67-b2c6-92ee0faebae0.png)'
- en: 'Now, if we want to get the columns, we can use the same command again, and
    we''re going to say get  `--columns` from `-T accounts -D owasp10`. Following
    is the command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要获取列，我们可以再次使用相同的命令，我们将从`-T accounts -D owasp10`获取`--columns`。以下是命令：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Following is the output of the command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令的输出：
- en: '![](assets/ef54dd84-cc2c-491f-8fef-c9e273708dd5.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ef54dd84-cc2c-491f-8fef-c9e273708dd5.png)'
- en: 'So, we have `is_admin`, `password`, and `username`, and we can get their data
    using the `--dump` option. It''s the same command that we used before, so we''re
    getting it from the `accounts` table and the `owasp10` database. Following is
    the command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有`is_admin`、`password`和`username`，我们可以使用`--dump`选项获取它们的数据。这是我们之前使用的相同命令，因此我们从`accounts`表和`owasp10`数据库获取它们。以下是命令：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Following is the output of the preceding command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令的输出：
- en: '![](assets/c9d0babf-536f-4438-9854-c9d73f894280.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c9d0babf-536f-4438-9854-c9d73f894280.png)'
- en: In the preceding screenshot we have `admin`, its `adminpass` password, and we
    have `adrian` and his password is `somepassword`. So, as we said, this tool is
    very useful. It can make our life much easier and it does everything automatically.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们有`admin`，其`adminpass`密码，还有`adrian`，他的密码是`somepassword`。所以，正如我们所说，这个工具非常有用。它可以让我们的生活变得更加轻松，而且一切都是自动的。
- en: Preventing SQLi
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止SQL注入
- en: So far, we have seen that SQL injections are very dangerous; they also occur
    very easily and are very easy to find. We will find them everywhere, even in really
    famous websites. People try to prevent these vulnerabilities using filters. Filters
    can make it look like there are no exploits, but if we actually try harder, by
    using different types of encoding, or a proxy, we will be able to bypass most
    of these filters. Some programmers use a blacklist so, for example, they prevent
    the use of `union` and the `insert` statement. Again, it's not 100% secure, and
    it can be bypassed. Using a whitelist has exactly the same issues as a blacklist.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到SQL注入是非常危险的；它们也非常容易发生，而且很容易被发现。我们会在任何地方发现它们，甚至在一些非常著名的网站中。人们尝试通过使用过滤器来防止这些漏洞。过滤器可以让它看起来好像没有漏洞，但如果我们实际加大力度，使用不同类型的编码，或者通过代理，我们将能够绕过大多数这些过滤器。一些程序员使用黑名单，例如，防止使用`union`和`insert`语句。但这并不是百分之百安全的，也可以被绕过。使用白名单也存在与黑名单完全相同的问题。
- en: 'The best way to prevent SQLi is to program our web application so that it does
    not allow code to be injected into it and then executed. So, the best way to do
    that is to use parameterized statements, where the data and the code are separated.
    Let''s look at an example, we are keeping the least amount of programming in this
    example. We don''t want it to be a programming example (there are actually mistakes
    in the programming), but we are trying to look at the concept more than how to
    program it. Following is the example code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 防止SQL注入的最佳方法是编写我们的Web应用程序，使其不允许代码被注入并执行。所以，最佳的做法是使用参数化语句，在这种语句中，数据和代码是分开的。让我们来看一个例子，我们在这个例子中尽量保持最少的编程部分。我们不希望它成为一个编程示例（实际上，编程中存在错误），但我们试图更多地关注概念，而非如何编写代码。以下是示例代码：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The vulnerable code used `Select * from accounts` where `username` is equal
    to whatever we put in `textbox1`, and then we put in `textbox1`, say `admin`,
    and then close the quote. Then we''re able to do `union select` and execute something
    else; once we''re done, we add the comment (`#`), which basically ignores everything
    that comes in after it. The code looks like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脆弱的代码使用了`Select * from accounts`，其中`username`等于我们在`textbox1`中输入的内容，然后我们在`textbox1`中输入例如`admin`，并且关闭引号。接着，我们能够执行`union
    select`并执行其他操作；一旦完成，我们添加注释（`#`），这基本上会忽略注释之后的所有内容。代码看起来是这样的：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is very bad and very difficult to protect against. Using filters will
    only hide the problem, it will not fix it. The best way to fix the vulnerability
    is using parameterize statements, as in the following example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常糟糕，且非常难以防范。使用过滤器只会隐藏问题，并不能解决它。解决漏洞的最佳方法是使用参数化语句，以下是一个示例：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the safe way to do it. First, we `prepare` our statement. Most languages,
    such as PHP, actually have a function where you can `prepare ("Select * from accounts
    where username = ?")` and then we send the values. So, PHP now knows the SQL statement
    is `Select * from accounts where username` is equal to something, and then it''s
    going to take the value of `textbox1`. Even if we come in and use our very sneaky
    statement, which is `''$admin'' union select #''`, and paste it in the `execute`
    function, the web application will know that the value for `textbox1` is `admin
    union select`. It will actually try to use `Select * from accounts where` the
    `username`, and then it actually will add its own quotes and try to find `username`
    with the inserted `username`. So, it will be `select * from accounts where username
    ="''$admin'' union select#`. Therefore, whatever we put in `textbox`, it will
    be sent as a value, and the web application will know that this should be a value
    not code, and it will never execute it. This will protect us against SQL injections.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '这是安全的做法。首先，我们`prepare`语句。大多数语言，比如PHP，实际上都有一个可以`prepare ("Select * from accounts
    where username = ?")`的函数，然后我们发送值。所以，PHP现在知道SQL语句是`Select * from accounts where
    username`等于某个值，然后它会使用`textbox1`的值。即使我们使用非常狡猾的语句`''$admin'' union select #''`并粘贴到`execute`函数中，Web应用程序也会知道`textbox1`的值是`admin
    union select`。它实际上会尝试使用`Select * from accounts where`的`username`，然后它会添加自己的引号，并尝试用插入的`username`查找`username`。所以，它会变成`select
    * from accounts where username ="''$admin'' union select#`。因此，无论我们在`textbox`中输入什么内容，它都会被当作一个值发送，Web应用程序会知道这应该是一个值而不是代码，它将永远不会执行它。这将保护我们免受SQL注入攻击。'
- en: We can use the filters as a second line of defense. It's also advised that we
    use the least privilege possible. So, for each database, use one user with the
    least amount of privileges required; don't allow users to do anything that they
    want; unless it's a simple website that only does selection, then only allow the
    user to `select`. If they only need to `select` and `insert`, then only allow
    them to `select` and `insert`; this is a rule we should keep with everything,
    even with Linux systems. Make sure the permissions are always as minimal as possible,
    that each user doesn't have any extra permissions they don't need.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将过滤器作为第二道防线。建议我们使用最小权限原则。因此，对于每个数据库，使用一个权限最小的用户；不要允许用户做任何他们想做的事；除非是一个只做选择的简单网站，那么只允许用户`select`。如果他们只需要`select`和`insert`，那么只允许他们`select`和`insert`；这是我们应该遵循的规则，甚至对于Linux系统也是如此。确保权限始终保持最小化，确保每个用户没有任何他们不需要的额外权限。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a vulnerability that can be exploited, which are
    SQL injections. This SQLi can be used to perform a wide range of very dangerous
    attacks on the databases of a machine and the server. First, we saw how we can
    discover these injections. We also learned how we can log in to a system using
    a URL—all we had to do was launch a few lines of code in which we had to mention
    the password and username. Then, we saw how to bypass SQLi without using login
    credentials. We even used the `GET` method to discover SQLi. After that, we learned
    how to fire basic `select` statements on a database. We even learned how to use
    the `sqlmap` tool, which is capable of performing a lot of things, but we only
    covered the basics in this chapter. Finally, we covered methods to prevent SQLi.
    In the next chapter, we are going to exploit cross-site scripting vulnerabilities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了一个可以被利用的漏洞，那就是SQL注入。SQLi可以用于对机器和服务器的数据库执行一系列非常危险的攻击。首先，我们看到如何发现这些注入漏洞。我们还学会了如何通过URL登录系统——我们只需要启动几行代码，代码中只需要提到密码和用户名。接着，我们看到了如何在不使用登录凭证的情况下绕过SQLi。我们甚至使用`GET`方法来发现SQLi。之后，我们学会了如何在数据库上执行基本的`select`语句。我们还学会了如何使用`sqlmap`工具，该工具能够执行很多操作，但我们在这一章中只介绍了基础部分。最后，我们讨论了防止SQLi的方法。在下一章中，我们将利用跨站脚本漏洞。
