- en: Malware Functionalities and Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件功能和持久性
- en: Malware can carry out various operations, and it can include various functionalities.
    Understanding what a malware does and the behavior it exhibits is essential to
    understanding the nature and purpose of the malicious binary. In the last few
    chapters, you learned the skills and tools necessary to perform malware analysis.
    In this chapter and the next few chapters, we will mainly focus on understanding
    different malware behaviors, their characteristics, and their capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以执行各种操作，它可能包含各种功能。 理解恶意软件的功能和行为至关重要，以便理解恶意二进制文件的性质和目的。 在过去的几章中，你学习了执行恶意软件分析所需的技能和工具。
    在本章和接下来的几章中，我们将主要关注理解不同的恶意软件行为，它们的特征及其能力。
- en: 1\. Malware Functionalities
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 恶意软件功能
- en: By now, you should have an understanding of how malware utilizes API functions
    to interact with the system. In this section, you will understand how malware
    makes use of various API functions to implement certain functionality. For information
    regarding where to find help about a particular API and how to read the API documentation,
    refer to section 3, *Disassembling the Windows API, *in [Chapter 5](part0146.html#4B7I40-ac10ba3f98854c44bac1c2c5641ca485), *Disassembly
    Using IDA.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经了解恶意软件如何利用API函数与系统进行交互。 在本节中，你将了解恶意软件如何利用各种API函数实现特定功能。 有关在特定API上寻求帮助以及如何阅读API文档的信息，请参考第3节，《Windows
    API反汇编》，在[第5章](part0146.html#4B7I40-ac10ba3f98854c44bac1c2c5641ca485)中，《使用IDA进行反汇编》。
- en: 1.1 Downloader
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 下载器
- en: The simplest type of malware that you will encounter during malware analysis
    is a *Downloader*. A downloader is a program that downloads another malware component
    from the internet and executes it on the system. It does that by calling the `UrlDownloadToFile()`
    API, which downloads the file onto the disk. Once downloaded, it then uses either
    `ShellExecute()`, `WinExec()`, or `CreateProcess()` API calls to execute the downloaded
    component. Normally, you will find that downloaders are used as part of the exploit
    shellcode.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行恶意软件分析时，你将遇到的最简单类型的恶意软件是*下载器*。 下载器是从互联网下载另一个恶意软件组件并在系统上执行的程序。 它通过调用`UrlDownloadToFile()`
    API来完成文件下载到磁盘上。 下载完成后，它再使用`ShellExecute()`、`WinExec()`或`CreateProcess()` API调用来执行下载的组件。
    通常情况下，你会发现下载器被用作攻击载荷的一部分。
- en: 'The following screenshot shows a 32-bit malware downloader using `UrlDownloadToFileA()`
    and `ShellExecuteA()` to download and execute a malware binary. To determine the
    URL from where the malware binary is being downloaded, a breakpoint was set at
    the call to `UrlDownloadToFileA()`. After running the code, the breakpoint was
    triggered, as shown in the following screenshot. The second argument to `UrlDownloadToFileA()`
    shows the URL from where the malware executable (*wowreg32.exe*) will be downloaded,
    and the third argument specifies the location on the disk where the downloaded
    executable will be saved. In this case, the downloader saves the downloaded executable
    in the `%TEMP%` directory as `temp.exe`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了一个32位恶意软件下载器使用`UrlDownloadToFileA()`和`ShellExecuteA()`来下载和执行恶意二进制文件。
    为了确定从哪个URL下载恶意二进制文件，设置了一个在调用`UrlDownloadToFileA()`时断点。 运行代码后，断点被触发，如下截图所示。 `UrlDownloadToFileA()`的第二个参数显示了恶意可执行文件（*wowreg32.exe*）将被下载的URL，第三个参数指定了下载的可执行文件将保存在磁盘上的位置。
    在这种情况下，下载器将下载的可执行文件保存在`%TEMP%`目录下，命名为`temp.exe`：
- en: '![](../images/00172.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00172.jpeg)'
- en: 'After downloading the malware executable into the `%TEMP%` directory, the downloader
    executes it by calling the `ShellExecuteA()` API, as shown in the following screenshot.
    Alternatively, malware may also use the `WinExec()` or `CreateProcess()` API to
    execute the downloaded file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意软件可执行文件下载到`%TEMP%`目录后，下载器通过调用`ShellExecuteA()` API来执行它，如下截图所示。 或者，恶意软件也可能使用`WinExec()`或`CreateProcess()`
    API来执行下载的文件：
- en: '![](../images/00173.jpeg)While debugging the malicious binary, it is better
    to run monitoring tools (such as *Wireshark*) and simulation tools (such as *InetSim*),
    so that you can observe a malware''s actions and capture the traffic it generates.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00173.jpeg)在调试恶意二进制文件时，最好运行监控工具（如*Wireshark*）和仿真工具（如*InetSim*），以便观察恶意软件的行为并捕获其生成的流量。'
- en: 1.2 Dropper
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 植入器
- en: 'A *Dropper* is a program that embeds the additional malware component within
    itself. When executed, the dropper extracts the malware component and drops it
    to disk. A dropper normally embeds the additional binary in the resource section.
    To extract the embedded executable, a dropper uses the `FindResource()`, `LoadResource()`,
    `LockResource()` and `SizeOfResource()` API calls. In the following screenshot,
    the R*esource Hacker tool (covered in* [Chapter 2](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485), *Static
    Analysis)* shows the presence of a PE file in the resource section of a malware
    sample. In this case, the resource type is a DLL:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*下拉程序*是一个将额外的恶意软件组件嵌入自身的程序。当执行时，下拉程序提取恶意软件组件并将其写入磁盘。下拉程序通常会将额外的二进制文件嵌入资源区。为了提取嵌入的可执行文件，下拉程序使用`FindResource()`、`LoadResource()`、`LockResource()`和`SizeOfResource()`
    API调用。在下图中，R*esource Hacker工具（*在第2章中介绍* [第二章](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485)，*静态分析)*显示恶意软件样本的资源部分包含一个PE文件。在这种情况下，资源类型是DLL：'
- en: '![](../images/00174.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00174.jpeg)'
- en: 'Loading the malicious binary in the x64dbg and looking at the references to
    the API calls (*covered in the previous chapter*) displays references to the resource-related
    API calls. This is an indication of malware extracting the content from the resource
    section. At this point, you can set a breakpoint on the address where the `FindResourceA()`
    API is called, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在x64dbg中加载恶意二进制文件，并查看对API调用的引用（*在上一章中介绍*），显示了与资源相关的API调用引用。这表明恶意软件正在从资源部分提取内容。此时，你可以在调用`FindResourceA()`
    API的地址设置断点，如下所示：
- en: '![](../images/00175.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00175.jpeg)'
- en: 'In the following screenshot, after running the program, the execution is paused
    at the `FindResourceA()` API, due to the breakpoint set in the previous step.
    The second and third parameters passed to the `FindResourceA()` API tell you that
    the malware is trying to find the `DLL/101` resource, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，运行程序后，执行在`FindResourceA()` API处暂停，原因是之前步骤中设置了断点。传递给`FindResourceA()` API的第二个和第三个参数告诉你恶意软件正在尝试查找`DLL/101`资源，如下所示：
- en: '![](../images/00176.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00176.jpeg)'
- en: 'After executing `FindResourceA(),` its return value (stored in `EAX`), which
    is the handle to the specified resource''s information block, is passed as the
    second argument to the `LoadResource()` API. The `LoadResource()` retrieves the
    handle to the data associated with the resource. The return value of `LoadResource()`,
    which contains the retrieved handle, is then passed as the argument to the `LockResource()`
    API, which obtains the pointer to the actual resource. In the following screenshot,
    the execution is paused immediately after the call to `LockResource()`. Examining
    the return value (stored in `EAX`) in the dump window shows the PE executable
    content that was retrieved from the resource section:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完`FindResourceA()`后，它的返回值（存储在`EAX`中），即指定资源信息块的句柄，将作为第二个参数传递给`LoadResource()`
    API。`LoadResource()`检索与资源相关的数据句柄。`LoadResource()`的返回值（包含检索到的句柄）然后作为参数传递给`LockResource()`
    API，后者获取指向实际资源的指针。在下图中，执行在调用`LockResource()`后立即暂停。检查转储窗口中存储在`EAX`中的返回值，显示从资源部分检索到的PE可执行内容：
- en: '![](../images/00177.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00177.jpeg)'
- en: 'Once it retrieves the resource, the malware determines the size of the resource
    (PE file) using the `SizofResource()` API. Next, the malware drops a DLL on the
    disk using `CreateFileA`, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到资源，恶意软件通过`SizeOfResource()` API确定资源（PE文件）的大小。接下来，恶意软件使用`CreateFileA`将DLL写入磁盘，如下所示：
- en: '![](../images/00178.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00178.jpeg)'
- en: 'The extracted PE content is then written to the DLL using the `WriteFile()`
    API. In the following screenshot, the first argument `0x5c` is the handle to the
    DLL, the second argument `0x00404060` is the address of the retrieved resource
    (PE File), and the third argument `0x1c00` is the size of the resource, which
    was determined using the call to `SizeOfResource()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`WriteFile()` API将提取的PE内容写入DLL。在下图中，第一个参数`0x5c`是DLL的句柄，第二个参数`0x00404060`是检索到的资源地址（PE文件），第三个参数`0x1c00`是资源的大小，该大小是通过调用`SizeOfResource()`确定的：
- en: '![](../images/00179.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00179.jpeg)'
- en: 1.2.1 Reversing a 64-bit Dropper
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.1 反向分析64位下拉程序
- en: 'The following is an example of a 64-bit malware dropper (called *Hacker’s Door*).
    If you are not yet familiar with debugging 64-bit samples, refer to section *2.7,
    Debugging 64-bit Malware, *in the previous chapter. The malware uses the same
    set of API functions to find and extract the resource; the difference is that
    the first few parameters are placed in the registers and not pushed onto the stack
    (because it is a 64-bit binary). The malware first finds the `BIN/100` resource
    using the `FindResourceW()` API, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个64位恶意软件投放工具（称为 *黑客之门*）的示例。如果你还不熟悉调试64位样本，请参阅上一章的 *2.7 节，调试64位恶意软件*。该恶意软件使用相同的API函数集来查找并提取资源；不同之处在于，前几个参数被放置在寄存器中，而不是压入堆栈（因为它是64位二进制）。恶意软件首先使用
    `FindResourceW()` API 查找 `BIN/100` 资源，如下所示：
- en: '![](../images/00180.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00180.jpeg)'
- en: 'Then, the malware uses `LoadResource()` to retrieve the handle to the data
    associated with the resource, and it then uses `LockResource()` to obtain the
    pointer to the actual resource. In the following screenshot, examining the return
    value `(RAX)` of the `LockResource()` API shows the extracted resource. In this
    case, the 64-bit malware dropper extracts the DLL from its resource section, and
    later it drops the DLL onto the disk:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意软件使用 `LoadResource()` 获取与该资源关联的数据句柄，接着使用 `LockResource()` 获取指向实际资源的指针。在以下截图中，检查
    `LockResource()` API 的返回值 `(RAX)` 显示提取的资源。在这种情况下，64位恶意软件投放工具从其资源部分提取 DLL，并随后将
    DLL 投放到磁盘上：
- en: '![](../images/00181.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00181.jpeg)'
- en: 1.3 Keylogger
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 键盘记录器
- en: A *Keylogger* is a program that is designed to intercept and log keystrokes.
    Attackers use keylogging functionality in their malicious programs to steal confidential
    information (such as usernames, passwords, credit card information, and so on)
    entered via the keyboard. In this section, we will mainly focus on the user-mode
    software keyloggers. An attacker can log keystrokes using various techniques.
    The most common methods of logging keystrokes are using the documented Windows
    API functions: *(a) Checking the key state* (using the `GetAsyncKeyState()` API)
    and *(b) Installing Hooks* (using the `SetWindowHookEX()` API).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*键盘记录器* 是一种旨在拦截和记录按键的程序。攻击者在其恶意程序中使用键盘记录功能，窃取通过键盘输入的机密信息（如用户名、密码、信用卡信息等）。在本节中，我们将主要关注用户模式的软件键盘记录器。攻击者可以使用多种技术来记录按键。记录按键的最常见方法是使用文档化的
    Windows API 函数：*(a) 检查键状态*（使用 `GetAsyncKeyState()` API）和 *(b) 安装钩子*（使用 `SetWindowHookEX()`
    API）。'
- en: 1.3.1 Keylogger Using GetAsyncKeyState()
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.1 使用 GetAsyncKeyState() 的键盘记录器
- en: 'This technique involves querying the state of each key on the keyboard. To
    do that, keyloggers make use of the `GetAsyncKeyState()` API function to determine
    whether the key is *pressed* or *not*. From the return value of `GetAsyncKeyState()`,
    it can be determined whether the key is up or down at the time the function is
    called and whether the key was pressed after a previous call to `GetAsyncKeyState()`.
    The following is the function prototype of the `GetAsyncKeyState()` API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术涉及查询键盘上每个键的状态。为了实现这一点，键盘记录器利用`GetAsyncKeyState()` API 函数来确定某个键是*按下*还是*未按下*。通过
    `GetAsyncKeyState()` 的返回值，可以确定在调用该函数时键是否被按下，以及该键是否在之前调用 `GetAsyncKeyState()` 后被按下。以下是
    `GetAsyncKeyState()` API 的函数原型：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`GetAsynKeyState()` accepts a single integer argument `vKey` which specifies
    one of `256` possible *virtual-key codes*. To determine the state of a single
    key on the keyboard, the `GetAsyncKeyState()` API can be called by passing the
    virtual-key code associated with the desired key as the argument. To determine
    the state of all the keys on the keyboard, a keylogger constantly polls the `GetAsyncKeyState()`
    API (by passing each virtual-key code as an argument) in a loop to determine which
    key is pressed.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsyncKeyState()` 接受一个整数参数 `vKey`，该参数指定一个 `256` 个可能的*虚拟键码*之一。为了确定键盘上单个键的状态，可以通过将与所需键关联的虚拟键码作为参数来调用
    `GetAsyncKeyState()` API。为了确定键盘上所有键的状态，键盘记录器不断循环调用 `GetAsyncKeyState()` API（每次传递一个虚拟键码作为参数），以确定哪个键被按下。'
- en: You can find the symbolic constant names associated with the virtual-key codes
    on the MSDN website ([https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MSDN 网站上找到与虚拟键码相关的符号常量名称（[https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx)）。
- en: 'The following screenshot shows a code snippet from a keylogger. The keylogger
    determines the status of the *Shift *key (if it is up or down) by calling the `GetKeyState()`
    API at address `0x401441`. At address `0x401459`, the keylogger calls `GetAsyncKeyState()`,
    which is part of a loop, and in each iteration of the loop, the virtual-key code
    (which is read from the array of key codes) is passed as the argument to determine
    the status of each key. At address `0x401463`, a `test` operation (the same as
    the `AND` operation) is performed on the return value of `GetAsyncKeyState()`
    to determine if the *most significant bit* is set. If the most significant bit
    is set, it is an indication of the key being pressed. If a particular key is pressed,
    then the keylogger calls `GetKeyState()` at address `0x40146c` to check the status
    of the *Caps Lock* key (to check if it is turned on). Using this technique, malware
    can determine whether the upper case letter, lower case letter, number, or a special
    character was typed on the keyboard:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了键盘记录器的代码片段。键盘记录器通过在地址`0x401441`调用`GetKeyState()` API来确定*Shift*键的状态（是按下还是释放）。在地址`0x401459`，键盘记录器调用`GetAsyncKeyState()`，这是一个循环的一部分，在每次循环中，虚拟键码（从键码数组中读取）作为参数传递，用于确定每个按键的状态。在地址`0x401463`，对`GetAsyncKeyState()`的返回值执行`test`操作（与`AND`操作相同），以确定*最高有效位*是否被设置。如果最高有效位被设置，则表示按键被按下。如果某个特定按键被按下，则键盘记录器会在地址`0x40146c`调用`GetKeyState()`来检查*Caps
    Lock*键的状态（检查它是否被打开）。通过这种技术，恶意软件可以确定在键盘上输入的是大写字母、小写字母、数字还是特殊字符：
- en: '![](../images/00182.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00182.jpeg)'
- en: 'The following screenshot shows the end of the loop. From the code, you can
    tell that the malware iterates through the `0x5c (92)` key codes. In other words,
    it monitors `92` keys. `var_4`, in this case, acts as an *index* into an array
    of key codes to check, and it is incremented at the end of the loop, and as long
    as the value of `var_4` is less than `0x5c(92)`, the loop is continued:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了循环的结束。从代码中可以看出，恶意软件遍历了`0x5c (92)`键码。换句话说，它监控了`92`个按键。在这种情况下，`var_4`充当*键码数组*的*索引*，用于检查键码，并在循环结束时递增，只要`var_4`的值小于`0x5c(92)`，循环将继续：
- en: '![](../images/00183.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00183.jpeg)'
- en: 1.3.2 Keylogger Using SetWindowsHookEx()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.2 使用 SetWindowsHookEx() 的键盘记录器
- en: 'Another common keylogger technique is where it installs a function (called
    *hook procedure*) to monitor keyboard events (such as *key press*). In this method,
    the malicious program registers a function (*hook procedure*) that will be notified
    when a keyboard event is triggered, and that function can log the keystrokes to
    a file or send them over the network. The malicious program uses the `SetWindowsHookEx()`
    API to specify what type of event to monitor (such as the keyboard, mouse, and
    so on) and the hook procedure that should be notified when a specific type of
    event occurs. The *hook procedure* can be contained within a DLL or the current
    module. In the following screenshot, the malware sample registers a hook procedure
    for the low-level keyboard event by calling `SetWindowsHookEx()` with the `WH_KEYBOARD_LL`
    parameter (malware may also use `WH_KEYBOARD`). The second parameter, `offset
    hook_proc`, is the *address of the hook procedure.* When the keyboard event occurs,
    this function will be notified. Examining this function will give an idea of how
    and where the keylogger logs keystrokes. The third parameter is the *handle* to
    the module (such as DLL or the current module) that contains the hook procedure.
    The fourth parameter, `0`, specifies that the hook procedure is to be associated
    with all existing threads in the same desktop:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的键盘记录器技术是它安装一个函数（称为*钩子过程*）来监控键盘事件（例如*按键*）。在这种方法中，恶意程序注册一个函数（*钩子过程*），当键盘事件被触发时，该函数会收到通知，并可以将按键信息记录到文件中或通过网络发送。恶意程序使用`SetWindowsHookEx()`
    API来指定要监控的事件类型（例如键盘、鼠标等）和当特定类型事件发生时应通知的钩子过程。*钩子过程*可以包含在一个DLL或当前模块中。在以下截图中，恶意软件样本通过调用`SetWindowsHookEx()`并使用`WH_KEYBOARD_LL`参数来注册一个用于低级键盘事件的钩子过程（恶意软件也可能使用`WH_KEYBOARD`）。第二个参数`offset
    hook_proc`是*钩子过程的地址*。当键盘事件发生时，这个函数将会收到通知。检查这个函数可以帮助了解键盘记录器是如何以及在哪里记录按键信息的。第三个参数是包含钩子过程的模块（例如DLL或当前模块）的*句柄*。第四个参数`0`指定钩子过程将与同一桌面中的所有现有线程相关联：
- en: '![](../images/00184.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00184.jpeg)'
- en: 1.4 Malware Replication Via Removable Media
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 通过可移动媒体复制恶意软件
- en: Attackers can spread their malicious program by infecting the removable media
    (such as a USB drive). An attacker can take advantage of *Autorun* features (or
    exploit the vulnerability in *Autorun*) to automatically infect other systems,
    when the infected media is plugged in to it. This technique typically involves
    copying files or modifying the existing files stored on the removable media. Once
    malware copies the malicious file to removable media, it can use various tricks
    to make that file look like a legitimate file to trick the user into executing
    it when the USB is plugged in to a different system. The technique of infecting
    removable media allows an attacker to spread their malware on disconnected or
    air-gapped networks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过感染可移动介质（如 USB 驱动器）来传播其恶意程序。攻击者可以利用*自动运行*功能（或利用*自动运行*中的漏洞）来自动感染其他系统，当感染的介质插入到该系统时。这种技术通常涉及将文件复制或修改存储在可移动介质上的现有文件。一旦恶意软件将恶意文件复制到可移动介质，它可以使用各种技巧让该文件看起来像一个合法的文件，从而欺骗用户在将
    USB 插入另一个系统时执行该文件。感染可移动介质的技术使攻击者能够在断开连接或空中隔离的网络中传播其恶意软件。
- en: 'In the following example, malware calls `GetLogicalDriveStringsA()` to obtain
    the details of the valid drives on the computer. After the call to `GetLogicDriveStringsA()`,
    the list of available drives is stored in the output buffer `RootPathName`, which
    is passed as the second argument to `GetLogicalDriveStringsA()`. The following
    screenshot shows three drives, `C:\`, `D:\`, and `E:\`, after the call to `GetLogicDriveStringsA()`,
    where `E:\` is the USB drive. Once it determines the list of drives, it iterates
    through each drive to determine if it is a removable drive. It does that by comparing
    the return value of `GetDriveTypeA()` with `DRIVE_REMOVABLE` (constant value `2`):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，恶意软件调用`GetLogicalDriveStringsA()`以获取计算机上有效驱动器的详细信息。在调用`GetLogicalDriveStringsA()`之后，可用驱动器的列表会存储在输出缓冲区`RootPathName`中，该缓冲区作为第二个参数传递给`GetLogicalDriveStringsA()`。下图显示了三个驱动器，`C:\`、`D:\`和`E:\`，在调用`GetLogicalDriveStringsA()`后，其中`E:\`是
    USB 驱动器。一旦确定了驱动器列表，它就会遍历每个驱动器以确定它是否是可移动驱动器。它通过将`GetDriveTypeA()`的返回值与`DRIVE_REMOVABLE`（常量值`2`）进行比较来判断：
- en: '![](../images/00185.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00185.jpeg)'
- en: 'If a removable media is detected, the malware copies itself (executable) into
    the removable media (USB drive) using the `CopyFileA()` API. To hide the file
    on removable media, it calls the `SetFileAttributesA()` API and passes it a constant
    value `FILE_ATTRIBUTE_HIDDEN`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到可移动介质，恶意软件使用`CopyFileA()` API 将自身（可执行文件）复制到可移动介质（USB 驱动器）中。为了隐藏文件，恶意软件调用`SetFileAttributesA()`
    API，并将常量值`FILE_ATTRIBUTE_HIDDEN`传递给它：
- en: '![](../images/00186.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00186.jpeg)'
- en: After copying the malicious file to removable media, the attacker can wait for
    the user to double-click on the copied file or can take advantage of *Autorun*
    features. Before Windows Vista, malware, apart from copying the executable file,
    also copied the `autorun.inf` file containing Autorun commands into the removable
    media. These Autorun commands allowed the attacker to start programs automatically
    (without user intervention) when the media was inserted into the system. Starting
    with Windows Vista, executing malicious binaries via Autorun is not possible by
    default, so an attacker has to use a different technique (such as modifying the
    registry entries) or exploit a vulnerability which could allow the malicious binary
    to execute automatically.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在将恶意文件复制到可移动介质后，攻击者可以等待用户双击复制的文件，或者利用*自动运行*功能。Windows Vista 之前，恶意软件除了复制可执行文件外，还会将包含自动运行命令的`autorun.inf`文件复制到可移动介质中。这些自动运行命令允许攻击者在介质插入系统时自动启动程序（无需用户干预）。从
    Windows Vista 开始，通过自动运行执行恶意二进制文件默认不可行，因此攻击者必须使用其他技术（例如修改注册表项）或利用某个漏洞，使恶意二进制文件能够自动执行。
- en: 'Some malware programs rely on tricking the user to execute the malicious binary
    instead of taking advantage of Autorun features. *Andromeda* is an example of
    one such malware. To demonstrate the tricks used by Andromeda, consider the following
    screenshot, which shows the content of the 2 GB clean USB drive before plugging
    it into the system infected with Andromeda. The root directory of the USB consists
    of a file called `test.txt` and a folder named `testdir`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件程序依赖于欺骗用户执行恶意二进制文件，而不是利用自动运行功能。*Andromeda* 就是这样一种恶意软件的例子。为了演示 Andromeda
    使用的技巧，请考虑以下截图，展示了将 2 GB 的干净 USB 驱动器插入感染了 Andromeda 的系统之前的内容。USB 根目录包含一个名为`test.txt`的文件和一个名为`testdir`的文件夹：
- en: '![](../images/00187.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00187.jpeg)'
- en: 'Once the clean USB drive is inserted into the *Andromeda-*infected computer,
    it performs the following steps to infect the USB drive:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦干净的USB驱动器插入到*Andromeda-*感染的计算机中，它会执行以下步骤来感染USB驱动器：
- en: It determines the list of all the drives on the system by calling `GetLogicalDriveStrings()`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过调用`GetLogicalDriveStrings()`来确定系统上所有驱动器的列表。
- en: The malware iterates through each drive and determines whether any drive is
    a removable media, using the `GetDriveType()` API.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件通过遍历每个驱动器，使用`GetDriveType()` API判断是否有驱动器是可移动媒体。
- en: 'Once it finds the removable media, it calls the `CreateDirectoryW()` API to
    create a folder (directory) and passes an extended ASCII code `xA0 (á)` as the
    first parameter (directory name). This creates a folder called `E:\á` in the removable
    media, and due to the use of extended ASCII code, the folder is displayed with
    no name. The following screenshot shows the creation of the `E:\á` directory. 
    From now on, I will refer to this directory created by the malware as the *unnamed
    directory (folder)*:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到可移动媒体，恶意软件调用`CreateDirectoryW()` API创建一个文件夹（目录），并将扩展ASCII码`xA0 (á)`作为第一个参数（目录名）。这将在可移动媒体上创建一个名为`E:\á`的文件夹，由于使用了扩展ASCII码，该文件夹显示为没有名称。以下截图展示了`E:\á`目录的创建。从现在起，我将把这个恶意软件创建的目录称为*未命名目录（文件夹）*：
- en: '![](../images/00188.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00188.jpeg)'
- en: 'The following screenshot shows the unnamed folder. This is the folder with
    the extended ascii code of xA0 that was created in the previous step:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了未命名文件夹。这是之前步骤中创建的带有扩展ASCII码xA0的文件夹：
- en: '![](../images/00189.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00189.jpeg)'
- en: 'It then sets the attributes of the *unnamed folder* to hidden and makes it
    a protected operating system folder by calling the `SetFileAttributesW()` API.
    This hides the folder on the removable media:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过调用`SetFileAttributesW()` API将*未命名文件夹*的属性设置为隐藏，并将其设为受保护的操作系统文件夹。这会将文件夹隐藏在可移动媒体上：
- en: '![](../images/00190.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00190.jpeg)'
- en: 'Malware decrypts the executable content from the registry. It then creates
    a file in the unnamed folder. The created file name has the convention `<randomfilename>.1`
    and it writes the PE executable content (malicious DLL) to this file (using the `CreateFile()`
    and `WriteFile()` APIs). As a result, a DLL is created with the name `<randomfilename>.1`
    inside the unnamed folder, as shown here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件从注册表中解密可执行内容。然后它在未命名文件夹中创建一个文件。创建的文件名遵循`<randomfilename>.1`的约定，并将PE可执行内容（恶意DLL）写入该文件（使用`CreateFile()`和`WriteFile()`
    API）。结果，在未命名文件夹中创建了一个名为`<randomfilename>.1`的DLL， 如下所示：
- en: '![](../images/00191.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00191.jpeg)'
- en: 'The malware then creates a `desktop.ini` file inside the *unnamed folder* and
    writes icon information to assign a *custom icon* to the unnamed folder. The content
    of `desktop.ini` is shown here:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件随后在*未命名文件夹*中创建一个`desktop.ini`文件，并写入图标信息，为未命名文件夹分配一个*自定义图标*。`desktop.ini`的内容如下所示：
- en: '![](../images/00192.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00192.jpeg)'
- en: 'The following screenshot displays the icon of the unnamed folder which has
    been changed to the drive icon. Also, note that the *unnamed folder* is now hidden.
    In other words, this folder will only be visible when the *folder options* are
    configured to show *hidden* and *protected* operating system files:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了未命名文件夹的图标，该图标已更改为驱动器图标。此外，请注意*未命名文件夹*现在已被隐藏。换句话说，只有当*文件夹选项*配置为显示*隐藏*和*受保护的*操作系统文件时，这个文件夹才会可见：
- en: '![](../images/00193.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00193.jpeg)'
- en: 'The malware then calls the `MoveFile()` API to move all the files and folders
    (in this case, `test.txt` and `testdir`) from the root directory to the *unnamed
    hidden folder*. After copying the user''s files and folders, the root directory
    of the USB drive looks like the one shown here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件随后调用`MoveFile()` API，将所有文件和文件夹（在此案例中为`test.txt`和`testdir`）从根目录移动到*未命名隐藏文件夹*。在复制用户的文件和文件夹后，USB驱动器的根目录如下所示：
- en: '![](../images/00194.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00194.jpeg)'
- en: 'The malware then creates a shortcut link that points to `rundll32.exe`, and
    the parameter to `rundll32.exe` is the `<randomfile>.1` file (which was the DLL
    dropped in the *unnamed folder* earlier). The following screenshot displays the
    appearance of the shortcut file, and the properties showing the way a malicious
    DLL is loaded via rundll32.exe. In other words, when the shortcut file is double-clicked,
    the malicious DLL gets loaded via rundll32.exe, thereby executing the malicious
    code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件随后创建一个快捷方式链接，指向`rundll32.exe`，而传递给`rundll32.exe`的参数是`<randomfile>.1`文件（即之前在*无名文件夹*中丢失的DLL文件）。以下截图显示了快捷方式文件的外观，并展示了恶意DLL通过rundll32.exe加载的属性。换句话说，当双击该快捷方式文件时，恶意DLL会通过rundll32.exe加载，从而执行恶意代码：
- en: '![](../images/00195.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00195.jpeg)'
- en: Using the aforementioned operations, *Andromeda* plays a psychological trick.
    Now, let's understand what happens when the user plugs in the infected USB drive
    on a clean system. The following screenshot shows the contents of the infected
    USB drive, which is displayed to the normal user (with default folder options).
    Notice that the *unnamed folder* is not visible to the user, and the user's files/folders (in
    our case, `test.txt` and `testdir`) are missing from the root drive. The malware
    is tricking the user into believing that the shortcut file is a *drive:*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述操作，*Andromeda*玩了一个心理把戏。现在，让我们来了解当用户将感染了恶意软件的USB驱动器插入干净的系统时会发生什么。以下截图展示了感染USB驱动器的内容，呈现给正常用户（使用默认的文件夹选项）。请注意，*无名文件夹*对用户不可见，并且用户的文件/文件夹（在我们的例子中是`test.txt`和`testdir`）从根驱动器中消失。恶意软件正欺骗用户，让其相信快捷方式文件是一个*驱动器：*
- en: '![](../images/00196.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00196.jpeg)'
- en: When the user finds all the important files and folders missing from the USB
    root drive, the user is very likely to double-click on the shortcut file (thinking
    that it is a drive) to look for the missing files. As a result of double clicking
    the shortcut, `rundll32.exe` will load the malicious DLL from the *unnamed hidden
    folder* (not visible to the user) and infect the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户发现USB根目录中缺失所有重要文件和文件夹时，用户很可能会双击快捷方式文件（以为它是一个驱动器），以寻找丢失的文件。由于双击该快捷方式，`rundll32.exe`会从*无名隐藏文件夹*（用户不可见）加载恶意DLL，从而感染系统。
- en: 1.5 Malware Command and Control (C2)
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 恶意软件指令与控制（C2）
- en: The malware command and control (also called *C&C* or *C2*) refers to how attackers
    communicate and exhibit control of the infected system. Upon infecting the system,
    most malware communicates with the attacker-controlled server (C2 server) either
    to take commands, download additional components, or to exfiltrate information.
    Adversaries use different techniques and protocols for command and control. Traditionally,
    *Internet Relay Chat (IRC)* used to be the most common C2 channel for many years,
    but because IRC is not commonly used in organizations, it was possible to detect
    such traffic easily. Today, the most common protocol used by the malware for the
    C2 communication is *HTTP/HTTPS*. Using HTTP/HTTPS allows the adversary to bypass
    firewalls/network-based detection systems and to blend in with the legitimate
    web traffic. Malware may sometimes use a protocol such as P2P for C2 communication.
    Some malware have also used DNS tunneling ([https://securelist.com/use-of-dns-tunneling-for-cc-communications/78203/](https://securelist.com/use-of-dns-tunneling-for-cc-communications/78203/))
    for C2 communications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件指令与控制（也称为*C&C*或*C2*）指的是攻击者与被感染系统之间的通信方式，以及如何控制该系统。在感染系统后，大多数恶意软件与攻击者控制的服务器（C2服务器）进行通信，目的是接收指令、下载附加组件或外泄信息。对手使用不同的技术和协议进行指令与控制。传统上，*互联网中继聊天（IRC）*曾是许多年的最常见C2渠道，但由于IRC在组织中不常使用，因此很容易检测到这种流量。如今，恶意软件进行C2通信时最常使用的协议是*HTTP/HTTPS*。使用HTTP/HTTPS使得攻击者能够绕过防火墙/基于网络的检测系统，并与合法的网络流量混合。恶意软件有时还会使用P2P等协议进行C2通信。一些恶意软件也使用DNS隧道（[https://securelist.com/use-of-dns-tunneling-for-cc-communications/78203/](https://securelist.com/use-of-dns-tunneling-for-cc-communications/78203/)）进行C2通信。
- en: 1.5.1 HTTP Command and Control
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5.1 HTTP指令与控制
- en: 'In this section, you will understand how adversaries use HTTP to communicate
    with the malicious program. The following is an example of a malware sample (*WEBC2-DIV*
    backdoor) used by the APT1 group ([https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf](https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf)).
    The malicious binary makes use of the `InternetOpen()`, `InternetOpenUrl()`, and
    `InternetReadFile()` API functions to retrieve a web page from an attacker-controlled
    C2 server. It expects the web page to contain special HTML tags; the backdoor
    then decrypts the data within the tags and interprets it as a command. The following
    steps describe the manner in which the *WEB2-DIV* backdoor communicates with the
    C2 to receive commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解对手如何使用HTTP与恶意程序通信。以下是APT1组使用的恶意软件样本（*WEBC2-DIV*后门）的示例（[https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf](https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf)）。该恶意二进制文件利用`InternetOpen()`、`InternetOpenUrl()`和`InternetReadFile()`
    API函数从攻击者控制的C2服务器获取网页。它期望网页包含特殊的HTML标签；然后，后门解密标签中的数据，并将其解释为命令。以下步骤描述了*WEB2-DIV*后门与C2通信以接收命令的方式：
- en: 'First, the malware calls the `InternetOpenA()` API to initialize the connection
    to the internet. The first argument specifies the *User-Agent* the malware will
    use for the HTTP communication. This backdoor generates the User-Agent by concatenating
    the host-name of the infected systems (which it gets by calling the `GetComputerName()`
    API) with a hardcoded string. Whenever you come across a hardcoded *User-Agent*
    string used in the binary, it can make an excellent network indicator:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，恶意软件调用`InternetOpenA()` API初始化互联网连接。第一个参数指定恶意软件将用于HTTP通信的*User-Agent*。该后门通过将感染系统的主机名（它通过调用`GetComputerName()`
    API获得）与硬编码字符串连接来生成User-Agent。每当你遇到二进制文件中使用的硬编码*User-Agent*字符串时，它可以作为一个很好的网络指示器：
- en: '![](../images/00197.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00197.jpeg)'
- en: 'It then calls `InternetOpenUrlA()` to connect to a URL. You can determine the
    name of URL it connects to by examining the second argument as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`InternetOpenUrlA()`连接到一个URL。你可以通过检查第二个参数来确定它连接到的URL名称，如下所示：
- en: '![](../images/00198.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00198.jpeg)'
- en: 'The following screenshot shows the network traffic generated after calling `InternetOpenUrlA()`.
    At this stage, the malware communicates with the C2 server to read the HTML content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了调用`InternetOpenUrlA()`后生成的网络流量。在此阶段，恶意软件与C2服务器通信以读取HTML内容：
- en: '![](../images/00199.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00199.jpeg)'
- en: 'It then retrieves the content of the web page using the `InternetReadFile()`
    API call. The second argument to this function specifies the pointer to the buffer
    that receives the data. The following screenshot shows the HTML content retrieved
    after calling `InternetReadFile()`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它使用`InternetReadFile()` API调用获取网页内容。该函数的第二个参数指定接收数据的缓冲区指针。以下截图显示了调用`InternetReadFile()`后检索到的HTML内容：
- en: '![](../images/00200.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00200.jpeg)'
- en: 'From the retrieved HTML content, the backdoor looks for specific content within
    the *<div>* HTML tag . The code performing the check for the content within a
    div tag is shown in the following screenshot. If the required content is not present,
    the malware does nothing and keeps periodically checking for the content:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从检索到的HTML内容中，后门会查找特定内容，该内容位于*<div>* HTML标签中。检查div标签内内容的代码如下所示。如果未找到所需内容，恶意软件不会做任何操作，只会定期检查内容：
- en: '![](../images/00201.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00201.jpeg)'
- en: 'To be specific, the malware expects the content to be enclosed within the `div`
    tag in a specific format such as the one shown in the following code. If the following
    format is found in the retrieved HTML content, its extracts the encrypted string
    `(KxAikuzeG:F6PXR3vFqffP:H)`, which is enclosed between `<div safe: and balance></div>`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '具体来说，恶意软件期望内容被按特定格式包裹在`div`标签中，如下面代码所示。如果在检索到的HTML内容中找到以下格式，它会提取加密字符串`(KxAikuzeG:F6PXR3vFqffP:H)`，该字符串被包裹在`<div
    safe: 和 balance></div>`之间：'
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The extracted encrypted string is then passed as the argument to a *decryption
    function*, which decrypts the string using a custom encryption algorithm. You
    will learn more about malware encryption techniques in [Chapter 9](part0271.html#82E8E0-ac10ba3f98854c44bac1c2c5641ca485),
    *Malware Obfuscation Techniques*. The following screenshot shows the decrypted
    string after calling `decryption function`. After decrypting the string, the backdoor
    checks if the first character of the decrypted string is `J`.  If this condition
    is satisfied, then the malware calls the `sleep()` API to sleep for a specific
    period. In short, the first character of the decrypted string acts as a command
    code, which tells the backdoor to perform the sleep operation:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取的加密字符串随后作为参数传递给*解密函数*，该函数使用自定义加密算法解密字符串。你将在[第9章](part0271.html#82E8E0-ac10ba3f98854c44bac1c2c5641ca485)中了解更多关于恶意软件加密技术的内容，*恶意软件混淆技术*。下图显示了调用`解密函数`后的解密字符串。解密字符串后，后门会检查解密字符串的第一个字符是否为`J`。如果满足此条件，恶意软件会调用`sleep()`API，使程序进入指定时间的休眠状态。简而言之，解密字符串的第一个字符充当命令代码，指示后门执行休眠操作：
- en: '![](../images/00202.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00202.jpeg)'
- en: 'If the first character of the decrypted string is `D`, then it checks if the
    second character is `o`, as shown here. If this condition is satisfied, then it
    extracts the URL starting from the third character and downloads an executable
    from that URL using `UrlDownloadToFile()`. It then executes the downloaded file
    using the `CreateProcess()` API. In this case, the first two characters, `Do`,
    act as the command code that tells the backdoor to download and execute the file:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果解密字符串的第一个字符是`D`，则会检查第二个字符是否为`o`，如图所示。如果满足此条件，则从第三个字符开始提取URL，并使用`UrlDownloadToFile()`从该URL下载可执行文件。然后，它通过`CreateProcess()`API执行下载的文件。在这种情况下，前两个字符`Do`充当命令代码，指示后门下载并执行文件：
- en: '![](../images/00203.jpeg)For a full analysis of the *APT1 WEBC2-DIV* backdoor,
    check the author''s Cysinfo meet presentation and video demo ([https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/](https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00203.jpeg)要查看*APT1 WEBC2-DIV*后门的完整分析，请查看作者的Cysinfo会议演讲和视频演示（[https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/](https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/)）。'
- en: 'Malware may also use APIs such as `InternetOpen()`, `InternetConnect()`, `HttpOpenRequest()`, `HttpSendRequest()`,
    and `InternetReadFile()` to communicate over HTTP. You can find analysis and reverse
    engineering of one such malware here: [https://cysinfo.com/sx-2nd-meetup-reversing-and-decrypting-the-communications-of-apt-malware/](https://cysinfo.com/sx-2nd-meetup-reversing-and-decrypting-the-communications-of-apt-malware/).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可能使用诸如`InternetOpen()`、`InternetConnect()`、`HttpOpenRequest()`、`HttpSendRequest()`和`InternetReadFile()`等API通过HTTP进行通信。你可以在这里找到对某种恶意软件的分析与逆向工程：[https://cysinfo.com/sx-2nd-meetup-reversing-and-decrypting-the-communications-of-apt-malware/](https://cysinfo.com/sx-2nd-meetup-reversing-and-decrypting-the-communications-of-apt-malware/)。
- en: In addition to using HTTP/HTTPS, adversaries may abuse *social networks* ([https://threatpost.com/attackers-moving-social-networks-command-and-control-071910/74225/](https://threatpost.com/attackers-moving-social-networks-command-and-control-071910/74225/)),
    *legitimate sites* such as *Pastebin* ([https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/](https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/)),
    and *cloud storage services* such as *Dropbox* ([https://www.fireeye.com/blog/threat-research/2015/11/china-based-threat.html](https://www.fireeye.com/blog/threat-research/2015/11/china-based-threat.html))
    for their malware command and control. These techniques make it difficult to monitor
    and detect malicious communications, and they allow an attacker to bypass network-based
    security controls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用HTTP/HTTPS，攻击者还可能滥用*社交网络*（[https://threatpost.com/attackers-moving-social-networks-command-and-control-071910/74225/](https://threatpost.com/attackers-moving-social-networks-command-and-control-071910/74225/)）、*合法网站*如*Pastebin*（[https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/](https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/)）、以及*云存储服务*如*Dropbox*（[https://www.fireeye.com/blog/threat-research/2015/11/china-based-threat.html](https://www.fireeye.com/blog/threat-research/2015/11/china-based-threat.html)）来进行恶意软件的命令与控制。这些技术使得监视和检测恶意通信变得困难，并允许攻击者绕过基于网络的安全控制。
- en: 1.5.2 Custom Command and Control
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5.2 自定义命令与控制
- en: 'Adversaries may use a custom protocol or communicate over the non-standard
    port to hide their command and control traffic. The following is an example of
    such a malware sample (*HEARTBEAT RAT*) whose details are documented in the whitepaper
    ([http://www.trendmicro.it/media/wp/the-heartbeat-apt-campaign-whitepaper-en.pdf](http://www.trendmicro.it/media/wp/the-heartbeat-apt-campaign-whitepaper-en.pdf)).
    This malware makes an encrypted communication on port `80` using a custom protocol
    (not HTTP) and retrieves the command from the C2 server. It makes use of the `Socket()`, `Connect()`, `Send()`,
    and `Recv()` API calls to communicate and receive commands from the C2:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可能会使用自定义协议或通过非标准端口来隐藏他们的命令和控制流量。以下是一个恶意软件样本（*HEARTBEAT RAT*）的示例，其详细信息在白皮书中有所记录（[http://www.trendmicro.it/media/wp/the-heartbeat-apt-campaign-whitepaper-en.pdf](http://www.trendmicro.it/media/wp/the-heartbeat-apt-campaign-whitepaper-en.pdf)）。该恶意软件使用自定义协议（非
    HTTP）在端口`80`上进行加密通信，并从 C2 服务器检索命令。它利用`Socket()`、`Connect()`、`Send()`和`Recv()`
    API 调用与 C2 进行通信并接收命令：
- en: 'First, the malware calls the `WSAStartup()` API to initialize the Windows socket
    system. It then calls the `Socket()` API to create a socket, which is shown in
    the following screenshot. The socket API accepts three arguments. The first argument, `AF_INET`,
    specifies the address family, which is `IPV4`. The second argument is the socket
    type, `(SOCK_STREAM)`, and the third argument, `IPPROTO_TCP`, specifies the protocol
    being used (TCP, in this case):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，恶意软件调用`WSAStartup()` API来初始化 Windows 套接字系统。然后，它调用`Socket()` API来创建一个套接字，如下图所示。套接字
    API 接受三个参数。第一个参数`AF_INET`指定地址族，即`IPV4`。第二个参数是套接字类型`(SOCK_STREAM)`，第三个参数`IPPROTO_TCP`指定正在使用的协议（此处为
    TCP）：
- en: '![](../images/00204.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00204.jpeg)'
- en: 'Before establishing the connection to the socket, the malware resolves the
    address of the C2 domain name using the `GetHostByName()` API. This makes sense,
    because the *remote address* and *port* need to be supplied to the `Connect()`
    API to establish the connection. The return value (`EAX`) of `GetHostByName()` is
    a pointer to a structure named `hostent`, which contains the resolved IP addresses:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在建立与套接字的连接之前，恶意软件使用`GetHostByName()` API 解析 C2 域名的地址。这是有意义的，因为*远程地址*和*端口*需要提供给`Connect()`
    API，以便建立连接。`GetHostByName()`的返回值（`EAX`）是一个指向名为`hostent`的结构体的指针，该结构体包含了解析后的 IP
    地址：
- en: '![](../images/00205.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00205.jpeg)'
- en: 'It reads the resolved IP address from the `hostent` structure and passes it
    to the `inet_ntoa()` API, which converts the IP address into an ASCII string such
    as `192.168.1.100`. It then calls `inet_addr()`, which converts an IP address
    string such as `192.168.1.100` so that it can be used by the `Connect()` API.
    The `Connect()` API is then called to establish the connection with the socket:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从`hostent`结构中读取解析后的 IP 地址，并将其传递给`inet_ntoa()` API，该 API 将 IP 地址转换为 ASCII 字符串，如`192.168.1.100`。然后调用`inet_addr()`，该函数将类似`192.168.1.100`的
    IP 地址字符串转换为可以供`Connect()` API 使用的格式。然后调用`Connect()` API 来建立与套接字的连接：
- en: '![](../images/00206.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00206.jpeg)'
- en: 'The malware then collects the *system information*, encrypts it using the `XOR`
    encryption algorithm (encryption techniques will be covered in *Chapter 9*), and
    sends it to C2 using the `Send()` API call. The second argument to the `Send()`
    API shows the encrypted content that will be sent to the C2 server:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件随后收集*系统信息*，使用`XOR`加密算法对其进行加密（加密技术将在*第9章*中介绍），并使用`Send()` API 调用将其发送到 C2
    服务器。`Send()` API 的第二个参数显示了将发送到 C2 服务器的加密内容：
- en: '![](../images/00207.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00207.jpeg)'
- en: 'The following screenshot shows the encrypted network traffic captured after
    calling the `Send()` API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在调用`Send()` API 后捕获的加密网络流量：
- en: '![](../images/00208.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00208.jpeg)'
- en: 'The malware then calls `CreateThread()` to start a new thread. The third parameter
    to `CreateThread` specifies the start address (start function) of the thread,
    so after the call to `CreateThread()`, the execution begins at the start address.
    In this case, the start address of the thread is a function that is responsible
    for reading the content from the C2:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，恶意软件调用`CreateThread()`来启动一个新线程。`CreateThread`的第三个参数指定线程的起始地址（起始函数），因此在调用`CreateThread()`后，执行将从起始地址开始。在这种情况下，线程的起始地址是一个负责从
    C2 读取内容的函数：
- en: '![](../images/00209.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00209.jpeg)'
- en: 'The content from the C2 is retrieved using the `Recv()` API function. The second argument
    to `Recv()` is a buffer where the retrieved content is stored. The retrieved content
    is then decrypted, and, depending on the command received from the C2, appropriate
    actions are performed by the malware. To understand all the functionalities of
    this malware and how it processes the received data, refer to the author''s presentation
    and the video demo ([https://cysinfo.com/session-11-part-2-dissecting-the-heartbeat-apt-rat-features/](https://cysinfo.com/session-11-part-2-dissecting-the-heartbeat-apt-rat-features/)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 内容来自C2，使用`Recv()` API函数进行检索。`Recv()`的第二个参数是存储检索内容的缓冲区。然后，检索到的内容会被解密，接着，根据从C2接收到的命令，恶意软件执行相应的操作。要了解此恶意软件的所有功能以及它如何处理接收到的数据，请参阅作者的演示文稿和视频演示（[https://cysinfo.com/session-11-part-2-dissecting-the-heartbeat-apt-rat-features/](https://cysinfo.com/session-11-part-2-dissecting-the-heartbeat-apt-rat-features/)）。
- en: '![](../images/00210.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00210.jpeg)'
- en: 1.6 PowerShell-Based Execution
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 基于PowerShell的执行
- en: To evade detection, malware authors often leverage tools that already exist
    on the system (such as *PowerShell*) which allow them to hide their malicious
    activities. PowerShell is a management engine based on the .NET framework. This
    engine exposes a series of commands called *cmdlets*. The engine is hosted in
    an application and Windows operating system, which by default ships a *command-line
    interface (interactive console)* and a *GUI PowerShell ISE (Integrated Scripted
    Environment).*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避开检测，恶意软件作者通常利用系统中已存在的工具（如*PowerShell*），这些工具可以帮助他们隐藏恶意活动。PowerShell是基于.NET框架的管理引擎。该引擎暴露了一系列命令，称为*cmdlets*。该引擎托管在应用程序和Windows操作系统中，默认情况下提供*命令行界面（交互式控制台）*和*GUI
    PowerShell ISE（集成脚本环境）*。
- en: 'PowerShell is not a programming language, but it allows you to create useful
    scripts containing multiple commands. You can also open *PowerShell prompt* and
    execute individual commands. PowerShell is typically used by the System Administrators
    for a legitimate purpose. However, there is an increase in the use of PowerShell
    by the attackers to execute their malicious code. The major reason why attackers
    use PowerShell is that it provides access to all major operating system functions
    and it leaves very few traces, thereby making detection more difficult. The following
    outlines how attackers leverage PowerShell in malware attacks:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell不是一种编程语言，但它允许你创建包含多个命令的有用脚本。你还可以打开*PowerShell提示符*并执行单个命令。PowerShell通常由系统管理员用于合法目的。然而，攻击者使用PowerShell执行恶意代码的情况在增加。攻击者使用PowerShell的主要原因是它可以访问所有主要的操作系统功能，并且几乎不留下痕迹，从而使检测更加困难。以下是攻击者如何在恶意软件攻击中利用PowerShell的概述：
- en: In most cases, Powershell is used post-exploitation to download additional components.
    It is mostly delivered via email attachments containing files (such as `.lnk`,
    `.wsf`, JavaScript, VBScript, or office documents containing malicious macros)
    which are capable of executing PowerShell scripts directly or indirectly. Once
    the attacker tricks the user into opening the malicious attachment, then the malicious
    code invokes PowerShell directly or indirectly to download additional components.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，PowerShell在利用后用于下载其他组件。它通常通过电子邮件附件发送，附件中包含能够直接或间接执行PowerShell脚本的文件（如`.lnk`、`.wsf`、JavaScript、VBScript或包含恶意宏的办公文档）。一旦攻击者诱使用户打开恶意附件，恶意代码便直接或间接调用PowerShell来下载其他组件。
- en: It is used in the lateral movement, where the attacker executes code on a remote
    computer to spread inside the network.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还用于横向移动，攻击者在远程计算机上执行代码，以便在网络内传播。
- en: Attackers use PowerShell to dynamically load and execute code directly from
    memory without accessing the file system. This allows the attacker to be stealthy
    and makes forensic analysis much harder.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者使用PowerShell动态加载并执行代码，直接从内存中执行，而不访问文件系统。这使得攻击者能够保持隐秘，并使取证分析变得更加困难。
- en: Attackers use PowerShell to execute their obfuscated code; this makes it hard
    to detect it with traditional security tools.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者使用PowerShell执行其混淆的代码，这使得传统安全工具很难检测到它。
- en: If you are new to PowerShell, you can find many tutorials to get started with
    PowerShell at the following link: [https://social.technet.microsoft.com/wiki/contents/articles/4307.powershell-for-beginners.aspx](https://social.technet.microsoft.com/wiki/contents/articles/4307.powershell-for-beginners.aspx)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 PowerShell 新手，你可以通过以下链接找到许多入门教程，帮助你开始使用 PowerShell：[https://social.technet.microsoft.com/wiki/contents/articles/4307.powershell-for-beginners.aspx](https://social.technet.microsoft.com/wiki/contents/articles/4307.powershell-for-beginners.aspx)
- en: 1.6.1 PowerShell Command Basics
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6.1 PowerShell 命令基础
- en: 'Before delving into the details of how malware uses PowerShell, let''s understand
    how to execute PowerShell commands. You can execute a PowerShell command using
    the interactive PowerShell console; you can bring it up using the Windows program
    search feature or by typing `powershell.exe` in the command prompt. Once in the
    interactive PowerShell, you can type the command to execute it. In the following
    example, the `Write-Host` cmdlet writes the message to the console. A *cmdlet*
    (such as `Write-Host`) is a compiled command written in a .NET Framework language
    which is meant to be small and serves a single purpose. The *cmdlet* follows a
    standard *Verb-Noun* naming convention:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解恶意软件如何利用 PowerShell 之前，先了解如何执行 PowerShell 命令。你可以使用交互式 PowerShell 控制台执行
    PowerShell 命令；可以通过 Windows 程序搜索功能启动它，或者在命令提示符下输入 `powershell.exe`。进入交互式 PowerShell
    后，你可以输入命令并执行它。在以下示例中，`Write-Host` cmdlet 将消息写入控制台。*cmdlet*（如 `Write-Host`）是用 .NET
    Framework 语言编写的已编译命令，旨在小巧并完成单一功能。*cmdlet* 遵循标准的 *动词-名词* 命名约定：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A cmdlet can accept parameters. The parameter starts with a dash immediately
    followed by a parameter name and a space followed by the parameter value. In the
    following example, the `Get-Process` cmdlet is used to display the information
    about the explorer process. The `Get-Process` cmdlet accepts a parameter whose
    name is `Name`, and the value is `explorer`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: cmdlet 可以接受参数。参数以破折号开头，后跟参数名称和一个空格，再后跟参数值。在以下示例中，`Get-Process` cmdlet 用于显示关于
    explorer 进程的信息。`Get-Process` cmdlet 接受一个名为 `Name` 的参数，值为 `explorer`：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can also use parameter shortcuts to reduce some typing;
    the above command can also be written as:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用参数快捷方式来减少输入；上面的命令也可以写成：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get more information about cmdlet (such as details about the syntax and
    the parameters), you can use the `Get-Help` cmdlet or the `help` command. If you
    wish to get the most up-to-date information, you can get help online, using the
    second command shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关 cmdlet（如语法和参数的详细信息）的更多信息，你可以使用 `Get-Help` cmdlet 或 `help` 命令。如果你希望获取最新的信息，可以通过以下命令在线获取帮助：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In PowerShell, variables can be used to store values. In the following example, `hello`
    is a variable that is prefixed with a `$` symbol:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，变量可以用来存储值。在以下示例中，`hello` 是一个以 `$` 符号为前缀的变量：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Variables can also hold the result of PowerShell commands, and the variable
    can then be used in the place of a command, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以存储 PowerShell 命令的结果，然后可以在命令的地方使用该变量，如下所示：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 1.6.2 PowerShell Scripts And Execution Policy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6.2 PowerShell 脚本与执行策略
- en: 'PowerShell''s capabilities allow you to create scripts by combining multiple
    commands. The PowerShell script has an extension of `.ps1`*.* By default, you
    will not be allowed to execute a PowerShell script. This is due to the default
    *execution policy* setting in PowerShell that prevents the execution of PowerShell
    scripts. The execution policy determines the conditions under which PowerShell
    scripts are executed. By default, the execution policy is set to *"Restricted",*
    which means that a PowerShell script (.ps1) cannot be executed, but you can still
    execute individual commands. For example, when the `Write-Host` `"Hello World"`
    command is saved as a PowerShell script *(hello.ps1)* and executed, you get the
    following message stating that running scripts is disabled. This is due to the
    execution policy setting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的功能使你能够通过组合多个命令来创建脚本。PowerShell 脚本的扩展名为 `.ps1`*.* 默认情况下，你将无法执行 PowerShell
    脚本。这是因为 PowerShell 中的默认 *执行策略* 设置阻止了 PowerShell 脚本的执行。执行策略决定了在何种条件下可以执行 PowerShell
    脚本。默认情况下，执行策略设置为 *"Restricted"*，这意味着无法执行 PowerShell 脚本（.ps1 文件），但仍然可以执行单个命令。例如，当
    `Write-Host` `"Hello World"` 命令保存为 PowerShell 脚本 *(hello.ps1)* 并执行时，你会看到以下消息，说明脚本执行被禁用。这是由于执行策略设置的原因：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The execution policy is not a security feature; it''s just a control to prevent
    users from accidentally executing scripts. To display the current execution policy
    setting, you can use the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略不是一个安全功能；它只是一个控制措施，用来防止用户不小心执行脚本。要显示当前的执行策略设置，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can change the execution policy setting using the `Set-ExecutionPolicy`
    command (provided you are executing the command as Administrator). In the following
    example, the execution policy is set to `Bypass`, which allows the script to run
    without any restriction. This setting can be useful for your analysis if you come
    across a malicious PowerShell script and if you would like to execute it to determine
    its behavior:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Set-ExecutionPolicy` 命令更改执行策略设置（前提是你以管理员身份执行命令）。在以下示例中，执行策略被设置为 `Bypass`，这允许脚本在没有任何限制的情况下运行。如果你遇到恶意
    PowerShell 脚本，并且希望执行它以确定其行为，这个设置可能对你的分析很有帮助：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 1.6.2 Analyzing PowerShell Commands/Scripts
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6.2 分析 PowerShell 命令/脚本
- en: Powershell commands are easy to understand compared to assembly code, but in
    some situations (such as when a PowerShell command is obfuscated), you may want
    to run the PowerShell commands to understand how it works. The easiest method
    to test a single command is to execute it in the interactive PowerShell. If you
    wish to execute a PowerShell script (`.ps1`) containing multiple commands, first
    change the execution policy setting to either *Bypass* or *Unrestricted* (as mentioned
    previously) and then execute the script using the PowerShell console. Remember
    to execute malicious script in an isolated environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于汇编代码，PowerShell 命令比较容易理解，但在某些情况下（比如 PowerShell 命令被混淆时），你可能想要运行这些 PowerShell
    命令以理解它是如何工作的。测试单个命令的最简单方法是通过交互式 PowerShell 执行它。如果你希望执行一个包含多个命令的 PowerShell 脚本（`.ps1`），首先将执行策略设置更改为
    *Bypass* 或 *Unrestricted*（如前所述），然后通过 PowerShell 控制台执行脚本。记住，要在隔离的环境中执行恶意脚本。
- en: 'Running the script (`.ps1`) in the PowerShell prompt will run all the commands
    at once. If you wish to have control over the execution, then you can debug the
    PowerShell script using *PowerShell ISE (Integrated Scripting Environment)*. You
    can bring up PowerShell ISE by using the program search feature and then load
    the PowerShell script into PowerShell ISE or copy-paste a command and use its
    debugging features (such as *Step Into*, *Step Over*, *Step Out,* and B*reakpoints*)
    which can be accessed via the Debug menu. Before debugging, make sure to set the
    execution policy to *Bypass*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 提示符下运行脚本（`.ps1`）会一次性执行所有命令。如果你希望对执行过程进行控制，那么可以使用 *PowerShell ISE（集成脚本环境）*
    调试 PowerShell 脚本。你可以通过程序搜索功能打开 PowerShell ISE，然后将 PowerShell 脚本加载到 PowerShell
    ISE 中，或复制粘贴一个命令并使用其调试功能（如 *逐步进入*、*逐步跳过*、*逐步跳出* 和 *断点*），这些功能可以通过调试菜单访问。在调试之前，确保将执行策略设置为
    *Bypass*：
- en: '![](../images/00211.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00211.jpeg)'
- en: 1.6.3 How Attackers Use PowerShell
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6.3 攻击者如何使用 PowerShell
- en: 'With an understanding of basic PowerShell and what tools to use for analysis,
    let''s now look at how attackers use PowerShell. Due to the restriction in executing
    the PowerShell scripts (`.ps1`) via the PowerShell console or by double-clicking
    (which will open it in notepad rather than executing the script), it is unlikely
    to see adversaries sending PowerShell scripts to their victims directly. The attacker
    must first trick the user into executing the malicious code; this is mostly done
    by sending email attachments containing files such as `.lnk`*,* `.wsf`*, javascript,*
    or *malicious macro documents*. Once the user is tricked into opening the attached
    files, the malicious code can then invoke PowerShell directly (`powershell.exe`),
    or indirectly via `cmd.exe`, `Wscript`, `Cscript`, and so on. After the PowerShell
    is invoked, various methods can be used to bypass the execution policy. For example,
    to bypass an execution restriction policy, an attacker can use the malicious code
    to invoke `powershell.exe` and pass the `Bypass` execution policy flag, as shown
    in the following screenshot. This technique will work even if the user is not
    an Administrator, and it overrides the default execution restriction policy and
    executes the script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解基础的 PowerShell 知识以及分析所需的工具，我们现在来看攻击者如何使用 PowerShell。由于在 PowerShell 控制台或双击运行
    PowerShell 脚本（`.ps1`）时受到限制（会在记事本中打开，而不是执行脚本），因此攻击者不太可能直接将 PowerShell 脚本发送给受害者。攻击者必须首先欺骗用户执行恶意代码，这通常通过发送包含
    `.lnk`、`.wsf`、JavaScript 或恶意宏文档等文件的电子邮件附件来实现。一旦用户被诱骗打开这些附件文件，恶意代码便可以直接调用 PowerShell（`powershell.exe`），或者通过
    `cmd.exe`、`Wscript`、`Cscript` 等间接调用。一旦调用了 PowerShell，可以使用多种方法绕过执行策略。例如，攻击者可以使用恶意代码调用
    `powershell.exe` 并传递 `Bypass` 执行策略标志，如下图所示。这种技术即使在用户不是管理员的情况下也能工作，它会覆盖默认的执行限制策略并执行脚本：
- en: '![](../images/00212.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00212.jpeg)'
- en: 'In the same manner, attackers use various PowerShell command-line arguments
    to bypass the execution policy. The following table outlines the most common PowerShell
    arguments used to evade detection and bypass local restrictions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，攻击者还使用各种 PowerShell 命令行参数绕过执行策略。下表列出了最常用的 PowerShell 参数，用于规避检测和绕过本地限制：
- en: '| **Command-Line Argument** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **命令行参数** | **描述** |'
- en: '| ExecutionPolicy Bypass (`-Exec bypass`) | Ignores the execution policy restriction
    and runs script without warning |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 执行策略绕过 (`-Exec bypass`) | 忽略执行策略限制并在没有警告的情况下运行脚本 |'
- en: '| WindowStyle Hidden (`-W Hidden`) | Hides the PowerShell window |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 窗口样式隐藏 (`-W Hidden`) | 隐藏 PowerShell 窗口 |'
- en: '| NoProfile (`-NoP`) | Ignores the commands in the profile file |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 无配置文件 (`-NoP`) | 忽略配置文件中的命令 |'
- en: '| EncodedCommand (`-Enc`) | Executes command encoded in Base64 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 编码命令 (`-Enc`) | 执行编码为 Base64 的命令 |'
- en: '| NonInteractive (`-NonI`) | Does not present an interactive prompt to the
    user |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 非交互模式 (`-NonI`) | 不向用户显示交互提示 |'
- en: '| Command (`-C`) | Executes a single command |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 命令 (`-C`) | 执行单个命令 |'
- en: '| File (`-F`) | Executes commands from a given file |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 文件 (`-F`) | 从指定文件执行命令 |'
- en: 'Apart from using PowerShell command-line arguments, attackers also make use
    of cmdlets or .NET APIs in the PowerShell scripts. The following are the most
    frequently used commands and functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 PowerShell 命令行参数外，攻击者还会在 PowerShell 脚本中利用 cmdlet 或 .NET API。以下是最常用的命令和函数：
- en: '`Invoke-Expression (IEX)`: This cmdlet evaluates or executes a specified string
    as a command'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-Expression (IEX)`: 该 cmdlet 评估或执行指定的字符串作为命令'
- en: '`Invoke-Command`: This cmdlet can execute a PowerShell command on either a
    local or a remote computer'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-Command`: 该 cmdlet 可以在本地或远程计算机上执行 PowerShell 命令'
- en: '`Start-Process`: This cmdlet starts a process from a given file path'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start-Process`: 该 cmdlet 从给定的文件路径启动一个进程'
- en: '`DownloadString`: This method from `System.Net.WebClient` (WebClient Class)
    downloads the resource from an URL as a string'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadString`: 该方法来自 `System.Net.WebClient`（WebClient 类），用于将资源从 URL 下载为字符串'
- en: '`DownloadFile()`: This method from `System.Net.WebClient` (WebClient Class)
    downloads the resource from an URL to a local file'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadFile()`: 该方法来自`System.Net.WebClient`（WebClient类），用于将资源从URL下载到本地文件'
- en: The following is an example of a PowerShell downloader used in an attack mentioned
    in the author's blog post ([https://cysinfo.com/cyber-attack-targeting-indian-navys-submarine-warship-manufacturer/](https://cysinfo.com/cyber-attack-targeting-indian-navys-submarine-warship-manufacturer/)).
    In this case, the PowerShell command was invoked via `cmd.exe` by the malicious
    macro contained within the Microsoft Excel sheet, which was sent in an email attachment
    to the victims.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作者博客中提到的一次攻击中使用的 PowerShell 下载器的示例（[https://cysinfo.com/cyber-attack-targeting-indian-navys-submarine-warship-manufacturer/](https://cysinfo.com/cyber-attack-targeting-indian-navys-submarine-warship-manufacturer/)）。在这个例子中，PowerShell
    命令通过受害者收到的电子邮件附件中的恶意宏，使用 `cmd.exe` 被触发，微软 Excel 表格内嵌的宏执行了该命令。
- en: 'The PowerShell drops the downloaded executable in the `%TEMP%` directory as
    `doc6.exe`. It then adds a registry entry for the dropped executable and invokes
    `eventvwr.exe`, which is an interesting registry hijack technique which allows `doc6.exe`
    to be executed by `eventvwr.exe` with high integrity level. This technique also
    silently bypasses the *UAC (user account control)*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 将下载的可执行文件投放到 `%TEMP%` 目录中，并命名为 `doc6.exe`。接着，它会为该可执行文件添加一个注册表条目，并调用
    `eventvwr.exe`，这是一种有趣的注册表劫持技术，允许 `doc6.exe` 被 `eventvwr.exe` 以高权限级别执行。该技术还悄悄绕过了
    *UAC（用户帐户控制）*：
- en: '![](../images/00213.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00213.jpeg)'
- en: 'The following is a PowerShell command from a targeted attack ([https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/](https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/)).
    In this case, the PowerShell is invoked by the malicious macro and instead of
    downloading an executable directly, the base64 content from a Pastebin link was
    downloaded using the `DownloadString` method. After downloading the encoded content,
    it is decoded and dropped onto the disk:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一次定向攻击中的 PowerShell 命令示例（[https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/](https://cysinfo.com/uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/)）。在这个例子中，PowerShell
    是通过恶意宏触发的，且不是直接下载一个可执行文件，而是通过 `DownloadString` 方法下载了来自 Pastebin 链接的 base64 编码内容。下载编码内容后，它会被解码并写入磁盘：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the following example, before invoking PowerShell, a malware dropper first
    writes a DLL with a *.bmp* extension (`heiqh.bmp`) in the `%Temp%` directory and
    then launches `rundll32.exe` via PowerShell to load the DLL and executes the DLL''s
    export function `dlgProc`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，在调用 PowerShell 之前，恶意软件投放器首先在 `%Temp%` 目录中写入一个扩展名为 *.bmp* 的 DLL 文件（`heiqh.bmp`），然后通过
    PowerShell 启动 `rundll32.exe` 来加载该 DLL，并执行 DLL 导出的函数 `dlgProc`：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For more information on different PowerShell techniques used in malware attacks,
    refer to the Whitepaper: *The Increased use of PowerShell in attacks:* [https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/increased-use-of-powershell-in-attacks-16-en.pdf](https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/increased-use-of-powershell-in-attacks-16-en.pdf). Adversaries
    make use of various obfuscation techniques to make analysis harder. To get an
    idea of how attackers use PowerShell obfuscation, watch this Derbycon presentation
    by Daniel Bohannon: [https://www.youtube.com/watch?v=P1lkflnWb0I](https://www.youtube.com/watch?v=P1lkflnWb0I).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有关恶意软件攻击中使用的不同 PowerShell 技术的更多信息，请参阅白皮书：*攻击中 PowerShell 使用的增加：* [https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/increased-use-of-powershell-in-attacks-16-en.pdf](https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/increased-use-of-powershell-in-attacks-16-en.pdf)。对手利用各种混淆技术使分析变得更加困难。想了解攻击者如何使用
    PowerShell 混淆技术，请观看 Daniel Bohannon 在 Derbycon 的演讲：[https://www.youtube.com/watch?v=P1lkflnWb0I](https://www.youtube.com/watch?v=P1lkflnWb0I)。
- en: 2\. Malware Persistence Methods
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 恶意软件持久化方法
- en: Often, adversaries want their malicious program to stay on the compromised computers,
    even when the Windows restarts. This is achieved using various persistence methods;
    this persistence allows an attacker to remain on the compromised system without
    having to re-infect it. There are many ways to run the malicious code each time
    Windows starts. In this section, you will understand some of the persistence methods
    used by the adversaries. Some of these persistence techniques covered in this
    section allow the attackers to execute malicious code with elevated privileges
    (privilege escalation).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对手常常希望他们的恶意程序即使在Windows重启后也能继续存在。这通过使用各种持久性方法实现；这种持久性允许攻击者在不需要重新感染的情况下继续存在于被攻击的系统中。有许多方法可以让恶意代码每次在Windows启动时执行。在这一节中，你将了解一些对手使用的持久性方法。这些持久性技术中的一些方法允许攻击者在提权后执行恶意代码（权限提升）。
- en: 2.1 Running the Registry Key
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 运行注册表键
- en: 'One of the most common persistence mechanisms used by adversaries to survive
    the reboot is achieved by adding an entry to the *run registry keys*. The program
    that is added to the run registry key gets executed at system startup. The following
    is a list of the most commonly run registry keys. Malware can add itself to various
    auto-start locations in addition to the ones were are about to mention. The best
    way to get an idea of various auto-start locations is to use the *AutoRuns utility *by
    Sysinternals ([https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns](https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对手用来在重启后生存的最常见的持久性机制之一是通过向*运行注册表键*添加条目来实现。添加到运行注册表键中的程序会在系统启动时执行。以下是最常见的运行注册表键的列表。除了我们即将提到的这些，恶意软件还可以将自己添加到其他自动启动位置。了解各种自动启动位置的最好方法是使用Sysinternals的*AutoRuns工具*（[https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns](https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns)）：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following example, upon execution, the malware (`bas.exe`)  first drops
    an executable in the Windows directory *(*`LSPRN.EXE`*)* and then adds the following
    entry in the run registry key so that the malicious program can start every time
    the system starts. From the registry entries, it can be seen that malware is trying
    to make its binary look like a printer-related application:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，执行时，恶意软件（`bas.exe`）首先在Windows目录中投放一个可执行文件（`LSPRN.EXE`），然后在运行注册表键中添加以下条目，以便每次系统启动时都能启动该恶意程序。从注册表条目可以看出，恶意软件试图使其二进制文件看起来像一个与打印机相关的应用程序：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To detect the malware using this persistence method, you can monitor for the
    changes to the Run registry keys that are not associated with the known program.
    You can also use Sysinternal's *AutoRuns utility* to inspect the Auto-start locations
    for suspicious entries.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测使用这种持久性方法的恶意软件，你可以监控那些与已知程序无关的Run注册表键的变动。你也可以使用Sysinternal的*AutoRuns工具*来检查自动启动位置的可疑条目。
- en: 2.2 Scheduled Tasks
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 调度任务
- en: 'Another persistence method adversaries use is to schedule a task that allows
    them to execute their malicious program at a specified time or during system startup.
    Windows utilities such as `schtasks` and `at` are normally used by the adversaries
    to schedule a program or script to execute at a desired date and time. By making
    use of these utilities, an attacker can create tasks on a local computer or remote
    computer, provided the account used to create the task is part of an Administrator
    group. In the following example, the malware (`ssub.exe`) first creates a file
    called `service.exe` in the `%AllUsersProfile%\WindowsTask\` directory and then
    invokes `cmd.exe`,  which in turn uses the `schtasks` Windows utility to create
    a scheduled task for persistence:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对手使用的持久性方法是调度任务，使其能够在指定时间或系统启动时执行恶意程序。像`schtasks`和`at`这样的Windows工具通常被对手用来调度程序或脚本在指定的日期和时间执行。通过利用这些工具，攻击者可以在本地计算机或远程计算机上创建任务，只要用于创建任务的账户是管理员组的成员。在以下示例中，恶意软件（`ssub.exe`）首先在`%AllUsersProfile%\WindowsTask\`目录中创建一个名为`service.exe`的文件，然后调用`cmd.exe`，该程序进一步使用`schtasks`
    Windows工具创建一个调度任务以保持持久性：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To detect this type of persistence, one can use the Sysinternals *Autoruns or*
    the *task scheduler* utility to list currently scheduled tasks. You should consider
    monitoring the changes to the tasks that are not related to the legitimate programs.
    You can also monitor the command-line arguments passed to the system utilities
    such as `cmd.exe`, which may be used to create tasks. Tasks may also be created
    using management tools such as *PowerShell* and *Windows Management Instrumentation
    (WMI)*, so appropriate logging and monitoring should help in detecting this technique.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这种持久性类型，可以使用Sysinternals的*Autoruns*或*任务计划程序*实用程序列出当前计划任务。应考虑监视与合法程序无关的任务的更改。还可以监视传递给系统实用程序（如`cmd.exe`）的命令行参数，这些参数可能用于创建任务。任务也可以使用管理工具（如*PowerShell*和*Windows管理工具（WMI）*）创建，因此适当的日志记录和监视应有助于检测此技术。
- en: 2.3 Startup Folder
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 启动文件夹
- en: 'Adversaries can achieve persistence by adding their malicious binary in the
    *startup folders*. When the operating system starts, the startup folder is looked
    up and files residing in this folder are executed. The Windows operating system
    maintains two types of startup folders: *(a) user wide* and *(b) system-wide*,
    as shown in the following code. A program residing in the user''s startup folder
    is executed only for a specific user and the program residing in the system folder
    is executed when any user logs on to the system. Administrator privilege is required
    to achieve persistence using a system-wide startup folder:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过将其恶意二进制文件添加到*启动文件夹*中实现持久性。操作系统启动时，将查找启动文件夹并执行位于此文件夹中的文件。Windows操作系统维护两种类型的启动文件夹：*（a）用户范围*和*（b）系统范围*，如下所示。位于用户启动文件夹中的程序仅为特定用户执行，而位于系统文件夹中的程序在任何用户登录到系统时执行。需要管理员权限才能使用系统范围的启动文件夹实现持久性：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the following example, the malware *(Backdoor.Nitol)* first drops a file
    in the `%AppData%` directory. It then creates a shortcut *(*`.lnk`*)* that points
    to the dropped file and then adds that shortcut to the `Startup` folder. This
    way, when the system starts, the dropped file gets executed via the shortcut *(*`.lnk`*)*
    file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，恶意软件*(Backdoor.Nitol)*首先将文件放在`%AppData%`目录中。然后创建一个指向已放置文件的快捷方式（*`.lnk`*），然后将该快捷方式添加到`Startup`文件夹中。这样，当系统启动时，通过快捷方式（*`.lnk`*）文件执行已放置的文件：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To detect this type of attack, you can monitor the entries added and changes
    made to the startup folders.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这种类型的攻击，可以监视添加的条目和对启动文件夹所做的更改。
- en: 2.4 Winlogon Registry Entries
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 Winlogon注册表条目
- en: An attacker can achieve persistence by modifying the registry entries used by
    the *Winlogon* process. The Winlogon process is responsible for handling interactive
    *user logons* and *logoffs*. Once the user is authenticated, the `winlogon.exe`
    process launches `userinit.exe`, which runs logon scripts and re-establishes network
    connections. `userinit.exe` then starts `explorer.exe`, which is the default User's
    shell.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过修改*Winlogon*进程使用的注册表条目来实现持久性。Winlogon进程负责处理交互式*用户登录*和*注销*。一旦用户经过身份验证，`winlogon.exe`进程会启动`userinit.exe`，该进程运行登录脚本并重新建立网络连接。然后`userinit.exe`启动`explorer.exe`，这是默认用户的外壳。
- en: 'The `winlogon.exe` process launches `userinit.exe` due to the following registry
    value. This entry specifies which programs need to be executed by Winlogon when
    a user logs on. By default, this value is set to the path of `userinit.exe` (`C:\Windows\system32\userinit.exe`).
    An attacker can change or add another value containing the path to the malicious
    executable, which will then be launched by the `winlogon.exe` process (when the
    user logs on):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`winlogon.exe`进程启动`userinit.exe`是由以下注册表值决定的。此条目指定Winlogon在用户登录时需要执行哪些程序。默认情况下，此值设置为`userinit.exe`的路径（`C:\Windows\system32\userinit.exe`）。攻击者可以更改或添加另一个包含恶意可执行文件路径的值，然后该文件将由`winlogon.exe`进程启动（用户登录时）：'
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same manner, `userinit.exe` consults the following registry value to
    start the default User''s shell. By default, this value is set to `explorer.exe`.
    An attacker can change or add another entry containing the name of the malicious
    executable, which will then be started by `userinit.exe`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`userinit.exe`查看以下注册表值以启动默认用户的外壳。默认情况下，此值设置为`explorer.exe`。攻击者可以更改或添加另一个条目，其中包含恶意可执行文件的名称，然后由`userinit.exe`启动：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the following example, the *Brontok* worm achieves persistence by modifying
    the following Winlogon registry values with its malicious executables:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，*Brontok* 蠕虫通过修改以下 Winlogon 注册表值并使用其恶意可执行文件实现持久化：
- en: '![](../images/00214.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00214.jpeg)'
- en: To detect this type of persistence mechanism, the Sysinternals *Autoruns utility*
    may be used. You can monitor for suspicious entries (not related to legitimate
    programs) in the registry, as mentioned earlier.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这种类型的持久化机制，可以使用 Sysinternals *Autoruns 实用程序*。你可以监视注册表中的可疑条目（与合法程序无关），如前所述。
- en: 2.5 Image File Execution Options
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 图像文件执行选项
- en: '*Image File Execution Options (IFEO)* allows one to launch an executable directly
    under the debugger. It gives the developer the option to debug their software
    to investigate issues in the executable''s startup code. A developer can create
    a subkey with the name of his/her executable under the following registry key
    and set the debugger value to the path of the debugger:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图像文件执行选项 (IFEO)* 允许直接在调试器下启动可执行文件。它为开发者提供了调试软件的选项，以调查可执行文件启动代码中的问题。开发者可以在以下注册表项下创建一个与其可执行文件名称相同的子键，并将调试器值设置为调试器的路径：'
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Adversaries take advantage of this registry key to launch their malicious program.
    To demonstrate this technique, the debugger for `notepad.exe` is set to a calculator
    (`calc.exe`) process by adding the following registry entry:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对手利用这个注册表键来启动他们的恶意程序。为了演示这种技术，`notepad.exe`的调试器被设置为计算器（`calc.exe`）进程，通过添加以下注册表项：
- en: '![](../images/00215.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00215.jpeg)'
- en: 'Now, when you start notepad, it will be launched by a calculator program (even
    though it is not a debugger). This behavior can be seen in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你启动记事本时，它将通过计算器程序启动（即使它不是一个调试器）。这种行为可以在以下截图中看到：
- en: '![](../images/00216.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00216.jpeg)'
- en: 'The following is an example of a malware sample *(TrojanSpy:Win32/Small.M)*
    that configures its malicious program, `iexplor.exe`, as a debugger for internet
    explorer, (`iexplore.exe`). This is achieved by adding the following registry
    value. In this case, the attackers chose a filename that looks similar to the
    legitimate internet explorer executable name. Due to the following registry entry,
    whenever the legitimate internet explorer (`iexplore.exe`) is executed, it will
    be launched by the malicious program `iexplor.exe`, thereby executing the malicious
    code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个恶意软件样本*(TrojanSpy:Win32/Small.M)*的示例，它将其恶意程序`iexplor.exe`配置为 Internet Explorer
    的调试器（`iexplore.exe`）。这是通过添加以下注册表值实现的。在这种情况下，攻击者选择了一个与合法的 Internet Explorer 可执行文件名相似的文件名。由于以下注册表项的存在，每当执行合法的
    Internet Explorer（`iexplore.exe`）时，它将通过恶意程序`iexplor.exe`启动，从而执行恶意代码：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To detect this type of persistence technique, you can inspect the I*mage File
    Execution Options* registry entry for any modifications not related to the legitimate
    programs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这种类型的持久化技术，可以检查I*mage File Execution Options*注册表项，查看是否有与合法程序无关的修改。
- en: 2.6 Accessibility Programs
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 可访问性程序
- en: The Windows operating system provides various accessibility features such as
    the *On-screen keyboard*, *Narrator*, *Magnifier*, *Speech recognition*, and so
    on. These features are mainly designed for people with special needs. These accessibility
    programs can be launched without even logging into the system. For example, many
    of these accessibility programs can be accessed by pressing the *Windows + U*
    key combination, which launches `C:\Windows\System32\utilman.exe`, or you can
    enable sticky keys by pressing the *shift key* five times, which will launch the
    program `C:\Windows\System32\sethc.exe`*.* An attacker can change the way these
    accessibility programs (such as `sethc.exe` and `utilman.exe`) are launched to
    execute a program of their choice, or they can use `cmd.exe` with elevated privileges
    (privilege escalation).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统提供了多种可访问性功能，例如*屏幕键盘*、*讲述人*、*放大镜*、*语音识别*等。这些功能主要是为有特殊需求的人群设计的。这些可访问性程序甚至在未登录系统的情况下也可以启动。例如，许多可访问性程序可以通过按下*Windows
    + U*键组合来访问，这将启动`C:\Windows\System32\utilman.exe`，或者你可以通过连续按五次*Shift键*来启用粘滞键，这将启动程序`C:\Windows\System32\sethc.exe`。攻击者可以改变这些可访问性程序（如`sethc.exe`和`utilman.exe`）的启动方式，执行他们选择的程序，或者利用具有提升权限的`cmd.exe`（权限提升）。
- en: 'Adversaries use the sticky keys (`sethc.exe`) feature to gain unauthenticated
    access via Remote Desktop (RDP). In the case of the *Hikit* Rootkit, ([https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html](https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html))
    the legitimate `sethc.exe` program was replaced with `cmd.exe`. This allowed the
    adversaries to access the command prompt with *SYSTEM* privileges over RDP just
    by pressing the *shift key* five times. While in the older versions of Windows
    it was possible to replace the accessibility program with another program, the
    newer versions of Windows enforces various restrictions such as the replaced binary
    must reside in `%systemdir%`**,** it needs to be digitally signed for x64 systems,
    and it must be protected by *Windows File or Resource Protection (WFP/WRP)*. These
    restrictions make it hard for the adversaries to replace the legitimate programs
    (such as `sethc.exe`). To avoid replacing the files, adversaries make use of the
    *Image File Execution Options* (covered in the previous section), as shown in
    the following code. The following registry entry sets `cmd.exe` as the debugger
    for `sethc.exe`; now, an adversary can use RDP login and press the *Shift* key
    five times to get access to the System-level command shell. Using this shell,
    an adversary can execute any arbitrary commands even before authentication. In
    the same manner, a malicious backdoor program can be executed by setting it as
    a debugger for `sethc.exe` or `utilman.exe`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者利用粘滞键（`sethc.exe`）功能通过远程桌面（RDP）获得未认证的访问权限。在 *Hikit* Rootkit 的情况下，([https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html](https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html))
    合法的 `sethc.exe` 程序被替换为 `cmd.exe`。这使得攻击者仅需按五次 *Shift 键*，就能通过 RDP 获得带有 *SYSTEM*
    权限的命令提示符。虽然在旧版 Windows 中，可以将辅助功能程序替换为其他程序，但新版 Windows 强制执行各种限制，比如替换后的二进制文件必须位于
    `%systemdir%`，必须为 x64 系统数字签名，并且必须受到 *Windows 文件或资源保护（WFP/WRP）* 的保护。这些限制使得攻击者很难替换合法的程序（如
    `sethc.exe`）。为了避免替换文件，攻击者利用 *图像文件执行选项*（在上一节中已讲解），如以下代码所示。以下注册表项将 `cmd.exe` 设置为
    `sethc.exe` 的调试器；现在，攻击者可以通过 RDP 登录并按五次 *Shift* 键来访问系统级别的命令行。通过该命令行，攻击者可以在身份验证之前执行任何任意命令。同样，一个恶意后门程序也可以通过将其设置为
    `sethc.exe` 或 `utilman.exe` 的调试器来执行：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following example, when a malware sample (`mets.exe`) is executed, it
    runs the following command, which modifies the firewall rules/registry to allow
    RDP connection and then adds a registry value to set the task manager (`taskmgr.exe`)
    as the debugger for `sethc.exe`. This allows an adversary to access `taskmgr.exe`
    over RDP (with SYSTEM privileges). Using this technique, an adversary can *kill
    a process* or s*tart/stop a service* over RDP without even logging in to the system:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当恶意软件样本（`mets.exe`）被执行时，它会运行以下命令，该命令修改防火墙规则/注册表以允许 RDP 连接，然后添加一个注册表值，将任务管理器（`taskmgr.exe`）设置为
    `sethc.exe` 的调试器。这使得攻击者可以通过 RDP 访问 `taskmgr.exe`（并具有 SYSTEM 权限）。使用此技术，攻击者可以在不登录系统的情况下，通过
    RDP *终止进程* 或 *启动/停止服务*：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This type of attack is slightly difficult to detect, because an attacker either
    replaces the accessibility programs with legitimate programs or makes use of legitimate
    programs. However, if you suspect that the accessibility program (`sethc.exe`)
    has been replaced with legitimate files, such as `cmd.exe` or `taskmgr.exe`, then
    you can compare the hash values of the replaced accessibility program with the
    hash values of the legitimate files (`cmd.exe` or `taskmgr.exe`) to look for a
    match. A hash value match is an indication that the original `sethc.exe` file
    was replaced. You can also inspect the *Image File Execution Options* registry
    entry for any suspicious modifications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击类型稍微难以检测，因为攻击者要么用合法程序替换辅助功能程序，要么利用合法程序。然而，如果你怀疑辅助功能程序（`sethc.exe`）已被合法文件（如
    `cmd.exe` 或 `taskmgr.exe`）替换，那么你可以通过比较替换后辅助功能程序的哈希值与合法文件（`cmd.exe` 或 `taskmgr.exe`）的哈希值，来寻找是否匹配。哈希值匹配表明原始的
    `sethc.exe` 文件已被替换。你还可以检查 *图像文件执行选项* 注册表项，查看是否有任何可疑的修改。
- en: 2.7 AppInit_DLLs
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 AppInit_DLLs
- en: 'The `AppInit_DLLs` feature in Windows provides a way to load custom DLLs into
    the address space of every interactive application. Once a DLL is loaded into
    the address space of any process, it can run within the context of that process
    and can hook well-known APIs to implement an alternate functionality. An attacker
    can achieve persistence for their malicious DLL by setting the `AppInit_DLLs`
    value in the following registry key. This value typically contains space or comma-delimited
    list of DLLs. All the DLLs specified here are loaded into every process that loads
    `User32.dll`. Since `User32.dll` is loaded by almost all of the processes, this
    technique enables the attacker to load their malicious DLL into most of the processes
    and executes the malicious code within the context of the loaded process. In addition
    to setting the `AppInit_DLLs` value, an attacker may also enable the `AppInit_DLLs`
    functionality by setting the `LoadAppInit_DLLs` registry value to `1`. The `AppInit_DLLs`
    functionality is disabled on Windows 8 and later versions, where the secure boot
    is enabled:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中的 `AppInit_DLLs` 功能提供了一种将自定义 DLL 加载到每个交互式应用程序地址空间中的方法。一旦 DLL 被加载到任何进程的地址空间中，它就可以在该进程的上下文中运行，并且可以挂钩常见的
    API 来实现替代功能。攻击者可以通过在以下注册表项中设置 `AppInit_DLLs` 值来使其恶意 DLL 保持持久性。该值通常包含由空格或逗号分隔的
    DLL 列表。这里指定的所有 DLL 都会被加载到每个加载 `User32.dll` 的进程中。由于几乎所有进程都加载 `User32.dll`，这一技术使得攻击者能够将其恶意
    DLL 加载到大多数进程中，并在加载的进程上下文中执行恶意代码。除了设置 `AppInit_DLLs` 值外，攻击者还可以通过将 `LoadAppInit_DLLs`
    注册表值设置为 `1` 来启用 `AppInit_DLLs` 功能。在 Windows 8 及更高版本中，如果启用了安全启动，`AppInit_DLLs`
    功能将被禁用：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot shows the AppInit DLL entries added by the *T9000
    backdoor* ([https://researchcenter.paloaltonetworks.com/2016/02/t9000-advanced-modular-backdoor-uses-complex-anti-analysis-techniques/](https://researchcenter.paloaltonetworks.com/2016/02/t9000-advanced-modular-backdoor-uses-complex-anti-analysis-techniques/)):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了*T9000 后门*添加的 AppInit DLL 条目 ([https://researchcenter.paloaltonetworks.com/2016/02/t9000-advanced-modular-backdoor-uses-complex-anti-analysis-techniques/](https://researchcenter.paloaltonetworks.com/2016/02/t9000-advanced-modular-backdoor-uses-complex-anti-analysis-techniques/))：
- en: '![](../images/00217.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00217.jpeg)'
- en: 'As a result of adding the preceding registry entries, when any new process
    (that loads `User32.dll`) is started, it loads the malicious DLL (`ResN32.dll`)
    into its address space. The following screenshot displays the operating system''s
    processes that loaded the malicious DLL (`ResN32.dll`) after rebooting the system.
    Since most of these processes run with high integrity levels, it allows an adversary
    to execute malicious code with elevated privileges:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加了上述注册表条目，当任何新的进程（加载了`User32.dll`）启动时，它会将恶意 DLL（`ResN32.dll`）加载到其地址空间中。以下截图显示了系统重启后加载了恶意
    DLL（`ResN32.dll`）的操作系统进程。由于大多数这些进程以高完整性级别运行，因此攻击者可以利用这一点以提升的权限执行恶意代码：
- en: '![](../images/00218.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00218.jpeg)'
- en: To detect this technique, you can look for the suspicious entries in the `AppInit_DLLs` registry
    value, that do not relate to the legitimate programs in your environment. You
    can also look for any process exhibiting abnormal behavior due to the loading
    of the malicious DLL.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测这一技术，您可以查找 `AppInit_DLLs` 注册表值中与您环境中的合法程序无关的可疑条目。您还可以查找由于加载恶意 DLL 而表现出异常行为的进程。
- en: 2.8 DLL Search Order Hijacking
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 DLL 搜索顺序劫持
- en: 'When a process is executed, its associated DLLs are loaded into the process
    memory (either via an *import table* or as a result of the process calling the `LoadLibrary()`
    API). The Windows operating system searches for the DLL to be loaded in a specific
    order in the predefined locations. The search order sequence is documented in
    the MSDN here: [http://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx](http://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程被执行时，它相关的 DLL 被加载到进程内存中（无论是通过*导入表*，还是因为进程调用了`LoadLibrary()` API）。Windows
    操作系统会按照特定顺序在预定义的位置搜索要加载的 DLL。搜索顺序的文档可以在 MSDN 中找到：[http://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx](http://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx)。
- en: 'In short, if any DLL has to be loaded, the operating system first checks if
    the DLL is already loaded in the memory. If yes, it uses the loaded DLL. If not,
    it checks if the DLL is defined in the `KnownDLLs` registry key (`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
    Manager\KnownDLLs`). The DLLs listed here are system DLLs (located in the `system32`
    directory), and they are protected using *Windows file protection* to ensure that
    these DLLs are not deleted or updated except by the operating system updates.
    If the DLL to be loaded in is in the list of `KnownDLLs`, then the DLL is always
    loaded from the `System32` directory. If these conditions are not met, then the
    operating system looks for the DLL in the following locations in sequential order:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果需要加载任何 DLL，操作系统首先会检查该 DLL 是否已加载到内存中。如果已加载，它会使用已加载的 DLL。如果未加载，操作系统会检查
    DLL 是否已在 `KnownDLLs` 注册表键中定义（`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
    Manager\KnownDLLs`）。此处列出的 DLL 是系统 DLL（位于 `system32` 目录中），它们通过 *Windows 文件保护* 进行保护，以确保除操作系统更新外，这些
    DLL 不会被删除或更新。如果要加载的 DLL 在 `KnownDLLs` 列表中，那么该 DLL 始终会从 `System32` 目录加载。如果这些条件不满足，操作系统会按顺序在以下位置查找
    DLL：
- en: The directory from where the application was launched.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动的目录。
- en: The system directory (`C:\Windows\System32`).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统目录（`C:\Windows\System32`）。
- en: The 16-bit system directory (`C:\Windows\System`).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 16 位系统目录（`C:\Windows\System`）。
- en: The Windows directory (`C:\Windows`).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Windows 目录（`C:\Windows`）。
- en: The current directory.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前目录。
- en: Directories defined in the `PATH` variables.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATH` 变量中定义的目录。'
- en: 'Adversaries can take advantage of how the operating system searches for the
    DLL to escalate privilege and to achieve persistence. Consider the malware (*Prikormka
    dropper*) used in Operation Groundbait ([http://www.welivesecurity.com/wp-content/uploads/2016/05/Operation-Groundbait.pdf](http://www.welivesecurity.com/wp-content/uploads/2016/05/Operation-Groundbait.pdf)).
    This malware, upon execution, drops a malicious DLL called `samlib.dll` in the
    Windows directory (`C:\Windows`), as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以利用操作系统查找 DLL 的方式来提升权限并实现持久性。考虑到在“Operation Groundbait”行动中使用的恶意软件（*Prikormka
    dropper*）([http://www.welivesecurity.com/wp-content/uploads/2016/05/Operation-Groundbait.pdf](http://www.welivesecurity.com/wp-content/uploads/2016/05/Operation-Groundbait.pdf))。该恶意软件在执行时会在
    Windows 目录（`C:\Windows`）中放置一个名为 `samlib.dll` 的恶意 DLL，如下所示：
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On a clean operating system, a DLL with the same name (`samlib.dll`) resides
    in the `C:\Windows\System32` directory and this clean DLL is loaded by `explorer.exe`,
    which resides in the `C:\Windows` dir*ectory.* The clean DLL is also loaded by
    few other processes which reside in the `system32` directory, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个干净的操作系统中，名为 `samlib.dll` 的 DLL 存在于 `C:\Windows\System32` 目录中，并且该干净的 DLL 会被位于
    `C:\Windows` 目录中的 `explorer.exe` 加载。该干净的 DLL 也会被其他一些位于 `system32` 目录中的进程加载，如下所示：
- en: '![](../images/00219.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00219.jpeg)'
- en: 'Since the malicious DLL is dropped in the same directory as `explorer.exe`
    (which is `C:\Windows`), as a result, when the system reboots, the malicious `samlib.dll`
    is loaded by `explorer.exe` from the `C:\Windows` directory instead of the legitimate
    DLL from the `system32` directory. The following screenshot, taken after rebooting
    the infected system, displays the malicious DLL loaded by `explorer.exe` as a
    result of DLL search order hijacking:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意 DLL 被放置在与 `explorer.exe` 相同的目录中（即 `C:\Windows`），因此在系统重启后，恶意的 `samlib.dll`
    会由 `explorer.exe` 从 `C:\Windows` 目录加载，而不是从 `system32` 目录加载合法的 DLL。以下截图显示了在感染系统重启后，由于
    DLL 搜索顺序劫持，`explorer.exe` 加载了恶意 DLL：
- en: '![](../images/00220.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00220.jpeg)'
- en: The *DLL search order hijack* technique makes forensic analysis much harder
    and evades traditional defenses. To detect such attacks, you should consider monitoring
    the creation, renaming, replacing, or deletion of DLLs and look for any modules
    (DLLs) loaded by the processes from abnormal paths.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*DLL 搜索顺序劫持* 技术使得取证分析变得更加困难，并且能够绕过传统防御措施。为了检测此类攻击，您应考虑监控 DLL 的创建、重命名、替换或删除，并查看任何由进程加载的来自异常路径的模块（DLL）。'
- en: 2.9 COM hijacking
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 COM 劫持
- en: '*Component Object Model (COM)* is a system that allows the software components
    to interact and communicate with each other, even if they have no knowledge of
    each other''s code ([https://msdn.microsoft.com/en-us/library/ms694363(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms694363(v=vs.85).aspx)).
    The software components interact with each other through the use of COM objects,
    and these objects can be within a single process, other processes, or on remote
    computers. COM is implemented as a client/server framework. A COM client is a
    program that uses the service from the COM server (COM object), and a COM server
    is an object which provides service to the COM clients. The COM server implements
    an interface consisting of various methods (functions), either in a DLL (called
    *in-process server*) or in an EXE (called *out-of-process server*). A COM client
    can utilize the service provided by COM server by creating an instance of the
    COM object, acquiring the pointer to the interface, and calling the method implemented
    in its interface.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件对象模型（COM）* 是一个允许软件组件互相交互和通信的系统，即使它们互相之间不了解对方的代码（[https://msdn.microsoft.com/en-us/library/ms694363(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms694363(v=vs.85).aspx)）。软件组件通过使用
    COM 对象相互交互，这些对象可以位于单个进程、其他进程或远程计算机上。COM 被实现为一个客户端/服务器框架。COM 客户端是一个使用 COM 服务器（COM
    对象）服务的程序，COM 服务器是一个为 COM 客户端提供服务的对象。COM 服务器实现了一个包含各种方法（函数）的接口，这些方法可以在 DLL 中（称为
    *进程内服务器*）或 EXE 中（称为 *进程外服务器*）。COM 客户端可以通过创建 COM 对象的实例、获取接口指针并调用其接口中实现的方法来使用 COM
    服务器提供的服务。'
- en: 'The Windows operating system provides various COM objects that can be used
    by the programs (COM client). The COM objects are identified by a unique number
    called *class identifiers* (*CLSIDs*), and they are typically found in the registry
    key `HKEY_CLASSES_ROOT\CLSID\< unique clsid>`. For example, the COM object for
    *My Computer* is `{20d04fe0-3aea-1069-a2d8-08002b30309d}`, which can be seen in
    the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统提供了各种 COM 对象，供程序（COM 客户端）使用。这些 COM 对象由一个唯一的编号标识，称为 *类标识符*（*CLSIDs*），它们通常可以在注册表项
    `HKEY_CLASSES_ROOT\CLSID\< unique clsid>` 中找到。例如，*我的电脑* 的 COM 对象是 `{20d04fe0-3aea-1069-a2d8-08002b30309d}`，可以在以下截图中看到：
- en: '![](../images/00221.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00221.jpeg)'
- en: 'For each CLSID key, you also have a subkey called `InProcServer32` that specifies
    the filename of the DLL that implements the COM server functionality. The following
    screenshot tells you that `shell32.dll` (COM server) is associated with *My computer*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 CLSID 键，您还有一个名为 `InProcServer32` 的子键，指定实现 COM 服务器功能的 DLL 文件名。以下截图显示 `shell32.dll`（COM
    服务器）与 *我的电脑* 关联：
- en: '![](../images/00222.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00222.jpeg)'
- en: Similar to the *My Computer* COM object, Microsoft provides various other COM
    objects (implemented in DLLs) that are used by the legitimate programs. When the
    legitimate program (COM client) uses the service from a specific COM object (using
    its CLSID), its associated DLL gets loaded into the process address space of the
    client program. In the case of *COM Hijacking*, an attacker modifies the registry
    entry of a legitimate COM object and associates it with the attacker's malicious
    DLL. The idea is that when legitimate programs use the hijacked objects, the malicious
    DLL gets loaded into the address space of the legitimate program. This allows
    an adversary to persist on the system and execute malicious code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 *我的电脑* COM 对象，微软提供了各种其他 COM 对象（通过 DLL 实现），这些对象被合法程序所使用。当合法程序（COM 客户端）使用特定
    COM 对象的服务（使用其 CLSID）时，相关的 DLL 会被加载到客户端程序的进程地址空间中。在 *COM 劫持* 的情况下，攻击者修改了合法 COM
    对象的注册表项，并将其与攻击者的恶意 DLL 关联。其目的是，当合法程序使用被劫持的对象时，恶意 DLL 会被加载到合法程序的地址空间中。这使得攻击者能够在系统上保持持久性并执行恶意代码。
- en: 'In the following example, upon executing the malware (*Trojan.Compfun*), it
    drops a `dll` with a `._dl` extension, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，当执行恶意软件（*Trojan.Compfun*）时，它会丢弃一个带有 `._dl` 扩展名的 `dll` 文件，如下所示：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The malware then sets the following registry value in `HKCU\Software\Classes\CLSID`.
    This entry associates the COM object `{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    of the `MMDeviceEnumerator` class with the malicious DLL `C:\Windows\system\api-ms-win-downlevel-qgwo-l1-1-0._dl`
    for the current user:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意软件在 `HKCU\Software\Classes\CLSID` 中设置以下注册表值。此条目将 `MMDeviceEnumerator` 类的
    COM 对象 `{BCDE0395-E52F-467C-8E3D-C4579291692E}` 与恶意 DLL `C:\Windows\system\api-ms-win-downlevel-qgwo-l1-1-0._dl`
    关联，针对当前用户：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On a clean system, the COM object `{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    of the `MMDeviceEnumerator` Class is associated with the DLL `MMDevApi.dll`, and
    its registry entry  is typically found in `HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\`,
    and no corresponding entry is found in `HKCU\Software\Classes\CLSID\`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在干净的系统上，`MMDeviceEnumerator` 类的 COM 对象 `{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    关联的 DLL 是 `MMDevApi.dll`，其注册表条目通常位于 `HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\`，而在
    `HKCU\Software\Classes\CLSID\` 中找不到相应的条目：
- en: '![](../images/00223.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00223.jpeg)'
- en: 'As a result of the malware adding an entry in `HKCU\Software\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`,
    the infected system now contains two registry entries for the same CLSID. Since
    the user objects from `HKCU\Software\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    get loaded before the machine objects located in `HKLM\SOFTWARE\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`,
    the malicious DLL gets loaded, thereby hijacking the COM object of `MMDeviceEnumerator`.
    Now, any process that uses the `MMDeviceEnumerator` object loads the malicious
    DLL. The following screenshot was taken after restarting the infected system.
    After the restart, the malicious DLL was loaded by `explorer.exe`, as shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意软件在 `HKCU\Software\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    中添加了条目，受感染的系统现在包含了相同 CLSID 的两个注册表条目。由于用户对象从 `HKCU\Software\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    被加载，优先于位于 `HKLM\SOFTWARE\Classes\CLSID\{BCDE0395-E52F-467C-8E3D-C4579291692E}`
    的机器对象，恶意 DLL 被加载，从而劫持了 `MMDeviceEnumerator` 的 COM 对象。现在，任何使用 `MMDeviceEnumerator`
    对象的进程都会加载恶意 DLL。在重新启动受感染的系统后，如下图所示，`explorer.exe` 加载了恶意 DLL。
- en: '![](../images/00224.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00224.jpeg)'
- en: The *COM hijacking* technique evades detection from most of the traditional
    tools. To detect this kind of attack, you can look for the presence of objects
    in `HKCU\Software\Classes\CLSID\`. Instead of adding an entry in `HKCU\Software\Classes\CLSID\`,
    malware may modify the existing entry in `HKLM\Software\Classes\CLSID\` to point
    to a malicious binary, so you should also consider checking for any value pointing
    to an unknown binary in this registry key.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*COM劫持* 技术可逃避大多数传统工具的检测。要检测此类攻击，可以查看 `HKCU\Software\Classes\CLSID\` 中对象的存在。恶意软件可能不会在
    `HKCU\Software\Classes\CLSID\` 中添加条目，而是修改 `HKLM\Software\Classes\CLSID\` 中的现有条目以指向恶意二进制文件，因此还应考虑检查此注册表键中指向未知二进制文件的任何值。'
- en: 2.10 Service
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 服务
- en: 'A service is a program that runs in the background without any user interface,
    and it provides core operating system features such as event logging, printing,
    error reporting, and so on. An adversary with Administrator privilege can persist
    on the system by installing the malicious program as a service or by modifying
    an existing service. For an adversary, the advantage of using the service is that
    it can be set to start automatically when the operating system starts, and it
    mostly runs with a privileged account such as SYSTEM; this allows an attacker
    to elevate privileges. An attacker may implement the malicious program as an *EXE*,
    *DLL,* or *kernel driver* and run it as a service. Windows supports various service
    types, and the following outlines some of the common service types used by the
    malicious programs:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是在后台运行且没有用户界面的程序，它提供核心操作系统功能，如事件日志记录、打印、错误报告等。攻击者通过将恶意程序安装为服务或修改现有服务，可以在具有管理员特权的系统上持久存在。使用服务的优势在于可以在操作系统启动时自动启动，并且大多数情况下以
    SYSTEM 等特权帐户运行；这使攻击者可以提升权限。攻击者可以将恶意程序实现为 *EXE*、*DLL* 或 *内核驱动程序* 并将其作为服务运行。Windows
    支持各种服务类型，以下概述了恶意程序常用的一些服务类型：
- en: '*Win32OwnProcess*: The code for the service is implemented as an executable,
    and it runs as an individual process'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Win32OwnProcess:* 该服务的代码作为可执行文件实现，并作为单独的进程运行'
- en: '*Win32ShareProcess:* The code for the service is implemented as a DLL, and
    it runs from a shared host process (`svchost.exe`)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Win32ShareProcess:* 该服务的代码作为 DLL 实现，并且从共享主机进程 (`svchost.exe`) 运行'
- en: '*Kernel Driver Service:* This type of service is implemented in a driver (`.sys`),
    and it is used to execute the code in kernel space'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内核驱动程序服务:* 这种类型的服务在驱动程序（`.sys`）中实现，并用于在内核空间执行代码'
- en: 'Windows stores the list of installed services and their configuration in the
    registry under the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services` key.
    Each service has its own subkey consisting of values that specify how, when, and
    whether the service is implemented in an *EXE*, *DLL,* or *kernel driver*. For
    example, the service name for the *Windows installer service* is `msiserver`,
    and in the following screenshot, a subkey is present with the same name as the
    service name under `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services`. The
    `ImagePath` value specifies that the code for this service is implemented in `msiexec.exe`,
    the `Type` value of `0x10(16)` tells us that it is `Win32OwnProces*s*`, and the
    `Start` value `0x3` represents `SERVICE_DEMAND_START`, which means that this service
    needs to be started manually:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 将已安装服务及其配置存储在注册表的 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services`
    键下。每个服务都有其自己的子键，其中包含指定如何、何时以及是否以 *EXE*、*DLL* 或 *内核驱动程序* 实现该服务的值。例如，*Windows 安装程序服务*
    的服务名为 `msiserver`，在以下截图中，注册表下的子键与服务名相同，位于 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services`
    下。`ImagePath` 值指定该服务的代码实现于 `msiexec.exe`，`Type` 值为 `0x10(16)`，表示它是 `Win32OwnProcess`，而
    `Start` 值 `0x3` 表示 `SERVICE_DEMAND_START`，即该服务需要手动启动：
- en: '![](../images/00225.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00225.jpeg)'
- en: 'To determine the symbolic name associated with the constant values, you can
    refer to the MSDN documentation for the `CreateService()` API ([https://msdn.microsoft.com/en-us/library/windows/desktop/ms682450(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682450(v=vs.85).aspx)),
    or you can query the service configuration using the `sc` utility by providing
    the service name, as shown here. This will display similar information that is
    found in the registry subkey:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定与常量值关联的符号名称，您可以参考 MSDN 文档中的 `CreateService()` API ([https://msdn.microsoft.com/en-us/library/windows/desktop/ms682450(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682450(v=vs.85).aspx))，或者可以通过提供服务名称来使用
    `sc` 工具查询服务配置，如下所示。这将显示类似于注册表子项中找到的信息：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s now look at an example of the *Win32ShareProcess* service. The *Dnsclient*
    service has a service name of `Dnscache`, and code for the service is implemented
    in the DLL. When a service is implemented as a DLL (service DLL), the `ImagePath`
    registry value will typically contain the path to the `svchost.exe` (because that
    is the process that loads the Service DLL). To determine the DLL that is associated
    with the service, you will have to look at the `ServiceDLL` value, which is present
    under the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\<service name>\Parameters`
    subkey. The following screenshot shows the DLL (`dnsrslvr.dll`) associated with
    the Dnsclient service; this DLL gets loaded by the generic host process `svchost.exe`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个 *Win32ShareProcess* 服务的示例。*Dnsclient* 服务的服务名为 `Dnscache`，该服务的代码实现于
    DLL 中。当服务实现为 DLL（服务 DLL）时，`ImagePath` 注册表值通常会包含指向 `svchost.exe` 的路径（因为该进程加载了服务
    DLL）。要确定与服务关联的 DLL，您需要查看 `ServiceDLL` 值，该值位于 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\<service
    name>\Parameters` 子项下。以下截图显示了与 Dnsclient 服务关联的 DLL（`dnsrslvr.dll`）；该 DLL 由通用宿主进程
    `svchost.exe` 加载：
- en: '![](../images/00226.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00226.jpeg)'
- en: 'An attacker can create services in many ways. The following outlines some of
    the common methods:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过多种方式创建服务。以下概述了其中一些常见的方法：
- en: '**sc utility:** A malware can invoke `cmd.exe` and run an `sc` command such
    as `sc create` and `sc start` (or `net start`) to create and start the service,
    respectively. In the following example, malware executes the `sc` command (via
    `cmd.exe`) to create and start a service named `update`:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sc 工具：** 恶意软件可以调用 `cmd.exe` 并运行 `sc` 命令，例如 `sc create` 和 `sc start`（或 `net
    start`）来创建和启动服务。以下示例中，恶意软件通过 `cmd.exe` 执行 `sc` 命令来创建并启动一个名为 `update` 的服务：'
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Batch script**: A malware can drop a batch script and execute the previously
    mentioned commands to create and start the service. In the following example,
    the malware (*Trojan:Win32/Skeeyah)* drops a batch script (`SACI_W732.bat`) and
    executes the batch script (via `cmd.exe`), which in turn creates and starts a
    service named `Saci`:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理脚本：** 恶意软件可以投放批处理脚本并执行前面提到的命令来创建和启动服务。在以下示例中，恶意软件 (*Trojan:Win32/Skeeyah)*
    投放了一个批处理脚本（`SACI_W732.bat`）并执行该脚本（通过 `cmd.exe`），该脚本会创建并启动一个名为 `Saci` 的服务：'
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Windows API**: The malware can use Windows API, such as `CreateService()`
    and `StartService()` to *create* and *start* the service. When you run `sc utility` in
    the background, it uses these API calls to create and start the service. Consider
    the following example of the *NetTraveler* malware. Upon execution, it first drops
    a dll:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows API**：恶意软件可以使用Windows API，如`CreateService()`和`StartService()`来*创建*和*启动*服务。当你在后台运行`sc
    utility`时，它使用这些API调用来创建和启动服务。考虑以下*NetTraveler*恶意软件的示例。执行时，它首先会丢弃一个dll：'
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It then opens a handle to the service control manager using the `OpenScManager()`
    API and creates a service of type `Win32ShareProcess` by calling the `CreateService()`
    API. The second argument specifies the name of the service, which in this case
    is `FastUserSwitchingCompatiblity`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它通过`OpenScManager()` API打开到服务控制管理器的句柄，并通过调用`CreateService()` API创建一个`Win32ShareProcess`类型的服务。第二个参数指定服务的名称，在这种情况下是`FastUserSwitchingCompatiblity`：
- en: '![](../images/00227.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00227.jpeg)'
- en: 'After the call to `CreateService()`, the service gets created, and the following
    registry key is added with service configuration information:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`CreateService()`后，服务被创建，并且以下注册表项被添加，包含服务配置信息：
- en: '![](../images/00228.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00228.jpeg)'
- en: 'It then creates a `Parameters` subkey under the registry key created in the
    previous step:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，它在之前创建的注册表项下创建一个`Parameters`子项：
- en: '![](../images/00229.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00229.jpeg)'
- en: 'After that, it drops and executes a batch script, which sets the registry value
    (`ServiceDll`) to associate the DLL with the created service. The content of the
    batch script is shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它丢弃并执行一个批处理脚本，该脚本设置注册表值（`ServiceDll`）以将DLL与创建的服务关联。批处理脚本的内容如下所示：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As a result of creating a `Win32ShareProcess` service, when the system boots,
    the service control manager (`services.exe`) starts the `svchost.exe` process,
    which in turn loads the malicious ServiceDLL `FastUserSwitchingCompatibilityex.dll`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建了一个`Win32ShareProcess`服务，当系统启动时，服务控制管理器（`services.exe`）启动`svchost.exe`进程，进而加载恶意的ServiceDLL
    `FastUserSwitchingCompatibilityex.dll`。
- en: '** PowerShell and WMI**: A service can also be created using management tools
    such as *PowerShell* ([https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-service?view=powershell-5.1](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-service?view=powershell-5.1))
    and *Window Management Instrumentation (WMI)* high-level interfaces ([https://msdn.microsoft.com/en-us/library/aa394418(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa394418(v=vs.85).aspx)).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerShell 和 WMI**：可以使用管理工具如*PowerShell*（[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-service?view=powershell-5.1](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-service?view=powershell-5.1)）和*Windows
    Management Instrumentation (WMI)* 高级接口（[https://msdn.microsoft.com/en-us/library/aa394418(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa394418(v=vs.85).aspx)）来创建服务。'
- en: 'Instead of creating a new service, an adversary can modify (hijack) the existing
    service. Normally, an attacker hijacks a service that is unused or disabled. This
    makes detection slightly harder because, if you are trying to find the nonstandard
    or unrecognized service, you will miss this type of attack. Consider the example
    of the *BlackEnergy* malware dropper, which *Hijacks* the existing service to
    persist on the system. Upon execution, *BlackEnergy* replaces a legitimate driver
    called `aliide.sys` (associated with the service named `aliide`) residing in the `system32\drivers`
    directory with the malicious `aliide.sys` driver. After replacing the driver,
    it modifies the registry entry associated with the `aliide` service and sets it
    to autostart (the service starts automatically when the system starts), as shown
    in the following events:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以修改（劫持）现有服务，而不是创建新服务。通常，攻击者劫持的是未使用或已禁用的服务。这使得检测稍微变得困难，因为如果你试图查找非标准或未识别的服务，你可能会错过这种类型的攻击。考虑以下*BlackEnergy*恶意软件投放器的示例，它*劫持*现有服务以在系统上保持存在。执行时，*BlackEnergy*替换了一个合法的驱动程序`aliide.sys`（与名为`aliide`的服务相关联），该驱动程序位于`system32\drivers`目录中，并将其替换为恶意的`aliide.sys`驱动程序。替换驱动程序后，它修改与`aliide`服务相关的注册表项，并将其设置为自动启动（服务在系统启动时自动启动），如下所示：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following screenshot shows the service configuration of the `aliide` service
    before and after modification. For a detailed analysis of the *BlackEnergy3* big
    dropper, read the author''s blog post here at: [https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/](https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`aliide`服务在修改前后的服务配置。有关*BlackEnergy3*大掉落器的详细分析，请阅读作者的博客文章，链接如下：[https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/](https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/)
- en: '![](../images/00230.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00230.jpeg)'
- en: To detect such attacks, monitor the changes to service registry entries that
    are not associated with the legitimate program. Look for the modification to the
    binary path associated with the service, and changes to the service startup type
    (from manual to automatic). You should also consider monitoring and logging the
    usage of tools such as *sc*, *PowerShell*, and *WMI,* which can be used to interact
    with the service. The Sysinternals *AutoRuns utility* can also be used to inspect
    the use of service for persistence.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测此类攻击，请监控与合法程序无关的服务注册表条目的变化。查看与服务关联的二进制路径的修改情况，以及服务启动类型（从手动到自动）的变化。你还应考虑监控和记录使用像*sc*、*PowerShell*和*WMI*等工具的情况，这些工具可以用来与服务交互。Sysinternals的*AutoRuns工具*也可以用来检查服务的持久性使用情况。
- en: 'An adversary can persist and execute the malicious code within the DLL whenever
    the Microsoft Office application starts. For more details, see [http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key-part-10/](http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key-part-10/)
    and [https://researchcenter.paloaltonetworks.com/2016/07/unit42-technical-walkthrough-office-test-persistence-method-used-in-recent-sofacy-attacks/](https://researchcenter.paloaltonetworks.com/2016/07/unit42-technical-walkthrough-office-test-persistence-method-used-in-recent-sofacy-attacks/).For
    further details on various persistence methods and to understand the adversary
    tactics and techniques, refer to MITRE’s ATT&CK wiki: [https://attack.mitre.org/wiki/Persistence](https://attack.mitre.org/wiki/Persistence).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可以在每次启动Microsoft Office应用程序时保持恶意代码的持久性并执行它。有关更多详细信息，请参见[http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key-part-10/](http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key-part-10/)和[https://researchcenter.paloaltonetworks.com/2016/07/unit42-technical-walkthrough-office-test-persistence-method-used-in-recent-sofacy-attacks/](https://researchcenter.paloaltonetworks.com/2016/07/unit42-technical-walkthrough-office-test-persistence-method-used-in-recent-sofacy-attacks/)。有关各种持久化方法的更多详细信息，并了解对手的战术和技术，请参考MITRE的ATT&CK维基：[https://attack.mitre.org/wiki/Persistence](https://attack.mitre.org/wiki/Persistence)。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Malware uses various API calls to interact with the system, and in this chapter,
    you learned how API calls are used by the malicious binary to implement various
    functionalities. This chapter also covered different persistent techniques used
    by the adversaries, which allow them to reside on the victim's system even after
    a system reboot (some of these techniques allow a malicious binary to execute
    code with high privileges).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用各种API调用与系统交互，在本章中，你学习了恶意二进制文件如何利用API调用实现各种功能。本章还涵盖了对手使用的不同持久化技术，这些技术使得恶意软件即使在系统重启后仍能驻留在受害者系统上（其中一些技术允许恶意二进制文件以高权限执行代码）。
- en: In the next chapter, you will learn about different code injection techniques
    used by the adversaries to execute their malicious code within the context of
    a legitimate process.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习对手使用的不同代码注入技术，这些技术用于在合法进程的上下文中执行恶意代码。
