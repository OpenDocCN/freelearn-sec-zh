- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Analyzing Android Malware Samples
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Android 恶意软件样本
- en: With the rise of mobile devices, the name Android has become well-known to most
    people, even to those far from the IT world. It was originally developed by Android
    Inc. and later acquired by Google in 2005\. The Android name is derived from the
    nickname of the founder of the company, Andy Rubin. This open source operating
    system is based on a modified version of the Linux kernel and there are several
    variants of it, such as Wear OS for wearable devices, and Android TV, which can
    be found on multiple smart TVs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备的兴起，Android 这个名字已经为大多数人熟知，甚至是那些远离 IT 世界的人。它最初由 Android Inc. 开发，并在 2005
    年被谷歌收购。Android 这个名字源自公司创始人安迪·鲁宾（Andy Rubin）的昵称。这个开源操作系统基于修改版的 Linux 内核，并且有多个变种，如用于可穿戴设备的
    Wear OS 和可以在多款智能电视上找到的 Android TV。
- en: As mobile devices store and can provide access to more and more sensitive information,
    it’s no surprise that mobile platforms are increasingly becoming targets for attackers
    who are exploring ways to leverage their power for malicious purposes. In this
    chapter, we are going to dive into the internals of the most popular mobile operating
    system in the world, explore existing and potential attack vectors, and provide
    detailed guidelines on how to analyze malware targeting Android users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备存储并能提供越来越多敏感信息，移动平台逐渐成为攻击者的目标，这也就不足为奇了。攻击者正在探索如何利用这些平台的力量来进行恶意活动。本章将深入探讨全球最受欢迎的移动操作系统的内部机制，分析现有和潜在的攻击向量，并提供如何分析针对
    Android 用户的恶意软件的详细指南。
- en: 'To facilitate learning, this chapter is divided into the following main sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于学习，本章分为以下几个主要部分：
- en: (Ab)using the Android internals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （滥用）Android 内部机制
- en: Understanding Dalvik and ART
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Dalvik 和 ART
- en: File formats and APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件格式和 API
- en: Malware behavior patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件行为模式
- en: Static and dynamic analysis of threats
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对威胁的静态与动态分析
- en: Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: (Ab)using the Android internals
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （滥用）Android 内部机制
- en: Before analyzing the actual malware, let’s become familiar with the system itself
    first and understand the principles it is based on. This knowledge is vital when
    performing analysis, as it allows the engineer to better understand the logic
    behind malicious code and not miss any important part of its functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析实际的恶意软件之前，让我们先了解系统本身，并理解其所基于的原理。这些知识在进行分析时至关重要，因为它可以帮助工程师更好地理解恶意代码背后的逻辑，并确保不会错过其功能中的任何重要部分。
- en: The file hierarchy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件层次结构
- en: As Android is based on the modified Linux kernel, its file structure resembles
    the one that can be found in various Linux distributions. The file hierarchy is
    a single tree, with the top of it called the root directory or root (generally
    specified with the `/` symbol), and multiple standard Linux directories, such
    as `/proc`, `/sbin`, and others. The Android kernel is shipped with multiple supported
    filesystems; the exact selection varies depending on the version of the OS and
    the device’s manufacturer. It has used EXT4 as the default main filesystem since
    Android 2.3, but prior to that, YAFFS was used. External storage and SD cards
    are usually formatted using FAT32 to maintain compatibility with Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 基于修改过的 Linux 内核，因此其文件结构与各种 Linux 发行版中的结构相似。文件层次结构是一个单一的树形结构，顶端称为根目录或根（通常使用
    `/` 符号表示），并且包含多个标准的 Linux 目录，例如 `/proc`、`/sbin` 等。Android 内核配备了多种支持的文件系统，具体选择取决于操作系统的版本和设备的制造商。从
    Android 2.3 开始，默认主文件系统为 EXT4，但在此之前，使用的是 YAFFS。外部存储和 SD 卡通常采用 FAT32 格式，以保持与 Windows
    的兼容性。
- en: 'In terms of the specifics of the directory structure, the official Android
    documentation defines the following data storage options:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就目录结构的具体细节而言，官方 Android 文档定义了以下数据存储选项：
- en: '`/data/data/` directory and its symlink, the `/data/user/0` directory.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data/` 目录及其符号链接，即 `/data/user/0` 目录。'
- en: Its main purpose is to securely store files privately from apps. What this means
    is that no other apps, or even the user, have direct access to them. Each app
    gets its own folder, and if the user uninstalls the application, all its content
    will be deleted. Thus, the usual applications don’t store anything that should
    persist independently of them here (for example, photos taken by a user with an
    app’s help). Later, we will see what the corresponding behavior of malicious apps
    is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要目的是安全地将文件存储在应用的私有空间中。也就是说，其他任何应用程序，甚至用户，都无法直接访问它们。每个应用都有自己的文件夹，如果用户卸载该应用，其所有内容将被删除。因此，通常的应用程序不会在这里存储任何应独立于它们持久化的内容（例如，用户通过应用拍摄的照片）。接下来，我们将看到恶意应用程序的相应行为。
- en: '`/storage/emulated/0` path. In this case, `/storage/self/primary` is a main
    symlink to it, which, in turn, has `/sdcard` and `/mnt/sdcard` symlinks pointing
    to it. `/mnt/user/0/primary` is another common symlink pointing to `/storage/emulated/0`.
    This space is shared across all apps and is world-readable, including for the
    end user. This is where users see well-known folders such as `Downloads` or `DCIM`.
    For the apps themselves, its presence is not actually guaranteed, so its availability
    should be checked each time that it is accessed. In addition, apps have the option
    to have their own app-specific directory (in case they need more space), which
    will be deleted with the app once it is uninstalled. The main location for this
    data on modern forms of Android is `/storage/emulated/0/Android/data/<app_name>`.
    Again, this location is world-accessible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/storage/emulated/0` 路径。在这种情况下，`/storage/self/primary` 是其主要符号链接，反过来，它有指向它的
    `/sdcard` 和 `/mnt/sdcard` 符号链接。`/mnt/user/0/primary` 是另一个指向 `/storage/emulated/0`
    的常见符号链接。这个空间是所有应用共享的，且是全局可读的，包括终端用户。这是用户看到如 `Downloads` 或 `DCIM` 等常见文件夹的位置。对于应用程序本身来说，实际上并不能保证它的存在，因此每次访问时都应检查它的可用性。此外，应用程序可以选择拥有自己专用的目录（如果它们需要更多空间），一旦应用程序被卸载，这些目录也会被删除。现代
    Android 系统中此数据的主要位置是 `/storage/emulated/0/Android/data/<app_name>`。再次强调，这个位置是全球可访问的。'
- en: In addition, the documentation describes shared preferences and databases, which
    are outside the scope of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文档还描述了共享首选项和数据库，这些内容超出了本书的范围。
- en: 'There may be a considerable level of confusion here in terms of naming, as
    many file-manager apps call the external file storage internal when they want
    to distinguish it from SD cards (which are treated by the OS in pretty much the
    same way as the embedded phone’s external storage). The truth is, unless the device
    is rooted, the internal storage can’t be accessed and therefore won’t be visible
    to a normal user:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有一定程度的混淆，因为许多文件管理应用将外部存储称为内部存储，以便将其与 SD 卡区分开（SD 卡在操作系统中的处理方式与嵌入式手机的外部存储几乎相同）。事实上，除非设备已经获得
    root 权限，否则内部存储是无法访问的，因此普通用户是无法看到它的：
- en: '![Figure 13.1 – The file manager referring to external storage as internal'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 文件管理器将外部存储视为内部存储'
- en: '](img/Figure_13.1_B18500.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B18500.jpg)'
- en: Figure 13.1 – The file manager referring to external storage as internal
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 文件管理器将外部存储视为内部存储
- en: 'Apart from this, here are some of the other important file paths unique to
    Android:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，以下是一些其他对 Android 独有的重要文件路径：
- en: '`/data/app` and its modern symlink, `/factory`: Contains APK and ODEX files
    for installed apps.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/app` 及其现代符号链接 `/factory`：包含已安装应用的 APK 和 ODEX 文件。'
- en: '`/data/dalvik-cache`: The optimized bytecode for installed apps.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/dalvik-cache`：已安装应用的优化字节码。'
- en: '`/system`: This is the location of the operating system itself. It contains
    directories that are normally found in the root directory.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system`：这是操作系统本身的所在位置。它包含通常在根目录中找到的目录。'
- en: '`/vendor`: A symbolic link to `/system/vendor`. This path contains vendor-specific
    files.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/vendor`：指向 `/system/vendor` 的符号链接。这个路径包含厂商特定的文件。'
- en: '`/system/app/`: Contains pre-installed Android system apps, for example, to
    interact with the camera or messages.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/app/`：包含预安装的 Android 系统应用，例如用于与相机或消息进行交互。'
- en: '`/data/local/tmp/`: A directory where temporary files can be stored.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/local/tmp/`：一个可以存储临时文件的目录。'
- en: '![Figure 13.2 – Android’s root directory'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – Android 的根目录'
- en: '](img/Figure_13.2_B18500.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B18500.jpg)'
- en: Figure 13.2 – Android’s root directory
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Android 的根目录
- en: Later, we will see which paths malware generally uses during the deployment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到恶意软件在部署过程中通常使用的路径。
- en: The Android security model
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 安全模型
- en: There are multiple mechanisms implemented in Android in order to complicate
    the lives of attackers. The system has evolved gradually over time and the latest
    versions differ quite significantly from the earlier editions in terms of security.
    In addition, modern Android systems are based on the newer Linux kernel 4.x+ starting
    from version 7.0\. Let’s talk about some of the most important aspects of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了多种机制来复杂化攻击者的操作。该系统随着时间的推移逐渐发展，最新版本在安全性方面与早期版本有显著区别。此外，现代 Android
    系统从 7.0 版本开始基于更新的 Linux 内核 4.x+。让我们讨论一些最重要的方面。
- en: Process management
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程管理
- en: Android implements **Mandatory Access Control** (**MAC**) over all processes
    and uses the **Security-Enhanced Linux** (**SELinux**) model to enforce it. SELinux
    is based on the deny-by-default principle, where everything that is not explicitly
    allowed is forbidden. Its implementation has evolved over different versions of
    Android; the enforcing mode was enabled in Android 5.0.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了**强制访问控制**（**MAC**），并使用**增强安全 Linux**（**SELinux**）模型来执行它。SELinux
    基于默认拒绝原则，即一切没有明确允许的行为都是禁止的。其实现已经随着 Android 的不同版本而发展；在 Android 5.0 中启用了强制模式。
- en: 'On Android, each app runs as an individual process and its own user is created.
    This is how process sandboxing is implemented: to ensure that no process can access
    the data of another one. An example of the generated username in this case is
    `u2_a84`, where `2` is the actual user ID, with the offset `100000` (the actual
    value will be `100002`), and `84` is the app ID, with the offset `10000` (which
    means the value itself is `10084`). The mappings between apps and their corresponding
    user IDs can be found in the `/data/system/packages.xml` file (see the `userId`
    XML attribute), as well as in the matching, more concise `packages.list` file.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，每个应用程序作为独立进程运行，并会创建自己的用户。这就是进程沙盒的实现方式：确保没有进程能够访问另一个进程的数据。在这种情况下，生成的用户名示例是`u2_a84`，其中`2`是实际用户
    ID，偏移量为`100000`（实际值为`100002`），`84`是应用程序 ID，偏移量为`10000`（即值本身为`10084`）。应用与其对应用户
    ID 之间的映射可以在`/data/system/packages.xml`文件中找到（参见`userId` XML 属性），以及在更简洁的`packages.list`文件中找到。
- en: 'In addition to actual users, Android has many system accounts with predefined
    IDs. Apart from `AID_ROOT` (0), which is used to run some native daemons, here
    are some other examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际用户，Android 系统中还有许多具有预定义 ID 的系统账户。除了用于运行一些原生守护进程的`AID_ROOT`（0）外，还有一些其他示例如下：
- en: '`AID_SYSTEM` (1000): This is a regular user account with special permissions
    to interact with system services.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_SYSTEM`（1000）：这是一个具有特殊权限的常规用户账户，用于与系统服务进行交互。'
- en: '`AID_VPN` (1016): This is associated with the **Virtual Private Network** (**VPN**)
    system.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_VPN`（1016）：与**虚拟私人网络**（**VPN**）系统相关。'
- en: '`AID_SHELL` (2000): This is the account the user gets when they use the `adb`
    tool with the `shell` argument.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_SHELL`（2000）：当用户使用`adb`工具并传递`shell`参数时，系统分配给用户的账户。'
- en: '`AID_INET` (3003): This can create `AF_INET` or `AF_INET6` sockets.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AID_INET`（3003）：此账户可以创建`AF_INET`或`AF_INET6`套接字。'
- en: A full, up-to-date list of these can be found in the `android_filesystem_config.h`
    file in the Android source code, which is easily accessible online.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些账户的完整且最新的列表可以在 Android 源代码中的`android_filesystem_config.h`文件中找到，该文件可以在线轻松访问。
- en: In order to support **Inter-Process Communication** (**IPC**), a dedicated **Binder**
    mechanism has been introduced. It provides a remote method invocation functionality,
    where all the communication between client and server apps passes through a dedicated
    device driver. Later, we will discuss how a single vulnerability in it allows
    attackers to elevate privileges in order to root the corresponding devices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持**进程间通信**（**IPC**），引入了一种专用的**Binder**机制。它提供了远程方法调用功能，其中所有客户端和服务器应用程序之间的通信都通过专用设备驱动程序进行。稍后我们将讨论如何通过它的一个漏洞使攻击者提升权限，从而使设备获取
    root 权限。
- en: The filesystem
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统
- en: As we now know, all generic user data and shared app data is stored in `/storage/emulated/0`.
    It is available for read and write access but setting executable permissions for
    files located there is not allowed. The idea here is that the user won’t be able
    to simply write to a disk and then execute a custom binary directly, even by mistake
    or as the result of a social engineering attack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知道的，所有通用用户数据和共享应用数据都存储在`/storage/emulated/0`中。该路径允许读写访问，但不允许为其中的文件设置可执行权限。这里的目的是，用户无法简单地将自定义二进制文件写入磁盘并直接执行，即使是无意间或作为社会工程攻击的结果。
- en: By contrast, each installed app has full access to its own directory in `/data/data`,
    but not to the directories of other apps unless they explicitly allow it. This
    is done so that one app won’t be able to affect the work of another one or get
    access to sensitive data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，每个已安装的应用程序都可以完全访问其在`/data/data`中的目录，但不能访问其他应用程序的目录，除非它们明确允许。这样做的目的是为了防止一个应用程序影响另一个应用程序的工作或访问敏感数据。
- en: App permissions
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序权限
- en: The main purpose of app permissions is to protect user privacy by giving them
    control over what data and system functionalities can be accessed by each application.
    By default, no app can affect the work of another app, unless it is explicitly
    allowed to do so; the same applies to accessing sensitive user data. Depending
    on the version of Android and the settings, some permissions may be granted automatically,
    while others will require manual user approval.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序权限的主要目的是通过让用户控制每个应用程序可以访问的数据和系统功能来保护用户隐私。默认情况下，任何应用程序都不能影响其他应用程序的工作，除非明确允许这样做；同样，访问敏感用户数据也适用此规则。根据Android的版本和设置，一些权限可能会自动授予，而其他则需要用户手动批准。
- en: The default behavior when requesting user consent depends on the Android version
    and the SDK version used to build the app. For Android 6.0+ and SDK version >=
    23, the user is not notified about it at installation time. Instead, the app has
    to ask permission at runtime using a standard system dialog window. For older
    Android and SDK versions, all permissions were requested at installation time.
    The user is presented with groups of permissions rather than individual entries;
    otherwise, it might be overwhelming to go through all of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请求用户同意的默认行为取决于所使用的Android版本和SDK版本。对于Android 6.0+及SDK版本>=23，安装时用户不会收到通知。相反，应用程序必须在运行时通过标准系统对话框窗口请求权限。对于较旧的Android版本和SDK版本，所有权限在安装时一次性请求。用户看到的是一组权限而不是单独的条目，否则逐一查看所有权限可能会感到不堪重负。
- en: 'Each app has to announce what permissions it requires in its embedded `manifest`
    file. For this purpose, dedicated `<uses-permission>` tags can be used. Permissions
    are split into three protection levels:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都必须在其嵌入的`manifest`文件中声明其所需的权限。为此，可以使用专门的`<uses-permission>`标签。权限分为三个保护级别：
- en: '`ACCESS_NETWORK_STATE`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_NETWORK_STATE`'
- en: '`BLUETOOTH`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLUETOOTH`'
- en: '`NFC`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NFC`'
- en: '`VIBRATE`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIBRATE`'
- en: '`BIND_AUTOFILL_SERVICE`*   `BIND_VPN_SERVICE`*   `WRITE_VOICEMAIL`*   `READ_CONTACTS`*   `WRITE_CONTACTS`*   `GET_ACCOUNTS`*   Location:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BIND_AUTOFILL_SERVICE`*   `BIND_VPN_SERVICE`*   `WRITE_VOICEMAIL`*   `READ_CONTACTS`*   `WRITE_CONTACTS`*   `GET_ACCOUNTS`*   位置：'
- en: '`ACCESS_FINE_LOCATION`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_FINE_LOCATION`'
- en: '`ACCESS_COARSE_LOCATION`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCESS_COARSE_LOCATION`'
- en: 'An example of the permissions requested by a sample in its manifest file can
    be seen in the following figure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示为清单文件中请求权限的示例：
- en: '![Figure 13.3 – An example of the permissions requested by malware in the manifest
    ﬁle'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 恶意软件在清单文件中请求的权限示例'
- en: '](img/Figure_13.3_B18500.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B18500.jpg)'
- en: Figure 13.3 – An example of the permissions requested by malware in the manifest
    ﬁle
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 恶意软件在清单文件中请求的权限示例
- en: It is worth mentioning that the list of permissions evolved over time, with
    multiple new permissions being enforced eventually, making the system more secure.
    The exact API version in which a particular permission was added (or deprecated)
    can be found in the most recent official Android documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，权限列表随着时间的推移不断发展，最终强制执行了多个新权限，从而提高了系统的安全性。特定权限添加（或弃用）的确切API版本可以在最新的官方Android文档中找到。
- en: Apart from this, there are also so-called special permissions that are distinct
    from normal or dangerous ones. They are particularly important, so an app should
    ask for user authorization, in addition to declaring them in the manifest file.
    Examples of such permissions are `SYSTEM_ALERT_WINDOW` and `WRITE_SETTINGS`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些所谓的特殊权限，它们与普通权限或危险权限不同。这些权限特别重要，因此应用程序除了在清单文件中声明它们之外，还应请求用户授权。此类权限的示例包括`SYSTEM_ALERT_WINDOW`和`WRITE_SETTINGS`。
- en: As different devices may have different hardware features, another manifest
    tag, `<uses-feature>`, was introduced. In this case, if the `android:required`
    attribute is set to `True`, then Google Play won’t allow that app to be installed
    on the device without the feature being supported by it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同设备可能具有不同的硬件特性，因此引入了另一个清单标签`<uses-feature>`。在这种情况下，如果`android:required`属性设置为`True`，则如果设备不支持该特性，Google
    Play将不允许在该设备上安装该应用。
- en: Security services
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全服务
- en: 'Multiple services have been introduced on the Android platform in order to
    improve the overall security structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台已推出多个服务，以改善整体安全结构：
- en: '**Android updates**: As long as vulnerabilities are being identified and fixed,
    users receive updates to improve reliability and security.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android 更新**：只要漏洞被识别并修复，用户就会收到更新，以提高可靠性和安全性。'
- en: '**Google Play**: Introduces several security features, such as application
    security scanning that aims to prevent malicious authors from uploading and promoting
    malicious software.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Play**：引入了多个安全功能，例如应用安全扫描，旨在防止恶意作者上传和推广恶意软件。'
- en: '**Google Play Protect**: A system that runs safety checks on apps downloaded
    from Google Play and checks the device for potentially malicious apps coming from
    other sources.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Play Protect**：一个对从 Google Play 下载的应用程序进行安全检查的系统，并检查设备是否存在来自其他来源的潜在恶意应用。'
- en: '**SafetyNet**: Provides several APIs, aiming to give apps that process sensitive
    data extra security-related information (for example, whether the current device
    is protected against known threats and whether the provided URL is safe).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SafetyNet**：提供多种 API，旨在为处理敏感数据的应用提供额外的安全相关信息（例如，当前设备是否能防御已知威胁，以及提供的 URL 是否安全）。'
- en: The console
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台
- en: 'By default, the console is not available on the device itself (`adb` is supposed
    to be used from another connected device). Thus, in order to get the ability to
    execute basic commands, users have to install third-party apps such as **Termux**
    or **Terminal Emulator**. The interface would look as follows on the mobile device:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制台在设备本身不可用（`adb` 应该在另一台连接的设备上使用）。因此，为了获得执行基本命令的能力，用户必须安装第三方应用程序，例如 **Termux**
    或 **Terminal Emulator**。在移动设备上的界面将如下所示：
- en: '![Figure 13.4 – Listing the ﬁles in a root directory using the Terminal Emulator
    app'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – 使用终端模拟器应用列出根目录中的文件'
- en: '](img/Figure_13.4_B18500.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B18500.jpg)'
- en: Figure 13.4 – Listing the ﬁles in a root directory using the Terminal Emulator
    app
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 使用终端模拟器应用列出根目录中的文件
- en: In this case, advanced commands can be used only on the rooted device with **BusyBox**
    or similar sets of tools installed separately.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有在已 root 的设备上并且安装了 **BusyBox** 或类似工具集时，才能使用高级命令。
- en: Now, let’s talk about rooting in greater detail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地讨论一下 root。
- en: To root or not to root?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要进行 root 还是不进行 root？
- en: Every once in a while, users may encounter applications that require their device
    to be rooted. What exactly does this mean and how does this process actually work?
    In this section, we will explore the security mechanisms implemented within different
    Android versions and how they can be bypassed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户偶尔会遇到需要设备进行 root 的应用程序。这到底意味着什么，这个过程是如何运作的呢？在这一部分，我们将探讨不同 Android 版本中实施的安全机制以及如何绕过它们。
- en: If the user requires some functionality not supported by standard system APIs
    (for example, removing certain pre-installed applications or carrier applications,
    overclocking the CPU, or completely replacing the OS), the only option they have
    – apart from creating a feature request – is to obtain root access through a known
    vulnerability. As a result, the user gets elevated privileges and full control
    over the system. The legality of this process varies depending on the country,
    but generally, it is either unclear (which means it falls into a gray area), acceptable
    for non-copyright-related activity, or regulated by some dedicated exemptions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要一些标准系统 API 不支持的功能（例如，删除某些预装应用或运营商应用、超频 CPU 或完全替换操作系统），他们唯一的选择——除了提交功能请求——就是通过已知漏洞获取
    root 权限。这样，用户就能获得提升的权限并完全控制系统。这个过程的合法性因国家而异，但通常情况下，要么不明确（意味着处于灰色地带），要么对于与版权无关的活动是可以接受的，或者由一些专门的豁免进行规范。
- en: 'Sometimes, the rooting process is used interchangeably with jailbreaking, generally
    applied to iOS devices. However, these are different procedures in terms of scope.
    Jailbreaking is the process of bypassing several different types of end-user restrictions;
    the main ones are listed here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，root 过程与越狱过程交替使用，一般适用于 iOS 设备。然而，这两者在范围上是不同的。越狱是绕过多种不同类型的最终用户限制的过程；主要的限制列举如下：
- en: The ability to modify and replace the operating system (controlled by the locked
    bootloader technology on iOS)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改和替换操作系统的能力（由 iOS 上的锁定启动加载器技术控制）
- en: Installing non-official applications (sideloading)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装非官方应用程序（侧载）
- en: Obtaining elevated privileges (what is usually known as rooting)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取提升的权限（通常称为root）
- en: Unlike iOS, on Android, it is possible to officially enable sideloading, and
    many devices are shipped with bootloaders unlocked, so only rooting remains an
    issue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS不同，Android上可以正式启用侧加载，且许多设备出厂时解锁了引导加载程序，因此只有root权限仍然是一个问题。
- en: 'Each time a new rooting-related vulnerability becomes known, the developers
    are expected to fix it and either release a security patch or make the next version
    of the OS more secure. Thus, researchers have to come up with a new vulnerability
    to exploit in order to make rooting possible. Some rooting methods involve using
    `adb`, while others can be executed with the help of the usual user interface.
    Here are some of the most well-known privilege escalation exploits for Android
    OS:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的与root相关的漏洞被发现时，开发人员需要修复它，并发布安全补丁或使操作系统的下一个版本更加安全。因此，研究人员必须想出新的漏洞来利用，从而实现root。一些root方法涉及使用`adb`，而其他方法则可以通过普通的用户界面执行。以下是一些最著名的Android操作系统特权升级漏洞：
- en: '![](img/Table_13.1_B18500.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.1_B18500.png)'
- en: Rooting is accompanied by security risks for end users, as in this case, they
    are no longer protected by system-embedded security mechanisms and restrictions.
    A common way to get root privileges is to place a standard Linux `su` utility,
    which can grant the required privileges to custom files, in an accessible location
    and use it on demand. Malware can check whether this tool is already available
    on the compromised device and misuse it at its discretion without any extra work
    being required.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Root操作伴随着终端用户的安全风险，因为此时用户不再受到系统内嵌的安全机制和限制的保护。获得root权限的常见方法是将标准Linux `su` 工具放置在一个可访问的位置，该工具能够为自定义文件授予所需权限，并按需使用。恶意软件可以检查该工具是否已在受损设备上存在，并可以在不需要额外操作的情况下任意滥用它。
- en: 'Many Android malware families are also bundled with rooting software in order
    to elevate privileges on their own. There are multiple reasons why root access
    is beneficial to malware authors; particularly, it allows them to obtain the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Android恶意软件家族还与root软件捆绑在一起，以便自行提升权限。root访问对恶意软件作者有多个好处，特别是它使他们能够获取以下内容：
- en: Access to crucial data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问重要数据
- en: Improved persistence capabilities
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的持久性能力
- en: Hiding capabilities
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏能力
- en: 'Examples of these kinds of malware families include:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的恶意软件家族的示例包括：
- en: '**Dvmap**: Uses root privileges to modify system libraries for persistence
    and privilege escalation'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dvmap**：利用root权限修改系统库以实现持久化和特权升级'
- en: '**Zeahache**: Escalates privileges and opens a back door for other modules
    to enter the compromised system'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zeahache**：提升权限并为其他模块打开后门，允许它们进入受损的系统'
- en: '**Guerrilla**: Here, root privileges are required to access a user’s Google
    Play tokens and credentials and gain the ability to interact with the store directly,
    installing and promoting other apps'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Guerrilla**：在这里，需要root权限才能访问用户的Google Play令牌和凭证，并获得与商店直接交互的能力，从而安装和推广其他应用程序'
- en: '**Ztorg**: Escalates privileges, mainly to achieve better stealth and aggressively
    display ads'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ztorg**：提升权限，主要目的是实现更好的隐蔽性，并积极展示广告'
- en: '**CopyCat**: Infects Android’s **Zygote** process (a template for other processes)
    and loads itself into other processes to access and alter sensitive information'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CopyCat**：感染Android的**Zygote**进程（其他进程的模板），并将自己加载到其他进程中以访问和更改敏感信息'
- en: '**Tordow**: Steals sensitive information such as credentials from browsers'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tordow**：窃取浏览器中的敏感信息，如凭证'
- en: It is worth mentioning that not all malware families implement rooting, as it
    also increases the probability of being detected by antivirus solutions or damaging
    the device. In the end, it is up to the authors whether the advantages associated
    with it outweigh the risks, all depending on the purpose of malware.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，并非所有恶意软件家族都实现root，因为它也增加了被杀毒软件检测到或损坏设备的概率。最终，是否使用root取决于作者，关键看其目的是否使得这些优点超过风险。
- en: As we now have some basic understanding of how Android works, it’s time to dive
    deeper into its internals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Android的基本工作原理有所了解，是时候深入研究其内部机制了。
- en: Understanding Dalvik and ART
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Dalvik和ART
- en: The Android OS has evolved drastically over the past several years in order
    to address user and industry feedback, making it more stable, fast, and reliable.
    In this section, we will explore how the file execution process was implemented
    and progressed. In addition, we will dig into various original and newer file
    formats and learn how the Android executables are actually working.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应用户和行业的反馈，Android 操作系统在过去几年中发生了巨大的变化，使其变得更加稳定、快速和可靠。在本节中，我们将探讨文件执行过程是如何实现和发展的。此外，我们将深入研究各种原始和更新的文件格式，并了解
    Android 可执行文件的实际工作方式。
- en: Dalvik VM (DVM)
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dalvik 虚拟机（DVM）
- en: The **Dalvik VM** (**DVM**) was an open source process virtual machine used
    in Android up to version 4.4 (KitKat). It got its name from the village Dalvík
    in Iceland. The DVM implemented register-based architecture, which differs from
    stack-based architecture VMs such as Java VMs. The difference here is that stack-based
    machines use instructions to load and manipulate data on the stack and generally
    require more instructions than register machines in order to implement the same
    high-level code. By contrast, analogous register machine instructions must often
    define the register values used (which is not the case for stack-based machines,
    as the order of values on the stack is always known and the operands can be addressed
    implicitly by the stack pointer), so they tend to be bigger.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dalvik 虚拟机**（**DVM**）是一个开源的进程虚拟机，曾用于 Android 直到 4.4 版本（KitKat）。它的名字来自冰岛的
    Dalvík 村。DVM 实现了基于寄存器的架构，这与基于栈的架构虚拟机（如 Java 虚拟机）不同。这里的区别在于，基于栈的虚拟机使用指令来加载和操作栈上的数据，通常需要比寄存器机器更多的指令来实现相同的高级代码。相比之下，类似的寄存器机器指令通常必须定义所使用的寄存器值（而栈基机器则不需要，因为栈上的值的顺序始终已知，操作数可以通过栈指针隐式寻址），因此这些指令通常更大。'
- en: Usually, Dalvik programs are written in the `dx` is used, which converts Java
    class files into the **Dalvik Executable** (**DEX**) format. It is worth mentioning
    that multiple class files can be converted into a single DEX file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Dalvik 程序是用 `dx` 工具编写的，该工具将 Java 类文件转换为 **Dalvik 可执行文件**（**DEX**）格式。值得一提的是，多个类文件可以被转换为一个单独的
    DEX 文件。
- en: Once DEX files are created, they can be combined together with resources and
    code native to the `dexopt` tool, producing the **Optimized DEX** (**ODEX**) file,
    which is interpreted by the DVM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了 DEX 文件，它们可以与资源和本地代码一起通过 `dexopt` 工具进行合并，生成 **优化 DEX**（**ODEX**）文件，该文件由
    DVM 解释执行。
- en: Starting from Android 2.2, the **Just-In-Time** (**JIT**) compiler was introduced
    for Dalvik. The way it works is that it continually profiles applications on every
    run and dynamically compiles the most used blocks of bytecode into native machine
    code. However, independent benchmark tests have shown that stack-based the Java
    HotSpot VM was on average two to three times faster than the DVM (with enabled
    JIT) on the same device, with the Dalvik code not taking up less space either.
    In order to improve the overall performance and introduce more features, **Android
    Runtime** (**ART**) was created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 2.2 开始，引入了 **即时编译**（**JIT**）编译器用于 Dalvik。其工作原理是它在每次运行时持续分析应用程序，并动态地将最常用的字节码块编译成本地机器代码。然而，独立的基准测试显示，在同一设备上，启用
    JIT 的 Dalvik 相比栈基的 Java HotSpot VM 平均慢了两到三倍，且 Dalvik 代码的空间占用也没有减少。为了提高整体性能并引入更多功能，**Android
    运行时**（**ART**）应运而生。
- en: Android runtime (ART)
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 运行时（ART）
- en: ART was first introduced as an alternative runtime environment in Android 4.4
    (KitKat) and completely replaced Dalvik in the subsequent major release of Android
    5.0 (Lollipop).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ART 最早在 Android 4.4（KitKat）中作为替代运行时环境引入，并在随后的 Android 5.0（Lollipop）版本中完全替代了
    Dalvik。
- en: 'In order to explore the relationship between Dalvik and ART, let’s take a look
    at this diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 Dalvik 和 ART 之间的关系，我们来看一下这张图：
- en: '![Figure 13.5 – A diagram depicting the diﬀerences between Dalvik and ART (origin:
    Wikimedia Commons)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – 描述 Dalvik 和 ART 之间差异的图示（来源：Wikimedia Commons）'
- en: '](img/Figure_13.5_B18500.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B18500.jpg)'
- en: 'Figure 13.5 – A diagram depicting the diﬀerences between Dalvik and ART (origin:
    Wikimedia Commons)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 描述 Dalvik 和 ART 之间差异的图示（来源：Wikimedia Commons）
- en: As you can see, both Dalvik and ART share the same logic at the beginning, and
    operate with the same DEX and APK files to maintain backward compatibility. The
    major differences lie in how the files are actually processed and executed. Instead
    of interpreting DEX bytecode, ART translates it to machine code instructions in
    order to achieve better performance results. This way, instead of generating ODEX
    files at install time, ART compiles apps using the `dex2oat` tool to generate
    ELF files (already covered in the previous chapters) that contain native code.
    Originally, they also contained DEX code, but on modern Android systems, the DEX
    code is stored in dedicated **VDEX** files rather than inside the **OAT** files.
    This process is known as **Ahead-Of-Time** (**AOT**) compilation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Dalvik 和 ART 在开始时共享相同的逻辑，并使用相同的 DEX 和 APK 文件以保持向后兼容性。主要的区别在于文件实际如何处理和执行。ART
    并不像 Dalvik 那样解释 DEX 字节码，而是将其转换为机器码指令，以实现更好的性能。因此，ART 在安装时不会生成 ODEX 文件，而是通过 `dex2oat`
    工具编译应用程序生成包含本地代码的 ELF 文件（在前面章节中已经讲过）。最初，这些 ELF 文件也包含 DEX 代码，但在现代 Android 系统中，DEX
    代码被存储在专用的 **VDEX** 文件中，而不是存储在 **OAT** 文件内。这个过程被称为 **提前编译**（**AOT**）编译。
- en: 'Starting from Android 7.0 (Nougat), a JIT compiler complements AOT compilation
    and optimizes the code execution on the fly based on the profiler output. While
    JIT and AOT use the same compiler, the former is able to incorporate runtime information
    in order to achieve better results generally, for example, via improved inlining.
    The following is a diagram depicting the relationship between JIT and AOT:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 7.0（Nougat）开始，JIT 编译器补充了 AOT 编译，并根据分析器输出实时优化代码执行。虽然 JIT 和 AOT 使用相同的编译器，但前者能够在运行时利用信息，以便一般性地获得更好的结果，例如通过改进的内联。下面是一个图示，描述了
    JIT 和 AOT 之间的关系：
- en: '![Figure 13.6 – The process of compiling and executing ﬁles in ART (origin:
    source.android.com)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.6 – 在 ART 中编译和执行文件的过程（来源：source.android.com）'
- en: '](img/Figure_13.6_B18500.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B18500.jpg)'
- en: 'Figure 13.6 – The process of compiling and executing ﬁles in ART (origin: source.android.com)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 在 ART 中编译和执行文件的过程（来源：source.android.com）
- en: As you can see, if the AOT binary is available (which is not always the case),
    they are executed straight away, either from the JIT code cache (if it is JIT-compiled)
    or in the usual way. Otherwise, they are interpreted and optionally compiled by
    JIT, depending on how it is used throughout the system, in particular, whether
    it is used by other applications and whether it has a meaningful profile (profile
    files are recorded and created during the sample execution). The AOT compilation
    daemon also runs periodically and utilizes this information to (re)compile highly
    used files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果 AOT 二进制文件可用（但并非总是如此），它们会直接执行，无论是从 JIT 代码缓存中执行（如果是 JIT 编译的）还是按常规方式执行。否则，它们会被解释并根据系统的使用情况选择性地由
    JIT 编译，特别是是否被其他应用程序使用，以及是否具有有效的分析数据（分析文件在执行过程中记录并生成）。AOT 编译守护进程也会定期运行，并利用这些信息来（重新）编译高频使用的文件。
- en: Now, let’s dive deeper into Dalvik’s bytecode instruction set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨 Dalvik 的字节码指令集。
- en: The bytecode set
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码集
- en: As we now know, Dalvik is a register-based machine, which defines the syntax
    of bytecode. There are multiple instructions operating with registers in order
    to access and manipulate data. The total size of any instruction is a multiple
    of 2 bytes. All instructions are type-agnostic, which means that they don’t differentiate
    between the values of different data types as long as their sizes are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们现在所知，Dalvik 是一种基于寄存器的机器，它定义了字节码的语法。有多个指令通过寄存器进行操作，以访问和操作数据。任何指令的总大小都是 2 字节的倍数。所有指令都是与类型无关的，这意味着它们不会区分不同数据类型的值，只要它们的大小相同。
- en: 'Here are some examples of how they look in the official documentation. We’ll
    split them into several categories for easier navigation. The explanation of how
    to interpret the first column can be found after this table:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它们在官方文档中的一些示例。我们将它们分为几个类别，便于浏览。关于如何解读第一列的说明可以在该表格后找到：
- en: '**Data access and movement**:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问与传输**：'
- en: '![](img/Table_13.2(a)_B18500.jpg)![](img/Table_13.2(b)_B18500.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.2(a)_B18500.jpg)![](img/Table_13.2(b)_B18500.jpg)'
- en: '**Arithmetic operations**:![](img/Table_13.3(a)_B18500.jpg)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术操作**：![](img/Table_13.3(a)_B18500.jpg)'
- en: '![](img/Table_13.3(b)_B18500.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.3(b)_B18500.jpg)'
- en: '**Branching and calls**: As all instructions are multiples of 2 bytes, all
    branching instructions operate with words:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支和调用**：由于所有指令都是 2 字节的倍数，所有分支指令都以字为单位进行操作：'
- en: '![](img/Table_13.4(a)_B18500.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.4(a)_B18500.jpg)'
- en: '![](img/Table_13.4(b)_B18500.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.4(b)_B18500.png)'
- en: It is worth mentioning that some sets of instructions (for example, for optimized
    code) can be marked as unused in the official documentation, and it is quite unlikely
    they will be found in malware aiming to achieve the maximum coverage possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，某些指令集（例如，用于优化代码的指令）可能在官方文档中标记为未使用，且在旨在实现最大覆盖率的恶意软件中不太可能找到。
- en: Now, let’s examine the format notation used in the first column.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看第一列中使用的格式符号。
- en: The first byte is the opcode of the instruction (Dalvik utilizes only one-byte
    values (00-0xFF) to encode the instructions themselves). In the official documentation,
    some similar instructions are grouped into one row with the `range` they belong
    (“`..`” is used to define the range) specified in the first column and the mappings
    for the corresponding instructions provided in the second column.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字节是指令的操作码（Dalvik 只使用一个字节的值（00-0xFF）来编码指令）。在官方文档中，一些类似的指令被分组到一行中，`range` 指明它们所属的范围（“`..`”用来定义范围），并在第二列提供对应指令的映射。
- en: 'Supported instruction formats are described using a special format ID notation
    in the official documentation. Format IDs mostly consist of three characters –
    two digits and a letter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的指令格式在官方文档中使用特殊的格式 ID 符号表示。格式 ID 通常由三个字符组成——两个数字和一个字母：
- en: The first digit indicates the number of two-byte code units in the resulting
    bytecode (see the *Examples* column).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数字表示结果字节码中两字节代码单元的数量（参见 *Examples* 列）。
- en: The second digit specifies the maximum number of registers used (as some instructions
    support a variable number of them).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数字指定使用的寄存器的最大数量（因为一些指令支持可变数量的寄存器）。
- en: 'The final letter indicates the type of any extra data encoded by the format.
    Here is the official table describing these mnemonics:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个字母表示格式编码的额外数据类型。以下是描述这些助记符的官方表格：
- en: '![](img/Table_13.5_B18500.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.5_B18500.png)'
- en: 'Let’s use the first row of the first table as an example. Here, a `01 12x`
    value describing the `move v0, v1` instruction encoded using 2 bytes, `0110`,
    means the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以第一张表的第一行作为例子。在这里，描述 `move v0, v1` 指令的 `01 12x` 值，使用 2 字节 `0110` 编码，意味着以下内容：
- en: '`01` – the byte encoding the actual instruction (`0x01`).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01` – 编码实际指令的字节（`0x01`）。'
- en: '`12x` should be interpreted as three individual values:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`12x` 应该解释为三个单独的值：'
- en: '`1` – the size of the instruction (one word, 2 bytes in total: `0x01` and `0x10`)'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` – 指令的大小（一个字，2 字节，总共：`0x01` 和 `0x10`）'
- en: '`2` – the number of registers (two in total, `v0` and `v1`)'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` – 寄存器的数量（共两个，`v0` 和 `v1`）'
- en: '`x` – no extra data used here'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` – 这里不使用额外的数据'
- en: 'As for the prefixes for arguments used in the second column of the first table,
    this is what they mean:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一张表格第二列使用的参数前缀，它们的含义如下：
- en: The `v` symbol is used to mark the arguments that the name registers.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 符号用于标记寄存器名称的参数。'
- en: The `#+` prefix specifies arguments indicating a literal value.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#+` 前缀指定表示字面值的参数。'
- en: The `+` symbol is used for arguments that indicate a relative instruction address
    offset.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 符号用于表示相对指令地址偏移量的参数。'
- en: The `kind@` prefix indicates a constant pool kind (string, type, field, and
    so on).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind@` 前缀表示常量池类型（字符串、类型、字段等）。'
- en: A separate official document describes all the possible variants of format.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有一份单独的官方文档描述了所有可能的格式变体。
- en: 'Here is an example of how a sequence of Dalvik bytecode looks:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Dalvik 字节码序列的示例：
- en: '![Figure 13.7 – An example of disassembled Dalvik bytecode'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.7 – 反汇编的 Dalvik 字节码示例'
- en: '](img/Figure_13.7_B18500.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B18500.jpg)'
- en: Figure 13.7 – An example of disassembled Dalvik bytecode
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 反汇编的 Dalvik 字节码示例
- en: Overall, the related Android documentation is very detailed and easily accessible,
    so in case of doubt, it always makes sense to consult it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，相关的 Android 文档非常详细且易于访问，因此如果有疑问，最好参考文档。
- en: Now that we know how Android works, it’s time to go one level deeper and understand
    the main file formats used in its apps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Android 的工作原理，是时候更深入一步，了解其应用程序中使用的主要文件格式。
- en: File formats and APIs
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件格式和 API
- en: Here are the most important file formats associated with applications written
    for different versions of Android.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与为不同版本Android编写的应用程序相关的最重要的文件格式。
- en: DEX
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DEX
- en: 'The DEX format holds a set of class definitions and associated data. The file
    layout is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: DEX格式包含一组类定义和相关数据。文件布局如下：
- en: '![](img/Table_13.6(a)_B18500.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.6(a)_B18500.jpg)'
- en: '![](img/Table_13.6(b)_B18500.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_13.6(b)_B18500.png)'
- en: 'The rest of the fields define the sizes and offset of other data blocks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其余字段定义了其他数据块的大小和偏移量：
- en: '![Figure 13.8 – A DEX header with the fields described in detail'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8 – 详细描述字段的DEX头文件'
- en: '](img/Figure_13.8_B18500.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B18500.jpg)'
- en: Figure 13.8 – A DEX header with the fields described in detail
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 详细描述字段的DEX头文件
- en: The header starts with an 8-byte `DEX_FILE_MAGIC` value that consists of a `dex`
    string (`\x64\x65\x78`) followed by the newline symbol (`\x0a`), the 3 bytes defining
    the format version, and finally a zero byte (`\x00`). This format aims to provide
    a way to identify DEX files and the corresponding layout used, and to prevent
    basic data corruption.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件以一个8字节的`DEX_FILE_MAGIC`值开始，该值由一个`dex`字符串（`\x64\x65\x78`）后跟换行符（`\x0a`）、定义格式版本的3个字节，最后是一个零字节（`\x00`）组成。此格式旨在提供一种识别DEX文件及其使用的相应布局的方法，并防止基本的数据损坏。
- en: ODEX
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ODEX
- en: 'Actively used before the appearance of ART, ODEX files are the result of the
    optimizations made to DEX on the device in order to improve performance and decrease
    the result size. ODEX files consist of the already described DEX layout, wrapped
    with a short ODEX header:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在ART出现之前广泛使用的ODEX文件是对设备上DEX进行优化的结果，目的是提高性能并减少结果文件大小。ODEX文件由已描述的DEX布局组成，并加上一个简短的ODEX头文件：
- en: '[PRE0]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The header `magic` value is the same as for DEX but features a slightly different
    first 3-byte signature, `dey` (`\x64\x65\x79`), rather than `dex`. This format
    is defined in the `DexFile.h` source code file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`magic`头文件的值与DEX相同，但其前三个字节的签名略有不同，使用`dey`（`\x64\x65\x79`），而不是`dex`。此格式在`DexFile.h`源代码文件中定义。'
- en: OAT
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAT
- en: OAT files aimed to replace ODEX in the newer ART environment. To begin with,
    file extensions shouldn’t be trusted when dealing with Android executables. In
    particular, on recent Android systems, files with the `.dex`, `.odex,` and `.oat`
    extensions may actually implement the OAT format. It is not very well-documented
    and varies for different versions of Android, but the most important thing here
    is that the result data is wrapped in ELF shared objects. Starting from Android
    Oreo, OAT files don’t store DEX code, leaving it to VDEX files, and are used mainly
    to store mapping information and the native code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: OAT文件旨在替代新ART环境中的ODEX。首先，在处理Android可执行文件时，不应仅仅依赖文件扩展名。特别是在近期的Android系统上，`.dex`、`.odex`和`.oat`扩展名的文件实际上可能实现了OAT格式。该格式文档并不完善，并且在不同版本的Android中有所不同，但最重要的一点是，结果数据被封装在ELF共享对象中。从Android
    Oreo开始，OAT文件不再存储DEX代码，而是将其交给VDEX文件，主要用于存储映射信息和本地代码。
- en: VDEX
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VDEX
- en: These files were introduced in newer versions of Android (starting from Android
    Oreo) and are created by the `dex2oat` tool. The idea here is to store DEX code
    independently, not inside the OAT structure, with some additional metadata to
    speed up verification. As with OAT, the file format is not documented and changes
    between different versions of Android. Its description can be found in Android’s
    `vdex_file.h` source code file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是在新版Android中引入的（从Android Oreo开始），并由`dex2oat`工具创建。其思路是将DEX代码独立存储，而不是存储在OAT结构中，并附加一些元数据以加速验证。与OAT一样，该文件格式未公开文档，并且在不同版本的Android中有所变化。其描述可以在Android的`vdex_file.h`源代码文件中找到。
- en: Apart from this, a new internal ART format called `cdex`. The most up-to-date
    description can be found in the `compact_dex_file.h` source code file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种新的内部ART格式，称为`cdex`。最新的描述可以在`compact_dex_file.h`源代码文件中找到。
- en: ART
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ART
- en: These files contain internal representations of certain strings and classes
    listed in the APK for ART and are used to speed up the application start. The
    common file extension used in this case is `.art`. As in the previous case, this
    file format is not documented and changes between different versions of Android.
    As it is generally not used by malware, we won’t go into greater detail here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件包含APK中列出的ART的某些字符串和类的内部表示，并用于加速应用程序启动。此情况下常用的文件扩展名为`.art`。与前面的情况一样，这种文件格式没有文档说明，并且在不同版本的Android中有所变化。由于它通常不被恶意软件使用，这里不再详细讨论。
- en: ELF
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ELF
- en: In addition to Android-specific file formats, it is also possible to execute
    general ELF files compiled for the corresponding architecture. Unlike Linux systems,
    which mostly rely on **glibc**, Android uses its own **Bionic C** library due
    to licensing issues. At the moment, x86 and ARM (both 32-bit and 64-bit) architectures
    are supported. Besides this, as has just been mentioned, it is also used to store
    OAT data blocks for optimized Android executables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Android 特有的文件格式外，还可以执行为相应架构编译的通用 ELF 文件。与主要依赖 **glibc** 的 Linux 系统不同，Android
    由于许可问题使用自己的 **Bionic C** 库。目前，支持 x86 和 ARM（32 位和 64 位）架构。除此之外，正如前面所提到的，它还用于存储优化过的
    Android 可执行文件的 OAT 数据块。
- en: The ELF format has already been covered in great detail in [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188),
    *Dissecting Linux and IoT Malware*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 格式已经在[*第 11 章*](B18500_11.xhtml#_idTextAnchor1188)《剖析 Linux 和物联网恶意软件》中详细讲解过。
- en: APK
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APK
- en: APK files are archive files based on the JAR format, which, as we know from
    [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946)*, Reversing Bytecode Languages
    – .NET, Java, and More*, implements the ZIP format. What this means is that APK
    files can be unpacked using any software supporting ZIP-compressed files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: APK 文件是基于 JAR 格式的归档文件，正如我们从[*第 9 章*](B18500_09.xhtml#_idTextAnchor946)《反编译字节码语言——.NET、Java
    和更多》知道的那样，它实现了 ZIP 格式。这意味着，APK 文件可以通过任何支持 ZIP 压缩文件的软件解压。
- en: 'Usually, APK files contain the following files:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，APK 文件包含以下文件：
- en: '`res`: This directory contains various resource files (such as XMLs and pictures).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`：此目录包含各种资源文件（如 XML 和图片）。'
- en: '`META-INF`: Stores metadata files associated with the package, mainly the following
    ones:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`META-INF`：存储与包相关的元数据文件，主要包括以下内容：'
- en: '`MANIFEST.MF`: A `manifest` file containing names and SHA1/SHA2 digests of
    files inside the APK'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANIFEST.MF`：一个`manifest`文件，包含 APK 内文件的名称和 SHA1/SHA2 摘要'
- en: '`<name>.RSA`: Contains the application’s signature and certificate'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>.RSA`：包含应用程序的签名和证书'
- en: '`<name>.SF`: Contains SHA1 or SHA2 digests of the corresponding lines in the
    `MANIFEST.MF` and the list of associated resources'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>.SF`：包含 `MANIFEST.MF` 中相应行的 SHA1 或 SHA2 摘要，以及相关资源的列表'
- en: '`AndroidManifest.xml`: The main `manifest` file defining various important
    app-related values for the system and Google Play. It is stored in human-unreadable
    format inside the APK. One of the easiest ways to decode it is by using **apktool**
    for extraction.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xml`：主要的`manifest`文件，定义了与系统和 Google Play 相关的各种重要应用程序值。它以人类无法读取的格式存储在
    APK 中。解码它的最简单方法之一是使用**apktool**进行提取。'
- en: '`classes.dex`: A compiled file containing the app’s DEX bytecode; there can
    be several of them with numbers added following this format: `classes<num>.dex`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classes.dex`：包含应用程序的 DEX 字节码的编译文件；可以有多个，文件名后附数字，格式为 `classes<num>.dex`。'
- en: '`resources.arsc`: This compiled file contains metadata associated with resources
    used by the app.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources.arsc`：此编译文件包含与应用程序使用的资源相关的元数据。'
- en: At the moment, Android doesn’t perform CA verification for application certificates,
    so self-signed certificates are allowed. Apart from this, other directories such
    as assets and files can also be commonly found inside APK files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Android 不对应用程序证书执行 CA 验证，因此允许使用自签名证书。除此之外，像 assets 和 files 等其他目录也常见于 APK
    文件中。
- en: 'Regarding `AndroidManifest.xml`, only the `<manifest>` and `<application>`
    elements are required to be present. Generally, the following data can be specified
    there:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `AndroidManifest.xml`，只有 `<manifest>` 和 `<application>` 元素是必需存在的。通常，以下数据可以在其中指定：
- en: Basic app information (such as the package name)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的应用程序信息（如包名）
- en: App components and the corresponding types (activity, service, broadcast receiver,
    or content provider)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序组件及其相应类型（活动、服务、广播接收器或内容提供者）
- en: Required permissions (see the corresponding section, *The Android security model*)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需的权限（参见相应章节《Android 安全模型》）
- en: Hardware and software features that the app needs
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序所需的硬件和软件特性
- en: Information about the supported Android SDK
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的 Android SDK 信息
- en: 'Unlike programs on many other systems, generally speaking, Android apps don’t
    necessarily have a single entry point, which means there is no main function.
    The sample’s main activities can be found by looking at the app’s `AndroidManifest.xml`
    file and searching for the components with the `android.intent.action.MAIN` value
    specified. Also check that if there is a class name mentioned in the `android:name`
    attribute of the `<application>` element (this name should represent a subclass
    of the `Application` class), it gets control first. Once found, search for the
    `onCreate` methods in these components – here is how they will look in disassembly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他系统上的程序不同，一般来说，Android 应用程序不一定具有单一的入口点，这意味着没有主函数。可以通过查看应用程序的 `AndroidManifest.xml`
    文件，搜索具有 `android.intent.action.MAIN` 值的组件来找到示例的主要活动。还需要检查 `<application>` 元素的
    `android:name` 属性中是否提到了类名（这个类名应代表 `Application` 类的子类），如果提到了，那么该类应首先获得控制权。一旦找到，接着搜索这些组件中的
    `onCreate` 方法——它们在反汇编中将会是这样的：
- en: '![Figure 13.9 – The onCreate method in the disassembled Android sample'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9 – 反汇编后的 Android 示例中的 onCreate 方法'
- en: '](img/Figure_13.9_B18500.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B18500.jpg)'
- en: Figure 13.9 – The onCreate method in the disassembled Android sample
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 反汇编后的 Android 示例中的 onCreate 方法
- en: Now that we have become familiar with the most common file formats used in Android,
    let’s talk about its APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Android 中最常用的文件格式，接下来让我们来讨论它的 API。
- en: APIs
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APIs
- en: 'Most of the code for the Android platform is written in Java, so the whole
    infrastructure is built on it. However, Android implements its own APIs in order
    to let programs interact with the OS to achieve their goals. While some classes
    might be quite similar to Java (for example, the `System` class), there are also
    a significant number of differences, such as the different meanings of certain
    properties (or properties that have lost their meaning). In addition, some introduced
    classes and APIs are new and aim to provide access to the unique features implemented
    in Android. An example is the `DexClassLoader` class, which loads classes from
    JAR and APK files and can be used to execute code that wasn’t part of an application.
    Here are some other examples of APIs and their classes, with self-explanatory
    names that can be commonly seen in malware:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台的大多数代码是用 Java 编写的，因此整个基础架构都是建立在 Java 上的。然而，Android 实现了自己的 API，以便让程序与操作系统交互以实现其目标。虽然某些类可能与
    Java 相似（例如，`System` 类），但也有许多不同之处，比如某些属性的含义不同（或有些属性失去了其原本的意义）。此外，一些新引入的类和 API 旨在提供对
    Android 中实现的独特功能的访问。例如，`DexClassLoader` 类，它从 JAR 和 APK 文件加载类，并可用于执行不属于应用程序的代码。以下是一些其他
    API 及其类的示例，这些类有着易于理解的名称，并且通常可以在恶意软件中看到：
- en: '`SmsManager`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SmsManager`'
- en: '`sendTextMessage`'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendTextMessage`'
- en: '`ActivityManager`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityManager`'
- en: '`GetRunningServices`'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRunningServices`'
- en: '`getRunningAppProcesses`'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningAppProcesses`'
- en: '`PackageManager`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageManager`'
- en: '`GetInstalledApplications`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetInstalledApplications`'
- en: '`getInstalledPackages`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstalledPackages`'
- en: '`DevicePolicyManager`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DevicePolicyManager`'
- en: '`LockNow`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LockNow`'
- en: '`reboot`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot`'
- en: '`Camera`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera`'
- en: '`TakePicture`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TakePicture`'
- en: '`DownloadManager`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadManager`'
- en: '`enqueue`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue`'
- en: '`DownloadManager.Request`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DownloadManager.Request`'
- en: '`setDestinationUri`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDestinationUri`'
- en: Some functionality can also be accessed through the use of a combination of
    the `Intent` class, with a particular argument describing the requested action,
    and the `Activity` class, to actually perform an action, generally using the `startActivityForResult`
    method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过组合使用 `Intent` 类（其中包含描述所请求操作的特定参数）和 `Activity` 类（实际执行操作，通常使用 `startActivityForResult`
    方法）来访问某些功能。
- en: Regarding the downloading-related functionality, many malware families obviously
    prefer to avoid using the standard download manager, as it tends to be more visible
    to the user, and instead implement it using Java classes such as `java.net.URL`
    and `java.net.URLConnection`. And, of course, as we know, some APIs require particular
    permissions to be requested prior to use. In this case, it should be at least
    `android.permission.INTERNET`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于下载相关的功能，许多恶意软件家族显然更倾向于避免使用标准下载管理器，因为它往往更容易被用户看到，而是使用 Java 类（如 `java.net.URL`
    和 `java.net.URLConnection`）来实现下载。当然，正如我们所知道的，某些 API 需要在使用之前请求特定的权限。在这种情况下，至少需要
    `android.permission.INTERNET` 权限。
- en: Now that we have learned how the files are structured as well as what APIs we
    need to pay attention to, it is time to focus on particular patterns commonly
    found in malware as well as the logic behind them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了文件的结构以及需要关注的 API，接下来是时候关注恶意软件中常见的特定模式以及其背后的逻辑了。
- en: Malware behavior patterns
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件行为模式
- en: Generally speaking, even though malware for mobile devices has its own nuances
    caused by the different environment and use cases of the targeted systems, many
    motivation patterns behind attacks stays the same as for PC platforms. In this
    section, we are going to dive deeper into various examples of mobile malware functionality
    and learn what methods it uses in order to achieve malevolent goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽管移动设备的恶意软件由于目标系统的不同环境和使用场景而具有其自身的细微差别，但攻击背后的动机模式与 PC 平台上的攻击模式大致相同。在本节中，我们将深入探讨各种移动恶意软件功能的例子，并了解它们为实现恶意目标所使用的方法。
- en: Now that we know how things are supposed to work, let’s take a look at how malware
    authors leverage them. Here, we will go through various attack stages common for
    the vast majority of malware, which will enable us to see these patterns in the
    analyzed samples and understand their purpose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些操作本该如何进行，让我们看看恶意软件作者是如何利用这些机制的。在这里，我们将通过对大多数恶意软件常见的各种攻击阶段进行分析，帮助我们在分析样本时识别这些模式，并理解它们的目的。
- en: Initial access
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始访问
- en: 'The most common ways malware gets access to devices are the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件获取设备访问权限的最常见方式如下：
- en: Google Play
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Play
- en: Third-party markets and sideloading
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方市场和旁加载
- en: Malicious ads and exploits
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意广告和漏洞利用
- en: 'In the first two cases, malware authors generally rely on social engineering,
    tricking users into installing a potentially useful app. There are many techniques
    used to make this possible, such as the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种情况下，恶意软件作者通常依赖社交工程，欺骗用户安装可能有用的应用。为此，使用了多种技术，以下是其中的一些：
- en: '**Similar design**: The app may look similar and have a similar name to some
    other well-known, legal application.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相似设计**：该应用可能与其他一些知名的合法应用在外观和名称上相似。'
- en: '**Fake reviews**: To make the app look authentic and not suspicious.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚假评论**：使应用看起来真实且不令人怀疑。'
- en: '**Anti-detection techniques**: To bypass automatic malware scanners and prolong
    the hosting.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反检测技术**：绕过自动恶意软件扫描器并延长托管时间。'
- en: '**Malicious update**: The original application uploaded to the store is clean,
    but its update contains hidden malicious functionality.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意更新**：上传到应用商店的原始应用是干净的，但其更新包含了隐藏的恶意功能。'
- en: '**Luring description**: Promises free or forbidden content, easy money, and
    so on.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**诱导描述**：承诺提供免费或禁忌内容、轻松赚钱等。'
- en: The app itself may be mostly legitimate but also contain hidden malicious functionality.
    There are multiple ways the user may come across them – by clicking fraudulent
    links received via messengers, texts, emails, or left on forums, or encountering
    it during searches for particular apps due to illegal **Search Engine Optimization**
    (**SEO**) techniques.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 应用本身可能大部分是合法的，但也可能包含隐藏的恶意功能。用户可能通过多种方式遇到这些应用——例如点击通过即时通讯、短信、电子邮件收到的欺诈链接，或在论坛上留下的链接，或者在搜索特定应用时由于非法的**搜索引擎优化**（**SEO**）技术而遭遇它们。
- en: Use of malicious ads involves delivering malicious code through the advertisement
    network with the help of exploits. An example could be **lbxslt**, an exploit
    leaked from HackingTeam and used by attackers to spread ransomware in 2017\. In
    addition, exploits may also be used for high-profile attacks targeting particular
    individuals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意广告的使用涉及通过广告网络传递恶意代码，并借助漏洞利用来实现。一个例子是**lbxslt**，这是2017年黑客团队泄露的一个漏洞，攻击者利用它传播勒索软件。此外，漏洞还可以用于针对特定个人的高调攻击。
- en: Privilege escalation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提权
- en: The next stage is to obtain all required permissions. Apart from the rooting
    options already discussed, it is possible for malware to abuse so-called administrative
    permissions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一阶段是获得所需的所有权限。除了已经讨论过的 root 权限外，恶意软件还可以滥用所谓的管理员权限。
- en: Originally designed for enterprise use cases to remotely administrate the mobile
    devices of employees, they can offer malware powerful capabilities, including
    the ability to wipe important data. Usually, the easiest way to get permissions
    is to keep asking the user and don’t stop until they are granted.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最初设计用于企业用例，远程管理员工的移动设备，它们可以为恶意软件提供强大的功能，包括擦除重要数据的能力。通常，获得权限的最简单方式是不断地请求用户，直到权限被授予为止。
- en: As long as all the required privileges are obtained, malware generally attempts
    to deploy its modules somewhere on a device. At this stage, extra modules can
    be downloaded after contacting the command and control server.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 只要获得了所有必要的权限，恶意软件通常会尝试将其模块部署到设备的某个位置。在此阶段，额外的模块可以通过联系命令和控制服务器后下载。
- en: Persistence
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: 'The most common places where malware installs itself once it gets executed
    are the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件执行后最常安装的位置通常包括以下几种：
- en: '`/data/data`: Standard paths intended to be used for all Android applications.
    This approach poses a threat to attackers, as it is relatively easy to remediate
    such threats.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data/data`：所有Android应用程序应使用的标准路径。此方法对攻击者构成威胁，因为相对容易修复此类威胁。'
- en: '`/system/(app|priv-app|lib|bin|xbin|etc)`: These paths require malware to use
    rooting exploits to get access to them. This makes it harder for the user to identify
    and delete the threat.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/(app|priv-app|lib|bin|xbin|etc)`：这些路径要求恶意软件使用root漏洞来访问它们，这使得用户更难识别并删除威胁。'
- en: Persistence in this case can be achieved using the standard Android `BroadcastReceiver`
    functionality common to all apps using the `BOOT_COMPLETED` action. The `RECEIVE_BOOT_COMPLETED`
    permission is required in this case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，持久性可以通过使用标准的Android `BroadcastReceiver` 功能来实现，这种功能在所有使用`BOOT_COMPLETED`操作的应用中都很常见。在这种情况下，`RECEIVE_BOOT_COMPLETED`权限是必需的。
- en: While many mass malware families follow similar patterns in order to achieve
    their goals, there is also a much smaller – but at the same time, often a more
    highly significant – set of examples implementing advanced techniques in order
    to achieve more specific goals. An example is APT groups performing high-profile
    espionage tasks and therefore having much higher requirements in terms of stealth
    and effectiveness. An example of the relevant malware family patching system libraries
    is `libdvm.so` and `libandroid_runtime.so`), injecting its code there. The libraries
    are supposed to execute a standard system executable with system privileges, which
    is replaced by the attackers to achieve persistence and escalate privileges at
    the same time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多大规模的恶意软件家族遵循类似的模式以实现其目标，但也存在一个较小——但同时通常更为重要——的例子集，它们采用先进技术来实现更为具体的目标。例如，APT组织执行高-profile间谍任务，因此对隐匿性和有效性有更高的要求。一个相关的恶意软件家族示例是修补系统库（如`libdvm.so`和`libandroid_runtime.so`），并在其中注入代码。这些库本应执行一个具有系统权限的标准系统可执行文件，但被攻击者替换，以实现持久性并同时提升权限。
- en: Impact
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: 'As long as the malware completed its installation, it can switch to the main
    purpose it was created for. The exact implementation will vary drastically depending
    on that. Here are some of the most common behaviors found in mass malware:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 只要恶意软件完成安装，它就可以切换到创建它的主要目的。具体的实施方式将根据目标而大不相同。以下是一些在大规模恶意软件中常见的行为：
- en: '**Premium SMS senders**: Probably the easiest way to make money straight away
    in mobile malware in certain countries is to send paid SMS messages to premium
    numbers (including the ones related to in-app purchases) or subscribing to paid
    services. Each of them will cost a certain amount of money, or an automatic subscription
    payment will be taken regularly, which eventually leads to draining the victim’s
    balance. In order to bypass CAPTCHA protection, existing anti-CAPTCHA services
    may be used.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**付费短信发送者**：在某些国家，利用移动恶意软件立即赚钱最简单的方法可能是向付费号码（包括与应用内购买相关的号码）发送付费短信，或者订阅付费服务。每次发送都需要一定的费用，或者会定期扣除自动订阅费用，最终导致受害者余额耗尽。为了绕过验证码保护，可能会使用现有的反验证码服务。'
- en: '**Clickers**: A more generic group of threats that uses mobile devices to make
    money in multiple different ways:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点击器**：一种更为通用的威胁类型，利用移动设备通过多种不同方式赚钱：'
- en: '**Ad clickers**: Simulates clicks on advertising websites without the user’s
    interaction, eventually draining money from advertising companies.'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告点击器**：模拟点击广告网站，无需用户交互，最终从广告公司获取资金。'
- en: '**WAP clickers**: This group is similar to SMS senders in the way that it uses
    another form of mobile payment, this time, by simulating clicks on WAP-billing
    web pages. The charge will be applied to the victim’s phone balance.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WAP点击器**：这个组与付费短信发送者类似，它使用另一种移动支付形式，这次是通过模拟点击WAP计费网页来收费。费用将被计入受害者的手机余额。'
- en: Clickers that increase traffic to websites for illegal SEO purposes; for example,
    to promote malicious apps.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加网站流量以进行非法SEO目的的点击器；例如，用于推广恶意应用程序。
- en: Clickers that leave fake reviews or change ratings of some apps and services.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 留下虚假评论或改变某些应用和服务评分的点击器。
- en: Clickers that buy expensive apps on Google Play, for example, using accessibility
    services to emulate user taps or implementing their own clients to interact with
    the store directly.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用辅助功能服务购买Google Play上的昂贵应用程序，例如，通过模拟用户点击或实现自己的客户端直接与商店互动。
- en: '**Adware**: These threats aim to monetize custom advertisements shown to users,
    often in an excessive and abusive way.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告软件**：这些威胁旨在通过向用户展示定制的广告来实现货币化，通常方式过度且具有侵扰性。'
- en: '**Infostealers**: As mobile devices often contain sensitive information, including
    saved credentials, photos, and private messages, it is also possible for malware
    authors to make money from stealing it, for example, by selling it on the underground
    market or extorting users. Another possible option here is cyber espionage.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息盗窃程序**：由于移动设备通常包含敏感信息，包括保存的凭证、照片和私人信息，恶意软件作者也可以通过窃取这些信息来赚钱，例如，通过将其出售给地下市场或勒索用户。另一个可能的选项是网络间谍活动。'
- en: '**Banking trojans**: Sometimes also named infostealers, this malware aims to
    steal users’ banking information to get access to their bank accounts, or manipulate
    payments. The most common ways to do this are by displaying fake windows simulating
    a real banking or popular booking app on top of the real one and letting the user
    enter their credentials there, or by using accessibility services to make the
    real app perform illegitimate transactions. Access to SMS messages on a device
    can be used to bypass the two-factor authentication introduced by some banks.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**银行木马**：有时也被称为信息盗窃程序，这种恶意软件旨在窃取用户的银行信息，以访问他们的银行账户或操控支付。最常见的做法是通过在真实银行或流行的预订应用上方显示伪造的窗口，模拟真实的应用程序并让用户在其中输入凭证，或使用辅助功能服务使真实应用执行非法交易。对设备上短信的访问可以用来绕过一些银行引入的双因素身份验证。'
- en: '**Ransomware**: As in the PC world, some malware families try to block access
    to certain files or a whole device to illegally push the users into paying a ransom
    in order to restore access. Quite often, this behavior is accompanied by statements
    that the affected user did something wrong (for example, watched illegal content),
    and demanding them to pay a fine, otherwise, the information will become public.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**勒索软件**：与PC世界一样，一些恶意软件家族试图阻止访问某些文件或整个设备，以非法迫使用户支付赎金以恢复访问权限。这种行为通常伴随着声明，指控受影响的用户做错了什么（例如，观看了非法内容），并要求他们支付罚款，否则信息将会公开。'
- en: '**DDoS**: Multiple infected mobile devices can generate enough traffic to cause
    significant load for the targeted websites.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式拒绝服务（DDoS）**：多个受感染的移动设备能够产生足够的流量，从而给目标网站带来显著的负载。'
- en: '**Proxy**: Quite rarely used alone, this functionality allows malicious actors
    to use infected devices as a free proxy to get access to particular resources
    and increase anonymity. An example of such a family is **Sockbot**.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：这种功能很少单独使用，它允许恶意行为者利用感染的设备作为免费代理，获取特定资源并增加匿名性。**Sockbot**就是一个这样的家族示例。'
- en: '**Cryptocurrency miners**: This group abuses a device’s calculation power in
    order to mine cryptocurrencies. While the CPU of each device might be not very
    powerful, a large amount of affected devices when put together can generate significant
    profit for attackers. For the affected user, it results in increased traffic usage,
    and the device slows down drastically and excessively heats up, which eventually
    may cause damage.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密货币挖矿程序**：这一类恶意软件滥用设备的计算能力来进行加密货币挖矿。虽然每台设备的CPU可能不是很强大，但当大量受感染设备汇聚在一起时，攻击者可以获得可观的利润。对于受影响的用户来说，这会导致流量使用增加，设备显著变慢并过度发热，最终可能会造成损坏。'
- en: Some trojans prefer to implement **backdoor** or **RAT** functionality and then
    deliver customizable modules in order to achieve flexibility in extending malware
    functionality.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些木马更倾向于实现**后门**或**RAT**功能，并通过交付可定制的模块来实现扩展恶意软件功能的灵活性。
- en: It is worth mentioning that not all malware families get their unique names
    based on the actual functionality. Quite often, a shared name describing its propagation
    method is used, for example, **Fakeapp**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，并非所有恶意软件家族的名称都基于其实际功能。通常会使用描述其传播方式的共享名称，例如**Fakeapp**。
- en: In terms of propagation, as malware can easily access a victim’s contacts, usually,
    the spreading mechanism involves sending links or samples to people the user knows
    via text, messengers, and email.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在传播方面，由于恶意软件可以轻松访问受害者的联系人，因此传播机制通常涉及通过短信、即时通讯软件和电子邮件向用户认识的人发送链接或样本。
- en: As for getting the actual money, at first, malware authors preferred to get
    it via premium SMS messages and local payment kiosks. Later, with the rise of
    cryptocurrencies, alternative options became an obvious choice for malicious authors
    due to anonymity and an easier setup process, providing users with detailed instructions
    on how to make a payment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 至于实际获取资金，最初，恶意软件作者更倾向于通过高级短信服务和本地支付终端来获取资金。后来，随着加密货币的兴起，由于其匿名性和更简便的设置过程，替代选项成为恶意作者的显而易见选择，并提供了详细的支付指导。
- en: Collection
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集
- en: Pure keylogging without screen capturing is not very common for Android malware.
    There are several reasons for this, starting with the fact that, in most cases,
    it is just not needed, and also because of the peculiarities of data input on
    mobile devices. Sometimes high-profile spying malware implements it in a pretty
    creative way. For example, it is possible to keep track of screen touches and
    match them against a pre-defined map of coordinates to deduce the keys pressed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 纯键盘记录而不进行屏幕捕捉在Android恶意软件中并不常见。原因有多种，首先在大多数情况下并不需要这样做，而且还因为移动设备上数据输入的特殊性。有时，一些高调的间谍恶意软件会以相当富有创意的方式实现此功能。例如，它可以跟踪屏幕上的触摸操作，并将其与预定义的坐标映射进行匹配，从而推断按下的键。
- en: An example of a family implementing it is **BusyGasper**, which is backdoor
    malware.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实施该机制的例子是**BusyGasper**，这是一种后门恶意软件。
- en: Defence evasion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御规避
- en: 'There are multiple anti-analysis techniques that mobile malware can incorporate
    in order to protect itself, including the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 移动恶意软件可以集成多种反分析技术以保护自己，包括以下几种：
- en: '**An inaccessible location**: A previously mentioned technique where malware
    uses rooting exploits to allow it to deploy itself in locations that are not accessible
    with standard user privileges. Another option is to overwrite existing system
    apps.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可访问的位置**：前面提到的技术，恶意软件通过利用Root漏洞，使自己能够部署在标准用户权限无法访问的地方。另一个选项是覆盖现有的系统应用程序。'
- en: '**Detecting privilege revocation**: Multiple techniques are used to scare the
    user when permissions are revoked in an attempt to prevent it.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测权限撤销**：当权限被撤销时，使用多种技术来吓唬用户，试图阻止其撤销操作。'
- en: '**Detecting antivirus solutions**: In this case, malware keeps looking for
    files associated with known antivirus products and once detected, may display
    a nag window asking for its uninstallation. These kinds of messages are shown
    in a loop and prevent the victim from using the device properly until the requested
    action is taken.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测杀毒软件**：在这种情况下，恶意软件会不断搜索与已知杀毒产品相关的文件，一旦检测到这些文件，可能会弹出一个提示窗口，要求卸载杀毒软件。这类消息会循环显示，直到受害者执行请求的操作，否则无法正常使用设备。'
- en: '**Emulator and sandbox detection**: Here, the malware checks whether it is
    being executed on the emulated environment or not. There are multiple ways it
    can be done: by checking the presence of certain system files or values inside
    them, such as IMEI and IMSI, build information, various product-related values,
    as well as the phone numbers used. In this case, malware behaves differently depending
    on the result to tamper with automatic and manual analysis. Another popular simple
    technique used to bypass basic sandboxes with an execution time limit is to sleep
    or perform benign actions for a certain period of time.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟器和沙盒检测**：在这种情况下，恶意软件检查其是否正在模拟环境中执行。可以通过多种方式进行检查：检查某些系统文件的存在或其中的值，例如IMEI和IMSI、构建信息、各种产品相关值，以及所使用的电话号码。在这种情况下，恶意软件会根据结果表现出不同的行为，从而干扰自动和手动分析。另一种常见的简单技巧是利用执行时间限制来绕过基本的沙盒，方法是让程序暂停或在一段时间内执行无害操作。'
- en: '**Icon hiding**: The idea here is that the user can’t easily uninstall the
    app using an icon. For example, a transparent image with no visible app name can
    be used.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标隐藏**：这里的想法是用户不能轻松地通过图标卸载应用程序。例如，可以使用一个透明图像且没有可见应用名称的图标。'
- en: '**Multiple copies**: Malware can install itself in various locations in the
    hope that some of them will be missed. In addition, infecting the Zygote process
    allows malware to create multiple copies in the memory.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重副本**：恶意软件可以将自身安装在多个位置，以期望有些副本能够逃过检测。此外，感染Zygote进程允许恶意软件在内存中创建多个副本。'
- en: '**Code packing or obfuscation**: As many Android programs are written in Java,
    the same code protection solutions can also be used here. Multiple commercial
    options are available on the market at the moment. This topic has already been
    covered in [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946), *Reversing Bytecode
    Languages – .NET, Java, and More*.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码打包或混淆**：由于许多安卓程序是用Java编写的，因此可以使用相同的代码保护解决方案。市场上目前有多个商业选项。这一主题已经在[*第9章*](B18500_09.xhtml#_idTextAnchor946)中讨论过，*反向工程字节码语言—.NET、Java及更多*。'
- en: In previous chapters, we covered state-of-the-art malware that aims to get more
    control over the operating system in order to perform more advanced tasks, such
    as hiding files and processes from monitoring software and amending data at a
    lower level. These approaches can be applied to mobile operating systems as well.
    While still not actively used by malware due to deployment complexity, there are
    several open source projects proving that it is possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了先进的恶意软件，这些恶意软件旨在获取更多对操作系统的控制，从而执行更复杂的任务，例如隐藏文件和进程以防止监控软件检测，或在较低层次修改数据。这些方法同样可以应用于移动操作系统。尽管由于部署的复杂性，恶意软件目前仍未广泛使用这些方法，但已有一些开源项目证明这在技术上是可行的。
- en: One of them is the `sys_call_table`. The final goal here is to hide the presence
    of a sample at a low level.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是`sys_call_table`。这里的最终目标是低层次地隐藏样本的存在。
- en: Now, it’s time to summarize everything we have learned so far and apply it to
    practice to be able to understand the functionality of Android malware samples.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候总结我们迄今为止所学的内容，并将其应用到实践中，以便能够理解安卓恶意软件样本的功能。
- en: Static and dynamic analysis of threats
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁的静态和动态分析
- en: At this stage, we have enough knowledge to start analyzing actual malware. For
    static analysis, the process and tools used will be mostly the same for different
    versions of the Android OS (regardless of whether it is based on the old DVM or
    new ART technology); the differences will be in the dynamic analysis techniques
    used. Now, it is time to get our hands dirty and become familiar with the tools
    that can facilitate this process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经掌握了足够的知识，开始分析实际的恶意软件。对于静态分析，使用的过程和工具在不同版本的安卓操作系统中大致相同（无论是基于旧的DVM还是新的ART技术）；区别主要体现在动态分析技术上。现在是时候动手实践，熟悉可以帮助我们完成这个过程的工具了。
- en: Static analysis
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: Generally, static analysis of bytecode malware involves either disassembling
    it and digging into the bytecode instructions or decompiling to the original language
    and exploring the source code. In many cases, the latter approach is preferable
    wherever possible, as reading the human-friendly code reduces the time the analysis
    takes. The former approach is often used when decompiling doesn’t work for whatever
    reason, such as a lack of up-to-date tools or because of anti-reverse-engineering
    techniques implemented in the sample.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字节码恶意软件的静态分析涉及要么反汇编字节码并深入研究字节码指令，要么反编译回原始语言并探索源代码。在很多情况下，后一种方法更为可取，因为阅读人类友好的代码可以减少分析所需的时间。前一种方法通常在反编译因各种原因无法成功时使用，例如缺乏最新工具，或者样本中实施了反逆向工程技术。
- en: Here are some of the most commonly used tools for static analysis of Android
    malware.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些最常用的工具，用于安卓恶意软件的静态分析。
- en: Disassembling and data extraction
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反汇编与数据提取
- en: 'These tools aim to restore Dalvik assembly from the compiled bytecode:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具旨在从编译后的字节码中恢复Dalvik汇编：
- en: '`.smali` file extensions.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.smali`文件扩展名。'
- en: There were a handful of changes to the format between version 1 and 2 of SMALI
    files. To convert existing SMALI files to the new format, you can assemble the
    old ones with the latest Smali tool, version 1, and then disassemble them with
    the latest Baksmali tool, version 2.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在SMALI文件的第1版和第2版之间有一些格式上的变化。要将现有的SMALI文件转换为新格式，可以使用最新版本的Smali工具（版本1）将旧文件汇编，然后使用最新版本的Baksmali工具（版本2）将其反汇编。
- en: '**Apktool**: A wrapper around the Smali tool; it provides the functionality
    to easily process APK files. Its interface looks as follows:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apktool**：这是一个基于Smali工具的包装器，它提供了方便处理APK文件的功能。其界面如下所示：'
- en: '![Figure 13.10 – The interface of the Apktool'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.10 – Apktool的界面'
- en: '](img/Figure_13.10_B18500.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B18500.jpg)'
- en: Figure 13.10 – The interface of the Apktool
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – Apktool的界面
- en: 'Apart from these, there are other online and desktop solutions built on top
    of these two, providing convenient UIs and extra features, for example, **APK
    Studio**:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些基于这两者构建的其他在线和桌面解决方案，提供了便捷的用户界面和额外的功能，例如 **APK Studio**：
- en: '`aapt dump badging <path_to_apk>`, and to parse `AndroidManifest.xml`, use
    `aapt dump xmltree <path_to_apk> AndroidManifest.xml`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aapt dump badging <path_to_apk>`，要解析 `AndroidManifest.xml`，使用 `aapt dump xmltree
    <path_to_apk> AndroidManifest.xml`'
- en: '**oat2dex** (part of **SmaliEx**): A very useful tool for extracting DEX bytecode
    from older ELF files, storing it as part of the OAT data so that it can be analyzed
    as usual.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oat2dex**（**SmaliEx** 的一部分）：一个非常有用的工具，可以从旧的 ELF 文件中提取 DEX 字节码，并将其存储为 OAT
    数据的一部分，以便像往常一样进行分析。'
- en: '**vdexExtractor**: This tool can be used to extract DEX bytecode from VDEX
    files, as modern OAT files don’t store it anymore.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vdexExtractor**：这个工具可以用来从 VDEX 文件中提取 DEX 字节码，因为现代 OAT 文件不再存储它。'
- en: '**LIEF**: This cross-platform library provides plenty of functionality to parse
    and modify Android files of various formats.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LIEF**：这个跨平台库提供了丰富的功能，可以解析和修改各种格式的 Android 文件。'
- en: '**Androguard**: A versatile toolset combining multiple tools to perform various
    types of operations, including disassembling, parsing, and decoding of various
    files.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Androguard**：一个多功能的工具集，结合了多个工具来执行各种类型的操作，包括反汇编、解析和解码各种文件。'
- en: While bytecode assembly can definitely be used for static analysis purposes
    on its own, many engineers prefer to work with decompiled code instead to save
    time. In this case, decompiling tools are extremely useful.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字节码汇编确实可以用于静态分析，但许多工程师更倾向于使用反编译代码，以节省时间。在这种情况下，反编译工具极为有用。
- en: Decompiling
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反编译
- en: 'Instead of restoring the assembly instructions, this set of tools restores
    the source code, which is usually a more human-friendly option:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具集不是恢复汇编指令，而是恢复源代码，这通常是一个更人性化的选择：
- en: '**JADX**: A DEX to Java decompiler that provides both a command-line and a
    GUI tool to obtain something close to the original source code in the Java language.
    In addition, it provides a basic deobfuscation functionality. Here is how its
    interface looks:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JADX**：一个将 DEX 转换为 Java 的反编译器，提供命令行和图形界面工具，可以获得接近原始源代码的 Java 语言代码。此外，它还提供了基本的去混淆功能。它的界面如下所示：'
- en: '![Figure 13.11 – A decompiled Android sample in JADX'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.11 – 在 JADX 中反编译的 Android 示例'
- en: '](img/Figure_13.11_B18500.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B18500.jpg)'
- en: Figure 13.11 – A decompiled Android sample in JADX
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 在 JADX 中反编译的 Android 示例
- en: '**AndroChef**: This commercial decompiler supports both Java and Android files
    and provides a handy GUI to go through the results.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AndroChef**：这个商业反编译器支持 Java 和 Android 文件，并提供一个方便的 GUI 来查看结果。'
- en: '**JEB decompiler**: Another powerful commercial disassembling and decompiling
    solution, this supports both Dalvik and machine code.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JEB 反编译器**：另一个强大的商业反汇编和反编译解决方案，支持 Dalvik 和机器代码。'
- en: '**dex2jar**: While not exactly a decompiler, this tool allows engineers to
    convert DEX files to JARs. After that, it becomes possible to use multiple Java
    decompilers to obtain Java source code, as already discussed in [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946),
    *Reversing Bytecode Languages – .NET, Java, and More*.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dex2jar**：虽然不完全是一个反编译器，这个工具允许工程师将 DEX 文件转换为 JAR 文件。之后，可以使用多个 Java 反编译器来获得
    Java 源代码，正如在 [*第9章*](B18500_09.xhtml#_idTextAnchor946) 中讨论的，*反向工程字节码语言 – .NET、Java
    等*。'
- en: '**Ghidra**: In addition to native executables, this powerful toolset also supports
    Android apps by converting them into JARs and can be used to facilitate static
    analysis for this platform.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ghidra**：除了支持本地可执行文件外，这个强大的工具集还通过将 Android 应用转换为 JAR 文件来支持 Android 应用，并可以用于促进该平台的静态分析。'
- en: Once obtained, the source code can be analyzed in any IDE or text editor with
    syntax highlighting that supports it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得源代码，可以在任何支持语法高亮的 IDE 或文本编辑器中进行分析。
- en: Now, it is time to explore the options engineers have to perform dynamic analysis.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索工程师进行动态分析的选项了。
- en: Dynamic analysis
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分析
- en: Effective dynamic analysis requires either some sort of emulation or remote
    debugging, as many mobile devices tend to have relatively small native screens
    and basic input capabilities.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的动态分析需要某种形式的仿真或远程调试，因为许多移动设备的本地屏幕相对较小，输入能力较为基础。
- en: Android Debug Bridge
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 调试桥
- en: '**Android Debug Bridge** (**ADB**) is a versatile command-line tool that lets
    users interact with mobile devices from the PC, providing a variety of actions.
    It is a part of Android SDK Platform Tools and consists of three parts:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android 调试桥**（**ADB**）是一个多功能命令行工具，允许用户从 PC 与移动设备进行交互，提供多种操作。它是 Android SDK
    Platform Tools 的一部分，包含三个部分：'
- en: A client running on the PC, providing an interface to enter commands.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PC 上运行的客户端，提供输入命令的接口。
- en: A daemon (**adbd**) executing entered commands on the mobile device. It runs
    as a background process on all devices.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个守护进程（**adbd**）在移动设备上执行输入的命令。它作为后台进程在所有设备上运行。
- en: A server running on the PC that manages communication between the client and
    the daemon.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PC 上运行的一个服务器，管理客户端与守护进程之间的通信。
- en: On the physical devices, ADB can be allowed by enabling the **USB Debugging**
    option under **Developer options** in **Settings**. On a modern Android OS, this
    option is hidden by default and can become visible by tapping the **Build number**
    option (usually, can be found in **Settings** | **About phone**) multiple times
    and then returning to the previous screen. In addition to real devices, ADB can
    also recognize and work with an Android emulator without any changes required.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理设备上，可以通过在 **设置** 中的 **开发者选项** 启用 **USB 调试** 选项来允许 ADB。 在现代 Android 操作系统中，此选项默认隐藏，可以通过多次点击
    **版本号**（通常在 **设置** | **关于手机** 中可以找到）使其显示，然后返回到上一个界面。在实际设备之外，ADB 还可以识别并与 Android
    模拟器配合使用，无需任何更改。
- en: In addition to accessing the device via USB, wireless interaction via Wi-Fi
    is also possible by first issuing the `adb tcpip <port>` command via USB, disconnecting
    the device, and using the `adb connect <ip_address>:<port>` command.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过 USB 访问设备外，还可以通过 Wi-Fi 进行无线交互，方法是先通过 USB 发出 `adb tcpip <port>` 命令，然后断开设备连接，再使用
    `adb connect <ip_address>:<port>` 命令进行连接。
- en: 'Here are some examples of other command-line options available:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些其他命令行选项的示例：
- en: '`adb devices`: Lists the attached devices.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb devices`：列出连接的设备。'
- en: '![Figure 13.12 – Adb seeing an emulated device'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.12 – Adb 识别模拟设备'
- en: '](img/Figure_13.12_B18500.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.12_B18500.jpg)'
- en: Figure 13.12 – Adb seeing an emulated device
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – Adb 识别模拟设备
- en: '`adb kill-server`: Resets the adb host'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb kill-server`：重置 adb 主机'
- en: '`adb install <path_to_apk>`: Sideloads the app using its APK file'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb install <path_to_apk>`：通过 APK 文件将应用程序安装到设备'
- en: '`adb pull` or `adb push`: Moves files between the mobile device and the PC'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb pull` 或 `adb push`：在移动设备和 PC 之间移动文件'
- en: '`adb root` or `adb unroot`: Restarts the `adbd` daemon with or without root
    permissions (not intended to be used in production builds)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb root` 或 `adb unroot`：以或不以 root 权限重新启动 `adbd` 守护进程（不建议在生产版本中使用）'
- en: '`adb forward`: Forwards the specified port from the host to the device:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb forward`：将主机的指定端口转发到设备：'
- en: 'Example: `adb forward tcp:1234 tcp:5678` – forwards the host’s port `1234`
    to the device’s port `5678`'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：`adb forward tcp:1234 tcp:5678` – 将主机的端口 `1234` 转发到设备的端口 `5678`
- en: '`adb shell [<command>]`: Creates a remote interactive shell or runs a command
    within the shell'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb shell [<command>]`：创建远程交互式 shell 或在 shell 中运行命令'
- en: 'Apart from traditional Linux commands, such as `ls` or `cat`, the Android shell
    supports multiple custom commands. Here are some examples:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的 Linux 命令，例如 `ls` 或 `cat`，Android shell 还支持多个自定义命令。以下是一些示例：
- en: '`screencap <filepath>`: Takes a screenshot and save the result on the device.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screencap <filepath>`：截取屏幕截图并将结果保存到设备上。'
- en: '![Figure 13.13 – Using the screencap command'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.13 – 使用 screencap 命令'
- en: '](img/Figure_13.13_B18500.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.13_B18500.jpg)'
- en: Figure 13.13 – Using the screencap command
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 使用 screencap 命令
- en: '`screenrecord <filepath>`: Performs screen video recording until *Ctrl + C*
    is pressed.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`screenrecord <filepath>`：执行屏幕视频录制，直到按下 *Ctrl + C*。'
- en: '`monkey <package_name>`: Originally designed to perform random activities and
    this way, stress-test applications, it can also be used to launch desired apps
    by using the `adb shell monkey -p <package_name> 1` syntax.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monkey <package_name>`：最初设计用于执行随机操作，从而对应用进行压力测试，也可以通过使用 `adb shell monkey
    -p <package_name> 1` 语法启动指定的应用程序。'
- en: '`input keyevent <num>`: Initiates the specified key event. Here are a few examples
    of them and the corresponding numbers:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input keyevent <num>`：发起指定的按键事件。以下是一些按键事件及其对应的数字：'
- en: '`3` – presses the `4` – presses the `64` – opens a browser'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` – 按下 `4` – 按下 `64` – 打开浏览器'
- en: '`207` – opens contacts'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`207` – 打开联系人'
- en: The complete up-to-date list can be found by looking at the `KeyEvent` class
    in the official Android documentation.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的最新列表可以通过查看官方 Android 文档中的 `KeyEvent` 类找到。
- en: Important note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: To pass arguments requiring quotes as part of the command, you will have to
    surround the quoted string with a pair of different quotes (either single or double).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递需要引号的参数作为命令的一部分，你必须使用一对不同的引号（单引号或双引号）将引号字符串括起来。
- en: 'In addition, ADB can be used to issue commands to additional modules:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ADB 可用于向额外的模块发出命令：
- en: '`adb shell pm list packages` – lists the names of all packages. Use the `–f`
    option to also get the paths of the corresponding APKs. Third-party apps can be
    filtered out using the `–3` argument.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb shell pm list packages` – 列出所有包的名称。使用 `–f` 选项还可以获取相应 APK 的路径。可以使用 `–3`
    参数过滤掉第三方应用程序。'
- en: '`adb shell am start -a android.intent.action.MAIN -n <package_name>/<main_activity>`
    – launches the main activity of an app. The most reliable way to specify the main
    activity is to provide the full path to it within the package (such as `adb shell
    am start -a android.intent.action.MAIN -n com.google.android.calendar/com.android.calendar.LaunchActivity`).*   `adb
    shell dpm set-active-admin -user current <component>` – sets the specified component
    as an active admin, usually to enforce security policies.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb shell am start -a android.intent.action.MAIN -n <package_name>/<main_activity>`
    – 启动应用的主活动。指定主活动的最可靠方法是提供包内主活动的完整路径（例如 `adb shell am start -a android.intent.action.MAIN
    -n com.google.android.calendar/com.android.calendar.LaunchActivity`）。*   `adb
    shell dpm set-active-admin -user current <component>` – 将指定的组件设置为活动管理员，通常用于强制执行安全策略。'
- en: All the commands can be found in the comprehensive official documentation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都可以在全面的官方文档中找到。
- en: Emulators
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟器
- en: 'As with any other platform, emulators aim to facilitate dynamic analysis by
    emulating the executed instructions without the need to use real devices. There
    are several third-party solutions aiming to provide easier access to Android apps
    and games, for example, BlueStacks. However, for reverse-engineering purposes,
    solutions that are more focused on giving developers the ability to create and
    debug apps generally provide better options. They include the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他平台一样，模拟器旨在通过模拟执行的指令来促进动态分析，无需使用真实设备。有许多第三方解决方案旨在提供更容易访问 Android 应用程序和游戏的途径，例如
    BlueStacks。然而，对于逆向工程目的，通常更侧重于为开发人员提供创建和调试应用程序能力的解决方案，通常会提供更好的选项。它们包括以下几种：
- en: '**Android Emulator**: The official Android Emulator can be installed as part
    of the official **Android Studio** or using the command-line **SDK Manager**.
    It provides almost all the capabilities of real physical devices and comes with
    predefined sets of configurations aiming to simulate various mobile devices (whether
    a phone, tablet, and wearable) on the PC.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android 模拟器**：官方 Android 模拟器可以作为官方 **Android Studio** 的一部分安装，或使用命令行 **SDK
    Manager** 安装。它几乎提供了真实物理设备的所有功能，并且配备了预定义的配置集，旨在模拟各种移动设备（无论是手机、平板还是可穿戴设备）在 PC 上的表现。'
- en: 'To install the emulator without Android Studio (using only the command line),
    follow these steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在没有 Android Studio 的情况下安装模拟器（仅使用命令行），请按照以下步骤操作：
- en: If you have never installed the Android SDK before, create an empty directory
    somewhere where you would like the whole Android SDK to be located and create
    an environment variable, `ANDROID_HOME`, to point to this directory.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你以前从未安装过 Android SDK，请在你希望存放整个 Android SDK 的位置创建一个空目录，并创建一个名为 `ANDROID_HOME`
    的环境变量，指向该目录。
- en: Download the Android command-line tools, unzip them, and move the whole extracted
    directory, `cmdline-tools`, (not its content!) to the Android SDK folder.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 Android 命令行工具，解压缩它们，然后将整个解压后的目录 `cmdline-tools`（而不是其内容！）移动到 Android SDK 文件夹。
- en: Inside `$ANDROID_HOME/cmdline-tools`, create a directory called `latest`, and
    move the whole content of `cmdline-tools` there.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `$ANDROID_HOME/cmdline-tools` 内创建一个名为 `latest` 的目录，并将 `cmdline-tools` 的整个内容移动到该目录中。
- en: 'In the `$ANDROID_HOME/cmdline-tools/latest/bin` directory, you can find the
    `sdkmanager` tool. Use this method to get the emulator and platform tools, including
    `adb`:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `$ANDROID_HOME/cmdline-tools/latest/bin` 目录中，你可以找到 `sdkmanager` 工具。使用此方法获取模拟器和平台工具，包括
    `adb`：
- en: '[PRE1]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can list all the available Android system images by running the following
    command:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令列出所有可用的 Android 系统镜像：
- en: '[PRE2]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, we decided to emulate Android 12, corresponding to the API level
    of `31`. Use the following command to download a system image that will be emulated
    on an x86-64 machine, together with the corresponding packages:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们决定模拟 Android 12，对应的 API 级别是 `31`。使用以下命令下载将在 x86-64 机器上模拟的系统镜像，以及相应的包：
- en: '[PRE3]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Using `google_apis_playstore` images will enable access to Google Play but the
    `adb root` command will not work on them!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `google_apis_playstore` 镜像将启用对 Google Play 的访问，但 `adb root` 命令在这些镜像上将无法使用！
- en: 'Use the following command to create a virtual device linked to the chosen system
    image (no need to create a custom hardware profile). In this case, the name used
    is `avd_31_noplay`, but it can be any other name:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个与选定系统镜像关联的虚拟设备（无需创建自定义硬件配置文件）。在这种情况下，使用的名称是 `avd_31_noplay`，但可以使用任何其他名称：
- en: '[PRE4]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, everything is ready to run the emulator, located in the `$ANDROID_HOME/emulator`
    directory, using the following command:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，一切都准备好运行模拟器，模拟器位于 `$ANDROID_HOME/emulator` 目录中，使用以下命令：
- en: '[PRE5]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When running an emulator on the VM, you may be prompted about hardware acceleration
    – to address it, enable support for Intel VT-x in the VM’s settings.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机上运行模拟器时，可能会提示有关硬件加速的问题——为了解决这个问题，需要在虚拟机设置中启用 Intel VT-x 支持。
- en: 'Here is how the result will look:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果的样子：
- en: '![Figure 13.14 – Running the Android Emulator on a VM'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.14 – 在虚拟机上运行 Android 模拟器](img/Figure_13.14_B18500.jpg)'
- en: '](img/Figure_13.14_B18500.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.14_B18500.jpg)'
- en: Figure 13.14 – Running the Android Emulator on a VM
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 在虚拟机上运行 Android 模拟器
- en: The Emulator also allows us to create and restore snapshots containing the entire
    state of the emulated device.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器还允许我们创建和恢复包含整个模拟设备状态的快照。
- en: '**VMWare, VirtualBox, or QEMU**: These versatile solutions can be used to run
    an **Android-x86** image and perform dynamic analysis in a similar way to what
    would be done on the Linux VM. Keep in mind that Android-x86 is usually a few
    versions behind the latest Android release:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMWare、VirtualBox 或 QEMU**：这些多功能解决方案可以用来运行 **Android-x86** 镜像，并以类似于在 Linux
    虚拟机上进行的方式执行动态分析。请记住，Android-x86 通常比最新的 Android 版本滞后几个版本：'
- en: '![Figure 13.15 – Running Android-x86 on a VM'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.15 – 在虚拟机上运行 Android-x86](img/Figure_13.15_B18500.jpg)'
- en: '](img/Figure_13.15_B18500.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.15_B18500.jpg)'
- en: Figure 13.15 – Running Android-x86 on a VM
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 在虚拟机上运行 Android-x86
- en: Other ways to get access to Android systems include cloud-based **Genymotion**
    and container-based **anbox** solutions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Android 系统访问权限的其他方式包括基于云的**Genymotion**和基于容器的**anbox**解决方案。
- en: Once we have the environment to run Android programs, we need debuggers to do
    it in a controlled way.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了运行 Android 程序的环境，就需要调试器以受控的方式执行它。
- en: Debuggers
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试器
- en: Once the app of interest is decompiled back to Java code, parts of it can be
    debugged as with usual source code in the IDE supporting it, for example, Android
    Studio. If you are using a physical device instead of an emulator, don’t forget
    to enable USB debugging. In addition, the code should include the `debuggable
    true` option in its build configuration.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标应用程序被反编译回 Java 代码，其部分代码可以像在 IDE 中调试普通源代码一样进行调试，例如 Android Studio。如果使用物理设备而不是模拟器，别忘了启用
    USB 调试。此外，代码应在其构建配置中包含 `debuggable true` 选项。
- en: Sometimes, it is required to debug the native Dalvik instructions or whole apps.
    Luckily, there are tools that can facilitate this process. One that deserves particular
    attention is **smalidea**. It is a plugin for IntelliJ IDEA (or Android Studio,
    which is based on it) allowing for step-by-step execution of the analyzed code.
    This project belongs to the Smali authors and can be found with the corresponding
    assembler and disassembler tools.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，调试原生的 Dalvik 指令或整个应用程序是必要的。幸运的是，有一些工具可以简化这一过程。其中值得特别关注的是 **smalidea**。它是
    IntelliJ IDEA（或基于它的 Android Studio）的插件，允许逐步执行分析过的代码。这个项目属于 Smali 作者，并且可以与相应的汇编器和反汇编器工具一起找到。
- en: 'In addition, Android also provides tools to debug native code. Here are the
    instructions on how to attach at the start:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android 还提供了调试原生代码的工具。以下是如何开始附加的说明：
- en: First, obtain the Android NDK to get `lldb-server` prebuilt, as well as the
    `lldb` tools (in the past, the `gdbserver` and `gdb` tools were used)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，获取 Android NDK，以便获得预构建的 `lldb-server`，以及 `lldb` 工具（过去曾使用 `gdbserver` 和 `gdb`
    工具）。
- en: 'Then, push the `lldb-server` executable to the device, for example, to the
    `/data/local/tmp` directory, and make it executable:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将 `lldb-server` 可执行文件推送到设备上，例如推送到 `/data/local/tmp` 目录，并使其可执行：
- en: '[PRE6]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set up port forwarding:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置端口转发：
- en: '[PRE7]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have two options: either to use `lldb-server` in `gdbserver` or the
    `platform` mode. Let’s provide examples for both.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个选择：使用 `lldb-server` 在 `gdbserver` 模式下，或者使用 `platform` 模式。让我们提供两个例子的说明。
- en: 'Using the `gdbserver` mode involves the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gdbserver` 模式涉及以下操作：
- en: 'Start the debugger server on the Android device – the sample of interest should
    be copied there as well:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android设备上启动调试器服务器——感兴趣的示例也应复制到那里：
- en: '[PRE8]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Launch `lldb` on the host and connect to the debugger server running on the
    device via the forwarded port:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机上启动`lldb`，并通过转发端口连接到设备上运行的调试器服务器：
- en: '[PRE9]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the `platform` mode involves the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`platform`模式涉及以下内容：
- en: 'Start the debugger server on the Android device – no need to copy the sample
    there:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android设备上启动调试器服务器——无需将示例复制到那里：
- en: '[PRE10]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Here, we have to provide the `--gdbserver-port` argument, otherwise, `lldb`
    won’t be able to copy a sample from the host machine to the Android device later.
    An additional `adb forward` command is required to forward this auxiliary port.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须提供`--gdbserver-port`参数，否则`lldb`稍后将无法将示例从主机复制到Android设备。需要额外的`adb forward`命令来转发此辅助端口。
- en: 'Launch `lldb` on the host, connect to the debugger server via the forwarded
    port, and launch the sample – it will be copied to the Android device automatically:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机上启动`lldb`，通过转发端口连接到调试器服务器，然后启动示例——它会自动复制到Android设备上：
- en: '[PRE11]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is how the successful connection will look on the debugger server side:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调试器服务器端成功连接的显示方式：
- en: '![Figure 13.16 – A successful connection to the debugger server running on
    the Android emulator'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.16 – 成功连接到在Android模拟器上运行的调试器服务器'
- en: '](img/Figure_13.16_B18500.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.16_B18500.jpg)'
- en: Figure 13.16 – A successful connection to the debugger server running on the
    Android emulator
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 成功连接到在Android模拟器上运行的调试器服务器
- en: Apart from that, IDA is shipped with a set of proprietary debugger servers for
    Android supporting both 32- and 64-bit versions of x86 and ARM platforms (`android_server`
    or `android_server64`).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IDA还附带了一组专有的Android调试器服务器，支持x86和ARM平台的32位和64位版本（`android_server`或`android_server64`）。
- en: 'App startup can be debugged in the following way:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式调试应用程序启动：
- en: Go to `jdb` debugger to be attached.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`jdb`调试器进行附加。
- en: Start the app from the launcher or using the console, wait for it to load.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动器或控制台启动应用程序，等待其加载。
- en: Attach a debugger such as `lldb`, set the required breakpoints, and continue
    the execution.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加调试器如`lldb`，设置所需的断点，然后继续执行。
- en: 'Attach the `jdb` debugger to let the app run:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加`jdb`调试器以让应用程序运行：
- en: '[PRE12]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let’s talk about behavioral analysis.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论行为分析。
- en: Behavioral analysis and tracing
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为分析与跟踪
- en: 'As with many other platforms, the **fsmon** tool can be used to monitor file
    operations on Android. Here is an example of it being used to detect the creation
    of a new file:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他平台一样，**fsmon**工具可用于监控Android上的文件操作。以下是它用于检测新文件创建的示例：
- en: '![Figure 13.17 – Testing fsmon on the Android Emulator by recording test file
    creation'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.17 – 在Android模拟器上测试fsmon，通过记录测试文件创建'
- en: '](img/Figure_13.17_B18500.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.17_B18500.jpg)'
- en: Figure 13.17 – Testing fsmon on the Android Emulator by recording test file
    creation
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 – 在Android模拟器上测试fsmon，通过记录测试文件创建
- en: In terms of APIs, an **AppMon** solution includes a set of components to intercept
    and manipulate API calls. It is based on the **Frida** project, which also provides
    its own versatile tools, such as **frida-trace** (working together with **frida-server**).
    One more tool based on Frida is **Objection**, which provides access to multiple
    options including various memory-related tasks, heap manipulation, and the execution
    of custom scripts.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 就API而言，**AppMon**解决方案包括一组组件，用于拦截和操作API调用。它基于**Frida**项目，后者还提供了自己的多功能工具，如**frida-trace**（与**frida-server**协同工作）。另一个基于Frida的工具是**Objection**，它提供了多种选项，包括各种与内存相关的任务、堆操作以及执行自定义脚本。
- en: 'For native programs, the standard `strace` tool can also be used to monitor
    system calls. As you can see in the following screenshot, its interface is identical
    to the one found on Linux systems:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地程序，还可以使用标准的`strace`工具监控系统调用。如以下截图所示，其界面与Linux系统上的界面相同：
- en: '![Figure 13.18 – Using strace for behavioral analysis on the Android Emulator'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.18 – 使用strace进行Android模拟器上的行为分析'
- en: '](img/Figure_13.18_B18500.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.18_B18500.jpg)'
- en: Figure 13.18 – Using strace for behavioral analysis on the Android Emulator
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18 – 在Android模拟器上使用strace进行行为分析
- en: Speaking about recording network traffic, the standard `tcpdump` tool can run
    on the device for this purpose and is generally the easiest-to-use solution. Wireshark
    creators also supply a tool called **androiddump** to provide interfaces to capture
    on Android devices (which generally needs to be built separately). In addition,
    as long as the malicious sample is decompiled, it also becomes possible to embed
    various libraries intercepting API calls, for example, **AndroidSnooper** to intercept
    HTTP traffic.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 说到记录网络流量，标准的 `tcpdump` 工具可以在设备上运行，用于此目的，通常是最容易使用的解决方案。Wireshark 的开发者还提供了一种名为
    **androiddump** 的工具，用于在 Android 设备上提供捕获接口（通常需要单独构建）。此外，只要恶意样本被反编译，还可以嵌入各种库来拦截
    API 调用，例如，**AndroidSnooper** 用于拦截 HTTP 流量。
- en: Once we know which tools can be used for the analysis, let’s summarize the analysis
    workflow.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道可以用于分析的工具，接下来就可以总结分析工作流。
- en: The analysis workflow
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析工作流
- en: 'Here is an example of the workflow, describing how the Android sample analysis
    can be performed:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个工作流示例，描述如何执行 Android 样本分析：
- en: '`boot.oat` file.'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boot.oat` 文件。'
- en: '`Application`’s subclass from the `android:name` attribute of the `<application>`
    element (if present)'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Application` 的子类来自 `<application>` 元素的 `android:name` 属性（如果存在）。'
- en: '**Decompilation or disassembling**: It always makes sense to try to get the
    decompiled source code, as it is usually much easier to read it and perform dynamic
    analysis, including alteration if necessary. If decompilation doesn’t work and
    some anti-reverse-engineering technique is expected, then the code can be disassembled
    so that the tampering logic can be amended. Native code in ELF binaries can be
    processed in the same way as described in [*Chapter 11*](B18500_11.xhtml#_idTextAnchor1188),
    *Dissecting Linux and IoT Malware*.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反编译或反汇编**：尝试获取反编译的源代码总是有意义的，因为通常它更容易阅读并进行动态分析，包括必要时进行修改。如果反编译无法成功，并且预计会有某些反反编译技术，那么可以进行反汇编，从而修改篡改逻辑。ELF
    二进制文件中的原生代码可以像 [*第11章*](B18500_11.xhtml#_idTextAnchor1188) 中描述的那样进行处理，*剖析 Linux
    和物联网恶意软件*。'
- en: '`onCreate` methods of the main activities, and the previously mentioned optional
    `Application`’s subclass specified in the manifest, as the app execution starts
    there.'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要活动的 `onCreate` 方法，以及清单中之前提到的可选 `Application` 子类，因为应用程序执行在这里开始。
- en: '**Deobfuscation and decryption**: If it has been confirmed that the sample
    is obfuscated, at first, it’s worth trying to figure out whether it is a known
    Java solution and whether any ready deobfuscators exist. If not, then generic
    method renaming will be helpful. There are multiple tools that can do this; refer
    to [*Chapter 9*](B18500_09.xhtml#_idTextAnchor946), *Reversing Bytecode Languages
    – .NET, Java, and More*.'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**去混淆和解密**：如果已确认样本经过混淆，首先值得尝试弄清楚它是否是已知的 Java 解决方案，是否存在任何现成的去混淆工具。如果没有，那么通用方法重命名将会有所帮助。有多种工具可以做到这一点；请参考
    [*第9章*](B18500_09.xhtml#_idTextAnchor946)，*反向工程字节码语言 – .NET、Java 等*。'
- en: '**Behavioral analysis**: It may make sense to execute a sample in the emulator
    with your behavioral analysis tools of choice enabled to quickly get an idea of
    the potential functionality. If an emulator detection technique is implemented,
    it’s usually pretty straightforward to identify it in the code and amend the sample
    to exclude these checks.'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行为分析**：执行样本并启用你选择的行为分析工具，可能有助于快速了解潜在功能。如果实现了模拟器检测技术，通常可以很容易地在代码中识别出来，并修改样本以排除这些检测。'
- en: '**Debugging**: Sometimes, it’s hard to understand certain blocks of functionality,
    particularly ones where malware heavily interacts with the operating system. In
    this case, proper step-by-step debugging may be required to speed up the analysis.
    Always use emulators supporting snapshot creation, so that it is possible to go
    back and quickly reproduce the same situation as many times as necessary.'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调试**：有时候，很难理解某些功能块，特别是那些恶意软件与操作系统紧密交互的部分。在这种情况下，可能需要通过适当的逐步调试来加速分析过程。始终使用支持快照创建的模拟器，这样就可以回溯并根据需要多次快速重现相同的情况。'
- en: Obviously, each case is unique, and depending on circumstances, the selection
    of actions and their order may vary. Malware analysis is also an art and often
    requires a certain amount of creativity in order to achieve results in a prompt
    way.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个案例都是独特的，具体的行动选择及其顺序可能会根据情况有所不同。恶意软件分析也是一门艺术，通常需要一定的创造力，以便迅速达成分析结果。
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the most important aspects of Android’s internals,
    covering various runtime environments implemented in different versions of it.
    In addition, we became familiar with the associated file formats and went through
    the syntax of the bytecode instructions.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了 Android 内部最重要的方面，涵盖了不同版本中实现的各种运行时环境。此外，我们还熟悉了相关的文件格式，并了解了字节码指令的语法。
- en: Then, we dove deeper into the world of modern mobile malware, familiarizing
    ourselves with its different types and the associated behavior. We also learned
    how attackers can bypass Android security mechanisms in order to achieve their
    goals. Finally, we learned about various reverse-engineering tools aiming to facilitate
    static and dynamic analysis, and established guidelines on how and when they can
    be used.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更深入地探索了现代移动恶意软件的世界，了解了它的不同类型及相关行为。我们还学习了攻击者如何绕过 Android 安全机制以实现他们的目标。最后，我们了解了各种逆向工程工具，旨在促进静态和动态分析，并建立了如何以及何时使用这些工具的指导方针。
- en: Equipped with this knowledge, you can better track threat actors that are trying
    to penetrate Android devices and promptly mitigate the risks. In addition, the
    set of skills obtained can be used during the incident response process to properly
    understand the logic of the attacks to improve the overall security posture.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你可以更好地追踪试图渗透 Android 设备的威胁行为者，并及时减轻风险。此外，获得的技能可以在事件响应过程中使用，以正确理解攻击的逻辑，从而提高整体安全态势。
- en: This is the last chapter of this book – we hope you enjoyed it! As a next step,
    we recommend putting your new knowledge into action by practicing analyzing various
    types of malware and sharing your results with the community. Malware analysis
    is a never-ending journey. We really hope this book will help many novice and
    experienced engineers to analyze modern and future threats more efficiently and
    eventually make the world a safer place.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章——希望你喜欢！接下来的步骤，我们建议将你的新知识付诸实践，分析各种类型的恶意软件，并与社区分享你的结果。恶意软件分析是一个永无止境的旅程。我们真心希望本书能帮助许多新手和经验丰富的工程师更高效地分析现代及未来的威胁，并最终使世界变得更安全。
