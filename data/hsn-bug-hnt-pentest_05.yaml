- en: SQL, Code Injection, and Scanners
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL、代码注入和扫描器
- en: Code injection is when unvalidated data is added (injected) into a vulnerable
    program and executed. Injection can occur in SQL, NoSQL, LDAP, XPath, NoSQL, XML
    parsers, and even through SMTP headers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注入是指未经验证的数据被添加（注入）到一个脆弱的程序中并被执行。注入可以发生在 SQL、NoSQL、LDAP、XPath、NoSQL、XML 解析器，甚至通过
    SMTP 头部。
- en: The XSS vulnerabilities discussed in the previous chapter are also examples
    of code injection. When an unsanitized HTML tag with malicious code in its attribute
    is added to a web application's database via a comment thread or discussion board
    submission, that code is injected into the application and executed when other
    users view that same comment or discussion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论的 XSS 漏洞也是代码注入的例子。当一个带有恶意代码的未清理 HTML 标签通过评论线程或讨论板提交添加到 Web 应用的数据库中时，该代码会被注入到应用中，并在其他用户查看相同评论或讨论时被执行。
- en: For the purposes of this chapter though, we're going to focus on detecting and
    preventing code injection attacks related to databases—SQL and NoSQL, respectively.
    We'll cover how to use CLI tools to test a form input for SQLi vulnerabilities,
    how to use similar techniques for NoSQLi, scanning for both SQLi and other injection
    attacks, and best practices for avoiding damage to your target's database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是检测和防止与数据库相关的代码注入攻击——分别是 SQL 和 NoSQL。我们将讨论如何使用命令行工具测试表单输入的 SQLi 漏洞，如何使用类似的技术进行
    NoSQLi 测试，如何扫描 SQLi 以及其他注入攻击，并介绍避免对目标数据库造成损害的最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: SQLi and other code injection attacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLi 和其他代码注入攻击
- en: Testing for SQLi with `sqlmap`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sqlmap` 测试 SQLi
- en: Trawling for bugs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找 bug
- en: Scanning for SQLi with Arachni
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Arachni 扫描 SQLi
- en: NoSQL injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL 注入
- en: An end-to-end example of SQLi
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLi 的端到端示例
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, in addition to our existing Burp and Burp Proxy integration
    with Chrome (`66.0.3359.139`), we'll also be using `sqlmap`, a CLI tool for detecting
    SQL- and NoSQL-based injections. `sqlmap` can be installed using Homebrew with
    `brew install sqlmap` and is also available as a Python module installable via
    `pip`. `sqlmap` is a popular tool, so there should be an installation path for
    you whatever your system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，除了我们现有的 Burp 和 Burp Proxy 与 Chrome（`66.0.3359.139`）的集成外，我们还将使用 `sqlmap`，这是一个用于检测
    SQL 和 NoSQL 注入的命令行工具。`sqlmap` 可以通过 Homebrew 安装，命令为 `brew install sqlmap`，也可以作为
    Python 模块通过 `pip` 安装。`sqlmap` 是一个流行的工具，因此无论您的系统是什么，应该都有安装路径。
- en: We'll also be using Arachni as our go-to scanner. Though noisy, scanners can
    be indispensable for the appropriate situation, and are great at flushing out
    otherwise hard-to-detect bugs. Arachni is an excellent choice because it's open
    source, multi-threaded, extensible via plugins, and has a great CLI that allows
    it to be worked into other automated workflows. Arachni is easy to install; you
    can install it as a gem (`gem install arachni`) or you can simply download the
    official packages straight from the installation site.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 Arachni 作为我们的首选扫描器。尽管扫描器比较吵闹，但在适当的情况下，它们是不可或缺的，并且非常擅长发现那些难以检测的 bug。Arachni
    是一个出色的选择，因为它是开源的，支持多线程，能够通过插件进行扩展，且具有出色的命令行界面，允许将其集成到其他自动化工作流程中。Arachni 很容易安装；你可以通过安装
    gem（`gem install arachni`）或直接从官方网站下载相应的安装包来安装。
- en: Please install Arachni from the site's Download page at [http://www.arachni-scanner.com/download/#Mac-OSX.](http://www.arachni-scanner.com/download/#Mac-OSX)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请从 Arachni 的下载页面安装：[http://www.arachni-scanner.com/download/#Mac-OSX](http://www.arachni-scanner.com/download/#Mac-OSX)
- en: After you've installed it, if you've downloaded the packages for the appropriate
    system, you'll want to move them to wherever is appropriate within your system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，如果你已经下载了适合系统的安装包，你需要将它们移动到系统内适当的位置。
- en: 'Then you can create a symlink (symbolic link) so that all the `arachni` CLI
    packages will be available within your path (fill in the correct path to your
    `arachni` installation):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个符号链接（symlink），使得所有 `arachni` 命令行工具都可以在你的路径中使用（请填写正确的路径到你的 `arachni`
    安装目录）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You might find that, after you symlink your `arachni` executables to your path,
    you receive the following error:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，在将 `arachni` 可执行文件符号链接到你的路径后，出现以下错误：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you receive this error, simply symlink, copy, or move the `readlink_f.sh`
    script from your `arachni` installation''s `bin` directory to your own path. In
    this case, we''ll symlink it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到这个错误，只需将 `arachni` 安装目录下的 `bin` 目录中的 `readlink_f.sh` 脚本符号链接、复制或移动到你自己的路径中。在这种情况下，我们将进行符号链接操作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now when we use `arachni` later in the chapter, we can invoke it directly, as
    opposed to having to type the full path each time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在本章后面使用 `arachni` 时，我们可以直接调用它，而不需要每次都输入完整路径。
- en: SQLi and Other Code Injection Attacks – Accepting Unvalidated Data
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLi 和其他代码注入攻击——接受未验证的数据
- en: SQLi is a rather old vulnerability. It's been two decades since the first public
    disclosures of the attack started appearing in 1998, detailed in publications
    such as Phrack, but it persists, often in critically damaging ways. SQLi vulnerabilities
    can allow an attacker to read sensitive data, update database information, and
    sometimes even issue OS commands. As OWASP succinctly states, the "flaw depends
    on the fact that SQL makes no real distinction between the control and data planes."
    This means that SQL commands can modify both the data they contain and parts of
    the underlying system running the software, so when the access prerequisites for
    a feature such as sqlmap's `--os-shell` flag are present, a SQLi flaw can be used
    to issue system commands.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SQLi 是一种相对古老的漏洞。自从1998年首次公开披露该攻击开始，已经过去了二十年，诸如 Phrack 等出版物详细描述了这种攻击，但它仍然存在，且往往以严重破坏的方式存在。SQLi
    漏洞可能允许攻击者读取敏感数据、更新数据库信息，有时甚至发出操作系统命令。正如 OWASP 简洁地指出的那样，“这个缺陷依赖于 SQL 并没有对控制平面和数据平面做出真实区分。”
    这意味着 SQL 命令可以修改它们所包含的数据以及运行软件的底层系统的部分，因此当存在像 sqlmap 的 `--os-shell` 标志这样的功能访问先决条件时，SQLi
    漏洞可以被用来发出系统命令。
- en: Many tools and design patterns exist for preventing SQLi. But the pressure of
    getting new applications to market and iterating quickly on features means that
    SQLi-vulnerable inputs don't get audited, and the procedures to prevent the bug
    are never put into place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具和设计模式用于防止 SQLi。但由于将新应用程序快速推向市场并迅速迭代功能的压力，SQLi 漏洞输入未被审计，防止此类错误的程序也没有得到实施。
- en: As a vulnerability endemic to one of the most common languages for database
    development and as an easily detected, easily exploited, and richly rewarded bug,
    SQLi is a worthy subject for study.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种广泛存在于数据库开发中最常用语言中的漏洞，并且是一种容易被发现、容易被利用并且回报丰厚的错误，SQLi 是一个值得研究的主题。
- en: A Simple SQLi Example
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 SQLi 示例
- en: Let's look at how SQLi breaks down into actual code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 SQLi 是如何分解成实际代码的。
- en: 'Take a look at the following query, where the value of `$id` would be input
    supplied by the user:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的查询，其中 `$id` 的值是用户提供的输入：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One common SQLi technique is to input data that can change the context or logic
    of the SQL statement's execution. Because that `$id` value is being inserted directly—with
    no data sanitization, removal of dangerous code, or data type transformation—the
    SQL statement is dynamic, and subject to tampering.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的 SQLi 技巧是输入可以改变 SQL 语句执行上下文或逻辑的数据。因为 `$id` 的值直接插入——没有数据清理、删除危险代码或数据类型转换——所以
    SQL 语句是动态的，容易被篡改。
- en: 'Let''s make a change that will affect the execution of the statement:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做出一个改变，这将影响语句的执行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, `10 OR 1=1` is the user-supplied data. By modifying the `WHERE`
    clause, the user can alter the logic of the developer-supplied part of the executed
    example. The preceding example is pretty innocuous, but if the statement asked
    for account information from a user table, or a part of the database associated
    with privileges, instead of just information about a blog post, that could represent
    a way to seriously damage the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`10 OR 1=1` 是用户提供的数据。通过修改 `WHERE` 子句，用户可以改变开发者提供的执行示例的逻辑。前面的示例相对无害，但如果语句要求从用户表中获取账户信息，或者与权限相关的数据库部分，而不仅仅是关于博客文章的信息，那就可能严重损害应用程序。
- en: Testing for SQLi With Sqlmap – Where to Find It and How to Verify It
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sqlmap 进行 SQLi 测试——在哪里找到它以及如何验证它
- en: '`sqlmap` is a popular CLI tool for detecting and exploiting SQLi vulnerabilities.
    Since we''re only interested in discovering those bugs, we''re less interested
    in the weaponization, except for brainstorming possible attack scenarios for report
    submissions.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 是一个流行的 CLI 工具，用于检测和利用 SQLi 漏洞。由于我们只对发现这些错误感兴趣，除了为报告提交集思广益的攻击场景外，我们对武器化并不那么感兴趣。'
- en: 'The simplest use of `sqlmap` is using the `-u` flag to target the parameters
    being passed in a specific URL. Using `webscantest.com` again as our example target,
    we can test the parameters in a form submission specifically vulnerable to `GET`
    requests:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sqlmap` 的最简单方法是使用 `-u` 标志来针对特定 URL 中传递的参数。再次以 `webscantest.com` 为例，我们可以测试一个专门对
    `GET` 请求易受攻击的表单提交中的参数：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](assets/8afa3f4a-8dd8-4939-a2bd-c30605d6ac17.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8afa3f4a-8dd8-4939-a2bd-c30605d6ac17.png)'
- en: 'As `sqlmap` begins probing the parameters passed in the target URL, it will
    prompt you to answer several questions about the direction and scope of the attack:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当`sqlmap`开始探测目标 URL 中传递的参数时，它会提示你回答几个关于攻击方向和范围的问题：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you can successfully identify the backend through your own investigations,
    it's a good idea to say yes here, just to reduce any possible noise in the report.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能通过自己的调查成功识别后端，建议在这里选择“是”，以减少报告中的噪音。
- en: 'You should also get a question about what `risk` level of input values you''re
    willing to tolerate:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会被问到愿意接受哪种`risk`级别的输入值：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`sqlmap`, as a tool designed to both detect SQLi vulnerabilities and exploit
    them, needs to be handled with care. Unless you''re testing against a sandboxed
    instance, completely independent from all production systems, you should go with
    the lower risk-level settings. Using the lowest risk level ensures that `sqlmap`
    will test the form with malicious SQL inputs designed to cause the database to
    sleep or enumerate hidden information—and not corrupt data or compromise authentication
    systems. Because of the sensitivity of the information and processes contained
    in the targeted SQL database, it''s important to tread carefully with vulnerabilities
    associated with backend systems.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmap` 作为一个既能检测 SQLi 漏洞又能利用这些漏洞的工具，需要谨慎使用。除非你在一个完全独立于所有生产系统的沙盒环境中进行测试，否则你应该选择较低的风险级别设置。使用最低的风险级别可确保
    `sqlmap` 使用恶意 SQL 输入测试表单，这些输入旨在让数据库休眠或枚举隐藏信息，而不是破坏数据或危害身份验证系统。由于目标 SQL 数据库中包含的信息和过程非常敏感，因此在处理与后端系统相关的漏洞时需要小心谨慎。'
- en: 'Once `sqlmap` runs through its range of test inputs, it will prompt you to
    ask about targeting other parameters. Once you''ve run through all the parameters
    passed in the targeted URL, `sqlmap` will print out a report of all the vulnerabilities
    discovered:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`sqlmap`完成其测试输入范围，它会提示你是否要测试其他参数。完成对目标 URL 中所有传递参数的测试后，`sqlmap`会输出所有发现的漏洞报告：
- en: '![](assets/2983a87b-790c-4600-b6fc-58604df95930.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2983a87b-790c-4600-b6fc-58604df95930.png)'
- en: Success! There are a few vulnerabilities related to the `id` parameter, including
    a pair of blind SQLi vulnerabilities (where the results of the injection are not
    directly visible in the GUI) and error- and `UNION`-based inputs—all confirmed
    by the documentation on `webscantest.com`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！有几个与`id`参数相关的漏洞，包括一对盲注 SQLi 漏洞（注入的结果在 GUI 中不可直接看到）以及基于错误和`UNION`的输入——所有这些都被
    `webscantest.com` 的文档确认。
- en: Trawling for Bugs – Using Google Dorks and Python for SQLi Discovery
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**抓取漏洞** – 使用 Google Dorks 和 Python 进行 SQLi 漏洞发现'
- en: Using `sqlmap` requires a URL to target—one that will contain testable parameters.
    This next technique can be used to target specific applications and form inputs—like
    `sqlmap` does—or to simply return a list of sites susceptible to SQLi vulnerabilities.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sqlmap`需要一个目标 URL——这个 URL 必须包含可测试的参数。接下来的技术可以用来定位特定的应用程序和表单输入——就像`sqlmap`一样——或者简单地返回一个易受
    SQLi 漏洞影响的站点列表。
- en: Google Dorks for SQLi
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Dorks 用于 SQLi
- en: Using Google Dorks—sometimes called Google hacking—means employing specially-crafted
    search queries to get search engines to return sites susceptible to SQLi and other
    vulnerabilities. The name Google dork refers to a hapless employee misconfiguring
    their site and exposing sensitive corporate information online.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google Dorks——有时称为 Google 黑客技术——意味着通过精心设计的搜索查询，利用搜索引擎返回易受 SQLi 和其他漏洞攻击的网站。Google
    Dork 这个名字源自一个不小心配置错误的员工，他们将敏感的公司信息暴露到网上。
- en: 'Here are a few examples of common Google Dorks for discovering instances of
    SQLi:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些常见的 Google Dorks 示例，用于发现 SQLi 漏洞：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see the queries are designed to return results, where the sites discovered
    are at least theoretically susceptible to SQLi (because of the sites'' URL structure).
    The basic form of a dork is `search_method:domain/dork`, where the `search_method`
    and dork are calibrated to look for a specific type of vulnerability and `domain`
    is used for when you''d like to target a specific application. For example, here''s
    a dork designed to return insecure CCTV feeds:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些查询被设计为返回结果，其中发现的站点至少在理论上是易受 SQLi 攻击的（因为这些站点的 URL 结构）。Dork 的基本形式是`search_method:domain/dork`，其中
    `search_method` 和 dork 被调整为查找特定类型的漏洞，`domain` 用于在你希望针对特定应用程序时。比如，下面是一个设计用于返回不安全
    CCTV 视频流的 dork：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This dork doesn't target a particular URL; it's simply looking for any site
    where the page's title contains `Evocam` and the page's URL contains `webcam.html`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dork 并没有针对特定的 URL；它只是寻找任何页面标题包含 `Evocam` 且页面 URL 包含 `webcam.html` 的网站。
- en: Validating a Dork
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证 Dork
- en: 'While browsing a small security site, I find the following dork, listed on
    the company''s Bugtraq section (the title of the company featured in the `intext`
    field has been changed):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览一个小型安全网站时，我发现了以下 Dork，列在该公司 Bugtraq 部分（`intext` 字段中显示的公司标题已被更改）：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This dork, though it doesn't have a target URL, does focus on a particular company
    via the `intext` search filter. For the `inurl` value, `jsp` is the file extension
    for JSP, a web application framework for Java servlets. `jsp` is a little old—it
    was Sun Microsystems' response to Microsoft's **Active Server Pages** (**ASP**)
    in 1999—but like so much tech, is still employed in legacy industries, small businesses,
    and small `dev` shops.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个 Dork 没有指定目标 URL，但它通过 `intext` 搜索过滤器专注于特定公司。对于 `inurl` 值，`jsp` 是 JSP 的文件扩展名，JSP
    是 Java Servlet 的 Web 应用框架。`jsp` 有点老——它是 Sun Microsystems 在 1999 年推出的对微软的 **Active
    Server Pages** (**ASP**) 的回应——但像许多技术一样，它仍然在遗留行业、小型企业和小型开发公司中被使用。
- en: 'When we use this dork to search Google, our first result returns a URL containing
    `index.jsp?`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个 Dork 在 Google 中搜索时，第一条结果返回一个包含 `index.jsp?` 的 URL：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see the site is making a `GET` request, passing a parameter identifying
    the page visited (`idPagina`). Let's check that and see if it's vulnerable, which
    we can do by passing the URL to `sqlmap`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该网站正在发起一个 `GET` 请求，传递一个标识访问页面的参数（`idPagina`）。让我们检查一下，看它是否存在漏洞，我们可以通过将
    URL 传递给 `sqlmap` 来进行检查。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a valid `sqlmap` command. The cool thing about the tool is that it
    also supports an option for Dorks, `-g`, making it also possible to pass a string
    of the dork you''d like to search (instead of doing the search manually):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的 `sqlmap` 命令。这个工具的一个很酷的功能是，它还支持 Dorks 选项 `-g`，使得你可以传递你想要搜索的 Dork 字符串（而不是手动进行搜索）：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this instance, `sqlmap` will use that dork to search Google and then take
    the results from the first page and analyze them one-by-one, prompting you each
    time to ask if you want to analyze the URL, skip it, or quit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`sqlmap` 将使用该 Dork 在 Google 上进行搜索，然后获取第一页的结果，一一分析它们，每次都会提示你是否想要分析该 URL，跳过它，或退出。
- en: 'Taking the results from just the first search result—the one we targeted directly
    by passing the URL to `sqlmap` via `-u`—we can see both time-based and error-based
    SQLi vulnerabilities:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只取第一条搜索结果——我们通过将 URL 传递给 `sqlmap` 直接进行的搜索——我们可以看到基于时间的和基于错误的 SQL 注入漏洞：
- en: '![](assets/37a4adc5-ef18-4b4f-bab4-df80f05c375b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37a4adc5-ef18-4b4f-bab4-df80f05c375b.png)'
- en: Time-based SQLi is when `SLEEP()` or another similar function is called to inject
    a delay into the query being processed. This delay, combined with conditionals
    and other logic, is then used to extract information from a database by slowly
    enumerating resources. If your payload produces a delay, you can infer your condition
    evaluated to `true` and the assumptions you made are correct. Doing this enough
    can expose sensitive information to determined attackers. As an attack, time-based
    SQLi is very noisy. The impact on application logs is relatively small, but repeated
    use of time-based SQLi will cause large CPU consumption spikes, easily detectable
    by an attentive sysadmin or SRE.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的 SQL 注入（SQLi）是指调用 `SLEEP()` 或其他类似函数，在处理查询时引入延迟。通过延迟、条件语句和其他逻辑的结合，可以慢慢枚举资源，从数据库中提取信息。如果你的有效载荷产生了延迟，你可以推测你的条件已被评估为
    `true`，并且你的假设是正确的。足够多的这种操作可能会暴露敏感信息给有决心的攻击者。作为一种攻击方式，基于时间的 SQL 注入非常嘈杂。对应用程序日志的影响相对较小，但重复使用基于时间的
    SQL 注入会导致 CPU 消耗急剧增加，容易被细心的系统管理员或 SRE 检测到。
- en: If we take the payload from the `sqlmap` time-based results (`12 RLIKE SLEEP(5)`)
    and plug it into the `idPagina` URL parameter, we find it's successful! The page
    takes longer to load as our `SLEEP(5)` command is not sanitized and gets mistakenly
    executed by the application's SQL server. This is a bona fide bug.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `sqlmap` 基于时间的结果（`12 RLIKE SLEEP(5)`）中的有效载荷插入 `idPagina` URL 参数中，我们会发现它成功了！由于我们的
    `SLEEP(5)` 命令未被清理，导致该命令被应用程序的 SQL 服务器错误执行，页面加载时间变长。这是一个真正的漏洞。
- en: 'Error-based SQLi is also returned as a vector for `idPagina`. Error-based SQLi
    is when a SQL command can be made to expose sensitive database information through
    error messages. Again, let''s use this payload as the `idPagina` URL parameter
    and enter it all into the browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基于错误的 SQLi 也作为 `idPagina` 的攻击向量返回。基于错误的 SQLi 是指可以通过错误消息暴露敏感数据库信息的 SQL 命令。再一次，让我们使用这个有效载荷作为
    `idPagina` URL 参数，并将其输入浏览器：
- en: We're successful! The page returns a table ID. Exposing sensitive database info
    more than meets the threshold for a valid SQLi vulnerability.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功了！页面返回了一个表格 ID。暴露敏感数据库信息的程度已经超出了有效 SQLi 漏洞的阈值。
- en: Scanning for SQLi With Arachni
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Arachni 扫描 SQLi
- en: As we mentioned in the *Technical requirements* section, `arachni` is our weapon
    of choice for SQLi scanners because it's open source, extensible, multi-threaded,
    and can be used from a CLI that plays nicely with other forms of automation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*技术要求*部分提到的，`arachni` 是我们选择的 SQLi 扫描工具，因为它是开源的、可扩展的、多线程的，并且可以从命令行界面（CLI）使用，且与其他自动化工具兼容。
- en: 'After installing `arachni` as per the requirements (and symlinking your installation''s
    `arachni` executable), you''ll be able to access the `arachni` CLI in your `$PATH`.
    Let''s look at Arachni''s help message to explore some of the options available:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照要求安装 `arachni`（并为你安装的 `arachni` 可执行文件创建符号链接）后，你将能够在 `$PATH` 中访问 `arachni`
    的命令行界面。让我们查看 Arachni 的帮助信息，探索一些可用的选项：
- en: '![](assets/b6fd496f-2a04-44e9-94c5-863b47f9b0a6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b6fd496f-2a04-44e9-94c5-863b47f9b0a6.png)'
- en: This is a truncated version of the output. Arachni has so many options there
    are too many to reprint here. But certain CLI options are useful for extending
    Arachni's functionality and creating more sophisticated workflows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的截断版本。Arachni 有许多选项，数量多到这里无法全部列举。但某些命令行选项对于扩展 Arachni 的功能和创建更复杂的工作流非常有用。
- en: Going Beyond Defaults
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越默认设置
- en: Like many scanners, `arachni` can be point-and-click almost to a fault. Though
    no extra arguments are required to start spidering a URL from the command-line,
    there are several critical options we should be aware of to get better functionality.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多扫描器一样，`arachni` 几乎可以通过点击操作来完成一切，甚至到了有些过头的程度。虽然开始从命令行对一个 URL 进行蜘蛛抓取时不需要额外的参数，但有几个关键选项我们应该关注，以获得更好的功能。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you set `arachni` loose on a URL it spins up multiple threads that start
    bombarding the target with the malicious snippets and exploratory requests all
    scanners use to flush out interesting behavior. If you're going too quickly though
    and get hit by a WAF throttling your traffic, you might find some or all of those
    threads hanging, sometimes indefinitely. The `--timeout` parameter allows you
    to pass as an argument to specify how long `arachni` should wait before shutting
    down and compiling a report based on the collected data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让 `arachni` 扫描一个 URL 时，它会启动多个线程，开始用所有扫描器用来触发有趣行为的恶意代码片段和探索性请求来轰炸目标。然而，如果你速度过快，并且被
    WAF 限制了流量，你可能会发现一些或所有的线程挂起，有时是无限期地。`--timeout` 参数允许你传入一个参数，指定 `arachni` 在关闭并基于收集到的数据生成报告之前应该等待多长时间。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By default, when you target a URL, without passing any extra information, you'll
    be applying every check `arachni` has in its system. But sometimes you might want
    to exclude some lower-priority warnings—`arachni`, for example, will warn you
    when a company email is exposed publicly, but usually that's not an issue if the
    email is a corporate handle or meant to otherwise be customer-facing. Some forms
    of data leakage are important, but for most companies this is not one of them.
    You also might want to exclude noisy checks that would put too much of a load
    on the target server or network architecture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你扫描一个 URL 时，如果没有传递任何额外的信息，`arachni` 会应用其系统中的所有检查。但有时你可能希望排除一些优先级较低的警告——例如，`arachni`
    会警告你公司邮箱被公开暴露，但通常如果邮箱是公司邮箱或本来就是面向客户的，这并不是问题。一些形式的数据泄露是重要的，但对于大多数公司来说，这不在其中。你也可能想排除一些噪声较大的检查，因为这些检查会对目标服务器或网络架构造成过大的负担。
- en: The `checks` option takes as its arguments the checks you should include and
    exclude, with the splat character `*` operating as its usual stand-in for all
    options and excluded checks indicated by the use of a minus sign (`-`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`checks` 选项接受的参数是你应该包含和排除的检查项，星号 `*` 表示所有选项，排除的检查项则通过减号（`-`）表示。'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This switch does just what it sounds like—it tells `arachni` that, when it spiders
    a URL, it's free to follow any links it finds to that site's subdomains.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开关的作用正如它的名字所示——它告诉 `arachni`，当它爬取 URL 时，可以自由地跟随它找到的任何指向该网站子域的链接。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `plugin` option allows us to pass environment variables that an `arachni`
    plugin might depend on (authentication tokens for SaaS variables, configuration
    settings, SMTP usernames and passwords, and so on).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugin` 选项允许我们传递 `arachni` 插件可能依赖的环境变量（如 SaaS 变量的身份验证令牌、配置设置、SMTP 用户名和密码等）。'
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Arachni's ability to keep its HTTP requests in check is critical to ensuring
    a target server isn't overwhelmed with traffic. Even if scans are allowed under
    the terms of engagement for a specific target range, they'll typically set a speed
    limit for the scanner to prevent the equivalent of a DoS attack. And regardless,
    turning your request concurrency down can ensure you don't get hit by a WAF. The
    default for the scanner's `MAX_CONCURRENCY` is `20` HTTP requests/second.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni 控制 HTTP 请求的能力对于确保目标服务器不会被过多流量压垮至关重要。即使在特定目标范围内扫描被允许，根据约定，通常会为扫描器设置一个速度限制，以防止类似
    DoS 攻击的情况发生。不管怎样，降低请求并发量可以确保你不会受到 WAF 的攻击。扫描器的默认 `MAX_CONCURRENCY` 是 `20` 个 HTTP
    请求/秒。
- en: Writing a Wrapper Script
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写封装脚本
- en: 'Just as we wrote our `bootstrap_burp.sh` script as a convenient wrapper around
    the longer command initializing Burp''s `JAR` file, so that we don''t have to
    type the full path and all our options each time we start the application, we
    can do the same for `arachni`. Putting together all of the options we''ve just
    covered (except for `--plugins`), this is what our script looks like. We''ll call
    it `ascan.sh`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将 `bootstrap_burp.sh` 脚本写作方便的封装器，来简化初始化 Burp 的 `JAR` 文件的长命令，这样每次启动应用程序时就不用每次输入完整的路径和选项一样，我们也可以对
    `arachni` 做同样的事情。将我们刚才覆盖的所有选项（除了 `--plugins`）组合起来，这就是我们的脚本样子。我们将它命名为 `ascan.sh`：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Like `bootstrap_burp.sh`, we can make it executable through a simple `chmod
    u+x ascan.sh` and add it into our path by using `sudo ln -s /Path/to/ascan.sh
    /usr/local/bin/ascan`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `bootstrap_burp.sh` 一样，我们可以通过简单的 `chmod u+x ascan.sh` 使其可执行，并使用 `sudo ln -s
    /Path/to/ascan.sh /usr/local/bin/ascan` 将其添加到我们的路径中。
- en: The timeout is admittedly long, to accommodate the longer hangups that occur
    with a smaller request pool, as well as the extended waiting necessary because
    of time-based SQLi calls.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 超时时间确实较长，目的是为了适应较小请求池所导致的长时间挂起，以及由于基于时间的 SQL 注入调用而需要的延长等待时间。
- en: NoSQL Injection – Injecting Malformed MongoDB Queries
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL 注入——注入格式错误的 MongoDB 查询
- en: According to OWASP, there are over 150 varieties of NoSQL database available
    for use in web applications. We're going to take a look specifically at MongoDB,
    the most widely-used, open source, unstructured NoSQL database, to illustrate
    how injection can work across a variety of toolsets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 OWASP 的数据，市面上有超过 150 种不同的 NoSQL 数据库可以用于 Web 应用程序。我们将特别关注 MongoDB，最广泛使用的开源无结构
    NoSQL 数据库，来展示如何在多种工具集中实现注入。
- en: The MongoDB API usually expects BSON data (binary JSON) constructed using a
    secure BSON query construction tool. But in certain cases, MongoDB can also accept
    unserialized JSON and JavaScript expressions—like in the case of the `$where`
    operator.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB API 通常期望使用安全的 BSON 查询构建工具构建的 BSON 数据（即二进制 JSON）。但在某些情况下，MongoDB 也可以接受未经序列化的
    JSON 和 JavaScript 表达式——例如 `$where` 操作符的情况。
- en: 'It''s usually used—like the SQL `WHERE` operator—as a filter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常用作过滤器——就像 SQL 的 `WHERE` 操作符一样：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can get more complicated with the expression, of course. Ultimately, if
    the data is not properly sanitized, the MongoDB `$where` clause is capable of
    inserting and executing entire scripts written in JavaScript. Unlike SQL, which
    is declarative and somewhat limited as a language, MongoDB's NoSQL support for
    sophisticated JavaScript conditionals opens it up to exploits served by the language's
    full range of features.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以让这个表达式变得更加复杂。最终，如果数据没有得到适当的清理，MongoDB 的 `$where` 子句能够插入并执行整个用 JavaScript
    编写的脚本。与 SQL 不同，SQL 是声明式的且作为语言具有一定的局限性，而 MongoDB 支持复杂的 JavaScript 条件表达式，拓宽了语言的全套特性，进而也使其容易遭到攻击。
- en: 'You can see patterns to how this type of vulnerability is commonly exploited.
    On GitHub and other code-sharing sites, you can find lists enumerating different
    malicious MongoDB `$where` inputs, like this one: [github.com/cr0hn/nosqlinjection_wordlists](https://github.com/cr0hn/nosqlinjection_wordlists).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这种类型的漏洞是如何常见地被利用的。在GitHub和其他代码分享网站上，你可以找到列举不同恶意MongoDB `$where`输入的清单，例如这个：[github.com/cr0hn/nosqlinjection_wordlists](https://github.com/cr0hn/nosqlinjection_wordlists)。
- en: 'Some inputs are designed as **Denial-of-Service** (**DoS**)and resource consumption
    attacks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些输入被设计为**拒绝服务**（**DoS**）和资源消耗攻击：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While some aim for password discovery:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人目的是发现密码：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another vector for code injection within MongoDB is available within PHP implementations.
    Since `$where` is not only a MongoDB reserved word, but valid PHP, an attacker
    can potentially submit code into a query by creating a `$where` variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中的另一个代码注入途径存在于PHP实现中。由于`$where`不仅是MongoDB的保留字，而且是有效的PHP代码，攻击者可以通过创建一个`$where`变量，将代码提交到查询中。
- en: But regardless of the implementation, these attacks all rely on the same principle
    as general injection attacks—unsanitized data being mistaken for and executed
    as an application command.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论实现方式如何，这些攻击都依赖于与一般注入攻击相同的原理——未经清理的数据被误认为并作为应用程序命令执行。
- en: As MongoDB shows, the principle of malformed input changing the logic of a developer's
    code is a problem that extends well beyond SQL or any other specific language,
    framework, or tool.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如MongoDB所示，输入格式不正确改变开发者代码逻辑的问题，不仅限于SQL或任何特定语言、框架或工具，而是一个更广泛的问题。
- en: SQLi – An End-to-End Example
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入 – 一个端到端示例
- en: 'Returning to `arachni`, let''s point it at `webscantest.com/datastore` and
    see what we find, kicking it off with a scan: [https://webscantest.com/datastore](http://webscantest.com/datastore/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`arachni`，我们将其指向`webscantest.com/datastore`，并开始扫描，看看我们能发现什么：[https://webscantest.com/datastore](http://webscantest.com/datastore/)。
- en: 'After running the scan (which will take a while), `arachni` will print out
    the results to the console and generate an `AFR` file. The `AFR`extension stands
    for Arachni Framework Report and is what `arachni` uses to store scan results.
    That `AFR` file can then be converted to HTML, JSON, XML, or another document
    format:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行扫描（这会花费一些时间）后，`arachni`将把结果打印到控制台并生成一个`AFR`文件。`AFR`扩展名代表Arachni框架报告，是`arachni`用来存储扫描结果的格式。这个`AFR`文件可以转换成HTML、JSON、XML或其他文档格式：
- en: '![](assets/c2635c71-9df0-48bb-9956-ea82e2d5435b.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2635c71-9df0-48bb-9956-ea82e2d5435b.png)'
- en: We can immediately see there's a vulnerability to explore in greater detail
    here. This is a good opportunity to use the HTML version of the report, which
    takes advantage of the browser to visualize the entire scan results.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到这里有一个漏洞可以进一步探索。这是一个使用报告HTML版本的好机会，它利用浏览器可视化整个扫描结果。
- en: 'When you want to analyze the results of your scan, you can generate a zipped
    HTML file using the `arachni_reporter` executable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想分析扫描结果时，可以使用`arachni_reporter`可执行文件生成一个压缩的HTML文件：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's important to specify the outfile as zipped HTML, because that's the format
    the `arachni_reporter` will use to create it. If you leave off the `zip` suffix
    and just try to open the resulting HTML file, your browser will show a long stream
    of unformatted, unintelligible special characters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要指定输出文件为压缩的HTML格式，因为这是`arachni_reporter`用来创建报告的格式。如果你省略`zip`后缀，直接尝试打开生成的HTML文件，浏览器将显示一长串未经格式化、难以理解的特殊字符。
- en: 'The following is what you get when you unzip and view the file in a browser:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在解压并在浏览器中查看文件时得到的内容：
- en: '![](assets/ba370d1c-3ae5-4718-bcd9-52caf9f6c3bb.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba370d1c-3ae5-4718-bcd9-52caf9f6c3bb.png)'
- en: 'Arachni shows us a nice overview of the issues discovered. Drilling down, we
    can find a few instances of SQLi. Let''s look at one of the timing issues:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni给我们展示了发现问题的概览。深入分析后，我们可以找到一些SQL注入的实例。让我们来看一下一个时间问题：
- en: '![](assets/d9af206c-59bd-43c3-96e2-54280b6ee224.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d9af206c-59bd-43c3-96e2-54280b6ee224.png)'
- en: 'Scrolling past some of the explanatory text and remediation guidance, we can
    see the payload and affected URLs, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动过一些解释性文本和修复建议后，我们可以看到有效负载和受影响的URL，如下所示：
- en: '![](assets/8034b465-9d93-4c8b-8de4-1dfedb3f8e23.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8034b465-9d93-4c8b-8de4-1dfedb3f8e23.png)'
- en: Now we can write our report.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始写报告了。
- en: Gathering Report Information
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集报告信息
- en: Let's walk through the info we need to write our report.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步写出报告所需的信息。
- en: Category
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别
- en: This is a time-based SQL injection attack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于时间的SQL注入攻击。
- en: Timestamps
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳
- en: For our timestamp, we can provide an estimate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的时间戳，我们可以提供一个估算值。
- en: URL
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL
- en: 'The vulnerability''s URL is provided clearly in the `arachni` report:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞的 URL 已在 `arachni` 报告中清楚地提供：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Payload
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效载荷
- en: 'The SQLi payload is listed prominently in both the console and HTML reports
    under injected seed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SQLi 有效载荷在控制台和 HTML 报告中都显著列出，位于注入的种子下：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Methodology
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法论
- en: Again, only use a scanner if you're authorized to! We would report this finding
    as coming from version `1.5.1` of Arachni.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，只有在获得授权的情况下才能使用扫描器！我们会报告此发现来自 Arachni 的 `1.5.1` 版本。
- en: Instructions to Reproduce
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现步骤
- en: Rather than simply pointing to `arachni`, we want to list the steps to manually
    recreate the vulnerability we're reporting. In this case, that will be navigating
    to the form on the affected page, entering the payload, and hitting Submit. There's
    no encoding, DOM manipulation, or other tricks required.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅是指向 `arachni`，我们还希望列出手动重现我们报告的漏洞的步骤。在这种情况下，步骤是导航到受影响页面上的表单，输入有效载荷并点击提交。无需编码、DOM
    操作或其他技巧。
- en: Attack Scenario
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击场景
- en: When a SQL database suffers from a time-based injection attack, that vulnerability
    allows an attacker to enumerate information available in a database through the
    tactical use of expressions and the SQLi-induced pause. An attack could exfiltrate
    business or payment data, sensitive tokens/authentication credentials, or any
    number of other critical pieces of information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQL 数据库遭受基于时间的注入攻击时，该漏洞允许攻击者通过巧妙地使用表达式和 SQLi 引发的暂停来枚举数据库中的信息。攻击可能会窃取商业或支付数据、敏感令牌/身份验证凭证，或任何其他关键数据。
- en: Final Report
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终报告
- en: 'Let''s use this information to format our submission:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些信息来格式化我们的提交：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: This chapter covered the fundamentals of SQL and NoSQL injection, using `sqlmap`
    to test a target host URL, the value of Google Dorks for both application-targeted
    and general vulnerability analysis, and reporting a SQLi bug properly, from detection
    to submission.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 SQL 和 NoSQL 注入的基本概念，使用 `sqlmap` 测试目标主机 URL，Google Dorks 对于应用程序目标和通用漏洞分析的价值，以及如何正确报告
    SQLi 漏洞，从检测到提交。
- en: In the next chapter, we'll discuss cross-site request forgery (CSRF), how to
    create (and automate) CSRF PoCs, where CSRF occurs, validating a CSRF vulnerability,
    strategies for reporting the bug, and more.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论跨站请求伪造（CSRF）、如何创建（并自动化）CSRF PoC、CSRF 的发生地点、验证 CSRF 漏洞、报告该漏洞的策略等。
- en: Questions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are blind SQLi, error-based SQLi, and time-based SQLi?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是盲注 SQLi、基于错误的 SQLi 和基于时间的 SQLi？
- en: What are some of the dangers of trying to detect SQLi vulnerabilities using
    aggressive string inputs?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用激进字符串输入检测 SQLi 漏洞有什么危险？
- en: What's a Google dork? How did it get its name?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Google dork？它是如何得名的？
- en: What command-line options are particularly useful for the `arachni` CLI?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`arachni` 命令行界面（CLI）有哪些特别有用的命令行选项？'
- en: How do you generate a report from an Arachni Framework Report (`AFR`) file?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从 Arachni Framework Report（`AFR`）文件生成报告？
- en: What are some injection vectors in MongoDB?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MongoDB 中有哪些注入向量？
- en: What's the value of being able to make a SQL thread sleep?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 SQL 线程休眠有什么价值？
- en: Further Reading
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接了解本章讨论的某些主题：
- en: 'Arachni GitHub Page: [https://github.com/Arachni/arachni](https://github.com/Arachni/arachni)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arachni GitHub 页面：[https://github.com/Arachni/arachni](https://github.com/Arachni/arachni)
- en: 'Exploit DB: [https://ww.exploit-db.com](https://ww.exploit-db.com)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Exploit DB：[https://ww.exploit-db.com](https://ww.exploit-db.com)
- en: 'GoogleDorking: [http://www.google-dorking.com](http://www.google-dorking.com)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoogleDorking：[http://www.google-dorking.com](http://www.google-dorking.com)
