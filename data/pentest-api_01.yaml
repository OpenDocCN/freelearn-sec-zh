- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding APIs and their Security Landscape
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解API及其安全性
- en: '**Application Programming Interfaces** (**APIs**) are pretty much everywhere
    on the internet although they were created way before the global network existed.
    Due to their importance in our daily lives and to guarantee sustainable communication
    between devices and systems, it is recommended that you start reading this book
    by first understanding what APIs are, as well as what security problems they may
    have.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**APIs**）几乎无处不在，尽管它们的创建早于全球网络的出现。由于API在我们日常生活中的重要性，并且为了确保设备和系统之间的可持续通信，建议您从理解API是什么，以及它们可能存在的安全问题开始阅读本书。'
- en: In this chapter, you will be introduced to APIs, a bit of their history, and
    some famous examples of APIs. You will get to know the main API components and
    how they interact with each other to put the *magic* to work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解API的基本概念、它们的一些历史以及一些著名的API示例。您将了解到API的主要组件，以及它们如何相互作用以实现*魔力*的运作。
- en: You will also understand the various ways in which APIs can be presented, as
    well as their types and the protocols involved in API deployments. Depending on
    the software you are willing to create, you will see that it may be better to
    design a more specific API type.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解API的不同呈现方式，以及它们的类型和部署中涉及的协议。根据您愿意创建的软件，您会发现设计一个更具体的API类型可能更合适。
- en: The chapter also covers the importance of API security, discussing the premises
    of its design and deployment phases. By the end of this chapter, you will understand
    how some common vulnerabilities can arise from poorly secured APIs and the problems
    they may cause to your environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了API安全性的重要性，讨论了其设计和部署阶段的前提条件。到本章结束时，您将了解一些常见漏洞是如何从安全性差的API中产生的，以及它们可能对您的环境造成的影响。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What is an API?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是API？
- en: API types and protocols
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API类型和协议
- en: Importance of API security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API安全性的重要性
- en: Common API vulnerabilities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的API漏洞
- en: What is an API?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API？
- en: 'There are a few definitions. For example, Red Hat says that APIs are “*a set
    of definitions and protocols* *for building and integrating* *application software*.”
    whereas **Amazon Web Services** (**AWS**) states that “*APIs are mechanisms that
    enable two software components to communicate with each other using a set of definitions
    and protocols*.”. Well, APIs are not limited to two software components only,
    for sure, but both definitions share this part: “*definitions and protocols*”.
    Let’s craft our own definition by making a comparison with the analog world.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个定义。例如，Red Hat表示，API是“*一套用于构建和集成* *应用程序软件*的定义和协议。”而**Amazon Web Services**（**AWS**）则表示，“*API是使两个软件组件能够使用一套定义和协议相互通信的机制*。”当然，API不仅限于两个软件组件，但这两个定义都包含了这一部分：“*定义和协议*”。让我们通过与类比世界的比较来创造我们自己的定义。
- en: An API is a bridge (communication path) between two distinct parts (codes),
    belonging to the same city or not (the same program). By following a set of pre-established
    traffic rules (protocols) and conventions (definitions), vehicles (requests and
    responses) can freely flow between both sides. Sometimes, APIs may have speed
    controls (throttling gears) that are enforced as needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: API是两个不同部分（代码）之间的桥梁（通信路径），无论它们是否属于同一个城市（同一程序）。通过遵循一套预先建立的交通规则（协议）和约定（定义），车辆（请求和响应）可以在两侧自由流动。有时，API可能会有速度控制（节流装置），根据需要执行。
- en: As it happens with all kinds of communication, definitions need to be established
    first. This rule is not limited to the digital world. I can’t ask you to sell
    me a car if you have no idea what selling is or if a car is a type of vehicle.
    Protocols also are paramount. Unless you are donating a product, a sale starts
    with me paying you for the product I want and you handing it over to me. It includes
    giving me change if necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有通信方式一样，首先需要建立定义。这条规则不仅限于数字世界。如果你不知道什么是“销售”或“汽车”是一种交通工具，我不能要求你卖给我一辆车。协议同样至关重要。除非你是赠送产品，否则销售始于我支付你我想要的产品的费用，而你将产品交给我。如果需要，还包括找零。
- en: In terms of APIs, definitions are related to which **types** and **lengths**
    of data are acceptable and allowed between the communicating partners. A requester
    cannot send certain data as a string when the receiver is expecting to receive
    a number, for example. Negative numbers may also pose an additional challenge
    to badly written APIs. When dealing with data lengths, minimum and especially
    maximum sizes are applicable. You will learn later how important it is to block
    data chunks that are bigger than what your API is able to handle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在API的定义中，涉及到在通信方之间哪些**类型**和**长度**的数据是可接受和允许的。例如，当接收方期望接收一个数字时，请求方不能将数据作为字符串发送。负数也可能对编写不良的API造成额外的挑战。在处理数据长度时，适用最小值，尤其是最大值。稍后你将了解，如何阻止大于API能处理的块大小的数据传输是非常重要的。
- en: 'Protocols are the second component of an API. As their counterparts in the
    networking arena, they are responsible for guaranteeing that independently written
    software will be able to communicate in an effective manner. Even though you might
    be reading this book primarily because of web-bound APIs and ways to explore their
    security flaws, I need to tell you that even inside your computer, there are APIs
    working between your **Operating System** (**OS**) and your Wi-Fi card, with definitions
    and protocols like their more famous web cousins. If you are familiar with the
    **Transmission Control Protocol/Internet Protocol** (**TCP/IP**) stack, the following
    figure is not strange. The communication on TCP/IP can only happen because each
    small *rectangle* has their own lower-level protocols implemented in a way that
    allows the same **Network Interface Card** (**NIC**) to be used in different OSs
    and those different OSs can communicate with each other:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 协议是API的第二个组成部分。作为网络领域的对应物，它们负责确保独立编写的软件能够以有效的方式进行通信。即使你主要是因为Web相关的API及其安全漏洞而阅读本书，我也需要告诉你，甚至在你的计算机内部，API也在**操作系统**（**OS**）与Wi-Fi卡之间工作，并具有类似于更著名的Web
    API的定义和协议。如果你熟悉**传输控制协议/互联网协议**（**TCP/IP**）栈，那么以下的图对你来说并不陌生。TCP/IP上的通信之所以能够发生，是因为每个小*矩形*都有自己实现的低层协议，这样就能让同一个**网络接口卡**（**NIC**）在不同的操作系统之间使用，并且这些不同的操作系统可以相互通信：
- en: '![Figure 1.1 – Communication with TCP/IP](img/B19657_01_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 使用TCP/IP进行通信](img/B19657_01_01.jpg)'
- en: Figure 1.1 – Communication with TCP/IP
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 使用TCP/IP进行通信
- en: Every API should be well documented so anyone who wants to use it does not have
    to request information from its creators or maintainers. Can you imagine the avalanche
    of NIC manufacturers sending enquiries to **Defense Advanced Research Project
    Agency** (**DARPA**) scientists to understand how the data link layer should be
    developed, which data structures should be in place, and which sizes and types
    of data should be considered every time a new product was going to be released?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API都应该有良好的文档，这样任何想使用它的人就不必向其创建者或维护者请求信息。你能想象如果每次新产品发布时，**国防高级研究计划局**（**DARPA**）的科学家们收到来自网络接口卡制造商的关于如何开发数据链路层、应该使用哪些数据结构、以及应该考虑哪些数据类型和大小的询问，会是一场怎样的灾难吗？
- en: When documenting an API, at least the definitions of data types and protocol(s)
    adopted need to be made explicit. Well-documented APIs also usually have examples
    of their usage, along with exceptions that may be generated when something goes
    wrong, such as bad data manipulation or unexpected behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写API文档时，至少需要明确数据类型和采用的协议的定义。完善的API文档通常还会提供使用示例，以及在发生错误时可能产生的异常，比如数据处理错误或意外行为。
- en: A brief history of APIs
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API的简史
- en: You will read a lot about web APIs in this book. However, as you saw in the
    TCP/IP example, APIs were not created along with the web. The idea was born many
    decades ago, in 1951, when Maurice Wilkes, David Wheeler and Stanley Gill, three
    British computer scientists, proposed this concept while they were building the
    **Electronic Delay Storage Automatic Calculator** (**EDSAC**), one of the very
    first computers ever. Their book, *The Preparation of Programs for an Electronic
    Digital Computer*, focused primarily on explaining the library they built, as
    well as its subroutines (should you need to develop a program to run on the EDSAC).
    Observe the concern in explaining how the computer could be used beginning with
    the book’s title. This book became the first API documentation we have records
    of.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中你将阅读大量关于 Web API 的内容。然而，正如你在 TCP/IP 示例中看到的，API 并不是随着 Web 一起诞生的。这个概念的诞生要追溯到几十年前，1951
    年，当时三位英国计算机科学家 Maurice Wilkes、David Wheeler 和 Stanley Gill 提出了这一概念，他们当时正在构建 **电子延迟储存自动计算机**（**EDSAC**），这是最早的计算机之一。他们的著作《电子数字计算机程序的准备》主要解释了他们所构建的库以及其子程序（如果你需要开发一个程序以在
    EDSAC 上运行）。从书名可以看出，书中重点解释了如何使用这台计算机。这本书成为我们有记录的第一本 API 文档。
- en: 'Moving on to the 1960s and 70s, the usage of computers grew, leveraging the
    improvements in electric and electronic circuitry. Their sizes also started to
    reduce. Nonetheless, they were still the size of some rooms. The use of APIs was
    now attached to the need for developers to not have to worry about the details
    of how displays or other peripherals worked. We were in the era of mainframes,
    and the advent of new ways to interact with a computer, such as terminals and
    printers, was posing additional challenges to program developers. In 1975, Cristopher
    Date and Edgar Codd, a British mathematician and computer scientist respectively,
    released a paper titled *The relational and network approaches: Comparison of
    the application programming interfaces*. In this work, APIs were proposed to databases,
    something that is still in use today.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 1960 和 70 年代，计算机的使用逐渐增长，得益于电气和电子电路的改进。计算机的体积也开始缩小，尽管如此，它们仍然占据着一个房间的大小。此时，API
    的使用开始与开发者不必担心显示器或其他外设如何工作的需求相关联。我们处于大型主机时代，而新方式与计算机交互的出现，例如终端和打印机，给程序开发者带来了额外的挑战。1975
    年，英国数学家和计算机科学家 Cristopher Date 和 Edgar Codd 发表了一篇题为《关系与网络方法：应用程序编程接口的比较》的论文。在这篇论文中，API
    被提出应用于数据库，至今这一概念仍在使用。
- en: In the 1980s, we started seeing commercial explorations of consumer networks.
    In 1984, *The Electronic Mall*, an online shopping service sold by CompuServe,
    was offered to the company’s subscribers. They could buy products from other merchants
    through their **Consumer Information Service** network. You may ask yourself where
    there is an API in all of this. With the incremental usage of computer networks,
    developers needed to sophisticate their code, and requirements to access code
    and libraries located in remote computers began to show up. It was in 1981 that
    the term **Remote Procedure Calls** (**RPCs**) was coined by the American computer
    scientist Bruce Nelson. The concept is as simple as a client sending a request
    to a network server that then processes the request (executes some computation)
    and returns a result to the client. RPC is therefore what we know as a *message
    passing* mechanism, in which some channel (usually a computer network) is applied
    to allow communication between different elements through message exchanges.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 1980 年代，我们开始看到消费网络的商业探索。1984 年，CompoServe 推出的在线购物服务 *电子商城* 向其订阅用户提供。用户可以通过该公司的
    **消费者信息服务** 网络从其他商家购买产品。你可能会问，这其中哪里有 API。随着计算机网络的逐步使用，开发者需要让他们的代码更加复杂，并且对远程计算机上存储的代码和库的访问要求开始出现。正是
    1981 年，美国计算机科学家 Bruce Nelson 首次提出了 **远程过程调用**（**RPCs**）的概念。这个概念非常简单，就是客户端向网络服务器发送请求，服务器处理该请求（执行某些计算）并将结果返回给客户端。因此，RPC
    就是我们所知道的 *消息传递* 机制，通过某个通道（通常是计算机网络）实现不同元素之间通过消息交换的通信。
- en: 'In the 1990s, that is, more than 40 years after the idea of APIs was first
    used, the internet was generally used around the world (in the USA, this happened
    nearly one decade before). Previously restricted to research institutions and
    government agencies only, the commercial use of the network was then completely
    possible. This increased the adoption of APIs even more and they became the *de
    facto* way of exchanging information between programs. New websites came up, new
    consumer products and services became commercially accessible through the internet,
    and it was clear that software needed standards to communicate with each other.
    Java, a programming language created by Sun Microsystems (now part of Oracle Inc.),
    played a vital role. In 1984, John Gage, the #21 employee of Sun Microsystems,
    coined the phrase “*The network is the computer*”. In his own words, “*We based
    our vision of an interconnected world on open and shared standards.*” Eleven years
    after, James Gosling, another Sun Microsystems employee, created the Java programming
    language, which would evolve to Java 2 afterward and became the seed of notable
    APIs, released as part of its **Java 2 Enterprise Edition** (**J2EE**, now **Jakarta
    EE**) and **Java 2 Micro** **Edition** (**J2ME**).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代，也就是在API的概念首次提出超过40年后，互联网在全球范围内普及开来（在美国，这一变化发生在近十年前）。互联网此前仅限于研究机构和政府机关使用，而商业化的网络使用在那时变得完全可行。这进一步推动了API的采用，它们成为了程序之间交换信息的*事实标准*。新的网站不断涌现，新的消费产品和服务通过互联网得以商业化，软件之间需要通过标准来进行沟通变得愈加明确。由Sun
    Microsystems（现为Oracle Inc.一部分）创建的编程语言Java在这一过程中起到了至关重要的作用。1984年，Sun Microsystems的第21号员工John
    Gage提出了“*网络就是计算机*”这一观点。用他自己的话说，“*我们将关于互联世界的愿景建立在开放和共享的标准之上。*”十一年后，另一位Sun Microsystems的员工James
    Gosling创建了Java编程语言，随后发展为Java 2，并成为了重要API的基石，这些API作为**Java 2企业版**（**J2EE**，现在的**Jakarta
    EE**）和**Java 2微型版**（**J2ME**）的一部分发布。
- en: In the 2000s, the internet had pretty much been consolidated. The always-growing
    number of companies joining the network among massive amounts of developers creating
    new web solutions demanded a quick and effective way to establish a communication
    path between clients (at this time, those were mostly browsers) and web servers.
    In 2000, a PhD thesis entitled *Architectural Styles and the Design of Network-based
    Software Architectures* by Roy Fielding proposed a structured way to allow clients
    and servers to exchange messages on the internet. Roy proposed **Representation
    State Transfer** (**REST**), which became one of the most popular API protocols
    in the world. This decade also saw the explosion of cloud computing offerings,
    both private and public, which mostly implemented REST. It also saw the creation
    of Web 2.0 in 2004, which states the new way that the internet should be used
    (with a greater focus on centering on the user), as well as the birth of applications
    such as Facebook, X (previously Twitter), Reddit, and many more.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2000年代，互联网基本上已经巩固下来。不断增加的加入网络的公司数量，以及大量开发者创造的新网页解决方案，要求一种快速有效的方式来建立客户端（当时大多是浏览器）和网页服务器之间的通信路径。2000年，Roy
    Fielding在其博士论文《*网络基础软件架构的建筑风格与设计*》中提出了一种结构化的方法来允许客户端和服务器在互联网上交换信息。Roy提出了**表现层状态转移**（**REST**），它成为了全球最受欢迎的API协议之一。这个年代还见证了云计算的爆炸式增长，无论是私有云还是公有云，大多数实现了REST。2004年，Web
    2.0的诞生也标志着互联网使用方式的变化（更加注重以用户为中心），同时像Facebook、X（前身为Twitter）、Reddit等应用也在这一时期诞生。
- en: Ten years later, in the 2010s, web protocols were even more evolved. We were
    in the decade of social media and apps, with millions of requests per minute.
    To give you an idea, in 2013, each minute on the Internet was occupied, among
    other traffic, with 461,805 Facebook logins, 38,000 photos uploaded to Instagram,
    and 347,000 tweets sent. This was also the decade when containers and microservice-based
    applications faced their most expressive adoption. The release of Kubernetes,
    an open source container orchestrator, augmented the possibilities for dynamic
    applications on the internet. It was in the 2010s that the term **Web 3.0** was
    coined for the first time, with its focus primarily based on blockchain. APIs
    became fundamental for companies creating and delivering their products to the
    public.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 十年后，在2010年代，网络协议更为发展。那是社交媒体和应用程序的时代，每分钟数百万个请求。举个例子，2013年，每分钟互联网流量中，包括其他流量，461,805个Facebook登录，38,000张Instagram照片上传和347,000条推文发送。这也是容器和基于微服务的应用程序迎来最广泛采用的十年。Kubernetes的发布，作为开源容器编排工具，扩大了互联网动态应用的可能性。正是在2010年代，**Web
    3.0**这一术语首次被提出，主要聚焦于区块链技术。API成为了公司为公众创建和交付产品的基础。
- en: As the Tears for Fears’ 1985 hit song *Head Over Heels* states, it’s “*funny
    how time flies*”. Time really flew and we arrived in the 2020s. Nowadays, applications
    keep modernizing themselves, but now we have the presence of systems running even
    more spread. The advent of concepts such as edge computing and the **Internet
    of Things** (**IoT**) increased the complexity of the whole scenario and demanded
    the evolution of APIs to encompass such changes. Web 3.0 was, in fact, only incorporated
    in 2021\. We currently have applications being designed and developed around an
    API, and not the opposite, as it happened in the early stages of the technology.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Tears for Fears 1985年热曲*Head Over Heels*所说，时间过得“*真是快得令人惊讶*”。时光飞逝，我们进入了2020年代。如今，应用程序不断更新，但我们现在有了更加分散运行的系统。边缘计算和**物联网**
    (**IoT**) 等概念的出现增加了整个场景的复杂性，并要求API进化以适应这些变化。Web 3.0实际上是在2021年才被纳入。现在，我们正在设计和开发围绕API的应用程序，而不是像技术早期那样反过来。
- en: API types and protocols
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 类型和协议
- en: 'Back to our web world, there are some notable API protocols:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的网络世界，这里有一些显著的API协议：
- en: '**Simple Object Access Protocol** (**SOAP**): This allows access to objects,
    maintains communication using HTTP, and is based on **Extensible Markup Language**
    (**XML**). It is simple and presents a good way to establish communications between
    web applications, as it is OS-independent and agnostic about technologies and
    programming languages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单对象访问协议** (**SOAP**)：它允许访问对象，通过HTTP保持通信，并基于**可扩展标记语言** (**XML**) 。它简单且提供了一个很好的方式来建立Web应用程序之间的通信，因为它是操作系统独立的，且不依赖于技术和编程语言。'
- en: '**REST**: Maybe one of the most famous web API protocols in use nowadays, REST
    is an architectural style to design web services. Therefore, the services that
    follow such a style are said to be **RESTful**. The predefined set of REST operations
    is stateless, and the services have access to constructs to manipulate text-based
    representations of the data.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST**：也许是现在使用的最著名的Web API协议，REST是一种设计Web服务的架构风格。因此，遵循这种风格的服务被称为**RESTful**。REST操作的预定义集合是无状态的，服务可以访问构造来操作数据的文本表示形式。'
- en: '**Google Remote Procedure Call** (**gRPC**): Developed by the company behind
    the search engine, it is another HTTP-based architecture that happens to be open
    source. It applies buffers to allow data transmissions between pairs.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌远程过程调用** (**gRPC**)：由搜索引擎背后的公司开发，它是另一种基于HTTP的架构，恰好是开源的。它应用缓冲区以允许数据在对之间传输。'
- en: '**JavaScript Object Notation – Remote Procedure Call** (**JSON-RPC**): Just
    like REST, JSON-RPC is also stateless, uses objects (like SOAP), and can be applied
    instead of REST when higher performance is necessary.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法 – 远程过程调用** (**JSON-RPC**)：就像REST一样，JSON-RPC也是无状态的，使用对象（像SOAP一样），并且在需要更高性能时可以替代REST。'
- en: '**Graph Query Language** (**GraphQL**): It was created by Meta (previously
    Facebook) and designed to be a database query language. GraphQL is open source
    and allows for complex responses by using simple data structures such as JSON.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形查询语言** (**GraphQL**)：由Meta（前身为Facebook）创建，旨在成为一种数据库查询语言。GraphQL是开源的，通过使用JSON等简单数据结构，允许复杂的响应。'
- en: Let’s analyze each one of them in more depth.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地分析每个协议。
- en: SOAP
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP
- en: 'Since SOAP is based on objects, for the sake of simplicity, both peers in a
    conversation must agree on which elements they would use to exchange information.
    SOAP messages are implemented by regular XML files containing at least the following
    elements:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SOAP是基于对象的，为了简化，通信中的两个对等方必须就他们交换信息时使用的元素达成一致。SOAP消息由常规的XML文件实现，至少包含以下元素：
- en: '**Body**: It keeps information about the call and the response.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：它包含关于调用和响应的信息。'
- en: '**Envelope**: This identifies a file as a SOAP message.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信封**：这用于将文件标识为SOAP消息。'
- en: '**Fault**: It carries information about errors and status.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障**：它携带有关错误和状态的信息。'
- en: '**Header**: As the name implies, holds header information.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：顾名思义，包含头部信息。'
- en: 'Although SOAP messages must use XML as their structure, such documents cannot
    contain processing instructions or **Document Type Definitions** (**DTDs**). An
    XML document has its attributes defined inside a DTD. The SOAP 1.1 specification
    had three parts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SOAP消息必须使用XML作为结构，但此类文档不能包含处理指令或**文档类型定义**（**DTDs**）。XML文档的属性是在DTD内定义的。SOAP
    1.1规范有三部分：
- en: The **envelope**, where the contents of the message are defined, the responsible
    structures that should handle it, and a specification if it is mandatory or optional.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信封**，定义了消息的内容、应该处理它的结构，以及是否是强制性的或可选的规格。'
- en: The **encoding rules** that define the mechanism to be used when serializing
    the datatype.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码规则**，定义了序列化数据类型时使用的机制。'
- en: The **RPC** representation that indicates how to represent remote calls and
    their responses.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPC**表示法，用于指示如何表示远程调用及其响应。'
- en: 'The SOAP 1.2 specification has only two parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 1.2规范只有两个部分：
- en: The message envelope.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息信封。
- en: The data model and protocol bindings.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型和协议绑定。
- en: 'In terms of organizational structure, SOAP messages are comprised of namespaces.
    The root element is the SOAP envelope. The `Header`, `Body`, and eventual `Fault`
    elements are all inside of it. All SOAP envelopes must specify the `http://www.w3.org/2003/05/soap-envelope/`
    `encodingStyle` attribute may appear to indicate which encoding schema is used
    inside the message. The envelope declaration would look something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从组织结构的角度来看，SOAP消息由命名空间组成。根元素是SOAP信封。`Header`、`Body`和最终的`Fault`元素都包含在其中。所有SOAP信封必须指定`http://www.w3.org/2003/05/soap-envelope/`，`encodingStyle`属性可能出现在其中，以指示消息内部使用的编码模式。信封声明可能如下所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A header in a SOAP message is optional, but if one is present, it must be at
    the beginning of the message, just after the `Envelope` declaration. Its purpose
    is to store data that is specific to the application, such as payment information
    or an `env:role`, `env:mustUnderstand`, and `env:relay`. The first one is used
    to define which role is associated with the header block. The second one is a
    Boolean variable. When true, it means that the recipient of the message must process
    the header. If some issue is raised while processing the header, a fault element
    is generated. Finally, the `env:relay` component is only checked or processed
    by relay (intermediary nodes). It is a new feature of the SOAP 1.2 specification.
    An example header with two blocks could look like this (the tags were wrapped
    in multiple lines to facilitate reading):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP消息中的头部是可选的，但如果存在，它必须位于消息的开始位置，即在`Envelope`声明之后。其目的是存储特定于应用程序的数据，例如支付信息或`env:role`、`env:mustUnderstand`和`env:relay`。第一个用于定义与头部块关联的角色。第二个是一个布尔变量，当其值为`true`时，表示消息的接收者必须处理该头部。如果在处理头部时出现问题，则会生成一个故障元素。最后，`env:relay`组件仅由中继（中间节点）检查或处理。它是SOAP
    1.2规范中的新特性。一个包含两个块的示例头部可能如下所示（标签被分成多行以便于阅读）：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the block A part has a `mustUnderstand` clause that is `true`,
    which means that the recipient must process it. Block B is meant to be parsed
    by intermediary nodes only, since the `env:relay` attribute is set to `true`.
    Both blocks have role specifications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，A块部分有一个`mustUnderstand`子句，其值为`true`，意味着接收者必须处理它。B块仅供中间节点解析，因为`env:relay`属性被设置为`true`。这两个块都有角色规范。
- en: '**XML Protocol** (**XMLP**) was another XML-based message-exchanging protocol
    that was on spot until 2009, two years after SOAP specification 1.2 was released.
    XMLP proposed an abstract model, whereas SOAP details the primitives to allow
    for the practical application of this model. SOAP and XMLP have the concept of
    binding that determines which other protocol XMLP and/or SOAP should connect to
    work. One of (if not the) most popular bindings for SOAP is HTTP. This means that
    SOAP messages can and are effectively employed to allow communication of peers
    through HTTP.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML协议**（**XMLP**）是另一种基于XML的消息交换协议，直到2009年才停止使用，SOAP规范1.2发布后的两年。XMLP提出了一个抽象模型，而SOAP详细描述了实现该模型的基本原语。SOAP和XMLP都具有绑定的概念，用于确定XMLP和/或SOAP应连接的其他协议。SOAP最流行的绑定之一（如果不是最流行的话）就是HTTP。这意味着SOAP消息可以有效地用于通过HTTP实现对等通信。'
- en: REST
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: 'The predefined set of REST operations is stateless (as is also the case with
    XMLP), and the services have access to constructs to manipulate text-based representations
    of the data. While SOAP and XMLP have bindings that allow both to connect to other
    application-layer protocols and even to the transport layer (TCP or UDP), REST
    is more related to HTTP (also stateless), and therefore, manipulating such constructs
    reduces the learning curve for developers and sysadmins that are already used
    to HTTP terms. While using HTTP, all the protocol’s methods are available with
    REST: `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT`, and
    `TRACE`. REST was used to define the HTTP version 1.1 specification.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的REST操作集是无状态的（与XMLP相同），并且服务可以访问构造体来操作数据的文本表示。尽管SOAP和XMLP具有绑定功能，可以将它们连接到其他应用层协议，甚至传输层（TCP或UDP），但REST更多与HTTP相关（同样是无状态的），因此，操作这些构造体减少了开发人员和系统管理员学习HTTP术语的难度。使用HTTP时，REST可以使用协议的所有方法：`CONNECT`、`DELETE`、`GET`、`HEAD`、`OPTIONS`、`PATCH`、`POST`、`PUT`
    和 `TRACE`。REST用于定义HTTP 1.1版本的规范。
- en: 'There may be the presence of intermediary nodes, which, in the case of REST,
    are translated as gateways such as cache or proxy servers, or even firewalls.
    Those nodes could allow scalability to the architecture since no state is held
    inside the messages, and some explicit cache information could be inserted into
    the responses. According to Roy Fielding’s specification, there are six constraints
    that rule whether a system can be categorized as RESTful. They are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在中介节点，在REST的情况下，这些节点表现为网关，如缓存或代理服务器，甚至是防火墙。这些节点可能为架构提供可扩展性，因为消息内部不保存状态，而且可以在响应中插入一些显式的缓存信息。根据Roy
    Fielding的规范，有六个约束条件决定一个系统是否可以被归类为RESTful，具体如下：
- en: '**Client-server**: Although there might be intermediary nodes, the communication
    usually happens between two peers only.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：尽管可能存在中介节点，但通信通常只发生在两个对等体之间。'
- en: '**Stateless**: No state is stored in RESTful messages. The session state must
    be managed by the client. As the state is not controlled, this grants scalability
    to the architecture.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：RESTful消息中不存储状态。会话状态必须由客户端管理。由于状态不被控制，这使得架构具备可扩展性。'
- en: '**Cache**: Intermediary nodes can present themselves as cache servers. The
    server points to the content that can be cached, and this is respected by the
    client.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：中介节点可以充当缓存服务器。服务器指向可以缓存的内容，客户端会遵循这一指引。'
- en: '**Uniform interface**: Using generality, the architecture becomes simpler,
    which improves the visibility of interactions.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：通过使用通用性，架构变得更简单，从而提高了交互的可见性。'
- en: '**Layered system**: Through the adoption of a hierarchy, each layer only has
    visibility to the layers it directly interacts with, which allows for the encapsulation
    of legacy services.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：通过采用层级结构，每一层仅能访问与其直接交互的其他层，这样可以实现对遗留服务的封装。'
- en: '**Code-on-demand**: Client functionality can be extended through the download
    and execution of additional codes from the server, which simplifies the client
    design.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：通过从服务器下载和执行额外的代码，可以扩展客户端功能，从而简化客户端设计。'
- en: The heart of any REST-based design is the `POST`, Read relates to `GET`, Update
    relates to `PUT` and Delete relates to `DELETE` (HTTP verbs are usually represented
    in technical literature with all capital letters).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任何基于REST的设计的核心是`POST`，读取操作对应`GET`，更新操作对应`PUT`，删除操作对应`DELETE`（HTTP动词通常在技术文献中用大写字母表示）。
- en: Despite the similarities, some notable differences exist between REST and SOAP.
    They are specially related to how to do remote invocations (RPCs). On the other
    hand, with REST, a client locates a resource in a server and chooses what to do
    with it (change it, delete it, or get info about it – which could be mapped to
    the `UPDATE`, `DELETE`, and `GET` HTTP methods, respectively). With SOAP, there
    is no direct interaction with a resource. Instead, the client needs to call a
    service and the service, in turn, does all the required actions with related objects
    and resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管REST和SOAP有许多相似之处，但它们在如何进行远程调用（RPC）方面存在一些显著的差异。另一方面，在REST中，客户端定位服务器中的资源，并选择对其进行什么操作（修改、删除或获取信息——分别对应`UPDATE`、`DELETE`和`GET`
    HTTP方法）。在SOAP中，客户端不会直接与资源进行交互。相反，客户端需要调用一个服务，服务再对相关的对象和资源执行所需的操作。
- en: To circumvent this way of work, SOAP leverages some frameworks that allow it
    to give additional capability to the clients. One of those frameworks is `getTermRequest`,
    and a type, such as `string`, WSDL grants one step beyond using SOAP with web
    services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这种工作方式，SOAP利用了一些框架，允许它为客户端提供额外的功能。其中一个框架是`getTermRequest`，例如`string`类型，WSDL在使用SOAP进行Web服务时提供了更进一步的能力。
- en: We need to understand why REST virtually took over SOAP in the modern web API
    landscape. One of the points that counted in favor of REST when compared to SOAP
    was that SOAP is based on XML. This language can produce quite complex and verbose
    documents that obviously need to be correctly crafted by the sender and parsed
    by the receiver. Parsing an XML document (or structure) means reading it and transforming
    its elements into some data structure that can be further handled by the application.
    One of the most well-known parsers is called **Document Object Model** (**DOM**).
    One drawback of using DOM is its high memory consumption, which might be many
    times bigger than the amount of memory originally described in the document.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解为什么REST几乎完全取代了SOAP，成为现代Web API领域的主流。比较REST和SOAP时，支持REST的一个关键因素是SOAP基于XML。XML语言能够生成相当复杂且冗长的文档，这些文档显然需要发送方正确构造，并由接收方解析。解析XML文档（或结构）意味着读取它并将其元素转换为一种数据结构，之后应用程序可以进一步处理。最著名的解析器之一叫做**文档对象模型**（**DOM**）。使用DOM的一个缺点是它消耗大量内存，可能是文档中原始描述的内存大小的几倍。
- en: In computer science, data serialization is the activity of transforming abstract
    objects (or elements) present in data structures into something that can be stored
    at or transferred between computers. Deserialization means the opposite. Data
    serialization becomes more complex as nesting is used in documents. XML allows
    element nesting. There is no formal limit for this in the XML specification, which
    essentially means that an infinite number of elements could be nested. Complexity
    may raise security threats. Through the parsing of an XML document, an application
    could store its elements in a **Structured Query Language** (**SQL**) database,
    translating them to tables, rows, and columns, or even as **Key-Value** (**KV**)
    pairs in a NoSQL database. When accepting serialized objects from unknown or untrusted
    sources, this might impose an unnecessary risk to the application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，数据序列化是将数据结构中存在的抽象对象（或元素）转换成可以存储在计算机上或在计算机之间传输的格式的过程。反序列化是与此相反的操作。随着文档中使用嵌套，数据序列化变得更加复杂。XML允许元素嵌套。在XML规范中没有正式的限制，这基本上意味着元素可以无限制地嵌套。复杂性可能带来安全威胁。通过解析XML文档，应用程序可以将其元素存储在**结构化查询语言**（**SQL**）数据库中，将其转换为表、行和列，甚至作为NoSQL数据库中的**键值**（**KV**）对。当从未知或不可信的源接受序列化对象时，这可能会给应用程序带来不必要的风险。
- en: '**Open Web Application Security Project** (**OWASP**) is a global organization
    that regularly releases cyber security best practices, including secure code development,
    and maintains some notable security projects. One of them is **Top Ten**, which
    lists the top ten most dangerous threats to web applications. The most current
    version was published in 2021\. Insecure data deserialization is in the *A03-2021
    Injection* group, which means that it is considered the third-most dangerous threat
    for applications.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放Web应用程序安全项目**（**OWASP**）是一个全球性组织，定期发布网络安全最佳实践，包括安全的代码开发，并维护一些著名的安全项目。其中之一是**Top
    Ten**，它列出了对Web应用程序最具威胁性的十大安全问题。最新版本发布于2021年。数据反序列化不安全属于*A03-2021 注入*类别，这意味着它被认为是应用程序第三大最危险的威胁。'
- en: Under the same project but classified as the fifth-most dangerous threat to
    web security is the **XML External Entities** (**XXE**) attack, categorized under
    the *A05-2021 Security Misconfiguration* group. If an XML document makes use of
    DTDs, it can be incorrectly interpreted by the XML parser. A DTD was the first
    way to specify the structure of an XML document, and it can also be used to determine
    how XML data should be stored.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一项目中，**XML外部实体**（**XXE**）攻击被归类为对网络安全构成的第五大危险威胁，属于*2021年A05安全配置错误*组。如果XML文档使用了DTD，它可能会被XML解析器错误地解读。DTD是指定XML文档结构的第一种方式，它还可以用来确定XML数据应如何存储。
- en: With the usage of DTDs, a vulnerable XML parser might be the victim of a **Denial
    of Service** (**DoS**) attack called an **XML bomb** (also known as **a billion
    laughs attack**). Through the specification of ten DTD entities, with each subsequent
    entity being ten times a reference of the previous entity, this would result in
    one billion copies of the first entity. As previously explained, to accommodate
    all entities in memory, the XML parser needs to allocate a considerable amount
    of memory, eventually crashing and making the application unavailable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DTD时，一个易受攻击的XML解析器可能会成为**拒绝服务**（**DoS**）攻击的受害者，这种攻击被称为**XML炸弹**（也称为**十亿笑话攻击**）。通过指定十个DTD实体，每个后续实体是前一个实体的十倍引用，这将导致第一个实体出现十亿次。如前所述，为了在内存中容纳所有实体，XML解析器需要分配大量内存，最终会崩溃，导致应用程序无法使用。
- en: 'REST APIs, on the other hand, are primarily based on JSON data structures.
    Those are simpler documents organized as maps that leverage the concept of KV
    pairs. JSON files do not require a specific parser; they support different types
    of data, such as strings, Boolean, numbers, arrays, and objects. However, JSON
    files are usually smaller when compared to their equivalents on XML. JSON also
    does not support comments. JSON structures are therefore more compact, as well
    as easy to craft and process. The code block that follows contains an example
    of a JSON structure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，REST API主要基于JSON数据结构。这些是更简单的文档，作为映射组织，利用键值对（KV对）的概念。JSON文件不需要特定的解析器；它们支持不同类型的数据，如字符串、布尔值、数字、数组和对象。然而，与XML文件相比，JSON文件通常较小。JSON也不支持注释。因此，JSON结构更紧凑，也更容易编写和处理。下面的代码块包含一个JSON结构的示例：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: gRPC
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC
- en: The core idea of gRPC is to let you, a developer, invoke a remote method (located
    on your colleague’s computer or on the other side of the world) as if it was in
    your codebase itself. In other words, a client (or **stub**, as it is referred
    to inside the specification) calls a function, with its expected parameters, but
    that function is not even inside its code. It is implemented somewhere else. To
    tackle this, you need to follow definitions established by the server side of
    the gRPC invocation. Such definitions include the acceptable data types and the
    methods to return after their invocations end. Everything is based on creating
    a service that will leverage such methods to provide data to clients.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC的核心思想是让你作为开发者，调用一个远程方法（位于你同事的电脑上或世界另一端），就像它在你自己的代码库中一样。换句话说，客户端（在规范中称为**存根**）调用一个函数，带有预期的参数，但该函数甚至不在它的代码中，而是在其他地方实现的。为了解决这个问题，你需要遵循gRPC调用的服务器端所定义的规范。这些定义包括可接受的数据类型以及方法调用结束后返回的内容。所有的工作都基于创建一个服务，通过这些方法向客户端提供数据。
- en: Another interesting part of gRPC is the support of modern programming languages,
    which allows you to split the development efforts among your team, with, for example,
    the Go programmers being responsible for the server and the Python programmers
    being occupied with building the client. As the protocol was created by Google,
    a gRPC server can also be hosted on the company’s public cloud.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC的另一个有趣的特点是它对现代编程语言的支持，这使得你可以在团队中分配开发任务，例如，让Go程序员负责服务器，而Python程序员则专注于构建客户端。由于该协议是由Google创建的，因此gRPC服务器也可以托管在公司的公共云上。
- en: 'There is one major difference between gRPC and the other two protocols already
    covered: it uses `protoc` protocol buffer compiler, object classes are created
    in your code. The data structures are stored in text files with the `.proto` extension.
    In a `.proto` file, you create a service and define what makes the message that
    will flow between the client and server. When you run `protoc`, it creates or
    updates the corresponding classes. The code block that follows shows an example
    of a file like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 与之前讨论的其他两种协议之间有一个主要的区别：它使用 `protoc` 协议缓冲编译器，数据类在代码中创建。数据结构存储在 `.proto`
    扩展名的文本文件中。在 `.proto` 文件中，你创建一个服务并定义在客户端和服务器之间流动的消息。当你运行 `protoc` 时，它会创建或更新相应的类。以下代码块展示了一个这样的文件示例：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, you are creating a service called `ProcessFile` that
    is invoked by the client side of your application on a method called `FileRequest`
    that returns `ExitCode` as the output. This last method is implemented on the
    server portion of your application. Obviously, as per the definition of gRPC,
    client and server portions can be in separate machines. Services can be of four
    different types:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你正在创建一个名为`ProcessFile`的服务，该服务由应用程序的客户端在一个名为`FileRequest`的方法中调用，该方法返回`ExitCode`作为输出。这个方法的实现位于应用程序的服务器部分。显然，根据
    gRPC 的定义，客户端和服务器部分可以位于不同的机器上。服务可以有四种不同的类型：
- en: '**Unary**: The client sends a single request and waits for a single response.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元请求**：客户端发送一个请求并等待一个响应。'
- en: '**Server Streaming**: The client sends a request, and the response is returned
    as a stream of messages. The messages are sent in sequence.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器流式传输**：客户端发送一个请求，响应作为消息流返回。消息按顺序发送。'
- en: '**Client Streaming**: The client sends a sequence of messages and waits for
    a single response from the server.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端流式传输**：客户端发送一系列消息并等待来自服务器的单一响应。'
- en: '**Bidirectional Streaming**: Both parts send sequences of messages.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向流式传输**：两方都发送消息序列。'
- en: It is interesting to realize how gRPC also works as a `protoc` compiler. In
    Python, the compiler is implemented as a **Package Installer for Python** (**PIP**)
    module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，gRPC 也可以作为 `protoc` 编译器。在 Python 中，编译器作为 **Python 包安装器** (**PIP**) 模块实现。
- en: JSON-RPC
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: As we’ve introduced, JSON-RPC is a good replacement for REST when performance
    is an important factor. One characteristic of this protocol is that a client can
    send a request with no need to wait for a server response. Another feature allows
    clients to send multiple requests to the server and the server returning the responses
    out of the original requested order. In other words, the server’s responses follow
    asynchronously.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们介绍的，JSON-RPC 是当性能是一个重要因素时，替代 REST 的一个不错选择。该协议的一个特点是，客户端可以发送请求而无需等待服务器的响应。另一个特点是，客户端可以向服务器发送多个请求，服务器返回的响应顺序与原始请求顺序不同。换句话说，服务器的响应是异步跟随的。
- en: The current specification is 2.0 and it is not fully compatible with the previous
    one (1.0). JSON-RPC 2.0 request and response objects may not be correctly understood
    when the client and server are not running the same version of the protocol, although
    it is easy to identify the 2.0 specification, since it uses a `jsonrpc` key whose
    value is `2.0`. All JSON primitives (strings, numbers, Booleans, null) and structures
    (arrays and objects) are fully supported.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的规范是 2.0，并且与之前的 1.0 版本不完全兼容。当客户端和服务器没有运行相同版本的协议时，JSON-RPC 2.0 请求和响应对象可能无法正确理解，尽管容易识别
    2.0 规范，因为它使用一个名为 `jsonrpc` 的键，其值为 `2.0`。所有 JSON 原始数据类型（字符串、数字、布尔值、null）和结构（数组和对象）都得到完全支持。
- en: 'There is a strict syntax (remember when we started talking about API definitions?)
    that must be respected when sending requests and receiving responses. The following
    are possible members of a request:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求和接收响应时，必须遵守严格的语法（记得我们之前提到过 API 定义吗？）。以下是请求中可能的成员：
- en: '`jsonrpc`: This contains `2.0` when this is the specification in use.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonrpc`：当使用该规范时，它包含 `2.0`。'
- en: '`method`: String containing the name of the remote method to be invoked.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：包含要调用的远程方法名称的字符串。'
- en: '`params`: Optional member that’s structured (either an array or object) and
    contains parameters to be passed to the invoked method.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：可选成员，结构化（可以是数组或对象），包含传递给调用方法的参数。'
- en: '`id`: Optional member that can be a string, number, or null and contains the
    identification of the request.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：可选成员，可以是字符串、数字或 null，包含请求的标识。'
- en: 'Likewise, there is a definition for the response structure. Its members are
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也有响应结构的定义。其成员如下：
- en: '`jsonrpc`: Same description as for the request.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonrpc`：与请求中的描述相同。'
- en: '`result`: Exists only when the method was successfully invoked; the contents
    are provided by the invoked method.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`：仅在方法成功调用时存在；其内容由调用的方法提供。'
- en: '`error`: Only exists when the method is not successfully invoked; this is an
    object member, and its contents are provided by the invoked method.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：仅在方法未成功调用时存在；这是一个对象成员，其内容由调用的方法提供。'
- en: '`id`: Same description as for the request, needs to carry the same value as
    the one specified in the request.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：与请求中的描述相同，需要携带与请求中指定的相同值。'
- en: 'The error object has its own structure. You can easily realize another difference
    between REST and JSON-RPC. There are no HTTP methods, such as `GET`, `PUT`, or
    `POST`, to be called. Instead, a simple JSON structure is provided. Another difference
    lies in the response. Where REST can use JSON or XML formats, JSON-RPC only supports
    JSON. For error handling, you just saw that JSON-RPC has its own `error` member.
    REST provides HTTP status codes, such as 200 (`IsStudent` is invoked to return
    `True` or `False` should a provided numeric enrollment `id` be a registered student.
    The first request succeeds, while the second request generates an error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 错误对象有其自己的结构。你可以很容易地看出 REST 和 JSON-RPC 之间的另一个区别。没有 `GET`、`PUT` 或 `POST` 等 HTTP
    方法被调用。相反，提供了一个简单的 JSON 结构。另一个区别在于响应格式。REST 可以使用 JSON 或 XML 格式，而 JSON-RPC 仅支持 JSON。在错误处理方面，你刚刚看到
    JSON-RPC 有其自己的 `error` 成员。REST 提供了 HTTP 状态码，例如 200（当提供的数字注册 `id` 是已注册学生时，`IsStudent`
    会返回 `True` 或 `False`。第一个请求成功，而第二个请求会产生错误）：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GraphQL
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: GraphQL, as the name implies, is a language to allow querying data served by
    an API. Wait a moment! This is inside a subsection on protocols. What is a language
    doing here? A generic definition of protocol could be “*a set of rules that need
    to be properly followed to allow the successful establishment of communication
    between two or more peers.*” GraphQL implements this as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，GraphQL 是一种用于查询由 API 提供的数据的语言。等等！这在协议小节里，语言怎么在这里？协议的一般定义可以是“*一组规则，必须正确遵循才能成功建立两个或更多对等方之间的通信。*”
    GraphQL 也实现了这一点。
- en: It was created by Meta (then Facebook) in 2012 and released as an open source
    project in 2015\. Later, in 2018, it was started to be hosted by the Linux Foundation
    and its ownership was taken by the GraphQL Foundation. One notorious feature is
    the fact that a single endpoint is exposed, making it easier for developers to
    request and receive the desired data. Other API protocols may eventually expose
    multiple endpoints to fulfill the needs of providing different types of data,
    or data spread in various databases or systems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它由 Meta（当时是 Facebook）在 2012 年创建，并于 2015 年作为开源项目发布。后来，2018 年，它开始由 Linux 基金会托管，并由
    GraphQL 基金会接管了所有权。一个著名的特点是，GraphQL 只暴露一个端点，方便开发者请求和接收所需的数据。其他 API 协议可能最终会暴露多个端点，以满足提供不同类型数据或数据分布在多个数据库或系统中的需求。
- en: The data formats are also like JSON with some slight changes. There is a tremendous
    difference between GraphQL and REST. Rather than making requests, fetching the
    results, and adjusting the requests after analyzing the results to then submit
    new requests, with GraphQL, the application can interactively change the request
    until the received results are satisfactory. This is supported by **WebSockets**,
    a technology that allows continuous bidirectional communications between an HTTP
    client and a server where both sides send and receive data and any side can close
    the connection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式也类似于 JSON，只是有一些微小的变化。GraphQL 和 REST 之间有着巨大的差异。与其发出请求、获取结果，并在分析结果后调整请求然后提交新请求，GraphQL
    允许应用程序交互式地更改请求，直到接收到令人满意的结果。这得到了**WebSockets**的支持，这是一种允许 HTTP 客户端与服务器之间进行持续双向通信的技术，双方都可以发送和接收数据，任何一方都可以关闭连接。
- en: 'Since any side, client, or server can send data to each other at any time,
    WebSockets is also useful for sending notifications, especially from server to
    client, while the connection is still open. One possible application for this
    protocol is a currency exchange website. A client queries the server for the rate
    once. Every time the rate changes, the server notifies the client of the new rate.
    GraphQL also supports query parameters. You can filter results based on a criterion
    or ask the server to make data conversions or calculations all in the same query.
    The code block that follows shows an example of a request:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何一方，客户端或服务器，随时都可以互相传输数据，WebSockets 也非常适合用于发送通知，尤其是从服务器到客户端，当连接仍然保持开放时。这个协议的一个应用场景是货币兑换网站。客户端只需查询一次服务器获取汇率，每当汇率变化时，服务器就会通知客户端新的汇率。GraphQL
    也支持查询参数。你可以基于某个标准过滤结果，或者请求服务器进行数据转换或计算，所有操作都在同一个查询中完成。接下来的代码块展示了一个请求的示例：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code queries the server for a student whose `id` is `100`. The
    client wants the student’s name and their grade, but only the average grade (calculated
    over the course modules), not the grade itself (`average: True`). A possible answer
    is in the code block that follows. Observe that responses in GraphQL follow the
    structure of the request:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '上面的代码查询服务器获取一个 `id` 为 `100` 的学生。客户端想要学生的姓名和他们的成绩，但只需要平均成绩（通过课程模块计算的平均分），而不是具体成绩（`average:
    True`）。一个可能的答案在下面的代码块中。请注意，GraphQL 的响应遵循与请求相同的结构：'
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: GraphQL data structures have a schema. This way, when designing queries, a developer
    will know the possible types of data that could be returned in a response in advance.
    It is useful to know that a single query may generate a list of items as a response
    with not much effort, considering the schemas have been properly set.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的数据结构有一个模式。这样，在设计查询时，开发人员可以提前知道响应中可能返回的数据类型。值得注意的是，考虑到模式已经正确设置，一个查询可能只需少量的努力就能生成一系列项目作为响应。
- en: Importance of API security
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 安全性的重要性
- en: Even with the simple code and template examples you have seen here, an attentive
    reader will realize that potential security flaws may arise from them since those
    simple data structures and queries can result in extensive resource consumption
    with a small number of lines. Secure software development is not a new buzzword
    but has gradually received more focus as new threats and attacks enter general
    awareness.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是你在这里看到的简单代码和模板示例，一个细心的读者也会意识到，从这些简单的数据结构和查询中可能会产生潜在的安全漏洞，因为这些简单的结构和查询可能会用少量的代码行造成大量的资源消耗。安全软件开发并不是一个新的流行词，但随着新威胁和攻击的出现，它逐渐获得了更多的关注。
- en: 'Some companies prefer investing more of their time and money into containment
    strategies, such as implementing an incident response team, bound to a business
    continuity plan. Albeit very important, we know that such teams are put into action
    when something has already happened. They can only do damage control, trying to
    reduce the impact some intrusion has on the company’s assets. Some other companies
    believe that their systems are secure simply because they are running on a public
    cloud. It is well known that public cloud players share this responsibility with
    their customers in a way that is called the shared responsibility model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司更倾向于将更多的时间和资金投入到应急策略中，例如实施一个与业务连续性计划相绑定的事故响应团队。尽管这一点非常重要，我们知道这些团队通常是在事情发生之后才投入使用。他们只能进行损害控制，尽量减少某些入侵对公司资产的影响。其他一些公司则认为他们的系统是安全的，仅仅因为它们运行在公共云上。众所周知，公共云服务商与客户共享安全责任，这种方式被称为共享责任模型：
- en: '![Figure 1.2 – The public cloud shared responsibility model](img/B19657_01_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 公共云共享责任模型](img/B19657_01_02.jpg)'
- en: Figure 1.2 – The public cloud shared responsibility model
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 公共云共享责任模型
- en: As it is valid with any substantial software being developed, APIs have their
    life cycles, and they belong to a pipeline. There is a general sense that security
    should be shifted left as much as possible, which means that concerns about potential
    flaws should be taken into consideration sooner rather than later. You need to
    think about security starting with the API design. However, this may not be exactly
    easy for companies with a small budget or without proper technical enablement.
    This is to say that not all companies adopt security countermeasures in the early
    stages because they simply cannot.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何正在开发的重大软件一样，API 也有它们的生命周期，并且它们属于一个管道。普遍的看法是，安全性应该尽可能向左迁移，这意味着应该尽早考虑潜在缺陷的安全问题，而不是等到后期再考虑。你需要从
    API 设计开始就考虑安全性。然而，对于预算有限或缺乏适当技术支持的公司来说，这可能并不容易。也就是说，并非所有公司在早期阶段都会采取安全对策，因为它们根本做不到。
- en: When developing an API, you should start by choosing the protocol your API will
    use. Consider the ones discussed here and select one that you believe will fulfill
    the application’s needs and user expectations. Look for the protocol’s drawbacks
    and verify the possibility of letting a public cloud player implement the API
    for you. All major players have API management or gateway offerings. They usually
    implement security best practices and are integrated with web firewalls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 API 时，你应该从选择你的 API 将使用的协议开始。考虑这里讨论过的协议，并选择一个你认为能满足应用程序需求和用户期望的协议。查找协议的缺点，并验证是否可以让一个公共云服务商为你实现
    API。所有主要的云服务商都有 API 管理或网关服务。它们通常实施安全最佳实践，并与 Web 防火墙集成。
- en: APIs are frequently the only entrance doors, or at least the most used ones,
    for applications. This is why reinforcing them is paramount for any business segment.
    All parts of an API should get their corresponding protection. For example, how
    do you handle AuthN and **Authorization** (**AuthZ**)? Do you use tokens or only
    user/password credentials pairs? How are such tokens or credentials stored and
    how do they flow between your API endpoints and clients? Do you handle their life
    cycles? Do you record every time a token or credential is used and what parts
    of your system a user with such tokens or credentials tries to access? Do you
    frequently rotate tokens or credentials? Can you see how many questions were raised
    for a single point of attention? Badly handled AuthN and AuthZ may lead to potential
    intrusions and massive damage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: API 通常是应用程序唯一的入口点，或者至少是最常用的入口。这就是为什么加强它们的安全性对任何业务领域都至关重要的原因。API 的每个部分都应该获得相应的保护。例如，你是如何处理身份认证（AuthN）和**授权**（**AuthZ**）的？你是使用令牌还是仅使用用户名/密码凭证对？这些令牌或凭证是如何存储的，并且它们如何在
    API 端点和客户端之间流动？你是否管理它们的生命周期？你是否记录每次令牌或凭证的使用情况，以及拥有这些令牌或凭证的用户试图访问系统的哪些部分？你是否定期旋转令牌或凭证？你能看到仅仅一个关注点就提出了多少问题吗？处理不当的身份认证（AuthN）和授权（AuthZ）可能导致潜在的入侵和重大损失。
- en: Common API vulnerabilities
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 API 漏洞
- en: AuthN and AuthZ are just some of the topics that deserve strict care when designing
    and developing an API. Although they are two separate concepts, they are usually
    spoken of and discussed together because it does not make much sense to have one
    without the other. They are not only relevant when dealing with external users.
    When your application needs to interact with internal systems or partner applications,
    the same or other controls must be in place. Applications talk to applications,
    and impersonating an application or an external user is the first vulnerability
    I would like to talk about.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 身份认证（AuthN）和授权（AuthZ）只是设计和开发 API 时需要特别注意的众多话题之一。尽管它们是两个独立的概念，但通常会一起讨论，因为没有一个就没有另一个的意义。它们不仅在处理外部用户时相关。当你的应用程序需要与内部系统或合作伙伴应用程序进行交互时，同样或其他的控制措施也必须到位。应用程序之间会相互通信，冒充应用程序或外部用户是我想要讨论的第一个漏洞。
- en: OWASP, the same organization mentioned earlier, also owns the **Top 10 API 2023**
    security project. Its API Security Top 10 initiative positions API1:2023 – **Broken
    Object Level AuthZ** and API1:2023 – **Broken AuthN** as the two most dangerous
    threats. The first topic is about not correctly handling access to objects throughout
    the API execution. This can lead to inadvertent exposure of data, including sensible
    data, to unauthorized people. So, controls to verify and protect access at the
    level of objects need to be in place. The second topic is related to what we discussed
    in the last paragraph of the previous section. Incorrectly handling AuthN data
    or implementing weak AuthN mechanisms or with known security flaws becomes a very
    big headache on your API management.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP，这个我们之前提到的组织，也拥有**2023 年 API 安全前十**项目。它的 API 安全前十倡议将 API1:2023——**破损的对象级权限控制（Broken
    Object Level AuthZ）**和 API1:2023——**破损的身份验证（Broken AuthN）**定位为两个最危险的威胁。第一个话题是关于在
    API 执行过程中未正确处理对对象的访问。这样可能会导致敏感数据无意中暴露给未授权的人。因此，必须在对象级别上实施访问验证和保护措施。第二个话题与上一段讨论的内容相关。错误地处理身份验证数据，或实施了弱身份验证机制或已知的安全漏洞，会成为
    API 管理中的一个重大难题。
- en: Moving on, we have **Broken Object Property Level AuthZ** as the third-most
    problematic threat. APIs vulnerable to this either do not implement or only partially
    implement the security controls necessary to protect object-level access, which
    results in data being exposed more than necessary, especially to unauthorized
    people. It is like Broken Object Level AuthZ, but this vulnerability has to do
    with APIs displaying more data than necessary to carry out their activities. Next
    on the list is **unrestricted resource consumption**. Do you remember, back when
    we were talking about XML and XMLP, how we mentioned that the way the XML documents
    are created may lead to security exploitations? This is what it is about. By not
    correctly parsing the input, an API might suffer DoS, since more processing power
    or disk access will happen, leading to increases in costs. Imagine the API is
    running on a public cloud provider and the result of more processing being demanded
    is the launching of new instances (virtual machines) or storing random data on
    high-performance disk areas. This would augment the monthly bill exponentially
    or activate some throttling mechanism – managed by the cloud provider or by your
    company – that would put the API down or into a dormant state. In any case, the
    application stops running.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论**破损的对象级权限控制（Broken Object Property Level AuthZ）**，这是排名第三的严重威胁。容易受此漏洞影响的
    API 要么没有实现必要的安全控制，要么仅部分实现了这些控制，导致对象级别的访问保护不足，尤其是未授权人员可能会接触到不该公开的数据。它类似于破损的对象级权限控制，但该漏洞涉及的是
    API 显示了超出必要的数据来执行其功能。接下来的威胁是**不受限制的资源消耗**。你还记得我们之前讨论 XML 和 XMLP 时提到过，XML 文档的创建方式可能会导致安全漏洞吗？这正是指的这种情况。API
    如果没有正确解析输入，可能会遭受 DoS 攻击，因为会进行更多的处理或磁盘访问，导致成本增加。假设 API 运行在公有云服务商上，如果更多的处理被请求，可能导致启动新的实例（虚拟机）或将随机数据存储到高性能磁盘区域。这将导致月度账单呈指数级增长，或者触发一些由云服务商或公司管理的限流机制，使得
    API 停机或进入休眠状态。无论如何，应用程序都会停止运行。
- en: AuthZ issues come up one more time with the next threat. As your API grows in
    complexity and reach, especially if it touches other systems, you may hit **Broken
    Function Level AuthZ**, which means you need to pay close attention to roles and
    personas created to separate permissions inside the API. When they are not clearly
    defined and enforced, bad handling of the API hierarchy may lead to vulnerabilities
    in which a user belonging to a role can purposefully or accidentally (valid users
    may face this issue even when they do not mean to do so) assume permissions of
    a higher role. An API does not constitute the whole application. It is part of
    something bigger and sometimes, various business flows are running to sustain
    the system. When you have **unrestricted access to business flows**, a subsequent
    vulnerability that may arise is the API exposing how such flows are internally
    structured. Hence, an attacker exploiting this vulnerability could infer the business
    logic behind the API. This will be covered later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证授权问题（AuthZ）再次出现在下一个威胁中。随着你的 API 变得越来越复杂并且触及其他系统，尤其是在与其他系统交互时，你可能会遇到 **功能级别授权失效（Broken
    Function Level AuthZ）**，这意味着你需要密切关注在 API 内部创建的角色和角色所涉及的权限。当这些角色和权限没有被明确定义和强制执行时，不当处理
    API 层级结构可能会导致漏洞，使得属于某个角色的用户能够有意或无意地（即使是合法用户，也可能会不小心遇到这种问题）获取更高角色的权限。API 并不构成整个应用程序。它是更大系统的一部分，有时，为了支撑系统的正常运转，会有多个业务流程同时运行。当你拥有**对业务流程的无限制访问**时，可能会出现一个漏洞：API
    会暴露这些流程的内部结构。因此，攻击者利用这一漏洞可能会推断出 API 背后的业务逻辑。我们稍后将进一步讲解。
- en: '**Server-side request forgery** is a very common threat to web applications
    and APIs, including in cloud environments. A vulnerable API would accept any URI,
    including running internal commands that could reveal the supporting system behind
    the API: OS, kernel or library versions, and additional components, among others.
    It is important to protect the API itself by securely designing and implementing
    it. There is a saying in Brazilian Portuguese that translates to something like
    this: “*one swallow doesn’t make a summer*”. I mean to say that only protecting
    the API itself is not enough. When a system is vulnerable to **security misconfiguration**,
    in other words, when the systems that help the API to work are not updated frequently
    enough or when they are not tuned to implement security best practices, this threat
    becomes a reality for the API.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端请求伪造（SSRF）** 是一种非常常见的威胁，针对 Web 应用程序和 API，包括云环境中的威胁。一个易受攻击的 API 可能会接受任何
    URI，包括执行内部命令，这些命令可能会暴露 API 背后的支持系统：操作系统、内核或库版本，及其他组件等。保护 API 本身非常重要，必须通过安全设计和实施来加以防护。巴西葡萄牙语中有句谚语，翻译过来大概是：“*一只燕子不能代表一个夏天*”。我想说的是，仅仅保护
    API 本身是不够的。当一个系统存在**安全配置错误**时，换句话说，当帮助 API 运作的系统没有足够频繁地更新，或者没有被调整以实施安全最佳实践时，这种威胁就会变成
    API 的现实。'
- en: It is quite important to manage the whole environment where the API runs, including
    endpoints, underlying systems, libraries, and so on. APIs, as is the case for
    any software, have versions that are eventually made obsolete. Endpoints running
    deprecated versions should either be decommissioned or made unavailable. When
    **improper inventory management** occurs, forgotten API endpoints or sustaining
    systems may still be participating in the API’s current implementation and expose
    additional exploitable vulnerabilities. The API you developed is meant to be consumed
    by valid users or third parties. However, investment in protecting APIs is usually
    dedicated more to external users than to partners. When an attacker discovers
    API integrations, they might try to exploit the third party to then intrude on
    the originally targeted endpoint. This is referred to as the **unsafe consumption
    of APIs** and can be avoided or at least reduced when you adopt a terminology
    called **zero trust**, which we will talk about later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 API 运行的整个环境非常重要，包括端点、底层系统、库等。API 和其他软件一样，都有版本，最终这些版本会被淘汰。运行弃用版本的端点应该被淘汰或使其不可用。当发生**不当的库存管理**时，遗忘的
    API 端点或支持系统仍可能参与到 API 当前的实现中，暴露出额外的可利用漏洞。你开发的 API 是为合法用户或第三方所设计的。然而，保护 API 的投资通常更多地集中在外部用户，而非合作伙伴。当攻击者发现
    API 集成时，他们可能会尝试利用第三方来入侵原本针对的端点。这被称为 **不安全的 API 使用**，通过采用我们稍后会讨论的 **零信任** 术语，能够避免或至少减少这种情况的发生。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the concepts behind APIs and included a brief account
    of their history, including explaining what data definitions are and disclosing
    the main protocols that implement APIs. We moved on and discussed how important
    API security is for modern applications and we finished the chapter by talking
    about the most common API vulnerabilities. I hope you have enjoyed the beginning
    of our journey toward pentesting APIs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了API背后的概念，并简要回顾了它们的历史，包括解释了数据定义是什么，并披露了实现API的主要协议。接着，我们讨论了API安全性对现代应用程序的重要性，并通过讲解最常见的API漏洞结束了本章内容。希望你已经享受了我们向API渗透测试之旅的开始。
- en: In the next chapter, we will set up our pentesting environment. Some tools will
    be introduced, examples of execution will be given, and we will have the chance
    to save some time by cloning the book’s repository, which will allow us to leverage
    some utilities.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将设置我们的渗透测试环境。将介绍一些工具，给出执行示例，并且我们有机会通过克隆书籍的代码库来节省时间，这将帮助我们利用一些工具。
- en: Further reading
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延伸阅读
- en: You can find a definition of API from Red Hat at [https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces](https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces](https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces)找到Red
    Hat关于API的定义。
- en: You can find a definition of API from AWS at [https://aws.amazon.com/what-is/api/](https://aws.amazon.com/what-is/api/)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://aws.amazon.com/what-is/api/](https://aws.amazon.com/what-is/api/)找到AWS关于API的定义。
- en: See a scientific article comparing TCP/IP and OSI-RM models at https://ieeexplore.ieee.org/document/46812
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关于TCP/IP与OSI-RM模型比较的科学文章：https://ieeexplore.ieee.org/document/46812
- en: '*The Preparation of Programs for an Electronic Digital* *Computer*: [https://archive.org/details/programsforelect00wilk/mode/2up](https://archive.org/details/programsforelect00wilk/mode/2up)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*电子数字计算机的程序准备*： [https://archive.org/details/programsforelect00wilk/mode/2up](https://archive.org/details/programsforelect00wilk/mode/2up)'
- en: You’ll find a scientific article comparing APIs at [https://dl.acm.org/doi/10.1145/800297.811532](https://dl.acm.org/doi/10.1145/800297.811532)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将会找到一篇比较API的科学文章：[https://dl.acm.org/doi/10.1145/800297.811532](https://dl.acm.org/doi/10.1145/800297.811532)
- en: Read up on a brief history of e-commerce at [https://web.archive.org/web/20160326123900/http://gsbrown.org/compuserve/electronic-mall-1984-04/](https://web.archive.org/web/20160326123900/http://gsbrown.org/compuserve/electronic-mall-1984-04/)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读电子商务简史：[https://web.archive.org/web/20160326123900/http://gsbrown.org/compuserve/electronic-mall-1984-04/](https://web.archive.org/web/20160326123900/http://gsbrown.org/compuserve/electronic-mall-1984-04/)
- en: 'DSs thesis *Architectural Styles and the Design of Network-based Software Architectures*:
    [https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DS的论文*《网络基础软件架构的架构风格与设计》*： [https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
- en: 'This infographic shows data generation during one minute on the internet, comparing
    2013 and 2014: [https://www.fourthsource.com/general/internet-minute-2013-vs-2014-infographic-18293](https://www.fourthsource.com/general/internet-minute-2013-vs-2014-infographic-18293)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这张信息图展示了2013年和2014年每分钟的互联网数据生成情况：[https://www.fourthsource.com/general/internet-minute-2013-vs-2014-infographic-18293](https://www.fourthsource.com/general/internet-minute-2013-vs-2014-infographic-18293)
- en: 'OWASP Top Ten Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP Top Ten项目：[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
- en: 'gRPC Official Documentation: [https://grpc.io/docs/](https://grpc.io/docs/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC官方文档：[https://grpc.io/docs/](https://grpc.io/docs/)
- en: See the official JSON-RPC documentation at [https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看官方的JSON-RPC文档：[https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification)
- en: You can learn more about the OWASP Topen Ten API Project at [https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://owasp.org/www-project-api-security/](https://owasp.org/www-project-api-security/)了解更多关于OWASP
    Top Ten API项目的信息。
