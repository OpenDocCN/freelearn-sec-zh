- en: '*Chapter 3*: Sniffing and Spoofing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：嗅探与欺骗'
- en: During the 1970s, the United States conducted a daring **Signals Intelligence**
    (**SIGINT**) operation against the Soviet Union called Operation Ivy Bells in
    the Sea of Okhotsk. Whereas any other message with a reasonable expectation of
    being intercepted would have been encrypted, some key communications under the
    Sea of Okhotsk took place in plaintext. Using a device that captured signals moving
    through the cable via electromagnetic induction, United States intelligence was
    able to retrieve sensitive military communication from hundreds of feet below
    the surface of the sea. It was a powerful demonstration of *sniffing* – the ability
    to capture and analyze data moving through a communications channel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，美国对苏联进行了一次大胆的**信号情报**（**SIGINT**）行动，代号“常春藤钟”行动，该行动发生在鄂霍次克海。虽然任何预期会被拦截的消息都会被加密，但一些关键通信却在鄂霍次克海下方以明文方式进行。通过使用一种能够通过电磁感应捕捉经过电缆的信号的设备，美国情报部门成功地从海底几百英尺的地方获取了敏感的军事通信。这是一次强有力的*嗅探*演示——能够捕捉并分析通过通信通道传输的数据。
- en: Decades earlier, the Allies were preparing to liberate Nazi-occupied Western
    Europe in the 1944 Battle of Normandy. A critical component of success was catching
    the Germans unprepared, but they knew an invasion was imminent; so, a massive
    deception campaign called Operation Fortitude was employed. Part of this deception
    operation was convincing the Germans that an invasion would take place in Norway
    (Fortitude North) by generating fake radio traffic in Operation Skye. The generated
    traffic was a perfect simulation of the radio signature of army units coordinating
    their movements and plans for attack. The strategy was deployed, and its ingenious
    attention to detail is a powerful demonstration of *spoofing* – false traffic
    intended to mislead the receiver.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，盟军准备在1944年的诺曼底战役中解放纳粹占领的西欧。成功的关键因素之一是让德军措手不及，但他们知道入侵即将来临；因此，进行了一个名为“坚韧行动”的大规模欺骗行动。这个欺骗行动的一部分是通过在“天际行动”中生成假电台流量，迷惑德军相信入侵将在挪威（坚韧行动北部）进行。生成的流量完美模拟了军队单位协调移动和攻击计划的电台信号。这一策略的部署，其巧妙的细节展现了*欺骗*——旨在误导接收方的虚假流量。
- en: Our discussion in this chapter will be in the context of modern computer networks
    and your consideration of these concepts as a pentester, but these historical
    examples should help illuminate the theory behind the technical details. For now,
    let’s demonstrate some hands-on examples of sniffing and spoofing for a pentester
    armed with Kali Linux.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的讨论将以现代计算机网络为背景，并从作为渗透测试员的角度来考虑这些概念，但这些历史案例应该有助于阐明技术细节背后的理论。现在，让我们展示一些针对配备
    Kali Linux 的渗透测试员的嗅探和欺骗的实际操作示例。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Advanced Wireshark statistical analysis and filtering to find the individual
    bits we need on a network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Wireshark 统计分析和过滤技术，用于在网络中找到我们需要的特定数据位
- en: Targeting WLANs with the Aircrack-ng suite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Aircrack-ng 套件攻击 WLAN
- en: Advanced Ettercap to build a stealthy eavesdropping access point
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Ettercap 用于构建一个隐秘的窃听接入点
- en: Ettercap packet filters to analyze, drop, and manipulate traffic in transit
    through our access point
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ettercap 数据包过滤器来分析、丢弃并操控通过我们接入点传输的流量
- en: Getting better with BetterCAP fundamentals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更深入地掌握 BetterCAP 基础
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get started, you will need to have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要具备以下条件：
- en: A laptop running Kali Linux
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Kali Linux 的笔记本
- en: A wireless card that can be run as an access point
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张可以作为接入点使用的无线网卡
- en: Basic Wireshark knowledge
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的 Wireshark 知识
- en: Advanced Wireshark – going beyond simple captures
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Wireshark——超越简单的数据包捕获
- en: I assume you’ve had some experience with Wireshark (formerly known as Ethereal)
    by now. Even if you’re new to pen testing, it’s hard to avoid Wireshark in lab
    environments. If you aren’t familiar with this fantastic packet analyzer, you’ll
    no doubt be familiar with packet analyzers in general. A sniffer is a great challenge
    for anyone learning how to code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你现在已经有了一些使用 Wireshark（前身为 Ethereal）的经验。即使你是渗透测试的新手，也很难避免在实验室环境中接触到 Wireshark。如果你对这个出色的数据包分析工具不熟悉，那你一定对数据包分析器有所了解。嗅探器是任何学习编程的人面临的一大挑战。
- en: So, I won’t be covering the basics of Wireshark. We are all familiar with packet
    analyzers as a concept; we know about Wireshark’s color-coded protocol analysis
    and so on. We’re going to take Wireshark beyond theory and ordinary capture, and
    apply it to some practical examples. We’ll look at passive wireless analysis with
    Wireshark, and we’ll learn how to use Wireshark as our sidekick when we use our
    attack tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我不会讲解Wireshark的基础知识。我们都熟悉数据包分析器这个概念；我们知道Wireshark的颜色编码协议分析等等。我们将把Wireshark的应用推向理论之外和普通捕获之外，应用到一些实际的例子中。我们将查看Wireshark中的被动无线分析，并学习如何在使用攻击工具时将Wireshark作为我们的助手。
- en: Passive wireless analysis
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被动无线分析
- en: So far, we’ve been studying layer 2 and above. The magical world of layer 1
    – the physical layer – is a subject for another (very thick) book, but in today’s
    world, we can’t talk about the physical means of accessing networks without playing
    around with wireless.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在研究第二层及以上的内容。第一层——物理层——的神奇世界是另一本（非常厚的）书的内容，但在今天的世界里，我们无法谈论访问网络的物理方式而不涉及无线技术。
- en: 'There are two core strategies in sniffing attacks: *passive* and *active*.
    A passive sniffing attack is also commonly referred to as *stealthy* as it can’t
    be detected by the target. We’re going to take a look at passive wireless reconnaissance
    – which is just a fancy way of saying *listening to the radio*. When you tune
    into your favorite station on your car’s FM radio, the radio station has no way
    of knowing that you have started listening. Passive wireless reconnaissance is
    the same concept, except we’re going to record the radio show so that we can analyze
    it in detail later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 嗅探攻击有两种核心策略：*被动*和*主动*。被动嗅探攻击通常也被称为*隐蔽*攻击，因为它无法被目标检测到。我们将看看被动无线侦察——这只是一个Fancy的说法，意思是*监听广播*。当你在车上的FM收音机调到你最喜欢的电台时，电台并不知道你已经开始收听。被动无线侦察是相同的概念，只不过我们要录制这个广播节目，以便稍后详细分析。
- en: To pull this off, we need the right hardware. A wireless card has to be willing
    to record everything it can see and pass it along to the operating system. This
    is known as **monitor mode** and not all wireless cards support it. My card of
    choice is an Alfa AWUS036NEH, but a little research online will help you find
    an ideal device.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要合适的硬件。无线网卡必须能够记录它能看到的一切，并将其传递给操作系统。这就是**监视模式**，但并非所有无线网卡都支持它。我选择的卡是Alfa
    AWUS036NEH，但稍微在网上做些研究就能帮助你找到理想的设备。
- en: 'We’ll use **iwconfig** to enable monitor mode and confirm its status after
    bringing the device up:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**iwconfig**来启用监视模式，并在启动设备后确认其状态：
- en: '![Figure 3.1 – Using iwconfig to enable monitor mode ](image/Figure_3.01_B17616.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 使用iwconfig启用监视模式](image/Figure_3.01_B17616.jpg)'
- en: Figure 3.1 – Using iwconfig to enable monitor mode
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 使用iwconfig启用监视模式
- en: 'Note the use of both configuration utilities: **ifconfig** and **iwconfig**.
    Don’t mix up their names!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意两种配置工具的使用：**ifconfig**和**iwconfig**。不要混淆它们的名称！
- en: When we run the last command, we can confirm that monitor mode is enabled. If
    you check the RX packet count, you’ll see it’s already rapidly climbing (depending
    on how busy your RF surroundings are) – it’s receiving packets, even though you
    are not associated with an access point. This is what makes this type of analysis
    stealthy – no devices that are merely listening are detected.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行最后一个命令时，我们可以确认监视模式已启用。如果检查RX数据包计数，你会看到它已经在快速增长（具体取决于你的射频环境有多忙碌）——它正在接收数据包，即使你没有与接入点关联。这就是这种分析方法隐蔽的原因——仅仅在监听的设备是不会被检测到的。
- en: It’s important to note that true stealth requires that your device is *not*
    sending any data. Sometimes, we intend to simply listen, so assume we’re being
    stealthy, but if the card is announcing its presence in some way, it isn’t passive.
    When you’re good at analyzing your environment, use your skills to check your
    stealth!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，真正的隐蔽性要求你的设备*不*发送任何数据。有时候，我们仅仅是打算监听，所以假设我们在隐蔽地进行监听，但如果无线网卡以某种方式宣布它的存在，它就不再是被动的。当你擅长分析你的环境时，运用你的技巧来检查你的隐蔽性！
- en: 'Now, we’ll fire up Wireshark and select the interface we specified previously
    – in this example, **wlan0**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启动Wireshark并选择之前指定的接口——在这个例子中是**wlan0**：
- en: '![Figure 3.2 – Raw wireless capture with Wireshark ](image/Figure_3.02_B17616.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 使用Wireshark进行原始无线捕获](image/Figure_3.02_B17616.jpg)'
- en: Figure 3.2 – Raw wireless capture with Wireshark
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 使用Wireshark进行原始无线捕获
- en: Whoa, okay – hold on a second. The screen just lit up at a pace of 27 packets
    per second, and this is a relatively quiet environment. (Fire this up in an apartment
    building and enjoy the fun.) Don’t get me wrong – I’m a data hound and this number
    of packets excites me – but we need to find out what’s happening in this environment
    so that we can tune in on the good stuff. We’ll revisit the high-altitude view
    of a wireless environment with Wireshark in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，好吧——等一下。屏幕在每秒 27 个数据包的速度下亮了起来，而且这是一个相对安静的环境。（如果你在公寓楼里启动这个，玩得会更有意思。）别误会，我是一个数据狂人，这么多包让我兴奋——但我们需要搞清楚这个环境里发生了什么，以便筛选出有价值的内容。我们将在下一节中使用
    Wireshark 回顾无线环境的高空视角。
- en: Targeting WLANs with the Aircrack-ng suite
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Aircrack-ng 套件定位 WLAN
- en: 'No discussion on wireless attacks is adequate without the Aircrack-ng suite.
    Though the name implies it’s just a password cracker, it’s a fully-featured wireless
    attack suite. In our example, we’re going to take a look at the wireless sniffer
    with the **airodump-ng wlan0** command. Here’s the output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于无线攻击的讨论都离不开 Aircrack-ng 套件。虽然名字暗示它只是一个密码破解工具，但它是一个功能全面的无线攻击套件。在我们的例子中，我们将通过**airodump-ng
    wlan0** 命令查看无线嗅探器。以下是输出：
- en: '![Figure 3.3 – airodump-ng output ](image/Figure_3.03_B17616.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – airodump-ng 输出](image/Figure_3.03_B17616.jpg)'
- en: Figure 3.3 – airodump-ng output
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – airodump-ng 输出
- en: This is the same task, but this tool can organize the wireless environment and
    the identities of all participating devices. An especially useful column is **#Data**,
    which tells us how many observed packets contain network data. This is handy because
    as we saw when watching the raw environment, there are a lot of packets that are
    for wireless management. It’s easy enough to sort packets in Wireshark, but now,
    we’re getting a tidy list of networks, the MAC addresses of the clients and access
    points (BSSIDs), and an idea of how busy they are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的任务，但这个工具可以整理无线环境和所有参与设备的身份信息。一个特别有用的列是**#数据**，它告诉我们观察到的包中有多少包含网络数据。这很方便，因为正如我们在查看原始环境时看到的，很多包是用于无线管理的。虽然在
    Wireshark 中对包进行排序很简单，但现在，我们得到了一个整洁的网络列表，包括客户端和接入点的 MAC 地址（BSSID），以及它们的繁忙程度。
- en: 'The **ENC** column tells us what encryption method – if any – is in use for
    the listed network. **OPN** means there is no encryption. This is unusual these
    days, but in this example, the open network is a guest network. It’s been left
    open on purpose to allow easy access, but clients will be dropped into a captive
    portal environment once they’ve been associated. You’ll recall from [*Chapter
    2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Bypassing Network Access
    Control* that we worked to intercept authentication to the captive portal from
    the network layer by attacking the data link layer. But in this case, we’re sitting
    in radio range and the packets aren’t encrypted. We should be able to intercept
    anything that isn’t protected with some tunneling method (for instance, HTTPS)
    by merely listening – no injection required, and with a zero detectable footprint.
    So, how do we leverage the information here to sift through the wilderness captured
    in monitor mode? Let’s target the guest network by filtering on the access point’s
    MAC address (the BSSID): **40:16:7E:59:A7:A0**.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**ENC** 列告诉我们所列网络使用的加密方法——如果有的话。**OPN** 表示没有加密。现在这种情况比较少见，但在这个例子中，开放网络是一个访客网络。它故意保持开放，以便轻松访问，但一旦连接成功，客户端将被引导进入一个受限的门户环境。你会记得在[*第二章*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)，*绕过网络访问控制*中，我们通过攻击数据链路层来拦截到受限门户的认证请求。但在这种情况下，我们处于无线电范围内，并且包没有加密。我们应该能够通过监听来拦截任何没有采用隧道加密方法（例如，HTTPS）保护的内容——不需要注入，也没有可检测的痕迹。那么，我们如何利用这里的信息来筛选出在监控模式下捕获的杂乱数据呢？让我们通过过滤接入点的
    MAC 地址（BSSID）：**40:16:7E:59:A7:A0** 来锁定访客网络。'
- en: 'As you know, the 2.4 GHz band for 802.11 communication is split into channels.
    Airodump-ng will hop these channels by default – jump from one channel to the
    next, rapidly, listening for data on whatever channel it’s on at the moment. As
    you can imagine, if a juicy packet is being transmitted on channel 1 while Airodump-ng
    is listening on channel 4, you’ll miss it. So, when you know your target, you
    need to tell Airodump-ng to focus. In our example, the open network is on **channel
    1**. We use **--channel** to specify our listening frequency, and we use **--bssid**
    to filter out our target access point by MAC address. We’ll use **--output-format**
    to specify a **.pcap** file (any packet analyzer can work with this output format):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，802.11 通信的 2.4 GHz 波段被划分为多个频道。默认情况下，Airodump-ng 会在这些频道之间跳跃——快速从一个频道跳到下一个频道，监听当前频道的数据。正如你可以想象的那样，如果一个重要的数据包在频道
    1 上传输，而 Airodump-ng 正在频道 4 上监听，你就会错过它。因此，当你知道目标时，你需要告诉 Airodump-ng 集中注意力。在我们的示例中，开放网络位于
    **频道 1**。我们使用 **--channel** 来指定我们的监听频率，使用 **--bssid** 通过 MAC 地址来过滤目标接入点。我们将使用
    **--output-format** 来指定 **.pcap** 文件（任何数据包分析器都可以处理这种输出格式）：
- en: airodump-ng -w test_capture --output-format pcap --bssid 40:16:7e:59:a7:a0 --channel
    11 wlan0
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: airodump-ng -w test_capture --output-format pcap --bssid 40:16:7e:59:a7:a0 --channel
    11 wlan0
- en: 'While we watch the metadata on our screen, our test file is being written.
    We can let this run as long as we like; then, we must hit *Ctrl* + *C* and import
    it into Wireshark:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在屏幕上观察元数据时，我们的测试文件正在被写入。我们可以让它运行尽可能长的时间；然后，我们必须按 *Ctrl* + *C* 并将其导入到 Wireshark
    中：
- en: '![Figure 3.4 – Opening our test capture file in Wireshark ](image/Figure_3.04_B17616.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 在 Wireshark 中打开我们的测试捕获文件](image/Figure_3.04_B17616.jpg)'
- en: Figure 3.4 – Opening our test capture file in Wireshark
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 在 Wireshark 中打开我们的测试捕获文件
- en: Without sending any data whatsoever, we’ve already discovered a legit IP address
    (**192.168.80.80**), and we can watch the DNS queries being sent by this host.
    We have a decent start on our reconnaissance phase for this particular network,
    and we haven’t even sent any packets.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有发送任何数据的情况下，我们已经发现了一个合法的 IP 地址（**192.168.80.80**），并且可以看到这个主机发送的 DNS 查询。我们已经在这个特定网络的侦察阶段迈出了不错的一步，而我们甚至还没有发送任何数据包。
- en: We’re Living in a 5 GHz World
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个 5 GHz 的世界里
- en: Though 2.4 GHz remains dominant, there are more and more 5 GHz devices out there
    and you might need to sniff those out. A newer wireless card should support it.
    When you’re working with airodump-ng, use the **band** flag and set it to **abg**,
    which will enable 5 GHz.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 2.4 GHz 仍然占主导地位，但越来越多的 5 GHz 设备出现在市场上，你可能需要嗅探这些设备。新的无线网卡应该支持它。当你使用 airodump-ng
    时，使用 **band** 标志并设置为 **abg**，这将启用 5 GHz。
- en: Now that we have some experience with raw wireless sniffing, let’s check out
    Wireshark’s built-in analysis features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些原始无线嗅探的经验，让我们来看看 Wireshark 内建的分析功能。
- en: WLAN analysis with Wireshark
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Wireshark 进行 WLAN 分析
- en: 'Let’s review using Wireshark to interpret a wireless environment. We disabled
    channel hopping in the previous section so that we could focus on a target, but
    now, let’s try to capture as much as possible and let Wireshark do the explaining.
    With a wireless capture open, click **Wireless** | **WLAN Traffic**. The resulting
    window is **Wireshark - Wireless LAN Statistics - test_wifi_capture-01** with
    sortable columns. I’m interested in finding the busiest networks, so I have sorted
    by **Percent Packets**:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Wireshark 来解读无线环境。我们在上一节中禁用了频道跳跃，以便集中关注一个目标，但现在，让我们尽可能多地捕获数据，让 Wireshark
    来解释。在打开无线捕获的情况下，点击 **Wireless** | **WLAN Traffic**。生成的窗口是 **Wireshark - Wireless
    LAN Statistics - test_wifi_capture-01**，并且具有可排序的列。我感兴趣的是找到最繁忙的网络，所以我按 **Percent
    Packets** 进行排序：
- en: '![Figure 3.5 – Wireless LAN statistics in Wireshark ](image/Figure_3.05_B17616.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – Wireshark 中的无线局域网统计](image/Figure_3.05_B17616.jpg)'
- en: Figure 3.5 – Wireless LAN statistics in Wireshark
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – Wireshark 中的无线局域网统计
- en: 'By expanding **BSSID** on the left, we can see nested BSSIDs: the parent is
    the access point, while the nested devices are associated clients. Right-click
    on a target and click **Apply as Filter** | **Selected**. Close the statistics
    box to return to Wireshark’s main window. The display filter text box will be
    populated with our chosen filter. Apply the filter and enjoy the time you’ve saved
    digging through packets:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过展开左侧的 **BSSID**，我们可以看到嵌套的 BSSID：父节点是接入点，而嵌套的设备是关联的客户端。右键点击一个目标，然后点击 **Apply
    as Filter** | **Selected**。关闭统计框返回到 Wireshark 的主窗口。显示过滤器文本框将填充我们选择的过滤器。应用该过滤器，享受你节省下来的时间，避免在数据包中翻找：
- en: '![Figure 3.6 – Filtering by BSSID ](image/Figure_3.06_B17616.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 按 BSSID 过滤](image/Figure_3.06_B17616.jpg)'
- en: Figure 3.6 – Filtering by BSSID
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 按 BSSID 过滤
- en: Let’s get back to the network layer and see what Wireshark can do for us once
    we’ve established a presence on the LAN. I’ve been sniffing for a few minutes
    on a network with several actively browsing clients. In a short time, I have a
    juicy amount of data to analyze.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到网络层，看看一旦我们在局域网中建立了连接，Wireshark 能为我们做些什么。我已经在一个有多个活跃浏览客户端的网络上嗅探了几分钟。短短的时间内，我就捕获到了大量有用的数据可以分析。
- en: Active network analysis with Wireshark
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Wireshark 进行的网络分析
- en: As we can expect in today’s world of casual web browsing, almost all traffic
    is TLS-encrypted. It’s hard to even read the news or search for a dictionary definition
    without passing through a tunnel. Sniffing isn’t what it used to be in the old
    days when sitting on a LAN in promiscuous mode was everything you needed to intercept
    full HTTP sessions. So, our goal here is to apply some statistical analysis and
    filtering to learn more about the captured data and infer relationships.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在今天的日常网页浏览中可以预见的那样，几乎所有的流量都是通过 TLS 加密的。即便是查看新闻或搜索字典定义，也很难不经过一个隧道进行数据传输。嗅探（Sniffing）已经不像过去那样简单了，以前只需要在局域网中设置混杂模式（promiscuous
    mode），就能截获完整的 HTTP 会话。所以，我们的目标是应用一些统计分析和过滤技术，深入了解捕获的数据，并推断出数据之间的关系。
- en: In the previous section, we looked at WLAN statistics. Now that we’re established
    on the network, we can get much more granular with protocol and service-level
    analysis.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们查看了 WLAN 的统计信息。现在我们已经接入网络，可以通过协议和服务级别的分析，更加细致地观察网络数据。
- en: Let’s learn a little more about everyone chatting on the network. In Wireshark
    parlance, we call all the individual devices endpoints. Every IP address is considered
    an endpoint, and endpoints have conversations with each other. Let’s select **Endpoints**
    from the **Statistics** menu.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下网络中每个设备的通信情况。在 Wireshark 中，我们将每个设备称为端点（endpoint）。每个 IP 地址都被视为一个端点，端点之间会进行相互通信。让我们从
    **统计** 菜单中选择 **端点**。
- en: 'I’m interested in the endpoint with an ASN belonging to the **Orange** network
    in France. I can right-click to apply a filter based on this particular endpoint:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我对一个属于法国 **Orange** 网络的端点感兴趣。我可以右键点击该端点，基于这个特定端点应用过滤器：
- en: '![Figure 3.7 – Filtering endpoints ](image/Figure_3.07_B17616.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 过滤端点](image/Figure_3.07_B17616.jpg)'
- en: Figure 3.7 – Filtering endpoints
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 过滤端点
- en: 'Now, I’m going to review just the HTTP 200 responses from this particular endpoint.
    I will use this filter and apply it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将只查看这个特定端点的 HTTP 200 响应。我将使用这个过滤器并应用它：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I’ve narrowed down five packets of interest out of the 33,644 that we captured.
    At this point, I can right-click any packet to create a filter for that particular
    TCP session, allowing me to follow the HTTP conversation in an easy-to-read format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我从捕获的 33,644 个数据包中筛选出了五个有用的数据包。此时，我可以右键点击任意一个数据包，创建一个过滤器来聚焦于这个特定的 TCP 会话，这样我就可以以一种易于阅读的格式跟踪
    HTTP 会话：
- en: '![Figure 3.8 – Reviewing the filtered packets ](image/Figure_3.08_B17616.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 审查过滤后的数据包](image/Figure_3.08_B17616.jpg)'
- en: Figure 3.8 – Reviewing the filtered packets
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 审查过滤后的数据包
- en: So, what’s going on with this display filter? The syntax should be familiar
    to coders. You start with a layer and specify subcategories separated by a period.
    In our example, we started with **ip** and then specified the IP address with
    **addr**. The address subcategory is an option for other layers; for example,
    **eth.addr** would be used to specify a MAC address. Wireshark display filters
    are extremely powerful, and we simply don’t have enough pages to dive in, but
    you can easily build filters from scratch by reviewing packets manually and honing
    in on the data you need. For example, we were just filtering out packets from
    the endpoint that belongs to the AS5511 network in France. Could I filter any
    packets from France?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个显示过滤器到底是怎么回事呢？它的语法应该对程序员来说并不陌生。你首先从一个层次开始，然后通过句点分隔指定子类别。在我们的示例中，我们从 **ip**
    开始，然后用 **addr** 来指定 IP 地址。地址子类别也适用于其他层次；例如，**eth.addr** 用于指定 MAC 地址。Wireshark
    的显示过滤器非常强大，我们没有足够的篇幅深入探讨，但你可以通过手动审查数据包，逐步构建你需要的过滤器。例如，我们刚才过滤出了来自法国 AS5511 网络的端点的数据包。我能过滤出来自法国的所有数据包吗？
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s take GeoIP a step further by looking for any TCP ACK packets going to
    **Mountain View**, California:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 GeoIP 进一步应用，查找所有发送到 **Mountain View**，加利福尼亚的 TCP ACK 数据包：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s look for any SSL-encrypted alerts where the TCP window scale factor is
    set to **128**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下任何TCP窗口缩放因子设置为**128**的SSL加密警报：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I know what the hacker in you is saying: *we can build out Wireshark display
    filters to fingerprint operating systems just like p0f*. Very good, I’m so proud!
    How about we look for packets that are not destined for HTTPS while matching a
    Linux TCP signature and layer 2 destined for the gateway (in other words, leaving
    the network, so we’re fingerprinting local hosts)?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你心中的黑客正在说：*我们可以构建Wireshark显示过滤器来指纹识别操作系统，就像p0f一样*。很好，我真为你感到骄傲！那我们来看看如何寻找那些不以HTTPS为目标的包，同时匹配Linux的TCP特征，并且目标二层是网关（换句话说，这些包正在离开网络，所以我们正在指纹识别本地主机）？
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I warned you that this would get fun.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我警告过你，这会变得有趣。
- en: Advanced Ettercap – the man-in-the-middle Swiss Army Knife
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Ettercap——中间人攻击的瑞士军刀
- en: 'In the previous chapter, we fooled around with ARP poisoning in Ettercap. I’m
    like every other normal person: I love a good ARP spoof. However, it’s infamously
    noisy. It just screams, HEY! I’M A BAD GUY, SEND ME ALL THE DATA! Did you fire
    up Wireshark during the attack? Even Wireshark knows that something is wrong and
    warns the analyst that *duplicate use has been detected!* It’s the nature of the
    beast when we’re convincing the network to send everything to a single interface
    – what is called unified sniffing.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在Ettercap中玩弄了ARP欺骗。我和其他正常人一样：我喜欢一场好的ARP欺骗。然而，它臭名昭著地嘈杂。它就是在大喊：“嘿！我可是坏人，给我所有数据吧！”你在攻击过程中启动了Wireshark吗？即使是Wireshark也知道出了一点问题，并警告分析师：*检测到重复使用！*
    当我们让网络将所有流量发送到单一接口时，这就是其固有的特性——这就是所谓的统一嗅探。
- en: Now, we’re going to take man-in-the-middle to the next level with bridged sniffing,
    which is bridging together two interfaces on our Kali box and conducting our operations
    between the two interfaces. Those interfaces are local to us and bridged together,
    all on the fly, by Ettercap; in other words, a user won’t see anything amiss.
    We aren’t telling the network to do anything funky. If we can place ourselves
    in a privileged position between two endpoints pointing at an interface on either
    side of our host, the network will look normal to the endpoints. Back in my day,
    we had to manually set up the bridge to pull off this kind of thing, but now,
    Ettercap is kind enough to take care of everything for us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过桥接嗅探将中间人攻击提升到一个新层次，这意味着将我们Kali主机上的两个接口桥接在一起，并在这两个接口之间进行操作。这些接口对我们来说是本地的，Ettercap会自动将它们桥接在一起，也就是说，用户不会发现任何异常。我们并没有让网络做什么奇怪的事情。如果我们能够把自己置于两个端点之间的特权位置，并让流量通过我们主机的某个接口，网络看起来对端点是正常的。回到我的时代，我们必须手动设置桥接才能做到这一点，但现在，Ettercap非常贴心地为我们处理了一切。
- en: The first (and obvious) question is, how do we place ourselves in such a position?
    There are many scenarios to consider and covering them all would be beyond the
    scope of this book. For our purposes, we’re going to set up a malicious access
    point by building on our Host AP Daemon knowledge from [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033),
    *Bypassing Network Access Control*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（也是最明显）的问题是，我们如何将自己放置在这样的一个位置？有许多场景需要考虑，涵盖所有内容超出了本书的范围。为了我们的目的，我们将通过利用在[*第二章*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)中学到的Host
    AP Daemon知识，来设置一个恶意接入点，*绕过网络访问控制*。
- en: Bridged sniffing and the malicious access point
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接嗅探与恶意接入点
- en: 'In [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Bypassing
    Network Access Control*, we built an access point to serve as a backdoor into
    a network. This access point provided us with DHCP, DNS, and NAT to get us out
    of the **eth0** interface attached to the inside network. The attached client
    was not a victim; it was the attacker on the outside of the building. This time,
    we’re creating an access point, but it’s intended for our target(s) to connect
    to it. The access point will grant them some kind of wanted network access, and
    the destination network will handle them like normal – in fact, we’re going to
    let the destination network handle DHCP and DNS, so don’t even bother with **dnsmasq**
    this time. The idea is that we’re essentially invisible: aside from providing
    an access point, we offer no network services. What we will be doing is sniffing
    everything that passes through our bridge.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**第二章**](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)中，我们构建了一个接入点作为网络的后门。这个接入点为我们提供了
    DHCP、DNS 和 NAT，以便我们能够突破连接到内网的**eth0**接口。连接的客户端并不是受害者；它是建筑外部的攻击者。这一次，我们在创建一个接入点，但它是为了让我们的目标连接上它。接入点将授予他们某种想要的网络访问权限，目标网络将像处理正常连接一样处理他们——事实上，我们将让目标网络处理
    DHCP 和 DNS，因此这次不必担心使用**dnsmasq**。我们的想法是我们本质上是隐形的：除了提供接入点外，我们不提供任何网络服务。我们要做的是嗅探所有通过我们桥接的流量。
- en: 'These principles can be applied to any bridged sniffing scenario, so I encourage
    you to let your hacking imagination run wild with the possibilities. For our demonstration,
    we’re firing up the timeless classic *Free Wi-Fi* attack. The idea is simple:
    offer free internet and let the fish come to you. This attack has potential in
    legitimate pen tests; attacking your client’s users can be difficult in secure
    networks and setting up free Wi-Fi in a corporate environment is surprisingly
    effective. (Wouldn’t you like the opportunity to bypass your company’s web filters?)
    Another possibility is the *evil twin* concept, where you’re masquerading as a
    legitimate ESSID, or even the ESSID of a lonely wireless device’s probes, looking
    for a familiar face in a strange place. (Check out Fluxion if you want to dive
    deeper into Wi-Fi MitM attacks). Again, I leave the rest to your imagination.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则可以应用于任何桥接嗅探场景，因此我鼓励你放开想象力，充分发挥黑客创意的潜力。在我们的演示中，我们将启动经典的*免费 Wi-Fi*攻击。这个想法很简单：提供免费的互联网，等着鱼儿上钩。这种攻击在合法的渗透测试中有潜力；在安全的网络中攻击你的客户用户可能很困难，而在企业环境中设置免费的
    Wi-Fi 出奇有效。（你难道不想绕过公司网络过滤器吗？）另一种可能性是*恶意双胞胎*概念，即你伪装成一个合法的 ESSID，甚至是一个孤独无线设备探测到的
    ESSID，寻找一个在陌生地方熟悉的面孔。（如果你想深入了解 Wi-Fi 中间人攻击，可以查看 Fluxion）。再次提醒，剩下的交给你的想象力。
- en: Don’t Forget to Open Your WLAN!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了打开你的 WLAN！
- en: If you’re following along from the previous example with **hostapd**, your configuration
    file is probably still specifying a WPA-protected network! Make sure you open
    that up again with nano and remove the lines about WPA encryption. Don’t forget
    to change your SSID to something like **Free Wi-Fi** as well.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随之前的**hostapd**示例，你的配置文件可能仍然指定了一个 WPA 保护的网络！确保你用 nano 打开它并删除有关 WPA 加密的行。别忘了将你的
    SSID 改成像**免费 Wi-Fi**这样的名字。
- en: 'First, I must set up my access point. If you’re following the **hostapd** example
    from [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Bypassing
    Network Access Control*, note the differences here – I don’t need **dnsmasq**
    and I don’t need **iptables**, so I’ll use **ifconfig** and **grep** to quickly
    confirm the subnet of our Ethernet interface’s existing connection, set up forwarding,
    and prepare the wireless interface for hosting:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我必须设置我的接入点。如果你正在按照[**第二章**](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)中*绕过网络访问控制*的**hostapd**示例进行操作，请注意这里的不同——我不需要**dnsmasq**，也不需要**iptables**，所以我将使用**ifconfig**和**grep**快速确认我们的以太网接口现有连接的子网，设置转发，并准备无线接口用于主机：
- en: '![Figure 3.9 – Configuring bridged sniffing with hostapd ](image/Figure_3.09_B17616.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 使用 hostapd 配置桥接嗅探](image/Figure_3.09_B17616.jpg)'
- en: Figure 3.9 – Configuring bridged sniffing with hostapd
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 使用 hostapd 配置桥接嗅探
- en: I gave the wireless interface an IP assignment in the Ethernet interface’s network.
    By running **ifconfig** and piping the output into **grep** so that it matches
    **inet**, we can confirm the assigned IP address, so I’ll just pick another one
    in that same subnet. I also ran **airmon-ng check kill** to ensure that any wireless
    networking utilities are killed, as they will prevent **hostapd** from doing its
    thing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我给无线接口分配了一个在以太网接口网络中的 IP 地址。通过运行 **ifconfig** 并将输出通过 **grep** 管道传输，以便匹配 **inet**，我们可以确认分配的
    IP 地址，所以我会选择同一子网中的另一个地址。我还运行了 **airmon-ng check kill** 来确保所有无线网络工具都被终止，因为它们会阻止
    **hostapd** 正常工作。
- en: 'We used the graphical interface last time; I’m going to keep it clean and just
    fire off this command in a new terminal window:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上次使用了图形界面；这次我将保持简洁，只在一个新的终端窗口中运行这个命令：
- en: '![Figure 3.10 – Firing off the bridge with Ettercap ](image/Figure_3.10_B17616.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 用 Ettercap 启动桥接](image/Figure_3.10_B17616.jpg)'
- en: Figure 3.10 – Firing off the bridge with Ettercap
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 用 Ettercap 启动桥接
- en: 'This command is easy thanks to Ettercap’s behind-the-scenes power to manage
    the bridge and sniffing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ettercap 在幕后强大的桥接和嗅探管理功能，这个命令非常简单：
- en: '**-T** tells Ettercap to go *old school* and use a text-only interface.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-T** 告诉 Ettercap 使用 *传统的* 纯文本界面。'
- en: '**-q** means *be quiet*. We don’t want Ettercap reporting every packet to our
    interface; that’s what our capture file is for. We are analyzing later, not now.
    Let’s just let it run.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-q** 表示 *保持安静*。我们不希望 Ettercap 将每个数据包都报告到我们的接口；这正是我们捕获文件的用途。我们稍后会进行分析，而不是现在。让它静静地运行吧。'
- en: '**-B** starts up *bridged sniffing*. Remember, we need two interfaces (in our
    example, **eth0** and **wlan0**), so I run this flag twice for each interface.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-B** 启动 *桥接嗅探*。记住，我们需要两个接口（在我们的例子中是 **eth0** 和 **wlan0**），所以我会为每个接口运行这个标志两次。'
- en: '**-w** will write the packets to a **.pcap** file for later analysis in Wireshark.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-w** 将把数据包写入 **.pcap** 文件，以便稍后在 Wireshark 中分析。'
- en: 'Then, we must apply ordinary Wireshark analysis. With this privileged position,
    we can proceed to more advanced attacks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须进行普通的 Wireshark 分析。在这个特权位置下，我们可以继续进行更高级的攻击：
- en: '![Figure 3.11 – The Conversation view of our bridged sniffing capture file
    ](image/Figure_3.11_B17616.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 我们的桥接嗅探捕获文件的对话视图](image/Figure_3.11_B17616.jpg)'
- en: Figure 3.11 – The Conversation view of our bridged sniffing capture file
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 我们的桥接嗅探捕获文件的对话视图
- en: Now, we’ll pull out our surgical scalpel and learn how to find and even manipulate
    packets based on their properties.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将拿出我们的外科手术刀，学习如何根据数据包的属性查找甚至操控数据包。
- en: Ettercap filters – fine-tuning your analysis
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ettercap 过滤器 – 精细调整你的分析
- en: 'We’ve seen just how powerful Ettercap can be out of the box. Ettercap shines
    due to its content filtering engine and its ability to interpret custom scripts.
    Ettercap makes man-in-the-middle attacks a no-brainer; however, with filters,
    we can turn a Kali box running Ettercap into, for instance, an IDS. Imagine the
    combined power of our bridged sniffing attack and custom filters, which have been
    designed to interpret packets, and take action on them: dropping them and even
    modifying them in transit.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Ettercap 开箱即用的强大功能。Ettercap 之所以出色，是因为它的内容过滤引擎以及解释自定义脚本的能力。Ettercap 使得中间人攻击变得轻而易举；然而，通过使用过滤器，我们可以将运行
    Ettercap 的 Kali 主机变成一个入侵检测系统（IDS）。想象一下，我们的桥接嗅探攻击和自定义过滤器的结合威力，这些过滤器已经设计好可以解释数据包并对其进行操作：丢弃它们，甚至在传输过程中修改它们。
- en: 'Let’s take a look at a basic example to whet our appetite. You may immediately
    notice the C-like syntax and the similarity to Wireshark display filters. There’s
    a lot of conceptual overlap here; you’ll find that analyzing patterns with Wireshark
    can yield some powerful Ettercap filters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基础示例，激发一下我们的兴趣。你可能会立刻注意到类似 C 语言的语法和与 Wireshark 显示过滤器的相似性。这里有很多概念上的重叠；你会发现使用
    Wireshark 分析模式可以生成一些强大的 Ettercap 过滤器：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Translated into plain English, this says, *test if the IP protocol is TCP; if
    so, do another test to see if the source port is* **80***, or if the destination
    port is* **80***; if either is true, display a message to the user that says*
    **HTTP traffic detected**. This is an example of nested if statements, which are
    embedded in graph parentheses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这表示 *测试 IP 协议是否为 TCP；如果是，再进行一次测试，看源端口是否为* **80** *，或者目标端口是否为* **80** *；如果其中一个为真，向用户显示一条消息，表示*
    **检测到 HTTP 流量**。这是一个嵌套 if 语句的例子，嵌入在图形括号中。
- en: 'Let’s take a look at an ability that should intrigue the Scapy/Python part
    of your brain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个应该能引起你对 Scapy/Python 部分好奇心的功能：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this sample, we’re testing for any TCP packet destined for port **12345**.
    If the packet is seen, we alert the user that an executable is being triggered.
    The script then launches **12345_exec**. We could write up a Python script (and
    yes, import Scapy to craft packets) that will trigger upon meeting a condition
    in Ettercap.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在测试任何目标端口为 **12345** 的 TCP 数据包。如果检测到该数据包，我们将提醒用户有可执行文件被触发。然后脚本会启动
    **12345_exec**。我们也可以写一个 Python 脚本（是的，导入 Scapy 来构造数据包），在 Ettercap 中遇到某个条件时触发。
- en: Killing connections with Ettercap filters
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Ettercap 过滤器终止连接
- en: 'Now, let’s try to construct a filter to kill SSH and SMTP connections while
    allowing all other traffic. This will give us hands-on experience with setting
    up a basic service filtering mechanism on our Kali box. Pay attention: my first
    shot at this short filter will have a troublemaking function in it. We’ll review
    the results and see if we can fix the problem.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试构造一个过滤器，终止 SSH 和 SMTP 连接，同时允许其他所有流量。这将使我们在 Kali 机器上亲手设置基本的服务过滤机制。注意：我第一次尝试这个简短的过滤器时，它会包含一个有问题的函数。我们将回顾结果，看看能否修复这个问题。
- en: 'First, I will fire up nano and create a file with this filter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将启动 nano 并创建一个包含这个过滤器的文件：
- en: '![Figure 3.12 – Finishing the filter in nano ](image/Figure_3.12_B17616.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 在 nano 中完成过滤器](image/Figure_3.12_B17616.jpg)'
- en: Figure 3.12 – Finishing the filter in nano
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 在 nano 中完成过滤器
- en: 'Let’s review this line by line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行回顾一下：
- en: '**if (ip.proto == TCP) {** is our parent **if** statement, checking if the
    packet in question is a TCP packet. If so, the script proceeds.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if (ip.proto == TCP) {** 是我们的父级 **if** 语句，用来检查数据包是否为 TCP 数据包。如果是，脚本将继续执行。'
- en: '**if (tcp.src == 22 || tcp.dst == 22 || tcp.src == 25 || tcp.dst == 25) {**
    is the nested if statement that checks if the TCP packet that passed our first
    check is coming from or destined to ports **22** or **25**. The double pipe means
    *or*, so any of these four checks will pass the if statement, taking us to the
    functions:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if (tcp.src == 22 || tcp.dst == 22 || tcp.src == 25 || tcp.dst == 25) {**
    是嵌套的 if 语句，用来检查通过我们第一次检查的 TCP 数据包是否来自或目标是端口 **22** 或 **25**。双竖线表示 *或*，因此这四个检查中的任何一个都会通过
    if 语句，使我们进入到以下函数：'
- en: '**msg()** displays a message in our Ettercap window. I would always recommend
    using this so that we know that the filter was triggered.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**msg()** 在我们的 Ettercap 窗口中显示一条信息。我建议始终使用这个函数，这样我们就能知道过滤器已被触发。'
- en: '**drop()** simply drops the packet; since we’re in the middle, it means we
    received it but we won’t be passing it on. The sender doesn’t get any confirmation
    of receipt, and the recipient never gets it.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**drop()** 只是丢弃数据包；由于我们处于数据包中间的位置，这意味着我们已接收到数据包，但不会将其转发给其他地方。发送方不会收到任何接收确认，而接收方也永远不会收到该数据包。'
- en: '**kill()** gets aggressive and sends an RST packet to both ends of the communication.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kill()** 变得更激进，向通信的两端发送一个 RST 数据包。'
- en: The two closing graph parentheses correspond to each **if** statement.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个闭合的图形括号对应每个 **if** 语句。
- en: I will save this text file with nano and prepare to compile it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 nano 保存这个文本文件，并准备编译它。
- en: 'Why are we compiling the filter? Because interpreting code is slow, and we’re
    dealing with analysis and manipulation in the middle of the packet’s flight. The
    compiler is very simple to use and is included, so we can simply issue the command
    with the name of the file we just created:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要编译过滤器？因为解释代码的速度较慢，而我们处理的是数据包飞行中的分析和操作。编译器非常简单易用，并且已包含在内，因此我们可以直接执行命令，传入我们刚刚创建的文件名：
- en: etterfilter [filter text file]
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etterfilter [过滤文本文件]
- en: 'We’ll see the compiler introduce itself and then it gets to work:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到编译器介绍自己，然后开始工作：
- en: '![Figure 3.13 – Compiling our filter with etterfilter ](image/Figure_3.13_B17616.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 使用 etterfilter 编译我们的过滤器](image/Figure_3.13_B17616.jpg)'
- en: Figure 3.13 – Compiling our filter with etterfilter
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 使用 etterfilter 编译我们的过滤器
- en: The default output is **filter.ef**, but you can name it whatever you want.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输出为 **filter.ef**，但你可以将其命名为任何你想要的名字。
- en: 'Now, we can simply fire up Ettercap like we did previously, but this time,
    we’re going to be loading our filter with **-F**. Ettercap does everything else
    automatically:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像之前一样启动 Ettercap，但这次我们将使用 **-F** 加载过滤器。Ettercap 会自动完成其他所有工作：
- en: ettercap -T -q -F filter.ef -B eth0 -B wlan0 -w SSH_SMTP_Filter_Testcapture
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ettercap -T -q -F filter.ef -B eth0 -B wlan0 -w SSH_SMTP_Filter_Testcapture
- en: 'I connect to our naughty network, and I try to connect to my SSH server at
    home. The connection fails, just as we had planned – but the console starts lighting
    up with my filter message. Let’s look in Wireshark and filter by port **22** traffic
    to see what’s going on:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我连接到我们那坏坏的网络，然后尝试连接到家里的 SSH 服务器。连接失败，就像我们计划的那样 —— 但控制台开始亮起我的过滤器信息。让我们在 Wireshark
    中查看并通过端口 **22** 流量来过滤，看看发生了什么：
- en: '![Figure 3.14 – Lighting up the LAN with RST packets ](image/Figure_3.14_B17616.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 用 RST 数据包点亮局域网](image/Figure_3.14_B17616.jpg)'
- en: Figure 3.14 – Lighting up the LAN with RST packets
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 用 RST 数据包点亮局域网
- en: What in tarnation? 26,792 RST packets in a matter of a couple of minutes! We
    just flooded ourselves with RST packets. How did we manage this with such a dinky
    script?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 什么鬼？短短几分钟内收到 26,792 个 RST 数据包！我们刚刚让自己被 RST 数据包淹没了。我们是怎么用这么一个小脚本做到这一点的？
- en: 'I know what the hacker in you is thinking: *we included a kill function in
    bridged sniffing, so the filter is running* *on two interfaces and designed to
    match any packet going to and from SSH, which would, by definition, include our
    RST packets*. Nicely done – I’m impressed. Let’s recompile our script and take
    out **kill()**.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你心中的黑客正在想什么：*我们在桥接嗅探中加入了 kill 功能，所以过滤器正运行在两个接口上，并设计为匹配任何进出 SSH 的数据包，这也会包括我们的
    RST 数据包*。做得好 —— 我印象深刻。我们重新编译一下脚本，去掉 **kill()**。
- en: 'That’s better:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好：
- en: '![Figure 3.15 – Dropping the kill function ](image/Figure_3.15_B17616.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 丢弃 kill 功能](image/Figure_3.15_B17616.jpg)'
- en: Figure 3.15 – Dropping the kill function
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 丢弃 kill 功能
- en: 'The network calms down and our bridge merely drops the packets without sending
    any RST packets. My SSH client running on our victim Windows box never gets the
    SYN-ACK it was hoping for:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 网络恢复平静，我们的桥接器仅丢弃数据包，而不发送任何 RST 数据包。我们在受害者 Windows 机器上运行的 SSH 客户端永远也收不到它期待的 SYN-ACK：
- en: '![Figure 3.16 – Port 22 successfully dropped ](image/Figure_3.16_B17616.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 成功丢弃端口 22](image/Figure_3.16_B17616.jpg)'
- en: Figure 3.16 – Port 22 successfully dropped
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 成功丢弃端口 22
- en: 'Any good pen tester has a variety of tools at his or her disposal. Often, different
    tools are comparable to each other in functionality, but one does something better
    than the other and vice versa. A common pain point for any pen tester is the wonderfully
    powerful tool that is no longer supported, so you make do with what was last updated
    a decade ago. Hey, if it ain’t broke, don’t fix it – some attacks, such as ARP
    spoofing, don’t change over the years at their core. However, any bugs that were
    present are there for life. Ettercap has proven itself to security practitioners,
    and we’ve seen its power here, but I’m going to wrap up the sniffing and spoofing
    discussion with the new kid on the block (relatively speaking): BetterCAP.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个优秀的渗透测试人员都会拥有多种工具。通常，这些工具的功能是相似的，但有的工具做得比其他工具更好，反之亦然。一个常见的痛点是，某些曾经强大的工具已经不再支持了，你只能使用那些十年前最后更新的工具。嘿，如果它没坏，别修理它
    —— 有些攻击，例如 ARP 欺骗，核心技术多年未变。然而，曾经存在的漏洞会永远存在。Ettercap 已经证明了自己的实力，我们也见识了它的强大，但我将结束嗅探和欺骗的讨论，带来一个新面孔（相对而言）：BetterCAP。
- en: Getting better – scanning, sniffing, and spoofing with BetterCAP
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变得更好 – 使用 BetterCAP 进行扫描、嗅探和欺骗
- en: 'We can get started and grab BetterCAP on Kali very easily as it’s in the repository:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地在 Kali 上启动并获取 BetterCAP，因为它已经包含在仓库中了：
- en: apt-get install bettercap
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt-get install bettercap
- en: 'Back in my day, the legacy BetterCAP used a command-line interface. Now, there’s
    a very slick web interface to bring sniffing and spoofing into the current century.
    As with any locally hosted web interface, you’ll want to be aware of the credentials
    that are used for logging in. Grab nano and configure the HTTP caplet at **/usr/share/bettercap/caplets/http-ui.cap**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我那时候，传统的 BetterCAP 使用的是命令行界面。现在，有了一个非常简洁的网页界面，把嗅探和欺骗带入了现代。像任何本地托管的网页界面一样，你需要注意登录时使用的凭证。拿起
    nano 编辑器，配置 HTTP caplet 文件，路径为 **/usr/share/bettercap/caplets/http-ui.cap**：
- en: '![Figure 3.17 – Configuring the HTTP UI ](image/Figure_3.17_B17616.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 配置 HTTP UI](image/Figure_3.17_B17616.jpg)'
- en: Figure 3.17 – Configuring the HTTP UI
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 配置 HTTP UI
- en: Take a Break from the Command Line
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行中休息一下
- en: Once you’ve logged in with the HTTP UI, you can modify any caplet parameters
    from there, including the username and password specified here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 HTTP UI 登录后，你就可以在这里修改任何 caplet 参数，包括这里指定的用户名和密码。
- en: 'Now, let’s get this party started by running the **bettercap –caplet http-ui**
    command. Then, you can fire up your browser and head on over to your localhost:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行 **bettercap –caplet http-ui** 命令来开始这个过程。然后，你可以打开浏览器并访问本地主机：
- en: '![Figure 3.18 – The Events window for BetterCAP ](image/Figure_3.18_B17616.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – BetterCAP 的事件窗口](image/Figure_3.18_B17616.jpg)'
- en: Figure 3.18 – The Events window for BetterCAP
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – BetterCAP 的事件窗口
- en: 'Our first stop is the **Events** tab. You can also keep an eye on what’s happening
    in the terminal window. Since we haven’t started anything yet, not much is happening
    here. Let’s click on the **LAN** tab and see if we can find some targets. Click
    the **net.probe** play button and grab some coffee while BetterCAP does the rest:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一站是 **事件** 标签。你也可以留意终端窗口中的内容。由于我们还没有开始任何操作，这里没发生什么事情。让我们点击 **LAN** 标签，看看能否找到一些目标。点击
    **net.probe** 的播放按钮，然后去喝杯咖啡，等待 BetterCAP 完成剩下的工作：
- en: '![Figure 3.19 – Starting the network probe ](image/Figure_3.19_B17616.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 启动网络探测](image/Figure_3.19_B17616.jpg)'
- en: Figure 3.19 – Starting the network probe
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 启动网络探测
- en: 'Immediately, we start probing the local network for hosts – and boy oh boy,
    those are some fast results! Hopefully, this concerns you: there’s no way it’s
    that fast without being all kinds of noisy. So, let’s take a look at Wireshark
    while we’re running this module:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们开始对本地网络进行主机探测——哇哦，那些结果真是太快了！希望这让你感到担忧：不可能这么快而不产生大量噪音。那么，让我们在运行这个模块时查看一下
    Wireshark：
- en: '![Figure 3.20 – The net.probe module behind the scenes ](image/Figure_3.20_B17616.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – net.probe 模块幕后](image/Figure_3.20_B17616.jpg)'
- en: Figure 3.20 – The net.probe module behind the scenes
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – net.probe 模块幕后
- en: 'There you have it – it’s an ARP sweep of the local network at a rate of over
    80 probes per second. In a real-world pen test, you’ll probably want this much
    lower (unless you are stress testing or making a point to your client). Click
    on the **Advanced** tab at the top, find the **net.probe** module in the listing
    on the left, and adjust the **net.probe.throttle** value based on your needs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——它以每秒超过 80 次探测的速度对本地网络进行 ARP 扫描。在真实的渗透测试中，你可能希望将这个速度降低（除非你是在进行压力测试或向客户证明某些事情）。点击顶部的
    **高级** 标签，在左侧的列表中找到 **net.probe** 模块，并根据需要调整 **net.probe.throttle** 的值：
- en: '![Figure 3.21 – Throttling the LAN probe ](image/Figure_3.21_B17616.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 限制 LAN 探测速度](image/Figure_3.21_B17616.jpg)'
- en: Figure 3.21 – Throttling the LAN probe
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 限制 LAN 探测速度
- en: 'I know what you’re thinking now: *whoa. There is a lot of cool stuff here*.
    This is where you can get a feel for the caplets that are installed and how they
    work. Along the left-hand side of the screen is a listing of BetterCAP’s capabilities.
    You’ll find **arp.spoof** to pull off the work from this chapter with a beautiful
    interface (move over, Cain sniffer). Some of the additional flexibility offered
    by BetterCAP can be found under **Parameters** and includes the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你现在在想什么：*哇，这里有好多酷东西*。在这里，你可以感受一下安装的 caplets 及其工作原理。屏幕左侧列出了 BetterCAP 的功能。你会找到
    **arp.spoof**，它可以通过一个漂亮的界面完成本章的工作（让开，Cain sniffers）。BetterCAP 提供的一些额外灵活性可以在 **参数**
    下找到，包括以下内容：
- en: '**arp.spoof.fullduplex** allows you to poison the ARP table of just your target,
    or the tables of both the target and the gateway. In other words, are you pretending
    to be just your target, or both your target and the gateway? Since the target
    intends to chat with the gateway, setting **fullduplex** to **false** means you’ll
    only see the target’s half of the conversation. This may be desirable to stay
    under the radar.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arp.spoof.fullduplex** 允许你仅对目标主机或对目标和网关的 ARP 表进行攻击。换句话说，你是只假装是目标主机，还是假装是目标主机和网关？由于目标主机打算与网关通信，将
    **fullduplex** 设置为 **false** 意味着你只会看到目标主机的部分对话。这可能有助于保持低调。'
- en: '**arp.spoof.internal** simply attacks the entire LAN, allowing you to capture
    chatter between hosts. This need depends on the specific environment you’re in.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arp.spoof.internal** 仅攻击整个 LAN，允许你捕获主机之间的通信。这取决于你所处的具体环境。'
- en: '**arp.spoof.skip_restore** can be thought of as whether you’ll stop your attack
    rudely or politely. Remember that the ARP table is maintained by each host independently;
    the table will only change when it’s updated by ARP packets on the wire. If you
    run your attack, grab the loot you need, then unplug and run away, you’re leaving
    the network looking for your MAC address. *Restoring* in this context is what
    I call re-ARPing. Setting **skip_restore** to **true** is more disruptive.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arp.spoof.skip_restore** 可以理解为您是否会粗鲁或礼貌地停止攻击。请记住，每台主机都独立维护 ARP 表；表只会在通过网络上的
    ARP 数据包更新时才会更改。如果您运行攻击，获取所需的战利品，然后拔掉线逃跑，您会让网络寻找您的 MAC 地址。在这种情况下，恢复是我称之为重新 ARP
    的操作。将 **skip_restore** 设置为 **true** 会更具破坏性。'
- en: '**arp.spoof.targets** allows you to specify the targets for your attack. What’s
    nice about this field is that it accepts Nmap format as well, so it’s easier to
    drop in that data.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arp.spoof.targets** 允许您指定攻击目标。这个字段的好处是它也接受 Nmap 格式，因此更容易插入数据。'
- en: '**arp.spoof.whitelist** is for those situations where you need to specify your
    non-targets.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**arp.spoof.whitelist** 用于需要指定非目标的情况。'
- en: 'What you would normally be doing with the **set** command in BetterCAP is what
    the HTTP UI is handling for you here. My favorite thing about this is the aesthetics:
    it makes presentations for the client more exciting.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在BetterCAP中通常使用**set**命令的操作，在这里由HTTP UI处理。我最喜欢的是美学：它使客户的演示更加令人兴奋。
- en: Finally, click on the **Caplets** tab to get a look at the attacks you can pull
    off once BetterCAP has placed your interface in the privileged position you desire.
    I like to think of these as *recipes* using BetterCAP’s native capabilities. For
    example, check out the parameters under **http-req-dump**. You’ll see that it
    configures **net.probe**, **net.sniff**, **http.proxy**, **https.proxy**, and
    **arp.spoof**. For those of you who are adventurous, you’ll find exceptional configurability
    for your needs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击 **Caplets** 选项卡，查看一下 BetterCAP 将您的接口置于所需的特权位置后可以执行的攻击。我喜欢将这些看作是使用 BetterCAP
    的本机功能的 *配方*。例如，查看 **http-req-dump** 下的参数。您会看到它配置了 **net.probe**、**net.sniff**、**http.proxy**、**https.proxy**
    和 **arp.spoof**。对于那些勇于尝试的人，您会发现对您需求的出色可配置性。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about passive versus active sniffing. We started
    by exploring wireless LANs in monitor mode, which allowed us to capture data without
    revealing our presence. We used Airodump-ng to organize the wireless environment
    and inform more precise sniffing with Wireshark. After exploring the basics with
    Wireshark, we moved on to advanced statistical analysis of both passive and active
    sniffing methods. For the active sniffing phase, we connected to a network (thus
    revealing our presence) and captured data visible to our card. We applied advanced
    display filters to hone in on interesting packets within even very large network
    dumps. We then moved on to advanced Ettercap sniffing techniques, focusing on
    bridged sniffing with two interfaces. To demonstrate the power of this attack,
    we configured a malicious access point and set up our Kali box to function as
    a full-fledged traffic interceptor and IDS, including using Ettercap filters to
    capture and drop select data from the network. We then introduced BetterCAP, a
    sophisticated alternative to Ettercap.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习 passvie 与 active 嗅探的区别。我们首先探讨了监视模式下的无线局域网，这使我们能够捕获数据而不暴露我们的存在。我们使用
    Airodump-ng 来组织无线环境，并通过 Wireshark 进行更精确的嗅探。在使用 Wireshark 探索基础知识后，我们转向对 passvie
    和 active 嗅探方法的高级统计分析。对于 active 嗅探阶段，我们连接到一个网络（从而暴露我们的存在），并捕获我们的卡可见的数据。我们应用高级显示过滤器来聚焦于即使在非常大的网络转储中也能找到有趣数据包。然后我们转向使用两个接口进行桥接嗅探的高级
    Ettercap 嗅探技术。为了展示这种攻击的威力，我们配置了一个恶意访问点，并设置我们的 Kali 系统作为一个完整的流量拦截器和 IDS，包括使用 Ettercap
    过滤器来捕获和丢弃网络中的特定数据。然后我们介绍了 BetterCAP，这是 Ettercap 的一个复杂的替代品。
- en: In the next chapter, we will discuss Windows password fundamentals, and we will
    demonstrate practical attacks to capture Windows credentials off the wire and
    a host to feed into a password cracker. We will then discuss password cracking
    methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Windows密码基础知识，并演示捕获Windows凭据的实际攻击方法，以及供给密码破解器使用的主机。然后我们将讨论密码破解方法。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的了解：
- en: You put your wireless card in monitor mode and capture raw wireless packets
    without associating them with a WLAN. What sniffing concept is this?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将你的无线网卡置于监视模式，并捕获未与 WLAN 关联的原始无线数据包。这是什么嗅探概念？
- en: The BSSID of an access point is the same as the hardware’s _____________.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接入点的 BSSID 与硬件的_____________相同。
- en: Individual devices that participate in conversations are called ___________
    by Wireshark.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Wireshark 中，参与会话的各个设备被称为_____________。
- en: What is the Wireshark display filter called that’s used to find any packet with
    the TCP ACK flag set?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于查找设置了 TCP ACK 标志的任何数据包的 Wireshark 显示过滤器叫什么？
- en: When writing Ettercap filters, you can put a space between a function name and
    the opening parenthesis. (True | False)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写 Ettercap 过滤器时，你可以在函数名称和开括号之间放置一个空格。（正确 | 错误）
- en: What Ettercap filter function will quietly prevent packets from passing to a
    destination?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么 Ettercap 过滤器函数会悄悄地阻止数据包传递到目的地？
- en: How do you reduce the verbosity of Ettercap’s command-line interface?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何减少 Ettercap 命令行界面的详细程度？
- en: What is the file extension of a binary Ettercap filter?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个二进制 Ettercap 过滤器的文件扩展名是什么？
- en: What does ICMP stand for?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ICMP 代表什么？
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖的主题的更多信息，请查看以下资源：
- en: 'Ettercap main page: [https://linux.die.net/man/8/ettercap](https://linux.die.net/man/8/ettercap)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ettercap 主页：[https://linux.die.net/man/8/ettercap](https://linux.die.net/man/8/ettercap)
- en: 'etterfilter main page, which includes details about scripting syntax: [https://linux.die.net/man/8/etterfilter](https://linux.die.net/man/8/etterfilter)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etterfilter 主页，包括有关脚本语法的详细信息：[https://linux.die.net/man/8/etterfilter](https://linux.die.net/man/8/etterfilter)
- en: 'Advanced Wireshark usage guide: [https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml](https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Wireshark 使用指南：[https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml](https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml)
- en: 'RFC 792: [https://datatracker.ietf.org/doc/html/rfc792](https://datatracker.ietf.org/doc/html/rfc792)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 792：[https://datatracker.ietf.org/doc/html/rfc792](https://datatracker.ietf.org/doc/html/rfc792)
- en: 'RFC 793: [https://datatracker.ietf.org/doc/html/rfc793](https://datatracker.ietf.org/doc/html/rfc793)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC 793：[https://datatracker.ietf.org/doc/html/rfc793](https://datatracker.ietf.org/doc/html/rfc793)
