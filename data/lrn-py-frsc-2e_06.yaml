- en: Extracting Artifacts from Binary Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从二进制文件中提取工件
- en: Parsing binary data is an indispensable skill. Inevitably, we are tasked with
    analyzing artifacts that are unfamiliar or undocumented. This issue is compounded
    when the file of interest is a binary file. Rather than analyzing a text-like
    file, we often need to use our favorite hex editor to begin reverse engineering
    the file's internal binary structure. Reverse engineering the underlying logic
    of binary files is out of scope for this chapter. Instead, we will work with a
    binary object whose structure is already well-known. This will allow us to highlight
    how to use Python to parse these binary structures automatically once the internal
    structure is understood. In this chapter, we will examine the `UserAssist` registry
    key from the `NTUSER.DAT` registry hive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 解析二进制数据是一个不可或缺的技能。我们不可避免地会遇到需要分析的不熟悉或未记录的工件。当感兴趣的文件是二进制文件时，这个问题更加复杂。与分析类文本文件不同，我们通常需要使用我们最喜欢的十六进制编辑器来开始逆向工程文件的内部二进制结构。逆向工程二进制文件的底层逻辑超出了本章的讨论范围。相反，我们将使用一个已经熟知结构的二进制对象。这将使我们能够突出展示如何在理解内部结构后，使用
    Python 自动解析这些二进制结构。在本章中，我们将检查来自 `NTUSER.DAT` 注册表配置单元的 `UserAssist` 注册表项。
- en: 'This chapter illustrates how to extract Python objects from binary data and
    generate an automatic Excel report. We will use three modules to accomplish this
    task: `struct`, `yarp`, and `xlsxwriter`. Although the `struct` module is included
    in the standard installation of Python, both `yarp` and `xlsxwriter` must be installed
    separately. We will cover how to install these modules in their respective sections.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何从二进制数据中提取 Python 对象并生成自动化 Excel 报告。我们将使用三个模块来完成这项任务：`struct`、`yarp` 和
    `xlsxwriter`。虽然 `struct` 模块包含在 Python 的标准安装中，但 `yarp` 和 `xlsxwriter` 必须单独安装。我们将在各自的章节中讲解如何安装这些模块。
- en: The `struct` library is used to parse the binary object into Python objects.
    Once we have parsed the data from the binary object, we can write our findings
    into a report. In past chapters, we have reported results in the CSV or HTML files.
    In this chapter, we will create an Excel report containing tables and summary
    charts of the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 库用于将二进制对象解析为 Python 对象。一旦我们从二进制对象中解析出数据，就可以将我们的发现写入报告中。在过去的章节中，我们已经将结果报告在
    CSV 或 HTML 文件中。在本章中，我们将创建一个包含数据表格和汇总图表的 Excel 报告。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the `UserAssist` artifact and its binary structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `UserAssist` 工件及其二进制结构
- en: An introduction to ROT-13 encoding and decoding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROT-13 编码与解码简介
- en: Installing and manipulating registry files with the `yarp` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `yarp` 模块安装和操作注册表文件
- en: Using `struct` to extract Python objects from binary data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`struct`从二进制数据中提取 Python 对象
- en: Creating worksheets, tables, and charts using `xlsxwriter`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `xlsxwriter` 创建工作表、表格和图表
- en: The code for this chapter was developed and tested using Python 2.7.15 and Python
    3.7.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码是在 Python 2.7.15 和 Python 3.7.1 上开发和测试的
- en: UserAssist
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserAssist
- en: 'The `UserAssist` artifact identifies **graphical user interface** (**GUI**)
    application execution on Windows machines. This artifact stores differing amounts
    of information depending on the version of Windows OS. To identify the data specific
    to certain applications, we have to decode the registry key name as it is stored
    as the ROT13-encoded path and name of the application. As an example, the `UserAssist`
    value data for Windows XP and Vista is 16 bytes in length, and it stores the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserAssist` 工件标识 **图形用户界面**（**GUI**）应用程序在 Windows 机器上的执行。根据 Windows 操作系统的版本，这个工件存储的信息量不同。为了识别特定应用程序的数据，我们必须解码注册表项名称，因为它是作为
    ROT13 编码的路径和应用程序名称存储的。例如，Windows XP 和 Vista 的 `UserAssist` 值数据长度为 16 字节，存储如下信息：'
- en: The last execution time in UTC (in FILETIME format)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后执行时间的 UTC 信息（以 FILETIME 格式）
- en: Execution count
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行计数
- en: Session ID
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话 ID
- en: The last execution time information is stored as a Windows FILETIME object.
    This is another common representation of time that differs from the UNIX timestamps
    we've seen in previous chapters. We will show how this timestamp can be interpreted
    within Python and displayed as human-readable, later in this chapter. The execution
    count represents the number of times the application has been launched.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行时间信息以 Windows FILETIME 对象的形式存储。这是另一种常见的时间表示方法，区别于我们在之前章节中看到的 UNIX 时间戳。我们将在本章后面展示如何在
    Python 中解读这个时间戳并以人类可读的形式显示。执行计数表示应用程序被启动的次数。
- en: 'Windows 7 and higher store even more data than their predecessors. Windows
    7 `UserAssist` values are 72 bytes in length and, in addition to the three previously
    mentioned artifacts, store the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 7及更高版本存储的数据比它们的前身更多。Windows 7的`UserAssist`值长度为72字节，并且除了前述的三个艺术品外，还存储以下内容：
- en: Focus count
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点计数
- en: Focus time
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点时间
- en: The focus count is the number of times the application was clicked on to bring
    it back into focus. For example, when you have two applications opened, only one
    is in focus at a given time. The other application is inactive until it is clicked
    on again. The focus time is the total amount of time a given application was in
    focus, and it is expressed in milliseconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点计数是将应用程序点击以将其带回焦点的次数。例如，当您打开两个应用程序时，只有一个应用程序在给定时间内处于焦点状态。另一个应用程序在再次点击它之前处于非活动状态。焦点时间是给定应用程序处于焦点状态的总时间，以毫秒表示。
- en: This registry artifact does not store the execution of command-line-based programs
    or GUI applications that are Windows startup programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此注册表项不存储基于命令行的程序或Windows启动程序的GUI应用程序的执行。
- en: 'The `UserAssist` registry key is located within the `NTUSER.DAT` registry hive
    found in the root folder of every user''s home directory. Within this hive, the
    `UserAssist` key is found at `SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\UserAssist`.
    Subkeys of the `UserAssist` key consist of known GUIDs and their respective count
    subkey. Within the count subkey of each GUID, there may be numerous values related
    to program execution. This structure is demonstrated here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserAssist`注册表键位于每个用户主目录的根文件夹中找到的`NTUSER.DAT`注册表中。在这个注册表中，`UserAssist`键位于`SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\UserAssist`。`UserAssist`键的子键包括已知的GUID及其各自的计数子键。在每个GUID的计数子键中，可能有与程序执行相关的多个值。该结构如下所示：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The values within the count subkey store the application execution information
    we are interested in parsing. Each value's name under the count subkey represents
    the ROT-13-encoded path and name of the executable. This makes it difficult to
    identify executables at first glance. Let's fix that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计数子键内的值存储了我们感兴趣的应用程序执行信息。计数子键下每个值的名称表示了ROT-13编码的可执行文件的路径和名称。这使得一眼难以识别可执行文件。让我们修复这个问题。
- en: Understanding the ROT-13 substitution cipher – rot13.py
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ROT-13替换密码 - rot13.py
- en: ROT-13 is a simple substitution cipher that transforms text and substitutes
    each character with another, thirteen characters after it. For example, the letter
    `a` would be substituted with the letter `n` and vice versa. Elements such as
    numbers, special characters, and a character's case are unaffected by the cipher.
    While Python does offer a built-in way of decoding ROT-13, we are going to pretend
    that it doesn't exist and manually decode ROT-13 data. We will use the built-in
    ROT-13 decoding method in our script.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ROT-13是一种简单的替换密码，它转换文本并用后面的十三个字符替换每个字符。例如，字母`a`将被替换为字母`n`，反之亦然。数字、特殊字符和字符的大小写在密码的影响下不变。虽然Python确实提供了一种内置的解码ROT-13的方式，但我们假装它不存在，并手动解码ROT-13数据。我们将在脚本中使用内置的ROT-13解码方法。
- en: 'Before we pretend that this functionality doesn''t exist, let''s quickly use
    it to illustrate how we could encode and decode ROT-13 data with Python 2:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们假装这个功能不存在之前，让我们快速使用它来说明如何使用Python 2对ROT-13数据进行编码和解码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Decoding or encoding with ROT-13 in Python 3 requires a slightly different
    approach with the native `codecs` library:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，使用原生的`codecs`库对ROT-13进行解码或编码需要稍微不同的方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's look at how you might approach this if it weren't already built-in.
    While you should never reinvent the wheel, we want to take this opportunity to
    practice list operations and introduce a tool to audit code. The code from the
    `rot13.py` script in the code bundle for this chapter is demonstrated next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果没有内置功能，您可能会如何处理这个问题。虽然你不应该重复造轮子，但我们希望借此机会练习列表操作并介绍一个用于审计代码的工具。本章代码包中的`rot13.py`脚本中的代码如下所示。
- en: 'The `rot_code()` function defined at line 32 accepts a ROT-13-encoded or ROT-13-decoded
    string. On line 39, we have `rot_chars`, a list of characters in the alphabet.
    As we iterate through each character in the supplied input, we will use this list
    to substitute the character with its counterpart 13 elements away. As we execute
    this substitution, we will store them in the substitutions list instantiated in
    line 43:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第32行定义的`rot_code()`函数接受一个经过ROT-13编码或解码的字符串。在第39行，我们有`rot_chars`，一个包含字母表中字符的列表。当我们遍历输入的每个字符时，我们将使用该列表将字符替换为其相隔13个元素的对照字符。在执行替换时，我们会将其存储在第43行初始化的替换列表中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On line 46, we begin to walk through each character, `c`, in the data string.
    On line 49, we use a conditional statement to determine if the character is uppercase
    or lowercase. We do this to preserve the case of the character as we process it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第46行，我们开始遍历数据字符串中的每个字符`c`。在第49行，我们使用条件语句来判断字符是大写字母还是小写字母。这样做是为了在处理时保留字符的大小写：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On line 54, we attempt to identify the index of the character in our list.
    If the character is a non-alphabetical character, we will receive a `ValueError`
    exception. Non-alphabetical characters, such as numbers or special characters,
    are appended to the substitutions list unmodified as these types of values are
    not encoded by ROT-13:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第54行，我们尝试识别字符在列表中的索引。如果字符是非字母字符，我们将收到一个`ValueError`异常。数字或特殊字符等非字母字符将不做任何修改地添加到替换列表中，因为这些类型的值不会被ROT-13编码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have found the index of the character, we can calculate the corresponding
    index 13 characters away by subtracting 13\. For values less than 13, this will
    be a negative number. Fortunately, list indexing supports negative numbers and
    works splendidly here. Before appending the corresponding character to our substitutions
    list, we use the string `upper()` function to return the character to its original
    case:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到字符的索引，我们就可以通过减去13来计算相隔13个字符的对应索引。对于小于13的值，这将是一个负数。幸运的是，列表索引支持负数，并且在这里表现得非常好。在将对应的字符添加到替换列表之前，我们使用字符串的`upper()`函数将字符恢复为其原始大小写：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `else` statement of the conditional block handles lowercase characters.
    The following code block is substantially the same functionality as what we just
    covered. The difference is that we never use lowercase or uppercase because the
    character is already in the proper case to be processed:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句的`else`部分处理小写字符。以下代码块的功能与我们刚刚讨论的基本相同。不同之处在于，我们从不使用小写或大写字母，因为字符已经处于正确的大小写格式，便于处理：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, on line 76, we collapse the substitutions list to a string using the
    `join()` method. We join on an empty string so that each element of the list is
    appended without any separating characters. If this script is invoked from the
    command line, it will print out the processed string, `Jul, EBG-13?`, which we
    know corresponds to `ROT-13?`. We have the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第76行，我们使用`join()`方法将替换列表合并为一个字符串。我们在空字符串上进行连接，这样列表中的每个元素都会被附加，而没有任何分隔符。如果从命令行调用此脚本，它将输出处理后的字符串`Jul,
    EBG-13?`，我们知道它对应的是`ROT-13?`。我们有以下代码：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot illustrates how we can import our `rot13` module and
    call the `rot_code()` method to either decode or encode a string:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们如何导入`rot13`模块并调用`rot_code()`方法来解码或编码字符串：
- en: '![](img/b57fa910-b502-48b3-9555-b4d80ba72530.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b57fa910-b502-48b3-9555-b4d80ba72530.png)'
- en: Make sure that the Python interactive prompt is opened in the same directory
    as the `rot13.py` script. Otherwise, an `ImportError` will be generated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Python交互式提示符与`rot13.py`脚本在同一目录下打开。否则，将会生成`ImportError`错误。
- en: Evaluating code with timeit
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用timeit评估代码
- en: 'Let''s now audit our module and see if it is superior to the built-in method
    (spoiler: it''s not!) We mentioned that you should never reinvent the wheel unless
    absolutely required. There''s a good reason: most built-in or third-party solutions
    have been optimized for performance and security. How does our `rot_code()` function
    stack up against the built-in function? We can use the `timeit` module to calculate
    the time a function or line of code takes to execute.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们审视一下我们的模块，看看它是否优于内置方法（剧透：并不是！）我们曾提到，除非绝对必要，否则你不应重新发明轮子。这样做是有充分理由的：大多数内置或第三方解决方案已经过性能和安全性优化。我们的`rot_code()`函数与内置函数相比如何呢？我们可以使用`timeit`模块来计算一个函数或代码行执行所需的时间。
- en: Let's compare the difference between the two methods of decoding ROT-13 values.
    Supplying the Python interpreter with `-m` executes a named module if its parent
    directory is found in the `sys.path` list. The `timeit` module can be called directly
    from the command line using the `-m` switch.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两种解码ROT-13值的方法之间的差异。通过向Python解释器提供`-m`选项，如果其父目录在`sys.path`列表中，则会执行指定的模块。`timeit`模块可以直接从命令行通过`-m`选项调用。
- en: We can see what directories are in scope by importing the `sys` module and printing
    `sys.path`. To extend the items available through `sys.path`, we can append new
    items to it using list attributes, such as append or extend.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导入`sys`模块并打印`sys.path`来查看哪些目录在作用范围内。为了扩展`sys.path`中可用的项目，我们可以使用列表属性（如append或extend）将新项目追加到其中。
- en: The `timeit` module supports a variety of switches, and can be used to run individual
    lines of code or entire scripts. The `-v` switch prints more verbose output, and
    is increasingly more verbose when supplied with additional `v` switches. The `-n`
    switch is the number of times to execute the code or script (for example, the
    number of executions per measuring period). We can use the `-r` switch to specify
    how many times to repeat a measurement (defaults to `3`). Increasing this will
    allow us to calculate a more accurate average execution speed. Finally, the `-s`
    switch is a statement to be run once on the first round of execution, in this
    case, to allow us to import the script we made. For further documentation, please
    visit [http://docs.python.org/3/library/timeit.html](http://docs.python.org/3/library/timeit.html)
    or run `python -m timeit -h`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块支持多种开关，并可以用于运行单行代码或整个脚本。`-v`开关打印更详细的输出，且当提供更多的`v`开关时，输出会越来越详细。`-n`开关是执行代码或脚本的次数（例如，每个测量周期内的执行次数）。我们可以使用`-r`开关来指定重复测量的次数（默认为`3`）。增加这个值可以让我们计算出更精确的平均执行速度。最后，`-s`开关是一个在第一次执行时运行的语句，用于让我们导入制作的脚本。有关更多文档，请访问[http://docs.python.org/3/library/timeit.html](http://docs.python.org/3/library/timeit.html)或运行`python
    -m timeit -h`。'
- en: 'The output generated on our computer when timing both methods is captured in
    the following screenshot. Performance may vary depending on the machine. For our
    first test, we measured the time it took to run three one million cycles of our
    script. On the first cycle, we imported our module, `rot13`, before calling it.
    On the second test, we similarly measured three one-million cycles of the built-in
    Python 2 `decode()` functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在计算两种方法的执行时间时，计算机生成的输出如以下截图所示。性能可能会因机器不同而有所差异。在我们的第一次测试中，我们测量了运行三次一百万次脚本所需的时间。在第一次循环中，我们先导入了我们的模块`rot13`，然后才调用它。在第二次测试中，我们同样测量了Python
    2内置`decode()`函数的三次一百万循环：
- en: '![](img/4a42bb2c-e3a3-452b-8dbe-5b982a4a4104.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a42bb2c-e3a3-452b-8dbe-5b982a4a4104.png)'
- en: It turns out that there is good reason to not reinvent the wheel. Our custom
    `rot_code()` function is significantly slower than the built-in method when run
    a thousand times. Odds are we will not call this function a thousand times; for
    the `UserAssist` key, this function will likely be called only hundreds of times.
    However, if we were working with more data or had a particularly slow script,
    we could begin timing individual functions or lines of code to identify poorly
    optimized code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，不必重新发明轮子是有充分理由的。我们的自定义`rot_code()`函数在运行一千次时明显比内置方法慢。我们可能不会调用这个函数一千次；对于`UserAssist`键，这个函数可能只会调用几百次。然而，如果我们处理更多数据或脚本特别慢，我们就可以开始对单独的函数或代码行进行计时，找出那些优化不良的代码。
- en: As an aside, you can also use the `time.time()` function before and after a
    function call and calculate the elapsed time by subtracting the two times. This
    alternative approach is slightly simpler to implement but not as robust.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一句，你还可以在函数调用前后使用`time.time()`函数，通过减去两个时间点来计算经过的时间。这种替代方法实现起来稍微简单一些，但没有那么健壮。
- en: You have now learned about the `UserAssist` artifact, ROT-13 encoding, and a
    mechanism to audit our code. Let's shift focus and examine other modules that
    will be used in this chapter. One of those modules, `yarp`, will be used to access
    and interact with the `UserAssist` key and values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了`UserAssist`工件、ROT-13编码以及审计我们代码的机制。让我们转移焦点，看看本章中将要使用的其他模块。其中一个模块`yarp`将用于访问和交互`UserAssist`键和值。
- en: Working with the yarp library
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用yarp库
- en: The **yarp** (short for **Yet Another Registry Parser**) library can be used
    to obtain keys and values from registry hives. Python provides a built-in registry
    module named `_winreg`; however, this module only works on Windows machines. The
    `_winreg` module interacts with the registry on the system running the module.
    It does not support opening external registry hives.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**yarp**（即**Yet Another Registry Parser**）库可以用来从注册表hive中获取键和值。Python提供了一个名为`_winreg`的内置注册表模块；然而，这个模块仅在Windows机器上工作。`_winreg`模块与运行该模块的系统上的注册表进行交互。它不支持打开外部的注册表hive。'
- en: 'The `yarp` library allows us to interact with supplied registry hives and can
    be run on non-Windows machines. The `yarp` library can be downloaded from [https://github.com/msuhanov/yarp](https://github.com/msuhanov/yarp).
    On the project''s GitHub page, click on the releases section to see a list of
    all stable versions and download the desired version. For this chapter, we use
    version 1.0.25\. Once the archived file is downloaded and extracted, we can run
    the included `setup.py` file to install the module. In a Command Prompt, execute
    the following code in the module''s top-level directory:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarp`库允许我们与提供的注册表hive进行交互，并且可以在非Windows机器上运行。`yarp`库可以从[https://github.com/msuhanov/yarp](https://github.com/msuhanov/yarp)下载。在该项目的GitHub页面上，点击发布部分，可以看到所有稳定版本的列表，并下载所需的版本。对于本章，我们使用的是1.0.25版本。下载并解压缩归档文件后，我们可以运行其中的`setup.py`文件来安装模块。在命令提示符中，在模块的顶级目录执行以下代码：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This should install the `yarp` library successfully on your machine. We can
    confirm by opening the Python interactive prompt and typing `import yarp`. We
    will receive an error if the module was not installed successfully. With `yarp`
    installed, let's begin learning how we can leverage this module for our needs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能够成功地在你的机器上安装`yarp`库。我们可以通过打开Python交互式提示符并输入`import yarp`来确认。如果模块没有成功安装，我们将收到一个错误。安装了`yarp`后，接下来我们可以开始学习如何利用这个模块满足我们的需求。
- en: 'First, we need to import the `Registry` class from the `yarp` module. Then,
    we use the `RegistryHive` function and pass it the registry object we want to
    query. In this example, we have copied the `NTUSER.DAT` registry file to our current
    working directory, which allows us to supply just the filename and not the path.
    Next, we use the `find_key` method to navigate to our key of interest. In this
    case, we are interested in the `RecentDocs` registry key. This key contains recent
    active files separated by extension:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`yarp`模块中导入`Registry`类。然后，使用`RegistryHive`函数并将其传递给我们想要查询的注册表对象。在这个例子中，我们已将`NTUSER.DAT`注册表文件复制到当前工作目录，这样我们只需要提供文件名而不需要路径。接下来，我们使用`find_key`方法来导航到我们感兴趣的键。在这个例子中，我们关注的是`RecentDocs`注册表键。这个键包含按扩展名分隔的最近活动文件：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we print the `recent_docs` variable, we can see that it contains 151 values
    with 75 subkeys, which may contain additional values and subkeys. In addition,
    we can use the `last_written_timestamp()` method to see the last written time
    of the registry key:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印`recent_docs`变量，我们可以看到它包含151个值和75个子键，这些子键可能包含附加的值和子键。此外，我们还可以使用`last_written_timestamp()`方法查看注册表键的最后写入时间：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can iterate over the values in the `recent_docs` key using the `subkeys()` function
    in a for loop. For each value, we can access the `name()`, `value()`, and `values_count()`
    methods, among others. When accessing a value (as opposed to a subkey), we can
    also access the value''s raw data by using the `raw_data()` function. For our
    purposes, we use the `raw_data()` function when we want to work with the underlying
    binary data. We have the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`subkeys()`函数在`recent_docs`键的值上进行迭代，使用for循环遍历。对于每个值，我们可以访问`name()`、`value()`和`values_count()`方法等。访问值时（与访问子键不同），我们还可以通过使用`raw_data()`函数访问该值的原始数据。对于我们的目的，当我们想处理底层的二进制数据时，会使用`raw_data()`函数。我们有如下代码：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another useful feature of the `yarp` module is a provided means of querying
    for a certain subkey or value. This is provided by the `subkey()`, `value()`,
    or `find_key()` functions. A `None` value is generated when a subkey is not present
    when using the `subkey()` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarp`模块的另一个有用功能是提供了查询特定子键或值的方式。这可以通过`subkey()`、`value()`或`find_key()`函数来实现。如果使用`subkey()`函数时找不到子键，则会生成`None`值：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `find_key()` function takes a path and can find a subkey recursively through
    multiple levels. The `subkey()` and `value()` functions search only child elements.
    We can use these functions to confirm that a key or value exists before trying
    to navigate to them. `yarp` has a number of other relevant features not covered
    here, including recovering deleted registry keys and values, carving registry
    keys and values, and supporting transaction log files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_key()` 函数接受一个路径，并能够通过多级递归查找子键。`subkey()` 和 `value()` 函数仅搜索子元素。我们可以使用这些函数在尝试导航到键或值之前确认它们是否存在。`yarp`
    还提供了其他一些相关功能，本文未涵盖，包括恢复已删除的注册表键和值、提取注册表键和值以及支持事务日志文件。'
- en: With the `yarp` module, finding keys and their values is straightforward. However,
    when the values are not strings and are instead binary data, we have to rely on
    another module to make sense of the mess. For all binary needs, the `struct` module
    is an excellent candidate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `yarp` 模块，查找键及其值非常简单。然而，当值不是字符串而是二进制数据时，我们必须依赖另一个模块来理清数据。对于所有二进制相关的需求，`struct`
    模块是一个极好的选择。
- en: Introducing the struct module
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 `struct` 模块
- en: The `struct` module is part of the standard Python library and is incredibly
    useful. The `struct` library is used to convert C structures to or from binary
    data. Full documentation for this module can be found at [http://docs.python.org/3/library/struct.html](http://docs.python.org/3/library/struct.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 模块是 Python 标准库的一部分，非常有用。`struct` 库用于将 C 结构转换为二进制数据，或将二进制数据转换为 C 结构。该模块的完整文档可以在
    [http://docs.python.org/3/library/struct.html](http://docs.python.org/3/library/struct.html)
    找到。'
- en: For forensic purposes, the most important function in the struct module is the
    `unpack()` method. This method takes a format string representing the objects
    to be extracted from the binary data. It is important that the size dictated by
    the format string correlates to the size of the binary data supplied to the function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 出于取证目的，`struct` 模块中最重要的函数是 `unpack()` 方法。该方法接受一个格式字符串，表示要从二进制数据中提取的对象。格式字符串指定的大小必须与传递给函数的二进制数据的大小相符。
- en: 'The format string informs the `unpack()` function of what kind of data is in
    the binary object and how it should be interpreted. If we do not correctly identify
    the types of data or try to unpack more or less than what is provided, the `struct`
    module will throw an exception. The following is a table of the most common characters
    we use to build our format strings. The standard size column indicates the expected
    size of the binary object in bytes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串告诉 `unpack()` 函数二进制对象中包含的数据类型及其解释方式。如果我们没有正确识别数据类型或尝试解包的数据比提供的数据多或少，`struct`
    模块将抛出异常。以下是构建格式字符串时最常用字符的表格。标准大小列表示二进制对象的预期大小（以字节为单位）：
- en: '| **Character** | **Python object** | **Standard size (bytes)** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **Python 对象** | **标准大小（字节）** |'
- en: '| `h` | Integer | 2 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 整数 | 2 |'
- en: '| `i` | Integer | 4 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 整数 | 4 |'
- en: '| `q` | Integer | 8 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 整数 | 8 |'
- en: '| `s` | String | 1 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 字符串 | 1 |'
- en: '| `x` | N/A | N/A |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 不适用 | 不适用 |'
- en: There are additional characters that can be used in format strings. For example,
    other characters can interpret binary data as floats, Booleans, and other various
    C structures. The `x` character is simply a padding character that can be used
    to ignore bytes we're not interested in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串中还可以使用其他字符。例如，其他字符可以将二进制数据解释为浮点数、布尔值以及其他各种 C 结构。`x` 字符仅仅是一个填充字符，用于忽略我们不关心的字节。
- en: Additionally, an optional starting character can be used to define byte order,
    size, and alignment. The default is native byte order, size, and alignment. As
    we cannot predict the environment the script might be running on, it is often
    not advisable to use any native option. Instead, we can specify little or big
    endian byte order with standard sizes using the `<" and ">` symbols, respectively.
    Let's practice with a few examples.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用可选的起始字符来定义字节顺序、大小和对齐方式。默认情况下是本地字节顺序、大小和对齐方式。由于我们无法预测脚本可能运行的环境，因此通常不建议使用任何本地选项。相反，我们可以使用
    `<` 和 `>` 符号分别指定小端或大端字节顺序和标准大小。让我们通过几个例子来实践。
- en: 'First, open an interactive prompt and import `struct`. Next, we assign 0x01000000
    to a variable. In Python 3, hex notation is specified by an escape character and
    an `x` before every two hexadecimal characters. The length of our hex data is
    four bytes, and to interpret this as an integer, we use the `i` character. Interpreting
    the hex as a little endian integer returns a value of `1`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个交互式提示符并导入`struct`模块。接下来，我们将0x01000000赋值给一个变量。在Python 3中，十六进制表示法通过转义字符和每两个十六进制字符前的`x`来指定。我们的十六进制数据长度为四个字节，为了将其解释为一个整数，我们使用`i`字符。将十六进制数据解释为小端整数时，返回的值是`1`：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `<i` and `>i` represents the string format. We are telling the `unpack()`
    method to interpret `raw_data` as a four-byte integer in little or big endian
    byte ordering. The struct module returns the unpacked data as a tuple. By default,
    Python will print a single element tuple in parenthesis with a trailing comma,
    as seen in the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<i`和`>i`表示字符串格式。我们告诉`unpack()`方法将`raw_data`解释为一个四字节整数，按照小端或大端字节顺序。`struct`模块将解包的数据作为元组返回。默认情况下，Python会将一个单一元素的元组打印在括号中，并带有尾随逗号，如以下输出所示：'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s look at another example. We can interpret `rawer_data` as three 4-byte
    integers by using three `i` characters. Alternatively, we can prepend a number
    to the format character to parse multiple values in a row. In both cases, when
    interpreted as a little endian, we receive the integers `1`, `5`, and `4`. If
    we aren''t interested in the middle integer, we can skip it with the `4x` character:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们可以通过使用三个`i`字符将`rawer_data`解释为三个4字节整数。或者，我们可以在格式字符前加上数字，以便按顺序解析多个值。在这两种情况下，当按小端方式解释时，我们得到整数`1`、`5`和`4`。如果我们不关心中间的整数，可以使用`4x`字符跳过它：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We raised the possibility of errors with struct earlier in this section. Now,
    let''s purposely create errors with struct to understand what they mean. We receive
    an error for the following two examples because we tried to `unpack()` more or
    fewer values than were actually present in the `rawer_data` variable used previously.
    This can cause some initial frustration when trying to unpack a large amount of
    binary data. Always be sure to check the math, the byte order, and whether the
    size is standard or native:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节早些时候提到了使用`struct`时可能出现的错误。现在，让我们故意制造一些错误，以理解它们的含义。以下两个例子会出现错误，因为我们试图`unpack()`的数据量比`rawer_data`变量中实际存在的值多或少。这在尝试解包大量二进制数据时可能会导致一些初步的挫败感。务必检查数学计算、字节顺序以及大小是否为标准或本地格式：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take it one step further and parse a `UserAssist` value using the struct
    module. We will parse a Windows XP value, which represents the easiest scenario
    as it is only 16 bytes in length. The byte offsets of a Windows XP UserAssist
    value are recorded in the following table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，使用`struct`模块解析一个`UserAssist`值。我们将解析一个Windows XP的值，这是最简单的情况，因为它仅为16个字节。Windows
    XP UserAssist值的字节偏移量记录在以下表中：
- en: '| **Byte offset** | **Value** | **Object** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **字节偏移量** | **值** | **对象** |'
- en: '| 0-3 | Session ID | Integer |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0-3 | 会话ID | 整数 |'
- en: '| 4-7 | Count | Integer |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 4-7 | 计数 | 整数 |'
- en: '| 8-15 | FILETIME | Integer |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 8-15 | FILETIME | 整数 |'
- en: 'The following hex dump is saved into the file `Neguhe Qrag.bin`. The file is
    packaged with the code bundle that can be downloaded from [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下十六进制转储保存到文件`Neguhe Qrag.bin`中。该文件与代码包一起提供，可以从[https://packtpub.com/books/content/support](https://packtpub.com/books/content/support)下载：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When unpacking data from a file object, we need to open it in the `rb` mode
    rather than the default `r` mode to ensure that we can read the data as bytes.
    Once we have the raw data, we can parse it using our specific character format.
    We know that the first 8 bytes are two 4-byte integers (`2i`), and then one 8-byte
    integer (`q`) representing the FILETIME of the `UserAssist` value. We can use
    indexing on the returned tuple to print out each extracted integer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在从文件对象解包数据时，我们需要以`rb`模式打开文件，而不是默认的`r`模式，以确保可以将数据作为字节读取。获取原始数据后，我们可以使用特定的字符格式解析它。我们知道前8个字节是两个4字节整数（`2i`），然后是一个8字节整数（`q`），表示`UserAssist`值的FILETIME。我们可以对返回的元组进行索引，打印出每个提取的整数：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once we have parsed the `UserAssist` values in our script, we will present the
    results in a report-ready format. In the past, we have used CSV and HTML for output
    reports. Frequently, reports are often reviewed in spreadsheet format using software
    such as Microsoft Excel. To provide reports that fully leverage this software,
    we will learn how to create XSLX-formatted spreadsheets as an output of our script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在脚本中解析了`UserAssist`值，我们将以报告准备好的格式呈现结果。过去，我们使用了CSV和HTML格式的输出报告。报告通常会以电子表格格式进行审查，使用像Microsoft
    Excel这样的软件。为了提供充分利用此软件的报告，我们将学习如何将XSLX格式的电子表格作为脚本的输出。
- en: Creating spreadsheets with the xlsxwriter module
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xlsxwriter模块创建电子表格
- en: '`xlsxwriter` (version 1.1.2) is a useful third-party module that can write
    data to Excel spreadsheets. There are a plethora of Excel-supported modules for
    Python, but we chose this module because it was highly robust and well-documented.
    As the name suggests, this module can only be used to write Excel spreadsheets.
    The `xlsxwriter` module supports cell and conditional formatting, charts, tables,
    filters, and macros, among others. This module can be installed with `pip`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlsxwriter`（版本1.1.2）是一个有用的第三方模块，可以将数据写入Excel电子表格。Python有很多支持Excel的模块，但我们选择了这个模块，因为它非常强大且文档齐全。顾名思义，这个模块只能用于写入Excel电子表格。`xlsxwriter`模块支持单元格和条件格式、图表、表格、过滤器和宏等功能。这个模块可以通过`pip`安装：'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding data to a spreadsheet
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向电子表格中添加数据
- en: 'Let''s quickly create a script named `simplexlsx.v1.py` for this example. On
    lines 2 and 3, we import the `xlsxwriter` and `datetime` modules. The data we
    are going to be plotting, including the column names, is stored as nested lists
    in the `school_data` variable. Each list is a row of information we will want
    to store in the Excel spreadsheet, with the first element containing the column
    names:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个名为`simplexlsx.v1.py`的脚本来演示这个例子。在第2和第3行，我们导入了`xlsxwriter`和`datetime`模块。我们将要绘制的数据，包括列名，存储在`school_data`变量中的嵌套列表中。每个列表是一行信息，我们希望将其存储在Excel电子表格中，第一项包含列名：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `write_xlsx()` function, defined on line 45, is responsible for writing
    our data to a spreadsheet. First, we must create our Excel spreadsheet using the
    `Workbook()` function and supplying the desired name of the file as an input.
    On line 53, we create a worksheet using the `add_worksheet()` function. This function
    can take the desired title of the worksheet or use the default name `Sheet N`,
    where `N` represents a number:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_xlsx()`函数定义在第45行，负责将数据写入电子表格。首先，我们必须使用`Workbook()`函数创建Excel电子表格，并提供所需的文件名作为输入。在第53行，我们使用`add_worksheet()`函数创建工作表。此函数可以接受所需的工作表标题，或者使用默认名称`Sheet
    N`，其中`N`表示一个数字：'
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `date_format` variable stores a custom number format we will use to display
    our `datetime` objects in the desired human-readable format. On line 58, we begin
    to enumerate through our data to write. The conditional on line 59 is used to
    handle the first item, the column names, in the data list. We use the `write()`
    function and supply a numerical row and column. Alternatively, for instance, rather
    than using numerical values to represent the column and row to write the data
    to, we could have also used Excel notation such as `A1` to signify the data should
    be written to the first column and row:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_format`变量存储我们将用来显示`datetime`对象的自定义数字格式，以便以所需的易读格式显示它们。在第58行，我们开始遍历数据以进行写入。第59行的条件用于处理数据列表中的第一项，即列名。我们使用`write()`函数并提供数值型的行和列。例如，我们也可以使用Excel符号表示法，如`A1`，表示数据应写入第一列和第一行，而不是使用数值来表示列和行：'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `write()` method will try to write the appropriate data type for an object
    when it can detect that data''s type. However, we can use different write methods
    to specify the correct format. These specialized writers preserve the data type
    in Excel, so we can use the appropriate data type-specific Excel functions for
    the object. Since we know the data types within the entry list, we can manually
    specify when to use the general `write()` function versus the `write_number()`
    function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()`方法将尝试在检测到数据类型时写入适当的对象数据类型。然而，我们可以使用不同的写入方法来指定正确的格式。这些专用的写入方法会保留数据类型，以便我们可以使用适当的数据类型特定的Excel函数处理对象。由于我们知道条目列表中的数据类型，我们可以手动指定何时使用通用的`write()`函数，何时使用`write_number()`函数：'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For the fourth entry in the list, the `datetime` object, we supply the `write_datetime()`
    function with our `date_format` defined on line 55\. After our data is written
    to the workbook, we use the `close()` function to close and save our spreadsheet.
    On line 73, we call the `write_xlsx()` function, passing it the `school_data`
    list we built earlier, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的第四个条目，即 `datetime` 对象，我们向 `write_datetime()` 函数传入第55行定义的 `date_format`。数据写入工作簿后，我们使用
    `close()` 函数关闭并保存电子表格。在第73行，我们调用 `write_xlsx()` 函数，并将之前构建的 `school_data` 列表传入，代码如下：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A table of `write` functions and the objects they preserve is presented as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 `write` 函数及其保留的对象：
- en: '| **Function** | **Supported objects** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **支持的对象** |'
- en: '| `write_string` | `str` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `write_string` | `str` |'
- en: '| `write_number` | `int`, `float`, `long` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `write_number` | `int`、`float`、`long` |'
- en: '| `write_datetime` | `datetime` objects |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `write_datetime` | `datetime` 对象 |'
- en: '| `write_boolean` | `bool` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `write_boolean` | `bool` |'
- en: '| `write_url` | `str` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `write_url` | `str` |'
- en: 'When the script is invoked at the command line, a spreadsheet named `MyWorkbook.xlsx`
    is created. When we convert this to a table, we can sort by any of our values
    and use Excel functions and features we are all familiar with. Had we failed to
    preserve the data types, values such as our dates might be displayed differently
    than intended:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本在命令行中被调用时，会创建一个名为 `MyWorkbook.xlsx` 的电子表格。当我们将其转换为表格时，我们可以按任何值进行排序，并使用我们都熟悉的
    Excel 函数和功能。如果我们没有保留数据类型，像日期这样的值可能会显示得与预期不同：
- en: '![](img/6ebf556b-de5e-4dcd-90d4-4920d67fd960.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ebf556b-de5e-4dcd-90d4-4920d67fd960.png)'
- en: Building a table
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表格
- en: Being able to write data to an Excel file and preserve the object type is already
    a step up over CSV, but we can do better. Often, the first thing an examiner will
    do with an Excel spreadsheet is convert the data into a table and begin the frenzy
    of sorting and filtering the data set. However, we can convert our data range
    to a table using `xlsxwriter`. In fact, writing a table with `xlsxwriter` is arguably
    easier than writing each row individually. The code discussed in this section
    is represented in the `simplexlsx.v2.py` file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将数据写入Excel文件并保留对象类型，已经比CSV有所改进，但我们还能做得更好。通常，检查员在处理Excel电子表格时首先会做的就是将数据转换为表格，并开始对数据集进行排序和筛选。但我们可以使用
    `xlsxwriter` 将数据范围转换为表格。事实上，用 `xlsxwriter` 写入表格可以说比逐行写入要容易。本文讨论的代码体现在 `simplexlsx.v2.py`
    文件中。
- en: 'For this iteration, we have removed the initial list in the `school_data` variable
    that contained the column names. Our new `write_xlsx()` function writes the header
    separately, which we will see later:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一版本中，我们删除了 `school_data` 变量中包含列名的初始列表。我们新的 `write_xlsx()` 函数单独写入表头，稍后我们将看到这一点：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lines 44 through 55 are identical to the previous iteration of the function.
    Writing our table to the spreadsheet is accomplished on line 58\. See the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第44到55行与函数的前一版本相同。我们将表格写入电子表格的操作在第58行完成。请查看以下代码：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `add_table()` function takes multiple arguments. First, we pass a string
    representing the top-left and bottom-right cells of the table in Excel notation.
    We use the length variable, defined on line 56, to calculate the necessary length
    of our table. The second argument is a little more confusing; this is a dictionary
    with two keys, data and columns. The `data` key has the value of our data variable,
    which is perhaps poorly named in this case. The `columns` key defines each column
    header and, optionally, its format, as seen on line 62:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_table()` 函数接受多个参数。首先，我们传入一个表示表格左上角和右下角单元格的字符串，采用Excel表示法。我们使用在第56行定义的`length`变量来计算表格所需的长度。第二个参数稍微有些复杂；这是一个字典，包含两个键：data
    和 columns。`data` 键对应我们的 `data` 变量的值，在这个例子中，它可能命名得不好。`columns` 键定义了每个列头，并且可以选择性地定义其格式，如第62行所示：'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In fewer lines than the previous example, we've managed to create a more useful
    output built as a table. Now, our spreadsheet has our specified data already converted
    into a table and ready to be sorted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，我们用更少的代码行创建了一个更有用的输出，且它是以表格形式构建的。现在，我们的电子表格已经将指定的数据转换成了表格，并准备好进行排序。
- en: There are more possible keys and values that can be supplied during the construction
    of a table. Please consult the documentation ([http://xlsxwriter.readthedocs.org](http://xlsxwriter.readthedocs.org))
    for more details on advanced usage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建表格时，还可以提供更多的键和值。有关高级用法的更多详细信息，请查阅文档（[http://xlsxwriter.readthedocs.org](http://xlsxwriter.readthedocs.org)）。
- en: This process is simple when we are working with nested lists representing each
    row of a worksheet. Data structures not in this format require a combination of
    both methods demonstrated in our previous iterations to achieve the same effect.
    For example, we can define a table to span across a certain number of rows and
    columns and then use the `write()` function for those cells. However, to prevent
    unnecessary headaches, we recommend keeping data in nested lists where possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理表示工作表每一行的嵌套列表时，这个过程非常简单。对于不符合这种格式的数据结构，我们需要结合我们之前迭代中演示的两种方法，以实现相同的效果。例如，我们可以定义一个跨越特定行和列的表格，然后使用
    `write()` 函数写入这些单元格。然而，为了避免不必要的麻烦，我们建议在可能的情况下保持数据为嵌套列表格式。
- en: Creating charts with Python
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 创建图表
- en: Finally, let's create a chart with `xlsxwriter`. The module supports a variety
    of different chart types, including line, scatter, bar, column, pie, and area.
    We use charts to summarize data in meaningful ways. This is particularly useful
    when working with large datasets, allowing examiners to gain some preliminary
    understanding of the data before getting into the weeds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `xlsxwriter` 创建一个图表。该模块支持多种不同类型的图表，包括线形图、散点图、条形图、柱状图、饼图和区域图。我们使用图表来以有意义的方式总结数据。这在处理大数据集时特别有用，能够让分析人员在深入分析之前先对数据有个初步的了解。
- en: 'Let''s modify the previous iteration yet again to display a chart. We will
    save this modified file as `simplexlsx.v3.py`. On line 65, we are going to create
    a variable named `department_grades`. This variable will be our chart object created
    by the `add_chart()` method. For this method, we pass in a dictionary specifying
    keys and values. In this case, we specify the type of the chart to be a column
    chart:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改上一个版本，以显示图表。我们将把这个修改过的文件保存为 `simplexlsx.v3.py`。在第 65 行，我们将创建一个名为 `department_grades`
    的变量。这个变量将是我们通过 `add_chart()` 方法创建的图表对象。对于这个方法，我们传入一个字典，指定键和值。在这种情况下，我们指定图表的类型为柱状图：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On line 66, we use the `set_title()` function and again pass in a dictionary
    of parameters. We set the name key equal to our desired title. At this point,
    we need to tell the chart what data to plot. We do this with the `add_series()`
    function. Each category key maps to the Excel notation specifying the horizontal
    axis data. The vertical axis is represented by the `values` key. With the data
    to plot specified, we use the `insert_chart()` function to plot the data in the
    spreadsheet. We give this function a string representing the cell that will act
    as an anchor to plot the top-left corner of the chart to:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 66 行，我们使用 `set_title()` 函数，再次传入一个参数字典。我们将名称键设置为我们想要的标题。此时，我们需要告诉图表要绘制哪些数据。我们通过
    `add_series()` 函数来完成这一点。每个类别键都映射到 Excel 表示法，用于指定横轴数据。纵轴由 `values` 键表示。数据指定完成后，我们使用
    `insert_chart()` 函数在电子表格中绘制数据。我们给这个函数传递一个字符串，表示将作为锚点的单元格，图表的左上角将绘制在此处：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running this version of the script will convert our data into a table and generate
    a column chart, comparing departments by their cumulative grades. We can clearly
    see that, unsurprisingly, the Physics department has the highest GPA earners in
    the school''s program. This information is easy enough to eyeball for such a small
    dataset. However, when working with data orders of greater magnitude, creating
    summarizing graphics can be particularly useful to understand the big picture:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此版本的脚本将把我们的数据转换为表格并生成一个柱状图，按部门比较它们的累计成绩。我们可以清楚地看到，不出意料，物理系在学校项目中拥有最高的 GPA
    获得者。对于这样一个小型数据集，这些信息足够直观。但在处理更大规模的数据时，创建总结性图表将特别有助于理解全貌：
- en: '![](img/e646a0eb-8a11-4cfe-bde6-4b14cf4c64cd.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e646a0eb-8a11-4cfe-bde6-4b14cf4c64cd.png)'
- en: Be aware that there is a great deal of additional functionality in the `xlsxwriter`
    module that we will not use in our script. This is an extremely powerful module,
    and we recommend it for any operation that requires writing Excel spreadsheets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`xlsxwriter` 模块中有大量额外的功能，我们在脚本中不会使用到。这个模块非常强大，我们推荐在任何需要写入 Excel 电子表格的操作中使用它。
- en: The UserAssist framework
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserAssist 框架
- en: 'Our `UserAssist` framework is made up of three scripts, `userassist_parser.py`,
    `csv_writer.py`, and `xlsx_writer.py`. The `userassist_parser.py` script handles
    the bulk of the processing logic and then passes the results to the CSV or XLSX
    writer. The directory structure of our framework is shown as follows. Our writers
    are contained within a directory named `Writers`. Remember that for a directory
    to be searchable by Python, it needs to include the `__init__.py` file. This file
    may be empty, contain functions and classes, or contain code to be executed upon
    import:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UserAssist`框架由三个脚本组成，分别是`userassist_parser.py`、`csv_writer.py`和`xlsx_writer.py`。`userassist_parser.py`脚本处理大部分的处理逻辑，然后将结果传递给CSV或XLSX写入器。我们框架的目录结构如下所示。我们的写入器包含在一个名为`Writers`的目录中。请记住，为了让Python能够搜索到一个目录，它需要包含`__init__.py`文件。该文件可以为空，包含函数和类，或者包含在导入时执行的代码：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Developing our UserAssist logic processor – userassist_parser.py
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的UserAssist逻辑处理器 – userassist_parser.py
- en: 'The `userassist_parser.py` script is responsible for handling user input, creating
    a log file, and parsing `UserAssist` data from the `NTUSER.DAT` file. On lines
    2 through 9, we import familiar and new modules to facilitate our tasks. The `yarp`
    and `struct` modules will grant us access to and then extract objects from the
    `UserAssist` binary data, respectively. We import our `xlsx_writer` and `csv_writer`
    modules, which are in the `Writers` directory. Other used modules have been introduced
    in previous chapters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`userassist_parser.py`脚本负责处理用户输入、创建日志文件，并解析来自`NTUSER.DAT`文件的`UserAssist`数据。在第2到第9行，我们导入了熟悉的和新的模块来促进我们的任务。`yarp`和`struct`模块将分别允许我们访问并提取来自`UserAssist`二进制数据的对象。我们导入了位于`Writers`目录中的`xlsx_writer`和`csv_writer`模块。其他使用的模块在之前的章节中已经介绍过：'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `KEYS` variable defined as an empty list on line 45 will store parsed `UserAssist`
    values. The `main()` function, defined on line 48, will handle all coordinating
    logic. It calls functions to parse the `UserAssist` key and then to write the
    results. The `create_dictionary()` function uses the `Registry` module to find
    and store `UserAssist` value names and raw data in a dictionary for each GUID.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第45行定义的`KEYS`变量作为一个空列表，将存储解析后的`UserAssist`值。第48行定义的`main()`函数将处理所有协调逻辑。它调用函数解析`UserAssist`键，并随后写入结果。`create_dictionary()`函数使用`Registry`模块查找并将`UserAssist`值名称和原始数据存储在每个GUID的字典中。
- en: 'On line 134, we define the `parse_values()` function, which processes the binary
    data of each `UserAssist` value using `struct`. During this method, we determine
    if we are working with Windows XP- or Windows 7-based `UserAssist` data based
    on length. The `get_name()` function is a small function that separates the executable
    name from the full path:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第134行，我们定义了`parse_values()`函数，该函数使用`struct`处理每个`UserAssist`值的二进制数据。在此方法中，我们根据数据的长度来确定我们正在处理的是Windows
    XP还是Windows 7的`UserAssist`数据。`get_name()`函数是一个小函数，用于从完整路径中分离出可执行文件的名称：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On lines 202 through 212, we create our argument parser object, which takes
    two positional arguments and one optional argument. Our `REGISTRY` input is the
    `NTUSER.DAT` file of interest. The `OUTPUT` argument is the path and filename
    of the desired output file. The optional `-l` switch is the path of the log file.
    If this is not supplied, the log file is created in the current working directory:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第202到212行，我们创建了一个参数解析对象，它接受两个位置参数和一个可选参数。我们的`REGISTRY`输入是感兴趣的`NTUSER.DAT`文件。`OUTPUT`参数是所需输出文件的路径和文件名。可选的`-l`开关是日志文件的路径。如果没有提供此路径，日志文件将创建在当前工作目录中：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the user supplies a log path, we check on line 215 if the path exists. If
    it does not exist, we use the `os.makedirs()` function to create the log directory.
    In either case, we instantiate the `log_path` variable with the supplied directory
    and the log file. On line 220, we create our log and write startup details in
    the same manner as previous chapters, before calling `main()` on line 227:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供了日志路径，我们会在第215行检查该路径是否存在。如果路径不存在，我们使用`os.makedirs()`函数创建日志目录。无论哪种情况，我们都会使用提供的目录和日志文件实例化`log_path`变量。在第220行，我们创建日志并像之前的章节一样写入启动细节，然后在第227行调用`main()`：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following flow chart depicts the interconnected functions within our `UserAssist` framework.
    Here, we can see how the `main()` function calls and receives data from the `create_dictionary()`
    and `parse_values()` functions. The `parse_values()` function separately calls
    the `get_name()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下流程图描述了我们`UserAssist`框架内相互关联的函数。在此图中，我们可以看到`main()`函数如何调用并接收来自`create_dictionary()`和`parse_values()`函数的数据。`parse_values()`函数分别调用了`get_name()`函数：
- en: '![](img/fc43a4f9-08e2-4833-8939-e1202ce69efd.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc43a4f9-08e2-4833-8939-e1202ce69efd.png)'
- en: Evaluating the main() function
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估`main()`函数
- en: 'The `main()` function sends the registry file to be processed before calling
    the appropriate methods to write the `out_file`. On line 61, we call the `create_dictionary()`
    function to create a list of dictionaries containing `UserAssist` data mapped
    to the executable''s name:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数在调用适当的方法以写入`out_file`之前，先将注册表文件发送进行处理。在第61行，我们调用`create_dictionary()`函数，创建一个包含`UserAssist`数据并映射到可执行文件名的字典列表：'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, this dictionary is fed into the `parse_values()` method that appends
    parsed data to the `KEYS` list we created on line 45\. This function returns an
    integer representing the type of `UserAssist` data parsed. This function returns
    a value of `0` for Windows XP `UserAssist` values and `1` for Windows 7\. We log
    this information for troubleshooting purposes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这个字典被传递给`parse_values()`方法，该方法将解析后的数据附加到我们在第45行创建的`KEYS`列表中。此函数返回一个整数，表示解析的`UserAssist`数据类型。该函数对于Windows
    XP的`UserAssist`值返回`0`，对于Windows 7的返回`1`。我们记录此信息以便进行故障排除：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once data is processed, it can be sent to our writers. We use the `endswith()`
    method to identify what the extension is of the user-supplied output. If the output
    ends with `.xlsx` or `.csv`, we send the data to our `excel_writer()` or `csv_writer()`
    functions, respectively, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据处理完成，它可以被发送到我们的写入程序。我们使用`endswith()`方法来识别用户提供的输出文件的扩展名。如果输出以`.xlsx`或`.csv`结尾，我们分别将数据发送到`excel_writer()`或`csv_writer()`函数，具体如下：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the user does not include an extension in their output, we write a warning
    to the log and write the data to a CSV file in the current working directory.
    We chose a CSV output because it represents the simplest and most portable option
    of our supported output formats. In addition, if the user wanted to examine their
    data in a spreadsheet application, they could easily import and convert the CSV
    document to an XLSX format:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有在输出文件中包括扩展名，我们会向日志写入警告，并将数据写入当前工作目录中的CSV文件。我们选择CSV输出，因为它代表了我们支持的输出格式中最简单且最具可移植性的选项。此外，如果用户希望在电子表格应用程序中检查数据，他们可以轻松导入并将CSV文档转换为XLSX格式：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Both writers accept the same arguments: `KEYS` and `out_file`. The `KEYS` list,
    which was defined on line 45, is a container of `UserAssist` dictionaries. We
    packaged our data as a list of dictionaries in order to use the dictionary keys
    to dictate which headers were present. The `out_file` is the path and name of
    the desired output.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 两个写入程序接受相同的参数：`KEYS`和`out_file`。`KEYS`列表（在第45行定义）是一个包含`UserAssist`字典的容器。我们将数据打包成字典列表，以便使用字典键来决定哪些头部是存在的。`out_file`是期望输出的路径和名称。
- en: Defining the create_dictionary() function
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`create_dictionary()`函数
- en: 'The `create_dictionary()` function prepares the `UserAssist` data for processing.
    This function pulls all values within each `UserAssist` GUID key. It creates a
    dictionary where the keys are the ROT-13 decoded executable name, and the values
    are the respective binary data. This binary data is extracted now, so we can process
    it in a later function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_dictionary()`函数为处理准备`UserAssist`数据。此函数提取每个`UserAssist` GUID键中的所有值。它创建一个字典，其中键是经过ROT-13解码的可执行文件名，值是相应的二进制数据。现在提取这些二进制数据，以便稍后在其他函数中处理：'
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On line 97, we try to open the registry file provided by the user. If there
    is an error accessing the input file, we catch the error, log it, and exit gracefully
    with an error code of `2`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第97行，我们尝试打开用户提供的注册表文件。如果访问输入文件时发生错误，我们会捕获该错误，记录日志，并以错误代码`2`优雅地退出：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we can open the registry file, we then try to navigate to the `UserAssist`
    key. We use a conditional to catch the scenario where the `UserAssist` key is
    not found in the supplied registry file. Note that, for this error, we use the
    integer, `3`, to differentiate from our previous exit scenario:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够打开注册表文件，我们接着尝试导航到`UserAssist`键。我们使用条件语句来捕捉`UserAssist`键未在提供的注册表文件中找到的情形。注意，对于此错误，我们使用整数`3`来区分与先前的退出情形：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On line 113, we create a list named `apps_list`, which will store `UserAssist`
    dictionaries. If we were able to find the `UserAssist` key, we loop through each
    `ua_subkey`, a GUID, and check their count subkey. This is an important step;
    as Windows has evolved, more GUIDs have been added to the `UserAssist` key. Rather
    than hardcoding these values, which could miss new GUIDs added in future versions
    of Windows, we opted for a more dynamic process that will discover and handle
    new GUIDs across many versions of Windows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 113 行，我们创建了一个名为 `apps_list` 的列表，用于存储 `UserAssist` 字典。如果我们能够找到 `UserAssist`
    键，我们就会遍历每个 `ua_subkey`，一个 GUID，并检查它们的计数子键。这是一个重要的步骤；随着 Windows 的发展，`UserAssist`
    键中添加了更多的 GUID。为了避免硬编码这些值，可能会遗漏未来 Windows 版本中新添加的 GUID，我们选择了一个更动态的过程，该过程将发现并处理跨多个版本的
    Windows 中的新 GUID：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This process involves checking each GUIDs that has a subkey named `Count`,
    which stores the actual `UserAssist` application values. On line 118, we determine
    if the GUID has a subkey named `Count` with one or more values. This ensures that
    we find all the `UserAssist` values present on the system:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程涉及检查每个具有名为`Count`的子键的 GUID，该子键存储实际的 `UserAssist` 应用程序值。在第 118 行，我们确定该 GUID
    是否具有名为 `Count` 的子键，并且该子键具有一个或多个值。这确保我们找到了系统上所有的 `UserAssist` 值：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We create an apps dictionary on line 120 and begin to loop through each value
    under the `Count` subkey. For each value, we add the ROT-13-decoded name as the
    key, and associate it with its `raw_data` as the value. Once all the values in
    the GUID have been added to the dictionary, it is appended to `apps_list` and
    the cycle repeats. Once all of the GUIDs have been processed, our list is returned
    to the `main()` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 120 行创建了一个应用程序字典，并开始循环遍历 `Count` 子键下的每个值。对于每个值，我们将解码后的 ROT-13 名称作为键，并将其
    `raw_data` 作为值进行关联。一旦 GUID 中的所有值都添加到字典中，它就会被附加到 `apps_list` 中，循环再次开始。一旦所有 GUID
    都被处理完，我们的列表会返回到 `main()` 函数：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Extracting data with the parse_values() function
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `parse_values()` 函数提取数据
- en: 'The `parse_values()` function takes the list of GUID dictionaries as its input
    and uses struct to parse the binary data. As we''ve discussed, there are two types
    of `UserAssist` keys we will support: Windows XP and Windows 7\. The following
    two tables break down the relevant data structures we will parse. Windows XP-based
    keys are 16 bytes in length and contain a Session ID, Count, and FILETIME timestamp:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_values()` 函数将 GUID 字典列表作为输入，并使用 `struct` 解析二进制数据。正如我们所讨论的，我们将支持两种类型的
    `UserAssist` 键：Windows XP 和 Windows 7。以下两个表格分解了我们将解析的相关数据结构。基于 Windows XP 的键是
    16 字节长，包含会话 ID、计数和 FILETIME 时间戳：'
- en: '| **Byte offset** | **Value** | **Object** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **字节偏移量** | **值** | **对象** |'
- en: '| 0-3 | Session ID | Integer |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0-3 | 会话 ID | 整数 |'
- en: '| 4-7 | Count | Integer |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 4-7 | 计数 | 整数 |'
- en: '| 8-15 | FILETIME | Integer |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 8-15 | FILETIME | 整数 |'
- en: 'Windows 7 artifacts are 72 bytes in length containing a session ID, count,
    focus count/time, and FILETIME timestamp:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Windows 7 的数据是 72 字节长，包含会话 ID、计数、专注计数/时间和 FILETIME 时间戳：
- en: '| **Byte offset** | **Value** | **Object** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **字节偏移量** | **值** | **对象** |'
- en: '| 0-3 | Session ID | Integer |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 0-3 | 会话 ID | 整数 |'
- en: '| 4-7 | Count | Integer |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 4-7 | 计数 | 整数 |'
- en: '| 8-11 | Focus count | Integer |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 8-11 | 专注计数 | 整数 |'
- en: '| 12-15 | Focus time | Integer |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 12-15 | 专注时间 | 整数 |'
- en: '| 16-59 | ??? | N/A |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 16-59 | ??? | 不适用 |'
- en: '| 60-67 | FILETIME | Integer |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 60-67 | FILETIME | 整数 |'
- en: '| 68-71 | ??? | N/A |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 68-71 | ??? | 不适用 |'
- en: 'On lines 143 through 146, we set up our function by instantiating the `ua_type`
    variable and logging execution status. This `ua_type` variable will be used to
    document which type of `UserAssist` value we''re working with. On lines 148 and
    149, we loop through each value in each dictionary to identify its type and parse
    it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 143 行到第 146 行，我们通过实例化 `ua_type` 变量并记录执行状态来设置我们的函数。这个 `ua_type` 变量将用于记录我们正在处理的
    `UserAssist` 值的类型。在第 148 行和第 149 行，我们遍历每个字典中的每个值，以识别其类型并进行解析：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On lines 151 and 159, we use the `len()` function to identify the type of `UserAssist`
    key. For Windows XP-based data, we need to extract two 4-byte integers followed
    by an 8-byte integer. We also want to interpret this data in little endian using
    standard sizes. We accomplish this on line 152 with `<2iq` as the struct format
    string. The second argument we pass to the unpack method is the raw binary data
    for the particular key from the GUID dictionary:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 151 行和第 159 行，我们使用 `len()` 函数来识别 `UserAssist` 键的类型。对于基于 Windows XP 的数据，我们需要提取两个
    4 字节的整数，后跟一个 8 字节的整数。我们还希望使用标准大小以小端字节顺序解释这些数据。在第 152 行，我们通过 `<2iq` 作为 `struct`
    格式字符串来实现这一点。传递给 `unpack` 方法的第二个参数是来自 GUID 字典的特定键的原始二进制数据：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The Windows 7-based data is slightly more complicated. There are bytes in the
    middle and end of the binary data that we are not interested in parsing and yet,
    because of the nature of struct, we must account for them in our format. The format
    string we use for this task is `<4i44xq4x`, which accounts for the four 4-byte
    integers, the 44 bytes of intervening space, the 8-byte integer, and the remaining
    4 bytes we will ignore:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Windows 7 的数据稍微复杂一些。二进制数据的中间和末尾部分包含我们不感兴趣的字节，但由于结构体的性质，我们必须在格式中考虑到它们。我们为此任务使用的格式字符串是
    `<4i44xq4x`，它包含了四个 4 字节整数、44 字节的中间空隙、一个 8 字节整数，以及我们将忽略的剩余 4 字节：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we parse `UserAssist` records, we append them to the `KEYS` list for storage.
    When we append the parsed values, we wrap them in curly braces to create our inner
    dictionary object. We also call the `get_name()` function on the `UserAssist`
    value name to separate the executable from its path. Note that regardless of the
    type of `UserAssist` key, we still create the same keys in our dictionary. This
    will ensure that all our dictionaries have the same structure and will help streamline
    our CSV and XLSX output functions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析 `UserAssist` 记录时，我们将它们附加到 `KEYS` 列表中进行存储。当我们附加解析值时，我们用大括号将它们包裹起来，创建我们内部的字典对象。我们还对
    `UserAssist` 值名调用 `get_name()` 函数，以分离可执行文件和其路径。请注意，无论 `UserAssist` 键的类型如何，我们都会在字典中创建相同的键。这将确保所有字典具有相同的结构，并有助于简化我们的
    CSV 和 XLSX 输出函数。
- en: 'If a `UserAssist` value is not 16 or 72 bytes (which can happen), then that
    value is skipped and the user is notified of the name and size that was passed
    over. From our experience, these values were not forensically relevant, and so
    we decided to pass on them. On line 173, the `UserAssist` type is returned to
    the `main()` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `UserAssist` 值不是 16 或 72 字节（这种情况是可能发生的），那么该值将被跳过，并且用户会被通知跳过的名称和大小。根据我们的经验，这些值与法医取证无关，因此我们决定跳过它们。在第
    173 行，`UserAssist` 类型被返回到 `main()` 函数：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Processing strings with the get_name() function
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 get_name() 函数处理字符串
- en: 'The `get_name()` function uses string operations to separate the executable
    from the path name. From testing, we found that a colon, backslash, or both characters
    were present in the path. Because this pattern exists, we can try to split this
    information using these characters to extract the name:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_name()` 函数使用字符串操作将可执行文件与路径名分离。从测试中我们发现路径中包含冒号、反斜杠或两者兼有。由于这种模式的存在，我们可以尝试使用这些字符来分割路径信息，从中提取出文件名：'
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On line 185, we check to see if both colon and backslashes are in the `full_name`
    variable. If this is true, we use the `rindex()` function to get the index of
    the rightmost occurrence of the substring for both elements. On line 187, we check
    to see if the right-most index for the colon is found later in the string than
    the backslash. The element with the greatest index is used as the delimiter for
    the `split()` function. To get the last substring in the list (our executable
    name), we use the `-1` index:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 185 行，我们检查 `full_name` 变量中是否同时包含冒号和反斜杠。如果为真，我们使用 `rindex()` 函数获取两个元素的最右侧子字符串的索引。在第
    187 行，我们检查冒号的最右侧索引是否出现在反斜杠的后面。使用最大索引的元素作为 `split()` 函数的分隔符。为了获得列表中的最后一个子字符串（即我们的可执行文件名），我们使用
    `-1` 索引：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'On lines 196 and 198, we handle the alternative scenarios and split on either
    the colon or backslash, and return the last element in the list of substrings:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 196 行和第 198 行，我们处理了替代场景，并在冒号或反斜杠处进行分割，然后返回子字符串列表中的最后一个元素：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This completes the logic in our `userassist_parser.py` script. Now, let's turn
    our attention to our two writer functions responsible for writing our parsed data
    in a useful format.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们在 `userassist_parser.py` 脚本中的逻辑。现在，让我们将注意力转向负责以有用格式写入解析数据的两个写入函数。
- en: Writing Excel spreadsheets – xlsx_writer.py
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入 Excel 电子表格 – xlsx_writer.py
- en: 'The `xlsx_writer.py` script contains the logic for creating an excel document
    containing our processed `UserAssist` values. In addition to this, this script
    also creates an additional worksheet that contains summarizing charts of our data.
    The `xlsxwriter` is imported on line 1 and is the third-party module we use to
    create the Excel document. The `itemgetter` function, imported on line 3, will
    be used and explained in the sorting functions later in this section. We have
    seen the `datetime` and `logging` modules from previous chapters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlsx_writer.py`脚本包含了创建包含我们处理过的`UserAssist`值的Excel文档的逻辑。除此之外，这个脚本还创建了一个包含我们数据摘要图表的额外工作表。`xlsxwriter`在第1行导入，是我们用来创建Excel文档的第三方模块。第3行导入的`itemgetter`函数将在本节后面的排序函数中使用并解释。我们已经在前面的章节中见过`datetime`和`logging`模块：'
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There are six functions in the `xlsx_writer.py` script. The coordinating logic
    is handled by the `excel_writer()` function defined on line 36\. This function
    creates our Excel workbook object and then hands it off to the `dashboard_writer()`
    and `userassist_writer()` functions to create the dashboard and `UserAssist` worksheets,
    respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlsx_writer.py`脚本中有六个函数。协调逻辑由第36行定义的`excel_writer()`函数处理。该函数创建我们的Excel工作簿对象，然后将其交给`dashboard_writer()`和`userassist_writer()`函数，分别用于创建仪表板和`UserAssist`工作表。'
- en: The remaining three functions, `file_time()`, `sort_by_count()`, and `sort_by_date()`,
    are helper functions used by the dashboard and `UserAssist` writers. The `file_time()`
    function is responsible for converting FILETIME objects that we parsed from the
    raw `UserAssist` data into `datetime` objects. The sorting functions are used
    to sort the data by either count or date. We use these sorting functions to answer
    some basic questions about our data. What are the most-used applications? What
    are the least-used applications? What were the last 10 applications used on the
    machine (according to `UserAssist`)?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个函数，`file_time()`、`sort_by_count()`和`sort_by_date()`，是仪表板和`UserAssist`写入器使用的辅助函数。`file_time()`函数负责将我们从原始`UserAssist`数据中解析出的FILETIME对象转换为`datetime`对象。排序函数用于根据计数或日期对数据进行排序。我们使用这些排序函数来回答一些关于数据的基本问题。最常用的应用程序是什么？最不常用的应用程序是什么？在计算机上最后使用的10个应用程序是什么（根据`UserAssist`数据）？
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Controlling output with the excel_writer() function
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`excel_writer()`函数控制输出
- en: 'The `excel_writer()` function is the glue for this script. The headers list
    on line 47 is a list containing our desired column names. These column names also
    conveniently correlate to the keys in our `UserAssist` dictionaries we will be
    writing. On line 49, we create the `Workbook` object we will write to. On the
    next line, we create our `title_format`, which controls the color, font, size,
    and other style options for our spreadsheet header. We have the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`excel_writer()`函数是这个脚本的核心。在第47行的headers列表中，包含了我们所需的列名。这些列名也方便地与我们将要写入的`UserAssist`字典中的键相对应。在第49行，我们创建了将要写入的`Workbook`对象。在下一行，我们创建了`title_format`，它控制了电子表头的颜色、字体、大小和其他样式选项。我们有以下代码：'
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `title_format` is similar to the `date_format` we created when we previously
    discussed the `xlsxwriter` module. This format is a dictionary containing keywords
    and values. Specifically, we'll use this format when creating a title and subtitle
    rows so it sticks out from other data in our spreadsheet.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`title_format`与我们之前讨论的`xlsxwriter`模块时创建的`date_format`相似。这个格式是一个包含关键词和值的字典。具体来说，我们将在创建标题和副标题行时使用这个格式，以使其从电子表格中的其他数据中突出显示。'
- en: 'On lines 54 through 59, we convert our dictionaries back into lists. This might
    seem to you as though we made the wrong data type choice to store our data, and
    perhaps you have a point. However, storing our data in lists will immensely simplify
    writing out XSLX output. Once we see how the CSV writer handles the data, it will
    become clearer why we originally use dictionaries. In addition, the use of dictionaries
    allows us to easily understand the stored data without need for review of the
    code or documentation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在第54到59行，我们将字典转换回列表。看起来这可能会让你觉得我们在存储数据时选择了错误的数据类型，也许你有一定的理由。然而，将数据存储在列表中会极大简化生成XSLX输出的过程。一旦我们看到CSV写入器如何处理数据，为什么最初使用字典会变得更加清晰。此外，使用字典可以让我们轻松理解存储的数据，而无需查看代码或文档：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We use list comprehension to append data from our dictionary in the proper order.
    Let's break it down. On line 59, we iterate through each `UserAssist` dictionary.
    As we know, dictionaries do not store data by index and instead store by key mapping.
    However, we want our data to be written in a certain order as dictated by our
    headers list. The `x` in the headers loop allows us to iterate over that list.
    For each `x`, we use the `get()` method to return the value for `x` if found in
    the dictionary or an empty string.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导将字典中的数据按正确的顺序追加到数据中。让我们逐步分解。在第 59 行，我们迭代每个`UserAssist`字典。正如我们所知，字典不按索引存储数据，而是按键映射存储数据。但是，我们希望按照我们的标题列表指定的顺序写入数据。标题循环中的`x`允许我们迭代该列表。对于每个`x`，我们使用`get()`方法返回字典中`x`对应的值，如果在字典中找到的话，否则返回空字符串。
- en: 'On line 61 and 62, we call the two worksheet writers for the dashboard and
    `UserAssist` data. After the last of those functions exit, we `close()` the workbook
    object. It is incredibly important to close the workbook. Failing to do so will
    throw an exception that might prevent us from transferring our Excel document
    from memory to disk. Take a look at the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 61 和 62 行，我们为仪表板和`UserAssist`数据调用两个工作表编写器。在这些函数的最后退出后，我们关闭工作簿对象的`close()`方法。关闭工作簿非常重要。如果不这样做，将会抛出异常，可能会阻止我们将
    Excel 文档从内存传输到磁盘。请看下面的代码：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Summarizing data with the dashboard_writer() function
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`dashboard_writer()`函数总结数据
- en: The aim of the `dashboard_writer()` function is to provide the analyst or reviewer
    with some graphics that summarize our `UserAssist` data. We chose to present the
    top 10, bottom 10, and most recent 10 executables to the user. This function is
    our longest and requires the most logic.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`dashboard_writer()`函数的目的是向分析师或审核人员提供一些汇总我们`UserAssist`数据的图形。我们选择向用户展示前 10、后
    10 和最近的 10 个可执行文件。这个函数是我们最长的函数，需要最多的逻辑。'
- en: 'On line 81, we add our dashboard worksheet object to the workbook. Next, we
    merge the first row from the `A` to `Q` columns and write our company name, `XYZ
    Corp`, using our title format created in the `excelWriter()` function. Similarly,
    we create a subtitle row to identify this worksheet as our dashboard on line 83,
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 81 行，我们将我们的仪表板工作表对象添加到工作簿中。接下来，我们将从`A`到`Q`列合并第一行，并使用我们在`excelWriter()`函数中创建的标题格式写入我们的公司名称`XYZ
    Corp`。类似地，在第 83 行，我们创建一个副标题行，以标识这个工作表作为我们的仪表板。
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'On line 87, we create and add a `date_format` to the workbook in order to properly
    format our dates. On lines 92 and 93, we make function calls to the two sorting
    functions. We use list slicing to carve the sorted data to create our sublists:
    `topten`, `leastten`, and `lastten`. For the `topten` executables used by count,
    we grab the last 10 elements in the sorted list. For the `leastten`, we simply
    perform the inverse. For the `lastten`, we grab the first 10 results in the sorted
    dates list, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 87 行，我们创建并向工作簿添加`date_format`以正确格式化我们的日期。在第 92 和 93 行，我们调用两个排序函数。我们使用列表切片来切割排序后的数据，创建我们的子列表：`topten`，`leastten`
    和 `lastten`。对于按计数使用的`topten`可执行文件，我们从排序列表中获取最后 10 个元素。对于`leastten`，我们只需执行相反操作。对于`lastten`，我们获取排序日期列表中的前
    10 个结果，如下所示：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On line 103, we iterate over the elements in the `lastten` list. We must convert
    each timestamp into a `datetime` object. The `datetime` object is stored in the
    first index of the `UserAssist` list we created and is converted by the `file_time()`
    function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 103 行，我们迭代处理`lastten`列表中的元素。我们必须将每个时间戳转换为`datetime`对象。`datetime`对象存储在我们创建的`UserAssist`列表的第一个索引中，并通过`file_time()`函数进行转换：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On lines 108 through 116, we create our three tables for our top, bottom, and
    most recent data points. Note how these tables start on row 100\. We chose to
    place them far away from the top of the spreadsheet so the user sees the tables
    we will add instead of the raw data. As we saw when describing tables in the `xlsxwriter`
    section, the second argument of the `add_table()` function is a dictionary containing
    keywords for header names and formats. There are other keywords that could be
    provided for additional functionality. For example, we use the `format` keyword
    to ensure that our `datetime` objects are displayed as desired using our `date_format`
    variable. We have the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第108行到116行之间，我们为顶部、底部和最新的数据点创建了三个表格。注意这些表格从第100行开始。我们选择将它们放置得离电子表格顶部较远，这样用户会先看到我们将要添加的表格，而不是原始数据。正如我们在`xlsxwriter`部分描述表格时所看到的，`add_table()`函数的第二个参数是一个字典，包含标题名称和格式的关键字。还可以提供其他关键字来实现更多功能。例如，我们使用`format`关键字确保我们的`datetime`对象按照我们指定的`date_format`变量显示。我们有以下代码：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On lines 118 to 153, we create our charts for the three tables. After instantiating
    `top_chart` as a pie chart, we set the title and the scale in the *X* and *Y*
    direction. During testing, we realized that the figure would be too small to adequately
    display all of the information, and so we used a larger scale:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在第118行到153行之间，我们为三个表格创建了图表。在将`top_chart`实例化为饼图后，我们设置了标题以及*X*轴和*Y*轴的刻度。在测试过程中，我们意识到图表的尺寸太小，无法充分展示所有信息，因此我们使用了更大的比例：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On line 127, we add the series for our pie chart; identifying the categories
    and values is straightforward. All we need to do is define the rows and columns
    we want to plot. The `data_labels` key is an additional option that can be used
    to specify the value''s format of the plotted data. In this case, we chose the
    `''percentage''` option as seen on line 130, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第127行，我们为饼图添加了系列；识别类别和值是非常直接的。我们需要做的只是定义我们想要绘制的行和列。`data_labels`键是一个附加选项，可以用来指定绘制数据的值格式。在此情况下，我们选择了`'percentage'`选项，如第130行所示，代码如下：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this setup, our pie chart will be split based on usage count, the legend
    will contain the name of the executable, and the percentage will show the relative
    execution in comparison to the other nine executables. After creating the chart,
    we call `insert_chart()` to add it to the dashboard worksheet. The `least_chart`
    is created in the same manner, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，我们的饼图将根据使用次数进行分割，图例将包含可执行文件的名称，百分比将显示与其他九个可执行文件相比的相对执行情况。创建图表后，我们调用`insert_chart()`将其添加到仪表盘工作表中。`least_chart`的创建方式与此相同，如下所示：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we create and add the `last_chart` to our spreadsheet. In an effort
    to save trees, this is handled in the same fashion as we previously discussed.
    This time, however, our chart is a column chart and we''ve modified the scale
    to be appropriate for the type of chart:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建并将`last_chart`添加到电子表格中。为了节省纸张，这一过程与我们之前讨论的方式相同。不过，这次我们的图表是柱状图，并且我们调整了比例，以便适合该类型的图表：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Writing artifacts in the userassist_writer() function
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在userassist_writer()函数中编写的内容
- en: 'The `userassist_writer()` function is similar to the previous dashboard function.
    The difference is that this function creates a single table containing our raw
    data without any of the additional accouterments. On lines 167 through 169, we
    create the `UserAssist` worksheet object and add our title and subtitle to the
    spreadsheet. On line 173, we once again create a `date_format` to properly display
    dates, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`userassist_writer()`函数与之前的仪表盘函数类似。不同之处在于，这个函数创建了一个包含原始数据的单一表格，没有任何附加的装饰。在第167行到169行之间，我们创建了`UserAssist`工作表对象，并将标题和副标题添加到电子表格中。在第173行，我们再次创建了一个`date_format`，以便正确显示日期，如下所示：'
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'On line 178, we loop through the outer list and convert the FILETIME object
    into a `datetime` object using our prebuilt function. We also add an integer to
    the beginning of the list so that examiners can quickly determine how many `UserAssist`
    records are there by looking at the index:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在第178行，我们遍历外部列表，并使用我们预先构建的函数将FILETIME对象转换为`datetime`对象。我们还在列表的开头添加了一个整数，以便检查人员通过查看索引可以快速确定有多少个`UserAssist`记录：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'On line 188, we begin creating our `UserAssist` table. We use the length variable,
    created in line 184, to determine the appropriate number distance to the bottom-right
    corner of the table. Note that the length is the length of the list plus three.
    We added three to this length because we need to account for our title and subtitle
    rows, taking up the first two columns, and the difference between how Python and
    Excel count. We have the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在第188行，我们开始创建 `UserAssist` 表。我们使用第184行创建的长度变量来确定距离表格右下角的适当位置。注意，长度是列表的长度加三。我们将三加到该长度上，是因为我们需要考虑标题和副标题行，占用了前两列，以及
    Python 和 Excel 计数方式的差异。我们有如下代码：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Defining the file_time() function
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 `file_time()` 函数
- en: This is a very small helper function. The FILETIME object we parsed with the
    struct library is an 8-byte integer representing the count of 100-nanosecond units
    since 01/01/1601\. This date is used by most Microsoft operating systems and applications
    as a common reference point in time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的帮助函数。我们使用 struct 库解析的 FILETIME 对象是一个 8 字节的整数，表示自 1601 年 1 月 1 日以来 100
    纳秒单位的计数。这个日期是大多数微软操作系统和应用程序作为公共时间参考点所使用的。
- en: 'Therefore, to get the date it represents, we need to add the FILETIME value
    to the `datetime` object representing 01/01/1601 with the `timedelta()` function.
    The `timedelta` function calculates the number of days and hours an integer represents.
    We can then add the output from the `timedelta()` function directly to the `datetime`
    object to arrive at the correct date. In order to arrive at the correct magnitude,
    we need to divide the FILETIME value by `10`, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得它所表示的日期，我们需要将 FILETIME 值加到代表 1601 年 1 月 1 日的 `datetime` 对象上，并使用 `timedelta()`
    函数。`timedelta` 函数计算一个整数所代表的天数和小时数。然后，我们可以将 `timedelta()` 函数的输出直接加到 `datetime`
    对象中，得到正确的日期。为了得到正确的量级，我们需要将 FILETIME 值除以 `10`，如下所示：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Processing integers with the sort_by_count() function
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `sort_by_count()` 函数处理整数
- en: The `sort_by_count()` function sorts the inner lists based on their execution
    count value. This is a somewhat complicated one-liner, so let's take it apart
    step by step. To begin, let's focus on the `sorted(data, key=itemgetter(3))` step
    first. Python includes a built-in `sorted()` method to sort data by a key, normally
    an integer. We can supply the `sorted()` function with a key to tell it what to
    sort by and return a new sorted list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_by_count()` 函数根据执行计数值对内部列表进行排序。这是一个相对复杂的单行代码，让我们一步一步地拆解。首先，先关注 `sorted(data,
    key=itemgetter(3))` 这一部分。Python 提供了内置的 `sorted()` 方法，用于根据键（通常是整数）对数据进行排序。我们可以为
    `sorted()` 函数提供一个键，告诉它按照什么排序，并返回一个新的排序后的列表。'
- en: 'As with any new piece of code, let''s look at a simple example in the interactive
    prompt:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何新的代码一样，让我们在交互式提示符下看一个简单的例子：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the preceding example, we''ve created an outer list that contains inner
    lists with two elements: a character and a number. Next, we sort this list and
    use the number in the first index of the inner lists as the key. By default, `sorted()`
    will sort in ascending order. To sort in descending order, you need to supply
    the `reverse=True` argument. If we wanted to sort by letter, we would provide
    the `itemgetter()` with the value of `0` to specify to sort on elements found
    at that location.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个外部列表，包含了包含两个元素的内部列表：一个字符和一个数字。接下来，我们对这个列表进行排序，并使用内部列表中第一个索引的数字作为排序的键。默认情况下，`sorted()`
    会按升序排序。要按降序排序，你需要提供 `reverse=True` 参数。如果我们想按字母排序，则可以向 `itemgetter()` 提供值 `0`，以指定按该位置的元素排序。
- en: Now, all that is left is to understand what `x[0:5:3]` means. Why are we even
    doing this in the first place? We are using list slicing to only grab the first
    and third element, that is, the name and count of the executable, to use for our
    table.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是理解 `x[0:5:3]` 的含义了。我们为什么要这么做？我们使用列表切片仅抓取第一个和第三个元素，即可执行文件的名称和计数，供我们用于表格。
- en: 'Remember that slicing notation supports three optional components: *List[x:y:z], *were,
    *x* = start index, *y* = end index, *z* = step.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，切片表示法支持三个可选的组件：*List[x:y:z]*，其中，*x* = 起始索引，*y* = 结束索引，*z* = 步长。
- en: In this example, we start at index 0 and stop at index 5, taking steps of 3\.
    If we do this, we will only get the elements at the zero and third position of
    the list before reaching the end.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从索引 0 开始，到索引 5 结束，步长为 3。如果这样做，我们将只获取列表中第零和第三个位置的元素，直到到达末尾。
- en: Now, the statement `x[0:5:3]` for `x` in `sorted(data, key=itemgetter(3))` will
    loop through the newly sorted list and only retain the zero and third-positioned
    elements in each list. We then wrap this entire statement in a pair of square
    brackets in order to preserve our outer and inner list structure that `xlsxwriter`
    prefers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x[0:5:3]`语句会对`sorted(data, key=itemgetter(3))`中的`x`进行遍历，并仅保留每个列表中的零和第三位置元素。我们然后将整个语句用一对方括号括起来，以便保留`xlsxwriter`所偏好的外部和内部列表结构。
- en: 'The list object also has a `sort()` method that is syntactically similar to
    the `sorted()` function. However, the `sort()` function is more memory-friendly
    as it does not create a new list, but rather sorts the current list in place.
    Because memory consumption is not a big concern for a dataset, that might contain
    a few hundred entries at most and, as we did not want to modify the original list,
    we chose to use the `sorted()` function. We have the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象也有一个`sort()`方法，它在语法上类似于`sorted()`函数。然而，`sort()`函数更节省内存，因为它不会创建新列表，而是就地排序当前列表。由于数据集的内存消耗不是大问题，最多可能包含几百条记录，并且由于我们不想修改原始列表，所以选择使用`sorted()`函数。我们有以下代码：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Processing datetime objects with the sort_by_date() function
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sort_by_date()函数处理datetime对象
- en: The `sort_by_date()` function is very similar to the `sort_by_count()` function
    except that it uses different indices. Since a `datetime` object is really just
    a number, we can easily sort by that as well. Supplying `reverse=True` allows
    us to sort in descending order.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_by_date()`函数与`sort_by_count()`函数非常相似，唯一不同的是它使用了不同的索引。由于`datetime`对象实际上只是一个数字，我们也可以轻松地按此排序。提供`reverse=True`允许我们按降序排序。'
- en: 'Once again, we''re first creating a new sorted list using the datetime in position
    4 as the key. We are then only retaining the zero- and fourth-positioned elements
    in each list and wrapping all of that inside another list to preserve our nested
    list structure:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先通过位置4的datetime来创建一个新的排序列表。然后我们只保留每个列表中的零和第四位置元素，并将所有内容包装在另一个列表中，以保留我们的嵌套列表结构：
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Writing generic spreadsheets – csv_writer.py
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写通用电子表格 – csv_writer.py
- en: 'The `csv_writer.py` script is fairly straightforward compared with the previous
    two scripts we''ve written. This script is responsible for the CSV output of our
    `UserAssist` data. The `csv_writer.py` script has two functions: `csv_writer()`
    and the helper function, `file_time()`. We explained the `file_time()` function
    in the `xlsx_writer` section, and it will not be repeated here as it has the same
    implementation.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv_writer.py`脚本相比我们之前编写的两个脚本要简单得多。这个脚本负责输出`UserAssist`数据的CSV格式。`csv_writer.py`脚本有两个函数：`csv_writer()`和辅助函数`file_time()`。我们在`xlsx_writer`部分已解释过`file_time()`函数，由于它的实现相同，这里不再重复。'
- en: Understanding the csv_writer() function
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解csv_writer()函数
- en: 'The `csv_writer()` function, defined on line 38, is slightly different from
    the way we have been creating CSV output in previous chapters. We normally start
    by creating our headers list, creating a writer object, and writing the headers
    list and each sublist in our data variable. This time, instead of using `writer()`,
    we will use the `DictWriter()` method to handle writing our `UserAssist` dictionaries
    for us:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv_writer()`函数定义在第38行，与我们在前几章中创建CSV输出的方式略有不同。我们通常会首先创建标题列表，创建写入对象，并写入标题列表以及数据变量中的每个子列表。这次，我们不再使用`writer()`，而是使用`DictWriter()`方法来帮助我们写入`UserAssist`字典：'
- en: '[PRE73]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'On line 49, we do still create our headers list as normal. However, this list
    plays a more important role. This list contains the name of each key that will
    appear in our `UserAssist` dictionaries and in the order we want to display them.
    The `DictWriter()` method will allow us to then order our dictionaries by this
    list to ensure that our data is presented in the appropriate sequence. Depending
    on whether Python 2 or 3 is running the code, we open the `csvfile` using the
    appropriate method. Look at the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在第49行，我们仍然像往常一样创建我们的标题列表。然而，这个列表起到了更重要的作用。这个列表包含了每个键的名称，这些键将出现在我们的`UserAssist`字典中，并且是我们希望显示的顺序。`DictWriter()`方法将允许我们根据这个列表来排序字典，以确保数据按适当的顺序展示。根据代码是由Python
    2还是3运行，我们会使用合适的方法来打开`csvfile`。请看下面的代码：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We start by creating our `csvfile` object and our writer. The `DictWriter()`
    method takes a file object as its required argument and optional keyword arguments.
    The `fieldnames` argument will ensure that the dictionary keys are written in
    the appropriate order. The `extrasaction` keyword is set to ignore scenarios where
    a dictionary contains a keyword that is not in the `fieldnames` list. If this
    option was not set, we would receive an exception if there was an extra unaccounted-for
    key in the dictionary. In our scenario, we should never encounter this issue as
    we have hardcoded the keys. However, if for some reason there are extra keys,
    we would rather the `DictWriter()` ignore them than crash, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`csvfile`对象和写入器。`DictWriter()`方法需要一个文件对象作为必需的参数，还可以使用可选的关键字参数。`fieldnames`参数将确保字典的键按照适当的顺序写入。`extrasaction`关键字设置为忽略字典中包含但不在`fieldnames`列表中的键。如果没有设置这个选项，如果字典中有额外的未记录键，我们将会遇到异常。在我们的场景中，由于我们已经硬编码了这些键，应该不会遇到这个问题。然而，如果因为某种原因出现了额外的键，我们宁愿让`DictWriter()`忽略它们，而不是崩溃，代码如下：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With the `DictWriter()` object, we can call the `writeheader()` method to automatically
    write the supplied field names:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DictWriter()`对象，我们可以调用`writeheader()`方法自动写入提供的字段名：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that we do some additional processing on each dictionary before writing
    it. First, we add the ID key to the current loop count. Next, on line 71, we call
    the `fileTime()` method to convert the FILETIME object into a `datetime` format.
    Finally, on line 73, we write our dictionary to the CSV output file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在写入每个字典之前会进行一些额外的处理。首先，我们将ID键添加到当前的循环计数中。接下来，在第71行，我们调用`fileTime()`方法将FILETIME对象转换为`datetime`格式。最后，在第73行，我们将字典写入CSV输出文件：
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After all the dictionaries have been written, we `flush()` and `close()` the
    handle on the `csvfile` object. And with that, we log the successful completion
    of our CSV script. All that''s left at this point is to actually run our new framework:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字典写入完成后，我们对`csvfile`对象调用`flush()`并执行`close()`操作。至此，我们记录下CSV脚本成功完成的日志。此时，剩下的就是实际运行我们新的框架：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Running the UserAssist framework
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行UserAssist框架
- en: 'Our script is capable of parsing both Windows XP- and Windows 7-based `UserAssist`
    keys. However, let''s focus our attention on the differences between the CSV and
    XLSX output options. Using the `xlsxwriter` module and seeing the output should
    make the advantages of writing directly to an excel file over CSV clear. While
    you do lose the portability of the CSV document, you gain a lot more functionality.
    The following is the screenshot of running the `userassist.py` script against
    a Vista `NTUSER.DAT` and creating an XLSX output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本能够解析基于Windows XP和Windows 7的`UserAssist`注册表项。然而，我们将重点关注CSV和XLSX输出选项之间的差异。使用`xlsxwriter`模块并查看输出结果应该能清楚地展示直接写入Excel文件相对于CSV文件的优势。虽然你失去了CSV文档的可移植性，但你获得了更多的功能。以下是运行`userassist.py`脚本对Vista系统的`NTUSER.DAT`文件进行处理并创建XLSX输出的截图：
- en: '![](img/29ff171f-7815-454a-b2a8-cc8540a30495.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29ff171f-7815-454a-b2a8-cc8540a30495.png)'
- en: The CSV output is not capable of preserving Python objects or crafting report-ready
    spreadsheets. The upside of a CSV report, besides the portability, is that writing
    the module itself is very simple. We were able to write the main logic in just
    a few lines of code compared with over 100 lines for the Excel document, which
    clearly took more time to develop.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: CSV输出无法保存Python对象或创建可供报告使用的电子表格。CSV报告的优点，除了其可移植性之外，就是模块的编写非常简单。与超过100行代码的Excel文档相比，我们能够用仅仅几行代码写出主要逻辑，显然后者开发起来花费了更多时间。
- en: Being able to write a customized Excel report is great, but comes at a time
    cost. It might not always be a feasible addition for the forensic developer as
    time constraints often play a large role in the development cycle and dictate
    what you can and cannot do. However, if time permits, this can save the hassle
    of performing this process manually by the examiner and allow more time for analysis.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写自定义的Excel报告是很棒的，但它需要时间成本。对于法医开发人员来说，这可能并不总是一个可行的附加功能，因为时间限制往往在开发周期中起着重要作用，并决定了你能做什么和不能做什么。然而，如果时间允许，这可以节省检查员手动执行此过程的麻烦，并为分析留出更多时间。
- en: Challenge
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: 'We talked extensively about the additions that Windows 7 brought to the `UserAssist`
    artifact. However, there are even more changes that we did not account for in
    our current implementation of the `UserAssist` framework. With Windows 7, some
    common folder names were replaced with GUIDs. The following is a table of some
    examples of folders and their respective GUIDs:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了 Windows 7 对 `UserAssist` 工件所做的新增内容。然而，仍有一些我们在当前 `UserAssist` 框架实现中未考虑到的变化。随着
    Windows 7 的发布，一些常见文件夹名称被 GUID 替换。以下是一些文件夹及其对应 GUID 的示例表：
- en: '| **Folder** | **GUID** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **文件夹** | **GUID** |'
- en: '| `UserProfiles` | `{0762D272-C50A-4BB0-A382-697DCD729B80}` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `UserProfiles` | `{0762D272-C50A-4BB0-A382-697DCD729B80}` |'
- en: '| `Desktop` | `{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `Desktop` | `{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}` |'
- en: '| `Documents` | `{FDD39AD0-238F-46AF-ADB4-6C85480369C7}` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `Documents` | `{FDD39AD0-238F-46AF-ADB4-6C85480369C7}` |'
- en: '| `Downloads` | `{374DE290-123F-4565-9164-39C4925E467B}` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `Downloads` | `{374DE290-123F-4565-9164-39C4925E467B}` |'
- en: An improvement to our script might involve finding these and other common folder
    GUIDs, and replacing them with the true path. A list of some of these common GUIDs
    can be found on Microsoft's MSDN website at [http://msdn.microsoft.com/en-us/library/bb882665.aspx](http://msdn.microsoft.com/en-us/library/bb882665.aspx).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的脚本进行改进，可能涉及到查找这些和其他常见文件夹 GUID，并将其替换为真实路径。微软 MSDN 网站上提供了一些常见 GUID 的列表，网址为
    [http://msdn.microsoft.com/en-us/library/bb882665.aspx](http://msdn.microsoft.com/en-us/library/bb882665.aspx)。
- en: Alternatively, the graph we chose to chart the last 10 executables may not be
    the best way of presenting dates graphically. It might be worthwhile to create
    a more timeline-focused graph to better represent that data. Try using some of
    the other built-in graphs and their features to become more familiar with the
    graphing features of `xlsxwriter`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们选择用来绘制最后 10 个可执行文件的图表，可能不是展示日期的最佳方式。创建一个更侧重时间线的图表可能更能有效地展示这些数据。尝试使用一些其他内置图表及其功能，以更好地熟悉
    `xlsxwriter` 的图表功能。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a module-centric chapter, where we added three new modules to our toolkit.
    In addition, we gained an understanding of the `UserAssist` artifact and how to
    parse it. While these concepts are important, our brief detour with `timeit` may
    prove most valuable going forward.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个模块为中心的章节，我们向工具包中添加了三个新模块。此外，我们还了解了 `UserAssist` 工件以及如何解析它。虽然这些概念很重要，但我们对
    `timeit` 的短暂探讨可能在今后的工作中更具价值。
- en: As developers, there will be times where the execution of our scripts is lacking
    or, on large datasets, takes an absurd amount of time. In these situations, modules
    such as `timeit` can help audit and evaluate code to identify more efficient solutions
    for a given situation. The code for this project can be downloaded from GitHub
    or Packt, as described in the *Preface*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们有时会遇到脚本执行效率不足，或者在处理大数据集时花费大量时间的情况。在这些情况下，像 `timeit` 这样的模块可以帮助审计和评估代码，以找出更高效的解决方案。该项目的代码可以从
    GitHub 或 Packt 下载，具体说明见 *前言*。
- en: In the next chapter, we will introduce how to hash files in Python. Specifically,
    we will focus on hashing blocks of data to identify identical and similar files.
    This is referred to as "fuzzy hashing." This technique is useful when evaluating
    objects that share a similar root, such as malware. We could take a known sample
    of malware we suspect was used on a system, fuzzy hash it, and search for matches
    on the system. Instead of finding an identical match, we receive a 90% match on
    an obscure file, which upon further inspection turns out to be a new variant of
    the malware that might otherwise have gone unnoticed. We will cover multiple methods
    to implement this functionality and the logic behind the process.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍如何在 Python 中进行文件哈希。具体来说，我们将重点讲解如何对数据块进行哈希，以识别相同或相似的文件。这被称为“模糊哈希”。当评估共享相似根源的对象时，这种技术非常有用，例如恶意软件。我们可以获取我们怀疑已在系统中使用的已知恶意软件样本，进行模糊哈希，并在系统中搜索匹配项。我们不再寻找完全匹配，而是在一个不显眼的文件上找到了90%的匹配，进一步检查后，发现这其实是恶意软件的新变种，否则可能会被忽略。我们将介绍实现这一功能的多种方法和背后的逻辑。
