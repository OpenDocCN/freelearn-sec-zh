- en: Warming up – Your First Antivirus-Free Persistence Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预热 – 您的第一个无病毒软件的持久化 Shell
- en: Nowadays, security solutions such as firewalls, IPS, and sandboxing are becoming
    more and more advanced to prevent and detect cyber-attacks. So, being an advanced
    hacker requires you to code your own script and tools to bypass these security
    solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，防火墙、入侵防御系统（IPS）和沙盒等安全解决方案正变得越来越先进，以防止和检测网络攻击。因此，成为一名高级黑客需要编写自己的脚本和工具，以绕过这些安全解决方案。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Preparing the attacker machine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备攻击者机器
- en: Preparing the target machine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备目标机器
- en: TCP reverse Shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 反向 Shell
- en: HTTP reverse Shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 反向 Shell
- en: Persistence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化
- en: Tuning connection attempts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整连接尝试
- en: Tips for preventing a shell breakdown
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止 Shell 崩溃的小贴士
- en: Countermeasures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对策
- en: Preparing the attacker machine
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备攻击者机器
- en: In this section, we will prepare our Kali Linux machine as the attacker. Note
    that we are assuming that the operating system is already set up in VMware or
    VirtualBox. As of now, we will be using VirtualBox for all our chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将准备 Kali Linux 机器作为攻击者。请注意，我们假设操作系统已经在 VMware 或 VirtualBox 中设置好。目前，我们将使用
    VirtualBox 来处理所有章节。
- en: 'We can check the version of any Linux OS by running the following `cat` command
    to display the content from the file `/etc/os-release`, which contains OS distribution
    data. We will be using Kali Linux version 2018.1, as you can see from the following
    screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下 `cat` 命令来检查任何 Linux 操作系统的版本，显示来自文件 `/etc/os-release` 的内容，该文件包含操作系统的分发数据。我们将使用
    Kali Linux 版本 2018.1，正如下图所示：
- en: '![](../images/00005.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: 'It doesn''t matter what your Kali version is. For this book, we will be using
    the latest version available at the time of writing. Since, by default, Python
    is preinstalled in every Linux distribution, we can get the version details from
    either the interactive shell by running the command `python` or by using `python
    -V`, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的 Kali 版本是什么，对于本书，我们将使用写作时可用的最新版本。由于 Python 默认预安装在每个 Linux 发行版中，我们可以通过在交互式
    Shell 中运行 `python` 命令或使用 `python -V` 来获取版本信息，如下图所示：
- en: '![](../images/00006.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: We will be using `Python 2.7.14+` for now, which came preinstalled with our
    Linux version.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `Python 2.7.14+`，该版本已预安装在我们的 Linux 版本中。
- en: 'So, let''s go for networking a little bit. In this chapter, the Kali IP is `10.0.2.15`.
    We can check the Kali IP by running the `ifconfig eth0`command. This will return
    the network interface configuration as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们稍微配置一下网络。在本章中，Kali 的 IP 地址是 `10.0.2.15`。我们可以通过运行 `ifconfig eth0` 命令来检查
    Kali 的 IP 地址。这将返回网络接口配置，如下所示：
- en: '![](../images/00007.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: Setting up internet access
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置互联网访问
- en: 'To set up the internet on our system, we just need to change the network mode
    to **Network Address Translation** (NAT) in VirtualBox. NAT mode will mask all
    network activity as if it came from your host OS, although VirtualBox can access
    external resources. To do this, perform the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在系统上设置互联网，我们只需要将网络模式更改为 **网络地址转换**（NAT）模式，在 VirtualBox 中，NAT 模式将所有网络活动伪装成来自主机操作系统的请求，尽管
    VirtualBox 可以访问外部资源。要执行此操作，请按照以下步骤进行：
- en: Click on the Devices menu from VirtualBox's menu bar
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 VirtualBox 的菜单栏点击 **设备** 菜单
- en: Go to Network and select Network Settings
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到网络并选择网络设置
- en: 'Select the network mode as NAT and click on OK as shown in the following screenshot:  ![](../images/00008.jpeg)'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择网络模式为 **NAT** 并点击 OK，如下图所示： ![](../images/00008.jpeg)
- en: Once you perform the preceding steps, you should be able to reach the internet,
    as long as the VirtualBox host does. You can check internet access by running `ping
    8.8.8.8` from the terminal.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了上述步骤，只要 VirtualBox 主机能够连接互联网，您就应该能够访问互联网。您可以通过从终端运行 `ping 8.8.8.8` 来检查网络连接。
- en: 'Now, if you don''t have a GUI compiler for Python, you can just install it
    using the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您没有 Python 的 GUI 编译器，可以通过以下命令安装：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once it''s installed, let''s do a quick print program using **IDLE (using Python-2.7)**,
    which we installed using the previous command. Open a new Python file and type
    `print (''hello there'')`. Run the program and save it on the desktop. Once you
    finish accessing the internet, you now need to change the network mode back to
    Internal Network so that we can reach out to our Windows target. This is shown
    in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们使用**IDLE（使用Python-2.7）**做一个快速的打印程序，该程序是通过前面命令安装的。打开一个新的Python文件，输入`print
    ('hello there')`。运行程序并将其保存到桌面。完成此操作后，访问互联网后，你需要将网络模式更改回内部网络，以便能够连接到Windows目标。如下图所示：
- en: '![](../images/00009.jpeg)Note that the Windows target globally machine is sitting
    on the same internal network as Kali attacker globally machine, `intnet`, here.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00009.jpeg)请注意，Windows目标机器和Kali攻击者机器都位于相同的内部网络`intnet`上。'
- en: And, as a last step, we should verify that we still got the same IP address,
    which is `10.0.2.15` by running `ifconfig` in the terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们应该验证是否仍然获得相同的IP地址，即通过在终端中运行`ifconfig`命令，得到`10.0.2.15`。
- en: if the IP changes, you can change the IP back by running `ifconfig eth0 10.0.2.15.`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IP发生变化，可以通过运行`ifconfig eth0 10.0.2.15`将IP改回。
- en: Preparing the target machine
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备目标机器
- en: In this section, we will be preparing our target. We are using a 32-bit Windows
    7 machine as our target. We will begin by installing Python 2.7.14+ version from
    [https://www.python.org/downloads/](https://www.python.org/downloads/). After
    you begin the installation, you'll notice that Python will install other handy
    tools such as `pip` and `easy_install`. We will be using `pip` to install third-party
    libraries later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将准备我们的目标。我们使用的是一台32位Windows 7机器作为目标。我们将从[https://www.python.org/downloads/](https://www.python.org/downloads/)安装Python
    2.7.14+版本。在你开始安装时，你会注意到Python还会安装一些其他实用工具，如`pip`和`easy_install`。稍后我们将使用`pip`来安装第三方库。
- en: Similar to what we have done in Kali, we will create a quick and simple Python
    script just to make sure that everything is working fine. Create a new file. Type
    `print ('hi')`, run the script, and save it to the desktop. After this, we need
    to add Python to our path, so we can start an interactive mode or interactive
    shell anywhere from the command line. Open a command line and type `python`; you
    will see that Windows does not recognize the `python.exe` application by default,
    so we've got to add that manually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在Kali中做的，我们将创建一个快速简单的Python脚本，确保一切正常运行。创建一个新文件，输入`print ('hi')`，运行脚本并将其保存到桌面。完成此操作后，我们需要将Python添加到路径中，这样就可以从命令行的任何位置启动交互模式或交互式终端。打开命令行并输入`python`；你会看到Windows默认不识别`python.exe`应用程序，因此我们需要手动添加它。
- en: 'Perform the following steps to achieve this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现这一点：
- en: Go to Advanced system settings | Environment Variables.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到高级系统设置 | 环境变量。
- en: In System Variables, scroll down until you reach the variable Path. You will
    need to append the Python path and the `pip` path here.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统变量中，向下滚动直到找到变量Path。你需要在此处附加Python路径和`pip`路径。
- en: Copy the path where the Python application is installed and append it to the
    Variable value.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Python应用程序的安装路径，并将其附加到变量值中。
- en: Ensure that you insert a semicolon at the end, just to make sure that you append
    it to our existing Variable value.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在末尾插入分号，以确保它被附加到我们现有的变量值中。
- en: Also, copy the path where `pip` is installed from the `/Scripts` folder and
    append it to the Variable value as shown in the following screenshot: ![](../images/00010.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，复制`pip`安装路径（位于`/Scripts`文件夹中），并将其附加到变量值中，如下图所示：![](../images/00010.jpeg)
- en: Restart the machine so that it recognizes the new values we've just inserted.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启机器，以便它能识别我们刚刚插入的新值。
- en: After the restart is complete, open a command line and type `python` and the
    interactive shell will appear:![](../images/00011.gif)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启完成后，打开命令行并输入`python`，交互式终端将会出现：![](../images/00011.gif)
- en: 'Now, to get connectivity with our Kali machine, make sure that the network
    setting is set to Internal Network and the network name matches the name on the
    Kali side, which is `intnet`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了与我们的Kali机器建立连接，请确保网络设置为“内部网络”，并且网络名称与Kali端的名称匹配，即`intnet`：
- en: '![](../images/00012.jpeg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: 'Lastly, we need to give this machine an IP address on the same subnet as the
    Kali machine. We can change the network settings by going to Network and Internet/Network
    and Sharing Center from the control panel. Click on the Local Area Connection
    and then click on Properties. From there, go to Internet Protocol Version 4 (TCP/IPv4),
    enter the IP address as `10.0.2.10` and the rest as shown in the following screenshot.
    Then click on OK:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为这台机器分配一个与 Kali 机器处于同一子网的 IP 地址。我们可以通过控制面板进入网络和 Internet/网络和共享中心来更改网络设置。点击本地连接，然后点击属性。在这里，进入互联网协议版本
    4 (TCP/IPv4)，输入 IP 地址为 `10.0.2.10`，并按照以下截图所示填写其余内容。然后点击确认：
- en: '![](../images/00013.jpeg)We have installed the Python compiler on the target
    machine just to have a better way to explain the code and compile it. However,
    we will compile the Python script into a standalone EXE later on, so it''ll work
    on any target without having a Python compiler installed.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00013.jpeg)我们已经在目标机器上安装了 Python 编译器，目的是更好地解释代码并进行编译。然而，我们稍后将把
    Python 脚本编译成独立的 EXE 文件，这样它就可以在任何没有安装 Python 编译器的目标上运行。'
- en: TCP reverse shell
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 反向 Shell
- en: 'In this section, we will have a quick overview of TCP reverse shells, why we
    need a reverse connection, and what a shell is. The best way to answer these questions
    is to study the topology shown in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速概述 TCP 反向 Shell，为什么我们需要反向连接，以及什么是 shell。回答这些问题的最佳方法是研究以下图示的拓扑结构：
- en: '![](../images/00014.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: Let's say that we have an **Attacker** connected somewhere on the **Internet,**
    and on the right side we have our **Target**. So technically, we have a PC that
    is fully patched with a **built-in firewall** **enabled**, and we have the corporate
    firewall in place. And most likely that **Corporate firewall** is integrated with
    an **IPS** module or **Antivirus software**. So now, for the attacker to access
    this protected PC, there are two major problems here. First, the attacker needs
    to bypass the built-in or the host-based firewall on the operating system, which,
    by default, will block any incoming connection to that PC unless it's explicitly
    permitted; and the same rule goes for the corporate firewall as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个**攻击者**连接到**互联网**的某个地方，右侧是我们的**目标**。所以，从技术上讲，我们有一台完全修补的计算机，并且启用了**内置防火墙**，同时也有企业防火墙在运行。而且，很可能**企业防火墙**已经集成了**入侵防御系统
    (IPS)**模块或**杀毒软件**。因此，现在，攻击者要访问这台受保护的计算机，面临两个主要问题。首先，攻击者需要绕过操作系统上的内置防火墙或主机防火墙，默认情况下，防火墙会阻止任何进入该计算机的连接，除非明确允许；同样的规则也适用于企业防火墙。
- en: But, if the attacker could somehow find a way to send a malicious file to the
    user, or maybe trick that user into visiting our malicious website and downloading
    a malicious file, then we might be able to compromise that PC or maybe the whole
    network. So, in order to bypass the firewall root restriction, we need to make
    our target, which is the TCP client, initiate the connection back to us. So, in
    this case, we are acting as a TCP server, and our target, or our victim here,
    is acting as a TCP client and this is exactly why we need a reverse shell.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果攻击者能以某种方式找到向用户发送恶意文件的方法，或者可能欺骗用户访问我们的恶意网站并下载恶意文件，那么我们可能会危及该计算机，甚至可能是整个网络。因此，为了绕过防火墙根本限制，我们需要让我们的目标，也就是
    TCP 客户端，主动发起连接回我们。所以，在这种情况下，我们充当 TCP 服务器，而我们的目标或受害者充当 TCP 客户端，这正是我们需要反向 shell
    的原因。
- en: Now, we need to understand what a shell is in the first place. If we can initiate
    a `cmd` process on the target machine and bind that process to a network socket,
    in this case, it's called a **reverse shell**. Hence, when we say that we sent
    a TCP reverse shell on port `123` to the target machine, it means that once the
    victim runs the file, we're expecting to receive a reverse TCP connection on port
    `123`. So, the destination port in this case will be `123`, and we should be listening
    on this port. So this port should be open in our Kali machine. Then, after completing
    the TCP three-way handshake, we can send certain commands to the victim/target,
    make the victim execute them, and get the result back to us.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要先理解什么是 shell。如果我们可以在目标机器上启动 `cmd` 进程，并将该进程绑定到网络套接字上，那么这就被称为**反向 Shell**。因此，当我们说将
    TCP 反向 Shell 发送到端口 `123` 时，意味着一旦受害者运行该文件，我们预期会在端口 `123` 接收到反向 TCP 连接。所以，在这种情况下，目标端口将是
    `123`，我们应该在这个端口上监听。因此，这个端口应该在我们的 Kali 机器上开放。然后，在完成 TCP 三次握手后，我们可以向受害者/目标发送某些命令，让受害者执行，并将结果返回给我们。
- en: Keep in mind that a combination of social engineering and client-side attacks,
    which we discussed here, is the most powerful type of attack, and is highly likely
    to succeed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，结合社会工程学和客户端攻击（我们在这里讨论的），是最强大的攻击类型，并且很有可能成功。
- en: Coding a TCP reverse shell
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个 TCP 反向 shell
- en: In this section, we will call a sample TCP server on the Kali machine and a
    sample TCP client on the target machine. Then, we will see how to execute some
    commands remotely from the Kali machine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在 Kali 机器上调用一个示例 TCP 服务器，并在目标机器上调用一个示例 TCP 客户端。然后，我们将看到如何从 Kali 机器远程执行一些命令。
- en: Server side
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端
- en: 'Lets start with the server side. Building a TCP server in Python is quite simple:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器端开始。在 Python 中构建一个 TCP 服务器非常简单：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the preceding code, the script starts with importing the
    `socket` library, which is responsible for coding a low-level network interface.
    The `AF_INIT` defines the socket address as a pair: the host and port. In this
    case, it will be `10.10.10.100`, and the port is `8080`. The `SOCK_STREAM` is
    the default mode for the socket type. Now, the bind function specifies the Kali
    IP address and the listening port in a tuple format, which is `10.10.10.100`,
    and we should be listening on port `8080` to receive a connection.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，脚本首先导入了`socket`库，它负责编写低级网络接口。`AF_INIT` 定义了套接字地址为一对：主机和端口。在这种情况下，它将是`10.10.10.100`，端口是`8080`。`SOCK_STREAM`
    是套接字类型的默认模式。现在，bind 函数指定了 Kali IP 地址和监听端口的元组格式，即`10.10.10.100`，我们应该在端口`8080`上监听以接收连接。
- en: Since we are expecting only a single connection from a single target, we'll
    be listening for a single connection. So the backlog size, which specifies the
    maximum number of queued connection, is `1`; and we define the listening value
    to be `1`. Now, the `accept` function returns the value of a pair of connection
    objects (`conn`), as well as the address (`addr`). The address here is the target
    IP address and the source port used from the target to initiate the connection
    back to us. Next, we will go into an infinite loop and get our command input and
    send it to the target machine. This raw input is used to get the user input. If
    the user input was `terminate`, we will inform our target that we want to close
    the session, and then we will close the session from our side. Otherwise, we will
    send a `command` to the target, and we will read and print the first KB of the
    received data from the target side.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只期望来自单个目标的单个连接，因此我们将监听一个连接。所以，backlog 大小，指定最大排队连接数，是`1`；我们将监听值定义为`1`。现在，`accept`
    函数返回一对连接对象（`conn`）的值，以及地址（`addr`）。这里的地址是目标的 IP 地址和用于从目标发起连接回我们的源端口。接下来，我们将进入一个无限循环，获取我们的命令输入并将其发送到目标机器。这个原始输入用于获取用户输入。如果用户输入的是`terminate`，我们将通知目标我们希望关闭会话，然后我们会从我们这边关闭会话。否则，我们将向目标发送一个`command`，并且我们将读取并打印从目标端收到的前
    1 KB 数据。
- en: Client side
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Now, let''s look into the client side script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下客户端脚本：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import the `subprocess` to start the shell and the system. Next, the connection
    part is quite simple. We define `s` and `socket` object, and we specify the IP
    address of the Kali machine and the port that we should initiate the connection
    on. The port that we are listening to on the Kali machine should exactly match
    the port from which we initiate the connection from the target machine. Similar
    to the server side, we will go into an infinite loop and get the attacker command.
    If the attacker command is `terminate`, or if there is a `terminate` keyword or
    string in the command, then we close the connection and break the infinite loop,
    otherwise we will use the `subprocess` to start a shell in the system. We will
    pass the command that we have received from the attacker machine to the `subprocess`,
    and get the result or the error. Notice that the `subprocess` has a kind of self-mechanism
    for exception handling. For instance, if we mistype a certain command on the Kali
    side and send the wrong syntax to the target, instead of crashing the process,
    the `stderr` handles the exception and returns the error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`subprocess`来启动shell和系统。接下来，连接部分相当简单。我们定义`s`和`socket`对象，并指定Kali机器的IP地址和我们应该发起连接的端口。我们在Kali机器上监听的端口必须与我们从目标机器发起连接的端口完全匹配。与服务器端类似，我们将进入一个无限循环并获取攻击者的命令。如果攻击者的命令是`terminate`，或者命令中包含`terminate`关键字或字符串，则我们关闭连接并打破无限循环；否则，我们将使用`subprocess`启动系统中的shell。我们将把从攻击者机器接收到的命令传递给`subprocess`，并获取结果或错误。请注意，`subprocess`有一种自我处理异常的机制。例如，如果我们在Kali端输入了错误的命令并将错误的语法发送给目标，`stderr`不会导致进程崩溃，而是处理异常并返回错误。
- en: 'Let''s quickly try our script from the Python IDE that we used earlier for
    the `hello there` program. Run the server side first by clicking on Run and selecting
    Run Module. Just to verify that we have opened a listener on port `8080`, run
    the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前用于`hello there`程序的Python IDE快速尝试一下我们的脚本。首先点击运行并选择运行模块，启动服务器端。只是为了验证我们是否已经在`8080`端口上打开了监听器，运行以下命令：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../images/00015.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: 'As you can see, `python2.7` has opened the port and we are listening. Run the
    target script on the other VirtualBox. As shown in the following screenshot, we''ve
    got ten our shell from an IP address of `10.0.2.10`, which is the IP address of
    our Windows machine, and a source port of `49160`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`python2.7`已经打开了端口并在监听。现在在另一个虚拟机上运行目标脚本。正如以下截图所示，我们从`10.0.2.10`的IP地址获取到了我们的shell，而这个IP地址是我们的Windows机器的IP地址，源端口为`49160`：
- en: '![](../images/00016.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: 'Let''s explore the target machine a little bit starting with `ipconfig` and
    `dir`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ipconfig`和`dir`开始，稍微探索一下目标机器：
- en: '![](../images/00017.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: 'Let''s go for `arp -a`. We now get the ARP table on the target machine:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试`arp -a`。现在我们获取目标机器上的ARP表：
- en: '![](../images/00018.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: As shown in the previous screenshot, on mistyping a command, instead of crashing
    the script, the subprocess `stderr` returns the wrong syntax error.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，输入错误命令时，子进程的`stderr`返回错误的语法，而不是使脚本崩溃。
- en: To quickly recap what we have done here so far, we have built a reverse TCP
    tunnel and got the user input using the raw input. When we type `arp -a`, the
    raw input will get that command and then we will send it to the target machine.
    Once received at the target side, we initiate `cmd` as a subprocess, send the
    error or the result back, and print it out on the target side.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速回顾我们到目前为止所做的工作，我们已经建立了一个反向TCP隧道，并通过原始输入获取了用户输入。当我们输入`arp -a`时，原始输入将获取该命令，然后我们将其发送到目标机器。一旦在目标端接收到命令，我们将启动`cmd`作为子进程，发送错误或结果并在目标端打印出来。
- en: The shell will crash if you hit *Enter* a couple of times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连续按几次*Enter*键，shell将崩溃。
- en: Data exfiltration – TCP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据外泄 – TCP
- en: In the previous section, we have seen how to navigate target directories. Now
    we will see how to grab these files. Ensure that, before grabbing any data from
    the target machine, the rules of engagement explicitly allow this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经学习了如何导航目标目录。现在我们将看到如何抓取这些文件。在从目标机器抓取任何数据之前，请确保交战规则明确允许这样做。
- en: Server side
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端
- en: 'So, let''s start with the updated server side script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从更新后的服务器端脚本开始：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `elif 'grab' in command:` code indicates that this is not a normal command;
    this command is used to transfer a file. So, both the server and the client must
    agree on this indicator or formula. Now, the formula will be `grab` followed by `*` and
    the path of the file that we want to grab, for example, `grab*C:\Users\Hussam\Desktop\photo.jpeg`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif ''grab'' in command:`代码表明这不是一个普通的命令；此命令用于传输文件。因此，服务器和客户端必须就此指示符或公式达成一致。现在，公式将是`grab`，后面跟上`*`和我们要抓取的文件路径，例如，`grab*C:\Users\Hussam\Desktop\photo.jpeg`。'
- en: Client side
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Now, let''s take a look at the client side script:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看客户端脚本：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As mentioned previously, both the client and the server must agree on the `grab`
    formula. So, on the client side, if we receive a grab string, we will split the
    command into two sections, the section before `*` and the section after `*`, where
    the second section contains the path and we will store the path in the path variable.
    Now, to make sure that our script will not crash if something goes wrong during
    the transfer, we will use the exception handler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端和服务器必须就`grab`公式达成一致。所以，在客户端，如果我们接收到一个grab字符串，我们会将命令分成两部分，`*`前后的部分，其中第二部分包含路径，我们会将路径存储在path变量中。为了确保我们的脚本在传输过程中如果发生问题不会崩溃，我们将使用异常处理器。
- en: Next, we send the `path` variable to the `transfer` function. So, the first
    thing that we'll do in the `transfer` function is to check whether the requested
    file exists in the first place or not. If not, then we'll send the `'Unable to
    find out the file'` message to the server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`path`变量传递给`transfer`函数。所以，在`transfer`函数中，我们首先要做的就是检查请求的文件是否存在。如果不存在，我们将把`'无法找到文件'`的消息发送给服务器。
- en: Next, we will read the file as pieces or chunks, where each piece or each chunk
    has a value of 1 KB, and we will loop around until we reach the end of the file.
    And when we do so, we need to send an indicator or a tag to the server side to
    indicate that we have reached the end of the file. So, the `DONE` string in the
    preceding code block is to indicate that we have reached the end of the file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将文件分成若干部分或块，每个块的大小为1KB，我们将循环读取，直到文件的末尾。当我们这样做时，需要发送一个指示符或标签给服务器端，表明我们已经到达文件的末尾。因此，前面代码块中的`DONE`字符串用于指示我们已经到达文件末尾。
- en: Now, on the server side, we create a placeholder or file holder. We will store
    the received bytes in `test.png`, which is the file holder here. When the control
    enters the loop, and each time we read 1 KB of data, it's written into `test.png`.
    When it receives the `DONE` string, it means that we have reached the end of the
    file. So, the file is closed and the loop ends. Also, if the server gets `Unable
    to find the file`, it will print this out and break the loop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在服务器端，我们创建一个占位符或文件持有者。我们将把接收到的字节存储在`test.png`中，这里就是文件持有者。当控制进入循环，每次读取1KB的数据时，它会写入`test.png`。当接收到`DONE`字符串时，意味着我们已经到达文件的末尾。此时，文件会被关闭，循环结束。另外，如果服务器收到`无法找到文件`，它会打印出来并中断循环。
- en: 'Now, run the server script again and we''ll be listening to port `8080`. Once
    we run the script on the target side, we get the shell. Next, proceed to the directory
    and try to grab `Module2.pdf` by running the `grab*Module2.pdf` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行服务器脚本，我们将监听端口`8080`。一旦在目标端运行脚本，我们就能获得shell。接下来，进入目录并尝试通过运行`grab*Module2.pdf`命令来获取`Module2.pdf`：
- en: '![](../images/00019.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: When we type the aforementioned command, it will trigger the `if` statement
    on both the client side as well as the server side. So, on the target when we
    receive a `grab*Module2.pdf`, we will split up this command into two parts. The
    second part contains `Module2.pdf`, which is the file that we want to grab. We
    will store it in the path variable as discussed previously. The code will check
    whether the file exists, read it in chunks, and send it over to the server side.
    This gives a response at the server side: `[+] Transfer completed`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入上述命令时，它将在客户端和服务器端都触发`if`语句。因此，当我们在目标端接收到`grab*Module2.pdf`时，我们将把这个命令分为两部分。第二部分包含`Module2.pdf`，即我们要抓取的文件。我们将如前所述将其存储在path变量中。代码将检查文件是否存在，按块读取，并将其发送到服务器端。这将在服务器端返回响应：`[+]
    传输完成`。
- en: Find the file on your desktop, it's called `1.txt` now, change the file extension
    to `.pdf`, and rename the file, since we know that this is not an image but only
    a placeholder. Now, open `Module2.pdf` using any PDF reader just to make sure
    that the file is not corrupt. It'll open without any errors if it hasn't been
    corrupted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上找到文件，它现在叫做`1.txt`，将文件扩展名改为`.pdf`，并重命名文件，因为我们知道这不是一个图片，而只是一个占位符。现在，用任何PDF阅读器打开`Module2.pdf`，以确保文件没有损坏。如果没有损坏，它将正常打开。
- en: 'Let''s try with another one. Now, we''ll grab `Tulips.png`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试另一个。现在，我们将抓取`Tulips.png`：
- en: '![](../images/00020.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: Since the file that we want to grab has the same extension as our file holder,
    which is `.png`, we don't need to change the file extension.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要抓取的文件与我们的文件夹具有相同的扩展名，即`.png`，因此我们不需要更改文件扩展名。
- en: 'Try to grab any file that exists but the same rule applies here: change the
    name of the file with its original extension. Let''s try with a file that does
    not exist. Go back to our shell, and type `grab*blaaaah.exe` and it will throw
    an error, as shown in the following image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试抓取任何已存在的文件，但同样的规则适用：更改文件名为其原始扩展名。让我们尝试一个不存在的文件。回到我们的终端，输入`grab*blaaaah.exe`，它将抛出一个错误，如下图所示：
- en: '![](../images/00021.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: This will crash our script on the target side, which you will see when you run `ipconfig`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致我们的脚本在目标机器上崩溃，运行`ipconfig`时你会看到这个问题。
- en: You were probably expecting us to use a well-known protocol such as FTP, SCP,
    or secure FTP to do the file transfer. But we used a very low-level file transfer
    over a TCP socket, so you might ask why we performed it. Since these well-known
    protocols could be blocked on the firewall, we won't be able to grab any files
    out. What we have done here is, instead of initiating a new channel every time
    we want to transfer a file which may trigger the admin's attention, create a single
    TCP socket, a single session, to gain access, doing a remote shell, as well as
    for file transfer. This type of transfer is called an **inline transfer**, where
    we got a single channel and a single session to perform all the desired actions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期待我们使用一个知名协议，如FTP、SCP或安全FTP来进行文件传输。但我们使用了通过TCP套接字进行的低级文件传输，因此你可能会问为什么要这么做。由于这些知名协议可能会被防火墙屏蔽，我们将无法传输任何文件。我们在这里所做的是，不每次传输文件时都启动一个新的通道，这可能会引起管理员的注意，而是创建一个TCP套接字，一个会话来获取访问权限，执行远程Shell操作，以及进行文件传输。这种类型的传输称为**内联传输**，我们通过一个通道和一个会话来执行所有需要的操作。
- en: Exporting to EXE
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出为EXE
- en: There are multiple methods to export your Python script into a standalone EXE
    file. Today we'll use `py2exe` library. You can download the `py2exe-0.6.9.win32-py2.7.exe`
    version from [https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/](https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以将Python脚本导出为独立的EXE文件。今天我们将使用`py2exe`库。你可以从[https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/](https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/)下载`py2exe-0.6.9.win32-py2.7.exe`版本。
- en: First, proceed to install this library. It is a fairly simple process just follow
    the on-screen prompts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装这个库。安装过程非常简单，只需按照屏幕上的提示进行操作。
- en: 'After you''ve finished the installation, open a Python window on the Windows
    machine and import `py2exe` just to make sure that we can import this library
    without any exceptions. Type `python` and then import `py2exe`. If it doesn''t
    throw a error, you''re successful:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在Windows机器上打开Python窗口并导入`py2exe`，以确保我们能够毫无异常地导入此库。输入`python`，然后导入`py2exe`。如果没有抛出错误，说明成功：
- en: '![](../images/00022.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: 'Now, create a folder named `Toexe` on your desktop. In this folder, you should
    have three things: the `py2exe` binary file, `py2exe` setup file, and your `Client.py`
    script file. For simplicity, rename the binary to `py2exe`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在桌面上创建一个名为`Toexe`的文件夹。这个文件夹里应该有三样东西：`py2exe`二进制文件、`py2exe`安装文件和你的`Client.py`脚本文件。为了简便起见，将二进制文件重命名为`py2exe`。
- en: 'The setup file, `setup.py`, will set the criteria for the final standalone
    EXE file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 安装文件`setup.py`将设置最终独立EXE文件的标准：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `setup.py` script, we start by appending the `py2exe` binary into our
    directory. Then, we set the `bundle_files` to `1`. Define the name of our script,
    `Client.py`. Set `zipfile` to `None` and run this `setup` file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup.py`脚本中，我们首先将`py2exe`二进制文件添加到我们的目录中。然后，我们将`bundle_files`设置为`1`。定义我们的脚本名称为`Client.py`。将`zipfile`设置为`None`并运行该`setup`文件。
- en: 'Two folders will be created, called `build` and `dist` , after performing the
    aforementioned steps, as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述步骤后，将创建两个文件夹，分别名为`build`和`dist`，如下图所示：
- en: '![](../images/00023.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: 'So under the `dist` folder, we got our `Client.exe` as a standalone, without
    any dependencies. Now, on running `Client.exe`, we will get the connection (provided
    the server script from the previous section *Data exfiltration, *is running on
    the Kali side) and we can see that a the `Client.exe` process has been created
    on the Windows Task Manager, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在`dist`文件夹下，我们得到了独立的`Client.exe`，没有任何依赖。现在，运行`Client.exe`时，我们将建立连接（前提是前一节中的服务器脚本*数据窃取*在Kali侧运行），我们可以看到`Client.exe`进程已在Windows任务管理器中创建，如下图所示：
- en: '![](../images/00024.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: 'So once again, perform a quick verification as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次进行如下的快速验证：
- en: Run `ipconfig`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ipconfig`
- en: Navigate through the directories
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览目录
- en: 'Grab a file such as `Koala.png` and wait for its successful transfer:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个文件，例如`Koala.png`，并等待其成功传输：
- en: '![](../images/00025.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: Change the file extension to `.png`
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件扩展名更改为`.png`
- en: Now, open the image and, after successfully viewing it, terminate the `Client.exe`
    process
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开图片，成功查看后，终止`Client.exe`进程
- en: Execute `terminate` in the shell on your Kali machine
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Kali机器上的Shell中执行`terminate`
- en: Once you hit *Enter*, it gets terminated on the target machine
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你按下*Enter*，目标机器上的进程将被终止
- en: HTTP reverse shell
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP反向Shell
- en: In this section, we will discuss a higher-level Python reverse shell, which
    will be carried over the HTTP protocol. The HTTP protocol is highly likely to
    be opened on the outbound or egress firewall rules, since it's used for web surfing.
    Also, a lot of HTTP traffic is required in every network, which makes monitoring
    much harder and the chances of us slipping up are high. Let's see how it works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一个更高层次的Python反向Shell，它将通过HTTP协议进行传输。由于HTTP协议通常会在出站或出口防火墙规则中被允许，因为它用于网页浏览，因此非常有可能已被开放。此外，每个网络中都需要大量的HTTP流量，这使得监控更加困难，犯错的机会较高。让我们看看它是如何工作的。
- en: First, we'll configure a simple HTTP server and a simple HTTP client and we'll
    use the `GET` and `POST` methods to send data back and forth between these two
    entities. So, as mentioned earlier, the client will initiate a reverse HTTP session
    back to our server using a `GET` method and on the server side, once we receive
    a `GET` request, we'll start taking commands using raw input, and we will send
    that command back to the target.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将配置一个简单的HTTP服务器和一个简单的HTTP客户端，我们将使用`GET`和`POST`方法在这两个实体之间来回发送数据。如前所述，客户端将使用`GET`方法发起一个反向HTTP会话回到我们的服务器，而在服务器端，一旦我们收到`GET`请求，我们将开始使用原始输入接收命令，并将该命令发送回目标。
- en: 'Once we give the command to the target, it''ll initiate a subprocess: a `cmd.exe` subprocess.
    Pass the command to that subprocess and it will post the result back to us using
    the `POST` method. Just to make sure there is continuity for our shell, we will
    perform `sleep` for 3 seconds. Then we will repeat the whole process all over
    again using the `while True:` infinite loop. The code is much simpler than the
    previous TCP socket, especially in the file transfer section, and this is because
    we are using a high-level protocol to transfer the files and data. The next section
    deals with the coding part.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们向目标发出命令，它将启动一个子进程：一个`cmd.exe`子进程。将命令传递给该子进程，它将使用`POST`方法将结果返回给我们。为了确保我们的Shell能够持续运行，我们会执行`sleep`
    3秒。然后，我们将使用`while True:`无限循环重复整个过程。与之前的TCP套接字相比，这段代码要简单得多，尤其是在文件传输部分，这是因为我们使用的是高层协议来传输文件和数据。下一部分将处理编码部分。
- en: Coding the HTTP reverse shell
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写HTTP反向Shell
- en: In this section, we'll cover the coding part for an HTTP reverse shell. On the
    client side, we'll be using a very high-level library to send our `GET` and `POST`
    requests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖HTTP反向Shell的编码部分。在客户端，我们将使用一个非常高层的库来发送我们的`GET`和`POST`请求。
- en: The library called `Requests`, which is available at [https://pypi.python.org/pypi/requests/2.7.0#downloads](https://pypi.python.org/pypi/requests/2.7.0#downloads),
    will make it much easier to do a `GET` or `POST` request in only a single line. `Requests`
    is a third-party library, so let's start by installing it. All you have to do
    is navigate through the Command Prompt to the folder that contains its setup file
    and issue `python setup.py install`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`Requests`的库，位于[https://pypi.python.org/pypi/requests/2.7.0#downloads](https://pypi.python.org/pypi/requests/2.7.0#downloads)，使得发送`GET`或`POST`请求变得更加简单，只需要一行代码。`Requests`是一个第三方库，因此我们首先需要安装它。你只需通过命令提示符导航到包含其安装文件的文件夹，然后执行`python
    setup.py install`。
- en: 'To verify that the library has been installed successfully, open the Python
    interpreter, like we did earlier for  `py2exe` , and enter `import requests`.
    If no exceptions are thrown here, we''re good to go:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证库是否已成功安装，打开Python解释器，就像我们之前为`py2exe`做的那样，输入`import requests`。如果这里没有抛出异常，那么我们就可以开始使用了：
- en: '![](../images/00026.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: Server side
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端
- en: 'The following block of code is on the server side:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块位于服务器端：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the server side, we'll use a built-in library named `BaseHTTPServer`, to
    build a basic HTTP server, which handles the client requests. Next, we define
    our Kali IP and the listening port address by setting `PORT_NUMBER` to `80`. Then,
    we create a `server_class` and `httpd` object, and we will pass our listener IP,
    the `PORT_NUMBER`, and a class handler `MyHandler` to the `server_class`. The
    class handler `MyHandler` defines what should be done when the server receives
    a `GET` or `POST` request. The server will run forever without coding a `while
    True:`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将使用一个名为`BaseHTTPServer`的内建库来构建一个基本的HTTP服务器，用于处理客户端请求。接下来，我们通过将`PORT_NUMBER`设置为`80`来定义Kali
    IP和监听端口地址。然后，我们创建`server_class`和`httpd`对象，并将监听IP、`PORT_NUMBER`以及类处理程序`MyHandler`传递给`server_class`。类处理程序`MyHandler`定义了当服务器接收到`GET`或`POST`请求时应执行的操作。服务器将永久运行，无需编写`while
    True:`。
- en: Now, if the server gets a `GET` request, it will grab the user input using the
    raw input and will send back an HTML status, `200`, which means OK. Now, the `send_header()` specifies
    the header field definition. It's mandatory to set this value since our HTTP client
    has to know the type of data. In this case, it's HTML text, `text/html`. The `wfile.write()` function is
    equivalent to sending data in our previous TCP shell, and we will be using this
    function to send the command that the user has input to our target.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果服务器接收到一个`GET`请求，它将使用原始输入获取用户输入，并发送一个HTML状态`200`，表示一切正常。此时，`send_header()`指定了头字段的定义。由于我们的HTTP客户端需要知道数据的类型，因此设置此值是强制性的。在此情况下，数据类型是HTML文本，`text/html`。`wfile.write()`函数等同于我们之前TCP
    shell中发送数据的方式，我们将使用该函数将用户输入的命令发送到目标。
- en: If the server gets a `POST` request first, similar to `GET`, we will return
    an HTML status `200` to say that we got the `POST` without any problem. The `s.headers['Content-Length']`
    specifies how many bytes the `HTTP POST` data contains. Note that the returned
    value is a string, but it has to be converted to an integer before passing it
    as a parameter to `rfile.read()`. We will use the `integer` function to perform
    this. Finally, we'll print the `postVar` variable, and in this case it'll be the
    command execution output. The server will run forever using the `serve_forever()`
    function without coding a `while True:`. However, if we invoke *Ctrl* + *C* from
    the keyboard, it will break the loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器首先接收到一个`POST`请求，类似于`GET`请求，我们将返回一个HTML状态`200`，表示我们已经成功接收到`POST`请求而没有任何问题。`s.headers['Content-Length']`指定了`HTTP
    POST`数据所包含的字节数。请注意，返回的值是一个字符串，但在将其作为参数传递给`rfile.read()`之前，必须将其转换为整数。我们将使用`integer`函数来进行此转换。最后，我们将打印`postVar`变量，在这种情况下，它将是命令执行的输出。服务器将使用`serve_forever()`函数永久运行，而无需编写`while
    True:`循环。然而，如果我们从键盘按下*Ctrl* + *C*，它将中断循环。
- en: Client side
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'The following block of code is on the client side:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块位于客户端：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we use the subprocess to create a shell, and then we create a `GET` request
    to our Kali server. Note that the `req.text` function returns the text that we
    have got from sending the `GET` request. In this case, `text` is the command that
    we should execute. Now, once we get the command, we will start a subprocess, and
    the execution result or error will be sent as a `POST` method in just a single
    line. Then, the process will sleep for 3 seconds, and repeat all over again. This `time.sleep()` part
    is just to be on the safe side—in case we get a packet drop or unexpected error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 subprocess 来创建一个 shell，然后我们创建一个 `GET` 请求发送到我们的 Kali 服务器。请注意，`req.text`
    函数返回的是我们通过发送 `GET` 请求所获得的文本。在这个例子中，`text` 就是我们应该执行的命令。现在，一旦我们获得了命令，我们将启动一个子进程，执行结果或错误将通过
    `POST` 方法发送，并且只会是单行的。然后，进程将休眠 3 秒，再次重复整个过程。`time.sleep()` 这部分只是为了保险——防止我们遇到数据包丢失或意外的错误。
- en: Also, you can enhance this script by adding some exception handling using the `try`
    and `except` functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过使用 `try` 和 `except` 函数添加一些异常处理来增强这个脚本。
- en: 'Once we proceed to run the script on both sides, we will get our shell on the
    server side and try navigating through the current working directories. Execute
    `ipconfig` and you''ll get the complete IP configuration. Now, mistype a command
    and the error message will be thrown, as shown in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在双方运行脚本，我们将在服务器端获得我们的 shell，并尝试在当前工作目录中进行导航。执行 `ipconfig`，你将获得完整的 IP 配置信息。现在，错误地输入一个命令，将会抛出错误信息，如下所示：
- en: '![](../images/00027.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: At the end we terminate the session by executing `terminate` on the server side.
    Once we do this, we exit our script on the client side, whereas to exit the script
    on the server side we need to hit on *Ctrl* + *C* on the keyboard to terminate
    the loop. The server will terminate by showing a `[!] Server is terminated` message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在服务器端执行 `terminate` 来终止会话。一旦我们这样做，我们将在客户端退出脚本，而在服务器端退出脚本时，我们需要按 *Ctrl*
    + *C* 来终止循环。服务器将通过显示 `[!] Server is terminated` 消息来终止。
- en: Data exfiltration – HTTP
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据外泄 – HTTP
- en: As we did with our TCP reverse shell, we will do a file transfer from the target
    machine back to the attacker machine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们之前在 TCP 反向 shell 中做的类似，我们将进行一个从目标机器到攻击者机器的文件传输。
- en: Client side
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: 'Thankfully, the `Requests` library supports submitting a file in just two lines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Requests` 库支持仅用两行代码提交一个文件：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we will perform the same process as we did in the TCP socket. If we get
    a `grab` command from the attacker machine, we will split this command into two
    parts, where the second part contains the path directory or the path for the file
    that we want to grab. Next, we will check whether the file is there. If not, we
    will notify the server about it immediately. Now, in case the file was there,
    notice that we have appended `/store` to our URL, `url = 'http://10.0.2.15/store'` as
    an indicator that we will be transferring a file, not a normal `cmd` output since
    both use the `POST` method to transmit data. So, for instance, when we send a
    file, let's say `x.doc`, we will send it with a `/store` in the URL. Also, the `Requests`
    library uses a special `POST` method called `multipart/form-data` to submit or
    send a file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将执行与 TCP 套接字中相同的过程。如果我们从攻击者机器收到一个 `grab` 命令，我们将把这个命令分成两部分，第二部分包含我们要抓取的文件的路径或目录。接下来，我们将检查该文件是否存在。如果没有，我们会立即通知服务器。现在，如果文件确实存在，请注意我们在
    URL 中添加了 `/store`，`url = 'http://10.0.2.15/store'`，作为一个标识，表示我们将传输的是文件而不是普通的 `cmd`
    输出，因为两者都使用 `POST` 方法传输数据。所以，比如说，当我们发送一个文件，假设是 `x.doc`，我们将带有 `/store` 的 URL 发送它。另外，`Requests`
    库使用了一种特殊的 `POST` 方法，叫做 `multipart/form-data`，来提交或发送文件。
- en: Server side
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端
- en: 'Now, on the server side, we''ve imported a new library called `cgi`. This one
    is used to handle the received file and store it locally. The following is the
    server side script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在服务器端，我们导入了一个新的库叫做`cgi`。这个库用于处理接收到的文件并将其存储在本地。以下是服务器端的脚本：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we receive a `POST` with a `/store` in the URL and the content type as `multipart/form-data`,
    it means that we''ll get a file from the target machine, not the usual command
    output. Then, we need to pass the received file, `headers`, and `REQUEST_METHOD`
    to the `FieldStorage` class. The returned value of `FieldStorage` can be indexed
    like a Python dictionary, where we have a key and a corresponding value. For instance,
    if we create a Python dictionary called `D` with a key `K` and value `v` as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到带有`/store`的`POST`请求，并且内容类型为`multipart/form-data`，则意味着我们将从目标机器获取一个文件，而不是通常的命令输出。然后，我们需要将接收到的文件、`headers`和`REQUEST_METHOD`传递给`FieldStorage`类。`FieldStorage`的返回值可以像Python字典一样进行索引，其中包含一个键和一个对应的值。例如，如果我们创建一个名为`D`的Python字典，键为`K`，值为`v`，如下所示：
- en: '![](../images/00028.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: To get the value, `v` , we just need to have the corresponding key, `K`. On
    the client side, when we submitted the file, we attached a tag or key called `files
    ='file'`. So, we will use this tag or key on the server side to receive that file.
    The `FieldStorage` will grab the keys and its values and store them in an object
    called `fs`. But we're only interested in the value of `file`, which is the tag
    or key that contains the actual file we sent. Once we get that value, we will
    write it into a placeholder called `1.txt`. In the end, we exit the function to
    prevent any mix-up with ongoing file transfer posts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取值`v`，我们只需要相应的键`K`。在客户端，当我们提交文件时，我们附加了一个名为`files ='file'`的标签或键。因此，我们将在服务器端使用这个标签或键来接收该文件。`FieldStorage`将抓取键及其值并将它们存储在名为`fs`的对象中。但我们只关心`file`的值，这是包含我们发送的实际文件的标签或键。一旦我们获取到该值，就会将其写入一个名为`1.txt`的占位符中。最后，我们退出该函数，以防止与正在进行的文件传输POST混淆。
- en: 'To initiate the file transfer, perform the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动文件传输，执行以下步骤：
- en: Run the code the usual way on both machines (Run | Run Module)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式在两台机器上运行代码（运行 | 运行模块）
- en: Once we get the `Shell>`, proceed to perform a directory search with the `dir`
    command and try to grab a file, say `putty.exe`, by running the `grab` command,
    `grab*putty.exe`
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们获得`Shell>`，继续执行`dir`命令进行目录搜索，并尝试抓取一个文件，例如`putty.exe`，通过运行`grab`命令，`grab*putty.exe`
- en: 'Once we get the file on our server machine, rename the placeholder to `putty.exe` and
    verify that we have  `putty.exe` running fine without any file corruption. This
    can be done by executing the following from the Command Prompt:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在服务器端获得文件，将占位符重命名为`putty.exe`并验证我们是否成功运行了`putty.exe`且没有文件损坏。可以通过在命令提示符中执行以下命令来验证：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Go back to the shell and grab another file, say `password.txt`, just to test
    it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到shell并获取另一个文件，比如`password.txt`，只是为了测试。
- en: Check whether you can read the contents after renaming the placeholder
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查重命名占位符后是否可以读取其内容
- en: Try to grab a non-existing file; you'll be presented with an error since it
    does not exist in the first place
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试抓取一个不存在的文件；你会遇到错误，因为它根本不存在。
- en: Exporting to EXE
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出为EXE
- en: In this section, similar to what we have done in our TCP socket, we will export
    and test our HTTP reverse shell into an EXE, and test it after that.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，类似于我们在TCP套接字中所做的那样，我们将导出并测试我们的HTTP反向Shell为EXE，并在此之后进行测试。
- en: Here, also you need to create a folder named `Toexe` on your desktop. As mentioned
    earlier, the `py2exe` binary file, the `py2exe` setup file, and the `HTTP_Client.py`
    script file should be in the folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您还需要在桌面上创建一个名为`Toexe`的文件夹。如前所述，`py2exe`二进制文件、`py2exe`设置文件和`HTTP_Client.py`脚本文件应该位于该文件夹中。
- en: 'The setup file, `setup.py`, will be as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件`setup.py`将如下所示：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Perform the following steps to initiate the export:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以启动导出：
- en: Start by editing the setup file  `py2exe` and change `Client.py` into `HTTP_Client.py`,
    which is the name of our script on the target side.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从编辑`py2exe`设置文件开始，将`Client.py`更改为`HTTP_Client.py`，这是我们在目标端脚本的名称。
- en: Execute the `setup.py` script.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`setup.py`脚本。
- en: Once we have finished, we will go to the `dist` folder and copy `HTTP_Client.py`
    to the desktop.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将进入`dist`文件夹，并将`HTTP_Client.py`复制到桌面。
- en: Ensure that the server is already running. Once we get the `Shell>`, go to the
    directories using the `dir`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务器已经在运行。一旦我们获得`Shell>`，使用`dir`命令进入目录。
- en: Try to grab a file, say `grab*password.txt`, as we did in the previous sections.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试抓取一个文件，比如`grab*password.txt`，就像我们在前面的章节中做的那样。
- en: After getting the file successfully on the server side, try other simple commands
    such as `cd` and `whoami`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器端成功获取文件后，尝试其他简单命令，如`cd`和`whoami`。
- en: Try typing an incorrect command and check whether you are getting the proper
    error message
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试输入一个错误命令，检查是否能得到正确的错误信息。
- en: At the end, terminate the session from our shell by executing the `terminate`
    command
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过执行`terminate`命令从Shell中终止会话。
- en: You can check to see that we have the `HTTP_Client.exe` process on our Windows
    machine; once we execute `terminate`, the process will disappear from the list
    confirming its termination
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以检查一下是否有`HTTP_Client.exe`进程在我们的Windows机器上；一旦我们执行`terminate`，该进程将从列表中消失，确认其终止。
- en: Persistence
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性
- en: Maintaining access is a very important phase of penetration testing. Let's assume
    that our target has run our shell and all things are going fine. Then suddenly,
    the target just turned off the computer. So, in this case, we'll lose everything.
    So, the key point here is that we need to survive after a reboot or a shutdown
    by the target machine. Now, before proceeding any further, some customers prohibit
    any modification to the target machine, so you've got to make sure you set the
    right expectations with your customer before proceeding any further.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 保持访问是渗透测试中一个非常重要的阶段。假设我们的目标已经运行了我们的Shell，所有事情都进行得很顺利。然后突然，目标机器关闭了电脑。这样的话，我们就会失去所有的访问权限。所以，这里关键的一点是，我们需要在目标机器重新启动或关机后能够继续生存下去。在继续之前，一些客户禁止对目标机器进行任何修改，因此在进一步操作之前，必须确保与你的客户设定好正确的期望。
- en: 'If the modification is allowed, then we have three phases of execution as given
    here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许进行修改，那么我们有三个执行阶段，如下所示：
- en: First, we'll copy ourselves in a different location and we are doing that just
    in case our target deletes the shell file; so this copy is a backup. In this phase,
    two parameters should be identified. First, the *source path*, which is the directory
    where our shell exists or, in other words, the current working directory. The
    second parameter is the *destination path;* here it is the `Documents` folder.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们会将自己复制到另一个位置，这样做是为了防止目标删除Shell文件；所以这份复制就是备份。在这个阶段，应该识别两个参数。第一个是*源路径*，即Shell文件所在的目录，换句话说，就是当前工作目录。第二个参数是*目标路径*；在这里是`Documents`文件夹。
- en: Since each PC has a different username, we'll have to find this out as we don't
    know the username profile that was on our target previously.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每台PC的用户名不同，我们需要弄清楚目标机器上以前的用户名是什么。
- en: In the second phase, after copying our shell into the `Documents` folder or
    `Documents` directory, we need to add a registry key and point it out to the copied
    file in the `Documents` folder. Keep in mind that the first and second phases
    should only run once after our backdoor gets installed on the target machine for
    the first time.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，将Shell复制到`Documents`文件夹或`Documents`目录后，我们需要添加一个注册表项，并将其指向`Documents`文件夹中的复制文件。请记住，第一阶段和第二阶段仅应在首次将后门安装到目标机器后执行一次。
- en: The third phase is to start our reverse shell without repeating the preceding
    2 phases.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三阶段是启动我们的反向Shell，而不重复之前的两个阶段。
- en: Since we don't know the current working directory or user profile, we've got
    to figure it out in the first place. This will happen in the system reconnaissance
    phase.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道当前的工作目录或用户配置文件，因此我们必须首先找出这些信息。这将在系统侦察阶段完成。
- en: 'Now, to break down the workflow for our persistence shell, take a look at this
    simple flowchart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了详细了解我们持久性Shell的工作流程，请看看这个简单的流程图：
- en: '![](../images/00029.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: Logically, we'll start with the system reconnaissance, Sys Reconn, phase and
    the output of this phase will include two things. First, we will discover the
    current working directory of our shell, and find out the user profile. The second
    output should be the destination path. Next, we need to determine whether we are
    running for the first time on the target machine. Now, you probably are wondering
    how can we do that. Well, thanks should go to the OS library for simplifying the
    task for us. To achieve this, we will simply check whether our script exists in
    the destination path or not. If it exists, then this is not the first time we
    are on the target side since we have already done the first two phases. So, we
    will skip phases 1 and 2, and fire up our shell.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，我们将从系统侦察阶段开始，这一阶段的输出将包括两项内容。首先，我们将发现我们的 shell 当前的工作目录，并找出用户配置文件。第二个输出应该是目标路径。接下来，我们需要判断是否第一次在目标机器上运行。你可能会问，我们怎么做到这一点呢？答案要感谢
    OS 库，它简化了我们的任务。为了实现这一点，我们只需检查脚本是否存在于目标路径中。如果存在，那么这就不是我们第一次到达目标机器，因为我们已经完成了前两个阶段。所以，我们将跳过第一和第二阶段，直接启动
    shell。
- en: However, if this is the first time we have run on the target side, we will copy
    ourselves to the destination path, which is what we do in phase 1\. Then, we add
    a new registry key pointing to this location, which is phase 2 here. Finally,
    we need to make sure that we get our connection back to the Kali server. In two
    upcoming sections, you'll see everything in action to provide more clarity on
    this concept. For ease of understanding, we'll break the coding part into two
    parts. In the first part, we will make  `putty.exe` persistent, and in the second
    part we will wrap up and integrate the persistent script with our previous HTTP
    reverse shell.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这是我们第一次在目标机器上运行，我们将把自身复制到目标路径，这就是我们在第一阶段所做的。然后，我们将添加一个新的注册表键，指向这个位置，这就是这里的第二阶段。最后，我们需要确保我们能够重新连接到
    Kali 服务器。在接下来的两个部分中，你将看到所有步骤的实际操作，以更清楚地理解这个概念。为了便于理解，我们将把编码部分分成两部分。在第一部分，我们将使
    `putty.exe` 持久化，在第二部分，我们将完成并将持久化脚本与之前的 HTTP 反向 shell 集成。
- en: Making putty.exe persistent
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 `putty.exe` 持久化
- en: In this section, we'll make the `putty.exe` program persistent. You can search
    on Google and download PuTTY software for free. As we explained earlier, our script
    will start by doing a system reconnaissance, and the output of this phase will
    either be the current working directory or the destination of the user profile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使 `putty.exe` 程序持久化。你可以在 Google 上搜索并免费下载 PuTTY 软件。正如我们之前所解释的，我们的脚本将从执行系统侦察开始，这一阶段的输出将是当前的工作目录或用户配置文件的目标位置。
- en: 'Now, let''s translate this phase into a block of code as shown here—these lines
    will perform the reconnaissance phase for us:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个阶段翻译成一段代码，如下所示——这些行将为我们执行侦察阶段：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `os.getcwd()` function will get the current working directory for us.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.getcwd()` 函数将为我们获取当前工作目录。'
- en: Now, on the `Desktop` we make a folder named `Persistence` with the `putty.exe`
    that we downloaded for this section and the `Presistance.py` script shown previously.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `Desktop` 上，我们创建一个名为 `Persistence` 的文件夹，里面放置我们为本节下载的 `putty.exe` 和之前提到的
    `Presistance.py` 脚本。
- en: 'Let''s see the output of the `os.getcwd()` line using the Python interactive
    shell or the Python interactive window:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 交互式 shell 或 Python 交互式窗口查看 `os.getcwd()` 这一行的输出：
- en: Open Command Prompt and navigate to the current working directory, which is
    Persistence. Start a Python interactive mode.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并导航到当前工作目录，即 Persistence。启动 Python 交互模式。
- en: Execute `import os` and `print os.getcwd()`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `import os` 和 `print os.getcwd()`。
- en: 'We get the current working directory here for our script. This result will
    be stored on the path variable:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里获取脚本的当前工作目录。这个结果将存储在路径变量中：
- en: '![](../images/00030.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: Looking back into the `Persistence.py` script, we invoke `set USERPROFILE` into
    the subprocess and use this step to grab the `USERPROFILE` name. Based on this,
    we can build our destination path, which is the `Documents` folder.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 `Persistence.py` 脚本，我们在子进程中调用 `set USERPROFILE`，并使用这一步骤获取 `USERPROFILE` 名称。根据这个信息，我们可以构建目标路径，即
    `Documents` 文件夹。
- en: Enter the preceding `set USERPROFILE` variable into the Command Prompt. The
    output will be a little noisy, so we will split the output and store the second
    part in a variable called `userprof`. The splitting criterion or parameter is
    based on the `=` sign. Based on this, we will split the output into two sections.
    The second section will be stored in a variable called `userprof`. Once we know
    this information, we can build our destination path, which is the `Documents`
    folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中输入上面的 `set USERPROFILE` 变量。输出可能会有些杂乱，因此我们将分割输出，并将第二部分存储在名为 `userprof`
    的变量中。分割标准或参数是基于 `=` 符号。根据这个标准，我们将把输出分成两部分。第二部分将存储在一个名为 `userprof` 的变量中。一旦我们知道了这些信息，就可以构建我们的目标路径，也就是
    `Documents` 文件夹。
- en: We append `Documents` and the `putty.exe` string to have the destination's absolute
    path. Notice that the `<UserName>` here is not unknown anymore. At this point,
    we have accomplished our reconnaissance phase successfully. Moving on to check
    whether it's the first time that we have landed on this computer, we'll do this
    trick via an OS function called `path.exists()`. If `putty.exe` does not exist
    in the `Documents` folder, this means that it is the first time we are running
    our script here because the next time PuTTY will be copied, and the result of
    this `if` statement, `if not os.path.exists(destination):`, will be `false`. Since
    this is our first time, we will copy  `putty.exe`, which is the source variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Documents` 和 `putty.exe` 字符串附加在一起，得到目标的绝对路径。请注意，这里的 `<UserName>` 不再是未知的了。此时，我们已经成功完成了侦查阶段。接下来，检查是否是第一次进入这台计算机，我们将通过一个操作系统功能
    `path.exists()` 来实现这个技巧。如果 `putty.exe` 不存在于 `Documents` 文件夹中，则意味着我们第一次在这里运行脚本，因为下次
    PuTTY 会被复制，`if` 语句 `if not os.path.exists(destination):` 的结果将为 `false`。由于这是我们的第一次，我们将复制
    `putty.exe`，它是源变量。
- en: 'Next, we will add a registry key in the user space. Note that we used a user
    space, not a machine space, on purpose. By using the user space, our script will
    work, even if we don''t have admin privileges. We''ve named the registry key string `RegUpdater`
    (you can change it later to anything else) and point its value to our final destination.
    Here, we don''t have a shell; it''s just `putty.exe`. So, this part will be discussed
    in the next section. Before running this script, let''s verify that we''ve got
    nothing in the registry database related to our script. Go to the Registry Editor by
    searching `regedit` at Windows Start, and our path will be `Computer\HKEY_CURRENT_USER|Software\Microsoft\Windows\CurrentVersion\Run`,
    as shown at the bottom of the following screenshot, which doesn''t have anything
    in it now other than the `(Default)` entry:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在用户空间中添加一个注册表项。请注意，我们故意使用了用户空间，而不是机器空间。通过使用用户空间，即使没有管理员权限，我们的脚本也能正常工作。我们将注册表键字符串命名为
    `RegUpdater`（你可以稍后改成任何你想要的名称），并将其值指向我们的最终目标。在这里，我们没有 shell，只是 `putty.exe`。因此，这部分内容将在下一节中讨论。在运行脚本之前，让我们先验证一下注册表数据库中是否与我们的脚本相关的内容。通过在
    Windows 开始菜单搜索 `regedit` 打开注册表编辑器，路径将是 `Computer\HKEY_CURRENT_USER|Software\Microsoft\Windows\CurrentVersion\Run`，如下图所示，目前除了
    `(Default)` 条目外，里面没有任何内容：
- en: '![](../images/00031.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: Now, navigate to the `Documents` folder and ensure that there is nothing left
    to be done. Lastly, make sure that the PuTTY software itself is functional by
    opening it directly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到 `Documents` 文件夹，确保没有任何事情需要做。最后，确保 PuTTY 软件本身可以正常运行，直接打开它。
- en: 'We''ll run the script right now. If we do not get an exception or error, we''ll
    verify the database of the registry. You''ll notice that we''ve got our registry
    key pointing to this directory in `Documents` and also PuTTY has been copied to
    the `Documents` directory:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在就运行脚本。如果没有遇到异常或错误，我们将验证注册表数据库。你会注意到，我们的注册表键指向了 `Documents` 目录，而且 PuTTY 也被复制到了
    `Documents` 目录：
- en: '![](../images/00032.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: Now, close everything and restart VirtualBox. Once we boot our machine, if everything
    is working fine, we should see that `putty.exe` has been executed and the PuTTY
    window should pop up.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关闭所有内容并重启 VirtualBox。启动虚拟机后，如果一切正常，我们应该会看到 `putty.exe` 已经执行，并且 PuTTY 窗口应该会弹出。
- en: In the next section, we will make our HTTP reverse shell more intelligent and
    perform all of these steps within a built-in function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使我们的 HTTP 反向 shell 更加智能，并在内置函数中执行所有这些步骤。
- en: Making a persistent HTTP reverse shell
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建持久化的 HTTP 反向 shell
- en: In this section, we will make our HTTP reverse shell, which we coded earlier.
    Then, we will export it to EXE, and give it a try and test it. Now, almost all
    of the hard work is done already and at this point you should be familiar with
    every part of the code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将制作之前编码的 HTTP 反向 shell。然后，我们将其导出为 EXE 文件，进行尝试并测试。现在，几乎所有的难点工作已经完成，在这一点上你应该已经熟悉代码的每个部分。
- en: So for a quick recap, what we've done here is change `putty.exe` to `Persistence.exe`,
    which will be our EXE filename. The destination part will be the same, that is,
    the `Documents` folder. Finally, we start our HTTP reverse shell as usual.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下，我们在这里做的事情是将 `putty.exe` 改为 `Persistence.exe`，这将是我们的 EXE 文件名。目标部分将保持不变，也就是
    `Documents` 文件夹。最后，我们像往常一样启动 HTTP 反向 shell。
- en: 'The setup file here will be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的安装文件将如下所示：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try and export this code to EXE and the name here will be `Persistence`.
    Once it''s done, it should be in the `dist` folder. Now, we will test it on a
    non-admin account just to show that no part on our shell requires admin privileges:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这段代码导出为 EXE，文件名将是 `Persistence`。完成后，它应该位于 `dist` 文件夹中。现在，我们将在非管理员账户上测试它，以展示我们的
    shell 不需要管理员权限：
- en: From Control Panel, create a standard user.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制面板创建一个标准用户。
- en: Create a quick password.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个快速密码。
- en: Copy the persistence file to `C:`; so we can grab that file from the nonstandard
    user once we log in to that account.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将持久性文件复制到 `C:` 目录；这样我们在登录该非标准用户账户后，就可以从那里获取该文件。
- en: Log off and log in with the new standard account.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销并使用新的标准账户登录。
- en: Find the `Persistence` file and copy it on the desktop.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `Persistence` 文件并将其复制到桌面。
- en: As usual, before running that shell, verify that we've got nothing in the registry
    database. This also applies for the `Documents` folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，在运行 shell 之前，验证注册表数据库中没有任何内容。这同样适用于 `Documents` 文件夹。
- en: Set up our listener on the Kali side, that is, run our HTTP server.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kali 端设置我们的监听器，也就是运行我们的 HTTP 服务器。
- en: Once done, notice that the registry key has been added successfully and at the
    end our file was able to find out the username and copy itself to the `Documents`
    folder successfully.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，注意到注册表项已成功添加，并且最终我们的文件能够成功识别用户名并将自己复制到 `Documents` 文件夹。
- en: Let's verify that our shell is working as expected. Start the Task Manager on
    the Windows machine.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证一下我们的 shell 是否按预期工作。在 Windows 机器上启动任务管理器。
- en: Let's start by running `ping 10.0.2.15` at the server side, which is the IP
    address of the Kali machine.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从在服务器端运行 `ping 10.0.2.15` 开始，这个地址是 Kali 机器的 IP。
- en: Check the `arp` table on the Windows side with `arp -a` and ensure that these
    commands are working fine.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `arp -a` 检查 Windows 端的 `arp` 表，并确保这些命令正常工作。
- en: After successfully terminating the process, we will delete the `Persistence.exe`
    file assuming that our target has deleted the shell file and restarted the client
    machine.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功终止进程后，我们将删除 `Persistence.exe` 文件，假设目标已经删除了 shell 文件并重新启动了客户端机器。
- en: Log in again and, if you can see the shell on the Kali machine, we've been successful
    with our task.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次登录，如果你在 Kali 机器上看到 shell，我们的任务就成功了。
- en: Tuning the connection attempts
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整连接尝试
- en: 'In all our previous sections, we have assumed that the attacker and the target
    machine are in sync with time. This means that our server was up and listening
    all the time. Now, the question is: What happens if the attacker machine was offline
    for some reason or the connection did not happen properly? Well, our backdoor
    on the client side will crash and at the same time give a pop up as an error message
    and dump a text file indicating an exception error.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的所有部分中，我们假设攻击者和目标机器的时间是同步的。这意味着我们的服务器一直处于启动和监听状态。现在，问题是：如果攻击者机器因某种原因离线或连接没有正确建立，会发生什么？那么，客户端上的后门将崩溃，并同时弹出一个错误信息框并生成一个文本文件，指示异常错误。
- en: 'Currently, our Kali machine is not listening on any port. So, if the attacker
    initiates a TCP SYN to make a connection with us, now, since the port is closed,
    our Kali machine will reply with a TCP RST. Now, let''s have a quick look at the
    packet level:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，我们的 Kali 机器没有在任何端口上监听。所以，如果攻击者发起 TCP SYN 请求与我们建立连接，由于端口关闭，我们的 Kali 机器将以 TCP
    RST 响应。现在，让我们快速看一下数据包级别：
- en: Enable Wireshark on the attacker machine by executing `sudo wireshark` and you
    can see that our script is not running there
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `sudo wireshark` 在攻击者机器上启用 Wireshark，你可以看到我们的脚本没有在那里运行。
- en: Start a new live capture
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动新的实时捕获
- en: Set the filter to TCP
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将过滤器设置为 TCP
- en: Log in on the Windows machine
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 机器上登录
- en: 'Since we are not listening to port `80`, we are replying  with TCP RST, as
    you can see in the following screenshot:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有监听端口`80`，我们正在回复 TCP RST，正如以下截图所示：
- en: '![](../images/00033.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: 'Also, on the target side, our script will crash and throws away an exception
    or log message. Navigate to the log file and you''ll see that it says connection
    aborted because the target machine actively refused it, as shown in the following
    screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在目标端，我们的脚本会崩溃并抛出异常或日志信息。进入日志文件，你会看到它显示连接已中止，因为目标机器主动拒绝了连接，如下图所示：
- en: '![](../images/00034.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'Log in with the `admin` account, where we have the Python compiler. So we''ll
    fix this issue by creating an infinite loop with an exception handler, as shown
    here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`admin`帐户登录，我们已安装了 Python 编译器。因此，我们将通过创建一个带有异常处理程序的无限循环来解决此问题，如下所示：
- en: '[PRE15]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, a new function called `connect()` is added to the script. So,
    using an exception handler, whatever the reason may be, if we get an exception
    for initiating the connection, we''ll sleep for some random time between 1 to
    10 seconds, and then try to connect again. In a real-world scenario, you''ve got
    to be more patient and make it from 1 to 10 minutes. In the end, we pass the exception
    instead of raising it here. Now, the question is: How to terminate the process,
    as we have two infinite loops? Since the single break command won''t do the job
    for us, the trick here is, if we terminate, then we will break the whole function
    and retain a value of `1`. And if the connection function retains the value of
    `1`, then we will break the second loop, which will terminate the process eventually.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个名为`connect()`的新函数已添加到脚本中。因此，使用异常处理器，无论是什么原因，如果在初始化连接时遇到异常，我们将暂停 1 到 10
    秒之间的随机时间，然后再尝试连接。在实际场景中，你需要更有耐心，将时间延长至 1 到 10 分钟。最后，我们传递异常，而不是抛出异常。现在，问题是：如何终止进程，因为我们有两个无限循环？由于单独的`break`命令无法完成任务，解决方法是，如果我们终止，那么整个函数将被中断，并保留一个值`1`。如果连接函数保留了`1`的值，那么我们将中断第二个循环，这样就能最终终止进程。
- en: 'Now, let''s quickly try and test this modification:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速尝试并测试这个修改：
- en: As we've done earlier, export the script to EXE
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，将脚本导出为 EXE
- en: Ensure that the `Documents` folder and the registry key are empty
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`Documents`文件夹和注册表项为空
- en: Double-click on `Persistence.exe` from the `dist` folder and run the script
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`dist`文件夹中的`Persistence.exe`并运行脚本
- en: 'And once we run our script here, notice that the target keeps trying to reach
    us until we run our server and the connection attempts here will be anywhere between
    1 to 10 seconds, as shown in the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里运行脚本时，注意到目标一直在尝试连接我们，直到我们运行服务器，连接尝试的时间会在 1 到 10 秒之间，如下图所示：
- en: '![](../images/00035.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: 'Now, once we start our listener on the server side, we have completed three-way
    handshakes and got the `GET` request from our target, as shown in the following
    screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们在服务器端启动监听器，完成三次握手，并从目标接收到`GET`请求，如下图所示：
- en: '![](../images/00036.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: Check whether the registry key is there and whether the script has copied itself
    to `Documents`. So, the last thing to test is whether the termination process
    is working or not. Ping `10.0.2.15` and perform a `terminate`. You can see that
    `Persistence.exe` is gone from the Windows Task Manager.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 检查注册表项是否存在，脚本是否已复制到`Documents`文件夹。最后一个要测试的事情是终止进程是否有效。Ping `10.0.2.15`并执行`terminate`。你会看到`Persistence.exe`已从
    Windows 任务管理器中消失。
- en: Tips for preventing a shell breakdown
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止 Shell 崩溃的小贴士
- en: As we have explained earlier, We created a shell by creating a subprocess and
    passing the commands to this subprocess. Now, the point is that some commands
    cannot work properly using this technique, such as the `cls` and `clear` commands,
    both of which will not work in a shell. Now, for instance, let's say that we were
    able to get a shell to the client PC and later on we discovered some kind of Telnet
    or FTP server connected on the same internal network. Unfortunately, we cannot
    use the built-in Telnet client in the operating system from our shell and this
    is because once we do so, the server will prompt us with a username and password;
    this is called the interactive method and the shell will fail to handle these
    types of interaction.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，我们通过创建一个子进程并将命令传递给该子进程来创建了一个 shell。现在，关键是有些命令无法通过这种技术正常工作，例如 `cls`
    和 `clear` 命令，这两个命令在 shell 中都无法执行。举个例子，假设我们能够将 shell 获取到客户端 PC，然后我们发现有某种 Telnet
    或 FTP 服务器连接在同一内部网络上。不幸的是，我们无法通过我们的 shell 使用操作系统内置的 Telnet 客户端，这是因为一旦我们这样做，服务器会提示我们输入用户名和密码；这就是所谓的交互式方法，而
    shell 无法处理这类交互。
- en: One solution is to use a special Python library called **Pexpect**. Pexpect
    allows your script to interact with an application just as if a human were typing
    these commands. Now, last but not least, always test the command locally in a
    VirtualBox before sending it to your target.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用一个特殊的 Python 库，叫做 **Pexpect**。Pexpect 允许您的脚本像人类输入命令一样与应用程序进行交互。最后但同样重要的是，在将命令发送给目标之前，务必先在
    VirtualBox 中本地测试该命令。
- en: There are couple of points to mention here. First, we have a problem with clear
    text. Now, all our traffic and file transfer was in clear text. This means that
    any IPS or network analyzer will easily pick up our commands and may block that
    connection or at least raise a flag to the system or the SOC team. Now, in [Chapter
    4](part0080.html#2C9D00-f5e5253c9e4346ba8f07a93bc319b4b2), *Catch Me If You Can!*,
    we will address this point by building a custom XOR encryption to encrypt all
    our traffic between the attacker and the target machine.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个要提到的要点。首先，我们遇到了明文传输的问题。现在，我们所有的流量和文件传输都是明文传输。这意味着任何 IPS 或网络分析器都能轻松捕捉到我们的命令，并且可能会阻止该连接，或至少会向系统或
    SOC 团队发出警告。现在，在[第 4 章](part0080.html#2C9D00-f5e5253c9e4346ba8f07a93bc319b4b2)《*抓住我吧！*》中，我们将通过构建自定义的
    XOR 加密来解决这个问题，确保攻击者与目标机器之间的所有流量都进行加密。
- en: 'The second point is: What if the hacker IP address was dynamically changed?
    Let''s say that the hacker is behind an ADSL or a proxy, where each time he connects
    to the internet his IP address will change. Remember that we configured our target
    to connect to a fixed IP address and eventually the connection will fail since
    that IP address will not be valid anymore.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要点是：如果黑客的 IP 地址发生动态变化怎么办？假设黑客位于 ADSL 或代理后面，每次连接到互联网时，IP 地址都会发生变化。记住，我们已经将目标配置为连接到固定的
    IP 地址，最终连接将会失败，因为该 IP 地址将不再有效。
- en: Countermeasures
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对策
- en: 'In this section, we will see how we can protect ourselves from the attacks
    we explained in this chapter. Now, if we think about it for a second: How could
    the attacker reach our internal host to begin with? Well, we rely on a social
    engineering attack along with a client-side attack to make it happen. The main
    key defense here is to start by securing people as they are the weakest points
    in the whole system. So you''ve got to start securing your staff on a regular
    basis with some management enforcement. Next, you should never rely on antivirus
    software, a sandbox, or VMware, as modern malware has built-in mechanisms to protect
    itself from being detected. Also, you should stay away from any suspicious software,
    especially cracked files. Before you install any software,if it was a legitimate
    software, verify file integrity using MD5 or the sha1 algorithm. If possible,
    use **Data Leaking Prevention** (**DLP**) to detect any file transfer on the endpoint
    or in the network transit path. Also, as a best practice, you can install something
    called **Host-Based Intrusion Detection System** (**HIDS**) to collect the operating
    system logs and notice any modification that is happening on the operating system
    logs. If possible, create a whitelist, and limit which process is allowed to run
    on the operating system. During the security awareness session, always inform
    nontechnical people to report any phishing email or suspicious files to the network
    security team or to the security operator or analyst.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何保护自己免受本章中解释的攻击。现在，如果我们思考一下：攻击者如何能够首先接触到我们的内部主机呢？嗯，我们依赖社会工程攻击以及客户端攻击来实现这一点。这里的主要防御关键是从保护人员开始，因为他们是整个系统中最薄弱的环节。因此，你必须开始定期保护你的员工，并加强管理执行。其次，你不应该依赖于杀毒软件、沙箱或VMware，因为现代恶意软件具有内置机制来保护自己免受检测。此外，你应该远离任何可疑软件，尤其是破解文件。在安装任何软件之前，如果是合法软件，使用MD5或sha1算法验证文件完整性。如果可能的话，使用**数据泄漏防护**（**DLP**）来检测终端或网络传输路径上的任何文件传输。此外，作为最佳实践，你可以安装称为**基于主机的入侵检测系统**（**HIDS**）来收集操作系统日志，并注意操作系统日志上发生的任何修改。如果可能的话，创建一个白名单，并限制哪些进程被允许在操作系统上运行。在安全意识培训中，始终告知非技术人员向网络安全团队、安全操作员或分析员报告任何钓鱼邮件或可疑文件。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by preparing our attacker and target machines, and
    then proceeded to learn and code TCP and an HTTP reverse shell. For each of these
    reverse shells, we looked into data exfiltration and exporting the Python script
    into `.exe`, which made the attack independent of the Python compiler. We learned
    how to make the connection persistent. We also looked into tuning connection attempts
    and countermeasures to prevent the attacks we learned about.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先准备了攻击者和目标机器，然后开始学习和编写TCP和HTTP反向shell。对于每个反向shell，我们研究了数据泄露和将Python脚本导出为`.exe`，这使得攻击独立于Python编译器。我们学会了如何使连接持久化。我们还研究了调整连接尝试和防范我们学到的攻击的对策。
- en: In the next chapter, we'll cover DDNS, interactive Twitter, countermeasures,
    replicating Metasploit screen capturing, target directory navigation, and integrating
    low-level port scanners.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖DDNS、交互式Twitter、对策、复制Metasploit屏幕捕获、目标目录导航以及集成低级端口扫描器。
