- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Pentesting Containerized Applications in GCP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCP中进行容器化应用的渗透测试
- en: If the organization you work for engages in DevOps or CI/CD application development,
    there’s an excellent chance that they have Docker or Kubernetes clusters in GCP.
    Let’s learn how to pentest them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你所在的组织从事DevOps或CI/CD应用程序开发，极有可能他们在GCP中有Docker或Kubernetes集群。让我们学习如何对它们进行渗透测试。
- en: In this chapter, I will explain what containerization is, why containerization
    is used, and how containerization works in general. We’ll learn how Docker and
    Kubernetes work in GCP and how to use Trivy with Docker- and Kubernetes-based
    applications in GCP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我将解释什么是容器化，为什么要使用容器化，以及容器化通常是如何工作的。我们将学习Docker和Kubernetes在GCP中的工作原理，以及如何在GCP中使用Trivy与基于Docker和Kubernetes的应用程序进行配合。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: How containerization works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化是如何工作的
- en: How Docker works in GCP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker在GCP中是如何工作的
- en: How Kubernetes works in GCP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes在GCP中是如何工作的
- en: Docker and Kubernetes pentesting techniques in GCP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GCP中进行Docker和Kubernetes的渗透测试技术
- en: So, let’s explore containerization in GCP!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们在GCP中探索容器化吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will work with Microsoft’s infrastructure. Massive Azure data centers will
    do the bulk of the computer processing work for the exercises in this chapter.
    So, fortunately, you don’t need to have a top-of-the-line workstation. You will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用微软的基础设施。庞大的Azure数据中心将为本章中的练习提供大量计算处理工作。因此，幸运的是，你不需要一台顶级的工作站。你需要以下设备：
- en: A web browser
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网页浏览器
- en: A desktop or laptop PC
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台桌面或笔记本电脑
- en: An Android or iPhone mobile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安卓手机或iPhone手机
- en: A good, reliable internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好的、可靠的互联网连接
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/404CEg8](https://bit.ly/404CEg8)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码演示：[https://bit.ly/404CEg8](https://bit.ly/404CEg8)
- en: How containerization works
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化是如何工作的
- en: Virtualization in computing is all about software simulating the functions of
    hardware. For example, my laptop is one computer. But on my computer, I can run
    software that pretends to be several different computers at the same time. (Thank
    goodness I expanded the RAM in my laptop to 64 GB, because each of those simulated
    computers could need 4 GB of memory!) The CPU, RAM, disk drive, and I/O device
    interfaces for each of those computers are simulated in the software. The software
    uses my laptop’s real CPU, RAM, disk drive, and I/O interfaces and allocates their
    capacity to make several imaginary computers. When operating systems and applications
    are installed in those imaginary computers, as far as the operating systems and
    applications know, they are each running on their own physical computer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机虚拟化是关于软件模拟硬件功能的。例如，我的笔记本电脑是一台计算机。但在我的电脑上，我可以运行一些软件，假装同时运行几台不同的计算机。（幸好我将笔记本电脑的内存扩展到了64GB，因为每台模拟计算机可能需要4GB的内存！）每台计算机的CPU、RAM、硬盘和I/O设备接口都在软件中被模拟。软件使用我笔记本电脑的实际CPU、RAM、硬盘和I/O接口，并分配它们的容量，以创建几台虚拟计算机。当操作系统和应用程序安装在这些虚拟计算机上时，就操作系统和应用程序本身而言，它们认为每台虚拟计算机都是在自己的物理计算机上运行。
- en: There are two common ways to deploy virtualization on cloud networks—VMs and
    containers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在云网络中部署虚拟化有两种常见方式——虚拟机和容器。
- en: VMs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机
- en: VMs are simulated computers, as I described in my example. Instead of directly
    running on PC or server machine hardware, a VM imitates all of the hardware components
    that are needed to run an operating system. In this model, my laptop runs a hypervisor
    that acts as a layer between the VMs and my physical computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: VMs是模拟计算机，正如我在示例中所描述的那样。它们并不是直接在PC或服务器硬件上运行，而是模拟运行操作系统所需的所有硬件组件。在这个模型中，我的笔记本电脑运行一个虚拟机监控器，它充当虚拟机与我的物理计算机之间的层。
- en: You can use an application on your own PC, such as Oracle VirtualBox or VMware
    Workstation Player, to work as a hypervisor for your VMs. All you need is a disk
    image file of an operating system you’d like to run in your VM, and then to configure
    it in your hypervisor. The operating systems don’t have to match your host operating
    system, and very often they don’t. I could run a Kali Linux VM on my Windows 11
    PC. You could run a Windows 11 VM on your MacBook. And I could run a macOS VM
    on my Kubuntu Linux desktop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在自己的PC上使用像Oracle VirtualBox或VMware Workstation Player这样的应用程序，作为虚拟机的虚拟机监控器。你所需要的只是一个操作系统的磁盘镜像文件，想要在虚拟机中运行该操作系统，然后在虚拟机监控器中进行配置。操作系统不需要与主机操作系统匹配，实际上它们通常并不匹配。我可以在我的Windows
    11 PC上运行一个Kali Linux虚拟机。你可以在你的MacBook上运行一个Windows 11虚拟机。我也可以在我的Kubuntu Linux桌面上运行一个macOS虚拟机。
- en: VMs can also be run on cloud platforms such as GCP. Then, the virtualized computer
    is running on one of Google’s computers, not on a computer you can physically
    touch on your own premises. VMs are a common use case for GCP, and they’re a good
    solution when a company wants to run single computers on GCP for a long time,
    such as to use as a web server or an email server. A lot of the websites you visit
    every day are hosted on VMs run on cloud platforms such as GCP!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机也可以在 GCP 等云平台上运行。这样，虚拟化计算机就运行在 Google 的计算机上，而不是你可以物理接触的自己设备上。虚拟机是 GCP 的一个常见使用案例，当公司希望长时间在
    GCP 上运行单一计算机时，虚拟机是一个不错的解决方案，例如作为 Web 服务器或邮件服务器。你每天访问的许多网站都托管在运行在云平台（如 GCP）上的虚拟机上！
- en: But VMs aren’t the best option when companies deploy massive dynamic applications,
    such as with DevOps or CI/CD methodologies that require them to be very scalable
    and responsive. The amount of computer processing power, memory, and network bandwidth
    a DevOps or CI/CD application requires could halve one day and double the next,
    whereas you can’t grow or shrink a VM’s hardware capacity as quickly or to the
    same extent. The hardware resources allocated to a VM are relatively static.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当公司部署大规模的动态应用时，虚拟机并不是最佳选择，例如使用 DevOps 或 CI/CD 方法论，这些方法要求应用具有高度可扩展性和响应能力。DevOps
    或 CI/CD 应用所需的计算处理能力、内存和网络带宽可能一天减少一半，第二天又增加一倍，而虚拟机的硬件容量无法像容器一样迅速变化。分配给虚拟机的硬件资源相对固定。
- en: Enter containerization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应运而生。
- en: Containers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: Docker and Kubernetes are two containerization orchestration platforms commonly
    used by companies today. A containerization orchestration platform will automatically
    launch and kill containers without needing direct human interaction. These platforms
    manage how containers are deployed, and also handle the load balancing within
    the virtualized hardware, allocating hardware resources such as CPU and memory
    only as much as is needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Kubernetes 是当今公司常用的两种容器化编排平台。容器化编排平台可以自动启动和终止容器，无需直接的人为操作。这些平台管理容器的部署，并处理虚拟化硬件内的负载均衡，只分配所需的硬件资源，如
    CPU 和内存。
- en: Cloud platforms have made containerized applications possible for companies
    and other sorts of enterprises. Google has massive computer networks and computer
    hardware resources in its various data centers around the world, a lot of which
    is dedicated to deploying GCP to its business customers all over the world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台使得公司和其他类型的企业能够实现容器化应用。Google 在全球各地的多个数据中心拥有庞大的计算机网络和硬件资源，其中很多资源专门用于向全球的商业客户提供
    GCP 服务。
- en: How Docker works in GCP
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 在 GCP 中的工作原理
- en: Docker isn’t the first containerization technology to exist, but it’s probably
    the first to be widely used by companies and organizations around the world. It
    also serves as the foundation for Kubernetes, the other popular way to deploy
    containers. Docker and Kubernetes aren’t competitors like Coca-Cola and Pepsi.
    Rather, Kubernetes is kind of a fork of Docker, like comparing Debian Linux to
    Ubuntu Linux (which is based on Debian).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 不是第一个存在的容器化技术，但它可能是第一个被全球公司和组织广泛使用的容器化技术。它也是 Kubernetes 的基础，Kubernetes
    是另一种流行的容器部署方式。Docker 和 Kubernetes 不是像可口可乐与百事可乐那样的竞争对手，而是 Kubernetes 是 Docker 的一个分支，就像将
    Debian Linux 和基于 Debian 的 Ubuntu Linux 进行对比一样。
- en: Here’s the basic architecture of a Docker containerization orchestration system
    (you can refer to [*Chapter 6*](B18672_06.xhtml#_idTextAnchor101) for the architecture
    diagram).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Docker 容器化编排系统的基本架构（你可以参考[*第六章*](B18672_06.xhtml#_idTextAnchor101)查看架构图）。
- en: The Docker host runs directly on your computer or on the computer you manage
    on a cloud service (such as **Google Compute Engine**, or **GCE**). In the Docker
    host, the Docker daemon stores Docker images and makes and manages containers
    based on those images. Docker images are very much like disk image ISO files for
    operating systems that you can use to make VMs. In fact, many Docker images are
    made with ordinary operating systems such as Ubuntu Linux. However, the images
    and their containers may not have all of the operating system components, but
    only as much as is needed to run your containerized application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 主机直接运行在你的电脑上，或在你管理的云服务上的计算机（例如 **Google Compute Engine**，或 **GCE**）。在
    Docker 主机中，Docker 守护进程存储 Docker 镜像，并根据这些镜像创建和管理容器。Docker 镜像非常像操作系统的磁盘镜像 ISO 文件，你可以使用这些镜像来创建虚拟机。事实上，许多
    Docker 镜像是使用普通操作系统（如 Ubuntu Linux）制作的。然而，这些镜像及其容器可能没有操作系统的所有组件，而仅包含运行容器化应用所需的部分。
- en: The Docker host connects to a registry, which is usually (but not always) hosted
    on an external network that’s most often the internet. The registry makes Docker
    images available for your Docker host to download. The registry also maintains
    those images and updates them like any other internet-hosted software, kind of
    like a Git repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker主机连接到注册表，通常（但不总是）该注册表托管在外部网络上，通常是互联网。注册表使Docker镜像可以供Docker主机下载。注册表还会维护这些镜像并像其他互联网托管的软件一样进行更新，类似于Git仓库。
- en: Finally, a Docker client running in a place such as your GCP console or on your
    endpoint in Docker Desktop is where you can execute commands to your Docker daemon
    (under the umbrella of your Docker host) in order to manage it. That’s how you
    send instructions to your Docker containerization orchestration system. We will
    be executing commands that way to a Docker system in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行在GCP控制台或Docker Desktop终端上的Docker客户端是你可以执行命令的地方，命令将传递给Docker守护进程（在你的Docker主机下）。这就是你如何向Docker容器化编排系统发送指令。在本章中，我们将通过这种方式向Docker系统执行命令。
- en: The default way to deploy a Docker containerization system in GCP uses Cloud
    Build to simplify the Docker build steps, and Cloud Run to help run containerized
    apps, all while your Docker host runs in GCE.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP中部署Docker容器化系统的默认方式是使用Cloud Build来简化Docker构建步骤，并利用Cloud Run来运行容器化的应用程序，同时Docker主机在GCE中运行。
- en: 'Here’s Google’s description of Cloud Build ([https://cloud.google.com/build](https://cloud.google.com/build)):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Google对Cloud Build的描述（[https://cloud.google.com/build](https://cloud.google.com/build)）：
- en: “*Cloud Build scales up and down with no infrastructure to set up, upgrade,
    or scale. Run builds in a fully managed environment in Google Cloud with connectivity
    to your own private network*.”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “*Cloud Build根据需要进行扩展和缩小，无需设置、升级或扩展基础设施。在Google Cloud中的完全托管环境中运行构建，并与您自己的私有网络连接*。”
- en: Cloud Build is a system that runs in the background when you deploy Docker containerization
    in GCP in the usual way. It spares developers the tedium of having to manage the
    servers that run your Docker containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build是一个在后台运行的系统，当你以常规方式在GCP中部署Docker容器化时，它会执行相关操作。它使开发人员免去管理运行Docker容器的服务器的繁琐工作。
- en: 'And here’s Google’s description of Cloud Run ([https://cloud.google.com/run/docs/overview/what-is-cloud-run](https://cloud.google.com/run/docs/overview/what-is-cloud-run)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Google对Cloud Run的描述（[https://cloud.google.com/run/docs/overview/what-is-cloud-run](https://cloud.google.com/run/docs/overview/what-is-cloud-run)）：
- en: “*Cloud Run allows developers to spend their time writing their code, and very
    little time operating, configuring, and scaling their Cloud Run service. You don’t
    have to create a cluster or manage infrastructure in order to be productive with
    Cloud Run*.”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “*Cloud Run使开发人员能够将更多时间花在编写代码上，而很少需要操作、配置和扩展Cloud Run服务。你不需要创建集群或管理基础设施就可以高效使用Cloud
    Run*。”
- en: Cloud Run is another system that runs in the background when you deploy Docker
    containerization in the usual way in GCP. It spares developers from having to
    tweak the computer processing configurations that execute their Docker containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run是另一个在后台运行的系统，当你以常规方式在GCP中部署Docker容器化时，它将为开发人员省去调整计算处理配置的麻烦，这些配置用于执行Docker容器。
- en: Now that we’ve looked at Docker in GCP, it’s time to learn about how Kubernetes
    works in GCP.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在GCP中使用Docker，接下来是时候学习Kubernetes在GCP中的工作原理。
- en: How Kubernetes works in GCP
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes在GCP中的工作原理
- en: Kubernetes can be used to deploy containerized applications in AWS and Azure.
    In *Chapters 6* and *9*, I walked you through deploying Kubernetes on those platforms,
    and we pentested them. But GCP is arguably the home of Kubernetes. Here’s why.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以用于在AWS和Azure上部署容器化应用程序。在*第6章*和*第9章*中，我带领你们了解了如何在这些平台上部署Kubernetes，并对其进行了渗透测试。但是，GCP可以说是Kubernetes的发源地。原因如下。
- en: Kubernetes was originally developed by a team at Google. The Kubernetes project
    was announced by Google cloud computing specialist Eric Brewer in 2014 ([https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes](https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes)).
    Kubernetes was inspired by some of the containerization innovations pioneered
    by Docker. But Kubernetes was mainly influenced by Borg ([https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/](https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/)),
    which was proprietary in-house cloud computing middleware that Google wanted to
    keep for its own purposes. Borg helps to run the backend for Gmail, Google Search,
    Google Maps, and a number of other popular Google services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 最初是由 Google 的一个团队开发的。Kubernetes 项目在 2014 年由 Google 云计算专家 Eric Brewer
    宣布（[https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes](https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes)）。Kubernetes
    的灵感来自于 Docker 所推动的一些容器化创新。但 Kubernetes 主要受到 Borg 的影响（[https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/](https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/)），Borg
    是 Google 用于内部目的的专有云计算中间件。Borg 帮助支撑 Gmail、Google 搜索、Google 地图和其他许多流行的 Google 服务的后台运行。
- en: Google’s Joe Beda, Brendan Burns, Brian Grant, Tim Hockin, and Craig McLuckie
    conceived of Kubernetes as being an open source platform that could be used for
    many of the same use cases Google deployed for Borg internally. By July 2015,
    the first version of Kubernetes was publicly released. By 2017, big tech companies
    and software developers including Red Hat (IBM), VMware, Docker, Inc., Microsoft
    Azure, and AWS all announced support for it. That’s the beauty of **open source
    software** (**OSS**) and open standards! And just as some organizations have multi-cloud
    networks that integrate services from AWS, Azure, and GCP, some organizations
    have both Docker and Kubernetes containerized applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 Joe Beda、Brendan Burns、Brian Grant、Tim Hockin 和 Craig McLuckie 将 Kubernetes
    构思为一个开源平台，可以用于许多 Google 在内部为 Borg 部署的相同用例。到 2015 年 7 月，Kubernetes 的第一个版本公开发布。到
    2017 年，Red Hat（IBM）、VMware、Docker, Inc.、Microsoft Azure 和 AWS 等大型科技公司和软件开发商都宣布支持它。这就是
    **开源软件**（**OSS**）和开放标准的魅力！正如一些组织拥有集成 AWS、Azure 和 GCP 服务的多云网络一样，一些组织同时也拥有 Docker
    和 Kubernetes 容器化应用。
- en: Here’s the basic architecture of a Kubernetes containerization orchestration
    system (you can refer to [*Chapter 6*](B18672_06.xhtml#_idTextAnchor101) for the
    architecture diagram).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Kubernetes 容器化编排系统的基本架构（你可以参考 [*第六章*](B18672_06.xhtml#_idTextAnchor101)
    查看架构图）。
- en: 'The control plane supports the entire containerization system and works as
    the vector between your Kubernetes-based network and the cloud platform, such
    as **Google Kubernetes Engine** (**GKE**) in GCP. The control plane contains a
    handful of components, including those listed here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面支持整个容器化系统，并作为 Kubernetes 基于的网络和云平台之间的载体，例如 GCP 中的 **Google Kubernetes Engine**（**GKE**）。控制平面包含几个组件，其中包括以下列出的组件：
- en: '**etcd** is a key-value store. It maintains data about all of your clusters.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd** 是一个键值存储。它维护着你所有集群的数据。'
- en: Pods run with the support of nodes, and **kube-scheduler** assigns nodes to
    newly created Pods.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods 在节点的支持下运行，**kube-scheduler** 会为新创建的 Pods 分配节点。
- en: '**kube-apiserver** manages the Kubernetes API. So, it helps your Kubernetes-based
    application integrate with external applications. It’s also where **kubectl**
    (**ctl** stands for **command-line tool**) connects to in order to send commands
    to your Kubernetes system.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-apiserver** 管理 Kubernetes API。因此，它帮助你的 Kubernetes 基于的应用程序与外部应用程序集成。这也是
    **kubectl**（**ctl** 代表 **命令行工具**）连接的地方，以便向你的 Kubernetes 系统发送命令。'
- en: '**kube-controller-manager** runs controller processes. There are controllers
    for maintaining nodes, controllers for executing scheduled jobs (such as “back
    up these files every day at 6 p.m.”), controllers to generate links between services
    and Pods, and controllers to create service accounts. Pods and nodes will be explained
    later in this section.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-controller-manager** 运行控制器过程。这里有用于维护节点的控制器、用于执行计划任务的控制器（例如，“每天晚上6点备份这些文件”）、用于在服务和
    Pods 之间生成链接的控制器，以及用于创建服务账户的控制器。Pods 和节点将在本节后面讲解。'
- en: '**cloud-controller-manager** connects your Kubernetes network to your cloud
    provider’s APIs. In GCP, **cloud-controller-manager** usually interfaces with
    GKE.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cloud-controller-manager**将你的Kubernetes网络连接到云提供商的API。在GCP中，**cloud-controller-manager**通常与GKE接口对接。'
- en: '*Nodes* are the control plane’s children. There could be 2 nodes, 20 nodes,
    or many different numbers of nodes according to what your application needs at
    any given time. Each node contains a kubelet. The kubelet is a node agent that
    registers the node with the API server using a hostname or another sort of identifier
    specific to the cloud provider.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*节点*是控制平面的子资源。根据应用程序的需求，节点的数量可能是2个、20个，或者更多。每个节点都包含一个kubelet。kubelet是一个节点代理，使用主机名或其他特定于云提供商的标识符将节点注册到API服务器。'
- en: '*Pods* are the children of nodes, which also makes Pods the grandchildren of
    the control plane. The kubelet in each node defines the nodes according to a PodSpec,
    which is written as a YAML or JSON file. It helps to know that YAML is similar
    in some ways to HTML, and JSON was created for use with JavaScript—two technologies
    that were developed for the web. YAML and JSON files can be viewed in a text editor,
    and sometimes they only have a few lines of code. The vulnerability scans you’ll
    be running as a pentester and in your red team engagements will sometimes scan
    YAML and JSON files depending on the situation. But you don’t need to know how
    to write your own YAML or JSON files for the purposes of this book.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*是节点的子资源，也因此是控制平面的孙子资源。每个节点中的kubelet根据PodSpec来定义节点，PodSpec是以YAML或JSON文件形式编写的。需要知道的是，YAML在某些方面类似于HTML，而JSON是为JavaScript使用而创建的——这两种技术都是为Web开发而产生的。YAML和JSON文件可以在文本编辑器中查看，有时它们仅包含几行代码。你在作为渗透测试员或红队成员进行漏洞扫描时，可能会扫描YAML和JSON文件，具体情况视情况而定。但本书的目的并不要求你学会编写自己的YAML或JSON文件。'
- en: Each Pod has a container runtime in which your containers run. Containers are
    made from container images that are like the ISO disk images of operating systems
    that are used in VMs. But a Kubernetes container image will have just the operating
    system components that are needed to execute the code that it’ll process. There
    are many default container images that can be used, and also, container images
    are sometimes custom-made for a particular company and its application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod都有一个容器运行时环境，容器在其中运行。容器是由容器镜像构成的，这些镜像类似于操作系统的ISO磁盘镜像，通常用于虚拟机中。但是，Kubernetes的容器镜像只包含执行代码所需的操作系统组件。可以使用许多默认的容器镜像，有时，容器镜像也会根据特定公司及其应用程序进行定制。
- en: Finally, the nodes (which contain Pods) interface with a load balancer, which
    helps manage the hardware and network resources that are needed at any given time.
    The load balancer also provides an interface between your Kubernetes-based application
    and your end users.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，节点（包含Pods）通过负载均衡器与外部交互，负载均衡器帮助管理任何给定时间所需的硬件和网络资源。负载均衡器还为基于Kubernetes的应用程序和终端用户之间提供了一个接口。
- en: As a cloud pentester, it helps to know that both the load balancer and the API
    servers can be vectors for cyber attacks on your Kubernetes application! The load
    balancer is most often subject to cyber attacks from an Ingress, north-south direction
    between your cloud and external networks, and the API servers are more often subject
    to attacks from an east-west direction between components within your cloud network.
    Sometimes, cyber attacks enter from the public internet through the ingress route
    and then travel between parts of a cloud network using lateral movement that may
    involve privilege escalation. That’s kind of like a burglar breaking into a department
    store’s jewelry department and then moving on to the fragrances and cosmetics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名云渗透测试员，了解负载均衡器和API服务器都可能成为针对Kubernetes应用的网络攻击的攻击面是很有帮助的！负载均衡器最常受到来自Ingress的网络攻击，Ingress的流量是从你的云与外部网络之间的南北方向流动的，而API服务器则更容易遭受来自云网络内部组件之间东西向的攻击。有时，网络攻击会通过入口路由从公共互联网进入，然后利用横向移动在云网络的不同部分之间传播，这可能涉及权限提升。这有点像小偷闯入百货商店的珠宝部，接着又转到香水和化妆品部。
- en: The entire Kubernetes containerization system is called a cluster. Some organizations
    may deploy multiple clusters. But no matter how many clusters an organization
    uses, each cluster is composed of a control plane, nodes, and Pods, in the order
    of bottom to top.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 整个Kubernetes容器化系统被称为集群。某些组织可能会部署多个集群。但是，无论组织使用多少个集群，每个集群都由控制平面、节点和Pods组成，顺序从底至顶。
- en: GKE ([https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine))
    is a GCP service that’s specially designed to run Kubernetes-based applications.
    It automates cluster and node management and how hardware resources are provisioned
    through the load balancer. The vast majority of the time, organizations both large
    and small will prefer to run Kubernetes applications in GCP through GKE.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GKE（[https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)）是一个专为运行基于
    Kubernetes 的应用程序而设计的 GCP 服务。它自动化了集群和节点管理，以及通过负载均衡器提供硬件资源的方式。在绝大多数情况下，大大小小的组织都会选择通过
    GKE 在 GCP 上运行 Kubernetes 应用程序。
- en: The beauty of cloud computing and containerization is that applications can
    be made to be very scalable, dynamic, and efficient with hardware resources. A
    lot of the drudgery of application deployment and network management can be automated.
    So, it’s natural that organizations will prefer to use GKE so that they aren’t
    burdened with server management tasks. A containerized application in the cloud
    can literally double and halve within days. There should always be just as much
    computing power and bandwidth as is needed at any given time, and containers sometimes
    only have a lifespan of hours.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算和容器化的优势在于，应用程序可以变得非常可扩展、动态且高效地使用硬件资源。很多应用程序部署和网络管理的繁琐工作可以通过自动化来完成。因此，组织自然会倾向于使用
    GKE，以免陷入服务器管理任务的困扰。在云中的容器化应用程序甚至可以在几天内实现翻倍或减半。无论何时，都应该根据需求提供足够的计算能力和带宽，而容器有时甚至只有几个小时的生命周期。
- en: It’s no wonder that cloud computing has revolutionized how all kinds of organizations
    of all sizes and in all industries deploy applications through the internet. However,
    the containerized applications that organizations deploy through the cloud can
    be just as attractive targets to cyber attackers as VMs deployed through the cloud.
    They interface with the internet, which provides an access route for attackers.
    And they can contain sensitive information that can make cyber criminals a lot
    of money, such as sensitive financial data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 难怪云计算彻底改变了各类组织在各行各业中通过互联网部署应用程序的方式。然而，组织通过云部署的容器化应用程序与通过云部署的虚拟机一样，可能成为网络攻击者的有吸引力的目标。它们与互联网连接，这为攻击者提供了访问的途径。而且，它们可能包含敏感信息，这些信息能为网络犯罪分子带来丰厚的回报，比如敏感的财务数据。
- en: Your job as a cloud pentester is to make sure you discover how an attacker could
    harm your client’s cloud networks before an attacker tries to do it. That way,
    the company you work for can improve its security accordingly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为云渗透测试员，你的任务是确保在攻击者尝试进行攻击之前，发现攻击者如何危害你客户的云网络。这样，你所在的公司就能相应地改进其安全措施。
- en: So, in the final set of hands-on pentesting exercises in this book, let’s get
    into pentesting Docker and Kubernetes in GCP!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书的最后一组实际渗透测试练习中，让我们开始在 GCP 中进行 Docker 和 Kubernetes 的渗透测试吧！
- en: Docker and Kubernetes pentesting techniques in GCP
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCP 中的 Docker 和 Kubernetes 渗透测试技术
- en: Now that we understand Docker and Kubernetes, let’s deploy them in GCP. Then,
    we’ll pentest them. First, let’s deploy the Docker and Kubernetes clusters that
    we’ll practice pentesting in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了 Docker 和 Kubernetes，让我们在 GCP 中部署它们。然后，我们将进行渗透测试。首先，让我们部署我们将练习渗透测试的 Docker
    和 Kubernetes 集群。
- en: Deploying Docker
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Docker
- en: 'We will use basic default Docker container images in our Docker deployment
    because we’re not doing anything fancy with it; we’re just trying out our pentesting
    tools! Follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Docker 部署中使用基本的默认 Docker 容器镜像，因为我们并没有做什么复杂的操作；我们只是试用我们的渗透测试工具！请按照以下步骤进行：
- en: The simplest way for us to deploy a Docker cluster in GCP is to start with Cloud
    Run. Use your web browser to log in to the Google Cloud account we set up in [*Chapter
    11*](B18672_11.xhtml#_idTextAnchor197). Once you’re in the GCP web console, go
    to [https://console.cloud.google.com/run](https://console.cloud.google.com/run)
    to use Cloud Run.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 GCP 中部署 Docker 集群的最简单方式是从 Cloud Run 开始。使用你的网络浏览器登录到我们在[*第 11 章*](B18672_11.xhtml#_idTextAnchor197)中设置的
    Google Cloud 帐号。进入 GCP 网页控制台后，访问 [https://console.cloud.google.com/run](https://console.cloud.google.com/run)
    使用 Cloud Run。
- en: 'The Cloud Run screen should look something like this:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cloud Run 界面应该像这样：
- en: '![Figure 12.1 – Cloud Run panel in the GCP console](image/B18672_12_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – GCP 控制台中的 Cloud Run 面板](image/B18672_12_01.jpg)'
- en: Figure 12.1 – Cloud Run panel in the GCP console
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – GCP 控制台中的 Cloud Run 面板
- en: 'Click on **+CREATE SERVICE** at the top, just underneath the top menu bar.
    You’ll see a screen that looks like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部菜单栏下方的 **+CREATE SERVICE**。你将看到一个像这样的界面：
- en: '![Figure 12.2 – Creating a Cloud Run service in GCP to run Docker](image/B18672_12_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 在 GCP 中创建 Cloud Run 服务以运行 Docker](image/B18672_12_02.jpg)'
- en: Figure 12.2 – Creating a Cloud Run service in GCP to run Docker
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 在 GCP 中创建 Cloud Run 服务以运行 Docker
- en: We will be using as many defaults as possible just to create a basic Docker
    environment to try our pentesting tools in. In situations where you may want to
    deploy a particular type of application with Docker containers, you may have to
    use different settings in Cloud Run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽可能使用默认设置，以便创建一个基础的 Docker 环境来尝试我们的渗透测试工具。如果你打算使用 Docker 容器部署某种特定类型的应用，可能需要在
    Cloud Run 中使用不同的设置。
- en: 'To keep it simple, these are the options I chose for my Docker deployment in
    Cloud Run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，以下是我为我的 Docker 部署在 Cloud Run 中选择的选项：
- en: At the top where it provides the **Deploy one revision from an existing container
    image** and **Continuously deploy new revisions from a source repository options**,
    I chose the first option.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部提供的**从现有容器镜像部署一个版本**和**从源代码仓库持续部署新版本**选项中，我选择了第一个选项。
- en: Next, instead of entering a container image URL, I clicked on **TEST WITH A**
    **SAMPLE CONTAINER**.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我没有输入容器镜像 URL，而是点击了**使用示例容器进行测试**。
- en: 'On this screen, I clicked on the **CONTAINER REGISTRY** tab and chose the **hello**
    demo container. Then, I clicked on **SELECT** next to the container image URL:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面，我点击了**容器注册表**选项卡，并选择了**hello**演示容器。然后，我点击了容器镜像 URL 旁的**选择**：
- en: '![Figure 12.3 – Choosing a Docker image for our Docker instance](image/B18672_12_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 为我们的 Docker 实例选择 Docker 镜像](image/B18672_12_03.jpg)'
- en: Figure 12.3 – Choosing a Docker image for our Docker instance
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 为我们的 Docker 实例选择 Docker 镜像
- en: In the **Service name** field, I entered **crawleydockertest**. I left my default
    region, which in my case is **us-central1 (lowa)**. Your default region might
    be something else. Each region represents a particular Google data center, and
    it may not even be in your country.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**服务名称**字段中，我输入了**crawleydockertest**。我保留了我的默认区域，对于我来说是**us-central1 (lowa)**。你的默认区域可能不同。每个区域代表一个特定的
    Google 数据中心，而且可能不在你的国家。
- en: To save money, under **CPU allocation and pricing**, I chose **CPU is only allocated
    during** **request processing**.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省费用，在**CPU 分配和定价**下，我选择了**仅在请求处理期间分配 CPU**。
- en: I left the **Autoscaling** option alone. By default, **0** is the minimum number
    of instances and **100** is the maximum. This sort of setting reflects the scalable
    nature of cloud applications. New instances can be automatically generated according
    to your application’s needs.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我没有更改**自动扩展**选项。默认情况下，**0** 是最小实例数，**100** 是最大实例数。这种设置反映了云应用的可扩展性。新实例可以根据应用的需求自动生成。
- en: Under **Ingress control**, I selected **All**, which will allow direct access
    to your service from the internet.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**入口控制**下，我选择了**全部**，这将允许从互联网直接访问你的服务。
- en: Under **Authentication**, I chose **Allow unauthenticated invocations**. These
    options may not be the best practices for cybersecurity, but they make trying
    out pentesting tools in our Docker application a lot easier.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**身份验证**下，我选择了**允许未经身份验证的调用**。这些选项可能不是最佳的网络安全实践，但它们使得在我们的Docker应用中尝试渗透测试工具变得更加简单。
- en: Finally, I clicked on the blue **CREATE** button at the bottom.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我点击了底部的蓝色**创建**按钮。
- en: 'Your web console screen will look like this as your service is created. The
    creation process took about 30 seconds for me; I wasn’t waiting very long:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当服务创建完成时，你的网页控制台界面应该会像这样。对于我来说，创建过程大约花了 30 秒；我并没有等待很长时间：
- en: '![Figure 12.4 – Creating a service for our Docker instance](image/B18672_12_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 为我们的 Docker 实例创建服务](image/B18672_12_04.jpg)'
- en: Figure 12.4 – Creating a service for our Docker instance
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 为我们的 Docker 实例创建服务
- en: Now that our Docker environment has been created in GCP, it’s time to make a
    Kubernetes environment!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Docker 环境已经在 GCP 中创建好了，接下来是创建 Kubernetes 环境！
- en: Deploying Kubernetes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Kubernetes
- en: 'It’s possible to deploy Kubernetes in Cloud Shell or in some other CLI. But
    I prefer to use the web console for deploying services and to use the CLI for
    pentesting tools. Follow the next steps to deploy Kubernetes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 或其他某些 CLI 中也可以部署 Kubernetes，但我更喜欢使用网页控制台来部署服务，使用 CLI 来进行渗透测试工具的操作。按照以下步骤部署
    Kubernetes：
- en: While logged in to GCP from the web and in the web console, go to [https://console.cloud.google.com/projectselector2/home/dashboard](https://console.cloud.google.com/projectselector2/home/dashboard).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCP的网页端登录并进入网页控制台后，访问[https://console.cloud.google.com/projectselector2/home/dashboard](https://console.cloud.google.com/projectselector2/home/dashboard)。
- en: 'For the time being, leave the project selector you just opened in one web browser
    tab. Open **Enable access to APIs** in another tab while using this link: [https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com](https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com,container.googleapis.com).'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，保持你刚刚打开的项目选择器网页标签不动。在另一个标签页中打开**启用API访问**，并使用此链接：[https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com](https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com,container.googleapis.com)。
- en: 'You will see a screen like this:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到如下界面：
- en: '![Figure 12.5 – Enabling the required API access for Kubernetes](image/B18672_12_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 为Kubernetes启用所需的API访问](image/B18672_12_05.jpg)'
- en: Figure 12.5 – Enabling the required API access for Kubernetes
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 为Kubernetes启用所需的API访问
- en: Click on **Confirm project**. **Enable APIs** will transition and say that you’re
    about to enable **Artifact Registry API** and **Kubernetes Engine API**. That’s
    exactly what we want to do. Click on **ENABLE**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确认项目**。**启用API**会过渡并显示你即将启用**Artifact Registry API**和**Kubernetes Engine
    API**。这正是我们要做的。点击**启用**。
- en: 'You may have to wait a few moments for your enabling of those APIs to process.
    I was surprised that this took more time than creating my Docker test container.
    But when that’s done, go back to your web browser tab with the project selector
    dashboard. That’ll look something like this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要等待几分钟才能完成API启用的处理。我很惊讶这比创建我的Docker测试容器还花了更多时间。但完成后，返回到带有项目选择器仪表板的网页标签。那应该看起来像这样：
- en: '![Figure 12.6 – Selecting a project in GCP for our Kubernetes instance](image/B18672_12_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 在GCP中为我们的Kubernetes实例选择一个项目](image/B18672_12_06.jpg)'
- en: Figure 12.6 – Selecting a project in GCP for our Kubernetes instance
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 在GCP中为我们的Kubernetes实例选择一个项目
- en: Click on a project. Make note of your project ID; it should be something similar
    to **blissful-axiom-115916**, as in the preceding screenshot.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一个项目。记下你的项目ID；它应该类似于**blissful-axiom-115916**，如前面的截图所示。
- en: 'Now, we will do the rest of the work in Cloud Shell in the CLI. Click on the
    icon that looks like this in the top menu bar on the right-hand side: **>_**.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在Cloud Shell的CLI中完成剩下的工作。点击右上角菜单栏中看起来像这样图标：**>_**。
- en: 'First, we’ll make sure that our selected project is the default by entering
    this at the command line:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将确保我们选择的项目是默认项目，方法是在命令行中输入以下命令：
- en: '[PRE0]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll create a default autopilot Kubernetes cluster with this command.
    If the region you set up earlier isn’t **us-central1**, then change it to the
    name of your region:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用此命令创建一个默认的自动驾驶Kubernetes集群。如果你之前设置的区域不是**us-central1**，则将其更改为你的区域名称：
- en: '[PRE1]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the *Code in Action* video of this exercise, it may take a
    few minutes for your cluster to be created. Be patient! Thankfully the command
    line in Cloud Shell will show you what’s going on while you wait.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你在本练习的*Code in Action*视频中所见，创建集群可能需要几分钟时间。耐心等待！幸运的是，Cloud Shell中的命令行会显示等待时的进展。
- en: 'After the several-minute process of creating your Kubernetes cluster is done,
    you next need to create authentication credentials for your cluster. This will
    make **kubectl** (the program you use to manage your Kubernetes cluster at the
    command line) ready to use your new cluster. Just be sure to change **us-central1**
    to the name of your region if it’s different:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Kubernetes集群的几分钟过程完成后，你接下来需要为集群创建身份验证凭证。这将使**kubectl**（你在命令行中用来管理Kubernetes集群的程序）准备好使用你的新集群。只要确保如果你的区域名称与**us-central1**不同，请更改为你所在的区域名称：
- en: '[PRE2]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’re going to create an application deployment in our new Kubernetes
    cluster with the following command. The directory path after **image=** is our
    default **hello** Kubernetes container image for testing purposes. If you want
    to do something specific with Kubernetes in GCP at some point after reading this
    book, you can modify the command to use a different container image:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下命令在新的Kubernetes集群中创建应用程序部署。**image=**后面的目录路径是我们默认的**hello** Kubernetes容器镜像，用于测试目的。如果你在读完本书后，想在GCP中使用Kubernetes做一些特定的操作，可以修改命令以使用不同的容器镜像：
- en: '[PRE3]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we need to set up the load balancer so that we can expose our deployment
    to the internet. We will be accessing our Kubernetes deployment through the internet
    in order to pentest it, so this step is absolutely necessary:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置负载均衡器，以便将我们的部署暴露到互联网上。我们将通过互联网访问我们的Kubernetes部署以进行渗透测试，所以这一步是绝对必要的：
- en: '[PRE4]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to run some checks to make sure our new Kubernetes Deployment
    is ready to use. First, let’s inspect the Pods:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要运行一些检查，以确保我们的Kubernetes部署已经准备好使用。首先，让我们检查一下Pods：
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The command line should show a **hello-server** Pod.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令行应该显示一个**hello-server** Pod。
- en: 'Now, we’ll inspect **hello-server**:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查**hello-server**：
- en: '[PRE6]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Copy the external IP that prints at the command line.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制命令行上打印出的外部IP。
- en: In a new web browser tab, enter **http://<your external IP here>** in the address
    bar and hit *Enter*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Web浏览器标签页中，在地址栏输入**http://<your external IP here>**并按*Enter*。
- en: My external connection to my Kubernetes Deployment was slow. But it eventually
    worked. I got an error in Firefox that warned me that the destination was HTTP
    and not HTTPS. I clicked the button to go to the HTTP site, and my screen showed
    this. It worked!
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我访问Kubernetes部署的外部连接较慢，但最终还是成功了。在Firefox中，我收到了一个错误提示，警告我目标是HTTP而非HTTPS。我点击了按钮，访问HTTP网站，屏幕上显示了这个内容。成功了！
- en: '![Figure 12.7 – Viewing the IP address for our Kubernetes Deployment in a web
    browser](image/B18672_12_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 在Web浏览器中查看我们的Kubernetes部署的IP地址](image/B18672_12_07.jpg)'
- en: Figure 12.7 – Viewing the IP address for our Kubernetes Deployment in a web
    browser
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 在Web浏览器中查看我们的Kubernetes部署的IP地址
- en: Now that we have both a working Docker environment and a working Kubernetes
    environment in GCP, it’s time to use those environments to try out some pentesting
    tools.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在GCP中已经有了一个正常工作的Docker环境和Kubernetes环境，是时候利用这些环境来尝试一些渗透测试工具了。
- en: Trivy
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trivy
- en: Trivy ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    is a pentesting tool that’s developed by Aqua Security and available on GitHub.
    It’s a security scanner that can find vulnerabilities in filesystems, VM images,
    and AWS. But it can also be used to scan Docker and Kubernetes images.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy ([https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy))
    是由Aqua Security开发的渗透测试工具，且可在GitHub上获取。它是一个安全扫描工具，可以在文件系统、虚拟机镜像和AWS中发现漏洞。同时，它也可以用来扫描Docker和Kubernetes镜像。
- en: 'Trivy can be run from Red Hat and CentOS, Arch Linux, and macOS. The installation
    instructions for all supported platforms can be found here: [https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/](https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/).
    The Linux VM I have running in my GCP deployment is based on Debian, so I’ll use
    the Debian installation instructions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy可以在Red Hat、CentOS、Arch Linux和macOS上运行。所有支持平台的安装说明可以在此处找到：[https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/](https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/)。我在GCP部署的Linux虚拟机基于Debian，因此我将使用Debian的安装说明：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have Trivy installed on our Linux VM in GCP, let’s try a couple
    of basic container scanning exercises. Trivy users and developers have a wide
    range of container pentesting tutorials on their website ([https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/](https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/))
    if you’d like to try some others.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在GCP的Linux虚拟机上安装了Trivy，让我们尝试几个基本的容器扫描练习。如果你想尝试其他的，Trivy用户和开发者在他们的网站上提供了广泛的容器渗透测试教程
    ([https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/](https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/))。
- en: 'Let’s try looking for misconfigurations in how I configured my Docker image.
    Remember—misconfigurations are security vulnerabilities that can be exploited
    by cyber attackers! Follow the next steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试寻找我配置Docker镜像时的错误配置。记住——错误配置是可以被网络攻击者利用的安全漏洞！按照以下步骤操作：
- en: 'I used GCP’s default **hello** test Docker image to build my Docker containers.
    This is its name and address:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我使用了GCP的默认**hello**测试Docker镜像来构建我的Docker容器。这是它的名称和地址：
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will need to verify the name and address of the image you used. In your
    GCP console, search for **Cloud Run**. You will then see a screen like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要验证你使用的镜像的名称和地址。在你的GCP控制台中，搜索**Cloud Run**。然后你将看到如下画面：
- en: '![Figure 12.8 – Viewing our Docker instance in the Cloud Run interface](image/B18672_12_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 在Cloud Run界面查看我们的Docker实例](image/B18672_12_08.jpg)'
- en: Figure 12.8 – Viewing our Docker instance in the Cloud Run interface
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 在Cloud Run界面查看我们的Docker实例
- en: I clicked on the name of my Docker cluster, which in my case is **crawleydockertest**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我点击了我的Docker集群的名称，在我的案例中是**crawleydockertest**。
- en: 'Then, I clicked on the **YAML** tab to see the YAML file that was used to build
    my Docker cluster. Where it says **image:** is where I found the name and address
    of the Docker image that I used. You can find yours the same way:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我点击了**YAML**选项卡，查看了用于构建我的Docker集群的YAML文件。在**image:**所在的位置，我找到了我使用的Docker镜像的名称和地址。你可以通过相同的方法找到你的镜像：
- en: '![Figure 12.9 – Viewing the YAML file that was used to create my Docker cluster](image/B18672_12_09.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 查看用于创建我的Docker集群的YAML文件](image/B18672_12_09.jpg)'
- en: Figure 12.9 – Viewing the YAML file that was used to create my Docker cluster
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 查看用于创建我的Docker集群的YAML文件
- en: 'Now, let’s run the scan:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行扫描：
- en: '[PRE9]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'My Docker image was found, and it was very misconfigured! Here are the results
    I got:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的Docker镜像找到了，而且配置非常错误！以下是我得到的结果：
- en: '![Figure 12.10 – Trivy scan output](image/B18672_12_010.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – Trivy扫描输出](image/B18672_12_010.jpg)'
- en: Figure 12.10 – Trivy scan output
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – Trivy扫描输出
- en: You could use this sort of data in your pentest report if you were conducting
    a real pentest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行实际的渗透测试，你可以在报告中使用这种类型的数据。
- en: 'Now, let’s try Trivy to conduct a pentest against my Kubernetes cluster in
    GCP:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用Trivy对我在GCP中的Kubernetes集群进行渗透测试：
- en: 'First, I found that I had to expose my Kubernetes cluster again in order for
    Trivy to be able to scan it:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我发现我需要再次暴露我的Kubernetes集群，以便Trivy能够扫描它：
- en: '[PRE10]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, I inspected the Pods:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我检查了Pods：
- en: '[PRE11]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, here’s a Trivy command that conducted a very thorough scan of my Kubernetes
    cluster:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这里有一个Trivy命令，对我的Kubernetes集群进行了非常彻底的扫描：
- en: '[PRE12]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After a few minutes in the Cloud Shell CLI, I got a very detailed summary that
    I could use in a pentest report:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Cloud Shell CLI中等待了几分钟后，我得到了一个非常详细的总结，可以用于渗透测试报告中：
- en: '![Figure 12.11 – Trivy scan vulnerability report](image/B18672_12_011.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – Trivy扫描漏洞报告](image/B18672_12_011.jpg)'
- en: Figure 12.11 – Trivy scan vulnerability report
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – Trivy扫描漏洞报告
- en: Trivy is a lot of fun to explore!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy非常有趣，值得探索！
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned which services manage containerization in GCP. We
    deployed our own Docker and Kubernetes clusters. Then, we conducted a security
    assessment with Trivy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了GCP中哪些服务负责容器化管理。我们部署了自己的Docker和Kubernetes集群。然后，我们使用Trivy进行了安全评估。
- en: The default way to deploy a Docker containerization system in GCP uses Cloud
    Build to simplify the Docker build steps and Cloud Run to help run containerized
    apps, all while your Docker host runs in GCE.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP中部署Docker容器化系统的默认方式是使用Cloud Build简化Docker构建步骤，使用Cloud Run帮助运行容器化应用，同时Docker主机运行在GCE中。
- en: The simplest way to deploy Kubernetes in GCP is to use GKE.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP中部署Kubernetes的最简单方式是使用GKE。
- en: Trivy is a third-party pentesting application that has lots of great features
    for vulnerability scanning both Docker and Kubernetes deployments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy是一个第三方渗透测试应用，具有许多出色的功能，用于扫描Docker和Kubernetes部署的漏洞。
- en: In the next and final chapter, I’ll quiz you on what we’ve learned in the previous
    12 chapters. Plus, I’ll give you tips for writing and signing pentesting contracts,
    more tips for writing pentest reports, and introduce you to cloud and pentesting-related
    certifications that may make you more employable as a cloud pentester.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一章，我将测试你对前12章所学内容的掌握情况。此外，我还会给你一些编写和签署渗透测试合同的技巧，更多的渗透测试报告写作建议，并向你介绍一些云计算和渗透测试相关的认证，这些认证可能会使你作为云渗透测试员更具竞争力。
- en: Further reading
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，你可以访问以下链接：
- en: '*Google Cloud* *Run*: [https://cloud.google.com/run](https://cloud.google.com/run'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud* *Run*: [https://cloud.google.com/run](https://cloud.google.com/run)'
- en: )
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Google Cloud* *Build*: [https://cloud.google.com/build](https://cloud.google.com/build'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud* *Build*： [https://cloud.google.com/build](https://cloud.google.com/build)'
- en: )
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*GKE*: [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GKE*: [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)'
- en: )
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Google Cloud documentation on deploying containers to Cloud* *Run*: [https://cloud.google.com/run/docs/deploying](https://cloud.google.com/run/docs/deploying'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud文档关于将容器部署到Cloud* *Run*： [https://cloud.google.com/run/docs/deploying](https://cloud.google.com/run/docs/deploying)'
- en: )
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Google Cloud documentation on deploying Kubernetes applications in* *GKE*:
    [https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster](https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud文档：在* *GKE*中部署Kubernetes应用： [https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster](https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster)'
- en: )
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Trivy*: [https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Trivy*：[https://github.com/aquasecurity/trivy](https://github.com/aquasecurity/trivy)'
