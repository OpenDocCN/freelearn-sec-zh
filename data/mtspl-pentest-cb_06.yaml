- en: Chapter 6. Advanced Meterpreter Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。高级Meterpreter脚本
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖：
- en: Passing the hash
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递哈希
- en: Setting up a persistent connection with backdoors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置持久连接与后门
- en: Pivoting with meterpreter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用meterpreter进行枢纽
- en: Port forwarding with meterpreter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用meterpreter进行端口转发
- en: Meterpreter API and mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meterpreter API和mixin
- en: Railgun - converting ruby into a weapon
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Railgun-将Ruby转换为武器
- en: Adding DLL and function definitions to Railgun
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将DLL和函数定义添加到Railgun
- en: Building a "Windows Firewall De-activator" meterpreter script
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建“Windows防火墙停用器”meterpreter脚本
- en: Analyzing an existing meterpreter script
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析现有的meterpreter脚本
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned about several powerful meterpreter commands
    which can be very helpful in post-exploitation. Meterpreter adds a lot of flexibility
    to the post-exploitation process by providing a very interactive and useful command
    interpreter. It not only eases the task, but also makes it more powerful and comprehensive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了一些强大的meterpreter命令，这些命令在后期利用中非常有帮助。Meterpreter通过提供一个非常交互式和有用的命令解释器，为后期利用过程增加了很多灵活性。它不仅简化了任务，而且使其更加强大和全面。
- en: In this chapter, we will take meterpreter a step ahead by learning some advanced
    concepts. So far, we have been using various commands and scripts that Metasploit
    provides to us, but during the process of penetration testing, a situation may
    arise when you will have to add your own scripts to meterpreter. The modular architecture
    of the platform makes it very easy to develop and integrate your own scripts and
    modules.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过学习一些高级概念，将meterpreter推进一步。到目前为止，我们一直在使用Metasploit提供给我们的各种命令和脚本，但在渗透测试过程中，可能会出现需要向meterpreter添加自己的脚本的情况。平台的模块化架构使得开发和集成自己的脚本和模块非常容易。
- en: We will start this chapter by learning some advanced meterpreter functionalities
    such as passing the hash, pivoting, port forwarding, and so on. Then, we will
    move to developing our own meterpreter scripts. In order to understand this chapter
    completely, you should be aware of the basic Ruby concepts. Even a basic idea
    about the Ruby language can help you in building smart meterpreter scripts. In
    order to facilitate the readers, I will start with some basic development concepts.
    Then, we will analyze some existing Ruby codes and see how we can reuse them or
    edit them according to our needs. Then, we will learn to develop our own simple
    "Windows Firewall De-activator" meterpreter script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习一些高级的meterpreter功能开始，比如传递哈希、枢纽、端口转发等等。然后，我们将转向开发我们自己的meterpreter脚本。为了完全理解本章，您应该了解基本的Ruby概念。即使对Ruby语言有基本的了解也可以帮助您构建智能的meterpreter脚本。为了方便读者，我将从一些基本的开发概念开始。然后，我们将分析一些现有的Ruby代码，看看我们如何可以重用它们或根据我们的需求进行编辑。然后，我们将学习开发我们自己简单的“Windows防火墙停用器”meterpreter脚本。
- en: The chapter will enhance your understanding about the platform in detail. So
    let us move ahead and start working out the recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细增强您对平台的理解。让我们继续前进，开始实践这些技巧。
- en: Passing the hash
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希传递
- en: Passing the hash or hashdump is the process of extracting the Windows logon
    hash files. Hashdump meterpreter script extracts and dumps the password hashes
    from the target machine. Hashes can be used to crack the logon passwords and gain
    authorized entry into other systems on the LAN for future pen tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传递哈希或哈希转储是提取Windows登录哈希文件的过程。Hashdump meterpreter脚本从目标机器中提取并转储密码哈希。哈希可以用于破解登录密码，并获得对LAN上其他系统的授权访问，以进行未来的渗透测试。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before starting with the recipe, let us first understand about Windows passwords
    and their storage format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始烹饪之前，让我们先了解一下Windows密码及其存储格式。
- en: 'When you type your password into the Windows Logon screen, it encrypts your
    password using an encryption scheme that turns your password into something that
    looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Windows登录屏幕上输入密码时，它会使用一个加密方案对您的密码进行加密，将您的密码转换成类似于这样的东西：
- en: '`7524248b4d2c9a9eadd3b435c51404ee`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`7524248b4d2c9a9eadd3b435c51404ee`'
- en: This is a password hash. This is what is actually being checked against when
    you type your password in. It encrypts what you typed and bounces it against what
    is stored in the registry and/or SAM file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个密码哈希。这实际上是在您输入密码时进行检查的内容。它会加密您输入的内容，并将其与存储在注册表和/或SAM文件中的内容进行比对。
- en: The SAM file holds the usernames and password hashes for every account on the
    local machine, or domain if it is a domain controller. It can be found on the
    hard drive in the folder `%systemroot%system32config`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SAM文件保存了本地机器上每个帐户或域（如果是域控制器）的用户名和密码哈希。它可以在硬盘驱动器的`%systemroot%system32config`文件夹中找到。
- en: However, this folder is locked to all accounts including Administrator while
    the machine is running. The only account that can access the SAM file during operation
    is the "System" account. So, you will have to keep in mind that you need an escalated
    privilege while you are trying to dump the hashes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有在机器运行时，这个文件夹才对包括管理员在内的所有帐户进行了锁定。在操作过程中，唯一可以访问SAM文件的帐户是“系统”帐户。因此，您必须记住，在尝试转储哈希时，您需要提升权限。
- en: Hashes will appear completely alien to you as they are encrypted text. Windows
    uses the **NTLM (NT LAN Manager)** security protocol to provide authentication.
    It is the successor of the LM protocol which was used in the older versions of
    Windows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希对您来说可能完全陌生，因为它们是加密文本。Windows使用**NTLM（NT LAN Manager）**安全协议进行身份验证。它是LM协议的后继者，LM协议用于旧版本的Windows。
- en: In order to decode the dumped hashes, we will require a NTLM/LM decryptor. There
    are different tools available for it. Some of them use a brute force technique
    (John the riper, pwdump) while some use rainbow tables (rainbow crack).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码转储的哈希，我们将需要一个NTLM/LM解密器。有不同的工具可用。其中一些使用暴力破解技术（John the riper，pwdump），而另一些使用彩虹表（彩虹破解）。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start with an active meterpreter session. I am assuming that you have
    penetrated the target and gained a meterpreter session. You can refer to recipes
    in [Chapter 4](ch04.html "Chapter 4. Client-side Exploitation and Antivirus Bypass"),
    *Client-side Exploitation and Antivirus Bypass* for more details on compromising
    a windows machine. The use of script is simple and straightforward. Let us first
    check our privilege on the target machine. We must have the system privilege in
    order to extract the hashes. We will be using the `getuid` command to know our
    current privilege level. To escalate our privilege, we will use the `getsystem`
    command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个活动的meterpreter会话开始。我假设您已经渗透了目标并获得了一个meterpreter会话。您可以参考[第4章](ch04.html
    "第4章。客户端利用和防病毒绕过")中的配方，*客户端利用和防病毒绕过*，以获取有关入侵Windows机器的更多详细信息。脚本的使用简单直接。让我们首先检查目标机器上的权限。我们必须拥有系统权限才能提取哈希。我们将使用`getuid`命令来了解我们当前的权限级别。为了提升我们的权限，我们将使用`getsystem`命令。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Now we have system privileges on the target, so we can move ahead and try the
    hashdump script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在目标上拥有系统权限，所以我们可以继续尝试hashdump脚本。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that the script has successfully extracted the password hashes from
    the SAM file. Now we can use different tools to crack this hash. Some of the well-known
    tools are John the riper, pwdump, rainbow crack, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到脚本已成功从SAM文件中提取了密码哈希。现在我们可以使用不同的工具来破解这个哈希。一些知名的工具有John the riper、pwdump、rainbow
    crack等。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us look at an alternate method of decrypting the hash, other than using
    the tools discussed earlier.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看除了使用之前讨论的工具之外，解密哈希的另一种方法。
- en: Online password decryption
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线密码解密
- en: 'There is a very popular website for decrypting the NTLM/LM hashes [http://www.md5decrypter.co.uk/](http://www.md5decrypter.co.uk/).
    It finds out the password by matching the hash with its huge database of hashes
    to find a match. It is an effective and fast technique for breaking simple and
    weak passwords. The following screenshot shows the result of decoding the hash
    that we dumped previously:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常流行的网站用于解密NTLM/LM哈希[http://www.md5decrypter.co.uk/](http://www.md5decrypter.co.uk/)。它通过将哈希与其庞大的哈希数据库进行匹配来找到密码。这是一种有效且快速破解简单和弱密码的技术。以下截图显示了我们之前转储的哈希的解码结果：
- en: '![Online password decryption](img/7423_06_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![在线密码解密](img/7423_06_01.jpg)'
- en: As you can see, a match has been found for our input hash and the corresponding
    readable password is 123.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的输入哈希已找到匹配项，相应的可读密码为123。
- en: 'A point to note here is that cracking passwords depends totally upon the strength
    of it. A weaker password will be fairly easy to crack compared to a complex one.
    Complex passwords will generate hashes which are not present in the online databases.
    Hence, consider using rainbow table-based crackers. More information on this subject
    can be found at the following URL:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，破解密码完全取决于其强度。相对于复杂密码，较弱的密码会更容易破解。复杂密码将生成在线数据库中不存在的哈希。因此，考虑使用基于彩虹表的破解器。有关此主题的更多信息可以在以下URL找到：
- en: '[http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html](http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html](http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html)。'
- en: Setting up a persistent connection with backdoors
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立与后门的持久连接
- en: We started this book with a pre-exploitation technique where we focused on information
    gathering. Then, we moved ahead to the exploitation phase where we learned different
    ways of compromising the target. Then, we learned some useful post-exploitation
    techniques that can be implemented after compromising the target. Now, in this
    recipe we will learn the **ever-exploitation technique** in which we will try
    to establish a persistent connection with our target, so that we can connect to
    it at our will. As the attacker, or the target machine, cannot be always available,
    backdooring the target can be effective for setting persistent connections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个预入侵技术开始这本书，重点是信息收集。然后，我们继续前进到利用阶段，在那里我们学习了不同的方式来妥协目标。然后，我们学习了一些有用的后期利用技术，可以在妥协目标之后实施。现在，在这个配方中，我们将学习**永久利用技术**，在这里我们将尝试与我们的目标建立持久连接，以便我们可以随意连接到它。作为攻击者，或目标机器，不能总是可用，对目标进行后门处理可以有效地建立持久连接。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Meterpreter provides us with two scripts which can perform the task of backdooring
    the target. They are Metsvc and Persistence. The working of both the scripts is
    similar. Let us deal with both these scripts one by one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter为我们提供了两个脚本，可以执行对目标进行后门处理的任务。它们是Metsvc和Persistence。这两个脚本的工作方式类似。让我们逐一处理这两个脚本。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both these meterpreter scripts create files on the target system so it can trigger
    alarms in the antivirus. So it is recommended to kill the antivirus program before
    running these scripts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个meterpreter脚本都在目标系统上创建文件，因此可能会触发防病毒软件的警报。因此建议在运行这些脚本之前关闭防病毒程序。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The Metsvc script works by creating temporary files such as the DLLs, the backdoor
    server, and the service on the target machine. The script can also start a matching
    multi/handler to automatically connect back to the backdoor. `-A` parameter is
    used for this purpose. Let us run the script on our Windows 7 target machine and
    analyze the result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Metsvc脚本通过在目标机器上创建临时文件，如DLL、后门服务器和服务来运行。该脚本还可以启动匹配的multi/handler以自动连接到后门。`-A`参数用于此目的。让我们在我们的Windows
    7目标机器上运行脚本并分析结果。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the backdoor files are uploaded successfully, it will automatically connect
    back to the multi/handler on port 31337\. Using this backdoor, we can easily connect
    to the target machine at our will.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦后门文件成功上传，它将自动连接到端口31337上的multi/handler。使用这个后门，我们可以随意连接到目标机器。
- en: Another useful backdooring script to look for is the persistence script. It
    works similar to Metscv, but it has some extra features like connecting back to
    the target at regular intervals, connecting back on system boot, autorun, and
    so on. Let us look at the different options available to us.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的后门脚本是持久性脚本。它的工作方式类似于Metscv，但它具有一些额外的功能，比如定期连接回目标，系统启动时连接回来，自动运行等等。让我们看看我们可以使用的不同选项。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see it has some extra options compared to Metsvc. Let us execute
    the script and pass different parameters according to our requirements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它与Metsvc相比有一些额外的选项。让我们执行脚本，并根据我们的需求传递不同的参数。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Notice the different parameters passed along with the script. The `-A` parameter
    automatically starts a listener on the attacking machine. The `-S` operator sets
    the backdoor to load every time Windows boots up. The `-U` operator executes the
    backdoor every time the user logs into the system. The `-i` operator sets the
    interval after which the backdoor will try to connect back to the agent handler.
    `-p` is the port number and `-r` is the IP address of the target machine. The
    output of the script execution also contains some useful information. The script
    has created a resource file for cleanup so that you can remove the backdoor after
    use. The script has created a vbs file in the `temp` folder on the target machine.
    Also it has created registry entries to auto load the backdoor every time Windows
    boots.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意脚本传递的不同参数。`-A` 参数会在攻击机器上自动启动监听器。`-S` 操作符设置后门在每次 Windows 启动时加载。`-U` 操作符在用户登录系统时执行后门。`-i`
    操作符设置后门尝试连接回代理处理程序的间隔。`-p` 是端口号，`-r` 是目标机器的IP地址。脚本执行的输出还包含一些有用的信息。脚本已经创建了一个资源文件用于清理，以便在使用后删除后门。脚本已经在目标机器的`temp`文件夹中创建了一个vbs文件。它还创建了注册表条目，以便在每次
    Windows 启动时自动加载后门。
- en: We have provided an interval of 60 seconds for the backdoor to connect back
    to the agent handler. After successful execution of the script, you will see that
    at an interval of 60 seconds a meterpreter session will be opened automatically
    on the target machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为后门设置了60秒的间隔，以便连接回代理处理程序。在脚本成功执行后，您将看到在60秒的间隔内，meterpreter会自动在目标机器上打开一个会话。
- en: This quick demonstration explains how we can set up a persistent connection
    with our target machine. You can try out different scenarios with these two scripts
    and analyze its working. In the next recipe, we will focus on another interesting
    concept called pivoting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速演示解释了我们如何与目标机器建立持久连接。您可以尝试使用这两个脚本进行不同的场景，并分析其工作原理。在下一个示例中，我们将专注于另一个有趣的概念，称为转向。
- en: Pivoting with meterpreter
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用meterpreter进行转向
- en: So far, we have covered most of the major meterpreter commands and script. You
    must have noticed how powerful meterpreter can be during post exploitation phase.
    In this recipe, we will discuss one of the coolest and my favorite concept called
    pivoting. Let us begin with the recipe by first understanding the meaning of pivoting,
    why is it needed and at last how can Metasploit be useful for pivoting.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了大部分主要的meterpreter命令和脚本。您一定已经注意到了在后期利用阶段，meterpreter可以有多么强大。在这个示例中，我们将讨论一个最酷的，也是我最喜欢的概念之一，称为转向。让我们从理解转向的含义开始，为什么需要它，最后Metasploit如何在转向中有用。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting with the recipe, let us first understand pivoting in detail.
    Pivoting refers to the method used by penetration testers that uses a compromised
    system to attack other systems on the same network. This is a multi-layered attack
    in which we can access even those areas of the network which are only available
    for local internal use such as the intranet. Consider the scenario shown in the
    following diagram.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用这个示例之前，让我们首先详细了解转向。转向是指渗透测试人员使用 compromise 的系统来攻击同一网络上的其他系统的方法。这是一个多层次的攻击，在这个攻击中，我们可以访问甚至那些仅供本地内部使用的网络区域，比如内部网。考虑下面图中显示的情景。
- en: '![Getting ready](img/7423_06_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/7423_06_02.jpg)'
- en: The attacker can compromise the outside nodes of a network which are connected
    to the Internet. These nodes are then connected with a firewall. Behind the firewall
    is the main server. Now since the attacker has no access to the server, he can
    use the nodes as a medium to access it. If the attacker can successfully compromise
    the node then it can further penetrate the network to reach up to the server as
    well. This is a typical scenario that involves pivoting. The red lines in the
    diagram show the pivoted path set up between the attacker and server through the
    compromised node. In this recipe, we will be using some of the meterpreter networking
    commands which we learned in the previous chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以 compromise 与互联网连接的网络的外部节点。然后这些节点与防火墙连接。防火墙后面是主服务器。现在，由于攻击者无法访问服务器，他可以使用节点作为访问的媒介。如果攻击者成功地
    compromise 了节点，那么它可以进一步渗透网络，以达到服务器。这是涉及转向的典型情况。图中的红线显示了通过 compromise 的节点在攻击者和服务器之间建立的转向路径。在这个示例中，我们将使用我们在上一章中学到的一些meterpreter网络命令。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us see how we can implement the previously discussed scenario using meterpreter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用meterpreter实现先前讨论的情景。
- en: In this example, our target node is a Windows 7 machine which is connected to
    a network. The server is running on Windows 2003\. The node has been compromised
    by using client-side browser vulnerability and we have an active meterpreter connection
    established. Let us start with running an ipconfig on the target node to see the
    available interfaces on it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的目标节点是运行在Windows 7上并连接到网络的机器。服务器运行在Windows 2003上。通过使用客户端浏览器漏洞，节点已经被
    compromise，并且我们已经建立了一个活动的meterpreter连接。让我们从在目标节点上运行ipconfig开始，看看它上面有哪些可用的接口。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the target node has two interfaces. One is 192.168.56.1 which
    is connected to the Internet and the other is 10.0.2.15 which is the IP interface
    for the internal network. Our next aim will be to find what other systems are
    available in this local network. To do this we will use a meterpreter script called
    `arp_scanner`. This script will perform an ARP scan on the internal network to
    find out other available systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，目标节点有两个接口。一个是连接到互联网的192.168.56.1，另一个是内部网络的IP接口10.0.2.15。我们下一个目标将是找出这个本地网络中还有哪些其他系统。为此，我们将使用一个名为`arp_scanner`的meterpreter脚本。这个脚本将在内部网络上执行ARP扫描，以找出其他可用的系统。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So the script has successfully discovered two available IP addresses on the
    network. Let us pick up the first IP address and perform pivoting on it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以脚本成功地发现了网络上两个可用的IP地址。让我们选择第一个IP地址并对其进行枢纽转发。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to access the system (which is the server) with IP 10.0.2.7, we will
    have to route all the packets through the IP 10.0.2.15 which is the target node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问IP为10.0.2.7的系统（即服务器），我们将不得不通过目标节点10.0.2.15路由所有数据包。
- en: To do this, we will use a command named `route.` We have learned about this
    command in our previous chapter as well. To use this command, we will background
    the current meterpreter session.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用一个名为`route`的命令。我们在之前的章节中也学习过这个命令。要使用这个命令，我们将把当前的meterpreter会话放到后台。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Look at the parameters of the route command. The `add` parameter will add the
    details into the routing table. Then we have provided the IP address of the target
    node and the default gateway. Then at last, we have provided the current active
    meterpreter session ID (which is 1). The `route print` command shows the table
    and you can clearly see that all the traffic sent through this network will now
    pass through the meterpreter session 1.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查看路由命令的参数。`add`参数将把详细信息添加到路由表中。然后我们提供了目标节点的IP地址和默认网关。最后，我们提供了当前活动的meterpreter会话ID（即1）。`route
    print`命令显示了表，你可以清楚地看到所有通过这个网络发送的流量现在都将通过meterpreter会话1。
- en: Now you can do a quick port scan on the IP address 10.0.2.7 which was previously
    unreachable for us but now we have routed our packets through the target node
    so we can easily figure out the open ports and services. Once you have figured
    out that it is running a Windows 2003 server, you can go ahead and use the `exploit/windows/smb/ms08_067_netapi`
    or any other OS based exploit to compromise the server or access its services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以快速对IP地址10.0.2.7进行端口扫描，这个地址以前对我们来说是不可达的，但现在我们已经通过目标节点路由了我们的数据包，所以我们可以轻松地找出开放的端口和服务。一旦你发现它正在运行Windows
    2003服务器，你就可以继续使用`exploit/windows/smb/ms08_067_netapi`或任何其他基于操作系统的漏洞来攻击服务器或访问其服务。
- en: Port forwarding with meterpreter
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用meterpreter进行端口转发
- en: Discussion of pivoting is never complete without talking about port forwarding.
    In this recipe, we will continue from our previous recipe on pivoting and see
    how we can port forward the data and request from the attacking machine to the
    internal network server via the target node. An important thing to note here is
    that we can use the port forwarding to access various services of the internal
    server, but if we have to exploit the server then we will have to use the complete
    concept discussed in the previous recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论枢纽转发时，没有谈论端口转发是不完整的。在这个教程中，我们将继续从之前的枢纽转发教程中，看看如何将数据和请求从攻击机器通过目标节点转发到内部网络服务器。这里需要注意的一点是，我们可以使用端口转发来访问内部服务器的各种服务，但如果我们必须利用服务器，那么我们将不得不使用在之前的教程中讨论的完整概念。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start from the same scenario which we discussed in the previous recipe.
    We have compromised the target node which is a Windows 7 machine and we have added
    the route information to forward all the data packets sent on the network through
    the meterpreter session. Let us take a look at the route table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从之前的教程中讨论的相同场景开始。我们已经攻破了目标节点，这是一个Windows 7机器，并且我们已经添加了路由信息，以便通过meterpreter会话转发发送到网络上的所有数据包。让我们来看一下路由表。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So our table is all set. Now we will have to set up port forwarding so that
    our request relays through to reach the internal server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的表已经准备好了。现在我们将设置端口转发，以便我们的请求通过中继到达内部服务器。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Suppose the internal server is running a web service on port 80 and we want
    to access it through port forwarding. Now, to do this, we will use the `portfwd`
    command. Let us check the available options with this command then pass the relevant
    values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设内部服务器在端口80上运行Web服务，我们想通过端口转发访问它。现在，为了做到这一点，我们将使用`portfwd`命令。让我们检查一下这个命令的可用选项，然后传递相关的值。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Successful execution of the command shows that a local TCP relay has been set
    up between the attacker and the internal server. The listener port on the attacker
    machine is 4321 and the service to access on the internal server is on port 80.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行命令表明，攻击者和内部服务器之间已经建立了本地TCP中继。攻击者机器上的监听端口是4321，要访问的内部服务器上的服务端口是80。
- en: As we have already set the route information, the entire relay happens transparently.
    Now, if we try to access the internal server through our browser by using the
    URL `http://10.0.2.7:80` then we will be directed to the http intranet service
    of the internal network.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了路由信息，整个中继过程是透明的。现在，如果我们尝试通过浏览器使用URL `http://10.0.2.7:80`来访问内部服务器，那么我们将被引导到内部网络的http内部服务。
- en: Port forwarding can be very handy in situations when you have to run commands
    or applications that Metasploit does not provide. In such situations, you can
    use port forwarding to ease up your task.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要运行Metasploit不提供的命令或应用程序的情况下，端口转发可能非常方便。在这种情况下，您可以使用端口转发来简化您的任务。
- en: This was a small demonstration of port forwarding. In the next recipe we will
    start with Ruby programming to develop our own meterpreter scripts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是端口转发的一个小演示。在下一个教程中，我们将开始使用Ruby编程来开发我们自己的meterpreter脚本。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Port forwarding works on a simple concept of providing a restricted service
    from an unsecure location or network. An authenticated or reliable system/software
    can be used to set up a communication medium between the unsecure and secure network.
    We have already discussed a simple use of port forwarding in the first chapter
    where we talked about setting Metasploit on a virtual machine and connecting it
    with the host operating system using PuTTY.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 端口转发的工作原理很简单，即在不安全的位置或网络提供受限服务的概念。可以使用经过身份验证或可靠的系统/软件在不安全和安全网络之间建立通信媒介。在第一章中，我们已经讨论了端口转发的简单用法，其中我们讨论了在虚拟机上设置Metasploit并使用PuTTY将其连接到主机操作系统。
- en: '![How it works...](img/7423_06_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7423_06_03.jpg)'
- en: The preceding diagram demonstrates the process of port forwarding with a simple
    example. The outside source wants to access the IRC server running on port 6667,
    but the firewall is configured to block any outside access to port 6667(red line
    in the diagram). So, the external source connects to an SSH server (for example,
    PuTTY) running on port 22 which is not blocked by the firewall. This will provide
    a firewall bypass to the external source and now it can access the IRC server
    through port forwarding from port 22 to port 6667\. Hence, an access tunnel is
    created (blue line in the diagram) as a result of port forwarding.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表演示了端口转发的过程，以一个简单的例子为例。外部来源想要访问运行在6667端口上的IRC服务器，但防火墙配置为阻止对6667端口的外部访问（图表中的红线）。因此，外部来源连接到运行在22端口上的SSH服务器（例如PuTTY），该端口未被防火墙阻止。这将为外部来源提供一个防火墙绕过，现在它可以通过从22端口到6667端口的端口转发访问IRC服务器。因此，端口转发创建了一个访问隧道（图表中的蓝线）。
- en: Meterpreter API and mixins
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meterpreter API和混合内容
- en: In the past one and a half chapters, we have learned extensively about using
    meterpreter as a potential post exploitation tool. You might have realized the
    important role of meterpreter to make our penetration task easier and faster.
    Now, from this recipe, we will move ahead and discuss some advanced concepts related
    to meterpreter. We will dive deeper into the core of Metasploit to understand
    how meterpreter scripts function and how we can build our own scripts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的一个半章中，我们已经广泛学习了如何将meterpreter作为潜在的后渗透工具。您可能已经意识到了meterpreter在使我们的渗透任务更轻松、更快速方面的重要作用。现在，从这个示例开始，我们将继续讨论与meterpreter相关的一些高级概念。我们将深入了解Metasploit的核心，了解meterpreter脚本的功能以及如何构建我们自己的脚本。
- en: From a penetration tester's point of view it is very essential to know how to
    implement our own scripting techniques so as to fulfill the needs of the scenario.
    There can be situations when you have to perform tasks where the meterpreter may
    not be enough to solve your task. So you can't sit back. This is where developing
    our own scripts and modules become handy. So let us start with the recipe. In
    this recipe, we will discuss about meterpreter API and some important mixins,
    and then in later recipes, we will code our own meterpreter scripts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从渗透测试人员的角度来看，了解如何实现我们自己的脚本技术以满足场景的需求非常重要。可能会出现需要执行任务的情况，meterpreter可能无法解决您的任务。因此，您不能坐视不管。这就是我们开发自己的脚本和模块变得方便的地方。让我们从这个示例开始。在这个示例中，我们将讨论meterpreter
    API和一些重要的混合内容，然后在后续的示例中，我们将编写我们自己的meterpreter脚本。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Meterpreter API can be helpful for programmers to implement their own scripts
    during penetration testing. As the entire Metasploit framework is built using
    Ruby language, an experience in Ruby programming can enhance your penetration
    experience with Metasploit. We will be dealing with Ruby scripts in the next few
    recipes so some Ruby programming experience will be required ahead. Even if you
    have a basic understanding of Ruby and other scripting languages then it will
    be easy for you to understand the concepts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter API对程序员来说可能会有所帮助，他们可以在渗透测试期间实现自己的脚本。由于整个Metasploit框架都是用Ruby语言构建的，因此Ruby编程经验可以增强您在Metasploit中的渗透经验。在接下来的几个示例中，我们将处理Ruby脚本，因此需要一些Ruby编程经验。即使您对Ruby和其他脚本语言有基本的了解，那么您也会很容易理解这些概念。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)账户中购买的所有Packt图书中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法
- en: Let us start with launching an interactive Ruby shell at the meterpreter. Here,
    I am assuming that we have already exploited the target (Windows 7) and have an
    active meterpreter session.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在meterpreter中启动交互式Ruby shell开始。在这里，我假设我们已经成功利用了目标（Windows 7）并且有一个活动的meterpreter会话。
- en: The Ruby shell can be launched by using the `irb` command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`irb`命令启动Ruby shell。
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we are into the Ruby shell and can execute our Ruby scripts. Let us start
    with a basic addition of two numbers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了Ruby shell，可以执行我们的Ruby脚本。让我们从两个数字的基本相加开始。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So our shell is working fine and can interpret the statements. Let us perform
    a complex operation now. Let us create a hash and store some values in it along
    with the keys. Then, we will delete the values conditionally. The script will
    look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的shell运行正常，可以解释语句。现在让我们执行一个复杂的操作。让我们创建一个哈希表，并在其中存储一些值和键。然后，我们将有条件地删除这些值。脚本如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The script is simple to understand. In the first line, we created keys (a and
    b) and assigned them values. Then, in the next line we added a condition which
    deletes any hash element whose value is less than 25.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很容易理解。在第一行中，我们创建了键（a和b）并为它们分配了值。然后，在下一行中，我们添加了一个条件，删除任何值小于25的哈希元素。
- en: Let's look at some print API calls which will be useful to us while writing
    meterpreter scripts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些打印API调用，这些对我们在编写meterpreter脚本时会很有用。
- en: '`print_line("message"):` This call will print the output and add a carriage
    return at the end.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_line("message")：`此调用将打印输出并在末尾添加回车。'
- en: '`print_status("message"):` This call is used most often in the scripting language.
    This call will provide a carriage return and print the status of whatever is executing,
    with a [*] prefixed at the beginning.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_status("message")：`此调用在脚本语言中经常使用。此调用将提供回车并打印正在执行的任何内容的状态，以[*]开头。'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`print_good("message"):` This call is used to provide a result of any operation.
    The message is displayed with a [+] prefixed at the beginning indicating that
    the action is successful.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_good("message")：`此调用用于提供任何操作的结果。消息显示为[+]，表示操作成功。'
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`print_error("message"):` This call is used to display an error message that
    may occur during script execution. The message is displayed with a [-] prefixed
    at the beginning of the error message.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_error("message")：`此调用用于显示在脚本执行过程中可能发生的错误消息。消息显示为[-]，表示错误消息的开始。'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The reason why I discussed these different print calls is that they are widely
    used while writing meterpreter scripts in respective situations. You can find
    documentations related to meterpreter API in `/opt/framework3/msf3/documentation`.
    Go through them in order to have a clear and detailed understanding. You can also
    refer to `/opt/framework3/msf3/lib/rex/post/meterpreter` where you can find many
    scripts related to meterpreter API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我讨论这些不同的打印调用的原因是它们在编写meterpreter脚本时在相应的情况下被广泛使用。您可以在`/opt/framework3/msf3/documentation`中找到与meterpreter
    API相关的文档。阅读它们以便清晰和详细地理解。您还可以参考`/opt/framework3/msf3/lib/rex/post/meterpreter`，在那里您可以找到许多与meterpreter
    API相关的脚本。
- en: Within these scripts are the various meterpreter core, desktop interaction,
    privileged operations, and many more commands. Review these scripts to become
    intimately familiar with how meterpreter operates within a compromised system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本中包含各种meterpreter核心、桌面交互、特权操作以及许多其他命令。查看这些脚本，以便熟悉meterpreter在受损系统中的操作方式。
- en: '**Meterpreter mixins**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Meterpreter mixins**'
- en: 'Meterpreter mixins are Metasploit specific irb calls. These calls are not available
    in irb but they can be used to represent the most common tasks while writing meterpreter
    scripts. They can simplify our task of writing meterpreter specific scripts. Let
    us see some useful mixins:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter mixins是Metasploit特定的irb调用。这些调用在irb中不可用，但它们可以用来表示编写meterpreter脚本时最常见的任务。它们可以简化我们编写特定meterpreter脚本的任务。让我们看一些有用的mixins：
- en: '`cmd_exec(cmd):` This executes the given command as hidden and channelized.
    The output of the command is provided as a multiline string.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd_exec(cmd)：`以隐藏和通道化的方式执行给定命令。命令的输出以多行字符串形式提供。'
- en: '`eventlog_clear(evt = ""):` This clears a given event log or all event logs
    if none is given. It returns an array of event logs that were cleared.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventlog_clear(evt = "")：`清除给定的事件日志或所有事件日志（如果未给出）。返回已清除的事件日志数组。'
- en: '`eventlog_list():` This enumerates the event logs and returns an array containing
    the names of the event logs.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventlog_list()：`枚举事件日志并返回包含事件日志名称的数组。'
- en: '`file_local_write(file2wrt, data2wrt):` This writes a given string to a specified
    file.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_local_write(file2wrt, data2wrt)：`将给定字符串写入指定文件。'
- en: '`is_admin?():` This identifies whether or not the user is an admin. Returns
    true if the user is an admin and false if not.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_admin?()：`标识用户是否为管理员。如果用户是管理员，则返回true，否则返回false。'
- en: '`is_uac_enabled?():` This determines whether **User Account Control (UAC)**
    is enabled on the system.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_uac_enabled?()：`确定系统上是否启用了用户账户控制（UAC）。'
- en: '`registry_createkey(key):` This creates a given registry key and returns true
    if successful.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_createkey(key)：`创建给定的注册表键并在成功时返回true。'
- en: '`registry_deleteval(key,valname):` This deletes a registry value given the
    key and value name. It returns true if successful.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_deleteval(key,valname)：`删除给定键和值名称的注册表值。如果成功，则返回true。'
- en: '`registry_delkey(key):` This deletes a given registry key and returns true
    if successful.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_delkey(key)：`删除给定的注册表键并在成功时返回true。'
- en: '`registry_enumkeys(key):` This enumerates the sub keys of a given registry
    key and returns an array of sub keys.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_enumkeys(key)：`枚举给定注册表键的子键并返回子键数组。'
- en: '`registry_enumvals(key):` This enumerates the values of a given registry key
    and returns an array of value names.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_enumvals(key)：`枚举给定注册表键的值并返回值名称数组。'
- en: '`registry_getvaldata(key,valname):` This returns the data of a given registry
    key and its value.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_getvaldata(key,valname)：`返回给定注册表键和其值的数据。'
- en: '`service_create(name, display_name, executable_on_host,startup=2):` This function
    is used for the creation of a service that runs its own process. Its parameters
    are the service name as a string, the display name as a string, the path of the
    executable on the host that will execute at start-up as a string, and the start-up
    type as an integer: 2 for Auto, 3 for Manual, or 4 for Disable'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_create(name, display_name, executable_on_host,startup=2)：`用于创建运行自己进程的服务。参数为服务名称（字符串）、显示名称（字符串）、在主机上执行的可执行文件的路径（字符串）和启动类型（整数：2为自动，3为手动，4为禁用）。'
- en: '`service_delete(name):` This function is used for deleting a service by deleting
    the key in the registry.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_delete(name)：`用于通过删除注册表中的键来删除服务。'
- en: '`service_info(name):` This gets the Windows service information. The information
    is returned in a hash with the display name, start-up mode, and command executed
    by the service. The service name is case sensitive. Hash keys are Name, Start,
    Command, and Credentials.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_info(name)：`获取Windows服务信息。信息以哈希形式返回，包括显示名称、启动模式和服务执行的命令。服务名称区分大小写。哈希键为Name、Start、Command和Credentials。'
- en: '`service_list():` This lists all the Windows services present. It returns an
    array containing the services'' names.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_list()：`列出所有存在的Windows服务。返回包含服务名称的数组。'
- en: '`service_start(name):` This function is used for the service start-up. It returns
    0 if the service is started, 1 if the service is already started, and 2 if the
    service is disabled.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_start(name):` 该函数用于服务启动。如果服务已启动，则返回0，如果服务已经启动，则返回1，如果服务已禁用，则返回2。'
- en: '`service_stop(name):` This function is used for stopping a service. It returns
    0 if the service is stopped successfully, 1 if the service is already stopped
    or disabled, and 2 if the service cannot be stopped.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_stop(name):` 该函数用于停止服务。如果服务成功停止，则返回0，如果服务已经停止或禁用，则返回1，如果服务无法停止，则返回2。'
- en: This was a quick reference to some important meterpreter mixins. Using these
    mixins can reduce the complexity of our scripts. We will understand their usage
    in the next few recipes where we will be creating and analyzing meterpreter scripts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对一些重要的meterpreter混合的快速参考。使用这些混合可以减少我们脚本的复杂性。我们将在接下来的几个教程中了解它们的用法，我们将创建和分析meterpreter脚本。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The meterpreter API simply creates a mini Ruby interpreter that can understand
    and interpret Ruby instructions. The major advantage of using API is that it gives
    us the flexibility to perform our own operations. We cannot have commands for
    all operations. There can be situations where we may need specific scripts to
    perform our task. This is where APIs can be handy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: meterpreter API简单地创建了一个可以理解和解释Ruby指令的迷你Ruby解释器。使用API的主要优势是它给了我们灵活性来执行我们自己的操作。我们不能为所有操作都有命令。可能会有需要特定脚本来执行任务的情况。这就是API可以派上用场的地方。
- en: Railgun - converting Ruby into a weapon
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Railgun - 将Ruby转化为武器
- en: In the previous recipe, we saw the use of the meterpreter API to run Ruby scripts.
    Let us take that a step ahead. Suppose we want to make remote API calls on the
    victim machine then what can be the simplest method? Railgun is the obvious answer.
    It is a meterpreter extension that allows an attacker to call DLL functions directly.
    Most often, it is used to make calls to the Windows API, but we can call any DLL
    on the victim's machine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们看到了使用meterpreter API运行Ruby脚本。让我们再进一步。假设我们想在受害者机器上进行远程API调用，那么最简单的方法是什么？Railgun是显而易见的答案。它是一个meterpreter扩展，允许攻击者直接调用DLL函数。通常，它用于调用Windows
    API，但我们可以调用受害者机器上的任何DLL。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start using Railgun, we will require an active meterpreter session on our
    target machine. To start the Ruby interpreter, we will use the `irb` command as
    discussed in the previous recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Railgun，我们需要在目标机器上有一个活动的meterpreter会话。要启动Ruby解释器，我们将使用上一个教程中讨论的`irb`命令。
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Before we move into calling DLLs, let us first see the essential steps to follow
    in order to get the best out of Railgun.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始调用DLL之前，让我们首先看看要遵循的基本步骤，以便充分利用Railgun。
- en: Identify the function(s) you wish to call.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别您希望调用的函数。
- en: Locate the function on [http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx)上找到该函数。
- en: Check the library (DLL) in which the function is located (for example, `kernel32.dll)`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查函数所在的库（DLL）（例如，`kernel32.dll`）。
- en: The selected library function can be called as `client.railgun.dll_name.function_name(arg1,
    arg2, ...)`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所选的库函数可以被调用为`client.railgun.dll_name.function_name(arg1, arg2, ...)`。
- en: The Windows MSDN library can be used to identify useful DLLs and functions to
    call on the target machine. Let us call a simple `IsUserAnAdmin` function of `shell32.dll`
    and analyze the output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Windows MSDN库可用于识别在目标机器上调用的有用的DLL和函数。让我们调用`shell32.dll`的简单`IsUserAnAdmin`函数并分析输出。
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the function returned `false` value indicating that the user
    is not an admin. Let us escalate our privilege and try the call again.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该函数返回了`false`值，表明用户不是管理员。让我们提升我们的特权，然后再试一次调用。
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time the function returned `true` indicating that our privilege escalation
    was successful and now we are working as the system admin. Railgun provides us
    with the flexibility to easily perform those tasks which are not present in the
    form of modules. So, we are not just limited to those scripts and modules that
    the framework provides us with, in fact, we can make calls on demand.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这次函数返回了`true`，表明我们的特权升级成功了，现在我们正在以系统管理员的身份工作。Railgun为我们提供了灵活性，可以轻松执行那些不以模块形式存在的任务。因此，我们不仅仅局限于框架提供的脚本和模块，事实上，我们可以按需调用。
- en: 'You can further extend this call into a small Ruby script with error checking:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步将此调用扩展为一个带有错误检查的小型Ruby脚本：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using Railgun can be a very powerful and exciting experience. You can practice
    your own calls and scripts to analyze the outputs. However, what if the DLL or
    the function you want to call is not a part of the Railgun definition. In that
    case, Railgun also provides you with the flexibility to add your own functions
    and DLLs to Railgun. We will deal with it in our next recipe.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Railgun可以是一个非常强大和令人兴奋的体验。您可以练习自己的调用和脚本来分析输出。但是，如果您想要调用的DLL或函数不是Railgun定义的一部分，那么Railgun还提供了灵活性，可以将您自己的函数和DLL添加到Railgun中。我们将在下一个教程中处理这个问题。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Railgun is a particular Ruby command interpreter that can be used to make remote
    DLL calls to the compromised target. Remote DLL calls are an important process
    in penetration testing as it gives us the command over the compromised target
    to execute any system instruction with full privilege.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Railgun是一个特定的Ruby命令解释器，可以用于对受损目标进行远程DLL调用。远程DLL调用在渗透测试中是一个重要的过程，因为它让我们对受损目标有了完全特权的系统指令执行权限。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Railgun is an interesting tool that can enhance the process of penetration testing.
    Let us find out some more information about Railgun.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Railgun是一个有趣的工具，可以增强渗透测试的过程。让我们找出更多关于Railgun的信息。
- en: Railgun definitions and documentation
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Railgun定义和文档
- en: 'Railgun currently supports ten different Windows API DLLs. You can find their
    definitions in the following folder: `pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Railgun目前支持十种不同的Windows API DLL。你可以在以下文件夹中找到它们的定义：`pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`
- en: 'Apart from this, you can also read the Railgun documentation from the following
    location:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还可以从以下位置阅读Railgun文档：
- en: '`/opt/framework3/msf3/external/source/meterpreter/source/extensions/stdapi/server/railgun/railgun_manual.pdf`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`/opt/framework3/msf3/external/source/meterpreter/source/extensions/stdapi/server/railgun/railgun_manual.pdf`'
- en: Adding DLL and function definition to Railgun
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Railgun添加DLL和函数定义
- en: In the previous recipe, we focused on calling Windows API DLLs through Railgun.
    In this recipe, we will focus on adding our own DLL and function definitions to
    Railgun. In order to do this, we should have an understanding of Windows DLLs.
    The Railgun manual can be helpful in giving you a quick idea about different Windows
    constants that can be used while adding function definitions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们专注于通过Railgun调用Windows API DLL。在这个示例中，我们将专注于向Railgun添加我们自己的DLL和函数定义。为了做到这一点，我们应该了解Windows
    DLL。Railgun手册可以帮助你快速了解可以在添加函数定义时使用的不同Windows常量。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Adding a new DLL definition to Railgun is an easy task. Suppose you want to
    add a DLL that ships with Windows but it is not present in your Railgun, then
    you can create a DLL definition under `pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`
    and name it as `def_dllname.rb`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 向Railgun添加新的DLL定义是一项简单的任务。假设你想添加一个随Windows一起提供但在你的Railgun中不存在的DLL，那么你可以在`pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`下创建一个DLL定义，并将其命名为`def_dllname.rb`。
- en: 'Consider the example of adding a shell32.dll definition into Railgun. We can
    start with adding the following lines of codes:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑将shell32.dll定义添加到Railgun中的示例。我们可以从添加以下代码行开始：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Saving this code as `def_shell32.dll` will create a Railgun definition for shell32.dll.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这段代码保存为`def_shell32.dll`将会为shell32.dll创建一个Railgun定义。
- en: The next step is to add functions to the DLL definition. If you take a look
    at the `def_shell32.dll` script in Metasploit you will see that the `IsUserAnAdmin`
    function is already added into it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是向DLL定义中添加函数。如果你看一下Metasploit中的`def_shell32.dll`脚本，你会发现`IsUserAnAdmin`函数已经被添加进去了。
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function simply returns a Boolean True or False, depending upon the condition.
    Similarly, we can add our own function definition in shell32.dll. Consider the
    example of adding the `OleFlushClipboard()` function. This will flush any data
    that is present on the Windows clipboard.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数简单地返回一个布尔值True或False，取决于条件。同样，我们可以在shell32.dll中添加我们自己的函数定义。考虑添加`OleFlushClipboard()`函数的示例。这将清除Windows剪贴板上存在的任何数据。
- en: 'Adding the following line of code in the shell32.dll definition will serve
    our purpose:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell32.dll定义中添加以下代码行将达到我们的目的：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To test the function, save the file and go back to the meterpreter session to
    check if the function executes successfully or not.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试该函数，保存文件并返回到meterpreter会话中，检查函数是否成功执行。
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Alternately, you can also add the DLLs and functions directly to Railgun using
    `add_dll` and `add_function`. Here is a complete script which checks for the availability
    of shell32\. dll and the `OleFlushClipboard` function and if they are not present
    then they are added using the `add_dll` and `add_function` calls.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`add_dll`和`add_function`直接将DLL和函数添加到Railgun。以下是一个完整的脚本，它检查shell32\.
    dll和`OleFlushClipboard`函数的可用性，如果它们不存在，则使用`add_dll`和`add_function`调用进行添加。
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was a short demonstration of using Railgun as a powerful tool to call Windows
    APIs depending on our need. You can look for various useful Windows API calls
    in the MSDN library, and add them into Railgun and enhance the functionality of
    your framework. It can be used to call any DLL that is residing on the target
    machine. In the next recipe, we will move ahead to develop our own meterpreter
    scripts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Railgun作为一个强大工具根据我们的需要调用Windows API的一个简短演示。你可以在MSDN库中寻找各种有用的Windows API调用，并将它们添加到Railgun中，增强你的框架的功能。它可以用来调用目标机器上的任何DLL。在下一个示例中，我们将继续开发我们自己的meterpreter脚本。
- en: Building a "Windows Firewall De-activator" meterpreter script
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个“Windows防火墙停用器”meterpreter脚本
- en: So far we have used several meterpreter scripts such as `killav.rb` and `persistence.rb`.
    Let's start discussing about developing our own meterpreter script. Ruby knowledge
    is essential for writing any module in Metasploit. You should have basic understanding
    of Ruby. There is not enough documentation available to learn directly about meterpreter
    scripting. The simplest and best practice is to learn Ruby language and side by
    side keep looking at the codes of various available modules. You can also read
    the Metasploit developer guide to understand about the different libraries provided
    by the framework which you can use while writing your own modules. The documentation
    can be found at [http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide](http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了几个meterpreter脚本，比如`killav.rb`和`persistence.rb`。让我们开始讨论开发我们自己的meterpreter脚本。编写Metasploit中的任何模块都需要Ruby知识。你应该对Ruby有基本的了解。目前没有足够的文档可以直接学习meterpreter脚本编写。最简单和最好的做法是学习Ruby语言，同时不断查看各种可用模块的代码。你也可以阅读Metasploit开发者指南，了解框架提供的不同库，这些库可以在编写自己的模块时使用。文档可以在[http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide](http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide)找到。
- en: The script we will develop here is a Windows Vista/7 firewall de-activator script.
    It will make use of the Windows command called `netsh` and meterpreter will execute
    the command on the target machine by using a mixin called `cmd_exec()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里开发的脚本是一个Windows Vista/7防火墙停用器脚本。它将使用Windows命令`netsh`，meterpreter将通过使用名为`cmd_exec()`的mixin在目标机器上执行该命令。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Meterpreter scripts run in context with the exploited client so it becomes easier
    for you to just focus on the task which you want to perform through your script.
    You don't have to worry about the connectivity or any other parameters. Let us
    look at some important guidelines that should be kept in mind while writing meterpreter
    scripts
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter脚本在受攻击的客户端上运行，因此您只需专注于通过脚本执行的任务。您不必担心连接或任何其他参数。让我们看看在编写meterpreter脚本时应该牢记的一些重要准则
- en: '**Avoiding global variables:** This is a general principal for coding on any
    framework. Use of global variables should be avoided as they can interfere with
    the framework variables. Use only instance, local and constant variables.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免全局变量：** 这是在任何框架上编码的一般原则。应避免使用全局变量，因为它们可能会干扰框架变量。只使用实例、局部和常量变量。'
- en: '**Use of comments:** Comments are essential while writing codes. This can help
    you keep a track of which part is responsible for a particular action.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用注释：** 在编写代码时，注释是必不可少的。这可以帮助您跟踪哪个部分负责特定的操作。'
- en: '**Including parameters:** You might have noticed in several recipes how we
    passed parameters along with the script. The most elementary, yet helpful, parameter
    is `-h` or the `help` option.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包括参数：** 您可能已经注意到在几个示例中，我们如何将参数与脚本一起传递。最基本但有用的参数是`-h`或`help`选项。'
- en: '**Printing results:** Printing the result of the operation can prove whether
    the execution of a script was a success or failure. Using different printing calls
    as `print_status, print_error`, and so on should be used extensively to display
    relevant information.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印结果：** 打印操作结果可以证明脚本的执行是成功还是失败。应该广泛使用不同的打印调用，如`print_status, print_error`等，以显示相关信息。'
- en: '**Platform validation:** Make sure that you validate the platform on which
    you want your script to perform an action.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台验证：** 确保您验证要在其上执行操作的平台。'
- en: '**Maintaining the file convention:** Once you have completed writing the script,
    save it under `/pentest/exploits/framework3/scripts/meterpreter`. Following the
    framework file convention can avoid any conflicts.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持文件约定：** 完成脚本编写后，请将其保存在`/pentest/exploits/framework3/scripts/meterpreter`目录下。遵循框架文件约定可以避免任何冲突。'
- en: '**Use of mixins:** Mixins are an important concept in meterpreter. Using mixins
    we can make our script look simpler and easier.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用mixin：** Mixin是meterpreter中的一个重要概念。使用mixin可以使我们的脚本看起来更简单、更容易。'
- en: You should keep these guidelines in mind while writing meterpreter scripts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写meterpreter脚本时，您应该牢记这些准则。
- en: Let us open any text editor to start writing the Ruby script. If you are working
    on BackTrack then you can use the Gedit text editor.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开任何文本编辑器开始编写Ruby脚本。如果您正在使用BackTrack，则可以使用Gedit文本编辑器。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Type the following lines of code in the text editor. Before moving on to the
    explanation section, give a thorough look at the script and try to figure out
    what each line means. The script is easy to catch.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中输入以下代码行。在转到解释部分之前，仔细查看脚本，并尝试弄清楚每行的含义。脚本很容易理解。
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once you have typed the code, save it as `myscript.rb` under `/pentest/exploits/framework3/scripts/meterpreter`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您输入了代码，请将其保存为`myscript.rb`，保存在`/pentest/exploits/framework3/scripts/meterpreter`目录下。
- en: To execute this script, we will need a meterpreter session. Ruby scripts can
    be executed using the `run` command. However, before using the script, make sure
    you have system privileges on the target machine.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此脚本，我们将需要一个meterpreter会话。可以使用`run`命令来执行Ruby脚本。但是，在使用脚本之前，请确保您在目标机器上拥有系统特权。
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Bingo! Successful execution of the script will silently disable the default
    firewall. The execution of the command occurs in the background so the target
    user remains unaware of it. Let us now understand the script in detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行脚本将悄悄地禁用默认防火墙。命令的执行发生在后台，因此目标用户对此毫不知情。现在让我们详细了解脚本。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let us analyze each segment of the script.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析脚本的每个部分。
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These lines of code are nothing but the options that we can pass along with
    the script. In this script, the only option available to us is the `-h` parameter
    which displays the script usage message. You can save this piece of code as a
    template for creating options in your scripts. You will encounter several code
    snippets which can be directly used in your own script.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行只是我们可以与脚本一起传递的选项。在此脚本中，我们可以使用的唯一选项是`-h`参数，它显示脚本的使用消息。您可以将此代码片段保存为创建脚本选项的模板。您将遇到几个代码片段，可以直接在您自己的脚本中使用。
- en: The script starts with creation of a hash (opts) which includes the Rex library
    which is the short form for the Ruby Extensions Library. The only key is `-h`.
    The usage value is set to 'false' which means that this is an optional parameter
    for the script. The next few lines of code match the options provided with the
    script and jumps to the particular case to display the message using `print_line()`.
    In our case, we have used only one option (`-h`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从创建一个哈希（opts）开始，其中包括Rex库，Rex库是Ruby扩展库的简写。唯一的键是`-h`。使用值设置为'false'，这意味着这是脚本的可选参数。代码的下几行将提供的选项与脚本匹配，并跳转到特定情况以使用`print_line()`显示消息。在我们的情况下，我们只使用了一个选项（`-h`）。
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This part of the script is operation specific. It starts with verifying the
    client operating system. Then it uses a meterpreter mixin `cmd_exec()` which can
    execute commands as hidden and channelized. The command to be executed is `netsh
    advfirewall set AllProfiles state off`. The mixin evokes this command on the client
    machine in context with the command prompt and its successful execution disables
    the windows firewall.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的这部分是操作特定的。它从验证客户端操作系统开始。然后使用meterpreter mixin `cmd_exec()`，它可以作为隐藏和通道化执行命令。要执行的命令是`netsh
    advfirewall set AllProfiles state off`。mixin在客户端机器上调用此命令，与命令提示符一起成功执行，禁用了Windows防火墙。
- en: You can play with the script by adding more functionalities and trying different
    possibilities. The more you experiment, the better you will learn.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加更多功能并尝试不同的可能性来玩弄脚本。您实验得越多，学到的就越多。
- en: This was a short demonstration on how to build a meterpreter script. In the
    next recipe, we will look at an advanced meterpreter script and understand it
    in detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何构建meterpreter脚本的简短演示。在下一个配方中，我们将详细了解高级meterpreter脚本。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us extend our discussion to reusing the codes for faster and efficient penetration
    testing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的讨论，以便更快更有效地进行渗透测试。
- en: Code re-use
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码重用
- en: Code re-use can be an effective technique in building your own scripts. You
    can find some readymade functions such as creating multi handler, setting up parameter
    checks, adding payloads. You can use them directly in your code and leverage its
    functionality. Remember that the best way to learn about meterpreter scripting
    is by looking at the built-in scripts.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用可以是构建自己脚本的有效技术。您可以找到一些现成的函数，例如创建多处理程序、设置参数检查、添加有效载荷。您可以直接在您的代码中使用它们并利用其功能。请记住，学习meterpreter脚本的最佳方法是查看内置脚本。
- en: Analyzing an existing meterpreter script
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析现有的meterpreter脚本
- en: Now that we have learned how to build our own script, let us move ahead and
    analyze an existing script that performs some advanced tasks. Once you are able
    to read an existing script completely, you can implement the functions from them
    according to your need. Code re-use is an effective technique to increase the
    optimization of codes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建自己的脚本，让我们继续分析执行一些高级任务的现有脚本。一旦您能完全阅读现有脚本，您就可以根据需要从中实现函数。代码重用是增加代码优化的有效技术。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To view an existing script, browse to `pentest/exploits/framework3/scripts/meterpreter`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看现有脚本，请浏览到`pentest/exploits/framework3/scripts/meterpreter`。
- en: You can find all the available meterpreter scripts in this folder. We will be
    analyzing the `persistence.rb` script which helps in setting up a backdoor on
    the target user. We have discussed the usage of this script in the previous chapter.
    Here we will look under the hood of how this script functions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此文件夹中找到所有可用的meterpreter脚本。我们将分析`persistence.rb`脚本，该脚本有助于在目标用户上设置后门。我们在上一章中已经讨论了此脚本的用法。在这里，我们将深入了解此脚本的功能。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let us analyze each section of the code one by one.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析代码的每个部分。
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code starts with declaring variables which are used in the script. You can
    see some of the common variables such as `rhost, rport, payload_type` which we
    have been using throughout the exploitation process.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从声明在脚本中使用的变量开始。您可以看到一些常见变量，例如`rhost、rport、payload_type`，我们在整个利用过程中一直在使用。
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next part of the script consists of different parameters (flags) that are
    required to pass along with the script. The parameters having a `true` value are
    compulsory flags whose values have to be passed by the penetration tester. Parameters
    with a `false` value are optional.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一部分包括必须与脚本一起传递的不同参数（标志）。具有`true`值的参数是必须的标志，其值必须由渗透测试人员传递。具有`false`值的参数是可选的。
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next section of the script comprises of function declaration. The first
    two functions are generally available in all meterpreter scripts. The usage function
    is used to display an introductory message of the script. It contains a short
    description about the use of the script. The `wrong_meter_version()` is used to
    verify whether the meterpreter version is supported by the script or not. Some
    scripts do not support the older versions of meterpreter so a validation can be
    helpful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一部分包括函数声明。前两个函数通常在所有meterpreter脚本中都可用。使用函数用于显示脚本的介绍性消息。它包含有关脚本用途的简短描述。`wrong_meter_version()`用于验证脚本是否支持meterpreter版本。一些脚本不支持较旧的meterpreter版本，因此验证可能会有所帮助。
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The next function is about creating a payload. You can directly use this function
    in your script if you want to create a payload (power of code reuse). The function
    `create_payload()` takes up two values namely `payload_type` and `lport`. If you
    remember the variable declaration section, then these two variables have been
    initialized with some default values.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是用于创建有效载荷的。如果您想创建有效载荷（代码重用的力量），则可以直接在您的脚本中使用此函数。函数`create_payload()`接受两个值，即`payload_type`和`lport`。如果您记得变量声明部分，那么这两个变量已经初始化为一些默认值。
- en: The `pay = client.framework.payloads.create(payload)` call allows us to create
    a payload from the Metasploit framework.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`pay = client.framework.payloads.create(payload)`调用允许我们从Metasploit框架中创建有效载荷。'
- en: One thing to note in this snippet is `pay.datastore['LHOST'] = lhost` and `pay.datastore['LPORT']
    = lport`. The datastore is simply a hash of values that may be used by modules
    or the framework itself to reference programmer or user controlled values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中需要注意的一件事是`pay.datastore['LHOST'] = lhost`和`pay.datastore['LPORT'] = lport`。数据存储区只是一组值的哈希，可能被模块或框架本身用来引用程序员或用户控制的值。
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The next function is for creating persistent scripts. The scripts are created
    depending upon the payload and other parameter values passed along with the script.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是用于创建持久脚本的。脚本是根据传递给脚本的有效载荷和其他参数值创建的。
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The next function is for creating a log directory for the script. The `host
    = @client.sys.config.sysinfo["Computer"]` call extracts the system info of the
    compromised target. The directory and filename is created using the Rex::FileUtils
    library which is responsible for performing file and directory operations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是用于为脚本创建日志目录的。`host = @client.sys.config.sysinfo["Computer"]`调用提取了受损目标的系统信息。使用负责执行文件和目录操作的Rex::FileUtils库创建了目录和文件名。
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function starts writing files to disk. It saves the various backdoor files
    in the folders and directories created in the previous function. The `Rex::Text.rand_text_alpha((rand(8)+6))
    + ".vbs"` call generates a random text for the filename to be created in the temp
    directory. The `fd.write()` call writes the files to disk.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数开始将文件写入磁盘。它将各种后门文件保存在之前函数创建的文件夹和目录中。`Rex::Text.rand_text_alpha((rand(8)+6))
    + ".vbs"`调用生成一个随机文本作为要在临时目录中创建的文件名。`fd.write()`调用将文件写入磁盘。
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function creates a multi handler to connect back to the attacking system.
    This is, again, a general function which can be used in your script if you want
    an auto connect back feature by setting a multi handler.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数创建一个多处理程序，以连接回攻击系统。这是一个通用函数，如果您想通过设置多处理程序来实现自动连接功能，可以在您的脚本中使用它。
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function is responsible for executing the script on the target machine.
    The persistence script creates vbs scripts on the target machine, so they must
    be executed in order to open a connection. The `Targets_exec()` function solves
    this purpose. This function can again be used as a general function in your own
    script if you want to execute scripts on the target machine. The `session.sys.process.execute()`
    call is responsible for executing the script and the `proc.pid` returns the process
    ID of the backdoor process created.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数负责在目标机器上执行脚本。持久性脚本在目标机器上创建vbs脚本，因此必须执行它们以打开连接。`Targets_exec()`函数解决了这个目的。如果您想在目标机器上执行脚本，这个函数可以再次作为通用函数在您自己的脚本中使用。`session.sys.process.execute()`调用负责执行脚本，`proc.pid`返回创建的后门进程的进程ID。
- en: The remaining part of the code is self-explanatory where these functions are
    called, a clear script is created, and an option check is implemented. This recipe
    might have given you a clear idea of what happens in the background when we execute
    a meterpreter script. It is very essential from a pen tester's point of view to
    be able to read and modify the codes according to the work scenario. This is where
    the beauty of the open source framework lies. You can make modifications according
    to your needs and you can learn by directly analyzing the available source codes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是不言自明的，这些函数被调用，一个清晰的脚本被创建，并且一个选项检查被实施。这个示例可能让您清楚地了解当我们执行一个meterpreter脚本时背后发生了什么。从渗透测试人员的角度来看，能够根据工作场景阅读和修改代码非常重要。这就是开源框架的美妙之处所在。您可以根据自己的需求进行修改，并通过直接分析现有的源代码来学习。
