- en: Man-in-the-Middle Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: In the previous chapter, we covered the ways we can gather information and analyze
    it with the help of various tools. In this chapter, we will learn about the **man-in-the-middle
    framework **(**MITMf**), which is a toolkit for one of the most powerful attacks.
    In order to implement MITMf we are going to use ARP spoofing, bypassing HTTPS, and DNS
    spoofing. We will also use keyloggers, and look at the code injection technique
    for MITMf implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何借助各种工具收集信息并进行分析。在本章中，我们将了解**中间人框架**（**MITMf**），这是一个用于最强大攻击之一的工具包。为了实施MITMf，我们将使用ARP欺骗、绕过HTTPS和DNS欺骗。我们还将使用键盘记录器，并研究MITMf实现中的代码注入技术。
- en: Towards the end of the chapter, we will learn about a special tool called Wireshark,
    which is very efficient when it comes to analyzing a network. With it, we can
    capture packets and learn the information they carry within them. In this section
    of the chapter, we are going to learn how to operate this tool and also how to
    use a few filters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将了解一个名为Wireshark的特殊工具，它在分析网络时非常高效。使用它，我们可以捕获数据包并了解它们所携带的信息。在本节中，我们将学习如何操作这个工具，以及如何使用一些过滤器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Man-in-the-middle-attacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: Wireshark
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark
- en: Man-in-the–middle attacks
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: In the next few sections, we're going to talk about what are known as **man-in-the-middle**
    (**MITM**) attacks. This is one of the most dangerous and effective attacks that
    we can carry out in a network. We can only do it once we have connected to the
    network. It can be used to redirect the flow of packets from any client to our
    device. This means that any packet that is sent to or from the client will have
    to go through our device, and since we know the password we know the key to the
    network, so we will be able to read those packets. They won't be encrypted, and
    we will be able to modify them, drop them, or just read them to see if they contain
    passwords or important information. This attack is so effective because it's very
    hard to protect against. We're going to talk about the ways to protect against
    it, but it's very hard to fully protect against this attack. This is due to the
    way the ARP protocol works. It was programmed in a way that's very simple and
    very effective, but it's not secure enough.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，我们将讨论所谓的**中间人**（**MITM**）攻击。这是我们在网络中可以执行的最危险、最有效的攻击之一。只有在连接到网络后，我们才能进行此攻击。它可以用于将数据包的流量从任何客户端重定向到我们的设备。这意味着，发送到客户端或从客户端发送的任何数据包都必须经过我们的设备，并且由于我们知道密码，因此知道网络的密钥，我们就能读取这些数据包。它们不会被加密，我们将能够修改它们、丢弃它们，或者仅仅读取它们，看它们是否包含密码或重要信息。这个攻击非常有效，因为它很难防御。我们会讨论如何防御这种攻击，但完全防御这种攻击非常困难。这是因为ARP协议的工作方式。它的设计非常简单而且有效，但安全性不足。
- en: ARP has two main security issues. The first one is that each ARP request or
    response is trusted, so whatever our device says to other devices that are in
    our network will be trusted. We can just tell any device that's on our network
    that we are the router and the device will trust us. It will not try to make sure
    that we are actually the router. It will not run any tests to ensure our identity.
    If we tell any device that we are the router, the device will believe us. In the
    same way, if we tell the router that we are someone else on the network, the router
    will trust us and will start treating us as that device; so, that's the first
    security issue. The second security issue is that clients can accept responses
    even if they didn't send a request. So, for example, when a device connects to
    the network, the first thing it's going to ask is, who is the router? And then
    the router will send a response saying "I am the router." Now, we can just send
    a response without the device asking who the router is. We can just tell the device
    we are the router, and because the devices trust anyone, they will trust us start
    sending us packets instead of sending the packets to the router.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ARP有两个主要的安全问题。第一个是每个ARP请求或响应都是被信任的，所以我们设备对其他设备说的任何内容都会被信任。我们可以告诉网络中的任何设备我们是路由器，设备会信任我们。它不会去验证我们是否真的是路由器，也不会做任何身份验证测试。如果我们告诉任何设备我们是路由器，它会相信我们。同样地，如果我们告诉路由器我们是网络中的另一个设备，路由器也会信任我们，并开始将我们当作那个设备来处理；这就是第一个安全问题。第二个安全问题是客户端可以接受即使它没有发送请求的响应。例如，当一个设备连接到网络时，它首先会询问“谁是路由器？”，然后路由器会发送一个响应，表示“我就是路由器”。现在，我们可以在设备没有询问路由器是谁的情况下直接发送响应。我们可以直接告诉设备我们是路由器，且由于设备信任任何人，它们会信任我们，并开始将数据包发送给我们，而不是发送给路由器。
- en: 'So, let''s have a deeper look at how this MITM attack works. It''s going to
    work using a technique called ARP poisoning, or ARP spoofing. This is done by
    exploiting the two security issues that we talked about in the previous paragraph.
    That''s a typical Wi-Fi network, and we can see in the following diagram that
    when the client requests something it will send the request to the **Wi-Fi router**,
    and then the router will get the request from the internet and come back with
    the responses to the **Client**:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们更深入地看看这个MITM攻击是如何运作的。它将通过一种叫做ARP中毒或ARP欺骗的技术来进行。通过利用前一段中提到的两个安全问题，这种攻击得以实现。以下是典型的Wi-Fi网络，我们可以在图示中看到，当客户端请求某个内容时，它会将请求发送给**Wi-Fi路由器**，然后路由器从互联网获取请求，并将响应发送回**客户端**：
- en: '![](assets/e3024871-2d17-49ff-abee-62061787b54a.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3024871-2d17-49ff-abee-62061787b54a.png)'
- en: Now, all this is done using packets. So, what we are going to do is we're going
    to send an ARP response to the **Client **so that we can send responses without
    the **Client** asking them. The **Client** didn't ask for anything, but we can
    still send it a response. We're going to say that our IP is the router IP. So,
    the router, for example, has the IP `192.168.1.1`; we're going to tell the **Client**the
    device with the IP `192.168.1.1` has our MAC address, so we're going to tell the
    **Client **that we are the router, basically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些操作都是通过数据包完成的。所以，我们要做的是向**客户端**发送一个ARP响应，这样我们就可以在**客户端**没有请求的情况下发送响应。**客户端**并没有请求任何内容，但我们仍然可以给它发送响应。我们将告诉它我们的IP是路由器的IP。例如，路由器的IP是`192.168.1.1`；我们将告诉**客户端**，IP为`192.168.1.1`的设备拥有我们的MAC地址，因此我们基本上是在告诉**客户端**我们就是路由器。
- en: 'This will cause the **Client**to start sending the packets to us instead of
    sending the packets to the router. The following diagram illustrates this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致**客户端**开始将数据包发送给我们，而不是发送给路由器。下图说明了这一点：
- en: '![](assets/056b43b2-b11c-4b6e-93e0-c6f6c2b2e89b.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/056b43b2-b11c-4b6e-93e0-c6f6c2b2e89b.png)'
- en: 'After that, we''re going to do the opposite to the Wi-Fi router. We''re going
    to tell the router that we are the client. We''ll do this by telling the router
    that our IP is the **Client** IP, and that **Client** has our MAC address, so
    the communication of packets will be done through the MAC address, and the **Wi-Fi
    router** will start sending any packet that''s meant to go to the **Client** to
    us instead. This will redirect the flow of packets through our device, so when
    the **Client** wants to send a request it will send the request to us:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将对Wi-Fi路由器做相反的操作。我们将告诉路由器我们是客户端。我们会通过告诉路由器我们的IP是**客户端**的IP，并且**客户端**拥有我们的MAC地址，来实现这一点，这样数据包的通信将通过MAC地址进行，**Wi-Fi路由器**将开始将任何原本要发送到**客户端**的数据包发送给我们。这样，数据包的流动就会被重定向到我们的设备，当**客户端**想要发送请求时，它将把请求发送给我们：
- en: '![](assets/ff245c34-1aa8-4a95-9cb8-953e355e48a3.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff245c34-1aa8-4a95-9cb8-953e355e48a3.png)'
- en: 'So, for example, as seen in the following screenshot, when the **Client** wants
    to open Google it will send the request to our device instead of sending it to
    the **Wi-Fi router**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，例如，在下面的截图中，当**客户端**想要打开Google时，它会将请求发送到我们的设备，而不是发送到**Wi-Fi路由器**：
- en: '![](assets/90804c5c-bc63-4e5f-b028-0431c0b05bda.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90804c5c-bc63-4e5f-b028-0431c0b05bda.png)'
- en: Now, our device will go to the **Wi-Fi router**, it'll get Google, the **Wi-Fi
    router** will send the response to our device instead of the **Client**, and then
    we will send the packet back. So, this means that each packet that is sent to
    the **Client** or from the **Client**, will have to go through us. Since it's
    going through us and we have the key, we can read these packets, we can modify
    them, or we can just drop them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的设备将去访问**Wi-Fi路由器**，它将获取Google，**Wi-Fi路由器**会将响应发送到我们的设备，而不是发送给**客户端**，然后我们会把数据包发送回去。这意味着每个发送到**客户端**或从**客户端**发出的数据包，都必须通过我们。既然数据包会通过我们，而我们拥有密钥，那么我们就可以读取这些数据包、修改它们，或者直接丢弃它们。
- en: So, that's the basic principle of the MITM attack and ARP poisoning. Basically,
    we're going to tell the **Client** that we are the **Wi-Fi router**, and then
    we're going to tell the router that we are the **Client**. This will put us in
    the middle of the packet flow, between the **Client** and the **Wi-Fi router**,
    and all the packets will start flowing through our device. Then we can read the
    packets, modify them, or drop them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是MITM攻击和ARP中毒的基本原理。基本上，我们将告诉**客户端**我们是**Wi-Fi路由器**，然后我们再告诉路由器我们是**客户端**。这样，我们就会处于数据包流的中间，位于**客户端**和**Wi-Fi路由器**之间，所有的数据包都会通过我们的设备流动。然后我们可以读取这些数据包、修改它们，或者丢弃它们。
- en: ARP spoofing using arpspoof
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用arpspoof进行ARP欺骗
- en: Now, let's see how to run an actual ARP poisoning attack, redirecting the flow
    of packets and making it flow through our device. We're going to talk about a
    tool called arpspoof, which is part of a suite called dsniff. dsniff is a suite
    that contains a number of programs that can be used to launch MITM attacks. We're
    just going to talk about arpspoof, and we're going to see how to use it to carry
    out ARP poisoning, which redirects the flow of packets through our device. The
    arpspoof tool is old, but it still works, and because it's so simple it's been
    ported to Android, iOS, and other smaller operating systems. There's a lot of
    people that actually like to use it to do ARP poisoning, which is why we're going
    to show you how to use this tool. In the next section and all the sections after
    that, we're going to use a tool called ettercap. We'll see how we use it and how
    to do ARP poisoning with it, but for this section we just want to show how to
    use arpspoof because it's going to be used a lot, so we need to know how to use
    it. It's very simple, anyway.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何运行一个实际的ARP中毒攻击，重定向数据包流并使其通过我们的设备。我们将介绍一个叫做arpspoof的工具，它是一个叫做dsniff的工具套件的一部分。dsniff是一个包含多个程序的套件，这些程序可以用来发起MITM攻击。我们只会讲解arpspoof，看看如何使用它来进行ARP中毒，从而重定向数据包流通过我们的设备。arpspoof工具比较老旧，但仍然有效，而且由于它非常简单，所以它已经被移植到Android、iOS以及其他小型操作系统上。有很多人喜欢用它来进行ARP中毒，这也是我们要展示如何使用这个工具的原因。在接下来的部分以及之后的所有章节中，我们将使用一个叫做ettercap的工具。我们将看到如何使用它以及如何通过它进行ARP中毒，但在这一部分，我们只想展示如何使用arpspoof，因为它将会被频繁使用，所以我们需要知道如何使用它。反正它非常简单。
- en: 'So, we are connected now to the target network. Let''s see how we use the tool.
    It''s going to be `arpspoof -i`, to choose our internet card (virtual card), so
    it''s `eth0`. Then we''re going to put in the target IP address. So, our target
    is the Windows device, with its IP, `10.0.2.5`. Then we will put the IP address
    for the access point, which is `10.0.2.1`. We will tell the access point that
    the client IP address has our MAC address, so basically, we''re going to tell
    the access point that we are the target client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在已经连接到目标网络。让我们看看如何使用这个工具。它的命令是 `arpspoof -i`，用来选择我们的网卡（虚拟网卡），所以是 `eth0`。接着，我们会输入目标
    IP 地址。我们的目标是 Windows 设备，它的 IP 是 `10.0.2.5`。然后我们将输入接入点的 IP 地址，即 `10.0.2.1`。我们将告诉接入点，客户端的
    IP 地址对应我们的 MAC 地址，基本上，我们要告诉接入点，我们就是目标客户端：
- en: '![](assets/a3bb8c09-629b-4c38-a142-bee72bdc0e8a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a3bb8c09-629b-4c38-a142-bee72bdc0e8a.png)'
- en: 'After this, we''re going to have to run arpspoof again, and instead of telling
    the access point that we the target client, we are going to tell the client that
    we are the access point, so we''re just going to flip the IPs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步之后，我们需要再次运行 arpspoof，而这次我们不再告诉接入点我们是目标客户端，而是告诉客户端我们是接入点，所以我们只需要交换 IP 地址：
- en: '![](assets/8e39a64b-7eb8-4902-a6ce-f5ca3cd96567.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e39a64b-7eb8-4902-a6ce-f5ca3cd96567.png)'
- en: So, by running both the preceding commands we're going to fool the access point
    and the client, and we're going to let the packets flow through our device.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过运行之前的两个命令，我们将欺骗接入点和客户端，并让数据包通过我们的设备流动。
- en: 'Now, let''s see, at the target, Windows is the target device, so we are going
    to the ARP table. So, if we just run the `arp -a` command in the Windows machine,
    it''s going to show us the ARP table. So, we can see in the following screenshot
    that the IP address for the access point is `10.0.2.1`, and we can see its MAC
    address is `52-54-00-12-35-00`. It''s stored in this ARP table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看目标设备，目标设备是 Windows，所以我们要查看 ARP 表。如果我们在 Windows 机器上运行 `arp -a` 命令，它将显示 ARP
    表。我们可以在以下截图中看到，接入点的 IP 地址是 `10.0.2.1`，并且可以看到它的 MAC 地址是 `52-54-00-12-35-00`。它存储在这个
    ARP 表中：
- en: '![](assets/5d665766-737b-483d-bad6-d44784a3d519.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d665766-737b-483d-bad6-d44784a3d519.png)'
- en: 'Now, once we do the attack, we will see that the MAC address `08-00-27-0b-91-66`
    for the target access point is going to change, and it''s going to be the attacker''s
    MAC address:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们进行攻击，我们将看到目标接入点的 MAC 地址 `08-00-27-0b-91-66` 会发生变化，变成攻击者的 MAC 地址：
- en: '![](assets/94954742-fb67-474e-8879-18e53518b7db.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94954742-fb67-474e-8879-18e53518b7db.png)'
- en: 'We''ll also need to do something called enabling IP forwarding. We do that
    so that when the packets flow through our device they don''t get dropped, so that
    each packet that goes through our device gets actually forwarded to its destination.
    So, when we get a packet from the router it goes to the client, and when a packet
    comes from the client it should go to the router without being dropped in our
    device. So, we''re going to enable it using this command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做一件叫做启用 IP 转发的事情。我们这么做是为了确保当数据包通过我们的设备时不会被丢弃，从而使每个经过我们设备的数据包都能被转发到它的目的地。因此，当我们从路由器接收到一个数据包时，它会转发给客户端，而当一个数据包来自客户端时，它应该被转发到路由器，而不会在我们的设备中丢失。所以，我们将通过以下命令来启用它：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Windows device now thinks the attacker device is the access point, and every
    time it tries to to access the internet, or every time it tries to communicate
    with the access point, it's going to send these requests to the attacker device
    instead of sending it to the actual access point. This will place our attacker
    device in the middle of the connection, and we will be able to read the packets,
    modify them, or drop them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Windows 设备认为攻击者设备是接入点，每当它试图访问互联网，或者每当它尝试与接入点通信时，它会将这些请求发送到攻击者设备，而不是实际的接入点。这将把我们的攻击者设备置于连接的中间，我们就可以读取、修改或丢弃这些数据包。
- en: We're going to see how we do that in the next sections; for now we just need
    to know how to do basic ARP poisoning. We're going to need to do this every time
    we try to do a MITM attack.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到如何做到这一点；现在我们只需要知道如何进行基本的 ARP 欺骗。每当我们尝试进行中间人攻击时，都需要这样做。
- en: ARP spoofing using MITMf
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MITMf 进行 ARP 欺骗
- en: In this section, and the next few sections, we're going to talk about a tool
    called MITMf, and as the name suggests, this tool allows you to run a number of
    MITM attacks. So, let's run the tool, see how we use it, and we're going to do
    a basic ARP poisoning attack, exactly like we did in the previous section. We
    are also going to be using our Ethernet internal virtual cards instead of the
    Wi-Fi card, so we can actually run these attacks against Wi-Fi or wired networks,
    and we can do it using your wireless card.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及接下来的几节中，我们将讨论一个名为MITMf的工具，正如其名字所示，这个工具可以让你执行多种MITM攻击。接下来，我们将运行这个工具，看看如何使用它，并且我们将进行一个基本的ARP中毒攻击，完全按照之前的操作进行。我们还将使用以太网内部虚拟网卡而不是Wi-Fi网卡，所以我们实际上可以对Wi-Fi或有线网络进行这些攻击，并且可以使用你的无线网卡。
- en: We connect it to the network, to the target network, and then do the attack
    like we did with arpspoof, or you can do it using an Ethernet virtual card.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它连接到网络，连接到目标网络，然后像使用arpspoof那样进行攻击，或者也可以使用以太网虚拟网卡来进行攻击。
- en: 'If we do `ifconfig` just to see our interfaces, we''ll see that we have the `eth0` card
    connected to the internal network at `10.0.2.15`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`ifconfig`命令查看我们的网络接口，我们会看到`eth0`网卡连接到内部网络，IP地址为`10.0.2.15`：
- en: '![](assets/6305c1e8-bf0b-4c8c-964d-cabadffad6b7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6305c1e8-bf0b-4c8c-964d-cabadffad6b7.png)'
- en: 'Now, go to the Windows machine and run `arp -a` to see our MAC addresses, and
    we can see in the following screenshot that we have the gateway at `10.0.2.1`,
    and the MAC address ends with `35-00`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去Windows机器上运行`arp -a`命令查看我们的MAC地址，我们可以在以下截图中看到网关IP为`10.0.2.1`，MAC地址以`35-00`结尾：
- en: '![](assets/92afce7b-0e77-4228-a56c-bb864af95f0a.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92afce7b-0e77-4228-a56c-bb864af95f0a.png)'
- en: So, we're going to run the ARP poisoning attack and see whether the MAC address
    changes and whether we can become the MITM.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将进行ARP中毒攻击，看看MAC地址是否发生变化，以及我们是否能成为中间人（MITM）。
- en: 'To use the tool, the name of which is MITMf, we''re going to put the command
    first. Then we''re going to tell it to do ARP poisoning, then we''re going to
    give it the gateway (the IP of the router), then we''re going to give it the IP
    of our target, and then give it the interface. The command is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用名为MITMf的工具，我们首先输入命令。接着，我们将指示它进行ARP中毒攻击，然后提供网关（路由器的IP），接着提供目标的IP，最后提供接口。命令如下：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we don''t specify a target, it will default to the whole network, to the
    whole subnet. The interface is specifying our virtual interface, but we can specify
    our wireless card if it''s connected to the wireless network. So, we are just
    going to hit *Enter*, and the tool will be running now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定目标，它将默认攻击整个网络、整个子网。接口指定了我们的虚拟接口，但如果它连接到无线网络，我们也可以指定无线网卡。所以，我们只需要按*Enter*，工具就会开始运行：
- en: '![](assets/e23e5fbc-5500-406c-a35d-f3023c6528ab.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e23e5fbc-5500-406c-a35d-f3023c6528ab.png)'
- en: 'Let''s go to the Windows machine, run `arp -a`, and see whether we managed
    to become the center of the connection. We can see in the following screenshot
    the MAC address has changed from `35-00` to `91-66`, and that is the same MAC
    address as the virtual interface that we have in Kali, so it ends up with `91-66`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去Windows机器上，运行`arp -a`，看看我们是否成功成为连接的中心。我们可以在以下截图中看到，MAC地址已经从`35-00`更改为`91-66`，这正是我们在Kali中使用的虚拟接口的MAC地址，因此它的结尾是`91-66`：
- en: '![](assets/7ced38b6-6382-4fd5-9db4-1dfc3d62a6a1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ced38b6-6382-4fd5-9db4-1dfc3d62a6a1.png)'
- en: So, that means we're the MITM at the moment, and the tool automatically starts
    a sniffer for us. So instead of arpspoof, which only places us in the middle,
    this tool actually starts a sniffer, which captures the data that is sent by the
    devices in our network.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这意味着我们此时是中间人（MITM），而该工具会自动为我们启动嗅探器。所以，与arpspoof仅仅让我们处于中间位置不同，这个工具实际上启动了嗅探器，捕获了网络中设备发送的数据。
- en: We are going to go to a website. Now, first, we are going to go to a HTTP website
    and see how to capture a username and a password, and then we'll see how we can
    capture passwords from websites that use HTTPS.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问一个网站。首先，我们将访问一个HTTP网站，看看如何捕获用户名和密码，然后我们将看看如何从使用HTTPS的网站捕获密码。
- en: 'So, on a Windows machine, we are going to go to a website called Hack.me, and
    then we are going to go to the login page to log in to an account while the MITM
    attack is running, and then we are just going to use a username and a password.
    We are going to put the Email Address as `zaid@isecur1ty.org`, and then we are
    going to use, for Password, a false password; but we''ll just see how we can capture
    this password. So, we are going to put `123456`. Now, if we go back to the MITMf
    console, we will see what we have; the username has been captured, which is `zaid@isecur1ty.org`,
    and the password has been captured, which is `123456`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在一台Windows机器上，我们将访问一个名为Hack.me的网站，然后进入登录页面登录账户，同时MITM攻击正在进行。接下来，我们将使用一个用户名和密码。我们将Email地址填写为`zaid@isecur1ty.org`，然后设置一个假的密码；但我们只是想看看如何捕获这个密码。所以我们将密码设置为`123456`。现在，如果我们返回到MITMf控制台，我们将看到捕获到的内容；用户名已经捕获，即`zaid@isecur1ty.org`，密码也被捕获，即`123456`：
- en: '![](assets/c4722f36-7d88-418a-9a75-33fcb4450b9b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4722f36-7d88-418a-9a75-33fcb4450b9b.png)'
- en: So, basically, we are able to capture any username and any password that is
    entered by the computers that we're ARP spoofing. We can also see all the URLs
    that the person has requested. So, for example, we can see that they requested
    `me.hack.me`. We can also see the URLs that Hack.me requested. These are only
    the URLs requested by the ads that are displayed on the website.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，基本上，我们能够捕获所有通过我们ARP欺骗的计算机输入的用户名和密码。我们还可以看到该人请求的所有URL。例如，我们可以看到他们请求了`me.hack.me`。我们还可以看到Hack.me请求的URL。这些仅仅是网站上显示的广告请求的URL。
- en: Bypassing HTTPS
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过HTTPS
- en: 'In the previous section, we saw how to sniff and capture anything sent over
    HTTP requests. Most famous websites use HTTPS instead of HTTP. This means that
    when we try to become the MITM, when the person goes to that website, the website
    will display a warning saying that the certificate of that website is invalid.
    That way, the person will be suspicious and probably won''t log in to that page.
    So, what we''re going to do is use a tool called SSLstrip, which will downgrade
    any HTTPS request to HTTP; so whenever the target person tries to go to [https://hotmail.com](https://hotmail.com),
    for example, they''ll be redirected to the HTTP of `hotmail.com`. Let''s go the
    browser on the target, and we are going to try to go to `hotmail.com`. Now, as
    we can see in the following screenshot, on the top in the address bar you will
    see that the website uses HTTPS, so if we try to become the MITM, this website
    will display a warning:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到如何嗅探并捕获通过HTTP请求发送的所有内容。大多数著名网站使用HTTPS而非HTTP。这意味着，当我们试图成为MITM时，当目标访问该网站时，网站会显示警告，提示该网站的证书无效。这样，目标就会产生怀疑，并且可能不会登录该页面。所以，我们要做的是使用一个名为SSLstrip的工具，它可以将任何HTTPS请求降级为HTTP；因此，当目标访问[https://hotmail.com](https://hotmail.com)时，他们将被重定向到`hotmail.com`的HTTP版本。我们进入目标浏览器，尝试访问`hotmail.com`。现在，如下截图所示，在地址栏顶部你会看到该网站使用HTTPS，因此，如果我们试图成为MITM，该网站将显示警告：
- en: '![](assets/606c1427-affe-4434-9b37-10da824c4c5c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/606c1427-affe-4434-9b37-10da824c4c5c.png)'
- en: To bypass the warning, we're going to use a tool called SSLstrip to downgrade
    any request to the HTTPS website and get it redirected to the HTTP version of
    this website. Once we go to the HTTP version, sniffing the data will be trivial,
    exactly like what happened in the previous section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过警告，我们将使用一个名为SSLstrip的工具，将任何请求HTTPS网站的连接降级为HTTP版本，并将其重定向到该网站的HTTP版本。一旦我们访问HTTP版本，嗅探数据将变得非常简单，就像在上一节中发生的那样。
- en: We can use SSLstrip manually, but luckily, MITMf starts it automatically for
    us. We are actually going to run exactly the same command that we saw in the previous
    section. We are not going to change anything in it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动使用SSLstrip，但幸运的是，MITMf会自动为我们启动它。我们实际上会运行与上一节看到的完全相同的命令，且不会对其做任何更改。
- en: 'If we look at the following screenshot, once we run this program we will see
    that it will actually tell us that SSLstrip has been started and it''s online:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看以下截图，一旦运行这个程序，我们将看到它实际上会告诉我们SSLstrip已经启动并且在线：
- en: '![](assets/5b6af66b-5cdc-4031-aaad-e9eacea9f044.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b6af66b-5cdc-4031-aaad-e9eacea9f044.png)'
- en: So, we are going to go back and we are going to try to go to `hotmail.com`,
    and we will see in the following screenshot that, instead of the HTTPS version
    that we're getting here, we're actually going to go to a HTTP version of hotmail.com.
    Now, notice the address bar here. There is no HTTPS, so we're actually at the
    HTTP version of the website. We will also notice that we didn't see any warnings,
    so it just looks like exactly a normal website, looking exactly like hotmail.com.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将返回并尝试访问`hotmail.com`，我们将在接下来的截图中看到，与我们这里获取到的HTTPS版本不同，我们实际上将访问hotmail.com的HTTP版本。现在，注意这里的地址栏。没有HTTPS，所以我们实际上是访问网站的HTTP版本。我们还会注意到没有看到任何警告，它看起来就像一个正常的网站，和hotmail.com一模一样。
- en: 'So, we are going to put in our email, and again we are going to use a false
    password. We are just going to put `123456`, and we are going to sign in. Now,
    if we go to the Kali machine, we will see that we managed to capture an email
    from `zaid@hotmail.com`, and we also managed to capture the password, which is
    `123456`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们要输入我们的电子邮件，再次使用一个错误的密码。我们只是输入`123456`，然后点击登录。现在，如果我们去Kali机器上查看，我们会看到我们成功捕获了来自`zaid@hotmail.com`的电子邮件，并且我们也成功捕获了密码，它是`123456`：
- en: '![](assets/f7fd9198-ae3e-456a-bf2c-23bea798dbe1.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7fd9198-ae3e-456a-bf2c-23bea798dbe1.png)'
- en: Websites such as Facebook and Google are actually using something called HSTS,
    and what that does is this; basically, the browser comes in with a pre-hardcoded
    list of websites that have to be browsed as HTTPS. So, even if we try to downgrade
    the HTTPS connection to HTTP, the browser will just refuse to show the website,
    or just show a HTTPS version of it. This is because, without connecting to anything,
    the browser has a list stored locally on the local computer saying that it shouldn't
    open Facebook, Gmail, and such websites as HTTP. So, whatever way we try to do
    it, the website will just refuse to open in HTTP.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 像Facebook和Google这样的网站实际上使用了一个叫做HSTS的功能，它的作用是这样的：基本上，浏览器会带着一个预先硬编码的网站列表，这些网站必须以HTTPS方式浏览。所以，即使我们尝试将HTTPS连接降级为HTTP，浏览器也会拒绝显示该网站，或者只会显示其HTTPS版本。这是因为，在不连接任何内容的情况下，浏览器在本地计算机上存储了一个列表，说明它不应该以HTTP方式打开Facebook、Gmail等网站。因此，无论我们尝试什么方式，网站都会拒绝以HTTP打开。
- en: Now, MITMf actually has, an HSTS plugin that attempts to bypass HSTS, but it
    only works against old browsers. It used to use an old vulnerability, which is
    patched now in new browsers. With new browsers, there is no way of bypassing the
    HTTPS connection to Gmail and Facebook at the moment because they use HSTS, which
    basically means they come in with a hardcoded list, so the browser refuses to
    open these websites as HTTP.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MITMf实际上有一个HSTS插件，尝试绕过HSTS，但它只对旧版浏览器有效。它曾经利用一个旧的漏洞，现在在新浏览器中已经修复了。对于新浏览器，目前没有办法绕过到Gmail和Facebook的HTTPS连接，因为它们使用了HSTS，这基本上意味着它们带着一个硬编码的列表，因此浏览器拒绝以HTTP打开这些网站。
- en: Session hijacking
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话劫持
- en: So far, we've seen how we can capture passwords from any computer that is on
    our network, and we've seen how we can even bypass HTTPS to capture passwords
    from famous websites that try to use encryption. What if the target person never
    actually entered their password? What if they use the **Remember Me** feature,
    so when they go to the website they already get logged in into that website? That
    way, they never enter the password, the password is never sent to the server,
    and therefore we'll never be able to capture the password because it's not even
    sent. So, let's have a look at that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何从我们网络上的任何计算机捕获密码，并且我们也看到如何绕过HTTPS来捕获那些尝试使用加密的著名网站的密码。那么，如果目标用户根本没有输入密码呢？如果他们使用了**记住我**功能，当他们访问该网站时，已经自动登录到该网站了呢？这样，他们就不需要输入密码，密码也不会发送到服务器，因此我们永远无法捕获到密码，因为密码根本没有被发送。那么，我们来看看这个情况。
- en: So, we are on our target Windows computer. If we go to Dailymotion, we have
    already logged in there before and we clicked on the Remember Me feature. So,
    if we go to that website, [https://www.dailymotion.com/ie](https://www.dailymotion.com/ie),
    we will see that we will already be logged in to our account without having entered
    our password. In this case, the users actually get authenticated based on their
    cookies. The cookies are stored in the browser, and every time the person tries
    to go to the website they will be authenticated to the website based on the cookies.
    What we can do is sniff out these cookies and inject them into our browser, and
    therefore we'll be able to log into the account without entering the password,
    exactly the same way that the target person is being authenticated to their account.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在目标的 Windows 计算机上。如果我们访问 Dailymotion，我们之前已经登录过，并且点击了“记住我”功能。所以，如果我们访问该网站，[https://www.dailymotion.com/ie](https://www.dailymotion.com/ie)，我们将看到自己已经自动登录到账户，无需输入密码。在这种情况下，用户实际上是通过
    cookies 进行认证的。cookies 被存储在浏览器中，每次用户访问该网站时，他们都会基于这些 cookies 自动登录。我们可以做的是嗅探这些 cookies
    并将它们注入到我们的浏览器中，这样我们就能在不输入密码的情况下登录账户，完全按照目标用户的认证方式来登录。
- en: To do that, we're going to use a tool called ferret, and ferret doesn't come
    installed with Kali. To install it, we are going to have to run `apt-get install
    ferret-sidejack`. Once we have that, first of all we're going to become the MITM
    using the same command that we've been using in the previous sections, using MITMf.
    Now, we can become the MITM any way we want, using arpspoof or any other tool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用一个名为 ferret 的工具，而 ferret 并没有预装在 Kali 中。要安装它，我们需要运行 `apt-get install
    ferret-sidejack`。安装完成后，首先我们将通过前面章节中使用的相同命令成为 MITM，使用 MITMf。现在，我们可以通过任何我们想要的方式成为
    MITM，使用 arpspoof 或任何其他工具。
- en: 'Once we are the MITM, we''re going to use ferret to capture the cookies. There
    is a ferret plugin that comes in with MITMf, but we are going to do it on the
    command line just to see how the whole process works together with another tool
    called hamster. We are going to run ferret, and running ferret is very simple.
    All we have to do is just type in `ferret`, and then we put our interface, which
    is `eth0` in our case. Again, if we are using our wireless card, then put as the
    interface the name of our wireless card. The command is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成为 MITM，我们将使用 ferret 来捕获 cookies。MITMf 自带一个 ferret 插件，但我们将通过命令行来操作，以了解整个过程如何与另一个名为
    hamster 的工具配合工作。我们将运行 ferret，运行 ferret 非常简单。我们所需要做的就是输入 `ferret`，然后指定我们的接口，在我们的情况下是
    `eth0`。如果我们使用无线网卡，则应指定无线网卡的名称作为接口。命令如下：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ferret is running now and it''s ready to capture cookies. In fact, it''s already
    capturing cookies:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ferret 现在正在运行，并且已经准备好捕获 cookies。事实上，它已经在捕获 cookies：
- en: '![](assets/f6dc2a30-b78a-4654-b6f9-25c3ffd4b158.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f6dc2a30-b78a-4654-b6f9-25c3ffd4b158.png)'
- en: 'We''re also going to start a graphical interface, a web GUI, that will allow
    us, to inject the cookies and navigate into our system''s session. To do that,
    we''re going to use a tool called hamster, and running hamster is even simpler
    than ferret. All we have to do is just run `hamster`, and we''re ready to go:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将启动一个图形界面（web GUI），它将允许我们注入 cookies 并进入我们的系统会话。为此，我们将使用一个名为 hamster 的工具，运行
    hamster 比运行 ferret 还要简单。我们所需要做的就是运行 `hamster`，然后就可以开始了：
- en: '![](assets/79c7ad68-38a6-4ff6-a794-61fa204a1b6d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79c7ad68-38a6-4ff6-a794-61fa204a1b6d.png)'
- en: 'So, everything is ready now. We are going to go into our target and log in
    to our account. So, we are just going to pretend that we are browsing the internet.
    We''re going to go to Udemy. We will just go to the website, and we''ll authenticated
    automatically without having to enter anything such as a username or a password.
    Now, let''s come back to the Terminal, and as we can see, we have managed to capture
    the cookies:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在一切都准备好了。我们将进入目标系统并登录到我们的账户。所以，我们假装自己在浏览互联网。我们将访问 Udemy 网站，直接进入该网站，我们将自动认证，无需输入用户名或密码。现在，让我们回到终端，并且如我们所见，我们已经成功捕获了
    cookies：
- en: '![](assets/17d6f932-6d19-4bd1-9c20-0e5e79124805.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/17d6f932-6d19-4bd1-9c20-0e5e79124805.png)'
- en: We are going to copy the proxy link that hamster gave us, which is `http://127.0.0.1:1234`,
    and we are going to go to our browser. Now, we need to modify our proxy settings
    to use hamster, so in our Kali browser we're going to go to Preferences | Advanced
    | Network | Settings, and we're going to set it to use a manual configuration,
    and we're going to set the port to `1234`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制hamster给我们的代理链接，即`http://127.0.0.1:1234`，然后我们将打开浏览器。现在，我们需要修改我们的代理设置以使用hamster，因此在我们的Kali浏览器中，我们将进入首选项
    | 高级 | 网络 | 设置，并设置为使用手动配置，端口设置为`1234`。
- en: 'So, we''re using `127.0.0.1`, which is our local address, and the port is `1234`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们使用的是`127.0.0.1`，这是我们的本地地址，端口是`1234`：
- en: '![](assets/b13a48e5-4052-4459-b05e-7629e2f934e9.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b13a48e5-4052-4459-b05e-7629e2f934e9.png)'
- en: 'Click OK, and then we''re going to navigate to the URL given to us by ferret,
    which is `127.0.0.1:1234`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”，然后我们将导航到ferret提供给我们的URL，即`127.0.0.1:1234`：
- en: '![](assets/6e4c0818-d499-476f-a44b-29b2e0de974e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e4c0818-d499-476f-a44b-29b2e0de974e.png)'
- en: 'We go and select our adapter by going into adapters and entering `eth0`. Then,
    click Submit Query:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入适配器并选择`eth0`，然后点击提交查询：
- en: '![](assets/6e1df58b-6264-4a07-931c-5ab2c3355668.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e1df58b-6264-4a07-931c-5ab2c3355668.png)'
- en: 'We can see that here we have two targets:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有两个目标：
- en: '![](assets/328bbdda-af43-4263-aa04-3ba4c25717b8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/328bbdda-af43-4263-aa04-3ba4c25717b8.png)'
- en: 'Our target is `10.0.2.5`; that''s our target IP. We are going to click on it,
    and as we can see in the following screenshot, on the left we have all the URLs
    that contain cookies related to our target:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是`10.0.2.5`；这是我们的目标IP。我们将点击它，正如我们在以下截图中看到的，左侧列出了所有包含与我们目标相关的cookie的URL：
- en: '![](assets/0bc76621-beec-4954-8cad-1fb47136cce0.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bc76621-beec-4954-8cad-1fb47136cce0.png)'
- en: Obviously, a lot of URLs listed are ad websites or ad URLs, but we can see that
    one of the URLs is for Udemy.com, and if we click on it, we will be actually logged
    in without having to enter a username or password. So, we can go into the channel
    and do anything that the target person is able to do without using the username
    and the password, and this is all possible because we stole the cookies that the
    person actually used to authenticate themselves with the website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，列出的大部分URL是广告网站或广告URL，但我们可以看到其中一个URL是Udemy.com，如果我们点击它，我们实际上会直接登录，而无需输入用户名或密码。因此，我们可以进入该频道并执行目标用户能够做的任何操作，而不使用用户名和密码，这一切都可能，因为我们窃取了目标用户用来认证自己的网站cookie。
- en: DNS spoofing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS欺骗
- en: In this section, we're going to learn what DNS spoofing is and how to perform
    it. DNS is basically a server that converts domain names, such as www.google.com,
    to the IP address of the device where the Google website is stored. Since we're
    the MITM, we can have a DNS server running on our computer and resolve DNS requests
    the way we want. For example, whenever a person requests Google, we can actually
    take them to another website, because we're in the middle. So, when someone requests
    it, we'll actually give them an IP that we want and then they'll see a completely
    different website than what they're expecting. So, we can have a fake website
    running on our own web server and get requests, for example, from live.com to
    that website.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习什么是DNS欺骗以及如何执行它。DNS本质上是一个服务器，它将域名（如www.google.com）转换为存储Google网站的设备的IP地址。由于我们是MITM（中间人），我们可以在我们的计算机上运行一个DNS服务器，并按我们希望的方式解析DNS请求。例如，每当有人请求Google时，我们实际上可以将他们引导到另一个网站，因为我们处于中间。所以，当有人请求时，我们会给他们一个我们希望的IP地址，然后他们会看到一个完全不同的网站，跟他们预期的完全不一样。因此，我们可以在自己的Web服务器上运行一个假的网站，并获取来自live.com的请求，重定向到该网站。
- en: We can have a website requesting the target person to download a backdoor; we
    can do anything we want, really, when we're pretending to be another website.
    The possibilities of what we can do with this attack are endless.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让一个网站要求目标用户下载后门；当我们假扮成另一个网站时，我们可以做任何我们想做的事情。这种攻击的可能性是无穷的。
- en: Let's see how we can do this. The first thing we are going to do is redirect
    people to our web server. The web server is going to be running on our local Kali
    machine. We can redirect people to any web server anywhere we want, but in this
    section we're redirecting them to our local web server. To do that, we're going
    to start Apache web server. It comes preinstalled with Kali, so all we have to
    do is run `service apache2 start`, and the web server will start.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这个目标。首先，我们要做的是将人们重定向到我们的 Web 服务器。Web 服务器将运行在我们的本地 Kali 机器上。我们可以将用户重定向到任何地方的
    Web 服务器，但在本节中我们将他们重定向到我们本地的 Web 服务器。为此，我们将启动 Apache Web 服务器。Kali 系统预安装了 Apache，所以我们只需运行`service
    apache2 start`，Web 服务器就会启动。
- en: 'The files for the web server are stored in the `/var/www/html` directory. We
    are going to open our file manager, and we are going to go to the `/var/www/html` directory,
    and the page that is seen in the following screenshot will be displayed to people
    who browse our web server:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器的文件存储在`/var/www/html`目录中。我们将打开文件管理器，进入`/var/www/html`目录，以下截图中的页面将显示给浏览我们
    Web 服务器的用户：
- en: '![](assets/d43d2a00-b00b-4a55-b511-1f97f2485855.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d43d2a00-b00b-4a55-b511-1f97f2485855.png)'
- en: 'We can have a whole complete website installed in here and it will be displayed
    whenever a person visits our web server. If we go to our browser and browse to
    `10.0.2.15`, which is our own IP address, our internal IP, we will see that we
    can see the `index.html` page there. Let''s configure the DNS server that comes
    in with MITMf; to do that we''re going to use Leafpad, which is just a text editor,
    and then we''re going to run `leafpad /etc/mitmf/mitmf.conf`. Then, we going to
    scroll down to where the `A` records are, as seen in the following screenshot;
    the `A` records are basically the records that are responsible for transforming
    or translating domain names to IP addresses:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里安装一个完整的网站，每当有人访问我们的 Web 服务器时，它就会显示。如果我们在浏览器中访问`10.0.2.15`，即我们的内部 IP 地址，我们会看到`index.html`页面。接下来，我们将配置
    MITMf 附带的 DNS 服务器；为此我们将使用 Leafpad，这是一个文本编辑器，然后运行`leafpad /etc/mitmf/mitmf.conf`。接下来，向下滚动到`A`记录的位置，如下截图所示；`A`记录基本上是负责将域名转换为
    IP 地址的记录：
- en: '![](assets/f543ef37-1367-4192-9d90-0a690b8cd9c0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f543ef37-1367-4192-9d90-0a690b8cd9c0.png)'
- en: 'We''re going to be targeting `live.com` and using the `*` as a wildcard. So,
    basically we''re saying any subdomain to `live.com` should be redirected to `10.0.2.15`—our
    IP address. We can replace this with any IP address. For example, we can put the
    IP address of a remote website that we have hosted on any hosting company, or
    we can have it redirecting to Google, for example, if we put Google''s IP. Any
    IP we put here will redirect `live.com`. Save the file and close it, and we are
    going to run our command. It is very similar to the commands that we were running
    before in previous sections. The only difference is I''m going to add one extra
    option, which is `--dns`. So it''s exactly the same commands, `mitmf --arp --spoof
    --gateway --target --i`, and then we added one extra option, which is `--dns`.
    The command is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`live.com`为目标，并使用`*`作为通配符。因此，基本上我们在说任何指向`live.com`的子域名都应重定向到`10.0.2.15`——我们的
    IP 地址。我们可以用任何 IP 地址替换这里的 IP。例如，我们可以放入我们在任何托管公司上托管的远程网站的 IP 地址，或者我们也可以将其重定向到 Google，例如，如果我们放入
    Google 的 IP 地址。我们在这里放入的任何 IP 都会重定向到`live.com`。保存文件并关闭，然后我们将运行命令。它与我们之前在其他部分运行的命令非常相似。唯一的区别是，我将添加一个额外的选项，即`--dns`。所以命令几乎相同，`mitmf
    --arp --spoof --gateway --target --i`，然后我们添加了一个额外的选项`--dns`。命令如下：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After hitting *Enter*, DNS spoofing is enabled. Let''s go to the target and
    try to go to `live.com` and see what happens. As we can see in the following screenshot, `live.com` actually
    uses HTTPS, and it has been redirected to our own website, which displays some
    simple text, but we can install anything we want. We can ask them to download
    something, or we can have a fake page, steal stuff, and steal credentials:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*回车*后，DNS 欺骗已启用。让我们访问目标网站，尝试进入`live.com`，看看会发生什么。如以下截图所示，`live.com` 实际上使用
    HTTPS，并且已被重定向到我们自己的网页，这里显示了一些简单的文本，但我们可以安装任何我们想要的内容。我们可以要求他们下载某些东西，或者可以设置一个假页面，盗取数据和凭证：
- en: '![](assets/ed0c86dd-9f54-4d91-bead-4b6752cce683.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed0c86dd-9f54-4d91-bead-4b6752cce683.png)'
- en: It can also be used to serve fake updates to the target person, for example,
    or for backdoor downloads on the fly. There are so many uses to DNS spoofing.
    This is just the basic way to do DNS spoofing, and then we can use it and combine
    it with other attacks or with other ideas to achieve really powerful attacks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以用于向目标人物提供虚假的更新，例如，或者用于即时下载后门程序。DNS欺骗有很多用途。这只是DNS欺骗的基本操作方式，之后我们可以将其与其他攻击或其他方法结合，执行非常强大的攻击。
- en: MITMf screenshot keylogger
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MITMf 截图键盘记录器
- en: 'In this section, we''re going to have an example of a simple plugin that comes
    in with MITMf. We are going to run `mitmf --help`, and after scrolling down past `help`,
    we will see a lot of plugins, as we can see in the following screenshot, that
    we can use to do various things on the target computer:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示一个MITMf自带的简单插件示例。我们将运行`mitmf --help`，然后在滚动到`help`之后，我们会看到很多可以用于目标电脑上执行各种操作的插件，如下图所示：
- en: '![](assets/c8b2c45f-2054-47d4-95ba-e529346e0ed4.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c8b2c45f-2054-47d4-95ba-e529346e0ed4.png)'
- en: 'We can use the `--inject` plugin to inject code into the web pages that the
    target person loads, and we''ll have an example of that later. What we want to
    do now is just see an example of a simple plugin, and then we''ll do more in the
    future. Now, for example, as we can see in the following screenshot, we have a
    `ScreenShotter` plugin, and this plugin takes screenshots of each of the pages
    that the person uses. Whenever the person uses a page, it takes a screenshot of
    that page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`--inject`插件将代码注入到目标人物加载的网页中，稍后我们会展示这个插件的例子。现在我们做的只是展示一个简单插件的示例，之后我们会做更多的尝试。现在，例如，我们可以看到以下截图中，我们有一个`ScreenShotter`插件，该插件会截取目标人物使用的每个页面的截图。每当目标人物使用一个页面时，它就会拍摄该页面的截图：
- en: '![](assets/d4197229-f288-40d6-b0da-eff7dc5482b1.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d4197229-f288-40d6-b0da-eff7dc5482b1.png)'
- en: We can set up the `--interval`; that's the amount of time in which the program
    should take a screenshot. It defaults to 10 seconds, so it takes a screenshot
    every 10 seconds, but we can modify it using the `--interval` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置`--interval`；这是程序拍摄截图的时间间隔。默认值为10秒，所以它每隔10秒拍一次截图，但我们可以使用`--interval`选项来修改它。
- en: 'We''re having a basic look at how we can use the plugins, so the first thing
    we do is use the plugin name, and then we put the option that we want to set.
    We''re going to use the same command that we always use, and then we''re going
    to put the plugin name after it. The plugin name is going to be `--screen`, and
    if we want to change the interval we can put the `--interval` option. Then, we
    put the interval for taking the screenshots. We are going to keep it at 10 seconds,
    so we are not going to do anything. Here is the command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先简单了解一下如何使用插件，首先做的就是使用插件名称，然后设置我们想要的选项。我们将使用我们常用的命令，然后将插件名称放在后面。插件名称是`--screen`，如果我们想更改间隔时间，可以添加`--interval`选项。然后，我们设置拍摄截图的时间间隔。我们将保持为10秒，所以我们不做任何更改。以下是命令：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We should go to the target computer and browse the internet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该去目标电脑并浏览互联网。
- en: 'Go to Bing or Google and search anything, go on Images and so on. The plugin
    has started taking screenshots of everything now; every ten seconds it''s taking
    a screenshot, and we can see in the following screenshot that it''s actually injecting
    the code in here every time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Bing或Google，搜索任何内容，进入图片等。插件现在已经开始每隔10秒拍摄一次截图，接下来我们可以看到截图中，实际上每次都会注入代码：
- en: '![](assets/ce690b1b-5877-4509-a2cf-7e59c324a7a0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce690b1b-5877-4509-a2cf-7e59c324a7a0.png)'
- en: 'Stop the process with *Ctrl* + *C*, and then we''re going to go and have a
    look on the screenshots that plugin has captured in the `/var/log/mitmf` directory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*停止进程，然后我们去查看插件在`/var/log/mitmf`目录下捕获的截图：
- en: '![](assets/b7b373c7-2271-4814-9728-97a205ae4046.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7b373c7-2271-4814-9728-97a205ae4046.png)'
- en: 'We can see we have the pictures we Googled on the target:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们在目标电脑上Google到的图片：
- en: '![](assets/63419c7f-45d0-41d5-b8a9-bcf7e4549c4c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63419c7f-45d0-41d5-b8a9-bcf7e4549c4c.png)'
- en: All the images will be stored in the `/var/log/mitmf` directory, and we can
    see them and get an idea of what the person is doing on their computer. There
    are other plugins that you can use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的图片将存储在`/var/log/mitmf`目录中，我们可以查看它们，并了解目标人物在其电脑上的操作。还有其他可以使用的插件。
- en: 'We have `--jskeylogger`, which will basically inject a keylogger into the target
    page, but it''s kind of useless because since we are the MITM, we can see the
    usernames and passwords anyway, as well as anything else that gets sent on the
    target computer. But if for any reason we wanted to have some sort of a keylogger
    injected into the target computer, or into the target website, then all we have
    to do is the same command that we always run and just type in `--jskeylogger`
    after it, and that''s the keylogger injected. Here is the command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`--jskeylogger`，它基本上会在目标页面中注入一个键盘记录器，但这有点没用，因为既然我们是中间人（MITM），我们本来就能看到用户名和密码，以及发送到目标计算机上的其他任何内容。但是如果我们出于某种原因想要将键盘记录器注入到目标计算机或目标网站中，那么我们只需要执行我们通常运行的相同命令，并在其后输入`--jskeylogger`，这样就会注入键盘记录器。以下是命令：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So again, we can go on the target web browser and search for something else.
    Let''s go to Carzone.ie and try to log in with fake credentials. We put the email
    `zaid@isecurity.org` and the password `123456`. Now, obviously, again this has
    been captured because we''re the in the middle of the connection. If we go to
    the MITMf Terminal, we can see that our JSKeylogger is detecting that stuff is
    being entered into the fields called `email` and `password`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以在目标网页浏览器上进行搜索，尝试使用假凭据登录。我们输入了邮箱`zaid@isecurity.org`和密码`123456`。显然，由于我们处于连接的中间，这些信息已经被捕获。如果我们查看MITMf终端，我们可以看到我们的JSKeylogger正在检测到`email`和`password`字段中有信息被输入：
- en: '![](assets/ae67cb5a-49f0-44b0-a157-7c2fce6d79db.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae67cb5a-49f0-44b0-a157-7c2fce6d79db.png)'
- en: So again, if the target person is writing anything on any page, we will be able
    to capture it using the keylogger, but since we are the MITM we can do that using
    Wireshark, and analyze all the packets and see what the person is typing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次强调，如果目标用户在任何页面上输入任何内容，我们将能够通过键盘记录器捕捉到这些信息。但由于我们是中间人（MITM），我们也可以使用Wireshark进行捕获，分析所有数据包，查看目标用户正在输入什么内容。
- en: This is another method of doing it. It's an example of how we can use the plugins
    that come with MITMf. Now again, typing `mitmf --help` will give we all the options,
    all the plugins that we can use, and using them is very similar to what we have
    been doing. So we usually just put the option, or the plugin name, and if we are
    going to set any options for it then we set the options.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方法的示例，展示了如何使用MITMf附带的插件。再次强调，输入`mitmf --help`会列出所有选项和插件，我们可以使用它们，使用的方法与我们之前的操作非常相似。所以我们通常只需要输入选项或插件名称，如果需要设置选项，就设置相应的选项。
- en: MITMf code injection
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MITMf 代码注入
- en: In this section, we're going to be talking about how to inject code into the
    browser, into the target computer. Since we're the MITM and since everything flows
    through our device, when someone requests a page we can actually insert any type
    of code that we want into that page. Browsers can run two types of code; they
    can run HTML code, and they can run JavaScript code. HTML code is the code responsible
    for the way that the page looks, so it's the code for the buttons, for the text,
    for the images, all of that. It can't really be used to do anything that will
    allow us to gain any access to the target computer. JavaScript, on the other hand,
    is a programming language that can be used to do many things, and we'll see that
    in later sections. In this section, we'll see how to inject JavaScript code into
    the target browser. We can use the same method to inject HTML, but JavaScript
    is more useful. That's why we're going to use our example to inject JavaScript.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何将代码注入到浏览器中，即注入到目标计算机中。由于我们是中间人（MITM），并且所有的流量都经过我们的设备，当某人请求页面时，我们实际上可以将任何类型的代码插入到该页面中。浏览器可以运行两种类型的代码；它们可以运行HTML代码，也可以运行JavaScript代码。HTML代码负责页面的外观，所以它控制按钮、文本、图片等的显示。它不能真正用于做任何能够让我们获取目标计算机访问权限的事情。而JavaScript则是一种编程语言，可以用于做很多事情，我们将在后续章节中看到这一点。在这一节中，我们将看到如何将JavaScript代码注入到目标浏览器中。我们也可以使用相同的方法来注入HTML代码，但JavaScript更为实用。因此，我们将使用我们的示例来注入JavaScript。
- en: 'So, let''s first of all run MITMf with the `--help` command, and it will show
    us what options we have with the `--inject` plugin, as shown in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先让我们运行带有`--help`命令的MITMf，它将显示我们在`--inject`插件下有哪些选项，如下图所示：
- en: '![](assets/ab955394-3c83-4357-b868-562ba9c24cd4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab955394-3c83-4357-b868-562ba9c24cd4.png)'
- en: 'We''re going to be using the same command that we always use. The only difference
    is we''re going to insert the `--inject` plugin, and then we have different options
    for injection. There are three main options:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们一直使用的相同命令。唯一的区别是我们将插入`--inject`插件，然后我们有不同的注入选项。主要有三个选项：
- en: We can have our code stored into a file, and we can use `--js-file` or `--html-file` to
    inject the code stored in the file that you specify.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码存储到一个文件中，并且可以使用`--js-file`或`--html-file`来注入您指定的文件中存储的代码。
- en: Code can be stored online, and it has a URL. We can use that URL using the `--js-url`
    or the `--html-url` options.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以在线存储，并且有一个URL。我们可以使用`--js-url`或`--html-url`选项来使用该URL。
- en: We can actually supply the code itself through the command using the `--js-payload`
    or the `--html-payload` options.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实际上可以通过命令本身提供代码，使用`--js-payload`或`--html-payload`选项。
- en: We're going to be supplying the code through the command the first time, and
    then do it using a file. We're going to be using `--inject payload`, and then
    we're going to be doing `--js-payload`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首次通过命令提供代码，然后使用文件进行操作。我们将使用`--inject payload`，然后我们将使用`--js-payload`。
- en: 'Our command is going to be the same as always, `mitmf`, and then we''re going
    to add the option, the plugin, which is `--inject`, and then we''re going to tell
    it that we want to specify the code through the command. We''re going to use the
    `--js-payload`, as then we can put the JavaScript code after the `--js-payload`
    option. We are going to put in our JavaScript code, and we are going to use very
    simple code that will only display a message on the target computer. Our code
    is not going to try to hack anything; all it''s going to do is just display a
    message box on the target computer, and in further sections we''ll see how we
    can use this option to do more powerful attacks. So, basically, our code is going
    to do an `alert()` function in JavaScript, and the alert is just going to say
    `test`. So, our command is the same, it''s `mitmf --arp --spoof`; our interface, `-i`;
    the `--gateway`; the `--target`; and then we loaded the `--inject` plugin; and
    we''re telling it we''re specifying the code through the command. The code that
    we want to run is `alert(''test'')`, and that''s it. The command is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令将和往常一样是`mitmf`，然后我们将添加选项，即插件，即`--inject`，然后我们将告诉它我们要通过命令指定代码。我们将使用`--js-payload`，然后我们可以在`--js-payload`选项后放置JavaScript代码。我们将放入我们的JavaScript代码，我们将使用非常简单的代码，它只会在目标计算机上显示一个消息框。我们的代码不会尝试入侵任何东西；它只会在目标计算机上显示一个消息框，在后续部分中我们将看到如何使用这个选项进行更强大的攻击。所以，基本上，我们的代码将在JavaScript中执行一个`alert()`函数，而这个警报只会显示`test`。所以，我们的命令是一样的，就是`mitmf
    --arp --spoof`；我们的接口，`-i`；`--gateway`；`--target`；然后我们加载了`--inject`插件；并告诉它我们通过命令指定代码。我们要运行的代码是`alert('test')`，就是这样。命令如下：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can check the result by going to the target system, browsing to a normal
    web page, and seeing what happens. We are just going to go to Carzone.ie, and
    as we can see in the following screenshot, the page displays a message box, and
    that message box says test:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过转到目标系统，浏览普通网页，并查看发生了什么来检查结果。我们只需转到Carzone.ie，如下截图所示，页面显示了一个消息框，消息框上写着test：
- en: '![](assets/5a1ea9d7-32e2-4d0c-a7ce-46bcdb33d258.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a1ea9d7-32e2-4d0c-a7ce-46bcdb33d258.png)'
- en: So again, this is very simple code that doesn't really allow us to do anything
    on the target computer, but we can use it in further sections to do more powerful
    attacks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是非常简单的代码，实际上并不能让我们在目标计算机上执行任何操作，但我们可以在后续部分中使用它来进行更强大的攻击。
- en: Again, we can actually Google JavaScript codes and see codes that will be useful
    for us. For example, there are JavaScript keyloggers, there are codes that can
    take screenshots of the target computer, and there are a lot of other codes. You
    can redirect the target computer somewhere else, steal their cookies; you can
    do a lot of these powerful attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们实际上可以搜索JavaScript代码，并查看对我们有用的代码。例如，有JavaScript键盘记录器，有可以在目标计算机上截图的代码，还有许多其他代码。您可以将目标计算机重定向到其他地方，窃取他们的cookie；您可以执行许多这些强大的攻击。
- en: 'Another way to run an `inject` attack is by using a file. If we are using one
    of these more complicated codes, it''s going to be hard to write it through the
    command, so we would be better off storing the code into a file and using the
    `--js-file` option. All we will have to do is open our Leafpad and get our code.
    We are actually just going to run `leafpad`, and we are going to write the same
    code that we did in the preceding example into a file. We are going to make an
    alert pop up, `alert(''test2'');`. We are going to save the file as `alert.js`,
    and we are going to store that in our `/root` directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种运行`inject`攻击的方法是使用文件。如果我们使用的是更复杂的代码之一，通过命令行编写将会很困难，所以最好将代码存储到文件中，并使用`--js-file`选项。我们只需打开Leafpad并获取我们的代码。实际上，我们只需运行`leafpad`，然后将在前面示例中编写的相同代码写入文件中。我们将使一个警报弹出，`alert('test2');`。我们将文件保存为`alert.js`，并将其存储在我们的`/root`目录中：
- en: '![](assets/08fd77fd-0e3c-436a-a396-66b2a2ecfe71.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/08fd77fd-0e3c-436a-a396-66b2a2ecfe71.png)'
- en: 'So again, if we are Googling or if we are using a more complicated code, we
    can have it all in this file, and then inject it. Run the command as we did before;
    the only difference is that  instead of using the `--js-payload`, we''re going
    to use `--js-file`, and we''re going to specify the file, the full path to the
    file. We stored it in the `/root` directory as `alert.js`. If we download a file
    from the internet that contains a keylogger, for example, or a file that will
    redirect the target computer to some other site, then again we use the same command,
    but make sure we put `--js-file` and then the full path to where that file is
    stored. The command is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们在谷歌搜索或使用更复杂的代码，我们可以将所有内容存储在这个文件中，然后进行注入。运行与之前相同的命令；唯一的区别是，不再使用`--js-payload`，而是使用`--js-file`，并指定文件，即文件的完整路径。我们将其存储在`/root`目录中，文件名为`alert.js`。如果我们从互联网下载包含键盘记录器的文件，例如，或者一个将目标计算机重定向到其他网站的文件，那么我们再次使用相同的命令，但确保我们使用`--js-file`，然后指定文件的完整路径。命令如下：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will then launch this command, and MITMf will start the process. We are
    going to come back to the target. Let''s browse for something. We will see that
    our code, the second code that we injected, which was called `test2`, was executed
    on the target machine. The result of the attack can be seen in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将启动这个命令，MITMf将开始进程。我们将回到目标机器。让我们浏览一些内容。我们将看到我们注入的第二个代码`test2`在目标机器上执行。攻击的结果可以在下面的截图中看到：
- en: '![](assets/4f0dbb92-f056-43a1-a693-23e0c9065d32.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f0dbb92-f056-43a1-a693-23e0c9065d32.png)'
- en: Now, again, these are really simple codes just displaying a message box, but
    we can download or look for more complicated JavaScript codes, or just follow
    up in the further sections and see how we can use this feature to carry out more
    powerful attacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些只是显示消息框的非常简单的代码，但我们可以下载或寻找更复杂的JavaScript代码，或者只需在后续部分中跟进，看看我们如何使用这个功能进行更强大的攻击。
- en: MITMf against a real network
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对真实网络进行MITMf攻击
- en: MITMf can be used against real networks exactly the same way that we were using
    it against virtual networks; the only difference is we want to make sure that
    you specify the right IPs, the right interface, and connect to the same network
    that the target person is connected to. We should also go over a few points that
    might prevent MITMf from working properly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MITMf可以针对真实网络进行攻击，方式与我们针对虚拟网络使用它的方式完全相同；唯一的区别是，我们要确保指定正确的IP地址、正确的接口，并连接到目标人员连接的相同网络。我们还应该了解一些可能会导致MITMf无法正常工作的要点。
- en: 'The first thing to do now is run the `ifconfig` command to see our configuration.
    We can see in the following screenshot that we have `eth0` and it''s connected
    to our NAT network, because we configured the Kali machine to use a NAT network:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要做的第一件事是运行`ifconfig`命令查看我们的配置。我们可以看到在下面的截图中，我们有`eth0`，它连接到我们的NAT网络，因为我们配置了Kali机器使用NAT网络：
- en: '![](assets/4cf88fdd-d423-44c0-b86b-5c786724cd68.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4cf88fdd-d423-44c0-b86b-5c786724cd68.png)'
- en: 'First of all, the thing we want to do before we target a real network is make
    sure that that''s the only network that Kali is connected to. The first thing
    that we need to do is disconnect from the network with the IP `10.0.2.15`, which
    is our virtual network. This is very important, and it''s actually the main thing
    that seems to be interfering with MITMf. The attack might work but we will have
    DNS issues, or the target machine will experience a very slow internet connection,
    or they''ll lose their internet connection completely. Go to Devices | Network,
    and look for the tick next to the Connect Network Adapter option:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们攻击真实网络之前，我们需要确保Kali只连接到了那个网络。我们需要做的第一件事是断开与IP为`10.0.2.15`的网络连接，这就是我们的虚拟网络。这个步骤非常重要，实际上，它是MITMf可能遇到干扰的主要原因。攻击可能会成功，但我们可能会遇到DNS问题，或者目标机器的互联网连接会变得非常慢，甚至完全丧失连接。请进入设备
    | 网络，并查看“连接网络适配器”选项旁边的勾选框：
- en: '![](assets/a36a4731-e12e-450b-9b47-fe628166a0b9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a36a4731-e12e-450b-9b47-fe628166a0b9.png)'
- en: 'The tick indicates we''re connected to the network, because it connects the
    network adapter. We''re going to click on Connect Network Adapter, and that''s
    going to disconnect us from the NAT network, as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 勾选表示我们已连接到网络，因为它连接了网络适配器。我们将点击“连接网络适配器”，这将使我们从NAT网络中断开，如下图所示：
- en: '![](assets/fc93efd9-6a51-42ae-ba3f-acffe7f171ae.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc93efd9-6a51-42ae-ba3f-acffe7f171ae.png)'
- en: 'Now, if we run the `ifconfig` command in our Kali machine, we will see that
    `eth0` is not connected to anything, which indicates we are offline in the Kali
    machine. We can''t even `ping` anything:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在Kali机器中运行`ifconfig`命令，我们会看到`eth0`没有连接到任何设备，表示我们在Kali机器上处于离线状态。我们甚至无法`ping`任何东西：
- en: '![](assets/d9335258-1c1b-48ef-b005-fd3363af4605.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d9335258-1c1b-48ef-b005-fd3363af4605.png)'
- en: 'The next thing that we need to do is connect to the same network that the target
    machine is connected to. We are going to be targeting a Windows machine. It''s
    a physical computer connected to a physical Wi-Fi network, and the name of the
    network is `Test`. As we mentioned before, we can''t use the internal wireless
    card inside VirtualBox, inside virtual machines, so to connect to a Wi-Fi network
    we''re going to need to use an external wireless adapter. We are going to connect
    our wireless adapter through a USB port, and then go to Devices | USB, and connect
    a wireless card called ATHEROS:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要做的是连接到目标机器所连接的同一网络。我们将攻击一台Windows机器。它是一台物理计算机，连接到一个物理Wi-Fi网络，网络名称是`Test`。如前所述，我们不能在VirtualBox内的虚拟机中使用内部无线网卡，所以为了连接到Wi-Fi网络，我们需要使用外部无线适配器。我们将通过USB端口连接无线适配器，然后进入设备
    | USB，连接一张名为ATHEROS的无线网卡：
- en: '![](assets/86cea1ca-d23e-4489-9e82-7c69e9dc8bce.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86cea1ca-d23e-4489-9e82-7c69e9dc8bce.png)'
- en: 'Now, if we run the `ifconfig` command, we will see that we have a new interface
    called `wlan0`. It is a wireless card, but as we can see in the following screenshot,
    the wireless card is not connected to any network:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`ifconfig`命令，我们会看到一个新的接口叫做`wlan0`。它是一个无线网卡，但正如我们在下图中看到的，这个无线网卡没有连接到任何网络：
- en: '![](assets/61d00ae7-98bb-481e-83f9-ad070d092559.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61d00ae7-98bb-481e-83f9-ad070d092559.png)'
- en: 'We need to connect to the same network that the Windows machine is connected
    to. After connecting, if we run `ifconfig` we will see that `wlan0` has an IP
    address, and notice that the first three parts of the IP address on Kali are the
    same as the first three parts of the IP address in Windows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接到Windows机器所连接的同一网络。连接后，如果我们运行`ifconfig`，我们会看到`wlan0`有了一个IP地址，并且注意到Kali的IP地址前三部分与Windows中的前三部分相同：
- en: '![](assets/f60b6571-cb63-4ec2-853c-432124601299.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f60b6571-cb63-4ec2-853c-432124601299.png)'
- en: 'Here is the IP of the Windows machine:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Windows机器的IP地址：
- en: '![](assets/483c5517-2c3c-4581-8a05-91c94c57dc0a.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/483c5517-2c3c-4581-8a05-91c94c57dc0a.png)'
- en: Basically, it means that both wireless cards are on the same subnet, on the
    same network, and now we can use `wlan0` to target the Windows computer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着两个无线网卡在同一子网和网络上，现在我们可以使用`wlan0`来定位Windows计算机。
- en: 'If we run `arp -a`, notice the MAC address now. Here is the correct MAC address
    of the router, and when we run MITMf it should change to the attacker''s MAC address:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`arp -a`，请注意现在的MAC地址。这里是路由器的正确MAC地址，当我们运行MITMf时，它应该会变成攻击者的MAC地址：
- en: '![](assets/50a0840c-5393-41e7-8e51-11ea560ba88b.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50a0840c-5393-41e7-8e51-11ea560ba88b.png)'
- en: 'Let''s run MITMf exactly the same way as before. We''re going to run `mitmf`.
    We''re going to do `--arp --spoof`, give it the interface, and this time we''re
    targeting a real computer. We''re targeting a real network, and the `wlan0` interface
    is connected to that real network. So we''re going to use `wlan0` for the interface
    instead of `eth0`. Then we are going to set the `--gateway`, and that''s usually
    the first IP in the subnet, so it''ll be `192.168.0.1`, and then we are going
    to specify `--target`, which is the Windows machine, and it had an IP of `192.168.0.3`.
    The command is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续像之前一样运行MITMf。我们将运行`mitmf`，并执行`--arp --spoof`，给定接口，这次我们目标是一个真实的计算机。我们连接到一个真实的网络，`wlan0`接口连接到该网络。因此，我们将使用`wlan0`作为接口，而不是`eth0`。然后，我们将设置`--gateway`，这通常是子网中的第一个IP地址，因此是`192.168.0.1`，接着我们指定`--target`，这是Windows机器，其IP地址是`192.168.0.3`。命令如下：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The only difference is we''re using different arguments; we''re using `wlan0`
    because `wlan0` is the wireless card that''s connected to the target network,
    we''re using the `--gateway` that is the first IP of the same IP that we have,
    and then we''re using the `--target`, which is this Windows machine, and we''ve
    set it to `192.168.0.3`. After hitting *Enter*, we can see the old MAC address
    of the router used to be `ec:1a:59:5a:ce:de`; now if we run the `--arp -a` command,
    the MAC address should change to the Kali machine''s MAC address:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们使用了不同的参数；我们使用`wlan0`是因为`wlan0`是连接到目标网络的无线网卡，我们使用`--gateway`是我们拥有的相同IP中的第一个IP，然后我们使用`--target`，这是这台Windows机器，我们将其设置为`192.168.0.3`。按下*Enter*后，我们可以看到路由器的旧MAC地址是`ec:1a:59:5a:ce:de`；现在，如果我们运行`--arp
    -a`命令，MAC地址应该会更改为Kali机器的MAC地址：
- en: '![](assets/68cf6235-de74-4880-b320-95bcde40303a.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68cf6235-de74-4880-b320-95bcde40303a.png)'
- en: This could actually take up to a minute and a half for the changes to be reflected.
    Just give it some time and then check the MAC address again if it's not reflected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这可能需要一分钟半的时间才能看到更改的反映。只需稍等片刻，然后检查MAC地址，如果没有反映出来，再查看一遍。
- en: 'Go and browse to a website just so that we generate some traffic on the Windows
    computer, so that it will go ahead and update its ARP table. MITMf is sniffing
    data and it''s capturing data that''s sent by the Windows machine:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个网站，生成一些流量在Windows计算机上，以便它更新其ARP表。MITMf正在嗅探数据并捕获Windows机器发送的数据：
- en: '![](assets/3cf2977d-54e9-4cc0-82c6-b099d467a9c6.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3cf2977d-54e9-4cc0-82c6-b099d467a9c6.png)'
- en: 'Try to log in to an HTTP website with fake credentials on the Windows machine.
    As we can see in the following screenshot, we managed to get the email, which
    is `zaid@isecurity.org`, and the password, which is `123456`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在Windows机器上使用虚假凭据登录一个HTTP网站。如下图所示，我们成功获得了电子邮件`zaid@isecurity.org`和密码`123456`：
- en: '![](assets/60b041aa-8df5-48fa-a051-1777a0be79f4.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60b041aa-8df5-48fa-a051-1777a0be79f4.png)'
- en: MITMf worked against a computer that is connected to a real network. The main
    thing to keep in mind is make sure that we are connected to the same network as
    the target person. If that person is connected to a Wi-Fi network, make sure we
    are using an external wireless adapter and we are not using a bridged or NAT network.
    We need to connect through the network manager of Kali Linux, so we need to attach
    the wireless card and then connect to the target network. Also keep in mind that
    we should disconnect the Kali machine from the NAT network, if it was connected
    to one, by going to Devices | Network, and then uncheck the virtual adapter, because
    we want to make sure that the Kali machine is isolated. We don't want it connected
    to any network other than the target network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MITMf对连接到真实网络的计算机有效。需要记住的主要事项是确保我们与目标设备连接到同一网络。如果该设备连接到Wi-Fi网络，确保我们使用的是外部无线适配器，而不是桥接或NAT网络。我们需要通过Kali
    Linux的网络管理器进行连接，因此我们需要连接无线网卡并连接到目标网络。同时，记得如果Kali机器曾连接到NAT网络，应该断开连接，通过进入设备|网络，取消选择虚拟适配器，确保Kali机器与目标网络隔离。我们不希望它连接到任何其他网络。
- en: 'If we run `ifconfig`, we can see that `eth0` does not have any IP addresses.
    The only device that has an IP address and that''s connected to the internet is
    `wlan0`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`ifconfig`，可以看到`eth0`没有任何IP地址。唯一拥有IP地址并连接到互联网的设备是`wlan0`：
- en: '![](assets/a13c0f83-11fb-4e26-ac54-beb0862f9e1b.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a13c0f83-11fb-4e26-ac54-beb0862f9e1b.png)'
- en: 'Once we are are done running attacks, and if we wanted to go back to using
    the NAT network to target other virtual machines, or if we just wanted to get
    our internet connection through the host machine, all we have to do is just go
    to Devices | Network, and click on Connect Network Adapter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了攻击操作，如果我们想要恢复使用NAT网络来定位其他虚拟机，或者如果我们只是想通过宿主机获取互联网连接，我们只需要进入设备 | 网络，然后点击连接网络适配器：
- en: '![](assets/1be5caca-10f4-41ff-83fe-9c11a9da6267.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1be5caca-10f4-41ff-83fe-9c11a9da6267.png)'
- en: 'That''ll again connect our `eth0` to the NAT network, and it will allow us
    to use it as we were using it before. So, if we run `ifconfig` now, we will see
    that `eth0` has an IP address and it''s connected again to the NAT network:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会重新将我们的`eth0`连接到NAT网络，并且允许我们像之前一样使用它。所以，如果我们现在运行`ifconfig`，我们会看到`eth0`已经有了IP地址，并且再次连接到NAT网络：
- en: '![](assets/68de1ef1-fa09-4a08-a5a1-22dd778d74d0.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68de1ef1-fa09-4a08-a5a1-22dd778d74d0.png)'
- en: Wireshark
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wireshark
- en: In this section, we're going to talk about a tool called Wireshark. Wireshark
    is a network protocol analyzer. It's not designed for hackers, and it's not designed
    for hacking and spying on other people on the network. It's designed for network
    administrators so that they can see what's happening in their network and make
    sure that everything is working properly, and that nobody is doing anything bad
    or suspicious on the network. The way that Wireshark works is it allows you to
    select an interface and then logs all the packets, or all the traffic, that flows
    through that interface. So, we are selecting an interface (it could be a wireless
    card, or it could be a wired card on our current computer), and then it'll start
    logging all the information that flows through that interface. It also has a really
    nice graphical interface that allows us to analyze this traffic, so it allows
    us to filter these packets based on the protocol used in them, such as HTTP or
    TCP. It also allows us to look for certain things, such as cookies or `POST` or
    `GET` requests, and it also allows us to search through these packets. We can
    search through the information that's stored in the packets, and find the things
    that we are looking for. This tool has a vast number of applications, and we might
    need a entire book to cover them all, so in this book we're actually going to
    use it in just a few sections, just covering the basics and the things that are
    related to us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一个名为Wireshark的工具。Wireshark是一个网络协议分析工具。它并不是为黑客设计的，也不是为了黑客攻击或监视网络上其他人而设计的。它是为网络管理员设计的，帮助他们查看网络中发生的事情，确保一切正常工作，没有人在网络上做任何恶意或可疑的事情。Wireshark的工作方式是，它允许你选择一个接口，然后记录所有通过该接口传输的数据包，或者所有的流量。所以，我们选择一个接口（它可以是无线网卡，也可以是我们当前计算机上的有线网卡），然后它会开始记录通过该接口流动的所有信息。它还具有一个非常友好的图形界面，允许我们分析这些流量，因此我们可以根据协议（如HTTP或TCP）来过滤这些数据包。它还允许我们查找特定的内容，如cookie或`POST`或`GET`请求，并且它还允许我们搜索这些数据包中的信息。我们可以在这些数据包存储的信息中进行搜索，找到我们要寻找的内容。这个工具有着广泛的应用，我们可能需要一本完整的书来涵盖所有内容，因此在本书中，我们实际上只会在几个章节中使用它，重点讲解基础知识以及与我们相关的内容。
- en: The main idea here is that Wireshark is not a hacking tool. It only allows us
    to capture the traffic that flows through our own computer, or interface. So,
    we are just going to go to Kali, and we're going to start Wireshark. We can run
    the `wireshark` command from the Terminal. First of all, you can actually just
    go to File | Open, and in here you can open a file that we've already captured.
    For example, you may have captured packets using a different sniffer, such as
    Airodump, MITMf, or TShark, which is the Terminal part of Wireshark.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是，Wireshark不是一个黑客工具。它只允许我们捕获通过我们自己计算机或接口流动的流量。所以，我们只需要进入Kali，启动Wireshark。我们可以从终端运行`wireshark`命令。首先，你实际上可以直接进入文件
    | 打开，在这里你可以打开我们已经捕获的文件。例如，你可能使用了其他抓包工具，如Airodump、MITMf或TShark（Wireshark的终端部分）来捕获数据包。
- en: 'If we captured packets using any of these programs and you stored it in a file,
    we can just come in here, open it, and start analyzing that file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这些程序中的任何一个捕获了数据包，并将其存储在一个文件中，我们可以进入这里，打开它，然后开始分析该文件：
- en: '![](assets/da1258f1-f27a-4f9d-b00d-23f7eed45b37.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da1258f1-f27a-4f9d-b00d-23f7eed45b37.png)'
- en: This is really handy because sometimes we don't really want to analyze the traffic
    on the fly. Sometimes we just want to capture traffic from a small laptop, or
    from our phone, and we may not even be at home. We may be somewhere else doing
    our pen test, and then we go back home and then we want to analyze what we captured.
    In such cases, we can store that in a file and then just open Wireshark and open
    the file that we want to analyze. The main idea here is that Wireshark is not
    a hacking tool, it's not going to capture things happening in another device.
    It will only capture things that flow through our own interface.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为有时我们并不想实时分析流量。有时我们只是想从一台小型笔记本或手机捕获流量，而我们甚至可能不在家。我们可能正在其他地方进行渗透测试，然后回到家后，我们想分析我们捕获的内容。在这种情况下，我们可以将其存储在一个文件中，然后只需打开
    Wireshark 并打开我们想要分析的文件。这里的主要思想是，Wireshark 不是一个黑客工具，它不会捕获其他设备上发生的事情。它只会捕获流经我们自己接口的流量。
- en: 'So, we can see in the following screenshot that we have all the interfaces
    in our computer. We can see that we have eth0, and we have all the other ones,
    some of which are created by VirtualBox:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以在下面的截图中看到我们计算机上的所有接口。我们可以看到 eth0，此外还有其他一些接口，其中一些是由 VirtualBox 创建的：
- en: '![](assets/e9c1e98e-2852-4090-bd4b-4b14671c34d8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9c1e98e-2852-4090-bd4b-4b14671c34d8.png)'
- en: The main one in the preceding screenshot is eth0, which is the virtual interface
    connected to our NAT network.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上面截图中的主要接口是 eth0，它是连接到我们 NAT 网络的虚拟接口。
- en: 'Now, open a browser and go to a normal website, such as Google. Now, as we
    can see in the following screenshot, we can see the traffic in the eth0 interface
    graph is spiking, so there was some traffic generated through that interface:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开浏览器，访问一个正常的网站，例如 Google。现在，正如我们在下面的截图中看到的，我们可以看到 eth0 接口图中的流量出现了峰值，说明通过该接口生成了流量：
- en: '![](assets/86e18233-0ebb-4dc1-858a-13ca9629392e.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86e18233-0ebb-4dc1-858a-13ca9629392e.png)'
- en: So, if we're sniffing on eth0, we will be able to capture the packets that were
    sent.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们在 eth0 上嗅探，我们将能够捕获到发送的包。
- en: Now, go to our Windows machine just to prove that point; browse to the website,
    and we will see that eth0 will not be affected. The traffic that's generated on
    this Windows machine, which is in the same network as the Kali machine, will not
    be captured by the Kali machine.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去我们的 Windows 机器上验证这一点；浏览一个网站，我们会看到 eth0 不会受到影响。在与 Kali 机器处于同一网络的 Windows
    机器上生成的流量，将不会被 Kali 机器捕获。
- en: So, why is Wireshark so useful, why are we even talking about it if we can only
    see things that go through our own computer? Why are we talking about it? Well,
    we're talking about it because we've seen that there are many ways that we can
    become the MITM.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 Wireshark 如此有用？如果我们只能看到流经自己计算机的流量，那我们为什么还要讨论它呢？我们之所以谈论它，是因为我们已经看到有许多方法可以让我们成为
    MITM（中间人攻击者）。
- en: Now, we talked about two methods of becoming the MITM. We talked about doing
    it using ARP spoofing, and if we create a fake access point then we'll naturally
    be the MITM because all the requests will be going through the fake access point
    and start sniffing on the interface that's used to become the MITM. We'll be able
    to capture all the traffic generated by the people that we're targeting in our
    MITM attack. So, if we start a fake access point, we can start sniffing on the
    interface that's broadcasting the signal, and we can capture all the packets sent
    to or received by anyone who is connected to that fake access point. If we become
    the MITM using ARP spoofing, then just select the interface that we used when
    we launched our ARP spoofing attack. We are going to perform this with ARP spoofing
    because it's quicker and easier than generating a fake access point, but again,
    this works on both ways. It even works if we manage to become the MITM using a
    different method. Just make sure we select the interface that's used to launch
    that attack.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们讨论了成为 MITM 的两种方法。我们谈到通过 ARP 欺骗来实现，如果我们创建一个伪造的接入点，那么我们自然会成为 MITM，因为所有的请求都会通过这个伪接入点，并开始在用来成为
    MITM 的接口上嗅探。我们将能够捕获到所有我们在 MITM 攻击中针对的目标产生的流量。所以，如果我们启动一个伪接入点，我们可以开始在广播信号的接口上嗅探，并捕获所有发送给或接收到与这个伪接入点连接的任何人的包。如果我们通过
    ARP 欺骗成为 MITM，那么只需选择我们在发起 ARP 欺骗攻击时使用的接口。我们将使用 ARP 欺骗来执行这个操作，因为它比生成一个伪接入点更快更简单，但这两种方法都适用。如果我们能够通过其他方式成为
    MITM，也可以使用这种方法。只要确保选择我们在发起该攻击时使用的接口即可。
- en: 'So, we are going to look at ARP spoofing. We can do it using arpspoof, or you
    can you do it using MITMf. We''re going to do it using MITMf, and our command
    is going to be `mitmf --arp --spoof -i`, which is going to be `eth0`, then we''re
    going to specify the `--gateway`, `10.0.2.1`, and then the `--target`, which is
    `10.0.2.5`. So, we performed this command before. It will just put us as the MITM.
    It''ll redirect the traffic from the computer that has the IP `10.0.2.5` to our
    computer, placing us in the middle. Run the attack using the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将要讲解ARP欺骗。我们可以使用arpspoof来进行，或者你也可以使用MITMf来进行。我们将使用MITMf，我们的命令将是`mitmf --arp
    --spoof -i`，其中`eth0`是我们的接口，接着我们会指定`--gateway`为`10.0.2.1`，然后是`--target`，目标地址为`10.0.2.5`。所以，我们之前已经执行过这个命令。它会将我们放置为中间人（MITM），并将来自IP地址`10.0.2.5`的流量重定向到我们的计算机，将我们置于中间。使用以下命令执行攻击：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Go to the Windows machine. If we do any browsing here, it is going to affect
    the traffic in eth0. We''ll see whether Wireshark will be able to capture traffic
    generated by this Windows machine. Browse to Google, or a different website, and
    if we come back to the tool, in the following screenshot you will see that we
    have traffic being generated here. We can see that eth0 is actually capturing
    packets in a completely different device, a device that''s not even connected
    to our network:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Windows机器。如果我们在这里进行任何浏览，它将影响eth0上的流量。我们将看看Wireshark是否能捕获由这台Windows机器生成的流量。访问Google或其他网站，如果我们回到工具中，在下面的截图中，你会看到这里有流量正在生成。我们可以看到eth0实际上正在捕获来自一个完全不同设备的数据包，这个设备甚至没有连接到我们的网络：
- en: '![](assets/605cda8c-9a09-40e0-87c5-8e4b348f11d4.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/605cda8c-9a09-40e0-87c5-8e4b348f11d4.png)'
- en: This is happening because when we are the MITM and all the packets that are
    generated by the Windows device are actually being redirected to our Kali device,
    and then Wireshark is sniffing them from the Kali machine, it's sniffing it from
    own local machine. It's not sniffing it from the network, it's not sniffing it
    from the target computer, it's only listening on current interface, which is eth0,
    and it can capture packets that are flowing through eth0 because MITMf has redirected
    the traffic of the Windows machine to flow through the Kali machine.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当我们是中间人（MITM）时，所有由Windows设备生成的数据包实际上都会被重定向到我们的Kali设备，然后Wireshark从Kali机器上嗅探这些数据包，它是从我们自己的本地机器上嗅探的。它不是从网络上嗅探的，也不是从目标计算机上嗅探的，它只是在当前接口（即eth0）上监听，并且可以捕获通过eth0流动的数据包，因为MITMf已经将Windows机器的流量重定向到Kali机器上。
- en: So, again, if an attack is performed with the fake access point, then just listen
    on the interface that we are broadcasting from. If we are performing this attack
    with a real wireless network, if we are connected to our home wireless network
    using wlan0, then we can perform it with wlan0. But with ARP spoofing, we have
    to first redirect the traffic. Then we can use Wireshark. Now, this is just to
    show what Wireshark is and how it works, and we just want to stress the idea that
    Wireshark is not a hacking tool. It's only a program that allows us to log packets
    flowing through a certain interface and then analyze these packets. So, in the
    next section, we'll see how we can sniff and analyze packets using Wireshark.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次强调，如果使用虚假接入点执行攻击，那么只需要监听我们正在广播的接口。如果我们使用真实的无线网络进行攻击，假如我们通过wlan0连接到家里的无线网络，那么我们就可以使用wlan0进行攻击。但在ARP欺骗中，我们必须先重定向流量。然后，我们可以使用Wireshark。现在，这只是为了展示Wireshark是什么以及它是如何工作的，我们要强调的是Wireshark并不是一个黑客工具。它只是一个让我们记录通过某个接口流动的数据包并进行分析的程序。因此，在下一部分，我们将看到如何使用Wireshark来嗅探和分析数据包。
- en: Wireshark basics
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wireshark基础
- en: 'In the previous section, we saw how to launch Wireshark, and we said that we
    can open a file that contains packets that we have already captured, and we can
    start analyzing them using Wireshark. In this section, we want to start sniffing
    packets and then generate some traffic in our Windows machine, and then we''ll
    see how to analyze these packets using Wireshark. As we know, we first have to
    be the MITM to use Wireshark, and then the traffic that''s generated in the Windows
    machine and is actually flowing through the eth0 interface, as we saw in the previous
    section. So, before we start capturing the packets, we need to go to the options
    by clicking the cog icon:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到如何启动Wireshark，并且我们提到可以打开一个包含我们已经捕获的数据包的文件，并使用Wireshark开始分析它们。在这一节中，我们将开始嗅探数据包，然后在Windows机器上生成一些流量，然后我们将看到如何使用Wireshark分析这些数据包。正如我们所知，首先我们需要成为MITM才能使用Wireshark，然后流经eth0接口的流量就是在Windows机器中生成的，正如我们在上一节中看到的。因此，在开始捕获数据包之前，我们需要通过点击齿轮图标进入选项：
- en: '![](assets/cf437545-b7bc-4ba0-b765-69ea8662d45f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf437545-b7bc-4ba0-b765-69ea8662d45f.png)'
- en: 'We can see all the options we can set, all the interfaces that we have, and
    we can see the traffic generated on them, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有可以设置的选项，我们拥有的所有接口，以及在这些接口上生成的流量，如下图所示：
- en: '![](assets/39f5872d-a7e8-4b5e-b860-f11e146f155a.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/39f5872d-a7e8-4b5e-b860-f11e146f155a.png)'
- en: 'The eth0 interface is generating some traffic every now and then because it''s
    coming from the Windows machine. We can select the interfaces that we want to
    start capturing on, and we can actually select more than one interface, and all
    we have to do is just hold the *Ctrl* key and then click the other interface we
    have. If we go on the Output tab, we have an option to store the packets:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: eth0接口时不时会生成一些流量，因为它来自Windows机器。我们可以选择我们要开始捕获的接口，实际上我们可以选择多个接口，所有需要做的就是按住*Ctrl*键，然后点击其他接口。如果我们点击“输出”标签，我们可以选择存储数据包的选项：
- en: '![](assets/eabc97b5-5f94-461c-ab7f-f826088e3cfc.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eabc97b5-5f94-461c-ab7f-f826088e3cfc.png)'
- en: If we only want to sniff and don't want to analyze things, then we can just
    go to Browse and store the packets that we are going to sniff somewhere, and then
    we can analyze them whenever we have the time at a different time. We can just
    open them with Wireshark like we saw in the previous section. We can just go on
    File | Open and then open the packets and start analyzing them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想嗅探而不想分析数据，那么我们可以直接进入“浏览”并将我们要嗅探的数据包存储在某个地方，之后我们可以在有时间时随时进行分析。我们只需像在上一节看到的那样，用Wireshark打开它们。只需要点击“文件”|“打开”，然后打开数据包并开始分析。
- en: 'Now, we have eth0 selected and we are just going to click on Start, and that''ll
    start capturing packets. Anything that''s going to flow through eth0 will be captured
    and will be displayed in Wireshark:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经选择了eth0接口，接下来点击“开始”，这将开始捕获数据包。任何将流经eth0的数据都会被捕获并在Wireshark中显示出来：
- en: '![](assets/a33aa469-4292-4cf9-a8aa-532544837d43.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a33aa469-4292-4cf9-a8aa-532544837d43.png)'
- en: Anything (we mean images, pictures, messages, cookies) that that computer does
    on the internet will flow through eth0, and therefore will be captured by Wireshark.
    It's not like MITMf, which was only showing us the important information. In Wireshark,
    we will see everything, all the traffic that's generated. So, let's first of all
    generate some traffic and try to analyze the packets, or the traffic that we generated.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 任何计算机在互联网上进行的操作（我们指的是图片、消息、cookie等）都会通过eth0流动，因此都会被Wireshark捕获。这与MITMf不同，MITMf只显示我们重要的信息。而在Wireshark中，我们将看到所有内容，所有产生的流量。因此，首先让我们生成一些流量并尝试分析我们生成的数据包或流量。
- en: 'In the main interface of Wireshark, as shown in the following screenshot, we
    can see that each record is a packet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Wireshark的主界面中，如下图所示，我们可以看到每条记录都是一个数据包：
- en: '![](assets/7fb3e307-3aed-40cd-8f54-2453fd6cea6e.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7fb3e307-3aed-40cd-8f54-2453fd6cea6e.png)'
- en: 'We can see the columns. First of all is the No. column for packet numbering.
    In the Time column, we will see the time that this packet was captured. The time
    increases as we go down, and it shows when these packets were captured. We can
    also see the Source column, which indicates which device the packet was sent from.
    The Destination column shows the receiving device IP. The Protocol column shows
    the name of the protocol used by the packet. In the Length column we can see the
    length, which is the size. We can also see more information about the packet in
    the Info column:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到列。首先是用于数据包编号的 No. 列。在时间列中，我们将看到此数据包被捕获的时间。时间随着向下滚动而增加，显示这些数据包被捕获的时间。我们还可以看到源列，显示数据包发送的设备。目标列显示接收设备的
    IP 地址。协议列显示数据包使用的协议名称。在长度列中，我们可以看到数据包的大小。我们还可以在信息列中看到有关数据包的更多信息：
- en: '![](assets/39518339-72d8-42c4-98da-efcb1b22f7e1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/39518339-72d8-42c4-98da-efcb1b22f7e1.png)'
- en: 'We can also see that packets have different colors. Usually, green is TCP packets
    and dark blue is DNS packets. Light blue is usually UDP, but we don''t have any
    UDP packets at the moment, and we can also see we have some black packets, and
    these are TCP packets that had issues. If we double-click on any of the packets,
    it will display more information for us. It''s the same information that''s being
    displayed at the bottom of the main interface. We can see in the following screenshot
    that we have the Frame, the Ethernet, the Internet Protocol, and the Transmission
    Control Protocol, and using that we can just click on the arrow and see more information
    that''s stored in here. Now, if we just double-click the packet, we will get the
    exact same information and we will be able to get information about the packet
    that we have selected:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到数据包具有不同的颜色。通常，绿色表示 TCP 数据包，深蓝色表示 DNS 数据包。浅蓝色通常表示 UDP，但目前我们没有任何 UDP 数据包，我们还可以看到一些黑色数据包，这些是存在问题的
    TCP 数据包。如果我们双击任何数据包，它将显示更多信息。这些信息与主界面底部显示的信息相同。我们可以在以下截图中看到，数据包包括帧、以太网、互联网协议和传输控制协议，我们可以使用箭头点击查看更多存储的信息。现在，如果我们双击数据包，我们将获得完全相同的信息，并能获取所选数据包的详细信息：
- en: '![](assets/e36be318-6531-4b9f-ae79-de698b6c2467.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e36be318-6531-4b9f-ae79-de698b6c2467.png)'
- en: 'Now, most of the traffic that we have generated was HTTP traffic, so to get
    rid of all this information that''s hard for us to read we''re just going to type HTTP in
    the filters, and hit *Enter*. As we can see, that filtered all the packets to
    HTTP traffic. So, for example, we have a `POST` request sent from our target computer
    to a server. We still don''t know what that server is, but it''s a server on the
    internet. When we double-click that, we''ll get more information about this packet.
    We''re going to make this smaller here. So, under Frame we can see the interface
    that''s used. We can see information about the packet itself. In Ethernet II,
    as we can see in the following screenshot, is the information about the Destination
    and the Source, so we can see that the MAC address is used. In the Internet Protocol,
    we will see information such as the geolocation of the target, wherein we will
    see where that packet is sent. In the Transmission, we can see information about
    the ports used:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们生成的大部分流量是 HTTP 流量，因此为了去除所有这些我们难以阅读的信息，我们只需要在过滤器中输入 HTTP，并按下*Enter*。如我们所见，这样就将所有数据包过滤为
    HTTP 流量。例如，我们有一个从目标计算机发送到服务器的 `POST` 请求。我们仍然不知道这个服务器是什么，但它是一个互联网上的服务器。当我们双击它时，我们将获得有关此数据包的更多信息。我们将在这里将其缩小。接下来，在帧下，我们可以看到所使用的接口。我们可以看到关于数据包本身的信息。在以太网
    II 中，如下图所示，可以看到目标和源的信息，所以我们可以看到使用了 MAC 地址。在互联网协议中，我们将看到诸如目标地理位置等信息，显示该数据包被发送到哪里。在传输协议中，我们可以看到有关所使用端口的信息：
- en: '![](assets/f52c280b-2ab1-4c1e-bc47-dd469a61d795.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f52c280b-2ab1-4c1e-bc47-dd469a61d795.png)'
- en: 'Now, a really interesting part for us is the Hypertext Transfer Protocol, as
    this is where we really see the interesting information. In here, we can see that
    the request was sent to bing.com, and we will see that this request was searching
    for www, and we can see that the Content Type was text. So, we can get this information,
    as we can see in the following screenshot, about each packet that''s sent, and
    can see that Wireshark logs everything that happens. It doesn''t only show the
    interesting information, it literally logs everything. It contains the interesting
    stuff plus much more:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对我们来说，真正有趣的部分是超文本传输协议（HTTP），因为这里是我们看到有趣信息的地方。在这里，我们可以看到请求被发送到bing.com，我们将看到这个请求是在搜索www，我们还可以看到内容类型是text。所以，我们可以获取这些信息，正如以下截图所示，关于每一个发送的包，并且可以看到Wireshark记录了发生的所有事情。它不仅显示有趣的信息，它实际上记录了所有内容。它包含了有趣的内容，还有更多：
- en: '![](assets/da65d88a-70b3-448f-a349-27a891983779.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da65d88a-70b3-448f-a349-27a891983779.png)'
- en: So, again, we can see all the searches that we did. We can see all the URLs
    that the user has entered so far. If we scroll down, we will be able to see all
    the other URLs that we visited.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，重新来看，我们可以看到我们所做的所有搜索。我们可以看到用户迄今为止输入的所有网址。如果我们向下滚动，就能够看到我们访问的其他网址。
- en: Wireshark filters
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wireshark过滤器
- en: 'In this section, we''ll see how to use more Wireshark filters and capture a
    username and a password, and we''ll also see how to see the cookies of a person
    if they''re already logged into a service and they haven''t entered their username
    and password. So, we are going to start a new capture. We will just go to Hotmail,
    and we are going to log in with a username, which is `zaid@hotmail.com`, and then
    we''ll enter the password, which is going to be a random password that''s going
    to be captured. So, we''re going to enter `123456`, and hit *Enter*. When we go
    to the Wireshark tool, we will see it has managed to capture the traffic, as we
    can see in the following screenshot. In the traffic we are going to look for HTTP,
    and we''re going to look for POST requests:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到如何使用更多的Wireshark过滤器捕获用户名和密码，并且我们还将看到如何查看一个已经登录服务且没有重新输入用户名和密码的人的cookies。所以，我们将开始一个新的捕获。我们将进入Hotmail，登录用户名是`zaid@hotmail.com`，然后输入密码，这将是一个随机密码，将被捕获。我们将输入`123456`并按*回车*。当我们进入Wireshark工具时，我们将看到它成功地捕获了流量，正如以下截图所示。在流量中，我们将寻找HTTP，并寻找POST请求：
- en: '![](assets/fe5d6789-db68-457b-90ba-ced713415986.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fe5d6789-db68-457b-90ba-ced713415986.png)'
- en: We see a POST request, sent from the target computer to the server. We are going
    to open it and see what's inside it. We will scan through such captures to see
    which session has our username and passwords.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个POST请求，从目标计算机发送到服务器。我们将打开它，查看其中的内容。我们将扫描这些捕获的数据，找出哪些会话包含我们的用户名和密码。
- en: 'We will open all the HTTPS URLs, and also one that has a POST request. In the
    following screenshot, we have found the session that has captured our login credentials.
    We have go to HTML form to see them. We have the login session captured, which
    is `zaid@hotmail.com`, so this is what we entered, and you can also see the password
    that was sent, `123456`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开所有HTTPS网址，还有一个包含POST请求的网址。在以下截图中，我们找到了捕获我们登录凭据的会话。我们通过HTML表单查看它们。我们捕获到的登录会话是`zaid@hotmail.com`，所以这是我们输入的内容，你还可以看到发送的密码，`123456`：
- en: '![](assets/838756e8-10af-496d-8cad-9bfe3e4e9c82.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/838756e8-10af-496d-8cad-9bfe3e4e9c82.png)'
- en: So, again, MITMf was sniffing all the data for us, and it was showing the information.
    It was filtering the important information. We can see that we can capture anything
    that's sent on the network using Wireshark.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次说明，MITMf为我们嗅探了所有数据，并显示了信息。它过滤了重要信息。我们可以看到，我们能够使用Wireshark捕获网络上发送的任何内容。
- en: 'Another thing that we can do is search through the whole packets. We can just
    go to the Edit option and then select Find Packet, and we can search in the packet
    list, or in the packet details. If we search in the packet details, we''re going
    to keep this `Narrow & Wide`, and we will get a string. We can actually put in
    a display filter if we want, but we are searching for a string, which is just
    the normal text. If we search for `Zaid` it''ll actually go straight to the packet
    that contains our username. Again, when we find it we can double-click it, whichever
    is easier for us. We can see in the following screenshot that we managed to capture
    the username, which is `zaid@hotmail.com`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一件事是搜索整个数据包。我们可以直接点击“编辑”选项，然后选择“查找数据包”，我们可以在数据包列表中或数据包详情中进行搜索。如果我们在数据包详情中搜索，我们将保持`Narrow
    & Wide`，然后得到一个字符串。实际上，如果我们想要，我们可以设置一个显示过滤器，但我们搜索的是一个字符串，就是普通文本。如果我们搜索`Zaid`，它实际上会直接跳转到包含我们用户名的数据包。当我们找到它时，可以双击它，选择对我们来说更方便的方式。在下面的截图中，我们成功捕获了用户名`zaid@hotmail.com`：
- en: '![](assets/83d2ee7f-82f6-4bea-bc34-6c07faf3be69.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83d2ee7f-82f6-4bea-bc34-6c07faf3be69.png)'
- en: Now, we can do Find Next and we will get the next one, which actually has our
    password in it. Again, the search right here is really useful function that will
    allow us to navigate through all of these packets and find what we are looking
    for.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以点击“查找下一个”，它会找到下一个数据包，里面实际上包含我们的密码。同样，这里的搜索功能是非常有用的，它可以帮助我们在所有数据包中找到我们需要的内容。
- en: 'Now, let''s start a new capture and see if we can actually capture the cookies.
    So, we are going to go to our Windows machine, and then we will go to Dailymotion,
    which we already logged into before. As we can see, it''s not asking me to log
    in because we are already logged in, and it already has a name here, so we are
    just going to go to this channel. It''s just a fake channel that we created. We
    go to Wireshark and stop the capture, and instead of HTTP we are going to look
    for http.cookie:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始一次新的捕获，看看是否能够实际捕获cookie。我们将前往我们的Windows机器，然后访问之前已经登录过的Dailymotion网站。如我们所见，它没有要求我重新登录，因为我们已经登录了，并且页面上已经显示了用户名，我们就进入这个频道。这是我们创建的一个假频道。我们进入Wireshark并停止捕获，然后我们不再搜索HTTP，而是搜索http.cookie：
- en: '![](assets/b5fad3b9-2c0e-484c-bc76-f42e3a11a69c.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5fad3b9-2c0e-484c-bc76-f42e3a11a69c.png)'
- en: So if we go down, the person got to their home page, which is the username,
    the fake username that we had. Now, if we go to the `POST` request before that
    and look at the hypertext, we can see the cookie that was sent to authenticate
    that person. We can just download a plugin for our browser and inject these cookies
    into that browser. We will be able to log in to that username, to that account,
    without using the password, the same way as the user. This is the same as we did
    with ferret and hamster. Again, we are just doing this to see that Wireshark can
    be used to do all of the attacks that we did before, plus much more, because basically,
    it can capture anything that flows through our device. Any request sent or received
    to or from the target computers will flow through our interface, and then Wireshark
    will capture anything. Regardless of whether it thinks it's important or not,
    it's going to capture everything, so it's a really, really handy and useful tool.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们往下看，用户到达了他们的主页，这是我们之前创建的假用户名。现在，如果我们去查看前面的`POST`请求，并查看超文本，我们可以看到用来认证这个用户的cookie。我们只需要为浏览器下载一个插件，并将这些cookie注入到浏览器中。这样我们就可以像用户一样登录到该账户，而不需要密码。这就像我们之前在使用ferret和hamster时做的一样。同样，我们这样做是为了证明Wireshark可以用于进行我们之前执行的所有攻击，甚至更多，因为基本上它可以捕获任何流经我们设备的数据。任何发送或接收的请求，不管是来自还是发往目标计算机的数据，都会流经我们的接口，Wireshark将捕获一切。无论Wireshark认为这些数据是否重要，它都会捕获所有内容，因此它是一个非常非常方便和有用的工具。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The first section of the chapter was about the MITM framework, which can be
    used for one of the most powerful attacks we can perform on a network. We performed
    a MITM attack using arpspoof, we bypassed HTTPS, we indulged in session hijacking,
    we looked at DNS-spoofing, we saw keyloggers, and we covered code injection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分讲述了MITM框架，它可以用于我们在网络上执行的最强大攻击之一。我们使用arpspoof进行了MITM攻击，绕过了HTTPS，进行会话劫持，研究了DNS欺骗，观察了键盘记录器，并涵盖了代码注入。
- en: Later, we learned about the Wireshark tool, which is a very effective tool for
    gathering information about clients by analyzing the packets that are sent in
    and out through a particular target. It lets users decode the information it carries.
    We learned the basics of how to use it, and we also learned how to apply and analyze
    a few filters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我们了解了Wireshark工具，它是通过分析特定目标进出数据包来收集客户端信息的非常有效的工具。它允许用户解码其中携带的信息。我们学习了如何使用它的基础知识，也学习了如何应用和分析一些过滤器。
- en: The next chapter covers the ARP poisoning attack, as well as how to detect and
    prevent this attack. We will be using Wireshark for detection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍ARP中毒攻击，以及如何检测和防止这种攻击。我们将使用Wireshark进行检测。
