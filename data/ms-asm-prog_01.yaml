- en: Intel Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔架构
- en: <q>-What languages do you usually use?</q> <q>-C and Assembly. In fact, I love
    programming in Assembly.</q>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <q>-你通常使用什么语言？</q> <q>-C 和汇编。事实上，我喜欢用汇编编程。</q>
- en: <q>-Hmmm... I would not have publicly admitted that...</q>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <q>-嗯……我可不敢公开承认这一点……</q>
- en: When speaking about the Assembly language, people usually imagine a sort of
    unknown and dangerous beast, which obeys only the weirdest representatives of
    the programming community, or a gun that may only be used for shooting your own
    leg. Just as any prejudice, this one is rooted in ignorance and the primal fear
    of the unknown. The purpose of this book is not only to help you overcome this
    prejudice, but also to show how the Assembly language may become a powerful tool,
    a sharp lancet, that will help you perform certain tasks, even sophisticated ones,
    with elegance and relative simplicity, avoiding the unnecessary complications
    which are, sometimes, implied by high-level languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 提到汇编语言时，人们通常会想象它是一种未知且危险的野兽，只听从编程社区中最怪异的代表，或者是一把只能用来射击自己腿部的枪。就像任何偏见一样，这种看法源于无知和对未知的原始恐惧。本书的目的不仅是帮助你克服这种偏见，还要展示如何将汇编语言变成一项强大的工具，一把锋利的手术刀，帮助你优雅而相对简单地完成某些任务，甚至是复杂的任务，避免有时由高级语言带来的不必要的复杂性。
- en: First of all, what is the Assembly language? To put it simply and precisely,
    we may safely define the Assembly language as symbolic or human readable machine
    code as each Assembly instruction translates into a single machine instruction
    (with a few exceptions). To be even more precise, there is no such thing as a
    single Assembly language as, instead, there are numerous Assembly languages--one
    per platform, where a platform is a programmable device. Almost any programmable
    device with a certain instruction set may have its own Assembly language, but
    this is not always so. Exceptions are devices such as, for example, NAND flash
    chips, which have their own command set, but have no means for fetching instructions
    from memory and executing them without implicitly being told to do so.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是汇编语言？简单而精确地说，我们可以安全地将汇编语言定义为符号化或人类可读的机器码，因为每条汇编指令都转换成一条机器指令（少数例外）。更精确地说，并没有单一的汇编语言，而是有多种汇编语言——每个平台有一种，而平台则是指可编程设备。几乎任何具有特定指令集的可编程设备都可能有其自己的汇编语言，但并非总是如此。例外的设备如NAND闪存芯片，虽然它们有自己的指令集，但没有从内存中获取指令并执行的手段，除非明确告知它们去执行。
- en: In order to be able to effectively use the Assembly language, one has to have
    a precise understanding of the underlying platform, as programming in the Assembly
    language means "talking" directly to the device. The deeper such understanding
    is, the more efficient is Assembly programming; however, we are not going to look
    at this in great detail, as this is beyond the scope of the book. One book would
    not be enough to cover each and every aspect of the specific architecture. Since
    we are going to concentrate on the Intel architecture during the course of this
    book, let's try to obtain at least a general understanding of Intel's x86/AMD64
    architectures, and try to enrich it and make it deeper.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够有效地使用汇编语言，必须对底层平台有一个精确的理解，因为用汇编语言编程意味着直接“与设备对话”。理解越深，汇编编程的效率就越高；然而，我们不会详细探讨这一点，因为这超出了本书的范围。一本书不足以涵盖特定架构的每一个方面。由于本书将集中讨论英特尔架构，让我们尽量对英特尔的x86/AMD64架构有一个大致的了解，并努力加深这一理解。
- en: This chapter, in particular, covers processor registers and the functionality
    thereof and briefly describes memory organization (for example, segmentation and
    paging).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲解处理器寄存器及其功能，并简要描述内存组织（例如，分段和分页）。
- en: '**General purpose registers**: Despite the fact that some of them have special
    meanings under certain circumstances, these registers, as the name of the group
    states, may be used for any purpose.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用寄存器**：尽管在某些情况下它们具有特殊的含义，但正如这一组名称所示，这些寄存器可以用于任何目的。'
- en: '**Floating point registers**: These registers are used for floating point operations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点寄存器**：这些寄存器用于浮点运算。'
- en: '**Segment registers**: These registers are hardly accessed by applications
    (the most common case is setting up structured exception handlers on Windows);
    however, it is important to cover them here so we may better understand the way
    the CPU percives RAM. The part of the chapter that discusses segment registers
    also addresses a few memory organization aspects, such as segmentation and paging.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**段寄存器**：这些寄存器很少被应用程序访问（最常见的情况是在Windows上设置结构化异常处理程序）；然而，在这里讨论它们很重要，因为它能帮助我们更好地理解CPU是如何看待内存的。本章讨论段寄存器的部分还涉及到一些内存组织的方面，例如分段和分页。'
- en: '**Control registers**: This is a tiny group of registers of registers of high
    importance, as they control the behavior of the processor as well as enable or
    disable certain features.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制寄存器**：这是一个非常小的寄存器组，具有重要的作用，因为它们控制着处理器的行为，并启用或禁用某些功能。'
- en: '**Debug registers**: Although registers of this group are mainly used by debuggers,
    they add some interesting abilities to our code, for example the ability to set
    hardware breakpoints when tracing execution of a program.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试寄存器**：尽管这一组寄存器主要由调试器使用，但它们为我们的代码增加了一些有趣的功能，例如在追踪程序执行时设置硬件断点的能力。'
- en: '**EFlags register**: This is also known as the status register on some platforms.
    This one provides us with the information regarding the result of the latest **arithmetic
    logic unit** (**ALU**) operation performed, as well as some settings of the CPU
    itself.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EFlags寄存器**：在某些平台上，这也被称为状态寄存器。这个寄存器提供了关于最新执行的**算术逻辑单元**（**ALU**）操作结果的信息，以及一些CPU自身的设置。'
- en: Processor registers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器寄存器
- en: 'Each programmable device, and Intel processors are not an exception, has a
    set of general purpose registers--memory cells located physically on the die,
    thus providing low latency access. They are used for temporary storage of data
    that a processor operates on or data that is frequently accessed (if the amount
    of general purpose registers allows this). The amount and bit size of registers
    on an Intel CPU vary in accordance with the current mode of operation. An Intel
    CPU has at least two modes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可编程设备，包括英特尔处理器，都有一组通用寄存器——这些是位于芯片上物理位置的存储单元，因此提供了低延迟访问。它们用于临时存储处理器操作的数据或经常访问的数据（如果通用寄存器的数量允许的话）。英特尔CPU的寄存器数量和位大小根据当前的操作模式而有所不同。英特尔CPU至少有两种模式：
- en: '**Real mode**: This is the good old DOS mode. When the processor is powered
    up, it starts in the real mode, which has certain limitations, such as the size
    of the address bus, which is only 20 bits, and the segmented memory space.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实模式**：这就是老旧的DOS模式。当处理器启动时，它会进入实模式，这种模式有一定的限制，例如地址总线的大小仅为20位，并且采用分段内存空间。'
- en: '**Protected mode**: This was first introduced in 80286\. This mode provides
    access to larger amount of memory, as it uses different memory segmentation mechanisms.
    Paging, introduced in 80386, allows even easier memory addressing virtualization.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护模式**：该模式最早在80286中引入。它通过使用不同的内存分段机制，提供了对更大内存空间的访问。80386引入的分页技术使得内存寻址虚拟化变得更加容易。'
- en: Since about 2003, we also have the so-called long mode--64-bit registers/addressing
    (although, not all 64 bits are used for addressing yet), flat memory model, and
    RIP-based addressing (addressing relative to the instruction pointer register).
    In this book, we will work with 32-bit protected (there is such a thing as the
    16-bit protected mode, but that is out of scope) and Long, which is a 64-bit mode
    of operation. The long mode may be considered a 64-bit extension of the protected
    mode, which evolved from 16-bit to 32-bit. It is important to know that registers
    accessible in the earlier mode are also accessible in the newer mode, meaning
    that the registers that were accessible in the real mode are also accessible in
    the protected mode, and that registers accessible in the protected mode would
    also be accessible in the long mode (if long mode is supported by the processor).
    There are a few exceptions regarding the bit width of certain registers and we
    will look at this soon in this chapter. However, since 16-bit modes (real and
    16-bit protected modes) are no longer used by application developers (with minor
    possible exceptions), in this book, we will work on protected and long modes only.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自2003年左右起，我们还引入了所谓的长模式——64位寄存器/寻址（尽管并非所有64位都用于寻址），扁平内存模型，以及基于RIP的寻址（相对于指令指针寄存器的寻址）。在本书中，我们将使用32位保护模式（虽然有16位保护模式，但这超出了本书的范围）和长模式，长模式是64位操作模式。长模式可以视为保护模式的64位扩展，而保护模式则从16位发展到32位。重要的是要知道，在早期模式中可以访问的寄存器，在新模式中也可以访问，这意味着在实模式中可以访问的寄存器，在保护模式中也可以访问，保护模式中可访问的寄存器，在长模式中也可以访问（如果处理器支持长模式）。关于某些寄存器位宽的细节会在本章稍后讨论。然而，由于16位模式（实模式和16位保护模式）不再被应用开发者使用（除少数例外），在本书中，我们仅讨论保护模式和长模式。
- en: General purpose registers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用寄存器
- en: Depending on the mode of the operation (protected or long), there are 8 to 16
    available general purpose registers in modern Intel processors. Each register
    is divided into subregisters, allowing access to data with a bit width lower than
    the width of the register.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作模式（保护模式或长模式），现代Intel处理器中有8到16个可用的通用寄存器。每个寄存器被划分为子寄存器，允许访问比寄存器宽度更小的位宽数据。
- en: 'The following table shows general purpose registers (further referred to as
    GPR):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了通用寄存器（以下简称GPR）：
- en: '![](img/b5174939-0612-4c0e-b002-15a4074b8af3.png)![](img/e4c9aef4-6a1f-4690-b55f-fb2f5b0dcd69.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5174939-0612-4c0e-b002-15a4074b8af3.png)![](img/e4c9aef4-6a1f-4690-b55f-fb2f5b0dcd69.png)'
- en: 'Table 1: x86/x86_64 registers'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：x86/x86_64寄存器
- en: All R* registers are only available in the long mode. Registers SIL, DIL, BPL,
    and SPL are only available in the long mode. Registers AH, BH, CH, and DH cannot
    be used in instructions that are not valid outside the long mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的R*寄存器仅在长模式下可用。寄存器SIL、DIL、BPL和SPL仅在长模式下可用。寄存器AH、BH、CH和DH不能在不适用于长模式的指令中使用。
- en: For convenience, we will refer to the registers by their 32-bit names (such
    as EAX, EBX, and so on) when we do not need to explicitly refer to a register
    of a certain bit width. The preceding table shows all general purpose registers
    available on the Intel platform. Some of them are only available in the long mode
    (all 64-bit registers, R* registers, and a few of the 8-bit registers) and certain
    combinations are not allowed. However, despite the fact that we can use those
    registers for any purpose, some of them do have a special meaning in certain circumstances.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们在不需要明确指定某个位宽寄存器时，将以其32位名称（如EAX、EBX等）来引用这些寄存器。上述表格显示了Intel平台上所有可用的通用寄存器。它们中的一些仅在长模式下可用（所有64位寄存器、R*寄存器，以及少数8位寄存器），并且某些组合是不允许的。然而，尽管我们可以将这些寄存器用于任何目的，但在某些情况下，它们确实有特殊的含义。
- en: Accumulators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累加寄存器
- en: The EAX register is also known as an **accumulator** and is used with multiplication
    and division operations, both as implied and target operands. It is important
    to mention that the result of a binary multiplication is twice the size of the
    operands and the result of a binary division consists of two parts (quotient and
    remainder), each of which has the same bit width as the operands. Since the x86
    architecture began with 16-bit registers and for the sake of backward compatibility,
    the EDX register is used for storing partial results when the values of the operands
    are larger than could fit into 8 bits. For example, if we want to multiply two
    bytes, `0x50` and `0x04`, we would expect the result to be `0x140`, which cannot
    be stored in a single byte. However, since the operands were 8 bits in size, the
    result is stored into the AX register, which is 16 bits. But if we want to multiply
    `0x150` by `0x104`, the result would need 17 bits to be stored (`0x150 * 0x104
    = 0x15540`) and, as we have mentioned already, the first x86 registers were only
    16 bits. This is the reason for using an additional register; in the case of the
    Intel architecture, this register is EDX (to be more precise, only the DX part
    would be used in this specific case). As a verbal explanation may sometimes be
    too generalized, it would be better to simply demonstrate the rule.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: EAX 寄存器也称为 **累加器**，用于乘法和除法操作，既作为隐含操作数，也作为目标操作数。值得一提的是，二进制乘法的结果是操作数大小的两倍，而二进制除法的结果由两个部分（商和余数）组成，每个部分的位宽与操作数相同。由于
    x86 架构最初是以 16 位寄存器为基础，并且出于向后兼容性考虑，当操作数的值大于 8 位时，EDX 寄存器用于存储部分结果。例如，如果我们要将两个字节
    `0x50` 和 `0x04` 相乘，预期结果是 `0x140`，它不能存储在一个字节中。然而，由于操作数是 8 位大小，结果存储在 AX 寄存器中，AX
    是 16 位的。但如果我们要将 `0x150` 与 `0x104` 相乘，结果需要 17 位才能存储（`0x150 * 0x104 = 0x15540`），而如前所述，最初的
    x86 寄存器只有 16 位。这就是使用额外寄存器的原因；在英特尔架构中，这个寄存器是 EDX（更准确地说，在这种情况下只使用 DX 部分）。由于口头解释有时过于概括，最好通过实际示例来展示这个规则。
- en: '| **Operand size** | **Source 1** | **Source 2** | **Destination** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **操作数大小** | **源操作数 1** | **源操作数 2** | **目标操作数** |'
- en: '| 8 bits (byte) | AL | 8-bit register or 8-bit memory | AX |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 8 位（字节） | AL | 8 位寄存器或 8 位内存 | AX |'
- en: '| 16 bits (word) | AX | 16-bit register or 16-bit memory | DX:AX |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 16 位（字） | AX | 16 位寄存器或 16 位内存 | DX:AX |'
- en: '| 32 bits (double word) | EAX | 32-bit register or 32-bit memory | EDX:EAX
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 32 位（双字） | EAX | 32 位寄存器或 32 位内存 | EDX:EAX |'
- en: '| 64 bits (quad word) | RAX | 64-bit register or 64-bit memory | RDX:RAX |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 64 位（四字） | RAX | 64 位寄存器或 64 位内存 | RDX:RAX |'
- en: Division implies a slightly different rule. To be more precise, this is the
    inverted multiplication rule, meaning that the result of the operation is half
    the bit width of the dividend, which in turn means that the largest dividend in
    the long mode may be 128-bit wide. The smallest dividend value remains the same
    as in the smallest value of the source operand in the case of multiplication--8
    bits.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除法涉及稍微不同的规则。更准确地说，这是反向乘法规则，意味着操作结果是被除数位宽的一半，这也意味着在长模式下，最大被除数可以是 128 位宽。最小的被除数值与乘法中源操作数的最小值相同——8
    位。
- en: '| **Operand size** | **Dividend** | **Divisor** | **Quotient** | **Remainder**
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **操作数大小** | **被除数** | **除数** | **商** | **余数** |'
- en: '| 8/16 bits | AX | 8-bit register or 8-bit memory | AL | AH |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 8/16 位 | AX | 8 位寄存器或 8 位内存 | AL | AH |'
- en: '| 16/32 bits | DX:AX | 16-bit memory or 16-bit register | AX | DX |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 16/32 位 | DX:AX | 16 位内存或 16 位寄存器 | AX | DX |'
- en: '| 32/64 bits | EDX:EAX | 32-bit register or 32-bit memory | EAX | EDX |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 32/64 位 | EDX:EAX | 32 位寄存器或 32 位内存 | EAX | EDX |'
- en: '| 64/128 bits | RDX:RAX | 64-bit register or 64-bit memory | RAX | RDX |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 64/128 位 | RDX:RAX | 64 位寄存器或 64 位内存 | RAX | RDX |'
- en: Counter
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器
- en: 'ECX register - also known as counter register. This register is used in loops
    as a loop iteration counter. It is first loaded with a number of iterations, and
    then decremented each time the loop instruction is executed until the value stored
    in ECX becomes zero, which instructs the processor to break out of the loop. We
    can compare this to the `do{...}while()` clause in C:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ECX 寄存器 - 也称为计数器寄存器。该寄存器在循环中用作循环迭代计数器。它首先加载一个迭代次数，然后每次执行循环指令时递减，直到 ECX 中存储的值变为零，指示处理器跳出循环。我们可以将其与
    C 中的 `do{...}while()` 子句进行比较：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another common usage of this register, actually the usage of its least significant
    part, CL, is in bitwise shift operations, where it contains the number of bits
    in which the source operand should be shifted. Consider the following code, for
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器的另一个常见用法，实际上是其最低有效部分CL的用法，是位移操作，其中它包含源操作数应移位的位数。例如，考虑以下代码：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would result in the register EAX being shifted 5 bits to the left (having
    the value of `0x2468a0` as a result).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致寄存器EAX被左移5位（结果值为`0x2468a0`）。
- en: Stack pointer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈指针
- en: An ESP register is the stack pointer. This register, together with the SS register
    (the SS register is explained a bit later in this chapter), describes the stack
    area of a thread, where SS contains the descriptor of the stack segment and ESP
    is the index that points to the current position within the stack.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ESP寄存器是堆栈指针。该寄存器与SS寄存器一起（SS寄存器将在本章稍后解释）描述线程的堆栈区域，其中SS包含堆栈段的描述符，而ESP是指向堆栈中当前指针位置的索引。
- en: Source and destination indices
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源和目标索引
- en: ESI and EDI registers serve as source and destination index registers in string
    operations, where ESI contains the source address and EDI, obviously, the destination
    address. We will talk about these registers a bit more in [Chapter 3](57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml),
    *Intel Instruction Set Architecture (ISA)*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ESI和EDI寄存器在字符串操作中作为源和目标索引寄存器，其中ESI包含源地址，EDI显然包含目标地址。我们将在[第3章](57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml)中更多地讨论这些寄存器，*英特尔指令集架构（ISA）*。
- en: Base pointer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基址指针
- en: EBP. This register is called the base pointer as its most common use is to point
    to the base of a stack frame during function calls. However, unlike the previously
    discussed registers, you may use any other register for this purpose if needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: EBP。这个寄存器被称为基址指针，因为它最常见的用途是在函数调用期间指向堆栈帧的基址。然而，与前面讨论的寄存器不同，如果需要，你可以使用任何其他寄存器来完成此目的。
- en: Another register worth mentioning here is EBX, which, in the good old days of
    16-bit modes (when it was still just a BX register), was one of the few registers
    that we could use as a base for addressing. Unlike EBP, EBX was (in the case of
    the XLAT instruction, which by default uses DS:EBX, still is) intended to point
    to a data segment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还值得提到另一个寄存器EBX，它在16位模式的“好日子”里（当时它还是BX寄存器）是我们可以用作寻址基址的少数寄存器之一。与EBP不同，EBX（在XLAT指令的情况下，默认使用DS:EBX，至今仍然如此）旨在指向数据段。
- en: Instruction pointer
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令指针
- en: There is one more special register that cannot be used for data storage--EIP
    (IP in the real mode or RIP in the long mode). This is the instruction pointer
    and contains the address of the instruction after the instruction currently being
    executed. All instructions are implicitly fetched from the code segment by the
    CPU; thus the full address of the instruction following the one being executed
    should be described as CS:IP. Also, there is no regular way to modify its content
    directly. It is not impossible, but we can't just use a `mov` instruction in order
    to load a value into EIP.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个特殊寄存器不能用于数据存储——EIP（在实模式下为IP，长模式下为RIP）。这是指令指针，包含当前执行的指令之后的指令地址。所有指令都会由CPU隐式从代码段获取；因此，执行的指令之后的完整地址应描述为CS:IP。此外，没有常规方法可以直接修改其内容。虽然这并非不可能，但我们不能仅仅使用`mov`指令将值加载到EIP中。
- en: All the other registers have no special meaning from the processor's perspective
    and may be used for any purpose.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他寄存器从处理器的角度来看没有特殊含义，可以用于任何目的。
- en: Floating point registers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点寄存器
- en: The CPU itself has no means for floating point arithmetic operations. In 1980,
    Intel announced the Intel 8087 - the floating point coprocessor for the 8086 line.
    8087 remained as a separate installable device until 1989, when Intel came up
    with the 80486 (i486) processor, which had an integrated 8087 circuit. However,
    when talking about floating point registers and floating point instructions, we
    still refer to 8087 as a floating-point unit (FPU) or, sometimes, still as a floating-point
    coprocessor (however, the latter is becoming more and more rare).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CPU本身没有进行浮点运算的功能。1980年，英特尔推出了Intel 8087——为8086系列设计的浮点协处理器。8087一直作为一个可单独安装的设备存在，直到1989年，英特尔推出了集成8087电路的80486（i486）处理器。然而，当谈到浮点寄存器和浮点指令时，我们仍然将8087称为浮点单元（FPU），有时仍称其为浮点协处理器（不过后者越来越少见）。
- en: 8087 has eight registers, 80 bits each, arranged in a stack fashion, meaning
    that operands are pushed onto this stack from the memory and results are popped
    from the topmost register to the memory. These registers are named ST0 to ST7
    (ST--stack) and the most used one, that is, the ST0 register, may be referred
    to as simply ST.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 8087处理器有八个寄存器，每个寄存器都是80位，按照栈的方式排列，这意味着操作数从内存推入此栈，结果从最顶端的寄存器弹出到内存。这些寄存器命名为ST0到ST7（ST--栈），其中使用最频繁的是ST0寄存器，可以简称为ST。
- en: 'The floating-point coprocessor supports several data types:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点协处理器支持多种数据类型：
- en: 80-bit extended-precision real
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 80位扩展精度实数
- en: 64-bit double-precision real
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位双精度实数
- en: 32-bit single-precision real
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位单精度实数
- en: 18-digit decimal integer
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 18位十进制整数
- en: 64-bit binary integer
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位二进制整数
- en: 32-bit binary integer
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位二进制整数
- en: 16-bit binary integer
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位二进制整数
- en: The floating-point coprocessor will be discussed in more detail in [Chapter
    3](57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml), *Intel Instruction Set Architecture
    (ISA)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点协处理器将在[第3章](57c5447c-2cc4-4a48-9c46-6825e4a83a9c.xhtml)，*Intel指令集架构（ISA）*中详细讨论。
- en: XMM registers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMM寄存器
- en: 'The 128-bit XMM registers are part of the SSE extension (where **SSE** is short
    for **Streaming SIMD Extension**, and **SIMD**, in turn, stands for **single instruction
    multiple data**). There are eight XMM registers available in non -64-bit modes
    and 16 XMM registers in long mode, which allow simultaneous operations on:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 128位XMM寄存器是SSE扩展的一部分（其中**SSE**是**流处理单指令多数据扩展**的缩写）。在非64位模式下有八个XMM寄存器，在长模式下有16个XMM寄存器，允许对以下内容进行并行操作：
- en: 16 bytes
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16字节
- en: eight words
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个字
- en: four double words
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个双字
- en: two quad words
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个四字
- en: four floats
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个浮点数
- en: two doubles
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个双精度实数
- en: We will pay much more attention to these registers and the technology behind
    them in [Chapter 5](81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml), *Parallel Data
    Processing*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](81d8a530-f9fe-484d-83f7-652ce31bfa1c.xhtml)，*并行数据处理*中更加关注这些寄存器及其背后的技术。
- en: Segment registers and memory organization
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 段寄存器和内存组织
- en: Memory organization is one of the most important aspects of CPU design. The
    first thing to note is that when we say "memory organization", we do not mean
    its physical layout on memory chips/boards. For us, it is much more important
    how the CPU sees memory and how it communicates with it (on a higher level, of
    course, as we are not going to dive into the hardware aspects of the architecture).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内存组织是CPU设计中最重要的方面之一。首先要注意的是，当我们说“内存组织”时，我们并不是指它在内存芯片/板上的物理布局。对我们来说，更重要的是CPU如何看待内存以及它如何与之通信（当然，这是在更高层次上，因为我们不会深入讨论架构的硬件方面）。
- en: However, as the book is dedicated to application programming, rather than operating
    system development, we will further consider the most relevant aspects of memory
    organization and access in this section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于本书专注于应用程序编程，而非操作系统开发，在本节中我们将进一步考虑内存组织和访问中最相关的方面。
- en: Real mode
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实模式
- en: Segment registers are a rather interesting topic, as they are the ones that
    tell the processor which memory areas may be accessed and how exactly they may
    be accessed. In real mode, segment registers used to contain a 16-bit segment
    address. The difference between a normal address and segment address is that the
    latter is shifted 4 bits to the right when stored in the segment register. For
    example, if a certain segment register was loaded with the `0x1234` value, it,
    in fact, was pointing to the address `0x12340`; therefore, pointers in real mode
    were rather offsets into segments pointed to by segment registers. As an example,
    let's take the DI register (as we are talking about a 16-bit real mode now), which
    is used with the DS (data segment) register automatically, and load it with, let's
    say, `0x4321` when the DS register is loaded with the `0x1234` value. Then the
    20-bit address would be `0x12340 + 0x4321 = 0x16661`. Thus, it was possible to
    address at most 1 MB of memory in real mode.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 段寄存器是一个非常有趣的主题，因为它们告诉处理器哪些内存区域可以访问，以及如何访问。在实模式下，段寄存器用于包含一个16位段地址。普通地址和段地址的区别在于后者在存储到段寄存器时向右移动4位。例如，如果某个段寄存器加载了`0x1234`值，实际上指向的地址是`0x12340`；因此，在实模式中，指针实际上是段寄存器指向的段的偏移量。例如，我们来看看DI寄存器（因为我们现在讨论的是16位实模式），它会自动与DS（数据段）寄存器一起使用，并且当DS寄存器加载了`0x1234`值时，将其加载为`0x4321`，那么20位地址将会是`0x12340
    + 0x4321 = 0x16661`。因此，在实模式下最多可以寻址1MB内存。
- en: 'There are in total six segment registers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有六个段寄存器：
- en: '**CS**: This register contains the base address of the currently used code
    segment.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CS**：该寄存器包含当前使用的代码段的基地址。'
- en: '**DS**: This register contains the base address of the currently used data
    segment.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DS**：该寄存器包含当前使用的数据段的基地址。'
- en: '**SS**: This register contains the base address of the currently used stack
    segment.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SS**：该寄存器包含当前使用的堆栈段的基地址。'
- en: '**ES**: This is the extra data segment for the programmer''s use.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES**：这是供程序员使用的附加数据段。'
- en: '**FS** and **GS**: These were introduced with the Intel 80386 processor. These
    two segment registers have no specific hardware-defined function and are for the
    programmer''s use. It is important to know that they do have specific tasks in
    Windows and Linux, but those tasks are operating system dependent only and have
    no connection to hardware specifications.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FS**和**GS**：这两个寄存器是随着Intel 80386处理器引入的。这两个段寄存器没有特定的硬件定义功能，供程序员使用。需要知道的是，它们在Windows和Linux中有特定的任务，但这些任务仅与操作系统相关，并与硬件规范无关。'
- en: The CS register is used together with the IP register (the instructions pointer,
    also known as the program counter on other platforms), where the IP (or EIP in
    protected mode and RIP in long mode) points to the offset of the instruction in
    the code segment following the instruction currently being executed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CS寄存器与IP寄存器（指令指针，也叫程序计数器）一起使用，其中IP（在保护模式下为EIP，在长模式下为RIP）指向当前正在执行的指令的偏移量，在代码段中跟随该指令。
- en: 'DS and ES are implied when using SI and DI registers, respectively, unless
    another segment register is implicitly specified in the instruction. For example,
    the `lodsb` instruction, although, it is written with no operands, loads a byte
    from the address specified by DS:SI into the AL register and the `stosb` instruction
    (which has no visible operands either) stores a byte from the AL register at the
    address specified by ES:DI. Using SI/DI registers with other segments would require
    explicitly mentioning those segments with the relevant segment register. Consider
    the following code, for example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SI和DI寄存器时，分别隐含使用DS和ES段寄存器，除非指令中隐式指定了其他段寄存器。例如，`lodsb`指令虽然没有操作数，但会从由DS:SI指定的地址加载一个字节到AL寄存器中，而`stosb`指令（同样没有可见操作数）会将AL寄存器中的一个字节存储到由ES:DI指定的地址中。使用SI/DI寄存器与其他段时，需要显式提及相关段寄存器。考虑以下代码示例：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code loads a double word from the location pointed by DS:SI and
    stores it to another location pointed by ES:DI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从DS:SI指向的位置加载一个双字，并将其存储到由ES:DI指向的另一个位置。
- en: The interesting thing about segment registers and segments at all is that they
    may peacefully overlap. Consider a situation where you want to copy a portion
    of code to either another place in the code segment or into a temporary buffer
    (for example, for decryptor). In such a case, both CS and DS registers may either
    point to the same location or the DS register may point somewhere into the code
    segment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 段寄存器和段的一个有趣之处在于，它们可以平稳重叠。例如，如果你想将一部分代码复制到代码段中的另一个位置或临时缓冲区（例如，用于解密器），此时，CS和DS寄存器可以指向相同位置，或者DS寄存器可以指向代码段的某个地方。
- en: Protected mode - segmentation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护模式 - 分段
- en: 'While it was all fine and simple in real mode, things become a bit more complicated
    when it comes to protected mode. Unfortunately, memory segmentation is still intact,
    but the segment register no longer contain addresses. Instead, they are loaded
    with the so-called selectors, which are, in turn, the indices into the descriptor
    table multiplied by 8 (shifted 3 bits to the left). The two least significant
    bits designate the requested privilege level (0 for kernel space to 3 for user
    land). The third bit (at index 2) is the **TI** bit (**table indicator**), which
    indicates whether the descriptor being referred is in a global descriptor table
    (0) or in a local descriptor table (1). The memory descriptor is a tiny 8-byte
    structure, which describes the range of physical memory, its access rights, and
    some additional attributes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实模式下，一切都很简单明了，但到了保护模式，事情变得复杂了。不幸的是，内存分段仍然存在，但段寄存器不再包含地址。相反，它们加载了所谓的选择子，这些选择子是描述符表中的索引，并乘以8（向左移位3位）。最低的两位表示请求的权限级别（0表示内核空间，3表示用户空间）。第三位（在索引2处）是**TI**位（**表指示符**），表示所引用的描述符是位于全局描述符表（0）还是局部描述符表（1）。内存描述符是一个小型8字节结构，描述了物理内存的范围、访问权限和一些附加属性：
- en: '![](img/36cdd2b3-3d39-4bab-9dff-512d9d120b34.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36cdd2b3-3d39-4bab-9dff-512d9d120b34.png)'
- en: 'Table 2: Memory descriptor structure'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：内存描述符结构
- en: 'Descriptors are stored in at least two tables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符至少存储在两个表中：
- en: '**GDT**: Global descriptor table (used by the operating system)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GDT**：全局描述符表（由操作系统使用）'
- en: '**LDT**: Local descriptor table (per task descriptor table)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDT**：局部描述符表（每个任务描述符表）'
- en: As we may conclude, the organization of memory in protected mode is not that
    different from that in real mode after all.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以得出的结论，保护模式下的内存组织实际上与实模式并没有太大的不同。
- en: There are other types of descriptors--interrupt descriptors (stored in the **interrupt
    description table** (**IDT**)) and system descriptors; however, since these are
    in use in kernel space only, we will not discuss them, as that falls out of the
    scope of this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的描述符——中断描述符（存储在**中断描述符表**（**IDT**）中）和系统描述符；然而，由于这些只在内核空间中使用，我们不会讨论它们，因为它们超出了本书的范围。
- en: Protected mode - paging
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护模式 - 分页
- en: Paging is a more convenient memory management scheme introduced in 80386 and
    has been a bit enhanced since then. The idea behind paging is memory virtualization--this
    is the mechanism that makes it possible for different processes to have the same
    memory layout. In fact, the addresses we use in pointers (if we are writing in
    C, C++, or any other high-level language that compiles into native code) are virtual
    and do not correspond to physical addresses. The translation of a virtual address
    into a physical address is implemented in hardware and is performed by the CPU
    (however, some operating system interventions are possible).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是一种在80386中引入的更方便的内存管理方案，并且此后有所增强。分页的核心思想是内存虚拟化——这是使不同进程能够拥有相同内存布局的机制。实际上，我们在指针中使用的地址（如果我们用C、C++或任何其他编译成本地代码的高级语言编程）是虚拟地址，并不对应于物理地址。虚拟地址到物理地址的转换由硬件实现，由CPU执行（不过，也可能有一些操作系统干预）。
- en: By default, a 32-bit CPU uses a two-level translation scheme for the derivation
    of a physical address from the supplied virtual one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，32位CPU使用两级转换方案将提供的虚拟地址转换为物理地址。
- en: 'The following table explains how a virtual address is used in order to find
    a physical address:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了如何使用虚拟地址来查找物理地址：
- en: '| **Address bits** | **Meaning** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **地址位** | **含义** |'
- en: '| 0 - 11 | Offset into a 4 KB page |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 11 | 在4KB页面中的偏移量 |'
- en: '| 12 - 21 | Index of the page entry in the table of 1024 pages |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 12 - 21 | 1024页的页表中的页项索引 |'
- en: '| 22 - 31 | Index of the page table entry in a 1024-entries page directory
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 22 - 31 | 页目录中1024条目页表项的索引 |'
- en: 'Table 3: Virtual address to physical address translation'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：虚拟地址到物理地址的转换
- en: 'Most, if not all, modern processors based on the Intel architecture also support
    **Page Size Extension** (**PSE**), which makes it possible to use the so-called
    large pages of 4 MB. In this case, the translation of a virtual address into a
    physical address is a bit different, as there is no page table any more. The following
    table shows the meaning of bits in a 32-bit virtual address:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于 Intel 架构的现代处理器都支持**页面大小扩展**（**PSE**），这使得使用所谓的 4 MB 大页面成为可能。在这种情况下，虚拟地址到物理地址的转换有所不同，因为不再有页面表。以下表格展示了
    32 位虚拟地址中各位的含义：
- en: '| **Address bits** | **Meaning** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **地址位** | **含义** |'
- en: '| 0 - 21 | Offset into a 4 MB page |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 21 | 4 MB 页面中的偏移量 |'
- en: '| 22 - 31 | Index of the corresponding entry in a 1024-entries page directory
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 22 - 31 | 1024项页面目录中相应条目的索引 |'
- en: 'Table 4: Virtual address to physical address translation with PSE enabled'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4：启用 PSE 时虚拟地址到物理地址的转换
- en: 'Furthermore, the **Physical Address Extension** (**PAE**) was introduced, which
    significantly changes the scheme and allows access to a much bigger range of memory.
    In protected mode, PAE adds a page directory pointer table of four entries and
    the virtual to physical address conversion would be as per the following table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**物理地址扩展**（**PAE**）被引入，显著改变了地址映射方案，允许访问更大的内存范围。在保护模式下，PAE 增加了一个四项条目的页面目录指针表，虚拟地址到物理地址的转换如下表所示：
- en: '| **Address bits** | **Meaning** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **地址位** | **含义** |'
- en: '| 0 - 11 | Offset into a 4 KB page |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 11 | 4 KB 页面中的偏移量 |'
- en: '| 12 - 20 | Index of a page entry in the table of 512 pages |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 12 - 20 | 512 页面表中的页面条目的索引 |'
- en: '| 21 - 29 | Index of a page table entry in a 512-entries page directory |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 21 - 29 | 512 项页面目录中的页面表项索引 |'
- en: '| 30 - 31 | Index of a page directory entry in a four-entries page directory
    pointer table |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 30 - 31 | 四项页面目录指针表中页面目录条目的索引 |'
- en: 'Table 5: Virtual to physical address translation with PAE enabled (no PSE)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5：启用 PAE（未启用 PSE）时的虚拟地址到物理地址转换
- en: Enabling PSE in addition to PAE forces each entry in the page directory to point
    directly to a 2 MB page instead of an entry in a page table.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 PSE 并同时启用 PAE 会强制页面目录中的每个条目直接指向一个 2 MB 的大页面，而不是指向页面表中的条目。
- en: Long mode - paging
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长模式 - 分页
- en: 'The only address virtualization allowed in long mode is paging with PAE enabled;
    however, it adds one more table--the page map level 4 table as the root entry;
    therefore, the conversion of a virtual address to a physical address uses the
    bits of a virtual address in the way described in the following table:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 长模式下唯一允许的地址虚拟化方式是启用 PAE 的分页；但是，它增加了一个新的表——页面映射级别 4 表作为根条目。因此，虚拟地址到物理地址的转换按以下表格所示，使用虚拟地址中的各个位：
- en: '| **Address bits** | **Meaning** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **地址位** | **含义** |'
- en: '| 0 - 11 | Offset into a 4 KB page |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 0 - 11 | 4 KB 页面中的偏移量 |'
- en: '| 12 - 20 | Index of a page entry in the table of 512 pages |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 12 - 20 | 512 页面表中的页面条目的索引 |'
- en: '| 21 - 29 | Index of a page table entry in the page directory |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 21 - 29 | 页面目录中页表项的索引 |'
- en: '| 30 - 38 | Index of a page directory entry in the page directory pointer table
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 30 - 38 | 页面目录指针表中页面目录条目的索引 |'
- en: '| 39 - 47 | Index of a page directory pointer table in the page-map level 4
    table |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 39 - 47 | 页面目录指针表在页面映射级别 4 表中的索引 |'
- en: 'Table 6: Virtual to physical address translation in long mode'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6：长模式下虚拟地址到物理地址的转换
- en: It is, however, important to mention that despite the fact that it is a 64-bit
    architecture, the MMU only uses the first 48 bits of the virtual address (also
    called the linear address).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要指出的是，尽管它是 64 位架构，MMU 仅使用虚拟地址的前 48 位（也称为线性地址）。
- en: The whole process of address resolution is performed by the **memory management
    unit** (**MMU**) in the CPU itself, and the programmer is only responsible for
    actually building these tables and enabling PAE/PSE. However, this topic is much
    wider than may be covered in a single chapter and falls a bit out of the scope
    of this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 地址解析的整个过程由 CPU 内部的**内存管理单元**（**MMU**）执行，程序员仅需负责实际构建这些表并启用 PAE/PSE。然而，这个话题远远超出了本书的范围，涉及的内容较广。
- en: Control registers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制寄存器
- en: Processors based on the Intel architecture have a set of control registers that
    are used for configuration of the processor at run time (such as switching between
    execution modes). These registers are 32-bit wide on x86 and 64-bit wide on AMD64
    (long mode).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Intel架构的处理器有一组控制寄存器，用于在运行时配置处理器（例如切换执行模式）。这些寄存器在x86上为32位宽，在AMD64（长模式）上为64位宽。
- en: 'There are six control registers and one **Extended Feature Enable Register**
    (**EFER**):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个控制寄存器和一个**扩展功能启用寄存器**（**EFER**）：
- en: '**CR0**: This register contains various control flags that modify the basic
    operation of the processor.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR0**：此寄存器包含修改处理器基本操作的各种控制标志。'
- en: '**CR1**: This register is reserved for future use.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR1**：此寄存器保留供未来使用。'
- en: '**CR2**: This register contains the Page Fault Linear Address when a page fault
    occurs.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR2**：当发生页面错误时，此寄存器包含页面错误的线性地址。'
- en: '**CR3**: This register is used when virtual addressing is enabled (paging)
    and contains the physical address of the page directory, page directory pointer
    table, or page map level 4 table, depending on the current mode of operation.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR3**：此寄存器在启用虚拟地址（分页）时使用，并包含页面目录、页面目录指针表或页面映射级别4表的物理地址，具体取决于当前的操作模式。'
- en: '**CR4**: This register is used in the protected mode for controlling different
    options of the processor.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR4**：此寄存器在保护模式下用于控制处理器的不同选项。'
- en: '**CR8**: This register is new and is only available in long mode. It is used
    for prioritization of external interrupts.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CR8**：此寄存器是新的，仅在长模式下可用。它用于外部中断的优先级排序。'
- en: '**EFER**: This register is one of the several model-specific registers. It
    is used for enabling/disabling SYSCALL/SYSRET instructions, entering/exiting long
    mode, and a few other features. Other model-specific registers are of no interest
    for us.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EFER**：此寄存器是多个特定于型号的寄存器之一。它用于启用/禁用SYSCALL/SYSRET指令、进入/退出长模式以及其他一些功能。其他特定于型号的寄存器对我们无关紧要。'
- en: However, these registers are not accessible in `ring3` (user land).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些寄存器在`ring3`（用户态）中不可访问。
- en: Debug registers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试寄存器
- en: In addition to control registers, processors also have a set of so-called debug
    registers, which are mostly used by debuggers for setting the so-called hardware
    breakpoints. These registers are in fact a very powerful tool when it comes to
    control over other threads or even processes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制寄存器外，处理器还具有一组所谓的调试寄存器，这些寄存器主要由调试器用于设置所谓的硬件断点。事实上，这些寄存器在控制其他线程甚至进程时是非常强大的工具。
- en: Debug address registers DR0 - DR3
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试地址寄存器DR0 - DR3
- en: Debug registers 0 to 3 (DR0, DR1, DR2, and DR3) are used to store virtual (linear)
    addresses of the so-called hardware breakpoints.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调试寄存器0到3（DR0、DR1、DR2和DR3）用于存储所谓的硬件断点的虚拟（线性）地址。
- en: Debug control register (DR7)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试控制寄存器（DR7）
- en: DR7 defines how the breakpoints set in **Debug Address Registers** should be
    interpreted by the processor and whether they should be interpreted at all.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: DR7定义了**调试地址寄存器**中设置的断点如何被处理器解释，以及是否需要被解释。
- en: 'The bits layout of this register is shown in the following table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该寄存器的位布局如下表所示：
- en: '![](img/419c0ba2-0820-456b-bcba-26304a641d71.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/419c0ba2-0820-456b-bcba-26304a641d71.png)'
- en: 'Table 3: DR7 bit layout'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：DR7位布局
- en: L* bits, when set to 1, enable breakpoint at the address which is specified
    in the corresponding Debug Address Register locally--within a task. These bits
    are reset by the processor on each task switch. G* bits, on the contrary, enable
    breakpoints globally--for all tasks, meaning that these bits are not reset by
    the processor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: L*位，当设置为1时，在相应的调试地址寄存器中指定的地址处启用断点--在任务内本地启用。这些位在每次任务切换时由处理器重置。G*位，相反，启用全局断点--适用于所有任务，意味着这些位不会被处理器重置。
- en: 'The R/W* bits specify breakpoint conditions, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: R/W*位指定断点条件，如下所示：
- en: '`00`: Break on instruction execution'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`：在指令执行时断点'
- en: '`01`: Break when the specified address is accessed for writing only'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`：仅在指定地址被写入时触发断点'
- en: '`10`: Undefined'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`：未定义'
- en: '`11`: Break on either read or write access or when an instruction at the specified
    address is executed'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`11`：在读取或写入访问时，或在指定地址处执行指令时触发断点'
- en: 'The LEN* bits specify the size of a breakpoint in bytes, thus, allowing coverage
    of more than one instruction or more than one byte of data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LEN*位指定断点的大小（以字节为单位），因此可以覆盖多个指令或多个字节的数据：
- en: '`00`: Breakpoint is 1-byte long'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`：断点为1字节长'
- en: '`01`: Breakpoint is 2-bytes long'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`：断点为2字节长'
- en: '`10`: Breakpoint is 8-bytes long (long mode only)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`: 断点为 8 字节长（仅长模式下）'
- en: '`11`: Breakpoint is 4-bytes long'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`11`: 断点为 4 字节长'
- en: Debug status register (DR6)
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试状态寄存器（DR6）
- en: When an enabled breakpoint is triggered, the corresponding bit of the four low-order
    bits in DR6 is set to 1 before entering the debug handler, thus, providing the
    handler with information about the triggered breakpoint (bit 0 corresponds to
    the breakpoint in DR0, bit 1 to the breakpoint in DR1, and so on).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用断点触发时，DR6 中低四位的相应位会在进入调试处理程序之前被置为 1，从而为处理程序提供有关触发断点的信息（位 0 对应 DR0 中的断点，位
    1 对应 DR1 中的断点，依此类推）。
- en: The EFlags register
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EFlags 寄存器
- en: It would have been impossible to write programs in any language for a given
    platform if the processor had no means to report its status and/or the status
    of the last operation. More than that, the processor itself needs this information
    from time to time. Try to imagine a processor unable to conditionally control
    the execution flow of a program--sounds like a nightmare, doesn't it?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理器没有办法报告其状态和/或最后一次操作的状态，任何语言的程序都无法在给定的平台上编写。更重要的是，处理器本身有时也需要这些信息。试想一下，如果处理器无法有条件地控制程序的执行流程——这听起来像一场噩梦，不是吗？
- en: The most common way for a program to obtain information on the last operation
    or on a certain configuration of an Intel-based processor is through the **EFlags**
    register (**E** stands for extended). This register is referred to as Flags in
    real mode, EFlags in protected mode, or **RFlags** in long mode.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关最后操作或 Intel 架构处理器某些配置的信息，程序最常用的方式是通过**EFlags**寄存器（**E**代表扩展）。该寄存在实模式下称为
    Flags，在保护模式下称为 EFlags，在长模式下称为**RFlags**。
- en: Let's take a look at the meaning of the individual bits (also referred to as
    flags) of this register and its usage.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个寄存器中各个位（也称为标志）的含义及其使用。
- en: 'Bit #0 - carry flag'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #0 - 进位标志'
- en: The **carry flag** (**CF**) is mostly used for the detection of carry/borrow
    in arithmetic operations and is set if the bit width result of the last such operation
    (such as addition and subtraction) exceeds the width of the ALU. For example,
    the addition of two 8-bit values, 255 and 1, would result in 256, which requires
    at least nine bits to be stored. In such a case, bit eight (the ninth bit) is
    placed into the CF, thus, letting us and the processor know that the last operation
    ended with carry.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**进位标志**（**CF**）主要用于检测算术运算中的进位/借位，并在最后一次此类运算的结果位宽（例如加法和减法）超出 ALU 的位宽时置位。例如，两个
    8 位值 255 和 1 相加会得到 256，这需要至少 9 位来存储。在这种情况下，第八位（第九位）被置入 CF，从而让我们和处理器知道最后的操作有进位。'
- en: 'Bit #2 - parity flag'
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #2 - 奇偶标志'
- en: The **parity flag** (**PF**) is set to 1 in case the number of 1s in the least
    significant byte is even; otherwise, the flag is set to zero.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**奇偶标志**（**PF**）在最低有效字节中 1 的个数为偶数时置为 1；否则，置为零。'
- en: 'Bit #4 - adjust flag'
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #4 - 调整标志'
- en: The **adjust flag** (**AF**) signals when a carry or borrow occurred in the
    four least significant bits (lower nibble) and is primarily used with **binary
    coded decimal** (**BCD**) arithmetics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整标志**（**AF**）在最低有效的四个位（低半字节）发生进位或借位时被置位，主要用于**二进制编码十进制**（**BCD**）算术运算。'
- en: 'Bit #6 - zero flag'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #6 - 零标志'
- en: The **zero flag** (**ZF**) is set when the result of an arithmetic or bitwise
    operation is 0\. This includes operations that do not store the result (for example,
    comparison and bit test).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**零标志**（**ZF**）在算术或按位操作的结果为 0 时置位。这包括没有存储结果的操作（例如比较和位测试）。'
- en: 'Bit #7 - sign flag'
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #7 - 符号标志'
- en: The **sign flag** (**SF**) is set when the last mathematical operation resulted
    in a negative number; in other words, when the most significant bit of the result
    was set.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号标志**（**SF**）在上一次数学运算结果为负数时被置位；换句话说，当结果的最高有效位被置位时，符号标志会被置位。'
- en: 'Bit #8 - trap flag'
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #8 - 陷阱标志'
- en: When set, the **trap flag** (**TF**) causes a single step interrupt after every
    executed instruction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当置位时，**陷阱标志**（**TF**）会在每条指令执行后引发单步中断。
- en: 'Bit #9 - interrupt enable flag'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #9 - 中断使能标志'
- en: The **interrup enable flag** (**IF**) defines whether processor will or will
    not react to incoming interrupts. This flag is only accessible in real mode or
    at the Ring 0 protection level in other modes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断使能标志**（**IF**）定义处理器是否对传入的中断做出反应。该标志仅在实模式或其他模式下的 Ring 0 保护级别下可访问。'
- en: 'Bit #10 - direction flag'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #10 - 方向标志'
- en: The **direction flag** (**DF**) controls the direction of string operations.
    An operation is performed from the lower address to the higher address if the
    flag is reset (is 0) or from the higher address to the lower address if the flag
    is set (is 1).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**方向标志**（**DF**）控制字符串操作的方向。如果标志被复位（为 0），操作会从低地址到高地址执行；如果标志被置位（为 1），操作则从高地址到低地址执行。'
- en: 'Bit #11 - overflow flag'
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '位 #11 - 溢出标志'
- en: The **overflow flag** (**OF**) is sometimes perceived as two's complement form
    of the carry flag, which is not really the case. OF is set when the result of
    the operation is either too small or too big a number to fit into the destination
    operand. For example, consider the addition of two 8-bit positive values, 0x74
    and 0x7f. The resulting value of such an addition is 0xf3, which is still 8-bit,
    which is fine for unsigned numbers, but since we added two values that we considered
    to be signed, there has to be the sign bit and there are no more bits to store
    the 9-bit signed result. The same would happen if we try to add two negative 8-bit
    values, 0x82 and 0x81\. The meaning of the addition of two negative numbers is
    in the fact subtraction of a positive number from a negative number, which should
    result in an even smaller number. Thus, 0x82 + 0x81 would result in 0x103, where
    the ninth bit, 1, is the sign bit, but it cannot be stored in an 8-bit operand.
    The same applies to larger operands (16, 32, and 64-bit).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**溢出标志**（**OF**）有时被认为是进位标志的二进制补码形式，但实际上并非如此。OF 在操作的结果太小或太大，无法适配目标操作数时被置位。例如，考虑将两个
    8 位正值 0x74 和 0x7f 相加。这次加法的结果是 0xf3，仍然是 8 位的，对于无符号数来说是可以接受的，但由于我们加的是两个有符号数，必须考虑符号位，而存储
    9 位有符号结果的地方已经没有足够的位数。如果我们尝试加上两个负的 8 位数 0x82 和 0x81，也会发生同样的情况。两个负数相加的意义在于从负数中减去正数，结果应当是一个更小的数。因此，0x82
    + 0x81 将得到 0x103，其中第九位（1）是符号位，但它无法存储在一个 8 位操作数中。更大的操作数（如 16、32 和 64 位）也是如此。'
- en: Remaining bits
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余的位
- en: 'The remaining 20 bits of the EFlags register are not that important for us
    while in user-land except, probably, the ID bit (bit #21). The ID flag indicates
    whether we can or cannot use the CPUID instruction.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '在用户模式下，EFlags 寄存器的剩余 20 位对我们来说并不重要，除非可能是 ID 位（位 #21）。ID 标志指示我们是否可以使用 CPUID
    指令。'
- en: Bits 32 - 63 of the RFlags register in long mode would be all 0s.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在长模式下，RFlags 寄存器的第 32 位到第 63 位将全部为 0。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have briefly run through the basics of the internal structure
    of x86-based processors essential for the further understanding of topics covered
    in later chapters. Being a huge fan of Occam's Razor principle, yours truly had
    no intention to replicate Intel's programmer manual; however, certain topics covered
    in this chapter exceed the range of topics necessary for a successful start with
    Assembly language programming.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地介绍了 x86 架构处理器的内部结构基础知识，这对进一步理解后续章节的主题至关重要。作为奥卡姆剃刀原理的忠实粉丝，我本人并不打算重复英特尔的程序员手册；然而，本章涉及的一些话题超出了成功开始汇编语言编程所必需的内容。
- en: However, I believe that you would agree--we've had enough of dry information
    here and it is the right time to start doing something. Let's begin by setting
    up the development environment for Assembly language programming in [Chapter 2](cb7ac242-8ebb-4d6a-946a-220133f96674.xhtml),
    *Setting Up a Development Environment*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我相信你会同意——我们已经了解了足够的干货，现在是时候开始动手做一些事情了。让我们从在[第二章](cb7ac242-8ebb-4d6a-946a-220133f96674.xhtml)中设置开发环境开始，*设置开发环境*。
