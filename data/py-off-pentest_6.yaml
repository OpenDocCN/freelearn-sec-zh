- en: Abuse of Cryptography by Malware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件对加密技术的滥用
- en: In this chapter, we will protect our tunnel with something more solid than a
    simple XOR, as modern malware is using a well-known ciphering algorithm to protect
    its traffic in the transit path.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用比简单的XOR更坚固的方式来保护我们的隧道，因为现代恶意软件使用一种知名的加密算法来保护其在传输路径中的流量。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Introduction to encryption algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密算法简介
- en: Protecting your tunnel with AES – stream mode
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AES保护你的隧道—流模式
- en: Protecting your tunnel with RSA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RSA保护你的隧道
- en: Hybrid encryption key
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合加密密钥
- en: Introduction to encryption algorithms
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密算法简介
- en: In this section, we'll have a quick overview of the most common encryption algorithms
    in the cryptography world. Basically, there are two types of encryption algorithms.
    The first one is called **symmetric** and the second one is called **asymmetric**.
    Now, this classification is made based on the number of needed keys and how they
    are operated. Let's discuss the difference between these algorithms a little bit,
    and we will start with the symmetric one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要概述加密领域中最常见的加密算法。基本上，有两种类型的加密算法：第一种叫做**对称加密**，第二种叫做**非对称加密**。这种分类是根据所需密钥的数量以及它们的操作方式来进行的。我们将稍微讨论一下这些算法之间的区别，首先从对称加密开始。
- en: Now, symmetric encryption uses one key for both the encryption and the decryption
    process and this key is shared on both the client and the server side. Now, the
    most common examples of symmetric encryption are AES, Blowfish, RC4, and Triple
    DES. In asymmetric encryption, we have the concept of the key pair, where we have
    a key called **public** key that is used for encryption and we have a **private**
    key that is used for decryption. Now, the key name implies that the public key
    can be published over the untrusted network like the internet and doing so will
    cause no harm. On the other hand, the private key should never leave the operating
    system or the machine that is intended to decrypt the data. If the private key
    is leaked out of the operating system, then anybody who has that private key can
    decrypt the traffic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对称加密使用一个密钥来进行加密和解密，这个密钥在客户端和服务器端共享。最常见的对称加密算法有AES、Blowfish、RC4和Triple DES。在非对称加密中，我们有密钥对的概念，其中一个叫做**公钥**，用于加密，而另一个叫做**私钥**，用于解密。密钥的名称暗示了公钥可以在不可信的网络（如互联网）上发布，这样做不会造成任何损害。另一方面，私钥绝不能离开操作系统或旨在解密数据的机器。如果私钥泄露出操作系统，那么任何拥有该私钥的人都可以解密流量。
- en: The client or the target has to generate his/her own key pair and the server
    or the attacker has to generate his own keys. Now, after generating the key pair
    on each side, the operation will be as follows. The client will hold his own private
    key, and the server's public key. On the other hand, the server will hold his
    own private key and the client's public key. So, to quickly recap, after switching
    over, at this point on the Kali side we have our own private key and the target's
    public key. Also, on the target side, we have our own private key and we also
    hold the Kali public key. So, reflecting this to our shell, when we get a reverse
    shell prompt to enter our command to be executed, such as `ipconfig` it will be
    encrypted using the client's public key and we will send it over the tunnel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或目标必须生成自己的密钥对，服务器或攻击者则需要生成自己的密钥。现在，在双方各自生成密钥对后，操作流程如下：客户端将持有自己的私钥和服务器的公钥；另一方面，服务器将持有自己的私钥和客户端的公钥。简要回顾一下，切换后，在Kali一侧我们拥有自己的私钥和目标的公钥。同样，在目标一侧，我们拥有自己的私钥，并且也持有Kali的公钥。因此，在我们的shell中反映这一点，当我们得到一个反向shell提示并输入要执行的命令时，例如`ipconfig`，它将使用客户端的公钥进行加密，并通过隧道发送。
- en: When we enter `ipconfig` in the shell prompt, before sending over the `ipconfig`
    in a clear text, we will use the target's public key to encrypt this message and
    we will send it over the tunnel. No matter who's watching that traffic, only the
    client can decrypt it, and that's because only the client is the one who holds
    the private key. Using the target private key, we will decrypt the command and
    revert it to clear text, which is again, the `ipconfig` command. Now, when the
    client executes the `ipconfig`, instead of sending the output in clear text, the
    output will be encrypted using the server or Kali public key and we will send
    it over the tunnel. Now, on the Kali side, once we get the encrypted message,
    we will pass it over to our private key, which will be used to decrypt the traffic
    or to decrypt the message and print it out in clear text. Now, the last thing
    I should mention about asymmetric encryption are the most common examples of this
    algorithm, which are the RSA and **Pretty Good Privacy** (**PGP**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端提示符中输入`ipconfig`时，在将`ipconfig`明文发送之前，我们将使用目标的公钥对该消息进行加密，并通过隧道发送出去。不管谁在监视这段流量，只有客户端可以解密它，因为只有客户端持有私钥。我们将使用目标的私钥解密命令，并将其恢复为明文，这就是`ipconfig`命令。现在，当客户端执行`ipconfig`时，输出不会以明文形式发送，而是使用服务器或Kali公钥进行加密，并通过隧道发送出去。现在，在Kali一侧，一旦我们收到加密的消息，我们将将其交给我们的私钥，私钥将用于解密流量或解密消息并以明文形式打印出来。最后，我需要提到的关于非对称加密的内容是这个算法的最常见示例，即RSA和**Pretty
    Good Privacy**（**PGP**）。
- en: There are certain advantages and disadvantages to both methods. The asymmetric
    algorithm is considered hard to break, more solid, and more secure than the symmetric
    one. However, it requires more processes and is much slower than the symmetric
    one. So, the question is, can we create a hybrid system or hybrid algorithm that
    can take advantage of both the symmetric and asymmetric systems? The answer is
    yes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法各有其优缺点。非对称算法被认为比对称算法更难破解，更坚固、更安全。然而，它需要更多的处理过程，比对称算法慢得多。那么，问题是，我们能否创建一个混合系统或混合算法，利用对称和非对称系统的优点？答案是肯定的。
- en: We will use the asymmetric algorithm to securely transfer a random and complex
    key. Now, this key will be used later on to encrypt our transfer data using symmetric
    algorithm. So, basically, here's the deal. The Kali machine will hold the target's
    public key, then we will generate symmetric key on the Kali side. Now, we will
    take advantage of the asymmetric public key of the target side and we will use
    it to encrypt the generated symmetric key and send it over to the target side.
    Now, the target will decrypt the symmetric key using its private key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用非对称算法安全地传输一个随机且复杂的密钥。这个密钥稍后将用于使用对称算法加密我们的传输数据。所以，基本上，事情是这样的。Kali机器将持有目标的公钥，然后我们将在Kali侧生成对称密钥。现在，我们将利用目标侧的非对称公钥，并使用它来加密生成的对称密钥，并将其发送到目标侧。目标将使用其私钥解密对称密钥。
- en: We will use the target private key to export or to decrypt the symmetric key
    here. So, at this point, we can use this symmetric key for our tunnel encryption.
    Now, once we have securely transferred the symmetric key, we can use it to encrypt
    each command or output going through this tunnel. So, to recap really quickly,
    as soon as the target initiates a session back to us on the Kali side, we will
    generate the symmetric key. Now, to securely transfer this symmetric key, we will
    encrypt it using the target's public key, and send it over. On the target side,
    we will decrypt that message and extract the symmetric key one more time. At this
    point, we have the symmetric key on both ends. Now, we can securely transfer our
    commands back and forth using the symmetric key. The last thing we should talk
    about are the benefits for using a hybrid method, which are, first, we keep our
    generated symmetric key secure by transferring it securely over the internet.
    Second, keep in mind that this is a randomly generated key and will be changed
    on each connection. Instead of hardcoding the key on both sides or on both ends,
    the key will change per connection. Moreover, we can change the key whenever we
    want. So for example, in VPN IPSEC protocol you can set a criteria where you can
    change the encryption key after a certain amount of time or after consuming a
    certain bandwidth.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用目标的私钥来导出或解密对称密钥。因此，到这个步骤，我们可以使用这个对称密钥来进行隧道加密。现在，一旦我们安全地传输了对称密钥，我们就可以用它来加密通过这个隧道传输的每个命令或输出。简单回顾一下，一旦目标端启动与我们Kali侧的会话，我们将生成对称密钥。为了安全地传输这个对称密钥，我们将使用目标的公钥加密它，并发送过去。在目标端，我们将解密该消息并再次提取对称密钥。到此为止，双方都拥有了对称密钥。现在，我们可以安全地通过对称密钥在双方之间传输命令。最后，我们要讨论的是使用混合方法的好处。首先，我们通过安全地传输生成的对称密钥来保持它的安全。其次，请记住，这是一个随机生成的密钥，每次连接时都会更改。我们不会在两端硬编码这个密钥，而是每次连接时密钥都会更改。此外，我们还可以随时更改密钥。例如，在VPN
    IPSEC协议中，你可以设置一个标准，在一定时间或消耗一定带宽后更换加密密钥。
- en: Protecting your tunnel with AES – stream mode
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AES加密保护你的隧道 – 流模式
- en: In this section, we will protect our TCP tunnel with AES encryption. Now, generally
    speaking, AES encryption can operate in two modes, the **Counter (CTR) mode encryption**
    (also called the **Stream Mode**) and the **Cipher Block Chaining (CBC) mode encryption**
    (also called the **Block Mode**)**.**
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用AES加密来保护我们的TCP隧道。一般来说，AES加密可以在两种模式下运行：**计数器（CTR）模式加密**（也称为**流模式**）和**密码块链接（CBC）模式加密**（也称为**块模式**）**。
- en: Cipher Block Chaining (CBC) mode encryption
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码块链接（CBC）模式加密
- en: 'The **Block Mode** means that we need to send data in the form of chunks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**块模式**意味着我们需要以数据块的形式发送数据：'
- en: '![](../images/00055.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00055.jpeg)'
- en: For instance, if we say that we have a block size of 512 bytes and we want to
    send 500 bytes, then we need to add 12 bytes additional padding to reach 512 bytes
    of total size. If we want to send 514 bytes, then the first 512 bytes will be
    sent in a chunk and the second chunk or the next chunk will have a size of 2 bytes.
    However, we cannot just send 2 bytes alone, as we need to add additional padding
    of 510 bytes to reach 512 in total for the second chunk. Now, on the receiver
    side, you would need to reverse the steps by removing the padding and decrypting
    the message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们说块大小为512字节，并且我们想发送500字节的数据，那么我们需要额外添加12字节的填充数据，以使总大小达到512字节。如果我们想发送514字节，那么前512字节将作为一个块发送，第二个块或下一个块将为2字节大小。然而，我们不能仅仅发送2字节，因为我们需要添加额外的510字节填充，以使第二个块的总大小为512字节。现在，在接收端，你需要通过去除填充并解密消息来逆向执行这些步骤。
- en: Counter (CTR) mode encryption
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器（CTR）模式加密
- en: 'Now, let''s jump to the other mode, which is the **Counter (CTR) mode encryption**
    or the **Stream Mode**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到另一种模式，也就是**计数器（CTR）模式加密**或**流模式**：
- en: '![](../images/00056.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00056.jpeg)'
- en: Here, in this mode, the message size does not matter since we are not limited
    with a block size and we will encrypt in stream mode, just like XOR does. Now,
    the block mode is considered stronger by design than the stream mode. In this
    section, we will implement the stream mode and I will leave it to you to search
    around and do the block mode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，消息大小并不重要，因为我们不受块大小的限制，且我们将以流模式加密，就像XOR操作一样。现在，块模式在设计上被认为比流模式更强。在本节中，我们将实现流模式，剩下的块模式的实现将交给你自己去探索。
- en: 'The most well-known library for cryptography in Python is called `PyCrypto`.
    For Windows, there is a compiled binary for it, and for the Kali side, you just
    need to run the setup file after downloading the library. You can download the
    library from [http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto).
    So, as a start, we will use `AES` without TCP or HTTP tunneling:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最著名的加密库叫做 `PyCrypto`。对于 Windows，它有一个编译好的二进制文件，对于 Kali 端，你只需要在下载库后运行安装文件。你可以从
    [http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto)
    下载这个库。所以，作为开始，我们将使用 `AES`，而不使用 TCP 或 HTTP 隧道：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code is quite straightforward. We will start by importing the `os` library,
    and we will import the `AES` class from `Crypto.Cipher` library. Now, we use the
    `os` library to create the random `key` and random `counter`. The counter length
    is `16` bytes, and we will go for `32` bytes length for the key size in order
    to implement AES-256\. Next, we create an encryption object by passing the `key`,
    the AES mode (which is again the stream or CTR mode) and the `counter` value.
    Now, note that the `counter` is required to be sent as a callable object. That's
    why we used `lambda` structure or `lambda` construct, where it's a sort of anonymous
    function, like a function that is not bound to a name. The decryption is quite
    similar to the encryption process. So, we create a decryption object, and then
    pass the encrypted message and finally, it prints out the decrypted message, which
    should again be clear text.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们将首先导入 `os` 库，并从 `Crypto.Cipher` 库中导入 `AES` 类。现在，我们使用 `os` 库来创建随机的 `key`
    和随机的 `counter`。计数器的长度是 `16` 字节，我们将为密钥大小选择 `32` 字节，以实现 AES-256。接下来，我们通过传递 `key`、AES
    模式（这仍然是流模式或 CTR 模式）和 `counter` 值来创建加密对象。现在，请注意，`counter` 需要作为可调用对象发送。这就是我们使用 `lambda`
    结构或 `lambda` 构造的原因，它是一种匿名函数，就像一个没有绑定名字的函数。解密过程与加密过程非常相似。所以，我们创建一个解密对象，然后传递加密消息，最后它会打印出解密后的消息，应该是明文的。
- en: 'So, let''s quickly test this script and encrypt my name. Once we run the script
    the encrypted version will be printed above and the one below is the decrypted
    one, which is the clear-text one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们快速测试一下这个脚本并加密我的名字。一旦我们运行脚本，加密后的版本会显示在上面，下面的是解密后的版本，即明文：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, to test the message size, I will just invoke a space and multiply the size
    of my name with `5`. So, we have `5` times of the length here. The size of the
    clear-text message does not matter here. No matter what the clear-text message
    was, with the stream mode, we get no problem at all.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了测试消息的大小，我将调用一个空格，并将我的名字的长度乘以`5`。这样，我们就得到了`5`倍的长度。明文的大小在这里并不重要。无论明文是什么，使用流模式时，我们都不会遇到任何问题。
- en: 'Now, let us integrate our encryption function to our TCP reverse shell. The
    following is the client side script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将加密功能集成到我们的 TCP 反向 Shell 中。以下是客户端脚本：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What I have added was a new function for encryption and decryption for both
    sides and, as you can see, the key and the counter values are hardcoded on both
    sides. A side note I need to mention is that we will see in the hybrid encryption
    later how we can generate a random value from the Kali machine and transfer it
    securely to our target, but for now, let's keep it hardcoded here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加的是一个新的加密和解密函数，适用于双方，正如你所看到的，密钥和计数器值在两端都是硬编码的。我需要提到的一个旁注是，我们将在后面的混合加密中看到，如何从
    Kali 机器生成一个随机值并安全地传输到我们的目标，但现在，暂时让我们将其硬编码在这里。
- en: 'The following is the server side script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器端脚本：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is how it works. Before sending anything, we will pass whatever we want
    to send to the encryption function first. When we get the shell prompt, our input
    will be passed first to the encryption function; then it will be sent out of the
    TCP socket. Now, if we jump to the target side, it's almost a mirrored image.
    When we get an encrypted message, we will pass it first to the decryption function,
    and the decryption will return the clear-text value. Also, before sending anything
    to the Kali machine, we will encrypt it first, just like we did on the Kali side.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样工作的。在发送任何内容之前，我们会先将想要发送的内容传递给加密函数。当我们得到 Shell 提示符时，我们的输入会首先传递给加密函数；然后它会通过
    TCP 套接字发送出去。现在，如果我们跳转到目标端，它几乎是镜像的。当我们接收到加密消息时，我们会首先将其传递给解密函数，解密函数会返回明文值。同时，在向
    Kali 机器发送任何内容之前，我们会先加密它，就像在 Kali 端所做的那样。
- en: Now, run the script on both sides. Keep Wireshark running in background at the
    Kali side. Let's start with the `ipconfig`. So on the target side, we will able
    to decipher or decrypt the encrypted message back to clear text successfully.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在两个端进行脚本运行。保持Wireshark在Kali端后台运行。我们从`ipconfig`开始。在目标端，我们将能够成功地将加密消息解密为明文。
- en: Now, to verify that we got the encryption in the transit path, on the Wireshark,
    if we right-click on the particular IP and select Follow TCP Stream in Wireshark,
    we will see that the message has been encrypted before being sent out to the TCP
    socket.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证我们在传输路径中得到了加密，在Wireshark中，如果我们右键点击特定的IP并选择“Follow TCP Stream”，我们将看到消息在发送到TCP套接字之前已经被加密。
- en: Protecting your tunnel with RSA
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RSA保护你的隧道
- en: 'In this section, we will be using the RSA asymmetric algorithm to protect our
    tunnel. Now, to review the requirements for asymmetric encryption: as we said,
    each entity has its own key pair; when I say key pair, I mean a public and a private
    key. The final key-pair distribution will be as follows. The client will hold
    its own private key and the server''s public key. On the other side, the server
    or the Kali machine will hold its own private key and the target''s public key.
    So, when we want to send a message or command to our target from the Kali side,
    first we will encrypt that message using the target''s public key and then we
    will send it over the tunnel in encrypted format. The target will grab that command
    or message, and using its private key it can decrypt it and extract it back to
    clear text. The reply, after executing the command, will be encrypted using the
    server''s public key. After that, we will send it out in encrypted format to the
    network and once we received that message or that encrypted message on the Kali
    machine, we will use the Kali private key to decrypt it back to clear text.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用RSA非对称算法来保护我们的隧道。现在，回顾非对称加密的要求：正如我们所说，每个实体都有自己的一对密钥；当我说密钥对时，我指的是公钥和私钥。最终的密钥对分配如下：客户端将持有自己的私钥和服务器的公钥。另一方面，服务器或Kali机器将持有自己的私钥和目标的公钥。因此，当我们想从Kali端向目标发送消息或命令时，首先我们将使用目标的公钥加密该消息，然后将其以加密格式通过隧道发送。目标将接收该命令或消息，并使用其私钥解密，从而恢复明文。执行完命令后，回复将使用服务器的公钥进行加密。之后，我们将以加密格式将其发送到网络，一旦我们在Kali机器上接收到该消息或加密消息，我们将使用Kali的私钥将其解密为明文。
- en: 'Now, the first step is to generate a key pair on both sides:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一步是在两端生成一个密钥对：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, we start with importing the `RSA` class. Then, we create a new object to
    generate a key with a size of `4096` bits. Now, this is the maximum size that
    `RSA` can support, but the tax that you will pay for having a complex key is the
    slowness. The more key size the more secure, but slower will be the operation.
    Next, we export the keys in `PEM` format. `PyCrypto` supports other formats such
    as `DER`, which is binary encoding. The most common format is the `PEM`, which
    is also used on network devices such as firewalls and routers for VPN or HTTPS
    access purposes. Now, after printing out the generated keys, we'll save them to
    the `private.pem` and `public.pem` files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们从导入`RSA`类开始。然后，我们创建一个新的对象来生成一个大小为`4096`位的密钥。现在，这是`RSA`支持的最大大小，但拥有一个复杂密钥所付出的代价就是其运行速度较慢。密钥越大，安全性越高，但操作会越慢。接下来，我们将密钥导出为`PEM`格式。`PyCrypto`支持其他格式，如`DER`，它是二进制编码。最常见的格式是`PEM`，它也用于网络设备，如防火墙和路由器，用于VPN或HTTPS访问目的。现在，打印出生成的密钥后，我们将其保存到`private.pem`和`public.pem`文件中。
- en: Let's start, and run the Generate Keys script given previously on both sides,
    at target and attacker. On the Kali side we will get the RSA private key and the
    public key. The begin and the end of keys will be marked. We will get a similar
    result on the Windows side too. So, what we'll do right now is we'll copy each
    key on the Kali machine end and save it to a separate file. Let's start with the
    private key on the attacker machine and simply paste the private key in a notepad
    file. Rename this file to `private.pem`. Now, let's go and do the same for the
    public key. Let's call this one `public.pem`. After this, jump to the Windows
    side and do what we have done on the Kali machine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，运行之前提供的生成密钥脚本，分别在目标机器和攻击者机器上执行。在Kali机器上，我们会得到RSA私钥和公钥，密钥的开始和结束部分会被标记。我们在Windows机器上也会得到类似的结果。那么，现在我们要做的是，在Kali机器上复制每个密钥并保存到一个单独的文件中。首先从攻击者机器上的私钥开始，将私钥粘贴到记事本文件中。将此文件重命名为`private.pem`。现在，接下来做相同的操作，处理公钥。我们将它命名为`public.pem`。之后，切换到Windows机器，按照在Kali机器上做的操作进行。
- en: 'Now, as we did with the AES encryption, before integrating the encryption to
    our tunnel, let''s first have a look at how the encryption and decryption will
    work:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们在AES加密中所做的那样，在将加密集成到我们的隧道中之前，首先让我们看看加密和解密是如何工作的：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first define an encryption function, where we will pass the message
    that we want to encrypt, and a decryption function down below, just as we did
    in the AES case. Now, after getting the clear-text message, we will open the public
    key file that will encrypt the message for us and link the imported key into the
    `encryptor` object. Now, the `encryptor` object will do the actual encryption
    for us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义一个加密函数，我们将传入我们想加密的消息，并在下面定义一个解密函数，就像我们在AES加密中做的一样。现在，在获取明文消息之后，我们将打开公钥文件，这个文件会为我们加密消息，并将导入的密钥链接到`encryptor`对象中。现在，`encryptor`对象将为我们执行实际的加密操作。
- en: The encryption function in the `RSA` class takes two parameters. The first one
    is the plaintext message and the second one can be simply discarded. Therefore,
    we have passed a `0` value. Another thing is that, the encryption output is returned
    in a tuple format. The first item contains the encrypted text, so we'll print
    it out and for testing purposes—I'm starting with encrypting my name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`RSA`类中的加密函数需要两个参数。第一个是明文消息，第二个参数可以简单地忽略。因此，我们传入了一个`0`值。另一个需要注意的是，加密的输出以元组格式返回。第一个元素包含加密后的文本，所以我们将打印出来，进行测试时——我先从加密我的名字开始。'
- en: Let's jump to the decryption process and we will do something similar to the
    encryption process by importing. Now, here's the key difference. In the decryption,
    we'll import the `privatekey` and pass the `cipher` value and print it out in
    a clear text after doing the decryption.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到解密过程，我们将通过导入做类似于加密过程的操作。现在，这是关键的不同点。在解密时，我们将导入`privatekey`并传入`cipher`值，然后在解密后打印出明文。
- en: Let's try and run the script on the Windows side and if you encounter an error
    message saying that we've got no file or directory for `public.pem` most likely,
    this error message is because of the format for the saved file. View the complete
    extension and remove the `.txt` and make it `.pem` for both public and private
    files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Windows机器上运行脚本，如果你遇到一个错误消息，提示我们没有找到`public.pem`文件或目录，很可能是因为保存的文件格式问题。查看完整的扩展名并去掉`.txt`，将其改为`.pem`，无论是公钥还是私钥文件都需要这样修改。
- en: Here, we want to start by encrypting my name, and we will pass my name in clear
    text to the encryption function. Now, once we import the public key for encryption,
    we will print the encrypted message. Then, we will pass the encrypted message
    back to the decryption function so we can print it out in clear-text format.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先要加密我的名字，我们将以明文形式将我的名字传递给加密函数。现在，一旦我们导入了公钥进行加密，就会打印出加密后的消息。然后，我们将加密后的消息传回解密函数，以便我们可以以明文格式打印出来。
- en: 'Right now, if we jump to the Kali side and run the script with a slight change
    in the `encrypt()` function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们切换到Kali机器并运行稍微修改过的`encrypt()`函数脚本：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, notice that I have encrypted a message that has a size of `512` bytes in
    the code block. The point that I want to show you is that RSA is working as a
    block `cipher` type and, per `PyCrypto` implementation, the block size is `512`
    bytes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意到我已经在代码块中加密了一个大小为`512`字节的消息。我想展示的重点是，RSA作为一个块`密码`类型在工作，并且根据`PyCrypto`的实现，块大小为`512`字节。
- en: Now, let's see what'll happen if I raised the message size by 1 byte. So, instead
    of multiplying this one with `512`, I will simply multiply with `513`. So, an
    exception will be thrown saying that the plaintext is too large to be handled.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我将消息大小增加 1 字节会发生什么。所以下面我不会将其乘以 `512`，而是直接乘以 `513`。此时会抛出一个异常，提示明文数据过大，无法处理。
- en: 'So, the maximum size of the message must be `512` bytes. Now, what I will do
    first is I will integrate the RSA to our TCP tunnel and then I will show you how
    we can solve the block size issue within a few lines of Python code. Now, the
    integration is quite similar to what we have done in the previous section. Let''s
    look into the client side script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，消息的最大大小必须是 `512` 字节。现在，我要做的第一件事是将 RSA 集成到我们的 TCP 隧道中，然后我会展示如何通过几行 Python
    代码解决块大小问题。现在，集成过程与我们在前面部分所做的非常相似。让我们来看一下客户端脚本：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, I have created two functions: one for the encryption and a second one for
    the decryption. Before sending any command, we will pass it first to the encryption
    function and before printing any result, we will pass what we get to the decryption
    function. Now, remember that the target holds its private key and the server''s
    public key and the Kali machine holds its private key and the client''s public
    key. Now, go to the Kali machine and open the public key which you had saved in
    the text file. Copy and paste the public key into the variable. So, obviously,
    we would need to import these keys manually before exporting the script on the
    target side into EXE format. Now, we will open the public key from the target
    side that we have just generated. Remember, this public key should be located
    in the public key variable on the Kali machine. Perform the same operation as
    the previous one.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我创建了两个函数：一个用于加密，另一个用于解密。在发送任何命令之前，我们首先将其传递给加密函数，在打印任何结果之前，我们将得到的结果传递给解密函数。现在，请记住，目标端持有其私钥和服务器的公钥，而
    Kali 机器持有其私钥和客户端的公钥。现在，去 Kali 机器，打开你之前保存在文本文件中的公钥。复制并粘贴公钥到变量中。所以，很显然，在将脚本导出为 EXE
    格式之前，我们需要手动导入这些密钥。接下来，我们将打开刚才生成的目标端公钥。记住，这个公钥应该位于 Kali 机器上的公钥变量中。执行与之前相同的操作。
- en: Right now, it's time for the private key. So, the private key for the Kali machine
    will be located on the script for the Kali machine. Copy-paste the private keys
    from the text files into the strings on both server and client side and save them.
    Now, let's find out whether our scripts will work after the integration to the
    TCP tunnel. Start Wireshark and run it on the server side. Let's jump to the target
    side and, basically, we get a connection and a shell prompt. Check the connection
    with something less heavy like `whoami`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理私钥了。因此，Kali 机器的私钥将位于该机器的脚本中。从文本文件中复制并粘贴私钥到服务器端和客户端的字符串中，并保存它们。现在，让我们看看集成到
    TCP 隧道后的脚本是否能正常工作。启动 Wireshark，并在服务器端运行它。接着，我们跳到目标端，基本上我们得到了连接和一个 Shell 提示符。用一个不那么复杂的命令，比如
    `whoami` 来检查连接。
- en: Now, keep in mind that `whoami` is less than `512` bytes; so, we were able to
    encrypt it successfully on the Kali machine and send it over to the target side.
    Also, since the output of the executing `whoami` on the target side is also less
    than `512` bytes we get the reply successfully. So, we have verified that the
    encryption is working here. Now, let's try with another command say, `ipconfig`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住，`whoami` 的大小小于 `512` 字节；因此，我们能够成功地在 Kali 机器上加密它，并将其发送到目标端。而且，由于执行 `whoami`
    的输出大小也小于 `512` 字节，我们成功收到了回复。所以，我们已经验证了加密功能在这里正常工作。现在，让我们尝试另一个命令，比如 `ipconfig`。
- en: 'You will notice that we have received the command successfully but for some
    reason we get no output on the Kali side and this is because the execution output
    of the `ipconfig` on the client side or on the target side is larger than `512`
    bytes, and therefore the script will crash as we have exceeded the message size.
    Now, as I said earlier, this can be resolved by verifying the message length and
    breaking it down into chunks, where each chunk should be less than or equal to
    `512` bytes. So, let''s jump to the latest code, which resolves the bulk size
    problem for us:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们已经成功接收到命令，但由于某些原因，在 Kali 机器上没有输出，这是因为在客户端或目标端执行 `ipconfig` 的输出超过了 `512`
    字节，因此脚本会崩溃，因为我们超出了消息的大小限制。正如我之前所说，这可以通过验证消息长度并将其分解成多个块来解决，每个块应该小于或等于 `512` 字节。所以，让我们看一下最新的代码，它为我们解决了块大小的问题：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have created an `if` statement to check the size of the command execution
    output. For instance, let''s say the command that we got from Kali was `ipconfig`.
    So, we''ll see if the output or the size of the output of `ipconfig` is larger
    than `512` bytes. If it''s not, then we got no problem: we will send the output
    to the `encrypt()` function, then it will be sent directly to the Kali machine.
    However, if the output was larger than `512` bytes, we will split it into chunks,
    where the maximum size for each chunk is `512` bytes. The splitting will happen
    by making a `for` loop, where we''ll start from `0` until the length of our command
    execution output. And each time we make a loop, we will increment our `i` counter
    with `512` bytes. So, what we''ll achieve by doing this is, the chunk variable
    will hold the split result, where the first chunk will cut the result from `0`
    to `512` bytes and the second chunk will be from `500` to `1024` bytes, and so
    on, until reaching the length of the command output. Now, note that each time
    we got a chunk we are good to go and we will send it immediately to the attacker
    machine after for sure passing out or passing into the encryption function.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`if`语句来检查命令执行输出的大小。例如，假设我们从 Kali 得到的命令是`ipconfig`。那么，我们将检查 `ipconfig`
    的输出是否大于 `512` 字节。如果没有，说明没有问题：我们将把输出发送到 `encrypt()` 函数，然后它会直接发送到 Kali 机器。不过，如果输出大于
    `512` 字节，我们将其拆分成多个块，每个块的最大大小为 `512` 字节。拆分过程将通过一个 `for` 循环完成，我们从 `0` 开始，直到命令执行输出的长度。每次循环时，我们会将
    `i` 计数器增加 `512` 字节。因此，通过这样做，我们将使得每个拆分的结果保存在块变量中，第一块将包含从 `0` 到 `512` 字节的结果，第二块将包含从
    `500` 到 `1024` 字节的结果，以此类推，直到达到命令输出的长度。现在，注意到每次我们得到一个块后，我们就可以立即将其发送到攻击者机器，确保在发送之前已经通过加密函数处理过。
- en: Now, on the target side, since the maximum size of the received data is already
    known to us, which is again `512` bytes, instead of reading 1 KB and splitting
    into chunks again, we will read one chunk each time. So, that's why we have changed
    the received value from `1` KB to `512` bytes. So, now, after decrypting the chunk,
    if we got a clear-text message with full size of `512` bytes, this probably means
    that this message has been split into chunks on the target side, right? So, the
    next message or chunk is related to the first one. Now, this is why the stored
    variable will hold both of them, and when I say both, I mean `store + decrypt`
    message and the next coming `store + decrypt`. Finally, we will `print` out the
    `result`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在目标端，由于我们已经知道接收到的数据的最大大小是 `512` 字节，而不是再去读取 1 KB 并拆分成块，我们将每次读取一个块。因此，这就是为什么我们将接收值从
    `1` KB 更改为 `512` 字节的原因。现在，在解密该块后，如果我们得到的明文消息的大小正好是 `512` 字节，这很可能意味着该消息已经在目标端被拆分成了块，对吧？那么，下一条消息或块与第一条相关联。这就是为什么存储的变量会保存这两条消息的原因，当我说这两条时，我指的是
    `store + decrypt` 消息和接下来的 `store + decrypt` 消息。最后，我们将 `print` 出 `result`。
- en: If the command execution was larger than two messages or, in other words, was
    larger than 1 KB, then we may need to link the third message as well to the stored
    variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行结果大于两条消息，或者换句话说，结果大于 1 KB，那么我们可能需要将第三条消息也与存储的变量关联起来。
- en: So, let's verify if our code is working right now. Start running the server
    side and the client side. Let's start with the command that we failed to run earlier,
    that is `ipconfig`. We will see that we get the output in a single piece, even
    it is bigger than `512` bytes. The same goes for `whoami` and directories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们来验证一下代码现在是否有效。启动服务器端和客户端。首先运行之前失败的命令 `ipconfig`，我们会看到它的输出是一个完整的结果，即使它大于
    `512` 字节。`whoami` 和目录命令也会得到类似的输出。
- en: RSA is also being used in developing something called **ransomware**. Now, in
    ransomware, the attackers can encrypt the target files using a public key and
    ask for money to provide the private key, which will decrypt their important files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 还被用于开发一种叫做 **勒索软件** 的东西。在勒索软件中，攻击者可以使用公钥加密目标文件，并要求支付费用以提供私钥，从而解密这些重要文件。
- en: Hybrid encryption key
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合加密密钥
- en: At this point, you should be able to code and implement both the RSA asymmetric
    and the AES symmetric encryption, and integrate both of them over our TCP shell.
    So, now, we will implement a hybrid way to take advantage of both the algorithms.
    So let's quickly recap. The client will hold its own private key, and the server
    or the Kali machine will hold the target's public key. Once the TCP connection
    is started, the Kali machine will generate a random AES key and we will securely
    send this key to the target side. The reason that I say **securely** is because
    the transfer will happen via encryption or via encrypting the random AES key with
    a target's public key. Once the target gets that message, it will decrypt it using
    the target private key and extract the AES key back to clear text. At this point,
    both the Kali and the target machines have the same random generated AES keys
    which can, and will, be used for AES encryption. Now, the AES encryption at this
    point will be used to encrypt our commands that will be transferred back and forth
    between the Kali machine and our target.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该能够编写代码并实现RSA非对称加密和AES对称加密，并将两者整合到我们的TCP shell中。那么现在，我们将实现一种混合方式，利用这两种算法。我们先快速回顾一下。客户端将持有自己的私钥，服务器或Kali机器将持有目标的公钥。一旦TCP连接建立，Kali机器将生成一个随机的AES密钥，我们将安全地将这个密钥发送到目标端。我之所以说**安全地**，是因为传输将通过加密进行，或者通过使用目标的公钥加密随机的AES密钥。一旦目标收到该消息，它将使用目标的私钥进行解密，并将AES密钥还原为明文。此时，Kali和目标机器都拥有相同的随机生成的AES密钥，这些密钥将用于AES加密。现在，此时的AES加密将用于加密我们将在Kali机器和目标之间来回传输的命令。
- en: Upon a new connection, both Kali and the target will repeat the whole process,
    and a new random key will be derived. Now, this is why it's called a **hybrid
    method**, since we are using the asymmetric algorithm to securely transfer a generated
    symmetric key, which eventually will be used to encrypt our commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次新的连接时，Kali和目标将重复整个过程，并且会派生出一个新的随机密钥。这就是为什么这叫做**混合方法**，因为我们使用非对称算法来安全地传输生成的对称密钥，最终将用来加密我们的命令。
- en: 'So, let''s jump to the coding part, which is sort of a mix between the symmetric
    and the asymmetric. The following is the server side-script:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们跳到编码部分，这部分是对称和非对称的混合。以下是服务器端脚本：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon completing the TCP three-way handshake, we will create two random values,
    which are the `key` and the `counter`. Their values are a combination of an uppercase,
    lowercase, digits, and special characters. Before going to the infinite loop—which
    will be used to transfer the command that we want to be executed—we''ll encrypt
    these values with the target''s public key and then send it over:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成TCP三次握手后，我们将生成两个随机值，即`key`和`counter`。它们的值是由大写字母、小写字母、数字和特殊字符的组合组成。在进入无限循环之前——该循环将用于传输我们希望执行的命令——我们将使用目标的公钥对这些值进行加密，然后传输：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the target side, and also before going into the infinite loop, we will decrypt
    the key and the counter that we have received from the Kali machine; we will do
    this encryption using our private key. Then, we will store them in a global variable,
    which will be used for AES encryption. One more time, this will happen before
    going to the infinite loop. The definition of our private key is under a function
    called `GET_AES_KEY()`. So, at this point, we get the key and the `counter` values,
    and as I said, we''ll use them for AES encryption. So, the encrypt function and
    the decrypt function are used to protect our commands that will be going back
    and forth between the Kali and the Windows machines. Now, once we are within the
    infinite loop, we will use the AES''s stream mode to protect our tunnel later
    on:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标端，并且在进入无限循环之前，我们将解密从Kali机器接收到的密钥和计数器；我们将使用我们的私钥进行加密。然后，我们将它们存储在一个全局变量中，这个变量将用于AES加密。同样，这个操作也会在进入无限循环之前完成。我们的私钥的定义在一个名为`GET_AES_KEY()`的函数中。所以，在此时，我们获得了密钥和`counter`值，正如我所说，我们将使用它们进行AES加密。因此，encrypt函数和decrypt函数用于保护我们将在Kali和Windows机器之间来回传输的命令。现在，一旦我们进入无限循环，我们将使用AES的流模式来保护我们的隧道：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's run the scripts, start with the Kali side, then with Windows side.
    You will notice that once we fire up the target, we get a random AES key that
    gets generated on the Kali machine, which is then transferred to the target side.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本，先从Kali端开始，然后是Windows端。你会注意到，一旦我们启动目标，Kali机器上会生成一个随机的AES密钥，然后将其传输到目标端。
- en: If we open Wireshark and right-click on any IP and select Follow TCP Stream,
    we can see that the AES key gets transferred successfully after being encrypted
    with the target's public key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开Wireshark，右键点击任何一个IP地址并选择“Follow TCP Stream”，我们可以看到AES密钥在经过目标的公钥加密后成功传输。
- en: So, once we get the key, everything that is being sent, will be encrypted using
    the AES's key stream. So, when we run `ipconfig` on the Kali machine and again
    click on Follow TCP Stream, `ipconfig` gets encrypted using the AES algorithm.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们获得密钥，所有发送的数据将会使用AES密钥流进行加密。所以，当我们在Kali机器上运行`ipconfig`并再次点击“Follow TCP
    Stream”时，`ipconfig`将会使用AES算法进行加密。
- en: Let's try with another command, such as `whoami`. If we stop this session by
    typing `terminate` and then re-establish a new session, you will see that we will
    get a new random AES key generated as per the new session.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个命令，例如`whoami`。如果我们通过输入`terminate`停止此会话，然后重新建立一个新会话，你会看到根据新会话生成了一个新的随机AES密钥。
- en: So, each time the target connects to the Kali machine, a new random key will
    be generated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，每次目标连接到Kali机器时，都会生成一个新的随机密钥。
- en: Technically speaking, you can enhance the script here and make both sides change
    the AES key after a certain amount of time or after certain amount of bytes being
    sent over, just like the IPSEC in VPN tunnel does.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度讲，你可以在这里增强脚本，使两端在一定时间后或发送特定字节数后更换AES密钥，就像VPN隧道中的IPSEC所做的那样。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've discussed a wide range of topics ranging from introduction
    to encryption algorithms to discussing different types of algorithms. We've also
    implemented AES and RSA to protect the tunnel during passage of information.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从加密算法介绍到不同类型算法的各种话题。我们还实现了AES和RSA来保护信息传输过程中的隧道。
- en: With this, we've arrived at the end of the book! I hope you've learned some
    great techniques to test with Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经走到了本书的结尾！希望你学到了很多可以用Python进行测试的技巧。
