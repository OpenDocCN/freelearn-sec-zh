- en: Python Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 基础知识
- en: We have explored the basic concepts behind Python and fundamental elements used
    to construct scripts. We will now build a series of scripts throughout this book
    using the data types and built-in functions that we have discussed in the first
    chapter. Before we begin developing scripts, let's walk through some additional
    important features of the Python language, building upon our existing knowledge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了 Python 的基本概念和构建脚本所使用的基本元素。现在，我们将通过本书中的一系列脚本，使用我们在第一章中讨论的数据类型和内置函数。在开始开发脚本之前，让我们基于已有知识，再深入了解
    Python 语言的一些其他重要特性。
- en: In this chapter, we will explore more advanced features that we will utilize
    when building our forensic Python scripts. This includes complex data types and
    functions, creating our first script, handling errors, using libraries, interacting
    with the user, and some best practices for development. After completing this
    chapter, we will be ready to dive into real-world examples featuring the utility
    of Python in forensic casework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探索我们在构建取证 Python 脚本时将使用的更多高级特性。这些包括复杂的数据类型和函数、创建我们的第一个脚本、处理错误、使用库、与用户互动以及一些开发的最佳实践。完成本章后，我们将准备好进入实际案例，展示
    Python 在取证工作中的应用。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Advanced features, including iterators and `datetime` objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级特性，包括迭代器和 `datetime` 对象
- en: Installing and using modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用模块
- en: Error handling with `try`, `except`, and `raise` statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `try`、`except` 和 `raise` 语句进行错误处理
- en: Sanity checking and accessing user-supplied data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和访问用户提供的数据
- en: Creating forensic scripts to find USB vendor and product information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建取证脚本以查找 USB 厂商和产品信息
- en: Advanced data types and functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据类型和函数
- en: This section highlights two common features, iterators and `datetime` objects,
    of Python that we will frequently encounter in forensic scripts. Therefore, we
    will introduce these objects and functionality in more detail.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍 Python 中的两个常见特性——迭代器和 `datetime` 对象，这些特性在取证脚本中将经常遇到。因此，我们将更详细地介绍这些对象和功能。
- en: Iterators
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: You previously learned about several iterable objects, such as `lists`, `sets`,
    and `tuples`. In Python, a data type is considered an iterator if an `__iter__` method
    is defined or if elements can be accessed in a sequenced manner. These three data
    types (that is, `lists`, `sets`, and `tuples`) allow us to iterate through their
    contents in a simple and efficient manner. For this reason, we often use these
    data types when iterating through the lines in a file or through file entries
    within a directory listing, or when trying to identify a file based on a series
    of file signatures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前学习过几种可迭代对象，例如 `lists`、`sets` 和 `tuples`。在 Python 中，如果定义了 `__iter__` 方法，或者可以按顺序访问元素，那么一个数据类型就被认为是迭代器。这三种数据类型（即
    `lists`、`sets` 和 `tuples`）允许我们以简单且高效的方式遍历其内容。因此，我们在遍历文件中的行或目录列表中的文件条目时，或者在根据一系列文件签名识别文件时，经常使用这些数据类型。
- en: The `iter` data type allows us to step through data in a manner that doesn't
    preserve the initial object. This seems undesirable; however, when working with
    large sets or on machines with limited resources, it is very useful. This is due
    to the resource allocation associated with the `iter` data type, where only active
    data is stored in memory. This preserves memory allocation when stepping through
    every line of a 3 GB file by feeding one line at a time and preventing massive
    memory consumption while still handling each line in order.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter` 数据类型允许我们以不保留初始对象的方式遍历数据。这似乎不太理想；然而，当处理大数据集或在资源有限的机器上工作时，它非常有用。这是因为 `iter`
    数据类型的资源分配方式，其中只有活动数据被存储在内存中。在逐行读取一个 3 GB 文件时，通过每次只加载一行来保持内存分配，避免了大量内存消耗，同时仍然按顺序处理每一行。'
- en: 'The code block mentioned here steps through the basic usage of iterables. We
    use the `next()` function on an iterable to retrieve the next element. Once an
    object is accessed using `next()`, it is no longer available in `iter()`, as the
    cursor has moved past the element. If we have reached the end of the iterable
    object, we will receive `StopIteration` for any additional `next()` method calls.
    This exception allows us to gracefully exit loops with an iterator and alerts
    us to when we are out of content to read from the iterator:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的代码块演示了迭代对象的基本用法。我们在一个可迭代对象上使用`next()`函数来获取下一个元素。一旦通过`next()`访问了某个对象，它就不再在`iter()`中可用，因为游标已经移过了该元素。如果我们已经到达了可迭代对象的末尾，对于任何额外的`next()`方法调用，我们将收到`StopIteration`。这个异常允许我们优雅地退出使用迭代器的循环，并提醒我们迭代器中没有更多内容可以读取：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Python 2.7, you can use the `obj.next()` method call to get the same output
    as the preceding example via use of the `next()` function. For simplicity and
    uniformity, Python 3 renamed `obj.next()` to `obj.__next__()` and encourages the
    use of the `next()` function. With this, it is recommended to use `next(y)`, as
    shown previously, in place of `y.next()` or `y.__next__()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.7中，你可以使用`obj.next()`方法调用，获得与前面的示例相同的输出，方法是使用`next()`函数。为了简便和一致性，Python
    3将`obj.next()`重命名为`obj.__next__()`，并鼓励使用`next()`函数。因此，推荐使用`next(y)`，如前所示，代替`y.next()`或`y.__next__()`。
- en: 'The `reversed()` built-in function can be used to create a reversed iterator.
    In the following example, we reverse a list and retrieve the following object
    from the iterator using the `next()` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`内建函数可用于创建一个反向迭代器。在以下示例中，我们反转一个列表，并使用`next()`函数从迭代器中获取下一个对象：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By implementing generators, we can further take advantage of the `iter` data
    type. Generators are a special type of function that produces iterator objects.
    Generators are similar to functions, as those discussed in [Chapter 1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml),
    *Now for Something Completely Different—*though, instead of returning objects,
    they `yield` iterators. Generators are best used with large datasets that would
    consume vast quantities of memory, similar to the use case of the `iter` data
    type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现生成器，我们可以进一步利用`iter`数据类型。生成器是一种特殊类型的函数，它生成迭代器对象。生成器与函数相似，如在[第1章](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml)中讨论的内容，*现在开始完全不同的内容——*不过，生成器不是返回对象，而是`yield`迭代器。生成器最适合用于处理大型数据集，这些数据集可能消耗大量内存，这类似于`iter`数据类型的使用场景。
- en: 'The code block mentioned here shows the implementation of a generator. In the `file_sigs()` function,
    we create a list of tuples stored in the `sigs` variable. We then loop through
    each element in `sigs` and yield a `tuple` data type. This creates a generator,
    allowing us to use the `next()` function to retrieve each tuple individually and
    limit the generators'' memory impact. See the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的代码块展示了生成器的实现。在`file_sigs()`函数中，我们创建了一个包含元组的列表，存储在`sigs`变量中。然后我们遍历`sigs`中的每个元素，并`yield`一个`tuple`数据类型。这创建了一个生成器，使我们可以使用`next()`函数逐个获取每个元组，从而限制生成器对内存的影响。请参见以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find additional file signatures at [http://www.garykessler.net/library/file_sigs.html](http://www.garykessler.net/library/file_sigs.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.garykessler.net/library/file_sigs.html](http://www.garykessler.net/library/file_sigs.html)找到更多文件签名。
- en: datetime objects
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: datetime对象
- en: Investigators are often asked to determine when a file was deleted, when a text
    message was read, or the correct order for a sequence of events. Consequently,
    a great deal of analysis revolves around timestamps and other temporal artifacts.
    Understanding time can help us piece together the puzzle and further understand
    the context surrounding an artifact. For this, and many other reasons, let's practice
    handling timestamps using the `datetime` module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调查人员经常被要求确定文件何时被删除、文本消息何时被读取，或者一系列事件的正确顺序。因此，大量分析工作围绕时间戳和其他时间性工件展开。理解时间可以帮助我们拼凑出谜题，并进一步理解工件周围的背景。出于这个原因，以及许多其他原因，让我们通过`datetime`模块来练习处理时间戳。
- en: Python's `datetime` module supports the interpretation and formatting of timestamps.
    This module has many features, most notably getting the current time, determining
    the change (or delta) between two timestamps, and converting common timestamp
    formats into a human readable date. The `datetime.datetime()` method creates a
    `datetime` object and accepts the year, month, day, and optionally hour, minute,
    second, millisecond, and time zone arguments. The `timedelta()` method shows the
    difference between two `datetime` objects by storing the difference in days, seconds,
    and microseconds.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `datetime` 模块支持时间戳的解析和格式化。该模块有许多功能，最显著的包括获取当前时间、确定两个时间戳之间的差异（或增量），以及将常见的时间戳格式转换为人类可读的日期。`datetime.datetime()`
    方法创建一个 `datetime` 对象，并接受年份、月份、日期以及可选的小时、分钟、秒、毫秒和时区参数。`timedelta()` 方法通过存储天数、秒数和微秒数的差异，显示两个
    `datetime` 对象之间的差异。
- en: 'First, we need to import the `datetime` library so that we can use functions
    from the module. We can see the current date with the `datetime.now()` method.
    This creates a `datetime` object, which we then manipulate. For instance, let''s
    create a `timedelta` object by subtracting two `datetime` objects, separated by
    a few seconds. We can add or subtract the `timedelta` object to or from our `right_now`
    variable to generate another `datetime` object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 `datetime` 库，这样我们就可以使用该模块中的函数。我们可以使用 `datetime.now()` 方法查看当前日期。这会创建一个
    `datetime` 对象，我们可以对其进行操作。例如，假设我们通过减去两个 `datetime` 对象来创建一个 `timedelta` 对象，它们相隔几秒钟。我们可以将
    `timedelta` 对象加到或从 `right_now` 变量中减去，以生成另一个 `datetime` 对象：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output may vary, as you are running these commands at a different time than
    when they were for this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会有所不同，因为你运行这些命令的时间与书中展示时的时间不同。
- en: 'Another highly used application of the `datetime` module is `strftime()`, which
    allows `datetime` objects to be converted into custom-formatted strings. This
    function takes a string format as its input. This format string is made up of
    special characters beginning with the percentage sign. The following table illustrates
    examples of the formatters we can use with the `strftime()` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime` 模块的另一个常用应用是 `strftime()`，它允许将 `datetime` 对象转换为自定义格式的字符串。该函数接受一个格式字符串作为输入。该格式字符串由以百分号开头的特殊字符组成。下表展示了我们可以与
    `strftime()` 函数一起使用的格式化器示例：'
- en: '| **Description** | **Formatter** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **格式化器** |'
- en: '| Year (YYYY) | `%Y` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 年 (YYYY) | `%Y` |'
- en: '| Month (MM) | `%m` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 月份 (MM) | `%m` |'
- en: '| Day (DD) | `%d` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 日期 (DD) | `%d` |'
- en: '| 24 hour (HH) | `%H` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 24 小时 (HH) | `%H` |'
- en: '| 12 hour (HH) | `%I` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 12 小时 (HH) | `%I` |'
- en: '| Minute (MM) | `%M` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 (MM) | `%M` |'
- en: '| Second (SS) | `%S` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 秒 (SS) | `%S` |'
- en: '| Microseconds (SSSSSS) | `%f` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 微秒 (SSSSSS) | `%f` |'
- en: '| Timezone (Z) | `%z` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 时区 (Z) | `%z` |'
- en: '| AM/PM | `%p` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 上午/下午 | `%p` |'
- en: You can find additional timestamp formatting information at [http://strftime.org/](http://strftime.org/)
    or via the official documentation:[ https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://strftime.org/](http://strftime.org/) 或通过官方文档：[https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)
    查找更多时间戳格式化的信息。
- en: 'In addition, the `strptime()` function, which we do not showcase here, can
    be used for the reverse process. The `strptime()` function will take a string
    containing a date and time and convert it into a `datetime` object using the formatting
    string. We can also interpret epoch time (also called Unix or POSIX time), represented
    as an integer, into a UTC `datetime` object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`strptime()` 函数（我们在这里没有展示）可以用于反向操作。`strptime()` 函数将接受包含日期和时间的字符串，并使用格式化字符串将其转换为
    `datetime` 对象。我们还可以将表示为整数的纪元时间（也叫 Unix 或 POSIX 时间）解释为 UTC `datetime` 对象：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can print this new object and it will be automatically converted into a
    string representing the `datetime` object. However, let''s pretend that we do
    not like to separate our date by hyphens. Instead, we can use the `strftime()`
    method to display the date with forward slashes or using any of the defined formatters.
    Lastly, the `datetime` library has a few pre-built formatters such as `isoformat()`,
    which we can use to easily produce a standard timestamp format:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印这个新对象，它会自动转换为表示 `datetime` 对象的字符串。然而，假设我们不喜欢用连字符来分隔日期。相反，我们可以使用 `strftime()`
    方法，以斜杠或任何已定义的格式化器来显示日期。最后，`datetime` 库还提供了一些预构建的格式化器，例如 `isoformat()`，我们可以使用它轻松生成标准时间戳格式：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a note, we have imported `print_function` into our interpreter to allow us
    to print these date values in both Python 2 and Python 3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个备注，我们已经将`print_function`导入到我们的解释器中，以便在Python 2和Python 3中都能打印这些日期值。
- en: The `datetime` library alleviates a great deal of stress involved in handling
    date and time values in Python. This module is also well-suited for processing
    time formats that are often encountered during investigations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime`库大大减轻了在Python中处理日期和时间值时的复杂性。这个模块也非常适合处理在调查过程中常见的时间格式。'
- en: Libraries
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'Libraries, or modules, expedite the development process, making it easier to
    focus on the intended purpose of our script rather than developing everything
    from scratch. External libraries can save large amounts of developing time and,
    if we''re being honest, they are often more accurate and efficient than any code
    we, as developers, can cobble together during investigations. There are two categories
    of libraries: standard and third-party. Standard libraries are distributed with
    every installation of Python and carry commonly used code that''s supported by
    the Python Software Foundation. The number and names of the standard libraries
    vary between Python versions, especially as you move between Python 2 and Python
    3\. We will do our best to call out when a library is imported or used differently
    between Python 2 and 3\. In the other category, third-party libraries introduce
    new code, add or improve functionality to the standard Python installation, and
    allow for the community to contribute modules.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 库，或模块，加速了开发过程，使我们能够专注于脚本的预定目标，而不是从头开始开发所有功能。外部库可以节省大量的开发时间，坦率地说，它们通常比我们作为开发人员在调查过程中拼凑出来的代码更准确高效。库分为两类：标准库和第三方库。标准库随Python的每次安装而分发，包含了Python软件基金会支持的常用代码。标准库的数量和名称在不同版本的Python中有所不同，尤其是在Python
    2和Python 3之间切换时。我们将尽力指出在Python 2和3之间导入或使用库的不同之处。在另一个类别中，第三方库引入了新的代码，增加或改进了标准Python安装的功能，并允许社区贡献模块。
- en: Installing third-party libraries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装第三方库
- en: We know that we do not need to install standard modules because they come with
    Python, but what about third-party modules? The Python Package Index is a great
    place to start looking for third-party libraries. This can be found at [https://pypi.org/](https://pypi.org/).
    This service allows tools, such as `pip`, to install packages automatically. If
    an internet connection is not available or the package is not found on PyPi, a
    `setup.py` file can usually be used to install the module manually. The examples
    of using `pip` and `setup.py` are shown later. Tools such as `pip` are very convenient
    as they handle the installation of dependencies, check whether items are already
    installed, and suggest upgrades if an older version is installed. An internet
    connection is required to check for online resources, such as dependencies and
    newer versions of a module; however, `pip` can also be used to install code on
    an offline machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道标准模块不需要安装，因为它们随Python一起提供，但第三方模块呢？Python包索引（Python Package Index）是寻找第三方库的好地方。可以在[https://pypi.org/](https://pypi.org/)找到它。该服务允许像`pip`这样的工具自动安装软件包。如果没有互联网连接或在PyPi上找不到软件包，通常可以使用`setup.py`文件手动安装模块。稍后将展示使用`pip`和`setup.py`的示例。像`pip`这样的工具非常方便，它们处理依赖项的安装，检查项目是否已安装，并在安装的是旧版本时建议升级。需要互联网连接来检查在线资源，如依赖项和模块的新版本；但是，`pip`也可以用于在离线计算机上安装代码。
- en: 'These commands are run in the Terminal or Command Prompt, not the Python interpreter.
    Please note that in the example mentioned below, full paths may be necessary if
    your Python executable is not included in the current environment''s `PATH` variable.
    `pip` may need to be run from an elevated console, either using `sudo` or an elevated
    Windows Command Prompt. Full documentation for `pip` can be found at [http://pip.pypa.io/en/stable/reference/pip/](http://pip.pypa.io/en/stable/reference/pip/):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令在终端或命令提示符中运行，而不是在Python解释器中运行。请注意，在下面提到的示例中，如果你的Python可执行文件没有包含在当前环境的`PATH`变量中，可能需要使用完整路径。`pip`可能需要从提升权限的控制台运行，可以使用`sudo`或者提升权限的Windows命令提示符。有关`pip`的完整文档，请访问[http://pip.pypa.io/en/stable/reference/pip/](http://pip.pypa.io/en/stable/reference/pip/)：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Libraries in this book
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中的库
- en: In this book, we use many third-party libraries that can be installed with `pip`
    or the `setup.py` method. However, not all third-party modules can be installed
    so easily and sometimes require you to search the internet. As you may have noted
    in the previous code block, some third-party modules, such as the `yarp` module,
    are hosted on source code management systems such as GitHub. GitHub and other
    SCM services allow us to access publicly available code and view changes made
    to it over time. Alternatively, Python code can sometimes be found on a blog or
    a self-hosted website. In this book, we will provide instructions on how to install
    any third-party modules that we use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了许多可以通过`pip`或`setup.py`方法安装的第三方库。然而，并不是所有第三方模块都能如此轻松地安装，有时需要你搜索互联网。正如你在之前的代码块中可能注意到的，某些第三方模块，如`yarp`模块，托管在像GitHub这样的源代码管理系统上。GitHub和其他SCM服务允许我们访问公开的代码，并查看随时间推移所做的更改。或者，Python代码有时会出现在博客或自托管的网站上。在本书中，我们将提供如何安装我们使用的任何第三方模块的说明。
- en: Python packages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 包
- en: A Python package is a directory containing Python modules and a `__init__.py`
    file. When we import a package, the `__init__.py` code is executed. This file
    contains the imports and code that's required to run other modules in the package.
    These packages can be nested within subdirectories. For example, the `__init__.py`
    file can contain `import` statements that bring in each Python file in the directory
    and all of the available classes or functions when the folder is imported. The
    following is an example directory structure and below that is the `__init__.py`
    file, which shows us how the two interact when imported. The last line in the
    following code block imports all specified items in the subdirectory's `__init__.py`
    file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python包是一个包含Python模块和`__init__.py`文件的目录。当我们导入一个包时，`__init__.py`文件中的代码会被执行。此文件包含运行包中其他模块所需的导入语句和代码。这些包可以嵌套在子目录中。例如，`__init__.py`文件可以包含`import`语句，将目录中的每个Python文件以及所有可用的类或函数导入。当文件夹被导入时，所有内容都会被加载。以下是一个示例目录结构，下面是`__init__.py`文件，它展示了两者在导入时如何交互。以下代码块的最后一行导入了子目录`__init__.py`文件中指定的所有项目。
- en: 'The hypothetical folder structure is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设的文件夹结构如下：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The top-level `__init__.py` file''s contents is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级`__init__.py`文件的内容如下：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code mentioned below executes the `__init__` script we mentioned previously,
    and it will import all functions from `script1.py`, only `function_name` from
    `script2.py`, and any additional specifications from `subDirectory/__init__.py`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行我们之前提到的`__init__`脚本，它将导入`script1.py`中的所有函数，仅导入`script2.py`中的`function_name`，以及从`subDirectory/__init__.py`中导入的任何附加规范：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Classes and object-oriented programming
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和面向对象编程
- en: Python supports **object-oriented programming** (**OOP**) using the built-in
    class keyword. Object-oriented programming allows advanced programming techniques
    and sustainable code that supports better software development. Because OOP is
    not commonly used in scripting and is above the introductory level, this book
    will implement OOP and some of its features in later chapters after we master
    the basic features of Python. What's important to keep in mind is almost everything
    in Python, including classes, functions, and variables, are objects. Classes are
    useful in a variety of situations, allowing us to design our own objects to interact
    with data in a custom manner.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持**面向对象编程**（**OOP**），使用内建的类关键字。面向对象编程允许使用高级编程技术，并能编写可持续的代码，以支持更好的软件开发。由于OOP在脚本编程中不常用，并且属于高于入门级的概念，本书将在掌握Python基本功能后，在后续章节中实现OOP及其一些特性。需要记住的是，Python中的几乎所有东西，包括类、函数和变量，都是对象。类在多种情况下都很有用，允许我们设计自己的对象，以自定义方式与数据进行交互。
- en: Let's look at the `datetime` module for an example of how we will interact with
    classes and their methods. This library contains several classes, such as `datetime`,
    `timedelta`, and `tzinfo`. Each of these classes handles different functionality
    associated with timestamps. The most commonly used is the `datetime` class, which
    can be confusing as it is a member of the `datetime` module. This class is used
    to represent dates as Python objects. The two other mentioned classes support
    the `datetime` class by allowing dates to be added or subtracted, through the
    `timedelta` class, and time zones represented through the `tzinfo` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`datetime`模块，作为我们如何与类及其方法交互的一个示例。这个库包含几个类，如`datetime`、`timedelta`和`tzinfo`。这些类处理与时间戳相关的不同功能。其中最常用的是`datetime`类，它可能会让人困惑，因为它是`datetime`模块的成员。这个类用于表示日期作为Python对象。其他两个提到的类通过`timedelta`类支持`datetime`类，允许对日期进行加减操作，通过`tzinfo`类表示时区。
- en: 'Focusing on the `datetime.datetime` class, we will look at how we can use this
    object to create multiple instances of dates and extract data from them. To begin,
    as seen in the following code block, we must import our printing statement and
    this library to access the `datetime` module''s classes and methods. Next, we
    pass arguments to the `datetime` class and assign the `datetime` object to `date_1`.
    Our `date_1` variable contains the value to represent April Fool''s Day, 2018\.
    Since we did not specify a time value when initiating the class, the value will
    reflect midnight, down to the millisecond. As we can see, like functions, classes
    too can have arguments. Additionally, a class can contain their own functions,
    commonly called methods. An example of a method is the call to `now()`, allowing
    us to gather the current timestamp for our local machine and store the value as
    `date_2`. These methods allow us to manipulate data that''s specific to the defined
    instance of the class. We can see the contents of our two date objects by printing
    them in the interactive prompt:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重点关注`datetime.datetime`类，我们将查看如何使用这个对象创建多个日期实例并从中提取数据。首先，正如以下代码块所示，我们必须导入打印语句并导入此库，以访问`datetime`模块的类和方法。接下来，我们将参数传递给`datetime`类，并将`datetime`对象分配给`date_1`。我们的`date_1`变量包含表示2018年愚人节的值。由于我们在初始化类时没有指定时间值，因此该值将反映午夜时分，精确到毫秒。如我们所见，像函数一样，类也可以有参数。此外，类可以包含它们自己的函数，通常称为方法。一个方法的例子是调用`now()`，它允许我们获取本地计算机的当前时间戳，并将该值存储为`date_2`。这些方法让我们能够操作与类的特定实例相关的数据。我们可以通过在交互式提示符中打印它们，查看我们两个日期对象的内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can access the properties of our date objects by calling specific class
    attributes. These attributes are usually leveraged by code within the class to
    process the data, though we can also use these attributes to our advantage. For
    example, the hour or year attributes allow us to extract the hour or the year
    from our date objects. Though this may seem simple, it becomes more helpful in
    other modules when accessing the parsed or extracted data from the class instance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用特定的类属性来访问日期对象的属性。这些属性通常被类内部的代码用于处理数据，虽然我们也可以利用这些属性。例如，小时或年份属性允许我们从日期对象中提取小时或年份。尽管这看起来很简单，但在其他模块中访问从类实例中解析或提取的数据时，它变得更有用：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As mentioned previously, we can always run the `dir()` and `help()` functions
    to provide context on what methods and attributes are available for a given object.
    If we run the following code, we can see that we can extract the weekday or format
    the date using the ISO format. These methods provide additional information about
    our `datetime` objects and allow us to take full advantage of what the class object
    has to offer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以随时运行`dir()`和`help()`函数，以了解给定对象可用的方法和属性。如果我们运行以下代码，就可以看到我们能够提取星期几或使用ISO格式格式化日期。这些方法提供了关于我们`datetime`对象的额外信息，并让我们能够充分利用类对象提供的功能：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try and except
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试与异常处理
- en: The try and except syntax is used to catch and safely handle errors that are
    encountered during runtime. As a new developer, you'll eventually become accustomed
    to having people telling you that your scripts don't work. In Python, we use the
    `try` and `except` blocks to stop preventable errors from crashing our code. Please
    use the `try` and `except` blocks in moderation. Don't use them as if they were
    band-aids to plug up holes in a sinking ship—instead, reconsider your original
    design and contemplate modifying the logic to better prevent errors. One great
    way to help with this is to provide instructions for use through command-line
    arguments, documentation, or otherwise. Using these correctly will enhance the
    stability of your program. However, improper usage will not add any stability
    and can mask underlying issues in your code. A good practice is to use as few
    lines of code within a `try` and `except` block as possible; this way, the error
    handling is focused and addressed properly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`和`except`语法用于捕获并安全处理运行时遇到的错误。作为新手开发者，你最终会习惯于别人告诉你你的脚本无法正常工作。在Python中，我们使用`try`和`except`块来防止可避免的错误使代码崩溃。请适度使用`try`和`except`块。不要把它们当作修补漏洞的创可贴来用——相反，要重新考虑你的原始设计，并思考调整逻辑，以更好地防止错误。一个很好的方法是通过命令行参数、文档或其他方式提供使用说明。正确使用这些将增强程序的稳定性。然而，错误使用将无法增加稳定性，并可能掩盖代码中的潜在问题。一个好的实践是，在`try`和`except`块中尽可能使用较少的代码行；这样，错误处理更为集中和有效。'
- en: For example, say we have some code that performs a mathematical calculation
    on two numerical variables. If we anticipate that a user may accidentally enter
    non-integer or float values, we may want to wrap a `try` and `except` around the
    calculation to catch any `TypeError` exceptions that may arise. When we catch
    the error, we can try and convert the variables to integers with the class constructor
    method before entering the `try` and `except` block again. If successful, we have
    saved our code from a preventable crash and maintained specificity to prevent
    our program from accepting dictionary input, for example. In the case of receiving
    a dictionary object, we would want the script to crash and present debug information
    to the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一些代码，执行两个数值变量的数学计算。如果我们预见到用户可能会不小心输入非整数或浮动值，我们可能希望在计算过程中加入`try`和`except`，以捕获可能出现的`TypeError`异常。当我们捕获到错误时，可以尝试通过类构造方法将变量转换为整数，然后再进入`try`和`except`块。如果成功，我们就避免了程序因可预防的崩溃而中断，并且保持了特定性，防止程序接受如字典类型的输入。例如，在接收到字典对象时，我们希望脚本崩溃并向用户呈现调试信息。
- en: 'Any line that has a reasonable chance of generating an error should be handled
    by its own try and except block with a solution for that specific line to ensure
    that we are properly handling the specific error. There are a few variations of
    the `try` and `except` block. In short, there are catch-all, catch-as-variable,
    and catch-specific types of blocks. The following pseudocode shows examples of
    how the blocks are formed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有可能生成错误的代码行，都应该由独立的`try`和`except`块处理，并针对该特定行提供解决方案，以确保我们正确地处理了特定错误。`try`和`except`块有几种变体。简而言之，分为通用捕获、变量捕获和特定捕获类型的块。以下伪代码展示了这些块的构成示例：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The catch-all or bare except will catch any error. **This is often regarded
    as a poor coding practice as it can lead to undesired program behaviors.** Catching
    an exception as a variable is useful in a variety of situations. The error message
    of the exception stored in `e` can be printed or written to a log by calling `e.message`—this
    can be particularly useful when an error occurs within a large multi-module program.
    In addition, the built-in `isinstance()` function can be used to determine the
    type of error.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的或裸的`except`将捕获任何错误。**这通常被认为是一种糟糕的编码实践，因为它可能导致程序出现不期望的行为。** 捕获异常并将其作为变量是许多情况下非常有用的做法。通过调用`e.message`，存储在`e`中的异常错误信息可以被打印或写入日志——在大型多模块程序中，尤其有助于调试错误。此外，内建的`isinstance()`函数可以用来判断错误的类型。
- en: For support in both Python 2 and Python 3, please use the `except Exception
    as error` syntax as described previously, as opposed to the `except Exception,
    error` syntax supported by Python 2.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持Python 2和Python 3，请使用如前所述的`except Exception as error`语法，而不是Python 2支持的`except
    Exception, error`语法。
- en: 'In the example that we''ll look at next, we define two functions: `give_error()`
    and `error_handler()`. The `give_error()` function tries to append `5` to the
    `my_list` variable. This variable has not yet been instantiated and will generate
    a `NameError` instance. In the except clause, we are catching a base `Exception`
    and storing it in the `e` variable. We then pass this exception object to our
    `error_handler()` function, which we define later.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来要看的例子中，我们定义了两个函数：`give_error()`和`error_handler()`。`give_error()`函数尝试将`5`添加到`my_list`变量中。这个变量还没有实例化，因此会生成一个`NameError`实例。在`except`子句中，我们捕获了一个基类`Exception`，并将其存储在变量`e`中。然后，我们将这个异常对象传递给稍后定义的`error_handler()`函数。
- en: 'The `error_handler()` function takes an exception object as its input. It checks
    whether the error is an instance of `NameError` or `TypeError`, or it passes otherwise.
    Based on the type of exception, it will print out the exception type and error
    message:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_handler()`函数接收一个异常对象作为输入。它检查该错误是否为`NameError`或`TypeError`的实例，若不是则跳过。根据异常类型，它将打印出异常类型和错误信息：'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, the catch-specific try and except block can be used to catch individual
    exceptions and has targeted error-handling code for that specific error. A scenario
    that might require a catch-specific try and except block is working with an object,
    such as a list or dictionary, which may or may not be instantiated at that point
    in the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，特定异常捕获的`try`和`except`块可以用于捕获个别异常，并且为该特定错误提供有针对性的错误处理代码。一个可能需要使用特定异常捕获`try`和`except`块的场景是处理对象，比如列表或字典，这些对象可能在程序中某一时刻尚未实例化。
- en: 'In the following example, the results list does not exist when it is called
    in the function. Fortunately, we wrapped the append operation in a `try` and `except`
    to catch the `NameError` exceptions. When we catch this exception, we first instantiate
    the results list as an empty list and then append the appropriate data before
    returning the list. Here is the example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，当函数中调用结果列表时，它并不存在。幸运的是，我们将追加操作包装在了`try`和`except`中，以捕获`NameError`异常。当我们捕获到此异常时，我们首先将结果列表实例化为空列表，然后再添加适当的数据，最后返回该列表。以下是示例：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For (hopefully) obvious reasons, the previous code sample is intended to show
    the handling of exceptions. We should always be sure to initiate variables before
    usage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 出于（希望）显而易见的原因，前面的代码示例旨在展示如何处理异常。我们应该始终确保在使用变量之前进行初始化。
- en: The raise function
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`raise`函数'
- en: As our code can generate its own exceptions during execution, we can also manually
    trigger an exception to occur with the built-in `raise()` function. The `raise()` method
    is often used to raise an exception to the function that called it. While this
    may seem unnecessary, in larger programs, this can actually be quite useful.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码在执行过程中可能会生成自己的异常，我们也可以使用内置的`raise()`函数手动触发异常。`raise()`方法通常用于将异常抛给调用它的函数。尽管这看起来似乎不必要，但在大型程序中，这实际上是非常有用的。
- en: 'Imagine a function, `function_b()`, which receives parsed data in the form
    of a packet from `function_a()`. Our `function_b()` function does some further
    processing on the packet and then calls `function_c()` to continue to process
    the packet. If `function_c()` raises an exception back to `function_b()`, we might
    design some logic to alert the user of the malformed packet instead of trying
    to process it and producing faulty results. The following is some pseudocode representing
    such a scenario:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个函数`function_b()`，它接收从`function_a()`传递的解析数据包。我们的`function_b()`函数对数据包进行进一步处理，然后调用`function_c()`继续处理数据包。如果`function_c()`抛出异常返回给`function_b()`，我们可能会设计一些逻辑，提醒用户数据包格式错误，而不是尝试继续处理它，从而产生错误的结果。以下是表示这种场景的一些伪代码：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In addition, raising custom or built-in exceptions can be useful when dealing
    with exceptions that Python doesn't recognize on its own. Let's revisit the example
    of the malformed packet. When the second function received the raised error, we
    might design some logic that tests some possible sources of error. Depending on
    those results, we might raise different exceptions back to the calling function,
    `function_a()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在处理 Python 无法自动识别的异常时，抛出自定义或内置的异常是非常有用的。让我们回顾一下恶性数据包的例子。当第二个函数接收到抛出的错误时，我们可能会设计一些逻辑来测试一些可能的错误来源。根据这些结果，我们可能会抛出不同的异常回到调用函数`function_a()`。
- en: 'When raising a built-in exception, make sure to use an exception that most
    closely matches the error. For example, if the error revolves around an index
    issue, use the `IndexError` exception. When raising an exception, we should pass
    in a string containing a description of the error. This string should be descriptive
    and help the developer identify the issue, unlike the following string that''s
    used. The adage *do what we say, not what we do* applies here, as we are simply
    demonstrating functionality:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在引发内建异常时，确保使用最接近错误类型的异常。例如，如果错误涉及索引问题，应使用 `IndexError` 异常。在引发异常时，我们应该传入一个包含错误描述的字符串。这个字符串应当具有描述性，帮助开发者识别问题，而不像以下字符串那样简单。格言
    *做我们说的，不做我们做的* 在这里适用，因为我们仅仅是在展示功能：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating our first script – unix_converter.py
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个脚本 – unix_converter.py
- en: Our first script will perform a common timestamp conversion that will prove
    useful throughout this book. Named `unix_converter.py`, this script converts Unix
    timestamps into a human readable date and time value. Unix timestamps are generally
    formatted as an integer representing the number of seconds since `1970-01-01 00:00:00`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个脚本将执行一个常见的时间戳转换，这对于本书的内容非常有用。这个名为`unix_converter.py`的脚本将 Unix 时间戳转换为人类可读的日期和时间值。Unix
    时间戳通常格式化为一个整数，表示自 `1970-01-01 00:00:00` 起的秒数。
- en: 'On line one, we provide a brief description of our script to the users, allowing
    them to quickly understand the intentions and uses of the script. Following this
    are import statements on lines two through four. These imports likely look familiar,
    providing support (in order) for printing information in Python 2 and 3, interpreting
    timestamp data, and accessing information about the version of Python used. The
    `sys` library is then used on lines 6 through 12 to check what version of Python
    was used to call the script to properly handle accepting user input. Python 2
    uses the `raw_input` function to accept data at the Terminal for the user, while
    Python 3 implements the `input` function. This `if`/`elif`/`else` statement is
    then concluded with `NotImplementedError` for other (future) versions of Python
    not specified. To make things easier, we built this conditional in a manner that
    you can easily plug into your code. See the following for the described code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们为用户提供了脚本的简要描述，使他们能够快速理解脚本的意图和用途。接下来的第二至第四行是导入语句。这些导入可能看起来很熟悉，分别为 Python
    2 和 3 中打印信息、解析时间戳数据以及访问 Python 版本信息提供支持。然后，第六到第十二行使用 `sys` 库来检查调用脚本时使用的 Python
    版本，以便正确处理用户输入。Python 2 使用 `raw_input` 函数在终端接受用户数据，而 Python 3 实现了 `input` 函数。接下来，这个
    `if`/`elif`/`else` 语句在未指定的其他（未来）Python 版本中以 `NotImplementedError` 结束。为了简化起见，我们将这个条件语句设计得可以方便地插入到你的代码中。请参见以下描述的代码：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After an omitted license statement (please see the source code for the MIT license
    information), we provide additional script information for reference by the user
    and to standardize our script implementation. We then move to the `main()` function,
    which prompts the user for a timestamp to convert and then prints the results
    of the transformed timestamp from our `Unix_converter()` function. To break apart
    line 49 a little more, let's start at the innermost component, the `get_input()`
    function call. This function is supplied with a string that will be displayed
    to the user in front of the buffer allowing user input. This `get_input()` function
    returns a string value of the data entered into the console by the user, although
    we need to convert this value into an integer. We use the `int` class to initialize
    an integer value that we then store in the `unix_ts` variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在省略的许可证声明之后（请参阅源代码中的 MIT 许可证信息），我们提供了额外的脚本信息，供用户参考，并且标准化我们的脚本实现。然后，我们进入 `main()`
    函数，提示用户输入一个时间戳进行转换，并打印从 `Unix_converter()` 函数转换后的时间戳结果。为了更详细地解析第49行，让我们从最内层的部分开始，`get_input()`
    函数的调用。该函数接受一个字符串，显示在用户输入框前，允许用户输入数据。`get_input()` 函数返回用户在控制台输入的数据的字符串值，尽管我们需要将这个值转换为整数。我们使用
    `int` 类初始化一个整数值，并将其存储在 `unix_ts` 变量中。
- en: Applying concepts
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用概念
- en: How could we redesign line 49 to better handle the user input and any exceptions
    that may arise when accepting this data?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何重新设计第49行，以更好地处理用户输入以及可能出现的异常？
- en: Hint
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It may take more than one line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要多行代码。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On line 50 in the previous code block, we call the `unix_converter()` function,
    providing the integer input from the user. This function then, as defined on line
    53 in the following code, calls the `datetime` module and uses the `utcfromtimestamp()`
    method to read the integer as a `datetime` object. We are using the `utcfromtimestamp()`
    method here instead of the similarly named `fromtimestamp()` method, as the `utcfromtimestamp()`
    version does not apply time zone modifications to the provided data and leaves
    the timestamp in the original time zone. This returned `datetime` object is then
    converted into a human-readable string using the `strftime()` method and the resulting
    string is returned to the calling function, which ultimately prints this value
    to the console:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中的第50行，我们调用了`unix_converter()`函数，并提供了来自用户的整数输入。然后该函数，如以下代码第53行所定义，调用了`datetime`模块，并使用`utcfromtimestamp()`方法将整数读取为`datetime`对象。我们在这里使用`utcfromtimestamp()`方法，而不是名字类似的`fromtimestamp()`方法，因为`utcfromtimestamp()`版本不会对提供的数据应用时区修改，而是保持时间戳在原始时区。返回的`datetime`对象随后使用`strftime()`方法转换为人类可读的字符串，并将结果字符串返回给调用函数，最终将该值打印到控制台：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our script is concluded with two lines of code, as shown in the following snippet,
    which will become very frequent in the conclusions of our scripts. The first of
    these lines, on line 57, is a conditional that''s used to check whether the script
    was executed as a script instead of imported as a module. This allows us to change
    the functionality of our code based on how it is used. In an example, a console
    version of our code should, generally, accept command-line arguments while a version
    used as a library will not need to prompt the user for those details as the calling
    script may only use a subset of functions within this code. This means that line
    58 is the only logic we want to execute if this code is called at the command
    line, which starts the `main()` function. If this script is imported as a module
    to another script, nothing will occur as we have no further logic to run on import.
    If it is imported, we will be able to use the functions without worrying about
    other calls occurring on import:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本以两行代码结束，如下所示，这将在我们脚本的结尾部分非常常见。第一行位于第57行，是一个条件语句，用于检查脚本是否作为脚本执行，而不是作为模块导入。这使我们能够根据代码的使用方式来改变其功能。在一个例子中，作为控制台版本的代码通常应该接受命令行参数，而作为库使用的版本则不需要提示用户输入这些细节，因为调用脚本可能只会使用此代码中的一部分功能。这意味着，第58行是我们希望在命令行调用此代码时执行的唯一逻辑，它启动了`main()`函数。如果此脚本作为模块导入到另一个脚本中，则不会发生任何操作，因为我们没有在导入时运行的进一步逻辑。如果它被导入，我们仍然可以使用这些函数，而无需担心导入时发生其他调用：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now execute this script by calling `unix_converter.py` at the command
    line. This script ran, as shown in the following screenshot, until it required
    input from the user. Once the value was entered, the script continued execution
    and printed the converted timestamp to the console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在命令行调用`unix_converter.py`来执行此脚本。该脚本如以下截图所示运行，直到它需要用户输入。一旦输入值，脚本继续执行并将转换后的时间戳打印到控制台：
- en: '![](img/9a19d5dc-c394-4e33-930c-487382ce4ca0.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a19d5dc-c394-4e33-930c-487382ce4ca0.png)'
- en: User input
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户输入
- en: Allowing user input enhances the dynamic nature of a program. It is a good practice
    to query the user for file paths or values rather than explicitly writing this
    information into the code file. Therefore, if the user wants to use the same program
    on a separate file, they can simply provide a different path, rather than editing
    the source code. In most programs, users supply input and output locations or
    identify which optional features or modules should be used at runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户输入增强了程序的动态性。最好向用户查询文件路径或值，而不是将这些信息显式写入代码文件。因此，如果用户想在另一个文件上使用相同的程序，他们可以简单地提供不同的路径，而无需编辑源代码。在大多数程序中，用户提供输入和输出位置，或者确定在运行时应使用哪些可选功能或模块。
- en: User input can be supplied when the program is first called or during runtime
    as an argument. For most projects, it is recommended to use command-line arguments
    because asking the user for input during runtime halts the program execution while
    waiting for the input.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入可以在程序首次调用时或在运行时作为参数提供。对于大多数项目，建议使用命令行参数，因为在运行时要求用户输入会暂停程序执行，直到输入完成。
- en: Using the raw input method and the system module – user_input.py
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始输入方法和系统模块 – user_input.py
- en: Both `input()` and `sys.argv` represent basic methods of obtaining input from
    users. Be cognizant of the fact that both of these methods return string objects,
    as previously discussed for the Python 2 `raw_input()` and Python 3 `input()`
    functions. We can simply convert the string into the required data type using
    the appropriate class constructor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 和 `sys.argv` 都是获取用户输入的基本方法。请注意，这两种方法返回的都是字符串对象，正如我们之前讨论的 Python 2
    中的 `raw_input()` 和 Python 3 中的 `input()` 函数一样。我们可以通过适当的类构造函数将字符串转换为所需的数据类型。'
- en: The `input()` function is similar to asking someone a question and waiting for
    their reply. During this time, the program's execution thread halts until a reply
    is received. We define a function later that queries the user for a number and
    returns the squared value. As seen in our first script, when converting Unix timestamps,
    we have to wait for the user to provide a value before the script can continue.
    While this wasn't an issue in that very short script, larger code bases or long-running
    scripts should avoid this delay.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()` 函数类似于向某人提问并等待其回复。在此期间，程序的执行线程会暂停，直到收到回复为止。稍后我们将定义一个函数，询问用户一个数字并返回其平方值。如我们在第一个脚本中所见，当转换
    Unix 时间戳时，我们必须等待用户提供值，脚本才能继续执行。尽管在那个非常简短的脚本中这不是问题，但较大的代码库或长时间运行的脚本应避免这种延迟。'
- en: Arguments supplied at the command line are stored in the `sys.argv` list. As
    with any list, these arguments can be accessed with an index, which starts at
    zero. The first element is the name of the script, while any element after that
    represents a space-separated user-supplied input. We need to import the `sys`
    module to access this list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行提供的参数存储在 `sys.argv` 列表中。像任何列表一样，这些参数可以通过索引访问，索引从零开始。第一个元素是脚本的名称，而之后的每个元素代表一个以空格分隔的用户输入。我们需要导入
    `sys` 模块才能访问这个列表。
- en: 'On line 39, we copy the arguments from the `sys.argv` list into a temporary
    list variable named `args`. This is preferred because, on line 41, we remove the
    first element after printing it. For the remaining items in the `args` list, we
    use a `for` loop and wrap our list with the built-in `enumerate()` function. This
    gives us a counter for our loop, `i`, to count the number of loop iterations or
    arguments used in this case. On lines 43 and 44, we print out each argument and
    its position and data type. We have the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 39 行，我们将 `sys.argv` 列表中的参数复制到一个名为 `args` 的临时列表变量中。这是首选方法，因为在第 41 行，我们打印出第一个元素后将其删除。对于
    `args` 列表中的其余项，我们使用 `for` 循环并将列表包装在内建的 `enumerate()` 函数中。这为我们的循环提供了一个计数器 `i`，用来计算循环的迭代次数或本例中使用的参数数目。在第
    43 和 44 行，我们打印出每个参数及其位置和数据类型。我们有如下代码：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After saving this file as `user_input.py`, we can call it at the command line
    and pass in our arguments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此文件保存为 `user_input.py` 后，我们可以在命令行调用它并传入我们的参数。
- en: 'As you can see in the following example, arguments are space delimited, therefore
    an argument with spaces needs to be wrapped with quotes. It is also clear in the
    following example that all argument values from `sys.argv` are stored as string
    values. The `input()` function also interprets all input as string values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如下例所示，参数是以空格分隔的，因此带有空格的参数需要用引号括起来。从以下示例中也可以清楚看出，所有来自 `sys.argv` 的参数值都作为字符串值存储。`input()`
    函数也会将所有输入解释为字符串值：
- en: '![](img/11dcec26-1ede-4643-9c05-8daa53de02c5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dcec26-1ede-4643-9c05-8daa53de02c5.png)'
- en: For smaller programs that do not have many command-line options, the `sys.argv`
    list is a quick and easy way to obtain user input without blocking script execution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有很多命令行选项的小型程序，`sys.argv` 列表是一个快速简便的方式来获取用户输入，而不会阻塞脚本的执行。
- en: 'File paths that contain a space should be double-quoted. For example, `sys.argv`
    would split `C:/Users/LPF/misc/my books` into `C:/Users/LPF/misc/my` and `books`.
    This would result in an `IOError` exception when trying to interact with this
    directory in a script. Additionally, watch for file paths containing the backslash
    character `\`; we need to escape this character to prevent our command line Terminal
    and our code from misunderstanding the input. This character is escaped by using
    a second backslash, like so: `\\`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 包含空格的文件路径应该使用双引号括起来。例如，`sys.argv` 会将 `C:/Users/LPF/misc/my books` 分割成 `C:/Users/LPF/misc/my`
    和 `books`。这会在脚本尝试与该目录交互时导致 `IOError` 异常。此外，注意包含反斜杠字符 `\` 的文件路径；我们需要转义此字符，以防止我们的命令行终端和代码误解输入。这个字符通过使用第二个反斜杠来转义，像这样：`\\`。
- en: Understanding Argparse – argument_parser.py
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Argparse – argument_parser.py
- en: Argparse is a module in the standard library and will be used throughout this
    book as a means of obtaining user input. Argparse can help develop more complicated
    command-line interfaces. By default, `argparse` creates a `-h` switch or a help
    switch to display help and usage information for the scripts. In this section,
    we will build a sample `argparse` implementation that has required, optional,
    and default arguments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`是标准库中的一个模块，本书中将多次使用它来获取用户输入。`argparse`有助于开发更复杂的命令行接口。默认情况下，`argparse`会创建一个`-h`开关或帮助开关，用于显示脚本的帮助和使用信息。在本节中，我们将构建一个示例的`argparse`实现，包含必需、可选和默认参数。'
- en: We import the `argparse` module, following our usual `print_function` and script
    description. We then specify our usual script header details as `__author__`,
    `__date__`, and `__description__` as we will be using all three in our `argparse`
    implementation. On line 38, we then define an overly simple `main()` function
    to print the parsed argument information, as we don't have any plans for this
    script other than to show off some neat user argument handling. To accomplish
    that goal, we first need to initiate our `ArgumentParser` class instance, as shown
    on lines 43 through 48\. Notice how we only implement this if the script is called
    from the command line with the conditional on line 42.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`argparse`模块，并按照常规的`print_function`和脚本描述进行设置。接着，我们指定通常的脚本头部信息，如`__author__`、`__date__`和`__description__`，因为我们将在`argparse`实现中使用这三者。在第38行，我们定义了一个过于简单的`main()`函数来打印解析后的参数信息，因为除了展示一些简洁的用户参数处理外，我们没有其他计划。为了实现这个目标，我们首先需要初始化`ArgumentParser`类实例，如第43到48行所示。注意，只有当脚本通过命令行调用时，才会执行这一部分，具体条件在第42行给出。
- en: 'On line 43, we initialize `ArgumentParser` with three optional arguments. The
    first is the description of the script, which we will read in from the `__description__`
    variable that was previously set. The second argument is the epilog or details
    provided at the end of the help section. This can be any arbitrary text, as can
    the description field, though we chose to use this to provide authorship and version
    information. For getting started, using date values as a version number is helpful
    for user reference and prevents complications with numbering schemes. The last
    optional argument is a formatter specification, instructing our argument parser
    to display any default values set by the script so that the user can know whether
    options will be set if they do not modify them through an argument. It is highly
    recommended to include this as a force of habit:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第43行，我们用三个可选参数初始化`ArgumentParser`。第一个是脚本的描述，我们会从之前设置的`__description__`变量中读取。第二个参数是结尾的附加说明，或者说帮助信息部分末尾的细节。这可以是任意文本，和描述字段一样，尽管我们选择用它来提供作者和版本信息。为了开始，使用日期作为版本号对于用户参考很有帮助，也能避免编号方案的复杂性。最后一个可选参数是格式化器规格，它指示我们的参数解析器显示脚本设置的任何默认值，以便用户了解如果不通过参数修改，选项是否会被设置。建议养成习惯，强烈推荐包括这个：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now leverage our newly instantiated parser object to add an argument
    specification. To start, let's discuss some healthy practices for required and
    optional arguments. Argparse, by default, uses the presence of one or two dashes
    prior to an argument name to note whether the argument should be considered optional
    or not. If the argument specification has a leading dash, it will be considered
    both optional and non-positional; the inverse, a lack of a leading dash, will
    instruct argparse to interpret an argument as required and positional.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用新实例化的解析器对象来添加参数说明。首先，让我们讨论一些有关必需和可选参数的良好实践。默认情况下，`argparse`会通过参数名前是否有一个或两个破折号来判断该参数是否是可选的。如果参数说明前有破折号，它将被认为既是可选的，又是非位置性的；反之，如果没有破折号，则`argparse`会将该参数视为必需且位置性参数。
- en: Use the following as an example; in this script, the `timezone` and `input_file`
    arguments are required and must be provided in that order. Additionally, the arguments
    for these two items do not require an argument specifier; instead, `argparse`
    will look for an unpaired value to assign to the `timezone` argument and then
    look for a second unpaired value to assign to the `input_file` argument. Inversely,
    the `--source`, `--file-type`, `-h` (or `--help`), and `-l` (or `--log`) arguments
    are non-positional and can be provided in any order as long as the appropriate
    value is immediately following, that is, paired with, with the argument specifier.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请参照以下示例；在这个脚本中，`timezone` 和 `input_file` 参数是必需的，且必须按照这个顺序提供。此外，这两个参数不需要额外的参数说明符；`argparse`
    会查找一个没有配对的值并将其分配给 `timezone` 参数，然后再查找另一个没有配对的值并将其分配给 `input_file` 参数。相反，`--source`、`--file-type`、`-h`（或
    `--help`）和 `-l`（或 `--log`）等参数是非位置参数，可以按任何顺序提供，只要紧跟其后的值与相应的参数说明符配对即可。
- en: 'To make things a little more complex, but more customizable, we can require
    non-positional arguments. This has an advantage, as we can now allow the user
    to enter the arguments in an arbitrary order, though as a disadvantage it requires
    additional typing for fields that are required for the script to operate. You''ll
    notice in the following code that the `--source` argument on the second line does
    not have square brackets surrounding the value. This is argparse''s (subtle) way
    of indicating that this is a required non-positional argument. It can be tricky
    for a user to understand this at first glance, though argparse will halt the execution
    of the script and alert the user if the argument is missing from the provided
    arguments. You may want to use non-positional required arguments in your scripts
    or avoid them all together—it is up to you as the developer to find the most comfortable
    and fitting interface for your users:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得稍微复杂一点，但也更具可定制性，我们可以要求非位置参数。这样做有一个优势，我们可以允许用户以任意顺序输入参数，尽管其缺点是要求用户为脚本运行所需的字段进行额外的输入。你会注意到，在接下来的代码中，第
    2 行的 `--source` 参数周围没有方括号。这是 `argparse` （微妙的）方式来指示这是一个必需的非位置参数。虽然一开始可能会让用户难以理解，但如果缺少此参数，`argparse`
    会中止脚本执行并提示用户。你可能想在脚本中使用非位置的必需参数，或者完全避免使用它们——作为开发者，你需要根据用户的需求找到最舒适且合适的界面：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mini-tangent aside, let''s start adding arguments to the parser object we initiated.
    We will start with one of the positional arguments we previously discussed. The
    `timezone` argument is defined using the `add_argument()` method, allowing us
    to provide a string representing the argument name and optional parameters for
    additional detail. On line 51, we simply offer helpful information to provide
    context to how this argument should be used:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微离题一下，接下来我们将开始向我们初始化的解析器对象添加参数。我们将从之前讨论过的一个位置参数开始。`timezone` 参数是通过 `add_argument()`
    方法定义的，允许我们提供一个表示参数名称的字符串，并可以附加一些可选的参数来增加详细信息。在第 51 行，我们简单地提供了一些有用的信息，用以说明如何使用该参数：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next argument we add, on line 54, is the non-positional required argument
    previously discussed. Notice how we use the `required=True` statement to indicate
    that, regardless of the leading dashes, this argument is required for execution:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 54 行添加的下一个参数是之前讨论过的非位置必需参数。注意，我们使用了 `required=True` 语句来表示，无论前面有没有连字符，这个参数在执行时都是必需的：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now add our first non-positional and optional argument for the log file.
    Here, we are providing two options for how the user can specify the argument,
    `-l` or `--log.` This is recommended for common arguments, as it provides the
    frequent user shorthand and the novice user context for argument use:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加第一个非位置参数和可选的日志文件参数。在这里，我们提供了两种方式让用户指定该参数，`-l` 或 `--log`。这是针对常见参数的推荐方式，因为它既为经常使用的用户提供了简短的命令，也为新手用户提供了参数使用的上下文：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Not all arguments need to accept a value; in some instances, we just need a
    Boolean answer from the argument. Additionally, we may want to allow the argument
    to be specified multiple times or have custom functionality when called. To support
    this, the `argparse` library allows for the use of actions. The actions we will
    commonly use in this book are demonstrated as follows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的参数都需要接受一个值；在某些情况下，我们只需要从参数中得到一个布尔值的答案。此外，我们可能希望允许多次指定该参数，或者在调用时实现自定义功能。为了支持这一点，`argparse`
    库允许使用动作。我们在本书中常用的动作如下所示。
- en: The first action that is handy is `store_true` and is the opposite of `store_false`.
    These are handy for getting information on enabling or disabling functionality
    in your script. As shown in the following code block on lines 61 through 64, we
    can see the action parameter being used to specify whether `True` or `False` should
    be stored as a result of the argument. In this case, this is duplicative, and
    one of these two arguments could be used to determine whether the email in this
    example should be sent. Additional actions are available, such as `append`, as
    shown on line 66 and 67, where each instance of an email address, in this example,
    will be added to a list that we can iterate through and use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有用的操作是 `store_true`，它是 `store_false` 的反义词。这对于获取脚本中启用或禁用功能的信息非常方便。正如下面代码块中第
    61 到第 64 行所示，我们可以看到操作参数用于指定是否应该将 `True` 或 `False` 存储为参数的结果。在这种情况下，这是重复的，两个参数中的一个可以用来决定是否应该发送此示例中的电子邮件。还有其他操作可用，例如
    `append`，如第 66 和 67 行所示，其中每个电子邮件地址实例（在这个例子中）将被添加到一个列表中，我们可以遍历该列表并使用它。
- en: 'The last action example in the following code is used to count the number of
    times an argument is called. We see this implementation primarily for increasing
    verbosity or debugging messages, though it can be used elsewhere in the same fashion:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的最后一个操作示例用于计算某个参数被调用的次数。我们主要在增加冗余或调试信息时看到这种实现，但它也可以在其他地方以相同的方式使用：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `default` keyword dictates the default value of an argument. We can also
    use the `type` keyword to store our argument as a certain object. Instead of being
    stuck with strings as our only input, we can now store the input directly as the
    desired object, such as an integer, and remove the need for user input conversions
    from our scripts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 关键字决定了参数的默认值。我们还可以使用 `type` 关键字将我们的参数存储为特定的对象。现在，我们可以直接将输入存储为所需的对象，例如整数，而无需将字符串作为唯一输入，并且不再需要在脚本中进行用户输入转换：'
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Argparse can be used to directly open a file for reading or writing. On line
    76, we open the required argument, `input_file`, in reading mode. By passing this
    file object into our main script, we can immediately begin to process our data
    of interest. This is repeated on the next line to handle opening a file for writing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Argparse 可以直接用于打开文件进行读取或写入。在第 76 行，我们以读取模式打开所需的参数 `input_file`。通过将这个文件对象传递到主脚本中，我们可以立即开始处理我们感兴趣的数据。下一行会重复执行这个操作，处理文件写入的打开：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last keyword we will discuss is `choices`, which takes a list of case-sensitive
    options that the user can select from. When the user calls this argument, they
    must then provide one of the valid options. For example, `--file-type RAW` would
    set the `file-type` argument to the RAW choice, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个关键字是 `choices`，它接受一个大小写敏感的选项列表，用户可以从中选择。当用户调用此参数时，他们必须提供有效选项之一。例如，`--file-type
    RAW` 将把 `file-type` 参数设置为 RAW 选项，如下所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, once we have added all of our desired arguments to our `parser`, we
    can parse the arguments. On line 84, we call the `parse_args()` function, which
    creates a `Namespace` object. To access, for example, the length argument that
    we created on line 72, we need to call the `Namespace` object such as `arguments.length`.
    On line 85, we pass our arguments into our `main()` function, which prints out
    all of the arguments in the `Namespace` object. We have the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们将所有所需的参数添加到 `parser` 中，我们可以解析这些参数。在第 84 行，我们调用 `parse_args()` 函数，它创建了一个
    `Namespace` 对象。例如，要访问我们在第 72 行创建的 `length` 参数，我们需要像 `arguments.length` 这样调用 `Namespace`
    对象。在第 85 行，我们将参数传递到 `main()` 函数中，该函数打印出 `Namespace` 对象中的所有参数。我们有以下代码：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These `Namespace` objects may be reassigned to variables for easier recall.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Namespace` 对象可以重新分配给变量，以便更容易记住。
- en: 'With the basics of the `argparse` module behind us, we can now build simple
    and more advanced command-line arguments for our scripts. Therefore, this module
    is used extensively to provide command-line arguments for most of the code we
    will build. When running the following code with the `--help` switch, we should
    see our series of required and optional arguments for the script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了 `argparse` 模块的基础知识后，我们现在可以为我们的脚本构建简单和更高级的命令行参数。因此，这个模块被广泛用于为我们将要构建的大多数代码提供命令行参数。当运行以下代码并使用
    `--help` 开关时，我们应该能够看到脚本所需的必需参数和可选参数：
- en: '![](img/10198d66-121b-4449-a597-a10870d68445.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10198d66-121b-4449-a597-a10870d68445.png)'
- en: Forensic scripting best practices
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法医脚本最佳实践
- en: 'Forensic best practices play a big part in what we do and, traditionally, refer
    to handling or acquiring evidence. However, we''ve designated some forensic best
    practices of our own when it comes to programming, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 取证最佳实践在我们的工作中占据着重要地位，传统上，它指的是处理或获取证据。然而，在编程方面，我们自己也定义了一些取证最佳实践，如下所示：
- en: Do not modify the original data you're working with
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要修改你正在使用的原始数据
- en: Work on copies of the original data
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始数据的副本上进行操作
- en: Comment code
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释代码
- en: Validate your program's results (and other application results)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证程序的结果（以及其他应用程序的结果）
- en: Maintain extensive logging
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护详细的日志记录
- en: Return output in an easy-to-analyze format (your users will thank you)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以易于分析的格式返回输出（你的用户会感谢你）
- en: 'The golden rule of forensics is: strongly avoid modification of the original
    data. Work on a verified forensic copy whenever possible. However, this may not
    be an option for other disciplines, such as for incident responders where the
    parameters and scope varies. As always, this varies on the case and circumstances,
    but please keep in mind the ramifications of working on live systems or with original
    data.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 取证的黄金法则是：尽量避免修改原始数据。尽可能在经过验证的取证副本上进行操作。然而，这对其他领域可能不可行，例如事故响应人员，因其参数和范围不同。如同往常一样，这要根据具体情况而定，但请记住在运行时系统或原始数据上工作的潜在后果。
- en: In these cases, it is important to consider what the code does and how it might
    interact with the system at runtime. What kind of footprint does the code leave
    behind? Could it inadvertently destroy artifacts or references to them? Has the
    program been validated in similar conditions to ensure that it operates properly?
    These are the kinds of considerations that are necessary when it comes to running
    a program on a live system.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，重要的是要考虑代码的作用以及它在运行时如何与系统互动。代码会留下什么样的痕迹？它是否可能无意间破坏了证据或与之相关的引用？程序是否在类似的条件下经过验证，以确保它能正常运行？这些是运行程序时必须考虑的因素，尤其是在实时系统上。
- en: We've touched on commenting code before, but it cannot hurt to overstate its
    value. Soon, we will create our first forensic script, `usb_lookup.py`, which
    is a little over 90 lines of code. Imagine being handed the code without any explanation
    or comments. It might take a few minutes to read and understand what it does exactly,
    even for an experienced developer. Now, imagine a large project's source code
    that has thousands of lines of code—it should be apparent how valuable comments
    are, not just for the developer but also those who examine the code afterwards.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过代码注释，但再强调它的重要性也不会过分。很快，我们将创建第一个取证脚本`usb_lookup.py`，它的代码行数略超过90行。试想一下，如果没有任何解释或注释，直接交给你这段代码。即便是经验丰富的开发者，也可能需要几分钟时间才能理解它的具体功能。现在，想象一下一个大型项目的源代码，里面有成千上万行代码——这样你就能明白注释的价值了，这不仅对开发者很重要，也对之后查看代码的人至关重要。
- en: Validation essentially comes down to knowing the code's behavior. Obviously,
    bugs are going to be discovered and addressed. However, bugs have a way of frequently
    turning up and are ultimately unavoidable as it is impossible to test against
    all possible situations during development. Instead, what can be established is
    an understanding of the behavior of the code in a variety of environments and
    situations. Mastering the behavior of your code is important, not only to be able
    to determine if the code is up for the task at hand but also when asked to explain
    its function and inner workings in a courtroom.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 验证本质上就是要了解代码的行为。显然，漏洞会被发现并解决。然而，漏洞有时会反复出现，最终是无法避免的，因为在开发过程中无法测试所有可能的情况。相反，我们可以建立对代码在不同环境和情况下行为的理解。掌握代码的行为非常重要，不仅是为了能确定代码是否能够完成任务，还因为当你被要求在法庭上解释其功能和内部工作时，了解这些也至关重要。
- en: Logging can help keep track of any potential errors during runtime and act as
    an audit-chain of sorts for what the program did and when. Python supplies a robust
    logging module in the standard library, unsurprisingly named `logging`. We will
    use this module and its various options throughout this book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录有助于跟踪运行时可能出现的错误，并充当程序执行过程的审计链。Python在标准库中提供了一个强大的日志模块，名为`logging`。在本书中，我们将使用这个模块及其各种选项。
- en: The purpose of our scripts is to automate some of the tedious repetitive tasks
    in forensics and supply analysts with actionable knowledge. Oftentimes, the latter
    refers to storing data in a format that is easily manipulated. In most cases,
    a CSV file is the simplest way to achieve this so that it can be opened with a
    variety of different text or workbook editors. We will use the `csv` module in
    many of our programs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写脚本的目的是自动化一些繁琐的重复任务，为分析人员提供可操作的知识。通常来说，后者指的是以易于操作的格式存储数据。在大多数情况下，CSV 文件是实现这一目标的最简单方式，因为它可以用多种不同的文本编辑器或工作簿编辑器打开。我们将在许多程序中使用
    `csv` 模块。
- en: Developing our first forensic script – usb_lookup.py
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个取证脚本 – usb_lookup.py
- en: Now that we've gotten our feet wet writing our first Python script, let's write
    our first forensic script. During forensic investigations, it is not uncommon
    to see references to external devices by their **vendor identifier** (**VID**)
    and **product identifier** (**PID**) values; these values are represented by four
    hexadecimal characters. In cases where the vendor and product name are not identified,
    the examiner must look up this information. One such location for this information
    is the following web page: [http://linux-usb.org/usb.ids](http://linux-usb.org/usb.ids).
    For example, on this web page, we can see that a Kingston DataTraveler G3 has
    a VID of 0951 and a PID of 1643\. We will use this data source when attempting
    to identify vendor and product names by using the defined identifiers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经开始编写第一个 Python 脚本，接下来让我们编写第一个取证脚本。在取证调查中，常常会看到通过 **厂商标识符** (**VID**) 和
    **产品标识符** (**PID**) 值来引用外部设备；这些值由四个十六进制字符表示。如果没有标识出厂商和产品名称，检查员必须查找相关信息。一个这样的查找位置是以下网页：[http://linux-usb.org/usb.ids](http://linux-usb.org/usb.ids)。例如，在这个网页上，我们可以看到
    Kingston DataTraveler G3 的 VID 是 0951，PID 是 1643。当我们试图通过已定义的标识符来识别厂商和产品名称时，我们将使用这个数据源。
- en: 'First, let''s look at the data source we''re going to be parsing. A hypothetical
    sample illustrating the structure of our data source is mentioned later. There
    are USB vendors and, for each vendor, a set of USB products. Each vendor or product
    has four-digit hexadecimal characters and a name. What separates vendor and product
    lines are tabs because products are tabbed over once under their parent vendor.
    As a forensic developer, you will come to love patterns and data structures, as
    it is a happy day when data follows a strict set of rules. Because of this, we
    will be able to preserve the relationship between the vendor and its products
    in a simple manner. Here is the afore-mentioned hypothetical sample:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下我们将要解析的数据源。后面会提到一个假设的示例，来说明我们数据源的结构。数据源包含 USB 厂商，并且每个厂商下有一组 USB 产品。每个厂商或产品都有四位十六进制字符和一个名称。区分厂商和产品行的标识符是制表符，因为产品在其父厂商下往往是通过制表符缩进的。作为一名取证开发者，你会开始喜爱模式和数据结构，因为当数据遵循一套严格的规则时，真的是个开心的日子。正因为如此，我们可以简单地保留厂商和产品之间的关系。以下是上述假设的示例：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This script, named `usb_lookup.py`, takes a `VID` and `PID` that''s supplied
    by the user and returns the appropriate vendor and product names. Our program
    uses the `urlopen` method from the `urllib` module to download the `usb.ids` database
    to memory and create a dictionary of VIDs and their products. Since this is one
    of the libraries that changed between versions 2 and 3 of Python, we have introduced
    some logic in a `try` and `except` block to ensure we are able to call the `urlopen`
    method without issue, as shown in the following code. We also import the `argparse`
    module to allow us to accept `VID` and `PID` information from the user:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本名为 `usb_lookup.py`，它接收用户提供的 `VID` 和 `PID`，并返回相应的厂商和产品名称。我们的程序使用 `urllib`
    模块中的 `urlopen` 方法下载 `usb.ids` 数据库到内存，并创建一个包含 VIDs 及其产品的字典。由于这是 Python 2 和 3 版本之间改变过的库，我们在
    `try` 和 `except` 块中引入了一些逻辑，以确保我们能够顺利调用 `urlopen` 方法，代码如下所示。我们还导入了 `argparse` 模块，以便接受用户提供的
    `VID` 和 `PID` 信息：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If a vendor and product combination is not found, error handling will inform
    the user of any partial results and exit the program gracefully.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到厂商和产品的组合，错误处理机制将通知用户任何部分结果，并优雅地退出程序。
- en: 'The `main()` function contains the logic to download the `usb.ids` file, store
    it in memory, and create the USB dictionary. The structure of the USB dictionary
    is somewhat complex and involves mapping a `VID` to a list, containing the name
    of the vendor as the first element, and a product dictionary as the second element.
    This product dictionary maps PIDs to their names. The following is an example
    of the USB dictionary containing two vendors, `VendorId_1` and `VendorId_2`, each
    mapped to a list containing the vendor name, and a dictionary for any product
    ID and name pairs:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数包含了下载`usb.ids`文件、将其存储到内存中并创建USB字典的逻辑。USB字典的结构有些复杂，它涉及将`VID`映射到一个列表，列表的第一个元素是供应商名称，第二个元素是一个产品字典，后者将PID映射到其名称。以下是包含两个供应商`VendorId_1`和`VendorId_2`的USB字典示例，每个供应商都映射到一个包含供应商名称的列表，并且每个列表都包含一个用于存储产品ID和名称对的字典：'
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It may be tempting to just search for `VID` and `PID` in the lines and return
    the names rather than creating this dictionary that links vendors to their products.
    However, products can share the same ID across different vendors, which could
    result in mistakenly returning a product from a different vendor. With our previous
    data structure, we can be sure that the product belongs to the associated vendor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一种冲动，只是简单地在代码行中搜索`VID`和`PID`并返回名称，而不是创建一个将供应商与其产品链接的字典。然而，产品在不同的供应商之间可能会共享相同的ID，这可能导致错误地返回来自其他供应商的产品。通过我们之前的数据结构，我们可以确保产品属于相关的供应商。
- en: 'Once the USB dictionary has been created, the `search_key()` function is responsible
    for querying the dictionary for a match. It first assigns the user-supplied two
    arguments, `VID` and `PID`, before continuing with the execution of the script.
    Next, it searches for a `VID` match in the outermost dictionary. If `VID` is found,
    the innermost dictionary is searched for the responsive `PID`. If both are found,
    the resolved names are printed to the console. Lastly, starting at line 81, we
    define our arguments for the user to provide the `VID` and `PID` values before
    calling the `main()` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦USB字典被创建，`search_key()`函数就负责查询字典以匹配项。它首先赋值用户提供的两个参数，`VID`和`PID`，然后继续执行脚本。接下来，它在最外层字典中搜索`VID`匹配项。如果找到了`VID`，则会在最内层字典中搜索响应的`PID`。如果两个都找到了，解析出的名称将打印到控制台。最后，从第81行开始，我们定义了用户提供`VID`和`PID`值的参数，然后调用`main()`函数：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For larger scripts, such as this, it is helpful to view a diagram that illustrates
    how these functions are connected together. Fortunately, a library named `code2flow`,
    available on GitHub ([https://github.com/scottrogowski/code2flow.git](https://github.com/scottrogowski/code2flow.git)),
    exists to automate this process for us. The following schematic illustrates the
    flow from the `main()` function to the `search_key()` function. There are other
    libraries that can create similar flow charts. However, this library does a great
    job of creating a simple and easy to understand flowchart:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的脚本，像这样的脚本，查看一个展示这些函数如何连接在一起的图示是非常有帮助的。幸运的是，有一个名为`code2flow`的库，托管在GitHub上（[https://github.com/scottrogowski/code2flow.git](https://github.com/scottrogowski/code2flow.git)），它可以自动化这个过程。下面的示意图展示了从`main()`函数到`search_key()`函数的流程。还有其他库可以创建类似的流程图。然而，这个库在创建简单且易于理解的流程图方面做得非常好：
- en: '![](img/2ed8a4fd-93ec-4620-a007-9ef795ebbab2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ed8a4fd-93ec-4620-a007-9ef795ebbab2.png)'
- en: Understanding the main() function
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`main()`函数
- en: 'Let''s start by examining the `main()` function, which is called on line 90,
    as seen in the previous code block. This function, on line 42, requires the `vid`
    and `pid` information supplied by the user''s arguments for resolution in the
    `usb.ids` database. On lines 43 through 46, we create our initial variables. The `url` variable
    stores the URL containing the USB data source. We use the `urlopen()` function
    from the `urllib` module to create a list of strings from our online source. We
    will use a lot of string operations, such as `startswith()`, `isalnum()`, `islower()`,
    and `count()`, to parse the `usb.ids` file structure and store the parsed data
    in the `usbs` dictionary. The `curr_id` variable, defined as an empty string on
    line 46, will be used to keep track of which vendor we are currently processing
    in our script:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查 `main()` 函数开始，该函数在第 90 行被调用，如前面的代码块所示。这个函数在第 42 行需要用户参数提供的 `vid` 和 `pid`
    信息，以便在 `usb.ids` 数据库中解析。在第 43 到 46 行，我们创建了初始变量。`url` 变量存储包含 USB 数据源的 URL。我们使用
    `urllib` 模块中的 `urlopen()` 函数从在线数据源创建字符串列表。我们将使用许多字符串操作，如 `startswith()`、`isalnum()`、`islower()`
    和 `count()`，来解析 `usb.ids` 文件结构，并将解析后的数据存储在 `usbs` 字典中。第 46 行定义的空字符串 `curr_id`
    变量将用于跟踪我们当前在脚本中处理的供应商：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An important concept in Python string manipulation is encoding. This is one
    of the most common issues when writing Python 2 and Python 3 compatible code.
    The following `for` loop on line 48 starts iterating over each line in the file,
    providing the line for review. For Python 3 support, we have to check whether
    the line variable is an instance of bytes, a raw data type that (in this case)
    is holding encoded string data. If this is the case, we must decode it using the
    `decode()` method and provide the proper encoding—`latin-1` in this instance,
    as seen on line 50\. Python 2 reads data from files as strings and therefore will
    not enter this conditional, so we can move forward with parsing the line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 字符串操作中，一个重要的概念是编码。这是编写兼容 Python 2 和 Python 3 代码时最常见的问题之一。第 48 行的 `for`
    循环开始迭代文件中的每一行，逐行进行检查。为了支持 Python 3，我们必须检查该行变量是否是字节类型的实例，这是一种原始数据类型（在此情况下）存储了编码的字符串数据。如果是这种情况，我们必须使用
    `decode()` 方法并提供正确的编码——在此例中为 `latin-1`，如第 50 行所示。Python 2 从文件中读取数据时是以字符串形式读取的，因此不会进入这个条件判断，之后我们可以继续解析该行：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our next conditional checks for commented lines in the `usb.ids` file, skipping
    any blank lines (only containing a newline or tab character) and any comment lines
    starting with a pound character. To check for comment lines, we can use the `startswith()` string
    method to check whether the provided string, of one or more characters, is the
    same as the line we are checking. To simplify our code, we also leveraged the
    `in` statement, which allows us to handle an `or`-like comparison of equality
    for the line. This is a handy shortcut you will see in a variety of scripts. If
    either of these conditions is true, we will use the continue statement as seen
    on line 52 to step into the next loop iteration:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的条件判断会检查 `usb.ids` 文件中的注释行，跳过任何空行（只包含换行符或制表符）和以井号字符开头的注释行。为了检查注释行，我们可以使用
    `startswith()` 字符串方法来判断提供的字符串（一个或多个字符）是否与我们检查的行相同。为了简化代码，我们还利用了 `in` 语句，它允许我们进行类似
    `or` 的等式比较。这是一个方便的快捷方式，你将在各种脚本中看到它。如果这两个条件中的任何一个为真，我们将使用 continue 语句（如第 52 行所示）跳入下一次循环迭代：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second half of our conditional handles additional validation of the line
    format. We want to confirm that the line we are inspecting matches the format
    of a vendor line, so we can include our vendor-related parsing code within it.
    To do this, we check to make sure the line does not start with a tab character
    and the first character is alphanumeric with the `isalnum()` call:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们条件判断的第二部分处理额外的行格式验证。我们希望确认我们正在检查的行是否符合供应商行的格式，这样我们就可以将与供应商相关的解析代码放入其中。为此，我们首先检查该行是否以制表符开头，并且第一个字符是否为字母数字字符，通过调用
    `isalnum()` 来进行判断：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Knowing that the line passed our check for confirming it is a vendor informational
    line, we can start extracting the needed values and fill out our data structure.
    On line 55, we extract our two values from the line, `uid` and `name`, by stripping
    the line and using the `split()` method. The `split()` method is using two parameters
    here, one for the character to split on and the second for the number of times
    to split. In this case, we are splitting on a space character and only splitting
    after finding the first space.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 知道该行通过了检查，确认它是供应商信息行后，我们可以开始提取所需的值，并填充我们的数据结构。在第55行，我们通过去除行两侧的空白字符，并使用`split()`方法从该行中提取`uid`和`name`两个值。`split()`方法在这里使用了两个参数，一个是拆分字符，另一个是拆分次数。在这种情况下，我们是基于空格字符进行拆分，并且只在找到第一个空格后进行拆分。
- en: This is useful, as our vendor name may contain a space in it and we want to
    keep those details together. Since we anticipate two values returning, we can
    use the assignment seen on line 55 to simultaneously populate the `uid` and `name`
    variables with the correct values, though this can lead to errors if the `split()`
    method only returns one object. In this instance, we know our data source and
    have validated that this should always return two values, though this is a great
    spot to add a try-except block in your version of the code to handle any errors
    that may arise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做很有用，因为我们的供应商名称中可能包含空格，我们希望将这些详细信息保持在一起。由于我们预计返回两个值，因此可以使用第55行看到的赋值语句同时填充`uid`和`name`变量的正确值，尽管如果`split()`方法仅返回一个对象，这可能会导致错误。在这种情况下，我们了解数据源，并已验证这应该始终返回两个值，尽管这是一个很好的位置，在你自己的代码版本中添加一个`try-except`块来处理可能出现的错误。
- en: 'We then assign the `uid` variable to the `curr_id` value for use while parsing
    `PID` details on line 56\. Finally, on line 57, we add this information to our
    data structure, `usbs`. Since the `usbs` structure is a dictionary, we assign
    the VID''s `uid` value as the key and set up our list with the `VID` common name
    as the first element and an empty dictionary for product details as a second.
    On line 57, we ensure that the vendor name does not have any unwanted whitespace
    characters on it by calling the `strip()` method on the string:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`uid`变量赋值为`curr_id`的值，以便在解析第56行的`PID`详细信息时使用。最后，在第57行，我们将这些信息添加到我们的数据结构`usbs`中。由于`usbs`结构是一个字典，我们将VID的`uid`值作为键，并将`VID`的通用名称作为第一个元素，产品详细信息的空字典作为第二个元素。在第57行，我们通过调用字符串的`strip()`方法来确保供应商名称没有多余的空白字符：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we have processed the vendor data pattern, let''s turn our attention
    to the product data pattern. First, we will use an `elif` conditional to check
    that the line does start with a tab character and, using the `count()` method,
    ensure that it is the only tab character in the line. On line 59, we make a familiar
    call to strip and split the line into our required values. On line 60, we then
    add the product information to our data structure. As a quick refresher, `usbs`
    is a dictionary, where the keys are VIDs. Within a VID''s value is a list where
    element zero is the vendor name and element one is the dictionary to store PID
    details. As expected, we will use the `uid` value as the key for the product details
    and assign the product name to the `PID` key. Notice how we use the `curr_id`
    value from the prior vendor line to ensure we are correlating the VIDs and PIDs
    properly:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了供应商数据模式，接下来将注意力转向产品数据模式。首先，我们将使用`elif`条件语句检查该行是否以制表符字符开始，并使用`count()`方法确保该行中只有一个制表符字符。在第59行，我们调用熟悉的`strip()`方法并将该行拆分为所需的值。在第60行，我们将产品信息添加到我们的数据结构中。作为一个简短的回顾，`usbs`是一个字典，其中的键是VID。在每个VID的值中，是一个列表，列表的第一个元素是供应商名称，第二个元素是一个字典，用于存储PID详细信息。正如预期的那样，我们将使用`uid`值作为产品详细信息的键，并将产品名称分配给`PID`键。请注意，我们如何使用前一行供应商中的`curr_id`值来确保我们正确地关联VID和PID：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previous lines then repeat in a `for` loop until the end of the file is
    reached, parsing out the vendor and product details and adding them into the `usbs`
    dictionary.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，前面的行会在一个`for`循环中重复，直到文件结束，解析出供应商和产品的详细信息，并将其添加到`usbs`字典中。
- en: 'We are almost there—the last part of our `main()` function is a call to the
    `search_key()` function, which takes the user-supplied `vid` and `pid` information,
    along with our newly built `usbs` dictionary for lookup. Notice how this call
    is indented with four spaces, placing it outside of the `for` loop and allowing
    us to only call this method one time, once the `usbs` lookup dictionary is complete:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快到了——`main()`函数的最后部分是调用`search_key()`函数，它接受用户提供的`vid`和`pid`信息，以及我们新创建的`usbs`字典进行查找。注意，这个调用缩进了四个空格，将其置于`for`循环之外，确保我们只调用一次该方法，前提是`usbs`查找字典已经完成：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This takes care of the logic in the `main()` function. Now, let's take a look
    at the `search_key()` function to determine how we will lookup our VID and PID
    values.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分完成了`main()`函数中的逻辑。现在，让我们看看`search_key()`函数，了解如何查找我们的VID和PID值。
- en: Interpreting the search_key() function
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释`search_key()`函数
- en: The `search_key()` function, originally called on line 62 of the `main()` function,
    is where we search for the user-supplied vendor and product IDs, and display the
    resolved results to the user. In addition, all of our error handling logic is
    contained within this function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_key()`函数最初在`main()`函数的第62行被调用，是我们查找用户提供的供应商和产品ID并将结果显示给用户的地方。此外，我们的所有错误处理逻辑都包含在这个函数中。'
- en: 'Let''s practice accessing nested lists or dictionaries. We discussed this in
    the `main()` function; however, it pays to actually practice rather than take
    our word for it. Accessing nested structures requires us to use multiple indices
    rather than just one. For example, let''s create a list and map that to `key_1`
    in a dictionary. To access elements from the nested list, we will need to supply
    `key_1` to access the list and then a numerical index to access elements of the
    list:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习访问嵌套的列表或字典。我们在`main()`函数中讨论过这个问题；然而，实际操作比仅仅听我们说更有帮助。访问嵌套结构需要我们使用多个索引，而不仅仅是一个。例如，让我们创建一个列表，并将其映射到字典中的`key_1`。要访问嵌套列表中的元素，我们需要先提供`key_1`来访问该列表，然后再提供一个数字索引来访问列表中的元素：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, let's switch gears, back to the task at hand, and leverage our new skills
    to search our dictionary to find vendor and product IDs. The `search_key()` function
    is defined on line 65 and takes the user-supplied VID and PID along with our parsed
    out `usb_dict` dictionary. We then start by querying `usb_dict` for the `vendor_key`
    value, using the `get()` method of a dictionary to attempt to get the requested
    key's value or return `None`, as specified on line 66, if the key is not found.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转回到当前任务，运用我们新学的技能，搜索字典中的供应商和产品ID。`search_key()`函数在第65行定义，它接受用户提供的VID和PID以及我们解析出的`usb_dict`字典。然后，我们开始查询`usb_dict`中对应的`vendor_key`值，使用字典的`get()`方法来尝试获取请求的键的值，如果找不到该键，则返回`None`，如第66行所指定：
- en: 'Please note that the data returned by the `get()` call, if successful, is the
    entire value for that key, or in this case a list, where element zero is the vendor
    name and element one is the dictionary of product details. We can then check,
    on line 67, to see whether the key was found; if it was unavailable, we print
    this to the user and exit on lines 68 and 69, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`get()`调用返回的数据（如果成功）是该键的整个值，或者在这个例子中是一个列表，其中元素零是供应商名称，元素一是包含产品详细信息的字典。然后，我们可以在第67行检查是否找到了该键；如果没有找到，我们会在第68和69行输出错误信息并退出，如下所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then repeat this logic for looking up the product information, though
    we first have to navigate to the product information. On line 71, we access element
    one of the vendor list, containing the product details dictionary, and perform
    the same `get()` method call to look up any name resolution for the PID. In the
    same manner, we check to see if the lookup failed and provide any available details
    to the user; in case it fails, we can at least give the vendor information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重复这个查找产品信息的逻辑，尽管我们首先需要导航到产品信息。在第71行，我们访问供应商列表的元素一，它包含产品详细信息字典，然后执行相同的`get()`方法调用，查找PID的任何名称解析。以相同的方式，我们检查查找是否失败，并提供任何可用的详细信息给用户；如果失败，至少我们可以提供供应商信息：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If everything resolves successfully, we can print the output to the user and
    the script will complete! Notice how, on line 77, in the format statement, we
    have to call the first element of the vendor variable since the value of the VID
    key lookup was a list, whereas the value of the PID key lookup is just the product''s
    name. This is where things can get a little confusing, though feel free to reference
    the earlier sample data structure and add as many intermediate print statements
    to help with comprehension:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们可以将输出打印给用户，脚本也就完成了！请注意，在第 77 行的格式化语句中，我们必须调用厂商变量的第一个元素，因为 VID 键查找的值是一个列表，而
    PID 键查找的值仅仅是产品名称。虽然这可能会让人有些困惑，但请随时参考之前的示例数据结构，并添加尽可能多的中间打印语句以帮助理解：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Running our first forensic script
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的第一个取证脚本
- en: 'The `usb_lookup.py` script requires two arguments—vendor and product IDs for
    the USB of interest. We can find this information by looking at a suspect `HKLM\SYSTEM\%CurrentControlSet%\Enum\USB`
    registry key. For example, supplying the vendor, `0951`, and product, `1643`,
    from the sub-key `VID_0951&PID_1643`, results in our script identifying the device
    as a Kingston DataTraveler G3:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`usb_lookup.py` 脚本需要两个参数——目标 USB 设备的厂商 ID 和产品 ID。我们可以通过查看疑似的 `HKLM\SYSTEM\%CurrentControlSet%\Enum\USB`
    注册表键来找到这些信息。例如，提供厂商 ID `0951` 和产品 ID `1643`（来自子键 `VID_0951&PID_1643`），可以让我们的脚本识别该设备为
    Kingston DataTraveler G3：'
- en: '![](img/9cf95fc4-970a-4d46-86ab-3025ec84fbbc.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cf95fc4-970a-4d46-86ab-3025ec84fbbc.png)'
- en: Our data source is not an all-inclusive list, and if you supply a vendor or
    a product ID that does not exist in the data source, our script will print that
    the ID was not found. The full code for this and all of our scripts can be downloaded
    from [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据源并非一个包含所有数据的完整列表，如果你提供了一个在数据源中不存在的厂商或产品 ID，我们的脚本会打印出该 ID 未找到的消息。此示例和所有其他脚本的完整代码可以从
    [https://packtpub.com/books/content/support](https://packtpub.com/books/content/support)
    下载。
- en: Troubleshooting
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: At some point in your development career—probably by the time you write your
    first script—you will have encountered a Python error and received a **Traceback**
    message. A Traceback provides the context of the error and pinpoints the line
    that caused the issue. The issue itself is described as an exception, and usually
    provides a human-friendly message of the error.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开发生涯的某个阶段——大概是在你写完第一个脚本之后——你肯定会遇到 Python 错误并收到 **Traceback** 消息。Traceback
    提供了错误的上下文，并指出了引起问题的代码行。问题本身被描述为一个异常，通常会提供一个对人类友好的错误信息。
- en: Python has a number of built-in exceptions, the purpose of which is to help
    the developer in diagnosing errors in their code. A full listing of built-in exceptions
    can be found at [https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多内建的异常，其目的是帮助开发者诊断代码中的错误。完整的内建异常列表可以在 [https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)
    找到。
- en: 'Let''s look at a simple example of an exception, `AttributeError`, and what
    the Traceback looks like in this case:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的异常示例，`AttributeError`，以及在这种情况下 Traceback 的样子：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The Traceback indicates the file in which the error occurred, in this case,
    `stdin` or standard input, because this code was written in the interactive prompt.
    When working on larger projects or with a single script, the file will be the
    name of the script causing the error rather than `stdin`. The `in <module>` bit
    will be the name of the function that contains the faulty line of code, or `<module>`
    if the code is outside of a function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Traceback 会指出错误发生的文件，在这个例子中是 `stdin` 或标准输入，因为这段代码是在交互式提示符中编写的。当在更大的项目中工作或只有一个脚本时，文件将是导致错误的脚本的名称，而不是
    `stdin`。`in <module>` 部分将是包含错误行代码的函数名，或者如果代码不在任何函数内，则显示 `<module>`。
- en: 'Now, let''s look at a slightly more complicated issue. To do this, let''s use
    the data structure from our prior script. In the following code block, we are
    not accessing the VID data with the `get()` call, but instead hoping that it exists.
    Temporarily replace line 66 of the `usb_lookup.py` script with the following for
    this example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个稍微复杂一点的问题。为此，我们将使用之前脚本中的数据结构。在下面的代码块中，我们并没有通过 `get()` 方法访问 VID 数据，而是希望它存在。为了示范，请暂时将
    `usb_lookup.py` 脚本中的第 66 行替换为以下内容：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, if you run this updated code with a valid vendor key, you will get an
    expected result, though use a key such as `ffff` and see what occurs. Check if
    it looks like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用有效的供应商密钥运行更新后的代码，你将得到预期的结果，尽管使用像`ffff`这样的密钥看看会发生什么。检查一下是否看起来像下面这样：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The traceback here has three traces in the stack. The last trace at the bottom
    is where our error occurred. In this case, on line 66 of the `usb_lookup.py` file,
    the `search_key()` function generated a `KeyError` exception. Looking up what
    a `KeyError` exception is in the Python documentation would indicate that this
    is due to the key not existing in the dictionary. Most of the time, we will need
    to address the error at that specific error causing line. In our case, we employed
    the `get()` method of a dictionary to safely access key elements. Please revert
    the line back to its prior state at this time to prevent this error from occurring
    in the future!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的追踪信息有三个堆栈追踪。最底部的最后一条追踪就是我们的错误发生的位置。在这种情况下，是在`usb_lookup.py`文件的第66行，`search_key()`函数生成了一个`KeyError`异常。在Python文档中查找`KeyError`异常的定义会表明，这是由于字典中不存在该键。大多数情况下，我们需要在导致错误的特定行解决此问题。在我们的案例中，我们使用了字典的`get()`方法来安全地访问键元素。请将该行恢复到之前的状态，以防止此错误在未来再次发生！
- en: Challenge
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: We recommend experimenting with the code to learn how it works or try to improve
    its functionality. For example, how can we further validate the VID and PID input
    to ensure they are valid? Can we perform this same check on the returned UID values
    on lines 55 and 59?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议通过实验代码来学习它是如何工作的，或者尝试改进它的功能。例如，我们如何进一步验证VID和PID输入，以确保它们是有效的？我们是否可以对第55和第59行返回的UID值进行相同的检查？
- en: Another extension to our first script is to consider offline environments. How
    can we modify this code to allow someone to run in an air-gapped environment?
    What arguments can be used to change the behavior depending on the user's need
    for offline access?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个脚本的另一个扩展是考虑离线环境。我们如何修改这段代码，以允许某人在隔离环境中运行？可以使用什么参数来根据用户的离线访问需求改变行为？
- en: Programs are constantly evolving and are never truly finished products. There
    are plenty of other improvements that can be made here and we invite you to create
    and share the modifications to this and all of your other forensic Python scripts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是不断发展的，永远不会是完全完成的产品。这里还有很多可以改进的地方，我们邀请你创建并分享对此脚本以及你所有其他取证Python脚本的修改。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter continued from where we left off in previous chapter, and helped
    us build a solid Python foundation for later chapters. We covered advanced data
    types and object-oriented programming, developed our first scripts, and dived
    into traceback messages. At this point, you should start to become comfortable
    with Python, though repeat these two chapters and manually type out the code to
    help strengthen your comfort level as needed. We highly recommend to practice
    and experiment by either testing out ideas in the interactive prompt or modifying
    the scripts we developed. The code for this project can be downloaded from GitHub
    or Packt, as described in the *Preface*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接续了上一章的内容，帮助我们为后续章节打下坚实的Python基础。我们涵盖了高级数据类型和面向对象编程，开发了我们的第一个脚本，并深入探讨了追踪信息。到目前为止，你应该已经开始熟悉Python，尽管如此，还是建议你重复这两章并手动输入代码，帮助自己巩固对Python的掌握。我们强烈建议通过在交互式提示符中测试想法或修改我们编写的脚本来进行实践和实验。此项目的代码可以从GitHub或Packt下载，具体说明见*前言*部分。
- en: As we move away from theory and look into the core part of this book, we will
    start with simple scripts and work toward increasingly more complicated programs.
    This should allow a natural development of understanding programming and skills.
    In the next chapter, you will learn how to parse the `setupapi.dev.log` file on
    Windows systems to identify USB installation times.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步远离理论，进入本书的核心部分，我们将从简单的脚本开始，逐步发展成更为复杂的程序。这应该会自然地发展出编程和技能的理解。在下一章，你将学习如何解析Windows系统上的`setupapi.dev.log`文件，以识别USB安装时间。
