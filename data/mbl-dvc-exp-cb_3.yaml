- en: Chapter 3. Auditing Mobile Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：审计移动应用
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Auditing Android apps using static analysis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态分析审计Android应用
- en: Auditing Android apps using a dynamic analyzer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分析器审计Android应用
- en: Using Drozer to find vulnerabilities in Android applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Drozer在Android应用中发现漏洞
- en: Auditing iOS application using static analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态分析审计iOS应用
- en: Auditing iOS application using a dynamic analyzer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分析器审计iOS应用
- en: Examining iOS App Data storage and Keychain security vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查iOS应用数据存储和钥匙串安全漏洞
- en: Finding vulnerabilities in WAP-based mobile apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于WAP的移动应用中发现漏洞
- en: Finding client-side injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现客户端注入
- en: Insecure encryption in mobile apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用中的不安全加密
- en: Discovering data leakage sources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现数据泄露源
- en: Other application-based attacks in mobile devices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备中的其他基于应用的攻击
- en: Launching intent injection in Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android中发起意图注入
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Mobile applications such as web applications may have vulnerabilities. These
    vulnerabilities in most cases are the result of bad programming practices or insecure
    coding techniques, or may be because of purposefully injected bad code. For users
    and organizations, it is important to know how vulnerable their applications are.
    Should they fix the vulnerabilities or keep/stop using the applications?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用（如Web应用）可能存在漏洞。这些漏洞在大多数情况下是由于糟糕的编程实践或不安全的编码技术引起的，或者可能是由于故意注入的不良代码。对于用户和组织来说，了解他们的应用程序有多脆弱是非常重要的。他们应该修复漏洞，还是继续使用/停止使用这些应用程序？
- en: To address this dilemma, mobile applications need to be audited with the goal
    of uncovering vulnerabilities. Mobile applications (Android, iOS, or other platforms)
    can be analyzed using static or dynamic techniques. Static analysis is conducted
    by employing certain text or string based searches across decompiled source code.
    Dynamic analysis is conducted at runtime and vulnerabilities are uncovered in
    simulated fashion. Dynamic analysis is difficult as compared to static analysis.
    In this chapter, we will employ both static and dynamic analysis to audit Android
    and iOS applications. We will also learn various other techniques to audit findings,
    including Drozer framework usage, WAP-based application audits, and typical mobile-specific
    vulnerability discovery.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个困境，移动应用需要进行审计，目的是发现漏洞。可以使用静态或动态技术分析移动应用（安卓、iOS或其他平台）。静态分析是通过对反编译的源代码进行某些基于文本或字符串的搜索来进行的。动态分析则是在运行时进行，漏洞以模拟的方式被发现。与静态分析相比，动态分析更具挑战性。在本章中，我们将结合使用静态和动态分析来审计Android和iOS应用。我们还将学习审计发现的其他技术，包括Drozer框架使用、基于WAP的应用审计以及典型的移动特定漏洞发现。
- en: Auditing Android apps using static analysis
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态分析审计Android应用
- en: Static analysis is the most commonly and easily applied analysis method in source
    code audits. Static by definition means something that is constant. Static analysis
    is conducted on the static code, that is, raw or decompiled source code or on
    the compiled (object) code, but the analysis is conducted without the runtime.
    In most cases, static analysis becomes code analysis via static string searches.
    A very common scenario is to figure out vulnerable or insecure code patterns and
    find the same in the entire application code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是源代码审计中最常见且最易应用的分析方法。静态分析的定义意味着某物是常量。静态分析是在静态代码上进行的，即原始或反编译的源代码，或在已编译（目标）代码上进行的，但分析是在没有运行时的情况下进行的。在大多数情况下，静态分析通过静态字符串搜索来实现代码分析。一个非常常见的场景是找出脆弱或不安全的代码模式，并在整个应用代码中找到相同的模式。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For conducting static analysis of Android applications, we at least need one
    Android application and a static code scanner. Pick up any Android application
    of your choice and use any static analyzer tool of your choice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行Android应用的静态分析，我们至少需要一个Android应用和一个静态代码扫描器。选择任何你喜欢的Android应用，并使用你选择的任何静态分析工具。
- en: In this recipe, we use **Insecure Bank**, which is a vulnerable Android application
    for Android security enthusiasts. We will also use **ScriptDroid**, which is a
    static analysis script. Both Insecure Bank and ScriptDroid are coded by Android
    security researcher, Dinesh Shetty.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用**Insecure Bank**，这是一个面向Android安全爱好者的漏洞Android应用。我们还将使用**ScriptDroid**，这是一种静态分析脚本。Insecure
    Bank和ScriptDroid都是由Android安全研究员Dinesh Shetty编写的。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Download the latest version of the Insecure Bank application from GitHub. Decompress
    or unzip the `.apk` file and note the path of the unzipped application.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 下载最新版本的 Insecure Bank 应用程序。解压或解压`.apk`文件，并记下解压后的应用程序路径。
- en: 'Create a `ScriptDroid.bat` file by using the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个`ScriptDroid.bat`文件：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Go to the command prompt and navigate to the path where ScriptDroid is placed.
    Run the `.bat` file and it prompts you to input the path of the application for
    which you wish to perform static analysis. In our case we provide it with the
    path of the Insecure Bank application, precisely the path where Java files are
    stored. If everything worked correctly, the screen should look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令提示符并导航到 ScriptDroid 所在的路径。运行 `.bat` 文件，它会提示你输入要进行静态分析的应用程序路径。在我们的例子中，我们提供了
    Insecure Bank 应用的路径，准确地说是 Java 文件存储的路径。如果一切正常，屏幕应该显示如下内容：
- en: '![How it works...](graphics/image_03_001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/image_03_001.jpg)'
- en: The script generates a folder by the name `OUTPUT` in the path where the Java
    files of the application are present. The `OUTPUT` folder contains multiple text
    files, each one corresponding to a particular vulnerability. The individual text
    files pinpoint the location of vulnerable code pertaining to the vulnerability
    under discussion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会在应用程序的 Java 文件所在的路径生成一个名为`OUTPUT`的文件夹。`OUTPUT`文件夹包含多个文本文件，每个文件对应一个特定的漏洞。这些文本文件标明了与正在讨论的漏洞相关的易受攻击的代码位置。
- en: The combination of ScriptDroid and Insecure Bank gives a very nice view of various
    Android vulnerabilities; usually the same is not possible with live apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptDroid 与 Insecure Bank 的结合为我们提供了一个非常好的视角，展示了各种 Android 漏洞；通常，实时应用程序无法做到这一点。
- en: 'Consider the following points, for instance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下几点，例如：
- en: '`Weakencryption.txt` has listed down the instances of Base64 encoding used
    for passwords in the Insecure Bank application'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Weakencryption.txt`列出了 Insecure Bank 应用中用于密码的 Base64 编码实例。'
- en: '`Logging.txt` contains the list of insecure log functions used in the application'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logging.txt`包含应用程序中使用的不安全日志函数列表。'
- en: '`SdcardStorage.txt` contains the code snippet pertaining to the definitions
    related to data storage in SD Cards'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SdcardStorage.txt`包含与 SD 卡中数据存储相关定义的代码片段。'
- en: Details like these from static analysis are eye-openers in letting us know of
    the vulnerabilities in our application, without even running the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些来自静态分析的细节让我们了解到应用程序中的漏洞，甚至在未运行应用程序的情况下。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current recipe used just ScriptDroid, but there are many other options available.
    You can either choose to write your own script or you may use one of the free
    or commercial tools. A few commercial tools have pioneered the static analysis
    approach over the years via their dedicated focus.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的配方仅限于 ScriptDroid，但还有许多其他选项可供选择。你可以选择编写自己的脚本，或者使用一些免费的或商业的工具。一些商业工具多年来通过专注于静态分析方法，已经在这一领域开创了先河。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[https://github.com/dineshshetty/Android-InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dineshshetty/Android-InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)'
- en: '*Auditing iOS application using static analysis*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用静态分析审计 iOS 应用*'
- en: Auditing Android apps a using a dynamic analyzer
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分析审计 Android 应用
- en: '**Dynamic analysis** is another technique applied in source code audits. Dynamic
    analysis is conducted in runtime. The application is run or simulated and the
    flaws or vulnerabilities are discovered while the application is running. Dynamic
    analysis can be tricky, especially in the case of mobile platforms. As opposed
    to static analysis, there are certain requirements in dynamic analysis, such as
    the analyzer environment needs to be runtime or a simulation of the real runtime.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态分析**是另一种用于源代码审计的技术。动态分析是在运行时进行的。应用程序被运行或模拟，并且在应用程序运行时发现缺陷或漏洞。动态分析可能会很棘手，特别是在移动平台上。与静态分析不同，动态分析有一些特定的要求，比如分析环境需要是运行时环境或真实运行时的模拟。'
- en: Dynamic analysis can be employed to find vulnerabilities in Android applications
    which are difficult to find via static analysis. A static analysis may let you
    know a password is going to be stored, but dynamic analysis reads the memory and
    reveals the password stored in runtime. Dynamic analysis can be helpful in tampering
    data in transmission during runtime that is, tampering with the amount in a transaction
    request being sent to the payment gateway. Some Android applications employ obfuscation
    to prevent attackers reading the code; Dynamic analysis changes the whole game
    in such cases, by revealing the hardcoded data being sent out in requests, which
    is otherwise not readable in static analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析可以用来发现 Android 应用程序中的漏洞，这些漏洞通过静态分析是难以发现的。静态分析可能让你知道一个密码会被存储，但动态分析则读取内存并揭示运行时存储的密码。动态分析有助于在运行时篡改传输中的数据，例如篡改发送到支付网关的交易请求中的金额。一些
    Android 应用程序使用混淆技术来防止攻击者读取代码；在这种情况下，动态分析改变了整个游戏规则，它能够揭示在请求中发送的硬编码数据，而这些数据在静态分析中是无法读取的。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For conducting dynamic analysis of Android applications, we at least need one
    Android application and a dynamic code analyzer tool. Pick up any Android application
    of your choice and use any dynamic analyzer tool of your choice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行 Android 应用程序的动态分析，至少需要一个 Android 应用程序和一个动态代码分析工具。选择任何你喜欢的 Android 应用程序，并使用你喜欢的任何动态分析工具。
- en: 'The dynamic analyzer tools can be classified under two categories:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析工具可以分为两类：
- en: The tools which run from computers and connect to an Android device or emulator
    (to conduct dynamic analysis)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从计算机上运行并连接到 Android 设备或模拟器的工具（用于进行动态分析）
- en: The tools that can run on the Android device itself
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在 Android 设备本身运行的工具
- en: For this recipe, we choose a tool belonging to the latter category.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们选择了属于后一类的工具。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps for conducting dynamic analysis:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤进行动态分析：
- en: Have an Android device with applications (to be analyzed dynamically) installed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一台安装了应用程序（需要进行动态分析的）Android 设备。
- en: Go to the Play Store and download **Andrubis**. Andrubis is a tool from iSecLabs
    which runs on Android devices and conducts static, dynamic, and URL analysis on
    the installed applications. We will use it for dynamic analysis only in this recipe.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Play 商店并下载 **Andrubis**。Andrubis 是 iSecLabs 提供的一款工具，可在 Android 设备上运行，对已安装的应用程序进行静态、动态和
    URL 分析。在本教程中，我们仅使用它进行动态分析。
- en: Open the Andrubis application on your Android device. It displays the applications
    installed on the Android device and analyzes these applications.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Android 设备上打开 Andrubis 应用程序。它会显示已安装的应用程序并分析这些应用程序。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Open the analysis of the application of your interest. Andrubis computes an
    overall malice score (out of 10) for the applications and gives the color icon
    in front of its main screen to reflect the vulnerable application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你感兴趣的应用程序的分析。Andrubis 会计算应用程序的总体恶意评分（满分为 10 分），并在主屏幕前显示颜色图标，以反映易受攻击的应用程序。
- en: 'We selected an orange colored application to make more sense with this recipe.
    This is how the application summary and score is shown in Andrubis:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个橙色的应用程序，以便与本教程更好地契合。下面是 Andrubis 中展示的应用程序摘要和评分：
- en: '![How it works...](graphics/image_03_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](graphics/image_03_002.jpg)'
- en: 'Let us navigate to the **Dynamic Analysis** tab and check the results:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到 **动态分析** 标签并查看结果：
- en: '![How it works...](graphics/image_03_003.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](graphics/image_03_003.jpg)'
- en: The results are interesting for this application. Notice that all the files
    going to be written by the application under dynamic analysis are listed down.
    In our case, one `preferences.xml` is located.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的结果很有意思。注意，在动态分析过程中，应用程序将写入的所有文件都列出。我们在这里找到一个名为 `preferences.xml` 的文件。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Though the fact that the application is going to create a preferences file could
    have been found in static analysis as well, additionally, dynamic analysis confirmed
    that such a file is indeed created. It also confirms that the code snippet found
    in static analysis about the creation of a preferences file is not a dormant code
    but a file that is going to be created. Further, go ahead and read the created
    file and find any sensitive data present there. Who knows, luck may strike and
    give you a key to hidden treasure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序将创建一个偏好设置文件这一事实也可以通过静态分析发现，但动态分析进一步确认了确实会创建这样的文件。它还确认了静态分析中发现的有关创建偏好设置文件的代码片段不是一个死代码，而是一个将被创建的文件。接下来，继续读取已创建的文件，查找其中是否存在任何敏感数据。谁知道呢，或许运气会眷顾你，给你一个通向隐藏宝藏的钥匙。
- en: 'Notice that the first screen has a hyperlink, **View full report in browser**.
    Tap on it and notice that the detailed dynamic analysis is presented for your
    further analysis. This also lets you understand what the tool tried and what response
    it got. This is shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一屏幕有一个超链接，**在浏览器中查看完整报告**。点击它并注意，详细的动态分析结果会展示出来，供您进一步分析。这也让您理解工具尝试了什么操作以及获得了什么响应。如下截图所示：
- en: '![How it works...](graphics/image_03_004.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/image_03_004.jpg)'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current recipe used a dynamic analyzer belonging to the latter category.
    There are many other tools available in the former category. Since this is an
    Android platform, many of them are open source tools.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的方案使用了属于后者类别的动态分析工具。前者类别也有许多其他工具可用。由于这是一个Android平台，许多工具都是开源的。
- en: DroidBox can be tried for dynamic analysis. It looks for file operations (read/write),
    network data traffic, SMS, permissions, broadcast receivers, and so on, among
    other checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: DroidBox可以尝试进行动态分析。它检查文件操作（读/写）、网络数据流量、短信、权限、广播接收器等。
- en: Hooker is another tool that can intercept and modify API calls initiated from
    the application. This is very useful in dynamic analysis. Try hooking and tampering
    with data in API calls.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Hooker是另一款可以拦截和修改应用程序发起的API调用的工具。在动态分析中，这非常有用。尝试钩取和篡改API调用中的数据。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://play.google.com/store/apps/details?id=org.iseclab.andrubis](https://play.google.com/store/apps/details?id=org.iseclab.andrubis)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://play.google.com/store/apps/details?id=org.iseclab.andrubis](https://play.google.com/store/apps/details?id=org.iseclab.andrubis)'
- en: '[https://code.google.com/p/droidbox/](https://code.google.com/p/droidbox/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/droidbox/](https://code.google.com/p/droidbox/)'
- en: '[https://github.com/AndroidHooker/hooker](https://github.com/AndroidHooker/hooker)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/AndroidHooker/hooker](https://github.com/AndroidHooker/hooker)'
- en: Using Drozer to find vulnerabilities in Android applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Drozer查找Android应用程序中的漏洞
- en: Drozer is a mobile security audit and attack framework, maintained by MWR InfoSecurity.
    It is a must-have tool in the tester's armory. Drozer (Android installed application)
    interacts with other Android applications via **IPC** (**Inter Process Communication**).
    It allows fingerprinting of application package-related information, its attack
    surface, and attempts to exploit those. Drozer is an attack framework and advanced
    level exploits can be conducted from it. We use Drozer to find vulnerabilities
    in our applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer是一个由MWR InfoSecurity维护的移动安全审计和攻击框架，是测试人员工具库中必不可少的工具。Drozer（Android安装应用程序）通过**IPC**（**进程间通信**）与其他Android应用程序进行交互。它允许对应用程序包相关信息、攻击面进行指纹识别，并尝试进行利用。Drozer是一个攻击框架，可以从中执行高级漏洞攻击。我们使用Drozer来查找应用程序中的漏洞。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备
- en: Install Drozer by downloading it from [https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)
    and follow the installation instructions mentioned in the user guide.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从[https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)下载Drozer并按照用户指南中的安装说明进行安装。
- en: Install Drozer console agent and start a session as mentioned in the User Guide.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照用户指南中的说明，安装Drozer控制台代理并启动会话。
- en: If your installation is correct, you should get Drozer command prompt (`dz>`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的安装正确，您应该会看到Drozer命令提示符（`dz>`）。
- en: You should also have a few vulnerable applications as well to analyze. Here
    we chose OWASP GoatDroid application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该有一些易受攻击的应用程序供分析。在这里，我们选择了OWASP GoatDroid应用程序。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Every pentest starts with fingerprinting. Let us use Drozer for the same. The
    Drozer User Guide is very helpful for referring to the commands.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每次渗透测试都从指纹识别开始。让我们使用Drozer来完成这一任务。Drozer用户指南在参考命令时非常有帮助。
- en: 'The following command can be used to obtain information about an Android application
    package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于获取关于 Android 应用程序包的信息：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We used the same to extract the information from the GoatDroid application
    and found the following results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法从 GoatDroid 应用中提取信息，并得到了以下结果：
- en: '![How to do it...](graphics/image_03_005.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_005.jpg)'
- en: Notice that apart from the general information about the application, `User
    Permissions` are also listed by Drozer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了关于应用程序的一般信息，`User Permissions`（用户权限）也会被 Drozer 列出。
- en: Further, let us analyze the attack surface. Drozer's attack surface lists the
    exposed activities, broadcast receivers, content providers, and services. The
    in-genuinely exposed ones may be a critical security risk and may provide you
    access to privileged content.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分析攻击面。Drozer 的攻击面列出了暴露的活动、广播接收器、内容提供者和服务。那些不应暴露的内容可能是严重的安全风险，并可能让你访问特权内容。
- en: 'Drozer has the following command to analyze the attack surface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 具有以下命令来分析攻击面：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We used the same to obtain the attack surface of the Herd Financial application
    of GoatDroid and the results can be seen in the following screenshot. Notice that
    one Activity and one Content Provider are exposed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法获取了 GoatDroid 的 Herd Financial 应用的攻击面，结果可以在以下截图中看到。请注意，一个活动和一个内容提供者被暴露。
- en: 'We chose to attack the content provider to obtain the data stored locally.
    We used the following Drozer command to analyze the content provider of the same
    application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择攻击内容提供者以获取本地存储的数据。我们使用以下 Drozer 命令分析相同应用的内容提供者：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This gave us the details of the exposed content provider, which we used in
    another Drozer command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们获得了暴露的内容提供者的详细信息，我们在另一个 Drozer 命令中使用了这些信息：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could successfully query the content providers. Lastly, we would be interested
    in stealing the data stored by this content provider. This is possible via another
    Drozer command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功查询了内容提供者。最后，我们有兴趣窃取这个内容提供者存储的数据。这可以通过另一个 Drozer 命令实现：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The entire sequence of events is shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了整个事件的过程：
- en: '![How to do it...](graphics/image_03_006.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_006.jpg)'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: ADB is used to establish a connection between Drozer Python server (present
    on computer) and Drozer agent (`.apk` file installed in emulator or Android device).
    Drozer console is initialized to run the various commands we saw.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ADB 用于在 Drozer Python 服务器（位于计算机上）和 Drozer 代理（`.apk` 文件安装在模拟器或 Android 设备上）之间建立连接。Drozer
    控制台初始化后，可以运行我们看到的各种命令。
- en: Drozer agent utilizes the Android OS feature of IPC to take over the role of
    the target application and run the various commands as the original application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 代理利用 Android 操作系统的 IPC 特性，接管目标应用的角色，并作为原始应用运行各种命令。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Drozer not only allows users to obtain the attack surface and steal data via
    content providers or launch intent injection attacks, but it is way beyond that.
    It can be used to fuzz the application, cause local injection attacks by providing
    a way to inject payloads.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 不仅允许用户通过内容提供者获取攻击面并窃取数据，或发起意图注入攻击，它的功能远不止这些。它还可以用于对应用程序进行模糊测试，通过提供注入有效负载的方法来引发本地注入攻击。
- en: Drozer can also be used to run various in-built exploits and can be utilized
    to attack Android applications via custom-developed exploits. Further, it can
    also run in Infrastructure mode, allowing remote connections and remote attacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 还可以用来运行各种内置的漏洞攻击，并且可以通过自定义开发的漏洞攻击 Android 应用程序。此外，它还可以在基础设施模式下运行，允许远程连接和远程攻击。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Launching intent injection in Android*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Android 中发起意图注入*'
- en: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
- en: Auditing iOS application using static analysis
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态分析审核 iOS 应用程序
- en: Static analysis in source code reviews is an easier technique, and employing
    static string searches makes it convenient to use. Static analysis is conducted
    on the raw or decompiled source code or on the compiled (object) code, but the
    analysis is conducted outside of runtime. Usually, static analysis figures out
    vulnerable or insecure code patterns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码审查中的静态分析是一种更简单的技术，使用静态字符串搜索使其更加方便。静态分析是在原始或反编译的源代码或已编译（目标）代码上进行的，但分析是在运行时之外进行的。通常，静态分析可以识别出易受攻击或不安全的代码模式。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For conducting static analysis of iOS applications, we need at least one iOS
    application and a static code scanner. Pick up any iOS application of your choice
    and use any static analyzer tool of your choice.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行 iOS 应用程序的静态分析，我们需要至少一个 iOS 应用程序和一个静态代码扫描工具。选择任何你喜欢的 iOS 应用程序，并使用任何你喜欢的静态分析工具。
- en: We will use `iOS-ScriptDroid`, which is a static analysis script, developed
    by Android security researcher, Dinesh Shetty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`iOS-ScriptDroid`，这是一种静态分析脚本，由 Android 安全研究员 Dinesh Shetty 开发。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行...
- en: Keep the decompressed iOS application filed and note the path of the folder
    containing the `.m` files.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留解压后的 iOS 应用程序文件，并记录包含`.m`文件的文件夹路径。
- en: 'Create an `iOS-ScriptDroid.bat` file by using the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建`iOS-ScriptDroid.bat`文件：
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Go to the command prompt and navigate to the path where `iOS-ScriptDroid` is
    placed. Run the batch file and it prompts you to input the path of the application
    for which you wish to perform static analysis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令提示符并导航到放置`iOS-ScriptDroid`的路径。运行批处理文件时，它会提示你输入要进行静态分析的应用程序路径。
- en: In our case, we arbitrarily chose an application and inputted the path of the
    implementation (`.m`) files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们随意选择了一个应用程序，并输入了实现（`.m`）文件的路径。
- en: The script generates a folder by the name `OUTPUT` in the path where the `.m`
    files of the application are present. The `OUTPUT` folder contains multiple text
    files, each one corresponding to a particular vulnerability. The individual text
    files pinpoint the location of vulnerable code pertaining to the vulnerability
    under discussion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本会在应用程序的`.m`文件所在的路径下生成一个名为`OUTPUT`的文件夹。`OUTPUT`文件夹包含多个文本文件，每个文件对应一个特定的漏洞。这些单独的文本文件指出了与讨论中的漏洞相关的易受攻击代码的位置。
- en: The `iOS-ScriptDroid` gives first hand info of various iOS applications vulnerabilities
    present in the current applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`iOS-ScriptDroid`提供了当前应用程序中存在的各种 iOS 应用程序漏洞的第一手信息。'
- en: For instance, here are a few of them which are specific to the iOS platform.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一些特定于 iOS 平台的工具。
- en: '`BufferOverflow.txt` contains the usage of harmful functions when missing buffer
    limits such as `strcat`, `strcpy`, and so on are found in the application.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferOverflow.txt`包含了当应用程序中发现缺失缓冲区限制（如`strcat`、`strcpy`等）时，使用有害函数的情况。'
- en: URL Schemes, if implemented in an insecure manner, may result in access related
    vulnerabilities. Usage of URL schemes is listed in `URLSchemes.txt`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 URL Schemes 实现不安全，可能会导致与访问相关的漏洞。URL schemes 的使用列在`URLSchemes.txt`中。
- en: These are sefuuseful vulnerability details to know in iOS applications via static
    analysis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通过静态分析了解 iOS 应用程序漏洞的有用详细信息。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current recipe used just `iOS-ScriptDroid` but there are many other options
    available. You can either choose to write your own script or you may use one of
    the free or commercial tools available. A few commercial tools have pioneered
    the static analysis approach over the years via their dedicated focus.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的方案仅使用了`iOS-ScriptDroid`，但还有许多其他选项可供选择。你可以选择编写自己的脚本，也可以使用现有的免费或商业工具。几种商业工具多年来通过专注于静态分析方法而取得了先驱地位。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Auditing Android apps using static analysis*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用静态分析审计 Android 应用程序*'
- en: Auditing iOS application using a dynamic analyzer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分析器审计 iOS 应用程序
- en: Dynamic analysis is the runtime analysis of the application. The application
    is run or simulated to discover the flaws during runtime. Dynamic analysis can
    be tricky, especially in the case of mobile platforms.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析是应用程序的运行时分析。应用程序在运行或模拟过程中被执行，以发现运行时的缺陷。动态分析可能会很棘手，尤其是在移动平台上。
- en: Dynamic analysis is helpful in tampering data in transmission during runtime,
    for example, tampering with the amount in a transaction request being sent to
    a payment gateway. In applications that use custom encryption to prevent attackers
    reading the data, dynamic analysis is useful in revealing the encrypted data,
    which can be reverse-engineered.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析对于在运行时篡改传输中的数据非常有用，例如，篡改向支付网关发送的交易请求中的金额。在使用自定义加密以防止攻击者读取数据的应用程序中，动态分析有助于揭示被加密的数据，这些数据可以被逆向工程。
- en: Note that since iOS applications cannot be decompiled to the full extent, dynamic
    analysis becomes even more important in finding the sensitive data which could
    have been hardcoded.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于iOS应用无法完全反编译，因此动态分析在发现可能被硬编码的敏感数据时显得尤为重要。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For conducting dynamic analysis of iOS applications, we need at least one iOS
    application and a dynamic code analyzer tool. Pick up any iOS application of your
    choice and use any dynamic analyzer tool of your choice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对iOS应用进行动态分析时，我们需要至少一个iOS应用和一个动态代码分析工具。选择任意iOS应用，并使用任何你喜欢的动态分析工具。
- en: In this recipe, let us use the open source tool **Snoop-it**. We will use an
    iOS app that locks files which can only be opened using PIN, pattern, and a secret
    question and answer to unlock and view the file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将使用开源工具**Snoop-it**。我们将使用一个iOS应用，该应用通过PIN码、图案和秘密问题与答案来锁定文件，只有解锁后才能查看文件。
- en: Let us see if we can analyze this app and find a security flaw in it using Snoop-it.
    Please note that Snoop-it only works on jailbroken devices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否分析这个应用并使用Snoop-it找到其中的安全漏洞。请注意，Snoop-it只适用于越狱设备。
- en: To install Snoop-it on your iDevice, visit [https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6](https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6)
    .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的iDevice上安装Snoop-it，请访问[https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6](https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6)。
- en: We have downloaded **Locker Lite** from the App Store onto our device, for analysis.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从App Store下载了**Locker Lite**并安装到我们的设备上进行分析。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to conduct dynamic analysis on iOS applications:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来对iOS应用进行动态分析：
- en: Open the Snoop-it app by tapping on its icon.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Snoop-it应用图标打开它。
- en: Navigate to **Settings**. Here you will see the URL through which the interface
    can be accessed from your machine:![How to do it...](graphics/image_03_007.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**设置**。在这里你将看到可以从你的设备访问界面的URL：![如何操作...](graphics/image_03_007.jpg)
- en: Please note the URL, for we will be using it soon. We have disabled authentication
    for our ease.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意这个URL，因为我们稍后会使用它。为了方便，我们已禁用认证。
- en: Now, on the iDevice, tap on **Applications** | **Select App Store Apps** and
    select the **Locker** app:![How to do it...](graphics/image_03_008.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在iDevice上，点击**应用程序** | **选择App Store应用**，然后选择**Locker**应用：![如何操作...](graphics/image_03_008.jpg)
- en: Press the home button, and open the Locker app. Note that on entering the wrong
    PIN, we do not get further access:![How to do it...](graphics/image_03_009.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下主屏按钮，打开Locker应用。注意，如果输入错误的PIN码，我们将无法继续访问：![如何操作...](graphics/image_03_009.jpg)
- en: Making sure the workstation and iDevice are on the same network, open the previously
    noted URL in any browser. This is how the interface will look:![How to do it...](graphics/image_03_010.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保工作站和iDevice处于同一网络，打开先前记下的URL，并在任何浏览器中查看。界面将呈现如下：![如何操作...](graphics/image_03_010.jpg)
- en: Click on the **Objective-C Classes** link under **Analysis** in the left-hand
    panel:![How to do it...](graphics/image_03_011.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧面板中的**分析**下的**Objective-C 类**链接：![如何操作...](graphics/image_03_011.jpg)
- en: Now, click on `SM_LoginManagerController`. Class information gets loaded in
    the panel to the right of it.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`SM_LoginManagerController`。类信息会加载到右侧面板中。
- en: Navigate down until you see `-(void) unlockWasSuccessful` and click on the radio
    button preceding it:![How to do it...](graphics/image_03_012.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下导航，直到看到`-(void) unlockWasSuccessful`，然后点击前面的单选按钮：![如何操作...](graphics/image_03_012.jpg)
- en: This method has now been selected.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法现在已被选中。
- en: Next, click on the **Setup and invoke** button on the top-right of the panel.
    In the window that appears, click on the **Invoke Method** button at the bottom:![How
    to do it...](graphics/image_03_013.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击面板右上角的**设置并调用**按钮。在出现的窗口中，点击底部的**调用方法**按钮：![如何操作...](graphics/image_03_013.jpg)
- en: As soon as we click on the button, we notice that the authentication has been
    bypassed, and we can view our locked file successfully.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们点击按钮时，我们注意到认证已经被绕过，且我们成功查看了锁定的文件。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Snoop-it loads all classes that are in the app, and indicates the ones that
    are currently operational with a green color. Since we want to bypass the current
    login screen, and load directly into the main page, we look for `UIViewController`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Snoop-it 加载应用中的所有类，并用绿色标示当前正在运行的类。由于我们希望绕过当前的登录界面，直接加载主页面，我们需要寻找 `UIViewController`。
- en: Inside `UIViewController`, we see `SM_LoginManagerController`, which could contain
    methods relevant to authentication. On observing the class, we see various methods
    such as `numberLoginSucceed`, `patternLoginSucceed`, and many others.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UIViewController` 中，我们看到 `SM_LoginManagerController`，它可能包含与身份验证相关的方法。观察该类时，我们看到许多方法，例如
    `numberLoginSucceed`、`patternLoginSucceed` 等。
- en: The app calls the `unlockWasSuccessful` method when a PIN code is entered successfully.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入 PIN 码成功时，应用会调用 `unlockWasSuccessful` 方法。
- en: So, when we invoke this method from our machine and the function is called directly,
    the app loads the main page successfully.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们从我们的机器调用此方法并直接调用该功能时，应用成功加载了主页面。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The current recipe used just one dynamic analyzer but other options and tools
    can also be employed. There are many challenges in doing dynamic analysis of iOS
    applications. You may like to use multiple tools and not just rely on one to overcome
    the challenges.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的教程仅使用了一个动态分析器，但也可以使用其他选项和工具。进行 iOS 应用的动态分析面临许多挑战。你可能希望使用多个工具，而不仅仅依赖于一个工具，以克服这些挑战。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://code.google.com/p/snoop-it/](https://code.google.com/p/snoop-it/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/snoop-it/](https://code.google.com/p/snoop-it/)'
- en: '*Auditing Android apps using a dynamic analyzer*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用动态分析器审计 Android 应用*'
- en: Examining iOS App Data storage and Keychain security vulnerabilities
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 iOS 应用数据存储和钥匙串安全漏洞
- en: Keychain in iOS is an encrypted SQLite database that uses a 128-bit AES algorithm
    to hold identities and passwords.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 中的钥匙串是一个加密的 SQLite 数据库，使用 128 位 AES 算法存储身份信息和密码。
- en: On any iOS device, the Keychain SQLite database is used to store user credentials
    such as usernames, passwords, encryption keys, certificates, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 iOS 设备上，钥匙串 SQLite 数据库用于存储用户凭据，例如用户名、密码、加密密钥、证书等。
- en: Developers use this service API to instruct the operating system to store sensitive
    data securely, rather than using a less secure alternative storage mechanism such
    as a property list file or a configuration file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用此服务 API 来指示操作系统安全地存储敏感数据，而不是使用不太安全的存储机制，如属性列表文件或配置文件。
- en: In this recipe we will be analyzing Keychain dump to discover stored credentials.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将分析钥匙串转储以发现存储的凭据。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Please follow the given steps to prepare for Keychain dump analysis:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤准备钥匙串转储分析：
- en: Jailbreak the iPhone or iPad.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 越狱 iPhone 或 iPad。
- en: Ensure the SSH server is running on the device (default after jailbreak).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保设备上 SSH 服务器正在运行（越狱后默认启用）。
- en: Download the `Keychain_dumper` binary from [https://github.com/ptoomey3/Keychain-Dumper](https://github.com/ptoomey3/Keychain-Dumper)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/ptoomey3/Keychain-Dumper](https://github.com/ptoomey3/Keychain-Dumper)
    下载 `Keychain_dumper` 二进制文件
- en: Connect the iPhone and the computer to the same Wi-Fi network.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 iPhone 和计算机连接到同一 Wi-Fi 网络。
- en: On the computer, run SSH into the iPhone by typing the iPhone IP address, username
    as `root`, and password as `alpine`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机上，使用 SSH 登录到 iPhone，输入 iPhone 的 IP 地址，用户名为 `root`，密码为 `alpine`。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Follow these steps to examine security vulnerabilities in iOS:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤检查 iOS 的安全漏洞：
- en: 'Copy `keychain_dumper` into the iPhone or iPad by issuing the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `keychain_dumper` 复制到 iPhone 或 iPad：
- en: '[PRE7]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, Windows WinSCP can be used to do the same:![How to do it...](graphics/image_03_014.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，可以使用 Windows 的 WinSCP 来实现相同功能：![如何实现…](graphics/image_03_014.jpg)
- en: 'Once the binary has been copied, ensure the `keychain-2.db` has read access:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦二进制文件复制完成，确保 `keychain-2.db` 拥有读取权限：
- en: '[PRE8]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下图所示：
- en: '![How to do it...](graphics/image_03_015.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](graphics/image_03_015.jpg)'
- en: 'Give executable right to binary:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给二进制文件赋予可执行权限：
- en: '[PRE9]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we simply run `keychain_dumper`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需运行 `keychain_dumper`：
- en: '[PRE10]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](graphics/image_03_016.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现…](graphics/image_03_016.jpg)'
- en: 'This command will dump all keychain information, which will contain all the
    generic and Internet passwords stored in the keychain:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将转储所有钥匙串信息，其中包含存储在钥匙串中的所有通用和互联网密码：
- en: '![How to do it...](graphics/image_03_017.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_017.jpg)'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Keychain in an iOS device is used to securely store sensitive information such
    as credentials, such as usernames, passwords, authentication tokens for different
    applications, and so on, along with connectivity (Wi-Fi/VPN) credentials and so
    on. It is located on iOS devices as an encrypted SQLite database file located
    at `/private/var/Keychains/keychain-2.db`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 设备中的钥匙串用于安全存储敏感信息，如用户名、密码、不同应用程序的认证令牌等，以及连接凭证（Wi-Fi/VPN）等。它位于 iOS 设备上，作为一个加密的
    SQLite 数据库文件，路径为`/private/var/Keychains/keychain-2.db`。
- en: Insecurity arises when application developers use this feature of the operating
    system to store credentials rather than storing it themselves in `NSUserDefaults`,
    `.plist` files, and so on. To provide users the ease of not having to log in every
    time and hence saving the credentials in the device itself, the keychain information
    for every app is stored outside of its sandbox.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 安全隐患出现在应用开发者使用操作系统的此功能来存储凭证，而不是将凭证存储在`NSUserDefaults`、`.plist` 文件等地方。为了让用户不必每次都登录，从而将凭证保存在设备本身，所有应用的钥匙串信息会存储在其沙箱之外。
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This analysis can also be performed for specific apps dynamically, using tools
    such as Snoop-it. Follow the steps to hook Snoop-it to the target app, click on
    `Keychain Values`, and analyze the attributes to see its values reveal in the
    Keychain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此分析还可以使用 Snoop-it 等工具动态地针对特定应用进行。按照步骤将 Snoop-it 挂钩到目标应用，点击`Keychain Values`，并分析属性，以查看其值在钥匙串中的显示。
- en: More will be discussed in further recipes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内容将在后续的配方中讨论。
- en: Finding vulnerabilities in WAP-based mobile apps
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找基于 WAP 的移动应用中的漏洞
- en: WAP-based mobile applications are mobile applications or websites that run on
    mobile browsers. Most organizations create a lightweight version of their complex
    websites to be able to run easily and appropriately in mobile browsers. For example,
    a hypothetical company called `ABCXYZ` may have their main website at `www.abcxyz.com`,
    while their mobile website takes the form `m.abcxyz.com`. Note that the mobile
    website (or WAP apps) are separate from their installable application form, such
    as `.apk` on Android.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 WAP 的移动应用是运行在移动浏览器上的移动应用或网站。大多数组织会创建其复杂网站的轻量版，以便能够在移动浏览器中轻松且适当运行。例如，一个名为`ABCXYZ`的假想公司可能将其主网站设为`www.abcxyz.com`，而其移动网站则为`m.abcxyz.com`。需要注意的是，移动网站（或
    WAP 应用）与可安装的应用程序版本是分开的，例如 Android 上的`.apk`。
- en: Since mobile websites run on browsers, it is very logical to say that most of
    the vulnerabilities applicable to web applications are applicable to WAP apps
    as well. However, there are caveats to this. Exploitability and risk ratings may
    not be the same. Moreover, not all attacks may be directly applied or conducted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于移动网站运行在浏览器中，因此可以很合理地说，适用于 Web 应用的大多数漏洞同样适用于 WAP 应用。然而，这其中也有一些警告。漏洞的可利用性和风险评级可能不同。此外，并非所有的攻击都可以直接应用或执行。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, make sure to be ready with the following set of tools (in
    the case of Android):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本配方，请确保准备好以下工具集（以 Android 为例）：
- en: ADB
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADB
- en: WinSCP
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinSCP
- en: Putty
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Putty
- en: Rooted Android mobile
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已 root 的 Android 移动设备
- en: SSH proxy application installed on Android phone
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 手机上安装的 SSH 代理应用
- en: 'Let us see the common WAP application vulnerabilities. While discussing these,
    we will limit ourselves to mobile browsers only:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下常见的 WAP 应用漏洞。在讨论这些漏洞时，我们将只限于移动浏览器：
- en: '**Browser cache**: Android browsers store cache in two different parts—content
    cache and component cache. Content cache may contain basic frontend components
    such as HTML, CSS, or JavaScript. Component cache contains sensitive data like
    the details to be populated once content cache is loaded. You have to locate the
    browser cache folder and find sensitive data in it.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器缓存**：Android 浏览器将缓存存储在两个不同的部分——内容缓存和组件缓存。内容缓存可能包含基本的前端组件，如 HTML、CSS 或
    JavaScript。组件缓存包含敏感数据，例如在加载内容缓存后将填充的详细信息。你需要找到浏览器缓存文件夹并在其中查找敏感数据。'
- en: '**Browser memory**: Browser memory refers to the location used by browsers
    to store the data. Memory is usually long-term storage, while cache is short-term.
    Browse through the browser memory space for various files such as `.db`, `.xml`,
    `.txt`, and so on. Check all these files for the presence of sensitive data.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器内存**：浏览器内存是指浏览器用于存储数据的位置。内存通常是长期存储，而缓存是短期存储。浏览浏览器内存空间，查找各种文件，如 `.db`、`.xml`、`.txt`
    等。检查这些文件中是否存在敏感数据。'
- en: '**Browser history**: Browser history contains the list of the URLs browsed
    by the user. These URLs in GET request format contain parameters. Again, our goal
    is to locate a URL with sensitive data for our WAP application.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器历史记录**：浏览器历史记录包含用户浏览过的 URL 列表。这些 URL 以 GET 请求格式包含参数。同样，我们的目标是定位包含敏感数据的
    URL，供我们用于 WAP 应用程序。'
- en: '**Cookies**: Cookies are mechanisms for websites to keep track of user sessions.
    Cookies are stored locally in devices. Following are the security concerns with
    respect to cookie usage:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookies**：Cookies 是网站跟踪用户会话的一种机制。Cookies 存储在设备本地。以下是与 Cookie 使用相关的安全问题：'
- en: Sometimes a cookie contains sensitive information
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，Cookie 会包含敏感信息。
- en: Cookie attributes, if weak, may make the application security weak
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Cookie 属性较弱，可能会使应用程序的安全性变得脆弱。
- en: Cookie stealing may lead to a session hijack
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie 被窃取可能会导致会话劫持。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '**Browser Cache**:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器缓存**：'
- en: 'Let''s look at the steps that need to be followed with browser cache:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看浏览器缓存需要遵循的步骤：
- en: 'Android browser cache can be found at this location: `/data/data/com.android.browser/cache/webviewcache/`.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安卓浏览器缓存可以在以下位置找到：`/data/data/com.android.browser/cache/webviewcache/`。
- en: You can use either ADB to pull the data from `webviewcache`, or use `WinSCP/Putty`
    and connect to SSH application in rooted Android phones.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 ADB 从 `webviewcache` 中提取数据，或者使用 `WinSCP/Putty` 连接到已root的安卓手机上的 SSH 应用程序。
- en: Either way, you will land up at the `webviewcache` folder and find arbitrarily
    named files. Refer to the highlighted section in the following screenshot:![How
    to do it...](graphics/image_03_018.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论哪种方式，你最终都会进入 `webviewcache` 文件夹，并找到任意命名的文件。请参见以下截图中的高亮部分：![如何操作...](graphics/image_03_018.jpg)
- en: Rename the extension of arbitrarily named files to `.jpg` and you will be able
    to view the cache in screenshot format. Search through all files for sensitive
    data pertaining to the WAP app you are searching for.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任意命名的文件扩展名重命名为 `.jpg`，你将能够以截图格式查看缓存。在所有文件中搜索与 WAP 应用程序相关的敏感数据。
- en: '**Browser Memory**:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器内存**：'
- en: 'Like an Android application, browser also has a memory space under the `/data/data`
    folder by the name `com.android.browser` (default browser). Here is how a typical
    browser memory space looks:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Android 应用程序一样，浏览器也在 `/data/data` 文件夹下有一个名为 `com.android.browser`（默认浏览器）的内存空间。下面是典型浏览器内存空间的样子：
- en: '![How to do it...](graphics/image_03_019.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_019.jpg)'
- en: Make sure you traverse through all the folders to get the useful sensitive data
    in the context of the WAP application you are looking for.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保遍历所有文件夹，以获取你正在寻找的 WAP 应用程序的有用敏感数据。
- en: '**Browser history**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器历史记录**'
- en: Go to browser, locate options, navigate to **History**, and find the URLs present
    there.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 进入浏览器，定位到选项，导航到 **历史记录**，查找其中的 URL。
- en: '**Cookies**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cookies**'
- en: The files containing cookie values can be found at `/data/data/com.android.browser/databases/webview.db`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Cookie 值的文件可以在 `/data/data/com.android.browser/databases/webview.db` 路径下找到。
- en: These DB files can be opened with the SQLite Browser tool and cookies can be
    obtained.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库文件可以通过 SQLite 浏览器工具打开，并提取出 Cookie。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Apart from the primary vulnerabilities described here mainly concerned with
    browser usage, all other web application vulnerabilities which are related to
    or exploited from or within a browser are applicable and need to be tested:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里主要与浏览器使用相关的主要漏洞外，所有其他与浏览器相关或通过浏览器被利用的 web 应用漏洞都适用，并且需要进行测试：
- en: Cross-site scripting, a result of a browser executing unsanitized harmful scripts
    reflected by the servers is very valid for WAP applications.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本攻击是由于浏览器执行未经清理的有害脚本，服务器返回这些脚本的结果，对于 WAP 应用程序来说是非常有效的。
- en: The autocomplete attribute not turned to off may result in sensitive data remembered
    by the browser for returning users. This again is a source of data leakage.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果自动完成功能未关闭，可能导致浏览器为返回用户记住敏感数据。这也是数据泄漏的一个来源。
- en: Browser thumbnails and image buffer are other sources to look for data.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器缩略图和图像缓冲区是查找数据的其他来源。
- en: Above all, all the vulnerabilities in web applications, which may not relate
    to browser usage, apply. These include **OWASP Top 10** vulnerabilities such as
    SQL injection attacks, broken authentication and session management, and so on.
    Business logic validation is another important check to bypass. All these are
    possible by setting a proxy to the browser and playing around with the mobile
    traffic (we provide a different recipe for the same in a later chapter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，所有与浏览器使用无关的 Web 应用漏洞都适用。这些包括**OWASP Top 10** 漏洞，如 SQL 注入攻击、身份验证和会话管理漏洞等。业务逻辑验证是另一个需要绕过的重要检查。通过为浏览器设置代理并操作移动流量，这些漏洞都是可能的（我们将在后面的章节中提供一个相关的食谱）。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The discussion of this recipe has been around Android, but all the discussion
    is fully applicable to an iOS platform when testing WAP applications. Approach,
    steps to test, and the locations would vary, but all vulnerabilities still apply.
    You may want to try out iExplorer and plist editor tools when working with an
    iPhone or iPad.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本文讨论的内容主要围绕 Android，但所有讨论完全适用于在测试 WAP 应用时的 iOS 平台。方法、测试步骤和位置会有所不同，但所有漏洞仍然适用。在使用
    iPhone 或 iPad 时，你可能需要尝试 iExplorer 和 plist 编辑工具。
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/](http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/](http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/)'
- en: Finding client-side injection
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找客户端注入
- en: Client-side injection is a new dimension to the mobile threat landscape. Client
    side injection (also known as local injection) is a result of the injection of
    malicious payloads to local storage to reveal data not by the usual workflow of
    the mobile application. If `'or'1'='1` is injected in a mobile application on
    search parameter, where the search functionality is built to search in the local
    SQLite DB file, this results in revealing all data stored in the corresponding
    table of SQLite DB; client side SQL injection is successful.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端注入是移动威胁领域中的一个新维度。客户端注入（也称为本地注入）是通过将恶意有效载荷注入本地存储，从而揭示不通过移动应用程序的常规工作流程的数据。如果在移动应用的搜索参数中注入
    `'or'1'='1`，而该搜索功能是为在本地 SQLite 数据库文件中进行搜索而构建的，这将导致揭示存储在相应 SQLite 数据库表中的所有数据；此时客户端
    SQL 注入成功。
- en: Notice that the payload did not to go the database on the server side (which
    possibly can be Oracle or MSSQL) but it did go to the local database (SQLite)
    in the mobile. Since the injection point and injectable target are local (that
    is, mobile), the attack is called a **client side injection**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，恶意有效载荷并未传递到服务器端的数据库（可能是 Oracle 或 MSSQL），而是传递到移动设备的本地数据库（SQLite）。由于注入点和可注入目标是本地的（即移动设备），因此该攻击被称为**客户端注入**。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get ready to find client side injection, have a few mobile applications ready
    to be audited and have a bunch of tools used in many other recipes throughout
    this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备查找客户端注入，准备好一些需要审核的移动应用，并准备好本书中许多其他食谱中使用的工具。
- en: Note that client side injection is not easy to find on account of the complexities
    involved; many a time you will have to fine-tune your approach as per the successful
    first signs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于涉及的复杂性，客户端注入并不容易发现；许多时候，你需要根据首次成功的迹象来微调你的方法。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The prerequisite to the existence of client side injection vulnerability in
    mobile apps is the presence of a local storage and an application feature which
    queries the local storage. For the convenience of the first discussion, let us
    learn client side SQL injection, which is fairly easy to learn as users know very
    well SQL Injection in web apps.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用中存在客户端注入漏洞的前提条件是存在本地存储和一个查询本地存储的应用功能。为了方便首次讨论，我们先学习客户端 SQL 注入，这相对容易学习，因为用户对
    Web 应用中的 SQL 注入已经非常熟悉。
- en: Let us take the case of a mobile banking application which stores the branch
    details in a local SQLite database. The application provides a search feature
    to users wishing to search a branch. Now, if a person types in the city as Mumbai,
    the `city` parameter is populated with the value `Mumbai` and the same is dynamically
    added to the SQLite query. The query builds and retrieves the branch list for
    Mumbai city. (Usually, purely local features are provided for faster user experience
    and network bandwidth conservation.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个存储分支详情的本地 SQLite 数据库为例。该应用程序为希望搜索分支的用户提供了一个搜索功能。现在，如果某人将城市名称输入为孟买，`city`
    参数将填充为 `Mumbai`，并且该值动态地添加到 SQLite 查询中。查询构建并检索孟买城市的分支列表。（通常，为了更快的用户体验和节省网络带宽，应用会提供纯粹的本地功能。）
- en: Now if a user is able to inject harmful payloads into the city parameter, such
    as a wildcard character or a SQLite payload to the drop table, and the payloads
    execute revealing all the details (in the case of a wildcard) or the payload drops
    the table from the DB (in the case of a drop table payload) then you have successfully
    exploited client side SQL injection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户能够将有害有效负载注入到城市参数中，比如通配符字符或 SQLite 有效负载（如 drop table），并且这些有效负载执行后揭示了所有细节（在使用通配符的情况下），或者有效负载使表从数据库中删除（在使用
    drop table 有效负载的情况下），那么你就成功利用了客户端 SQL 注入漏洞。
- en: 'Another type of client side injection, presented in OWASP Mobile TOP 10 release,
    is local **cross-site scripting** (**XSS**). Refer to slide number 22 of the original
    OWASP PowerPoint presentation here: [http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)
    . They referred to it as Garden Variety XSS and presented a code snippet, wherein
    SMS text was accepted locally and printed at UI. If a script was inputted in SMS
    text, it would result in local XSS (JavaScript Injection).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种客户端注入类型，在 OWASP Mobile TOP 10 发布中提到的是本地**跨站脚本攻击**（**XSS**）。请参考原始 OWASP PowerPoint
    演示文稿的第 22 幻灯片，链接为：[http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)。他们称之为普通的
    XSS，并展示了一个代码片段，其中 SMS 文本在本地被接受并显示在 UI 上。如果在 SMS 文本中输入脚本，便会导致本地 XSS（JavaScript
    注入）。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: In a similar fashion, HTML Injection is also possible. If an HTML file contained
    in the application local storage can be compromised to contain malicious code
    and the application has a feature which loads or executes this HTML file, HTML
    injection is possible locally.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，HTML 注入也是可能的。如果应用程序本地存储的 HTML 文件可以被篡改为包含恶意代码，并且该应用程序有加载或执行该 HTML 文件的功能，那么本地就可能发生
    HTML 注入。
- en: A variant of the same may result in **Local File Inclusion** (**LFI**) attacks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的变体可能会导致**本地文件包含**（**LFI**）攻击。
- en: If data is stored in the form of XML files in the mobile, local XML Injection
    can also be attempted.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据以 XML 文件的形式存储在移动设备中，也可以尝试进行本地 XML 注入。
- en: There could be more variants of these attacks possible. Finding client-side
    injection is quite difficult and time consuming. It may need to employ both static
    and dynamic analysis approaches. Most scanners also do not support discovery of
    Client Side Injection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会有更多变体的攻击。发现客户端注入非常困难且耗时，可能需要采用静态和动态分析方法。大多数扫描工具也不支持发现客户端注入。
- en: Another dimension to Client Side Injection is the impact, which is judged to
    be low in most cases. There is a strong counter argument to this vulnerability.
    If the entire local storage can be obtained easily in Android, then why do we
    need to conduct Client Side Injection? I agree to this argument in most cases,
    as the entire SQLite or XML file from the phone can be stolen, why spend time
    searching a variable that accepts a wildcard to reveal the data from the SQLite
    or XML file?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端注入的另一个维度是其影响，通常在大多数情况下被评估为低风险。对此漏洞有一个强烈的反驳观点：如果可以轻松获取整个本地存储中的数据，那为什么还需要进行客户端注入？我在大多数情况下同意这个观点，因为整个
    SQLite 或 XML 文件都可以被盗取，那么为什么要花时间搜索一个接受通配符的变量来揭示 SQLite 或 XML 文件中的数据呢？
- en: However, you should still look out for this vulnerability, as HTML injection
    or LFI kind of attacks have malware-corrupted file insertion possibility and hence
    the impactful attack. Also, there are platforms such as iOS where sometimes, stealing
    the local storage is very difficult. In such cases, client side injection may
    come in handy.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你仍然需要注意这个漏洞，因为 HTML 注入或 LFI 类型的攻击可能会导致恶意软件感染的文件插入，从而造成更有影响力的攻击。此外，有些平台（如
    iOS）中，偷取本地存储非常困难。在这种情况下，客户端注入可能会派上用场。
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M7](https://www.owasp.org/index.php/Mobile_Top_10_2014-M7)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M7](https://www.owasp.org/index.php/Mobile_Top_10_2014-M7)'
- en: '[http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)'
- en: Insecure encryption in mobile apps
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动应用中的不安全加密
- en: Encryption is one of the misused terms in information security. Some people
    confuse it with hashing, while others may implement encoding and call it encryption.
    symmetric key and asymmetric key are two types of encryption schemes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是信息安全中被误用的术语之一。有些人将其与哈希混淆，而另一些人可能实现了编码并称之为加密。对称密钥和非对称密钥是两种加密方案。
- en: Mobile applications implement encryption to protect sensitive data in storage
    and in transit. While doing audits, your goal should be to uncover weak encryption
    implementation or the so-called encoding or other weaker forms, which are implemented
    in places where a proper encryption should have been implemented. Try to circumvent
    the encryption implemented in the mobile application under audit.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用实现加密以保护存储和传输中的敏感数据。在进行审计时，你的目标应该是揭示弱加密实现或所谓的编码或其他较弱的形式，这些形式出现在应该实施适当加密的地方。尝试绕过移动应用中实施的加密。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be ready with a few mobile applications and tools such as ADB and other file
    and memory readers, decompiler and decoding tools, and so on.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好一些移动应用和工具，如ADB、其他文件和内存读取器、反编译器和解码工具等。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are multiple types of faulty implementation of encryption in mobile applications.
    There are different ways to discover each of them:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用中的加密实现存在多种错误类型。每种类型的错误都有不同的发现方法：
- en: 'Encoding (instead of encryption): Many a time, mobile app developers simply
    implement Base64 or URL encoding in applications (an example of security by obscurity).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码（而非加密）：很多时候，移动应用开发人员只是简单地在应用中实现Base64或URL编码（这是一种通过模糊化进行的安全手段）。
- en: Such encoding can be discovered by simply doing static analysis. You can use
    the script discussed in the first recipe of this chapter for finding out such
    encoding algorithms.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种编码可以通过简单的静态分析发现。你可以使用本章第一个配方中讨论的脚本来查找这种编码算法。
- en: Dynamic analysis will help you obtain the locally stored data in encoded format.
    Decoders for these known encoding algorithms are available freely. Using any of
    those, you will be able to uncover the original value. Thus, such implementation
    is not a substitute for encryption.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态分析将帮助你获取本地存储的编码格式数据。已知编码算法的解码器可以免费获得。使用其中任何一种，你将能够揭示原始值。因此，这种实现不能替代加密。
- en: 'Serialization (instead of encryption): Another variation of faulty implementation
    is serialization. Serialization is the process of conversion of data objects to
    byte stream. The reverse process, deserialization, is also very simple and the
    original data can be obtained easily.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化（而非加密）：另一种错误实现的变体是序列化。序列化是将数据对象转换为字节流的过程。逆过程，反序列化，也非常简单，原始数据可以很容易地恢复。
- en: Static Analysis may help reveal implementations using serialization.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 静态分析可以帮助揭示使用序列化的实现。
- en: 'Obfuscation (instead of encryption): Obfuscation also suffers from similar
    problems and the obfuscated values can be deobfuscated.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混淆（而非加密）：混淆也存在类似问题，混淆的值可以被反混淆。
- en: 'Hashing (instead of encryption): Hashing is a one-way process using a standard
    complex algorithm. These one-way hashes suffer from a major problem in that they
    can be replayed (without needing to recover the original data). Also, rainbow
    tables can be used to crack the hashes.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希（而非加密）：哈希是一种使用标准复杂算法的单向过程。这些单向哈希面临一个主要问题，即它们可以被重放（而不需要恢复原始数据）。此外，彩虹表可以用于破解哈希值。
- en: Like other techniques described previously, hashing usage in mobile applications
    can also be discovered via static analysis. Dynamic analysis may additionally
    be employed to reveal the one-way hashes stored locally.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前描述的其他技术一样，移动应用中的哈希使用也可以通过静态分析发现。动态分析还可以用来揭示本地存储的单向哈希。
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To understand the insecure encryption in mobile applications, let us take a
    live case, which we observed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解移动应用中的不安全加密，我们来看看一个我们观察到的实际案例。
- en: An example of weak custom implementation
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱自定义实现的示例
- en: 'While testing a live mobile banking application, me and my colleagues came
    across a scenario where a `userid` and `mpin` combination was sent by a custom
    encoding logic. The encoding logic here was based on a predefined character by
    character replacement by another character, as per an in-built mapping. For example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试一个实时移动银行应用时，我和我的同事遇到了一个场景，其中 `userid` 和 `mpin` 的组合是通过自定义编码逻辑发送的。这里的编码逻辑基于预定义的字符逐一替换为另一个字符，按照内置的映射。例如：
- en: '`2` is replaced by `4`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 被替换为 `4`'
- en: '`0` is replaced by `3`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 被替换为 `3`'
- en: '`3` is replaced by `2`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` 被替换为 `2`'
- en: '`7` is replaced by `=`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`7` 被替换为 `=`'
- en: '`a` is replaced by `R`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 被替换为 `R`'
- en: '`A` is replaced by `N`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 被替换为 `N`'
- en: As you can notice, there is no logic to the replacement. Until you uncover or
    decipher the whole in-built mapping, you won't succeed. A simple technique is
    to supply all possible characters one-by-one and watch out for the response. Let's
    input `userid` and `PIN` as `222222` and `2222` and notice the converted `userid`
    and `PIN` are `444444` and `4444` respectively, as per the mapping above. Go ahead
    and keep changing the inputs, you will create a full mapping as is used in the
    application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，替换没有逻辑可言。直到你揭示或破译整个内置映射，你才有可能成功。一个简单的技巧是逐个输入所有可能的字符，并观察响应。我们输入 `userid`
    和 `PIN` 为 `222222` 和 `2222`，并注意到转换后的 `userid` 和 `PIN` 分别为 `444444` 和 `4444`，如上面的映射所示。继续改变输入，你将创建一个完整的映射，就像应用程序中使用的那样。
- en: Now steal the user's encoded data and apply the created mapping, thereby uncovering
    the original data. This whole approach is nicely described in the article mentioned
    under the *See also* section of this recipe.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，窃取用户的编码数据并应用创建的映射，从而揭示原始数据。整个过程在本文所提到的*另请参见*部分的文章中有很好的描述。
- en: This is a custom example of faulty implementation pertaining to encryption.
    Such kinds of faults are often difficult to find in static analysis, especially
    in the case of difficult to reverse apps such as iOS applications. The possibility
    of automated dynamic analysis discovering this is also difficult. Manual testing
    and analysis stands, along with dynamic or automated analysis, a better chance
    of uncovering such custom implementations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于加密故障实现的自定义示例。这类故障通常在静态分析中很难发现，尤其是在那些难以逆向的应用程序中，比如 iOS 应用。自动化动态分析发现这一点的可能性也很低。手动测试和分析，结合动态或自动化分析，更有可能揭示此类自定义实现。
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Finally, I would share another application we came across. This one used proper
    encryption. The encryption algorithm was a well known secure algorithm and the
    key was strong. Still, the whole encryption process can be reversed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想分享我们遇到的另一个应用程序。这个应用程序使用了正确的加密。加密算法是一个广为人知的安全算法，密钥也很强大。尽管如此，整个加密过程仍然可以被逆向破解。
- en: 'The application had two mistakes; we combined both of them to break the encryption:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序存在两个错误；我们将这两个错误结合起来破解了加密：
- en: The application code had the standard encryption algorithm in the APK bundle.
    Not even obfuscation was used to protect the names at least. We used the simple
    process of APK to DEX to JAR conversion to uncover the algorithm details.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码中包含了标准的加密算法在 APK 包中。甚至没有使用混淆来至少保护名称。我们使用简单的 APK 到 DEX 再到 JAR 的转换过程来揭示算法细节。
- en: The application had stored the strong encryption key in the local XML file under
    the `/data/data` folder of the Android device. We used adb to read this xml file
    and hence obtained the encryption key.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序将强加密密钥存储在 Android 设备的 `/data/data` 文件夹下的本地 XML 文件中。我们使用 adb 读取该 XML 文件，从而获得了加密密钥。
- en: According to Kerckhoff's principle, the security of a cryptosystem should depend
    solely on the secrecy of the key and the private randomizer. This is how all encryption
    algorithms are implemented. The key is the secret, not the algorithm.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据克尔科霍夫原理，加密系统的安全性应仅依赖于密钥和私有随机数生成器的保密性。这是所有加密算法实现的方式。密钥才是秘密，而不是算法。
- en: In our scenario, we could obtain the key and know the name of the encryption
    algorithm. This is enough to break the strong encryption implementation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们能够获得密钥并知道加密算法的名称。这足以破解强加密实现。
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/](http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/](http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/)'
- en: Discovering data leakage sources
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现数据泄漏源
- en: Data leakage risk worries organizations across the globe and people have been
    implementing solutions to prevent data leakage. In the case of mobile applications,
    first we have to think what could be the sources or channels for data leakage
    possibility. Once this is clear, devise or adopt a technique to uncover each of
    them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 数据泄露风险引起了全球各地组织的担忧，人们一直在实施解决方案以防止数据泄露。对于移动应用程序，首先我们需要思考数据泄露可能的来源或渠道。一旦这一点明确，就可以设计或采用一种技术来揭示其中的每一个渠道。
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As in other recipes, here also you need bunch of applications (to be analyzed),
    an Android device or emulator, ADB, DEX to JAR converter, Java decompilers, Winrar,
    or Winzip.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他方法一样，这里也需要一些应用程序（待分析）、一台Android设备或模拟器、ADB、DEX到JAR转换器、Java反编译器、Winrar或Winzip。
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To identify the data leakage sources, list down all possible sources you can
    think of for the mobile application under audit. In general, all mobile applications
    have the following channels of potential data leakage:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别数据泄露源，请列出你能想到的所有可能的移动应用数据泄露渠道。通常，所有移动应用都有以下潜在的数据泄露渠道：
- en: Files stored locally
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储的文件
- en: Client side source code
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端源代码
- en: Mobile device logs
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备日志
- en: Web caches
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络缓存
- en: Console messages
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台消息
- en: Keystrokes
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键记录
- en: Sensitive data sent over HTTP
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP发送的敏感数据
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The next step is to uncover the data leakage vulnerability at these potential
    channels. Let us see the six previously identified common channels:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是揭示这些潜在渠道中的数据泄露漏洞。我们来看看之前识别的六个常见渠道：
- en: '**Files stored locally**: By this time, readers are very familiar with this.
    The data is stored locally in files like shared preferences, xml files, SQLite
    DB, and other files.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地存储的文件**：到目前为止，读者应该非常熟悉这一点。数据以本地文件的形式存储，如共享偏好设置、xml文件、SQLite数据库及其他文件。'
- en: In Android, these are located inside the application folder under `/data/data`
    directory and can be read using tools such as ADB.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Android中，这些文件位于应用程序文件夹的`/data/data`目录下，可以使用工具如ADB来读取。
- en: In iOS, tools such as iExplorer or SSH can be used to read the application folder.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在iOS中，工具如iExplorer或SSH可以用来读取应用程序文件夹。
- en: '**Client side source code**: Mobile application source code is present locally
    in the mobile device itself. The source code in applications has been hardcoding
    data, and a common mistake is hardcoding sensitive data (either knowingly or unknowingly).'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端源代码**：移动应用程序的源代码本地存储在设备本身中。应用程序中的源代码可能硬编码了数据，而一个常见的错误是硬编码敏感数据（无论是故意还是无意）。'
- en: From the field, we came across an application which had hardcoded the connection
    key to the connected PoS terminal. Hardcoded formulas to calculate a certain figure,
    which should have ideally been present in the server-side code, was found in the
    mobile app. Database instance names and credentials are also a possibility where
    the mobile app directly connects to a server datastore.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从实践中，我们遇到过一个应用程序，它将连接到PoS终端的连接密钥硬编码在代码中。发现了一些应该理想情况下存在于服务器端代码中的硬编码公式，该公式用于计算某个数字。数据库实例名称和凭据也有可能被硬编码，尤其是在移动应用直接连接到服务器数据存储时。
- en: In Android, the source code is quite easy to decompile via a two-step process—APK
    to DEX and DEX to JAR conversion.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Android中，通过两步过程—APK到DEX，再到DEX到JAR的转换，源代码比较容易反编译。
- en: In iOS, the source code of header files can be decompiled up to a certain level
    using tools such as classdump-z or otool.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在iOS中，使用类dump-z或otool等工具可以将头文件的源代码反编译到一定程度。
- en: Once the raw source code is available, a static string search can be employed
    to discover sensitive data in the code.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦获取到原始源代码，就可以通过静态字符串搜索来发现代码中的敏感数据。
- en: '**Mobile device logs**: All devices create local logs to store crash and other
    information, which can be used to debug or analyze a security violation. A poor
    coding may put sensitive data in local logs and hence data can be leaked from
    here as well.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动设备日志**：所有设备都会生成本地日志来存储崩溃和其他信息，这些日志可以用来调试或分析安全漏洞。糟糕的编码可能会将敏感数据存储到本地日志中，从而导致数据泄露。'
- en: 'Android ADB command `adb logcat` can be used to read the logs on Android devices.
    If you use the same ADB command for the Vulnerable Bank application, you will
    notice the user credentials in the logs as shown in the following screenshot:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android ADB命令`adb logcat`可以用来读取Android设备上的日志。如果你对“易受攻击的银行”应用使用相同的ADB命令，你将看到日志中包含用户凭证，如下截图所示：
- en: '![How it works...](graphics/image_03_020.jpg)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/image_03_020.jpg)'
- en: '**Web caches**: Web caches may also contain the sensitive data related to web
    components used in mobile apps. We discussed how to discover this in the WAP recipe
    in this chapter previously.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 缓存**：Web 缓存也可能包含与移动应用中使用的 Web 组件相关的敏感数据。我们在本章之前讨论了如何在WAP配方中发现这一点。'
- en: '**Console messages**: Console messages are used by developers to print messages
    to the console while application development and debugging is in progress. Console
    messages, if not turned off while launching the application (GO LIVE), may be
    another source of data leakage. Console messages can be checked by running the
    application in debug mode.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台消息**：开发人员在应用开发和调试过程中使用控制台消息来打印信息。如果在应用程序上线时没有关闭控制台消息（GO LIVE），可能会成为数据泄露的另一个源。可以通过在调试模式下运行应用程序来检查控制台消息。'
- en: '**Keystrokes**: Certain mobile platforms have been known to cache key strokes.
    A malware or key stroke logger may take advantage and steal a user''s key strokes,
    hence making it another data leakage source. Malware analysis needs to be performed
    to uncover embedded or pre-shipped malware or keystroke loggers with the application.
    Dynamic analysis also helps.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按键记录**：某些移动平台已知会缓存按键操作。恶意软件或按键记录器可能会利用这一点窃取用户的按键，从而成为数据泄露的另一个来源。需要进行恶意软件分析，以发现嵌入或预装的恶意软件或按键记录器。动态分析也有帮助。'
- en: '**Sensitive data sent over HTTP**: Applications either send sensitive data
    over HTTP or use a weak implementation of SSL. In either case, sensitive data
    leakage is possible.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过 HTTP 发送的敏感数据**：应用程序可能会通过 HTTP 发送敏感数据，或使用弱 SSL 实现。在这两种情况下，敏感数据泄露是可能的。'
- en: Usage of HTTP can be found via static analysis to search for HTTP strings. Dynamic
    analysis to capture the packets at runtime also reveals whether traffic is over
    HTTP or HTTPS.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过静态分析查找 HTTP 字符串来发现 HTTP 的使用。动态分析通过捕获运行时的数据包也能揭示流量是通过 HTTP 还是 HTTPS。
- en: There are various SSL-related weak implementation and downgrade attacks, which
    make data vulnerable to sniffing and hence data leakage.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种与 SSL 相关的弱实现和降级攻击，这使得数据容易受到嗅探，从而导致数据泄露。
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Data leakage sources can be vast and listing all of them does not seem possible.
    Sometimes there are applications or platform-specific data leakage sources, which
    may call for a different kind of analysis.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 数据泄露源可以是广泛的，列出所有的数据泄露源似乎是不可能的。有时会存在应用程序或平台特定的数据泄露源，这可能需要进行不同类型的分析。
- en: Intent injection can be used to fire intents to access privileged contents.
    Such intents may steal protected data such as the personal information of all
    the patients in a hospital (under HIPPA compliance).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 意图注入可以用来发送意图以访问特权内容。这些意图可能会窃取保护的数据，如医院中所有患者的个人信息（符合HIPPA规定）。
- en: iOS screenshot backgrounding issues, where iOS applications store screenshots
    with populated user input data, on the iPhone or iPAD when the application enters
    background. Imagine such screenshots containing a user's credit card details,
    CCV, expiry date, and so on, are found in an application under PCI-DSS compliance.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 截图后台问题，当 iOS 应用程序在 iPhone 或 iPad 上进入后台时，会存储包含用户输入数据的截图。想象一下，像包含用户信用卡详细信息、CCV、有效期等的截图，在符合
    PCI-DSS 的应用程序中被发现。
- en: Malwares give a totally different angle to data leakage. Note that data leakage
    is a very big risk organizations are tackling today. It is not just financial
    loss; losses may be intangible, such as reputation damage, or compliance or regulatory
    violations. Hence, it makes it very important to identify the maximum possible
    data leakage sources in the application and rectify the potential leakages.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件从完全不同的角度给数据泄露带来了威胁。需要注意的是，数据泄露是组织今天所面临的一个重大风险。这不仅仅是经济损失；损失可能是无形的，比如声誉损害，或是合规性或监管违规。因此，识别应用中可能的最大数据泄露源并修复潜在的泄露非常重要。
- en: See also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M4](https://www.owasp.org/index.php/Mobile_Top_10_2014-M4)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M4](https://www.owasp.org/index.php/Mobile_Top_10_2014-M4)'
- en: '*Launching intent injection in Android*'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Android 中启动意图注入*'
- en: Other application-based attacks in mobile devices
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动设备中的其他基于应用的攻击
- en: When we talk about application-based attacks, **OWASP TOP 10** risks are the
    very first things that strike. OWASP ( [www.owasp.org](http://www.owasp.org) )
    has a dedicated project to mobile security, which releases **Mobile Top 10**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论基于应用的攻击时，**OWASP TOP 10** 风险是首先引起注意的事项。OWASP（[www.owasp.org](http://www.owasp.org)）有一个专门的项目致力于移动安全，并发布了**Mobile
    Top 10**。
- en: 'OWASP gathers data from industry experts and ranks the top 10 risks every three
    years. It is a very good knowledge base for mobile application security. Here
    is the latest Mobile Top 10 released in the year 2014:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP收集来自行业专家的数据，并每三年排名一次前10大风险。这是一个非常好的移动应用安全知识库。以下是2014年发布的最新移动Top 10：
- en: 'M1: Weak Server Side Controls'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M1：弱的服务器端控制
- en: 'M2: Insecure Data Storage'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M2：不安全的数据存储
- en: 'M3: Insufficient Transport Layer Protection'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M3：不足的传输层保护
- en: 'M4: Unintended Data Leakage'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M4：意外的数据泄露
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M5：较差的授权和认证
- en: 'M6: Broken Cryptography'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M6：破损的加密技术
- en: 'M7: Client Side Injection'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M7：客户端注入
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M8：通过不受信任的输入做安全决策
- en: 'M9: Improper Session Handling'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M9：不当的会话处理
- en: 'M10: Lack of Binary Protections'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M10：缺乏二进制保护
- en: Getting ready
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Have a few applications ready to be analyzed, use the same set of tools we have
    been discussing till now, and refer to the  *Setting up the Android pentesting
    environment* and *Setting up the iOS pentesting environment* recipes in [Chapter
    1](ch01.html "Chapter 1.  Introduction to Mobile Security"), *Introduction to
    Mobile Security*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一些应用程序来进行分析，使用我们目前讨论的同一套工具，并参考[第1章](ch01.html "第1章。移动安全简介")中的*设置Android渗透测试环境*和*设置iOS渗透测试环境*的步骤。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we restrict ourselves to other application attacks. The attacks
    which we have not covered till now in this book are:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将局限于其他应用攻击。本书中尚未涵盖的攻击有：
- en: 'M1: Weak Server Side Controls'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M1：弱的服务器端控制
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M5：较差的授权和认证
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M8：通过不受信任的输入做安全决策
- en: 'M9: Improper Session Handling'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M9：不当的会话处理
- en: In [Chapter 5](ch05.html "Chapter 5. Working with Other Platforms"), *Working
    with Other Platforms*, M1 is covered in a detailed manner and M5 and M9, which
    are mostly server-side issues are also discussed in it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。与其他平台的协作")，*与其他平台的协作*中，详细讨论了M1，同时也讨论了大部分为服务器端问题的M5和M9。
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Currently, let us discuss client-side or mobile-side issues for M5, M8, and
    M9.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们讨论M5、M8和M9的客户端或移动端问题。
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M5：较差的授权和认证
- en: 'A few common scenarios which can be attacked are:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的可以被攻击的场景包括：
- en: Authentication implemented at device level (for example, PIN stored locally)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备级别实现的认证（例如，PIN存储在本地）
- en: Authentication bound on poor parameters (such as UDID or IMEI numbers)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证绑定在较差的参数上（如UDID或IMEI号码）
- en: Authorization parameter responsible for access to protected application menus
    is stored locally
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责访问受保护应用菜单的授权参数存储在本地
- en: These can be attacked by reading data using ADB, decompiling the applications,
    and conducting static analysis on the same or by doing dynamic analysis on the
    outgoing traffic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过读取数据（使用ADB）、反编译应用程序并进行静态分析，或通过对外出流量进行动态分析来进行攻击。
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M8：通过不受信任的输入做安全决策
- en: This one talks about IPC. IPC entry points for applications to communicate to
    one other, such as Intents in Android or URL schemes in iOS, are vulnerable. If
    the origination source is not validated, the application can be attacked.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分讲的是IPC。应用程序间通信的IPC入口点，如Android中的Intents或iOS中的URL方案，是脆弱的。如果源没有经过验证，应用程序就可能受到攻击。
- en: Malicious intents can be fired to bypass authorization or steal data. Let us
    discuss this in further detail in the next recipe.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意意图可以被触发以绕过授权或窃取数据。让我们在下一个步骤中更详细地讨论这个问题。
- en: URL schemes are a way for applications to specify the launch of certain components.
    For example, the mailto scheme in iOS is used to create a new e-mail. If the applications
    fail to specify the acceptable sources, any malicious application will be able
    to send a mailto scheme to the victim application and create new e-mails.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: URL方案是应用程序指定启动特定组件的一种方式。例如，iOS中的mailto方案用于创建新的电子邮件。如果应用程序未能指定可接受的来源，任何恶意应用程序都可以发送mailto方案到受害应用程序并创建新邮件。
- en: 'M9: Improper Session Handling'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M9：不当的会话处理
- en: From a purely mobile device perspective, session tokens stored in `.db` files
    or `oauth` tokens, or strings granting access stored in weakly protected files,
    are vulnerable. These can be obtained by reading the local data folder using ADB.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的移动设备角度来看，存储在`.db`文件或`oauth`令牌中的会话令牌，或者存储在保护不力的文件中的访问授权字符串，都是脆弱的。通过使用ADB读取本地数据文件可以获取这些信息。
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks](https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks](https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks)'
- en: Launching intent injection in Android
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android中发起意图注入
- en: Android uses intents to request action from another application component. A
    common communication is passing Intent to start a service. We will exploit this
    fact via an **intent injection attack**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用意图请求来自另一个应用程序组件的操作。一种常见的通信方式是传递Intent来启动服务。我们将通过**意图注入攻击**来利用这一点。
- en: An intent injection attack works by injecting intent into the application component
    to perform a task that is usually not allowed by the application workflow. For
    example, if the Android application has a login activity which, post successful
    authentication, allows you access to protected data via another activity. Now
    if an attacker can invoke the internal activity to access protected data by passing
    an Intent, it would be an Intent Injection attack.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 意图注入攻击通过将意图注入应用程序组件来执行通常不被应用程序工作流允许的任务。例如，如果Android应用程序有一个登录活动，登录成功后允许通过另一个活动访问受保护的数据。如果攻击者能够通过传递Intent来调用内部活动以访问受保护的数据，那么这就是一次意图注入攻击。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Install Drozer by downloading it from [https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)
    and following the installation instructions mentioned in the User Guide.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)下载Drozer并按照用户指南中提到的安装说明进行安装。
- en: Install Drozer Console Agent and start a session as mentioned in the User Guide.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Drozer控制台代理并按照用户指南中提到的步骤启动会话。
- en: If your installation is correct, you should get a Drozer command prompt (`dz>`).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的安装正确，您应该会看到Drozer命令提示符（`dz>`）。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'You should also have a few vulnerable applications to analyze. Here we chose
    the OWASP GoatDroid application:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该有一些易受攻击的应用程序进行分析。我们选择了OWASP GoatDroid应用程序：
- en: Start the OWASP GoatDroid Fourgoats application in emulator.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器中启动OWASP GoatDroid Fourgoats应用程序。
- en: Browse the application to develop understanding. Note that you are required
    to authenticate by providing a username and password, and post-authentication
    you can access profile and other pages. Here is the pre-login screen you get:![How
    to do it...](graphics/image_03_021.jpg)
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览应用程序以了解其工作原理。请注意，您需要通过提供用户名和密码进行身份验证，身份验证后可以访问个人资料和其他页面。以下是您获得的登录前界面：![如何执行...](graphics/image_03_021.jpg)
- en: 'Let us now use Drozer to analyze the activities of the Fourgoats application.
    The following Drozer command is helpful:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用Drozer来分析Fourgoats应用程序的活动。以下Drozer命令非常有帮助：
- en: '[PRE11]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Drozer detects four activities with null permission. Out of these four, `ViewCheckin`
    and `ViewProfile` are post-login activities.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Drozer检测到四个具有空权限的活动。其中，`ViewCheckin`和`ViewProfile`是登录后的活动。
- en: 'Use Drozer to access these two activities directly, via the following command:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Drozer直接访问这两个活动，命令如下：
- en: '[PRE12]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We chose to access `ViewProfile` activity and the entire sequence of activities
    is shown in the following screenshot:![How to do it...](graphics/image_03_022.jpg)
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择访问`ViewProfile`活动，以下截图展示了整个活动序列：![如何执行...](graphics/image_03_022.jpg)
- en: Drozer performs some actions and the protected user profile opens up in the
    emulator, as shown here:![How to do it...](graphics/image_03_023.jpg)
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Drozer执行了一些操作，受保护的用户个人资料在模拟器中打开，如下所示：![如何执行...](graphics/image_03_023.jpg)
- en: How it works...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drozer passed an Intent in the background to invoke the post-login activity
    `ViewProfile`. This resulted in `ViewProfile` activity performing an action resulting
    in display of profile screen. This way, an intent injection attack can be performed
    using Drozer framework.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer在后台传递了一个Intent来调用登录后的活动`ViewProfile`。这导致`ViewProfile`活动执行某个操作，从而显示了个人资料界面。通过这种方式，可以使用Drozer框架执行意图注入攻击。
- en: There's more...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Android uses intents also for starting a service or delivering a broadcast.
    Intent injection attacks can be performed on services and broadcast receivers.
    A Drozer framework can also be used to launch attacks on the app components. Attackers
    may write their own attack scripts or use different frameworks to launch this
    attack.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Android 还使用意图（intents）来启动服务或发送广播。服务和广播接收器可以受到意图注入攻击。Drozer 框架也可以用来对应用程序组件进行攻击。攻击者可以编写自己的攻击脚本或使用不同的框架来执行此类攻击。
- en: See also
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using Drozer to find vulnerabilities in Android applications*'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Drozer 查找 Android 应用程序中的漏洞*'
- en: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
- en: '[https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf](https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf)'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf](https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf)'
