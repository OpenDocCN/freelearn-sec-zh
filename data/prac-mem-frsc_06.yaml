- en: 'Chapter 4: Reconstructing User Activity with Windows Memory Forensics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：通过 Windows 内存取证重建用户活动
- en: User activity reconstruction is essential for many use cases since it gives
    us a better understanding of what is going on. In the first chapter, we discussed
    that if you receive a device participating in the incident, the victim or suspect
    probably owned this device. If we analyze the victim's device, user activity can
    tell us how the infection occurred or how the attacker acted while remotely accessing
    the computer. If we are talking about the attacker's device, such analysis allows
    us to understand how the preparation for the attack took place, what actions the
    threat actor performed, and how to find evidence of illegitimate activity. Also,
    if you are dealing with criminal cases that are not related to hacking but more
    traditional crimes, such as child pornography, human trafficking, and drug dealing,
    memory images may contain key sources of evidence. Here, you may be able to recover
    private communications and browser history, as well as the encryption keys of
    the containers that were used by the suspect to hide the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户活动重建对于许多使用场景至关重要，因为它帮助我们更好地理解发生了什么。在第一章中，我们讨论了如果收到参与事件的设备，受害者或嫌疑人可能是设备的拥有者。如果我们分析受害者的设备，用户活动可以告诉我们感染是如何发生的，或者攻击者在远程访问计算机时是如何行动的。如果我们谈论的是攻击者的设备，这种分析可以帮助我们了解攻击准备是如何进行的，威胁行为者执行了哪些操作，并且如何找到非法活动的证据。另外，如果您处理的案件与黑客攻击无关，而是涉及传统犯罪，如儿童色情、人口贩卖和毒品交易，内存镜像可能包含关键证据来源。在这里，您可能能够恢复私人通信和浏览器历史记录，以及嫌疑人用来隐藏数据的容器的加密密钥。
- en: This chapter will provide some insights into user action recovery techniques,
    based not only on running processes but also on analyzing Windows Registry and
    the filesystem in memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供一些有关用户行为恢复技术的见解，这些技术不仅基于正在运行的进程，还基于分析内存中的 Windows 注册表和文件系统。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Analyzing launched applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析已启动的应用程序
- en: Searching for opened documents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索已打开的文档
- en: Investigating browser history
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查浏览器历史记录
- en: Examining communication applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查通信应用程序
- en: Recovering user passwords
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复用户密码
- en: Detecting crypto containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测加密容器
- en: Extracting recent activity from the registry
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从注册表中提取最近的活动
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the tools described in the next three chapters and conduct Windows
    memory forensics, you do not need to meet certain technical requirements. It is
    sufficient to have a Windows operating system installed on the main host or a
    virtual machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一章介绍的工具并进行 Windows 内存取证时，您不需要满足特定的技术要求。只需要在主机或虚拟机上安装 Windows 操作系统即可。
- en: Analyzing launched applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析已启动的应用程序
- en: Applications analysis may help an investigator to build the suspect's profile.
    The analysis of running processes may help us to understand whether the suspect
    is using some messengers or web browsers with high anonymity levels or if any
    encrypted containers are currently mounted. Such data sources may be full of valuable
    forensic artifacts and, what's more, be unavailable during post-mortem analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序分析可以帮助调查员建立嫌疑人的档案。分析运行中的进程可以帮助我们了解嫌疑人是否在使用一些具有高度匿名性的消息应用程序或网络浏览器，或者是否有加密容器正在挂载。这些数据源可能充满了有价值的取证文物，且在事后分析中可能无法访问。
- en: Each time the user starts a program, the corresponding process is created in
    memory and added to the list of active processes. By analyzing this list, we can
    get information about the programs running at the moment the dump is taken. That's
    what we'll do once we get to know our analysis tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户启动程序时，相应的进程会在内存中创建并添加到活动进程列表中。通过分析这个列表，我们可以获得关于在转储时运行的程序的信息。这就是我们一旦掌握分析工具后将要做的事情。
- en: Introducing Volatility
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Volatility
- en: The **Volatility framework** is the most popular free tool for memory dump analysis.
    Many vendors have included support for this tool in their solutions, including
    *Autopsy* and *Magnet AXIOM*. The source code for this tool is written in Python,
    so Volatility can be used on different operating systems. Moreover, Volatility
    allows you to analyze various operating systems, ranging from *Windows XP* to
    *Linux* and *macOS*. Naturally, we also decided to take Volatility as a basis,
    but we will not limit ourselves to it either.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Volatility 框架**是最流行的免费内存转储分析工具。许多厂商已经在他们的解决方案中加入了对该工具的支持，包括*Autopsy*和*Magnet
    AXIOM*。该工具的源代码是用 Python 编写的，因此 Volatility 可以在不同的操作系统上使用。此外，Volatility 还允许你分析各种操作系统，从*Windows
    XP*到*Linux*和*macOS*。当然，我们也决定以 Volatility 为基础，但我们不会仅限于此。'
- en: 'To run Volatility, you can use one of the following options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Volatility，你可以使用以下其中一种选项：
- en: '**Volatility Standalone**: This version is a separate executable file. The
    last version that was released in this format was **Volatility 2.6**. You can
    get it from the official site: [https://www.volatilityfoundation.org/26](https://www.volatilityfoundation.org/26).
    Just download the version that suits your operating system and copy the executable
    file to a convenient location.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Volatility 独立版**：此版本是一个独立的可执行文件。最后发布的该格式版本是**Volatility 2.6**。你可以从官方网站下载：[https://www.volatilityfoundation.org/26](https://www.volatilityfoundation.org/26)。只需下载适合你操作系统的版本并将可执行文件复制到一个方便的位置。'
- en: '**Python scripts**: Using scripts has its advantages as they are updated more
    frequently and support a larger number of profiles. To get them, you can simply
    go to the Volatility GitHub repository and clone the project: [https://github.com/volatilityfoundation/volatility](https://github.com/volatilityfoundation/volatility).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 脚本**：使用脚本有其优势，因为它们更新频繁，支持更多的配置文件。要获取这些脚本，你只需访问 Volatility 的 GitHub
    仓库并克隆该项目：[https://github.com/volatilityfoundation/volatility](https://github.com/volatilityfoundation/volatility)。'
- en: '**Volatility Workbench**: This option is suitable for those who prefer to work
    with tools that have a graphical interface. The developers of the Workbench periodically
    update it, so this tool also supports the latest versions of Volatility, including
    Volatility 3\. However, it also has disadvantages, such as incomplete support
    for all the parameters available in Volatility. You can download Workbench for
    free from the official website: [https://www.osforensics.com/tools/volatility-workbench.html](https://www.osforensics.com/tools/volatility-workbench.html).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Volatility Workbench**：此选项适用于那些喜欢使用具有图形界面的工具的用户。Workbench 的开发者定期更新该工具，因此它也支持
    Volatility 的最新版本，包括 Volatility 3。然而，它也有一些缺点，比如对 Volatility 中所有可用参数的支持不完整。你可以从官方网站免费下载
    Workbench：[https://www.osforensics.com/tools/volatility-workbench.html](https://www.osforensics.com/tools/volatility-workbench.html)。'
- en: The Volatility project is actively supported, so you can always find detailed
    installation instructions, official plugin descriptions, plugins from the community,
    and more information from the appropriate public sources. This includes the official
    web page, Volatility's GitHub repository, and various forums.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 项目得到了积极支持，因此你总能在适当的公共资源中找到详细的安装说明、官方插件描述、社区插件以及更多信息。这些资源包括官方网页、Volatility
    的 GitHub 仓库以及各种论坛。
- en: At the time of writing, the latest version of Volatility is Volatility 3\. However,
    this version is still under development, and some of the plugins we need are underdeveloped
    or missing altogether. In addition, the output processing in Volatility 3 is not
    as easy as in version 2.6, so we gave preference to the previous version of Volatility.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 截至写作时，Volatility 的最新版本是 Volatility 3。然而，该版本仍在开发中，我们所需的一些插件尚未开发完成，甚至完全缺失。此外，Volatility
    3 的输出处理不像 2.6 版本那么简便，因此我们优先选择了之前的版本。
- en: At the time of writing, the latest version of Volatility is Volatility 3\. However,
    this version is still under development, and some of the plugins we need are underdeveloped
    or missing altogether. In addition, the output processing in Volatility 3 is not
    as easy as in version 2.6, so we gave preference to the previous version of Volatility.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 截至写作时，Volatility 的最新版本是 Volatility 3。然而，该版本仍在开发中，我们所需的一些插件尚未开发完成，甚至完全缺失。此外，Volatility
    3 的输出处理不像 2.6 版本那么简便，因此我们优先选择了之前的版本。
- en: 'We will take the easy route and choose the standalone version. If you are running
    Windows, then after downloading Volatility from the official website, you will
    get the `volatility_2.6_win64_standalone.exe` executable file. Volatility is a
    command-line tool, so you need *Windows PowerShell* or *Windows Command Prompt*
    to run it. To check that everything works correctly, you can open PowerShell,
    go to the folder that contains the tool (in our case, this is the `D:\` `drive`),
    and run Volatility with the `--info` option. This option opens the help menu,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择简单的方式，使用独立版本。如果你在 Windows 系统上运行，下载 Volatility 后，你将获得 `volatility_2.6_win64_standalone.exe`
    可执行文件。Volatility 是一个命令行工具，因此你需要使用 *Windows PowerShell* 或 *Windows 命令提示符* 来运行它。为了检查一切是否正常工作，你可以打开
    PowerShell，进入包含工具的文件夹（在我们的案例中是 `D:\` 驱动器），并使用 `--info` 选项运行 Volatility。该选项会打开帮助菜单，如下图所示：
- en: '![Figure 4.1 – Volatility information'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – Volatility 信息'
- en: '](img/Figure_4.1_B17056.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B17056.jpg)'
- en: Figure 4.1 – Volatility information
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Volatility 信息
- en: Pay attention to the **Profiles** section since it lists all the versions of
    the operating systems supported by your version of Volatility. Without a correctly
    specified profile, the tool will not work as expected.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 **Profiles** 部分，因为它列出了你的 Volatility 版本支持的所有操作系统版本。如果没有正确指定配置文件，工具将无法按预期工作。
- en: Profile identification
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件识别
- en: 'Each profile in the `imageinfo` plugin, which will try to find the most suitable
    profiles for you. To run this plugin, you will also need to use the `-f` option,
    after which you must specify the path to the memory dump you want to analyze.
    We used the memory dump named `Win10Mem.vmem`, located in the `D:\user activity`
    folder. The whole command should look as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageinfo` 插件中的每个配置文件都会尝试为你找到最合适的配置文件。运行此插件时，你还需要使用 `-f` 选项，并指定你要分析的内存转储路径。我们使用的内存转储文件名为
    `Win10Mem.vmem`，位于 `D:\user activity` 文件夹中。整个命令应如下所示：'
- en: '![Figure 4.2 – Volatility imageinfo'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – Volatility imageinfo'
- en: '](img/Figure_4.2_B17056.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B17056.jpg)'
- en: Figure 4.2 – Volatility imageinfo
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Volatility imageinfo
- en: If you run the command successfully, the `Suggested profiles` line will show
    a list of profiles that Volatility considers suitable for the analysis. In most
    cases, the first profile on the list will be the most suitable, but if you notice
    that some plugins do not work (which may be a lack of output, incorrect output,
    or an error message) with that profile, just try to change it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功运行该命令，`Suggested profiles` 行会显示 Volatility 认为适合分析的配置文件列表。在大多数情况下，列表中的第一个配置文件是最合适的，但如果你发现某些插件在该配置文件下无法正常工作（可能是没有输出、不正确的输出或错误消息），可以尝试更换配置文件。
- en: Another important point is that if the operating system that the dump was taken
    from is quite new, a suitable profile may not exist. In this case, you can search
    on GitHub and add a new profile to Volatility, look at the next version of Volatility
    – in this case, Volatility 3 – or use another tool. Of course, if you cannot find
    a proper profile, you can write one yourself, but you will need a deeper knowledge
    of programming and operating systems to do so.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是，如果转储的操作系统非常新，可能没有适合的配置文件。在这种情况下，你可以在 GitHub 上搜索并将新的配置文件添加到 Volatility，查看
    Volatility 的下一个版本——此时是 Volatility 3——或者使用其他工具。当然，如果你无法找到合适的配置文件，你也可以自己编写，但这将需要更深入的编程和操作系统知识。
- en: In our case, we will use the `Win10x64_14393` profile for the `Win10Mem.vmem`
    dump.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用 `Win10x64_14393` 配置文件来分析 `Win10Mem.vmem` 转储文件。
- en: At this point, we have a tool and a suitable profile. Now, we can analyze the
    list of active processes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经拥有工具和合适的配置文件。现在，我们可以分析活动进程列表了。
- en: Searching for active processes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索活动进程
- en: Volatility has several plugins for listing the processes running on the system
    at the time of dump creation. The first one, `pslist`, allows you to get a list
    sorted by time. If we are mostly interested not in creation time but the relationship
    between the parent and child processes, the better option is to use `pstree`.
    Both plugins work with a list of active processes in memory and display data that,
    on a live system, can be obtained with **Task Manager**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility 提供了多个插件，用于列出内存转储创建时系统上运行的进程。第一个插件 `pslist` 允许你按时间获取进程列表。如果你更关心父进程与子进程之间的关系而非创建时间，使用
    `pstree` 插件会更好。两个插件都使用内存中活动进程的列表，并显示可以在实时系统中通过 **任务管理器** 获取的数据。
- en: 'The universal command for getting started with any of the plugins is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 启动任何插件的通用命令如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s try to get the list of active processes, sorted by time:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试按时间排序获取活动进程的列表：
- en: '![Figure 4.3 – Volatility pslist'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – Volatility pslist'
- en: '](img/Figure_4.3_B17056.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B17056.jpg)'
- en: Figure 4.3 – Volatility pslist
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Volatility pslist
- en: Take a look at the preceding screenshot. In the output of the plugin, we can
    find not only the name of the running process but also its unique identifier,
    the identifier of its parent process, the number of associated handles and threads,
    the time the process was created, and, if the process was terminated, the time
    it was exited.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的截图。在插件的输出中，我们不仅可以找到正在运行的进程的名称，还能找到其唯一标识符、父进程的标识符、关联的句柄和线程数、进程创建的时间以及如果进程已经终止，则可以看到它退出的时间。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many different kernel objects. When a process needs to open a particular
    object, a reference, called handle, is opened for it. Since every active process
    must have at least one thread (an object that represents the smallest sequence
    of programmed instructions), there is always a handle for that type of object.
    In addition to that, handles are often created for objects such as files, registry
    keys, and even other processes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对象种类繁多。当一个进程需要打开某个特定对象时，会为其打开一个称为句柄的引用。由于每个活动进程必须至少有一个线程（表示最小程序指令序列的对象），因此这种类型的对象总是有一个句柄。此外，句柄通常还会为文件、注册表项，甚至是其他进程等对象创建。
- en: However, what if the process was terminated recently and information about it
    has been removed from the list of active processes?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果进程最近已经终止，并且它的信息已经从活动进程列表中删除了，那该怎么办呢？
- en: Searching for finished processes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在查找已结束的进程
- en: From the operating system's point of view, all processes are objects of a certain
    `_EPROCESS` structure. When a process finishes its work, its data is still stored
    in memory for some time until the space occupied by the process is overwritten.
    Volatility allows you to search for such processes using a search for objects,
    similar in structure to `_EPROCESS`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看，所有进程都是某种`_EPROCESS`结构的对象。当一个进程完成工作后，它的数据仍会在内存中保存一段时间，直到被该进程占用的空间被覆盖。Volatility允许你通过类似`_EPROCESS`结构的对象搜索来查找这些进程。
- en: 'To find such processes, you can use the `psscan` plugin. Its execution will
    look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找这些进程，可以使用`psscan`插件。其执行过程如下所示：
- en: '![Figure 4.4 – Volatility psscan'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – Volatility psscan'
- en: '](img/Figure_4.4_B17056.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B17056.jpg)'
- en: Figure 4.4 – Volatility psscan
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Volatility psscan
- en: As you can see, the information that's displayed is quite similar to the `pslist`
    result, but now, we have more information about the terminated processes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，显示的信息与`pslist`的结果非常相似，但现在我们可以获得更多关于已终止进程的信息。
- en: Now, we can search for programs that were running by the user when the dump
    was created or were recently terminated. However, what if we need to look even
    further and search for programs that terminated earlier?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以搜索在创建转储时由用户运行的程序或最近终止的程序。然而，如果我们需要进一步查找，并搜索那些较早终止的程序呢？
- en: In this case, Volatility has a `userassist` plugin, which retrieves information
    about the programs that the user frequently runs. This can also include programs
    that the user has recently worked with.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Volatility提供了一个`userassist`插件，它可以获取用户经常运行的程序的信息。它还包括用户最近操作过的程序。
- en: 'We can obtain such data as the application name, run count, and last run time
    of the applications that were launched via *Windows Explorer*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取这样的数据，如通过*Windows资源管理器*启动的应用程序的名称、运行次数以及最后一次运行的时间：
- en: '![Figure 4.5 – Volatility userassist'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – Volatility userassist'
- en: '](img/Figure_4.5_B17056.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B17056.jpg)'
- en: Figure 4.5 – Volatility userassist
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Volatility userassist
- en: First of all, after execution, you will be able to see information about specific
    locations where this information was found. For example, `\??\C:\Users\Ben\ntuser.dat`
    means that the shown subkeys and values are related to the user `Ben`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在执行后，你将能够看到关于信息所在具体位置的详细信息。例如，`\??\C:\Users\Ben\ntuser.dat`意味着显示的子键和值与用户`Ben`相关。
- en: 'The following screenshot shows separate entries related to each application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了与每个应用程序相关的独立条目：
- en: '![Figure 4.6 – Userassist entries'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – Userassist条目'
- en: '](img/Figure_4.6_B17056.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.6_B17056.jpg)'
- en: Figure 4.6 – Userassist entries
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – Userassist条目
- en: As you can see, `userassist` shows the full path to the executable, run count,
    time focused, and the date and time of the key update that is related to the last
    run time of the application. Here, you can find not only programs running at the
    moment of memory dump creation but also programs that were launched earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`userassist`显示了可执行文件的完整路径、运行次数、聚焦时间，以及与应用程序最后一次运行时间相关的键更新的日期和时间。在这里，你不仅可以找到内存转储创建时正在运行的程序，还可以找到之前启动的程序。
- en: 'Now, imagine that, in the list of running or recently completed processes,
    we have `WINWORD.exe` (such a process is created when you start MS Word):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设在正在运行或最近完成的进程列表中，我们有`WINWORD.exe`（当你启动MS Word时，会创建这样的进程）：
- en: '![Figure 4.7 – Active MS Word process'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 活跃的MS Word进程'
- en: '](img/Figure_4.7_B17056.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B17056.jpg)'
- en: Figure 4.7 – Active MS Word process
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 活跃的MS Word进程
- en: What document was opened there? Can we get this information from memory?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个文档在这里被打开了？我们能从内存中获取这些信息吗？
- en: Searching for opened documents
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找已打开的文档
- en: In some cases, you may want to understand if any Microsoft Office files or just
    text files were opened by corresponding applications. Why? They may contain passwords
    or some data that's valuable from an investigative perspective. Volatility has
    several plugins that allow you to work with files in memory. For example, the
    `filescan` plugin allows you to get information about all the files that were
    encountered in the memory dump, and `dumpfiles` allows you to try to extract these
    files (remember that some files may be unloaded at the time the dump is created).
    So, how do we find a file that's been opened in MS Word?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想了解是否有任何微软Office文件或只是文本文件被相应的应用程序打开。为什么？它们可能包含密码或一些从调查角度来看有价值的数据。Volatility有多个插件可以让你在内存中处理文件。例如，`filescan`插件可以让你获取内存转储中遇到的所有文件的信息，而`dumpfiles`插件则可以尝试提取这些文件（记住，有些文件在转储创建时可能已被卸载）。那么，我们如何找到在MS
    Word中打开的文件呢？
- en: Documents in process memory
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程内存中的文档
- en: If we pay attention to the `-p` option to run Volatility plugins only for this
    process. If we want to see what resources our process used, the `handles` plugin
    can help us. Let's use this with the `-p` option and the `-t` `File` option, which
    will help us display only those resources that are related to files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注意到`-p`选项，只对该进程运行Volatility插件。如果我们想查看我们的进程使用了哪些资源，`handles`插件可以帮助我们。让我们使用`-p`选项和`-t`
    `File`选项，它将帮助我们仅显示与文件相关的资源。
- en: '![Figure 4.8 – Volatility handles'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – Volatility 句柄'
- en: '](img/Figure_4.8_B17056.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B17056.jpg)'
- en: Figure 4.8 – Volatility handles
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – Volatility 句柄
- en: 'In the preceding screenshot, we can see that our process resources mention
    a file called `GOT-7_HR`. Let''s find the location of this file in memory. To
    do that, we need to run the `filescan` plugin and redirect its output to a text
    file, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到我们的进程资源提到了一个名为`GOT-7_HR`的文件。让我们来找出这个文件在内存中的位置。为此，我们需要运行`filescan`插件，并将其输出重定向到一个文本文件，如下所示：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the plugin finishes running, we can find a text file called `filescan.txt`
    that contains the following contents on the specified path:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件运行完成时，我们可以在指定路径下找到一个名为`filescan.txt`的文本文件，其中包含以下内容：
- en: '![Figure 4.9 – Volatility filescan output'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – Volatility filescan 输出'
- en: '](img/Figure_4.9_B17056.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B17056.jpg)'
- en: Figure 4.9 – Volatility filescan output
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – Volatility filescan 输出
- en: 'Here, we can see the physical offset where the file was found, some related
    attributes, and the full path to the file on disk. Let''s find our file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到文件被找到的物理偏移量，一些相关的属性，以及文件在磁盘上的完整路径。让我们来找找我们的文件：
- en: '![Figure 4.10 – File offset'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 文件偏移'
- en: '](img/Figure_4.10_B17056.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B17056.jpg)'
- en: Figure 4.10 – File offset
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 文件偏移
- en: We now know the physical offset of our file and can use the `dumpfiles` plugin
    to retrieve it from memory. Here, we will use the `-Q` option to specify the physical
    offset and the `-D` option for the path where we want to save our file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了文件的物理偏移量，并且可以使用`dumpfiles`插件从内存中提取它。这里，我们将使用`-Q`选项来指定物理偏移量，并使用`-D`选项来指定我们希望保存文件的路径。
- en: '![Figure 4.11 – Volatility dumpfiles'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 – Volatility dumpfiles'
- en: '](img/Figure_4.11_B17056.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B17056.jpg)'
- en: Figure 4.11 – Volatility dumpfiles
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – Volatility dumpfiles
- en: As you can see, our file was detected at this offset. Now, there are two new
    files in our `D:\user activity` folder called `file.None.0xfffffa80282a6b80.vacb`
    and `file.None.0xfffffa80258625f0.dat`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的文件在这个偏移位置被检测到。现在，`D:\user activity` 文件夹中出现了两个新文件，分别是 `file.None.0xfffffa80282a6b80.vacb`
    和 `file.None.0xfffffa80258625f0.dat`。
- en: 'File data extensions identify the object that the data was extracted from:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文件数据扩展名标识数据提取自的对象：
- en: '`dat`: DataSectionObject'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dat`：DataSectionObject'
- en: '`vacb`: ImageSectionObject'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vacb`：ImageSectionObject'
- en: '`img`: SharedCacheMap'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img`：SharedCacheMap'
- en: These files are containers where the file's content and data are stored. To
    get the original file, try to rename the container with its extension. By doing
    this, you can open the extracted file with a suitable tool and continue to analyze
    it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是容器，其中存储着文件的内容和数据。要获取原始文件，尝试使用其扩展名重命名容器。通过这种方式，你可以使用合适的工具打开提取的文件并继续分析。
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you export a file that you think is malicious, make sure that you do not
    run it on your work machine for analysis. It is better to work with such files
    in sandboxes or to process them with special tools, which we will discuss in the
    next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导出了一个你认为是恶意的文件，请确保不要在你的工作机器上运行它进行分析。最好在沙箱中处理此类文件，或使用专门的工具处理它们，我们将在下一章讨论这些工具。
- en: With that, the files have been taken care of, but what about the processes related
    to browsers?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已经处理完了，那么与浏览器相关的进程呢？
- en: Investigating browser history
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查浏览器历史记录
- en: Browsers can contain a lot of useful data. By analyzing the browser history,
    we can understand what sites the user visited, what search queries user performed,
    and what files were downloaded. Even if a private mode or a special browser (for
    example, *Tor Browser*) was used to surf the internet, we can still find useful
    information in memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中可能包含很多有用的数据。通过分析浏览器历史记录，我们可以了解用户访问了哪些网站、执行了哪些搜索查询以及下载了哪些文件。即使用户使用了隐私模式或特殊浏览器（例如
    *Tor Browser*）上网，我们仍然可以在内存中找到有用的信息。
- en: 'The following screenshot shows the output of the `pslist` plugin, where we
    can see several processes related to *Google Chrome*, *Mozilla Firefox*, and *Tor
    Browser*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 `pslist` 插件的输出，我们可以看到几个与*Google Chrome*、*Mozilla Firefox* 和 *Tor Browser*
    相关的进程：
- en: '![Figure 4.12 – Browser-related processes'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 浏览器相关进程'
- en: '](img/Figure_4.12_B17056.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B17056.jpg)'
- en: Figure 4.12 – Browser-related processes
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 浏览器相关进程
- en: 'So, how do you get information about the visited resources? There are several
    ways to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何获取访问过的资源信息呢？有几种方法可以做到这一点：
- en: Export the process memory and process it with the `Strings` utility ([https://docs.microsoft.com/en-us/sysinternals/downloads/strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)),
    which allows you to get the list of ASCII and Unicode symbols from various files.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出进程内存并使用 `Strings` 工具进行处理（[https://docs.microsoft.com/en-us/sysinternals/downloads/strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)），该工具允许你从各种文件中获取
    ASCII 和 Unicode 字符列表。
- en: Export the process memory and process it with `bulk_extractor` ([https://downloads.digitalcorpora.org/downloads/bulk_extractor/](https://downloads.digitalcorpora.org/downloads/bulk_extractor/)),
    which allows you to scan disk images, memory dumps, specific files, or directories
    and extract useful information.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出进程内存并使用 `bulk_extractor` 工具进行处理（[https://downloads.digitalcorpora.org/downloads/bulk_extractor/](https://downloads.digitalcorpora.org/downloads/bulk_extractor/)），该工具允许你扫描磁盘映像、内存转储、特定文件或目录并提取有用信息。
- en: Search for URLs using regular expressions or YARA rules.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式或 YARA 规则搜索 URL。
- en: We have three browsers and three options, so this looks like a good plan. Let's
    start with Google Chrome and the regular expression search.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个浏览器和三个选项，因此这个计划看起来不错。让我们从 Google Chrome 和正则表达式搜索开始。
- en: Chrome analysis with yarascan
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 yarascan 分析 Chrome
- en: '`Yarascan` is one of the Volatility plugins that allows you to search for some
    specific information using regular expressions or YARA rules.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yarascan` 是 Volatility 插件之一，允许你使用正则表达式或 YARA 规则搜索特定的信息。'
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: YARA was originally developed to help malware researchers with detecting and
    classifying malware samples. However, this tool is also applicable to memory forensics
    since it allows us to create search patterns using textual or binary data. For
    more information, see [https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html](https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: YARA 最初是为帮助恶意软件研究人员检测和分类恶意软件样本而开发的。然而，这个工具也适用于内存取证，因为它允许我们使用文本或二进制数据创建搜索模式。有关更多信息，请参阅
    [https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html](https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html)。
- en: 'To use `yarascan` with a YARA rule file, we need to provide a path to the `.yar`
    file with the `-Y` option. In our case, we will run it with the `-y` option and
    the `/(https?:\/\/)?([\w\.-]+)([\/\w \.-]*)/` regular expression. In addition,
    we will scan just one of the Chrome processes – the process with `ID 4236`, as
    shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `yarascan` 和 YARA 规则文件，我们需要提供 `.yar` 文件的路径，并使用 `-Y` 选项。在我们的案例中，我们将使用 `-y`
    选项，并使用 `/(https?:\/\/)?([\w\.-]+)([\/\w \.-]*)/` 正则表达式。此外，我们只扫描一个 Chrome 进程——`ID
    4236` 的进程，如下所示：
- en: '![Figure 4.13 – Volatility yarascan'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – Volatility yarascan'
- en: '](img/Figure_4.13_B17056.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B17056.jpg)'
- en: Figure 4.13 – Volatility yarascan
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – Volatility yarascan
- en: Here, you can see that we managed to find several links using this regular expression
    right away – these links are in the memory of the Google Chrome process with `ID
    4236`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们通过这个正则表达式直接找到了几个链接——这些链接存在于 `ID 4236` 的 Google Chrome 进程的内存中。
- en: Now that we've looked at Chrome, let's move on to Firefox.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过 Chrome，让我们继续分析 Firefox。
- en: Firefox analysis with bulk extractor
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 bulk extractor 进行 Firefox 分析
- en: Bulk extractor is a command-line tool that allows you to search for some specific
    information, such as URLs, emails, and PDF files in different sources. There is
    also **BEViewer**, a graphical interface for bulk extractor, but it requires additional
    installation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bulk extractor 是一个命令行工具，允许你在不同来源中搜索特定的信息，例如 URL、电子邮件和 PDF 文件。还有 **BEViewer**，这是一个用于
    bulk extractor 的图形界面，但需要额外安装。
- en: Before using this tool, we need to dump the memory of the Firefox process. The
    `memdump` plugin is great for this as all we need to add is the `-p` option, along
    with the ID of the required process, and the `-D` option, along with the folder
    where we want to save the dump. In our case, the ID is `6380` and the path is
    `.\user activity\firefox`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此工具之前，我们需要转储 Firefox 进程的内存。`memdump` 插件非常适合此任务，因为我们只需添加 `-p` 选项，并指定所需进程的
    ID，还需要添加 `-D` 选项，并指定保存转储的文件夹。在我们的案例中，ID 为 `6380`，路径为 `.\user activity\firefox`。
- en: When the plugin completes, a file with the process ID set to a name and the
    `.dmp` extension will appear in the specified directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件完成时，一个以进程 ID 为文件名并带有 `.dmp` 扩展名的文件将在指定的目录中出现。
- en: Now, we can launch our bulk extractor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动我们的 bulk extractor。
- en: '![Figure 4.14 – Volatility memdump and bulk extractor'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – Volatility memdump 和 bulk extractor'
- en: '](img/Figure_4.14_B17056.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B17056.jpg)'
- en: Figure 4.14 – Volatility memdump and bulk extractor
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – Volatility memdump 和 bulk extractor
- en: 'For bulk extractor, we used several options:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 bulk extractor，我们使用了几个选项：
- en: '`-o`: Provides an output directory'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`：提供输出目录'
- en: '`-x all`: Disables all scanners'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x all`：禁用所有扫描器'
- en: '`-e email`: Enables an email scanner that searches for emails and URLs'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e email`：启用电子邮件扫描器，搜索电子邮件和 URL'
- en: In the end, we need to provide a path to the file that we want to analyze.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要提供我们要分析的文件路径。
- en: Important note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: To see all bulk extractor scanners available for use, simply run `bulk_extractor.exe`
    without adding any options.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的 bulk extractor 扫描器，只需运行 `bulk_extractor.exe`，而不添加任何选项。
- en: 'As a result, several files will appear in the specified directory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，多个文件将出现在指定的目录中：
- en: '![Figure 4.15 – Bulk extractor''s output'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – Bulk extractor 的输出'
- en: '](img/Figure_4.15_B17056.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B17056.jpg)'
- en: Figure 4.15 – Bulk extractor's output
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – Bulk extractor 的输出
- en: 'In these files, we can find information about the emails and URLs that appeared
    in Firefox''s memory. For instance, we can look into `url_histogram.txt`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件中，我们可以找到有关在 Firefox 内存中出现的电子邮件和 URL 的信息。例如，我们可以查看 `url_histogram.txt` 文件：
- en: '![Figure 4.16 – URL histogram file''s content'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – URL 直方图文件内容'
- en: '](img/Figure_4.16_B17056.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B17056.jpg)'
- en: Figure 4.16 – URL histogram file's content
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – URL 直方图文件内容
- en: 'Alternatively, we can check the searches that were made via the Firefox browser
    in the `url_searches.txt` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以检查通过 Firefox 浏览器进行的搜索，查看 `url_searches.txt` 文件：
- en: '![Figure 4.17 – URL searches'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – URL 搜索'
- en: '](img/Figure_4.17_B17056.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B17056.jpg)'
- en: Figure 4.17 – URL searches
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – URL 搜索
- en: From this, we can see that our user was searching for Tor Browser.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到，用户正在搜索 Tor 浏览器。
- en: Now that we've looked at Chrome and Firefox, it is time for the most fun part.
    Let's try to analyze the Tor process with the `Strings` utility.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看过了 Chrome 和 Firefox，现在是时候进入最有趣的部分了。让我们尝试使用`Strings`工具分析 Tor 进程。
- en: Tor analysis with Strings
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Strings 工具分析 Tor
- en: Tor is a private browser that allows you to visit not only standard resources
    but also sites in the deep and dark webs, where some private and sometimes illegal
    sources are located. Hence, we just can't ignore this process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Tor 是一款私人浏览器，它不仅可以访问标准资源，还能访问深网和暗网中的网站，这些网站上有一些私人或有时是非法的资源。因此，我们不能忽视这个过程。
- en: For analysis, we will use the `Strings` utility, which is part of **Sysinternals
    Suite** and can be used to search for different characters in files. When analyzing
    private browsers such as Tor, this utility is very useful.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析时，我们将使用 `Strings` 工具，它是 **Sysinternals Suite** 的一部分，可以用来搜索文件中的不同字符。在分析像 Tor
    这样的私人浏览器时，这个工具非常有用。
- en: Before we start, we need to dump our Tor memory. We can use the previous technique
    to do so. Our `tor.exe` file has `ID 4708`, so we will use it with the `-p` option
    for the `memdump` plugin. Do not forget to add the `-D` option and provide a path
    to the location where you want to store the dump.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要转储 Tor 内存。我们可以使用之前的技术来进行。我们的 `tor.exe` 文件的 `ID` 是 4708，因此我们将使用 `-p`
    选项和 `memdump` 插件。不要忘记添加 `-D` 选项，并提供存储转储文件的路径。
- en: 'After creating the dump, we can run the `Strings` utility. For this, we must
    pass the path to our process dump as an argument and redirect the output to a
    text file, as we did previously. As a result, we get the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建转储文件后，我们可以运行 `Strings` 工具。为此，我们必须将进程转储的路径作为参数传递，并将输出重定向到文本文件中，正如我们之前所做的那样。结果将得到以下输出：
- en: '![Figure 4.18 – Volatility memdump and the Strings utility'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – Volatility memdump 和 Strings 工具'
- en: '](img/Figure_4.18_B17056.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B17056.jpg)'
- en: Figure 4.18 – Volatility memdump and the Strings utility
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – Volatility memdump 和 Strings 工具
- en: This option takes longer and the final file is harder to work with, but there
    is more data to find than with the standard URLs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项需要更长的时间，最终的文件也更难以处理，但可以找到比标准 URL 更多的数据。
- en: 'We end up with a text file that looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们得到的文本文件大致如下：
- en: '![Figure 4.19 – URLs in Tor memory'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – Tor 内存中的 URL'
- en: '](img/Figure_4.19_B17056.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B17056.jpg)'
- en: Figure 4.19 – URLs in Tor memory
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – Tor 内存中的 URL
- en: We can also use regular expressions or the usual keyword search to quickly find
    information of interest.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用正则表达式或常规关键词搜索，快速找到感兴趣的信息。
- en: With that, we've looked at the history of browsers and even touched on the subject
    of email analysis. Now, let's take things further and take a closer look at emails
    and messengers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经了解了浏览器的历史，甚至简要涉及了电子邮件分析的话题。现在，让我们更进一步，仔细看看电子邮件和即时通讯工具。
- en: Examining communication applications
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析通讯应用程序
- en: How often do you use communication apps to chat, send videos, or look at pictures
    of cute cats that have been sent to you? The answer is probably every day. Email
    and messengers have become an essential part of our lives, so we cannot avoid
    them. While examining the dump that's been taken from the victim's computer, we
    might come across a malicious document sent by email, and in the memory dump of
    the suspect's computer, we might find correspondence with accomplices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你多久使用一次通讯应用程序进行聊天、发送视频或查看你收到的可爱猫咪照片？答案可能是每天。电子邮件和即时通讯工具已经成为我们生活的必需品，因此我们无法避免它们。在分析受害者电脑的内存转储时，我们可能会发现通过电子邮件发送的恶意文档，而在嫌疑人电脑的内存转储中，可能会找到与同谋的通信记录。
- en: We have already talked about email, so we'll start there.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过电子邮件了，因此从这里开始。
- en: Email, email, email
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件，电子邮件，电子邮件
- en: 'Nowadays, there are many different email agents, and some people prefer to
    use a browser to check their mail. Thus, we can reduce the analysis to the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，有许多不同的电子邮件客户端，一些人更喜欢使用浏览器来查看邮件。因此，我们可以将分析简化为以下几点：
- en: If, in the list of running processes, we see a process related to the email
    agent, we can check the resources being used by the `handles` plugin and look
    for files that might be in the attachment.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在运行的进程列表中看到与电子邮件客户端相关的进程，我们可以使用 `handles` 插件检查该进程所使用的资源，并寻找可能是附件的文件。
- en: Also, if there is an active email agent process, we can extract its memory with
    the `memdump` plugin and process the dump file with the `Strings` utility. This
    will allow us to search not only for filenames in attachments but also for fragments
    of the emails themselves.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果有一个活跃的电子邮件客户端进程，我们可以使用`memdump`插件提取其内存，并使用`Strings`工具处理转储文件。这将使我们不仅能搜索附件中的文件名，还能查找电子邮件内容的片段。
- en: Run bulk extractor, as we did in the previous section, but now use it to analyze
    the entire memory dump. In this case, we will be able to collect information about
    all the emails and attachments, regardless of using an email agent or a browser.
    However, be careful as bulk extractor will take much longer to run than it did
    previously.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照前一节中的方法运行 bulk extractor，但这次用它来分析整个内存转储。在这种情况下，我们将能够收集所有电子邮件和附件的信息，无论是使用电子邮件客户端还是浏览器。不过，要小心，因为
    bulk extractor 运行的时间会比之前更长。
- en: 'Since all these methods have already been described in detail, we will take
    a look at just one of them: analysis with bulk extractor.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些方法已经有详细的描述，我们将只关注其中一种：使用 bulk extractor 进行分析。
- en: 'Since we will now use the whole dump for searching, we do not need to extract
    the memory of individual processes. The command for this will look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在将使用整个转储进行搜索，我们无需单独提取每个进程的内存。相应的命令如下所示：
- en: '![Figure 4.20 – Full memory dump analysis with bulk extractor'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – 使用 bulk extractor 的完整内存转储分析'
- en: '](img/Figure_4.20_B17056.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B17056.jpg)'
- en: Figure 4.20 – Full memory dump analysis with bulk extractor
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 使用 bulk extractor 的完整内存转储分析
- en: 'Now, we can check the `email_histogram.txt` file, which contains information
    about all the email addresses that appeared in memory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查`email_histogram.txt`文件，其中包含了所有在内存中出现的电子邮件地址的信息：
- en: '![Figure 4.21 – Email histogram'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – 电子邮件直方图'
- en: '](img/Figure_4.21_B17056.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B17056.jpg)'
- en: Figure 4.21 – Email histogram
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 电子邮件直方图
- en: 'We also can do a keyword search against the `url_histogram.txt` file to find
    information about mailboxes and attachments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`url_histogram.txt`文件中进行关键词搜索，以查找关于邮箱和附件的信息：
- en: '![Figure 4.22 – Email attachment in the URL histogram'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.22 – URL 直方图中的电子邮件附件'
- en: '](img/Figure_4.22_B17056.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B17056.jpg)'
- en: Figure 4.22 – Email attachment in the URL histogram
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – URL 直方图中的电子邮件附件
- en: Everything seems to be clear regarding emails, but what about messengers? How
    can we look into conversations and find something useful in them?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于电子邮件一切似乎都很清楚，但即时通讯软件呢？我们如何查看对话并从中找到有用的内容？
- en: Instant messengers
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时通讯软件
- en: 'When it comes to messengers, the easiest thing to use is a messenger memory
    analysis tool. Let''s look at our list of processes again:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 说到即时通讯软件，最简单的方法是使用即时通讯内存分析工具。我们再看看进程列表：
- en: '![Figure 4.23 – List of active processes'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.23 – 活跃进程列表'
- en: '](img/Figure_4.23_B17056.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B17056.jpg)'
- en: Figure 4.23 – List of active processes
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 活跃进程列表
- en: 'In the list of active processes, we can see a couple of well-known messengers,
    including *Telegram* and *Discord*. We can dump the memory of these processes
    and parse it with the `Strings` utility, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在活跃进程列表中，我们可以看到一些知名的即时通讯软件，包括*Telegram*和*Discord*。我们可以转储这些进程的内存，并使用`Strings`工具进行解析，如下图所示：
- en: '![Figure 4.24 – Telegram memory extraction and parsing'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.24 – Telegram 内存提取与解析'
- en: '](img/Figure_4.24_B17056.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B17056.jpg)'
- en: Figure 4.24 – Telegram memory extraction and parsing
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – Telegram 内存提取与解析
- en: 'In the output file, you can search for specific usernames, messages, URLs,
    or keywords:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出文件中，你可以搜索特定的用户名、消息、网址或关键词：
- en: '![Figure 4.25 – Message history in Telegram''s memory'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.25 – Telegram 内存中的消息历史'
- en: '](img/Figure_4.25_B17056.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B17056.jpg)'
- en: Figure 4.25 – Message history in Telegram's memory
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – Telegram 内存中的消息历史
- en: This is how we can get some insights into the instant messengers' memory. By
    the way, some people can use messengers and chats with themselves to share their
    passwords between several devices, so you can check for the appearance of passwords
    as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何获得即时通讯软件内存中的一些信息。顺便提一下，有些人可能会用即时通讯软件和自己聊天，在多个设备间共享密码，所以你也可以检查密码的出现情况。
- en: Recovering user passwords
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复用户密码
- en: 'Instant messengers are not the only location where we can search for passwords.
    We can find them in a cache, in the memory of text editors, buffers, command lines,
    or even some specific system processes. Volatility has several plugins to collect
    information about credentials:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即时消息并不是我们唯一可以搜索密码的位置。我们还可以在缓存中、文本编辑器的内存中、缓冲区、命令行中，甚至一些特定的系统进程中找到它们。Volatility有多个插件可以收集有关凭证的信息：
- en: '`hashdump`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashdump`'
- en: '`lsadump`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsadump`'
- en: '`cachedump`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cachedump`'
- en: Let's check them out, one by one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一一查看它们。
- en: Hashdump
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hashdump
- en: 'The `hashdump` plugin can be used to dump hashes of local user passwords on
    Windows systems before Windows 8\. The command will look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashdump`插件可以用于转储Windows 8之前的Windows系统上本地用户密码的哈希。命令如下所示：'
- en: '![Figure 4.26 – Volatility hashdump'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26 – Volatility hashdump'
- en: '](img/Figure_4.26_B17056.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B17056.jpg)'
- en: Figure 4.26 – Volatility hashdump
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 – Volatility hashdump
- en: In the output, you can see the account name, followed by the relative identifier
    and the LM and NT hashes. Notice that we have the same hashes for Administrator
    and Guest users. These specific hashes indicate blank passwords.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你可以看到账户名，接着是相对标识符、LM和NT哈希。请注意，我们在管理员和来宾用户上有相同的哈希值。这些特定的哈希值表示空密码。
- en: Another way to dump credentials is to use the `cachedump` plugin.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种转储凭证的方法是使用`cachedump`插件。
- en: Cachedump
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cachedump
- en: 'This plugin can be used to dump hashes of cached domain user passwords. By
    default, our system stores up to 10 of the most recent domain account credentials.
    We can try to access them with `cachedump`. Its execution is quite similar to
    that of `hashdump`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件可以用于转储缓存的域用户密码哈希。默认情况下，我们的系统会存储最多10个最新的域帐户凭证。我们可以尝试使用`cachedump`访问它们。其执行方式与`hashdump`非常相似：
- en: '![Figure 4.27 – Volatility cachedump'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27 – Volatility cachedump'
- en: '](img/Figure_4.27_B17056.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B17056.jpg)'
- en: Figure 4.27 – Volatility cachedump
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 – Volatility cachedump
- en: Here, you can see the domain username, followed by the password hash and the
    domain itself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到域用户名，接着是密码哈希和域名本身。
- en: Another thing that we can do is search for **Local Security Authority** (**LSA**)
    information.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我们可以做的事情是搜索**本地安全权限**（**LSA**）信息。
- en: Lsadump
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lsadump
- en: 'The LSA subsystem service is responsible for user authentication, so its analysis
    can help us obtain some useful information. Look at the following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: LSA子系统服务负责用户身份验证，因此其分析可以帮助我们获取一些有用的信息。请看以下示例：
- en: '![Figure 4.28 – Volatility lsadump'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28 – Volatility lsadump'
- en: '](img/Figure_4.28_B17056.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.28_B17056.jpg)'
- en: Figure 4.28 – Volatility lsadump
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 – Volatility lsadump
- en: Here, we can see information from different resources and for some of them,
    we can identify plaintext passwords. Other locations where plaintext passwords
    can be found are in the memory of text editor processes or the command lines of
    some specific tools, such as **PsExec**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到来自不同资源的信息，并且在其中一些资源中，我们能够识别出明文密码。明文密码的其他位置可以在文本编辑器进程的内存中，或一些特定工具的命令行中找到，例如**PsExec**。
- en: Plaintext passwords
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明文密码
- en: 'Since we have already learned how to extract and analyze process memory, let''s
    concentrate on the command line. Volatility has several plugins that allow us
    to retrieve command-line arguments. One such plugin is `cmdline`. It does not
    require any additional arguments:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了如何提取和分析进程内存，现在让我们集中精力分析命令行。Volatility有多个插件可以让我们检索命令行参数。其中一个插件是`cmdline`，它不需要任何额外的参数：
- en: '![Figure 4.29 – Volatility cmdline'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29 – Volatility cmdline'
- en: '](img/Figure_4.29_B17056.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.29_B17056.jpg)'
- en: Figure 4.29 – Volatility cmdline
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 – Volatility cmdline
- en: 'From the very beginning, we can see information about the start of the system
    processes and the command lines that have been used for this purpose. In the case
    of running programs that require the password to be transmitted in clear text,
    we will be able to find something similar to the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就可以看到关于系统进程启动的信息以及为此目的使用的命令行。在需要传输明文密码的程序运行情况下，我们将能够找到类似于以下内容的信息：
- en: '![Figure 4.30 – Plaintext password in the PsExec command line'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30 – PsExec命令行中的明文密码'
- en: '](img/Figure_4.30_B17056.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B17056.jpg)'
- en: Figure 4.30 – Plaintext password in the PsExec command line
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30 – PsExec命令行中的明文密码
- en: In this case, we can see that PsExec has been used to connect remotely to the
    **win7** host and that the max user password has been transmitted in plaintext.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到PsExec已被用来远程连接到**win7**主机，并且最大用户密码已以明文传输。
- en: Now, you have several ways to get the user's password information. But what
    about those who use encryption and crypto containers?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有几种方法可以获取用户的密码信息。但是，那些使用加密和加密容器的用户怎么办呢？
- en: Detecting crypto containers
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测加密容器
- en: 'There are several popular encryption tools for Windows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上有几种流行的加密工具：
- en: Bitlocker
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bitlocker
- en: TrueCrypt
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrueCrypt
- en: VeraCrypt
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VeraCrypt
- en: Although the implementation of these tools varies, they all serve the same purpose
    – to encrypt user data. For some, this may be an opportunity to keep their data
    private, while for others, it may be an opportunity for them to hide their illegitimate
    activity. For us, as investigators, it is important to understand that if the
    encrypted disk was used at the time of dumping, we may find cached volume passwords,
    master encryption keys, some parts of unencrypted files, or their exact location
    in memory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些工具的实现有所不同，但它们的目的是相同的——加密用户数据。对于某些人来说，这可能是保持数据私密的机会，而对其他人来说，这可能是隐藏非法活动的机会。对于我们这些调查人员来说，重要的是要理解，如果加密磁盘在转储时正在使用，我们可能会找到缓存的卷密码、主加密密钥、一些未加密文件的部分内容或它们在内存中的确切位置。
- en: 'The first step of our investigation here is to identify if there are any encryption
    tools and what data was encrypted. Sometimes, we will be able to easily identify
    the tool from the list of running processes, as shown in the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调查的第一步是确定是否存在任何加密工具以及哪些数据被加密。有时，我们可以轻松从正在运行的进程列表中识别该工具，正如以下截图所示：
- en: '![Figure 4.31 – VeraCrypt process'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.31 – VeraCrypt 进程'
- en: '](img/Figure_4.31_B17056.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B17056.jpg)'
- en: Figure 4.31 – VeraCrypt process
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – VeraCrypt 进程
- en: 'Unfortunately, Volatility does not provide a lot of functionality to work with
    different encryption solutions, but it has a nice set of plugins for TrueCrypt:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Volatility 提供的功能不足以与不同的加密解决方案配合使用，但它为 TrueCrypt 提供了一套很好的插件：
- en: '`truecryptmaster` searches for encryption master keys.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truecryptmaster` 搜索加密主密钥。'
- en: '`truecryptpassphrase` searches for the passphrase that was used.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truecryptpassphrase` 搜索所使用的密码短语。'
- en: '`truecryptsummary` collects TrueCrypt-related information.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truecryptsummary` 收集与 TrueCrypt 相关的信息。'
- en: The last plugin allows us to gather information about TrueCrypt processes, services,
    drivers, associated symbolic links, and file objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个插件允许我们收集关于 TrueCrypt 进程、服务、驱动程序、相关符号链接和文件对象的信息。
- en: '![Figure 4.32 – Volatility TrueCrypt summary'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.32 – Volatility TrueCrypt 总结'
- en: '](img/Figure_4.32_B17056.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.32_B17056.jpg)'
- en: Figure 4.32 – Volatility TrueCrypt summary
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – Volatility TrueCrypt 总结
- en: 'Here, we can see that one of the drives was encrypted with **TrueCrypt**, so
    we can try to extract the master key from memory:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到其中一个驱动器被**TrueCrypt**加密了，因此我们可以尝试从内存中提取主密钥：
- en: '![Figure 4.33 – Volatility TrueCrypt master key'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.33 – Volatility TrueCrypt 主密钥'
- en: '](img/Figure_4.33_B17056.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.33_B17056.jpg)'
- en: Figure 4.33 – Volatility TrueCrypt master key
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – Volatility TrueCrypt 主密钥
- en: 'By default, TrueCrypt and some other tools use AES for encryption. That is
    why an alternative way to get the encryption master key is to use any tool with
    AES detection functionality. We have already discussed such a tool: one of the
    bulk extractor scanners can be used for this purpose. Let''s run aes scanner:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TrueCrypt 和一些其他工具使用 AES 进行加密。这就是为什么获取加密主密钥的另一种方式是使用任何具有 AES 检测功能的工具。我们已经讨论过这样一个工具：可以使用其中一个批量提取器扫描器来实现这一目的。让我们运行
    AES 扫描器：
- en: '![Figure 4.34 – Bulk extractor AES scanner'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.34 – 批量提取器 AES 扫描器'
- en: '](img/Figure_4.34_B17056.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.34_B17056.jpg)'
- en: Figure 4.34 – Bulk extractor AES scanner
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34 – 批量提取器 AES 扫描器
- en: 'As result, we will get a text file called `aes_keys.txt`. The content of this
    file looks as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们将得到一个名为 `aes_keys.txt` 的文本文件。该文件的内容如下所示：
- en: '![Figure 4.35 – Extracted AES keys'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.35 – 提取的 AES 密钥'
- en: '](img/Figure_4.35_B17056.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.35_B17056.jpg)'
- en: Figure 4.35 – Extracted AES keys
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.35 – 提取的 AES 密钥
- en: Here, we found several couples of `AES256` keys. By combining these couples
    of 256-bit keys, we can obtain our 512-bit master key.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现了几对 `AES256` 密钥。通过将这些 256 位密钥对结合起来，我们可以获得 512 位的主密钥。
- en: This process is not very easy, which is why some forensic software developers
    included key extraction functionality in their solutions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程并不容易，这也是一些取证软件开发人员在他们的解决方案中包含密钥提取功能的原因。
- en: Passware is one of the most popular solutions to search for encrypted files,
    decrypt encrypted drives, and recover Windows passwords and passwords stored in
    Password Managers. This tool supports most of the solutions for full-disk encryption,
    including **BitLocker**, **TrueCrypt**, and **PGP**.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Passware是最流行的工具之一，用于搜索加密文件、解密加密驱动器以及恢复Windows密码和存储在密码管理器中的密码。此工具支持大多数全盘加密解决方案，包括**BitLocker**、**TrueCrypt**和**PGP**。
- en: '![Figure 4.36 – Passware'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.36 – Passware'
- en: '](img/Figure_4.36_B17056.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.36_B17056.jpg)'
- en: Figure 4.36 – Passware
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.36 – Passware
- en: 'If you want to try this tool, you can request a demo version from their official
    web page: [https://www.passware.com/kit-forensic/](https://www.passware.com/kit-forensic/).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试这个工具，可以从他们的官方网站申请一个演示版：[https://www.passware.com/kit-forensic/](https://www.passware.com/kit-forensic/)。
- en: We have already discussed how to find launched programs and opened documents,
    how to recover passwords, and how to detect encrypted drives. However, there is
    one important thing that was left behind – Windows Registry.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何查找已启动的程序和打开的文档，如何恢复密码以及如何检测加密驱动器。然而，还有一件重要的事情被忽视了——Windows注册表。
- en: Investigating Windows Registry
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查Windows注册表
- en: Information about the programs that are frequently run by the user, recently
    opened documents, outgoing RDP connections, and much more is written in the computer's
    registry, and we always have the most recent version of it in our memory. To avoid
    confusion, we need to understand how the registry works in Windows.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户常用的程序、最近打开的文档、外发的RDP连接等信息都被写入计算机的注册表中，我们总是能在内存中找到它们的最新版本。为了避免混淆，我们需要理解注册表在Windows中的工作原理。
- en: Virtual registry
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟注册表
- en: To work properly, your computer needs to store information about hardware and
    software configurations, data about all the system users, information about each
    user's settings, and much, much more. When our system starts up, it collects this
    information from the hardware and registry files stored in non-volatile memory
    and creates a virtual registry in memory. This virtual registry is where the current
    configurations are stored, and where all the changes that will be transferred
    to the files and written to disk will be stored in the first place. The process
    of interacting with the registry is ongoing, so we can always find the hives of
    the virtual registry and associated files in the memory dumps.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，你的计算机需要存储关于硬件和软件配置的信息、所有系统用户的数据、每个用户的设置，以及更多信息。当我们的系统启动时，它会从硬件和存储在非易失性内存中的注册表文件中收集这些信息，并在内存中创建一个虚拟注册表。这个虚拟注册表是当前配置存储的地方，也是所有将被写入磁盘的更改的初始存储位置。与注册表的交互过程是持续进行的，因此我们总是能够在内存转储中找到虚拟注册表的蜂巢和相关文件。
- en: 'Most of the time, we have to work with several files:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们需要处理多个文件：
- en: '`SAM` contains information about groups and users, including their privileges,
    passwords, and last login date.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAM`包含关于组和用户的信息，包括他们的权限、密码和最后登录日期。'
- en: '`SYSTEM` contains OS-related information such as the computer''s name, services,
    connected USB devices, time zone information, and network adapter configuration.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSTEM`包含操作系统相关的信息，例如计算机的名称、服务、连接的USB设备、时区信息和网络适配器配置。'
- en: '`SOFTWARE` contains information about installed software, scheduled tasks,
    autorun, and application backward compatibility.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOFTWARE`包含已安装软件、计划任务、自动启动和应用程序的向后兼容性信息。'
- en: '`NTUSER.DAT` contains information related to a particular user: last viewed
    documents, frequently run programs, explorer history, and outgoing RDP connections.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NTUSER.DAT`包含与特定用户相关的信息：最后查看的文档、常用的程序、资源管理器历史记录以及外发的RDP连接。'
- en: Remember the `userassist` plugin? It takes information from the registry – to
    be more exact, from the `NTUSER.DAT` file. Both `hashdump` and `cachedump` also
    use the registry.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得`userassist`插件吗？它从注册表中提取信息——更确切地说，是从`NTUSER.DAT`文件中提取。`hashdump`和`cachedump`也使用注册表。
- en: Let's see how we can work with the registry files in memory.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在内存中处理注册表文件。
- en: Important note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are not going to cover the details of Windows Registry forensics as this
    topic requires in-depth studying. However, we will break down the main keys required
    for our purposes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讲解Windows注册表取证的细节，因为这个主题需要深入研究。然而，我们将拆解出为实现目的所需的主要键。
- en: 'Volatility provides several plugins for general work with the registry:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Volatility提供了几个插件用于一般的注册表工作：
- en: '`Printkey` shows registry keys, their subkeys, and their values.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Printkey` 显示注册表键、它们的子键及其值。'
- en: '`hivelist` lists accessible registry hives.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hivelist` 列出了可访问的注册表 hive。'
- en: '`dumpregistry` allows us to extract registry files from memory.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpregistry` 允许我们从内存中提取注册表文件。'
- en: 'Several plugins also take out the values of certain keys:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些插件还提取了某些键的值：
- en: '`userassist`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userassist`'
- en: '`shutdowntime`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdowntime`'
- en: '`shellbags`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shellbags`'
- en: All of these plugins display the values of the keys with the same name after
    launching them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些插件在启动后都会显示具有相同名称的键的值。
- en: However, working with the registry in this way is not always convenient. In
    addition, they are not adapted to work with newer versions of Windows 10\. What
    should we do if we need to analyze a fresh build? There is an excellent tool that
    allows you to view physical memory as files in a virtual filesystem. It is called
    **MemProcFS**.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种方式处理注册表并不总是方便。此外，它们并不适应与更新版本的 Windows 10 一起使用。如果我们需要分析一个新的构建版本，应该怎么办呢？有一个很棒的工具，可以让你将物理内存作为虚拟文件系统中的文件查看。它叫做
    **MemProcFS**。
- en: Installing MemProcFS
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 MemProcFS
- en: 'Take a look at this link to learn about the installation process for MemProcFS:
    [https://github.com/ufrisk/MemProcFS/blob/master/README.md](https://github.com/ufrisk/MemProcFS/blob/master/README.md).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个链接，了解 MemProcFS 的安装过程：[https://github.com/ufrisk/MemProcFS/blob/master/README.md](https://github.com/ufrisk/MemProcFS/blob/master/README.md)。
- en: 'This tool has several dependencies. First, you need to install `LeechCore`.
    To do so, you need to execute the following command in PowerShell:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具有多个依赖项。首先，你需要安装 `LeechCore`。为此，你需要在 PowerShell 中执行以下命令：
- en: '![Figure 4.37 – Installing LeechCore'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.37 – 安装 LeechCore'
- en: '](img/Figure_4.37_B17056.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.37_B17056.jpg)'
- en: Figure 4.37 – Installing LeechCore
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.37 – 安装 LeechCore
- en: 'The next step is to install Microsoft Visual C++ Redistributables for Visual
    Studio 2019\. You can get the installer from [https://go.microsoft.com/fwlink/?LinkId=746572](https://go.microsoft.com/fwlink/?LinkId=746572).
    Now, you must install `DokanSetup_redist` version. The last thing you need is
    *Python 3.6* or later. You can get a suitable version of Python from the official
    web page: [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装 Microsoft Visual Studio 2019 的 Visual C++ 可再分发组件。你可以从 [https://go.microsoft.com/fwlink/?LinkId=746572](https://go.microsoft.com/fwlink/?LinkId=746572)
    获取安装程序。接下来，你需要安装 `DokanSetup_redist` 版本。你所需要的最后一个组件是 *Python 3.6* 或更高版本。你可以从官方网页获取适合的
    Python 版本：[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)。
- en: Congratulations – you are now ready to download MemProcFS! Go to the MemProcFS
    GitHub repository at [https://github.com/ufrisk/MemProcFS](https://github.com/ufrisk/MemProcFS)
    and search for the latest releases.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜 – 你现在已经准备好下载 MemProcFS！前往 MemProcFS 的 GitHub 仓库 [https://github.com/ufrisk/MemProcFS](https://github.com/ufrisk/MemProcFS)，并搜索最新版本。
- en: '![Figure 4.38 – MemProcFS GitHub repository'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.38 – MemProcFS GitHub 仓库'
- en: '](img/Figure_4.38_B17056.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.38_B17056.jpg)'
- en: Figure 4.38 – MemProcFS GitHub repository
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.38 – MemProcFS GitHub 仓库
- en: Download the files_and_binaries ZIP archive and unzip it to a suitable location.
    To run `MemProcFS`, open PowerShell and move to the folder where you have unzipped
    the files. Run the following command to create a virtual filesystem from your
    memory dump (use the `-device` option to provide the location of your memory dump).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 `files_and_binaries` ZIP 压缩包并解压到合适的位置。要运行 `MemProcFS`，打开 PowerShell 并进入你解压文件的文件夹。运行以下命令以从你的内存转储创建一个虚拟文件系统（使用
    `-device` 选项提供你的内存转储位置）。
- en: '![Figure 4.39 – MemProcFS execution'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.39 – MemProcFS 执行'
- en: '](img/Figure_4.39_B17056.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.39_B17056.jpg)'
- en: Figure 4.39 – MemProcFS execution
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – MemProcFS 执行
- en: As you can see, our operating system was recognized and the dump was successfully
    mounted on the `M:\` drive. Now, we can open this drive via Explorer and search
    for something interesting.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的操作系统已被识别，转储成功地挂载在 `M:\` 驱动器上。现在，我们可以通过资源管理器打开这个驱动器，并搜索一些有趣的内容。
- en: Working with Windows Registry
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Windows 注册表的工作
- en: We decided to tell you about this tool for a reason. The point is that by using
    MemProcFS, you can easily extract all registry files from memory. (Honestly, you
    do not even need to extract anything.) Open your drive (in our case, it is the
    `M:\` drive) and go to `registry` > `hive_files`, as shown in the following screenshot.
    Here, you will find all the registry files that are available in our dump.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定告诉你这个工具的原因。因为使用 MemProcFS，你可以轻松地从内存中提取所有的注册表文件。（老实说，你甚至不需要提取任何东西。）打开你的驱动器（在我们的例子中是`M:\`驱动器），进入`registry`
    > `hive_files`，如下图所示。在这里，你将找到我们在转储中所有可用的注册表文件。
- en: '![Figure 4.40 – MemProcFS Hive files'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.40 – MemProcFS Hive 文件'
- en: '](img/Figure_4.40_B17056.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.40_B17056.jpg)'
- en: Figure 4.40 – MemProcFS Hive files
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.40 – MemProcFS Hive 文件
- en: So, we found the registry, but what should we do next? There are several options
    here. First, you can use *Eric Zimmerman's Registry Explorer* tool. The latest
    version can be downloaded from the official repository at [https://ericzimmerman.github.io/#!index.md](https://ericzimmerman.github.io/#!index.md).
    The archive that contains the tool must be unpacked with 7-Zip; otherwise, the
    tool will not work properly. Registry Explorer allows you to view various keys
    and values in their original form and use prepared bookmarks that contain useful
    information.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们找到了注册表，但接下来该做什么呢？这里有几种选择。首先，你可以使用*Eric Zimmerman 的 Registry Explorer* 工具。最新版可以从官方仓库下载：[https://ericzimmerman.github.io/#!index.md](https://ericzimmerman.github.io/#!index.md)。包含工具的压缩包必须用7-Zip解压，否则工具将无法正常工作。Registry
    Explorer 允许你查看各种键值，并使用包含有用信息的预设书签。
- en: '![Figure 4.41 – Registry Explorer'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.41 – 注册表查看器'
- en: '](img/Figure_4.41_B17056.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.41_B17056.jpg)'
- en: Figure 4.41 – Registry Explorer
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.41 – 注册表查看器
- en: 'On the other hand, you can parse these files with *RegRipper*. By doing this,
    all the information will be available to you as a single text file. This tool
    can be downloaded from the following GitHub repository: [https://github.com/keydet89/RegRipper3.0](https://github.com/keydet89/RegRipper3.0).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你也可以使用*RegRipper*来解析这些文件。这样，所有信息都会作为一个单一的文本文件提供给你。你可以从以下 GitHub 仓库下载这个工具：[https://github.com/keydet89/RegRipper3.0](https://github.com/keydet89/RegRipper3.0)。
- en: To run the GUI tool, you need to use the `rr.exe` file. In the window that appears,
    you need to specify the path to the file you want to process and the path to the
    text file where you want to save the result of the execution. Once all the fields
    have been filled in, you need to click the `ntuser` from our `hive_files` folder,
    copy it to a convenient location, and try to analyze it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行图形界面工具，你需要使用`rr.exe`文件。在出现的窗口中，你需要指定要处理的文件路径和保存执行结果的文本文件路径。填写完所有字段后，点击`ntuser`文件夹中的文件，从我们的`hive_files`文件夹中复制它到方便的位置，然后尝试分析它。
- en: '![Figure 4.42 – RegRipper'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.42 – RegRipper'
- en: '](img/Figure_4.42_B17056.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.42_B17056.jpg)'
- en: Figure 4.42 – RegRipper
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.42 – RegRipper
- en: As a result, you will get two text files. The first one, with the`.log` extension,
    is the log of the program. The second one, with the`.txt` extension, contains
    the parsing results. You can open it in any text editor and use a keyword search.
    For example, to find programs run by a user, you can search for `userassist`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，你将得到两个文本文件。第一个文件，带有`.log`扩展名，是程序的日志。第二个文件，带有`.txt`扩展名，包含了解析结果。你可以在任何文本编辑器中打开它并使用关键词搜索。例如，要查找用户运行的程序，你可以搜索`userassist`。
- en: '![Figure 4.43 – Userassist registry key'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.43 – Userassist 注册表键'
- en: '](img/Figure_4.43_B17056.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.43_B17056.jpg)'
- en: Figure 4.43 – Userassist registry key
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43 – Userassist 注册表键
- en: If you want to see what documents the user has recently worked with, look for
    `opensave` or `recentdocs`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看用户最近处理的文档，可以查找`opensave`或`recentdocs`。
- en: '![Figure 4.44 – RecentDocs registry key'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.44 – RecentDocs 注册表键'
- en: '](img/Figure_4.44_B17056.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.44_B17056.jpg)'
- en: Figure 4.44 – RecentDocs registry key
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.44 – RecentDocs 注册表键
- en: 'Finally, if you want to see what directories were visited by a user on a local
    or remote host, download *ShellbagsExplorer* from the respective GitHub repository
    (https://ericzimmerman.github.io/#!index.md). Find the `usrclass` registry file
    in the `hive_files` folder and drop it into the running tool. You should get the
    following output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想查看用户在本地或远程主机上访问过的目录，可以从相应的 GitHub 仓库下载*ShellbagsExplorer*（https://ericzimmerman.github.io/#!index.md）。找到`usrclass`注册表文件并将其拖入运行中的工具中。你应该能看到如下输出：
- en: '![Figure 4.45 – ShellBags Explorer'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.45 – ShellBags Explorer'
- en: '](img/Figure_4.45_B17056.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.45_B17056.jpg)'
- en: Figure 4.45 – ShellBags Explorer
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.45 – ShellBags Explorer
- en: Note that this file is derived from the memory dump, where we found traces of
    the S drive encrypted by TrueCrypt. Thanks to our analysis of the `usrclass` file,
    we can see some of the contents of the encrypted disk.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件是从内存转储中提取的，我们在其中发现了由TrueCrypt加密的S盘的痕迹。通过分析`usrclass`文件，我们能够看到加密磁盘的一部分内容。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Analyzing user activity is a very important part of investigating memory. In
    this chapter, you learned that you can recover a lot of artifacts. This can be
    extremely valuable in criminal investigations as such artifacts can help you reconstruct
    a user's activity, even if they used anonymous web browsers or secure messengers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 分析用户活动是内存调查中的一个非常重要的部分。在本章中，你学到了可以恢复很多痕迹。这对于刑事调查尤为重要，因为这些痕迹能帮助你重建用户活动，即使他们使用了匿名浏览器或安全通讯工具。
- en: Volatility is a great tool for memory dump analysis, but do not get hung up
    on it. Do not be afraid to use additional tools or alternative solutions in situations
    where you need to.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 波动性是内存转储分析的一个重要工具，但不要因此而停滞不前。在需要时，千万不要害怕使用额外的工具或替代解决方案。
- en: Despite the abundance of information in process memory, do not forget about
    the virtual registry, which stores a lot of useful information, including that
    related to user activity. Additionally, some registry keys can tell us a lot about
    malware activity and persistence traces. We will discuss these and other traces
    of malicious activity in the next chapter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进程内存中信息丰富，但不要忽视虚拟注册表，它存储了大量有用的信息，包括与用户活动相关的信息。此外，一些注册表键值能够告诉我们很多关于恶意软件活动和持久性痕迹的信息。我们将在下一章讨论这些及其他恶意活动的痕迹。
