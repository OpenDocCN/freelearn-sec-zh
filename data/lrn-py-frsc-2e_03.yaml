- en: Parsing Text Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析文本文件
- en: Text files, usually sourced from application or service logs, are common sources
    for artifacts in digital investigations. Log files can be quite large or contain
    data that makes human review difficult. A manual examination can devolve into
    a series of grep searches, which may or may not be fruitful; additionally, prebuilt
    tools may not have support for a specific log file format. For these instances,
    we will need to develop our own solution to properly parse and extract the relevant
    information. In this chapter, we will analyze the `setupapi.dev.log` file, which
    records device information on Windows machines. This log file is commonly examined,
    as it can extract the first connection time of USB devices on the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件，通常来自应用程序或服务日志，是数字调查中常见的证据来源。日志文件可能非常大，或者包含难以人工检查的数据。手动检查可能会变成一系列的 grep
    搜索，结果可能会有或没有成效；此外，预构建的工具可能不支持特定的日志文件格式。在这些情况下，我们需要开发自己的解决方案，正确解析并提取相关信息。在本章中，我们将分析
    `setupapi.dev.log` 文件，该文件记录了 Windows 机器上的设备信息。由于该日志文件能够提取系统中 USB 设备的首次连接时间，因此它通常会被检查。
- en: We will step through several iterations of the same code through this chapter.
    Though redundant, we encourage writing out each iteration for yourself. By rewriting
    the code, we will progress through the material together and find a more fitting
    solution, learn about bug handling, and implement efficiency measures. Please
    rewrite the code for yourself and test each iteration to see the changes in the
    output and code handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步讲解相同代码的几个迭代版本。尽管可能显得有些冗余，但我们鼓励你为自己编写每个版本的代码。通过重写代码，我们将一起推进学习，找到更合适的解决方案，学习如何处理
    bugs，并实现效率提升。请为自己重写代码并测试每个迭代版本，以查看输出和代码处理的变化。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Identifying repetitive patterns in this log file for USB device entries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别日志文件中 USB 设备条目的重复模式
- en: Extracting and processing artifacts from text files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本文件中提取和处理证据
- en: Iteratively improving our script design and features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代改进我们的脚本设计和功能
- en: Enhancing the presentation of data in a deduplicated and readable manner
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以去重且易读的方式增强数据展示
- en: The code for this chapter is developed and tested using Python 2.7.15 and Python
    3.7.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码是在 Python 2.7.15 和 Python 3.7.1 环境下开发和测试的。
- en: Setup API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 API
- en: The `setupapi.dev.log` file is a Windows log file that tracks connection information
    for a variety of devices, including USB devices. Since USB device information
    generally plays an important role in many investigations, our script will help
    identify the earliest installation time of a USB device on a machine. This log
    is system-wide, not user-specific, and therefore provides only the installation
    time of a USB device's first connection to the system. In addition to logging
    this timestamp, the log contains the **vendor ID** (**VID**), **product ID** (**PID**),
    and the serial number of the device. With this information, we can paint a better
    picture of removable storage activity. On Windows XP, this file can be found at
    `C:\Windows\setupapi.log`; on Windows 7 through 10, this file can be found at
    `C:\Windows\inf\setupapi.dev.log`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupapi.dev.log` 文件是一个 Windows 日志文件，用于跟踪各种设备的连接信息，包括 USB 设备。由于 USB 设备信息在许多调查中通常扮演重要角色，我们的脚本将帮助识别机器上
    USB 设备的最早安装时间。这个日志是全系统范围的，而不是用户特定的，因此仅提供 USB 设备首次连接系统的安装时间。除了记录这个时间戳外，日志还包含 **供应商
    ID** (**VID**)、**产品 ID** (**PID**) 以及设备的序列号。有了这些信息，我们可以更好地了解可移动存储设备的活动。在 Windows
    XP 上，这个文件可以在 `C:\Windows\setupapi.log` 找到；在 Windows 7 到 10 上，这个文件可以在 `C:\Windows\inf\setupapi.dev.log`
    找到。'
- en: Introducing our script
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的脚本
- en: In this section, we will build our `setupapi_parser.py` to parse the `setupapi.dev.log`
    file on Windows 7\. Equipped with only modules from the standard library, we will
    open and read a `setupapi.log` file, identify and parse relevant USB information,
    and display it to the user in the console. As mentioned in the introduction, we
    will use an iterative build process to mimic a natural development cycle. Each
    iteration will build upon the previous while we explore new features and methods.
    We encourage the development of additional iterations, and there are challenges
    at the end of this chapter to compliment this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将构建 `setupapi_parser.py`，以解析 Windows 7 中的 `setupapi.dev.log` 文件。仅使用标准库中的模块，我们将打开并读取一个
    `setupapi.log` 文件，识别并解析相关的 USB 信息，并将其显示在控制台中。正如在介绍中所提到的，我们将使用迭代构建过程来模拟自然的开发周期。每次迭代都会在前一次的基础上进行改进，同时我们探索新的功能和方法。我们鼓励开发额外的迭代，章节结尾处有挑战内容供读者尝试。
- en: Overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Before developing any code, let''s identify the requirements and features our
    script must possess to accomplish the desired task. We will need to execute the
    following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何代码之前，让我们先识别出我们的脚本必须具备的需求和功能，以完成预期任务。我们需要执行以下步骤：
- en: Open the log file and read all lines
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开日志文件并读取所有行
- en: In each line, check for indicators of a USB device entry
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一行中，检查是否有 USB 设备条目的指示符
- en: Parse responsive lines for timestamp and device information
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析响应行中的时间戳和设备信息
- en: Output the result to the user
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果输出给用户
- en: 'Now, let''s examine the log file of interest to determine repetitive structures
    that we can use as footholds in our script to parse the relevant data. In the
    following sample USB entry, we can see the device information on line 1 following
    the text `Device Install (Hardware initiated)`. This device information contains
    the VID, PID, device revision, and the unique ID of the device. Each of these
    elements is separated by either a `&` or `_` character and may contain some additional
    inconsequential characters. The installation time is recorded on line 2, following
    the `Section start` text. For our purposes, we are only interested in these two
    lines. All other surrounding lines will be ignored, as they relate to operating
    system driver information:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查感兴趣的日志文件，以确定我们可以在脚本中用作切入点的重复结构，以便解析相关数据。在以下示例的 USB 条目中，我们可以看到在文本 `Device
    Install (Hardware initiated)` 后，第 1 行包含设备信息。该设备信息包含 VID、PID、设备版本以及设备的唯一 ID。每个元素之间由
    `&` 或 `_` 字符分隔，并且可能包含一些额外的无关字符。安装时间记录在第 2 行，在 `Section start` 文本后。对于我们的目的，我们只关心这两行。所有其他的周围行将被忽略，因为它们与操作系统驱动程序信息相关：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our first iteration – setupapi_parser_v1.py
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一次迭代 – setupapi_parser_v1.py
- en: 'The goal of our first iteration is to develop a functional prototype that we
    will improve upon in later iterations. We will continue to see the following code
    block in all our scripts, which provides basic documentation about the script
    and support for printing information (line 2) and opening files (line 3) in both
    version 2 and 3 of Python. The following is the licensing information and basic
    script descriptors that can be found in all of our scripts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次迭代的目标是开发一个功能原型，在后续的迭代中对其进行改进。在所有脚本中，我们将继续看到以下代码块，它提供了有关脚本的基本文档，以及在 Python
    2 和 3 版本中打印信息（第 2 行）和打开文件（第 3 行）的支持。以下是所有脚本中可以找到的许可信息和基本脚本描述符：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our script involves three functions, which are outlined as follows. The `main()`
    function kicks off the script by calling the `parse_setupapi()` function. This
    function reads the `setupapi.dev.log` file and extracts the USB device and first
    installation date information. After processing, the `print_output()` function
    is called with the extracted information. The `print_output()` function takes
    the extracted information and prints it to the user in the console. These three
    functions work together to allow us to segment our code based on operations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本包含三个功能，具体如下。`main()` 函数通过调用 `parse_setupapi()` 函数启动脚本。此函数读取 `setupapi.dev.log`
    文件，并提取 USB 设备和首次安装日期的信息。处理完成后，调用 `print_output()` 函数，将提取的信息打印到控制台上。`print_output()`
    函数接收提取的信息，并将其打印给用户。这三个函数共同协作，使我们能够根据操作将代码分段：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run this script, we need to provide some code that calls the `main()` function.
    The following code block shows a Python feature that we will use in almost every
    one of our scripts throughout this book. This section of code will become more
    complex throughout this chapter, as we will be adding the ability to allow users
    to control input, output, and provide optional arguments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个脚本，我们需要提供一些代码来调用`main()`函数。以下代码块展示了一个Python特性，我们将在本书中的几乎每个脚本中使用。随着本章的进行，这部分代码将变得更加复杂，因为我们将添加允许用户控制输入、输出并提供可选参数的功能：
- en: 'Line 82 is simply an `if` statement that checks to see if this script is called
    from the command line. In more detail, the `__name__` attribute allows Python
    to tell us what function called the code. When `__name__` is equivalent to the
    `__main__` string, it indicates that it is the top-level script, and is therefore
    likely to be executed at the command line. This feature is especially important
    when designing code that may be called by another script. Someone else may import
    your functions into their code, and without this condition, it will likely result
    in our script immediately running when imported. We have the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第82行只是一个`if`语句，用来检查脚本是否是从命令行调用的。更详细地说，`__name__`属性允许Python告诉我们是哪个函数调用了这段代码。当`__name__`等于`__main__`字符串时，表示它是顶级脚本，因此很可能是在命令行执行。这个功能在设计可能被其他脚本调用的代码时尤其重要。其他人可能会将你的函数导入到他们的代码中，如果没有这个条件，脚本在导入时很可能会立即执行。我们有如下代码：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see in the following flowchart, the trunk function (our script as
    a whole) calls the `main()` function, which in turn calls `parse_setupapi()`,
    which finally calls the `print_output()` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，主函数（我们整个脚本）调用`main()`函数，而`main()`函数又调用`parse_setupapi()`，最后调用`print_output()`函数：
- en: '![](img/7f8802db-8038-41d3-9d2e-1100d3445b8b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f8802db-8038-41d3-9d2e-1100d3445b8b.png)'
- en: Designing the main() function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计`main()`函数
- en: 'The `main()` function, defined on line 39, is fairly straightforward in this
    scenario. This function handles initial variable assignments and setup before
    calling `parse_setup()`. In the following code block, we create a docstring, surrounded
    with three double quotes where we document the purpose of the function, along
    with the data returned by it, as shown on lines 40 through 43\. Pretty sparse,
    right? We''ll enhance our documentation as we proceed as things might change drastically
    this early in development:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第39行定义的`main()`函数在这个场景下相当简单。这个函数在调用`parse_setup()`之前处理初始变量赋值和设置。在接下来的代码块中，我们创建一个文档字符串，使用三个双引号括起来，其中记录了函数的目的以及它返回的数据，如第40到43行所示。看起来很简洁吧？随着开发的进行，我们会逐步增强文档，因为在开发初期，事情可能会发生剧烈变化：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the docstring, we hardcode the path to the `setupapi.dev.log` file on
    line 45\. This means that our script can only function correctly if a log file
    with this name is located in the same directory as our script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串之后，我们在第45行硬编码了`setupapi.dev.log`文件的路径。这意味着我们的脚本只有在与脚本位于同一目录下存在这个名称的日志文件时才能正常工作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On lines 48 through 50, we print our script information, including name and
    version, to the console, which notifies the user that the script is running. In
    addition, we print out 22 equal signs to provide a visual distinction between
    the setup information and any other output from the script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第48到50行，我们将脚本信息（包括名称和版本）打印到控制台，通知用户脚本正在运行。此外，我们还打印出22个等号，用以在设置信息和脚本的其他输出之间提供视觉上的区分：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, on line 51, we call our next function to parse the input file. This
    function expects a `str` object that represents the path to the `setupapi.dev.log`.
    Though it may seem to defeat the purpose of a `main()` function, we will place
    the majority of the functionality in a separate function. This allows us to reuse
    code that''s dedicated to the primary functionality in other scripts and for the
    `main()` function to act more as a primary controller. An example of this will
    be shown in the final iteration of this code. See the following line of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第51行，我们调用下一个函数来解析输入文件。这个函数期望一个`str`对象，表示`setupapi.dev.log`的路径。虽然这似乎与`main()`函数的目的相违背，但我们将大部分功能放在一个单独的函数中。这使得我们能够在其他脚本中重用专门处理主要功能的代码，而`main()`函数则充当一个主要的控制器。这个例子将在代码的最终版本中展示。请参见以下代码行：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Crafting the parse_setupapi() function
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写`parse_setupapi()`函数
- en: 'The `parse_setupapi()` function, defined on line 54, takes a string input that
    represents the full path to the Windows 7 `setupapi.dev.log` file, as detailed
    by the docstring on lines 55 through 59\. On line 60, we open the file path provided
    by the `main()` function and read the data into a variable named `in_file`. This
    open statement didn''t specify any parameters, so it uses default settings that
    open the file in read-only mode. This mode prevents us from accidentally writing
    to the file. In fact, trying to `write()` to a file that''s been opened in read-only
    mode results in the following error and message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在第54行定义的`parse_setupapi()`函数接受一个字符串输入，表示Windows 7 `setupapi.dev.log`文件的完整路径，具体内容由第55至59行的文档字符串详细说明。在第60行，我们打开`main()`函数提供的文件路径，并将数据读取到名为`in_file`的变量中。此打开语句未指定任何参数，因此使用默认设置以只读模式打开文件。此模式防止我们意外地向文件写入。实际上，尝试向以只读模式打开的文件执行`write()`操作会导致以下错误和信息：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although it does not allow writing to the file, working off a copy of the source
    evidence or the use of write-blocking technology should be used when handling
    digital evidence.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不允许向文件写入，但在处理数字证据时，应该使用源证据的副本或使用写入阻止技术。
- en: 'If there is any confusion regarding files and their modes, refer to [Chapter
    1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml), *Now for Something Completely*
    *Different*, for additional information. See the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对文件及其模式有任何疑问，请参阅[第1章](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml)，*现在换个话题*，以获取更多信息。请参见以下代码：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On line 61, we read each line from the `in_file` variable into a new variable
    named `data` using the file object''s `readlines()` method. This method returns
    a list where each element represents a single line in the file. Each element in
    the list is the string of text from the file delimited by the newline (`\n` or
    `\r\n`) character. At this newline character, the data is broken into a new element
    and fed as a new entry into the data list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第61行，我们使用文件对象的`readlines()`方法，将`in_file`变量中的每一行读取到一个名为`data`的新变量中。该方法返回一个列表，其中每个元素表示文件中的一行。列表中的每个元素都是文件中的文本字符串，以换行符（`\n`
    或 `\r\n`）字符分隔。在此换行符处，数据被拆分为一个新元素，并作为新条目添加到数据列表中：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the content of the file stored in the variable data, we begin a `for`
    loop to walk through each individual line. This loop uses the `enumerate()` function,
    which wraps our iterator with a counter that keeps track of the number of iterations.
    This is desirable because we want to check for the pattern that identifies a USB
    device entry, then read the following line to get our date value. By keeping track
    of what element we are currently processing, we can easily pull out the next line
    we need to process with *data [n + 1]*, where *n* is the enumerated count of the
    current line being processed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将文件的内容存储在`data`变量中，我们开始一个`for`循环，遍历每一行。这个循环使用`enumerate()`函数，该函数为我们的迭代器添加了一个计数器，记录迭代次数。这是有用的，因为我们希望检查识别USB设备条目的模式，然后读取下一行以获取日期值。通过跟踪当前正在处理的元素，我们可以轻松地提取我们需要处理的下一行，即*data
    [n + 1]*，其中*n*是当前正在处理行的枚举计数。
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once inside the loop, on line 64, we evaluate whether the current line contains
    the string `device install (hardware initiated)`. To ensure that we don''t miss
    valuable data, we will make the current line case insensitive by using the `.lower()`
    method to convert all characters in the string to lower case. If responsive, we
    execute lines 65 through 67\. On line 65, we use the current iteration count variable,
    `i`, to access the responsive line within the data object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入循环，在第64行，我们评估当前行是否包含字符串`device install (hardware initiated)`。为了确保我们不会遗漏重要数据，我们将当前行设置为不区分大小写，使用`.lower()`方法将字符串中的所有字符转换为小写。如果符合条件，我们执行第65至67行。在第65行，我们使用当前迭代计数变量`i`来访问数据对象中的响应行：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After accessing the value, we call the `.split()` method on the string to split
    the values on the dash (`-`) character. After splitting, we access the second
    value in the split list and feed that string into the `strip()` function. The
    `.strip()` function, without any provided values, will strip whitespace characters
    on the left and right ends of the string. We process the responsive line so that
    it only contains USB identifying information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 访问到值后，我们在字符串上调用`.split()`方法，通过短横线（`-`）字符拆分值。拆分后，我们访问拆分列表中的第二个值，并将该字符串传递给`strip()`函数。`.strip()`函数在未提供任何值的情况下，将去除字符串两端的空白字符。我们处理响应行，以便它仅包含USB标识信息。
- en: 'The following is a log entry prior to processing with line 65:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理前的日志条目，位于第65行之前：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the log entry after processing:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理后的日志条目：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After converting the first line from the `setupapi.dev.log` USB entry, we then
    access the data variable on line 66 to obtain the date information from the following
    line. Since we know the date value sits on the line after the device information
    data, we can add one to the iteration count variable, `i`, to access that next
    line and get the line that contains the date. Similarly to device line parsing,
    we call the `.split()` function on the `start` string and extract the second element
    from the split that represents the date. Before saving the value, we need to call
    `.strip()` to remove whitespaces on both ends of the string:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换`setupapi.dev.log`中的第一行USB条目后，我们在第66行访问数据变量，获取下一行中的日期信息。由于我们知道日期值位于设备信息数据之后的那一行，我们可以将迭代计数变量`i`加1，以访问下一行并获取包含日期的行。与设备行解析类似，我们在`start`字符串上调用`.split()`函数，提取分割后的第二个元素，代表日期。在保存该值之前，我们需要调用`.strip()`，以去除字符串两端的空格：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This process removes any other characters besides the date.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程去除了除了日期以外的其他字符。
- en: 'The following is a log entry prior to processing with line 66:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理前的日志条目，位于第66行之前：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the log entry after processing:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理后的日志条目：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On line 67, we pass our extracted `device_name` and `date` values to the `print_output()`
    function. This function is called repeatedly for any responsive lines found in
    the loop. After the loop completes, the code on line 68 executes, which closes
    the `setupapi.dev.log` file that we initially opened, releasing the file from
    Python''s use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第67行，我们将提取的`device_name`和`date`值传递给`print_output()`函数。该函数会在循环中找到的任何响应行上重复调用。循环完成后，第68行的代码会执行，关闭我们最初打开的`setupapi.dev.log`文件，并释放该文件，供Python使用：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Developing the print_output() function
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发`print_output()`函数
- en: 'The `print_output()` function defined on line 71 allows us to control how the
    data is displayed to the user. This function requires two strings as input that
    represent the USB name and date, as defined by the docstring. On line 78 and 79,
    we print the USB data using the `.format()` method. As discussed in [Chapter 1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml),
    *Now for Something Completely Different*, this function replaces the curly brackets
    (`{}`) with the data provided in the method call. A simple example like this doesn''t
    show off the full power of the `.format()` method. However, this function can
    allow us to perform complex string formatting with ease. After printing the input,
    execution returns to the called function where the script continues the next iteration
    of the loop, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第71行定义的`print_output()`函数允许我们控制数据如何展示给用户。该函数需要两个字符串作为输入，分别代表USB名称和日期，正如文档字符串所定义的那样。在第78和79行，我们使用`.format()`方法打印USB数据。正如在[第一章](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml)中讨论的，*现在来点完全不同的东西*，该函数将花括号（`{}`）替换为方法调用中提供的数据。像这样简单的例子并未展示`.format()`方法的全部威力。然而，该函数可以让我们轻松地进行复杂的字符串格式化。打印输入后，执行将返回到被调用的函数，脚本继续下一个循环的迭代，具体如下：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the script
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'We now have a script that takes a `setupapi.dev.log` file, as found on Windows
    7, and outputs USB entries with their associated timestamps. The following screenshot
    shows how we can execute the script with a sample `setupapi.dev.log` file, which
    has been provided in the code bundle. Your output may vary depending on the `setupapi.dev.log`
    file you use the script on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个脚本，可以处理在Windows 7中找到的`setupapi.dev.log`文件，并输出带有相关时间戳的USB条目。以下截图展示了如何使用提供的示例`setupapi.dev.log`文件来执行该脚本，您输出的内容可能会根据使用的`setupapi.dev.log`文件有所不同：
- en: '![](img/fd0d7ec0-c1ba-472c-b53b-cfb780f8fa95.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0d7ec0-c1ba-472c-b53b-cfb780f8fa95.png)'
- en: 'Since `setupapi.dev.log` has numerous entries, we have pulled out two additional
    snippets from our command''s output that focus on USB and USBSTOR devices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setupapi.dev.log`包含大量条目，我们从命令的输出中提取了两个额外的片段，专注于USB和USBSTOR设备：
- en: '![](img/e0a7af39-e28b-49c8-9e83-af8c7cdd65cf.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0a7af39-e28b-49c8-9e83-af8c7cdd65cf.png)'
- en: 'Our second snippet shows some details from the USBSTOR entries:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个代码片段显示了一些USBSTOR条目的详细信息：
- en: '![](img/9f38a21a-037f-423c-b936-0f6172b92655.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f38a21a-037f-423c-b936-0f6172b92655.png)'
- en: Our current iteration seems to generate some false positives by extracting responsive
    lines that do not pertain solely to USB devices; let's see how we can address
    that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的迭代似乎通过提取一些并非仅与USB设备相关的响应行，生成了一些误报；我们来看一下如何解决这个问题。
- en: Our second iteration – setupapi_parser_v2.py
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第二次迭代 – setupapi_parser_v2.py
- en: With a functioning prototype, we now have some cleanup work to do. The first
    iteration was a proof of concept to illustrate how a `setupapi.dev.log` file can
    be parsed for forensic artifacts. With our second revision, we will clean up and
    restructure the code so that it will be easier to use in the future. In addition,
    we will integrate a more robust command-line interface, validate any user-supplied
    inputs, improve processing efficiency, and display any results in a better format.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了一个可行的原型后，我们现在需要进行一些清理工作。第一次迭代只是一个概念验证，用来展示如何解析`setupapi.dev.log`文件中的取证信息。通过第二次修订，我们将清理并重构代码，以便未来更容易使用。此外，我们将集成更强大的命令行接口，验证任何用户提供的输入，提高处理效率，并以更好的格式显示结果。
- en: On lines 2 through 6, we import the libraries that we will need for these improvements,
    alongside familiar cross-version support libraries. `argparse` is a library that
    we discussed at length in [Chapter 2](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml),
    *Python Fundamentals*, and is used to implement and structure arguments from the
    user. Next, we import `os`, a library we will use in this script to check the
    existence of input files before continuing. This will prevent us from trying to
    process a file that does not exist. The `os` module is used to access common operating
    system functionality in an operating system agnostic manner. That is to say, these
    functions, which may be handled differently on other operating systems, are treated
    the same and share the same module. We can use the `os` module to recursively
    walk through a directory, create new directories, and change the permissions of
    an object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2到第6行之间，我们导入了为这些改进所需的库，同时也导入了一些熟悉的跨版本支持库。`argparse`是我们在[第2章](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml)《Python基础》中详细讨论过的一个库，用于实现和组织来自用户的参数。接下来，我们导入了`os`库，这是我们将在此脚本中使用的，用来在继续执行之前检查输入文件是否存在。这可以防止我们尝试处理不存在的文件。`os`模块用于以操作系统无关的方式访问常见的操作系统功能。也就是说，这些功能在不同操作系统中可能会有所不同，但它们都在同一个模块中处理。我们可以使用`os`模块递归地遍历目录、创建新目录，并修改对象的权限。
- en: 'Finally, we import `sys`, which we will use to exit the script in case an error
    occurs to prevent faulty or improper output. After our imports, we have kept our
    licensing and documentation variables from before, modifying them to provide details
    about the second iteration:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入了`sys`，它将在发生错误时用来退出脚本，避免错误或不正确的输出。导入完成后，我们保留了之前的许可和文档变量，并对它们进行了修改，以提供关于第二次迭代的详细信息：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The functions defined in our previous script are still present here. However,
    these functions contain new code that allows for improved handling and flows logically
    in a different manner. Designing our code in a modularized manner allows us to
    repurpose functions in new or updated scripts, limiting the need for a major overhaul.
    This segmentation also allows for easier debugging when reviewing an error that''s
    raised within a function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的脚本中定义的函数仍然存在于这里。然而，这些函数包含了新的代码，使得处理方式得到了改进，并以不同的方式实现了逻辑流。以模块化的方式设计代码使我们能够在新的或更新的脚本中重复使用这些函数，从而避免了大规模的重构。这种分段处理也使得在检查函数中抛出的错误时，调试变得更加容易：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `if` statement serves the same purpose as the prior iteration. The additional
    code shown within this conditional allows the user to provide input to modify
    the script''s behavior. In line 106, we create an `ArgumentParser` object with
    a description, default help formatting, and `epilog` containing author, version,
    and date information. This, in conjunction with the argument options, allows us
    to display information about the script that might be helpful to the user when
    running the `-h` switch. See the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的作用与之前的迭代相同。此条件语句中的附加代码允许用户提供输入，以修改脚本的行为。在第106行，我们创建了一个`ArgumentParser`对象，包含描述、默认帮助格式和包含作者、版本及日期信息的`epilog`。结合参数选项，我们可以在运行`-h`开关时，向用户显示关于脚本的有用信息。请参见以下代码：'
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After defining the `ArgumentParser` object as `parser`, we add the `IN_FILE`
    parameter on line 113 to allow the user to specify which file to use for input.
    Already, this increases the usability of our script by adding flexibility in the
    input file path rather than hard coding the path. At line 115, we parse any provided
    arguments and store them in the `args` variable. Finally, we call the `main()`
    function on line 118, passing a string representing the file location of `setupapi.dev.log` to
    the function, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`ArgumentParser`对象为`parser`之后，我们在第113行添加了`IN_FILE`参数，允许用户指定用于输入的文件。这样一来，我们的脚本在输入文件路径上增加了灵活性，而不是硬编码路径，提升了可用性。在第115行，我们解析任何提供的参数，并将它们存储在`args`变量中。最后，在第118行调用`main()`函数，传递表示`setupapi.dev.log`文件位置的字符串，如下所示：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note the difference in our flowchart. Our script is no longer very linear.
    The `main()` function calls and accepts returned data from the `parse_setupapi()`
    method (indicated by the dashed arrow). The `print_output()` method is called
    to print the parsed data to the console:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的流程图有所不同。我们的脚本不再是线性的。`main()`函数调用并接收来自`parse_setupapi()`方法的返回数据（由虚线箭头指示）。调用`print_output()`方法将解析后的数据打印到控制台：
- en: '![](img/e552b031-1dd2-4f20-b4d4-e7760da8efbf.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e552b031-1dd2-4f20-b4d4-e7760da8efbf.png)'
- en: Improving the main() function
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`main()`函数
- en: 'On line 42, we define the `main()` function that now accepts a new argument
    that we will call `in_file`. This argument, as defined by the docstring, is a
    string path to the `setupapi.dev.log` file to be analyzed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第42行，我们定义了`main()`函数，现在接受一个新的参数，我们称之为`in_file`。根据文档字符串定义，该参数是一个指向`setupapi.dev.log`文件的字符串路径，该文件将被分析：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On line 48, we perform a validation of the input file to ensure that the file
    path and file exists using the `os.path.isfile()` function, which will return
    `true` if it is a file that''s accessible by the script. As an aside, the `os.path.isdir()`
    function can be used to perform the same style of validation for directories.
    These functions work well with string inputs that represent either absolute or
    relative paths:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第48行，我们使用`os.path.isfile()`函数对输入文件进行验证，确保文件路径和文件存在，如果是脚本可访问的文件，函数将返回`true`。顺便提一下，`os.path.isdir()`函数可以用于对目录进行相同类型的验证。这些函数适用于表示绝对路径或相对路径的字符串输入：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the file path is valid, we print the version of the script. This time, we
    use the `.format()` method to create our desired string. Let's look at the formatters
    we've used on lines 49 and 51, starting with a colon to define our specified format.
    The caret (`^`) symbol indicates that we want to center the supplied object and
    have the padding to a minimum of 22 characters, using equal signs as padding. For
    example, the string `Hello World!` would be sandwiched between five equal signs
    on both sides. In the case of our script, we supply an empty string as the object
    to format because we only want 22 equal signs to create visual separation from
    the output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件路径有效，我们会打印脚本的版本。这一次，我们使用`.format()`方法来创建我们想要的字符串。让我们看看我们在第49行和第51行使用的格式化符号，从冒号开始定义我们指定的格式。插入符号（`^`）表示我们希望将提供的对象居中，并使用等号作为填充，使填充字符数最少为22个。例如，字符串`Hello
    World!`会被夹在两侧的五个等号之间。在我们的脚本中，我们提供一个空字符串作为要格式化的对象，因为我们只希望使用22个等号来与输出产生视觉上的分隔。
- en: Note that it is simpler to implement the `"=" * 22` logic from the prior iteration
    and that we have used the `format()` method to provide a demonstration of available
    features.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前版本的`"=" * 22`逻辑更简单，我们已使用`format()`方法演示可用的功能。
- en: 'On line 50, the `.format()` method is used to print the script name and version
    strings, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第50行，使用`.format()`方法打印脚本名称和版本字符串，如下所示：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On line 52, we call the `parse_setupapi()` function and pass the `setupapi.dev.log`
    file, which we know is available. This function returns a list of USB entries,
    with one entry per discovered device. Each entry in `device_information` consists
    of two elements, that is, the device name, and the associated date value. On line
    53, we iterate through this list using a `for` loop and feed each entry to the
    `print_output()` function on line 54:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第52行，我们调用`parse_setupapi()`函数并传入已知可用的`setupapi.dev.log`文件。该函数返回一个USB条目列表，每个条目代表一个被发现的设备。`device_information`中的每个条目由两个元素组成，即设备名称和关联的日期值。在第53行，我们使用`for`循环遍历此列表，并将每个条目传递给第54行的`print_output()`函数：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On line 55, we handle the case where the provided file is not valid. This is
    a common way to handle errors that have been generated from invalid paths. Within
    this condition, we print on line 56 that the input is not a valid file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第55行，我们处理提供的文件无效的情况。这是处理无效路径所生成错误的常见方式。在此条件中，我们在第56行打印出输入的文件无效。
- en: If we wanted to use a built-in Python `Exception` class, we could raise an IOError
    and provide a message that the input file is not available at the specified path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用Python内置的`Exception`类，我们可以引发IOError，并提供一个消息，指出输入文件在指定路径下不可用。
- en: 'On line 57, we call `sys.exit()` to quit the program with an error of one.
    You may place any number here; however, since we defined this as one, we will
    know where the error was raised at exit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第57行，我们调用`sys.exit()`以错误代码1退出程序。你可以在这里放置任何数字；然而，由于我们将其定义为1，我们将在退出时知道错误发生的地方：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tuning the parse_setupapi() function
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整`parse_setupapi()`函数
- en: 'The `parse_setupapi()` function accepts the path of the `setupapi.dev.log`
    file as its only input. Before opening the file, we must initialize the `device_list`
    variable on line 68 so that we can store extracted device records in a list:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_setupapi()`函数接受`setupapi.dev.log`文件的路径作为唯一输入。在打开文件之前，我们必须在第68行初始化`device_list`变量，以便将提取的设备记录存储在一个列表中：'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Starting on line 69, we open the input file in a novel manner; the `with` statement
    opens the file as `in_file` and allows us to manipulate data within the file without
    having to worry about closing the file afterward. Inside this `with` loop is a
    `for` loop that iterates across each line, which provides superior memory management.
    In the previous iteration, we used the `.readlines()` method to read the entire
    file into a list by line; though not very noticeable on smaller files, the `.readlines()`
    method on a larger file would cause performance issues on systems with limited
    resources:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从第69行开始，我们以一种新颖的方式打开输入文件；`with`语句将文件作为`in_file`打开，并允许我们在不需要担心关闭文件的情况下操作文件中的数据。在这个`with`循环内是一个`for`循环，它遍历每一行，提供了更优的内存管理。在之前的迭代中，我们使用`.readlines()`方法按行读取整个文件到一个列表中；虽然在较小的文件上不太显眼，但在较大文件上，`.readlines()`方法会在资源有限的系统上造成性能问题：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Within the `for` loop, we leverage similar logic to determine whether the line
    contains our device installation indicators. If responsive, we extract the device
    information using the same manner as discussed previously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内，我们利用类似的逻辑来判断该行是否包含我们的设备安装指示符。如果响应，我们将以之前讨论的方式提取设备信息。
- en: 'By defining the `lower_line` variable on line 74, we can truncate the remaining
    code by preventing continuous calls to the `.lower()` method. Please note that
    lines 73 through 75 reflect one line of wrapped code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在第74行定义`lower_line`变量，我们可以通过防止连续调用`.lower()`方法来截断剩余的代码。请注意，第73行到第75行反映的是一行换行代码：
- en: On line 73, the backslash (`\`) character indicates to Python that it should
    ignore the newline character and continue reading on the next line. Then, at the
    end of line 74, we can return to anywhere without the need for the backslash,
    as our conditional is within parenthesis.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第73行，反斜杠（`\`）字符告诉Python忽略换行符，并继续在下一行读取。然后，在第74行末尾，我们可以不使用反斜杠直接返回任何位置，因为我们的条件语句已在括号内。
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As noted in the first iteration, a fair number of false positives were displayed
    in our output. That's because this log contains information related to many types
    of hardware devices, including those interfacing with PCI, and not just USB devices.
    To remove the noise, we will check to see what type of device it is.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一次迭代中所述，我们的输出中出现了相当数量的误报。这是因为该日志包含与许多类型硬件设备相关的信息，包括与PCI接口的设备，而不仅仅是USB设备。为了去除这些噪音，我们将检查它是何种类型的设备。
- en: 'We can split on the backslash character, as shown on lines 78 and 79, to access
    the first split element of the `device_name` variable and see if it contains the
    `usb` string. As mentioned in [Chapter 1](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml),
    *Now for Something Completely Different*, we need to escape a single backslash
    with another backslash so that Python knows to treat it as a literal backslash
    character. This will respond for devices labeled as USB and USBSTOR in the file.
    Some false positives will still exist, since mice, keyboards, and hubs will likely
    display as USB devices; however, we do not want to over-filter and miss relevant
    artifacts. If we discover that the entry does not contain the `usb` string, we
    execute the continue statement, telling Python to step through the next iteration
    of the `for` loop:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第78和第79行使用反斜杠字符进行分割，以访问`device_name`变量的第一个分割元素并查看它是否包含`usb`字符串。如[第1章](8764f55f-76ef-4890-afbd-2fd1b6d39210.xhtml)中提到的*Now
    for Something Completely Different*，我们需要使用另一个反斜杠来转义单个反斜杠，这样Python就能将其视为字面量反斜杠字符。这将响应文件中标记为USB和USBSTOR的设备。由于鼠标、键盘和集线器可能也会显示为USB设备，因此会存在一些误报；然而，我们不希望过度过滤而错过相关的文物。如果我们发现条目不包含`usb`字符串，我们执行`continue`语句，告诉Python跳过本次迭代，进入`for`循环的下一次迭代：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To retrieve the date, we need to use a different procedure to get the next
    line since we have not invoked the `enumerate()` function. To solve this challenge,
    we use the `next()` function on line 87 to step into the next line in the file.
    We then process this line in the same fashion as we discussed previously:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取日期，我们需要使用不同的程序来获取下一行，因为我们没有调用`enumerate()`函数。为了解决这个问题，我们在第87行使用`next()`函数跳到文件中的下一行。然后，我们按照之前讨论的方式处理这行内容：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the device's name and date processed, we append it to the `device_list`
    as a tuple, where the device's name is the first value and the date is the second.
    We need the double parenthesis, in this case, to ensure that our data is appended
    properly. The outer set is used by the `.append()` function. The inner parentheses
    allow us to build a tuple and append it as one value. If we did not have the inner
    parentheses, we would be passing the two elements as separate arguments to the
    `append()` function instead of a single tuple element. Once all of the lines have
    been processed in the `for` loop, the `with` loop will end and close the file.
    On line 90, the `device_list` is returned and the function exits.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完设备的名称和日期后，我们将其作为元组追加到`device_list`中，其中设备的名称是第一个值，日期是第二个值。我们需要使用双层括号，以确保数据正确追加。外层括号由`.append()`函数使用，内层括号允许我们构建一个元组并作为一个值追加。如果没有内层括号，我们将把两个元素作为单独的参数传递给`append()`函数，而不是作为一个元组元素。所有行在`for`循环中处理完毕后，`with`循环将结束并关闭文件。在第90行，返回`device_list`并退出函数。
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Modifying the print_output() function
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改`print_output()`函数
- en: 'This function is identical to the previous iteration, with the exception of
    the addition of the newline character `\n` on line 101\. This helps separate entries
    in the console''s output with an extra space. When iterating through the code,
    we will find that not all functions need updating to improve the user experience,
    accuracy, or efficiency of the code. Only by modifying an existing function will
    some sort of benefit be achieved:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数与之前的版本相同，唯一的区别是在第101行添加了换行符`\n`。这有助于在控制台输出中用额外的空格分隔每个条目。在迭代代码时，我们会发现，并非所有函数都需要更新以提高用户体验、准确性或代码效率。只有修改现有函数才能带来某种益处：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running the script
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'In this iteration, we address several issues from the proof of concept. These
    changes include the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一轮迭代中，我们解决了概念验证中的几个问题。这些变化包括以下内容：
- en: The improvement of resource management by iterating through a file rather than
    reading the entire file into a variable
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过遍历文件而非将整个文件读取到变量中来改进资源管理
- en: The addition of an argument to allow the user to provide the `setupapi.dev.log`
    file to parse
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加了一个参数，允许用户提供`setupapi.dev.log`文件以进行解析
- en: The validation of the input file from the user
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入文件的验证
- en: The filtering of responsive hits to reduce noise in the output
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤响应性命中的内容以减少输出中的噪声
- en: Improved formatting of our output for ease of review
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了便于审核，改进了输出格式
- en: 'The following screenshot shows a snippet of the output of our script upon execution:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们脚本执行后的输出片段：
- en: '![](img/a337f4de-28e6-4496-81c2-38c50ec4236b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a337f4de-28e6-4496-81c2-38c50ec4236b.png)'
- en: 'Last but not least, we achieved considerable performance improvements over
    our previous design. The following screenshots display the impact on the machine''s
    memory utilization. The first iteration is displayed on the left and the second
    is displayed on the right. The red lines highlight the start and finish time of
    our script. As we can see, we have reduced our resource utilization by iterating
    across the lines of the file with the `for` loop over the `readlines()` method.
    This is a small-scale example of resource management, but a larger input file
    would have a more dramatic impact on the system:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们在之前的设计基础上取得了显著的性能提升。以下截图显示了对机器内存利用率的影响。第一迭代显示在左侧，第二迭代显示在右侧。红色线条标出了我们脚本的开始和结束时间。正如我们所见，通过在文件的每一行上使用
    `for` 循环迭代 `readlines()` 方法，我们减少了资源的使用。这是一个小规模的资源管理示例，但更大的输入文件将对系统产生更为显著的影响：
- en: '![](img/c36616f5-d81b-4767-be29-f2a1515bbe22.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c36616f5-d81b-4767-be29-f2a1515bbe22.png)'
- en: Our final iteration – setupapi_parser.py
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的最终迭代——setupapi_parser.py
- en: In our final iteration, we will continue to improve the script by adding deduplication
    of processed entries and improving upon the output. Although the second iteration
    introduced the logic for filtering out non-USB devices, it does not deduplicate
    the responsive hits. We will deduplicate on the device name to ensure that there
    is only a single entry per device. In addition, we will integrate our `usb_lookup.py`
    script from [Chapter 2](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml), *Python Fundamentals*,
    to improve the utility of our script by displaying USB VIDs and PIDs for known
    devices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终迭代中，我们将继续通过添加去重处理和改进输出内容来优化脚本。尽管第二次迭代引入了过滤非 USB 设备的逻辑，但它并未去重响应的数据。我们将基于设备名称去重，确保每个设备只有一个条目。此外，我们将整合来自[第二章](b09a5e87-9ada-41cb-ba04-bd61c744bf99.xhtml)
    *Python 基础*的 `usb_lookup.py` 脚本，通过显示已知设备的 USB VID 和 PID 来提高脚本的实用性。
- en: 'We had to modify the code in the `usb_lookup.py` script to properly integrate
    it with the `setupapi` script. The differences between the two versions are subtle
    and are focused on reducing the number of function calls and improving the quality
    of the returned data. Throughout this iteration, we will discuss how we have implemented
    our custom USB VID/PID lookup library to resolve USB device names. On line 4,
    we import the `usb_lookup` script, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须修改 `usb_lookup.py` 脚本中的代码，以便与 `setupapi` 脚本正确集成。两者版本之间的差异是微妙的，重点是减少函数调用次数并提高返回数据的质量。在这一迭代过程中，我们将讨论如何实现我们的自定义
    USB VID/PID 查找库，以解决 USB 设备名称的问题。在第 4 行，我们导入了 `usb_lookup` 脚本，如下所示：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we can see in the following code block, we have added three new functions.
    Our prior functions have undergone minor modifications to accommodate new features.
    The majority of the modifications are in our new functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码块所示，我们添加了三个新函数。我们之前的函数进行了少量修改，以适应新功能。大部分修改都集中在我们的新函数中：
- en: The `parse_device_info()` function is responsible for splitting out the necessary
    information to look up the VID/PID values online and format the raw strings into
    a standard format for comparison
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse_device_info()` 函数负责提取必要的信息，以便在线查找 VID/PID 值，并将原始字符串格式化为标准格式进行比较。'
- en: The next function, `prep_usb_lookup()`, prepares and parses the database into
    a format that supports querying
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的函数 `prep_usb_lookup()` 准备并解析数据库，将其转换为支持查询的格式。
- en: The `get_device_names()` function correlates matching device information with
    the database
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_device_names()` 函数将匹配的设备信息与数据库相关联。'
- en: 'With these new functions, we provide additional context for our investigators:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些新函数，我们为调查人员提供了更多的背景信息：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will add one argument to our parser before calling the `main()` function.
    The `--local` argument defined on lines 198 and 199 allow us to specify a local
    `usb.ids` file that we can use for parsing in an offline environment. The following
    code block shows our implementation of the arguments, spaced out over several
    lines to make it easier to read:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `main()` 函数之前，我们将为解析器添加一个参数。198 行和 199 行定义的 `--local` 参数允许我们指定一个本地的 `usb.ids`
    文件，以便在离线环境中进行解析。以下代码块展示了我们如何实现这些参数，并分成几行以便于阅读：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with our prior iterations, we have generated a flow chart to map the logical
    course of our script. Please note that it uses the same legend as our other flow
    charts, though we omitted the legend due to the width of the graphic. Our `main()`
    function is executed and makes direct calls to five other functions. This layout
    builds upon the nonlinear design from the second iteration. In each iteration,
    we are continuing to add more control within the `main()` function. This function
    leans on others to perform tasks and return data rather than doing the work itself.
    This offers a form of high-level organization within our script and helps keep
    things simple by executing one function after another in a linear fashion:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的迭代一样，我们生成了一个流程图来映射脚本的逻辑流程。请注意，它使用与其他流程图相同的图例，尽管由于图形的宽度，我们省略了图例。我们的`main()`函数执行并直接调用了其他五个函数。这个布局是在第二次迭代中非线性设计的基础上构建的。在每次迭代中，我们继续在`main()`函数内增加更多控制逻辑。这个函数依赖其他函数来执行任务并返回数据，而不是自己完成工作。这为我们的脚本提供了一种高层次的组织方式，并通过线性执行一个函数接一个函数，帮助保持简洁：
- en: '![](img/5b1debc7-d4f9-4cbd-9fe3-531711b89505.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b1debc7-d4f9-4cbd-9fe3-531711b89505.png)'
- en: Extending the main() function
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展main()函数
- en: 'The `main()` function has remained mostly intact, only adding changes to look
    up the USB VID and PID information and present a superior output for the end user.
    One way we are facilitating this lookup is by providing a file path as the `local_usb_ids`
    parameter, which allows us to use an offline file for our VID/PID lookup database.
    To cut down on clutter in our output, we have elected to remove the script name
    and version printing. On line 51, a new function call to `prep_usb_info()` is
    made to initiate the setup of the VID/PID lookups. Our loop on line 52 has been
    reconfigured to hand each processed device entry to the `parse_device_info()`
    function on line 53\. This new function is responsible for reading the raw string
    from the log file and attempts to split the VID and PID values for lookup:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数基本保持不变，只增加了查找USB VID和PID信息的功能，并为最终用户提供了更优的输出。我们简化了这个查找过程，其中一种方式是通过提供一个文件路径作为`local_usb_ids`参数，这使得我们可以使用离线文件作为VID/PID查找数据库。为了减少输出的杂乱，我们选择移除了脚本名称和版本的打印。在第51行，我们新增了一个函数调用`prep_usb_info()`，用于初始化VID/PID查找设置。第52行的循环已经重新配置，将每个处理过的设备条目交给第53行的`parse_device_info()`函数。这个新函数负责从日志文件中读取原始字符串，并尝试拆分VID和PID值以进行查找：'
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `if` statement on line 54 checks the value of the `parsed_info` variable
    to ensure that it was parsed correctly and can be compared against our known values.
    In the case that it is not prepared for this, the information is not queried or
    printed. See the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第54行的`if`语句检查`parsed_info`变量的值，确保其已经正确解析，并可以与已知值进行比较。如果未准备好进行比较，则不查询或打印信息。请参阅以下代码：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Additional logic on line 57 checks to see whether the `parsed_info` value is
    not equivalent to `None`. A `None` value is assigned to `parsed_info` if the `parse_device_info()`
    function discovered that the device was not recorded as a USB, eliminating false
    positives:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第57行的附加逻辑检查`parsed_info`值是否不等于`None`。如果`parse_device_info()`函数发现设备没有记录为USB设备，`parsed_info`值将被赋为`None`，从而消除误报：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, on line 59, we print to the console that we have completed parsing
    the log file. On lines 62 through 65, we address the situation where the `setupapi.dev.log`
    is not valid or accessible by our script and notify the user of the situation
    before exiting. The message that is printed before exiting the script is more
    detailed than in previous iterations. The more details we can provide to our users,
    especially regarding potential bugs, will improve their capability to determine
    the error and correct it on their own:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第59行，我们向控制台打印日志文件解析完成的信息。在第62行到第65行，我们处理`setupapi.dev.log`文件无效或无法通过脚本访问的情况，并在退出前通知用户该情况。退出脚本前打印的消息比之前的版本更为详细。我们提供给用户的细节越多，特别是关于潜在错误的详细信息，用户就越能自行判断并纠正错误：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding to the parse_setup_api() function
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到parse_setup_api()函数
- en: 'This function has minor modifications that are focused on storing unique entries
    from the log file. We created a new variable named `unique_list` that is a `set`
    data type on line 76\. Recall that a `set` must consist of hashable and unique
    elements, making it a perfect fit for this solution. Though it seems duplicative
    to have a list and set holding similar data, for simplicity of comparison and
    demonstration, we have created the second variable:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数做了少许修改，重点是从日志文件中存储唯一条目。我们在第76行创建了一个名为`unique_list`的新变量，它是一个`set`数据类型。回想一下，`set`必须由可哈希且唯一的元素组成，这使其非常适合此解决方案。虽然拥有一个列表和一个集合存储相似数据似乎有些重复，但为了方便比较和演示，我们创建了第二个变量：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'On line 79, we convert the line into lowercase to ensure that our comparisons
    are case-insensitive. At this point, we use the same logic to process the `device_name`
    and `date` values on lines 83 through 84\. We have moved the code from the second
    iteration, which verified the device type, into our new `parse_device_info()`
    function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第79行，我们将行转换为小写，以确保比较时不区分大小写。此时，我们在第83到84行使用相同的逻辑来处理`device_name`和`date`值。我们已将第二次迭代中验证设备类型的代码移至新的`parse_device_info()`函数中：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before we store the `device_name` and `date` information in our `device_list`,
    we check to ensure that the `device_name` does not already exist in our `unique_list`.
    If it doesn''t, we add the tuple on line 86, which contains the `device_name`
    and `date`. Afterward, we prevent that same device from being processed again
    by adding the entry to our `unique_list`. On line 89, we return our built list
    of tuples for the next stage of processing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将`device_name`和`date`信息存储到`device_list`之前，我们检查`device_name`是否已经存在于`unique_list`中。如果不存在，我们会在第86行添加包含`device_name`和`date`的元组。然后，我们通过将该条目添加到`unique_list`，防止相同的设备再次被处理。在第89行，我们返回构建好的元组列表，供下一阶段的处理使用：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating the parse_device_info() function
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`parse_device_info()`函数
- en: 'This function interprets the raw string from the `setupapi.dev.log` and converts
    it into a dictionary with VID, PID, revision, unique ID, and date values. This
    is described in the docstring on lines 94 through 98\. After the documentation,
    we initialize the variables we will use in this function on lines 101 through
    104\. This initialization provides default placeholder values, which will prevent
    future issues with the dictionary in scenarios where we cannot assign a value
    to these variables:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数解释来自`setupapi.dev.log`的原始字符串，并将其转换为一个包含VID、PID、修订版、唯一ID和日期值的字典。此过程在第94到98行的文档字符串中有描述。文档之后，我们在第101到104行初始化将在此函数中使用的变量。这些初始化提供了默认的占位符值，以防在无法为这些变量赋值的情况下，字典出现问题：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After initialization, we split the `device_info` value, which is passed from
    the `parse_setup_api()` function into segments, using a single backslash as the
    delimiter. We need to escape this backslash with another to interpret it as a
    literal backslash character. This split on line 107 separates the device type
    segment from the string containing the VID and PID information. Following this
    split, we check to ensure that the device type entry reflects a USB device. If
    the device is not a USB, we return `None` to ensure that it is not processed further
    by this function and that we do not attempt to resolve VIDs or PIDs for this device.
    By adding this logic, we save ourselves from spending additional time and resources
    processing irrelevant entries:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们将从`parse_setup_api()`函数传递的`device_info`值按单个反斜杠进行分割，作为分隔符。为了将其作为字面意义的反斜杠字符进行解释，我们需要使用另一个反斜杠来转义它。第107行的分割将设备类型段与包含VID和PID信息的字符串分开。在此分割之后，我们检查设备类型条目是否反映了USB设备。如果设备不是USB设备，我们返回`None`，以确保该设备不被此函数进一步处理，也避免我们为该设备解析VID或PID。通过添加此逻辑，我们避免了花费额外时间和资源处理不相关的条目：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we access the second element of the `segments` list, which contains the
    VID, PID, and revision data, delimited by an ampersand. Using `.split()`, we can
    access each of these values independently through the `for` loop on line 114\.
    We convert the line to lower case to allow us to search in a case-insensitive
    fashion, through a series of conditionals, to determine what each item represents.
    On line 116, we check each item to see if it contains the keywords `ven` or `vid`.
    If the line does contain one of these indicators, we split only on the first underscore
    character (specified by the integer `1` as the second parameter). This allows
    us to extract the VID from the raw string. Note how we use `lower_item` for our
    comparisons and the `item` variable for storing values, preserving the original
    case of our data. This behavior is repeated for the `pid` variable, using the
    `dev`, `prod`, and `pid` indicators, and the `rev` variable, using the `rev` or
    `mi` indicators on lines 118 through 122, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问 `segments` 列表的第二个元素，该元素包含由 & 符号分隔的 VID、PID 和修订数据。通过 `.split()`，我们可以在第
    114 行的 `for` 循环中独立访问这些值。我们将该行转为小写，允许我们以不区分大小写的方式，通过一系列条件判断来确定每个项的含义。在第 116 行，我们检查每一项，看看它是否包含
    `ven` 或 `vid` 关键字。如果行中包含这些指示符之一，我们只在第一个下划线字符处进行分割（由整数 `1` 指定为第二个参数）。这使我们能够从原始字符串中提取
    VID。注意我们使用 `lower_item` 进行比较，而使用 `item` 变量来存储值，从而保持数据的原始大小写。这个过程对于 `pid` 变量也是如此，使用
    `dev`、`prod` 和 `pid` 指示符，以及 `rev` 变量，使用 `rev` 或 `mi` 指示符，在第 118 至 122 行，如下所示：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After parsing the VID, PID, and revision information, we attempt to extract
    the unique ID from the segments variable, which is normally the last element in
    the string. Because the entire line is wrapped in brackets, we strip the closing
    bracket from the rightmost entry in the segment on line 125\. This removes the
    bracket, so it will not be included in our unique ID string:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析 VID、PID 和修订信息后，我们尝试从 segments 变量中提取唯一 ID，通常这是字符串中的最后一个元素。由于整行内容被括号包裹，我们在第
    125 行从 segment 的最右边条目中去掉了右括号。这样就去除了括号，确保它不会包含在我们的唯一 ID 字符串中：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On line 127, we use an `if` statement to determine whether the `vid` or `pid`
    received a value after initialization, and build a dictionary if we collected
    new information on lines 128 through 132\. If these values were not filled out,
    we return the original string to allow the output of the entry without the additional
    formatting, as seen on line 134, to ensure that we are not missing any data due
    to a formatting error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 127 行，我们使用 `if` 语句来判断 `vid` 或 `pid` 是否在初始化后获得了值，并在第 128 至 132 行构建一个字典，若这些值未填写，我们返回原始字符串，以允许输出没有额外格式化的条目，如第
    134 行所示，确保我们没有因格式化错误而遗漏任何数据：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Forming the prep_usb_lookup() function
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 prep_usb_lookup() 函数
- en: 'In this function, we call out to the `usb_lookup.py` script''s `.get_usb_file()`
    function. Using the `local_usb_ids` parameter that''s provided, we can confirm
    whether there is a known `usb.ids` file path that we should use for this lookup,
    or whether we should reach out to the online resource at [http://linux-usb.org/usb.ids](http://linux-usb.org/usb.ids)
    to read the known USB information into the `usb_file` variable on line 147\. This
    database is an open source project that hosts the VID/PID lookup database, allowing
    users to reference and expand on the database:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们调用了 `usb_lookup.py` 脚本的 `.get_usb_file()` 函数。利用提供的 `local_usb_ids`
    参数，我们可以确认是否有已知的 `usb.ids` 文件路径需要用于此次查询，或者我们是否需要访问在线资源 [http://linux-usb.org/usb.ids](http://linux-usb.org/usb.ids)，将已知的
    USB 信息读取到第 147 行的 `usb_file` 变量中。这个数据库是一个开源项目，托管了 VID/PID 查找数据库，允许用户参考并扩展该数据库：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After downloading or using a local copy, we pass the file object to the `.parse_file()`
    function to process and then return the USB VID/PID data as a Python dictionary.
    Instead of creating a new variable for this functionality, we can just place the
    `return` keyword in front of the function call to immediately pass the value back,
    as shown on line 148:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下载或使用本地副本后，我们将文件对象传递给 `.parse_file()` 函数进行处理，然后返回 USB VID/PID 数据，作为一个 Python
    字典。为了实现这一功能，我们无需创建新的变量，只需在函数调用前加上 `return` 关键字即可立即返回值，如第 148 行所示：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Constructing the get_device_names() function
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 get_device_names() 函数
- en: 'This function''s purpose is to pass the VID and PID information into the `usb_lookup`
    library and return resolved USB names. As defined by the docstring mentioned later,
    this function takes two dictionaries—the first contains the database of known
    devices from `prep_usb_lookup()`, and the second contains the extracted device
    entries from `parse_device_info()`. With this provided data, we will return a
    dictionary, updated with resolved vendor and product names:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的目的是将VID和PID信息传入`usb_lookup`库，并返回解析后的USB名称。如后文所述的文档字符串所定义，此函数接受两个字典——第一个包含`prep_usb_lookup()`中的已知设备数据库，第二个包含`parse_device_info()`中提取的设备条目。提供这些数据后，我们将返回一个字典，更新为解析后的供应商和产品名称：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function calls the `usb_lookup.search_key()` function, passing the processed
    online USB dictionary and a two-element list containing the device''s VID and
    PID as the first and second element, respectively. The `.search_key()` function
    returns either a responsive match or the `Unknown` string if no matches are discovered.
    This data is returned as a tuple and assigned to the `device_name` variable on
    line 161\. We then split the two resolved values into new keys of our `device_info`
    dictionary on lines 165 and 166\. Once we have expanded `device_info`, we can
    return it so that it can be printed to the console. See the following lines:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数调用`usb_lookup.search_key()`函数，传入处理过的在线USB字典以及一个包含设备VID和PID的两元素列表，分别作为第一个和第二个元素。`.search_key()`函数返回一个响应匹配项，如果没有匹配项，则返回`Unknown`字符串。这些数据以元组形式返回，并分配给第161行的`device_name`变量。接着，我们将在第165和166行将这两个解析后的值拆分为`device_info`字典的新键。一旦我们扩展了`device_info`，就可以将其返回，以便打印到控制台。请参见以下行：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Enhancing the print_output() function
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强了`print_output()`函数
- en: 'In this function, we have made some adjustments to improve the output to the
    console. With the addition of the separator defined on 178, we now have a line
    of 15 dashes visually breaking each entry from the output. As we can see, we have
    borrowed the same format string from the first iteration to add this break:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们做了一些调整，以改善输出到控制台的效果。通过在第178行添加分隔符，我们现在可以在每个条目之间插入15个短横线，从而可视化地分隔输出。如我们所见，我们借用了第一次迭代中的相同格式字符串来添加这个分隔符：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have also modified the code to allow additional output for flexible fields.
    In this function, we need to handle two different data types, tuples and dictionaries,
    since some entries do not have a resolved vendor or product name. To handle this
    divide in formats, we must use the `isinstance()` function on line 180 to test
    the `usb_information` variable data type. If the value is a dictionary, we will
    print each of the keys and values to the console to display one key-value pair
    per line on line 182\. This is possible through the combination of the `for` loop
    on line 181, which uses the `items()` method on a dictionary. This method returns
    a list of tuples, where the first tuple element is the key and the second is the
    value. Using this method, we can quickly extract the key-value pairs, as shown
    on lines 181 and 182:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了代码，允许输出更多灵活的字段。在此函数中，我们需要处理两种不同的数据类型：元组和字典，因为有些条目没有解析出的供应商或产品名称。为了处理这些不同的格式，我们必须在第180行使用`isinstance()`函数测试`usb_information`变量的数据类型。如果值是字典类型，我们将在第182行逐行打印字典中的每一个键值对。这是通过第181行的`for`循环与字典的`items()`方法结合实现的。此方法返回一个包含元组的列表，其中第一个元素是键，第二个元素是值。通过这种方法，我们可以快速提取键值对，如第181和182行所示：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we need to print a tuple, we use two `print` statements, similar to the
    output from the prior iteration. Because this data is from a device that could
    not be parsed, it has a fixed format that is the same as our previous iteration.
    See the following lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要打印一个元组，可以使用两个`print`语句，类似于前一次迭代的输出。由于这些数据来自无法解析的设备，它具有与我们先前迭代相同的固定格式。请参见以下行：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Running the script
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'We have come a long way since our first script, as this version now does the
    following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们编写第一个脚本以来，我们已经取得了长足进展，现在这个版本执行以下操作：
- en: Provides us with USB device information about the first installation time of
    a device on Windows 7
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于Windows 7中设备首次安装时间的USB设备信息
- en: Resolves additional device information using VID and PID data
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VID和PID数据解析更多的设备信息
- en: Prints output to the console in a format that is legible and informative
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出以可读且富有信息的格式打印到控制台
- en: 'The following is an example execution of the script and illustration of the
    output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本执行的示例及输出说明：
- en: '![](img/4b5156b8-1b52-4e1c-9d20-b362ab37cdf3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b5156b8-1b52-4e1c-9d20-b362ab37cdf3.png)'
- en: 'The following screenshot has been included to highlight some of our storage
    devices further down the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图已包含以突出显示我们更深入了解的一些存储设备输出：
- en: '![](img/47a584bc-cd0b-48bf-bb76-c05874f0d5a5.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47a584bc-cd0b-48bf-bb76-c05874f0d5a5.png)'
- en: Challenge
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: For this chapter, we propose adding support for the Windows XP format of the
    `setupapi.log`. The user can supply a switch at the command line to indicate which
    type of log will be processed. For a more difficult task, our script could automatically
    identify the type of log file by fingerprinting unique structures found only in
    Windows XP versus the Windows 7 version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们建议添加对`setupapi.log`的Windows XP格式的支持。用户可以在命令行中提供一个开关来指示将处理哪种类型的日志。对于一个更困难的任务，我们的脚本可以通过指纹识别仅在Windows
    XP与Windows 7版本中找到的唯一结构，自动识别日志文件的类型。
- en: Improving the deduplication process we used in this chapter would be a welcome
    addition. As we identified, some entries have UID values embedded in the device
    entry. This value is generally assigned by the manufacturer and could be used
    to deduplicate the entries. As you may note in the output, the UID can contain
    extra ampersand characters that may or may not be crucial to the UID structure
    and suggest their source. By applying some simple logic, possibly in a new function,
    we can improve deduplication based on UIDs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 改进我们在本章中使用的去重过程将是一个受欢迎的补充。正如我们所发现的，一些条目在设备条目中嵌入了UID值。该值通常由制造商分配，并可以用于去重条目。正如您在输出中可能注意到的那样，UID可能包含额外的和可能不重要的和符号，这些符号建议它们的来源。通过应用一些简单的逻辑，可能是在一个新函数中，我们可以基于UID来改进去重功能。
- en: Lastly, we can consider our output format. While it is useful to display things
    in a console-friendly format, we should consider adding support for a CSV or other
    report. This may be a good feature to revisit after working through the rest of
    the chapters of this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以考虑我们的输出格式。虽然在控制台友好的格式中显示东西很有用，但在处理完本书其余章节之后，我们应考虑添加对CSV或其他报告的支持。这可能是一个好功能，重新审视一下。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to parse a plain text file using Python. This
    process can be implemented for other log files, including those from firewalls,
    web servers, or other applications and services. Following these steps, we can
    identify repetitive data structures that lend themselves to scripts, process their
    data, and output results to the user. With our iterative build process, we implemented
    a test-then-code approach where we built a working prototype and then continually
    enhanced it into a viable and reliable forensic tool.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Python解析普通文本文件。这个过程可以用于其他日志文件，包括防火墙、Web服务器或其他应用程序和服务的日志文件。按照这些步骤，我们可以识别出适合脚本的重复数据结构，处理它们的数据，并将结果输出给用户。通过我们的迭代构建过程，我们实现了一个测试-然后-编码的方法，其中我们建立了一个工作原型，然后不断改进它成为一个可行且可靠的取证工具。
- en: In addition to the text format we explored here, some files have a more concrete
    structure and are stored in a serialized format. Other files, such as HTML, XML,
    and JSON, file structure data in a manner that can be readily converted into a
    series of Python objects. The code for this project can be downloaded from GitHub
    or Packt, as described in the *Preface*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里探讨的文本格式外，还有一些文件具有更具体的结构，并以序列化格式存储。其他文件，如HTML、XML和JSON，以一种可以轻松转换为一系列Python对象的方式存储数据。 该项目的代码可以从GitHub或Packt下载，如*前言*中所述。
- en: In the next chapter, we will explore the methods in Python that we can use to
    parse, manipulate, and interact with these structured formats.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在Python中解析、操作和与这些结构化格式交互的方法。
