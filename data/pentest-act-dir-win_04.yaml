- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Credential Access in Domain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域中的凭证访问
- en: It was difficult to choose the order of *Chapters 4*, *5* and *6*, as they are
    all closely interconnected. We are not going to cover how to dump secrets from
    the host (LSASS, DPAPI, Credential Manager, etc.). Instead, we will keep our focus
    on Active Directory. This chapter starts with discussing ways to obtain credentials
    in clear text in the domain. Then, we will explore various techniques to capture
    the hash, such as forced authentication and poisoning. Relay will be covered later
    in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093), *Lateral Movement*. After
    that will be an introduction to the Kerberos authentication protocol and different
    styles of roasting the three-headed dog. Finally, we will discuss native security
    mechanisms for password management, such as **Local Administrator Password Solution**
    (**LAPS**) and **Group Managed Service Account** (**gMSA**), and ways to recover
    privileged credentials from them. As a final note, the DCSync attack together
    with ways to dump hashes from the ntds.dit domain controller will be explained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 选择*第 4 章*、*第 5 章*和*第 6 章*的顺序很困难，因为它们之间有很强的关联性。我们不会涉及如何从主机（如 LSASS、DPAPI、凭证管理器等）转储机密数据。相反，我们将专注于
    Active Directory。本章从讨论如何在域中获取明文凭证开始。然后，我们将探索捕获哈希的各种技术，例如强制认证和投毒。中继攻击将在[ *第 5 章*](B18964_05.xhtml#_idTextAnchor093)中讨论，*横向移动*。接下来将介绍
    Kerberos 认证协议以及如何“烤”这只三头犬的不同方法。最后，我们将讨论本地密码管理的安全机制，如**本地管理员密码解决方案**（**LAPS**）和**组管理服务账户**（**gMSA**），以及如何从中恢复特权凭证。最后，还将解释
    DCSync 攻击及其从 ntds.dit 域控制器导出哈希值的方式。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Clear-text credentials in the domain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域中的明文凭证
- en: Capture the hash
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获哈希
- en: Forced authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制认证
- en: Ways to roast Kerberos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解 Kerberos 的方法
- en: Automatic password management in the domain (LAPS or gMSA)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域中的自动密码管理（LAPS 或 gMSA）
- en: DCSync attack and NTDS credentials exfiltration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DCSync 攻击与 NTDS 凭证外泄
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will need to have access to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要具备以下条件：
- en: VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, eight CPU
    cores, and at least 55 GB of total space (more if you take snapshots)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware Workstation 或 Oracle VirtualBox，要求至少 16 GB 内存、八个 CPU 核心以及至少 55 GB 的存储空间（如果你使用快照，则需要更多空间）。
- en: A Linux-based operating system is strongly recommended
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强烈推荐使用基于 Linux 的操作系统
- en: Vagrant installed with the plugin for the corresponding virtualization platform
    and Ansible
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Vagrant，并且配置了相应虚拟化平台的插件，以及安装了 Ansible。
- en: From the GOADv2 project, we will use DC02, DC03, SRV02, and SRV03
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GOADv2 项目中，我们将使用 DC02、DC03、SRV02 和 SRV03。
- en: Clear-text credentials in the domain
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域中的明文凭证
- en: In this section, we will discuss different ways to obtain credentials in clear
    text. However, we will not touch on things such as the **password.txt** file left
    on the share, the default set of credentials for some applications, and pushing
    the **WDigest** parameter so a password can be dumped in clear text from memory.
    We also will not discuss Internal Monologue attack[1] that allows to obtain credentials
    without touching LSASS[1]. Our focus is solely on Active Directory. We may find
    a very old pre-Windows 2000 computer in the domain or the domain may be vulnerable
    to MS14-025 with the local administrator password encrypted in a Group Policy
    file. We can try our luck with password spraying or by searching for a password
    in an Active Directory user’s comment field.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论获取明文凭证的不同方法。然而，我们不会涉及诸如**password.txt**文件（存放在共享文件夹中的）默认凭证，或者推送**WDigest**参数以便从内存中以明文形式导出密码等问题。我们也不会讨论允许在不接触
    LSASS 的情况下获取凭证的 Internal Monologue 攻击[1]。我们的重点仅仅是 Active Directory。我们可能会在域中找到一台非常古老的
    Windows 2000 之前的计算机，或者域可能受到 MS14-025 漏洞的影响，其中本地管理员密码被加密存储在组策略文件中。我们可以通过密码喷射或搜索
    Active Directory 用户的注释字段来试试运气。
- en: Old, but still worth trying
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 老旧，但仍值得尝试
- en: Recently, I came across some intriguing research published by *Oddvar Moe* regarding
    pre-created computer accounts[2]. Apparently, checking the **Assign this computer
    account as a pre-Windows 2000 computer** field will turn the password for the
    computer account into the same as the computer name. This is the case when the
    computer account was manually created by the administrator and has never been
    used in the domain. To find such accounts, we look for the **UserAccountControl**
    flag value equaling **4128**. Then, we can extract a list of computers and try
    to log in using **CrackMapExec**. The **STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT**
    error message will flag that the guessed password for the computer account is
    correct. We need to change the password before we can use the computer account.
    It can be done with various tools, such as **kpasswd.py** or **rpcchangepwd.py**.
    Note that using Kerberos authentication will take away your need to change the
    password for the computer account. This behavior was discovered by *Filip* *Dragovic:*
    https://twitter.com/filip_dragovic/status/1524730451826511872.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我遇到了一些由*Oddvar Moe*发布的关于预创建计算机账户的有趣研究[2]。显然，检查**将此计算机账户指定为预Windows 2000计算机**字段将使计算机账户的密码与计算机名称相同。这种情况发生在计算机账户由管理员手动创建且从未在域中使用过时。要查找这样的账户，我们需要寻找**UserAccountControl**标志值为**4128**。然后，我们可以提取计算机列表并尝试使用**CrackMapExec**登录。**STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT**错误消息会标明猜测的计算机账户密码正确。我们需要在使用计算机账户之前更改密码。这可以通过各种工具完成，例如**kpasswd.py**或**rpcchangepwd.py**。需要注意的是，使用Kerberos身份验证将使你无需更改计算机账户密码。这一行为由*Filip*
    *Dragovic*发现：https://twitter.com/filip_dragovic/status/1524730451826511872。
- en: '**Group Policy Preferences** (**GPP**) were introduced in Windows 2008 R2 to
    help system administrators with various configuration changes. The most dangerous
    one was the ability to set the local administrator’s password on domain machines.
    The problem was that the password was stored in an XML file that every authenticated
    user could read in **\\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\**. While the password
    was encrypted using the AES-256 key, Microsoft published the private key on MSDN,
    effectively making encryption useless. A good blog post by *Sean Metcalf* with
    a deeper explanation is available[3]. The attack comprises essentially two commands
    – one line by *Oddvar Moe* to search for the value and a Linux one-liner by *0x00C651E0*
    to decrypt the password:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**组策略首选项**（**GPP**）在Windows 2008 R2中引入，旨在帮助系统管理员进行各种配置更改。最危险的一个功能是能够在域计算机上设置本地管理员密码。问题在于密码存储在每个经过身份验证的用户都能读取的XML文件中，文件路径为**\\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\**。虽然密码使用AES-256密钥进行了加密，但微软在MSDN上发布了私钥，从而使得加密变得毫无意义。*Sean
    Metcalf*的一篇博客详细解释了这一点，博客地址：[3]。这个攻击基本上由两条命令组成——*Oddvar Moe*提供的一条命令用于搜索该值，和*0x00C651E0*提供的Linux一行命令用于解密密码：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Other tools, such as **Gpp-Decrypt** and the Metasploit **post/windows/gather/credentials/gpp**
    module, are available as well. After the patch, this functionality was completely
    removed from GPP by Microsoft.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具，如**Gpp-Decrypt**和Metasploit的**post/windows/gather/credentials/gpp**模块也可用。修补程序发布后，微软彻底移除了GPP中的此功能。
- en: Password in the description field
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述字段中的密码
- en: 'During the enumeration, we may be lucky and find the password in the description
    field of the user profile in Active Directory. An example is shown in the following
    screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举过程中，我们可能会幸运地在Active Directory中用户配置文件的描述字段找到密码。以下截图展示了一个例子：
- en: '![](image/B18964_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_01.jpg)'
- en: Figure 4.1 – Password in the description field
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 描述字段中的密码
- en: Even if there is no password in the description field, it is a good idea to
    examine it, as we may find useful information about the account’s purpose, instructions
    to the IT staff, and other valuable bits. However, such an account can be a honeypot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使描述字段中没有密码，检查它也是一个好主意，因为我们可能会找到关于账户用途的有用信息、IT工作人员的指示以及其他有价值的内容。然而，这样的账户可能是蜜罐。
- en: Password spray
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码喷洒
- en: 'Another way we can try to guess the correct set of credentials is with a password
    spray. There are different approaches we can take; for example, try the username
    as the password. Before starting, it is very important to review the password
    policy to avoid a lockout. If **NULL** session binding is not allowed, we need
    a set of valid credentials to pull the password policy. We can do it with the
    help of an amazing tool – **CrackMapExec**[4]:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种猜测正确凭证的方式是进行密码喷射。我们可以采取不同的方式，例如，尝试将用户名作为密码。在开始之前，非常重要的一点是要先查看密码策略，以避免触发锁定。如果**NULL**会话绑定不被允许，我们需要一组有效的凭证来拉取密码策略。我们可以通过一个非常强大的工具——**CrackMapExec**[4]来实现：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of the command is shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果如下面的截图所示：
- en: '![](image/B18964_04_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_02.jpg)'
- en: Figure 4.2 – Password policy enumeration
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 密码策略枚举
- en: There are various PowerShell commands we can use to pull the policy, such as
    **Get-DomainPolicyData** from PowerView or the native **Get-ADDefaultDomainPasswordPolicy**
    command from the Active Directory module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种PowerShell命令来拉取策略，例如来自PowerView的**Get-DomainPolicyData**命令，或者来自Active
    Directory模块的本地**Get-ADDefaultDomainPasswordPolicy**命令。
- en: 'Now that we know the password policy and lockout rules and hopefully have a
    list of the users, we can start our spray. CrackMapExec provides different options
    for performing a spray, for example, using lists, one-to-one matches, and wordlists.
    Let’s try to perform a spray where the username is the same as the password. We
    can run a command where we try to log in to all machines in the subnet over SMB
    (it is very loud and not OpSec safe):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了密码策略和锁定规则，并且希望能够获取到用户列表，我们可以开始进行喷射攻击。CrackMapExec提供了执行喷射的不同选项，例如，使用列表、一对一匹配以及字典列表。让我们尝试进行一种用户名和密码相同的喷射攻击。我们可以运行一个命令，尝试通过SMB登录子网内的所有机器（这种方式非常显眼，并且不符合操作安全要求）：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the previous command is shown in the following screenshot (user
    **hodor** has password **hodor**):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出如下面的截图所示（用户**hodor**的密码是**hodor**）：
- en: '![](image/B18964_04_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_03.jpg)'
- en: Figure 4.3 – Successful password spray
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 成功的密码喷射
- en: There are other tools that can be used for a spray, such as **kerbrute**[5]
    by *ropnop* and **DomainPasswordSpray**[6] by *dafthack*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可以用于喷射的工具，比如**kerbrute**[5]（*ropnop*开发）和**DomainPasswordSpray**[6]（*dafthack*开发）。
- en: Before performing a spray, it is important to carefully enumerate domain users,
    in order not to trigger possible decoy accounts. Also, wisely choose the interval
    between sprays, as a large number of failed login attempts (event ID 4625) will
    trigger an investigation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行喷射攻击之前，仔细枚举域用户是非常重要的，以避免触发可能的诱饵账户。此外，合理选择喷射之间的间隔，因为大量的失败登录尝试（事件ID 4625）将会触发调查。
- en: In the next section, we will cover how to capture the hash and avoid confusion
    in terminology.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何捕获哈希并避免术语混淆。
- en: Capture the hash
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获哈希
- en: 'This section will be focused on capturing the hash, the number-one step in
    a well-known attack: NTLM relay. As an introduction to this theme, I highly encourage
    you to read the most comprehensive guide about this attack[7].'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于捕获哈希，这是一个广为人知的攻击中的第一步：NTLM转发。为了更好地理解这一主题，我强烈建议你阅读关于该攻击的最全面的指南[7]。
- en: Firstly, we need to cover a bit of a theory. The NTLM authentication protocol
    is used for network authentication and has two versions. It uses a *zero-knowledge
    proof* concept, meaning that credentials have never been transmitted over the
    network. It uses a challenge-response scheme, where the server sends a random
    set of data and client responses with a value, which is a result of hashing this
    data together with some extra parameters and the client’s secret key. As an attacker,
    we are interested in capturing this valid NTLM response from the client. Next,
    we can try to crack the hash or relay it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要稍微介绍一下理论部分。NTLM认证协议用于网络认证，并且有两个版本。它使用*零知识证明*的概念，意味着凭证从未通过网络传输。它采用挑战-响应机制，其中服务器发送一组随机数据，客户端则以一个值响应，这个值是将这些数据与一些额外参数和客户端的密钥一起哈希后的结果。作为攻击者，我们的目标是捕获客户端有效的NTLM响应。接下来，我们可以尝试破解哈希或转发它。
- en: 'NTLMv1 is deprecated and not considered secure. However, it is possible to
    see NTLMv1 in use in older environments. There are two techniques to capture the
    hash: **Man in the Middle** (**MITM**) and **coerced authentication**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NTLMv1已经被弃用，且不被认为是安全的。然而，在较旧的环境中，仍然有可能看到NTLMv1的使用。捕获哈希有两种技术：**中间人攻击**（**MITM**）和**强制认证**。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'I recommend you refer to this resource if anything is not clear in the following
    text: [https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications](https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下文本中有任何不清楚的地方，建议您参考此资源：[https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications](https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications)。
- en: 'Let us start with network-related attacks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与网络相关的攻击开始：
- en: '**ARP poisoning** is possible when an attacker is sitting between the client
    and the server. The success ratio of this attack depends on the network topology
    and hardening. Also, it can cause severe network disruptions.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARP中毒**发生在攻击者位于客户端和服务器之间时。此攻击的成功率取决于网络拓扑结构和加固情况。此外，它可能导致严重的网络中断。'
- en: '**DNS spoofing** requires the attacker to introduce a malicious DNS server
    in the network for the clients via ARP/DHCPv6 spoofing. Then, the attacker can
    reply to the received client’s requests.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DNS欺骗**要求攻击者通过ARP/DHCPv6欺骗在网络中引入恶意DNS服务器，以便客户端可以通过该服务器进行通信。然后，攻击者可以回复收到的客户端请求。'
- en: '**DHCP poisoning** happens by injecting a malicious WPAD or DNS server address
    into the client’s DHCP reply. The client’s request for **wpad.dat** will trigger
    a malicious server to request authentication.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DHCP中毒**是通过向客户端的DHCP回复中注入恶意WPAD或DNS服务器地址来实现的。客户端请求**wpad.dat**时会触发恶意服务器请求认证。'
- en: '**DHCPv6 spoofing** is possible because IPv6 in Windows has higher priority
    than IPv4 and it is a multicast protocol. The attacker can provide the client
    with a malicious config and proceed with DNS spoofing later.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DHCPv6欺骗**之所以可能，是因为Windows中的IPv6优先级高于IPv4，并且它是一个多播协议。攻击者可以为客户端提供恶意配置，稍后继续进行DNS欺骗。'
- en: '**Local-Link Multicast Name Resolution (LLMNR), NetBIOS Name Service (NBT-NS),
    and Multicast Domain Name System (mDNS) spoofing** are possible because of multicast
    name resolution protocols used in Windows environments. If DNS fails, these protocols
    will be used for resolution as a fallback option. The attacker can answer queries
    and then ask the client to authenticate.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地链接多播名称解析（LLMNR）、NetBIOS名称服务（NBT-NS）和多播域名系统（mDNS）欺骗**是可能的，因为Windows环境中使用了多播名称解析协议。如果DNS解析失败，这些协议将作为回退选项进行解析。攻击者可以回答查询，然后要求客户端进行身份验证。'
- en: '**WSUS spoofing** requires ARP poisoning and an evil WSUS server to deploy
    malicious updates to the clients.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WSUS欺骗**需要ARP中毒和一个恶意WSUS服务器来向客户端部署恶意更新。'
- en: '**ADIDNS poisoning** is an attack on Active Directory-integrated DNS. The idea
    is to inject malicious DDNS records.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADIDNS中毒**是针对Active Directory集成DNS的攻击。其思路是注入恶意DDNS记录。'
- en: '**WPAD spoofing** abuses the feature of helping clients locate proxy configuration
    scripts. After the MS16-077 security update, this attack is only possible through
    ADIDNS or DHCPv6 spoofing.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WPAD欺骗**利用了帮助客户端定位代理配置脚本的功能。在MS16-077安全更新之后，此攻击只能通过ADIDNS或DHCPv6欺骗实现。'
- en: 'If the NTLMv1 protocol is allowed in the network, we can try to downgrade the
    authentication to obtain the NTLMv1 response. It uses weak DES encryption. We
    add a magical challenge value (**1122334455667788**) to the **Responder’s**[8]
    configuration file (**/etc/responder/Responder.conf**) and start it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络中允许使用NTLMv1协议，我们可以尝试将身份验证降级到NTLMv1，以获得NTLMv1响应。它使用弱DES加密。我们将一个神奇的挑战值（**1122334455667788**）添加到**Responder**的配置文件（**/etc/responder/Responder.conf**）中并启动它：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our lab, we do not have NTLMv1 enabled; however, after spinning up Responder,
    in a few minutes, we captured the NTLMv2 response for user **eddard.stark**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实验室中，NTLMv1未启用；然而，在启动Responder之后，几分钟内，我们捕获了用户**eddard.stark**的NTLMv2响应：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](image/B18964_04_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_04.jpg)'
- en: Figure 4.4 – Capturing the NTLMv2 response
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 捕获NTLMv2响应
- en: To simulate this activity, the lab author created a scheduled task on **winterfell**
    as the user **eddard.stark** is trying to connect over SMB to the server by DNS
    name with a typo. As the DNS server cannot resolve the name, broadcast protocols
    kicked in and we captured the NTLMv2 response.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这一活动，实验室作者在**winterfell**上创建了一个计划任务，用户**eddard.stark**尝试通过带有拼写错误的DNS名称通过SMB连接到服务器。由于DNS服务器无法解析该名称，广播协议被触发，我们捕获到了NTLMv2响应。
- en: To mitigate such capturing possibilities, ideally, we need to stop using NTLM.
    If this is not possible (as is often the case), a strong password policy and strict
    hardening on the network level should be applied. The idea is to disable all unnecessary
    multicasting protocols and NTLMv1 (in Group Policy, set **LAN Manager** to **Send
    NTLMv2 responses only. Refuse LM & NTLM**). We will provide recommendations for
    mitigating relay in the next chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这种捕获的可能性，理想情况下，我们需要停止使用 NTLM。如果无法做到这一点（这通常是情况），应在网络层面应用强密码策略并严格加固。其思路是禁用所有不必要的多播协议和
    NTLMv1（在组策略中，将 **LAN Manager** 设置为 **仅发送 NTLMv2 响应。拒绝 LM 和 NTLM**）。我们将在下一章提供有关减轻中继攻击的建议。
- en: 'But what if these network protocols are disabled and MITM is not really an
    option? There are a few ways we can force the client to authenticate to us. Recently,
    some intriguing research was published by *MDSec*[9]. There are certain types
    of files that we can put on the writable share and Windows will automatically
    authenticate and send an NTLM response to a remote machine: **SCF,** **URL**,
    **library-ms**, and **searchConnector-ms**. An important remark is that the attacker’s
    machine should be within the local intranet zone, meaning that the network connection
    can be established by using a UNC path. The idea in the research was to use a
    WebDAV-enabled HTTP server to collect hashes, which is called **farmer**, and
    the tool to create files is called **crop**. The following two commands will capture
    the hash:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果这些网络协议被禁用且 MITM 实际上不可行怎么办？我们可以通过几种方式强制客户端进行身份验证。最近，*MDSec*[9] 发布了一些有趣的研究。我们可以将某些类型的文件放置在可写共享文件夹中，Windows
    会自动进行身份验证并将 NTLM 响应发送到远程机器：**SCF**、**URL**、**library-ms** 和 **searchConnector-ms**。一个重要的说明是，攻击者的机器应该位于本地内联网区域内，这意味着可以通过
    UNC 路径建立网络连接。该研究的思路是使用启用 WebDAV 的 HTTP 服务器来收集哈希，这被称为 **farmer**，而用于创建文件的工具被称为
    **crop**。以下两个命令将捕获哈希：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also create a .URL file manually. The idea is that we put an environment
    variable in the file, so Explorer on the victim’s machine when viewing the folder
    will proactively look up this variable before sending the request, effectively
    connecting to our file share without any user interaction. This behavior allows
    us to catch the NTLMv2 response with Responder. The URL file content could look
    like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以手动创建一个 .URL 文件。其原理是我们将一个环境变量放入文件中，这样受害者机器上的资源管理器在查看文件夹时，会在发送请求之前主动查找该变量，从而有效地连接到我们的文件共享，无需任何用户交互。这种行为使我们能够通过
    Responder 捕获 NTLMv2 响应。该 .URL 文件的内容可能如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result can be seen as follows in Responder when **jon.snow** opens a publicly
    shared folder:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，**jon.snow** 打开一个公开共享的文件夹时，在 Responder 中可以看到结果：
- en: '![](image/B18964_04_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_05.jpg)'
- en: Figure 4.5 – NTLMv2 response capture after opening a public share with a .URL
    file
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 打开公共共享文件夹并使用 .URL 文件后捕获的 NTLMv2 响应
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Other interesting places to steal NTLMv2 responses are thoroughly described
    in this blog post by *Osanda* *Malith*: https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 盗取 NTLMv2 响应的其他有趣位置在 *Osanda* *Malith* 的博文中有详细描述：[https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/](https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/)。
- en: To prevent forced authentication of the file types mentioned previously, we
    need to turn off the display of thumbnails on network folders via the Group Policy
    setting. Next, we will cover another powerful technique to capture the hash, if
    all previous attempts were not successful.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止之前提到的文件类型强制身份验证，我们需要通过组策略设置关闭网络文件夹的缩略图显示。接下来，我们将介绍另一种强大的技术，用于捕获哈希，如果之前的所有尝试都未成功的话。
- en: Forced authentication
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制身份验证
- en: We have covered MITM capabilities and now will discuss in detail various ways
    to force authentication. The idea is that a standard user can force the target
    machine account (usually a domain controller) to connect to an arbitrary target.
    This is made possible through an automatic authentication attempt. You can find
    a repository with 15 known methods in 5 protocols[10]. Now, let’s dive a bit deeper
    into each method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 MITM 能力，现在将详细讨论各种强制身份验证的方法。其思路是标准用户可以强制目标机器账户（通常是域控制器）连接到任意目标。这是通过自动身份验证尝试实现的。你可以在一个包含
    15 种已知方法的 5 种协议的库中找到相关内容[10]。接下来，我们将深入探讨每种方法。
- en: MS-RPRN abuse (PrinterBug)
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MS-RPRN 滥用（PrinterBug）
- en: This is a *won’t-fix* bug, which is enabled by default in every Windows environment.
    The idea is that by using a domain username and password, the attacker can trigger
    the **RpcRemoteFindFirstPrinterChangeNotificationEx** method and force authentication
    over SMB. We will demonstrate this attack later when discussing Kerberos’s unconstrained
    delegation in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093). A go-to tool for
    this abuse is called **SpoolSample**[11] and can be found on GitHub.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 *不会修复* 的 bug，默认在每个 Windows 环境中启用。其原理是，攻击者通过使用域用户名和密码，可以触发 **RpcRemoteFindFirstPrinterChangeNotificationEx**
    方法，并强制通过 SMB 进行身份验证。我们将在后面讨论 Kerberos 的无约束委派时在[*第 5 章*](B18964_05.xhtml#_idTextAnchor093)中演示此攻击。此滥用的常用工具名为
    **SpoolSample**[11]，可在 GitHub 上找到。
- en: MS-EFSR abuse (PetitPotam)
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MS-EFSR 滥用（PetitPotam）
- en: The **Encrypting File System Remote** (**EFSR**) protocol can be abused via
    a number of RPC calls, such as **EfsRpcOpenFileRaw**, to coerce Windows hosts
    to authenticate to other machines. This RPC interface is available through different
    SMB pipes, including those discussed in [*Chapter 3*](B18964_03.xhtml#_idTextAnchor040),
    **\pipe\samr** and **\pipe\lsarpc**. To demonstrate this attack, we will use this
    proof of concept[12].
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密文件系统远程**（**EFSR**）协议可以通过多个 RPC 调用滥用，如 **EfsRpcOpenFileRaw**，迫使 Windows
    主机对其他计算机进行身份验证。此 RPC 接口可通过不同的 SMB 管道访问，包括在[*第 3 章*](B18964_03.xhtml#_idTextAnchor040)中讨论的
    **\pipe\samr** 和 **\pipe\lsarpc**。为了演示这一攻击，我们将使用此概念验证[12]。'
- en: 'We will run this command on **castelblack** with the attacker and domain controller
    IP addresses:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 **castelblack** 上运行此命令，带有攻击者和域控制器的 IP 地址：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will catch the domain controller’s hash with Responder:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Responder 捕获域控制器的哈希：
- en: '![](image/B18964_04_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_06.jpg)'
- en: Figure 4.6 – PetitPotam coerced authentication successful
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – PetitPotam 强制身份验证成功
- en: In [*Chapter 8*](B18964_08.xhtml#_idTextAnchor163), we will show how the domain
    controller’s hash can be relayed to the server running Active Directory Certificate
    Services, effectively allowing us to compromise the whole domain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 8 章*](B18964_08.xhtml#_idTextAnchor163)中，我们将展示如何将域控制器的哈希转发到运行活动目录证书服务的服务器，有效地使我们能够危及整个域。
- en: WebDAV abuse
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebDAV 滥用
- en: The idea behind WebDAV abuse is to find machines running this service in the
    domain. The **WebclientServiceScanner**[13] tool can help with such a task. If
    no clients have the **WebClient** service running, it can be enabled remotely
    via the **searchConnector-ms** file[14]. Then, we can use **PetitPotam** from
    previously, combined with **Resource-Based Constrained Delegation** (**RBCD**)
    abuse. We will discuss RBCD abuse in the Kerberos section of [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: WebDAV 滥用的想法是找到在域中运行此服务的计算机。**WebclientServiceScanner**[13] 工具可以帮助完成此任务。如果没有客户端运行
    **WebClient** 服务，则可以通过 **searchConnector-ms** 文件[14] 远程启用该服务。然后，我们可以使用之前的 **PetitPotam**，结合
    **基于资源的受限委派**（**RBCD**）滥用。我们将在 [*第 5 章*](B18964_05.xhtml#_idTextAnchor093) 的 Kerberos
    部分讨论 RBCD 滥用。
- en: MS-FSRVP abuse (ShadowCoerce)
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MS-FSRVP 滥用（ShadowCoerce）
- en: '**Microsoft’s File Server Remote VSS Protocol** (**MS-FSRVP**) is used to make
    shadow copies on the remote computer. Two methods are supported. Invocation is
    possible through an SMB named pipe. An attack is not possible if **File Server
    VSS Agent Service** is not enabled on the target machine. Also, patch KB5014692
    prevents coercion attacks. I was able to run a proof of concept[15] but did not
    manage to get the NTLMv2 response on Windows Server 2019 (c**astelblack**). The
    result of the coercion attempt is shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**微软文件服务器远程 VSS 协议**（**MS-FSRVP**）用于在远程计算机上创建影像副本。支持两种方法。调用可以通过 SMB 命名管道进行。如果目标计算机未启用
    **文件服务器 VSS 代理服务**，则无法进行攻击。此外，补丁 KB5014692 阻止了强制攻击。我能够运行概念验证[15]，但未能在 Windows
    Server 2019（**castelblack**）上获得 NTLMv2 响应。以下是强制尝试的结果截图：'
- en: '![](image/B18964_04_07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_07.jpg)'
- en: Figure 4.7 — ShadowCoerce running
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 — ShadowCoerce 运行中
- en: The next method also requires a service to be up and running on the target machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法也需要目标计算机上有一个服务在运行。
- en: MS-DFSNM abuse (DFSCoerce)
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MS-DFSNM 滥用（DFSCoerce）
- en: The same as other coerce methods, this one uses the RPC interface available
    through an SMB named pipe (**\pipe\netdfs**) in Microsoft’s Distributed File System
    Namespace Management protocol. *Filip Dragovic* found two methods (**NetrDfsAddStdRoot**
    and **NetrDfsRemoveStdRoot**) that can be used to force authentication. The proof-of-concept
    code was published on GitHub[16]. Simply run the command against only the domain
    controller with DFS running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他强制方法相同，该方法使用通过微软的分布式文件系统命名空间管理协议中的SMB命名管道（**\pipe\netdfs**）提供的RPC接口。*Filip
    Dragovic* 发现了两种方法（**NetrDfsAddStdRoot** 和 **NetrDfsRemoveStdRoot**），可以用来强制认证。概念验证代码已发布在GitHub上[16]。只需对运行DFS的域控制器运行该命令即可。
- en: The next section will cover another authentication protocol – Kerberos. Understanding
    the mechanisms and workflow of the protocol is crucial for understanding material
    further in the book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将涵盖另一种认证协议——Kerberos。理解该协议的机制和工作流对于进一步理解本书内容至关重要。
- en: Roasting the three-headed dog
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烤制三头犬
- en: It was inevitable that we would reach a point where we must discuss and understand
    Kerberos. This authentication protocol was built to access services in the network
    by presenting a valid ticket.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可避免地将达到一个必须讨论并理解Kerberos的时刻。该认证协议旨在通过提供有效的票证来访问网络中的服务。
- en: Kerberos 101
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kerberos 101
- en: We need a bit more of an understanding of how the protocol works before we can
    discuss the attack venues available for us. As a good starting point, I can recommend
    the blog post by *hackndo*[17]
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论可用的攻击途径之前，我们需要更多地理解协议的工作原理。作为一个好的起点，我推荐 *hackndo* 的博客文章[17]。
- en: 'We have three main subjects – the client, service, and **Key Distribution Center**
    (**KDC**), which is the domain controller. The following diagram[18], which was
    published on the Microsoft website, explains how it works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个主要的主体——客户端、服务和**密钥分发中心**（**KDC**），即域控制器。以下图表[18]，该图表发布于微软官网，解释了它的工作原理：
- en: '![](image/B18964_04_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_08.jpg)'
- en: Figure 4.8 – Kerberos in a nutshell
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – Kerberos概述
- en: Now let follow the authentication process in more details step-by-step.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地一步一步跟随认证过程。
- en: '**KRB_AS_REQ** (**Kerberos Authentication Service Request**) is sent by the
    client to KDC and contains various information, most importantly, a timestamp
    that is encrypted with the hashed version of the password. If the client exists,
    then KDC will try to decrypt the timestamp by using the received hash of the client’s
    password. If everything goes smoothly, the session key will be generated.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KRB_AS_REQ**（**Kerberos认证服务请求**）由客户端发送到KDC，并包含各种信息，最重要的是一个时间戳，该时间戳使用密码的哈希版本进行加密。如果客户端存在，那么KDC将尝试通过使用接收到的客户端密码的哈希值解密时间戳。如果一切顺利，会生成会话密钥。'
- en: '**KRB_AS_REP** (**Kerberos Authentication Service Reply**) will contain a **Ticket-Granting
    Ticket** (**TGT**), which is encrypted by the client’s password hash session key,
    the validity period, and other information. It is encrypted by the KDC key, so
    only the domain controller can read this ticket.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KRB_AS_REP**（**Kerberos认证服务回复**）将包含**票证授予票证**（**TGT**），该票证由客户端的密码哈希会话密钥加密，包含有效期和其他信息。它由KDC密钥加密，因此只有域控制器可以读取此票证。'
- en: '**KRB_TGS_REQ** (**Kerberos Ticket Granting Service Request**) is sent by the
    client when it wants to use a service. It contains the TGT, the service, and an
    authenticator. The authenticator is encrypted by the session key from *step 2*
    and contains the username and timestamp. If the session key from the TGT successfully
    decrypted the authenticator and the data matches, then authentication is successful.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KRB_TGS_REQ**（**Kerberos票证授予服务请求**）由客户端在想要使用某个服务时发送。它包含TGT、服务和认证器。认证器由*步骤2*中的会话密钥加密，并包含用户名和时间戳。如果TGT中的会话密钥成功解密了认证器，并且数据匹配，那么认证成功。'
- en: '**KRB_TGS_REP** (**Kerberos Ticket Granting Service Reply**) will contain the
    requested service name, client’s name, and session key for the service and client.
    The ticket is encrypted with the service’s key and with the session key from *step
    2*. Effectively, the client will decrypt the ticket and extract a new session
    key and ticket to communicate with the service.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KRB_TGS_REP**（**Kerberos票证授予服务回复**）将包含请求的服务名称、客户端的名称以及服务和客户端的会话密钥。票证使用服务的密钥和*步骤2*中的会话密钥加密。实际上，客户端将解密票证，并提取一个新的会话密钥和票证，以与服务进行通信。'
- en: '**KRB_AP_REQ** (**Kerberos Application Request**) is sent by the client with
    a new authenticator and TGS. The authenticator is encrypted with the session key
    inside TGS. Verification is like in *step 2*.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**KRB_AP_REQ**（**Kerberos 应用请求**）由客户端发送，包含新的身份验证器和 TGS。身份验证器使用 TGS 中的会话密钥加密。验证方式如*步骤
    2*所示。'
- en: Now, we will discuss how things can go wrong here. The following attacks are
    quite easy to perform, but we need to be OpSec aware when performing them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论事情可能出错的情况。以下攻击执行起来相当简单，但在执行时我们需要保持 OpSec 意识。
- en: ASREQRoast
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASREQRoast
- en: We will start with an attack that does not abuse any misconfiguration of the
    protocol and requires a powerful MITM attack. The idea is to intercept the KRB_AS_REQ
    packet and attempt to crack the hash of the user’s password. This hash is used
    to encrypt the timestamp in the pre-authentication stage. You can read the original
    research that covers this attack in detail[19]. In essence, we should have the
    MITM position; we passively collect the traffic and then use a tool such as **Pcredz**[20]
    to extract hashes that we can try to crack later with hashcat[21]. The main caveat
    in this attack is the requirement to obtain the MITM position.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一种不利用协议配置错误且需要强大 MITM 攻击的攻击开始。这个思路是拦截 KRB_AS_REQ 数据包并尝试破解用户密码的哈希。该哈希用于加密预身份验证阶段的时间戳。你可以阅读详细讨论此攻击的原始研究[19]。本质上，我们应该拥有
    MITM 位置；我们被动地收集流量，然后使用如**Pcredz**[20]之类的工具提取哈希，稍后可以使用 hashcat[21] 来尝试破解。这种攻击的主要警告是需要获取
    MITM 位置。
- en: KRB_AS_REP roasting (ASREPRoast)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KRB_AS_REP 烤制（ASREPRoast）
- en: 'This attack is possible when there is a misconfiguration made in Active Directory
    by enabling **Do not require Kerberos preauthentication**. This can be seen in
    the user object properties:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Active Directory 中配置错误，启用了**不要求 Kerberos 预身份验证**时，就可能发生此攻击。可以在用户对象属性中看到这一点：
- en: '![](image/B18964_04_09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_09.jpg)'
- en: Figure 4.9 – User with pre-authentication enabled
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 启用了预身份验证的用户
- en: 'For the attack execution, we will use Rubeus[22]. But before typing commands,
    we need to discuss some OpSec considerations. We know from the documentation that
    Rubeus will find all misconfigured accounts and try to roast them. This will create
    a security event on the domain controller with *ID=4768* and certain values (**Ticket
    Encryption Type 0x17, Pre-Authentication** **Type: 0**):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于攻击执行，我们将使用 Rubeus[22]。但在输入命令之前，我们需要讨论一些 OpSec 考虑事项。根据文档，我们知道 Rubeus 会找到所有配置错误的帐户并尝试烤制它们。这将在域控制器上生成安全事件，*ID=4768*
    和某些值（**票据加密类型 0x17，预身份验证** **类型：0**）：
- en: '![](image/B18964_04_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_10.jpg)'
- en: Figure 4.10 – ASREPRoasting detected
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 发现 ASREPRoasting 攻击
- en: 'A much better way is to pull the list of misconfigured accounts first, do a
    bit more reconnaissance (i.e., checking for honeypot accounts), and then roast
    them. We can use PowerView for this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是先提取配置错误的帐户列表，进行更多的侦查（例如，检查蜜罐帐户），然后再进行烤制。我们可以使用 PowerView 来执行此操作：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The LDAP search filter and output are shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 搜索过滤器和输出显示在以下截图中：
- en: '![](image/B18964_04_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_11.jpg)'
- en: Figure 4.11 – List of users vulnerable to AS-REP roasting
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 易受 AS-REP 烤制攻击的用户列表
- en: 'Now, we can run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下命令：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下图所示：
- en: '![](image/B18964_04_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_12.jpg)'
- en: Figure 4.12 – Hash ready for cracking
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 哈希已准备好破解
- en: We can use **john** (**--format=krb5asrep**) or **hashcat** (**-m 18200**) to
    crack the hash.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**john**（**--format=krb5asrep**）或**hashcat**（**-m 18200**）来破解哈希。
- en: 'To mitigate this attack, we can try the following measures:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻此攻击，我们可以尝试以下措施：
- en: By default, pre-authentication is enabled, so check why it was disabled for
    certain accounts
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，预身份验证已启用，因此请检查为什么某些帐户被禁用了此功能
- en: Apply additional password complexity requirements for accounts with disabled
    pre-authentication
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对禁用预身份验证的帐户应用额外的密码复杂性要求
- en: Ensure that only privileged users can change the pre-authentication attribute
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只有特权用户可以更改预身份验证属性
- en: Monitor events for changing the pre-authentication attribute (ID 4738 and ID
    5136)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控更改预身份验证属性的事件（ID 4738 和 ID 5136）
- en: Monitor for roasting attempts (ID 4768 and ID 4625)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控烤制尝试（ID 4768 和 ID 4625）
- en: Kerberoasting
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kerberoasting
- en: The idea behind this attack is to request a **Service Ticket** (**ST**) and
    crack the hash to obtain the service account’s password. To be able to request
    the ST, we need to be authenticated in the domain (possess a valid TGT) and know
    the **Service Principal Name** (**SPN**). The SPN is a unique service name in
    the forest. In most cases, services run under machine accounts that have long
    and complex passwords. But if a service account has a manually set password and
    SPN, we can try our luck.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击的核心思想是请求一个**服务票证**（**ST**），并破解哈希以获取服务账户的密码。为了能够请求 ST，我们需要在域中进行身份验证（拥有有效的
    TGT）并知道**服务主体名称**（**SPN**）。SPN 是林中唯一的服务名称。在大多数情况下，服务是由机器账户运行的，这些账户有着长且复杂的密码。但如果一个服务账户有手动设置的密码和
    SPN，我们可以试试运气。
- en: There is an outstanding blog post that covers Kerberoasting and OpSec in detail
    with examples[23]. We will cover the material from there, but the original research
    is an absolute must-read.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有一篇出色的博客文章详细介绍了 Kerberoasting 和 OpSec 的内容，并附有示例[23]。我们会在这里涵盖其中的内容，但原始研究是绝对值得一读的。
- en: 'In general, the strategy stays the same – find accounts with an SPN and roast
    them. Possible OpSec failures that can happen during AS-REP roasting are also
    relevant here as well as the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，策略保持不变——找到带有 SPN 的账户并进行 roasting。AS-REP roasting 中可能发生的 OpSec 失败同样适用于这里，以及以下内容：
- en: Too-wide LDAP search filter
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP 搜索过滤器过于宽泛
- en: Multiple STs requested in a short period of time (security events with ID 4769),
    including for honeypot accounts
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在短时间内请求了多个 ST（安全事件 ID 为 4769），包括蜜罐账户
- en: Requesting STs with encryption downgrade
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求带有加密降级的 ST
- en: 'Now, we will discuss how to avoid a failure step by step. Enumeration is the
    key to success here. Depending on the size of the forest, we can run general LDAP
    searches with a focus on collecting information that will help us to choose the
    right target. In our lab, our initial enumeration can be done by filtering users,
    excluding **krbtgt** and disabled ones:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步讨论如何避免失败。枚举是成功的关键。根据林的大小，我们可以进行一般的 LDAP 搜索，重点收集有助于我们选择正确目标的信息。在我们的实验室中，最初的枚举可以通过过滤用户来完成，排除掉**krbtgt**和禁用的账户：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have one promising candidate named **sql_svc**. We can confirm with the
    help of PowerView that this user has an SPN:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个很有前途的候选用户，名为**sql_svc**。通过 PowerView，我们可以确认这个用户拥有一个 SPN：
- en: '![](image/B18964_04_13.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_13.jpg)'
- en: Figure 4.13 – User with SPN found
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 找到带有 SPN 的用户
- en: 'To ensure that we are not dealing with a honeypot, we can check that the object
    really exists in the domain. What are the privileges of this object? Will we really
    benefit from roasting it? Also, its **pwdLastSet** and **lastLogon** attributes
    should be self-explanatory. The next smart move is to check the encryption type
    in the **MsDS-SupportedEncryptionTypes** attribute. In Rubeus, there is a parameter
    to filter AES-enabled accounts: **/rc4opsec**. As a last step, run the following
    command to obtain the hash (the **/nowrap** option will output the hash as a one-liner):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不是在处理一个蜜罐，我们可以检查该对象是否确实存在于域中。这个对象的权限是什么？我们真的能从 roasting 它中受益吗？此外，它的**pwdLastSet**和**lastLogon**属性应该是显而易见的。接下来的聪明做法是检查**MsDS-SupportedEncryptionTypes**属性中的加密类型。在
    Rubeus 中，有一个参数可以过滤启用 AES 的账户：**/rc4opsec**。最后一步，运行以下命令来获取哈希值（**/nowrap**选项会将哈希值输出为一行）：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output after executing the preceding command is shown in the following
    screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述命令后的输出如下所示：
- en: '![](image/B18964_04_14.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_14.jpg)'
- en: Figure 4.14 – Kerberoasting
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – Kerberoasting 攻击
- en: Then, we can crack this hash with **john** **(--format=krb5tgs**) or **hashcat**
    (**-m 13100**). There is one important thing to add before we discuss mitigations.
    It is possible to perform targeted Kerberoasting if an attacker has the right
    to add an SPN to another account. We will discuss it in more detail in [*Chapter
    6*](B18964_06.xhtml#_idTextAnchor119), *Privilege Escalation*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 **john** （**--format=krb5tgs**）或 **hashcat**（**-m 13100**）来破解这个哈希。在我们讨论缓解措施之前，有一件重要的事情需要补充。如果攻击者有权将
    SPN 添加到其他账户上，就可以执行有针对性的 Kerberoasting 攻击。我们将在 [*第 6 章*](B18964_06.xhtml#_idTextAnchor119)中详细讨论这个问题，*权限提升*。
- en: There is a C# tool written by *Luct0r* that fully implements OpSec recommendations
    from the blog post and can be found on GitHub[24].
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个由*Luct0r*编写的 C# 工具，完全实现了博客文章中的 OpSec 推荐，且可以在 GitHub 上找到[24]。
- en: To mitigate such attacks, we need to avoid assigning SPNs to user accounts.
    If this is not possible, we can use **Group Managed Service Accounts** (**gMSA**)
    for automatic password management, which we will discuss in the next section.
    Also, honeypot accounts and prompt logging of the event and search filters can
    help to identify attacks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻此类攻击，我们需要避免将 SPN 分配给用户帐户。如果无法避免，我们可以使用 **组管理服务帐户** (**gMSA**) 进行自动密码管理，接下来我们将讨论这一点。此外，蜜罐帐户、事件日志的及时记录以及搜索过滤器可以帮助识别攻击。
- en: The next section will show how adversaries can abuse domain security enhancements
    if they are misconfigured.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将展示如果域安全增强配置错误，攻击者如何滥用这些增强功能。
- en: Automatic password management in the domain
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域中的自动密码管理
- en: Some of the attacks from previously, for example, MS14-025 and Kerberoasting,
    contributed to the development of password management automation. To resolve the
    problem of local administrator password rotation, LAPS was created. To tackle
    Kerberoasting, gMSA was introduced a bit later by Microsoft.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的一些攻击，如 MS14-025 和 Kerberoasting，推动了密码管理自动化的发展。为了解决本地管理员密码轮换问题，LAPS 应运而生。为了应对
    Kerberoasting，微软稍后引入了 gMSA。
- en: LAPS
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LAPS
- en: Now, we will deploy LAPS on **braavos** in the **essos** domain and discuss
    possible attack venues. I will follow this deployment guide[25]. The general steps
    include component installation, Active Directory schema extension, agent deployment
    on computers, and Group Policy configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 **essos** 域的 **braavos** 上部署 LAPS，并讨论可能的攻击路径。我将遵循此部署指南[25]。总体步骤包括组件安装、Active
    Directory 架构扩展、在计算机上部署代理和配置组策略。
- en: 'The installation is straightforward. Just download the **.msi** file and deploy
    it. After running the following command, your schema will be extended (run as
    schema admin):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程非常简单。只需下载 **.msi** 文件并进行部署。运行以下命令后，您的架构将会扩展（以架构管理员身份运行）：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output would be like what is shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下截图所示：
- en: '![](image/B18964_04_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_15.jpg)'
- en: Figure 4.15 – Schema update was successful
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 架构更新成功
- en: 'The next step is the most important as misconfiguration here may lead to compromise.
    We need to assign users who will be able to view administrator passwords. By default,
    these users are is **SYSTEM** and from the “**Domain Admins"** group. This time,
    we will add non-privileged users to this group:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是最关键的，因为此处的配置错误可能导致被攻破。我们需要指定可以查看管理员密码的用户。默认情况下，这些用户是 **SYSTEM** 和“**域管理员**”组中的成员。这一次，我们将添加非特权用户到此组中：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the output of the commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了命令的输出：
- en: '![](image/B18964_04_16.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_16.jpg)'
- en: Figure 4.16 – Grant user LAPS read rights
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 授予用户 LAPS 读取权限
- en: 'Now, we will change sides and discuss the attacker’s options. First, we need
    to understand whether LAPS is installed. There are a few ways to get an answer:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将换个角度，讨论攻击者的选择。首先，我们需要了解 LAPS 是否已安装。有几种方法可以得到答案：
- en: Examine computer object attributes for the **ms-Mcs-AdmPwdExpirationTime** attribute
    with the help of PowerView
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PowerView 查看计算机对象属性中的 **ms-Mcs-AdmPwdExpirationTime** 属性
- en: Search for **AdmPwd.dll** in **C:\Program Files\LAPS\CSE**
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **C:\Program Files\LAPS\CSE** 中搜索 **AdmPwd.dll**
- en: Search for a **Group Policy Object** (**GPO**) named *LAPS*, *passwords*, or
    similar; however, do not fully rely on naming
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索名为 *LAPS*、*passwords* 或类似的 **组策略对象** (**GPO**)，但不要完全依赖命名
- en: 'Considering we are logged in as a domain user, we should be able to discover
    who is allowed to read the LAPS password. This can be done with the help of BloodHound
    and PowerView. Also, **LAPSToolkit**[26] can be used as a tool to execute the
    full attack chain. The output after running **Invoke-ACLScanner** from PowerView
    is shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们作为域用户登录，我们应该能够发现哪些人被允许读取 LAPS 密码。这可以借助 BloodHound 和 PowerView 来完成。此外，**LAPSToolkit**[26]
    可以作为执行完整攻击链的工具。运行 PowerView 中的 **Invoke-ACLScanner** 后的输出如以下截图所示：
- en: '![](image/B18964_04_17.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_17.jpg)'
- en: Figure 4.17 – User found with ReadLAPS privileges
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 发现具有 ReadLAPS 权限的用户
- en: 'If we have compromised such a user, we can obtain the local administrator password
    with the help of the **Get-LAPSPasswords** PowerShell commandlet[27]. The output
    from this operation is shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经妥协了这样的用户，我们可以通过 **Get-LAPSPasswords** PowerShell 命令获取本地管理员密码[27]。此操作的输出如以下截图所示：
- en: '![](image/B18964_04_18.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_18.jpg)'
- en: Figure 4.18 – Local administrator password revealed
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 本地管理员密码泄露
- en: The only mitigations we can introduce here are being careful of who you delegate
    the right to reveal the password to and ensuring that you enforce an expiration
    time via Group Policy. This will help us to ensure passwords are changed regularly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此可以引入的唯一缓解措施是小心谁被委托有权揭示密码，并确保通过组策略强制设置过期时间。这将帮助我们确保密码定期更改。
- en: gMSA
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gMSA
- en: gMSA was introduced in Windows Server 2016 but can be leveraged from Windows
    Server 2012 and above. The idea behind it has much in common with LAPS’s creation,
    but instead of local administrator accounts, it is used for service accounts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: gMSA 在 Windows Server 2016 中引入，但可以在 Windows Server 2012 及以上版本中使用。它的理念与 LAPS
    的创建有许多相似之处，但与本地管理员账户不同，它用于服务账户。
- en: gMSA is an object type in Active Directory with attributes and permissions.
    The most interesting attributes are **msDS-ManagedPassword** (blob with a password)
    and **msDS-GroupMSAMembership** (who can read the blob). Let’s deploy gMSA and
    discuss the attacking steps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: gMSA 是活动目录中的一种对象类型，具有属性和权限。最有趣的属性是**msDS-ManagedPassword**（包含密码的二进制大对象）和**msDS-GroupMSAMembership**（谁可以读取该二进制大对象）。让我们部署
    gMSA 并讨论攻击步骤。
- en: 'The first step is to create gMSA using the following two commands (run them
    as the domain administrator, not on domain controllers):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用以下两个命令创建 gMSA（以域管理员身份运行，而不是在域控制器上运行）：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see that the account was successfully created in the Active Directory
    Users and Computers console:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该账户已成功创建在活动目录用户和计算机控制台中：
- en: '![](image/B18964_04_19.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_19.jpg)'
- en: Figure 4.19 – gMSA created
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – gMSA 创建成功
- en: 'The second step will be to set principals who are allowed to retrieve the plaintext
    password. We will again set the principals on an unprivileged user to demonstrate
    the attack:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是设置允许检索明文密码的主体。我们将再次在一个非特权用户上设置主体，以演示攻击：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An attacker can use the following command to obtain information about the principal
    who can retrieve the managed password:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以使用以下命令来获取关于能够检索受管理密码的主体的信息：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the commands is shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![](image/B18964_04_20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_20.jpg)'
- en: Figure 4.20 – User to retrieve the gMSA password
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 用户检索 gMSA 密码
- en: 'The third step is to compromise the user and retrieve the password as a blob
    that the attacker can then convert into an NT hash using the following commands
    and the **DSInternals**[28] module:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是妥协用户并将密码作为二进制大对象提取，攻击者随后可以使用以下命令和 **DSInternals**[28] 模块将其转换为 NT 哈希：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot shows **SecureCurrentPassword** and **CurrentPassword**
    in UTF-16 format. We have also converted **SecureCurrentPassword** into an NT
    hash:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 **SecureCurrentPassword** 和 **CurrentPassword** 的 UTF-16 格式。我们还将 **SecureCurrentPassword**
    转换为 NT 哈希：
- en: '![](image/B18964_04_21.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_21.jpg)'
- en: Figure 4.21 – NT hash of the gMSA password
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – gMSA 密码的 NT 哈希
- en: This hash can then be used for a pass-the-hash attack, which we will discuss
    in the next chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用该哈希值进行传递哈希攻击，我们将在下一章中讨论这种攻击。
- en: 'But if we do not have the AD module installed, we can use **GMSAPasswordReader**
    written in Windows, by *rvazarkar*[29], or **gMSADumper** in Linux, written by
    *micahvandeusen*[30]. The only caveat is that we need the account name to dump
    its hash. Run the simple command as a user who has privileges to read the gMSA
    password:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果没有安装 AD 模块，我们可以使用 Windows 编写的 **GMSAPasswordReader**（由 *rvazarkar* 编写），或在
    Linux 上使用 **gMSADumper**（由 *micahvandeusen* 编写）。唯一的注意事项是我们需要账户名来转储其哈希。以具有读取 gMSA
    密码权限的用户身份运行简单命令：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will get the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下输出：
- en: '![](image/B18964_04_22.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_22.jpg)'
- en: Figure 4.22 – Result of using the GMSAPasswordRead tool
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 使用 GMSAPasswordRead 工具的结果
- en: As usual, mitigations are to ensure that permissions are set correctly for GMSA.
    Also, event logs can be configured and monitored for event ID 4662, which will
    show what account has queried the **msDS-ManagedPassword** attribute.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，缓解措施是确保正确设置 GMSA 的权限。同时，可以配置并监控事件日志中的事件 ID 4662，这将显示哪个账户查询了 **msDS-ManagedPassword**
    属性。
- en: NTDS secrets
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NTDS 秘密
- en: 'We will cover NTDS secrets extraction as this attack applies only to domain
    controllers. The ntds.dit file is a database that stores Active Directory data,
    including hashes. This file is in **%systemroot\NTDS\ntds.dit** and **%systemroot\System32\ntds.dit**.
    It is constantly in use, so it can’t be copied directly as any other file. There
    are different ways that ntds.dit data can be dumped[31]:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论 NTDS 密码提取，因为此攻击仅适用于域控制器。ntds.dit 文件是一个数据库，用于存储 Active Directory 数据，包括哈希值。该文件位于
    **%systemroot\NTDS\ntds.dit** 和 **%systemroot\System32\ntds.dit** 中。它会持续被使用，因此不能像其他文件一样直接复制。ntds.dit
    数据有多种转储方式[31]：
- en: '**ntdsutil.exe** – Active Directory maintenance tool'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ntdsutil.exe** – Active Directory 维护工具'
- en: '**VSSAdmin** – volume shadow copy'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSSAdmin** – 卷影复制'
- en: '**vshadow**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vshadow**'
- en: '**DiskShadow**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DiskShadow**'
- en: '**esentutl.exe**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**esentutl.exe**'
- en: '**NinjaCopy** from PowerSploit'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NinjaCopy** 来自 PowerSploit'
- en: '**Copy-VSS** from Nishang'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Copy-VSS** 来自 Nishang'
- en: '**windows/gather/credentials/domain_hashdump** from Metasploit'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**windows/gather/credentials/domain_hashdump** 来自 Metasploit'
- en: 'For our example, on a domain controller, we will run **ntdsutil.exe**, which
    will save the ntds.dit file and **SYSTEM** registry hive, which we can then move
    to our machine and extract hashes using **secretsdump**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，在域控制器上，我们将运行 **ntdsutil.exe**，它将保存 ntds.dit 文件和 **SYSTEM** 注册表 Hive，然后我们可以将其移动到我们的机器上，并使用
    **secretsdump** 提取哈希：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下面的截图所示：
- en: '![](image/B18964_04_23.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_23.jpg)'
- en: Figure 4.23 – Dumped hashes from NTDS.dit
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 从 NTDS.dit 提取的哈希
- en: To detect dumping, we need to enable command-line auditing and monitor event
    ID 4688 for signs of using tools from the preceding list. In the application log,
    check for NTDS database creation and detachment with event IDs 325, 326, 327,
    and 216.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测转储，我们需要启用命令行审计，并监视事件 ID 4688，以查找使用前述工具的迹象。在应用程序日志中，检查 NTDS 数据库的创建和分离，事件
    ID 为 325、326、327 和 216。
- en: In the next section, we will execute a DCSync attack against the domain controller,
    which does not require us to run any commands on the machine itself. We can do
    it over the network, and in case of misconfiguration, our user could lose all
    privileges.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将执行一个 DCSync 攻击，针对域控制器进行，该攻击不需要我们在机器上运行任何命令。我们可以通过网络进行，如果配置不当，我们的用户可能会失去所有权限。
- en: DCSync
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DCSync
- en: DCSync uses the domain controller’s API to emulate the replication process from
    a remote domain controller. DCSync, in a nutshell, performs a **DsGetNCChanges**
    operation from a domain controller via an RPC request to the **Directory Replication
    Service API** (**DRSUAPI**). This attack requires extended privileges, **DS-Replication-Get-Changes**
    and **DS-Replication-Get-Changes-All**, which are assigned by default only to
    the “Domain Controllers”, “Domain Admins”, “Administrators”, and “Enterprise Admins”
    groups in the domain.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: DCSync 使用域控制器的 API 来模拟从远程域控制器的复制过程。简而言之，DCSync 通过 RPC 请求执行域控制器的 **DsGetNCChanges**
    操作，访问 **Directory Replication Service API**（**DRSUAPI**）。此攻击需要扩展权限，**DS-Replication-Get-Changes**
    和 **DS-Replication-Get-Changes-All**，这些权限默认只分配给“域控制器”、“域管理员”、“管理员”和“企业管理员”组。
- en: 'If we were able to compromise the user with extended privileges, we could run
    **secretsdump** to obtain all hashes in the domain:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够通过扩展权限入侵用户，我们可以运行 **secretsdump** 获取域中的所有哈希：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output produced by the preceding command is shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令产生的输出如下所示：
- en: '![](image/B18964_04_24.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_24.jpg)'
- en: Figure 4.24 – Result of DCSync attack
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – DCSync 攻击结果
- en: As we can see, a DCSync attack is powerful, allowing the complete takeover of
    the entire domain. To reduce the footprint, an adversary may run this attack directly
    on a domain controller, avoiding network detection. However, it requires domain
    admin privileges.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，DCSync 攻击非常强大，能够完全接管整个域。为了减少攻击痕迹，攻击者可能会直接在域控制器上运行此攻击，避免被网络检测到。然而，这需要域管理员权限。
- en: Attack detection is possible via network traffic analysis or through event log
    monitoring. We can analyze traffic going toward domain controllers and check whether
    DRSUAPI RPC requests for the **DsGetNCChanges** operation are initiated by another
    domain controller. This can be done with the help of the tool named **DCSYNCMonitor**[32].
    This tool accepts a list of domain controllers and will generate an event when
    there is a request from an unknown source.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过网络流量分析或事件日志监控来检测攻击。我们可以分析朝向域控制器的流量，检查是否有其他域控制器发起了**DsGetNCChanges**操作的DRSUAPI
    RPC请求。这可以借助名为**DCSYNCMonitor**[32]的工具完成。该工具接受域控制器列表，并且当来自未知源的请求出现时，会生成事件。
- en: 'In the Windows event log, we can check for event ID 4662 and evaluate the **Property**
    value for control access rights:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows事件日志中，我们可以检查事件ID 4662，并评估**属性**值以控制访问权限：
- en: '**1131f6ad-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes-All**)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1131f6ad-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes-All**)'
- en: '**89e95b76-444d-4c62-991a-0facbeda640c** (**DS-Replication-Get-Changes-In-Filtered-Set**)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**89e95b76-444d-4c62-991a-0facbeda640c** (**DS-Replication-Get-Changes-In-Filtered-Set**)'
- en: '**1131f6aa-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes**)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1131f6aa-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes**)'
- en: Then, we need to check whether the value of **Account Name** is a domain controller.
    If it is not, then we can reliably detect DCSync. Event ID 4662 will appear in
    the log even if DCSync is running locally on the domain controller.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检查**帐户名称**的值是否为域控制器。如果不是，那么我们可以可靠地检测到DCSync。即使DCSync在域控制器本地运行，事件ID 4662仍会出现在日志中。
- en: Also, as DCSync uses the RPC protocol, ETW can be used to detect it on an endpoint,
    based on the UUID for DRSUAPI. Correlating **DSRUAPI UUID** (**e3514235-4b06-11d1-ab04-00c04fc2dcd2**)
    and **OpNum 3** (**IDL_DRSGetNCChanges**) would be a good indicator of malicious
    activity[33].
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，鉴于DCSync使用RPC协议，可以通过基于DRSUAPI的UUID在端点上使用ETW进行检测。将**DSRUAPI UUID**（**e3514235-4b06-11d1-ab04-00c04fc2dcd2**）和**OpNum
    3**（**IDL_DRSGetNCChanges**）关联起来，将是恶意活动的良好指示器[33]。
- en: Dumping user credentials in clear text via DPAPI
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过DPAPI以明文方式转储用户凭据
- en: 'Let us go through a scenario. Following internal security policies and after
    security awareness training, users started using Credential Manager in Windows
    instead of **password.txt** files. Credential Manager is a built-in password manager
    in Windows that uses the **Data Protection API** (**DPAPI**). DPAPI allows programs,
    such as Chrome or RDP, to store sensitive data transparently. This data is stored
    in a user’s directory and is encrypted by a key that is derived from the user’s
    password. Our target user, **khal.drogo**, had credentials in their Credential
    Manager for SQL **system administrator** (**SA**) account. An adversary has compromised
    the user with domain admin privileges and intends to pull the sa password in clear
    text. There are three attack scenarios:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个场景来进行说明。在遵循内部安全政策并经过安全意识培训后，用户开始使用Windows中的凭据管理器，而不再使用**password.txt**文件。凭据管理器是Windows内置的密码管理器，使用**数据保护API**（**DPAPI**）。DPAPI允许程序（如Chrome或RDP）透明地存储敏感数据。数据存储在用户目录中，并通过从用户密码派生的密钥进行加密。我们的目标用户**khal.drogo**在其凭据管理器中存储了SQL
    **系统管理员**（**SA**）帐户的凭据。攻击者已经获得了该用户的域管理员权限，并打算以明文形式提取SA密码。存在三种攻击场景：
- en: Obtain **khal.drogo**’s master key and then decrypt
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取**khal.drogo**的主密钥并进行解密
- en: Extract all local master keys if you have local administrator privileges
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您具有本地管理员权限，则提取所有本地主密钥
- en: Extract all backup master keys with the account in **Domain** **Admins** group
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Domain Admins**组中的帐户提取所有备份主密钥
- en: For demonstration purposes, we chose the third path. All commands are running
    under the **daenerys.targaryen** account (which is a member of “Domain Admins”
    group).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，我们选择了第三个路径。所有命令都在**daenerys.targaryen**帐户下运行（该帐户是“域管理员”组的成员）。
- en: 'The following steps are required for successful password extraction:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 成功提取密码所需的步骤如下：
- en: 'Locate credential files. Files are hidden and located in the following path:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位凭据文件。文件被隐藏，并位于以下路径：
- en: '[PRE21]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Find the **guidMasterKey** value by using the Mimikatz **dpapi::cred** command
    with the path to the credential file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Mimikatz的**dpapi::cred**命令和凭据文件的路径查找**guidMasterKey**值：
- en: '[PRE22]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Extract backup master keys from the domain controller:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从域控制器提取备份主密钥：
- en: '[PRE23]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Retrieve the master key of the user **khal.drogo**:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户**khal.drogo**的主密钥：
- en: '[PRE24]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Decrypt saved credentials:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解密保存的凭据：
- en: '[PRE25]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of the command execution can be seen in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下截图中看到命令执行的结果：
- en: '![](image/B18964_04_25.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B18964_04_25.jpg)'
- en: Figure 4.25 – Clear-text sa password
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 明文 sa 密码
- en: This technique can be detected by command-line auditing, generating event ID
    4688 for malicious tooling. A better option is to enable object auditing and check
    event ID 4662 for the object type (**SecretObject**), object name (***UPKEY***),
    and access mask (**0x2**) values.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术可以通过命令行审计进行检测，从而生成事件 ID 4688，标记恶意工具的使用。更好的选择是启用对象审计，检查事件 ID 4662，查看对象类型（**SecretObject**）、对象名称（***UPKEY***）和访问掩码（**0x2**）的值。
- en: Just a quick remark that dumping the backup key is possible via DCSync as well.
    Domain objectGUID of the key needs to be found in Active Directory for further
    dumping.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 简单提一下，通过 DCSync 也可以导出备份密钥。需要在 Active Directory 中找到该密钥的域对象 GUID 以进一步导出。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was devoted to tools and techniques that can help you get access
    to credentials either in clear-text or hashed form. Obtaining such sensitive data
    is a crucial step to progress further in attacking Active Directory. We have also
    discussed OpSec consideration and possible mitigation/detection options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了可以帮助您获取凭证（无论是明文形式还是哈希形式）的工具和技术。获取这些敏感数据是攻击 Active Directory 时向前推进的关键步骤。我们还讨论了
    OpSec 考虑因素以及可能的缓解/检测选项。
- en: In the next chapter, we will cover lateral movement inside the domain and between
    forests. We will focus on relay and different types of pass-the-whatever attacks,
    finishing with Kerberos delegation abuse and lateral movement between forests.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍域内以及森林之间的横向移动。我们将重点讨论中继和各种类型的通行证攻击，最后介绍 Kerberos 委托滥用和森林之间的横向移动。
- en: References
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Internal Monologue Attack – Retrieving NTLM Hashes without Touching LSASS:
    [https://github.com/eladshamir/Internal-Monologue](https://github.com/eladshamir/Internal-Monologue)'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '内部独白攻击 – 在不接触 LSASS 的情况下获取 NTLM 哈希值: [https://github.com/eladshamir/Internal-Monologue](https://github.com/eladshamir/Internal-Monologue)'
- en: 'Pre-created computer account research: [https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/](https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/)'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '预先创建的计算机帐户研究: [https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/](https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/)'
- en: 'Exploiting GPP: [https://adsecurity.org/?p=2288](https://adsecurity.org/?p=2288)'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '利用 GPP: [https://adsecurity.org/?p=2288](https://adsecurity.org/?p=2288)'
- en: 'CrackMapExec: [https://github.com/Porchetta-Industries/CrackMapExec](https://github.com/Porchetta-Industries/CrackMapExec)'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'CrackMapExec: [https://github.com/Porchetta-Industries/CrackMapExec](https://github.com/Porchetta-Industries/CrackMapExec)'
- en: 'Kerbrute: [https://github.com/ropnop/kerbrute](https://github.com/ropnop/kerbrute)'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Kerbrute: [https://github.com/ropnop/kerbrute](https://github.com/ropnop/kerbrute)'
- en: 'DomainPasswordSpray: [https://github.com/dafthack/DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'DomainPasswordSpray: [https://github.com/dafthack/DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)'
- en: 'NTLM relay: [https://en.hackndo.com/ntlm-relay/](https://en.hackndo.com/ntlm-relay/)'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'NTLM 中继: [https://en.hackndo.com/ntlm-relay/](https://en.hackndo.com/ntlm-relay/)'
- en: 'Responder: [https://github.com/lgandx/Responder](https://github.com/lgandx/Responder)'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Responder: [https://github.com/lgandx/Responder](https://github.com/lgandx/Responder)'
- en: 'Harvesting NetNTLM: [https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/)'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '收集 NetNTLM: [https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/)'
- en: 'Coerced authentication methods: [https://github.com/p0dalirius/windows-coerced-authentication-methods](https://github.com/p0dalirius/windows-coerced-authentication-methods)'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '强制身份验证方法: [https://github.com/p0dalirius/windows-coerced-authentication-methods](https://github.com/p0dalirius/windows-coerced-authentication-methods)'
- en: 'SpoolSample: [https://github.com/leechristensen/SpoolSample](https://github.com/leechristensen/SpoolSample)'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'SpoolSample: [https://github.com/leechristensen/SpoolSample](https://github.com/leechristensen/SpoolSample)'
- en: 'PetitPotam: [https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'PetitPotam: [https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)'
- en: 'WebClient Service Scanner: [https://github.com/Hackndo/WebclientServiceScanner](https://github.com/Hackndo/WebclientServiceScanner)'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'WebClient 服务扫描器: [https://github.com/Hackndo/WebclientServiceScanner](https://github.com/Hackndo/WebclientServiceScanner)'
- en: 'Remotely enable the WebClient service: [https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '远程启用 WebClient 服务: [https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)'
- en: 'ShadowCoerce: [https://github.com/ShutdownRepo/ShadowCoerce](https://github.com/ShutdownRepo/ShadowCoerce)'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'ShadowCoerce: [https://github.com/ShutdownRepo/ShadowCoerce](https://github.com/ShutdownRepo/ShadowCoerce)'
- en: 'DFSCoerce: [https://github.com/Wh04m1001/DFSCoerce](https://github.com/Wh04m1001/DFSCoerce)'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'DFSCoerce: [https://github.com/Wh04m1001/DFSCoerce](https://github.com/Wh04m1001/DFSCoerce)'
- en: 'Kerberos: [https://en.hackndo.com/kerberos/](https://en.hackndo.com/kerberos/)'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Kerberos: [https://en.hackndo.com/kerberos/](https://en.hackndo.com/kerberos/)'
- en: 'Kerberos diagram: [https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13)'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kerberos图解：[https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13)
- en: 'ASREQRoast: [https://dumpco.re/blog/asreqroast](https://dumpco.re/blog/asreqroast)'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'ASREQRoast: [https://dumpco.re/blog/asreqroast](https://dumpco.re/blog/asreqroast)'
- en: 'Pcredz: [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Pcredz: [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)'
- en: 'Hashcat: [https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Hashcat: [https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)'
- en: 'Rubeus: [https://github.com/GhostPack/Rubeus](https://github.com/GhostPack/Rubeus)'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Rubeus: [https://github.com/GhostPack/Rubeus](https://github.com/GhostPack/Rubeus)'
- en: 'Kerberoast with OpSec: [https://m365internals.com/2021/11/08/kerberoast-with-opsec/](https://m365internals.com/2021/11/08/kerberoast-with-opsec/)'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kerberoast与OpSec结合使用：[https://m365internals.com/2021/11/08/kerberoast-with-opsec/](https://m365internals.com/2021/11/08/kerberoast-with-opsec/)
- en: 'KerberOPSEC: [https://github.com/Luct0r/KerberOPSEC](https://github.com/Luct0r/KerberOPSEC)'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'KerberOPSEC: [https://github.com/Luct0r/KerberOPSEC](https://github.com/Luct0r/KerberOPSEC)'
- en: 'LAPS deploy: [https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/](https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/)'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LAPS部署：[https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/](https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/)
- en: 'LAPSToolkit: [https://github.com/leoloobeek/LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit)'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'LAPSToolkit: [https://github.com/leoloobeek/LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit)'
- en: 'Get-LAPSPasswords: [https://github.com/kfosaaen/Get-LAPSPasswords](https://github.com/kfosaaen/Get-LAPSPasswords)'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Get-LAPSPasswords: [https://github.com/kfosaaen/Get-LAPSPasswords](https://github.com/kfosaaen/Get-LAPSPasswords)'
- en: 'DSInternals: [https://github.com/MichaelGrafnetter/DSInternals](https://github.com/MichaelGrafnetter/DSInternals)'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'DSInternals: [https://github.com/MichaelGrafnetter/DSInternals](https://github.com/MichaelGrafnetter/DSInternals)'
- en: 'GMSAPasswordReader: [https://github.com/rvazarkar/GMSAPasswordReader](https://github.com/rvazarkar/GMSAPasswordReader)'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'GMSAPasswordReader: [https://github.com/rvazarkar/GMSAPasswordReader](https://github.com/rvazarkar/GMSAPasswordReader)'
- en: 'gMSADumper: [https://github.com/micahvandeusen/gMSADumper](https://github.com/micahvandeusen/gMSADumper)'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'gMSADumper: [https://github.com/micahvandeusen/gMSADumper](https://github.com/micahvandeusen/gMSADumper)'
- en: 'Dumping domain credentials: [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials)'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出域凭据：[https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials)
- en: 'DCSYNCMonitor: [https://github.com/shellster/DCSYNCMonitor](https://github.com/shellster/DCSYNCMonitor)'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'DCSYNCMonitor: [https://github.com/shellster/DCSYNCMonitor](https://github.com/shellster/DCSYNCMonitor)'
- en: 'Detect a DCSync attack via ETW: [https://www.netero1010-securitylab.com/detection/dcsync-detection](https://www.netero1010-securitylab.com/detection/dcsync-detection)'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过ETW检测DCSync攻击：[https://www.netero1010-securitylab.com/detection/dcsync-detection](https://www.netero1010-securitylab.com/detection/dcsync-detection)
- en: Further reading
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These resources for further study will help you dive deeper into the attacks
    covered in the chapter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源将帮助你深入了解本章涵盖的攻击内容：
- en: 'A good walk-through of WebDAV abuse and a further attack path: [https://pentestlab.blog/2021/10/20/lateral-movement-webclient/](https://pentestlab.blog/2021/10/20/lateral-movement-webclient/)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebDAV滥用及进一步攻击路径的详细解析：[https://pentestlab.blog/2021/10/20/lateral-movement-webclient/](https://pentestlab.blog/2021/10/20/lateral-movement-webclient/)
- en: 'A great writeup with traffic samples and event IDs generated during AS-REP
    roasting: [https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/](https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AS-REP烤制过程中生成的流量样本和事件ID的精彩解析：[https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/](https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/)
- en: 'A blog post with a focus on detecting and preventing AS-REP roasting: [https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/](https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇重点讲解检测和防止AS-REP攻击的博客文章：[https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/](https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/)
- en: 'A step-by-step guide on how to implement and abuse gMSA in the domain: [https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/](https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何在该领域实现和滥用gMSA的逐步指南：[https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/](https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/)
- en: 'A blog post about NTLM relay for gMSA passwords published by *Cube0x0*: [https://cube0x0.github.io/Relaying-for-gMSA/](https://cube0x0.github.io/Relaying-for-gMSA/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cube0x0*发布的关于gMSA密码的NTLM转发博客文章：[https://cube0x0.github.io/Relaying-for-gMSA/](https://cube0x0.github.io/Relaying-for-gMSA/)'
