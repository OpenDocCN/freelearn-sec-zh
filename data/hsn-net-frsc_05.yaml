- en: Deep Packet Inspection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度数据包检查
- en: '**Deep Packet Inspection** (**DPI**) become popular when the Edward Snowden
    leaks about data collection by the government came out. It has gone from just
    another buzzword to making headlines. In this chapter, we will look at various
    traits of protocols and packets that aid DPI.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度数据包检查** (**DPI**) 在爱德华·斯诺登关于政府数据收集泄露事件发生后变得流行。它从一个普通的流行词变成了头条新闻。在本章中，我们将研究有助于
    DPI 的各种协议和数据包特征。'
- en: 'We will be specifically looking at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别关注以下主题：
- en: Analysis of multiple protocols
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种协议的分析
- en: Packet encapsulation and packet analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包封装和数据包分析
- en: So, why are we learning DPI? Well, DPI is the process of looking beyond the
    generic TCP/IP headers and involves analyzing the payload itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要学习 DPI 呢？DPI 是超越常规 TCP/IP 头部分析的过程，涉及分析数据载荷本身。
- en: Devices with DPI capabilities can analyze, evaluate, and perform actions from
    layer 2 to the application layer itself. This means that the devices with DPI
    capabilities are not only reliant on the header information but also check what
    is being sent as the data part. Hence, the overall tradition of network analysis
    is now changing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具有 DPI 功能的设备可以分析、评估并执行从第二层到应用层的操作。这意味着，具有 DPI 功能的设备不仅依赖于头部信息，还会检查作为数据部分发送的内容。因此，网络分析的整体传统正在发生变化。
- en: 'DPI is widely used in the following fields and services:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: DPI 被广泛应用于以下领域和服务：
- en: '**Traffic shapers**: Blocking malicious traffic/limiting traffic.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量整形**：阻止恶意流量/限制流量。'
- en: '**Service assurance**: Network admins can ensure that high-priority traffic
    is carefully dealt with and services do not go down for them.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务保障**：网络管理员可以确保高优先级的流量得到妥善处理，并且不会因流量问题导致服务中断。'
- en: '**Identification ****of ****fake ****applications**: Applications that make
    use of non-standard ports to leverage standard protocol data are easily identified
    with DPI.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假应用程序的识别**：利用非标准端口来利用标准协议数据的应用程序，DPI 可以轻松识别。'
- en: '**Malware Detection**: Since DPI allows viewing the payload itself, malware
    detection is much easier to perform.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意软件检测**：由于 DPI 允许查看数据载荷本身，恶意软件检测变得更加容易。'
- en: '**Intrusion detection**: Not only malware, but also the DPI-enabled system
    can uncover hack attempts and exploit attempts, backdoors, and much more.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入侵检测**：不仅是恶意软件，启用了 DPI 的系统还可以发现黑客攻击尝试、漏洞利用、后门等。'
- en: '**Data Leakage Prevention (DLP)**: With DPI, we can identify critical data
    traveling out of the network as well, making it an ideal choice for DLP systems.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据泄漏防护 (DLP)**：通过 DPI，我们还可以识别网络中外泄的关键数据，使其成为 DLP 系统的理想选择。'
- en: Before diving deep, let's understand the encapsulation of protocols on the different
    layers of communication.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们理解不同通信层次上协议的封装过程。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete exercises performed in this chapter, you will require the following
    software''s:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章中的练习，你将需要以下软件：
- en: Wireshark v3.0.0 ([https://www.wireshark.org/download.html](https://www.wireshark.org/download.html))
    installed on Windows 10 OS / Ubuntu 14.04
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark v3.0.0 ([https://www.wireshark.org/download.html](https://www.wireshark.org/download.html))
    安装在 Windows 10 操作系统 / Ubuntu 14.04 上
- en: Notepad++ 7.5.9 ([https://notepad-plus-plus.org/download/v7.6.4.html](https://notepad-plus-plus.org/download/v7.6.4.html))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Notepad++ 7.5.9 ([https://notepad-plus-plus.org/download/v7.6.4.html](https://notepad-plus-plus.org/download/v7.6.4.html))
- en: Download PCAP files for this chapter from [https://github.com/nipunjaswal/networkforensics/tree/master/Ch3](https://github.com/nipunjaswal/networkforensics/tree/master/Ch3)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/nipunjaswal/networkforensics/tree/master/Ch3](https://github.com/nipunjaswal/networkforensics/tree/master/Ch3)
    下载本章的 PCAP 文件
- en: Protocol encapsulation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议封装
- en: 'Before moving forward, let''s look at how the packets are made and what sort
    of information they carry. Understanding a network packet will not only allow
    us to gain knowledge, but will also help to hone our network forensics skills.
    In layman''s terms, we can say that a network packet is merely data put together
    to be transferred from one endpoint/host to another. However, in the depths of
    a network, an IP packet looks similar to the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们了解数据包的构成以及它们携带的各种信息。理解网络数据包不仅能帮助我们获取知识，还能帮助提升我们的网络取证技能。通俗地讲，我们可以认为网络数据包只是为了从一个端点/主机传输到另一个端点/主机而组合在一起的数据。然而，在网络的深处，一个
    IP 数据包看起来类似于以下内容：
- en: '![](img/fda06dde-e116-47e4-9024-62fb1cf47f22.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fda06dde-e116-47e4-9024-62fb1cf47f22.png)'
- en: 'From the very first raw data on the wire, to becoming an Ethernet frame, to
    the IP packet, and further, to the TCP and UDP type, and finally, becoming the
    application data, the information is encapsulated through various layers. Let''s
    see an example of packet encapsulation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从最初的原始数据到以太网帧，再到IP数据包，再到TCP和UDP类型，最终到达应用数据，信息通过各种层进行封装。让我们看一个数据包封装的示例：
- en: '![](img/217bb7cc-0063-4863-8fb6-0a341f3d4a5f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/217bb7cc-0063-4863-8fb6-0a341f3d4a5f.png)'
- en: From the preceding example, we can see that on the wire, the packet was only
    a mere frame that encapsulated Ethernet information containing MAC addresses of
    both source and destination. The IP header is merely responsible for sending a
    packet from one endpoint to another, while the TCP header keeps a note of communication
    between the two endpoints. Finally, we have the data, which is nothing but our
    layer 7 data, such as HTTP and FTP. We will have a brief look at the IP header
    structure in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中我们可以看到，在传输过程中，数据包仅仅是一个封装了以太网信息的帧，包含源地址和目的地址的MAC地址。IP头仅负责将数据包从一个端点发送到另一个端点，而TCP头则记录两个端点之间的通信。最后，我们有数据，它就是我们的第7层数据，如HTTP和FTP。在下一节中，我们将简要查看IP头结构。
- en: The Internet Protocol header
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议头
- en: 'As we mentioned the IP header previously, let''s see an example of IPv4 packet
    and break it down in the form of its fields:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IP头部分，让我们来看一个IPv4数据包的示例，并将其按字段分解：
- en: '**Version**: The version contains the format of the IP packet.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：版本包含IP数据包的格式。'
- en: '**IP Header Length (IHL)**: Length of the IP packet header. There are generally count
    of 32-bit words in the packet.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP头长度（IHL）**：IP数据包头的长度。通常是数据包中的32位字数。'
- en: '**Differentiated Services Code Point (DCSP)**: Previously called the TOS, this
    is usually used for real-time communications.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差异化服务代码点（DCSP）**：以前称为TOS，通常用于实时通信。'
- en: '**Explicit Congestion Notification (ECN)**: Congestion can be detected through
    this field.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式拥塞通知（ECN）**：可以通过此字段检测拥塞。'
- en: '**Total Length**: The complete length of the packet, including the data and
    header.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总长度**：数据包的完整长度，包括数据和头部。'
- en: '**Identification**: For unique packet identification, however if fragmentation
    occurs, this value will be the same for all fragments'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：用于唯一标识数据包，但是如果发生分片，此值将在所有分片中相同。'
- en: '**Flags**: The flags usually indicate whether the router is allowed to fragment
    the packets.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**：标志通常指示路由器是否允许分片数据包。'
- en: '**Fragmentation Offset**: In cases where the fragmentation occurs, this field
    is used to indicate offset from the start of the datagram itself.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片偏移量**：当发生分片时，此字段用于指示从数据报本身开始的偏移量。'
- en: '**Time To Live (TTL)**: The number of devices the packet hops to before it
    expires.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生存时间（TTL）**：数据包在过期之前要经过的设备数量。'
- en: '**Protocol**: The meat of the packet that describes what protocol is encapsulated
    within, for example, TCP or UDP or other transport layer protocols.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：数据包的核心部分，描述数据包中封装了什么协议，例如TCP、UDP或其他传输层协议。'
- en: '**Header Checksum**: Used for error-detection purposes.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部校验和**：用于错误检测。'
- en: '**Source Address**: Packet sender.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源地址**：数据包发送者。'
- en: '**Destination Address**: Destination of the packet.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地址**：数据包的目的地。'
- en: '**Options**: Extra options. Variable length.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：额外选项。可变长度。'
- en: '**Padding**: Adds extra bits to make the packet length a multiple of 32 bits.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充**：添加额外的比特，使数据包的长度成为32位的倍数。'
- en: 'Let''s expand the IP header part of the packet to see these packet values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展数据包中的IP头部分，看看这些数据包值：
- en: '![](img/49866b08-4356-4415-82d8-7a456b5239df.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49866b08-4356-4415-82d8-7a456b5239df.png)'
- en: We can see all the mentioned fields in the IP header for the packet. Throughout
    our network forensics investigation, we will make use of them from time to time.
    Let's look at the next layer of encapsulation, which is the TCP header.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据包的IP头中所有提到的字段。在我们的网络取证调查过程中，我们将不时使用它们。让我们看一下下一层封装，即TCP头。
- en: The Transmission Control Protocol header
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输控制协议头
- en: 'Following our discussion on the IP header for the packet, we captured in Wireshark.
    Let''s check out the TCP header:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完数据包的IP头后，我们在Wireshark中捕获了它。让我们看看TCP头：
- en: '![](img/22dad0d5-fbb4-4f82-9b43-8d462b8d6350.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22dad0d5-fbb4-4f82-9b43-8d462b8d6350.png)'
- en: 'We can see that the TCP header contains the following sections:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，TCP头包含以下几个部分：
- en: '**Source Port**: The port that generates the packet.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Source Port**: 生成数据包的端口。'
- en: '**Destination Port**: The port at which the data is addressed for a particular
    host.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Destination Port**: 数据被发送到特定主机的端口。'
- en: '**Sequence number**: The first data byte position.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sequence number**: 第一个数据字节的位置。'
- en: '**Acknowledge number**: The next data byte the receiving host is expecting.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Acknowledge number**: 接收主机期望的下一个数据字节。'
- en: '**Header Length**: The length of the Transport layer header in 32-bit words.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Header Length**: 传输层头部的长度，单位为32位字。'
- en: '**Flags**: The control bit field has the following types of values:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flags**: 控制位字段具有以下类型的值：'
- en: '**URG**: Prioritize data'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URG**: 优先处理数据'
- en: '**ACK**: Acknowledge received packet'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACK**: 确认接收到的数据包'
- en: '**PSH**: Immediately push data'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PSH**: 立即推送数据'
- en: '**RST**: Abort a connection'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RST**: 中止连接'
- en: '**SYN**: Initiate a connection'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SYN**: 发起连接'
- en: '**FIN**: Close a connection'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIN**: 关闭连接'
- en: '**NS ECN-nonce - concealment protection**'
  id: totrans-62
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NS ECN-nonce - 隐匿保护**'
- en: '**Congestion Window Reduced** (**CWR**)'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Congestion Window Reduced** (**CWR**)'
- en: '**ECE ECN**: Echo either indicates that the peer can use ECN (if the SYN flag
    is set); otherwise, indicates that there is network congestion'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ECE ECN**: Echo标志表示对端可以使用ECN（如果SYN标志已设置）；否则，表示网络拥塞。'
- en: '**Window**: The size/amount of data that can be accepted.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Window**: 可以接受的数据大小/数量。'
- en: '**Checksum**: Used for finding errors while checking the header, data and pseudo-header'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Checksum**: 用于在检查头部、数据和伪头部时查找错误'
- en: '**Urgent pointer**: The pointer to the end of the urgent data.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Urgent pointer**: 指向紧急数据结束的位置。'
- en: '**Options**: Additional options.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Options**: 附加选项。'
- en: '**Padding**: For size-matching by padding the header.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Padding**: 通过填充头部进行大小匹配。'
- en: 'Moving further down the packet encapsulation, we can see that we have the TCP
    payload that contains the HTTP packet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 继续深入数据包封装，我们可以看到其中包含的TCP有效负载，这部分包含HTTP数据包：
- en: '![](img/8c2191e6-7d9e-49c5-8849-37d416c27415.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c2191e6-7d9e-49c5-8849-37d416c27415.png)'
- en: The HTTP packet
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP数据包
- en: 'The HTTP packet includes the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP数据包包括以下内容：
- en: '**Request Line**: Contains the `GET`/`POST` request type or other HTTP options
    followed by the requested resource, which is `cloudquery.php` in our case, supported
    by HTTP/1.1, which is the version of the HTTP protocol.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Request Line**: 包含`GET`/`POST`请求类型或其他HTTP选项，后跟请求的资源，在我们的例子中是`cloudquery.php`，支持HTTP/1.1版本的HTTP协议。'
- en: '**Request Message Headers**: This section contains all the header information,
    such as general headers, request headers, and entity headers.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Request Message Headers**: 这一部分包含所有的头部信息，如一般头部、请求头部和实体头部。'
- en: '**Message Body**: The sent data to the endpoint, such as files, parameters,
    and images, is placed here.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Message Body**: 发送到端点的数据，如文件、参数和图像，放置在此处。'
- en: 'In our case, we can see that the data is a `POST` request type that posts data
    to the `cloudquery.php` page on the `54.255.213.29` IP address. We can also see
    that the data posted contains some file data. We can see the message body:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以看到数据是一个`POST`请求类型，向`54.255.213.29` IP地址上的`cloudquery.php`页面发送数据。我们还可以看到发送的数据包含一些文件数据。我们可以看到消息体：
- en: '![](img/f50205a0-404a-4645-94d9-155607620cfa.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50205a0-404a-4645-94d9-155607620cfa.png)'
- en: We can see that the data being sent looks gibberish. We will see more on the
    decryption, decoding, and decompression of data in the upcoming chapters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到发送的数据看起来像乱码。我们将在接下来的章节中了解更多关于数据的解密、解码和解压。
- en: So far, we saw how a frame on the wire encapsulated a variety of data meant
    for the various layers of the TCP/IP model. We also saw how a frame jolted down
    right to the HTTP request that contained some encrypted data. Let's move further
    and figure out what is sometimes referred to as **unknown protocols** and how
    to make them recognizable in Wireshark.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一帧数据如何在传输中封装各种数据，这些数据是针对TCP/IP模型各层的。我们还看到数据帧如何直接传递到包含一些加密数据的HTTP请求。接下来，让我们继续前进，了解有时被称为**未知协议**的内容，并了解如何在Wireshark中使它们可识别。
- en: Analyzing packets on TCP
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析TCP数据包
- en: 'The reason of the world moving majorly onto the techniques such as DPI is the
    recognition of protocols on a non-standard port as well. Consider a scenario where
    an FTP server is listening on port `10008`, which is a non-standard FTP port,
    or where an attacker infiltrated the network and is using port `443` to listen
    to FTP packets. How would you recognize that the HTTP port is used for FTP services?
    DPI allows that and discovers what lies inside the packet rather than just identifying
    the type of service based on the port numbers. Let''s see an example of a capture
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 世界逐步转向使用DPI等技术的原因之一，也是为了识别非标准端口上的协议。考虑以下场景：一个FTP服务器监听在`10008`端口，这是一个非标准的FTP端口，或者攻击者渗透进网络并使用`443`端口监听FTP数据包。你怎么识别出HTTP端口被用作FTP服务呢？DPI可以实现这一点，通过分析包内的内容，而不仅仅是通过端口号识别服务类型。让我们来看一个捕获文件的示例：
- en: '![](img/08182eea-691f-4628-8f3d-6f619a83ba63.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08182eea-691f-4628-8f3d-6f619a83ba63.png)'
- en: 'From the preceding screenshot, we cannot exactly figure out the type of application
    layer the TCP packets are referring to. However, if we look closely in the data
    of the packet, to our surprise, we have the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们无法准确判断TCP包所指的是哪种应用层协议。然而，如果我们仔细查看数据包中的数据，令人惊讶的是，我们发现了以下内容：
- en: '![](img/5d5c00ea-b5af-43ee-a524-5e75be5f22a2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5c00ea-b5af-43ee-a524-5e75be5f22a2.png)'
- en: 'We can see that the decoded data contains a list of FTP commands. This means
    that the protocol is FTP, but the reason for Wireshark not decoding the protocol
    is again the same reason some firewalls and traffic analyzers make use of port
    numbers to identify protocols rather than looking inside and finding what matters
    the most, and that is the sole reason DPI is required. However, let''s look at
    ways we can decode what''s being sent and try to decode it back to FTP:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到解码后的数据包含了一系列FTP命令。这意味着协议是FTP，但Wireshark没有解码出该协议的原因和一些防火墙及流量分析工具相同，它们通过端口号来识别协议，而不是深入分析数据内容，找到真正重要的部分，这也是为什么需要深度包检测（DPI）的原因。不过，我们还是来看看如何解码这些数据，并尝试将其解码回FTP：
- en: '![](img/25d899b8-3d93-42c1-9d64-91c39fb196fa.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25d899b8-3d93-42c1-9d64-91c39fb196fa.png)'
- en: 'Let''s try following the TCP stream by right-clicking a packet and checking
    out the TCP stream:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来尝试通过右键点击一个数据包并查看TCP流：
- en: '![](img/9314af6d-85df-4bc0-a5f5-0f0b64a8424f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9314af6d-85df-4bc0-a5f5-0f0b64a8424f.png)'
- en: 'We can see that the TCP stream displays various types of FTP details, such
    as commands issued. However, this is not what we need. We need a mechanism to
    force Wireshark into decoding this data once and for all. Let''s have another
    look at the packet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，TCP流显示了各种FTP细节，例如发出的命令。然而，这并不是我们需要的内容。我们需要一个机制，能够强制Wireshark解码这些数据，一劳永逸。让我们再看看这个数据包：
- en: '![](img/9060a1e3-6f07-4b98-86cd-282e3c98087b.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9060a1e3-6f07-4b98-86cd-282e3c98087b.png)'
- en: 'We can see that the source port is `10008` for the data that originated from
    the FTP server. Let''s quickly note that down. Next, we need to decode this into
    FTP; we can use the Decode As..., a feature of Wireshark:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，源端口是`10008`，这是来自FTP服务器的数据。我们可以快速记下这个信息。接下来，我们需要将其解码为FTP；我们可以使用Wireshark的“解码为...”功能：
- en: '![](img/70865590-b83c-4f0d-be4c-929a9e173a13.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70865590-b83c-4f0d-be4c-929a9e173a13.png)'
- en: 'As soon as we press the **Decode as...** button, we get the following popup
    on the screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击**解码为...**按钮，屏幕上会弹出以下对话框：
- en: '![](img/1afbcaec-1986-4590-a2f6-b76ee93179c2.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1afbcaec-1986-4590-a2f6-b76ee93179c2.png)'
- en: 'Let''s click on the **+** button, which will populate the following entry:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击**+**按钮，这将显示以下条目：
- en: '![](img/9e037eab-4544-4a90-9de2-3632c8619b51.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e037eab-4544-4a90-9de2-3632c8619b51.png)'
- en: 'Since the originating port was `10008`, let''s modify the value to `10008`
    from `55695` and **Current** to **FTP**, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源端口是`10008`，我们将其从`55695`修改为`10008`，并将**Current**设置为**FTP**，如下所示：
- en: '![](img/6335a297-c30a-4415-bb76-defffac60bd9.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6335a297-c30a-4415-bb76-defffac60bd9.png)'
- en: 'Let''s press the **OK** button to see changes to the packets:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击**确定**按钮来查看数据包的变化：
- en: '![](img/5d41a3d4-dd2d-4024-b6d3-531529d53384.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d41a3d4-dd2d-4024-b6d3-531529d53384.png)'
- en: Wow! We can see the FTP data now. We just saw that we can recognize a protocol
    that is running on non-standard ports.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在我们可以看到FTP数据了。我们刚刚看到，我们可以识别出运行在非标准端口上的协议。
- en: We saw how the TCP packet works and also saw its applications, such as HTTP
    and FTP. Let's jump into the UDP packet and take the most common application of
    it, which is DNS. I know some might argue that DNS makes use of both TCP and UDP
    at times, like zone transfers. However, for most of its operations, such as resolving
    queries, DNS makes use of UDP packets only.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 TCP 数据包的工作原理，并且看到了一些它的应用，比如 HTTP 和 FTP。现在让我们来分析 UDP 数据包，探讨其最常见的应用——DNS。我知道有些人可能会争论
    DNS 有时同时使用 TCP 和 UDP，例如区域传输。然而，在大多数操作中，如解析查询，DNS 仅使用 UDP 数据包。
- en: Analyzing packets on UDP
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 UDP 数据包
- en: 'The **user datagram protocol** (**UDP**) is used primarily for real-time communications
    and in situations where speed matters. The UDP header size is 8 bytes compared
    to 20 in TCP. A UDP packet does not have segment acknowledgment and is usually
    much faster, since it is a connectionless protocol. Also, error checking is still
    a part of UDP, but no reporting of errors takes place. A common example of UDP
    is **Voice over Internet Protocol** (**VoIP**). Comparing to the structure we
    discussed in the very beginning of the chapter, we have the following structure
    for UDP:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）主要用于实时通信和对速度要求较高的情况。UDP 的头部大小为 8 字节，而 TCP 为 20 字节。UDP 数据包没有段确认，通常速度更快，因为它是一个无连接协议。同时，错误检查仍然是
    UDP 的一部分，但不会报告错误。UDP 的一个常见例子是 **互联网语音协议**（**VoIP**）。与我们在本章开头讨论的结构相比，UDP 的结构如下：'
- en: '![](img/eabc6ec9-495c-4102-a41d-ba0e8ee9a062.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eabc6ec9-495c-4102-a41d-ba0e8ee9a062.png)'
- en: 'We can see that we have so many fields reduced and primarily have only the **Source
    Port**, **Destination Port**, **Length**, and **Checksum** fields. Let''s validate
    this by analyzing a UDP packet in Wireshark:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，许多字段已经被简化，主要只剩下 **源端口**、**目标端口**、**长度** 和 **校验和** 字段。让我们通过在 Wireshark
    中分析一个 UDP 数据包来验证这一点：
- en: '![](img/30ebf07c-b4e0-4f74-a78d-8dc910f0371c.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30ebf07c-b4e0-4f74-a78d-8dc910f0371c.png)'
- en: 'We can see that we have certain fields as mentioned in the preceding diagram.
    Additionally, we can see that we have DNS data, which is nothing but the data
    field as mentioned in the diagram. Let''s see what details we have on expanding
    the DNS field:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们有一些前面图中提到的字段。此外，我们还可以看到 DNS 数据，它就是图中提到的数据字段。让我们展开 DNS 字段，看看我们能获得哪些详细信息：
- en: '![](img/75fbbd4b-c30a-4003-8647-a10ff679a22a.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75fbbd4b-c30a-4003-8647-a10ff679a22a.png)'
- en: 'We can see that the raw data was decoded by Wireshark to reveal **Transaction
    ID**, **Questions**, **Answers**, and other details:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，原始数据已被 Wireshark 解码，显示了 **事务 ID**、**问题**、**答案**以及其他细节：
- en: '![](img/fa065a8a-0b48-457c-9673-ac624377ccb2.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa065a8a-0b48-457c-9673-ac624377ccb2.png)'
- en: 'We can see that in the queries section, we also have the domain and subdomain
    values, record type, and addresses. You can see that pointing to any of the preceding
    fields will highlight the raw data segment:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在查询部分，我们还可以看到域名和子域名值、记录类型和地址。你可以看到，指向任何前述字段都会突出显示原始数据段：
- en: '![](img/e036e94e-777d-498a-9fd9-ddbbab0f470e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e036e94e-777d-498a-9fd9-ddbbab0f470e.png)'
- en: 'Understanding each raw data packet can also help us to develop PCAP readers
    and custom network analyzers. Hence, let''s build some filters based on the following
    data fields:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个原始数据包还可以帮助我们开发 PCAP 阅读器和自定义网络分析器。因此，让我们基于以下数据字段构建一些过滤器：
- en: '![](img/efcfbb84-e98f-4d85-9e3d-7a735d1f8c41.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efcfbb84-e98f-4d85-9e3d-7a735d1f8c41.png)'
- en: 'We saw a field called the DNS transaction ID. We can make use of it by coupling
    DNS and ID together while equating the value to `0x2581.` The filter would be
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个叫做 DNS 事务 ID 的字段。我们可以通过将 DNS 和 ID 结合在一起，并将其值设为 `0x2581` 来利用它。过滤器如下所示：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the filter, we will have the unique packets for the transaction, as we
    can see that we have a DNS standard query and its associated response. Wireshark
    allows us to perform a variety of filtering operations on the DNS and other protocols
    by interpreting raw fields:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过滤器后，我们将得到该事务的唯一数据包，如我们所见，我们有一个 DNS 标准查询及其相关响应。Wireshark 允许我们通过解析原始字段，对 DNS
    和其他协议进行多种过滤操作：
- en: '![](img/c488c772-2266-4b4f-b77b-da07e5f60fb6.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c488c772-2266-4b4f-b77b-da07e5f60fb6.png)'
- en: 'Let''s see an example of how DNS queries work and then figure out their corresponding
    response times in the next example by actually going ahead and capturing packets
    on our internet connected wireless interface. Additionally, we will only capture
    packets on port `53` to analyze the DNS queries and responses as shown in the
    following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个 DNS 查询如何工作的例子，然后在下一个例子中通过实际捕获我们联网无线接口上的数据包，找出它们相应的响应时间。另外，我们将只捕获端口 `53`
    上的数据包，以分析如下一截图所示的 DNS 查询和响应：
- en: '![](img/3cae3697-4e0d-4ef4-8e28-7ac2276c8f91.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cae3697-4e0d-4ef4-8e28-7ac2276c8f91.png)'
- en: 'We use a capture filter that will only capture packets from port `53`. Let''s
    double-click the Wi-Fi interface and start capturing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个捕获过滤器，只会捕获来自端口 `53` 的包。让我们双击 Wi-Fi 接口并开始捕获：
- en: '![](img/d833da11-a740-42fc-b183-5750e64b73c5.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d833da11-a740-42fc-b183-5750e64b73c5.png)'
- en: 'We can see that the data has started flowing in. Let''s open some websites
    and set the flags filter to `0x8180` by placing the `dns.flags == 0x8180` display
    filter. The value `0x8180` denotes a standard DNS response. Let''s see the result
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据已经开始流动。让我们打开一些网站，并通过设置标志过滤器为 `0x8180`，将显示过滤器设置为 `dns.flags == 0x8180`。值
    `0x8180` 表示标准 DNS 响应。我们来看一下结果如下：
- en: '![](img/7f1f99ac-ece4-4797-a907-029dc1b785cd.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f1f99ac-ece4-4797-a907-029dc1b785cd.png)'
- en: 'Wireshark only displays standard DNS response packets. Let''s analyze their
    response times as well. We can see that every packet has the response time associated
    with it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 仅显示标准 DNS 响应包。让我们也分析它们的响应时间。我们可以看到每个包都有一个相关的响应时间：
- en: '![](img/6f51504e-14fc-4cd8-a190-92429f097508.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f51504e-14fc-4cd8-a190-92429f097508.png)'
- en: 'Let''s right-click the time field and choose **Apply as Column**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们右键点击时间字段并选择 **应用为列**：
- en: '![](img/24a21a78-50ba-40fc-b6c7-57c4e2e5247c.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24a21a78-50ba-40fc-b6c7-57c4e2e5247c.png)'
- en: 'We can now see that another field got added to the packet list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到包列表中添加了另一个字段：
- en: '![](img/ea9619cd-2452-4c8e-a6ef-6a9fdb720528.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea9619cd-2452-4c8e-a6ef-6a9fdb720528.png)'
- en: 'We have a new column, **Time**, added to it. However, the entry''s name is
    redundant with time. Let''s change it by right-clicking and selecting Edit Column:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新增了一列，**时间**。不过，条目的名称与时间重复了。我们可以通过右键点击并选择编辑列来更改它：
- en: '![](img/debfb5dc-768f-4f07-8848-edd365ae2a1f.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/debfb5dc-768f-4f07-8848-edd365ae2a1f.png)'
- en: 'We can now rename the field `Response Time`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重命名字段 `响应时间`：
- en: '![](img/00bedfc3-e8e0-43a2-90f9-211de10dab4b.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00bedfc3-e8e0-43a2-90f9-211de10dab4b.png)'
- en: 'Let''s check out the packet list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看包列表：
- en: '![](img/8a62e2da-e9a4-4c3f-8041-866679aeee0f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a62e2da-e9a4-4c3f-8041-866679aeee0f.png)'
- en: 'We can now see that we have response times for all the DNS response packets.
    However, we can also see that some of the packets do not have this value, and
    this is where the DNS response has been received twice. You might be wondering
    why we are discussing this in a network forensics book. It''s because having a
    brief knowledge of these packets will help us understand the complex examples
    in the upcoming chapters. We are still in the learning phase, and in the next
    few chapters, everything we learn here will start to make sense. So, let''s continue
    and see only those packets that have been retransmitted using the `dns.retransmit_response`
    filter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到所有 DNS 响应包的响应时间。然而，我们也可以看到一些包没有这个值，这些包是 DNS 响应被接收了两次。你可能会想，为什么我们在网络取证书中讨论这个问题？这是因为，了解这些包的基本知识将帮助我们理解接下来章节中的复杂示例。我们仍然处于学习阶段，在接下来的几章中，我们在这里学到的内容将开始变得有意义。所以，让我们继续并查看那些使用
    `dns.retransmit_response` 过滤器重新传输的包：
- en: '![](img/328b2d59-e7ce-4a59-a712-232fabf972f2.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/328b2d59-e7ce-4a59-a712-232fabf972f2.png)'
- en: 'We can now only see retransmitted responses. We can also filter all the queries
    based on the query names; let''s filter out all the queries related to `google.com`.
    We can set up a filter, such as `dns.qry.name contains "google.com"`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只看到重新传输的响应。我们还可以基于查询名称过滤所有查询；让我们过滤掉与 `google.com` 相关的所有查询。我们可以设置一个过滤器，例如
    `dns.qry.name contains "google.com"`：
- en: '![](img/44ff94c7-8ad9-4b99-8137-10705a595dc9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44ff94c7-8ad9-4b99-8137-10705a595dc9.png)'
- en: Analyzing packets on ICMP
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 ICMP 包
- en: 'Let''s take a look at the **Internet Control Message Protocol** (**ICM****P**).
    It is one of the most popular protocols, and is better known for being used in
    ping commands, which is where an ICMP echo request is sent to an IP address with
    some random data, and it then denotes whether the system is alive. A typical ICMP
    packet would look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**互联网控制消息协议**（**ICMP**）。它是最流行的协议之一，更为人所知的是它用于ping命令，其中ICMP回声请求被发送到某个IP地址，附带一些随机数据，然后表明该系统是否存活。一个典型的ICMP数据包看起来是这样的：
- en: '![](img/a91bcd44-6b90-4d25-bda9-583c08e1a85f.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a91bcd44-6b90-4d25-bda9-583c08e1a85f.png)'
- en: The ICMP has many messages, which are identified by the **Type of Message**
    field. The **Code** field indicates the type of message. The **Identifier** and
    **Sequence Number** can be used by the client to match the reply with the request
    that caused the reply.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP有许多消息，这些消息由**消息类型**字段标识。**代码**字段指示消息的类型。**标识符**和**序列号**可以由客户端用来匹配导致响应的请求。
- en: 'The **Data** field may contain a random string or a timestamp to compute the
    round-trip time in a stateless manner. Let''s ping [https://www.google.com/](https://www.google.com/) and
    analyze it in Wireshark:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**字段可能包含一个随机字符串或时间戳，用于以无状态的方式计算往返时间。让我们对[https://www.google.com/](https://www.google.com/)进行ping测试，并在Wireshark中分析它：'
- en: '![](img/98c59ec6-89ac-4bb0-b5ab-1159ed7a1d38.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98c59ec6-89ac-4bb0-b5ab-1159ed7a1d38.png)'
- en: 'We can see that we have four Echo request and four Echo reply packets. Let''s
    see the request first:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有四个回声请求和四个回声应答数据包。让我们先看看请求：
- en: '![](img/d0b37d3b-c38d-4a74-bed4-caf7346224fc.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0b37d3b-c38d-4a74-bed4-caf7346224fc.png)'
- en: The request is of the Echo type and is denoted by the number 8, and the code
    is 0.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请求是回声类型（Echo），标识为数字8，代码为0。
- en: Check out the ICMP type and codes at [https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查看ICMP类型和代码，请访问[https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8](https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-8)。
- en: 'We can also see that the data starts with `09b` and goes up to 48 bytes. Since
    we are pinging Google, if it''s up, it will reply with the same data back to us.
    Let''s see the response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到数据从`09b`开始，直到48字节。由于我们正在对Google进行ping测试，如果Google在线，它会将相同的数据返回给我们。让我们看看响应：
- en: '![](img/be29763a-a1ea-4d7a-962a-32c24ffdd8e3.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be29763a-a1ea-4d7a-962a-32c24ffdd8e3.png)'
- en: 'We can see that the data was sent back as is, which denotes that the system
    is up. Also, we can see that the **Identifier** and **Sequence number** are similar
    to the one in the request. The **Type** for the **Echo reply** is denoted by **0**
    and the code also remains zero. Let''s see what happens when the IP is not reachable:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据被原样返回，表明系统正常运行。同时，我们可以看到**标识符**和**序列号**与请求中的相似。**回声应答**的**类型**为**0**，代码也保持为0。让我们看看当IP地址不可达时会发生什么：
- en: '![](img/dc1f9f48-b9b2-4078-a465-6e4bff975db5.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc1f9f48-b9b2-4078-a465-6e4bff975db5.png)'
- en: 'The preceding `ping` command denotes that there was a 100% loss of packets;
    let''s see Wireshark:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`ping`命令表明丢包率为100%；让我们看看Wireshark：
- en: '![](img/25cb726f-c673-4014-86df-592b21a78dec.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25cb726f-c673-4014-86df-592b21a78dec.png)'
- en: We can see that Wireshark has not seen any response. Hence, it marked it as
    no response found.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Wireshark没有看到任何响应，因此它标记为“未找到响应”。
- en: So far, we have covered the basics of the TCP, UDP, and ICMP protocols. Let's
    see a case study and analyze the involved PCAP evidence file in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了TCP、UDP和ICMP协议的基础知识。接下来，让我们通过一个案例研究来分析涉及的PCAP证据文件。
- en: Case study – ICMP Flood or something else
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – ICMP洪水攻击或其他情况
- en: 'Imagine you are a network forensics expert who has been tasked with analyzing
    the PCAP file. As soon as you open the file in Wireshark, you are presented with
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一名网络取证专家，负责分析PCAP文件。只要你在Wireshark中打开该文件，你就会看到以下内容：
- en: '![](img/02f4ec43-deaa-4ac4-958c-e349f8c8341f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02f4ec43-deaa-4ac4-958c-e349f8c8341f.png)'
- en: 'What we can see from the capture file is that it contains a ton of ICMP packets
    traveling to and from `192.168.153.129` and `192.168.153.130`. We quickly added
    a new column by right-clicking the column header in Wireshark and choosing **Column
    Preferences** and adding a new column by clicking the **+** button and choosing
    its type as **UTC** for the UTC time, as shown in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从捕获文件中，我们可以看到它包含大量在 `192.168.153.129` 和 `192.168.153.130` 之间来回传输的 ICMP 数据包。我们通过右击
    Wireshark 中的列标题，选择 **列首选项**，然后点击 **+** 按钮，选择其类型为 **UTC** 来快速添加一个新列，显示 UTC 时间，如下所示：
- en: '![](img/5dd5631a-3d36-4953-b150-6067da5a8f39.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dd5631a-3d36-4953-b150-6067da5a8f39.png)'
- en: 'Next, we go to the **Statistics** tab and choose Capture File Properties:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入 **统计** 标签页，选择捕获文件属性：
- en: '![](img/8cd5fffe-037f-4d4c-9e97-0c591645326e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cd5fffe-037f-4d4c-9e97-0c591645326e.png)'
- en: 'The preceding option will populate the following window:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述选项将填充以下窗口：
- en: '![](img/22e7c625-7e67-481b-af05-3b0f98ca7136.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22e7c625-7e67-481b-af05-3b0f98ca7136.png)'
- en: 'We can see a good amount of detail related to the capture file, such as the
    date and time of the first packet, last packet, duration, average packets per
    second, and the number of packets captured. When we populate the **Endpoints**
    tab, we can see the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到关于捕获文件的许多细节，比如第一个数据包、最后一个数据包的日期和时间、持续时间、每秒平均数据包数以及捕获的数据包数量。当我们填充 **端点**
    标签页时，我们可以看到以下内容：
- en: '![](img/eb9ece5b-5505-4a11-a368-2e93db1ae257.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb9ece5b-5505-4a11-a368-2e93db1ae257.png)'
- en: 'We can quickly determine that the `192.168.153.129` and `192.168.153.130` IP
    addresses are communicating. We can confirm this by opening the **Conversations**
    tab:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速确定 `192.168.153.129` 和 `192.168.153.130` 这两个 IP 地址正在通信。我们可以通过打开 **对话**
    标签页来确认这一点：
- en: '![](img/6524c7ab-837c-4470-b198-21170fe1e7d4.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6524c7ab-837c-4470-b198-21170fe1e7d4.png)'
- en: 'We can see that both IPs are communicating. However, the strange thing is that
    the only traffic exchanged between these two is ICMP traffic. Using the filter
    as `icmp.type == 8` displays that there are 510 ICMP echo requests sent from `192.168.153.129`
    to `192.168.153.130`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个 IP 地址正在通信。然而，奇怪的是，这两个 IP 之间交换的唯一流量是 ICMP 流量。使用 `icmp.type == 8` 过滤器可以显示从
    `192.168.153.129` 到 `192.168.153.130` 发送的 510 个 ICMP 回显请求：
- en: '![](img/087a01d1-8208-47ce-8da6-10d53e5abad7.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/087a01d1-8208-47ce-8da6-10d53e5abad7.png)'
- en: 'Let''s see the number of replies by setting the `icmp.type == 0` as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置 `icmp.type == 0` 来查看回复的数量，如下所示：
- en: '![](img/25a09d8e-7019-4172-9cc6-c9a9c655b104.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25a09d8e-7019-4172-9cc6-c9a9c655b104.png)'
- en: We can see that the number of replies is almost equal to the number of requests—Strange!
    Someone would never send out that amount of ping requests intentionally—unless
    they are conducting a DOS attack. However, carrying out a **ping of death** or
    Ping DoS will require a significantly higher number of packets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，回复的数量几乎等于请求的数量——奇怪！有人绝不会故意发送这么多的 ping 请求——除非他们在进行 DoS 攻击。然而，执行 **死亡 Ping**
    或 Ping DoS 攻击将需要显著更多的数据包。
- en: A ping DoS would require more packets, but a ping of death might only require
    one on a vulnerable system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ping DoS 攻击需要更多的数据包，但死亡 Ping 攻击可能只需在脆弱的系统上使用一个数据包。
- en: 'There is something wrong with this. Let''s investigate the packets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有些问题。让我们调查一下数据包：
- en: '![](img/8effb7a0-90f2-4bc4-be71-eb6ee6f93cef.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8effb7a0-90f2-4bc4-be71-eb6ee6f93cef.png)'
- en: 'Everything seems fine until we reach packet number 149, to which no response
    was received from the target. The next packet, number 150, contains something
    of interest:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常，直到我们看到第 149 个数据包，此时目标没有收到回复。下一个数据包，第 150 个，包含了一些有趣的内容：
- en: '![](img/6181fee4-1751-43ce-9754-759eda0daa22.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6181fee4-1751-43ce-9754-759eda0daa22.png)'
- en: 'Packet 150 contains `ipconfig` in the data segment. Hmm.. this is awkward!
    Let''s investigate further:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包 150 包含数据段中的 `ipconfig`。嗯……这有点尴尬！让我们进一步调查：
- en: '![](img/83c02494-1079-4160-b08d-3541665709d4.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83c02494-1079-4160-b08d-3541665709d4.png)'
- en: 'Packet number 179 has a system path in it. This is going south! The found traces
    denote that someone is accessing this system using an ICMP shell. The ICMP shell
    is a backdoor that makes use of data fields to send replies to a command sent
    by the attacker. Since all the requests originated from `192.168.153.129`, we
    have our attacker. We can also see another strange thing: The ICMP packets are
    missing data fields, apart from the packets'' ICMP backdoor packets. This gives
    us an edge to only focus on the packets having data, for this, we can type data
    as the filter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包编号179中包含一个系统路径。这真是糟糕透了！发现的痕迹表明有人正在通过ICMP Shell访问这个系统。ICMP Shell是一个后门，利用数据字段向攻击者发送命令的回复。由于所有请求都来自`192.168.153.129`，我们确定了攻击者。我们还发现了另一个奇怪的现象：除了数据包的ICMP后门数据包外，ICMP数据包缺少数据字段。这使得我们能够专注于仅包含数据的包，针对这个，我们可以使用“data”作为过滤器：
- en: '![](img/5febb9d6-f425-4df4-a994-b3bee70bb428.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5febb9d6-f425-4df4-a994-b3bee70bb428.png)'
- en: 'We can see that we are only left with 17 packets out of 1,087, which can be
    easily traversed using Tshark. Tshark is the command-line wireless equivalent
    and is way better for people who love the command line. We will make use of PowerShell
    to run Tshark in Windows, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，经过过滤后，我们只剩下了17个数据包，而原本有1,087个数据包，这些数据包可以很容易地通过Tshark进行遍历。Tshark是命令行版本的无线工具，对于喜欢命令行的人来说，Tshark要好得多。我们将使用PowerShell在Windows中运行Tshark，如下所示：
- en: '[PRE1]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command runs Tshark with the `-Y` switch as data, which denotes
    the filter, `-r` as the path of the capture file; the `-T` fields denotes the
    field types to print, and `-e` denotes which fields will be printed. Additionally,
    more details on these optional switches can be found using `man tshark` or `tshark
    –help` command in Windows. Now, let''s run this command as shown in the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令使用了`-Y`开关来指定数据过滤器，`-r`指定捕获文件的路径，`-T`指定打印的字段类型，`-e`指定将打印的字段。此外，关于这些可选开关的更多细节可以通过在Windows中使用`man
    tshark`或`tshark –help`命令来查看。现在，让我们按照以下截图运行这个命令：
- en: '![](img/006447da-e302-469d-b5c9-bff9dca2267f.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/006447da-e302-469d-b5c9-bff9dca2267f.png)'
- en: 'We can see that we have all the data from the 17 packets in hex. Let''s copy
    this data into Notepad++:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们拥有来自17个数据包的所有十六进制数据。让我们将这些数据复制到Notepad++中：
- en: '![](img/d50addc3-b31c-4b34-a613-fd3e6731a0ec.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d50addc3-b31c-4b34-a613-fd3e6731a0ec.png)'
- en: 'Notepad++ contains pre-installed plugins to convert hex into ASCII. Let''s
    browse to the **Plugins** tab and choose **Converter** | **Hex -> ASCII**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Notepad++内置了将十六进制转换为ASCII的插件。让我们浏览到**插件**标签并选择**转换器** | **Hex -> ASCII**：
- en: '![](img/188e9354-1c7f-4d68-b393-a10f9d6cd0bc.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/188e9354-1c7f-4d68-b393-a10f9d6cd0bc.png)'
- en: 'As soon as we press the **Hex -> ASCII** option, we will have the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按下**Hex -> ASCII**选项，我们将看到如下内容：
- en: '![](img/e6df6e9a-37e3-4c4c-a497-bde602e56914.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6df6e9a-37e3-4c4c-a497-bde602e56914.png)'
- en: God! Someone was running commands on the system; they ran `ipconfig` followed
    by the `whoami` command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊！有人在系统上执行了命令；他们运行了`ipconfig`，接着运行了`whoami`命令。
- en: 'In this exercise, we saw how innocent-looking ICMP packets were used to access
    a compromised system. However, throughout this exercise, we learned how to do
    a few things: We investigated ICMP packets, found some malicious activity, gathered
    and clubbed data from the various packets into a single file, and decoded them
    from hex into ASCII to reveal the intentions of the attacker and the activities
    that they performed on the target. We also identified that the backdoor was making
    use of the ICMP protocol to conduct command and control, and we looked at using
    Tshark for the very first time.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到看似无害的ICMP数据包被用来访问一个被攻陷的系统。然而，在整个练习过程中，我们学会了做几件事：我们调查了ICMP数据包，发现了一些恶意活动，从不同的数据包中收集并将数据整合到一个文件中，接着将它们从十六进制解码成ASCII，揭示了攻击者的意图以及他们在目标系统上执行的活动。我们还识别出后门利用ICMP协议进行命令和控制，并且第一次使用了Tshark。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered some serious theory in this chapter. We started by looking at the
    IP and TCP protocol headers, and we analyzed the HTTP protocol. We then analyzed
    the FTP protocol, and the UDP-oriented DNS service. We looked at the ICMP protocol
    and saw a case study where ICMP was being used for command and control. Throughout
    this chapter, we learned new and advanced concepts to analyze various packets
    and protocols. In the next chapter, we will look at statistical flow analysis,
    and we will learn how it can help us conduct an efficient network forensic exercise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍了一些深入的理论。我们从分析 IP 和 TCP 协议头开始，接着分析了 HTTP 协议。然后，我们分析了 FTP 协议以及面向 UDP 的
    DNS 服务。我们研究了 ICMP 协议，并查看了一个 ICMP 用于命令与控制的案例研究。在整个章节中，我们学习了新的和高级的概念，帮助我们分析各种数据包和协议。在下一章中，我们将学习统计流量分析，并了解它如何帮助我们进行高效的网络取证工作。
- en: Questions and exercises
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和练习
- en: 'To enhance your network forensics skills on various protocols and packets,
    try answering/solving the following exercises and problems:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升你在各种协议和数据包上的网络取证技能，尝试回答/解决以下练习和问题：
- en: Refer to the case study on ICMP. Try a similar exercise for DNS by analyzing
    `dns-shell` ([https://github.com/sensepost/DNS-Shell](https://github.com/sensepost/DNS-Shell)).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考关于 ICMP 的案例研究。通过分析 `dns-shell` ([https://github.com/sensepost/DNS-Shell](https://github.com/sensepost/DNS-Shell))，尝试进行类似的
    DNS 练习。
- en: Study at least five different packet structures including IPv6, TLS, NTP, and
    many others.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究至少五种不同的数据包结构，包括 IPv6、TLS、NTP 等等。
- en: Write a small Bash script in Linux to convert hexadecimal characters to ASCII.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 中编写一个小的 Bash 脚本，将十六进制字符转换为 ASCII。
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about DPI, check out [https://is.muni.cz/th/ql57c/dp-svoboda.pdf](https://is.muni.cz/th/ql57c/dp-svoboda.pdf).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 DPI 的信息，请查看 [https://is.muni.cz/th/ql57c/dp-svoboda.pdf](https://is.muni.cz/th/ql57c/dp-svoboda.pdf)。
