- en: '*Chapter 3*: I Love My Bits – Lab Setup'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：我爱我的比特 – 实验室设置'
- en: So far, we have been mostly configuring the connectivity of the network. Now,
    we'll take it to the next level. In this chapter, we are going to configure a
    simple **program** and use the software installed on the Windows 7 **virtual machine**
    (**VM**) to physically change the **I/O** on the PLC. This will pass through the
    VM interface, through the virtual switch, to the physical adapter. Then, it will
    pass to a *physically* managed switch and out to the PLC. This chapter will expand
    on the lab that we started to set up earlier in [*Chapter 2*](B16321_02_Epub_AM.xhtml#_idTextAnchor027),
    *Routing the Hardware*. We will go through a demo approach using **Koyo Click
    PLC** and **Human Machine Interfaces** (**HMI**) I and connect it to physical
    I/O to learn how to turn lights on and off, utilizing both the **graphical user
    interface** and **scripting**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要配置了网络的连接性。现在，我们将进入下一阶段。在本章中，我们将配置一个简单的**程序**，并使用安装在Windows 7 **虚拟机**（**VM**）上的软件，物理地改变PLC上的**I/O**。这一过程会通过虚拟机接口，通过虚拟交换机，到达物理适配器。然后，它会传递到*物理*管理交换机，并最终连接到PLC。本章将扩展我们之前在[*第二章*](B16321_02_Epub_AM.xhtml#_idTextAnchor027)中开始设置的实验室，*硬件路由*。我们将通过一个演示方法，使用**Koyo
    Click PLC**和**人机界面**（**HMI**）I，将其连接到物理I/O，以学习如何通过**图形用户界面**和**脚本编写**实现开关灯的操作。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Writing and downloading our first program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和下载我们的第一个程序
- en: Overriding and wiring the I/O
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写和接线I/O
- en: Testing control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制测试
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需材料：
- en: The **Koyo Click** software installed on our Windows 7 machine.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在Windows 7机器上的**Koyo Click**软件。
- en: A **Koyo Click** hardware power supply and PLC.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Koyo Click**硬件电源和PLC。'
- en: A physical network switch to route traffic between PLC and ESXi.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个物理网络交换机，用于在PLC和ESXi之间路由流量。
- en: A Selector Switch Station Box to toggle power on/off to I/O.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选择开关站盒，用于切换I/O的电源开/关。
- en: An Industrial Signal Tower Lamp to display visual feedback.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工业信号塔灯，用于显示视觉反馈。
- en: A voltmeter to test continuity.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只电压表用于测试连通性。
- en: A 14-gauge wire to wire both the Selector Switch Station Box and signal tower
    lamp to the PLC.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根14号线，用于将选择开关站盒和信号塔灯连接到PLC。
- en: Wire cutters and wire strippers to treat and prep the wire for installation.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪线钳和剥线钳，用于处理和准备安装电线。
- en: Screwdrivers (Phillips head and flathead) to open and close the terminal set
    screws.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 螺丝刀（十字头和一字头）用于打开和关闭接线端子的紧固螺丝。
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3v5w61B](https://bit.ly/3v5w61B)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看本章代码的实际操作：[https://bit.ly/3v5w61B](https://bit.ly/3v5w61B)
- en: Writing and downloading our first program
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和下载我们的第一个程序
- en: 'Now comes the exciting part – writing our *hello world* program for the automation
    space. We are going to cover how to build a simple ladder logic program that will
    energize or de-energize a coil. This will help us establish a deeper understanding
    of how the Koyo Click software works. This is important as every PLC, SCADA, and
    **Distributed Control System** (**DCS**) follows the same set of guidelines and
    standards. Speaking of standards, one in particular that you should get familiar
    with is *IEC 61131-3*, as it helps define five core programming languages, as
    follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了令人兴奋的部分——编写我们的*hello world*自动化程序。我们将介绍如何构建一个简单的梯形逻辑程序，用于通电或断电一个线圈。这将帮助我们更深入地理解Koyo
    Click软件的工作原理。这一点很重要，因为每个PLC、SCADA和**分布式控制系统**（**DCS**）都遵循相同的标准和准则。说到标准，有一个特别的标准你应该熟悉，那就是*IEC
    61131-3*，它帮助定义了五种核心编程语言，如下所示：
- en: Ladder diagram
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梯形图
- en: Functional block diagram
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能块图
- en: Structured text
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化文本
- en: Instruction list
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令列表
- en: Sequential function chart
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序功能图
- en: Similar to software programming languages where the core fundamentals are common
    across all languages, only the syntax changes for the most part and with these
    five languages, three are graphical-based and two are text-based. The **CLICK
    programming software** utilizes a **ladder diagram** as the core programming language,
    also known as **ladder logic**, and it is the most common language that you will
    encounter in the process automation space. It mimics an electric circuit, allowing
    the inputs on the left-hand side to drive the outputs on the right-hand side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于软件编程语言，其中核心基本原理在所有语言中是相同的，主要变化在于语法，这五种语言中，有三种是基于图形的，两种是基于文本的。**CLICK 编程软件**使用**梯形图**作为核心编程语言，也叫做**梯形逻辑**，这是在过程自动化领域最常见的语言。它模仿电路，允许左侧的输入驱动右侧的输出。
- en: 'To start, we are going to open our Koyo Click software on our Windows 7 machine,
    as shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打开在 Windows 7 机器上的 Koyo Click 软件，如下图所示：
- en: '![Figure 3.1 – Koyo Click software'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – Koyo Click 软件'
- en: '](image/Figure_3.01_B16321.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.01_B16321.jpg)'
- en: Figure 3.1 – Koyo Click software
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Koyo Click 软件
- en: 'Click the **File** option from the menu bar and then select **New Project…**,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单栏中点击**文件**选项，然后选择**新建项目…**，如下所示：
- en: '![Figure 3.2 – New Project…'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 新建项目…'
- en: '](image/Figure_3.02_B16321.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.02_B16321.jpg)'
- en: Figure 3.2 – New Project…
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 新建项目…
- en: 'Next, you will be presented with a dialog box, as shown in the following screenshot.
    You need to double-click on the **Start a new project** icon:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个对话框，如下图所示。您需要双击**启动新项目**图标：
- en: '![Figure 3.3 – Start a new project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 启动新项目'
- en: '](image/Figure_3.03_B16321.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.03_B16321.jpg)'
- en: Figure 3.3 – Start a new project
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 启动新项目
- en: 'At this point, we''ll be taken to the **Select a CPU Module** window, as shown
    in the following screenshot. We will be using in the lab that was recommended
    in the previous chapter. Now, you might be asking yourself, "*Wait, wasn''t there
    an easier way to do this?*", and you would be correct. In the previous chapter,
    we simply connected to the PLC and the software took care of auto detection and
    selecting the correct CPU for us. However, I want to show you that there is more
    than one way to establish a project. With that said, you will see a screen similar
    to the following, where you need to select **C0-10ARE-D**, which we discussed
    in the previous chapter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入**选择 CPU 模块**窗口，如下图所示。我们将在实验室使用在上一章推荐的 CPU。现在，您可能会问自己，“*等等，这不是有更简单的方法吗？*”，您是对的。在上一章，我们只需连接到
    PLC，软件会自动检测并为我们选择正确的 CPU。然而，我想向您展示，建立项目的方式不止一种。话虽如此，您将看到类似以下的屏幕，您需要选择**C0-10ARE-D**，这是我们在上一章中讨论的：
- en: '![Figure 3.4 – Selecting a lab CPU'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 选择实验室 CPU'
- en: '](image/Figure_3.04_B16321.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.04_B16321.jpg)'
- en: Figure 3.4 – Selecting a lab CPU
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 选择实验室 CPU
- en: From here, you can see detailed information about the CPU. We have eight AC
    inputs and six relay outputs, along with information about power consumption.
    Now, click **OK** to continue with the CPU selection process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看关于 CPU 的详细信息。我们有八个交流输入和六个继电器输出，以及关于功耗的信息。现在，点击**确定**继续 CPU 选择过程。
- en: 'Once you click it, you will be brought back to the programming screen, as shown
    here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击，您将被带回到编程界面，如下所示：
- en: '![Figure 3.5 – Main program'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 主程序'
- en: '](image/Figure_3.05_B16321.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.05_B16321.jpg)'
- en: Figure 3.5 – Main program
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 主程序
- en: 'Before we start adding instructions to the ladder, we want to configure a few
    small details. Select the **Setup** menu option and then click **System Configuration**,
    as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始添加梯形图指令之前，我们需要配置一些小细节。选择**设置**菜单选项，然后点击**系统配置**，如下所示：
- en: '![Figure 3.6 – System Configuration…'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 系统配置…'
- en: '](image/Figure_3.06_B16321.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.06_B16321.jpg)'
- en: Figure 3.6 – System Configuration…
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 系统配置…
- en: 'This will take us to the following screen, which shows a graphical layout of
    our **PLC chassis**. Here, you can see that the CPU from our previous selection
    is shown and that a warning is displayed, indicating that we don''t have enough
    power to supply to the CPU. This is simply because we have yet to set the **Power
    Supply Unit** (**PSU**) on this screen:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到下面的屏幕，显示了我们**PLC 机箱**的图形布局。在这里，您可以看到我们之前选择的 CPU，并显示警告，指示我们没有足够的电源供应给 CPU。这仅仅是因为我们尚未在此屏幕上设置**电源供应单元**（**PSU**）：
- en: '![Figure 3.7 – System Configuration window'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 系统配置窗口'
- en: '](image/Figure_3.07_B16321.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.07_B16321.jpg)'
- en: Figure 3.7 – System Configuration window
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 系统配置窗口
- en: 'Click the **Select** button in the first column (the **P/S** column), as shown
    in the preceding screenshot. You will be presented with the option to select your
    power supply, as shown in the following screenshot. Select the power supply that
    you''ve purchased and installed in your lab:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一列（**P/S**列）中的**选择**按钮，如前面的屏幕截图所示。您将看到选择电源的选项，如下面的屏幕截图所示。选择您购买并安装在实验室中的电源：
- en: '![Figure 3.8 – The Select a Power Supply window'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 选择电源窗口'
- en: '](image/Figure_3.08_B16321.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.08_B16321.jpg)'
- en: Figure 3.8 – The Select a Power Supply window
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 选择电源窗口
- en: 'Similar to the screen that we saw previously for the CPU, we can see more details
    in regard to the **Power Supply** we purchased, such as the input and output voltages
    and max power generated. Go ahead and click **OK** to select and apply the power
    supply to the chassis overview. You should now see an image that represents the
    power supply connected to the CPU. You will see that the warning has disappeared
    as the power is more than sufficient to power the CPU:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前看到的用于 CPU 的屏幕，我们可以看到有关我们购买的**电源**的更多细节，例如输入和输出电压以及生成的最大功率。继续点击**确定**以选择并应用电源到机箱概览。您现在应该看到一个代表连接到
    CPU 的电源的图像。您会看到警告已经消失，因为电源足以为 CPU 供电：
- en: '![Figure 3.9 – Updated System Configuration window'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 更新的系统配置窗口'
- en: '](image/Figure_3.09_B16321.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.09_B16321.jpg)'
- en: Figure 3.9 – Updated System Configuration window
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 更新的系统配置窗口
- en: 'Now, click **OK** and jump right into the program. We want to create a simple
    program that allows us to push a button and turn on a light. However, before we
    start, I want to provide a very quick crash course on certain terminology:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**确定**并立即进入程序。我们想创建一个简单的程序，允许我们按下按钮并点亮灯。但是，在我们开始之前，我想快速介绍一些术语：
- en: '**Ladder** and **rungs**: A ladder diagram is used to represent a control program
    in an electrical wiring framework. The power sources are the *vertical lines*
    (ladder), while the control circuits are the *horizontal lines* (rungs).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**梯形图**和**横梁**：梯形图用于表示电气布线框架中的控制程序。电源是*垂直线*（梯形），而控制电路是*水平线*（横梁）。'
- en: '**Instruction list**: This is a list of graphical controls that are used to
    design the circuit for your program.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令列表**：这是用于设计程序电路的图形控件列表。'
- en: '**Contacts**: A contact is a graphical representation of a binary selector,
    similar to that of a wall switch, for a lack of a better definition.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接点**：接点是二进制选择器的图形表示，类似于墙上的开关，没有更好的定义。'
- en: '**NO**/**NC**: **Normally Open** and **Normally Closed** are terms for contacts
    where we want to control the *state* of the I/O. A normally open contact means
    that a circuit is running when the contact is open, and the inverse is true for
    normally closed.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NO**/**NC**：**常开**和**常闭**是我们想要控制 I/O *状态*的接点的术语。常开接点意味着当接点打开时电路运行，反之亦然。'
- en: 'Now that we have a better understanding of the layout and terminology, the
    next step would be to drag a NO **Contact** to rung number one. Then, we should
    proceed to select the address by clicking the **Address** button on the right-hand
    side, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对布局和术语有了更好的理解，下一步是将一个 NO **接点**拖到第一横排。然后，我们应该通过点击右侧的**地址**按钮来选择地址，如下面的屏幕截图所示：
- en: '![Figure 3.10 – Inserting a contact'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 插入一个接点'
- en: '](image/Figure_3.10_B16321.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.10_B16321.jpg)'
- en: Figure 3.10 – Inserting a contact
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 插入一个接点
- en: 'A dialog box will appear, allowing us to select the address intended from the
    list of addresses available on Koyo Click. In the following screenshot, we can
    see the list options, including **Address**, **Datatype**, **Nickname**, and more:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一个对话框，允许我们从Koyo Click提供的地址列表中选择所需的地址。在下面的截图中，我们可以看到列表选项，包括**地址**、**数据类型**、**昵称**等：
- en: '![Figure 3.11 – Address Picker'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 地址选择器'
- en: '](image/Figure_3.11_B16321.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.11_B16321.jpg)'
- en: Figure 3.11 – Address Picker
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 地址选择器
- en: 'Double-click the first address; that is, **X001**. This will populate your
    address choice, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 双击第一个地址；也就是**X001**。这将填充您的地址选择，如下截图所示：
- en: '![Figure 3.12 – Address selected'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – 选择的地址'
- en: '](image/Figure_3.12_B16321.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.12_B16321.jpg)'
- en: Figure 3.12 – Address selected
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 选择的地址
- en: 'Once you have clicked the **OK** button, you should see that you now have a
    contact input with an address of **X001** on rung 1, as shown in the following
    screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮后，您应该看到您现在在横梁1上有一个地址为**X001**的接触输入，如下截图所示：
- en: '![Figure 3.13 – Contact X001'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.13 – 接触 X001'
- en: '](image/Figure_3.13_B16321.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.13_B16321.jpg)'
- en: Figure 3.13 – Contact X001
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 接触 X001
- en: 'So, now that we have an input, we are going to want an output. Grab the **Out**
    function under the **Coil** section of the **Instruction List** menu on the right-hand
    side of the user interface, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们有了一个输入，我们将需要一个输出。在用户界面右侧的**指令列表**菜单的**线圈**部分下，找到**Out**功能，并将其拖动到右侧的**(
    NOP )**位置，如下截图所示：
- en: '![Figure 3.14 – Coil output'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.14 – 线圈输出'
- en: '](image/Figure_3.14_B16321.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.14_B16321.jpg)'
- en: Figure 3.14 – Coil output
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 线圈输出
- en: 'Drag the **Out** function to the **( NOP )** location at the end of rung 1,
    as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Out**功能拖动到横梁1末端的**( NOP )**位置，如下所示：
- en: '![Figure 3.15 – Output'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.15 – 输出'
- en: '](image/Figure_3.15_B16321.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.15_B16321.jpg)'
- en: Figure 3.15 – Output
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 输出
- en: 'Once the function locks in, it will create a dialog box, asking the programmer
    to configure **Bit Memory** addressing, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦功能锁定，将创建一个对话框，要求程序员配置**位内存**寻址，如下所示：
- en: '![Figure 3.16 – Coil address'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.16 – 线圈地址'
- en: '](image/Figure_3.16_B16321.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.16_B16321.jpg)'
- en: Figure 3.16 – Coil address
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 线圈地址
- en: 'Click the memory address picker icon; you will be presented with an **Address
    Picker** dialog box, similar to the once we encountered during the NO input contact
    step. The following screenshot shows that the address picker automatically displays
    the real-world list of output addresses:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击内存地址选择器图标；将会出现一个**地址选择器**对话框，类似于我们在NO输入接触步骤中遇到的对话框。下面的截图显示，地址选择器会自动显示真实世界的输出地址列表：
- en: '![Figure 3.17 – Address Picker'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.17 – 地址选择器'
- en: '](image/Figure_3.17_B16321.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.17_B16321.jpg)'
- en: Figure 3.17 – Address Picker
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 地址选择器
- en: 'Pick **Y001** as the output address for the coil that we placed onto rung 1
    and select **OK**. As shown in the following screenshot, it has auto-populated
    the **Bit Memory Address1:** selection. You should see a green check mark next
    to the address to indicate that the address is a valid memory location:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Y001**作为我们放置在横梁1上的线圈的输出地址，并选择**确定**。如下截图所示，它已经自动填充了**位内存地址1：**的选择。您应该看到地址旁边有一个绿色的勾号，表示该地址是一个有效的内存位置：
- en: '![Figure 3.18 – Bit Memory Address'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.18 – 位内存地址'
- en: '](image/Figure_3.18_B16321.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.18_B16321.jpg)'
- en: Figure 3.18 – Bit Memory Address
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 位内存地址
- en: 'Click **OK** to proceed and add the **Coil** to the output location, as shown
    in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**继续并将**线圈**添加到输出位置，如下截图所示：
- en: '![Figure 3.19 – Coil output'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.19 – 线圈输出'
- en: '](image/Figure_3.19_B16321.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.19_B16321.jpg)'
- en: Figure 3.19 – Coil output
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 线圈输出
- en: 'If you are wondering why we chose **X001** and **Y001** as the input and output
    addresses, look at the front of your CLICK PLC. On the terminal strip, find where
    the **pin outs** are labeled **X1** and **Y1**. These addresses relate directly
    to these I/O terminals, as shown in the following image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么我们选择**X001**和**Y001**作为输入和输出地址，请看看您的CLICK PLC的正面。在端子条上，找到标有**X1**和**Y1**的**引脚输出**标签。这些地址直接与这些I/O端子相关联，如下图所示：
- en: '![Figure 3.20 – Terminal pins'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.20 – 端子引脚'
- en: '](image/Figure_3.20_B16321.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.20_B16321.jpg)'
- en: Figure 3.20 – Terminal pins
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 端子引脚
- en: 'Next, we need to add an **END** function to tell the program that we have concluded
    all operations. From the **Instruction List** menu, under the **Program Control**
    heading, select and drag the **END** function to the **( NOP )** location at the
    end of rung 2, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个**END**功能，告诉程序我们已经完成所有操作。从**指令列表**菜单中，在**程序控制**标题下，选择并拖动**END**功能到第
    2 横排末尾的**( NOP )**位置，如下截图所示：
- en: '![Figure 3.21 – Adding an END function'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.21 – 添加 END 功能'
- en: '](image/Figure_3.21_B16321.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.21_B16321.jpg)'
- en: Figure 3.21 – Adding an END function
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 添加 END 功能
- en: 'After we add the **END** function, we want to check for syntax errors. It is
    a good idea to get into the habit of running **syntax checks** periodically so
    that you can catch any mistakes before they turn into major issues, as you develop
    more complex programs in the future. On the **Program** tab, double-click the
    **Syntax Check** option located in the **Ladder Program** folder, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加**END**功能后，我们要检查语法错误。定期运行**语法检查**是个好习惯，这样您可以在将来开发更复杂的程序时捕捉任何错误之前，避免它们变成重大问题。在**程序**选项卡上，双击**梯形图程序**文件夹中的**语法检查**选项，如下所示：
- en: '![Figure 3.22 – Syntax Check'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.22 – 语法检查'
- en: '](image/Figure_3.22_B16321.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.22_B16321.jpg)'
- en: Figure 3.22 – Syntax Check
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 语法检查
- en: 'In the **output window**, you should see the outcome of the syntax check. If
    you have followed along closely, you should have similar results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在**输出窗口**中，您应该看到语法检查的结果。如果您一直在紧密跟随，您应该有类似的结果：
- en: '![Figure 3.23 – Syntax Check'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.23 – 语法检查'
- en: '](image/Figure_3.23_B16321.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.23_B16321.jpg)'
- en: Figure 3.23 – Syntax Check
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 语法检查
- en: 'As you can see, there are **0 error(s)** and **0 warning(s)**. At this point,
    you should save the program and then write the project to your PLC. To write the
    project to your PLC, select the **Write Project into PLC…** option from the **PLC**
    menu, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，目前有**0 个错误**和**0 个警告**。此时，您应该保存程序，然后将项目写入 PLC。要将项目写入 PLC，请从**PLC**菜单中选择**将项目写入
    PLC…**选项，如下截图所示：
- en: '![Figure 3.24 – Write Project into PLC…'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.24 – 将项目写入 PLC…'
- en: '](image/Figure_3.24_B16321.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.24_B16321.jpg)'
- en: Figure 3.24 – Write Project into PLC…
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 将项目写入 PLC…
- en: 'Once done, you will be presented with a dialog box that gives you a brief overview
    of a **diff** function, which we will use on the current PLC project versus the
    project that you will be writing into the PLC, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将看到一个对话框，简要介绍了一个**diff**功能，我们将在当前 PLC 项目与您将写入 PLC 的项目上使用，如下所示：
- en: '![Figure 3.25 – Write Project into PLC window'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.25 – 将项目写入 PLC 窗口'
- en: '](image/Figure_3.25_B16321.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.25_B16321.jpg)'
- en: Figure 3.25 – Write Project into PLC window
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – 将项目写入 PLC 窗口
- en: 'If everything goes smoothly, you should see a **Transfer completed** dialog
    box, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到一个**传输完成**对话框，如下所示：
- en: '![Figure 3.26 – Transfer completed'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.26 – 传输完成'
- en: '](image/Figure_3.26_B16321.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.26_B16321.jpg)'
- en: Figure 3.26 – Transfer completed
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 传输完成
- en: 'Next, you will be asked to change the **PLC Modes** setting from **STOP** to
    **RUN**, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将被要求将**PLC 模式**设置从**停止**更改为**运行**，如下所示：
- en: '![Figure 3.27 – PLC Modes window'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.27 – PLC 模式窗口'
- en: '](image/Figure_3.27_B16321.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.27_B16321.jpg)'
- en: Figure 3.27 – PLC Modes window
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – PLC 模式窗口
- en: 'If everything worked correctly, you should see the following indicators:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到以下指示器：
- en: A green **RUN** status
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色的**运行**状态
- en: No **PLC Error** message
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有**PLC 错误**消息
- en: The **END** function highlighted in blue
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色突出显示的**END**功能
- en: '**Output Window** – **Write Project to into PLC…**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出窗口** – **将项目写入 PLC…**'
- en: '**Output Window** – **Transfer completed**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出窗口** – **传输完成**'
- en: 'These indicators are shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指示器显示在以下截图中：
- en: '![Figure 3.28 – Running indicators'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.28 – 运行指示器'
- en: '](image/Figure_3.28_B16321.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.28_B16321.jpg)'
- en: Figure 3.28 – Running indicators
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – 运行指示器
- en: In this section, we learned how to create a simple program using inputs and
    outputs consisting of a Normally Open contact and a coil. We performed a syntax
    check and wrote the project to our PLC. This allowed us to get a deeper grasp
    of how the programming software works and some hands-on experience with creating
    and writing a project. These are the fundamentals to learn and are the building
    blocks of any automation and control-based project. In the next section, we are
    going to simulate a signal on our input to cause our program to produce an output.
    Then, we are going to energize the coil that we created in our program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何使用输入和输出创建一个简单的程序，该程序包含常开触点和线圈。我们进行了语法检查，并将项目写入我们的PLC。这使我们更深入地理解了编程软件的工作原理，并获得了创建和写入项目的实践经验。这些是学习的基础，是任何自动化和控制项目的构建模块。在下一部分，我们将模拟输入上的信号，使我们的程序产生输出。然后，我们将为程序中创建的线圈提供电能。
- en: Overriding and wiring the I/O
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖和接线输入输出
- en: In the previous section, we created a simple *hello world* program and wrote
    it to our PLC. In this section, we are going to simulate a signal on our input
    contact to energize our coil on the output. We will be diving deeper into the
    functionality of the CLICK programming software, familiarizing ourselves with
    the data view, and **overriding** inputs to generate an energized coil. To do
    this, we are going to utilize a tool called **Data View**, which allows us to
    read and write values to the memory address that we selected for the Normally
    Open contact we created in the previous section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们创建了一个简单的*Hello World*程序，并将其写入PLC。在这一部分，我们将模拟输入触点上的信号，为输出端的线圈供电。我们将深入了解CLICK编程软件的功能，熟悉数据视图，并**覆盖**输入以产生一个通电的线圈。为此，我们将使用一个名为**数据视图**的工具，它允许我们读取和写入我们在上一部分中为常开触点选择的内存地址。
- en: 'To do this, open the **Data View** window from the **Monitor** menu, as shown
    in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请从**监视器**菜单中打开**数据视图**窗口，如下图所示：
- en: '![Figure 3.29 – Data View selection'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.29 – 数据视图选择'
- en: '](image/Figure_3.29_B16321.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.29_B16321.jpg)'
- en: Figure 3.29 – Data View selection
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – 数据视图选择
- en: 'You will be presented with a blank table, as shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个空白表格，如下所示：
- en: '![Figure 3.30 – Data View tool'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.30 – 数据视图工具'
- en: '](image/Figure_3.30_B16321.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.30_B16321.jpg)'
- en: Figure 3.30 – Data View tool
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.30 – 数据视图工具
- en: 'Now, we are going to select the **Address** cell at row **001** and then click
    the **Edit** button in the left-hand corner of the dialog box, which will allow
    you to select the address picker we used previously. Here, we assigned addresses
    to both the **contact input** and the **coil output**. Next, you will see the
    auto populated address space starting at **X001**, and in the first memory address,
    you should see a **Yes** in the **Used** column for **X001**. This is feedback,
    telling us that we have used **X001** in our program. This can be seen in the
    following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将选择**001**行中的**地址**单元格，然后点击对话框左上角的**编辑**按钮，这将允许您选择我们之前使用的地址选择器。在这里，我们为**触点输入**和**线圈输出**分配了地址。接下来，您将看到自动填充的地址空间，从**X001**开始，在第一个内存地址中，您应该会看到**X001**的**已使用**列中显示**是**。这是反馈，告诉我们在程序中使用了**X001**。如下图所示：
- en: '![Figure 3.31 – Address Picker'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.31 – 地址选择器'
- en: '](image/Figure_3.31_B16321.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.31_B16321.jpg)'
- en: Figure 3.31 – Address Picker
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31 – 地址选择器
- en: 'Go ahead and select **X001** and press the **OK** button. This will then populate
    the **No.** **001** row of our **Data View** tool. You will see the settings for
    **Nickname**, if you gave it one previously, our **Current Value**, our **New
    Value**, **Write** (for feedback), **Viewing Format**, and any address comments
    that you might have added. This is shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 继续选择**X001**并按下**确定**按钮。这样将填充我们的**数据视图**工具中的**编号** **001**行。您将看到**昵称**设置（如果之前给它设置了），我们的**当前值**，**新值**，**写入**（用于反馈），**查看格式**，以及您可能添加的任何地址评论。如下图所示：
- en: '![Figure 3.32 – X001 address selected'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.32 – 选择的 X001 地址'
- en: '](image/Figure_3.32_B16321.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.32_B16321.jpg)'
- en: Figure 3.32 – X001 address selected
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.32 – 选择的 X001 地址
- en: 'Now, try selecting the **ON** button in the **New Value** column. An icon will
    appear in the **Write** column, which allows you to write the input value to the
    PLC. Double-click the icon to see what happens. Nothing should have happened at
    this point. The icon does write the value to PLC''s memory space, but the pin
    I/O is primary and nothing has changed on the physical input on the PLC, so nothing
    has changed. It is because of this behavior that we must enable **override**.
    From the dialog box, we will see a selection for **View Override**. You need to
    enable this option. After doing so, you will see that a new column has been added
    next to the **Write** icon. An **OVR** button has been added, as shown in the
    following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试选择**新值**列中的**ON**按钮。**写入**列中将出现一个图标，允许你将输入值写入PLC。双击该图标，看看会发生什么。此时应该什么都没有发生。图标确实将值写入PLC的内存空间，但针脚I/O是主导的，PLC上的物理输入没有发生变化，因此什么都没有改变。正是因为这种行为，我们必须启用**Override**。在对话框中，我们会看到**查看
    Override**的选项。你需要启用此选项。启用后，你将看到在**写入**图标旁边新增了一列。添加了一个**OVR**按钮，如下图所示：
- en: '![Figure 3.33 – Override'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.33 – Override'
- en: '](image/Figure_3.33_B16321.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.33_B16321.jpg)'
- en: Figure 3.33 – Override
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.33 – Override
- en: 'Double-click the **OVR** button, which will enable the **Override** functionality
    for this I/O. The CLICK programming software turns on an **Override** indicator
    on the primary window, and also highlights the **OVR** button in yellow in the
    **Data View** window:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 双击**OVR**按钮，这将启用此I/O的**Override**功能。CLICK编程软件会在主窗口中打开**Override**指示器，并在**数据视图**窗口中将**OVR**按钮高亮显示为黄色：
- en: '![Figure 3.34 – Override engaged'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.34 – 启用 Override'
- en: '](image/Figure_3.34_B16321.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.34_B16321.jpg)'
- en: Figure 3.34 – Override engaged
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.34 – 启用 Override
- en: 'Now, try and rerun the operation we ran previously, select the **ON** button
    in the **New Value** column, and double-click the **Write** icon. You should hear
    the coil energizing on the PLC and visually see the lights enabled on it, as well
    as the programming software showing **X001** highlighted, along with **Y001**,
    as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试重新运行我们之前运行的操作，在**新值**列中选择**ON**按钮，并双击**写入**图标。你应该能听到PLC上线圈的通电声音，并且可以看到线圈上的指示灯亮起，同时编程软件显示**X001**被高亮显示，以及**Y001**，如下所示：
- en: '![Figure 3.35 – Energized coil'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.35 – 通电线圈'
- en: '](image/Figure_3.35_B16321.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.35_B16321.jpg)'
- en: Figure 3.35 – Energized coil
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35 – 通电线圈
- en: 'If you do not see the highlighted input and output, as shown here, make sure
    to check that you have **Status Monitor** selected. It can be found in the **Monitor**
    menu, after selecting **Status Monitor**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到高亮显示的输入和输出，如图所示，请确保选择了**状态监视器**。你可以在**监视器**菜单中找到它，选择**状态监视器**后：
- en: '![Figure 3.36 – Status Monitor'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.36 – 状态监视器'
- en: '](image/Figure_3.36_B16321.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.36_B16321.jpg)'
- en: Figure 3.36 – Status Monitor
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.36 – 状态监视器
- en: 'Go ahead and double-click the **OFF** button in the **New Value** column, as
    shown in the following screenshot. You should notice that by double-clicking the
    button, we save a step; this is simply to show that there are multiple ways to
    quickly override the input:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继续双击**新值**列中的**OFF**按钮，如下图所示。你应该会注意到，通过双击按钮，我们节省了一步；这只是为了显示有多种方式可以快速覆盖输入：
- en: '![Figure 3.37 – Input is off'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.37 – 输入关闭'
- en: '](image/Figure_3.37_B16321.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.37_B16321.jpg)'
- en: Figure 3.37 – Input is off
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.37 – 输入关闭
- en: 'So far, everything we have done has been software focused. Now, we are going
    to use the **Selector Switch Station Box**, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们做的所有操作都是软件相关的。现在，我们将使用**选择开关站框**，如图所示：
- en: '![Figure 3.38 – Selector Switch Station Box'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.38 – 选择开关站框'
- en: '](image/Figure_3.38_B16321.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.38_B16321.jpg)'
- en: Figure 3.38 – Selector Switch Station Box
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.38 – 选择开关站框
- en: This switch, or a switch very similar to it, can be purchased on Amazon. We
    will be using the momentary *push button*, which is the green button, and wiring
    this to the **X001** input contact that we programmed and addressed in the previous
    section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开关，或类似的开关，可以在亚马逊上购买。我们将使用短时**按键**，即绿色按钮，并将其接线到我们在上一节中编程并寻址的**X001**输入接点。
- en: 'Use your *Phillips* screwdriver to remove the four faceplate screws and the
    faceplate. When you open the **Station Box**, you will see the three switch blocks,
    each of which will contain four terminals. Focusing on the momentary switch, the
    two sets of terminals correlate to the action of the switch. Since I want power
    to pass through the switch when I press the button, I will use the bottom set
    of terminals. You can test the terminals by utilizing your **voltmeter** and test
    the continuity on either side of the block. Press the switch to see if the terminals
    create a short, causing your voltmeter to beep. I feel that checking continuity
    with my voltmeter over hundreds of projects has been the primary use case for
    it, which now that I think about it is kind of sad, since the voltmeter has so
    many other functions and features. Once you feel comfortable that you are using
    the correct terminals, cut and strip two wires. Screw an end from each wire to
    either side of the terminal. Then, on one side, extend to the power source and
    on the other side, extend this wire to the **X1** I/O on the **PLC**. This can
    be seen in the following diagram:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的*菲利普斯*螺丝刀拆下四个面板螺丝和面板。当你打开**控制箱**时，你会看到三个开关模块，每个模块里都有四个接线端子。专注于瞬时开关，两个接线端子组与开关的动作相关联。因为我希望按下按钮时电流能够通过开关，所以我将使用底部的接线端子。你可以使用**电压表**测试接线端子，并测试模块两侧的连续性。按下开关，看看接线端子是否产生短路，导致电压表发出蜂鸣声。我认为，使用电压表检查连续性已经成为我数百个项目中的主要用途，现在想想其实有些可惜，因为电压表还有很多其他功能和特性。一旦你确认使用的是正确的接线端子，剪下并剥去两根电线的绝缘层。将每根电线的一端连接到接线端子两侧。然后，一侧连接到电源，另一侧将这根电线连接到**X1**的**PLC**输入/输出端。可以参考以下图示：
- en: '![Figure 3.39 – Wire diagram'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.39 – 接线图'
- en: '](image/Figure_3.39_B16321.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.39_B16321.jpg)'
- en: Figure 3.39 – Wire diagram
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 – 接线图
- en: 'On the I/O terminal, you will notice **C1** and **C2**, which stand for **Common
    1** and **Common 2**. Wire Common 1 to ground. If all the **wiring** is done correctly,
    pressing the momentary switch will cause the coil to energize and you should see
    a red light, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入/输出端子上，你会看到**C1**和**C2**，分别代表**公共端1**和**公共端2**。将公共端1接地。如果所有**接线**都正确，按下瞬时开关将激活线圈，你应该会看到红色指示灯亮起，如图所示：
- en: '![Figure 3.40 – Physical wire'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.40 – 实物接线'
- en: '](image/Figure_3.40_B16321.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.40_B16321.jpg)'
- en: Figure 3.40 – Physical wire
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.40 – 实物接线
- en: 'We now have a push button controlling the input of **X001** and we also have
    visual feedback on **Y001**. Next, we are going to wire up the output to our **Industrial
    Signal Tower Lamp**, which will look similar to the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个控制**X001**输入的按钮，并且在**Y001**上有了视觉反馈。接下来，我们将为**工业信号塔灯**接线输出，其外观类似于下图：
- en: '![Figure 3.41 – Industrial Signal Tower Lamp'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.41 – 工业信号塔灯'
- en: '](image/Figure_3.41_B16321.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.41_B16321.jpg)'
- en: Figure 3.41 – Industrial Signal Tower Lamp
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.41 – 工业信号塔灯
- en: Important note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Wiring the output will require you to make a change to your program by duplicating
    rung 1 and creating a rung per light in your Signal Tower Lamp. I am using a four-light
    system, with *red*, *yellow*, *green*, and *blue* lights.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接线输出将需要你修改程序，通过复制第1行并为信号塔灯中的每盏灯创建一行。我使用的是一个四灯系统，包含*红色*、*黄色*、*绿色*和*蓝色*灯。
- en: 'The following diagram shows how to connect your Signal Tower Lamp to the output
    channels. Because I am using a four-light system, I will run red to **Y001**,
    yellow to **Y002**, green to **Y003**, and blue to **Y004**, as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了如何将信号塔灯连接到输出通道。因为我使用的是一个四灯系统，所以我将红色接到**Y001**，黄色接到**Y002**，绿色接到**Y003**，蓝色接到**Y004**，如图所示：
- en: '![Figure 3.42 – Output wiring to the Tower Lamp'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.42 – 输出接线到塔灯'
- en: '](image/Figure_3.42_B16321.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.42_B16321.jpg)'
- en: Figure 3.42 – Output wiring to the Tower Lamp
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.42 – 输出接线到塔灯
- en: 'At this point, you should have wired up your outputs and changed your program
    to accommodate the new light output, as well as written the changes to the CLICK
    PLC. This process is the same as what we did the previous section, when we wrote
    the single rung program to the PLC. Your program should look as follows, in that
    you should have four distinct new inputs from **X001** – **X004** and four distinct
    outputs from **Y001** – **Y004**:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经接好了输出并更改了程序以适应新的灯光输出，并将更改写入CLICK PLC。这个过程与上一节中我们写入PLC的单个梯形图程序相同。你的程序应该如下所示，应该有四个新的独立输入来自**X001**到**X004**，以及四个新的独立输出来自**Y001**到**Y004**：
- en: '![Figure 3.43 – Program with four-light wiring'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.43 – 四灯接线程序'
- en: '](image/Figure_3.43_B16321.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.43_B16321.jpg)'
- en: Figure 3.43 – Program with four-light wiring
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.43 – 四灯接线程序
- en: In this section, we learned how to override input values to simulate a signal
    on the output side of the controller. We wired up a pushbutton switch to X001
    and wired up a Signal Tower Lamp four-light system to Y001, Y002, Y003, and Y004\.
    We now have a fully functional physical demo for our lab, and have also had a
    little exposure to the trials and tribulations that automation engineers go through
    when they approach a new project with new components. In the next section, we
    are going to learn how to interact with our lab via scripts that we will write
    and launch.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何重写输入值以模拟控制器输出端的信号。我们将一个按钮开关接入X001，并将四灯信号塔灯接入Y001、Y002、Y003和Y004。现在，我们有了一个完整的物理演示，并且对自动化工程师在接手新项目和新组件时所面临的挑战有了一定了解。在下一节中，我们将学习如何通过编写和启动脚本与我们的实验室进行交互。
- en: Testing control
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制测试
- en: In the previous section, we learned how to override the inputs and simulate
    a signal on contact X001, which allowed us to trigger an output on the Y001 coil.
    We then proceeded to wire up the input side of the PLC to a switch and reproduce
    the same results, but this time with a physical input. Finally, we wired up our
    four-light Signal Tower. In this section, we are going to test the **Signal Tower**
    both from the **DataView** and from our SCADA VM by utilizing the **MBtget** tool
    that we installed in [*Chapter 2*](B16321_02_Epub_AM.xhtml#_idTextAnchor027),
    *Route the Hardware*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何重写输入并在接触点X001上模拟信号，从而触发Y001线圈上的输出。接着，我们将PLC的输入端接到开关，并用物理输入再现相同的结果。最后，我们接线了四灯信号塔。在本节中，我们将通过使用在[*第2章*](B16321_02_Epub_AM.xhtml#_idTextAnchor027)中安装的**MBtget**工具，从**DataView**和我们的SCADA虚拟机测试**信号塔**。
- en: 'You will need to perform the following steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要执行以下步骤：
- en: Open **DataView1**, as we did in the previous section; as a refresher, check
    the following screenshot, where you will find it in the **Monitor** | **Data View**
    section:![Figure 3.44 – Data View
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**DataView1**，正如我们在上一节中所做的那样；作为复习，请查看以下截图，你将在**监视器**| **数据视图**部分找到它：![图 3.44
    – 数据视图
- en: '](image/Figure_3.44_B16321.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_3.44_B16321.jpg)'
- en: Figure 3.44 – Data View
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.44 – 数据视图
- en: This will bring up the window for Data View. As we did previously, add the new
    contacts you created in the previous section. These contacts are **X002**, **X003**,
    and **X004** in the address space. Make sure to enable the **View Override** option.
    If everything has worked correctly, your screen should look similar to the following:![Figure
    3.45 – Data View
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将弹出数据视图窗口。正如我们之前所做的，添加你在上一节中创建的新接点。这些接点是地址空间中的**X002**、**X003**和**X004**。确保启用**视图重写**选项。如果一切顺利，你的屏幕应该类似于以下内容：![图
    3.45 – 数据视图
- en: '](image/Figure_3.45_B16321.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_3.45_B16321.jpg)'
- en: Figure 3.45 – Data View
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.45 – 数据视图
- en: Now, go ahead and toggle the inputs and move through each value, ensuring that
    your physical light tower turns on the matching light that you have configured
    for your output. You will notice that you have visual feedback on the face of
    the CLICK, much like you do inside your software, as shown here:![Figure 3.46
    – Overriding the lamp
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续切换输入并逐步移动每个值，确保你的物理灯塔打开与你为输出配置的匹配灯光。你会注意到你可以看到CLICK上的视觉反馈，和你在软件中看到的一样，如下所示：![图
    3.46 – 重写灯光
- en: '](image/Figure_3.46_B16321.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](image/Figure_3.46_B16321.jpg)'
- en: Figure 3.46 – Overriding the lamp
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.46 – 重写灯光
- en: 'Now that we have all the lights working, open the **SCADA VM** that we created
    it in previously. Go to **Navigator** > **Virtual Machines** > **SCADA** to find
    it, as shown here:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将所有灯光打开，打开之前我们创建的 **SCADA 虚拟机**。前往 **Navigator** > **Virtual Machines**
    > **SCADA** 来查找它，如下所示：
- en: '![Figure 3.47 – SCADA VM'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.47 – SCADA 虚拟机'
- en: '](image/Figure_3.47_B16321.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.47_B16321.jpg)'
- en: Figure 3.47 – SCADA VM
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.47 – SCADA 虚拟机
- en: 'Launch the console for SCADA and open your **Terminal** program. Use the **mbtget
    -h** command to see details about the **mbtget** tool, as shown here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 SCADA 控制台并打开您的 **终端** 程序。使用 **mbtget -h** 命令查看有关 **mbtget** 工具的详细信息，如下所示：
- en: '![Figure 3.48 – mbtget tool'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.48 – mbtget 工具'
- en: '](image/Figure_3.48_B16321.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.48_B16321.jpg)'
- en: Figure 3.48 – mbtget tool
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.48 – mbtget 工具
- en: A good moment to explain mbtget
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释 mbtget 的一个好时机
- en: 'mbtget is a tool written in Perl that allows us to directly interact with Koyo
    Click via *ModbusTCP* over port **502**. For more details go to the following
    link and view the project on GitHub: [https://github.com/sourceperl/mbtget](https://github.com/sourceperl/mbtget).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget 是一个用 Perl 编写的工具，允许我们通过 **ModbusTCP** 在端口 **502** 上直接与 Koyo Click 交互。有关更多详细信息，请访问以下链接并查看
    GitHub 上的项目：[https://github.com/sourceperl/mbtget](https://github.com/sourceperl/mbtget)。
- en: 'OK; let''s go back to our normal programming. Now that we have mbtget sitting
    on our SCADA machine, we can check the bits on the four coils that we configured
    in the previous section by running the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们回到正常的编程工作。现在我们已经将 mbtget 安装在 SCADA 机器上，我们可以通过运行以下命令检查我们在上一部分中配置的四个线圈的位：
- en: mbtget -r1 -a 0 192.168.1.20
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -r1 -a 0 192.168.1.20
- en: 'Let''s look at the arguments that are included in the command. We will cover
    the **modbus** protocol in greater detail in [*Chapter 8*](B16321_08_Epub_AM.xhtml#_idTextAnchor097)*,
    Protocols 202*. For now, we need to know what the memory address is for the coils
    that we are using, and also whether we want to read or write to that memory address:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下命令中包含的参数。我们将在 [*第 8 章*](B16321_08_Epub_AM.xhtml#_idTextAnchor097)*，协议
    202* 中更详细地介绍 **modbus** 协议。现在，我们需要知道我们正在使用的线圈的内存地址，以及我们是要读取还是写入该内存地址：
- en: '**-r1**: Reads bit(s) at function **1**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r1**：读取功能 **1** 的位'
- en: '**-a**: Address at **0**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-a**：地址 **0**'
- en: The PLC address is **192.168.1.20**
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLC 地址是 **192.168.1.20**
- en: 'If you have cleared all the overrides that have been set in the programming
    software, you should see the following output, where the value at address **1**
    is **0**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经清除了编程软件中设置的所有覆盖项，您应该看到以下输出，其中地址 **1** 的值为 **0**：
- en: '![Figure 3.49 – Address 0 read output'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.49 – 地址 0 读取输出'
- en: '](image/Figure_3.49_B16321.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.49_B16321.jpg)'
- en: Figure 3.49 – Address 0 read output
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.49 – 地址 0 读取输出
- en: 'Now, write a value to the coil using the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令将值写入线圈：
- en: mbtget -w5 1 -a 0 192.168.1.20
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -w5 1 -a 0 192.168.1.20
- en: 'The following are the arguments that are included in the command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令中包含的参数：
- en: '**-w5**: Writes a function value of **1** for on'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-w5**：将功能值 **1** 写入以开启'
- en: '**-a**: Address **0**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-a**：地址 **0**'
- en: The PLC address is **192.168.1.20**
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLC 地址是 **192.168.1.20**
- en: 'If everything worked, you should have turned on the first/top light in your
    signal tower and have the following result:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该已经点亮了信号塔中的第一个/最上面的灯，并获得以下结果：
- en: '![Figure 3.50 – Writing the value to the coil'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.50 – 写入值到线圈'
- en: '](image/Figure_3.50_B16321.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.50_B16321.jpg)'
- en: Figure 3.50 – Writing the value to the coil
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.50 – 写入值到线圈
- en: 'Now, to confirm the output using **mbtget**, run the read coil command again:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用 **mbtget** 确认输出，请再次运行读取线圈命令：
- en: mbtget -r1 -a 0 192.168.1.20
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: mbtget -r1 -a 0 192.168.1.20
- en: 'The following are the arguments in the command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令中的参数：
- en: '**-r1**: Reads bit(s) function **1**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-r1**：读取功能 **1** 的位'
- en: '**-a**: Address **0**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-a**：地址 **0**'
- en: The PLC address is **192.168.1.20**
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLC 地址是 **192.168.1.20**
- en: 'If everything is working, you should the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到以下输出：
- en: '![Figure 3.51 – Reading coil address 0'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.51 – 读取线圈地址 0'
- en: '](image/Figure_3.51_B16321.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.51_B16321.jpg)'
- en: Figure 3.51 – Reading coil address 0
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.51 – 读取线圈地址 0
- en: You should have seen that the address value has changed to **1** and that the
    light is on. Go ahead and test the remaining lights in your tower by going through
    the same steps we went through previously. Write a **1** to your next few addresses,
    read the coil bits, and make sure the output is as expected.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到地址值已经更改为 **1**，并且灯亮了。继续测试塔中的其余灯光，按照我们之前的步骤进行操作。将 **1** 写入下一个地址，读取线圈位，并确保输出符合预期。
- en: You may have noticed how easy it was to randomly set a bit with a simple command-line
    function, and you might be wondering where the security features are. Why could
    you override a coil without having to enter a *key* or *password*? Is this truly
    how insecure the *industrial environment* is? Well, I have to say *yes and no*.
    Yes, the industrial environment has traditionally been this insecure, but there
    has been great progress in opening awareness to the security issues that reside
    in the field. The *vendors* have listened and started to embed security layers
    into their systems. However, this doesn't mean that customers have upgraded their
    legacy systems to the new technology. Now, for those of you who are curious, who
    might have realized what is going on… yes, yes, you caught me – the reason why
    this works is because we have the overrides enabled on the programming software
    still. Remove the overrides and try testing mbtget again by forcing a coil. What
    were the results? You shouldn't see an outcome – nothing should happen. This is
    because we have told the PLC to only react to localized input.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，通过一个简单的命令行功能随机设置一个比特是多么容易，可能会想知道安全特性在哪里。为什么你可以覆盖一个线圈而不需要输入*密钥*或*密码*？这真的是*工业环境*如此不安全吗？嗯，我得说*是的，也不是*。是的，工业环境传统上一直如此不安全，但在提升对该领域存在的安全问题的意识方面，已经取得了很大进展。*厂商*们已经听取了反馈，并开始将安全层嵌入到他们的系统中。然而，这并不意味着客户已经将其遗留系统升级为新技术。现在，对于那些好奇的你们，可能已经意识到发生了什么……是的，你们抓到了我——之所以能够这么做，是因为我们在编程软件中仍然启用了覆盖功能。移除覆盖功能后，再尝试通过强制控制线圈来测试mbtget。结果如何？你应该看不到任何结果——什么也不会发生。这是因为我们已经告诉PLC只对本地输入做出反应。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built an introductory functional lab, where we can develop
    logic inside our PLC and connect to real-world inputs and outputs to see how things
    react to certain environmental tests. This helps relay a fundamental understanding
    of how industrial systems operate and work. Building on these core concepts allows
    us to extend our lab to more complex scenarios. We used the **engineering software**
    to force inputs, and then we replicated the same behavior remotely with mbtget
    to convey how easy it is to change a simple on/off input on a controller.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个介绍性功能实验室，在这里我们可以在PLC中开发逻辑，并连接到现实世界的输入输出，观察在特定环境测试下事物如何反应。这有助于传达工业系统如何运作和工作的基本理解。基于这些核心概念，我们可以将实验室扩展到更复杂的场景。我们使用**工程软件**强制输入，然后我们通过mbtget在远程复制相同的行为，以说明如何轻松改变控制器上的简单开/关输入。
- en: Imagine what other industry processes operate this way, such as opening and
    closing valves on a water plant or opening a valve on a lye, also known as a sodium
    hydroxide, holding tank, and allowing it to flow into water treatment units, similar
    to the *Florida City Water Supply hack* on February 5, 2021\. However, the Florida
    City Water Supply hack is more complex as it involved changing a concentration
    amount on an operator screen. This change runs through a recipe logic block and
    ultimately tells the valve to stay open longer until the concentration level matches
    the new setpoint change. This is an example of how real-world impacts can occur
    from making small changes to logic. This is a double-edged sword, and a cautionary
    tale when it comes to pentesting engagements. It's quite easy to break and cause
    downtime in a customer's process, resulting in heavy production and revenue losses.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下其他行业流程是如何运作的，例如水厂上开关阀门，或是打开氢氧化钠（也称为烧碱）储罐的阀门，并允许它流入水处理单元，这与2021年2月5日发生的*佛罗里达市供水黑客攻击*类似。然而，佛罗里达市供水黑客攻击更为复杂，因为它涉及在操作员屏幕上更改浓度数值。这一更改通过食谱逻辑块传递，最终指示阀门保持更长时间开启，直到浓度水平匹配新的设定值。这是一个实际世界中，因小小的逻辑更改而可能产生重大影响的例子。这是双刃剑，也是渗透测试任务中的警示故事。非常容易破坏并导致客户流程停机，从而造成严重的生产和收入损失。
- en: In the next chapter, we will be taking a break from building our ICS lab and
    discussing **Open Source Intelligence** (**OSINT**) gathering, since this is a
    critical step in any pentesting engagement.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时停止构建我们的ICS实验室，并讨论**开源情报**（**OSINT**）收集，因为这是任何渗透测试任务中的关键步骤。
