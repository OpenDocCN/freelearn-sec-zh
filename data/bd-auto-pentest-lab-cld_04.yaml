- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Setting Up Isolated Penetration Testing Lab Environments on GCP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCP上设置隔离的渗透测试实验室环境
- en: While setting up cloud-based penetration testing labs, we are deliberately creating
    a vulnerable and misconfigured environment where we can practice various security
    techniques. It is critical that we secure the resources inside this lab environment
    from unauthorized external attacks and mitigate the risk of planned interference
    with any of the authorized testing activities or simulations inside the environment.
    *Imagine attackers managing to gain unauthorized access to vulnerable resources
    inside your penetration testing lab environment!* These attackers would be able
    to leverage the cloud resources to perform various malicious activities—including
    launching **Distributed Denial-of-Service** (**DDoS**) attacks, attacking the
    systems owned by other users and organizations, and even spreading malware from
    inside the compromised cloud account. *Scary, right?* By isolating vulnerable
    lab resources using a properly configured network environment, we can maintain
    a secure testing environment and minimize the risks associated with having penetration
    testing lab environments in the cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置基于云的渗透测试实验室时，我们故意创建一个易受攻击且配置错误的环境，以便练习各种安全技术。确保实验室环境中的资源免受未经授权的外部攻击，并减轻任何对实验室内授权测试活动或模拟的干扰风险是至关重要的。*想象一下，攻击者设法获得了对你的渗透测试实验室环境中易受攻击资源的未经授权的访问！*
    这些攻击者可以利用云资源执行各种恶意活动——包括发起**分布式拒绝服务**（**DDoS**）攻击，攻击其他用户和组织拥有的系统，甚至在受损的云账户内传播恶意软件。*可怕吧？*
    通过使用正确配置的网络环境将易受攻击的实验室资源隔离开来，我们可以保持一个安全的测试环境，最小化在云中设置渗透测试实验室所带来的风险。
- en: In this chapter, we will prepare an isolated network environment in **Google
    Cloud Platform** (**GCP**) and use this network environment for setting up a penetration
    testing lab environment secured from unauthorized external attacks. Inside one
    of the **Virtual Private Cloud** (**VPC**) networks of the overall network environment,
    we will set up a target **virtual machine** (**VM**) instance that hosts an intentionally
    vulnerable web application called the **OWASP Juice Shop**. Then, in a separate
    VPC network, we will launch an attacker VM instance (running a penetration testing-focused
    Linux distribution called **Kali Linux**) and configure it with browser-based
    access to its desktop environment. We will then establish VPC peering to create
    a connection between the target VPC network and the attacker VPC network. Finally,
    we will perform a quick penetration testing simulation inside the isolated network
    environment to verify that everything is working correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将准备一个**Google Cloud Platform**（**GCP**）中的隔离网络环境，并利用这个网络环境设置一个渗透测试实验室，防止未经授权的外部攻击。在整个网络环境的**虚拟私有云**（**VPC**）网络中，我们将设置一个目标**虚拟机**（**VM**）实例，托管一个故意存在漏洞的Web应用程序——**OWASP
    Juice Shop**。然后，在一个单独的VPC网络中，我们将启动一个攻击者虚拟机实例（运行一个名为**Kali Linux**的专注于渗透测试的Linux发行版），并配置其具有浏览器访问的桌面环境。接着，我们将建立VPC对等连接，创建目标VPC网络与攻击者VPC网络之间的连接。最后，我们将在隔离的网络环境中执行快速渗透测试模拟，以验证一切是否正常运行。
- en: 'That said, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将在本章中覆盖以下主题：
- en: Preparing the necessary components and prerequisites
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备必要的组件和前提条件
- en: Defining the project structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义项目结构
- en: Preparing the isolated network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备隔离网络
- en: Setting up the target VM instance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置目标虚拟机实例
- en: Importing the Kali Linux Generic Cloud Image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入Kali Linux通用云镜像
- en: Manually setting up the attacker VM instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动设置攻击者虚拟机实例
- en: Leveraging Terraform to automatically set up the attacker VM instance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Terraform自动设置攻击者虚拟机实例
- en: Simulating penetration testing in an isolated network environment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隔离网络环境中模拟渗透测试
- en: Cleaning up
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理工作
- en: In the first few chapters of this book, we primarily focused on using AWS when
    setting up penetration testing lab environments in the cloud. However, in this
    chapter, our attention will shift to GCP, where we will deploy various cloud resources
    inside a new GCP account. Since its introduction in 2008, GCP has rapidly evolved
    to offer a diverse range of infrastructure and platform services—including VMs
    and database services, along with data engineering and **machine learning** (**ML**)
    services. That said, it is essential for us to explore the process of building
    penetration testing lab environments within this mature and versatile cloud platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章主要集中在使用 AWS 来设置云端渗透测试实验室环境。然而，在本章中，我们的重点将转向 GCP，我们将在新的 GCP 账户内部署各种云资源。自2008年推出以来，GCP迅速发展，提供了多种基础设施和平台服务——包括虚拟机和数据库服务，以及数据工程和**机器学习**（**ML**）服务。因此，探索如何在这个成熟且多功能的云平台上构建渗透测试实验室环境是非常必要的。
- en: With these points in mind, let’s begin!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些准备，我们就可以开始了！
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start, we must have the following ready:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，以下准备工作需要完成：
- en: '**A GCP account**—You may start with a free trial account by completing the
    steps specified in the following link: [https://cloud.google.com/free/](https://cloud.google.com/free/).
    In case you have not set up a billing account in your GCP account, make sure that
    you have properly set up billing information/profile so that you can access and
    use the GCP services without interruption. For more information on how to create
    a billing account, check the following link: [https://www.youtube.com/watch?v=NeRYUoR4u0s](https://www.youtube.com/watch?v=NeRYUoR4u0s).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个 GCP 账户**——您可以通过完成以下链接中的步骤，开始使用免费的试用账户：[https://cloud.google.com/free/](https://cloud.google.com/free/)。如果您尚未在
    GCP 账户中设置账单账户，请确保您已正确设置账单信息/个人资料，以便可以不间断地访问和使用 GCP 服务。有关如何创建账单账户的更多信息，请查看以下链接：[https://www.youtube.com/watch?v=NeRYUoR4u0s](https://www.youtube.com/watch?v=NeRYUoR4u0s)。'
- en: Any text editor (such as Notepad++, Visual Studio Code, or Sublime Text) where
    we can temporarily store specific values (for example, your local machine’s IP
    address) used in the hands-on solutions in this chapter.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何文本编辑器（例如 Notepad++、Visual Studio Code 或 Sublime Text），我们可以在其中临时存储本章实践中使用的特定值（例如，您本地计算机的
    IP 地址）。
- en: You may proceed with the next steps once these are ready.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些准备工作完成，您就可以继续进行下一步操作。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Make sure *NOT* to use any existing GCP account with production (or staging)
    environment resources for the hands-on exercises and solutions in this book. It
    is strongly recommended to create a *new* GCP account specifically for launching
    intentionally vulnerable resources. This will ensure that your production (or
    staging) environment resources remain separate and secure. In addition to this,
    make sure to read the available documentation along with the FAQs to have a solid
    understanding of what is free (and what is not free) when creating resources in
    GCP. For more information, see the following link: [https://cloud.google.com/free/docs/free-cloud-features](https://cloud.google.com/free/docs/free-cloud-features).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保*不要*使用任何现有的 GCP 账户，其中有生产（或暂存）环境资源，用于本书中的实践练习和解决方案。强烈建议为启动故意存在漏洞的资源创建一个*新的*
    GCP 账户。这将确保您的生产（或暂存）环境资源保持独立和安全。此外，请确保阅读可用文档和常见问题解答，以便充分了解在 GCP 中创建资源时哪些是免费的（哪些不是免费的）。有关更多信息，请参阅以下链接：[https://cloud.google.com/free/docs/free-cloud-features](https://cloud.google.com/free/docs/free-cloud-features)。
- en: The source code and other files used for each chapter are available in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每章使用的源代码和其他文件可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud)。
- en: Preparing the necessary components and prerequisites
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备必要的组件和前提条件
- en: In this section, we will focus on preparing the prerequisites needed for this
    chapter. We will start by retrieving the IP address of your local machine. We’ll
    use this IP address value later when configuring the firewall rules to allow our
    local machine to access specific resources inside the lab environment. In addition
    to this, we will also set up the Google Cloud project where the cloud resources
    will be deployed in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将重点准备本章所需的前提条件。我们将从获取你本地机器的IP地址开始。稍后在配置防火墙规则时，我们将使用这个IP地址来允许本地机器访问实验环境中的特定资源。此外，我们还将设置Google
    Cloud项目，在本章中将部署云资源。
- en: Lastly, we will generate SSH keys (a **public key** and a **private key**) for
    accessing the attacker VM instance later in this chapter. As we can see in *Figure
    4**.1*, the private key will be stored inside your local machine while the public
    key will be stored inside the attacker VM instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将生成SSH密钥（一个**公钥**和一个**私钥**）以便在本章稍后访问攻击者虚拟机实例。正如我们在*图4.1*中所看到的，私钥将保存在你的本地机器中，而公钥将保存在攻击者虚拟机实例中。
- en: '![](image/B19755_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_01.jpg)'
- en: Figure 4.1 – Generating SSH keys for accessing the attacker VM instance
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 生成SSH密钥以访问攻击者虚拟机实例
- en: With this setup, the server (the attacker VM instance) can confirm the identity
    of the client (your local machine) using the private key without having to transmit
    sensitive credentials. This will then allow us to access the attacker VM instance
    via SSH and establish a secure connection for running commands and managing the
    instance remotely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种设置，服务器（攻击者虚拟机实例）可以使用私钥确认客户端（你的本地机器）的身份，而无需传输敏感的凭据。这样，我们就可以通过SSH访问攻击者虚拟机实例，并建立一个安全的连接，以便远程运行命令和管理实例。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *Figure 4**.1*, we can see the target VM instance along with the other components
    of the penetration testing lab environment. We will dive deeper into how the other
    resources in the lab environment will be configured in the succeeding sections
    of this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.1*中，我们可以看到目标虚拟机实例以及渗透测试实验环境中的其他组件。我们将在本章接下来的章节中深入探讨实验环境中其他资源的配置。
- en: 'That said, we’ll divide this section into three parts, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将把本节分为以下三个部分：
- en: '*Part 1 of 3 – Retrieving the IP address of your* *local machine*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1部分，共3部分 – 获取本地机器的* *IP地址*'
- en: '*Part 2 of 3 – Setting up the Google* *Cloud project*'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2部分，共3部分 – 设置Google* *Cloud项目*'
- en: '*Part 3 of 3 – Generating SSH keys to access the attacker* *VM instance*'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3部分，共3部分 – 生成SSH密钥以访问攻击者* *虚拟机实例*'
- en: With these points in mind, let’s proceed with the preparation of the necessary
    components and prerequisites for this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些要点后，我们将继续准备本章所需的必要组件和前提条件。
- en: Part 1 of 3 – Retrieving the IP address of your local machine
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分，共3部分 – 获取本地机器的IP地址
- en: 'Follow the next steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Take note of your local machine’s IP address using [https://ipinfo.io/ip](https://ipinfo.io/ip),
    [https://ifconfig.io/](https://ifconfig.io/), or other similar websites and online
    tools. Alternatively, you may use Google search to retrieve your local machine’s
    IP address.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[https://ipinfo.io/ip](https://ipinfo.io/ip)、[https://ifconfig.io/](https://ifconfig.io/)或其他类似的网站和在线工具，记下你本地机器的IP地址。你也可以使用Google搜索来获取你本地机器的IP地址。
- en: Store and save your IP address information in a text editor as we will use this
    to allow our local machine to access the attacker VM instance later in this chapter.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的IP地址信息保存在文本编辑器中，因为稍后我们将使用它来允许本地机器访问攻击者虚拟机实例。
- en: Part 2 of 3 – Setting up the Google Cloud project
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分，共3部分 – 设置Google Cloud项目
- en: 'Now, let’s create the Google Cloud project where we will deploy the cloud resources
    in this chapter. Proceed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建Google Cloud项目，在本章中我们将在其中部署云资源。请按以下步骤操作：
- en: 'Navigate to the Google Cloud console by opening the following link in your
    web browser: [https://console.cloud.google.com/](https://console.cloud.google.com/).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开以下链接，进入Google Cloud控制台：[https://console.cloud.google.com/](https://console.cloud.google.com/)。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The **Google Cloud console** is a web interface provided by GCP for managing
    cloud resources. You can think of it as the counterpart of the **AWS Management
    Console** we used in the first few chapters of this book. If you need a quick
    introduction to how to use the Google Cloud console, feel free to watch the following
    6-minute video: [https://www.youtube.com/watch?v=27Pb5g7bEAA](https://www.youtube.com/watch?v=27Pb5g7bEAA).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud 控制台**是 GCP 提供的一个网页界面，用于管理云资源。你可以把它看作是我们在本书前几章中使用的**AWS 管理控制台**的对应工具。如果你需要快速了解如何使用
    Google Cloud 控制台，可以观看以下6分钟的视频：[https://www.youtube.com/watch?v=27Pb5g7bEAA](https://www.youtube.com/watch?v=27Pb5g7bEAA)。'
- en: In the **Google Cloud** console, open the navigation menu (**☰**):![](image/B19755_04_02.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Google Cloud**控制台中，打开导航菜单（**☰**）：![](image/B19755_04_02.jpg)
- en: Figure 4.2 – Navigating to the Create a Project page
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2 – 导航到创建项目页面
- en: Locate and click **Create a project** under **IAM & Admin**, as highlighted
    in *Figure 4**.2*.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**IAM & 管理员**下找到并点击**创建项目**，如*图 4.2*中所示。
- en: In the **Project name** field, specify **secure-network-environments**. Keep
    the value in the **Location** field as it is (**No organization**).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**字段中，指定**secure-network-environments**。保持**位置**字段的值不变（**无组织**）。
- en: Click the **CREATE** button afterward.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**创建**按钮。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Projects** in GCP are used to organize resources into logical groups. Inside
    a project, we can have a set of users who have access to the project resources.
    A project includes the users and the APIs, along with specific configuration settings
    for these APIs. For more information, feel free to check the following link: [https://cloud.google.com/storage/docs/projects](https://cloud.google.com/storage/docs/projects).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 中，**项目**用于将资源组织成逻辑组。在一个项目中，我们可以有一组用户，这些用户可以访问项目资源。一个项目包括用户、API 以及这些 API
    的特定配置设置。有关更多信息，请查阅以下链接：[https://cloud.google.com/storage/docs/projects](https://cloud.google.com/storage/docs/projects)。
- en: Once the project has been successfully created, click the drop-down menu highlighted
    in *Figure 4**.3*:![](image/B19755_04_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目成功创建后，点击*图 4.3*中高亮显示的下拉菜单：![](image/B19755_04_03.jpg)
- en: Figure 4.3 – Opening the Select a project popup
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3 – 打开选择项目弹出窗口
- en: In the **Select a project** popup, select the **secure-network-environments**
    project and then click the **OPEN** button afterward.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**选择项目**弹出窗口中，选择**secure-network-environments**项目，然后点击**打开**按钮。
- en: Locate and click the **Activate Cloud Shell** button, as highlighted in *Figure
    4**.4*:![](image/B19755_04_04.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并点击**激活 Cloud Shell**按钮，如*图 4.4*中所示：![](image/B19755_04_04.jpg)
- en: Figure 4.4 – Activating Cloud Shell
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4 – 启动 Cloud Shell
- en: This should open a terminal where we can run command-line commands.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打开一个终端，我们可以在其中运行命令行命令。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It may take a minute or two for Cloud Shell to be ready.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一两分钟才能使 Cloud Shell 准备就绪。
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell terminal pane. This should open the Cloud Shell editor, similar to
    what we have in *Figure 4**.5*:![](image/B19755_04_05.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于 Cloud Shell 终端窗格右上角的**打开编辑器**按钮。这将打开 Cloud Shell 编辑器，类似于我们在*图 4.5*中看到的样子：![](image/B19755_04_05.jpg)
- en: Figure 4.5 – Cloud Shell editor
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.5 – Cloud Shell 编辑器
- en: If you can’t see a terminal similar to what we have in *Figure 4**.5*, open
    the **Terminal** menu of the Cloud Shell editor and then select **New Terminal**
    from the list of options.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有看到类似*图 4.5*中的终端，可以打开 Cloud Shell 编辑器的**终端**菜单，然后从选项列表中选择**新建终端**。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Google **Cloud Shell** provides a web-based interactive shell environment where
    we can run commands, write scripts, and manage resources when working with cloud
    resources and applications. Since we used **AWS CloudShell** in the previous chapters,
    we should easily adapt to using Google Cloud Shell in this chapter. It is important
    to note that Google Cloud Shell also provides an integrated code editor, allowing
    us to write, edit, and save scripts and configuration files directly within the
    environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Shell**提供了一个基于网页的交互式 shell 环境，供我们在使用云资源和应用程序时运行命令、编写脚本和管理资源。由于我们在前几章中已经使用过**AWS
    CloudShell**，因此我们应该能够很容易地适应本章中使用 Google Cloud Shell。需要注意的是，Google Cloud Shell
    还提供了一个集成的代码编辑器，允许我们在该环境中直接编写、编辑和保存脚本和配置文件。'
- en: 'In the terminal (right after the **$** sign), run the following command to
    list the projects in your GCP account:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（**$**符号后面），运行以下命令以列出你在 GCP 账户中的项目：
- en: '[PRE0]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you see the **Authorize Cloud Shell** popup (similar to what is shown in
    *Figure 4**.6*), make sure to click the **AUTHORIZE** button to allow the **gcloud**
    **command-line interface** (**CLI**) to make API calls for us:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你看到**授权 Cloud Shell**的弹窗（类似于*图 4**.6*所示），请确保点击**授权**按钮，允许**gcloud**命令行界面（**CLI**）为我们进行
    API 调用：
- en: '![](image/B19755_04_06.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_06.jpg)'
- en: Figure 4.6 – Authorize Cloud Shell
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.6 – 授权 Cloud Shell
- en: If this is your first time using the **gcloud** CLI, it is simply a command-line
    tool that helps us create and manage a variety of Google Cloud resources.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用**gcloud** CLI，它只是一个命令行工具，帮助我们创建和管理各种 Google Cloud 资源。
- en: 'Running the preceding command should then give us the following output:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行之前的命令后，应该会得到如下输出：
- en: '[PRE1]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure to take note of the **PROJECT_ID** value as we’ll need this when configuring
    the active project in the next set of steps.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记得记下**PROJECT_ID**值，因为在接下来的步骤中配置活动项目时我们需要这个值。
- en: 'Next, run the following command to check the active project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以检查当前活动项目：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the previous command returned a project ID that does not match the **<PROJECT_ID>**
    value from the previous step, run the following command to configure a new active
    project—this time specifying the **<PROJECT_ID>** value obtained from the previous
    step:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果之前的命令返回的项目 ID 与前一步骤中的**<PROJECT_ID>**值不匹配，请运行以下命令来配置一个新的活动项目—这次使用从前一步骤中获得的**<PROJECT_ID>**值：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Feel free to use the **gcloud config get-value project** command again to verify
    that the previous command succeeded. Note that when the Cloud Shell environment
    restarts, we may have to configure the active project again using **gcloud config
    set project <PROJECT_ID>** so that we’re running commands and creating cloud resources
    inside the correct project.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以再次使用**gcloud config get-value project**命令来验证前面的命令是否成功。请注意，当 Cloud Shell 环境重新启动时，我们可能需要再次使用**gcloud
    config set project <PROJECT_ID>**来配置活动项目，以确保我们在正确的项目中运行命令并创建云资源。
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Make sure *NOT* to use the project name (that is, **secure-network-environments**)
    for the **<PROJECT_ID>** value when using the **gcloud config set project** command.
    Specifying the incorrect **<PROJECT_ID>** value will yield the following warning
    message: **You do not appear to have access to project [secure-network-environments]
    or it does** **not exist.**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保*不要*使用项目名称（即**secure-network-environments**）作为**<PROJECT_ID>**值，特别是在使用**gcloud
    config set project**命令时。指定错误的**<PROJECT_ID>**值将会返回以下警告信息：**您似乎没有访问项目 [secure-network-environments]
    的权限，或者该项目不存在。**
- en: Using the search bar, navigate to the **VPC networks** page using the **vpc
    networks** search query.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用搜索框，使用**vpc networks**搜索查询导航到**VPC 网络**页面。
- en: If the Compute Engine API is not enabled yet, you will be redirected to the
    Compute Engine API page, similar to what is shown in *Figure 4**.7*:![](image/B19755_04_07.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有启用 Compute Engine API，你将被重定向到 Compute Engine API 页面，类似于*图 4**.7*所示的内容：![](image/B19755_04_07.jpg)
- en: Figure 4.7 – Enabling the Compute Engine API
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.7 – 启用 Compute Engine API
- en: Click the **ENABLE** button to proceed. Wait for about 3-5 minutes for the Compute
    Engine API to be enabled. Note that this step is necessary to ensure that you
    have access to Compute Engine services and functionalities within your project.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**启用**按钮继续。等待大约 3-5 分钟，直到 Compute Engine API 启用。请注意，这一步骤是必要的，以确保你可以在项目中访问
    Compute Engine 服务和功能。
- en: Part 3 of 3 – Generating SSH keys to access the attacker VM instance
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分，共 3 部分 – 生成 SSH 密钥以访问攻击者虚拟机实例
- en: 'Now, let’s generate SSH keys for accessing the attacker VM instance (which
    we’ll set up later in this chapter). Follow the next steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为访问攻击者虚拟机实例生成 SSH 密钥（我们将在本章后面进行设置）。按照以下步骤操作：
- en: Continuing where we left off in the previous part, let’s open a new **Cloud
    Shell** terminal (or reuse an existing one). Make sure that we are using **secure-network-environments**
    as the active project configured before proceeding.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续上一个部分的内容时，让我们打开一个新的**Cloud Shell**终端（或重新使用现有的）。确保我们使用的是之前配置的**secure-network-environments**作为活动项目。
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a new directory (named **kali_keys**) and navigate to it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中（**$**符号后），运行以下命令以创建一个新目录（命名为**kali_keys**）并进入该目录：
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will store the generated keys inside this directory.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将把生成的密钥存储在这个目录中。
- en: 'Generate a new SSH key pair and save the generated key files in the **kali_keys**
    directory:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成新的 SSH 密钥对并将生成的密钥文件保存在**kali_keys**目录中：
- en: '[PRE5]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When asked for a passphrase, just press *Enter* as we won’t add a passphrase
    to our key (the same goes for the password confirmation). This will generate two
    files—**kali-ssh** (the private key) and **kali-ssh.pub** (the public key).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当系统询问输入密码短语时，直接按*Enter*键即可，因为我们不会为密钥添加密码短语（密码确认也是如此）。这将生成两个文件——**kali-ssh**（私钥）和**kali-ssh.pub**（公钥）。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*How do these SSH key files work?* SSH key files consist of a **private key**
    (stored and kept on the client’s machine) and a corresponding **public key** uploaded
    to the remote server. During authentication, the client uses its private key to
    generate a digital signature, and the server verifies it using the corresponding
    public key. Here, the server can confirm the client’s identity based on the possession
    of the private key without having to transmit sensitive credentials.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些 SSH 密钥文件是如何工作的？* SSH 密钥文件由**私钥**（保存在客户端机器上）和相应的**公钥**（上传到远程服务器）组成。在身份验证过程中，客户端使用其私钥生成数字签名，服务器则使用相应的公钥进行验证。在这里，服务器可以通过确认客户端持有私钥来验证其身份，而不需要传输敏感的凭证。'
- en: 'Print the public key value using the **cat** command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**cat**命令打印公钥值：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Store this value in a text editor on your local machine as we will use this
    later in the *Manually setting up the attacker VM instance* section of this chapter.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此值保存在本地机器上的文本编辑器中，因为我们稍后将在本章的*手动设置攻击者虚拟机实例*部分中使用它。
- en: Click the **Open Editor** button (in case the editor is not yet open).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开编辑器**按钮（如果编辑器尚未打开）。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It may take a minute or two for the **Cloud Shell editor** to load.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载**Cloud Shell 编辑器**可能需要一两分钟的时间。
- en: Locate the generated private key (**kali-ssh**) in the file tree of the editor
    (similar to what is shown in *Figure 4**.8*):![](image/B19755_04_08.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器的文件树中找到生成的私钥（**kali-ssh**）（类似于*图 4.8*所示）：![](image/B19755_04_08.jpg)
- en: Figure 4.8 – Downloading the generated private key file
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.8 – 下载生成的私钥文件
- en: Right-click on the file and then select **Download** from the options in the
    context menu. Feel free to perform the same set of steps for the public key (**kali-ssh.pub**)
    to download it to your local machine.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键单击文件，然后从上下文菜单中的选项中选择**下载**。你也可以对公钥（**kali-ssh.pub**）执行相同的步骤，将其下载到本地机器。
- en: Now that we have the prerequisites ready, we can now proceed with setting up
    and defining the project structure!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了先决条件，可以继续进行项目结构的设置和定义！
- en: Defining the project structure
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义项目结构
- en: In this chapter, we will introduce the usage of Terraform **modules** to help
    define and organize our **Infrastructure-as-Code** (**IaC**) project structure.
    Modules allow us to encapsulate and reuse sets of resources to make our Terraform
    code more modular, maintainable, and scalable. By leveraging modules, we will
    be able to simplify the management of complex infrastructure deployments and abstract
    common configurations into reusable components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 Terraform **模块**来帮助定义和组织我们的**基础设施即代码**（**IaC**）项目结构。模块使我们能够封装并重用一组资源，使得我们的
    Terraform 代码更加模块化、可维护和可扩展。通过利用模块，我们将能够简化复杂基础设施部署的管理，并将常见配置抽象为可重用的组件。
- en: 'In *[Chapter 3](B19755_03.xhtml)*, *Succeeding with Infrastructure as Code
    Tools and Strategies*, we stored all our **.tf** files in a single directory.
    *It feels a bit messy, right?* In case you are wondering how modules change how
    we organize our code and our files, here’s an example of what the project structure
    might look like once we utilize Terraform modules:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*[第3章](B19755_03.xhtml)*，*成功使用基础设施即代码工具和策略*中，我们将所有的**.tf**文件存储在一个目录中。*感觉有点凌乱，对吧？*
    如果你想知道模块如何改变我们组织代码和文件的方式，下面是使用 Terraform 模块后，项目结构可能的样子：
- en: '![](image/B19755_04_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_09.jpg)'
- en: Figure 4.9 – Sample file and folder structure using Terraform modules
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 使用 Terraform 模块的示例文件和文件夹结构
- en: 'We have in *Figure 4**.9* a sample file and folder structure (left) along with
    how module directories are loaded in the **main.tf** file of the root module (right).
    Here, the **root_module** directory serves as the main entry point for the Terraform
    configuration. Directories such as **module1** and **module2** inside the project
    root directory will contain Terraform files such as **main.tf**, **variables.tf**,
    and **outputs.tf** specific to those modules. The modules are then defined in
    the **main.tf** file of the root module using the **module** block, similar to
    what we have in the following block of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.9*中，我们展示了一个示例的文件和文件夹结构（左侧），以及模块目录如何在根模块的 **main.tf** 文件中加载（右侧）。这里，**root_module**
    目录是 Terraform 配置的主要入口点。项目根目录中的 **module1** 和 **module2** 等目录将包含针对这些模块的 Terraform
    文件，如 **main.tf**、**variables.tf** 和 **outputs.tf**。然后，这些模块将在根模块的 **main.tf** 文件中通过
    **module** 块进行定义，就像我们在以下代码块中看到的那样：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that while it is common practice to have a separate directory named **modules**
    to store individual module directories such as **module1**, **module2**, and **module3**,
    we will follow the current project and folder structure shown in *Figure 4**.9*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然通常会有一个单独的目录叫做 **modules** 来存储各个模块目录，比如 **module1**、**module2** 和 **module3**，但我们会遵循当前项目和文件夹结构，如*图
    4.9*所示。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that the **module1**, **module2**, and **module3** directory
    names used in our example are arbitrary and can be renamed according to the user’s
    preference. For instance, alternative names such as **secure_network**, **attacker_vm**,
    and **target_vm** can be used to provide more descriptive and meaningful names
    for the modules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们示例中使用的 **module1**、**module2** 和 **module3** 目录名称是任意的，可以根据用户的偏好进行重命名。例如，可以使用
    **secure_network**、**attacker_vm** 和 **target_vm** 等替代名称，为模块提供更具描述性和意义的名称。
- en: 'The organization and modularization of the IaC configuration files are influenced
    by the overall design of the penetration testing lab environment along with how
    the resources are grouped together. It is crucial that we discuss (at a high level
    for now) what our lab environment will look like in this section. Have a look
    at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IaC 配置文件的组织和模块化受渗透测试实验环境整体设计的影响，同时也受到资源分组方式的影响。在这一部分，我们需要简要讨论（至少从高层次来看）我们的实验环境将是什么样子。请看以下示意图：
- en: '![](image/B19755_04_10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_10.jpg)'
- en: Figure 4.10 – High-level diagram of our penetration testing lab environment
    in GCP
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 我们在 GCP 中渗透测试实验环境的高层次示意图
- en: 'In *Figure 4**.10*, we have two VPC networks: **VPC 01** and **VPC 02**. If
    you are wondering what VPC networks are, these are simply isolated virtual networks
    within a cloud computing environment that allow us to securely separate and manage
    resources. *That being said, which resources are we planning to have inside these
    networks?* Inside **VPC 01**, we’ll have the target VM instance. On the other
    hand, we’ll have the attacker VM instance inside **VPC 02**. One way to group
    these resources together is by using the following groups:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.10*中，我们有两个 VPC 网络：**VPC 01** 和 **VPC 02**。如果你想知道什么是 VPC 网络，它们其实就是云计算环境中的隔离虚拟网络，用于安全地分离和管理资源。*话虽如此，我们计划在这些网络中放入哪些资源呢？*
    在 **VPC 01** 中，我们将放置目标虚拟机实例。而在 **VPC 02** 中，我们将放置攻击者虚拟机实例。将这些资源分组的一种方式是使用以下组别：
- en: '**Group 1**—**VPC 01** and the target VM instance'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 组**—**VPC 01** 和目标虚拟机实例'
- en: '**Group 2**—**VPC 02** and the attacker VM instance'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 组**—**VPC 02** 和攻击者虚拟机实例'
- en: We should take into consideration the possible limitations of this approach.
    Grouping **VPC 01** and the target VM instance together may restrict the flexibility
    and scalability of the network environment (from a modularization standpoint).
    If we want to add more target VM instances in the future, we will need to modify
    the existing group and potentially cause the first group to have too many resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑这种方法可能的局限性。将 **VPC 01** 和目标虚拟机实例放在一起，可能会限制网络环境的灵活性和可扩展性（从模块化的角度来看）。如果我们将来需要增加更多的目标虚拟机实例，就需要修改现有的分组，可能会导致第一个组拥有过多的资源。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with VPCs and VM instances, do not worry as we will discuss
    these in more detail in the upcoming section of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 VPC 和虚拟机实例，别担心，我们将在本章接下来的部分详细讨论这些内容。
- en: 'Alternatively, another option involves creating three distinct modules, as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一种选择是创建三个不同的模块，如下所示：
- en: The **secure_network** module—Network resources such as **VPC 01** and **VPC
    02**, along with other relevant resources grouped together
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**secure_network** 模块—网络资源，如 **VPC 01** 和 **VPC 02**，以及其他相关资源的组合'
- en: The **target_vm** module—The target VM instance
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target_vm** 模块—目标虚拟机实例'
- en: The **attacker_vm** module—The attacker VM instance
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**attacker_vm** 模块—攻击者虚拟机实例'
- en: This alternative appears to be a more favorable choice as it leans toward the
    preparation of a reusable network environment module that can be easily utilized
    for various iterations of our penetration testing lab environments in GCP. In
    addition to this, it provides the flexibility to swap out the target VM instance
    module with one or more alternative vulnerable-by-design target modules. While
    this approach is not perfect, this should do the trick for now as it offers significant
    advantages in terms of scalability, modularity, and adaptability for building
    dynamic penetration testing lab environments in GCP.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替代方案似乎是一个更合适的选择，因为它倾向于准备一个可重用的网络环境模块，可以轻松地用于我们在 GCP 上的渗透测试实验室环境的多个迭代。此外，它还提供了灵活性，可以将目标虚拟机实例模块替换为一个或多个易受攻击的设计目标模块。尽管这种方法并不完美，但它目前应能满足需求，因为它在可扩展性、模块化和适应性方面提供了显著的优势，适合在
    GCP 上构建动态渗透测试实验室环境。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the overview of our penetration testing lab environment in this section feels
    a bit vague and lacking in detail, do not worry – we will have a more comprehensive
    discussion as we go through each of the succeeding sections in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一节中关于我们渗透测试实验室环境的概述感觉有些模糊，缺乏细节，不必担心——我们将在接下来的每一节中进行更全面的讨论。
- en: 'Now, let’s proceed with setting up the initial project files and directories:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续设置初始的项目文件和目录：
- en: Continuing where we left off in the previous section, let’s make sure that we
    have a terminal ready where we’ll run the commands:![](image/B19755_04_11.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节中我们已经开始了，确保我们有一个终端可以运行命令：![](image/B19755_04_11.jpg)
- en: Figure 4.11 – Opening a new terminal
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.11 – 打开新终端
- en: Open the **Terminal** menu of the Cloud Shell editor (as highlighted in *Figure
    4**.11*). Select **New Terminal** from the list of options available.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 Cloud Shell 编辑器的 **Terminal** 菜单（如 *图 4.11* 中所示）。从可用选项中选择 **New Terminal**。
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a **pentest_lab** project directory (and navigate to the new directory
    as well):'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中（**$** 符号后），运行以下命令来创建一个 **pentest_lab** 项目目录（并切换到新目录）：
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the **pentest_lab** directory, let’s also create **secure_network**,
    **target_vm**, and **attacker_vm** directories, like so:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **pentest_lab** 目录下，我们还需要创建 **secure_network**、**target_vm** 和 **attacker_vm**
    目录，如下所示：
- en: '[PRE9]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll store the corresponding module files later in these directories.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后将在这些目录中存储相应的模块文件。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While it is common practice to have a separate directory named **modules** to
    store individual module directories such as **secure_network**, **target_vm**,
    and **attacker_vm**, our current project and folder structure should suffice for
    now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常会有一个名为 **modules** 的独立目录来存储像 **secure_network**、**target_vm** 和 **attacker_vm**
    这样的单独模块目录，但我们当前的项目和文件夹结构应该足够使用。
- en: 'Let’s create the files we’ll have in the root folder of our project:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建项目根目录中的文件：
- en: '[PRE10]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that at this point, these files are still empty. We will populate them
    with the necessary configurations as we go along. This is what our project structure
    currently looks like:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此时这些文件仍然是空的。我们将在后续过程中逐步添加必要的配置。以下是我们当前项目的结构：
- en: '![](image/B19755_04_12.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_12.jpg)'
- en: Figure 4.12 – What our current project structure looks like in the file tree
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.12 – 我们当前项目在文件树中的结构
- en: At this point, we have three empty directories (**attacker_vm**, **secure_network**,
    and **target_vm**) along with six empty files (**main.tf**, **outputs.tf**, **provider.tf**,
    **terraform.tfvars**, **variables.tf**, and **versions.tf**) inside the **pentest_lab**
    directory.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，我们在 **pentest_lab** 目录下有三个空目录（**attacker_vm**、**secure_network** 和 **target_vm**），以及六个空文件（**main.tf**、**outputs.tf**、**provider.tf**、**terraform.tfvars**、**variables.tf**
    和 **versions.tf**）。
- en: 'By locating the file in the file tree (left of the editor), open the **provider.tf**
    file in the editor and add the following block of code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在文件树（编辑器左侧）中定位文件，打开 **provider.tf** 文件并在编辑器中添加以下代码块：
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are configuring the Google provider, specifying the region as **us-central1**
    and the zone as **us-central1-c**. This provider configuration ensures that the
    resources we deploy with Terraform will be provisioned within the specified region
    and zone in GCP. With this in mind, make sure to save any modifications made to
    the **provider.tf** file before moving on to the next step.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在配置Google提供程序，将区域指定为**us-central1**，区域为**us-central1-c**。此提供程序配置确保我们通过Terraform部署的资源将在GCP中指定的区域和可用区内进行配置。考虑到这一点，在继续下一步之前，确保保存对**provider.tf**文件所做的任何修改。
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the next set of steps, we will be updating and adding code to multiple files
    inside the **~/pentest_lab** directory. Make sure that any changes made to each
    of the files are saved so that we don’t encounter unexpected errors when running
    the **terraform** commands.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将在**~/pentest_lab**目录中的多个文件中更新并添加代码。确保保存对每个文件所做的任何更改，以便在运行**terraform**命令时不会遇到意外错误。
- en: 'Next, let’s open **versions.tf** in the editor. Let’s add the following block
    of code to specify the required version constraints for the providers used:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开**versions.tf**文件。我们将添加以下代码块来指定所使用提供程序的版本约束：
- en: '[PRE12]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re specifying the source and version for the random and Google Cloud
    providers. *Why is this necessary?* This ensures that the correct versions of
    the providers are used to maintain compatibility and consistency while using Terraform.
    That said, make sure to save any modifications made to the **versions.tf** file
    before moving on to the next step.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们为随机和Google Cloud提供程序指定了源和版本。*为什么需要这样做？* 这样可以确保使用正确版本的提供程序，以保持在使用Terraform时的兼容性和一致性。话虽如此，确保在继续下一步之前保存对**versions.tf**文件所做的任何修改。
- en: 'Open **variables.tf** in the editor and add the following blocks of code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**variables.tf**文件，并添加以下代码块：
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are defining two variables—**my_ip** and **my_public_ssh_key**. Note
    that we won’t be specifying default values this time since we’ll be using the
    **terraform.tfvars** file to store the variable values instead. Make sure to save
    any modifications made to the **variables.tf** file before moving on to the next
    step.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个变量——**my_ip**和**my_public_ssh_key**。请注意，这次我们不会指定默认值，因为我们将使用**terraform.tfvars**文件来存储变量值。确保在继续下一步之前保存对**variables.tf**文件所做的任何修改。
- en: 'Open **terraform.tfvars** in the editor and add the following lines of code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**terraform.tfvars**文件，并添加以下代码行：
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Make sure to replace **<IP ADDRESS OF YOUR LOCAL MACHINE>** with the current
    IP address value of the laptop or desktop you are using. In addition to this,
    make sure to replace **<PUBLIC SSH KEY>** with the public key string value (after
    running **cat kali-ssh.pub** in an earlier step). Note that the value of **<PUBLIC
    SSH KEY>** should follow a format resembling **ssh-rsa ... kali**. Do not forget
    to save the **terraform.tfvars** file before proceeding to the next step.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<IP ADDRESS OF YOUR LOCAL MACHINE>**替换为你正在使用的笔记本或台式计算机的当前IP地址值。此外，确保将**<PUBLIC
    SSH KEY>**替换为公钥字符串值（在之前的步骤中运行**cat kali-ssh.pub**后获得）。请注意，**<PUBLIC SSH KEY>**的值应遵循类似**ssh-rsa
    ... kali**的格式。在继续下一步之前，不要忘记保存**terraform.tfvars**文件。
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you might be wondering what this file is used for! The **terraform.tfvars**
    file is used to store input variable values in a Terraform project. It provides
    a convenient way to manage and customize the properties of the infrastructure
    without having to modify the configuration code. In addition to this, the values
    stored in the **terraform.tfvars** file are automatically loaded when using the
    **terraform** **apply** command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想，这个文件是用来做什么的！**terraform.tfvars**文件用于在Terraform项目中存储输入变量值。它提供了一种便捷的方式来管理和自定义基础设施的属性，而无需修改配置代码。除此之外，存储在**terraform.tfvars**文件中的值在使用**terraform**
    **apply**命令时会自动加载。
- en: 'Open **main.tf** in the editor and add the following blocks of code to define
    the modules that will be used for this project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**main.tf**文件，并添加以下代码块来定义将用于该项目的模块：
- en: '[PRE15]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are adding module blocks in **main.tf** to include the **secure_network**,
    **attacker_vm**, and **target_vm** modules from their respective source directories.
    Make sure to save the **main.tf** file before proceeding to the next step.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们在**main.tf**中添加了模块块，以从各自的源目录中包含**secure_network**、**attacker_vm**和**target_vm**模块。确保在继续下一步之前保存**main.tf**文件。
- en: 'In the terminal (right after the **$** sign), let’s run the **terraform init**
    command to initialize the Terraform working directory:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中（在**$**符号后面），运行**terraform init**命令以初始化Terraform工作目录：
- en: '[PRE16]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should return the following output:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE17]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you are inside the **~/pentest_lab** directory before running
    the **terraform init** command (and the other **terraform** commands in the next
    set of steps).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在运行**terraform init**命令之前，已经位于**~/pentest_lab**目录中（以及接下来步骤中的其他**terraform**命令）。
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行**terraform plan**命令之前，让我们运行**terraform fmt**来格式化我们的Terraform代码：
- en: '[PRE18]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are using the **terraform fmt** command to ensure a consistent coding
    style across all Terraform configuration files. This command will scan the Terraform
    configuration files and adjust the indentation, spacing, and line breaks automatically
    to match the official Terraform style guide.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用**terraform fmt**命令来确保所有Terraform配置文件中的编码风格一致。该命令将扫描Terraform配置文件，并自动调整缩进、空格和换行，以符合官方的Terraform风格指南。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While this step is optional, it is highly recommended to use the **terraform
    fmt** command as part of your development workflow to maintain a clean and consistent
    coding style.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一步是可选的，但强烈建议将**terraform fmt**命令作为开发工作流的一部分，以保持干净且一致的编码风格。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行**terraform plan**以预览Terraform将执行的更改：
- en: '[PRE19]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should return the following output:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE20]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command should complete without any errors. Otherwise, make sure to review
    and fix any issues before proceeding.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令应无错误完成。否则，请确保在继续之前检查并修复任何问题。
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**terraform apply**命令来实现这些更改：
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should yield the following output:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Given that we have not yet defined and configured any cloud resource in our
    configuration code, this is the result that we’re expecting! That said, if the
    **terraform apply** command runs without any errors, we are ready to proceed to
    the next section.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鉴于我们尚未在配置代码中定义和配置任何云资源，这是我们期望的结果！也就是说，如果**terraform apply**命令运行无误，我们可以继续进入下一部分。
- en: With our project structure and skeleton ready, we can now proceed with setting
    up the isolated VPC network environment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目结构和骨架准备好后，我们可以继续设置隔离的VPC网络环境。
- en: Preparing the isolated network
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备隔离的网络
- en: 'Having a solid understanding of the compute and networking services in GCP
    is essential for designing and implementing secure network environments where
    penetration testing lab resources are deployed. That said, before we dive deep
    into the secure network design, let’s quickly go through some of the resources,
    concepts, features, and components we will work with in this chapter, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解GCP中的计算和网络服务对于设计和实现安全的网络环境至关重要，尤其是在进行渗透测试实验室资源部署时。话虽如此，在我们深入研究安全网络设计之前，先快速浏览一下本章中我们将使用的一些资源、概念、功能和组件，如下所示：
- en: '**VPC**—A VPC is a virtual network within a cloud computing environment that
    allows us to securely separate and manage resources. With VPCs, we can design
    and customize our own custom network architectures to meet specific requirements
    as well as enable secure communication between the resources deployed within the
    VPC. Inside a VPC, we can have **subnetworks** (**subnets**) that allow for further
    segmentation and isolation of resources within the larger VPC network. Subnets
    enable us to group resources together based on different considerations and requirements.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VPC**——VPC是云计算环境中的一个虚拟网络，它使我们能够安全地分隔和管理资源。通过VPC，我们可以设计和定制自己的网络架构，以满足特定需求，并启用VPC内部资源之间的安全通信。在VPC内部，我们可以拥有**子网**（**subnets**），它们允许进一步细分和隔离VPC网络中的资源。子网使我们能够根据不同的考虑和需求将资源分组。'
- en: 'Have a look at the following diagram:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看一下以下图示：
- en: '![](image/B19755_04_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_13.jpg)'
- en: Figure 4.13 – Simplified network diagram
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 - 简化的网络图
- en: In *Figure 4**.13*, we have a *simplified* network diagram with two VPC networks.
    Each of these VPCs has two subnets. Inside these subnets, we can have various
    resources such as VMs and other cloud resources. If this is your first time dealing
    with these concepts, you can think of a VPC network as a country and subnets as
    cities within a country. Similar to how a country establishes its own rules and
    borders, a VPC network creates a controlled environment (inside a cloud account)
    to securely manage resources. Just as cities within a country have their own distinct
    characteristics, subnets within a VPC network act as isolated zones that segregate
    various types of resources inside the larger VPC network.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.13*中，我们展示了一个包含两个VPC网络的*简化*网络图。每个VPC都有两个子网。在这些子网内，我们可以拥有各种资源，如虚拟机和其他云资源。如果这是你第一次接触这些概念，你可以把VPC网络想象成一个国家，而子网则是国家内的城市。就像一个国家制定自己的规则和边界一样，VPC网络创建了一个受控的环境（在云账户内）来安全地管理资源。就像国家内的城市各具特点一样，VPC网络中的子网作为隔离区域，将不同类型的资源分隔在更大的VPC网络内部。
- en: Important note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is important to note that we didn’t include projects or zones, along with
    other typical network components, in our simplified network diagram to focus instead
    on the key elements of networks that are relevant to our discussion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们没有在简化的网络图中包括项目或区域以及其他典型的网络组件，而是专注于与我们讨论相关的网络关键元素。
- en: '**Firewall rules**—Firewall rules are security rules that dictate how traffic
    is allowed or denied within a network. By setting up firewall rules, we can define
    the allowed (or blocked) communication paths and prevent unauthorized access and
    potential threats from reaching resources inside the network. Similar to how traffic
    police maintain order on city streets, firewall rules regulate the flow of data
    and help establish secure communication between various components in our cloud
    infrastructure.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防火墙规则**—防火墙规则是定义网络中允许或拒绝流量的安全规则。通过设置防火墙规则，我们可以定义允许（或阻止）的通信路径，并防止未授权的访问和潜在威胁到达网络内部的资源。就像交通警察维持城市街道的秩序一样，防火墙规则调控数据流，并帮助在我们云基础设施中的各种组件之间建立安全的通信。'
- en: '**VPC peering**—VPC peering is a networking capability that enables secure
    and private communication between two VPC networks as if they were part of the
    same network.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VPC对等连接**—VPC对等连接是一种网络功能，使得两个VPC网络之间能够像属于同一个网络一样进行安全和私密的通信。'
- en: 'Now, have a look at the following diagram:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，看看以下图示：
- en: '![](image/B19755_04_14.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_14.jpg)'
- en: Figure 4.14 – Simplified network diagram
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 简化网络图
- en: In *Figure 4**.14*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. With VPC peering, traffic from resources deployed
    in the subnet of the first VPC network would be able to reach resources deployed
    in the subnet of the second VPC network (and vice versa) as long as the necessary
    firewall rules have been configured correctly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.14*中，我们展示了一个简化的网络图，图中有两个通过VPC对等连接连接的VPC网络。通过VPC对等连接，第一VPC网络子网中部署的资源的流量可以到达第二VPC网络子网中部署的资源（反之亦然），只要防火墙规则已正确配置。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using VPC peering to connect VPC networks, it is important to note that
    IP address ranges used in peered VPC networks must not overlap to prevent routing
    conflicts. For instance, if VPC A has an IP address range of **10.0.0.0/16** and
    VPC B has an IP address range of **192.168.0.0/16**, then we should have a successful
    VPC peering connection since these ranges do not overlap. However, if both VPC
    A and VPC B have IP address ranges of **10.0.0.0/16**, then there would be an
    overlap that would result in routing conflicts and prevent the establishment of
    a VPC peering connection. In addition to this, VPC peering connections in GCP
    are unidirectional since each peering connection must be configured separately
    in each VPC network. This allows traffic to flow from one VPC network to another,
    but not in the reverse direction unless a reciprocal peering connection is established.
    Finally, VPC peering is non-transitive—meaning that peering connections do not
    extend to other VPC networks beyond immediate peers. If connectivity is required
    between multiple VPC networks, separate peering connections need to be established.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VPC 对等连接连接 VPC 网络时，需要注意，对等的 VPC 网络中使用的 IP 地址范围不能重叠，以避免路由冲突。例如，如果 VPC A 的
    IP 地址范围是 **10.0.0.0/16**，而 VPC B 的 IP 地址范围是 **192.168.0.0/16**，那么我们应该能够成功建立 VPC
    对等连接，因为这些范围不重叠。然而，如果 VPC A 和 VPC B 都有 **10.0.0.0/16** 的 IP 地址范围，那么会发生重叠，从而导致路由冲突，无法建立
    VPC 对等连接。此外，GCP 中的 VPC 对等连接是单向的，因为每个对等连接必须在每个 VPC 网络中单独配置。这允许流量从一个 VPC 网络流向另一个网络，但除非建立了互惠的对等连接，否则不能反向流动。最后，VPC
    对等连接是非传递的——这意味着对等连接不会扩展到其他超出直接对等的 VPC 网络。如果需要多个 VPC 网络之间的连接，则需要建立单独的对等连接。
- en: '**VM instance**—A VM instance refers to a virtualized computer system that
    runs within a cloud environment that enables users to deploy and run applications
    and services in a virtualized environment. A VM instance generally includes an
    operating system along with allocated computing resources such as CPU and memory,
    as well as storage capacity.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机实例**—虚拟机实例是指在云环境中运行的虚拟化计算机系统，允许用户在虚拟化环境中部署和运行应用程序及服务。虚拟机实例通常包括操作系统，以及分配的计算资源，如
    CPU 和内存，以及存储容量。'
- en: '**Private IP address**—A private IP address is an IP address assigned to a
    resource in a VPC that is used for internal communication between resources within
    the VPC. It’s important to note that the private IP address of a resource would
    fall within the range of available addresses designated for the specific subnet
    where the resource is launched.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有 IP 地址**—私有 IP 地址是分配给 VPC 中资源的 IP 地址，用于 VPC 内部资源之间的通信。需要注意的是，资源的私有 IP 地址会落在为该资源所在子网指定的可用地址范围内。'
- en: '**Public IP address**—A public IP address is an IP address assigned to a resource
    in a VPC that allows resources to be reachable from outside the VPC network. If
    a resource does not have a public IP address, it means that the resource is only
    accessible within the private network of the VPC and cannot be reached directly
    from the public internet.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公网 IP 地址**—公网 IP 地址是分配给 VPC 中资源的 IP 地址，允许这些资源从 VPC 网络外部访问。如果资源没有公网 IP 地址，则意味着该资源仅在
    VPC 的私有网络内可访问，无法从公共互联网直接访问。'
- en: '**Serial console**—The serial console is a capability (or feature) that provides
    direct access to the CLI of a VM instance. It allows us to troubleshoot and configure
    the operating system of the VM instance even when the VM’s network connectivity
    is unreliable or unavailable.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行控制台**—串行控制台是一项功能（或特性），提供直接访问虚拟机实例 CLI 的能力。即使虚拟机的网络连接不可靠或不可用，它也允许我们进行故障排除和配置虚拟机操作系统。'
- en: There are multiple ways to establish a secure network environment setup in GCP
    that restricts traffic from external hosts from reaching cloud resources deployed
    inside the network environment. By configuring strict firewall rules, implementing
    network segmentation, and leveraging relevant VPC features and configurations,
    we can prevent unauthorized external access to the internal network environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCP 中，有多种方法可以建立一个安全的网络环境设置，限制外部主机流量到达内部部署的云资源。通过配置严格的防火墙规则、实施网络分段并利用相关的 VPC
    特性和配置，我们可以防止未经授权的外部访问内部网络环境。
- en: 'In this chapter, we will focus on one of the various solutions that satisfy
    the following constraints and requirements:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讨论满足以下约束和要求的解决方案之一：
- en: Attacker resources (for example, a Kali Linux VM instance) should be deployed
    and grouped within a dedicated VPC network. Similarly, target resources (for example,
    vulnerable-by-design applications and resources) should be deployed and grouped
    within a separate VPC network.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者资源（例如Kali Linux虚拟机实例）应该在一个专用的VPC网络中进行部署和分组。同样，目标资源（例如设计脆弱的应用程序和资源）应在一个单独的VPC网络中进行部署和分组。
- en: Traffic originating from attacker resources should reach the target resources
    without issues even if these resources are deployed in a different VPC.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自攻击者资源的流量应该能够顺利到达目标资源，即使这些资源部署在不同的VPC中。
- en: Serial console access should be enabled to allow direct access to both the attacker
    and target VM resources.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应启用串行控制台访问，以允许直接访问攻击者和目标虚拟机资源。
- en: Since we will configure the attacker VM instance to establish SSH connections
    and SSH tunnels with your machine, we will restrict port **22** of the attacker
    VM instance to only allow access from your local machine. Similarly, since we
    will configure the attacker VM instance with browser-based access to its desktop
    environment, we will restrict port **8081** of the attacker VM instance to only
    allow access from your local machine.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将配置攻击者虚拟机实例，以便与您的机器建立SSH连接和SSH隧道，我们将限制攻击者虚拟机实例的端口**22**，仅允许来自您的本地机器的访问。同样，考虑到我们将配置攻击者虚拟机实例以通过浏览器访问其桌面环境，我们将限制攻击者虚拟机实例的端口**8081**，仅允许来自您的本地机器的访问。
- en: 'Given these constraints and requirements, what should our network environment
    look like? The following diagram gives us an overview:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些约束和要求，我们的网络环境应该是什么样的呢？下图为我们提供了一个概览：
- en: '![](image/B19755_04_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_15.jpg)'
- en: Figure 4.15 – High-level architecture diagram of our penetration testing lab
    environment
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 我们渗透测试实验环境的高级架构图
- en: In *Figure 4**.15*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. Here, traffic from the attacker VM instance deployed
    in **VPC 02** would be able to reach the target VM instance deployed in **VPC
    01** (and vice versa). With the correct project configuration, we should be able
    to use the serial console to connect to the attacker and target VM instances.
    The firewall rules configured should allow our local machines to access the attacker
    VM instance via port **22** and port **8081**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.15*中，我们有一个简化的网络图，其中两个VPC网络通过VPC对等连接。这里，部署在**VPC 02**中的攻击者虚拟机实例能够访问部署在**VPC
    01**中的目标虚拟机实例（反之亦然）。在正确的项目配置下，我们应该能够使用串行控制台连接到攻击者和目标虚拟机实例。配置的防火墙规则应允许我们的本地机器通过端口**22**和端口**8081**访问攻击者虚拟机实例。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: It is worth mentioning that the architecture we discussed is just one of the
    potential solutions. That said, several alternative approaches can meet the requirements
    and specified constraints.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们讨论的架构只是多种潜在解决方案中的一种。也就是说，还有多种替代方法可以满足要求和指定的约束。
- en: In addition to blocking external inbound traffic, the VPC networks in *Figure
    4**.15* may be configured to block outbound traffic to resources outside of the
    peered networks as well. While this is possible, it prevents the VM instances
    and other resources within the VPC networks from accessing resources outside of
    the peered networks. This means that these resources won’t be able to access external
    repositories for downloading updates and packages, which could impact the setup
    process. In this chapter, we will configure the VPC networks to allow outbound
    traffic (that is, the instances inside the peered VPCs should be able to access
    resources outside the overall network). However, after you have completed the
    chapter, feel free to explore the alternative approach of blocking outbound traffic
    for a more restricted network environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阻止外部入站流量外，*图 4.15*中的VPC网络还可以配置为阻止向对等网络外部资源的出站流量。虽然这是可能的，但这会阻止VPC网络中的虚拟机实例和其他资源访问对等网络外部的资源。这意味着这些资源无法访问外部仓库以下载更新和包，这可能会影响设置过程。在本章中，我们将配置VPC网络以允许出站流量（即，对等VPC中的实例应该能够访问外部网络资源）。然而，在完成本章后，您可以自由探索阻止出站流量的替代方法，以便实现更受限的网络环境。
- en: 'With these points in mind, let’s proceed with preparing the network environment,
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些要点，我们将继续准备网络环境，如下所示：
- en: 'In the Cloud Shell terminal (right after the **$** sign), run the following
    commands (one line at a time) to navigate to the **~/****pentest_lab/secure_network**
    directory:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cloud Shell终端（**$**符号后面）中，运行以下命令（每次一行）以导航到**~/pentest_lab/secure_network**目录：
- en: '[PRE23]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, run the following commands to create the files we will need in our **secure_network**
    module:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令来创建我们在**secure_network**模块中需要的文件：
- en: '[PRE24]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure not to get confused since we have a few files with the same filename
    in different directories! While we have the **main.tf**, **variables.tf**, and
    **outputs.tf** files inside the **~/pentest_lab/secure_network** directory, we
    also have files with the same name in the **~/****pentest_lab** directory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保不要混淆文件名，因为我们在不同的目录中有几个相同的文件名！尽管我们在**~/pentest_lab/secure_network**目录中有**main.tf**、**variables.tf**和**outputs.tf**文件，但在**~/pentest_lab**目录中也有相同名称的文件。
- en: 'Using the editor, add the following block of code to the **secure_network/variables.tf**
    file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器，将以下代码块添加到**secure_network/variables.tf**文件中：
- en: '[PRE25]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure to save the **secure_network/variables.tf** file before proceeding.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续之前，请确保保存**secure_network/variables.tf**文件。
- en: 'Next, open the **secure_network/main.tf** file in the editor. In the next set
    of steps, we will be adding blocks of code here to define and configure multiple
    network resources. Let’s start by adding the following block of code, which will
    allow us later to use serial connect to access our VM instances from the browser:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在编辑器中打开**secure_network/main.tf**文件。在接下来的步骤中，我们将添加一段代码来定义和配置多个网络资源。首先，添加以下代码块，允许我们以后通过串行连接从浏览器访问我们的虚拟机实例：
- en: '[PRE26]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are a variety of ways to connect to running VM instances. In this chapter,
    we’ll use **serial connect** since it offers a convenient way to access the VM
    instances we launched from the browser. Feel free to check the following link
    for more information: [https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console](https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到运行中的虚拟机实例有多种方式。在本章中，我们将使用**串行连接**，因为它提供了一种方便的方式让我们从浏览器访问启动的虚拟机实例。欢迎查看以下链接获取更多信息：[https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console](https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console)。
- en: 'In the same file (**secure_network/main.tf**), add the following block of code
    to define **google_compute_network** and **google_compute_subnetwork** resources:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中（**secure_network/main.tf**），添加以下代码块来定义**google_compute_network**和**google_compute_subnetwork**资源：
- en: '[PRE27]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we define a VPC network with a single subnet with the **10.1.0.0/20**
    **Classless Inter-Domain Routing** (**CIDR**) range. Since **auto_create_subnetworks**
    is set to **false**, no other subnets will be created (other than the subnet we
    just defined).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有单个子网的VPC网络，使用**10.1.0.0/20**的**无类域间路由**（**CIDR**）范围。由于**auto_create_subnetworks**被设置为**false**，因此不会创建其他子网（除我们刚才定义的子网外）。
- en: 'In the same file (**secure_network/main.tf**), define **vpc_02** and **subnet_02**
    resources as well:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中（**secure_network/main.tf**），定义**vpc_02**和**subnet_02**资源：
- en: '[PRE28]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will launch the attacker VM instance in these network resources later in
    this chapter.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章稍后在这些网络资源中启动攻击者虚拟机实例。
- en: 'In the same file (**secure_network/main.tf**), let’s define two **net_01**
    and **net_02** local values:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中（**secure_network/main.tf**），让我们定义两个**net_01**和**net_02**本地值：
- en: '[PRE29]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ll use these local values when defining the other networking resources in
    the next set of steps.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下一组步骤中定义其他网络资源时，使用这些本地值。
- en: 'In the same file (**secure_network/main.tf**), let’s define two **google_compute_network_peering**
    resources using the following blocks of code—one from **vpc-01** to **vpc-02**
    and another from **vpc-02** to **vpc-01**:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中（**secure_network/main.tf**），让我们使用以下代码块定义两个**google_compute_network_peering**资源—一个从**vpc-01**到**vpc-02**，另一个从**vpc-02**到**vpc-01**：
- en: '[PRE30]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In order for VPC Network Peering to work properly, the CIDR blocks of the VPCs
    involved should *NOT* overlap. In our case, our setup should work just fine since
    the CIDR blocks of **VPC 01** (**10.1.0.0/20**-**10.1.0.0**-**10.1.15.255**) and
    **VPC 02** (**10.2.0.0/20**-**10.2.0.0**-**10.2.15.255**) do not overlap. Feel
    free to use an online subnet calculator to verify this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保VPC网络对等互联正常工作，所涉及VPC的CIDR块不应*重叠*。在我们的案例中，设置应该没有问题，因为**VPC 01**（**10.1.0.0/20**-**10.1.0.0**-**10.1.15.255**）和**VPC
    02**（**10.2.0.0/20**-**10.2.0.0**-**10.2.15.255**）的CIDR块没有重叠。可以使用在线子网计算器来验证这一点。
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-all-from-vpc2**
    and **allow-all-from-vpc-1** firewalls using the following block of code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件（**secure_network/main.tf**）中，使用以下代码块定义**allow-all-from-vpc2**和**allow-all-from-vpc-1**防火墙：
- en: '[PRE31]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These blocks will (1) allow traffic from resources deployed in **VPC 02** to
    reach resources deployed in **VPC 01** (that is, from **10.2.0.0/20** to **10.1.0.0/20**)
    and (2) allow traffic from resources deployed in **VPC 01** to reach resources
    deployed in **VPC 02** (that is, from **10.1.0.0/20** to **10.2.0.0/20**).
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些代码块将（1）允许从部署在**VPC 02**中的资源访问部署在**VPC 01**中的资源（即，从**10.2.0.0/20**到**10.1.0.0/20**）以及（2）允许从部署在**VPC
    01**中的资源访问部署在**VPC 02**中的资源（即，从**10.1.0.0/20**到**10.2.0.0/20**）。
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Priority numbers in GCP firewall rules determine the order in which rules are
    evaluated. The *lower* the priority number, the *higher* the priority of the rule.
    GCP evaluates firewall rules in ascending order based on priority numbers until
    a matching rule is found, at which point the evaluation stops. That said, it is
    important to assign unique and appropriately sequenced priority numbers to ensure
    that the desired firewall rules are applied correctly and in the intended order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: GCP防火墙规则中的优先级数字决定了规则评估的顺序。*数字越低*，规则的优先级越*高*。GCP根据优先级数字按升序评估防火墙规则，直到找到匹配的规则，此时评估停止。也就是说，重要的是分配唯一且恰当顺序的优先级数字，以确保防火墙规则正确应用，并按预期顺序执行。
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-ssh-from-my-ip**
    and **allow-desktop-access-from-my-ip** firewalls using the following block of
    code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件（**secure_network/main.tf**）中，使用以下代码块定义**allow-ssh-from-my-ip**和**allow-desktop-access-from-my-ip**防火墙：
- en: '[PRE32]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These firewall rules will allow your local machine to access resources launched
    inside **VPC 02** (via ports **22** and **8081**) once the entire penetration
    lab environment has been set up.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些防火墙规则将允许你的本地机器访问在**VPC 02**内启动的资源（通过端口**22**和**8081**），一旦整个渗透实验环境搭建完成。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to save the **secure_network/main.tf** file (**File** menu > **Save**)
    before running the terminal commands in the succeeding set of steps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行接下来的一组终端命令之前，确保保存**secure_network/main.tf**文件（**文件**菜单 > **保存**）。
- en: 'Now, let’s open **secure_network/outputs.tf** in the editor. Add the following
    blocks of code to define the **subnet_01** and **subnet_02** outputs:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在编辑器中打开**secure_network/outputs.tf**文件。添加以下代码块以定义**subnet_01**和**subnet_02**输出：
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Make sure to save the **secure_network/outputs.tf** file as well before proceeding
    to the next step.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进行下一步之前，确保也保存**secure_network/outputs.tf**文件。
- en: 'Navigate to our **pentest_lab** project directory, like so:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们的**pentest_lab**项目目录，如下所示：
- en: '[PRE34]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用**terraform init**命令重新初始化Terraform工作目录：
- en: '[PRE35]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行**terraform plan**来预览Terraform将要执行的更改：
- en: '[PRE36]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This should give us a **Missing required argument — The argument “my_ip” is
    required, but no definition was found** error message since we have not provided
    any value for the **my_ip** argument while declaring the **secure_network** module.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们带来一个**缺少必需参数 — 必需的“my_ip”参数未定义**的错误信息，因为我们在声明**secure_network**模块时没有为**my_ip**参数提供任何值。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined the **my_ip** variable in the **secure_network/variables.tf**
    file in an earlier step.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么这个问题会突然出现，重要的是回忆一下我们在之前的步骤中已经在**secure_network/variables.tf**文件中定义了**my_ip**变量。
- en: To resolve the issue encountered in the previous step, we need to provide a
    value for the **my_ip** argument when declaring the **secure_network** module
    (similar to what we have in *Figure 4**.16*):![](image/B19755_04_16.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决在前一步中遇到的问题，我们需要在声明**secure_network**模块时为**my_ip**参数提供一个值（类似于*图4.16*中的内容）：![](image/B19755_04_16.jpg)
- en: Figure 4.16 – Passing the my_ip variable value to the my_ip input variable of
    the secure_network module
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.16 – 将my_ip变量值传递到secure_network模块的my_ip输入变量中
- en: Using *Figure 4**.16* as a reference, we will resolve the issue by passing the
    **my_ip** variable value (of the root module) to the **my_ip** input variable
    of the **secure_network** module. Since we had the **terraform.tfvars** file prepared
    in an earlier step, the default variable values for **my_public_ssh_key** and
    **my_ip** will be loaded from the **terraform.tfvars** file when we run the **terraform
    apply** command in a later step.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以*图 4.16*为参考，我们将通过将**my_ip**变量值（根模块中的）传递给**secure_network**模块的**my_ip**输入变量来解决问题。由于我们在之前的步骤中已准备了**terraform.tfvars**文件，运行**terraform
    apply**命令时，**my_public_ssh_key**和**my_ip**的默认变量值将从**terraform.tfvars**文件中加载。
- en: 'Now that we have a better idea of how to resolve the issue, let’s locate the
    following block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们对如何解决问题有了更清晰的思路，让我们在**main.tf**文件中找到以下代码块（**~/pentest_lab/main.tf**）：
- en: '[PRE37]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update it with the following block of code:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码块更新它：
- en: '[PRE38]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are passing the **my_ip** variable value to the **my_ip** input variable
    of the **secure_network** module.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将**my_ip**变量值传递给**secure_network**模块的**my_ip**输入变量。
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to save the **main.tf** file (**~/pentest_lab/main.tf**) before proceeding
    to the next step.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，请确保保存**main.tf**文件（**~/pentest_lab/main.tf**）。
- en: 'In the Cloud Shell terminal (right after the **$** sign), let’s run the following
    command to preview the changes to be performed by Terraform:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 终端（**$**符号之后），让我们运行以下命令预览 Terraform 将执行的更改：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should yield the following output:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会输出以下结果：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We should be able to proceed without encountering an error this time.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一次，我们应该能够顺利进行，而不会遇到错误。
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**terraform apply**命令来实现这些更改：
- en: '[PRE41]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running the command should return the following output:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行命令应返回以下输出：
- en: '[PRE42]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wait for a few minutes for the **terraform apply** command to complete.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，直到**terraform apply**命令完成。
- en: Now, let’s check the resources created by Terraform using the console. Navigate
    to the list of existing VPC networks by typing **vpc networks** in the search
    bar and then selecting **VPC networks** from the search results:![](image/B19755_04_17.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用控制台检查 Terraform 创建的资源。通过在搜索栏中键入**vpc networks**并从搜索结果中选择**VPC networks**，进入现有
    VPC 网络列表：![](image/B19755_04_17.jpg)
- en: Figure 4.17 – List of VPC networks
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.17 – VPC 网络列表
- en: In *Figure 4**.17*, we can see that **vpc-01** and **vpc-02** VPC networks have
    been created by Terraform successfully. Here, we can also see that both **vpc-01**
    and **vpc-02** have a single subnet each (indicated by the count under the **Subnets**
    column). Feel free to click the **REFRESH** button in case the list does not reflect
    the new VPCs we just created.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*图 4.17*中，我们可以看到**vpc-01**和**vpc-02** VPC 网络已成功由 Terraform 创建。在这里，我们还可以看到**vpc-01**和**vpc-02**各自有一个子网（在**子网（Subnets）**列下的计数表示）。如果列表未显示我们刚创建的新
    VPC，请随时点击**刷新（REFRESH）**按钮。
- en: Let’s check the VPC network where we’ll host the target VM instance. Click **vpc-01**
    from the list of VPC networks to navigate to the VPC network details page of the
    said VPC:![](image/B19755_04_18.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查将托管目标虚拟机实例的 VPC 网络。从 VPC 网络列表中点击**vpc-01**，进入该 VPC 的网络详情页面：![](image/B19755_04_18.jpg)
- en: Figure 4.18 – VPC network details
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.18 – VPC 网络详情
- en: We should see that we only have a single subnet inside **vpc-01**, similar to
    what we have in *Figure 4**.18*. You may also check the resources under the **FIREWALLS**
    and **VPC NETWORK PEERING** tabs to verify that these resources have been created
    and configured correctly.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该能看到**vpc-01**中只有一个子网，类似于*图 4.18*中的情况。您还可以检查**防火墙（FIREWALLS）**和**VPC 网络对等（VPC
    NETWORK PEERING）**选项卡下的资源，以验证这些资源是否已正确创建和配置。
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may navigate back to the list of VPC networks and check **vpc-02** along
    with the other resources created using the Google Cloud console as well.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以返回到 VPC 网络列表，检查**vpc-02**以及使用 Google Cloud 控制台创建的其他资源。
- en: '*Wasn’t that easy?* Without further ado, let’s move on to the next section.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*这不是很简单吗？* 话不多说，让我们继续下一部分。'
- en: Setting up the target VM instance
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置目标虚拟机实例
- en: 'With our isolated network environment ready, we can now proceed with setting
    up the target VM instance. In this section, we will set up the target VM instance
    in the subnet of **VPC 01**, similar to what we have in *Figure 4**.19*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的隔离网络环境准备好后，现在可以继续设置目标虚拟机实例。在本节中，我们将在**VPC 01**的子网中设置目标虚拟机实例，类似于*图 4.19*中的情况：
- en: '![](image/B19755_04_19.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_19.jpg)'
- en: Figure 4.19 – Setting up the target VM instance in the subnet of VPC 01
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 在VPC 01的子网中设置目标虚拟机实例
- en: Inside the target VM instance, we will be running an intentionally vulnerable
    application called **OWASP Juice Shop**. OWASP Juice Shop was designed, developed,
    and prepared by the **Open Web Application Security Project** (**OWASP**) to help
    developers, security engineers, and penetration testers enhance their understanding
    of secure coding practices and vulnerability identification, along with various
    mitigation strategies. To simplify the setup and installation of the OWASP Juice
    Shop application in our VM instance, we will utilize the **bkimminich/juice-shop**
    container image. This container image will allow us to run the vulnerable-by-design
    application inside a container.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标虚拟机实例内，我们将运行一个故意设计为易受攻击的应用程序，名为**OWASP Juice Shop**。**OWASP Juice Shop**由**开放Web应用程序安全项目**（**OWASP**）设计、开发和准备，旨在帮助开发人员、安全工程师和渗透测试人员提升他们对安全编码实践和漏洞识别的理解，并提供各种缓解策略。为了简化在我们的虚拟机实例中安装和设置**OWASP
    Juice Shop**应用程序，我们将使用**bkimminich/juice-shop**容器镜像。该容器镜像将允许我们在容器中运行这一设计上就易受攻击的应用程序。
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering what **containers** are, they are simply lightweight and
    isolated runtime environments that provide a consistent and portable way to run
    applications across various computing environments. On the other hand, container
    images (such as the **bkimminich/juice-shop** container image) are templates that
    contain the necessary files and configurations to create and run containers. They
    include the application code, along with all the prerequisites required to execute
    an application within a containerized environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想**容器**是什么，它们只是轻量级的、隔离的运行时环境，提供了一种一致且便捷的方式来在不同的计算环境中运行应用程序。另一方面，容器镜像（如**bkimminich/juice-shop**容器镜像）是包含创建和运行容器所需文件和配置的模板。它们包括应用程序代码，以及在容器化环境中执行应用程序所需的所有先决条件。
- en: Containers allow different vulnerable-by-design applications to coexist inside
    the VM instance without interfering with each other. That said, while we are planning
    to have only one container running inside the target VM instance, it is worth
    mentioning that running multiple intentionally vulnerable applications inside
    containers on the same VM instance is possible as well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 容器允许不同的易受攻击应用程序在虚拟机实例中共存而不互相干扰。也就是说，尽管我们计划在目标虚拟机实例内只运行一个容器，但值得一提的是，在同一个虚拟机实例的容器内运行多个故意设计为易受攻击的应用程序也是可能的。
- en: 'This section is divided into the following subparts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为以下几个子部分：
- en: '*Part 1 of 2 – Preparing the target VM instance* *using Terraform*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1部分/2 – 使用Terraform准备目标虚拟机实例*'
- en: '*Part 2 of 2 – Using the serial console to access the target* *VM instance*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2部分/2 – 使用串行控制台访问目标* *虚拟机实例*'
- en: Without further ado, let’s begin!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 事不宜迟，开始吧！
- en: Part 1 of 2 – Preparing the target VM instance using Terraform
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分/2 – 使用Terraform准备目标虚拟机实例
- en: 'Follow the next steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Navigate to the **~/pentest_lab/target_vm** directory by running the following
    in the Cloud Shell Terminal:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Cloud Shell终端运行以下命令，导航到**~/pentest_lab/target_vm**目录：
- en: '[PRE43]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the following commands to create the files we’ll need in our **target_vm**
    module:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建我们在**target_vm**模块中所需的文件：
- en: '[PRE44]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open a new browser tab and navigate to this book’s official GitHub repository:
    [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/).'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器标签，导航到本书的官方GitHub仓库：[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/)。
- en: Locate the **target_boot_script.tpl** template file inside the **ch04/pentest_lab/target_vm**
    directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)):![](image/B19755_04_20.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ch04/pentest_lab/target_vm**目录下找到**target_boot_script.tpl**模板文件（[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)）：![](image/B19755_04_20.jpg)
- en: Figure 4.20 – Copy Link Address option
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.20 – 复制链接地址选项
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.20*). This
    will copy the link address of the file to the clipboard of your local machine.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键点击 **Raw** 按钮，在上下文菜单中选择 **复制链接地址**（如 *图 4.20* 中突出显示的那样）。这将把文件的链接地址复制到本地计算机的剪贴板。
- en: 'Download the **target_boot_script.tpl** template file using the **wget** command:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **wget** 命令下载 **target_boot_script.tpl** 模板文件：
- en: '[PRE45]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将 **<DOWNLOAD LINK>** 替换为之前复制的链接（在选择上下文菜单中的 **复制链接地址** 后，它应该已经复制到剪贴板）。
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这个链接来替代 **<DOWNLOAD** **LINK>** 的值：
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)'
- en: 'Let’s quickly check the contents of the **target_boot_script.tpl** file we
    downloaded using the **cat** command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速检查一下我们下载的 **target_boot_script.tpl** 文件的内容，使用 **cat** 命令：
- en: '[PRE46]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Spend a few minutes reading the code inside the file. You’ll see that the script
    is divided into three parts, as follows:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 花几分钟阅读文件中的代码。你会看到，脚本分为三部分，具体如下：
- en: '**SET UP USER**—Running the script creates a new user on the system, sets a
    password for that user, and then grants the new user **sudo** privileges (without
    requiring a password)'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置用户**—运行脚本会在系统上创建一个新用户，为该用户设置密码，并授予该用户 **sudo** 权限（无需密码）'
- en: '**INSTALL DOCKER**—Here, we run a few commands for installing Docker on the
    system where the script will run'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Docker**—在这里，我们运行一些命令以在脚本运行的系统上安装 Docker'
- en: '**SET UP OWASP JUICE SHOP**—This portion of the script focuses on running the
    OWASP Juice Shop application in a Docker container and making it accessible on
    port **80** of the host machine where the script will run'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置 OWASP Juice Shop**—这一部分的脚本主要是运行 OWASP Juice Shop 应用程序，并将其托管在 Docker 容器中，使其可以通过脚本运行的主机的
    **80** 端口进行访问'
- en: Now, let’s open a new browser tab and locate the **wait_for_boot.tpl** template
    file inside the **ch04/pentest_lab/target_vm** directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)):![](image/B19755_04_21.jpg)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个新的浏览器标签页，在 **ch04/pentest_lab/target_vm** 目录下找到 **wait_for_boot.tpl**
    模板文件 ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)):![](image/B19755_04_21.jpg)
- en: Figure 4.21 – Copy Link Address option
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21 – 复制链接地址选项
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.21*). This
    will copy the link address of the file to the clipboard of your local machine.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右键点击 **Raw** 按钮，在上下文菜单中选择 **复制链接地址**（如 *图 4.21* 中突出显示的那样）。这将把文件的链接地址复制到本地计算机的剪贴板。
- en: 'Download the **wait_for_boot.tpl** template file using the **wget** command:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **wget** 命令下载 **wait_for_boot.tpl** 模板文件：
- en: '[PRE47]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将 **<DOWNLOAD LINK>** 替换为之前复制的链接（在选择上下文菜单中的 **复制链接地址** 后，它应该已经复制到剪贴板）。
- en: Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这个链接来替代 **<DOWNLOAD** **LINK>** 的值：
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)'
- en: 'Let’s quickly check the contents of the **wait_for_boot.tpl** file we downloaded
    using the **cat** command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用**cat**命令快速检查我们下载的**wait_for_boot.tpl**文件内容：
- en: '[PRE48]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Spend a minute or two reading the code inside the file. You’ll see that the
    script simply waits for the target boot script (based on the **target_boot_script.tpl**
    template script file) to finish running. The script loops for a certain number
    of retry attempts and checks if the target boot script has executed the following
    line of code:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 花上一两分钟阅读文件中的代码。你会看到脚本只是等待目标引导脚本（基于**target_boot_script.tpl**模板脚本文件）完成运行。脚本会进行一定次数的重试，并检查目标引导脚本是否执行了以下代码行：
- en: '[PRE49]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Important note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Make sure that the **target_boot_script.tpl** and **wait_for_boot.tpl** template
    files are inside the **pentest_lab/target_vm** directory before proceeding.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保**target_boot_script.tpl**和**wait_for_boot.tpl**模板文件位于**pentest_lab/target_vm**目录中。
- en: 'Now, let’s open **target_vm/variables.tf** in the editor and add the following
    block of code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在编辑器中打开**target_vm/variables.tf**文件，并添加以下代码块：
- en: '[PRE50]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we’ll define a single variable that will be used when configuring in which
    subnet the VM instance will be launched.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一个变量，用于配置虚拟机实例将在哪个子网中启动。
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Make sure to save the **target_vm/variables.tf** file before proceeding.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保保存**target_vm/variables.tf**文件。
- en: Now, let’s open the **target_vm/main.tf** file in the editor. We will add several
    blocks of code in the next set of steps.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在编辑器中打开**target_vm/main.tf**文件。在接下来的步骤中，我们将添加几块代码。
- en: 'In the **target_vm/main.tf** file, let’s define a resource called **random_password**
    that generates a random string of length **12** with special characters:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**target_vm/main.tf**文件中，让我们定义一个名为**random_password**的资源，它会生成一个长度为**12**的随机字符串，并带有特殊字符：
- en: '[PRE51]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we provide our own list of special characters to be used when generating
    the random password value. If you are wondering where we’ll use this generated
    password, we will use it when accessing the target VM instance (via the serial
    console) in the succeeding set of steps.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们提供了自己的特殊字符列表，用于生成随机密码值。如果你在想我们将在哪里使用这个生成的密码，我们将在接下来的步骤中通过串行控制台访问目标虚拟机实例时使用它。
- en: 'In the **target_vm/main.tf** file, let’s define a few local variables that
    we will use when configuring our VM instance (before defining our **google_compute_instance**
    resource):'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**target_vm/main.tf**文件中，让我们定义一些本地变量，用于配置我们的虚拟机实例（在定义**google_compute_instance**资源之前）：
- en: '[PRE52]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we define **vm_username**, **vm_password**, **script**, and **subnet_01**
    local variables. When defining the **script** local variable, we use the **templatefile()**
    function to render the contents of the **target_boot_script.tpl** template file
    by passing in the values of **vm_username** and **vm_password** as variables.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了**vm_username**、**vm_password**、**script**和**subnet_01**本地变量。在定义**script**本地变量时，我们使用**templatefile()**函数来渲染**target_boot_script.tpl**模板文件的内容，并传递**vm_username**和**vm_password**的值作为变量。
- en: 'In the **target_vm/main.tf** file, let’s define our first **google_compute_instance**
    resource using the following block of code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**target_vm/main.tf**文件中，让我们使用以下代码块定义我们的第一个**google_compute_instance**资源：
- en: '[PRE53]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the **target_vm/main.tf** file, let’s also define **wait_for_startup_script**
    and **null_resource** resources:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**target_vm/main.tf**文件中，我们还需要定义**wait_for_startup_script**和**null_resource**资源：
- en: '[PRE54]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you are wondering what this is for, this code block simply runs a script
    (coded inside the **wait_for_boot.tpl** template file) inside the VM instance
    and waits for the entire boot script (coded inside the **target_boot_script.tpl**
    template file) to complete.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在想这段代码是做什么的，这个代码块只是运行一个脚本（该脚本编码在**wait_for_boot.tpl**模板文件中）并在虚拟机实例中等待整个引导脚本（该脚本编码在**target_boot_script.tpl**模板文件中）完成。
- en: Important note
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Without this block, the **terraform apply** command would finish prematurely,
    even if the target VM instance’s boot process had not finished. This would mean
    that the OWASP Juice Shop application may not be available and accessible yet
    by the time the **terraform apply** command has completed!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个代码块，**terraform apply**命令将提前完成，即使目标虚拟机实例的引导过程还没有结束。这意味着在**terraform apply**命令完成时，OWASP
    Juice Shop应用可能还不可用或无法访问！
- en: 'In the **target_vm/main.tf** file, let’s define the following local values
    as well:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**target_vm/main.tf**文件中，让我们也定义以下本地值：
- en: '[PRE55]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Make sure to save the **target_vm/main.tf** file before proceeding with the
    next set of steps.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一组步骤之前，请确保保存**target_vm/main.tf**文件。
- en: 'Now, open the **target_vm/outputs.tf** file in the editor. Add the following
    blocks of code to define the outputs of the **target_vm** module:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在编辑器中打开 **target_vm/outputs.tf** 文件。添加以下代码块以定义 **target_vm** 模块的输出：
- en: '[PRE56]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Make sure to save the **target_vm/outputs.tf** file before proceeding with the
    next set of steps.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续下一步之前，确保保存 **target_vm/outputs.tf** 文件。
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will use these output values in the **~/****pentest_lab/outputs.tf** file.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 **~/pentest_lab/outputs.tf** 文件中使用这些输出值。
- en: 'In the Cloud Shell terminal (right after the **$** sign), navigate to the **pentest_lab**
    project directory:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 终端（**$** 符号后面）中，导航到 **pentest_lab** 项目目录：
- en: '[PRE57]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 **terraform init** 命令重新初始化 Terraform 工作目录：
- en: '[PRE58]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 **terraform plan** 来预览 Terraform 将执行的更改：
- en: '[PRE59]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This should give us a **Missing required argument — The argument “subnet_01”
    is required, but no definition was found** error message since we have not provided
    any values for the **subnet_01** argument while declaring the **target_vm** module.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们一个 **Missing required argument — The argument “subnet_01” is required,
    but no definition was found** 错误消息，因为我们在声明 **target_vm** 模块时没有为 **subnet_01**
    参数提供任何值。
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering why we suddenly encountered this issue, it’s important
    to recall that we defined the **subnet_01** variable in the **target_vm/variables.tf**
    file in an earlier step. We will have this resolved in the next set of steps!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么我们突然遇到这个问题，那么重要的是要回想一下，我们在早期步骤中已经在 **target_vm/variables.tf** 文件中定义了
    **subnet_01** 变量。我们将在接下来的步骤中解决这个问题！
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_01** argument when declaring the **target_vm**
    module (similar to what we have in *Figure 4**.22*):![](image/B19755_04_22.jpg)
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决上一步骤中遇到的问题，我们需要确保在声明 **target_vm** 模块时为 **subnet_01** 参数提供一个值（类似于 *图 4.22*
    中所示）：![](image/B19755_04_22.jpg)
- en: Figure 4.22 – Providing a value for the subnet_01 argument when declaring the
    target_vm module
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.22 – 在声明 **target_vm** 模块时为 subnet_01 参数提供一个值
- en: 'Using *Figure 4**.22* as a reference, we will resolve the issue by passing
    the **subnet_01** output value from the **secure_network** module to the **subnet_01**
    input variable of the **target_vm** module. Now that we have a better idea of
    how we’ll resolve the issue, let’s locate the following block of code in our **main.tf**
    file (**~/pentest_lab/main.tf**):'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以 *图 4.22* 为参考，我们将通过将 **secure_network** 模块的 **subnet_01** 输出值传递给 **target_vm**
    模块的 **subnet_01** 输入变量来解决这个问题。现在我们对如何解决这个问题有了更清晰的思路，接下来让我们在 **main.tf** 文件 (**~/pentest_lab/main.tf**)
    中找到以下代码块：
- en: '[PRE60]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Update it with the following block of code:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码块更新它：
- en: '[PRE61]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_01**)
    to the **subnet_01** input variable of the **target_vm** module.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将 **secure_network** 模块的输出值 (**module.secure_network.subnet_01**) 传递给
    **target_vm** 模块的 **subnet_01** 输入变量。
- en: Note
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to save the changes made to the **main.tf** file (**~/pentest_lab/main.tf**).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 确保保存对 **main.tf** 文件 (**~/pentest_lab/main.tf**) 所做的更改。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 **terraform plan** 来预览 Terraform 将执行的更改：
- en: '[PRE62]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This should give us the following output:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们以下输出：
- en: '[PRE63]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We should be able to proceed without encountering an error this time.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一次，我们应该能够顺利进行，而不会遇到错误。
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 **terraform apply** 命令来实施更改：
- en: '[PRE64]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the command should yield the following output:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行该命令应该会得到以下输出：
- en: '[PRE65]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wait for a minute or two for the **terraform apply** command to complete.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一到两分钟，直到 **terraform apply** 命令完成。
- en: 'In order for us to see the output values, let’s open the **outputs.tf** file
    (**~/pentest_lab/outputs.tf**) in the editor and add the following blocks of code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看输出值，让我们在编辑器中打开 **outputs.tf** 文件 (**~/pentest_lab/outputs.tf**) 并添加以下代码块：
- en: '[PRE66]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will utilize the outputs from the **target_vm** module in the root module’s
    **outputs.tf** file (**~/pentest_lab/outputs.tf**).
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将利用 **target_vm** 模块的输出，在根模块的 **outputs.tf** 文件 (**~/pentest_lab/outputs.tf**)
    中。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 **terraform plan** 来预览 Terraform 将执行的更改：
- en: '[PRE67]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This should yield the following output:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会得到以下输出：
- en: '[PRE68]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 **terraform apply** 命令来实施更改：
- en: '[PRE69]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This should give us the following output:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们以下输出：
- en: '[PRE70]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we can see the output values after running the **terraform apply -auto-approve**
    command since we defined the outputs in the root module (that is, the code stored
    inside **~/pentest_lab**) in an earlier step.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到运行**terraform apply -auto-approve**命令后的输出值，因为我们在之前的步骤中已经在根模块中定义了输出（即存储在**~/pentest_lab**中的代码）。
- en: Store and save the output values for **target_vm_username**, **target_vm_password**,
    and **target_vm_private_ip** in a text editor as we will use these in the succeeding
    steps in this chapter.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**target_vm_username**、**target_vm_password**和**target_vm_private_ip**的输出值保存在文本编辑器中，因为我们将在本章的后续步骤中使用这些值。
- en: Part 2 of 2 – Using the serial console to access the target VM instance
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分 2/2 – 使用串行控制台访问目标虚拟机实例
- en: 'Follow the next steps:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results (similar to what
    is shown in *Figure 4**.23*):![](image/B19755_04_23.jpg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索框中输入**计算引擎**并从搜索结果中选择**Compute Engine**，导航到**VM 实例**页面（类似于*图 4.23*所示）：![](image/B19755_04_23.jpg)
- en: Figure 4.23 – Navigating to the VM instances page
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.23 – 导航到VM实例页面
- en: On the **VM instances** page, we’ll find a list of VM instances in our GCP account.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**VM 实例**页面，我们将看到我们GCP账户中的虚拟机实例列表。
- en: Click the link (**vm-target**) under the **Name** column to navigate to the
    **Instance details** page of our target VM instance (**vm-target**).
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**名称**列下的链接（**vm-target**），即可导航到我们的目标虚拟机实例（**vm-target**）的**实例详情**页面。
- en: It’s time we accessed the serial console! In case you are wondering what it
    is, the **serial console** serves as a troubleshooting tool that allows users
    to conveniently access the serial port of a VM instance directly in GCP. It enables
    users to interact with the VM’s console output, access the boot process, and diagnose
    issues even when SSH or other network-based connections are unavailable (or misconfigured).
    With this in mind, let’s click on the **CONNECT TO SERIAL CONSOLE** button. This
    will open a pop-up window similar to what we have in *Figure 4**.24*:![](image/B19755_04_24.jpg)
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候访问串行控制台了！如果你在想这是什么，**串行控制台**是一个故障排除工具，允许用户在GCP中方便地直接访问虚拟机实例的串行端口。它使用户能够与虚拟机的控制台输出进行交互，访问启动过程，并诊断问题，即使SSH或其他基于网络的连接不可用（或配置错误）。考虑到这一点，让我们点击**连接到串行控制台**按钮。这将打开一个类似于*图
    4.24*中的弹出窗口：![](image/B19755_04_24.jpg)
- en: Figure 4.24 – Serial console popup
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.24 – 串行控制台弹出窗口
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. Use the output values for **target_vm_username**
    (**testuser**) and **target_vm_password** (generated password) to log in.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你在弹出窗口中看到空白页面，点击空白页面，然后按*Enter*键。使用**target_vm_username**（**testuser**）和**target_vm_password**（生成的密码）登录。
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to run the **terraform show** command in the Cloud Shell terminal
    to retrieve the output values for **target_vm_username** and **target_vm_password**.
    Make sure that you are inside the **~/pentest_lab** directory before running the
    **terraform** **show** command.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 可以随时在Cloud Shell终端运行**terraform show**命令，以检索**target_vm_username**和**target_vm_password**的输出值。在运行**terraform
    show**命令之前，确保你位于**~/pentest_lab**目录内。
- en: 'Use the following command to check if the OWASP Juice Shop container is running
    inside the target VM instance:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查目标虚拟机实例中是否正在运行OWASP Juice Shop容器：
- en: '[PRE71]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If prompted for the password, simply use the **target_vm_password** output value
    to proceed with the command.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果提示输入密码，简单使用**target_vm_password**输出值即可继续执行命令。
- en: 'The **sudo docker ps** command should return a single running container using
    the **bkimminich/juice-shop** container image:'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**sudo docker ps**命令应返回一个正在运行的容器，使用**bkimminich/juice-shop**容器镜像：'
- en: '![](image/B19755_04_25.jpg)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_25.jpg)'
- en: Figure 4.25 – Confirming that the OWASP Juice shop container is already running
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.25 – 确认OWASP Juice Shop容器已经在运行
- en: Accessing port **80** of the VM instance would allow you to interact with the
    container running the **bkimminich/juice-shop** image.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问虚拟机实例的**80**端口将允许你与运行**bkimminich/juice-shop**镜像的容器进行交互。
- en: 'Run the following command to send a sample request to the local server and
    check whether a website is running on port **80**:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令向本地服务器发送示例请求，检查是否在**80**端口上运行了网站：
- en: '[PRE72]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This should yield the following output:'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '![](image/B19755_04_26.jpg)'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_26.jpg)'
- en: Figure 4.26 – Result after using the curl command
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26 – 使用curl命令后的结果
- en: Looks like we have confirmed that we have a website running on port **80** of
    the VM instance (mapped to a web application inside the running container).
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看来我们已经确认了在虚拟机实例的**80端口**（映射到运行中的容器内的Web应用程序）上运行了一个网站。
- en: Now that we have a better idea of what’s running inside the target VM instance,
    we can close the serial console (**SSH** **in-browser**) popup.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对目标虚拟机实例内部运行的内容有了更好的了解，我们可以关闭串行控制台（**SSH** **浏览器内**）弹出窗口。
- en: At this stage, you might be excited about exploring and accessing the OWASP
    Juice Shop application already! Given that we’ve intentionally configured the
    network environment to only allow resources in **VPC 02** to access **VPC 01**
    (where the target VM instance is launched), we will have to set up our attacker
    VM instance in **VPC 02** first before we can access the vulnerable-by-design
    application, along with performing a penetration testing simulation inside the
    network environment.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，你可能已经迫不及待地想要探索和访问OWASP Juice Shop应用程序了！考虑到我们故意配置了网络环境，只允许**VPC 02**中的资源访问**VPC
    01**（目标虚拟机实例所在的网络），因此在访问这个具有设计缺陷的应用程序并进行渗透测试模拟之前，我们必须先在**VPC 02**中设置攻击者虚拟机实例。
- en: Importing the Kali Linux Generic Cloud Image
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入Kali Linux通用云镜像
- en: '**Kali Linux** is a specialized operating system designed specifically for
    advanced penetration testing and ethical hacking activities. With its wide range
    of security tools, Kali Linux enables cybersecurity professionals and enthusiasts
    to perform penetration tests, digital forensics investigations, and vulnerability
    assessments. If you have not used Kali Linux before, think of it as an upgraded
    version of a specific operating system where powerful security tools are pre-installed,
    turning it into a specialized arsenal for cybersecurity professionals. It’s like
    transforming a regular car into a heavily armored tank with an array of advanced
    weapons!'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kali Linux**是一款专门为高级渗透测试和道德黑客活动设计的操作系统。凭借其广泛的安全工具，Kali Linux使网络安全专业人员和爱好者能够执行渗透测试、数字取证调查和漏洞评估。如果你之前没有使用过Kali
    Linux，可以把它想象成一个升级版的操作系统，其中预装了强大的安全工具，使其成为网络安全专业人员的专用武器库。就像将一辆普通车改造成配备高级武器的重型装甲坦克！'
- en: Important note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a specialized operating system with advanced hacking tools, Kali Linux has
    the potential to cause harm or engage in malicious activities if used improperly.
    While it is generally safe to use Kali Linux inside your own penetration testing
    lab environments, always make sure that you have proper authorization when using
    it for conducting security assessments and penetration testing exercises. This
    ensures that you stay within legal and ethical boundaries and avoid any unauthorized
    activities that may lead to legal consequences or harm the integrity of systems.
    Remember to obtain explicit permission from the owner of the systems or networks
    you are testing and adhere to any applicable laws, regulations, or guidelines.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux是一款专门为高级渗透测试和道德黑客活动设计的操作系统，如果使用不当，可能会造成损害或参与恶意活动。尽管在自己的渗透测试实验室环境中使用Kali
    Linux通常是安全的，但在进行安全评估和渗透测试时，务必确保你已获得适当的授权。这确保你在法律和道德的边界内操作，避免任何未经授权的活动，这些活动可能导致法律后果或损害系统的完整性。记住，在测试你所使用的系统或网络之前，要获得系统或网络所有者的明确许可，并遵守适用的法律、法规和指南。
- en: Given that Kali Linux is not available as a preconfigured image in **Google
    Cloud Marketplace**, we need to follow a specific set of steps to import the Generic
    Cloud Image before launching a Kali Linux VM. *Generic what??* The **Generic Cloud
    Image** of Kali Linux is simply a preconfigured and optimized image for deployment
    on various cloud platforms (including GCP). You can think of the image as a DNA
    template that can be used to prepare clones of Kali Linux instances on different
    cloud platforms. It serves as a foundational blueprint, containing all the essential
    configurations and software required for penetration testing and security assessments.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Kali Linux在**Google Cloud Marketplace**中没有作为预配置镜像提供，我们需要按照一套特定的步骤来导入通用云镜像，才能启动Kali
    Linux虚拟机。*通用什么？？* **Kali Linux通用云镜像**只是一个为各种云平台（包括GCP）部署而预配置和优化的镜像。你可以把这个镜像看作是一个DNA模板，可以用来在不同的云平台上准备Kali
    Linux实例的克隆。它作为一个基础性蓝图，包含了渗透测试和安全评估所需的所有基本配置和软件。
- en: 'Now that we have a better understanding of what Kali Linux is and what the
    Generic Cloud Image is used for, let’s proceed with importing the said image to
    our Google GCP project, as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Kali Linux以及通用云镜像的用途有了更好的理解，让我们继续将该镜像导入到我们的Google GCP项目中，步骤如下：
- en: Open a new browser tab and navigate to [https://www.kali.org/get-kali/#kali-cloud](https://www.kali.org/get-kali/#kali-cloud).
    Locate and right-click on the **Generic Cloud Image** download box to open the
    context menu:![](image/B19755_04_27.jpg)
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器标签页，访问[https://www.kali.org/get-kali/#kali-cloud](https://www.kali.org/get-kali/#kali-cloud)。定位并右键点击**通用云镜像**下载框，打开上下文菜单：![](image/B19755_04_27.jpg)
- en: Figure 4.27 – Copying the link address of the Generic Cloud Image
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.27 – 复制通用云镜像的链接地址
- en: 'Select **Copy Link Address** from the list of options in the context menu similar
    to what is shown in *Figure 4**.27*. This should copy the following download link
    to our local machine’s clipboard:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**复制链接地址**，类似于*图 4.27*中显示的内容。这将复制以下下载链接到我们本地计算机的剪贴板：
- en: '[PRE73]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that this download link may change as new versions of the image are made
    available.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，随着新版本的镜像发布，此下载链接可能会发生变化。
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Store and save this download link in a text editor as we will use this in the
    succeeding steps in this chapter. In case you are unable to copy the link address,
    you may find the Generic Cloud Image files here: [https://kali.download/cloud-images/kali-2023.1/](https://kali.download/cloud-images/kali-2023.1/)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 将此下载链接存储并保存到文本编辑器中，因为我们将在本章接下来的步骤中使用它。如果你无法复制链接地址，你可以在这里找到通用云镜像文件：[https://kali.download/cloud-images/kali-2023.1/](https://kali.download/cloud-images/kali-2023.1/)
- en: 'Navigate back to our Google Cloud console browser tab. In the Cloud Shell terminal
    (after the **$** sign), run the following commands to create a directory named
    **kali-image** (and navigate to the created directory as well):'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的Google Cloud控制台浏览器标签页。在Cloud Shell终端（**$**符号后）运行以下命令，以创建一个名为**kali-image**的目录（并进入该目录）：
- en: '[PRE74]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Download the latest version of the **Generic Cloud Image** using **wget** by
    running the following commands in the Cloud Shell terminal:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**wget**在Cloud Shell终端中运行以下命令，下载最新版本的**通用云镜像**：
- en: '[PRE75]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This should download the **kl_image.tar.xz** file inside our **kali-image**
    directory.
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把**kl_image.tar.xz**文件下载到我们的**kali-image**目录中。
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to update the **IMAGE_SOURCE** variable value with the download link
    you copied to the text editor in an earlier step.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 随意更新**IMAGE_SOURCE**变量的值，使用你在之前步骤中复制到文本编辑器的下载链接。
- en: 'Create a compatible **.tar.gz** file for storing the Kali Linux Generic Cloud
    Image by running the following lines (one line at a time):'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令行（每次一行）创建一个兼容的**.tar.gz**文件来存储Kali Linux通用云镜像：
- en: '[PRE76]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we are able to prepare a compressed tarball file named **kl_image.tar.gz**
    containing the contents of the **disk.raw** file.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们能够准备一个名为**kl_image.tar.gz**的压缩tar包文件，包含**disk.raw**文件的内容。
- en: 'Create a new **Google Cloud Storage** (**GCS**) bucket using the **gsutil**
    command:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**gsutil**命令创建一个新的**Google Cloud Storage**（**GCS**）桶：
- en: '[PRE77]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Make sure to replace **<BUCKET NAME>** with a globally unique bucket name (for
    a bucket that is yet to be created). Feel free to check the following link on
    some considerations when naming Cloud Storage buckets: [https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets).'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<BUCKET NAME>**替换为全球唯一的桶名称（对于尚未创建的桶）。可以参考以下链接了解命名Cloud Storage桶时的一些注意事项：[https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets)。
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If this is your first time using the **gsutil** command-line utility, it is
    a command-line tool provided by GCP for interacting with GCS. To grant permission
    for the **gsutil** command, we need to proceed by clicking on the **AUTHORIZE**
    button in the **Authorize Cloud Shell** pop-up window. This will allow the necessary
    permissions for the **gsutil** command to be executed successfully.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用**gsutil**命令行工具，它是GCP提供的一个命令行工具，用于与GCS交互。为了授权**gsutil**命令，我们需要点击**授权**按钮，授权**Cloud
    Shell**弹出窗口中的权限。这样可以允许执行**gsutil**命令所需的权限。
- en: 'Upload the **.tar.gz** file to an existing GCS bucket using the **gsutil**
    utility:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**gsutil**工具将**.tar.gz**文件上传到现有的GCS桶中：
- en: '[PRE78]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You may navigate to the **Cloud Storage Buckets** page using the user interface
    (Cloud console) and check if the **.tar.gz** file has been uploaded to the bucket
    successfully.
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过用户界面（Cloud控制台）导航到**Cloud Storage Buckets**页面，并检查**.tar.gz**文件是否已成功上传到存储桶中。
- en: 'Use the **gcloud compute images create** command to create an image from the
    **.tar.gz** file uploaded to the GCS bucket:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**gcloud compute images create**命令从上传到GCS存储桶中的**.tar.gz**文件创建镜像：
- en: '[PRE79]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Feel free to replace **kali-linux-2023-000** with a different **IMAGE_NAME**
    value.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以随意将**kali-linux-2023-000**替换为不同的**IMAGE_NAME**值。
- en: Note
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **gcloud** CLI is a unified command-line utility provided by GCP that allows
    users to access and manage various Google Cloud resources from the terminal. With
    this command-line utility, we can perform tasks such as provisioning and managing
    VMs, configuring networking, deploying applications, managing storage resources,
    and accessing service APIs. The **gsutil** tool, on the other hand, facilitates
    various tasks, including uploading, downloading, copying, and managing data within
    Cloud Storage buckets. It is worth noting that **gcloud** and **gsutil** have
    different functionalities, and it is important not to mistake one for the other.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**gcloud** CLI是由GCP提供的统一命令行工具，允许用户从终端访问和管理各种Google Cloud资源。使用该命令行工具，我们可以执行任务，如配置和管理虚拟机、配置网络、部署应用、管理存储资源以及访问服务API。另一方面，**gsutil**工具则方便进行各种任务，包括上传、下载、复制和管理Cloud
    Storage存储桶中的数据。值得注意的是，**gcloud**和**gsutil**具有不同的功能，不能将其混淆。'
- en: 'Run the following command to verify that we were able to successfully create
    the image:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来验证我们是否成功创建了镜像：
- en: '[PRE80]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This should return the following output:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该返回以下输出：
- en: '[PRE81]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we have a filtered list of custom images that have been created or imported
    into our account.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个过滤后的自定义镜像列表，这些镜像已经创建或导入到我们的账户中。
- en: '*Now that we have the image imported to Google Cloud, what’s next?* From this
    image, we should be able to launch a VM instance that will serve as the attacker
    instance in our penetration testing lab environment.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在我们已经将镜像导入到Google Cloud，接下来该做什么？* 从这个镜像中，我们应该能够启动一个虚拟机实例，作为渗透测试实验环境中的攻击者实例。'
- en: Manually setting up the attacker VM instance
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动设置攻击者虚拟机实例
- en: With our custom image and the VPC network setup ready, setting up our Kali Linux
    attacker machine on GCP should be straightforward. However, before proceeding
    with the hands-on portion of this section, let’s quickly discuss how our attacker
    VM machine will be configured and deployed.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好我们的自定义镜像和VPC网络设置后，在GCP上设置我们的Kali Linux攻击机应该是直接的。然而，在继续本节的实践部分之前，让我们快速讨论一下攻击者VM将如何配置和部署。
- en: 'To start with, we will be deploying the Kali Linux attacker machine in **VPC
    02**, similar to what we have in *Figure 4**.28*:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在**VPC 02**中部署Kali Linux攻击机，类似于*图4.28*所示：
- en: '![](image/B19755_04_28.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_28.jpg)'
- en: Figure 4.28 – Setting up the attacker VM instance in the subnet of VPC 02
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 – 在VPC 02的子网中设置攻击者虚拟机实例
- en: Traffic from our attacker machine should be able to reach resources deployed
    in **VPC 01** since **VPC 02** is peered with **VPC 01** and the configured firewall
    rules allow traffic from each of these VPC networks to reach the resources deployed
    in these networks.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 来自攻击机的流量应该能够到达部署在**VPC 01**中的资源，因为**VPC 02**与**VPC 01**建立了对等连接，且配置的防火墙规则允许来自这两个VPC网络的流量到达这些网络中部署的资源。
- en: 'In addition to this, we will set up the following in the attacker VM:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还将在攻击者虚拟机（VM）中设置以下内容：
- en: '**TigerVNC**—A high-performance cross-platform implementation of **Virtual
    Network Computing** (**VNC**) that enables users to remotely access and interact
    with graphical applications on remote machines'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TigerVNC**—一种高性能的跨平台实现的**虚拟网络计算**（**VNC**），使用户能够远程访问并与远程机器上的图形应用程序进行交互'
- en: '**noVNC**—A web-based implementation of VNC that allows users to access and
    control a remote desktop environment through a web browser'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**noVNC**—一种基于Web的VNC实现，允许用户通过Web浏览器访问和控制远程桌面环境'
- en: 'These will allow us to interact with the desktop environment of the attacker
    machine remotely from the browser (similar to what is shown in *Figure 4**.29*):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将允许我们通过浏览器远程与攻击机的桌面环境进行交互（类似于*图4.29*中所示的内容）：
- en: '![](image/B19755_04_29.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_29.jpg)'
- en: Figure 4.29 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 – 从攻击者实例中运行的浏览器访问目标实例
- en: It’s important to distinguish between the two browsers shown in *Figure 4**.29*.
    The first browser, which will run on our local machine, displays the desktop environment
    of our Kali Linux VM instance. Within this environment, we will launch the Firefox
    browser to access the **OWASP Juice Shop** web application running in the target
    VM instance.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分*图4.29*中显示的两个浏览器。第一个浏览器将在我们的本地机器上运行，显示我们Kali Linux虚拟机实例的桌面环境。在这个环境中，我们将启动Firefox浏览器，访问运行在目标虚拟机实例中的**OWASP
    Juice Shop** web应用程序。
- en: 'That said, we’ll divide this section into three parts, as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将把这一部分分为三部分，如下所示：
- en: '*Part 1 of 3 – Manually launching the* *attacker instance*'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1部分，共3部分 – 手动启动* *攻击者实例*'
- en: '*Part 2 of 3 – Enabling browser access to our Kali* *Linux server*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2部分，共3部分 – 启用浏览器访问我们的Kali* *Linux服务器*'
- en: '*Part 3 of 3 – Validating* *our setup*'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3部分，共3部分 – 验证* *我们的设置*'
- en: With these points in mind, let’s begin!
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要点，让我们开始吧！
- en: Part 1 of 3 – Manually launching the attacker instance
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分，共3部分 – 手动启动攻击者实例
- en: 'Follow the next steps:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索框中输入**计算引擎**并从搜索结果中选择**计算引擎**，进入**虚拟机实例**页面。
- en: Take note of the **Zone** value for **vm-target** (that is, **us-central1-c**)
    as we will use the same zone when creating the **kali-00** VM instance.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意**vm-target**的**区域**值（即**us-central1-c**），因为在创建**kali-00**虚拟机实例时，我们将使用相同的区域。
- en: 'Click the **CREATE INSTANCE** button. Specify the following configuration values
    when creating the new instance:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建实例**按钮。在创建新实例时，请指定以下配置值：
- en: '**Name**: **kali-00**'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**kali-00**'
- en: '**Region**: **us-central1 (Iowa)**'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：**us-central1（爱荷华）**'
- en: '**Zone**: **us-central1-c**'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：**us-central1-c**'
- en: '**Machine** **type**: **e2-medium**'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器类型**：**e2-medium**'
- en: '**Boot disk**: Locate and click the **CHANGE** button. Navigate to the **CUSTOM
    IMAGES** tab and select the **kali-linux-2023-000** image from the list of drop-down
    options, similar to what is shown in *Figure 4.30*. For the **Size (GB)** field,
    specify a value of **50**. Click the **SELECT** button afterward:![](image/B19755_04_30.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动磁盘**：找到并点击**更改**按钮。切换到**自定义镜像**标签页，并从下拉选项中选择**kali-linux-2023-000**镜像，类似于*图4.30*所示。对于**大小（GB）**字段，指定一个**50**的值。之后点击**选择**按钮：![](image/B19755_04_30.jpg)'
- en: Figure 4.30 – Configuring the boot disk
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.30 – 配置启动磁盘
- en: '**Advanced options** (expand) > **Networking** (expand) > **Network interfaces**:
    Change **default** to **vpc-02** under **Edit** **network interface**.'
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级选项**（展开）> **网络**（展开）> **网络接口**：在**编辑** **网络接口**下将**默认**更改为**vpc-02**。'
- en: Scroll down to the bottom of the page and then click the **CREATE** button.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动至页面底部，然后点击**创建**按钮。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一两分钟，直到此步骤完成。在等待时，可以喝杯咖啡或茶！
- en: Part 2 of 3 – Enabling browser access to our Kali Linux server
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分，共3部分 – 启用浏览器访问我们的Kali Linux服务器
- en: 'Follow the next steps:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Navigate to the **VM instances** page where we can find a list of running instances.
    Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our Kali Linux VM instance (**kali-00**).
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**虚拟机实例**页面，在那里我们可以找到正在运行的实例列表。点击**名称**栏下的链接（**kali-00**）以跳转到我们的Kali Linux虚拟机实例（**kali-00**）的**实例详情**页面。
- en: Let’s access the serial console by clicking on the **CONNECT TO SERIAL CONSOLE**
    button. A pop-up window will open.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接到串行控制台**按钮进入串行控制台。将弹出一个窗口。
- en: Note
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The serial console allows users to conveniently access the serial port of a
    VM instance directly in GCP. If the serial console is unresponsive, feel free
    to reboot or restart the VM instance, as this can often resolve the issue and
    restore functionality for troubleshooting and diagnostics. You may also run the
    **clear** command in case you need to clear the contents of the terminal screen.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 串行控制台允许用户直接在GCP中方便地访问虚拟机实例的串行端口。如果串行控制台无响应，可以尝试重新启动虚拟机实例，这通常能解决问题并恢复故障排除和诊断功能。如果需要清除终端屏幕内容，也可以运行**clear**命令。
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. You should see a **root@kali:~#** prompt where
    you can run **bash** commands as the **root** user.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在弹出窗口中看到空白页面，点击空白页面内并按下*回车*键。你应该会看到**root@kali:~#**提示符，可以以**root**用户身份运行**bash**命令。
- en: 'Now, let’s run the following block of code (after **root@kali:~#**) to set
    up access to our **kali** user:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令块（在**root@kali:~#**后）来设置对**kali**用户的访问：
- en: '[PRE82]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we first check if the **kali** user exists and create it if it doesn’t
    exist. It then sets up the SSH directory for the user, ensuring proper ownership
    and permissions.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查**kali**用户是否存在，如果不存在则创建它。然后为该用户设置SSH目录，确保正确的所有权和权限。
- en: 'Run the following commands (one line at a time) to write the value of the **$SSH_KEY**
    variable to the **authorized_keys** file located in the **.ssh** directory of
    the user’s home directory. After that, use the **cat** command to display the
    contents of the **authorized_keys** file to check if the changes have been applied
    correctly:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令（每次一行）将**$SSH_KEY**变量的值写入位于用户主目录下**.ssh**目录中的**authorized_keys**文件。之后，使用**cat**命令显示**authorized_keys**文件的内容，检查更改是否已正确应用：
- en: '[PRE83]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Make sure to replace **<SSH PUBLIC KEY VALUE>** with the output of the **cat
    kali-ssh.pub** command we ran in a previous step.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保用我们之前运行的**cat kali-ssh.pub**命令的输出替换**<SSH PUBLIC KEY VALUE>**。
- en: Note
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The value of the **$SSH_KEY** variable should follow a format resembling **ssh-rsa
    ...** **kali**.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**$SSH_KEY**变量的值应遵循类似**ssh-rsa ...** **kali**的格式。'
- en: 'Next, let’s run the following commands (one line at a time) to change the ownership
    of the **authorized_keys** file to the **$NEW_USER** user, set the file permissions
    to **600** for restricted access, and then restart the SSH service:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行以下命令（每次一行）将**authorized_keys**文件的所有权更改为**$NEW_USER**用户，将文件权限设置为**600**以限制访问，然后重新启动SSH服务：
- en: '[PRE84]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run the following commands to (1) add the **$NEW_USER** user to the **sudo**
    group, (2) grant the user passwordless sudo privileges by creating a configuration
    file in the **/etc/sudoers.d/** directory, and (3) set appropriate permissions
    for the configuration file:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：（1）将**$NEW_USER**用户添加到**sudo**组，（2）通过在**/etc/sudoers.d/**目录中创建配置文件授予用户无密码的sudo权限，（3）为配置文件设置适当的权限：
- en: '[PRE85]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, let’s switch to the **kali** user account and then navigate to the home
    folder:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们切换到**kali**用户帐户，然后导航到主文件夹：
- en: '[PRE86]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let’s update the package lists and then install the default set of packages
    for Kali Linux using the following commands:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新软件包列表，然后使用以下命令安装Kali Linux的默认软件包集：
- en: '[PRE87]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This step may take 15-20 minutes to complete. Feel free to grab a cup of coffee
    or tea while waiting! In case you’re looking for a script that automates *most*
    of the work done in this section, you may check the following link: [https://bit.ly/kali-desktop-setup](https://bit.ly/kali-desktop-setup).
    In this chapter, we have set up the attacker VM instance manually so that we have
    a better understanding and appreciation of what’s happening behind the scenes
    while running the installation commands. In the next chapter, we will use an automated
    script to set up the attacker VM instance to speed things up a bit.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能需要15-20分钟来完成。在等待的过程中，不妨喝一杯咖啡或茶！如果你想要一个自动化执行此部分大多数工作的脚本，可以查看以下链接：[https://bit.ly/kali-desktop-setup](https://bit.ly/kali-desktop-setup)。在本章中，我们手动设置了攻击者虚拟机实例，这样可以更好地理解并欣赏在运行安装命令时，幕后发生的事情。在下一章中，我们将使用自动化脚本来设置攻击者虚拟机实例，从而加快速度。
- en: 'Next, download the **xfce4.sh** script, make it executable using the **chmod**
    command, and then execute it using the following commands:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载**xfce4.sh**脚本，使用**chmod**命令使其可执行，然后使用以下命令执行它：
- en: '[PRE88]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This step may take around 10 minutes to complete. Feel free to grab a cup of
    coffee or tea while waiting!
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能需要大约10分钟来完成。在等待的过程中，不妨喝一杯咖啡或茶！
- en: 'Now, let’s enable and start the **xrdp** service:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们启用并启动**xrdp**服务：
- en: '[PRE89]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let’s also set the password for the **kali** user:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也为**kali**用户设置密码：
- en: '[PRE90]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, let’s install **TigerVNC** and **noVNC**:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们安装**TigerVNC**和**noVNC**：
- en: '[PRE91]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This step may take a minute or two to complete. Feel free to run the **clear**
    command to clear the screen (after the previous block of commands has finished
    running).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能需要一到两分钟来完成。完成之前的命令块后，可以随时运行**clear**命令来清除屏幕。
- en: 'Run the following commands to check if the VNC server and the noVNC proxy have
    been installed successfully:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令检查VNC服务器和noVNC代理是否已成功安装：
- en: '[PRE92]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let’s run the following command to edit the **cron table** (**crontab**) for
    the **kali** user:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行以下命令编辑**kali**用户的**cron表**（**crontab**）：
- en: '[PRE93]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we specified that we want to use **Vim** to edit the crontab configuration.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们指定希望使用**Vim**来编辑 crontab 配置。
- en: Note
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case you are wondering what the **crontab** is used for, it is simply a time-based
    job scheduler often used by users when performing administrative and scheduled
    (often repetitive) tasks. Each user on the system can have their own crontab file
    containing a list of scheduled tasks. Users can create, edit, and manage their
    crontab files using the **crontab** command, which provides options to view, modify,
    or remove entries.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想**crontab**是用来做什么的，它其实是一个基于时间的作业调度器，通常在执行管理任务和定期（通常是重复性的）任务时被用户使用。系统中的每个用户都可以拥有自己的
    crontab 文件，里面包含一系列的计划任务。用户可以使用**crontab**命令来创建、编辑和管理他们的 crontab 文件，该命令提供了查看、修改或删除条目的选项。
- en: Press *Shift* + *g* to jump to the last line of the file. Press *o* (lowercase
    letter “o”) to open a new line below the current line and enter **insert mode**.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Shift* + *g*跳转到文件的最后一行。按下*o*（小写字母“o”）以在当前行下方打开一行并进入**插入模式**。
- en: 'Add the following two entries to the end of the file:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两条条目添加到文件的末尾：
- en: '[PRE94]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: By including these crontab entries prefixed with **@reboot**, the VNC server
    and the noVNC proxy will automatically start upon each system reboot. This will
    (1) ensure persistent access to the graphical desktop environment and (2) enable
    remote connections via the web-based noVNC client. Here, you can see that we’ve
    configured **vncserver** and **novnc_proxy** to run after 60 seconds to wait for
    the system processes to be ready before these are run.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在这些 crontab 条目前添加**@reboot**，VNC 服务器和 noVNC 代理将在每次系统重启时自动启动。这将确保（1）保持对图形桌面环境的持久访问，并（2）通过基于
    Web 的 noVNC 客户端启用远程连接。这里，你可以看到我们已经配置了**vncserver**和**novnc_proxy**，它们将在 60 秒后启动，以便等待系统进程准备就绪。
- en: Note
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that there are other alternative methods available for running
    the VNC server and the noVNC proxy during system boot. These include using **init**
    scripts, **systemd** units, or startup configuration files, depending on the specific
    operating system and configuration preferences.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，系统启动时运行 VNC 服务器和 noVNC 代理有其他替代方法可用。这些方法包括使用**init**脚本、**systemd**单元或启动配置文件，具体取决于操作系统和配置偏好。
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes to the crontab configuration and then exit
    Vim as well. Feel free to use **crontab -l** to verify that the scheduled tasks
    and commands have been correctly configured in the cron job scheduler of the VM
    instance.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Esc*键切换到**正常模式**。输入**:wq!**，然后按*Enter*键。这将保存对 crontab 配置所做的更改，并退出 Vim 编辑器。你可以随时使用**crontab
    -l**命令来验证计划任务和命令是否已正确配置在虚拟机实例的 cron 作业调度器中。
- en: Close the serial console pop-up window.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭串口控制台弹出窗口。
- en: In the **VM details** page, locate and click the **RESET** button to restart
    the instance. Wait for about 3-5 minutes for the instance to reboot.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**虚拟机详情**页面，找到并点击**重置**按钮以重新启动实例。等待大约 3-5 分钟，直到实例重启完成。
- en: Note
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can safely close the Cloud Shell editor for now, as we won’t lose any files
    or progress (closing the editor does not delete or remove any files). We can open
    it again later when we need to edit files or run terminal commands.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安全地关闭 Cloud Shell 编辑器，因为我们不会丢失任何文件或进度（关闭编辑器并不会删除或移除任何文件）。当我们需要编辑文件或运行终端命令时，可以稍后重新打开它。
- en: Part 3 of 3 – Validating our setup
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分，共 3 部分 – 验证我们的设置
- en: 'Before automating our current setup, we first need to validate that the VM
    instance we manually set up and configured is working. To do so, proceed as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化我们当前的设置之前，我们首先需要验证我们手动设置并配置的虚拟机实例是否正常工作。为此，按照以下步骤操作：
- en: In the **Instance details** page of our Kali Linux VM instance (**kali-00**),
    scroll down and locate the **External IP address** value (under **Network interfaces**)
    and copy it to your clipboard.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Kali Linux 虚拟机实例（**kali-00**）的**实例详情**页面，向下滚动并找到**外部 IP 地址**值（在**网络接口**下），并将其复制到剪贴板中。
- en: 'Open a new browser tab and access the web-based noVNC client using the following
    URL:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器标签页，使用以下 URL 访问基于 Web 的 noVNC 客户端：
- en: '[PRE95]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **External
    IP address** value copied to the clipboard in an earlier step.
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<ATTACKER VM PUBLIC IP ADDRESS>**替换为在之前步骤中复制到剪贴板的**外部 IP 地址**值。
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.31*:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会打开一个欢迎屏幕，并显示一个**连接**按钮，类似于我们在*图 4.31*中看到的：
- en: '![](image/B19755_04_31.jpg)'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_31.jpg)'
- en: Figure 4.31 – noVNC welcome screen
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.31 – noVNC欢迎界面
- en: Important note
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply open the Cloud Shell editor
    and update the **terraform.tfvars** file. Once the **terraform.tfvars** file has
    been updated with the new IP address of your local machine, run the **terraform
    apply** command again to update the firewall rule to whitelist your new IP address.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现无法访问欢迎界面，可能是你的IP地址已经发生变化。只需打开Cloud Shell编辑器并更新**terraform.tfvars**文件。更新**terraform.tfvars**文件以包含本地机器的新IP地址后，再次运行**terraform
    apply**命令，以更新防火墙规则，允许你的新IP地址通过。
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.32*:![](image/B19755_04_32.jpg)
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接**按钮，然后使用密码**kali123**（或使用你在早期步骤中指定的密码）访问桌面环境，类似于我们在*图 4.32*中看到的那样：![](image/B19755_04_32.jpg)
- en: Figure 4.32 – Accessing the Kali Linux desktop/GUI environment in the browser
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.32 – 在浏览器中访问Kali Linux桌面/GUI环境
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们能够访问桌面环境，我们就能执行各种任务，并访问Kali Linux中提供的各种工具和实用程序（类似于我们在本地机器上使用的方式）。
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: In case you encounter a **Failed to connect to server** error, wait for about
    2-3 minutes before trying to access the desktop/GUI environment again.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到**无法连接到服务器**的错误，请等待大约2-3分钟后，再尝试访问桌面/GUI环境。
- en: Open the Firefox browser by clicking on the **Firefox** icon located at the
    upper-left corner of the desktop environment. Navigate to **http://<PRIVATE IP
    OF TARGET VM>** to open the OWASP Juice Shop vulnerable web application:![](image/B19755_04_33.jpg)
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击桌面环境左上角的**Firefox**图标打开Firefox浏览器，导航至**http://<PRIVATE IP OF TARGET VM>**，以打开OWASP
    Juice Shop易受攻击的Web应用程序：![](image/B19755_04_33.jpg)
- en: Figure 4.33 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.33 – 从攻击者实例中的浏览器访问目标实例
- en: Please remember to use the private IP address of the target VM instance instead
    of the public IP address, as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住使用目标虚拟机实例的私有IP地址，而不是公共IP地址，因为我们的**VPC 01**网络已经特别配置为仅允许来自**VPC 02**内资源的流量。
- en: Note
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: Now that we have verified that our setup is working correctly, we can close
    the browser tab used to access the Kali Linux desktop environment. We’ll resume
    the exploration of the OWASP Juice Shop application in the *Simulating penetration
    testing in the isolated network environment* section of this chapter.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们的设置正常工作，我们可以关闭用于访问Kali Linux桌面环境的浏览器标签。我们将在本章的*在隔离网络环境中模拟渗透测试*部分继续探索OWASP
    Juice Shop应用程序。
- en: 'It is important to note that we can also access the desktop environment of
    the attacker instance from our local machine using an **SSH tunnel**. *Remember
    the private key file we generated earlier in this chapter?* Once we’ve downloaded
    this key file to our local machine, we simply need to (1) open a new terminal
    tab in our local machine, (2) navigate to the directory containing the private
    key file, and (3) run the following command to create an SSH tunnel between our
    local machine and the attacker VM instance:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们还可以通过**SSH隧道**从本地机器访问攻击者实例的桌面环境。*记得我们在本章早些时候生成的私钥文件吗？* 一旦我们将此密钥文件下载到本地机器上，我们只需执行以下步骤：（1）在本地机器中打开一个新的终端标签，（2）导航到包含私钥文件的目录，（3）运行以下命令，在本地机器和攻击者虚拟机实例之间创建一个SSH隧道：
- en: '[PRE96]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Once the SSH tunnel has been set up, we can access the same desktop environment
    through **http://localhost:8081/vnc.html** (instead of using the public IP address
    of the attacker VM instance). If you are wondering what an SSH tunnel is, it is
    simply a secure encrypted connection used to access services and applications
    running inside a remote server. SSH tunnels leverage the encryption and authentication
    capabilities of SSH to secure data transmitted over the tunnel. With an SSH tunnel,
    we can securely access the desktop environment of the attack VM instance.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SSH隧道建立，我们就可以通过**http://localhost:8081/vnc.html**访问相同的桌面环境（而不是使用攻击者VM实例的公网IP地址）。如果你在想SSH隧道是什么，它其实就是一种用于访问远程服务器中运行的服务和应用的安全加密连接。SSH隧道利用SSH的加密和身份验证能力来保护通过隧道传输的数据。有了SSH隧道，我们就可以安全地访问攻击者VM实例的桌面环境。
- en: Note
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll leave this to you as an exercise. In addition to this, feel free to check
    [https://github.com/novnc/noVNC/wiki/Advanced-usage](https://github.com/novnc/noVNC/wiki/Advanced-usage)
    in case you want to further upgrade our setup.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这部分留给你作为练习。如果你想进一步升级我们的配置，随时可以查看[https://github.com/novnc/noVNC/wiki/Advanced-usage](https://github.com/novnc/noVNC/wiki/Advanced-usage)。
- en: Leveraging Terraform to automatically set up the attacker VM instance
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Terraform自动设置攻击者VM实例
- en: The previous section primarily focused on setting up the attacker VM instance
    manually. This was necessary because we will utilize this VM instance (**kali-00**)
    as a reference to create a **golden image**. By creating a golden image, we can
    capture the desired configuration and settings of the VM instance, making it easier
    to replicate and deploy similar instances with the same specifications in the
    future.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 上一部分主要集中在手动设置攻击者VM实例上。之所以需要这样做，是因为我们将利用这个VM实例（**kali-00**）作为参考来创建**黄金镜像**。通过创建黄金镜像，我们可以捕获VM实例的所需配置和设置，从而在未来更容易复制和部署具有相同规格的类似实例。
- en: Note that another approach when automating the process of setting up VM instances
    involves the usage of IaC tools such as Ansible to set up *what’s inside the VM
    instance* (in addition to the usage of Terraform for setting up, configuring,
    and managing the cloud resources). When preparing VM instances, it is important
    that we have a good understanding of the distinct advantages and differences of
    each approach. Golden images are well suited to scenarios where a predefined and
    static environment is required since they can capture the desired configuration,
    settings, and software of a fully configured VM instance. By using golden images
    as templates, new instances can be quickly created with the exact same specifications—ensuring
    consistency along with reducing the time and effort required for manual configuration.
    On the other hand, using IaC tools such as Ansible (in addition to Terraform)
    allows for dynamic configuration changes, making them suitable for environments
    that require frequent updates and configuration changes.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，另一种自动化设置VM实例的方式是使用基础设施即代码（IaC）工具，如Ansible，来设置*VM实例内部的内容*（除了使用Terraform来设置、配置和管理云资源之外）。在准备VM实例时，了解每种方法的独特优势和差异非常重要。黄金镜像非常适合需要预定义和静态环境的场景，因为它们能够捕获完全配置的VM实例的所需配置、设置和软件。通过使用黄金镜像作为模板，可以快速创建具有完全相同规格的新实例—确保一致性并减少手动配置所需的时间和精力。另一方面，使用IaC工具（如Ansible）与Terraform结合使用，可以进行动态配置更改，使其适用于需要频繁更新和配置更改的环境。
- en: Note
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: That said, the most suitable approach really depends on the specific needs of
    the environment and the level of customization required, along with the desired
    level of automation and flexibility in managing VM instances.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，最合适的方法实际上取决于环境的具体需求、所需的定制程度，以及管理VM实例时所期望的自动化和灵活性水平。
- en: 'We’ll divide this section into three parts, as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这部分分为三部分，具体如下：
- en: '*Part 1 of 3 – Creating a* *golden image*'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1部分，共3部分 – 创建一个* *黄金镜像*'
- en: '*Part 2 of 3 – Using Terraform to prepare the attacker* *VM instance*'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2部分，共3部分 – 使用Terraform准备攻击者* *VM实例*'
- en: '*Part 3 of 3 – Accessing the Kali Linux* *desktop environment*'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3部分，共3部分 – 访问Kali Linux* *桌面环境*'
- en: With these points in mind, let’s proceed with automating the process of setting
    up our attacker VM instance!
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些要点，我们继续自动化设置攻击者VM实例的过程吧！
- en: Part 1 of 3 – Creating a golden image
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分，共3部分 – 创建黄金镜像
- en: 'Follow the next steps:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results. Here, we’ll find
    a list of VM instances in our GCP account.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在搜索框中输入**计算引擎**，并从搜索结果中选择**计算引擎**，导航到**虚拟机实例**页面。在这里，我们可以找到GCP账户中的虚拟机实例列表。
- en: Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our attacker VM instance (**kali-00**).
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**名称**列下的链接（**kali-00**），进入我们攻击者虚拟机实例（**kali-00**）的**实例详情**页面。
- en: Turn off the instance by clicking **STOP**. Confirm the action by clicking **STOP**
    in the **Stop kali-00** popup that appears.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**停止**来关闭实例。在弹出的**停止kali-00**窗口中确认此操作，点击**停止**。
- en: Note
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Take note that it may take around 3-5 minutes for the VM instance to stop. Please
    wait for the VM instance to stop before proceeding to the next set of steps.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虚拟机实例停止可能需要约3-5分钟。在继续下一步之前，请等待虚拟机实例停止。
- en: Next, click **CREATE** **MACHINE IMAGE**.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**创建** **机器映像**。
- en: In the **Create a machine image** page, specify **kali-golden-image** for the
    **Name** value and then click the **CREATE** button.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建机器映像**页面，指定**kali-golden-image**作为**名称**值，然后点击**创建**按钮。
- en: In the **Machine images** page, wait for a few minutes for the status of the
    **kali-golden-image** image to be **Ready**.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**机器映像**页面，等待几分钟，直到**kali-golden-image**映像的状态变为**已准备好**。
- en: Note
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may click the **REFRESH** button to update the status and check if the image
    is ready for use.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击**刷新**按钮来更新状态并检查映像是否准备好使用。
- en: Navigate to the **Machine image details** page. Scroll down to the bottom of
    the page and click the **REST** link (from **Equivalent REST or** **command line**).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**机器映像详情**页面。向下滚动页面到底部，点击**REST**链接（来自**等效REST或命令行**）。
- en: 'Locate and copy the **selfLink** value, as highlighted in *Figure 4**.34*:'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定位并复制**selfLink**值，如*图4.34*所示：
- en: '![](image/B19755_04_34.jpg)'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_34.jpg)'
- en: Figure 4.34 – Locating the selfLink value of the machine image
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.34 – 定位机器映像的selfLink值
- en: 'Store this value in a text editor on your local machine. The **selfLink** value
    should have a format similar to the following:'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此值保存在本地机器的文本编辑器中。**selfLink**值的格式应类似于以下内容：
- en: '[PRE97]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Keep in mind that you’ll get a different **<PROJECT ID>** value (so do not copy
    and paste exactly what’s in the screenshot).
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，你会得到一个不同的**<项目ID>**值（因此不要直接复制截图中的内容）。
- en: Note
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that further upgrades can still be implemented on top of the image we prepared
    in the previous set of steps. In the meantime, this should do the trick for now.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，基于我们在前一组步骤中准备的映像，仍然可以进行进一步的升级。与此同时，这一过程应该足够了。
- en: Navigate back to the **VM instances** page. Click the link (**kali-00**) under
    the **Name** column to navigate to the **Instance details** page of our attacker
    VM instance (**kali-00**).
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**虚拟机实例**页面。点击**名称**列下的链接（**kali-00**），进入我们攻击者虚拟机实例（**kali-00**）的**实例详情**页面。
- en: Delete the Kali Linux instance (named **kali-00**) we created manually using
    the **DELETE** button in the **VM instances** page. Confirm the deletion by clicking
    **DELETE** in the **Delete** **kali-00** popup.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**删除**按钮在**虚拟机实例**页面删除我们手动创建的Kali Linux实例（命名为**kali-00**）。在弹出的**删除** **kali-00**窗口中确认删除，点击**删除**。
- en: Part 2 of 3 – Using Terraform to prepare the attacker VM instance
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分 共3部分 – 使用Terraform准备攻击者虚拟机实例
- en: 'Follow the next steps:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Open the Cloud Shell terminal. In case you closed it while working on an earlier
    step, simply click the **Activate Cloud Shell** button on the upper right-hand
    corner of the page (as highlighted in *Figure 4**.35*):![](image/B19755_04_35.jpg)
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Cloud Shell终端。如果你在之前的步骤中关闭了它，只需点击页面右上角的**激活Cloud Shell**按钮（如*图4.35*所示）：![](image/B19755_04_35.jpg)
- en: Figure 4.35 – Activating Cloud Shell
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.35 – 激活Cloud Shell
- en: This should open a terminal where we can run command-line commands.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会打开一个终端，我们可以在其中运行命令行命令。
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell Terminal pane. If you can’t see the terminal, open the **Terminal**
    menu of the Cloud Shell editor and then select **New Terminal** from the list
    of options.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Cloud Shell终端面板右上角的**打开编辑器**按钮。如果你看不到终端，请打开Cloud Shell编辑器的**终端**菜单，然后从选项列表中选择**新建终端**。
- en: 'In the Cloud Shell terminal (after the **$** sign), navigate to the **~/pentest_lab/attacker_vm**
    directory by running the following commands (one line at a time):'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cloud Shell终端（**$**符号后），通过运行以下命令（逐行执行）导航到**~/pentest_lab/attacker_vm**目录：
- en: '[PRE98]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Run the following commands (one line at a time) to create the files we’ll need
    in our **attacker_vm** module:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令（逐行执行）以创建我们在**attacker_vm**模块中需要的文件：
- en: '[PRE99]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, we are creating three empty files inside the **~/pentest_lab/attacker_vm**
    directory—(1) a **main.tf** file for defining the main configuration and resources,
    (2) a **variables.tf** file for declaring and managing variables used in the configuration,
    and (3) an **outputs.tf** file for specifying outputs or values that will be exposed
    after applying the configuration.
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们在**~/pentest_lab/attacker_vm**目录中创建了三个空文件——（1）用于定义主配置和资源的**main.tf**文件，（2）用于声明和管理配置中使用的变量的**variables.tf**文件，以及（3）用于在应用配置后指定将公开的输出或值的**outputs.tf**文件。
- en: 'Next, open the **attacker_vm/variables.tf** file in the editor and add the
    following blocks of code to define **subnet_02**, **kali_machine_image**, and
    **my_public_ssh_key** variables for our **attacker_vm** module:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在编辑器中打开**attacker_vm/variables.tf**文件，并添加以下代码块来定义我们的**attacker_vm**模块的**subnet_02**、**kali_machine_image**和**my_public_ssh_key**变量：
- en: '[PRE100]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Make sure to replace **<INSERT IMAGE>** with the **selfLink** value of the machine
    image from the previous section.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保用上一节中机器映像的**selfLink**值替换**<INSERT IMAGE>**。
- en: Note
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to save the **attacker_vm/variables.tf** file before proceeding
    to the next step.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一步之前，请不要忘记保存**attacker_vm/variables.tf**文件。
- en: 'Open the **attacker_vm/main.tf** file in the editor and add the following blocks
    of code to define and configure the attacker VM instance:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**attacker_vm/main.tf**文件，并添加以下代码块以定义和配置攻击者VM实例：
- en: '[PRE101]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, we’re using **google_compute_instance_from_machine_image** instead of
    **google_compute_instance** when defining the attacker VM resource since we want
    to create the VM instance from a pre-existing machine image. This allows us to
    quickly provision an instance with the desired configuration and software setup,
    such as using a Kali Linux image for the attacker VM. When typing these blocks
    of code, make sure that **{** is after **"kali_vm"** (same line instead of next
    line).
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义攻击者VM资源时，我们使用**google_compute_instance_from_machine_image**而不是**google_compute_instance**，因为我们希望从预先存在的机器映像创建VM实例。这允许我们快速配置具有所需配置和软件设置的实例，例如使用Kali
    Linux镜像作为攻击者VM。在键入这些代码块时，请确保**{**在**"kali_vm"**之后（同一行而不是下一行）。
- en: Note
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to save the **attacker_vm/main.tf** file before proceeding to
    the next step.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一步之前，请不要忘记保存**attacker_vm/main.tf**文件。
- en: 'Open the **attacker_vm/outputs.tf** file in the editor and add the following
    lines of code to define the following outputs: (1) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (2) **attacker_vm_access**—URL used
    to access the desktop environment from the browser:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开**attacker_vm/outputs.tf**文件，并添加以下代码行以定义以下输出：（1）**attacker_vm_public_ip**——攻击者VM实例的公共IP地址值，（2）**attacker_vm_access**——用于从浏览器访问桌面环境的URL：
- en: '[PRE102]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Make sure to save the **attacker_vm/outputs.tf** file before proceeding to the
    next step.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进入下一步之前，请确保保存**attacker_vm/outputs.tf**文件。
- en: 'Navigate back to the **~/pentest_lab** project folder by running the following
    command:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以返回到**~/pentest_lab**项目文件夹：
- en: '[PRE103]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory (since there are changes to the **attacker_vm** module code):'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用**terraform init**命令重新初始化Terraform工作目录（因为**attacker_vm**模块代码有更改）：
- en: '[PRE104]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行**terraform plan**以预览Terraform将执行的更改：
- en: '[PRE105]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This should give us **Missing required argument — The argument “subnet_02” is
    required, but no definition was found** and **Missing required argument — The
    argument “my_public_ssh_key ” is required, but no definition was found** error
    messages since we have not provided any values for the **subnet_02** and **my_public_ssh_key**
    arguments while declaring the **attacker_vm** module.
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会导致我们出现**Missing required argument — The argument “subnet_02” is required,
    but no definition was found**和**Missing required argument — The argument “my_public_ssh_key”
    is required, but no definition was found**错误消息，因为我们在声明**attacker_vm**模块时没有为**subnet_02**和**my_public_ssh_key**参数提供任何值。
- en: Note
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined **subnet_02** and **my_public_ssh_key** variables in the
    **attacker_vm/variables.tf** file in an earlier step.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么突然出现了这个问题，重要的是要记住我们在之前的步骤中在**attacker_vm/variables.tf**文件中定义了**subnet_02**和**my_public_ssh_key**变量。
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_02** and **my_public_ssh_key** arguments when
    declaring the **attacker_vm** module.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决上一步遇到的问题，我们需要确保在声明**attacker_vm**模块时为**subnet_02**和**my_public_ssh_key**参数提供一个值。
- en: 'Using *Figure 4**.36* as a reference, we will resolve the issue by passing
    the **subnet_02** output value from the **secure_network** module to the **subnet_02**
    input variable of the **attacker_vm** module:'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*图4**.36*作为参考，我们将通过将**secure_network**模块的**subnet_02**输出值传递给**attacker_vm**模块的**subnet_02**输入变量来解决问题：
- en: '![](image/B19755_04_36.jpg)'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_36.jpg)'
- en: Figure 4.36 – Providing a value for the subnet_02 and my_public_ssh_key arguments
    when declaring the attacker_vm module
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.36 – 在声明attacker_vm模块时为subnet_02和my_public_ssh_key参数提供一个值
- en: 'At the same time, we will pass the **my_public_ssh_key** variable value to
    the **my_public_ssh_key** input variable of the **attacker_vm** module. Now that
    we have a better idea of how we’ll solve the issue, let’s locate the following
    block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与此同时，我们将**my_public_ssh_key**变量值传递给**attacker_vm**模块的**my_public_ssh_key**输入变量。现在我们对如何解决问题有了更好的理解，让我们在我们的**main.tf**文件（**~/pentest_lab/main.tf**）中找到以下代码块：
- en: '[PRE106]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let’s replace this with the following block of code:'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用以下代码块替换这段代码：
- en: '[PRE107]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_02**)
    to the **subnet_02** input variable of the **attacker_vm** module. In addition
    to this, we are passing the **my_public_ssh_key** variable value to the **my_public_ssh_key**
    input variable of the **attacker_vm** module.
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将**secure_network**模块（**module.secure_network.subnet_02**）的输出值传递给**attacker_vm**模块的**subnet_02**输入变量。除此之外，我们还将**my_public_ssh_key**变量值传递给**attacker_vm**模块的**my_public_ssh_key**输入变量。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行**terraform plan**来预览Terraform将执行的更改：
- en: '[PRE108]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This time, we should not encounter a **Missing required argument** error message.
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们不应遇到**Missing required argument**错误消息。
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**terraform apply**命令来实施更改：
- en: '[PRE109]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一两分钟以完成此步骤。在等待时，可以随意喝杯咖啡或茶！
- en: Since we want to display the public IP address of the attacker VM instance along
    with the Kali Linux desktop environment access URL as output, we will reference
    and utilize the outputs from the **attacker_vm** module (as well as the outputs
    from the **target_vm** module) in the root module **outputs.tf** file (similar
    to what we have in *Figure 4**.37*):![](image/B19755_04_37.jpg)
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望显示攻击者VM实例的公共IP地址以及Kali Linux桌面环境访问URL作为输出，我们将在根模块**outputs.tf**文件中引用和利用**attacker_vm**模块（以及**target_vm**模块）的输出（类似于*图4**.37*中所示）：![](image/B19755_04_37.jpg)
- en: Figure 4.37 – Utilizing the outputs from the attacker_vm and target_vm modules
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.37 – 利用attacker_vm和target_vm模块的输出
- en: 'Using *Figure 4**.37* as a reference, we will update the **outputs.tf** file
    with the following block of code:'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*图4**.37*作为参考，我们将使用以下代码块更新**outputs.tf**文件：
- en: '[PRE110]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here, we’re defining the following outputs: (1) **target_vm_username** and
    **target_vm_password**—username and password used to access the target VM instance
    using the serial console, (2) **target_vm_public_ip** and **target_vm_private_ip**—public
    and private IP address values of the target VM instance, (3) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (4) **attacker_vm_access**—URL used
    to access the desktop environment from the browser.'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了以下输出：(1)**target_vm_username**和**target_vm_password**—用于通过串行控制台访问目标VM实例的用户名和密码，(2)**target_vm_public_ip**和**target_vm_private_ip**—目标VM实例的公共和私有IP地址值，(3)**attacker_vm_public_ip**—攻击者VM实例的公共IP地址值，(4)**attacker_vm_access**—用于从浏览器访问桌面环境的URL。
- en: Note
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure not to duplicate the output blocks defined in the **outputs.tf** file.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要重复定义**outputs.tf**文件中定义的输出块。
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行**terraform plan**来预览 Terraform 将执行的更改：
- en: '[PRE111]'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用**terraform apply**命令来实施更改：
- en: '[PRE112]'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Wait for a minute or two for this step to complete. This should yield the following
    output:'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待一两分钟，直到此步骤完成。这应该产生以下输出：
- en: '[PRE113]'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Store and save the **attacker_vm_public_ip** output value in a text editor as
    we will use this in the succeeding steps in this chapter.
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将**attacker_vm_public_ip**输出值存储并保存在文本编辑器中，因为我们将在本章的后续步骤中使用它。
- en: Part 3 of 3 – Accessing the Kali Linux desktop environment
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分 – 访问 Kali Linux 桌面环境
- en: 'Follow the next steps:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: At this point, we should have the following set up already:![](image/B19755_04_38.jpg)
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们应该已经设置好以下内容：![](image/B19755_04_38.jpg)
- en: Figure 4.38 – Current setup deployed and configured in GCP
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.38 – 部署并配置在 GCP 中的当前设置
- en: Here, we have the IP address of our local machine whitelisted to access the
    attacker VM instance in **VPC 02** via ports **22** and **8081**.
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经将本地机器的 IP 地址列入白名单，以通过端口**22**和**8081**访问**VPC 02**中的攻击者 VM 实例。
- en: Note
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While we can further upgrade this setup to include additional security mechanisms
    (such as establishing a VPN connection), this should do the trick for now.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以进一步升级此设置以包括其他安全机制（例如建立 VPN 连接），但目前这应该足够了。
- en: 'Now, let’s open a new browser tab and access the desktop environment using
    the following URL:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个新的浏览器标签，并使用以下网址访问桌面环境：
- en: '[PRE114]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **attacker_vm_public_ip**
    output value after running the **terraform apply** command in an earlier step.
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保在运行**terraform apply**命令后，用**<攻击者 VM 公共 IP 地址>**替换**attacker_vm_public_ip**输出值。
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.39*:'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该打开一个带有**连接**按钮的欢迎界面，类似于我们在*图 4**.39*中看到的：
- en: '![](image/B19755_04_39.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_39.jpg)'
- en: Figure 4.39 – noVNC welcome screen
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – noVNC 欢迎界面
- en: Important note
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply update the **terraform.tfvars**
    file, then run the **terraform apply** command again to update the firewall rule
    to whitelist your new IP address.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己无法访问欢迎界面，可能是您的 IP 地址已经更改。只需更新**terraform.tfvars**文件，然后再次运行**terraform
    apply**命令以更新防火墙规则以允许您的新 IP 地址。
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.40*:![](image/B19755_04_32.jpg)
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接**按钮，然后使用密码**kali123**（或使用您在早期步骤中指定的密码）访问桌面环境，类似于我们在*图 4**.40*中看到的：![](image/B19755_04_32.jpg)
- en: Figure 4.40 – Accessing the Kali Linux desktop/GUI environment in the browser
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.40 – 在浏览器中访问 Kali Linux 桌面/GUI 环境
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们能够访问桌面环境，我们应该能够执行各种任务，并访问 Kali Linux 中提供的广泛工具和实用程序（类似于我们在本地机器上使用的方式）。
- en: Note
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that you may use the **Connectivity Tests** diagnostic tool to validate
    network connectivity. For more information, feel free to check the following link:
    [https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests).'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用**连接性测试**诊断工具验证网络连接。更多信息，请查看以下链接：[https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests)。
- en: Simulating penetration testing in an isolated network environment
  id: totrans-721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在隔离的网络环境中模拟渗透测试
- en: 'Given that our lab environment in GCP has been set up, we can now proceed with
    having a penetration testing simulation to verify that everything has been configured
    correctly. Of course, we will work with a simplified penetration testing process,
    as our primary goal is to assess whether the penetration testing lab environment
    has been set up and configured correctly:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们在 GCP 中设置了实验环境，我们现在可以继续进行渗透测试模拟，以验证一切是否已正确配置。当然，我们将使用简化的渗透测试流程，因为我们的主要目标是评估渗透测试实验室环境是否已正确设置和配置：
- en: '![](image/B19755_04_41.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B19755_04_41.jpg)'
- en: Figure 4.41 – Penetration testing simulation
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.41 – 渗透测试模拟
- en: Our simulation will start with a port scan to check the open ports of the target
    VM instance (**vm-target**). After identifying that port **80** is open, we will
    use a web browser to navigate through the pages and explore the functionality
    of the vulnerable web application (running inside a container) accessible on the
    said port. We’ll end the simulation right after we have used an SQL Injection
    attack to gain administrator access and successfully signed in using an administrator’s
    account.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟将从端口扫描开始，以检查目标虚拟机实例（**vm-target**）的开放端口。在确认端口**80**是开放的后，我们将使用网页浏览器浏览页面，并探索可通过该端口访问的脆弱网页应用程序（运行在容器内部）的功能。我们将在使用SQL注入攻击获得管理员访问权限并成功使用管理员账户登录后结束模拟。
- en: Important note
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is unethical and illegal to attack cloud resources owned by another user
    or company. Before proceeding, make sure to read the *Examining considerations
    when building penetration testing lab environments in the cloud* section of *[Chapter
    1](B19755_01.xhtml)*, *Getting Started with Penetration Testing Labs in the Cloud*,
    since we will be simulating the attack process to validate if misconfigurations
    and vulnerabilities present in applications and services running in the target
    VM instance are exploitable.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击他人或公司拥有的云资源是非道德且非法的。在继续之前，请务必阅读*《云环境中构建渗透测试实验室时的考虑事项》*部分，这部分内容位于*《云中的渗透测试实验室入门》*一书的*第1章*中（*[Chapter
    1](B19755_01.xhtml)*），因为我们将模拟攻击过程，以验证目标虚拟机实例中运行的应用程序和服务中的配置错误和漏洞是否可以被利用。
- en: 'That said, let’s start the penetration testing simulation. Proceed as follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始渗透测试模拟。按以下步骤操作：
- en: Continuing where we left off in the previous section, let’s access the Terminal
    application by selecting the **Terminal** icon located in the upper-left corner
    of the Kali Linux desktop interface.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一节的基础上，让我们通过点击Kali Linux桌面界面左上角的**Terminal**图标来访问终端应用程序。
- en: 'In the terminal window, run the following command (after the **$** sign) to
    store the private IP address value of the target VM instance in the **TARGET_IP**
    variable:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，运行以下命令（在**$**符号后）以将目标虚拟机实例的私有IP地址值存储在**TARGET_IP**变量中：
- en: '[PRE115]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Make sure to replace **<PRIVATE IP ADDRESS OF TARGET VM>** with the private
    IP address of the target VM instance (**vm-target**). Using a private IP ensures
    that the request stays within the intended network environment. In addition to
    this, we won’t be able to access the target VM instance using its public IP address.
    That’s because the network environment is not configured to allow outside traffic
    to reach **VPC 01** where the target VM instance is launched, even if the network
    traffic came from another cloud resource running inside **VPC 01** and **VPC 02**.
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将**<PRIVATE IP ADDRESS OF TARGET VM>**替换为目标虚拟机实例（**vm-target**）的私有IP地址。使用私有IP可以确保请求保持在预定的网络环境中。此外，我们无法使用目标虚拟机实例的公共IP地址进行访问。因为该网络环境未配置为允许外部流量到达目标虚拟机实例所在的**VPC
    01**，即便网络流量来自**VPC 01**和**VPC 02**中的其他云资源。
- en: Note
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since the CIDR range of the subnet where the target VM instance is launched
    is **10.1.0.0/20**, the target IP address of the VM instance should fall within
    the range of **10.1.0.0** to **10.1.15.255** (excluding the reserved IP addresses).
    For more information, feel free to check the following link: [https://cloud.google.com/vpc/docs/subnets](https://cloud.google.com/vpc/docs/subnets).'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标虚拟机实例所在子网的CIDR范围为**10.1.0.0/20**，因此目标虚拟机实例的IP地址应该在**10.1.0.0**到**10.1.15.255**范围内（不包括保留IP地址）。更多信息，请参考以下链接：[https://cloud.google.com/vpc/docs/subnets](https://cloud.google.com/vpc/docs/subnets)。
- en: 'Now, let’s use **nmap** to scan the top **1000** ports of the target VM instance:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用**nmap**扫描目标虚拟机实例的前**1000**个端口：
- en: '[PRE116]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This should provide information about the open ports and the corresponding
    services running on the target VM instance. It allows us to identify which ports
    are accessible and potentially vulnerable to attacks, such as SSH (port **22**)
    and HTTP (port **80**), similar to what we have in *Figure 4**.42*:'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会提供关于目标虚拟机实例上开放端口和相应服务的信息。它可以帮助我们识别哪些端口是可访问的，且可能容易受到攻击，例如SSH（端口**22**）和HTTP（端口**80**），这与*图4.42*所示相似：
- en: '![](image/B19755_04_42.jpg)'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_42.jpg)'
- en: Figure 4.42 – Results of the nmap scan
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.42 – nmap扫描结果
- en: Depending on the results of the **nmap** scan, further steps can be performed
    to evaluate the open ports and services running on the target VM instance. However,
    for now, we will skip these steps and proceed with the other aspects of the penetration
    testing process.
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据**nmap**扫描的结果，可以执行进一步的步骤来评估目标虚拟机实例上开放的端口和运行的服务。然而，暂时我们将跳过这些步骤，继续进行渗透测试过程中的其他环节。
- en: Important note
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you’re wondering what **nmap** is, it is a popular open source network scanning
    tool designed to discover hosts and services on a computer network by sending
    packets and analyzing the responses. With **nmap**, we can perform tasks such
    as **host discovery** (to identify active hosts within a network), **port scanning**
    (for identifying potential entry points or services running on specific ports),
    **OS detection** (to gather information about the operating system running on
    a target host), and **service enumeration** (to gather details about specific
    services running on open ports). In addition to these, **nmap** provides other
    advanced features and capabilities such as **script scanning** (to automate specific
    tasks), **version detection** (to identify specific software versions running
    on target systems), **stealth scanning** (to evade detection), and **timing and
    performance tuning** (to optimize scan speed and accuracy). *Powerful, right?*
    When using **nmap** in conjunction with other penetration testing tools, it is
    important to exercise extreme caution as it can generate significant network traffic
    and potentially trigger security alerts or disrupt network operations if not used
    responsibly. It is advisable to follow ethical hacking practices, obtain necessary
    permissions, and employ proper filtering mechanisms to minimize any unintended
    consequences while performing comprehensive security assessments.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想**nmap**是什么，它是一款流行的开源网络扫描工具，旨在通过发送数据包并分析响应来发现计算机网络中的主机和服务。使用**nmap**，我们可以执行如**主机发现**（识别网络中的活动主机）、**端口扫描**（识别潜在的入口点或特定端口上运行的服务）、**操作系统检测**（收集关于目标主机操作系统的信息）以及**服务枚举**（收集关于开放端口上运行的具体服务的详细信息）等任务。除了这些，**nmap**还提供了其他高级功能和能力，如**脚本扫描**（自动化特定任务）、**版本检测**（识别目标系统上运行的特定软件版本）、**隐匿扫描**（规避检测）和**时间与性能调优**（优化扫描速度和准确性）。*强大吧？*
    在将**nmap**与其他渗透测试工具结合使用时，务必小心，因为它可能会产生大量网络流量，并且如果不谨慎使用，可能触发安全警报或破坏网络操作。建议遵循道德黑客实践，获取必要的权限，并使用适当的过滤机制，以最小化执行全面安全评估时可能产生的任何意外后果。
- en: You can now close the terminal window.
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以关闭终端窗口。
- en: 'Now, let’s check what’s running on port **80** of the target VM instance. Launch
    the **Firefox** browser by selecting the **Firefox** icon located in the top-left
    corner of the desktop interface. Navigate to the following URL:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下目标虚拟机实例的**80**端口上正在运行的内容。通过选择桌面界面左上角的**Firefox**图标来启动**Firefox**浏览器。然后访问以下URL：
- en: '[PRE117]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This should open the OWASP Juice Shop vulnerable-by-design web application,
    similar to what we have in *Figure 4**.43*:'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打开OWASP Juice Shop——一个设计上脆弱的Web应用程序，类似于我们在*图 4.43*中看到的：
- en: '![](image/B19755_04_43.jpg)'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](image/B19755_04_43.jpg)'
- en: Figure 4.43 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.43 – 从攻击者实例中的浏览器访问目标实例
- en: Here, we have the OWASP Juice Shop—a vulnerable-by-design application with various
    challenges and vulnerabilities meant to help security practitioners and engineers
    understand and learn about common security flaws.
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们有OWASP Juice Shop——一个设计上脆弱的应用程序，包含各种挑战和漏洞，旨在帮助安全从业者和工程师理解和学习常见的安全缺陷。
- en: Important note
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please remember to use the private IP address of the target VM instance (instead
    of the public IP address), as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得使用目标虚拟机实例的私有IP地址（而不是公共IP地址），因为我们的**VPC 01**网络已专门配置为只允许来自**VPC 02**中的资源的流量。
- en: For the next few minutes, explore the functionality and content of the OWASP
    Juice Shop application by navigating through the different pages and features.
    Feel free to interact with the forms, buttons, and links within the application
    to understand their behavior and purpose.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几分钟，浏览OWASP Juice Shop应用程序的功能和内容，浏览不同的页面和功能。随意与应用程序中的表单、按钮和链接互动，以理解它们的行为和目的。
- en: Now, let’s navigate to the **Login** page by opening the **Account** menu located
    in the upper-left corner of the page and then clicking **Login**. This will redirect
    us to the **Login** page, similar to what we have in *Figure 4**.44*:![](image/B19755_04_44.jpg)
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过打开页面左上角的 **Account** 菜单并点击 **Login**，来导航到 **Login** 页面。这将把我们重定向到 **Login**
    页面，类似于我们在 *图 4.44* 中看到的那样：![](image/B19755_04_44.jpg)
- en: Figure 4.44 – OWASP Juice Shop Login page
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.44 – OWASP Juice Shop 登录页面
- en: Here, we have a login form allowing us to specify an email address value and
    a password value. By analyzing the login process and attempting various techniques,
    we should be able to identify and exploit any vulnerabilities present in the login
    functionality.
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个登录表单，允许我们指定电子邮件地址和值和密码值。通过分析登录过程并尝试各种技术，我们应该能够识别和利用登录功能中存在的任何漏洞。
- en: Let’s try performing an SQL Injection attack! Type **' or 1=1--** in the **Email**
    field. After that, type **123** (or any combination of characters) in the **Password**
    field. Click the **Log in** button afterward. This should give us a success notification
    similar to what we have in *Figure 4**.45*:![](image/B19755_04_45.jpg)
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试执行 SQL 注入攻击！在 **Email** 字段中输入 **' or 1=1--**。之后，在 **Password** 字段中输入 **123**（或任何字符组合）。然后点击
    **Log in** 按钮。这应该会给我们一个成功的通知，类似于我们在 *图 4.45* 中看到的那样：![](image/B19755_04_45.jpg)
- en: Figure 4.45 – Successfully solving a challenge using an SQL Injection attack
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.45 – 使用 SQL 注入攻击成功解决挑战
- en: '*Looks like we were able to successfully sign in with the administrator’s user
    account!* *What just happened?* Here, our SQL Injection attack allowed us to authenticate
    using the first record in the table containing the registered application users
    (or accounts). Luckily for us, this record happened to be an administrator account
    (**admin@juice-sh.op**) as well!'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*看起来我们成功使用管理员的用户帐户登录了！* *刚才发生了什么？* 在这里，我们的 SQL 注入攻击让我们能够使用包含已注册应用用户（或帐户）的表中的第一条记录进行身份验证。幸运的是，这条记录恰好是一个管理员帐户（**admin@juice-sh.op**）！'
- en: 'If you are wondering what an **SQL Injection attack** is, it is a technique
    where an attacker exploits vulnerabilities in an application’s input fields to
    inject malicious SQL statements. In this specific case, by entering **'' or 1=1--**
    in the **Email** field, the updated SQL query executed by the application’s backend
    might look like this:'
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在想 **SQL 注入攻击** 是什么，它是一种攻击者利用应用程序输入字段中的漏洞注入恶意 SQL 语句的技术。在这个特定案例中，通过在 **Email**
    字段中输入 **' or 1=1--**，应用程序后台执行的更新 SQL 查询可能如下所示：
- en: '[PRE118]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The injected portion causes the **WHERE** condition to always evaluate to **true**—bypassing
    the need for a valid email address and password. This allowed us to log in without
    having to provide legitimate credentials. **--** at the end is used to comment
    out the remainder of the original query to ensure that the injected code does
    not cause any syntax errors.
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注入的部分使得 **WHERE** 条件始终评估为 **true**，从而绕过了有效的电子邮件地址和密码的需求。这使得我们能够在无需提供合法凭据的情况下登录。**--**
    用于注释掉原始查询的其余部分，确保注入的代码不会导致任何语法错误。
- en: Important note
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have intentionally skipped some steps as we’ve used a simplified penetration
    testing process validating our lab configuration and setup. That said, real-world
    penetration testing involves a more comprehensive and structured approach that
    includes various techniques, tools, and methodologies to thoroughly assess the
    security of an application or a system.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意跳过了一些步骤，因为我们使用了简化的渗透测试过程来验证我们的实验室配置和设置。也就是说，真实世界中的渗透测试涉及更全面和结构化的方法，包含多种技术、工具和方法，旨在彻底评估一个应用程序或系统的安全性。
- en: While our relatively simple SQL Injection example demonstrates a common attack
    technique, it’s important to note that various other attacks and techniques can
    be performed in our penetration testing lab environment. Feel free to explore
    and experiment further with the OWASP Juice Shop application before cleaning up
    the lab environment we prepared in this chapter.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们相对简单的 SQL 注入示例展示了一个常见的攻击技术，但需要注意的是，在我们的渗透测试实验室环境中，可以执行各种其他攻击和技术。在清理本章中我们准备的实验室环境之前，欢迎进一步探索并实验
    OWASP Juice Shop 应用程序。
- en: Cleaning up
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理工作
- en: 'Cleaning up the cloud resources we created or deployed is a crucial step when
    working with vulnerable cloud applications and environments. If we don’t clean
    up and delete the resources we created right away, we might end up paying for
    unused cloud resources. In addition to this, these cloud resources may end up
    being attacked by malicious users as well. At a *minimum*, we will be paying for
    the time the following resources are running:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 清理我们创建或部署的云资源是在处理易受攻击的云应用程序和环境时的关键步骤。如果我们不立即清理并删除已创建的资源，可能最终会为未使用的云资源付费。此外，这些云资源也可能会遭到恶意用户的攻击。*至少*，我们将支付以下资源运行时的费用：
- en: 1 x **e2-medium** VM instance for the attacker machine
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x **e2-medium** 虚拟机实例，用于攻击者机器
- en: 1 x **f1-micro** VM instance for the target machine
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x **f1-micro** 虚拟机实例，用于目标机器
- en: Please be aware that there are other costs we have to take into account as well—including
    data transfer fees, storage costs for persistent data used by instances, potential
    charges for other services utilized in the account, and any applicable taxes or
    fees associated with using resources.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还需要考虑其他费用——包括数据传输费用、实例使用的持久数据存储费用、账户中其他服务的潜在费用以及与使用资源相关的任何适用税费或费用。
- en: Note
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since the overall cost when running these resources depends on several parameters,
    it is best to refer to the pricing documentation page provided by the cloud platform,
    found here: [https://cloud.google.com/compute/vm-instance-pricing](https://cloud.google.com/compute/vm-instance-pricing).
    You can also utilize the **Google Cloud Pricing Calculator** to estimate the cost
    of deploying resources on GCP. You can access the Google Cloud Pricing Calculator
    using the following link: [https://cloud.google.com/products/calculator](https://cloud.google.com/products/calculator).'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行这些资源的整体成本取决于多个参数，最好参考云平台提供的定价文档页面，页面链接如下：[https://cloud.google.com/compute/vm-instance-pricing](https://cloud.google.com/compute/vm-instance-pricing)。您还可以使用
    **Google Cloud 定价计算器** 来估算在 GCP 上部署资源的成本。您可以通过以下链接访问 Google Cloud 定价计算器：[https://cloud.google.com/products/calculator](https://cloud.google.com/products/calculator)。
- en: 'That said, let’s proceed with deleting the resources we created in this chapter,
    as follows:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续删除本章中创建的资源，如下所示：
- en: Close the browser tab we used to access the Kali Linux desktop environment.
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭我们用来访问 Kali Linux 桌面环境的浏览器标签页。
- en: 'In the Cloud Shell terminal, navigate to the **~/pentest_lab** directory and
    then use **terraform destroy** to clean up the resources we created earlier:'
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Cloud Shell 终端中，导航到 **~/pentest_lab** 目录，然后使用 **terraform destroy** 清理我们之前创建的资源：
- en: '[PRE119]'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Feel free to run the **terraform destroy** command again in case there are some
    resources that fail to delete. Alternatively, you may delete resources manually
    using the user interface if all else fails.
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果有些资源未能删除，欢迎再次运行 **terraform destroy** 命令。或者，如果其他方法无效，您也可以通过用户界面手动删除资源。
- en: 'Verify that the resources have been destroyed successfully using the following
    command:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证资源是否已成功销毁：
- en: '[PRE120]'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This should return an empty response since all resources should have been deleted
    successfully.
  id: totrans-779
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于所有资源应该已经成功删除，因此此操作应该返回一个空响应。
- en: Important note
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Feel free to perform a full audit of your account using the Google Cloud console.
    This will help ensure that all resources have been properly deleted, minimize
    the risk of unintended costs, and address any potential security concerns.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 随时通过 Google Cloud 控制台执行全面审计。这将帮助确保所有资源已正确删除，减少未预期费用的风险，并解决任何潜在的安全问题。
- en: That’s pretty much it! At this point, we should have a good idea of how to prepare
    penetration testing lab environments on GCP.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！此时，我们应该对如何在 GCP 上准备渗透测试实验室环境有了较好的了解。
- en: Summary
  id: totrans-783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we were able to successfully build a penetration testing lab
    in GCP. We started by preparing the prerequisites, along with defining the project
    structure of the Terraform code for automating the lab environment. We then set
    up an isolated network for securing the lab environment resources from external
    attacks. Inside this isolated network, we launched a target VM instance running
    the OWASP Juice Shop application (inside a container). After that, we imported
    the Kali Linux Generic Cloud Image into our Google Cloud account. Using the imported
    image, we proceeded with the setup of the attacker VM instance inside the network
    environment. After completing the lab environment, we performed a simplified penetration
    testing simulation to verify that our lab had been (mis)configured correctly.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地在 GCP 中搭建了渗透测试实验室。我们首先准备了先决条件，并定义了用于自动化实验环境的 Terraform 代码项目结构。接着，我们搭建了一个隔离的网络，以保护实验室环境资源免受外部攻击。在这个隔离网络中，我们启动了一个运行
    OWASP Juice Shop 应用程序（在容器中）的目标虚拟机实例。随后，我们将 Kali Linux 通用云镜像导入到我们的 Google Cloud
    账户中。使用导入的镜像，我们继续在网络环境中设置攻击者虚拟机实例。完成实验环境的搭建后，我们进行了简化的渗透测试模拟，以验证我们的实验室是否（错误地）配置正确。
- en: In the upcoming chapter, our focus will shift toward setting up a penetration
    testing lab in Microsoft Azure. We will set up a lab environment where we can
    practice container breakout techniques for gaining authorized access to the host
    system (where the container is running). Our lab setup will also highlight how
    managed identities can be misused to access other resources in the cloud environment.
    If you are excited to learn how to build penetration testing labs in Azure, then
    the next chapter is for you!
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将重点讨论如何在 Microsoft Azure 中搭建渗透测试实验室。我们将搭建一个实验环境，在其中练习容器突破技术，以便获得对主机系统（容器运行所在的系统）的授权访问。我们的实验室设置还将展示如何滥用托管身份访问云环境中的其他资源。如果你对在
    Azure 中搭建渗透测试实验室感到兴奋，那么下一章将适合你！
- en: Further reading
  id: totrans-786
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For additional information on the topics covered in this chapter, you may find
    the following resources helpful:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章所涵盖主题的更多信息，你可以参考以下资源：
- en: '*Google Cloud – Guide to Cloud Billing Resource Organization & Access* *Management*
    ([https://cloud.google.com/billing/docs/onboarding-checklist](https://cloud.google.com/billing/docs/onboarding-checklist))'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud – 云计费资源组织与访问* *管理* 指南 ([https://cloud.google.com/billing/docs/onboarding-checklist](https://cloud.google.com/billing/docs/onboarding-checklist))'
- en: '*Integrate Azure services with virtual networks for network* *isolation* ([https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services](https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services))'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 Azure 服务与虚拟网络集成以实现网络* *隔离* ([https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services](https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services))'
- en: '*Google Cloud – Best practices and reference architectures for VPC* *design*
    ([https://cloud.google.com/architecture/best-practices-vpc-design](https://cloud.google.com/architecture/best-practices-vpc-design))'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud – VPC* *设计的最佳实践与参考架构* ([https://cloud.google.com/architecture/best-practices-vpc-design](https://cloud.google.com/architecture/best-practices-vpc-design))'
- en: '*Kali Linux –* *Cloud* ([https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/))'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kali Linux –* *云端* ([https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/))'
- en: '*Kali Linux – What is Kali* *Linux?* ([https://www.kali.org/docs/introduction/what-is-kali-linux/](https://www.kali.org/docs/introduction/what-is-kali-linux/))'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kali Linux – 什么是 Kali* *Linux？* ([https://www.kali.org/docs/introduction/what-is-kali-linux/](https://www.kali.org/docs/introduction/what-is-kali-linux/))'
- en: '*Google Cloud – Manually import boot* *disks* ([https://cloud.google.com/compute/docs/import/import-existing-image](https://cloud.google.com/compute/docs/import/import-existing-image))'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud – 手动导入启动* *磁盘* ([https://cloud.google.com/compute/docs/import/import-existing-image](https://cloud.google.com/compute/docs/import/import-existing-image))'
- en: '*OWASP Juice Shop: Probably the most modern and sophisticated insecure web*
    *application* ([https://github.com/juice-shop/juice-shop](https://github.com/juice-shop/juice-shop))'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OWASP Juice Shop：可能是最现代且最复杂的不安全 web* *应用* ([https://github.com/juice-shop/juice-shop](https://github.com/juice-shop/juice-shop))'
