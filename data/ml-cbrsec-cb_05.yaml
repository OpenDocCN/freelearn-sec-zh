- en: Penetration Testing Using Machine Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习的渗透测试
- en: A penetration test, aka a pen test, is an authorized simulated cyberattack on
    an information system, designed to elicit security vulnerabilities. In this chapter,
    we will be covering a wide selection of machine learning-technologies for penetration
    testing and security countermeasures. We'll begin by cracking a simple CAPTCHA
    system. We'll cover the automatic discovery of software vulnerabilities using
    deep learning, using fuzzing and code gadgets. We'll demonstrate enhancements
    to Metasploit, as well as covering how to assess the robustness of machine learning
    systems to adversarial attacks. Finally, we'll cover more specialized topics,
    such as deanonymizing Tor traffic, recognizing unauthorized access via keystroke
    dynamics, and detecting malicious URLs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试，简称“渗透测试”，是一种授权的模拟网络攻击，旨在发现信息系统中的安全漏洞。在本章中，我们将涵盖一系列用于渗透测试和安全对策的机器学习技术。我们将从破解一个简单的验证码系统开始。接下来，我们将介绍使用深度学习、模糊测试和代码小工具自动发现软件漏洞。我们将展示如何增强Metasploit，并讨论如何评估机器学习系统对抗性攻击的鲁棒性。最后，我们将探讨一些更专业的主题，如去匿名化Tor流量、通过键击动态识别未授权访问以及检测恶意URL。
- en: 'This chapter covers the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: CAPTCHA breaker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证码破解器
- en: Neural network-assisted fuzzing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络辅助模糊测试
- en: DeepExploit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DeepExploit
- en: Web server vulnerability scanner using machine learning (GyoiThon)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习的Web服务器漏洞扫描器（GyoiThon）
- en: Deanonymizing Tor using machine learning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习去匿名化Tor流量
- en: '**Internet of Things** (**IoT**) device type identification using machine learning'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习的**物联网**（**IoT**）设备类型识别
- en: Keystroke dynamics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键击动态
- en: Malicious URL detector
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意URL检测器
- en: Deep-pwning
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度渗透
- en: Deep learning-based system for the automatic detection of software vulnerabilities
    (VulDeePecker)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于深度学习的自动软件漏洞检测系统（VulDeePecker）
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下工具：
- en: TensorFlow
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow
- en: Keras
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras
- en: OpenCV
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV
- en: Google API Client
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google API客户端
- en: Censys
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Censys
- en: NetworkX
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetworkX
- en: Tldextract
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tldextract
- en: dpkt
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dpkt
- en: NumPy
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy
- en: SciPy
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy
- en: Xlib
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xlib
- en: Gensim
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gensim
- en: The code and datasets can be found at [https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter05](https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter05).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和数据集可以在[https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter05](https://github.com/PacktPublishing/Machine-Learning-for-Cybersecurity-Cookbook/tree/master/Chapter05)找到。
- en: CAPTCHA breaker
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证码破解器
- en: 'A **CAPTCHA** is a system intended to prevent automated access or scraping.
    It does so by asking questions that are meant to recognize when the user is a
    human and when the user is a program. You have probably seen countless variations
    of the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证码**是一种旨在防止自动访问或抓取的系统。它通过提出旨在识别用户是人类还是程序的问题来实现这一点。你可能已经看到了许多类似的屏幕截图：'
- en: '![](assets/2d535842-1285-4150-aa14-470cc388ae91.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d535842-1285-4150-aa14-470cc388ae91.png)'
- en: 'Sometimes, the request is to insert a code, sometimes it is to select some
    objects, for example, storefronts or traffic lights in a series of images, and
    sometimes the CAPTCHA is a math question. In this chapter, we are going to break
    a simple CAPTCHA system, called Really Simple CAPTCHA:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，要求插入一段代码，有时需要选择一些物体，例如在一系列图像中选择店面或交通信号灯，有时验证码是一个数学问题。在本章中，我们将破解一个简单的验证码系统，叫做“非常简单的验证码”：
- en: '![](assets/3e6d42c3-d51a-4506-b5f0-f88abef38a1c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e6d42c3-d51a-4506-b5f0-f88abef38a1c.png)'
- en: Despite its simplicity, **Really Simple CAPTCHA** is still widely used. Most
    importantly, it will illustrate how to approach breaking other, more complicated,
    CAPTCHA systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其简单性，**非常简单的验证码**仍然被广泛使用。最重要的是，它将说明如何破解其他更复杂的验证码系统。
- en: The first step will be to process the CAPTCHA dataset so that it is convenient
    for machine learning. The most naive approach to the problem is likely to fail.
    Namely, constructing a supervised classifier that takes a four-character CAPTCHA
    and classifies it into one of the *(26+10)^4 = 1,679,616* possible classes (26
    letters and 10 digits, taken to the fourth power due to the number of possible
    combinations of four in such a sequence) would require a huge amount of data and
    computation. Instead, we train a classifier on individual characters, cut the
    CAPTCHA into individual characters, and then perform classification four times.
    Here, again, there is a catch, and that is that it is not that easy to precisely
    crop the characters. Using OpenCV functionality and additional considerations,
    this recipe will solve this challenge.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是处理 CAPTCHA 数据集，以便它适合机器学习。最简单的方法可能会失败。即，构建一个监督分类器，该分类器接收一个四字符的 CAPTCHA，并将其分类到
    *(26+10)^4 = 1,679,616* 个可能的类别中（26个字母和10个数字，由于四个字符的组合，类别总数为上述幂的计算结果）。这种方法需要大量的数据和计算。相反，我们在单个字符上训练分类器，将
    CAPTCHA 切割成单个字符，然后进行四次分类。这里同样有一个问题，那就是精确裁剪字符并不容易。通过使用 OpenCV 功能和额外的考虑，本食谱将解决这一挑战。
- en: Processing a CAPTCHA dataset
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 CAPTCHA 数据集
- en: In this recipe, we'll perform the first part of creating a CAPTCHA breaker,
    in which we process a CAPTCHA dataset to make it amenable to training a machine
    learning model.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将执行创建 CAPTCHA 破解器的第一部分，即处理 CAPTCHA 数据集，使其适合训练机器学习模型。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The preparation for this recipe consists of installing a number of packages
    in `pip`. The instructions are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的准备工作包括在 `pip` 中安装一些软件包。安装说明如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition, a collection of CAPTCHAs has been included for your convenience
    in `captcha_images.7z`. To use these, simply extract the archive into a `captcha_images` folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了方便起见，已经包含了一些 CAPTCHA 数据集，存储在 `captcha_images.7z` 文件中。只需解压此存档到 `captcha_images`
    文件夹中即可使用。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we''ll process a CAPTCHA dataset to make it amenable
    to training a machine learning model:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将处理一个 CAPTCHA 数据集，使其适合训练机器学习模型：
- en: Collect a large corpus of CAPTCHAs.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集大量 CAPTCHA 数据。
- en: 'Our next goal is to process the CAPTCHAs, specify where the CAPTCHA images
    are stored and then enumerate all CAPTCHAs in the specified folder:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一个目标是处理 CAPTCHA，指定 CAPTCHA 图像存储的位置，然后枚举指定文件夹中的所有 CAPTCHA：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define a function that will take the image of a CAPTCHA and produce a grayscale
    version, as well as a thresholded (that is, black and white) version of the CAPTCHA''s
    image:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将接受 CAPTCHA 图像并生成一个灰度版本，以及一个阈值化的（即黑白）版本的 CAPTCHA 图像：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a function that will take the path of a CAPTCHA and use it to store
    the text label of that CAPTCHA:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将接受 CAPTCHA 的路径，并使用该路径存储该 CAPTCHA 的文本标签：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define a function that will take the contours of the CAPTCHA, which we will
    compute, and then determine their bounding rectangles, in preparation for cropping
    the CAPTCHA into individual characters:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将接受 CAPTCHA 的轮廓，我们将计算这些轮廓，并确定它们的边界矩形，为将 CAPTCHA 切割成单个字符做准备：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define a function that will take the path of a CAPTCHA, read it in as an image,
    and then preprocess it using the functions we have defined:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将接受 CAPTCHA 的路径，将其作为图像读取，并使用我们已定义的函数进行预处理：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define another helper function to take the bounding rectangles of contours
    of letters and produce character images from these:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个辅助函数，接受字母轮廓的边界矩形并从中生成字符图像：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define one last helper function to perform the cropping of a CAPTCHA and then
    save each cropped character:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义最后一个辅助函数，执行 CAPTCHA 的裁剪，然后保存每个裁剪后的字符：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Loop through all of the CAPTCHAs, preprocess them, find the character contours,
    and then save the corresponding characters:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有的 CAPTCHA，进行预处理，找到字符轮廓，然后保存相应的字符：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Our starting point is to collect a large corpus of CAPTCHAs (*step 1*). You
    can find these in `captcha_images.7z`. Alternatively, since Really Simple CAPTCHA's
    code is available online, you can modify it to generate a large number of CAPTCHAs.
    Additional ideas include utilizing bots to scrape CAPTCHAs. Next, in *step 2*,
    we specify where the CAPTCHA images are stored and then enumerate all CAPTCHAs
    in the specified folder. Our goal is to begin processing these. In *step 3*, we
    define a function to threshold and grayscale the CAPTCHA images. This allows us
    to reduce the computation, as well as making it easier to determine where one
    character starts and where the next one ends. We then define a function to obtain
    the label of a CAPTCHA (*step 4*). Continuing, to prepare for processing, we define
    a utility function that takes the contours of the CAPTCHA and uses them to determine
    each character's bounding rectangles. Once a bounding rectangle is found, it is
    easy to crop the character in order to isolate it (*step 5*). Next, in *step 6*,
    we combine the functions we have defined thus far into one convenient function.
    We also define an additional function, to actually crop the characters. Putting
    the above together, in *step 8*, we write a function that will perform the preceding
    steps, and then save the resulting isolated character, as well as keeping count
    of how many of each character has been saved. This is helpful for naming, as well
    as accounting. We are now in a position to perform the cropping, so, in *step
    9*, we iterate through all the CAPTCHAs and, using our utility functions, crop
    individual characters. Note that the `if` statement is meant to skip any incorrectly
    cropped CAPTCHAs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点是收集大量 CAPTCHA（*步骤 1*）。您可以在 `captcha_images.7z` 中找到这些 CAPTCHA。或者，由于 Really
    Simple CAPTCHA 的代码可以在线获取，您可以修改它来生成大量的 CAPTCHA。其他方法包括使用机器人抓取 CAPTCHA。接下来，在 *步骤
    2* 中，我们指定 CAPTCHA 图像的存储位置，并列举出指定文件夹中的所有 CAPTCHA。我们的目标是开始处理这些 CAPTCHA。在 *步骤 3*
    中，我们定义一个函数，用来阈值化并将 CAPTCHA 图像转换为灰度图像。这样可以减少计算量，并且更容易确定一个字符的起始位置和下一个字符的结束位置。然后我们定义一个函数来获取
    CAPTCHA 的标签（*步骤 4*）。接下来，为了准备处理，我们定义一个实用函数，获取 CAPTCHA 的轮廓，并利用这些轮廓来确定每个字符的边界矩形。一旦找到边界矩形，就可以轻松地裁剪字符，以便将其隔离出来（*步骤
    5*）。然后，在 *步骤 6* 中，我们将到目前为止定义的函数组合成一个方便的函数。我们还定义了一个额外的函数，用来实际裁剪字符。将以上内容结合起来，在 *步骤
    8* 中，我们编写一个函数来执行前面的步骤，然后保存结果中的隔离字符，并统计每个字符保存的数量。这对命名和统计都非常有帮助。现在我们可以开始裁剪了，所以，在
    *步骤 9* 中，我们遍历所有的 CAPTCHA，并利用我们的实用函数裁剪单个字符。请注意，`if` 语句用于跳过裁剪错误的 CAPTCHA。
- en: 'At the conclusion of the recipe, your output folder, `extracted_letter_images`,
    should have a folder for most letters and digits, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程结束时，您的输出文件夹 `extracted_letter_images` 应该会有一个文件夹，包含大多数字母和数字，如下图所示：
- en: '![](assets/23403397-e788-4dde-9d75-6ca1739d3a20.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23403397-e788-4dde-9d75-6ca1739d3a20.png)'
- en: The reason not all characters and digits are represented is that the CAPTCHAs
    do not contain the digit 1 and letter I, as the two are easily confused. Similarly
    for 0 and O.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的字符和数字都有表示，原因是 CAPTCHA 中不包含数字 1 和字母 I，因为这两者容易混淆。同理，数字 0 和字母 O 也存在相同问题。
- en: 'Inside each folder, you will have a large collection of instances of that letter
    or digit, cropped and processed from the initial CAPTCHAs:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件夹内，您将会有大量该字母或数字的实例，这些实例是从原始 CAPTCHA 中裁剪和处理出来的：
- en: '![](assets/21529bd2-1d19-4f7b-9556-2da0eb14c722.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21529bd2-1d19-4f7b-9556-2da0eb14c722.png)'
- en: This concludes the preprocessing step.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了预处理步骤。
- en: Training a CAPTCHA solver neural network
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练一个 CAPTCHA 解码神经网络
- en: Now that our data is nicely processed, we can train a neural network to perform
    CAPTCHA prediction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据已经处理得很整洁，可以训练一个神经网络来进行 CAPTCHA 预测。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Preparation for this recipe consists of installing a number of packages in
    pip. The instructions are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括通过 pip 安装若干软件包。安装步骤如下：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we''ll train a neural network to solve Really Simple
    CAPTCHA''s CAPTCHAs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将训练一个神经网络来解决 Really Simple CAPTCHA 的 CAPTCHA：
- en: 'Specify the folder where the extracted letter images are located:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定提取的字母图像所在的文件夹：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Import OpenCV and imutils for image manipulation:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 OpenCV 和 imutils 进行图像处理：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define a helper function to resize an image to a given size:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，将图像调整为给定的大小：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Prepare to read in the images:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备读取图像：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Read in each letter image and record its label:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取每个字母图像并记录其标签：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Normalize all images, that is, rescale the pixel values to 0-1 and convert
    labels to a NumPy array:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归一化所有图像，即将像素值缩放到0-1，并将标签转换为NumPy数组：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a train-test split:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建训练集和测试集的划分：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Import `LabelBinarizer` in order to encode the labels:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`LabelBinarizer`以编码标签：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define a neural network architecture:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义神经网络架构：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Fit the neural network to the training data:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将神经网络拟合到训练数据上：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Select a CAPTCHA instance you would like to break:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个你想破解的CAPTCHA实例：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We'll import all of the functions we used to process images in the previous
    recipe, namely, `find_bounding_rectangles_of_contours`, `preprocess_CAPTCHA`,
    `get_CAPTCHA_label`, and `CAPTCHA_to_grayscale_and_bounding_rectangles`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入在上一节中用于处理图像的所有函数，即`find_bounding_rectangles_of_contours`、`preprocess_CAPTCHA`、`get_CAPTCHA_label`和`CAPTCHA_to_grayscale_and_bounding_rectangles`。
- en: 'Process the CAPTCHA image as we did in the previous recipe:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照我们在上一节中所做的方式处理CAPTCHA图像：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Read in each cropped letter and use the neural network to predict the label:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取每个裁剪后的字母，并使用神经网络预测标签：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Print out the prediction:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出预测结果：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Having completed our preprocessing of CAPTCHAs in the previous recipe, we are
    now ready to utilize these to train a CAPTCHA breaker. We start by setting a variable
    to the path of all of our individual characters extracted from CAPTCHAs. We import
    the image manipulation libraries we will be using (*step 2*) and then define a
    function to resize an image in *step 3*. This is a relatively standard method
    for character recognition, which allows training to proceed faster, and memory
    utilization to be reduced. In *step 4*, we define a convenience function to read
    in files as NumPy arrays, for training purposes, and then, in *step 5*, we iterate
    through all the letters and record their labels. Next, we normalize all of the
    images (*step 6*), another standard computer vision trick. We now create a train-test
    split in preparation for fitting our classifier (*step 7*) and then utilize label
    binarizers to encode our labels (*step 8*). This is necessary since the labels
    are the characters, which may not be numerical. In *step 9*, we define the architecture
    of our neural network. The architecture stated is relatively common, and offers
    both precision and speed. We fit our neural network to the training set in *step
    10*. Other parameters can enhance the performance of the network. The hard work
    is now finished. We now proceed to demonstrate how the CAPTCHA breaker works.
    In *step 11*, we choose a singleton instance to demonstrate the efficacy of our
    CAPTCHA breaker. In steps 12-14, we pass this image through our pipeline and produce
    predicted text for this CAPTCHA. Finally, we verify that the prediction is correct
    (*step 15*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们已经完成了CAPTCHA的预处理，现在我们准备利用这些数据来训练一个CAPTCHA破解器。我们首先设置一个变量，指向从CAPTCHA中提取的所有单个字符的路径。然后我们导入将要使用的图像处理库（*第2步*），接着在*第3步*中定义一个调整图像大小的函数。这是一种相对标准的字符识别方法，可以加速训练并减少内存消耗。在*第4步*中，我们定义一个方便的函数，将文件读取为NumPy数组，用于训练；然后在*第5步*中，我们遍历所有字母并记录它们的标签。接下来，我们对所有图像进行归一化处理（*第6步*），这是另一个标准的计算机视觉技巧。现在我们创建训练集和测试集的划分，准备进行分类器拟合（*第7步*），然后使用标签二值化器对标签进行编码（*第8步*）。这是必要的，因为标签是字符，可能并非数值类型。在*第9步*中，我们定义神经网络的架构。所定义的架构是相对常见的，既具有精度又具备速度。在*第10步*中，我们将神经网络拟合到训练集上。其他参数可以增强网络的性能。现在，繁重的工作已经完成。接下来，我们展示CAPTCHA破解器如何工作。在*第11步*中，我们选择一个单例实例来展示CAPTCHA破解器的有效性。在*第12到14步*中，我们将图像通过我们的处理管道，生成对该CAPTCHA的预测文本。最后，我们验证预测是否正确（*第15步*）。
- en: Neural network-assisted fuzzing
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络辅助模糊测试
- en: Fuzzing is a software vulnerability detection method wherein a large number
    of random inputs are fed into a program in search of ones that will cause a crash,
    unwanted information leak, or other unintended behavior. In automated fuzzing,
    a program generates these inputs. Generally, automated fuzzers suffer from the
    shortcoming that they tend to get stuck trying redundant inputs. For this reason,
    AI-based fuzzers have recently been developed. In this recipe, we'll employ NEUZZ,
    a neural network-based fuzzer by She et al. (see [https://arxiv.org/abs/1807.05620](https://arxiv.org/abs/1807.05620)),
    to find unknown vulnerabilities in software.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Fuzz 测试是一种软件漏洞检测方法，其中将大量随机输入提供给程序，寻找会导致崩溃、信息泄露或其他意外行为的输入。在自动化模糊测试中，程序会生成这些输入。通常，自动化模糊测试器存在一个缺点，即它们倾向于重复尝试冗余的输入。为了解决这个问题，最近开发了基于
    AI 的模糊测试器。在这个食谱中，我们将使用 She 等人开发的基于神经网络的模糊测试器 NEUZZ（见 [https://arxiv.org/abs/1807.05620](https://arxiv.org/abs/1807.05620)）来发现软件中的未知漏洞。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following recipe requires an Ubuntu 16.04 or 18.04 virtual or physical
    machine. On this device, run the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱要求使用 Ubuntu 16.04 或 18.04 虚拟机或物理机。在此设备上运行以下命令：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Extract `neuzz-modified.7z` to a folder of your choosing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `neuzz-modified.7z` 解压到你选择的文件夹中。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we provide a recipe for using NEUZZ to find crash-causing
    inputs to the readelf Unix tool:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们提供了一个使用 NEUZZ 查找导致崩溃的输入的食谱，针对的是 `readelf` Unix 工具：
- en: 'Build neuzz using the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建 neuzz：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you receive warnings, that's okay.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到警告，没关系。
- en: '2\. Install the libraries needed for 32-bit binaries:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 安装 32 位二进制文件所需的库：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As root, set the CPU scaling algorithm and core dump notification:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 用户身份设置 CPU 缩放算法和核心转储通知：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Copy `neuzz`, `nn.py`, and `afl-showmap` to `programs/readelf`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `neuzz`、`nn.py` 和 `afl-showmap` 复制到 `programs/readelf`：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Provide all files with executable permission:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有文件提供可执行权限：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Open a Terminal to start the neural network module:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端以启动神经网络模块：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Open another Terminal and start NEUZZ:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并启动 NEUZZ：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is a snippet from running the commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行这些命令的一部分：
- en: '![](assets/9675c7a1-2b44-43e5-8fd8-9816e4176517.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9675c7a1-2b44-43e5-8fd8-9816e4176517.png)'
- en: 'Test the crashes that NEUZZ has collected by running the following:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令测试 NEUZZ 收集的崩溃：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](assets/d367d900-4a9f-47ff-906c-d598bb32bc9c.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d367d900-4a9f-47ff-906c-d598bb32bc9c.png)'
- en: How it works…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Most popular fuzzers, while effective in some limited situations, often get
    stuck in a loop. Gradient-based methods, such as the one discussed here, are promising
    but do not clearly apply to the problem, because real-world program behaviors
    are not necessarily smooth functions (for example, they can be discontinuous).
    The idea behind NEUZZ is to approximate the program's behavior as a smooth function
    using neural networks. Then, it is possible to apply gradient methods to improve
    fuzzing efficiency. We start our recipe by compiling NEUZZ (*step 1)*. The `funroll-loops`
    flag causes the compiler to unroll loops whose number of iterations can be determined
    at compile time or upon entry to the loop. As a result, the code is larger, and
    may run faster, although not necessarily. Continuing to setup NEUZZ, we add in
    32-bit support (*step 2*). We set the CPU scaling algorithm and core dump notification
    (*step 3*); the CPU frequency scaling is a setting that enables the OS to save
    power by scaling the CPU frequency up or down. In the next two steps, we simply
    place the files in a convenient location and allow permissions to execute them.
    We are done setting up NEUZZ. We can now use it to find inputs that cause programs
    to crash. In *step 6* and *step 7*, we begin the search for crashes using our
    neural network. After waiting a sufficient amount of time for *step 6* and *step 7*
    to gather enough inputs to cause the readelf tool to crash, we execute one of
    these inputs (*step 8*) to see the result. Indeed, we see that the input resulted
    in readelf crashing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的模糊测试工具在某些有限的情况下有效，但通常会陷入循环中。基于梯度的方法，如这里讨论的这种方法，虽然很有前景，但并不完全适用于这个问题，因为现实世界中的程序行为不一定是平滑的函数（例如，它们可能是不连续的）。NEUZZ
    背后的理念是使用神经网络来逼近程序的行为作为一个平滑的函数。然后，可以应用梯度方法来提高模糊测试的效率。我们从编译 NEUZZ（*步骤 1*）开始。`funroll-loops`标志会使编译器展开可以在编译时或进入循环时确定迭代次数的循环。这样，代码会变大，运行速度可能会更快，但不一定。继续设置
    NEUZZ，我们加入 32 位支持（*步骤 2*）。我们设置 CPU 调节算法和核心转储通知（*步骤 3*）；CPU 频率调节是一个让操作系统通过调整 CPU
    频率来节省电力的设置。在接下来的两个步骤中，我们只需将文件放置在一个方便的位置，并允许执行权限。我们已经完成了 NEUZZ 的设置。现在，我们可以使用它来找到导致程序崩溃的输入。在*步骤
    6*和*步骤 7*中，我们开始使用神经网络搜索崩溃。等待足够的时间，让*步骤 6*和*步骤 7*收集到足够的输入以使 readelf 工具崩溃后，我们执行其中一个输入（*步骤
    8*），看看结果。果然，我们看到该输入导致 readelf 崩溃。
- en: DeepExploit
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeepExploit
- en: '**DeepExploit** is a penetration testing tool that elevates Metasploit to a
    whole new level by leveraging AI. Its key features are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**DeepExploit**是一个渗透测试工具，通过利用人工智能，将 Metasploit 提升到一个全新的水平。它的主要特点如下：'
- en: '**Deep penetration**: If DeepExploit successfully exploits the target, it will
    automatically execute the exploit to other internal servers as well.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度渗透**：如果 DeepExploit 成功利用目标漏洞，它将自动执行漏洞利用到其他内部服务器。'
- en: '**Learning**: DeepExploit is a reinforcement learning system, akin to AlphaGo.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习**：DeepExploit 是一个强化学习系统，类似于 AlphaGo。'
- en: Using DeepExploit to pentest your security systems will take you a long way
    toward keeping your systems secure. In this recipe, we will set up and run DeepExploit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DeepExploit 来进行渗透测试可以大大增强你系统的安全性。在本教程中，我们将设置并运行 DeepExploit。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will now be guided through the steps required to install `DeepExploit`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将引导你完成安装`DeepExploit`的步骤：
- en: Download and set up Kali Linux. You can find VM images online at [https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/). The
    following steps all take place in your Kali Linux box.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并设置 Kali Linux。你可以在[https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/)找到虚拟机镜像。接下来的步骤都将在你的
    Kali Linux 系统中进行。
- en: 'Install Git by running the following in a Terminal:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令来安装 Git：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Install Python by running the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来安装 Python：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Clone the `git` repository. In a Terminal, run the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆`git`仓库。在终端中，运行以下命令：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open the `DeepExploit` directory:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DeepExploit`目录：
- en: 'In a Terminal, run the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，运行以下命令：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Install the prerequisite packages for `DeepExploit`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`DeepExploit`的前置软件包。
- en: 'In a Terminal, run the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，运行以下命令：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, you will use `DeepExploit` to compromise a victim virtual machine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将使用`DeepExploit`来攻破一个受害者虚拟机。
- en: Download a `Metasploitable2` VM image.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`Metasploitable2`虚拟机镜像。
- en: Details can be found at [https://metasploit.help.rapid7.com/docs/metasploitable-2](https://metasploit.help.rapid7.com/docs/metasploitable-2).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请参见[https://metasploit.help.rapid7.com/docs/metasploitable-2](https://metasploit.help.rapid7.com/docs/metasploitable-2)。
- en: Run a `Metasploitable2` instance on a VM.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟机上运行一个`Metasploitable2`实例。
- en: Obtain the IP address of your `Metasploitable2`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取你的`Metasploitable2`的IP地址。
- en: The next step is to set up DeepExploit's configurations.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置`DeepExploit`的配置。
- en: In a Terminal, run `ifconfig` to obtain your Kali Linux's IP. Edit `config.ini`
    (for example, using `vim`) by setting `server_host` under `[common]` to your Kali
    Linux IP.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`ifconfig`以获取Kali Linux的IP地址。编辑`config.ini`（例如，使用`vim`）并将`[common]`下的`server_host`设置为你的Kali
    Linux IP。
- en: Set the values of `proxy_host` and `proxy_port` in `config.ini` to those in
    `proxychains.conf`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`config.ini`中的`proxy_host`和`proxy_port`的值设置为`proxychains.conf`中的值。
- en: 'In the Terminal, run `cat /etc/proxychains.conf` and find the value next to
    `socks4`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，运行`cat /etc/proxychains.conf`并找到`socks4`旁边的值：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, set the values of `proxy_host` and `proxy_port` in `config.ini` equal
    to these values:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`config.ini`中`proxy_host`和`proxy_port`的值设置为这些值：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Launch Metasploit in the Terminal by running `msfconsole`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`msfconsole`启动Metasploit。
- en: 'Launch an RPC server on Metasploit. Where indicated, type in your Kali Linux''s
    IP:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Metasploit上启动RPC服务器。在指定的位置，输入你的Kali Linux的IP地址：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下内容：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In a Terminal of your Kali Linux machine, run `python3 DeepExploit.py -t "Metasploitable2
    ip" -m train` to train `DeepExploit`. The beginning of the training should look
    as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Kali Linux机器的终端中，运行`python3 DeepExploit.py -t "Metasploitable2 ip" -m train`来训练`DeepExploit`。训练开始时应该如下所示：
- en: '![](assets/b2fccab6-e290-47a0-b863-7b447bb02774.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2fccab6-e290-47a0-b863-7b447bb02774.png)'
- en: 'Whenever `DeepExploit` finds a vulnerability, you will see a `BINGO!!!` notification,
    as in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`DeepExploit`发现漏洞时，你会看到一个`BINGO!!!`的通知，如下图所示：
- en: '![](assets/b63f382c-1202-4166-9c8c-fb3fc19f2119.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b63f382c-1202-4166-9c8c-fb3fc19f2119.png)'
- en: 'Upon conclusion of the training, the learning is saved. You can see the completion
    screen here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 培训结束时，学习内容会被保存。你可以在此处看到完成屏幕：
- en: '![](assets/e312ea67-43e8-4c15-bb3f-1e50298d61ea.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e312ea67-43e8-4c15-bb3f-1e50298d61ea.png)'
- en: Test `Metasploitable2` for vulnerabilities using `DeepExploit`. In a Terminal,
    run `python DeepExploit.py -t "Metasploitable2 ip" -m test`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DeepExploit`测试`Metasploitable2`的漏洞。在终端中，运行`python DeepExploit.py -t "Metasploitable2
    ip" -m test`。
- en: 'Check the report of the pen test as shown:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查渗透测试的报告，如下所示：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll get the following as the output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下输出：
- en: '![](assets/840efb2f-5ed7-433e-8226-ef3474486359.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/840efb2f-5ed7-433e-8226-ef3474486359.png)'
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是…
- en: This recipe requires a large amount of preparation and configuration. The initial
    steps are to set up a victim virtual machine (*steps 1 and 2*). In *step 3*, we
    determine the IP address of the victim VM. Note that the credentials of `Metasploitable2`
    are `msfadmin/msfadmin`. You can use the credentials to log in and then use `ifconfig`
    to obtain your `Metasploitable2` IP. If you are using a Kali Linux VM and a `Metasploitable2`
    VM on the same host, make sure that the two can communicate. For instance, put
    both VMs on a Host-Only Adapter and ping from your Kali Linux machine to the Metasploitable2
    machine. Proceeding, we now configure `DeepExploit` so we can target the victim
    VM (*steps 4*-*8*). In *steps 9* and *10*, we open up Metasploit, which is used
    as a submodule by `DeepExploit`. Metasploit is a major penetration testing framework.
    Having finished all the preparation, we can now start to train our model. In *step
    11*, we train `DeepExploit` on the `Metasploitable2` VM. The model utilizes the
    **Asynchronous Actor-Critic Agents** (`A3C`) algorithm, released by Google's DeepMind
    group a few years back, famous for outperforming the `deep Q-network` (`DQN`)
    approach. Next, we test our model (*step 12*) and print out the results of its
    analysis in a report (*step 13*). As you can see from the long report, a large
    number of vulnerabilities were found by `DeepExploit`. Speaking from a high level,
    the application of reinforcement learning to penetration testing suggests that
    extremely efficient automated penetration testing is on the horizon.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要大量准备和配置。初步步骤是设置受害者虚拟机（*步骤 1 和 2*）。在 *步骤 3* 中，我们确定受害者虚拟机的 IP 地址。请注意，`Metasploitable2`
    的凭据是 `msfadmin/msfadmin`。您可以使用这些凭据登录，然后使用 `ifconfig` 获取 `Metasploitable2` 的 IP
    地址。如果您在同一主机上使用 Kali Linux 虚拟机和 `Metasploitable2` 虚拟机，请确保两者能够通信。例如，将两个虚拟机都放在 Host-Only
    适配器上，并从 Kali Linux 机器 ping `Metasploitable2` 机器。接下来，我们配置 `DeepExploit`，以便我们可以针对受害者虚拟机进行攻击（*步骤
    4*-*8*）。在 *步骤 9* 和 *10* 中，我们打开 Metasploit，Metasploit 被 `DeepExploit` 作为子模块使用。Metasploit
    是一个主要的渗透测试框架。完成所有准备工作后，我们现在可以开始训练我们的模型。在 *步骤 11* 中，我们在 `Metasploitable2` 虚拟机上训练
    `DeepExploit`。该模型利用 **异步演员批评算法**（`A3C`），这是 Google DeepMind 团队几年前发布的算法，因其超越了 `深度
    Q 网络`（`DQN`）方法而闻名。接下来，我们测试我们的模型（*步骤 12*），并将其分析结果以报告的形式打印出来（*步骤 13*）。从长报告中可以看出，`DeepExploit`
    发现了大量漏洞。从高层次来看，将强化学习应用于渗透测试表明，高效的自动化渗透测试即将到来。
- en: Web server vulnerability scanner using machine learning (GyoiThon)
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习的 Web 服务器漏洞扫描器（GyoiThon）
- en: '**GyoiThon** is an intelligence-gathering tool for web servers. It executes
    remote access to a target web server and identifies products operated on the server,
    such as the **Content Management System** (**CMS**), web server software, framework,
    and programming language. In addition, it can execute exploit modules for the
    identified products using Metasploit.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**GyoiThon** 是一款用于 Web 服务器的情报收集工具。它执行远程访问目标 Web 服务器，识别服务器上运行的产品，如 **内容管理系统**
    (**CMS**)、Web 服务器软件、框架和编程语言。此外，它还可以使用 Metasploit 执行已识别产品的漏洞利用模块。'
- en: 'Some of the main features of GyoiThon are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: GyoiThon 的一些主要功能如下：
- en: '**Remote access/Fully automatic**: GyoiThon can automatically gather information
    on a target web server using only remote access. You only execute GyoiThon once
    for your operation.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程访问/完全自动化**：GyoiThon 仅通过远程访问即可自动收集目标 Web 服务器的信息。您只需执行一次 GyoiThon 即可完成操作。'
- en: '**Non-destructive test**:GyoiThon can gather information on the target web
    server using only normal access. A feature permits GyoiThon to access abnormally,
    such as by sending exploit modules.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非破坏性测试**：GyoiThon 仅通过正常访问即可收集目标 Web 服务器的信息。一个功能允许 GyoiThon 异常访问，如通过发送漏洞利用模块。'
- en: '**Gathering varied information**: GyoiThon has a number of intelligence gathering
    engines such as a web crawler, the Google Custom Search API, Censys, an explorer
    of default contents, and the examination of cloud services. By analyzing gathered
    information using string pattern matching and machine learning, GyoiThon can identify
    a product/version/CVE number operated on the target web server, HTML comments/debug
    messages, login pages, and other information.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集多样的信息**：GyoiThon 拥有多种情报收集引擎，如网络爬虫、Google 自定义搜索 API、Censys、默认内容探索器以及云服务检查。通过使用字符串模式匹配和机器学习分析收集的信息，GyoiThon
    可以识别目标 Web 服务器上运行的产品/版本/CVE 编号、HTML 注释/调试信息、登录页面及其他信息。'
- en: '**Examination of real vulnerabilities**: GyoiThon can execute exploit modules
    on identified products using Metasploit. As a result, it can determine the real
    vulnerabilities of the target web server.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实漏洞检查**：GyoiThon可以使用Metasploit执行漏洞模块，对已识别的产品进行攻击。因此，它可以确定目标Web服务器的实际漏洞。'
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will now be guided through the steps for installing and running GyoiThon:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将按照步骤进行GyoiThon的安装和运行：
- en: Download and set up Kali Linux. You can find VM images online at [https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/). The
    following steps all take place in your Kali Linux box.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并设置Kali Linux。您可以在[https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/)找到虚拟机镜像。接下来的步骤都将在您的Kali
    Linux机器上进行。
- en: 'Install `git` in the Terminal by running the following:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过运行以下命令安装`git`：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Install `python` in the Terminal by running the following command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令安装`python`：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clone the Git repository into your Linux box in the Terminal by running the
    following command:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux终端中，通过运行以下命令克隆Git仓库：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open the `GyoiThon` directory in the Terminal by running the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令，打开`GyoiThon`目录：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Install the prerequisites for DeepExploit in the Terminal by running the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过运行以下命令安装DeepExploit的先决条件：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: (Optional.) Substitute the `Gyoi_CveExplorerNVD` file in modules with the one
    available in the repository for this book. In some cases, the original code has
    malfunctioned and the modified code available in the repository for this book
    may address this problem.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）将`Gyoi_CveExplorerNVD`文件替换为本书仓库中提供的文件。在某些情况下，原始代码可能已失效，而本书仓库中的修改代码可能解决了这个问题。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, you will use DeepExploit to compromise a victim virtual machine:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将使用DeepExploit来攻陷一个受害者虚拟机：
- en: Download a `Metasploitable2` VM image.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`Metasploitable2`虚拟机镜像。
- en: Run a `Metasploitable2` instance on a VM.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟机上运行一个`Metasploitable2`实例。
- en: Obtain the IP address of your `Metasploitable2`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取您的`Metasploitable2`的IP地址。
- en: 'In your Kali Linux machine, you should be able to see your `Metasploitable2''s`
    website instance by typing `Metasploitable2''s ip address:80` into a web browser:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Kali Linux机器上，您应该能够通过在浏览器中输入`Metasploitable2的ip地址:80`来查看`Metasploitable2`的网页实例：
- en: '![](assets/71464351-549d-4a10-9759-c96489711565.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/71464351-549d-4a10-9759-c96489711565.png)'
- en: In a Terminal, run `ifconfig` to obtain your Kali Linux's IP. Edit `config.ini`
    (for example, using `vim`) by setting `proxy` to `empty`, `server host` to your
    `Kali Linux IP`, `LHOST` to your `Metasploitable2 IP`, and `LPORT` to `80`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`ifconfig`来获取Kali Linux的IP地址。通过编辑`config.ini`（例如使用`vim`），将`proxy`设置为空，将`server
    host`设置为您的`Kali Linux IP`，将`LHOST`设置为`Metasploitable2 IP`，将`LPORT`设置为`80`。
- en: Open the host file and add the `Metasploitable2` web server address by typing
    in `http:Metasploitable2 ip:80/`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开主机文件，并通过输入`http:Metasploitable2 ip:80/`来添加`Metasploitable2`的web服务器地址。
- en: In a Terminal of your Kali Linux machine, run `python3 Gyoithon.py` to begin
    the attack.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kali Linux机器的终端中，运行`python3 Gyoithon.py`开始攻击。
- en: 'Upon the conclusion of the attack, check the report of the pen test in the
    folder report:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击结束后，检查位于报告文件夹中的渗透测试报告：
- en: '![](assets/efb44d52-8217-4d81-beae-0e222e914e69.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/efb44d52-8217-4d81-beae-0e222e914e69.png)'
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '*Steps 1-3* are no different than in the recipe for DeepExploit, where we prepared
    a victim VM. The credentials of `Metasploitable2` are `msfadmin/msfadmin`. You
    can use the credentials to log in and then use `ifconfig` to obtain your `Metasploitable2`
    IP. If you are using a Kali Linux VM and `Metasploitable2` VM on the same host,
    make sure that the two can communicate. For instance, put both VMs on a Host-only
    Adapter and ping from your Kali Linux machine to the Metasploitable2 machine.
    Next, we verify that the environment has been properly set up by checking that
    we are able to access the victim VM''s web page in *step 4*. In *step 5* and *step
    6*, we configure GyoiThon in preparation for our pen test. Having finished setting
    up our environments, we are now ready to perform the pen test. In *step 7*, we
    utilize GyoiThon to search for vulnerabilities. We then output a full report of
    the vulnerabilities detected (*step 8*). Looking at the report, we can see that
    GyoiThon was able to find a large number of vulnerabilities. Having now determined
    the vulnerabilities of the victim box, we can go ahead and exploit these, using,
    for example, Metasploit, to hack the victim box.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1-3*与DeepExploit中的配方没有区别，我们在其中准备了一个受害者虚拟机。`Metasploitable2`的凭证是`msfadmin/msfadmin`。你可以使用这些凭证登录，然后使用`ifconfig`获取你的`Metasploitable2`
    IP。如果你在同一主机上使用Kali Linux虚拟机和`Metasploitable2`虚拟机，确保它们能够通信。例如，将这两个虚拟机设置为Host-only适配器，并从Kali
    Linux机器ping到Metasploitable2机器。接下来，我们通过检查能否访问受害者虚拟机的网页来验证环境是否已正确设置（*步骤4*）。在*步骤5*和*步骤6*中，我们配置GyoiThon以准备进行渗透测试。完成环境设置后，我们就准备开始渗透测试。在*步骤7*中，我们利用GyoiThon搜索漏洞。然后，我们输出检测到的漏洞的完整报告（*步骤8*）。通过查看报告，我们可以看到GyoiThon能够找到大量漏洞。确定受害者主机的漏洞后，我们可以使用例如Metasploit等工具进行攻击。'
- en: Deanonymizing Tor using machine learning
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习去匿名化Tor
- en: Tor is a free, open source software for enabling anonymous communication. In
    addition, websites accessible only when using the Tor browser exist, and are part
    of the **dark web** ecosystem – the name given to the part of the internet that
    is hidden from the average user. In this recipe, we will deanonymize Tor traffic
    by collecting enough features and information from individual sessions to be able
    to identify the activity of anonymized users. This recipe utilizes the **conmarap/website-fingerprinting**
    repository.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Tor是一款免费的开源软件，用于实现匿名通信。此外，只有使用Tor浏览器才能访问的网站存在，它们是**暗网**生态系统的一部分——这是指普通用户无法访问的互联网部分。在这个配方中，我们将通过收集足够的特征和信息来去匿名化Tor流量，从而识别匿名用户的活动。这个配方使用了**conmarap/website-fingerprinting**仓库。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will now be guided through the steps needed to set up Tor and the Lynx
    web browser:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将引导你完成设置Tor和Lynx网页浏览器所需的步骤：
- en: Set up an Ubuntu VM.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个Ubuntu虚拟机。
- en: 'Install `git` in the Terminal by running the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过运行以下命令安装`git`：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Clone the code repository in the Terminal by running the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过运行以下命令克隆代码仓库：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Install `tor` and `lynx` in the Terminal by running the following command:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中通过运行以下命令安装`tor`和`lynx`：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: This recipe consists of three parts. The first part consists of the data collection
    of Tor traffic. The second consists of training a classifier on this data. And
    the final part consists of using the classifier to predict the type of traffic
    being observed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方由三个部分组成。第一部分是收集Tor流量数据。第二部分是基于这些数据训练分类器。最后一部分是使用分类器来预测观察到的流量类型。
- en: Collecting data
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据收集
- en: 'The following steps need to be followed for data collection:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是数据收集时需要遵循的：
- en: 'List the classes of traffic you wish to classify in `config.json`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`config.json`中列出你希望分类的流量类别：
- en: '![](assets/5c3ccb28-410d-41c7-bb0b-f8f7c8577d14.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c3ccb28-410d-41c7-bb0b-f8f7c8577d14.png)'
- en: 'Collect an additional data point for one of the classes, say `duckduckgo.com`,
    in a Terminal, from the website-fingerprinting directory by running the following
    command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`website-fingerprinting`目录中，从一个类（比如`duckduckgo.com`）收集额外的数据点，在终端中运行以下命令：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Open another Terminal, and run the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端，并运行以下命令：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Your two Terminals should look as follows, at this point:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的两个终端应该如下所示：
- en: '![](assets/ecfa12db-50fc-48f7-b06e-fa36a7cbdbdb.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ecfa12db-50fc-48f7-b06e-fa36a7cbdbdb.png)'
- en: Once you have finished the browsing session, end the capture by pressing *Q*
    twice.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦浏览会话结束，按*Q*键两次结束捕获。
- en: When a sufficient amount of training data has been gathered, we are ready to
    train a classifier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当足够的训练数据收集完毕后，我们就可以开始训练分类器。
- en: Training
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练
- en: 'To train a classifier on the data, run the following script using Python:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据上训练分类器，请使用 Python 运行以下脚本：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result is a file classifier: `nb.dmp`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个分类器文件：`nb.dmp`。
- en: Predicting
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测
- en: 'Let''s use the classifier to predict the type of traffic being observed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用分类器来预测所观察到的流量类型：
- en: To predict a new instance of traffic, collect the `pcap` file.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要预测新的流量实例，请收集`pcap`文件。
- en: 'Using Python, run the `predict.py` script with the `pcap` file as an argument:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 运行`predict.py`脚本，并将`pcap`文件作为参数：
- en: '![](assets/3ed74252-6025-48bc-b427-eea3b88220cd.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ed74252-6025-48bc-b427-eea3b88220cd.png)'
- en: 'The clustering by the author looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 作者的聚类结果如下：
- en: '![](assets/63bfbc53-5589-47b6-a81a-a8a28fe1d895.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63bfbc53-5589-47b6-a81a-a8a28fe1d895.png)'
- en: The preceding diagram shows that the features do indeed differentiate between
    the type of traffic, despite it being anonymous.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示，尽管流量是匿名的，但特征的确能够区分不同类型的流量。
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start constructing our classifier by creating a catalog of all of the websites
    we wish to profile (*step 1*). The more there are, the more likely the target
    is to visit one of these. On the other hand, the fewer there are, the smaller
    the training dataset will have to be. In *steps 2*-*4*, we perform the steps required
    to collect a data point for our classifier. Specifically, we do so by visiting
    one of the websites defined in *step 1* and then capture the packets for that
    visit. By repeating these steps for different browsing sessions, we are able to
    construct a robust dataset. In *step 5*, we train a classifier on our data, which
    we have collected up until now. We are now ready to test out our classifier. In
    *step 6*, we visit a website and collect its `pcap`, just as we did when collecting
    our training data. We then employ the classifier to classify this visit (*step
    7*). We see that it did, indeed, correctly determine which web page the user visited,
    despite the user using Tor.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个我们希望分析的所有网站的目录（*步骤 1*）来开始构建我们的分类器。网站数量越多，目标访问这些网站的可能性越大。另一方面，网站越少，训练数据集所需的大小也越小。在*步骤
    2* 到 *步骤 4* 中，我们执行收集分类器数据点所需的步骤。具体来说，我们通过访问*步骤 1*中定义的网站之一，然后捕获该访问的网络数据包。通过对不同的浏览会话重复这些步骤，我们能够构建一个强大的数据集。在*步骤
    5* 中，我们在迄今为止收集的数据上训练分类器。现在我们已经准备好测试我们的分类器了。在*步骤 6* 中，我们访问一个网站并收集其`pcap`文件，就像我们收集训练数据时一样。然后，我们使用分类器来分类这个访问（*步骤
    7*）。我们看到，尽管用户使用了 Tor，它仍然正确地识别出了用户访问的网页。
- en: In summary, in this recipe, scikit-learn was used to write a k-nearest neighbors
    classifier that would classify Tor `pcap` files. In practice, traffic is never
    as *clean*, so accuracy is likely to decrease on a real dataset of the same size.
    However, an entity with large amounts of resources can create a very accurate
    classifier. This means that it is entirely possible to use a method like this
    to accurately compromise anonymized users.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本教程中，使用了 scikit-learn 编写了一个 k 最近邻分类器，用来分类 Tor 的`pcap`文件。在实际情况中，流量数据往往不像*干净*数据那样，准确度在相同大小的真实数据集上可能会降低。然而，拥有大量资源的实体可以创建一个非常精确的分类器。这意味着，像这种方法完全有可能准确地攻破匿名用户。
- en: IoT device type identification using machine learning
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习进行物联网设备类型识别
- en: With the advent of IoT, the attack surfaces on any given target have increased
    exponentially. With new technology comes new risks, and, in the case of IoT, one
    such risk to an organization is the addition of a malicious IoT device connected
    to the organization's network. It is essential to be able to tell when such a
    device has been added to a network and to understand its nature. In this recipe,
    we'll build a machine learning model to classify network IoT devices by type.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 随着物联网（IoT）的到来，任何目标的攻击面都呈指数级增加。随着新技术的出现，也伴随而来的是新的风险，而在物联网的案例中，一个组织面临的风险之一就是恶意物联网设备被接入组织的网络。因此，能够判断网络中是否新增了此类设备，并了解其性质，是至关重要的。在本教程中，我们将构建一个机器学习模型，以按类型分类网络中的物联网设备。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The preparation for this recipe consists of installing the `sklearn`, `pandas`,
    and `xgboost` packages in `pip`. The instructions are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括在`pip`中安装`sklearn`、`pandas`和`xgboost`包。安装指令如下：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A dataset has been provided for you in the `iot_train.csv` and `iot_test.csv`
    files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集已通过`iot_train.csv`和`iot_test.csv`文件提供。
- en: How to do it…
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we''ll train and test a classifier on IoT network information:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将训练并测试一个分类器，基于物联网（IoT）网络信息：
- en: 'Import `pandas` and `os` and read in the training and testing data:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`和`os`，并读取训练和测试数据：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The data contains 298 features, as shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包含 298 个特征，如下图所示：
- en: '![](assets/9c50983f-be84-4f46-9db7-6d554bbccf6e.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c50983f-be84-4f46-9db7-6d554bbccf6e.png)'
- en: 'Create a training and testing dataset, where the target is the device category:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建训练和测试数据集，其中目标是设备类别：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The device categories are security camera, TV, smoke detector, thermostat, water
    sensor, watch, baby monitor, motion sensor, lights, and socket.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设备类别包括安全摄像头、电视、烟雾探测器、恒温器、水传感器、手表、婴儿监视器、运动传感器、灯具和插座。
- en: 'Encode the class categories into numerical form:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类别标签编码为数值形式：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Instantiate an `xgboost` classifier:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`xgboost`分类器：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Train and test the `xgboost` classifier:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练并测试`xgboost`分类器：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作…
- en: An important motivation for this recipe is that we can't rely on the IP address
    as an identifier of the device, since this value can be spoofed. Consequently,
    we would like to analyze the traffic's high-level data, that is, the metadata
    and traffic statistics, rather than content, to determine whether the device belongs
    to the network. We begin by reading in the training and testing datasets. We go
    on to featurize these and perform a quick data exploration step by observing the
    classification labels (*step 2*). To feed these into our classifier, we convert
    these categorical labels into numerical ones to be used to train our machine learning
    classifier (*step 3*). Having featurized the data in *step 4* and *step 5*, we
    instantiate, train and test an `xgboost` classifier, obtaining a score of `0.66`
    on the testing set. There are 10 categories of IoT devices in the associated data.
    The baseline of randomly guessing between the 10 would yield an accuracy of 0.1\.
    The `XGBoost` classifier trained here attains an accuracy of 0.66, suggesting
    that it is indeed a promising approach to classify IoT devices successfully based
    on high-level traffic data.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的一个重要动机是我们不能依赖 IP 地址作为设备的标识符，因为该值可能会被伪造。因此，我们希望分析流量的高层数据，即元数据和流量统计信息，而不是内容，以确定设备是否属于该网络。我们首先读取训练和测试数据集。接着我们对数据进行特征提取，并通过观察分类标签进行快速数据探索（*第
    2 步*）。为了将这些数据输入到我们的分类器中，我们将分类标签转换为数值标签，用于训练我们的机器学习分类器（*第 3 步*）。在*第 4 步*和*第 5 步*中提取特征后，我们实例化、训练并测试一个`xgboost`分类器，最终在测试集上获得了`0.66`的评分。关联数据中有
    10 类物联网设备。随机猜测 10 类设备的基线准确率为 0.1。这里训练的`XGBoost`分类器达到了 0.66 的准确率，表明它确实是一个有前景的基于高层流量数据成功分类物联网设备的方法。
- en: Keystroke dynamics
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 击键动态学
- en: Keystroke dynamics, aka typing biometrics, is the study of recognizing a person
    by the way they type. One important use case is recognizing which user is logging
    in using a given credential, for example, who is logging in as root? Another use
    case is recognizing when a different user has typed a sequence of keystrokes.
    In this recipe, we'll show how to use a machine learning-based keystroke dynamics
    algorithm.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 击键动态学，也叫打字生物特征识别，是通过一个人的打字方式来识别其身份的研究领域。一个重要的应用场景是识别使用给定凭证登录的用户，例如，谁正在以 root
    用户登录？另一个应用场景是识别何时有不同的用户输入了一系列击键。在这个示例中，我们将展示如何使用基于机器学习的击键动态学算法。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will require a Linux virtual or real machine. In preparation, do
    the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例需要在 Linux 虚拟机或实际机器上运行。准备工作如下：
- en: Install `git` on your device.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备上安装`git`。
- en: 'In a Terminal, run the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，运行以下命令：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Clone the `git` repository containing the code for the keystroke dynamics algorithm:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆包含击键动态学算法代码的`git`仓库：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps, we''ll train the model on two users'' typing patterns
    and then use the model to recognize one of the user''s typing patterns. The recipe
    should be run on a Linux virtual or real machine:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将训练模型，基于两位用户的打字模式，然后使用该模型识别其中一位用户的打字模式。此示例应在 Linux 虚拟机或实际机器上运行：
- en: 'Run `example.py`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`example.py`：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Train on the keystrokes of user 1 by selecting option 1 and then typing in
    the text:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择选项 1 并输入文本来训练用户 1 的击键模式：
- en: '![](assets/209f8806-a477-4839-b1e1-221d511f8a53.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/209f8806-a477-4839-b1e1-221d511f8a53.png)'
- en: 'Run `example.py` and train on the keystrokes of user 2 by selecting option
    1 and then having user 2 type in the text:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `example.py` 并通过选择选项 1 来训练用户 2 的按键动态，然后让用户 2 输入以下文本：
- en: '![](assets/b69bbb11-e7fb-4448-b4c9-fb5081e45a08.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b69bbb11-e7fb-4448-b4c9-fb5081e45a08.png)'
- en: Run `example.py` and, this time, select option 2.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `example.py`，这次选择选项 2。
- en: 'Have one of the users type the text again. The algorithm will match the keyboard
    dynamics to the most similar typist from the training data:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让其中一个用户再次输入文本。算法将匹配该用户的键盘动态，并与训练数据中最相似的打字员进行匹配：
- en: '![](assets/04dfcca1-d472-4c2a-a11e-b4c06a74d71f.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04dfcca1-d472-4c2a-a11e-b4c06a74d71f.png)'
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Analyzing keystroke dynamics utilizes the rhythm and pace at which a user types
    on a keyboard to verify that individual's identity. We begin by setting up some
    baselines. In *step 1* and *step 2*, we set up the keystroke dynamics system to
    learn the typing pattern of the first user. We then do the same for the second
    user (*step 3*). This establishes our *normal* users, as well as their typing
    patterns. In *step 4* and *step 5*, we utilize our trained model (trained in *steps
    1*-*3*), to determine who the current user is. As you can see, the classifier
    outputs a similarity score and a prediction of who the current user is from its
    catalog of saved users. This allows us to detect unauthorized users, as well as
    to simply keep track of system usage.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按键动态分析利用用户在键盘上的打字节奏和速度来验证该用户的身份。我们首先设置一些基准。在*步骤 1* 和 *步骤 2* 中，我们设置按键动态系统以学习第一个用户的打字模式。然后我们对第二个用户执行相同操作（*步骤
    3*）。这就建立了我们的*正常*用户及其打字模式。在*步骤 4* 和 *步骤 5* 中，我们利用经过训练的模型（在*步骤 1*-*3* 中训练）来确定当前用户是谁。如你所见，分类器输出相似度得分并预测当前用户是谁，依据的是它保存的用户目录。这使我们能够检测未经授权的用户，并能够简单地跟踪系统的使用情况。
- en: Malicious URL detector
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意 URL 检测器
- en: Malicious URLs cause billions of dollars of damage every year by hosting spam,
    malware, and exploits, as well as stealing information. Traditionally, defenses
    against these have relied on blacklists and whitelists – lists of URLs that are
    considered malicious, and lists of URLs that are considered safe. However, blacklists
    suffer from a lack of generality and an inability to defend against previously
    unseen malicious URLs. To remedy the situation, machine learning techniques have
    been developed. In this recipe, we'll run a malicious URL detector using character-level
    recurrent neural networks with Keras. The code is based on [https://github.com/chen0040/keras-malicious-url-detector](https://github.com/chen0040/keras-malicious-url-detector).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意 URL 每年造成数十亿美元的损失，原因包括托管垃圾邮件、恶意软件和漏洞攻击，以及窃取信息。传统上，对这些威胁的防御依赖于黑名单和白名单——分别是被认为恶意的
    URL 列表和被认为安全的 URL 列表。然而，黑名单存在缺乏通用性的问题，且无法防御之前未见过的恶意 URL。为了解决这一问题，已经开发出了机器学习技术。在本教程中，我们将使用
    Keras 运行一个基于字符级递归神经网络的恶意 URL 检测器。代码基于 [https://github.com/chen0040/keras-malicious-url-detector](https://github.com/chen0040/keras-malicious-url-detector)。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The preparation for this recipe consists of installing a number of packages
    in `pip`. The instructions are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括在 `pip` 中安装多个软件包。安装步骤如下：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In addition, clone the following `git` repository:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，克隆以下 `git` 仓库：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it…
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Train the bidirectional LSTM model:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练双向 LSTM 模型：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The training screen should look something like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 训练界面应如下所示：
- en: '![](assets/84819f8a-6cdb-44bc-92b1-ddf7aaae7375.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84819f8a-6cdb-44bc-92b1-ddf7aaae7375.png)'
- en: 'Test the classifier:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试分类器：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The testing screen should look like the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 测试界面应如下所示：
- en: '![](assets/9c1798ae-4ed4-4b4c-9241-67f07a4fd2cb.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c1798ae-4ed4-4b4c-9241-67f07a4fd2cb.png)'
- en: 'Finally, you can see the results under the `reports` folder:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在 `reports` 文件夹下看到结果：
- en: '![](assets/44212e52-6f14-44fd-864b-1937f0dbf77b.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44212e52-6f14-44fd-864b-1937f0dbf77b.png)'
- en: How it works…
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This is a relatively simple recipe but serves as a good starting point for
    a more high-powered malicious URL detector. The dataset consists of URLs with
    the labels 0 and 1, depending on whether they are malicious or benign:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的方案，但它是构建更高效恶意 URL 检测器的良好起点。数据集由带有标签 0 和 1 的 URL 组成，取决于它们是恶意的还是良性的：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In *step 1*, we train a bidirectional LSTM model. By digging deeper into the
    code, you can adjust the network to your needs. Having trained our model, it is
    important to assess its performance and perform some sanity checks. We do so in
    *step 2*, the testing step, consisting of displaying the results of the classifier
    on a random selection of 20 URLs. In general, a bidirectional LSTM is a recurrent
    neural network architecture that shows great promise, due to its ability to remember
    information and analyze data from both beginning to end, and end to beginning.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们训练了一个双向LSTM模型。通过深入代码，你可以根据自己的需求调整网络。训练好模型后，重要的是评估其性能并进行一些合理性检查。我们在*步骤
    2*中进行测试步骤，通过在20个随机选定的URL上展示分类器的结果来进行。一般来说，双向LSTM是一种循环神经网络架构，因其能够记住信息并分析从前到后的数据及从后到前的数据而展现出巨大的潜力。
- en: Deep-pwning
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deep-pwning
- en: Deep-pwning is a framework for evaluating the robustness of machine learning
    tools against adversarial attacks. It has become widely known in the data science
    community that naive machine learning models, such as deep neural networks trained
    with the sole aim of classifying images, are very easily fooled.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Deep-pwning是一个用于评估机器学习工具在对抗性攻击下鲁棒性的框架。数据科学界已经广泛认识到，单纯为分类图像而训练的深度神经网络等简单机器学习模型非常容易被欺骗。
- en: 'The following diagram shows Explaining and Harnessing Adversarial Examples,
    I. J. Goodfellow et al:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了《解释与利用对抗样本》，I. J. Goodfellow 等人的研究：
- en: '![](assets/9ac0d85b-0396-4dcd-af64-85b1d4e362f1.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ac0d85b-0396-4dcd-af64-85b1d4e362f1.png)'
- en: Cybersecurity being an adversarial field of battle, a machine learning model
    used to secure from attackers ought to be robust against adversaries. As a consequence,
    it is important to not only report the usual performance metrics, such as accuracy,
    precision, and recall, but also to have some measure of the adversarial robustness
    of the model. The deep-pwning framework is a simple toolkit for doing so.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全是一个对抗性较强的领域，用于防御攻击者的机器学习模型应当具备抗对抗性攻击的鲁棒性。因此，不仅要报告通常的性能指标，如准确率、精确度和召回率，还需要有一定的对抗鲁棒性测量。deep-pwning框架就是一个实现这一目标的简单工具包。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In preparation for this recipe, follow these steps:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 准备这个食谱时，请按照以下步骤操作：
- en: Install `git` on your device.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的设备上安装`git`。
- en: 'Download or clone the repository using Git by using the following:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令通过Git下载或克隆该仓库：
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Install the requirements for the repo.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装该仓库的依赖项。
- en: 'In a Terminal, go to the root directory of your repository and run the following
    command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，进入仓库的根目录并运行以下命令：
- en: '[PRE70]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it…
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the following steps, you will utilize deep-pwning to attack LeNet5 on the
    MNIST digits dataset:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，你将利用deep-pwning对MNIST数字数据集上的LeNet5进行攻击：
- en: 'From the directory down, run the MNIST driver using the following command:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该目录向下，使用以下命令运行MNIST驱动程序：
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The result should appear like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该像这样显示：
- en: '![](assets/850ff85a-8a0e-4458-80f8-9b13406ba064.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/850ff85a-8a0e-4458-80f8-9b13406ba064.png)'
- en: How it works…
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In *step 1*, we create a large dataset of adversarial samples; namely, 150,000
    adversarial samples are created, almost all of which are able to fool LeNet5 on
    digits. To examine these adversarial samples, unpickle the pickle in the output
    directory, like so:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们创建了一个包含对抗样本的大型数据集；即，创建了150,000个对抗样本，几乎所有这些样本都能够欺骗LeNet5对数字的识别。要检查这些对抗样本，可以像这样解压输出目录中的pickle文件：
- en: '![](assets/bb8fd2b2-dd3f-4dbf-906c-6c8e2af2fdf7.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb8fd2b2-dd3f-4dbf-906c-6c8e2af2fdf7.png)'
- en: 'Under `utils`, a file named `mnist_read_pickle.py` takes as an argument the
    `pickle` file. Running it displays one of the adversarial samples. The following
    image tricks LeNet5 into thinking that it is seeing the number 1:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`目录下，有一个名为`mnist_read_pickle.py`的文件，它将`pickle`文件作为参数传入。运行它会显示一个对抗样本。以下图像让LeNet5误以为它看到的是数字1：
- en: '![](assets/d48b2dcf-0f92-4bb1-a4a8-fdf33014de85.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d48b2dcf-0f92-4bb1-a4a8-fdf33014de85.png)'
- en: The deep-pwning framework is designed to be modular, so a user plugs in and
    modifies pieces to suit their needs. For instance, replacing the MNIST dataset
    and the LeNet5 architecture.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: deep-pwning框架设计为模块化，因此用户可以插入并修改各个部分以满足自己的需求。例如，替换MNIST数据集和LeNet5架构。
- en: Deep learning-based system for the automatic detection of software vulnerabilities
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于深度学习的自动化软件漏洞检测系统
- en: Experts in information security can usually identify potentially exploitable
    pieces of code. Yet, the work is intensive and costly, and may not be sufficient
    to make a program secure. One of the great advantages of deep learning over traditional
    machine learning is that features can be automatically discovered. This allows
    us to alleviate the need for a human expert on vulnerabilities, as well as to
    produce more effective systems. In this recipe, we'll utilize a modified version
    of *VulDeePecker : **A Deep Learning-Based System for Vulnerability Detection* ([https://arxiv.org/pdf/1801.01681.pdf](https://arxiv.org/pdf/1801.01681.pdf)),
    to automatically detect buffer error vulnerabilities and resource management errors
    in C/C++ software.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '信息安全专家通常能够识别出潜在可利用的代码片段。然而，这项工作是繁重且成本高昂的，并且可能不足以确保程序的安全性。深度学习相较于传统机器学习的一个重要优势是可以自动发现特征。这使得我们能够减少对漏洞领域人类专家的依赖，并且能产生更有效的系统。在本教程中，我们将使用一个修改版的*VulDeePecker
    : **基于深度学习的漏洞检测系统* ([https://arxiv.org/pdf/1801.01681.pdf](https://arxiv.org/pdf/1801.01681.pdf))，自动检测C/C++软件中的缓冲区错误漏洞和资源管理错误。'
- en: Getting ready
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The preparation for this recipe consists of installing the `pandas`, `gensim`,
    `keras`, `tensorflow`, and `sklearn` packages in `pip`. The instructions are as
    follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的准备工作包括安装`pandas`、`gensim`、`keras`、`tensorflow`和`sklearn`等软件包，使用`pip`进行安装。安装指令如下：
- en: '[PRE72]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In addition, for this recipe, clone the repository for VulDeePecker:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了进行本教程操作，克隆VulDeePecker的代码库：
- en: 'Install `git` and then, in a Terminal, run the following command:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`git`，然后在终端运行以下命令：
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Two datasets are available in the `datasets` folder, `cwe119_cgd.7z` and `cwe399_cgd.7z`.
    If you wish to use them for this recipe, extract them.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`datasets`文件夹中有两个数据集，`cwe119_cgd.7z`和`cwe399_cgd.7z`。如果你想使用它们，请解压。'
- en: How to do it…
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Collect a training dataset of gadgets and place it under `datasets`. Two datasets
    are available in the `datasets` folder, and they are of this form:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集一个包含代码小片段的训练数据集，并将其放在`datasets`文件夹下。该文件夹中有两个数据集，它们的形式如下：
- en: '![](assets/5bbdf15e-6406-47bc-8453-6fb22a8ac5f2.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bbdf15e-6406-47bc-8453-6fb22a8ac5f2.png)'
- en: Train and test the deep learning model on your dataset.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的数据集上训练和测试深度学习模型。
- en: 'This is accomplished by running the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来完成此操作：
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is displayed in the following screenshot:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示在以下截图中：
- en: '![](assets/714ed965-843e-4b21-9bd8-1d3c857a5f23.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/714ed965-843e-4b21-9bd8-1d3c857a5f23.png)'
- en: 'Collect the dataset you would like to predict on and place it under `datasets`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集你希望进行预测的数据集，并将其放置在`datasets`文件夹下：
- en: '![](assets/86517346-69b4-49ec-97f7-9d758835d94b.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86517346-69b4-49ec-97f7-9d758835d94b.png)'
- en: 'Use your trained model to predict whether these are vulnerable pieces of code
    by running the following command:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你训练好的模型通过运行以下命令来预测这些代码是否存在漏洞：
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![](assets/0422d9eb-52b2-4079-a859-beecd558e5de.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0422d9eb-52b2-4079-a859-beecd558e5de.png)'
- en: How it works…
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'For machine learning to work for vulnerability detection, you need to find
    representations of the software programs that are amenable to learning. For this
    purpose, we use code gadgets, which are transformed into vectors. A code gadget
    is a selection of lines of code that are semantically related to each other. In
    *step 1*, we collect such code gadgets for training. You can see an image of three
    code gadgets, along with labels. Here, a label of 1 indicates a vulnerability,
    while a label of 0 indicates no vulnerability. To extract gadgets from the desired
    program, it is advised to use the commercial product Checkmarx to extract program
    slices, and then assemble them into code gadgets. Another dataset is available.
    That dataset, `cwe-119`, corresponds to buffer error vulnerabilities. Next, we
    train a deep learning model on our vulnerability dataset (*step 2*). The deep
    learning model used is a **Bidirectional Long Short-Term Memory** (**BLSTM**),
    whose architecture is given as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让机器学习能够进行漏洞检测，你需要找到能够学习的软件程序表示方式。为此，我们使用代码小片段，并将它们转换为向量。代码小片段是一组语义相关的代码行。在*步骤1*中，我们为训练收集这样的代码小片段。你可以看到三种代码小片段及其标签的图片。这里，标签为1表示存在漏洞，而标签为0表示没有漏洞。为了从所需程序中提取小片段，建议使用商业产品Checkmarx来提取程序切片，然后将它们组装成代码小片段。另一个数据集`cwe-119`与缓冲区错误漏洞相关。接下来，我们在我们的漏洞数据集上训练一个深度学习模型（*步骤2*）。所使用的深度学习模型是**双向长短期记忆网络**（**BLSTM**），其架构如下所示：
- en: '[PRE76]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that the training phase automatically saves the model as `[base-name-of-training-dataset]_model.h5`.
    We are now ready to look for new vulnerabilities. So, we place a testing set in
    `datasets` (*step 3*) and then put our neural network to use by predicting vulnerabilities
    in this new set (*step 4*).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，训练阶段会自动将模型保存为`[base-name-of-training-dataset]_model.h5`。现在我们准备寻找新的漏洞。所以，我们将测试集放入`datasets`中（*步骤
    3*），然后通过预测这个新数据集中的漏洞来使用我们的神经网络（*步骤 4*）。
