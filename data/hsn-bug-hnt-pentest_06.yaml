- en: CSRF and Insecure Session Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF和不安全的会话认证
- en: '**Cross-Site Request Forgery** (**CSRF**) is when an attacker takes advantage
    of a logged-in user''s authenticated state to execute malicious application requests
    and change the user''s app in harmful ways. Because the attacker can''t see the
    result of any attack, it''s usually less about exfiltrating information and more
    about exploiting the app''s capabilities (for example, making the user of a mobile
    payment system send money to the wrong person). There''s often a strong social
    engineering aspect involved: phishing and other techniques are used to get a user
    to click on the link that will kick off a malicious request and act as the CSRF
    attack vector.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）是指攻击者利用已登录用户的身份验证状态执行恶意应用程序请求，并以有害的方式更改用户的应用程序。由于攻击者无法看到任何攻击的结果，通常与窃取信息无关，更多的是利用应用程序的功能（例如，让移动支付系统的用户向错误的人发送资金）。通常涉及强烈的社会工程方面：钓鱼和其他技术被用来诱使用户点击链接，从而发起恶意请求并充当CSRF攻击向量。'
- en: CSRF is often possible because authentication credentials or cookies meant for
    one part of an application mistakenly allow access to another. An example would
    be that while you're logged into PayPal or another payment app, you click on a
    link sent to you in a chat session. The link executes code that takes the authentication
    cookie you have in your browser to make an (authenticated) request sending money
    to the attacker. Unlike XSS, the danger isn't that you'll send sensitive information
    to the attacker, allowing them to impersonate or defraud you later;  instead,
    the danger is a direct consequence of the actions you're allowed to take as a
    logged-in user of the app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF通常是可能的，因为意图用于应用程序的身份验证凭据或cookie错误地允许访问另一个部分。例如，当您登录到PayPal或其他支付应用程序时，您点击在聊天会话中发送给您的链接。该链接执行代码，获取您在浏览器中的身份验证cookie，以进行（经过身份验证的）请求将资金发送给攻击者。与XSS不同，危险不在于您将敏感信息发送给攻击者，从而使他们能够稍后冒充或欺诈您；相反，危险是作为应用程序的已登录用户允许执行的操作的直接后果。
- en: Many frameworks (Spring, Joomla, and Django) have their own solutions for preventing
    CSRF, which usually consist of tying a cookie's authentication ability to a specific
    in-app action. But, despite CSRF's status as a solved problem, it persists as
    a recurring bug in the annual OWASP Top-10 surveys. Like SQLi, CSRF is a simple-but-damaging
    vulnerability that endures largely because of the tension in software development
    between security and productivity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架（Spring、Joomla和Django）都有自己的解决方案来防止CSRF，通常包括将cookie的身份验证能力与特定的应用程序内操作绑定。但是，尽管CSRF被视为已解决的问题，但它仍然作为年度OWASP十大调查中的一个经常出现的漏洞。与SQLi一样，CSRF是一个简单但具有破坏性的漏洞，主要是因为软件开发中安全性和生产力之间的紧张关系。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Mechanics of CSRF
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSRF的机制
- en: Tools to use for finding and validating CSRF vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于查找和验证CSRF漏洞的工具
- en: Discovering, validating, and reporting on CSRF vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现、验证和报告CSRF漏洞
- en: Technical Requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we'll be using Burp Suite and—for our everyday web browsing
    and proxy—Chrome (`66.0.3359.139`). We'll once again be employing Python 3.6.5
    and the standard macOS version of shell (`sh`) for scripting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用Burp Suite和Chrome（`66.0.3359.139`）作为我们日常的网络浏览和代理工具。我们将再次使用Python 3.6.5和标准的macOS版本的shell（`sh`）进行脚本编写。
- en: Building and Using CSRF PoCs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和使用CSRF PoC
- en: A CSRF proof of concept is just a short HTML snippet that, when executed by
    a user, will take advantage of the weak CSRF defence and change the application
    state in unexpected or unwanted ways, validating the vulnerability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF概念验证只是一个简短的HTML片段，当用户执行时，将利用弱CSRF防御并以意想不到或不希望的方式更改应用程序状态，从而验证漏洞。
- en: Creating a CSRF PoC Code Snippet
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CSRF PoC代码片段
- en: 'As the basis for building a CSRF PoC snippet, let''s go back to a form on the
    deliberately-vulnerable web app, `webscantest.com`, that''s vulnerable to both
    XSS and CSRF:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构建CSRF PoC片段的基础，让我们回到一个故意易受攻击的网页应用程序`webscantest.com`上的一个表单，该表单既容易受到XSS攻击，也容易受到CSRF攻击：
- en: '![](assets/f06d3b4b-5385-4cee-8b16-efb698a731f0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f06d3b4b-5385-4cee-8b16-efb698a731f0.png)'
- en: 'Now we can fill in the values for our form, entering the information for one
    `William` `Private Mandella` `Mandella`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以填写表单的值，输入一个`William` `Private Mandella` `Mandella`的信息：
- en: '![](assets/89b33017-93ea-44cb-8fca-1dea49657bb0.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89b33017-93ea-44cb-8fca-1dea49657bb0.png)'
- en: In order to build our CSRF PoC, it can be helpful to see the form as an HTTP
    action, so we can grab the type of data-encoding, HTTP verb, and form-field information
    all at once.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的 CSRF PoC，将表单视为一个 HTTP 操作是有帮助的，这样我们可以一次性获取数据编码类型、HTTP 动词和表单字段信息。
- en: 'In order to view that request, make sure you''re viewing the page in a browser
    connected to your Burp Proxy and then turn the intercept feature on from within
    the Proxy tab. Clicking Submit, you should see the form hang as the Burp Proxy
    intercepts (and holds onto) the form''s HTTP `POST` request:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看该请求，确保你在浏览器中打开页面，并且该浏览器已连接到你的 Burp Proxy，然后在 Proxy 标签中启用拦截功能。点击提交后，你应该会看到表单暂停，因为
    Burp Proxy 拦截并保持了表单的 HTTP `POST` 请求：
- en: '![](assets/d84b9b57-a399-459d-9a9d-95b15028e072.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d84b9b57-a399-459d-9a9d-95b15028e072.png)'
- en: 'From this, we can deduce all the necessary parts of our CSRF PoC. Let''s take
    a look at the code and then break down the rationale behind each tag and attribute:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以推导出构建 CSRF PoC 所需的所有部分。让我们看一下代码，然后逐一分析每个标签和属性背后的原因：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see the form's `enctype` attribute is pulled directly from the intercepted
    request—`method` and the URL value for the `action` attributes too. In fact, this
    entire snippet is simply a reverse-engineered expression of the submission in
    HTML. We know what HTTP request the form created – now we've written the code
    to produce that behavior.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到表单的`enctype`属性是直接从拦截的请求中提取的——`method`和`action`属性的 URL 值也是如此。事实上，这个代码片段本质上是提交内容的反向工程表达。我们知道表单创建了什么样的
    HTTP 请求——现在我们编写了代码来实现这种行为。
- en: This code imitates the form on the original `webscantest.com` page. But in the
    case of a real, malicious CSRF attack, the attacker probably wouldn't want to
    just trigger an exact duplicate of an ordinary request the user had already made.
    More likely, they'd alter it for their own purposes – switching financial routing
    numbers, changing account passwords, or altering some other piece of critical
    information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码模仿了原始`webscantest.com`页面上的表单。但在实际的恶意 CSRF 攻击中，攻击者可能并不想简单地触发用户已提交的普通请求的精确复制。更可能的是，他们会根据自己的需要对其进行修改——例如更改财务路由号、修改账户密码或更改其他关键性信息。
- en: In this case, the form fields might not be as ripe for exploitation, but the
    principal holds for more dangerous situations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，表单字段可能并不是那么容易被利用，但在更危险的情况下，这一原则依然适用。
- en: 'Let''s still have a little fun by promoting `Private Mandella` to his rightful
    rank of major. Here''s the altered code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还是稍微玩一下，将`Private Mandella`晋升为他应得的少将军衔。下面是修改后的代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But if the intent is to deceive the target of the CSRF attack into doing what
    we want – unwittingly changing Mandella''s rank – why are we showing them? Why
    offer the user a chance to see or manipulate the `nick` input field at all? See
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们的目的是让 CSRF 攻击的目标无意中做出我们想要的操作——例如改变 Mandella 的军衔——那么为什么要让他们看到这个呢？为什么要给用户一个机会查看或操作`nick`输入字段呢？请看以下内容：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this last snippet, we've changed the name of the `other-nick` input field
    with the `nick` label our hapless user is expecting, while making the real `nick`
    input hidden—which contains our secret value, the rank we think the major deserves.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的代码片段中，我们将`other-nick`输入字段的名称更改为我们的不幸用户期待的`nick`标签，同时将真正的`nick`输入隐藏——它包含了我们的秘密值，即我们认为该用户应得的军衔。
- en: Of course, when you're creating a CSRF PoC as part of a bug-report submission,
    you want to make sure you're not actually changing or modifying sensitive information
    (such as a password or transaction amount), though it can be useful to make a
    small alteration in order to illustrate the possible impact of the bug.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当你创建一个 CSRF PoC 作为 bug 报告的一部分时，你要确保不要实际更改或修改敏感信息（例如密码或交易金额），尽管为了说明 bug 可能的影响，进行一些小的修改是有用的。
- en: Validating Your CSRF PoC
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证你的 CSRF PoC
- en: Now that we've created a basic CSRF PoC, we can go about applying it to prove
    the presence of a CSRF vulnerability.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个基本的 CSRF PoC，我们可以应用它来证明 CSRF 漏洞的存在。
- en: 'Using our PoC snippet is extremely simple. We just open it as a local file
    in our browser and submit the form we''ve coded:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 PoC 代码片段非常简单。我们只需将其作为本地文件在浏览器中打开，然后提交我们编写的表单：
- en: '![](assets/93b3182f-9213-49de-979f-b279b1a9f2f6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93b3182f-9213-49de-979f-b279b1a9f2f6.png)'
- en: Here's what our PoC looks like opened in Chrome. There's no CSS making it pretty
    – our HTML snippet is as bare bones as it gets – but in the case of a CSRF vulnerability
    being exploited in the wild, most of the fields would probably be hidden anyway,
    with either a fake form to get the user to make the submission, or a way of automatically
    submitting the form on page load. Note that in the `nick` field, we have `Private
    Mandella`—our decoy data in action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 Chrome 中打开的 PoC。没有 CSS 来美化它——我们的 HTML 片段简洁到极点——但如果在现实中利用 CSRF 漏洞进行攻击，大多数字段可能都已隐藏，可能会有一个虚假的表单让用户提交，或者在页面加载时自动提交表单。请注意，在
    `nick` 字段中，我们有 `Private Mandella`——我们的诱饵数据正在发挥作用。
- en: 'Let''s submit the form to see whether we can successfully forge the cross-site
    request:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提交表单，看看是否能成功伪造跨站请求：
- en: '![](assets/d150e526-88ae-462c-abf7-4f067e38dd04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d150e526-88ae-462c-abf7-4f067e38dd04.png)'
- en: Request forged! We've been redirected to a success screen indicating the `POST`
    request generated from our local form has been accepted! Also, critically, we
    can see our hidden field containing the real value for the `nick` input tag was
    the value accepted as formerly Private, which is now Major Mandella's nick.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请求伪造成功！我们已经被重定向到一个成功页面，表明我们本地表单生成的 `POST` 请求已被接受！此外，关键的是，我们可以看到我们的隐藏字段，其中包含
    `nick` 输入标签的真实值，这个值被接受并原本为私密的，现在变成了 Major Mandella 的昵称。
- en: This example might still seem fairly innocuous – messing with part of a username
    – but the ability to change a user's application state by altering their form
    data is serious. Even altering a username can actually be a clever way of stealing
    an account – if the affected application didn't allow password retrieval using
    only an account-linked email, the victim of the attack might not be able to resolve
    their authentication problems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能仍然看起来相当无害——只是修改了用户名的一部分——但通过改变用户的表单数据来改变应用程序状态是很严重的。即使是修改用户名，也可能是盗取账户的巧妙方式——如果受影响的应用程序不允许仅使用与账户关联的电子邮件找回密码，攻击的受害者可能无法解决认证问题。
- en: Creating Your CSRF PoC Programmatically
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化创建 CSRF 漏洞验证代码（PoC）
- en: Rather than manually constructing a PoC just by eyeballing the intercepted HTTP
    request in our Burp proxy tab, it would be awfully nice if we had a script that
    could take the information we need as a series of input (from either a CLI argument,
    a web scraper, or another source).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与其通过手动构建 PoC 仅凭浏览 Burp 代理标签中的拦截 HTTP 请求，不如有一个脚本可以将我们需要的信息作为一系列输入（来自 CLI 参数、网页爬虫或其他来源），那就太好了。
- en: Let's do it. With just a little Python, we can make a short script that painlessly
    formats our info into a CSRF PoC.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。只需一点 Python，我们就可以编写一个简短的脚本，轻松地将我们的信息格式化为 CSRF 漏洞验证代码（PoC）。
- en: 'Let''s start by defining the data we''ll need to build the PoC. We''ll start
    defining those variables right after we set up our interpreter in our new `csrf_poc_generator.py`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义构建 PoC 所需的数据。我们将在设置解释器后，在新的 `csrf_poc_generator.py` 文件中开始定义这些变量：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This structure – strings for the basic `form` tag attributes and a `fields`
    list of dictionaries with all the information we need to build the different form
    fields – is simple enough as a starting point, while also allowing some basic
    capabilities. Specifically, the abilities to add an arbitrary amount of form fields
    and to add new attributes to make new form objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构——为基本 `form` 标签属性定义字符串，并为需要构建的不同表单字段提供信息的包含字典的 `fields` 列表——作为起点非常简单，同时也提供了一些基本的功能。具体来说，可以添加任意数量的表单字段并添加新属性以创建新的表单对象。
- en: Now we just need some logic to take this data and create the necessary HTML
    markup. Thankfully, the HTML parser we used in [Chapter 3](23759e04-8982-41fd-b936-580865a51439.xhtml),
    *Preparing for an Engagement* to extract the JavaScript from a page we were crawling
    for vulnerabilities – Beautiful Soup – can also be used to create markup.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要一些逻辑来处理这些数据并生成必要的 HTML 标记。幸运的是，我们在[第 3 章](23759e04-8982-41fd-b936-580865a51439.xhtml)《准备参与攻击》中使用的
    HTML 解析器——Beautiful Soup——不仅能提取我们爬取页面的 JavaScript，还能用来创建标记。
- en: 'For example, here''s the code creating our outermost `html` tag that will wrap
    our form:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是生成我们最外层 `html` 标签的代码，它将包裹我们的表单：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we''re just instantiating the HTML document as a single closed
    `html` tag. To insert a child element, we use this code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是将 HTML 文档实例化为一个单一的闭合 `html` 标签。要插入子元素，我们使用以下代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Following each line of the script, we grab a reference to that root `html` element,
    create a new tag for the `form` that will be our CSRF PoC, then append that form
    tag as a child element to its `html` parent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的每一行之后，我们获取对根`html`元素的引用，为将成为我们 CSRF PoC 的`form`创建一个新标记，然后将该表单标记作为其`html`父元素的子元素附加。
- en: Using the module this way illustrates its advantages over plain string manipulation—we
    don't have to constantly break up and nest successive elements and the `append()`
    syntax also makes it easier to loop through and nest multiple children (which
    will come in handy).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用模块展示了它相对于纯字符串操作的优势——我们不必不断地分解和嵌套连续的元素，而且`append()`语法也使得循环和嵌套多个子元素变得更容易（这将很有用）。
- en: 'With that structure in mind, we need to build the markup for the last (and
    most important) part of the PoC—the form fields. We''ll leverage the fact that
    we can nest multiple children in a loop and that we have our form field data stored
    in an enumerable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种结构，我们需要构建 PoC 的最后（也是最重要）部分的标记—表单字段。我们将利用我们可以在循环中嵌套多个子元素以及我们的表单字段数据存储在一个可枚举中的事实：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code gives us the right number of input, but of course we still need logic
    to add `type`, `name`, and other attributes. Note that, since we don''t need to
    latter retrieve the variable references for the tags we''re creating, we can go
    ahead and overwrite them with each iteration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码给我们正确数量的输入，但当然我们仍然需要逻辑来添加`type`、`name`和其他属性。请注意，由于我们不需要后来检索我们正在创建的标记的变量引用，我们可以继续用每次迭代覆盖它们：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might be wondering: why not just add another argument to the `new_tag()`
    call in order to address the input''s `name` and `type` in a single line?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：为什么不在`new_tag()`调用中添加另一个参数，以便在一行中处理输入的`name`和`type`？
- en: 'The `field_tag[''name''] = field[''name'']` line is an admittedly inelegant
    solution to the fact that `name` is a reserved keyword in Beautiful Soup. That
    means we need to use a part of the API that lets us define the attribute using
    a string, which this method does. Our final addition to complete the basic structure
    of the form is a submit `input` field. We can achieve that in two lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`field_tag[''name''] = field[''name'']`这一行是对 Beautiful Soup 中`name`是保留关键字这一事实的一个不太优雅的解决方案。这意味着我们需要使用
    API 的一部分，让我们使用字符串来定义属性，这个方法就是这样做的。我们为完成表单的基本结构的最后补充是一个提交`input`字段。我们可以用两行代码实现：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s the result of those additional changes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外更改的结果如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To take this further, we need to extend our use of attributes, and finally use
    the other variables (such as `action` and `method`) we defined earlier. We can
    do that while also adding a `label` tag for each appropriate `input` field.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步进行，我们需要扩展我们对属性的使用，并最终使用我们之前定义的其他变量（如`action`和`method`）。我们可以在为每个适当的`input`字段添加一个`label`标签的同时做到这一点。
- en: We can also extend our initial data structure to accompany some changes. Let's
    say we want to add a `value` attribute to each `input` (as we have in our other
    PoC). We can do that simply by adding an extra field in the dictionary for each
    form field.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展我们的初始数据结构以适应一些变化。假设我们想要为每个`input`添加一个`value`属性（就像我们在其他 PoC 中所做的那样）。我们只需在字典中为每个表单字段添加一个额外的字段即可。
- en: 'Here''s what it looks like when we put it all together:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把所有东西放在一起时，它看起来是这样的：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you're familiar with Python, you'll notice the logic is wrapped in a function
    and then bootstrapped in the `if __name__ == "__main__"` conditional so that we
    get the expected behavior when we run the script from the command line (the HTML
    is printed to `STDOUT`). At the same time, we can build other Python modules that
    import the `generate_poc()` function without side-effects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Python，你会注意到逻辑被封装在一个函数中，然后在`if __name__ == "__main__"`条件中引导，这样当我们从命令行运行脚本时就会得到预期的行为（HTML
    被打印到`STDOUT`）。同时，我们可以构建其他 Python 模块，导入`generate_poc()`函数而不会产生副作用。
- en: 'All of this generates the following markup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生成了以下标记：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It looks pretty much like the code we initially wrote from eyeballing the intercepted
    Burp request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与我们最初从拦截的 Burp 请求中编写的代码非常相似。
- en: 'Now to try it out! If we save this file, change Mandella''s rank again (making
    him a General), and open it in our browser, we can submit it to see whether our
    foray into meta-programming was a success:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来试一下！如果我们保存这个文件，再次更改 Mandella 的级别（使他成为一名将军），然后在浏览器中打开它，我们就可以提交它，看看我们对元编程的尝试是否成功：
- en: '![](assets/082c2992-dd79-4b31-8ccb-8449109b5062.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/082c2992-dd79-4b31-8ccb-8449109b5062.png)'
- en: Success! Based on a few simple data points, our code generated the code to prove
    this vulnerability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！根据一些简单的数据点，我们的代码生成了证明这个漏洞的代码。
- en: There are many ways to complete this script. As previously mentioned, the initial
    variables could be populated by command-line arguments, data pulled from a site,
    or a simple application form. The preceding script is a good starting point for
    any of those approaches.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个脚本有很多方法。如前所述，初始变量可以通过命令行参数、从网站提取的数据或简单的应用表单来填充。前面的脚本是所有这些方法的一个很好的起点。
- en: CSRF – An End-to-End Example
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF – 端到端示例
- en: 'Let''s take another look at a CSRF vulnerability on `webscantest.com`. Here''s
    the form we''ll be testing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下 `webscantest.com` 上的 CSRF 漏洞。这是我们将要测试的表单：
- en: '![](assets/68f5b43b-7d59-4fee-ac76-3d2682f3a18b.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68f5b43b-7d59-4fee-ac76-3d2682f3a18b.png)'
- en: 'Simple enough. Fire up the Burp proxy and make sure the Intercept feature is
    on, let''s fill in the form with a nice test value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单。启动 Burp 代理并确保拦截功能开启，接着我们填入一个合适的测试值：
- en: '![](assets/dcaafd6e-2165-4ec4-82e9-2d95682ec700.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dcaafd6e-2165-4ec4-82e9-2d95682ec700.png)'
- en: 'As a sidenote, Cyan is really cool – in the subtractive color system, Cyan
    is a primary color and can be created by removing red from white light. Let''s
    submit this form and then check back with Burp to see the intercepted request:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，青色真的很酷——在减色系统中，青色是原色，通过从白光中去除红色可以得到青色。让我们提交这个表单，然后回到 Burp 查看被拦截的请求：
- en: '![](assets/7bdcadc4-9b31-4fe3-b72b-69a2d889c00e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7bdcadc4-9b31-4fe3-b72b-69a2d889c00e.png)'
- en: 'OK, noting the important information – the HTTP request method, the form encoding,
    the field data, and so on – let''s take a look at what happens when we turn Intercept
    off and allow the `POST` request to resolve:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，注意重要信息——HTTP 请求方法、表单编码、字段数据等等——让我们看看当我们关闭拦截并允许 `POST` 请求完成时会发生什么：
- en: '![](assets/4bdd4353-82f1-497e-8c2b-8d862e3751ab.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4bdd4353-82f1-497e-8c2b-8d862e3751ab.png)'
- en: Here's what a successful submission looks like. Critically for us, we can see
    what value the form submitted through the success message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是成功提交后的样子。对我们来说，关键是我们可以通过成功消息看到表单提交了什么值。
- en: 'Let''s feed this information into our `csrf_poc_generator.py` script, making
    a few small changes where our important variables are declared so that we can
    pass them as command-line arguments. With those changes, here''s the new version
    of the top part of our script – notice the new `sys` and `ast` packages, and how
    we''re using `ast` to parse a text representation of a Python list into the actual
    data structure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些信息输入到我们的 `csrf_poc_generator.py` 脚本中，对我们声明重要变量的地方做一些小修改，以便我们可以将它们作为命令行参数传递。做完这些修改后，这是脚本顶部部分的新版本——请注意新的
    `sys` 和 `ast` 包，以及我们如何使用 `ast` 来解析 Python 列表的文本表示，转换成实际的数据结构：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The rest of our script is exactly the same. Now we can pass our critical information
    from the command line. Passing the field information right now is a little ungainly,
    but in the future, we could have it read from a generated JSON file or other data
    source (such as a web scraper). Here''s what our one-liner currently looks like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分的脚本完全一样。现在我们可以从命令行传递关键的信息。目前，传递字段信息有点笨拙，但未来我们可以让它从生成的 JSON 文件或其他数据源（如网络爬虫）中读取。这是我们目前的一行代码：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And this is what the PoC it outputs looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它输出的 PoC 的样子：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s what it looks like when we open it in Chrome:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 Chrome 中打开时的样子：
- en: '![](assets/f54a1333-3434-4c1c-9688-155dce4da3e5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f54a1333-3434-4c1c-9688-155dce4da3e5.png)'
- en: 'Strictly speaking, this CSRF PoC does what we need it to: it illustrates that
    we can forge form requests that originate from our own sources. But to make it
    just a tiny bit more black hat (and show the bounty program a hint of how the
    vulnerability could be exploited), let''s add some hidden-field chicanery.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这个 CSRF PoC 完成了我们需要的功能：它展示了我们可以伪造来自自己源的表单请求。但为了让它稍微黑帽一点（并向赏金计划展示一下该漏洞可能被如何利用），我们来添加一些隐藏字段的诡计。
- en: 'Here''s what our snippet looks like as it changes the visible form field to
    a dummy value and creates a second hidden field that contains our actual payload:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的代码片段的样子，它将可见表单字段更改为虚拟值，并创建一个包含实际有效载荷的第二个隐藏字段：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see in the malicious part – where we're populating the property the
    web app will actually consume – that we're submitting Peasoup as the user's favorite
    color. The depths of our depravity know no bounds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到恶意部分——我们正在填充 web 应用实际会消费的属性——我们提交了 Peasoup 作为用户的最爱颜色。我们的堕落深度无可限量。
- en: 'Pretending to be a hapless user, when we open our snippet in the browser, we
    don''t see any red flags (on the surface). If we opened our `dev` tools and started
    inspecting the hidden field element, it would be a different story:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假装成一个无助的用户，当我们在浏览器中打开代码片段时，我们不会看到任何明显的警告（表面上看）。但如果我们打开 `dev` 工具并开始检查隐藏字段元素，那将是另一个故事：
- en: '![](assets/cddb7a90-63f4-4858-8c9a-28ab9b88fe00.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cddb7a90-63f4-4858-8c9a-28ab9b88fe00.png)'
- en: 'Let''s go ahead and submit the form using our true favorite color: the visually
    beautiful and scientifically curious Cyan. What will the PoC return us? See the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续提交表单，使用我们真正最喜欢的颜色：视觉上美丽且科学上有趣的青色。PoC 会返回什么呢？请看以下内容：
- en: '![](assets/fed35a19-6a69-4b5b-9328-78aa0fcb34f1.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fed35a19-6a69-4b5b-9328-78aa0fcb34f1.png)'
- en: 'Peasoup – the ugliest and most cursed of colors. But more importantly for us,
    the success message shows our PoC has proved what it set out to do. After we do
    one more refactoring pass – putting the command-line argument parsing in the `if
    __name__ == "__main__":` bootstrapping conditional, where it belongs – and adding
    a PEP8-compatible function docstring, this is what our `csrf_poc_generator.py`
    looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 豆汤绿——最丑陋且最受诅咒的颜色。但更重要的是，成功信息表明我们的 PoC 已经证明了它的目标。经过一次重构，将命令行参数解析放入 `if __name__
    == "__main__":` 启动条件中，这才是它应在的位置，并添加了一个符合 PEP8 的函数文档字符串，最终我们的 `csrf_poc_generator.py`
    看起来是这样的：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With our script all cleaned up and the vulnerability successfully proven, now
    we can write our report.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理完脚本并成功证明漏洞后，我们现在可以编写报告了。
- en: Gathering Report Information
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集报告信息
- en: Let's walk through the info we need to write our report.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看写报告所需的信息。
- en: Category
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别
- en: This is a CSRF `POST` method attack.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种 CSRF `POST` 方法攻击。
- en: Timestamps
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳
- en: For our timestamp, we can use an approximate time for when we first submitted
    our CSRF PoC.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的时间戳，我们可以使用我们第一次提交 CSRF PoC 时的大致时间。
- en: URL
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL
- en: 'In our case, the vulnerable URL is simply the target of the `POST` action:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，易受攻击的 URL 仅仅是 `POST` 操作的目标：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Payload
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载
- en: For the PoC snippet we evil-ed up, the dastardly data alteration we made was
    forcing our user to select Peasoup as their favorite color. That's what we'll
    include as our Payload value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们恶搞过的 PoC 代码片段，我们所做的恶行就是迫使用户选择豆汤绿作为他们的最喜欢的颜色。这就是我们将作为负载值包括进去的内容。
- en: Methodology
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法论
- en: Our PoC was generated programmatically based on information taken from the intercepted
    form's HTTP request.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 PoC 是基于从拦截的表单 HTTP 请求中获取的信息，程序化生成的。
- en: Instructions to Reproduce
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现步骤
- en: For our instructions to reproduce, we can simply provide our CSRF PoC and list
    the very simple manual steps involved in submitting the forged form request.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的重现步骤，我们可以简单地提供我们的 CSRF PoC，并列出提交伪造表单请求的非常简单的手动步骤。
- en: Attack Scenario
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击场景
- en: Although the form where we've detected our vulnerability doesn't seem to be
    that critical (an individual's favorite color is not codeword-clearance-level
    information), the ability to change an individual's account information through
    unwanted application state changes is a serious flaw.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们检测到漏洞的表单看起来并不那么关键（个人最喜欢的颜色并不是机密等级的信息），但通过不必要的应用程序状态变化来更改个人账户信息是一个严重的缺陷。
- en: Final Report
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终报告
- en: 'Let''s use this information to format our submission:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些信息来格式化我们的提交：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of **Cross-Site Request Forgery** (**CSRF**)
    as a vulnerability, created and validated a CSRF PoC, created a CSRF PoC programmatically,
    and successfully documented the vulnerability for a bug-report submission. Hopefully,
    you've also come away with a sense of why the bug can be so severe, and a few
    attack scenarios you can use for a future impact report.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了作为一种漏洞的 **跨站请求伪造** (**CSRF**)，创建并验证了一个 CSRF PoC，程序化地创建了 CSRF PoC，并成功地为漏洞报告提交编写了文档。希望你也能理解为什么这个漏洞会如此严重，并掌握一些可以用于未来影响报告的攻击场景。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is CSRF?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 CSRF？
- en: What's one possible attack scenario for a malicious actor who discovers a CSRF
    vulnerability?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于发现 CSRF 漏洞的恶意行为者，可能的攻击场景是什么？
- en: What's the typical structure of a CSRF PoC?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSRF PoC 的典型结构是什么？
- en: How do you use a CSRF PoC to validate a vulnerability?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 CSRF PoC 来验证漏洞？
- en: What's the advantage of using BeautifulSoup to generate HTML, as opposed to
    raw string manipulation?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 BeautifulSoup 生成 HTML 相对于直接的字符串操作有什么优势？
- en: What type of CSRF attack did we engage in for our end-to-end example?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在端到端示例中使用了哪种类型的 CSRF 攻击？
- en: What kind of CSRF markup would a malicious actor use? How would it differ from
    our PoCs? How would it be similar?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意攻击者会使用什么样的 CSRF 标记？它与我们的 PoC 有什么不同？又有哪些相似之处？
- en: Further Reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到更多我们在本章中讨论的相关主题：
- en: '**Additional CSRF test vulnerabilities**: [http://webscantest.com/csrf/](http://webscantest.com/csrf/)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他 CSRF 测试漏洞**：[http://webscantest.com/csrf/](http://webscantest.com/csrf/)'
