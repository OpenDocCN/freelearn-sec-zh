- en: Chapter 10. Practical Server-Side Attacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：实用的服务器端攻击
- en: In the previous chapter, we went through a series of practical attacks against
    users, leveraging application vulnerabilities to achieve our goal. The focus of
    this chapter will be server-side attacks, primarily by exploiting XML vulnerabilities.
    Despite the fact that JSON has gained a large market share of data exchange in
    web applications, XML is still fairly prevalent. It's not as clean as JSON and
    can be a bit harder to read, but it is mature. There are a ton of XML-parsing
    libraries for any language a developer may choose to complete a project with.
    Java is still popular in the enterprise world and the Android phenomenon has only
    spawned more Java enthusiasts. Microsoft is still very fond of XML and you'll
    find it all over its operating system, in the application manifests, and in IIS
    website configuration files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过一系列实际攻击，利用应用程序的漏洞实现目标。本章的重点将是服务器端攻击，主要通过利用 XML 漏洞。尽管 JSON 在 web 应用中的数据交换中已经占据了大量市场份额，但
    XML 仍然相当普遍。它不像 JSON 那样简洁，可能稍微难以阅读，但它已经相当成熟。任何开发者选择的语言都有大量的 XML 解析库可供使用。Java 在企业界仍然很受欢迎，Android
    现象也促使了更多 Java 爱好者的涌现。微软仍然非常喜爱 XML，你可以在它的操作系统、应用程序清单和 IIS 网站配置文件中随处可见。
- en: 'The goal of this chapter is to get you comfortable with XML attacks and, by
    the end, you will be familiar with:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让你熟悉 XML 攻击，最终你将熟悉以下内容：
- en: DoS conditions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DoS 条件
- en: '**Server-Side Request Forgery** (**SSRF**) attacks'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端请求伪造**（**SSRF**）攻击'
- en: Information leaks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息泄露
- en: Blind exploitation and out-of-band exfiltration of data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盲目利用和带外数据外泄
- en: Remote code execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程代码执行
- en: 'On your travels, you no doubt have come across XML and, at first glance, it
    looks similar to HTML. There''s a header that describes the document and it typically
    looks like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的旅途中，你无疑已经遇到过 XML，乍一看，它与 HTML 类似。它有一个描述文档的头部，通常看起来是这样的：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is followed by arbitrary tags, which describe the data contained within
    the document. While HTML instructs a client, such as a browser, on how to render
    data, XML is used to describe the data itself and is therefore referred to as
    self-describing. The data is defined, or described, by building blocks called
    elements. An example XML document looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是任意标签，用于描述文档中包含的数据。虽然 HTML 指示客户端（如浏览器）如何渲染数据，XML 则用于描述数据本身，因此被称为自描述。数据通过称为元素的构建块进行定义或描述。一个
    XML 文档的示例如下：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `<user>` element indicates the type of record and its boundary is `</user>`,
    much like HTML. This is also the root element. Within this record, we have `<name>`,
    `<id>`, and `<email>` entries with the appropriate values. It's important to note
    that any application that parses this data must know what to do with the contents.
    Modern web browsers know what to do with HTML's `<div>` and `<a>` because they
    all follow a standard. Applications exchanging XML data must agree on what that
    data is, and how it is processed or rendered. An XML structure can be valid from
    a syntax point of view (that is, all the tags are properly closed, there's a root
    element, and the document header is present), but it may be missing expected elements
    and applications may crash or waste resources attempting to parse the data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`<user>` 元素表示记录类型，其边界为 `</user>`，类似于 HTML。这也是根元素。在该记录中，我们有 `<name>`、`<id>`
    和 `<email>` 条目，并包含相应的值。需要注意的是，任何解析此数据的应用程序都必须知道如何处理其中的内容。现代网页浏览器知道如何处理 HTML 中的
    `<div>` 和 `<a>`，因为它们都遵循标准。交换 XML 数据的应用程序必须就数据的内容以及如何处理或呈现这些数据达成一致。从语法角度来看，XML
    结构是有效的（即所有标签都正确闭合，存在根元素，文档头部也已包含），但可能缺少预期的元素，且应用程序在解析数据时可能会崩溃或浪费资源。'
- en: Internal and external references
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部和外部引用
- en: A **document type definition** (**DTD**) is used to the proper way to build a particular
    document. DTDs are referenced in XML documents by the use of a document type declaration
    (`DOCTYPE`) element. DTDs can be written out in full inside the XML document,
    or they can be referenced externally for the parser to download and process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档类型定义**（**DTD**）用于规范构建特定文档的正确方式。DTD 在 XML 文档中通过使用文档类型声明（`DOCTYPE`）元素进行引用。DTD
    可以完整地写在 XML 文档中，也可以通过外部引用供解析器下载和处理。'
- en: 'Internal DTDs can be found near the top of the XML document, in the `DOCTYPE`
    tag:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 DTD 通常位于 XML 文档的顶部，在 `DOCTYPE` 标签中：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding internal DTD defines the `user` root element and an internal entity,
    `company`, which is defined to hold the string value `"Ellingson Mineral Company"`.
    Within the document itself, the company entity can be referenced using the ampersand
    and semicolon wrappers, which should look familiar if you have some HTML experience.
    When the parser reaches the `&company;` string, it will insert the value defined
    in the preceding DTD.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的内部DTD定义了`user`根元素和一个内部实体`company`，该实体定义为存储字符串值`"Ellingson Mineral Company"`。在文档本身中，可以使用与HTML类似的符号（&和;）来引用公司实体。当解析器遇到`&company;`字符串时，它会插入在前面的DTD中定义的值。
- en: 'As I''ve said previously, it is also possible to point the XML parser of our
    document to an external DTD file. The parser will simply go and fetch this file
    before the rest of the document is processed. External DTDs are referenced in
    the `DOCTYPE` by preceding them with the `SYSTEM` keyword:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，也可以将文档的XML解析器指向外部DTD文件。解析器将在处理文档的其余部分之前，去获取该文件。外部DTD在`DOCTYPE`中通过在前面加上`SYSTEM`关键字进行引用：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `user.dtd` file will contain our entity and element definitions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`user.dtd`文件将包含我们的实体和元素定义：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `company` entity will be expanded, as before, once the DTD is successfully
    downloaded and parsed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DTD成功下载并解析，`company`实体将会像以前一样被扩展。
- en: 'Just like our external DTD definition, we can reference external entities as
    well. The syntax is similar to referencing external DTDs: it calls for the `SYSTEM`
    keyword and a URI:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的外部DTD定义一样，我们也可以引用外部实体。其语法类似于引用外部DTD：它需要使用`SYSTEM`关键字和URI：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can pass this XML document to a parser as part of, say, an API authentication
    request. When it's time to resolve the `&company;` entity, the parser will make
    an HTTP connection to `config.ecorp.local` and the contents will be echoed in
    the `<company>` element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此XML文档传递给解析器，作为例如API身份验证请求的一部分。当解析器需要解析`&company;`实体时，它会建立一个HTTP连接到`config.ecorp.local`，然后将内容回显在`<company>`元素中。
- en: The attacker mindset will take note of the ability of a user to influence server
    behavior and potentially look for ways to abuse it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的思维方式会注意到用户能够影响服务器行为的能力，并可能寻找滥用这种能力的方法。
- en: XXE attacks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XXE攻击
- en: XXE attacks take advantage of the fact that XML libraries allow for these external
    references for DTDs or entities. Developers may not be aware of this potential
    attack vector and XML input is sometimes left unsanitized. As attackers communicating
    with an API, for example, we can intercept SOAP XML requests and inject our own
    XML elements in the payload. The server-side component must parse this payload
    in order to know what to do with the data. If the parser is not properly configured
    and it allows external entities, we can abuse the server to read files on the
    system, perform SSRF attacks, perform DoS attacks, and in some cases even execute
    code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: XXE攻击利用了XML库允许这些外部引用（如DTD或实体）的事实。开发人员可能没有意识到这一潜在的攻击向量，而XML输入有时会被忽略清理。例如，作为与API通信的攻击者，我们可以拦截SOAP
    XML请求，并在负载中注入我们自己的XML元素。服务器端组件必须解析此负载以了解如何处理数据。如果解析器未正确配置，并且允许外部实体，我们可以利用服务器读取系统上的文件，执行SSRF攻击，发起DoS攻击，甚至在某些情况下执行代码。
- en: A billion laughs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十亿次笑声
- en: The **billion laughs attack**, also known as an **XML bomb**, is a DoS attack
    that aims to overload the XML parser by causing it to allocate more memory than
    it has available with a relatively small input buffer. On older systems, or virtual
    machines with limited memory, a parser bomb could quickly crash the application
    or even the host.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**十亿次笑声攻击**，也称为**XML炸弹**，是一种DoS攻击，旨在通过让XML解析器分配比可用内存更多的内存，从而使其超载，且仅使用相对较小的输入缓冲区。在较旧的系统或内存有限的虚拟机上，解析器炸弹可能会迅速导致应用崩溃，甚至使宿主崩溃。'
- en: The XML bomb exploits the fact that file formats such as XML allow the user
    to specify references or pointers to other arbitrarily defined data. In the earlier
    examples, we used entity expansion to replace `&company;` with data defined either in the
    header of the document or somewhere externally.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XML炸弹利用了文件格式（如XML）允许用户指定对其他任意定义数据的引用或指针这一事实。在前面的示例中，我们使用实体扩展将`&company;`替换为在文档头部或外部定义的数据。
- en: 'An XML bomb looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: XML炸弹的样子如下：
- en: '![A billion laughs](graphics/B09238_10_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![十亿次笑声](graphics/B09238_10_01.jpg)'
- en: 'Figure 10.1: XML bomb attack'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：XML炸弹攻击
- en: A parser will look at this data and begin expanding the entities, starting with
    the `<lolz>` root element. A reference to the `&lol9;` entity will point to 10
    other references defined by `&lol8`;. This is repeated until the first entity,
    `&lol`;, expands to the `"lol"` string. The result is the memory allocation of
    10^9 (1,000,000,000) instances of the `"lol"` string, or a billion lols. This
    alone can take up to 3 GB of memory, depending on the parser and how it handles
    strings in memory. On modern servers, the impact may be minimal, unless this attack
    is distributed through multiple connections to the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器将查看这些数据并开始扩展实体，从 `<lolz>` 根元素开始。对 `&lol9;` 实体的引用将指向由 `&lol8;` 定义的 10 个其他引用。这一过程会一直重复，直到第一个实体
    `&lol;` 扩展为 `"lol"` 字符串。最终结果是内存中分配了 10^9 (10亿) 个 `"lol"` 字符串的实例，或者说一亿次笑声。这本身就可能占用多达
    3 GB 的内存，具体取决于解析器及其如何在内存中处理字符串。在现代服务器上，除非此攻击通过多个连接分布到应用程序上，否则其影响可能微乎其微。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As always, take care when testing for these types of vulnerabilities on client
    systems. DoS attacks are not usually allowed during engagements. On rare occasions
    where DoS is allowed, an XML bomb may be a good way to tie up resources in the
    blue team while you focus on other parts of the network, provided the system is
    not business-critical.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在客户端系统上测试这些类型的漏洞时要小心。DoS 攻击通常在工作中不被允许。在极少数允许 DoS 攻击的情况下，XML 炸弹可能是一个有效的方式，用来在蓝队集中资源时拖慢其速度，前提是该系统不是业务关键系统。
- en: 'XML is not the only file format that allows for this type of DoS attack. In
    fact, any language that has constructs for creating pointers to other data can
    be abused in a similar fashion. YAML, a human-readable file format typically used
    in configuration files, also allows for pointers to data and thus the YAML bomb:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: XML 并不是唯一允许这种类型的 DoS 攻击的文件格式。事实上，任何具有创建指向其他数据的指针的语言都可以以类似的方式被滥用。YAML，一种通常用于配置文件中的人类可读的文件格式，也允许指向数据的指针，因此也可以发生
    YAML 炸弹攻击：
- en: '![A billion laughs](graphics/B09238_10_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![一亿次笑声](graphics/B09238_10_02.jpg)'
- en: 'Figure 10.2: YAML billion laughs attack'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：YAML 一亿次笑声攻击
- en: The effect of these attacks varies greatly, depending on the library and its
    memory management, as well as the underlying operating system and its available
    memory. While not all bombs will crash a system, they do illustrate the importance
    of input sanitization. Subverting confidentiality and violating integrity may
    be sexier, but when availability can so easily be influenced with a few lines
    of code, defenders should pay attention.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击的效果差异很大，取决于所使用的库及其内存管理方式，以及底层操作系统和可用的内存。虽然并非所有的炸弹都会导致系统崩溃，但它们确实展示了输入清理的重要性。破坏机密性和违反完整性可能更具吸引力，但当可用性可以通过几行代码轻易地被影响时，防御者应该保持警惕。
- en: Request forgery
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求伪造
- en: A **request forgery** attack occurs when an application is coerced into making
    a request to another host or hosts of the attacker's choosing. External entity
    expansion attacks are a form of SSRF, as they coerce the application into connecting to
    arbitrary URLs in order to download DTDs or other XML data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求伪造** 攻击发生在应用程序被迫向攻击者选择的其他主机发送请求时。外部实体扩展攻击是一种 SSRF 攻击形式，因为它强迫应用程序连接到任意的
    URL 来下载 DTD 或其他 XML 数据。'
- en: In the worst-case scenario (or best case, depending on your perspective), a
    request forgery such as XXE can result in information leakage, blind data exfiltration,
    or even remote code execution, as we'll see later on. However, SSRF can also be
    used to chain attacks to internal, non-public servers, or even to conduct port
    scans.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下（或者从你的角度来看，最好情况），像 XXE 这样的请求伪造可能导致信息泄露、盲数据外泄，甚至远程代码执行，正如我们稍后将看到的。然而，SSRF
    也可以用于将攻击链延伸至内部的非公开服务器，甚至进行端口扫描。
- en: 'To illustrate this particular attack, we will use this XML parsing application
    written in PHP. The code should be fairly simple to understand for most non-developers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种特定的攻击，我们将使用一个用 PHP 编写的 XML 解析应用程序。对于大多数非开发者来说，代码应该相当简单易懂：
- en: '![Request forgery](graphics/B09238_10_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_03.jpg)'
- en: 'Figure 10.3: Simple PHP XML parser'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：简单的 PHP XML 解析器
- en: 'A quick overview of the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的简要概述：
- en: Lines 7 to 11 define a form in HTML that allows the user to submit XML data
    via a `POST` request.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 7 到第 11 行定义了一个 HTML 表单，允许用户通过 `POST` 请求提交 XML 数据。
- en: 'Lines 2 to 5 will process the incoming XML text using the `SimpleXML` PHP module.
    The parsed data will be stored as an XML object: `$xml_object`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 到第 5 行将使用 `SimpleXML` PHP 模块处理传入的 XML 文本。解析后的数据将作为 XML 对象存储：`$xml_object`。
- en: Lines 13 to 23 will neatly display the parsed XML data.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第13到23行将整齐地显示解析后的XML数据。
- en: 'We can start a temporary web server from the command-line to test some SSRF
    attacks against our vulnerable XML-parsing application using the built-in PHP
    test server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行启动一个临时Web服务器，使用内置的PHP测试服务器对我们的易受攻击的XML解析应用程序进行一些SSRF攻击测试：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of this demo, our application will be accessible via `http://xml.parser.local`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，我们的应用程序将通过`http://xml.parser.local`访问。
- en: '![Request forgery](graphics/B09238_10_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_04.jpg)'
- en: 'Figure 10.4: Vulnerable PHP XML parser running'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：运行中的易受攻击的PHP XML解析器
- en: In order to test the parser's external entity expansion capabilities, we can
    use the form to send a short XML payload describing a book. We will use an external
    entity hosted by Burp Collaborator. This isn't a valid payload, as Collaborator
    responds with a canned HTML answer, but it will allow us to confirm that the application
    is vulnerable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试解析器的外部实体扩展功能，我们可以使用表单发送一个简短的XML负载，描述一本书。我们将使用由Burp Collaborator托管的外部实体。虽然这不是一个有效的负载，因为Collaborator会返回一个预设的HTML响应，但它可以帮助我们确认应用程序是否存在漏洞。
- en: 'Let''s create a new Collaborator client instance and pass the generated host
    to the application in our payload:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Collaborator客户端实例，并将生成的主机传递给我们的负载中的应用程序：
- en: 'From the **Burp** menu, select the **Burp Collaborator client** option:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Burp**菜单中选择**Burp Collaborator 客户端**选项：
- en: '![Request forgery](graphics/B09238_10_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_05.jpg)'
- en: 'Figure 10.5: Starting the Burp Collaborator client module'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：启动Burp Collaborator客户端模块
- en: 'We will generate one Collaborator host and select **Copy to clipboard** in
    the client window. It''s important that we do not close the Collaborator client
    for the duration of the attack after generating a hostname. If we close it prematurely,
    Collaborator will not be able to link out-of-band requests made to the hostname
    with our Burp session:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一个Collaborator主机，并在客户端窗口中选择**复制到剪贴板**。在生成主机名后，重要的是不要关闭Collaborator客户端，直到攻击结束。如果我们过早关闭它，Collaborator将无法将发往该主机名的带外请求与我们的Burp会话关联：
- en: '![Request forgery](graphics/B09238_10_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_06.jpg)'
- en: 'Figure 10.6: Copy the generated Collaborator hostname to the clipboard'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：将生成的Collaborator主机名复制到剪贴板
- en: 'The value generated will look similar to this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的值将类似于此：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now build an XML document that fetches the `publisher` value from the
    Burp Collaborator host we''ve just generated. We hope that when the vulnerable
    application attempts to fetch the external content, Burp Collaborator will be
    able to intercept the request and confirm the vulnerability:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建一个XML文档，从我们刚刚生成的Burp Collaborator主机中获取`publisher`值。我们希望当脆弱的应用程序尝试获取外部内容时，Burp
    Collaborator能够拦截该请求并确认漏洞：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Collaborator is not required for this confirmation. We can use a simple HTTP
    server running on our C2 server somewhere in the cloud. Collaborator is useful
    when HTTPS is needed in a rush, or if confirmation has to be done via DNS or some
    other protocol.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 确认这一点不需要Collaborator。我们可以在云中的C2服务器上运行一个简单的HTTP服务器。Collaborator在需要HTTPS连接时非常有用，或者在确认必须通过DNS或其他协议进行时。
- en: 'The result is a neatly­ parsed object displayed in red at the bottom of the
    screen:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个整齐的解析对象，显示在屏幕底部的红色区域：
- en: '![Request forgery](graphics/B09238_10_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_07.jpg)'
- en: 'Figure 10.7: Submitting the XML payload and observing the response'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：提交XML负载并观察响应
- en: 'We can see that the `&publisher;` entity was resolved by the parser, which
    means the application made an external HTTP connection to our Collaborator instance.
    It''s interesting to note that the HTML response was successfully interpreted
    as XML successfully by the parser, due to the structure similarity of XML and
    HTML:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`&publisher;`实体被解析器成功解析，这意味着应用程序向我们的Collaborator实例发出了外部HTTP连接。有趣的是，解析器成功地将HTML响应解释为XML，因为XML和HTML的结构相似：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Polling the Collaborator server from the client confirms the existence of this
    vulnerability and now we know we can influence the server in some way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端轮询Collaborator服务器确认了该漏洞的存在，现在我们知道我们可以以某种方式影响服务器：
- en: '![Request forgery](graphics/B09238_10_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![请求伪造](graphics/B09238_10_08.jpg)'
- en: 'Figure 10.8: Collaborator client confirms SSRF vulnerability'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：Collaborator客户端确认SSRF漏洞
- en: The port scanner
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口扫描仪
- en: Knowing that we can point the application to any URL and it will connect to
    it, we can abuse this to perform a crude port scan of the internal network (or
    any other host for that matter). We can scan for more than just HTTP ports. URLs
    allow for the specification of an arbitrary port, and while it may try to negotiate
    an HTTP connection, we can still infer the existence of an SMTP service by just
    examining the parser connection attempt error message.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到我们可以将应用程序指向任何 URL 并进行连接，我们可以利用这一点对内部网络（或其他任何主机）进行粗略的端口扫描。我们不仅可以扫描 HTTP 端口。URL
    允许指定任意端口，虽然它可能尝试协商 HTTP 连接，但我们仍然可以通过检查解析器连接尝试的错误信息来推测存在 SMTP 服务。
- en: Since we are forging our request to come from the vulnerable XML parser application,
    all port scan attempts will appear to come from an internal trusted system. This
    is good from a stealth perspective, and in some cases, can avoid triggering alarms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在伪造请求，使其看起来来自脆弱的 XML 解析器应用程序，因此所有的端口扫描尝试将表现为来自内部受信任系统。这从隐匿性角度来看是有利的，并且在某些情况下，可以避免触发警报。
- en: 'The XML code we''ll use for our XXE port scanner will target the `10.0.5.19`
    internal host, looking for interesting services: `8080`, `80`, `443`, `22`, and
    `21`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于 XXE 端口扫描器的 XML 代码将针对 `10.0.5.19` 内部主机，寻找有趣的服务：`8080`、`80`、`443`、`22` 和
    `21`：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once uploaded to the application for parsing, the payload will force the XML
    parser into systematically connecting to each specified port, in an attempt to
    fetch data for the `&portN;` entities:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传到应用程序进行解析，负载将迫使 XML 解析器系统地连接到每个指定的端口，尝试为 `&portN;` 实体获取数据：
- en: '![The port scanner](graphics/B09238_10_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![端口扫描器](graphics/B09238_10_09.jpg)'
- en: 'Figure 10.9: XXE port scanner showing error messages for open ports'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：XXE 端口扫描器显示开放端口的错误信息
- en: The server response is a bit messy, but it does provide us with enough information
    to see that port `80` is actually open on the internal `10.0.5.19` host. The parser
    was able to connect to the port and, while it failed to parse its contents, the
    error message speaks volumes. Conversely, entity `&port0;` returned a `Connection
    timed out` error message, which indicates that the port is likely firewalled.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应有些凌乱，但它确实提供了足够的信息，说明内部主机 `10.0.5.19` 上的端口 `80` 实际是开放的。解析器能够连接到该端口，虽然它未能解析其内容，但错误信息却提供了有价值的线索。相反，实体
    `&port0;` 返回了一个 `Connection timed out` 错误消息，这表明该端口可能被防火墙屏蔽。
- en: 'Burp Suite has a neat feature where it allows us to copy any request captured
    as a `curl` command. If we wish to repeat this attack on another internal host
    and perhaps parse the response for another tool, we can quickly copy the payload
    with a single click:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 具有一个非常方便的功能，可以让我们将捕获的任何请求复制为 `curl` 命令。如果我们希望对另一个内部主机重复进行此攻击，可能还需要解析响应供其他工具使用，我们可以通过一次点击快速复制负载：
- en: '![The port scanner](graphics/B09238_10_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![端口扫描器](graphics/B09238_10_10.jpg)'
- en: 'Figure 10.10: Save the Burp request as a curl command'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：将 Burp 请求保存为 curl 命令
- en: 'The generated `curl` command can be piped to `grep` and we can filter only
    lines containing `"http:"` to make reading the output a bit cleaner:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `curl` 命令可以通过管道传递给 `grep`，我们可以过滤出仅包含 `"http:"` 的行，以使输出更易于阅读：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From here, we can get a bit more fancy by automating payload generation or cleaning
    up the output further.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以更进一步，自动化负载生成或进一步清理输出。
- en: Information leak
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息泄露
- en: XXE can also be used to read any file on disk that the application has access
    to. Of course, most of the time, the more valuable files are the application's
    source code, which is a common target for attackers. Remember that external entities
    are accessed using a URL, and in PHP, the file system is accessible via the `file://`
    URL prefix.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: XXE 也可以用来读取应用程序可以访问的任何磁盘上的文件。当然，大多数情况下，更有价值的文件是应用程序的源代码，这是攻击者的常见目标。请记住，外部实体是通过
    URL 访问的，在 PHP 中，文件系统是通过 `file://` URL 前缀访问的。
- en: 'To read the `/etc/passwd` file on a Linux system, a simple payload such as
    this will work:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取 Linux 系统上的 `/etc/passwd` 文件，像这样的简单负载就能奏效：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is predictable and a good proof of concept for our report to the
    client. The XML parser will reach out over the `file://` scheme, grab the contents
    of `/etc/passwd`, and display them no the screen:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是可预测的，并且是我们向客户报告的一个很好的概念验证。XML 解析器将通过 `file://` 协议访问，获取 `/etc/passwd` 的内容，并在屏幕上显示：
- en: '![Information leak](graphics/B09238_10_11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![信息泄露](graphics/B09238_10_11.jpg)'
- en: 'Figure 10.11: Exploiting XXE to retrieve /etc/passwd'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：利用 XXE 获取 /etc/passwd
- en: 'As I alluded to earlier, there are more high-value targets to consider for
    exfiltration with this type of attack: the application''s source code, private
    keys (SSH private keys and certificate private keys), history files, operating
    system configuration files or scripts, and much more. If the application can read
    the files on disk, so can we.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，对于这种类型的攻击，除了文件外，还可以考虑更多高价值的目标进行数据外泄：应用程序的源代码、私钥（SSH私钥和证书私钥）、历史文件、操作系统配置文件或脚本等。如果应用程序可以读取磁盘上的文件，我们也能读取。
- en: Local files are not the only thing we can touch with this exploit, however.
    SSRF attacks, such as XXE, can also be used to target internal applications that
    may not be accessible from an outside network, such as other virtual local area
    networks (VLANs) or the internet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用此漏洞不仅仅可以访问本地文件。SSRF攻击，例如XXE，也可以用来针对可能无法从外部网络访问的内部应用程序，例如其他虚拟局域网（VLAN）或互联网。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The internal application running on `10.0.5.19` that we will use for demonstration
    purposes is the awesome **badguys** project from Mike Pirnat. The web application
    code can be downloaded from [https://github.com/mpirnat/lets-be-bad-guys](https://github.com/mpirnat/lets-be-bad-guys).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于演示的内部应用程序运行在`10.0.5.19`，它是Mike Pirnat的出色**badguys**项目。该Web应用程序的代码可以从[https://github.com/mpirnat/lets-be-bad-guys](https://github.com/mpirnat/lets-be-bad-guys)下载。
- en: Consider a scenario where, after further investigation of the server that we
    successfully scanned earlier, we've realized `10.0.5.19` was running an application
    vulnerable to LFI attacks. We cannot access `10.0.5.19` directly from our network
    segment and only the target `xml.parser.local` application is exposed to us. Normally,
    we'd be unable to attack `10.0.5.19`, but thanks to the XXE SSRF issue, we can
    force the XML parser to conduct the attack on our behalf.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在进一步调查我们之前成功扫描过的服务器后，我们意识到`10.0.5.19`上运行的应用程序容易受到LFI攻击。我们无法直接从我们的网络段访问`10.0.5.19`，只有目标`xml.parser.local`应用程序暴露给我们。通常情况下，我们无法攻击`10.0.5.19`，但由于XXE
    SSRF问题，我们可以迫使XML解析器代我们执行攻击。
- en: We will build a payload to pass to `xml.parser.local`, which will force it to
    connect to our target internal server and retrieve the settings file from the
    vulnerable application using an LFI attack.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个有效载荷，传递给`xml.parser.local`，这将迫使它连接到我们的目标内部服务器，并通过LFI攻击从易受攻击的应用程序中检索设置文件。
- en: 'The badguys application running on the internal `10.0.5.19` host is vulnerable
    to LFI in the `/user-pic` URL parameter, `p`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在内部`10.0.5.19`主机上的badguys应用程序在`/user-pic` URL参数`p`中存在LFI漏洞：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This particular vulnerable application is open-source and a quick GitHub search
    tells us everything we need to know about the file folder structure. This is also
    true for other frameworks and CMSs. A WordPress installation vulnerable to LFI
    can be exploited to grab the contents of `wp-config.php` just as easily.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特别的易受攻击应用程序是开源的，通过简单的GitHub搜索，我们可以了解文件夹结构的所有信息。对于其他框架和CMS也是如此。一个容易受到LFI攻击的WordPress安装也可以轻松利用，获取`wp-config.php`的内容。
- en: We know what the relative path to the settings file is because we looked it
    up, and we can use that as the injection payload for the LFI exploitation. The
    badguys application stores its settings in a file called `settings.py`, usually
    stored two directories up the chain from the current working directory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道设置文件的相对路径，因为我们已经查找过，并且可以将其用作LFI利用的注入有效载荷。badguys应用程序将设置存储在一个名为`settings.py`的文件中，通常存储在当前工作目录的上两级目录中。
- en: 'To grab this file''s contents, our XML payload will look something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这个文件的内容，我们的XML有效载荷可能会像这样：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of the Collaborator hostname, we will ask the XML server to reach out
    to the internal host and return the response back to us. If all goes well, the
    XML parser will exploit the internal badguys application running on `10.0.5.19`,
    giving us the contents of the `settings.py` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不使用Collaborator主机名，而是要求XML服务器连接到内部主机并将响应返回给我们。如果一切顺利，XML解析器将利用运行在`10.0.5.19`上的内部badguys应用程序，给我们返回`settings.py`文件的内容：
- en: '![Information leak](graphics/B09238_10_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![信息泄露](graphics/B09238_10_12.jpg)'
- en: 'Figure 10.12: Using XXE to exploit LFI on an internal host'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：使用XXE在内部主机上利用LFI
- en: The `settings.py` file has some interesting information, including database
    credentials and `sqlite3` file paths. It doesn't hurt to make a note of this for
    future use. A file of interest is the SQLite 3 database itself, located at `c:\db\badguys.sqlite3`
    on the `10.0.5.19` internal host.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.py` 文件包含一些有趣的信息，包括数据库凭证和 `sqlite3` 文件路径。记下这些信息以供将来使用是没有坏处的。一个值得注意的文件是
    SQLite 3 数据库本身，它位于 `10.0.5.19` 内部主机的 `c:\db\badguys.sqlite3` 路径下。'
- en: We can use the same LFI attack to grab its contents as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的 LFI 攻击来抓取其内容。
- en: 'There is one problem with just changing the `p` path to the database file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过更改 `p` 路径到数据库文件存在一个问题：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In normal LFI situations, this will work just fine. We traverse enough directories
    to reach the root of the drive, change directory to `db`, and fetch the `badguys.sqlite3` file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的 LFI 情况下，这种方法完全可行。我们遍历足够的目录以达到驱动器的根目录，切换到 `db` 目录，并抓取 `badguys.sqlite3`
    文件。
- en: 'You''ll notice that, in our payload, the contents of the SQLite 3 database
    will be fetched and inserted in the `<xxe>` tag before the parser processes the
    XML data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在我们的有效载荷中，SQLite 3 数据库的内容将被抓取并插入到 `<xxe>` 标签中，解析器在处理 XML 数据之前：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: SQLite 3's file format will contain characters that most XML parsers will have
    a problem processing, and therefore parse errors may prevent us from grabbing
    the contents.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 3 的文件格式包含一些大多数 XML 解析器处理时会遇到问题的字符，因此解析错误可能会阻止我们抓取内容。
- en: 'If we run our payload as is, we observe that even though the contents of the
    database were fetched, the application did not return them because it tried to
    parse them as part of the `<xxe>` tag. SQLite 3''s binary format is not really
    XML-friendly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样运行有效载荷，我们会观察到尽管数据库的内容已被抓取，应用程序并没有返回它们，因为它尝试将其作为 `<xxe>` 标签的一部分进行解析。SQLite
    3 的二进制格式并不真正适合 XML：
- en: '![Information leak](graphics/B09238_10_13.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![信息泄露](graphics/B09238_10_13.jpg)'
- en: 'Figure 10.13: XXE attack fails to return the contents of the database'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13：XXE 攻击未能返回数据库的内容
- en: To get around this issue, ideally, we want the XML parser to encode the data
    it retrieves from the vulnerable internal application before it injects it into
    the `<xxe>` tag for processing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，理想情况下，我们希望 XML 解析器在将数据注入到 `<xxe>` 标签进行处理之前，先对它从易受攻击的内部应用程序获取的数据进行编码。
- en: 'The XML parser application is written in PHP and therefore has access to various
    conversion filters, which can be applied to streaming data, such as a resource
    fetched from a URL. Filters can be accessed via the `php://` scheme, as shown:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: XML 解析器应用程序是用 PHP 编写的，因此可以访问各种转换过滤器，这些过滤器可以应用于流式数据，如从 URL 获取的资源。可以通过 `php://`
    协议访问过滤器，如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One of the conversion filters available is `base64-encode`, which will prove
    useful in our case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的转换过滤器之一是 `base64-encode`，这在我们的案例中将非常有用。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PHP's documentation shows all the available filters at [http://php.net/manual/en/filters.php](http://php.net/manual/en/filters.php).
    Data can be converted, encrypted, or compressed in-flight.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的文档显示了所有可用的过滤器，[http://php.net/manual/en/filters.php](http://php.net/manual/en/filters.php)。数据可以在传输过程中进行转换、加密或压缩。
- en: 'To Base64-encode the contents of the SQLite 3 database, we will have to forge
    a request to the following URI:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 SQLite 3 数据库的内容进行 Base64 编码，我们需要伪造一个请求，指向以下 URI：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `convert.base64-encode` filter is applied to the remote resource containing
    the database contents we need. The return will be a long Base64 string and it
    shouldn''t cause any more parser errors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert.base64-encode` 过滤器已应用于包含我们所需数据库内容的远程资源。返回将是一个长的 Base64 字符串，应该不会再引发解析器错误：'
- en: '![Information leak](graphics/B09238_10_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![信息泄露](graphics/B09238_10_14.jpg)'
- en: 'Figure 10.14: Repeating the attack using the PHP Base64 filter modification'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14：使用 PHP Base64 过滤器修改重复攻击
- en: 'We can now run the Base64 response through CyberChef with the option of saving
    the decoded data to a file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过 CyberChef 运行 Base64 响应，并选择将解码后的数据保存到文件中：
- en: '![Information leak](graphics/B09238_10_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![信息泄露](graphics/B09238_10_15.jpg)'
- en: 'Figure 10.15: SQL database extracted from an internal host'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15：从内部主机提取的 SQL 数据库
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CyberChef is a great tool for data manipulation, available online or for download
    from GCHQ at [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CyberChef 是一个非常棒的数据处理工具，可以在线使用或从 GCHQ 下载，[https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)。
- en: 'Success! We managed to leak a database from an internal system by chaining
    two exploits:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们通过链式利用两个漏洞成功泄露了来自内部系统的数据库：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we've seen, request forgery, particularly XXE (since we can retrieve the
    contents of the response), can be extremely valuable in an engagement.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，请求伪造，特别是 XXE（因为我们可以获取响应的内容），在渗透测试中可能非常有价值。
- en: Blind XXE
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盲 XXE
- en: As you have probably witnessed in your day-to-day role, not all XML parsers
    are as verbose as the preceding example. Many web applications are configured
    to suppress errors and warnings, and sometimes will not echo any useful data back
    to you. The preceding attacks relied on the fact that the payload was processed
    and the entities were echoed out to the screen. This allowed us to exfiltrate
    the data easily.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在日常工作中可能已经看到的，并非所有 XML 解析器都像前面的例子那样冗长。许多 Web 应用程序被配置为抑制错误和警告，有时甚至不会将任何有用的数据返回给你。之前的攻击依赖于有效载荷被处理且实体被回显到屏幕上的事实，这使得我们能够轻松地进行数据泄漏。
- en: In some cases, however, this may not be possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，这可能无法实现。
- en: 'To showcase this attack, we will patch our XML parser application to suppress
    PHP error messages and display a generic message after every submission:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个攻击，我们将修补我们的 XML 解析器应用程序，抑制 PHP 错误信息，并在每次提交后显示一个通用信息：
- en: '![Blind XXE](graphics/B09238_10_16.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![盲 XXE](graphics/B09238_10_16.jpg)'
- en: 'Figure 10.16: The modified PHP XML parser does not return data'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16：修改后的 PHP XML 解析器不返回数据
- en: Lines 2, 3, and 22 will render our previous information leak attacks useless.
    Even if we exploit XXE successfully, we will not be able to see the contents of
    whatever file we attempt to retrieve. SSRF attacks will still work, however, but
    are not as straightforward to exploit practically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2、3 和 22 行将使我们之前的信息泄露攻击无效。即使我们成功利用 XXE，我们也无法看到我们尝试获取的文件内容。然而，SSRF 攻击仍然有效，但在实际利用中并不如
    XXE 那么直接。
- en: '![Blind XXE](graphics/B09238_10_17.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![盲 XXE](graphics/B09238_10_17.jpg)'
- en: 'Figure 10.17: A blind XXE attack does not produce any useable output'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17：盲 XXE 攻击不会产生任何可用的输出
- en: How do we go about exfiltrating the data if the application does not return
    anything useful after exploitation?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序在利用后没有返回任何有用的内容，我们该如何进行数据外泄？
- en: We have to get a bit more creative. Out-of-band vulnerability identification
    uses a C2 server to confirm that the application is vulnerable, by observing incoming
    network connections. Confirming blind XXE vulnerabilities can be done out-of-band
    as well and, as shown in the previous example, using Burp Collaborator or an external
    C2 server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更具创意。带外漏洞识别使用 C2 服务器来确认应用程序是否存在漏洞，通过观察传入的网络连接。确认盲 XXE 漏洞也可以通过带外方式完成，正如之前的例子所示，可以使用
    Burp Collaborator 或外部 C2 服务器。
- en: What if, instead of instructing the XML parser to return the data we need with
    the `<xxe>&exfil;</xxe>` tag, we take an out-of-band approach? Since we cannot
    return data in the browser, we can ask the parser to connect to a C2 server and
    append the data to the URL. This will allow us to retrieve the contents by analyzing
    the C2 server's access logs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指示 XML 解析器通过`<xxe>&exfil;</xxe>`标签返回所需的数据，而是采用带外的方法，会怎样呢？由于我们无法在浏览器中返回数据，我们可以要求解析器连接到
    C2 服务器并将数据附加到 URL 上。这样我们就可以通过分析 C2 服务器的访问日志来获取内容。
- en: We know we can Base64-encode the contents of a file with a stream filter. Let's
    combine these two and attempt to send our data to our C2 instead of the web browser.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以使用流过滤器将文件内容进行 Base64 编码。现在让我们将这两者结合起来，尝试将数据发送到 C2 服务器，而不是 Web 浏览器。
- en: 'The entities we need to define in our XML payload will look something like
    this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 XML 有效载荷中定义的实体大概是这样的：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A keen eye will notice the new percent character preceding the entity names.
    This denotes a parameter entity as opposed to a general entity, as we''ve used
    so far. General entities can be referenced somewhere in the root element tree,
    while parameter entities can be referenced in the DTD or the header of the document:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到实体名称前面出现了新的百分号字符。这表示这是一个参数实体，而非我们之前使用的通用实体。通用实体可以在根元素树中的某个位置引用，而参数实体可以在
    DTD 或文档的头部引用：
- en: Parameter entities are prefixed with a percent character (`%`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数实体以百分号字符（`%`）为前缀
- en: General entities are prefixed with an ampersand character (`&`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用实体以与号字符（`&`）为前缀
- en: 'The next step is to try these two entities in our previous payload:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是尝试将这两个实体放入我们之前的有效载荷中：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we are defining the `%data` and `%conn` parameter entities in
    our `DOCTYPE`. The `%conn` entity also defines a general entity, `&exfil`, which
    will attach the Base64-encoded `%data` entity to our C2 URL for exfiltration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在`DOCTYPE`中定义了`%data`和`%conn`参数实体。`%conn`实体还定义了一个通用实体`&exfil`，它将把Base64编码的`%data`实体附加到我们的C2
    URL上进行外泄。
- en: Immediately following the parameter entity definition, we evaluate `%conn`,
    which will kickstart the data collection and encoding. This will also define `&exfil`,
    which is later called in the body of the document.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接在参数实体定义后，我们评估`%conn`，它将启动数据收集和编码过程。这也将定义`&exfil`，稍后在文档正文中被调用。
- en: 'Simply put, the vulnerable XML parser will perform the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，易受攻击的XML解析器将执行以下操作：
- en: Attempt to expand `%data` and, by extension, grab the contents of the `/etc/issue`
    file
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试扩展`%data`，并通过此操作获取`/etc/issue`文件的内容
- en: Use the `php://filter` scheme to encode the contents of `/etc/issue`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`php://filter`方案对`/etc/issue`的内容进行编码
- en: Attempt to expand `%conn` and, by extension, connect to our C2 server, `c2.spider.ml`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试扩展`%conn`，并通过此操作连接到我们的C2服务器`c2.spider.ml`
- en: Pass the Base64 contents of `%data` via the URL
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过URL传递`%data`的Base64内容
- en: Unfortunately, the payload will not work as is due to XML standard restrictions.
    References to parameter entities (such as `%data` and `%conn`) are not allowed
    in the markup declarations. We have to use an external DTD to define these.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于XML标准的限制，载荷不能按原样工作。对参数实体（如`%data`和`%conn`）的引用在标记声明中是不允许的。我们必须使用外部DTD来定义这些实体。
- en: 'We can check our payload for errors locally using the `xmllint` Linux command,
    as shown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`xmllint` Linux命令在本地检查我们的载荷是否有错误，如下所示：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '`xmllint` is available in the `libxml2-utils` package on Debian-based distributions,
    such as Kali.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmllint`可在Debian系发行版（如Kali）的`libxml2-utils`包中找到。'
- en: 'The workaround is easy enough. We will store the entity declarations for `%data`
    and `%conn` on our C2 server in an external DTD file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法非常简单。我们将在C2服务器上将`%data`和`%conn`的实体声明存储在外部DTD文件中：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will also setup a simple web server to provide `payload.dtd` to our target
    using the `php -S` command, as shown:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置一个简单的Web服务器，通过`php -S`命令向目标提供`payload.dtd`，如图所示：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The modified payload will look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的载荷将如下所示：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only real difference here is that we moved our two parameter entity declarations
    into an external DTD and we are now referencing it in our XML `DOCTYPE`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的实际区别是，我们将两个参数实体声明移到了外部DTD中，并在XML `DOCTYPE`中引用它。
- en: 'As expected, our XML data did not generate any errors and it did not return
    any data either. We are flying blind:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们的XML数据没有生成任何错误，也没有返回任何数据。我们目前无法得知具体情况：
- en: '![Blind XXE](graphics/B09238_10_18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Blind XXE](graphics/B09238_10_18.jpg)'
- en: 'Figure 10.18: The modified XML exploit code'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：修改后的XML漏洞利用代码
- en: 'However, on the `c2.spider.ml C2 server`, we can see the two HTTP requests
    coming in from the target:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`c2.spider.ml C2服务器`上，我们可以看到来自目标的两个HTTP请求：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first request comes in for the `payload.dtd` file; this means we have confirmed
    the XXE vulnerability. The contents are processed and the subsequent call to the
    `exfil` URL containing our data shows up in the logs almost immediately.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个请求请求的是`payload.dtd`文件；这意味着我们已确认XXE漏洞。文件内容已被处理，随后的对包含我们数据的`exfil` URL的调用几乎立即出现在日志中。
- en: 'Using CyberChef once more, Base64-decoding the URL data results in the contents
    of the `/etc/issue` file on the XML parser application server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用CyberChef，Base64解码URL数据后，我们得到了XML解析器应用服务器上`/etc/issue`文件的内容：
- en: '![Blind XXE](graphics/B09238_10_19.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Blind XXE](graphics/B09238_10_19.jpg)'
- en: 'Figure 10.19: CyberChef decoding Base64 exfiltrated data'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：CyberChef解码Base64外泄数据
- en: This method of exfiltration works great for smaller files, however, there may
    be issues with sending a large Base64 chunk over HTTP. Most clients, such as PHP
    or Java, will not make requests with URLs longer than around 2,000 characters.
    In some cases, up to 4,000 characters may be allowed. It varies greatly between
    client implementations, so whenever you're trying to steal some data with XXE,
    keep these limits in mind.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种外泄方法对于较小的文件效果很好，但通过HTTP发送大块的Base64数据可能会遇到问题。大多数客户端，如PHP或Java，无法处理长度超过大约2,000个字符的URL。在某些情况下，最多可能允许4,000个字符。不同的客户端实现差异很大，因此在使用XXE窃取数据时，请记住这些限制。
- en: Remote code execution
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程代码执行
- en: Ah, yes, the holy grail of penetration testing. While much less common, remote
    code execution is possible in certain XXE-vulnerable application deployments.
    Lax configuration and vulnerable components could allow us to abuse the XML parser,
    leading to remote code execution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，没错，这是渗透测试的圣杯。虽然远程代码执行较为少见，但在某些 XXE 漏洞的应用部署中，它是可能发生的。松散的配置和易受攻击的组件可能使我们能够利用
    XML 解析器，从而实现远程代码执行。
- en: 'In the previous examples, we leveraged a fairly simple payload to read data
    from the disk:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们利用了一个相对简单的有效载荷从磁盘读取数据：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once parsed, the `<xxe>` tag would contain the contents of the `/etc/passwd`
    file. Asking PHP to execute code is not much more difficult thanks to PHP's `expect`
    module. Although not typically deployed by default, the `expect` extension provides
    PHP applications with an `expect://` wrapper, allowing developers to execute shell
    commands through a URL-like syntax.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析，`<xxe>` 标签将包含 `/etc/passwd` 文件的内容。得益于 PHP 的 `expect` 模块，要求 PHP 执行代码变得不那么困难。虽然默认情况下并不常部署，但
    `expect` 扩展为 PHP 应用程序提供了一个 `expect://` 包装器，使得开发者可以通过类似 URL 的语法执行 shell 命令。
- en: 'Much like the `file://` wrapper, `expect://` provides read and write access
    to the PTY stream, as opposed to the filesystem. Developers can use the `fopen`
    function with an `expect://` wrapper to execute commands and retrieve their output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `file://` 包装器类似，`expect://` 提供对 PTY 流的读写访问，而不是对文件系统的访问。开发者可以使用 `fopen` 函数结合
    `expect://` 包装器来执行命令并获取其输出：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code will open a read-only stream to the underlying system shell,
    execute the `ssh root@remotehost` command, and, once connected, the command uptime
    will be executed on the remotehost.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打开一个只读流，连接到底层系统 shell，执行 `ssh root@remotehost` 命令，并在连接后，远程主机将执行 uptime
    命令。
- en: Once completed, the result can be used in the rest of the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，结果可以在应用程序的其余部分中使用。
- en: When attacking XML, we don't need to execute PHP code and call the `fopen` function.
    The `expect://` wrapper is readily available to XML parsers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击 XML 时，我们不需要执行 PHP 代码并调用 `fopen` 函数。`expect://` 包装器在 XML 解析器中已经可以直接使用。
- en: There are advantages to using `expect://` over the built-in system `passthru`
    command execution, as it allows some interaction with the terminal, whereas shell
    `passthru` commands are more limited. For this reason, you may still encounter
    this module being installed and enabled.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `expect://` 相比于内置的系统 `passthru` 命令执行有其优势，因为它允许与终端进行一些交互，而 shell `passthru`
    命令则更加有限。因此，你仍然可能会遇到这个模块已安装并启用的情况。
- en: 'To see this in action on a system with the `expect` module enabled, we can
    execute the following payload. The command we pass to `expect://` is a simple
    netcat bash redirector pointing to our C2 server in the cloud, `c2.spider.ml`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启用了 `expect` 模块的系统上看到这个操作，我们可以执行以下有效载荷。我们传递给 `expect://` 的命令是一个简单的 netcat
    bash 重定向器，指向我们位于云端的 C2 服务器 `c2.spider.ml`：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The beauty of this is we don't necessarily care about the output. If this is
    a blind XXE attack, our shell will spawn just fine.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这的美妙之处在于我们不一定关心输出。如果这是一个盲目 XXE 攻击，我们的 shell 会正常生成。
- en: 'Once the XML payload is parsed and the application attempts to expand the shell
    entity, the `expect` module will execute our netcat command on the target and
    we will gain shell access to the application server:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 XML 有效载荷被解析，且应用程序尝试展开 shell 实体，`expect` 模块将执行我们在目标上使用的 netcat 命令，我们将获得对应用服务器的
    shell 访问：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Netcat is not the only shell option available. If we have code execution through
    `expect://`, we can also upload a Meterpreter payload and gain access through
    the Metasploit console, giving us more post-exploitation tools at our fingertips.
    With remote code execution, the sky is the limit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 并不是唯一的 shell 选项。如果我们通过 `expect://` 获得代码执行权限，还可以上传 Meterpreter 有效载荷，并通过
    Metasploit 控制台获取访问权限，从而获得更多的后期利用工具。有了远程代码执行，几乎没有限制。
- en: Interactive shells
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式 Shell
- en: Reverse shells over netcat are good enough to execute some commands and perhaps
    read files, but they don't provide interactivity. To be more productive during
    post-exploitation, we need access to various tools, such as Vim or SSH, which
    require a proper terminal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 netcat 反向 shell 可以执行一些命令并可能读取文件，但它不提供交互性。为了在后期利用中更高效，我们需要访问一些工具，比如 Vim 或
    SSH，它们需要一个合适的终端。
- en: 'There are a few steps we need to take, which some may call magic, in order
    to upgrade our shell. First, we can call `python` to spawn a new TTY bash shell.
    Although not perfect, it''s better than what we had before:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 升级我们的 shell 需要几个步骤，有些人可能称之为魔法。首先，我们可以调用`python`来生成一个新的 TTY bash shell。虽然不完美，但比我们之前的要好：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The one-liner may look strange if you're not familiar with Python, but all it
    really does is import the `pty` package and spawn a bash shell.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 Python，这一行代码可能看起来很奇怪，但它其实做的就是导入`pty`包并生成一个 bash shell。
- en: 'In our reverse shell, we execute the `python` command and the result should
    look familiar:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的反向 shell 中，我们执行`python`命令，结果应该看起来很熟悉：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are some issues with this still: while Vim will work, there''s no access
    to history, or *Tab* completion, and *Ctrl*-*C* will terminate the shell.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一些问题：虽然 Vim 能正常工作，但无法访问历史记录，*Tab* 补全也不起作用，*Ctrl*-*C*会终止 shell。
- en: Let's go a step further and try to upgrade to a full TTY using `stty` and the
    local terminal configuration.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，尝试通过`stty`和本地终端配置升级到完整的 TTY。
- en: 'First, once the shell is upgraded using the preceding Python one-liner, we
    have to send the process to the background using *Ctrl*-*Z*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一旦使用前面的 Python 一行代码升级了 shell，我们需要通过*Ctrl*-*Z*将进程发送到后台：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to find the current terminal type by inspecting the `$TERM` variable:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过检查`$TERM`变量来找出当前的终端类型：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our C2 server is running in a `screen` session, but you can expect to see `xterm-256color`
    or Linux on a typical Kali installation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 C2 服务器正在一个`screen`会话中运行，但在典型的 Kali 安装中，你可能会看到`xterm-256color`或 Linux。
- en: 'Now, we need the configured rows and columns for the terminal display. To get
    these values, we use the `stty` program with the `-a` option:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置好的终端显示行数和列数。为了获取这些值，我们使用`stty`程序并加上`-a`选项：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The next command may seem as though it breaks the terminal, but in order to
    prevent *Ctrl*-*C* from killing our shell, we have to turn the TTY to `raw` and
    disable the echo of each character. The commands we input in our shell will still
    be processed, but the terminal itself, without a reverse shell active, may look
    broken.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令可能看起来像是破坏了终端，但为了防止*Ctrl*-*C*终止我们的 shell，我们必须将 TTY 设置为`raw`并禁用每个字符的回显。我们在
    shell 中输入的命令仍然会被处理，但没有激活反向 shell 时，终端本身可能看起来已经损坏。
- en: 'We tell `stty` to set the terminal to `raw` and disable echo with `-echo`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉`stty`将终端设置为`raw`并通过`-echo`禁用回显：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To get our shell back from the background, we issue the `fg` command. You will
    notice that this is not echoed into the terminal, due to the previously issued
    `stty raw -echo` command, but it should still be processed:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的 shell 从后台恢复过来，我们输入`fg`命令。你会注意到，由于之前输入的`stty raw -echo`命令，这个命令并没有在终端中回显，但它应该还是会被处理：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Returning from the background, you will see the reverse shell command echoed
    back to the screen: `nc -lvp 443`, and everything may look a bit broken again.
    No problem– we can type `reset` to clean it up.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从后台返回后，你将看到反向 shell 命令回显到屏幕上：`nc -lvp 443`，一切可能又看起来有些破损。没关系——我们可以输入`reset`来清理它。
- en: 'Inside the reverse shell, now that everything looks good again, we also need
    to set the same terminal options, including rows, columns, and type, in order
    for the shell to work properly:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向 shell 中，现在一切看起来都恢复正常，我们还需要设置相同的终端选项，包括行数、列数和类型，以便 shell 正常工作：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result is a fully working terminal with all the fancy features, and yes,
    we can even run `screen` in our netcat reverse shell:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果是一个完全可用的终端，具有所有炫酷的功能，没错，我们甚至可以在我们的 netcat 反向 shell 中运行`screen`：
- en: '![Interactive shells](graphics/B09238_10_20.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![交互式 shell](graphics/B09238_10_20.jpg)'
- en: 'Figure 10.20: A fully functional interactive reverse shell'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20：完全功能的交互式反向 shell
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how XXE exploitation can be practical in an engagement.
    We then explored the potential DoS conditions that, when used with care, can provide
    distraction during a red-team attack.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 XXE 漏洞利用在攻防演练中的实际应用。接着，我们讨论了潜在的 DoS 情况，这些情况如果小心使用，能够在红队攻击中提供干扰。
- en: We also examined XML-based request forgery attacks to not only perform a port
    scan but also chain exploits to reach vulnerable applications that we would otherwise
    not have access to. A more common use of XXE is to leak valuable information from
    the target application. We not only looked at the traditional exfiltration of
    data but also scenarios in which out-of-band communication was necessary. Using
    our cloud C2 server, we were able to exfiltrate data using a blind XXE attack.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了基于 XML 的请求伪造攻击，不仅可以进行端口扫描，还能通过链式利用攻击来访问我们本来无法接触到的易受攻击的应用程序。XXE 更常见的用途是从目标应用程序中泄露重要信息。我们不仅研究了传统的数据外泄方式，还探讨了在需要带外通信的场景下如何进行数据外泄。通过我们的云
    C2 服务器，我们能够通过盲目 XXE 攻击来外泄数据。
- en: Finally, we discovered how remote code execution can be achieved using XXE.
    While not as common, older application deployments may still fall victim to these
    types of exploits.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发现如何通过 XXE 实现远程代码执行。虽然这种攻击不太常见，但一些老旧的应用程序部署仍然可能成为此类攻击的受害者。
- en: As shown throughout this chapter, file format parsers may seem benign, but with
    added features comes complexity, and complexity is, as they say, the enemy of
    security. XML is still everywhere and, when deployed and locked down properly,
    it is very powerful. Unfortunately, this is not always the case and we will be
    there to take advantage of every little mistake. In the upcoming chapter, we will
    focus our attention on APIs and how to effectively test and attack them. All of
    the skills you have learned up to this point will come in handy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所展示的那样，文件格式解析器看似无害，但随着功能的增加，复杂性也随之而来，而复杂性正如他们所说，是安全性的敌人。XML 仍然无处不在，当它正确部署并锁定时，它非常强大。不幸的是，这并非总是如此，我们会利用每一个小小的错误。在接下来的章节中，我们将把注意力集中在
    API 上，研究如何有效地测试和攻击它们。到目前为止你所学到的所有技能都将派上用场。
