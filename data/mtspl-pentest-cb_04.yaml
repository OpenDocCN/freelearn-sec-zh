- en: Chapter 4. Client-side Exploitation and Antivirus Bypass
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。客户端攻击和防病毒绕过
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Internet Explorer unsafe scripting misconfiguration vulnerability
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet Explorer不安全的脚本配置漏洞
- en: Internet Explorer recursive call memory corruption
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet Explorer递归调用内存损坏
- en: Microsoft Word RTF stack buffer overflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Word RTF堆栈缓冲区溢出
- en: Adobe Reader `util.printf()` buffer overflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adobe Reader `util.printf()`缓冲区溢出
- en: Generating binary and shellcode from `msfpayload`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`msfpayload`生成二进制和shellcode
- en: Bypassing client-side antivirus protection using `msfencode`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`msfencode`绕过客户端防病毒保护
- en: Using `killav.rb` script to disable antivirus programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`killav.rb`脚本禁用防病毒程序
- en: A deeper look into the `killav.rb` script
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解`killav.rb`脚本
- en: Killing antivirus services from the command line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行终止防病毒服务
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we focused on penetration testing the target operating
    system. Operating systems are the first level of penetrating the target because
    an unpatched and outdated operating system can be easy to exploit and it will
    reduce our effort of looking for other methods of penetrating the target. But
    the situation can vary. There can be cases in which a firewall may block our scan
    packets and, thus, prevent us from gaining any information about the target operating
    system or open ports.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于对目标操作系统进行渗透测试。操作系统是渗透目标的第一层，因为未打补丁和过时的操作系统很容易被利用，这将减少我们寻找其他渗透目标方法的努力。但情况可能有所不同。有时防火墙可能会阻止我们的扫描数据包，从而阻止我们获取有关目标操作系统或开放端口的任何信息。
- en: There can also be a possibility that the target has automatic updates which
    patches the vulnerabilities of the operating system at regular intervals. This
    can again kill all the attacks of penetrating the target. Such security measures
    can prevent us from gaining access to the target machine by exploiting known vulnerabilities
    of the operating system in use. So we will have to move a step ahead. This is
    where client-side exploitation and antivirus bypassing techniques comes into play.
    Let us first understand a typical client-side attack vector.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能目标有自动更新，定期修补操作系统的漏洞。这可能再次阻止所有渗透目标的攻击。这样的安全措施可以防止我们通过利用操作系统中已知的漏洞来获取对目标机器的访问。因此，我们必须向前迈进一步。这就是客户端攻击和绕过防病毒技术发挥作用的地方。让我们首先了解典型的客户端攻击向量。
- en: Suppose the penetration tester has figured out that the target machine has an
    updated Windows XP SP3 operating system and Internet Explorer version 7 set up
    as the default browser to access the Internet and other web-related services.
    So, the pen-tester will now craft a malicious URL that will contain an executable
    script which can exploit a known vulnerability of IE 7\. Now he builds a harmless
    looking HTML page and creates a hyperlink which contains the same malicious URL.
    In the next step, he transfers the HTML page to the target user through social
    engineering and somehow entices him to click the malicious hyperlink. Since the
    link contained a known exploit of IE 7 browser, it can compromise the browser
    and allow further code execution, thus giving the penetration tester power to
    control the target system. He can move ahead to set up a backdoor, drop a virus,
    and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设渗透测试人员已经发现目标机器安装了更新的Windows XP SP3操作系统，并设置Internet Explorer 7作为默认浏览器来访问互联网和其他与网络相关的服务。因此，渗透测试人员现在将构建一个恶意URL，其中包含一个可利用IE
    7已知漏洞的可执行脚本。现在他构建了一个看似无害的HTML页面，并创建了一个包含相同恶意URL的超链接。接下来，他通过社会工程将HTML页面传输给目标用户，并以某种方式诱使他点击恶意超链接。由于该链接包含IE
    7浏览器的已知漏洞利用，它可以破坏浏览器并允许进一步的代码执行，从而使渗透测试人员能够控制目标系统。他可以继续设置后门、释放病毒等。
- en: What exactly happens now? Although the target machine was running a patched
    and updated version of Windows the default browser IE 7 was not updated or rather
    neglected by the target user. This allowed the penetration tester to craft a scenario
    and break into the system through the browser vulnerability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到底发生了什么？尽管目标机器运行了经过修补和更新的Windows操作系统，但默认浏览器IE 7并未更新，或者说被目标用户忽视了。这使得渗透测试人员能够构建一个场景，并通过浏览器漏洞进入系统。
- en: The scenario discussed previously is a simple client-side attack in which the
    target unknowingly executes a script which exploits vulnerability in the application
    software used by the target user. On successful execution of the exploit, the
    attacker compromises the system security.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 先前讨论的情景是一个简单的客户端攻击，目标在不知情的情况下执行了一个利用目标用户使用的应用软件中的漏洞的脚本。成功执行利用后，攻击者会破坏系统安全。
- en: Metasploit provides us with a large variety of exploit modules for several popular
    software which can be used to perform a client-side attack. Some of the popular
    tools which we will discuss in this chapter include Internet Explorer, Microsoft
    Office pack, Adobe reader, Flash, and so on. Metasploit repository contains several
    modules for these popular tools. Let us quickly analyze the client-side exploitation
    process in Metasploit. Our aim is to successfully attack the target through a
    client-side execution and set up shell connectivity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit为我们提供了大量针对几种流行软件的利用模块，可以用于执行客户端攻击。本章将讨论的一些流行工具包括Internet Explorer、Microsoft
    Office套件、Adobe Reader、Flash等。Metasploit存储库包含这些流行工具的多个模块。让我们快速分析Metasploit中的客户端攻击过程。我们的目标是通过客户端执行成功攻击目标并建立shell连接。
- en: 'Metasploit breaks this penetration process into two simple steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit将这个渗透过程分解为两个简单的步骤：
- en: It generates the respective malicious link/file for the application tool you
    choose to target. After that, it starts listening on a particular port for a back
    connection with the target. Then the attacker sends the malicious link/file to
    the target user.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您选择的应用程序工具生成相应的恶意链接/文件。然后，它开始在特定端口上监听与目标的反向连接。然后攻击者将恶意链接/文件发送给目标用户。
- en: Now once the target executes the malicious link/file, the application gets exploited
    and Metasploit immediately transfers the payload to some other Windows process
    so that if the target application crashes (due to exploit) or a user closes the
    application, the connectivity still remains.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一旦目标执行了恶意链接/文件，应用程序就会被利用，Metasploit立即将有效载荷传输到其他Windows进程，这样如果目标应用程序崩溃（由于利用）或用户关闭应用程序，连接仍然保持。
- en: The two preceding steps will be clear to you when we will discuss the recipes
    based on client-side attacks. This chapter will focus on some key application
    software based on the Windows operating system. We will start with analyzing browser-based
    client side exploits. We will look into various existing flaws in Internet Explorer
    (version 6, 7, and 8) and how to target it to penetrate the user machine. Then,
    we will shift to another popular software package named Microsoft Office (version
    2003 and 2007) and analyze its formatting vulnerability. Then, we will move ahead
    with analyzing PDF vulnerabilities and how a malicious PDF can be used to compromise
    the user security. Last, but not the least, we will discuss a very important aspect
    of penetration testing called antivirus bypass. It will focus on overriding the
    client-side antivirus protection to exploit the target machine without raising
    alarms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论基于客户端的攻击的配方时，前面两个步骤将对你来说是清晰的。本章将专注于基于Windows操作系统的一些关键应用软件。我们将从分析基于浏览器的客户端攻击开始。我们将研究Internet
    Explorer（版本6、7和8）中的各种现有漏洞，以及如何针对它来渗透用户机器。然后，我们将转向另一个名为Microsoft Office（版本2003和2007）的流行软件包，并分析其格式漏洞。然后，我们将继续分析PDF漏洞，以及如何使用恶意PDF来破坏用户安全。最后，但并非最不重要的，我们将讨论渗透测试中非常重要的一个方面，即绕过防病毒软件。它将重点放在覆盖客户端防病毒保护，以在不引起警报的情况下利用目标机器。
- en: This chapter will leverage the complete power of the Metasploit framework so
    that you will love reading and implementing it. Let us move ahead with our recipes
    for this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将充分利用Metasploit框架的全部功能，让你会喜欢阅读和实施它。让我们继续本章的配方。
- en: Internet Explorer unsafe scripting misconfiguration vulnerability
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Internet Explorer不安全的脚本配置漏洞
- en: Let us start with the first browser-based client side exploit. The elementary
    process of using any client-side exploit module is similar to the ones we discussed
    in previous chapters. The only difference lies in transferring the exploit to
    the target. Unlike operating system-based exploits, client-side exploits require
    manual execution of the exploit and payload at the target machine. You will understand
    it clearly, once we proceed with the recipe. So let us quickly dive into implementing
    the attack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个基于浏览器的客户端攻击开始。使用任何客户端攻击模块的基本过程与我们在之前章节中讨论的类似。唯一的区别在于将利用传输到目标机器。与基于操作系统的利用不同，客户端利用需要手动执行利用和有效载荷。一旦我们进行配方，你将清楚地理解它。所以让我们快速地开始实施攻击。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: We will start with launching our msfconsole and selecting the relevant exploit.
    The process is similar to what we have been discussing so far in previous chapters.
    Then, we will move ahead to select a payload which will help us set a shell connectivity
    with the target machine. The exploit we will be dealing with in this recipe is
    `exploit/windows/browser/i.e. unsafe scripting`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始启动我们的msfconsole并选择相关的利用。这个过程与我们在之前章节中讨论的类似。然后，我们将继续选择一个有效载荷，它将帮助我们与目标机器建立shell连接。在这个配方中，我们将处理的利用是`exploit/windows/browser/i.e.
    unsafe scripting`。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This exploit is known to affect Internet Explorer version 6 and 7 which are
    default browsers in all versions of Windows XP and 2003 servers. But it ran successfully
    even on my Windows 7 ultimate with internet Explorer 8 (unpatched).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个利用已知影响Internet Explorer 6和7版本，它们是Windows XP和2003服务器所有版本的默认浏览器。但它甚至成功运行在我的Windows
    7 ultimate上，使用的是Internet Explorer 8（未打补丁）。
- en: This exploit works when the **Initialize and script ActiveX controls not marked
    as safe** setting is marked within Internet Explorer. The following setting can
    be found by launching Internet Explorer and browsing to **Tools** | **Internet
    Options** | **Security** | **Custom Level** | **Initialize and script ActiveX
    controls not marked as safe** | **Enable**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当Internet Explorer中标记了**未标记为安全的初始化和脚本ActiveX控件**设置时，这个利用就会生效。可以通过启动Internet
    Explorer并浏览到**工具** | **Internet选项** | **安全** | **自定义级别** | **未标记为安全的初始化和脚本ActiveX控件**
    | **启用**来找到这个设置。
- en: '![Getting ready](img/7423_04_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![做好准备](img/7423_04_01.jpg)'
- en: Similar settings can be made in other versions of Internet Explorer as well.
    In this recipe, we will exploit two different targets. One is running Windows
    XP SP2 with IE 7 and the other is running Windows 7 with IE 8\. Let us now move
    ahead to execute the exploit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其他版本的Internet Explorer也可以进行类似的设置。在这个配方中，我们将利用两个不同的目标。一个运行Windows XP SP2，IE 7，另一个运行Windows
    7，IE 8。现在让我们继续执行利用。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Let us start with launching the msfconsole and set our respective exploit as
    active. We will be using the `reverse_tcp` payload to get shell connectivity with
    the two targets once they are exploited:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始启动msfconsole并将我们的相应利用设置为活动状态。一旦被利用，我们将使用`reverse_tcp`有效载荷与这两个目标建立shell连接：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now our exploit, as well as the payload has been set active. As you can see,
    we have not used the RHOST option here because it is a client-based attack. Let''s
    see what happens when we execute the `exploit` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的利用程序和有效载荷已经被设置为活动状态。正如你所看到的，我们在这里没有使用RHOST选项，因为这是一个基于客户端的攻击。让我们看看当我们执行`exploit`命令时会发生什么：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, a link has been generated as a result of the `exploit` command.
    This is the malicious link (`http://192.168.56.101:8080/2IGIaoJQB`) that we will
    have to send to our targets, so that it can exploit their browser. Also the last
    line says "server started" which is actually listening for a connection on port
    4444 from the target machine. Let us first analyze the outcome of the link execution
    on the Windows XP target machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`exploit`命令的结果生成了一个链接。这是我们将不得不发送给我们的目标的恶意链接（`http://192.168.56.101:8080/2IGIaoJQB`），以便它可以利用他们的浏览器。最后一行还说“服务器已启动”，实际上是在端口4444上监听来自目标机器的连接。让我们首先分析链接在Windows
    XP目标机器上的执行结果。
- en: 'The browser will try to load the page, but at the end nothing will be displayed.
    In turn, the browser either will hang or will remain idle. But you will notice
    some activity on your msfconsole. This activity will be similar to the one shown
    in the following command line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将尝试加载页面，但最终不会显示任何内容。相反，浏览器要么会挂起，要么会保持空闲状态。但你会注意到你的msfconsole上有一些活动。这个活动将类似于以下命令行中显示的活动：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Awesome! We have an active session with our target machine. The preceding command-line
    output shows that an executable file has been created in the `temp` folder of
    our target which is responsible for this entire exploitation process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们与目标机器有一个活动会话。前面的命令行输出显示，在我们的目标的`temp`文件夹中创建了一个可执行文件，这个文件负责整个利用过程。
- en: Let us now analyze the outcome of this malicious link execution on the Windows
    7 machine with IE 8.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在分析这个恶意链接在运行IE 8的Windows 7机器上的执行结果。
- en: We will notice that Internet Explorer will prompt with an alert message. On
    clicking **Allow**, the outside script will get executed and the browser may crash
    or hang (depending upon the system).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注意到Internet Explorer会提示一个警报消息。点击**允许**后，外部脚本将被执行，浏览器可能会崩溃或挂起（取决于系统）。
- en: '![How to do it...](img/7423_04_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7423_04_02.jpg)'
- en: 'Let us switch to attacking the msfconsole and notice the activity. We will
    notice the following command-line activity:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到攻击msfconsole并注意活动。我们将注意到以下命令行活动：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have yet another active session opened with the Windows 7 machine as well.
    Let us start interacting with our sessions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个与Windows 7机器打开的活动会话。让我们开始与我们的会话互动：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the sessions command has revealed the active sessions available
    to us. One is our Win XP machine and the other one is the Win7 machine. Let us
    move ahead to interact with the second session, that is, the Windows 7 machine.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`sessions`命令显示了我们可以使用的活动会话。一个是我们的Win XP机器，另一个是Win7机器。让我们继续与第二个会话互动，也就是Windows
    7机器。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working process might be clear to you. Let us focus on the reason for this
    exploit. When "Initialize and script ActiveX controls not marked safe for scripting"
    is set, then it allows access to the `WScript.Shell` ActiveX control. This `WScript.Shell`
    object provides functions to read the file system, environment variables, read
    and modify registry, and manage shortcuts. This feature of `WScript.Shell` allows
    the attacker to create a JavaScript to interact with the file system and run commands.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 工作过程可能对你来说很清楚。让我们专注于这个利用的原因。当设置“未标记为脚本安全的ActiveX控件的初始化和脚本”时，它允许访问`WScript.Shell`
    ActiveX控件。这个`WScript.Shell`对象提供了读取文件系统、环境变量、读取和修改注册表以及管理快捷方式的功能。`WScript.Shell`的这个特性允许攻击者创建一个JavaScript来与文件系统交互并运行命令。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us talk about another important browser-based exploit which can be used
    in a client-side attack.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈另一个可以在客户端攻击中使用的重要基于浏览器的利用。
- en: Internet Explorer Aurora memory corruption
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Internet Explorer Aurora内存损坏
- en: This is another widely used exploit for IE which came into light in mid 2010\.
    This flaw was the key component of "Operation Aurora" in which hackers targeted
    some top companies. This module exploits a memory corruption flaw in IE 6\. I
    am leaving this module as an exercise for you to try out and explore. The exploit
    can be found in `exploit/windows/browser/ms10_002_aurora`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个广泛使用的IE利用，于2010年中期曝光。这个漏洞是“极光行动”的关键组成部分，黑客们针对一些顶级公司。该模块利用了IE 6中的内存损坏漏洞。我将把这个模块留给你作为一个练习来尝试和探索。利用可以在`exploit/windows/browser/ms10_002_aurora`中找到。
- en: Internet Explorer CSS recursive call memory corruption
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Internet Explorer CSS递归调用内存损坏
- en: This is one of the most recent exploits available for the Windows platform running
    IE browser. This exploit is known to affect Windows 7 and Windows 2008 server
    with IE 8 as the default browser. The working process of this exploit is similar
    to the one we just discussed in the previous recipe. So let us quickly test it.
    Our target machine is a Windows 7 ultimate edition with IE 8 (unpatched) running
    as the default browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Windows平台上运行IE浏览器的最新利用之一。这个利用已知影响Windows 7和Windows 2008服务器，IE 8作为默认浏览器。这个利用的工作过程与我们刚刚在上一个示例中讨论的工作过程类似。所以让我们快速测试一下。我们的目标机器是运行IE
    8（未打补丁）的Windows 7旗舰版。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will start with launching the msfconsole. Our exploit in this recipe is `exploit/windows/browser/ms11_003_ie_css_import`
    and our payload will be `windows/meterpreter/bind_tcp` which will help in gaining
    shell connectivity with the target machine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从启动msfconsole开始。在这个示例中，我们的利用是`exploit/windows/browser/ms11_003_ie_css_import`，我们的有效载荷将是`windows/meterpreter/bind_tcp`，这将帮助我们与目标机器建立shell连接。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will start the same way we have been doing so far. First, we will select
    the exploit. Then, we will select the payload and pass on the various parameter
    values required by the exploit and the payload. Let us move ahead with all these
    steps in our msfconsole.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以迄今为止的相同方式开始。首先，我们将选择利用。然后，我们将选择有效载荷，并传递利用和有效载荷所需的各种参数值。让我们在我们的msfconsole中继续进行所有这些步骤。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the exploit and payload have been set along with various parameters.
    After executing the `exploit` command, the module has generated a local link `http://192.168.56.101:8080/K9JqHoWjzyAPji`.
    This is the malicious link which has to be transferred to the target in order
    to make him execute in his IE browser. The target browser will freeze completely
    and will consume a large part of the system resource. The target will be forced
    to shut down the browser. Let us monitor the activities on the msfconsole:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，漏洞利用和有效载荷已经设置，并带有各种参数。执行`exploit`命令后，模块生成了一个本地链接`http://192.168.56.101:8080/K9JqHoWjzyAPji`。这是恶意链接，必须传输给目标，以便他在IE浏览器中执行。目标浏览器将完全冻结，并且将占用系统资源的大部分。目标将被迫关闭浏览器。让我们在msfconsole上监视活动：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Upon successful execution of the exploit in the target's browser, we have a
    session started in the msfconsole, thus, opening shell connectivity. But there
    is something more that happens after opening a session between msf and the target.
    The `InitialAutoRunScript` executes a `migrate -f` command which migrates the
    payload from `iexplore.exe` to `notepad.exe`. This step is essential for a persistent
    connectivity. Even if the target user closes the browser, still the connection
    will be alive as we have migrated to another process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标浏览器成功执行漏洞利用后，我们在msfconsole中启动了一个会话，从而打开了shell连接。但在msf和目标之间建立会话后，还会发生更多的事情。`InitialAutoRunScript`执行了一个`migrate
    -f`命令，将有效载荷从`iexplore.exe`迁移到`notepad.exe`。这一步对于持久连接是必不可少的。即使目标用户关闭了浏览器，连接仍然会保持活动，因为我们已经迁移到另一个进程。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let us dig out this vulnerability for more information. Well, the reason for
    the vulnerability is exactly what its name says. When Microsoft's HTML engine
    (mshtml) parses an HTML page that recursively imports the same CSS file multiple
    times, then it leads to a memory corruption and allows arbitrary code execution.
    Consider the following HTML code snippet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们挖掘一下这个漏洞，以获取更多信息。嗯，漏洞的原因正是它的名字所说的。当微软的HTML引擎（mshtml）解析递归多次导入相同的CSS文件的HTML页面时，就会导致内存损坏并允许任意代码执行。考虑以下HTML代码片段。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The same CSS file has been called four times. When mshtml parses this HTML page
    then it leads to a memory corruption. This exploit utilizes a combination of heap
    spraying and the .NET 2.0 **mscorie.dll** module to bypass DEP and ASLR. Due to
    over consumption of system resources, it finally crashes. Using this vulnerability
    the attacker gains the same user rights as the logged in user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个CSS文件被调用了四次。当mshtml解析这个HTML页面时，就会导致内存损坏。这个漏洞利用利用了堆喷射和.NET 2.0 **mscorie.dll**模块的组合来绕过DEP和ASLR。由于系统资源的过度消耗，最终会崩溃。使用这个漏洞，攻击者获得与已登录用户相同的用户权限。
- en: '![How it works...](img/7423_04_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7423_04_03.jpg)'
- en: In the preceding screenshot, you can see that the background consists of the
    IE instance in which the malicious link has been executed and the foreground image
    is of the Windows task manager in which you can clearly see the over consumption
    of memory by the IE browser. Another interesting thing to note in this task manager
    is the notepad.exe process. Even though there is no running instance of notepad,
    still the task manager is showing this process. The obvious reason for this is
    that we have migrated from iexplorer.exe to notepad.exe so this process is running
    in the background.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到背景是IE实例，其中执行了恶意链接，前景图像是Windows任务管理器，您可以清楚地看到IE浏览器过度消耗内存。在任务管理器中还有一件有趣的事情要注意，那就是notepad.exe进程。尽管没有运行notepad的实例，但任务管理器仍然显示这个进程。这样做的明显原因是我们已经从iexplorer.exe迁移到notepad.exe，所以这个进程在后台运行。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a common error which we may encounter while using this exploit module.
    Let's have a quick look at it and find out a relevant solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这个漏洞利用模块时，我们可能会遇到一个常见的错误。让我们快速看一下，并找出相关的解决方案。
- en: Missing .NET CLR 2.0.50727
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺少.NET CLR 2.0.50727
- en: You may encounter an error "Target machine does not have the .NET CLR 2.0.50727"
    while using this exploit module. Well, the reason for this error is not because
    .Net is missing. The main reason for it is that Internet Explorer is not set as
    the default browser so the user agent is being abused to fetch an address from
    a non-ASLR region. This error can be overcome by setting Internet Explorer as
    the default web browser.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这个漏洞利用模块时，您可能会遇到一个错误"目标机器没有.NET CLR 2.0.50727"。嗯，这个错误的原因不是因为缺少.NET。它的主要原因是因为Internet
    Explorer没有设置为默认浏览器，因此用户代理被滥用以从非ASLR区域获取地址。通过将Internet Explorer设置为默认的Web浏览器，可以克服这个错误。
- en: Microsoft Word RTF stack buffer overflow
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft Word RTF堆栈缓冲区溢出
- en: In the previous two recipes, we focused completely on browser-based exploits.
    Now in this recipe, we will focus on another popular Windows tool called Microsoft
    Office. The RTF buffer overflow flaw exists in both 2010 and 2007 versions of
    the Office software pack. This vulnerability exists in the handling of `pfragments`
    shape property within the Microsoft Word RTF parser. Let us understand this exploit
    in detail. I am assuming that we have already gained information about our target
    that it has Office pack installed on his system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个教程中，我们完全专注于基于浏览器的漏洞利用。现在在这个教程中，我们将专注于另一个流行的Windows工具，称为Microsoft Office。RTF缓冲区溢出漏洞存在于Office软件包的2010和2007版本中。这个漏洞存在于Microsoft
    Word RTF解析器中的`pfragments`形状属性的处理中。让我们详细了解这个漏洞利用。我假设我们已经获得了关于我们的目标的信息，即他的系统上安装了Office软件包。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with launching the msfconsole. The exploit we will be using in
    this recipe can be located at `exploit/windows/fileformat/ms10_087_rtf_pfragments_bof`.
    The payload we will be using is `windows/meterpreter/reverse_tcp` to get shell
    connectivity with the target machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从启动msfconsole开始。我们将在这个教程中使用的漏洞可以在`exploit/windows/fileformat/ms10_087_rtf_pfragments_bof`中找到。我们将使用的有效载荷是`windows/meterpreter/reverse_tcp`，以与目标机器建立shell连接。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The working process will again be similar to what we have seen so far in previous
    recipes. We will first set our exploit. Then, we will select a payload and then
    pass the relevant parameters for both in order to execute the exploit successfully.
    Let us perform these steps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 工作过程将与我们在以前的食谱中看到的类似。我们将首先设置我们的利用。然后，我们将选择一个有效载荷，然后传递相关参数，以便成功执行利用。让我们执行这些步骤。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The exploit contains a parameter `FILENAME` which contains information about
    the malicious filename to be created. The default value is `msf.rtf`. Let us change
    it to some less suspicious name. We will also set the value for `LHOST` which
    is the attacking machine IP address.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 利用包含一个`FILENAME`参数，其中包含有关要创建的恶意文件名的信息。默认值为`msf.rtf`。让我们将其更改为一些不太可疑的名称。我们还将设置`LHOST`的值，这是攻击机的IP地址。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The filename has been changed to `priceinfo.rtf` and the value of `LHOST` has
    been set to `192.168.56.101`. So we are all set to execute the exploit module
    now.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名已更改为`priceinfo.rtf`，`LHOST`的值已设置为`192.168.56.101`。所以我们已经准备好执行利用模块了。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Metasploit has created a malicious file for us which we will have to use in
    order to proceed with the client-side attack. The file is located at `/root/.msf4/local/priceinfo.rtf`.
    Now the next step is to send this file to the target user either through a mail
    or through some other medium. Once the target user executes this malicious file,
    we will notice that it will open as a word document. After few seconds of execution,
    the Microsoft Word instance will either hang or crash depending upon the system.
    In the meantime, the malicious file successfully executes the exploit and provides
    an active session with the target. In order to make the connection persistent,
    the exploit migrates itself to some other process which will run in the background.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit已经为我们创建了一个恶意文件，我们必须使用它来进行客户端攻击。该文件位于`/root/.msf4/local/priceinfo.rtf`。现在的下一步是将此文件发送给目标用户，可以通过邮件或其他媒介。一旦目标用户执行了这个恶意文件，我们会注意到它会以一个Word文档的形式打开。在执行几秒钟后，Microsoft
    Word实例将挂起或崩溃，具体取决于系统。与此同时，恶意文件成功执行利用，并为目标提供了一个活动会话。为了使连接持久，利用将自己迁移到后台运行的其他进程。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first few lines of the command line shows a successful execution of the
    exploit which results in an active session with `SESSION ID = 2`. The last part
    of the command line shows that the exploit has successfully migrated from `WINWORD.EXE`
    to `notepad.exe`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行的前几行显示了成功执行利用，结果是与`SESSION ID = 2`的活动会话。命令行的最后部分显示，利用已成功从`WINWORD.EXE`迁移到`notepad.exe`。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The exploit module simply creates a malicious word file that passes illegal
    values to the word parser. The failure of parser in recognizing the illegal values
    leads to a buffer overflow in it. Then the payload comes into action which executes
    the code to set up a back connection with the attacking machine. The success of
    this attack varies from machine to machine as there can be situations when **Windows
    ASLR (Address Space Layout Randomization)** can prevent execution of an arbitrary
    code (payload).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 利用模块简单地创建一个恶意的Word文件，向Word解析器传递非法值。解析器无法识别非法值导致缓冲区溢出。然后有效载荷开始执行代码，与攻击机建立反向连接。这种攻击的成功与机器有关，因为有时**Windows
    ASLR（地址空间布局随机化）**可能会阻止执行任意代码（有效载荷）。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is another popular exploit available for the Office suite. I will leave
    it as a lesson for you to practically try it. Here I will give a brief overview
    about it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Office套件还有另一个流行的利用。我将把它作为一个实践的课程留给你。在这里，我将简要概述一下。
- en: Microsoft Excel 2007 buffer overflow
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft Excel 2007缓冲区溢出
- en: This known exploit targets the Microsoft Excel tool (`.xlb`) for version 2007\.
    Execution of a malicious .xlb file can lead to a stack-based buffer overflow and
    lead to an arbitrary code execution. The exploit can be located at `exploit/windows/fileformat/ms11_021_xlb_bof`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个已知的利用针对Microsoft Excel工具（`.xlb`）的2007版本。执行恶意的.xlb文件可能导致基于堆栈的缓冲区溢出，并导致任意代码执行。利用可以在`exploit/windows/fileformat/ms11_021_xlb_bof`中找到。
- en: Adobe Reader util.printf() buffer overflow
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adobe Reader util.printf()缓冲区溢出
- en: PDF is one of the most widely used formats for sharing files and documents.
    So, using it as a potential weapon to exploit the target machine can be a fruitful
    idea. Adobe Reader is the most popular PDF file reader tool. The exploit we will
    discuss here is a vulnerability existing in Adobe Reader prior to versions 8.1.3\.
    The exploit works by creating a malicious PDF file which, when opened in vulnerable
    versions of Adobe Reader, causes a buffer overflow and allows an arbitrary code
    execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PDF是用于共享文件和文档的最广泛使用的格式之一。因此，将其用作利用目标机器的潜在武器可能是一个有益的想法。Adobe Reader是最流行的PDF文件阅读工具。我们将讨论的利用是存在于Adobe
    Reader 8.1.3版本之前的漏洞。利用的工作原理是创建一个恶意的PDF文件，当在Adobe Reader的易受攻击版本中打开时，会导致缓冲区溢出，并允许任意代码执行。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The exploit process is very similar to those we have discussed so far in this
    chapter. Almost all client-side attacks work in a similar manner in which we first
    generate a malicious file/link and then somehow ask the target user to execute
    it on his/her machine. So a client-side attack involves Social Engineering as
    well. Let us move on to this exploit. Here, our target machine is Windows XP SP3
    running Adobe Reader version 8.1.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 利用过程与本章迄今讨论的利用非常相似。几乎所有客户端攻击都以类似的方式工作，我们首先生成一个恶意文件/链接，然后以某种方式要求目标用户在其机器上执行它。因此，客户端攻击也涉及社会工程。让我们继续进行这次利用。在这里，我们的目标机器是运行Adobe
    Reader 8.1的Windows XP SP3。
- en: We will start with launching our msfconsole and use the module `exploit/windows/fileformat/adobe_utilprintf`
    and payload module as `windows/meterpreter/reverse_tcp`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从启动我们的msfconsole开始，并使用模块`exploit/windows/fileformat/adobe_utilprintf`和有效载荷模块`windows/meterpreter/reverse_tcp`。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will start with selecting the exploit and setting it a active. Then, we will
    set the payload. After selecting the exploit and the payload, our next step will
    be to pass the various parameter values required to execute it. So, let us move
    ahead to perform these steps over the msfconsole.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从选择漏洞利用并将其设置为活动开始。然后，我们将设置有效载荷。在选择漏洞利用和有效载荷之后，我们的下一步将是传递执行所需的各种参数值。所以，让我们继续在msfconsole上执行这些步骤。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the target version of Adobe Reader is listed as 8.1.2 and the
    operating system is mentioned as Windows XP SP3\. So, the success of this exploit
    will greatly depend on the version or Adobe Reader and operating system used by
    the target.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，目标版本的Adobe Reader被列为8.1.2，操作系统被标记为Windows XP SP3。因此，这次漏洞利用的成功将在很大程度上取决于目标使用的Adobe
    Reader版本或操作系统。
- en: The exploit module contains a parameter `FILENAME` with a default value. This
    parameter decides the name of the malicious PDF file that will be created. Let
    us change its value to something less suspicious. Also we will have to pass the
    IP address of the local machine in `LHOST` parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞利用模块包含一个带有默认值的参数`FILENAME`。这个参数决定了将要创建的恶意PDF文件的名称。让我们将其值更改为一些不太可疑的东西。同时，我们还必须在`LHOST`参数中传递本地机器的IP地址。
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we are all set to execute the exploit command and generate the malicious
    PDF file which will be used in our client-side attacks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好执行漏洞利用命令并生成恶意PDF文件，这将用于我们的客户端攻击。
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, a malicious PDF file named `progressreport.pdf` has been created and
    stored in the `/root/.msf4/local` folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个名为`progressreport.pdf`的恶意PDF文件已经被创建并存储在`/root/.msf4/local`文件夹中。
- en: This time we will adopt a slightly different approach to start a listener for
    reverse connection. Suppose a situation comes when you have to suddenly close
    your msfconsole. What about the exploit then? Do we have to create the malicious
    PDF again? The answer is No. There is a special listener module present in Metasploit
    which can be used to start a listener on your msfconsole so that you can resume
    with your penetration testing process using the same files/links that you generated
    for the client-side attack. Consider a scenario where we have generated the malicious
    PDF file but not yet used it for client-side attack. So let us start the msfconsole
    again and use the `exploit/multi/handler` module to set up a listener for the
    reverse connection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将采用稍微不同的方法来启动反向连接的监听器。假设有一种情况，当你不得不突然关闭你的msfconsole时。那么漏洞利用怎么办？我们需要再次创建恶意PDF吗？答案是否定的。Metasploit中有一个特殊的监听器模块，可以用来在msfconsole上启动监听器，这样你就可以使用为客户端攻击生成的相同文件/链接继续进行渗透测试过程。假设我们已经生成了恶意PDF文件，但尚未用于客户端攻击。所以让我们再次启动msfconsole，并使用`exploit/multi/handler`模块设置反向连接的监听器。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we have set up the module `multi/handler` and then we also added
    a payload to it. The next step is to add an `LHOST` and `LPORT` depending upon
    the usage. We also have an additional option to run additional scripts along with
    the multi/handler module. We will discuss it later in the next chapter. The final
    step is to execute the exploit command and start the listener.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经设置了模块`multi/handler`，然后我们还为其添加了有效载荷。下一步是根据使用情况添加`LHOST`和`LPORT`。我们还有一个额外的选项，可以在multi/handler模块中运行额外的脚本。我们将在下一章中讨论它。最后一步是执行漏洞利用命令并启动监听器。
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So our reverse handler is up and running. Now it is ready to receive back the
    connection once the malicious PDF is executed on the target machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的反向处理程序已经启动并运行。现在它已经准备好在目标机器上恶意PDF被执行后接收连接。
- en: Once the PDF is executed on the client machine, it completely freezes and the
    Adobe Reader hangs completely, leading to denial of service. The reason for this
    crash is due to the buffer overflow caused by the malicious PDF file. On the attacker
    side, you will see that a meterpreter session has been started and now the target
    machine can be handled remotely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PDF在客户端机器上执行，它会完全冻结，Adobe Reader会完全挂起，导致服务拒绝。这次崩溃的原因是由于恶意PDF文件引起的缓冲区溢出。在攻击者端，你会看到一个meterpreter会话已经启动，现在目标机器可以远程处理。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This problem was identified in the way vulnerable versions of Adobe Reader implement
    the JavaScript `util.printf()` function. The function first converts the argument
    it receives to a String, using only the first 16 digits of the argument and padding
    the rest with a fixed value of "0" (0x30). By passing an overly long and properly
    formatted command to the function, it is possible to overwrite the program's memory
    and control its execution flow. The Metasploit module creates a specifically crafted
    PDF file that embeds JavaScript code to manipulate the program's memory allocation
    pattern and trigger the vulnerability. This can allow an attacker to execute the
    arbitrary code with the privileges of a user running the Adobe Reader application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是在易受攻击的Adobe Reader版本中实现JavaScript `util.printf()`函数的方式中被发现的。该函数首先将其接收到的参数转换为字符串，只使用参数的前16位数字，并用固定值“0”（0x30）填充其余部分。通过向函数传递过长且格式正确的命令，可以覆盖程序的内存并控制其执行流程。Metasploit模块创建了一个特别设计的PDF文件，嵌入了JavaScript代码来操纵程序的内存分配模式并触发漏洞。这可以让攻击者以运行Adobe
    Reader应用程序的用户权限执行任意代码。
- en: 'Consider the following two lines of JavaScript embedded in a PDF:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑嵌入在PDF中的以下两行JavaScript代码：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These two simple JavaScript lines cause the byte 0x20 to be copied 5000 times
    on the stack. This allows you to take control of the exception handler, and also
    to trigger an exception when trying to write in the section that comes after the
    stack.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行简单的JavaScript代码会在堆栈上复制5000次字节0x20。这允许你控制异常处理程序，并在尝试写入堆栈后面的部分时触发异常。
- en: Generating binary and shellcode from msfpayload
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从msfpayload生成二进制和shellcode
- en: So far, we have discussed many techniques that can be used for penetrating the
    target machine using the client-side attacks. All those techniques involved exploiting
    vulnerability in the various pieces of application software that run on the client
    machine. But, there can be a scenario when the previously discussed techniques
    may not work. These attacks leave us to the mercy of the vulnerable application
    software which we will have to exploit in order to gain access.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了许多可以用于利用客户端攻击渗透目标机器的技术。所有这些技术都涉及利用运行在客户端机器上的各种应用软件中的漏洞。但是，可能存在一种情况，先前讨论的技术可能无法奏效。这些攻击使我们处于对应用软件的漏洞的控制之下，我们必须利用这些漏洞以获取访问权限。
- en: Metasploit provides us with another feature in which we can execute a client-side
    attack without worrying about exploiting the application software running on the
    target machine. `msfpayload` is the solution for it. Let us give a quick introduction
    to `msfpayload` and move ahead with our recipe to practically implement it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit为我们提供了另一个功能，我们可以执行客户端攻击，而不必担心利用目标机器上运行的应用软件。`msfpayload`就是解决方案。让我们简要介绍一下`msfpayload`，然后继续实际实施。
- en: '`msfpayload` is a command-line instance of Metasploit that is used to generate
    various file types of shellcodes available in the Metasploit repository. The various
    file type options available are C, Ruby, Raw, Exe, Dll, VBA, and War. We can convert
    any Metasploit shellcode into one of these mentioned file formats using `msfpayload`.
    Then, it can be transferred to the target for execution. Once the file is executed
    on the target machine, we will get an active session. This reduces the overhead
    of exploiting any vulnerability existing in the application software running on
    the target machine. The other major benefit of `msfpayload` is that it can be
    used to generate customized shellcodes in specific programming languages such
    as C, Ruby, and so on which can be used in your own exploit development code.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfpayload`是Metasploit的命令行实例，用于生成Metasploit存储库中可用的各种文件类型的shellcode。可用的文件类型选项包括C、Ruby、Raw、Exe、Dll、VBA和War。我们可以使用`msfpayload`将任何Metasploit
    shellcode转换为这些提到的文件格式之一。然后，它可以传输到目标机器上执行。一旦文件在目标机器上执行，我们将获得一个活动会话。这减少了利用目标机器上运行的应用软件中存在的任何漏洞的开销。`msfpayload`的另一个主要好处是，它可以用于生成特定编程语言（如C、Ruby等）的定制shellcode，这些shellcode可以在您自己的利用开发代码中使用。'
- en: A major drawback of using `msfpayload` is that the files generated using it
    can be easily detected by antivirus programs when the target tries to execute
    it. Let us move ahead with the recipe and feel the power that `msfpayload` can
    add to our penetration testing process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`msfpayload`的一个主要缺点是，当目标尝试执行它时，使用它生成的文件很容易被杀毒程序检测到。让我们继续前进，感受一下`msfpayload`可以为我们的渗透测试过程增添的力量。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let us begin experimenting with `msfpayload`. We will start with launching the
    BackTrack terminal. We can start with the command `msfpayload -h` to view the
    description of its usage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始尝试`msfpayload`。我们将从启动BackTrack终端开始。我们可以使用命令`msfpayload -h`来查看其用法的描述。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To view the available list of shellcodes, we can use the `msfpayload -l` command.
    You will find a huge list of available shellcodes at our disposal.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的shellcode列表，我们可以使用`msfpayload -l`命令。您将发现我们可以使用的大量可用shellcode列表。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us proceed to see how we can generate a specific customized shellcode in
    C language. We will be using `windows/shell/reverse_tcp` payload to generate its
    shellcode in C language. We will first choose our respective payload shell and
    pass various parameter values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何在C语言中生成特定定制的shellcode。我们将使用`windows/shell/reverse_tcp`有效载荷来生成其C语言的shellcode。我们将首先选择我们各自的有效载荷shell并传递各种参数值。
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the little `o` parameter in the command line the various parameter options
    of the shellcode payload are listed. We will have to pass the values in order
    to generate a customized shellcode for our use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令行中的小`o`参数列出了shellcode有效载荷的各种参数选项。我们将不得不传递这些值，以生成我们自己使用的定制shellcode。
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So we have set up the `LHOST` and `LPORT` according to our need. The next step
    will be to generate a C code for our customized shell (the displayed output has
    been shortened to fit)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已根据需要设置了`LHOST`和`LPORT`。下一步将是为我们定制的shell生成C代码（显示的输出已经被缩短以适应）。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice the capital `C` parameter in the command line. You will notice a complete
    shellcode in C language which we can use in our own exploit development code.
    Alternatively, we also have the option to generate codes in Ruby and Perl language.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令行中的大写`C`参数。您将注意到一个完整的C语言shellcode，我们可以在自己的利用开发代码中使用。或者，我们也有选项可以生成Ruby和Perl语言的代码。
- en: Let us proceed to the next step of generating a binary executable for the shellcode
    which can be used in our client-side attack.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行下一步，生成一个用于客户端攻击的shellcode的二进制可执行文件。
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice the various parameters that we have passed in the command-line. We have
    used the `X` parameter to generate an exe file type and the file has been generated
    in the folder `.local` with the name `setup.exe`. This generated exe can now be
    used in our client-side attack.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在命令行中传递的各种参数。我们使用`X`参数生成了一个exe文件类型，并且该文件已经在名为`.local`的文件夹中生成，文件名为`setup.exe`。现在，这个生成的exe可以在我们的客户端攻击中使用。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Now that our executable is ready, we will have to set up a listener in our msfconsole
    to listen for a back connection when the target executes this exe file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的可执行文件已经准备好了，我们将不得不在msfconsole中设置一个监听器，以便在目标执行此exe文件时监听返回连接。
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we used the same payload and passed the same parameter values which
    we used while generating the executable. Now our listener is ready to receive
    a reverse connection. Once the target user (running Windows prior to Windows 7)
    executes the malicious exe, we will get a shell connectivity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了相同的payload，并传递了与生成可执行文件时使用的相同的参数值。现在我们的监听器已经准备好接收反向连接。一旦目标用户（运行Windows
    7之前的Windows）执行了恶意的exe文件，我们就会获得shell连接。
- en: Bypassing client-side antivirus protection using msfencode
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msfencode绕过客户端防病毒软件保护
- en: In the previous recipe, we focused on how to generate an executable shellcode
    and use it as a weapon for a client-side attack. But, such executables are easily
    detectable by the client-side antivirus protection which can prevent execution
    of such malicious files and raise alarms as well. So what can we do now? We will
    have to move to the next level of attack vector by bypassing the antivirus protection.
    Encoding the executables is an effective technique.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个步骤中，我们专注于如何生成可执行的shellcode，并将其用作客户端攻击的武器。但是，这样的可执行文件很容易被客户端防病毒软件检测到，可以阻止执行这样的恶意文件，并且还会引发警报。那么现在我们该怎么办呢？我们将不得不通过编码可执行文件来提高攻击向量的级别。
- en: Antivirus uses a signature-based technique in which they identify a potential
    threat by verifying the file's first few lines of code with their signature database.
    If a match is found, then the file is treated as a threat. We will have to exploit
    this technique of antiviruses in order to bypass them. `msfencode` is an effective
    tool which encodes the shellcodes and makes them less detectable to antiviruses.
    There are numerous encoding options provided to us by `msfencode`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 防病毒软件使用基于签名的技术，通过验证文件的前几行代码与其签名数据库来识别潜在威胁。如果找到匹配项，则将文件视为威胁。我们将不得不利用这种技术来绕过防病毒软件。`msfencode`是一种有效的工具，它对shellcodes进行编码，使它们对防病毒软件的检测能力降低。`msfencode`为我们提供了许多编码选项。
- en: 'There is an important thing to keep in mind before starting this recipe. The
    success of this recipe depends on two factors: the type of shellcode used and
    the type of antivirus running on the target machine. This recipe involves a lot
    of experimentation to check which shell to use and what type of encoding can be
    used to bypass a particular type of antivirus. Here, we have two targets. One
    is running Windows XP SP2 with AVG 10 (free version) running on it and the other
    is a Windows 7 Ultimate machine running ESET NOD32 (full and updated version).
    First, we will discuss a simple technique that can bypass old and un-updated antivirus,
    but can be detected by the latest versions of it. Then, we will discuss another
    technique which currently bypasses any antivirus available to date.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个步骤之前，有一件重要的事情要记住。这个步骤的成功取决于两个因素：使用的shellcode类型和目标机器上运行的防病毒软件类型。这个步骤涉及大量的实验，以检查使用哪种shell和可以用来绕过特定类型防病毒软件的编码类型。在这里，我们有两个目标。一个运行Windows
    XP SP2，上面运行着AVG 10（免费版本），另一个是运行ESET NOD32（完整和更新版本）的Windows 7 Ultimate机器。首先，我们将讨论一种简单的技术，可以绕过旧的和未更新的防病毒软件，但可能会被最新版本的防病毒软件检测到。然后，我们将讨论另一种技术，目前可以绕过任何防病毒软件。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: '`msfencode` is generally pipelined with the `msfpayload` command to encode
    the shellcode generated by it. This reduces our working steps. Let us get started
    with `msfencode` first. Executing the `msfencode -h` command lists various parameters
    available to us, and `msfencode -l` lists the various encoding styles. Let us
    have a look at each of them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfencode`通常与`msfpayload`命令一起进行编码生成的shellcode。这减少了我们的工作步骤。让我们先从`msfencode`开始。执行`msfencode
    -h`命令列出了我们可以使用的各种参数，`msfencode -l`列出了各种编码样式。让我们逐个看一下：'
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are lots of different encoders available with the framework and each uses
    different techniques to obfuscate the shellcode. The `shikata_ga_nai` encoding
    technique implements a polymorphic XOR additive feedback encoder. The decoder
    stub is generated based on dynamic instruction substitution and dynamic block
    ordering. Registers are also selected dynamically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 框架中有许多不同的编码器，每个编码器都使用不同的技术来混淆shellcode。`shikata_ga_nai`编码技术实现了多态XOR加性反馈编码器。解码器存根是基于动态指令替换和动态块排序生成的。寄存器也是动态选择的。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: I have divided this recipe into three different cases to give a better understanding
    of how we can dig deeper into this useful tool and develop our own logic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个步骤分为三种不同的情况，以更好地理解我们如何深入挖掘这个有用的工具并发展我们自己的逻辑。
- en: '**Case 1:** We will start with encoding a simple shell. Both the `msfpayload`
    and `msfencode` commands will be pipelined together.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况1：**我们将从对一个简单的shell进行编码开始。`msfpayload`和`msfencode`命令将被一起进行管道处理。'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let us understand the command line. We used the `windows/shell/reverse_tcp`
    shell and generated a raw file type using the `R` parameter. Then, we pipelined
    the `msfencode` command. The `e` parameter is used to determine the encoding style
    which is `cmd/generic_sh` in our case. The `c` parameter represents the number
    of iterations and the `t` parameter represents the file type to be created after
    encoding. Finally, the file will be created in `.local` folder with `encoded.exe`
    as the filename. When the `encoded.exe` file is used for the client-side attack
    on our two targets, then it is easily identified as a threat by both Windows XP(with
    AVG 10) and Windows 7(with NOD32). It may have provided us with shell connectivity,
    but the activity was blocked by the antivirus.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解命令行。我们使用了`windows/shell/reverse_tcp` shell，并使用`R`参数生成了原始文件类型。然后，我们将`msfencode`命令进行了管道处理。`e`参数用于确定编码样式，在我们的情况下是`cmd/generic_sh`。`c`参数表示迭代次数，`t`参数表示编码后要创建的文件类型。最后，文件将在`.local`文件夹中创建，文件名为`encoded.exe`。当`encoded.exe`文件用于对我们的两个目标进行客户端攻击时，Windows
    XP（带有AVG 10）和Windows 7（带有NOD32）都很容易识别它为威胁。它可能为我们提供了shell连接，但是这种活动被防病毒软件阻止了。
- en: '**Case 2:** Now we will increase the complexity of this encoding by adding
    a default windows exe template to the shell and also by increasing the number
    of iterations for encoding. Default templates will help us in creating a less
    suspicious file by binding the shellcode with one of the default Windows executables
    like `calc.exe` or `cmd.exe`. The Windows templates are available in the folder
    `/opt/framework3/msf3/lib/msf/util/../../../data/templates`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 案例2：现在我们将通过向shell添加默认的Windows可执行文件模板以及增加编码的迭代次数来增加这种编码的复杂性。默认模板将帮助我们通过将shellcode与默认的Windows可执行文件（如`calc.exe`或`cmd.exe`）绑定来创建一个不太可疑的文件。Windows模板可在文件夹`/opt/framework3/msf3/lib/msf/util/../../../data/templates`中找到。
- en: You can create a template by copying any default Windows executable in this
    folder and then use it as a template. In this recipe, I have copied `cmd.exe`
    into this folder to use it as a template for my shell. So what will our command
    line look like in this case?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将任何默认的Windows可执行文件复制到此文件夹中，然后将其用作模板来创建模板。在这个配方中，我已经将`cmd.exe`复制到这个文件夹中，以便将其用作我的shell的模板。那么在这种情况下，我们的命令行会是什么样子？
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only extra parameter in this case is `-x` which is used for specifying an
    alternate executable template. We have used `cmd.exe` as the template which is
    the default windows executable for the command prompt. Also we have changed the
    encoding style to `shikata_ga_nai` which ranks as "Excellent" in `msfencode`.
    The number of iterations has also been increased to 20 in this case. The executable
    created in this case appears like a `cmd.exe` executable (because of the template)
    and it easily bypasses the client-side antivirus protection of the Windows XP
    target which is running AVG 10 antivirus. Unfortunately, it was detected as a
    threat on our Windows 7 target running the latest version of NOD32\. So, it can
    be used to bypass the older versions of antiviruses running on Windows machines.
    The second problem, with this technique, is that it fails to launch a shell on
    Windows 7/Server 2008 machines even if they have older antivirus protection. The
    shellcode crashes on execution (because of the template) and even though it bypasses
    the antivirus, still it fails to launch a shell on newer versions of Windows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下唯一的额外参数是`-x`，用于指定替代可执行模板。我们使用了`cmd.exe`作为模板，这是命令提示符的默认Windows可执行文件。此外，我们还将编码样式更改为`shikata_ga_nai`，在`msfencode`中排名为“优秀”。在这种情况下，迭代次数也增加到了20。在这种情况下创建的可执行文件看起来像一个`cmd.exe`可执行文件（因为模板），并且轻松地绕过了运行AVG
    10防病毒软件的Windows XP目标的客户端防病毒保护。不幸的是，在我们运行最新版本的NOD32的Windows 7目标上被检测为威胁。因此，它可以用于绕过运行在Windows机器上的较旧版本的防病毒软件。这种技术的第二个问题是，即使在具有较旧的防病毒保护的Windows
    7/Server 2008机器上，它也无法启动shell。shellcode在执行时崩溃（因为模板），即使它绕过了防病毒软件，仍然无法在较新版本的Windows上启动shell。
- en: '**Case 3:** This case will overcome the shortcomings that we faced in Case
    2\. In this case, we will generate a client-side script instead of an executable
    file. The well-known client-side script for the Windows platform is visual basic
    script (`.vbs`). This technique can be used to bypass any antivirus known to date
    running on the latest versions of Windows. The reason that VB scripts make a potential
    weapon to bypass the antivirus is that they are never treated as a threat by antivirus
    programs and this is the reason why their signatures never match with the VB script
    file. Let us create a malicious VB script using `msfpayload` and `msfencode`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 案例3：这种情况将克服我们在案例2中遇到的缺点。在这种情况下，我们将生成一个客户端脚本，而不是可执行文件。Windows平台上众所周知的客户端脚本是Visual
    Basic脚本（.vbs）。这种技术可以用来绕过任何已知的运行在最新版本的Windows上的防病毒软件。VB脚本成为绕过防病毒软件的潜在武器的原因是，它们从不被防病毒程序视为威胁，这就是为什么它们的签名从不与VB脚本文件匹配的原因。让我们使用`msfpayload`和`msfencode`创建一个恶意的VB脚本。
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice the slight changes in the command line. The only change is that exe has
    been replaced by VBS, and we have not used any templates in order to prevent any
    crashes during client-side execution. This technique can help us bypass the antivirus
    protection of both our targets and provide us shell connectivity. We can set up
    a listener using the multi/handler module (discussed in the previous recipe) and
    wait for a back connection with the targets once they execute the script.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令行中的轻微变化。唯一的变化是将exe替换为VBS，并且我们没有使用任何模板，以防止客户端执行期间的崩溃。这种技术可以帮助我们绕过目标的防病毒保护，并提供shell连接。我们可以使用multi/handler模块（在前面的配方中讨论过）设置监听器，并等待目标执行脚本后与其建立反向连接。
- en: As you might have noticed by now, this recipe is purely based on trying out
    different combinations of payloads and encoders. The more you try out different
    combinations, the greater will be your chances of getting success. There are many
    things to explore in `msfpayload` and `msfencode`, so I would encourage you to
    actively try out different experiments and discover your own ways of bypassing
    the antivirus protection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到，这个配方纯粹是基于尝试不同的有效载荷和编码器的组合。您尝试不同组合的次数越多，成功的机会就越大。在`msfpayload`和`msfencode`中有许多可以探索的东西，因此我鼓励您积极尝试不同的实验，并发现自己绕过防病毒保护的方法。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Encoders are primarily used to obfuscate the shellcode script into a form that
    cannot be recognized by antiviruses. The `shikata_ga_nai` encoder uses polymorphic
    XOR technique in which the encoder uses dynamically generated gats as encoders.
    The reason which makes `shikata_ga_nai` popular is that it uses a self-decoding
    technique. Self-decryption means the software decrypts a part of itself at runtime.
    Ideally, the software just contains a decryptor stub and the encrypted code. Iterations
    further complicate the encoding process by using the same operation over and over
    again to make the shellcode look completely alien to antiviruses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器主要用于将shellcode脚本混淆成无法被杀毒软件识别的形式。`shikata_ga_nai`编码器使用多态异或技术，编码器使用动态生成的gats作为编码器。`shikata_ga_nai`受欢迎的原因是它使用自解码技术。自解密意味着软件在运行时解密自身的一部分。理想情况下，软件只包含一个解密存根和加密代码。迭代通过多次使用相同的操作来使shellcode看起来完全陌生，以使杀毒软件难以识别。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us find a quick way of testing a payload against different anti-virus vendors
    and find out which of them detect our encoded payload.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到一个快速的方法来测试有效载荷针对不同的反病毒供应商，并找出它们中有多少检测到我们的编码有效载荷。
- en: Quick multiple scanning with VirusTotal
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用VirusTotal进行快速多重扫描
- en: VirusTotal is an online website cum utility tool that can scan your file against
    multiple antivirus vendors to figure out how many of them are detecting it as
    a threat. You can scan your encoded payload against virus total to find whether
    it is raising an alarm in any of the antivirus products or not. This can help
    you in quickly figuring out whether your encoded payload will be effective in
    the field or not.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal是一个在线网站兼实用工具，可以将您的文件与多个杀毒软件供应商进行扫描，以找出有多少个杀毒软件将其检测为威胁。您可以将编码的有效载荷与病毒总和进行扫描，以找出它是否在任何杀毒产品中引发警报。这可以帮助您快速找出您的编码有效载荷是否在实际中有效。
- en: '![Quick multiple scanning with VirusTotal](img/7423_04_04.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用VirusTotal进行快速多重扫描](img/7423_04_04.jpg)'
- en: VirusTotal can be browsed from [http://www.virustotal.com](http://www.virustotal.com).
    It will ask you to upload the file you wish to scan against multiple antivirus
    products. Once the scanning is complete, it will return the test results.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal可以从[http://www.virustotal.com](http://www.virustotal.com)浏览。它会要求您上传要针对多个杀毒产品进行扫描的文件。扫描完成后，它将返回测试结果。
- en: Using the killav.rb script to disable antivirus programs
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用killav.rb脚本来禁用杀毒软件程序
- en: In the previous recipe, we focused on various techniques that can be implemented
    to bypass the client-side antivirus protection and open an active session. Well,
    the story doesn't end here. What if we want to download files from the target
    system, or install a keylogger, and so on. Such activities can raise an alarm
    in the antivirus. So, once we have gained an active session, our next target should
    be to kill the antivirus protection silently. This recipe is all about de-activating
    them. Killing antivirus is essential in order to keep our activities undetected
    on the target machine.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们专注于可以实施的各种技术，以绕过客户端杀毒软件保护并打开一个活动会话。好吧，故事并没有结束。如果我们想要从目标系统下载文件，或者安装键盘记录器等等。这样的活动可能会引起杀毒软件的警报。因此，一旦我们获得了一个活动会话，我们的下一个目标应该是悄悄地关闭杀毒软件保护。这个示例就是关于停用它们的。在目标机器上保持我们的活动不被检测到，杀死杀毒软件是必不可少的。
- en: In this recipe, we will be using some of the meterpreter scripts available to
    us during an active session. We have an entire chapter dedicated to meterpreter
    scripts so here I will just give a quick introduction to meterpreter scripts and
    some useful meterpreter commands. We will be analyzing meterpreter in great detail
    in our next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在活动会话期间使用一些可用的meterpreter脚本。我们有一个专门的章节专门介绍meterpreter脚本，所以在这里我只会对meterpreter脚本和一些有用的meterpreter命令进行快速介绍。我们将在下一章中详细分析meterpreter。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let us start with a quick introduction to meterpreter. Meterpreter is an advanced
    payload that greatly enhances the power of command execution on the target machine.
    It is a command interpreter which works by in-memory DLL injection and provides
    us with lots of advantages over traditional command interpreters (generally exists
    with shell codes) as it is more flexible, stable, and extensible. It can work
    as if several payloads are working together on the target machine. It communicates
    over the stager socket and provides a comprehensive client-side ruby API. We can
    get a meterpreter shell by using the payloads available in the `windows/meterpreter`
    directory. In this recipe, we will be using the `windows/meterpreter/reverse_tcp`
    payload and our target machine is Windows 7 running ESET NOD32 antivirus.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对meterpreter的快速介绍开始。Meterpreter是一个高级有效载荷，极大地增强了对目标机器上命令执行的能力。它是一个命令解释器，通过内存中的DLL注入工作，并为我们提供了许多优势，相对于传统的命令解释器（通常存在于shell代码）来说，它更加灵活、稳定和可扩展。它可以像几个有效载荷一起在目标机器上工作。它通过分段套接字进行通信，并提供了全面的客户端端ruby
    API。我们可以使用`windows/meterpreter`目录中可用的有效载荷来获得meterpreter shell。在这个示例中，我们将使用`windows/meterpreter/reverse_tcp`有效载荷，我们的目标机器是运行ESET
    NOD32杀毒软件的Windows 7。
- en: Let us set up our listener in msfconsole and wait for a back connection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在msfconsole中设置监听器，并等待一个反向连接。
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: So our listener in now ready. Once the client-side attack executes successfully
    on the target, we will have a meterpreter session opened in msfconsole.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以我们的监听器现在已经准备好了。一旦客户端攻击成功地在目标上执行，我们将在msfconsole中打开一个meterpreter会话。
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we are all set to leverage the powers of meterpreter in our experiment
    of killing antivirus. The first command we will execute is `getuid` which gives
    us the username of the system in which we broke in. The user can be either the
    main administrator or a less privileged user.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好利用meterpreter在我们的杀毒实验中的力量。我们将执行的第一个命令是`getuid`，它会给我们系统的用户名，我们已经破解了。用户可以是主管理员或者是一个权限较低的用户。
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It doesn't looks like we have the administrator privilege in the system we just
    penetrated. So the next step will be to escalate our privilege to administrator
    so that we can execute commands on the target without interruption. We will use
    the `getsystem` command which attempts to elevate our privilege from a local user
    to administrator.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来我们在刚刚渗透的系统中没有管理员特权。下一步将是提升我们的特权到管理员，以便我们可以在目标上执行命令而不受干扰。我们将使用`getsystem`命令，尝试将我们的特权从本地用户提升到管理员。
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see that `getsystem` has successfully elevated our privilege on the
    penetrated system using `technique 4` which is KiTrap0D exploit. We can check
    our new escalated ID by again using the `getuid` command.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到`getsystem`成功地使用`技术4`，也就是KiTrap0D漏洞，提升了我们在渗透系统上的特权。我们可以再次使用`getuid`命令来检查我们新提升的ID。
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So now we have the main administrator rights. The next step will be to run the
    `ps` command which lists all the running processes on the system. We will have
    to look at those processes that control the antivirus running on the target machine
    (output has been shortened to fit).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们拥有了主管理员权限。下一步将是运行`ps`命令，列出系统上所有正在运行的进程。我们将需要查看控制目标机器上运行的杀毒软件的那些进程（输出已经被缩短以适应）。
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the `Name` and `Path` columns, we can easily identify the processes that
    belong to an antivirus instance. In our case, there are two processes responsible
    for antivirus protection on the target system. They are `egui.exe` and `eset.exe`.
    Let us see how we can use the Metasploit to kill these processes.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Name`和`Path`列中，我们可以很容易地识别出属于杀毒软件实例的进程。在我们的情况下，有两个进程负责目标系统上的杀毒保护。它们是`egui.exe`和`eset.exe`。让我们看看如何使用Metasploit来终止这些进程。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Meterpreter provides a very useful script named `killav.rb` which can be used
    to kill the antivirus processes running on the target system and, thus, disable
    it. Let us try this script on our Windows 7 target which is running ESET NOD32
    antivirus.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter提供了一个非常有用的脚本，名为`killav.rb`，可以用来终止目标系统上运行的杀毒软件进程，从而禁用它。让我们在运行ESET
    NOD32杀毒软件的Windows 7目标上尝试这个脚本。
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `run` command is used to execute Ruby scripts in meterpreter. Once the script
    has executed, we can again check the running processes on the target in order
    to make sure that all the antivirus processes have been killed. If none of the
    antivirus processes are running, then it means that the antivirus has been temporarily
    disabled on the target machine and we can now move ahead with our penetration
    testing process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令用于在meterpreter中执行Ruby脚本。一旦脚本执行完毕，我们可以再次检查目标上正在运行的进程，以确保所有杀毒软件进程都已被终止。如果没有杀毒软件进程在运行，那么意味着杀毒软件已经在目标机器上被暂时禁用，我们现在可以继续进行渗透测试过程。'
- en: But what if the processes are still running? Let's find out the solution in
    the next recipe.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果进程仍在运行怎么办？让我们在下一个步骤中找到解决方案。
- en: A deeper look into the killav.rb script
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解killav.rb脚本
- en: Continuing from our previous recipe, we focused on how to kill running antivirus
    processes on the target machine using the `killav.rb` script. But, what if the
    processes are still running or they were not killed even after using the script?
    There can be two reasons for it. Either the `killav.rb` doesn't include those
    processes in its list to kill or the antivirus process is running as a service.
    In this recipe, we will try to overcome the problems. So let's quickly move on
    to our recipe.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前的步骤，我们专注于如何使用`killav.rb`脚本在目标机器上终止运行的杀毒软件进程。但是，如果进程仍在运行，或者即使使用脚本后它们仍未被终止，会怎么样呢？这可能有两个原因。要么`killav.rb`没有在其终止列表中包括这些进程，要么杀毒软件进程正在作为服务运行。在这个步骤中，我们将尝试克服这些问题。所以让我们快速进入我们的步骤。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the same meterpreter session where we ended our previous
    recipe. We have used the `killav.rb` script once, but still the antivirus processes
    are running. We can view the running processes by using the `ps` command.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个步骤结束的地方开始相同的meterpreter会话。我们已经使用了`killav.rb`脚本一次，但是杀毒软件进程仍在运行。我们可以使用`ps`命令查看正在运行的进程。
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the two antivirus processes are still alive even after using
    the `killav.rb` script. Let us start with giving a look at the `killav.rb` script.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，即使使用了`killav.rb`脚本，这两个杀毒软件进程仍然存活。让我们先看一下`killav.rb`脚本。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: To view and edit the `killav.rb` script, open a new terminal window and browse
    to `/pentest/exploits/framework3/scripts/meterpreter`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看和编辑`killav.rb`脚本，请打开一个新的终端窗口，浏览到`/pentest/exploits/framework3/scripts/meterpreter`。
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`vim` is a quick editor for files in Unix. It will open the whole script on
    our screen. Scroll down to find the various processes listed in it. These are
    the processes that the script looks for to kill. Check the entire list to look
    for `eset.exe` and `egui.exe`. If they are not available, then add the two processes
    in the script. To start the editing mode in vim, press the *a* key. It will start
    the insert mode. Now add the two processes in the script''s process list.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vim`是Unix中用于快速编辑文件的编辑器。它将在我们的屏幕上打开整个脚本。向下滚动以查找其中列出的各种进程。这些是脚本寻找要终止的进程。检查整个列表，查找`eset.exe`和`egui.exe`。如果它们不可用，那么将这两个进程添加到脚本中。要在vim中启动编辑模式，请按*a*键。它将启动插入模式。现在在脚本的进程列表中添加这两个进程。'
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The following code snippet shows the two processes added at the top of the list.
    To exit the insert mode, press the *esc* key. Now to save the script, press the
    *:* key. You will reach a mini command prompt of the vim editor. Now type `wq`
    to save and exit the editor.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段显示了列表顶部添加的两个进程。要退出插入模式，请按*esc*键。现在要保存脚本，请按*:*键。您将进入vim编辑器的迷你命令提示符。现在输入`wq`以保存并退出编辑器。
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now go back to the meterpreter session and execute the `killav.rb` script again,
    and notice what happens.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到meterpreter会话，再次执行`killav.rb`脚本，注意发生了什么。
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output of the command execution shows that the script successfully killed
    the two processes. Now, in order to verify whether all the antivirus processes
    have been killed or not, we will again execute the `ps` command to cross check
    (output shortened to fit).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令执行的输出显示脚本成功杀死了两个进程。现在，为了验证所有杀毒软件进程是否已被杀死，我们将再次执行`ps`命令进行交叉检查（输出缩短以适应）。
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You will find that there are no active processes for ESET antivirus. This shows
    that the script successfully killed the antivirus program. This example clearly
    shows how we can increase the efficiency of in-built scripts by adding our own
    inputs into it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现ESET杀毒软件没有活动进程。这表明脚本成功杀死了杀毒软件程序。这个例子清楚地展示了我们如何通过添加自己的输入来增加内置脚本的效率。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let us give a quick look at the `killav.rb` script which we have actively used
    in this recipe. The script contains a whole list of processes in an array (%W)
    which it looks for on the target machine to kill.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下我们在本篇文章中积极使用的`killav.rb`脚本。脚本包含一个数组（%W）中的整个进程列表，它在目标机器上查找并杀死。
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The last few lines of the code are self-explanatory. The script looks for a
    match for processes running on the target system with its array. When a match
    is found, it uses the `process.kill` function to kill the process. This loop continues
    until all the elements of the array are matched with the available processes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后几行是不言自明的。脚本在目标系统上查找正在运行的进程与其数组进行匹配。当找到匹配时，它使用`process.kill`函数来终止进程。这个循环会一直持续，直到数组的所有元素与可用进程匹配。
- en: Killing antivirus services from the command line
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行杀死杀毒软件服务
- en: In the previous recipe, we gave two reasons to why the antivirus process is
    still running even after using the `killav.rb` script. In the previous recipe,
    we addressed the first issue, that is, the `killav.rb` list doesn't include the
    processes to be killed. In this recipe, we will address the second issue that
    the antivirus program is running as a service on the target machine. Before we
    proceed, let us first understand the difference between a process and a service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们给出了杀毒软件进程在使用`killav.rb`脚本后仍然运行的两个原因。在上一篇文章中，我们解决了第一个问题，即`killav.rb`列表不包括要被杀死的进程。在本篇文章中，我们将解决第二个问题，即杀毒软件程序在目标机器上作为服务运行。在我们继续之前，让我们先了解一下进程和服务之间的区别。
- en: A process is any piece of software that is running on a computer. Some processes
    start when your computer boots, others are started manually when needed. Some
    processes are services that publish methods to access them, so other programs
    can call them as needed. A process is user-based, whereas a service is system-based.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是计算机上正在运行的任何软件。一些进程在计算机启动时启动，其他的在需要时手动启动。一些进程是服务，它们发布方法以便其他程序可以根据需要调用它们。进程是基于用户的，而服务是基于系统的。
- en: Antivirus can also run some components as a service such as e-mail filters,
    web access filters, and so on. The `killav.rb` script cannot kill services. So,
    even if we kill the processes using `killav.rb`, the antivirus service will immediately
    start them again. So even if `killav.rb` is killing all the antivirus processes
    and still they are listed every time we use the `ps` command, then it can be concluded
    that some component of antivirus is running as a service which is responsible
    for restarting the processes repeatedly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 杀毒软件也可以作为服务运行一些组件，比如电子邮件过滤器、网络访问过滤器等。`killav.rb`脚本无法杀死服务。所以，即使我们使用`killav.rb`杀死了进程，杀毒软件服务也会立即重新启动它们。所以即使`killav.rb`杀死了所有杀毒软件进程，但每次使用`ps`命令时它们仍然被列出，那么可以得出结论，杀毒软件的某个组件作为服务在负责重复启动进程。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We will start with a scenario in which the target machine is a Windows 7 machine
    running AVG 10 antivirus. I am assuming that we already have an active meterpreter
    session with the target machine with administrative privilege.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个场景开始，目标机器是运行AVG 10杀毒软件的Windows 7机器。我假设我们已经与目标机器建立了一个具有管理员权限的活动meterpreter会话。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: This recipe will use the Windows command prompt. So we will start off by opening
    a command prompt shell with the target.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个配方将使用Windows命令提示符。所以我们将从打开一个带有目标的命令提示符shell开始。
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we will use the `tasklist` command to look for various available tasks.
    Adding the `/SVC` parameter will list only those processes which are running as
    a service. As we know that the target machine is using AVG antivirus, we can add
    a wild card search to list only those services which belong to avg. So our command-line
    will look as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`tasklist`命令来查找各种可用任务。添加`/SVC`参数将只列出作为服务运行的进程。由于我们知道目标机器正在使用AVG杀毒软件，我们可以添加通配符搜索，只列出属于avg的服务。因此，我们的命令行将如下所示：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So we have a whole list or services and processes for AVG antivirus. The next
    step will be to issue the `taskkill` command to kill these tasks and disable the
    antivirus protection.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个完整的列表或服务和进程为AVG杀毒软件。下一步将是发出`taskkill`命令来终止这些任务并禁用杀毒软件保护。
- en: We can again give a wild card search to kill all tasks that have `avg` as the
    process name.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次使用通配符搜索来杀死所有进程名称为`avg`的任务。
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `/F` parameter is used to force kill the process. This will ultimately kill
    the various antivirus services running on the target machine. This recipe has
    lots of areas to explore. You may encounter some problems, but they can be overcome
    by following the right set of commands.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`/F`参数用于强制终止进程。这将最终杀死目标机器上运行的各种杀毒软件服务。这个配方有很多地方可以探索。您可能会遇到一些问题，但可以通过遵循正确的一系列命令来克服。'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Killing services from the command line simply evokes calls to the operating
    system which disables the particular service. Once we have an active shell session
    with our target, we can evoke these calls on behalf of the command line through
    our shell.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行杀死服务只是调用操作系统来禁用特定服务。一旦我们与目标建立了一个活动的shell会话，我们可以代表命令行通过我们的shell调用这些命令。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us conclude this recipe with some final notes on what to do if the antivirus
    service is still alive.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些最终说明来结束这个配方，讨论一下如果杀毒软件服务仍然存在该怎么办。
- en: Some services did not kill—what next?
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有些服务没有被终止，接下来怎么办？
- en: This can be due to several reasons. You may get an error for some services when
    you give the `taskkill` command. To overcome this, we can use the `net stop` and
    `sc config` commands for such services. I would recommend that you read about
    these two commands from Microsoft's website and understand their usage. They can
    help us kill or disable even those services that do not stop with the `taskkill`
    command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是由于几个原因。当你使用`taskkill`命令时，可能会出现一些服务的错误。为了克服这个问题，我们可以使用`net stop`和`sc config`命令来处理这些服务。我建议你从微软的网站上了解这两个命令的用法。它们可以帮助我们终止或禁用那些无法通过`taskkill`命令停止的服务。
