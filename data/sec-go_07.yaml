- en: Secure Shell (SSH)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全外壳（SSH）
- en: '**Secure Shell** (**SSH**) is a cryptographic network protocol for communicating
    on an unsecure network. The most common use of SSH is in connecting to a remote
    server and interacting with a shell. File transfer is also used via SCP and SFTP
    over the SSH protocol. SSH was created to replace the plaintext protocol, Telnet.
    Over time, there have been numerous RFCs to define SSH. Here is a partial list
    to give you an idea of what is defined. Since it is such a common and critical
    protocol, it is worth taking the time to understand the details. The following
    are some of the RFCs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全外壳（SSH）**是一种用于在不安全网络上进行通信的加密网络协议。SSH最常见的用途是连接到远程服务器并与shell交互。还可以通过SSH协议进行文件传输，如SCP和SFTP。SSH的创建是为了取代明文协议Telnet。随着时间的推移，有许多RFC定义了SSH。以下是一部分列出的RFC，以帮助理解其定义。由于它是如此常见和关键的协议，值得花时间了解其详细信息。以下是其中一些RFC：'
- en: '*RFC 4250* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250)):
    *The Secure Shell (SSH) Protocol Assigned Numbers*'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4250* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250)):
    *安全外壳（SSH）协议分配号码*'
- en: '*RFC 4251* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251)):
    *The Secure Shell (SSH) Protocol Architecture*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4251* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251)):
    *安全外壳（SSH）协议架构*'
- en: '*RFC 4252* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252)):
    *The Secure Shell (SSH) Authentication Protocol*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4252* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252)):
    *安全外壳（SSH）身份验证协议*'
- en: '*RFC 4253* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253)):
    *The Secure Shell (SSH) Transport Layer Protocol*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4253* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253)):
    *安全外壳（SSH）传输层协议*'
- en: '*RFC 4254* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254)):
    *The Secure Shell (SSH) Connection Protocol*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4254* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254)):
    *安全外壳（SSH）连接协议*'
- en: '*RFC 4255* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255)):
    *Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4255* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255)):
    *使用DNS安全发布安全外壳（SSH）密钥指纹*'
- en: '*RFC 4256* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256)):
    *Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4256* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256)):
    *安全外壳协议（SSH）的通用消息交换认证*'
- en: '*RFC 4335* ([https://tools.ietf.org/html/rfc4335](https://tools.ietf.org/html/rfc4335)):
    **The Secure Shell (SSH) Session Channel Break Extension**'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4335* ([https://tools.ietf.org/html/rfc4335](https://tools.ietf.org/html/rfc4335)):
    **安全外壳（SSH）会话通道断开扩展**'
- en: '*RFC 4344* ([https://tools.ietf.org/html/rfc4344](https://tools.ietf.org/html/rfc4344)):
    *The Secure Shell (SSH) Transport Layer Encryption Modes*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4344* ([https://tools.ietf.org/html/rfc4344](https://tools.ietf.org/html/rfc4344)):
    *安全外壳（SSH）传输层加密模式*'
- en: '*RFC 4345* ([https://tools.ietf.org/html/rfc4345](https://tools.ietf.org/html/rfc4345)):
    *Improved Arcfour Modes for the Secure Shell (SSH) Transport Layer Protocol*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 4345* ([https://tools.ietf.org/html/rfc4345](https://tools.ietf.org/html/rfc4345)):
    *安全外壳（SSH）传输层协议的改进Arcfour模式*'
- en: There were also additional expansions later to the standard, which you can read
    about at [https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation](https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 后来标准还有其他扩展，您可以在[https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation](https://en.wikipedia.org/wiki/Secure_Shell#Standards_documentation)上了解更多信息。
- en: SSH is a common target for brute force and default credential attacks across
    the internet. For this reason, you might consider putting SSH on a nonstandard
    port, but keep it to a system port (less than 1024) so that a low-privileged user
    cannot potentially hijack the port if the service goes down. If you leave SSH
    on the default port, services such as `fail2ban` can be invaluable for rate limiting
    and blocking brute force attacks. Ideally, password authentication is disabled
    completely and key authentication is required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SSH是互联网上常见的暴力破解和默认凭证攻击目标。因此，您可以考虑将SSH放在非标准端口上，但仍需将其保留在系统端口（小于1024），以防止低权限用户在服务崩溃时可能劫持端口。如果保留SSH在默认端口上，像`fail2ban`这样的服务在限制速率和阻止暴力攻击方面将非常有价值。理想情况下，应完全禁用密码身份验证，并要求使用密钥进行身份验证。
- en: 'The SSH package does not come packaged with the standard library, although
    it was written by the Go team. It is officially part of the Go project, but outside
    of the main Go source tree, so it is not installed with Go by default. It is available
    from [https://golang.org/](https://golang.org/) and can be installed using this
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 包并未随标准库一起打包，尽管它是由 Go 团队编写的。它是 Go 项目的正式组成部分，但位于 Go 源代码树之外，因此默认情况下不会与 Go 一起安装。它可以从
    [https://golang.org/](https://golang.org/) 获取，并可以使用以下命令安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we will cover how to use the SSH client to connect, execute
    commands, and use an interactive shell. We will also cover the different methods
    of authentication such as using a password or a private key. The SSH package provides
    functions for creating a server, but we'll cover only the client in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用 SSH 客户端连接、执行命令并使用交互式 shell。我们还将介绍不同的身份验证方法，例如使用密码或私钥。SSH 包提供了创建服务器的功能，但本书仅介绍客户端部分。
- en: 'This chapter will specifically cover the following for SSH:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专门涵盖 SSH 的以下内容：
- en: Authenticating with a password
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密码进行身份验证
- en: Authenticating with a private key
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私钥进行身份验证
- en: Verifying the key of a remote host
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证远程主机的密钥
- en: Executing a command over SSH
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 SSH 执行命令
- en: Starting an interactive shell
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动交互式 shell
- en: Using the Go SSH client
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go SSH 客户端
- en: The `golang.org/x/crypto/ssh` package provides an SSH client that is compatible
    with SSH version 2—the latest version. The client will work with the OpenSSH servers
    and any other server that follows the SSH specifications. It supports the traditional
    client features such as subprocesses, port forwarding, and tunneling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang.org/x/crypto/ssh` 包提供了与 SSH 版本 2（最新版本）兼容的 SSH 客户端。该客户端可以与 OpenSSH 服务器以及任何遵循
    SSH 规范的其他服务器一起使用。它支持传统的客户端功能，如子进程、端口转发和隧道。'
- en: Authentication methods
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证方法
- en: Authentication is not just the first step but also the most critical. Improper
    authentication can lead to potential loss of confidentiality, integrity, and availability.
    A man-in-the-middle attack can occur if the remote server is not verified, leading
    to spying, manipulation, or blocking of data. Weak password authentication can
    be exploited by brute force attacks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证不仅是第一步，而且是最关键的一步。身份验证不当可能导致机密性、完整性和可用性的潜在丧失。如果远程服务器没有经过验证，可能会发生中间人攻击，导致数据被窃听、篡改或阻塞。弱密码身份验证可能会受到暴力破解攻击的利用。
- en: Three examples are provided here. The first example covers password authentication,
    which is common, but not recommended due to the low entropy and bit count of passwords
    compared with that of cryptographic keys. The second example demonstrates how
    to use a private key to authenticate with a remote server. Both of these examples
    ignore the public key provided by the remote host. This is insecure, because you
    may end up connecting to a remote host you do not trust, but is good enough for
    testing. The third example of authentication is the ideal flow. It authenticates
    with a key and verifies the remote server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了三个示例。第一个示例涵盖了常见的密码身份验证，但不推荐使用，因为与加密密钥相比，密码的熵值和位数较低。第二个示例演示了如何使用私钥与远程服务器进行身份验证。这两个示例都忽略了远程主机提供的公钥。这是不安全的，因为你可能最终连接到一个你不信任的远程主机，但对于测试来说已经足够。第三个身份验证示例是理想的流程。它通过密钥进行身份验证，并验证远程服务器。
- en: Note that this chapter does not use PEM formatted key files as in [Chapter 6](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml),
    *Cryptography*. This uses SSH formatted keys, which is naturally the most common
    format for working with SSH. These examples are compatible with the OpenSSH tools
    and keys such as `ssh`, `sshd`, `ssh-keygen`, `ssh-copy-id`, and `ssh-keyscan`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章没有使用 [第六章](f68073f0-8cc8-40b5-af0e-795ce30e5271.xhtml) 中的 PEM 格式密钥文件，*密码学*。本章使用的是
    SSH 格式的密钥，这是处理 SSH 时最常见的格式。这些示例与 OpenSSH 工具和密钥兼容，如 `ssh`、`sshd`、`ssh-keygen`、`ssh-copy-id`
    和 `ssh-keyscan`。
- en: 'I recommend that you use `ssh-keygen` to generate a public and private key
    pair for authentication. This will generate the `id_rsa` and `id_rsa.pub` files
    in the SSH key format. The `ssh-keygen` tool is part of the OpenSSH project and
    is packed with Ubuntu by default:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用 `ssh-keygen` 来生成用于身份验证的公钥和私钥对。这将生成 SSH 密钥格式的 `id_rsa` 和 `id_rsa.pub`
    文件。`ssh-keygen` 工具是 OpenSSH 项目的一部分，并且默认与 Ubuntu 一起打包：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use `ssh-copy-id` to copy your public key (`id_rsa.pub`) to the remote server''s
    `~/.ssh/authorized_keys` file so that you can authenticate using the private key:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ssh-copy-id`将你的公钥（`id_rsa.pub`）复制到远程服务器的`~/.ssh/authorized_keys`文件中，这样你就可以使用私钥进行身份验证：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Authenticating with a password
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码进行身份验证
- en: 'Password authentication over SSH is the simplest method. This example demonstrates
    how to configure an SSH client with the `ssh.ClientConfig` struct and then connect
    to an SSH server using `ssh.Dial()`. The client is configured to use a password
    by specifying `ssh.Password()` as the authentication function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH进行密码认证是最简单的方法。此示例演示了如何使用`ssh.ClientConfig`结构配置SSH客户端，然后使用`ssh.Dial()`连接到SSH服务器。客户端被配置为通过指定`ssh.Password()`作为身份验证函数来使用密码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Authenticating with private key
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私钥进行身份验证
- en: A private key has a few advantages over password. It is much longer than a password,
    making it exponentially more difficult to brute force. It also eliminates the
    need to type in a password, making it convenient to connect to remote servers.
    Passwordless authentication is also helpful for cron jobs and other services that
    need to run automatically without human intervention. Some servers disable password
    authentication completely and require a key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥相比密码有一些优势。它比密码长得多，使得暴力破解变得更加困难。它还消除了输入密码的需求，方便连接远程服务器。无密码身份验证对于cron任务和其他需要自动运行的服务非常有用。此外，一些服务器完全禁用了密码身份验证，要求使用密钥。
- en: The remote server will need to have your public key as an authorized key before
    you can authenticate using the private key.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 远程服务器需要将你的公钥设置为授权密钥，才能通过私钥进行身份验证。
- en: 'You can use the `ssh-copy-id` tool if it is available on your system. It will
    copy your public key to the remote server, place it in your home folder SSH directory
    (`~/.ssh/authorized_keys`), and set the correct permissions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统上有`ssh-copy-id`工具，你可以使用它。它会将你的公钥复制到远程服务器，放置在主文件夹的SSH目录中（`~/.ssh/authorized_keys`），并设置正确的权限：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example is similar to the previous example, where we authenticate
    using a password, but `ssh.ClientConfig` is configured to use `ssh.PublicKeys()`
    as the authentication function, instead of `ssh.Password()`. We will also create
    a special function named `getKeySigner()` in order to load the private key for
    the client from a file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例与之前的示例类似，我们使用密码进行身份验证，但`ssh.ClientConfig`配置为使用`ssh.PublicKeys()`作为身份验证函数，而不是`ssh.Password()`。我们还将创建一个名为`getKeySigner()`的特殊函数，以便从文件中加载客户端的私钥：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that you can pass more than a single private key to the `ssh.PublicKeys()`
    function. It accepts an unlimited number of keys. If you provide multiple keys,
    and only one works for the server, it will automatically use the one key that
    works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以将多个私钥传递给`ssh.PublicKeys()`函数。它可以接受无限数量的密钥。如果你提供了多个密钥，而只有一个能够正常工作，系统将自动使用那个有效的密钥。
- en: This is useful if you want to use the same configuration to connect to a number
    of servers. You may want to connect to 1,000 different hosts using 1,000 unique
    private keys. Instead of having to create multiple SSH client configs, you can
    reuse a single config that contains all of the private keys.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用相同的配置连接多个服务器，这将非常有用。你可能希望使用1,000个不同的主机名连接到1,000个不同的服务器，并使用1,000个独特的私钥。你无需为每个主机配置多个SSH客户端配置，而是可以重用一个包含所有私钥的单一配置。
- en: Verifying remote host
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证远程主机
- en: To verify the remote host, in `ssh.ClientConfig`, set `HostKeyCallback` to `ssh.FixedHostKey()`
    and pass it the public key of the remote host. If you attempt to connect to the
    server and it provides a different public key, the connection will be aborted.
    This is important for ensuring that you are connecting to the expected server
    and not a malicious server. If DNS is compromised, or an attacker performs a successful
    ARP spoof, it's possible that your connection will be redirected or will be a
    victim of the man-in-the-middle attack, but an attacker will not be able to imitate
    the real server without the corresponding private key for the server. For testing
    purposes, you may choose to ignore the key provided by the remote host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证远程主机，在`ssh.ClientConfig`中，将`HostKeyCallback`设置为`ssh.FixedHostKey()`并传入远程主机的公钥。如果你尝试连接到服务器且它提供了不同的公钥，连接将会被中断。这对于确保你连接到的是预期的服务器而不是恶意服务器非常重要。如果DNS遭到破坏，或者攻击者成功执行了ARP欺骗攻击，你的连接可能会被重定向，或者成为中间人攻击的受害者，但攻击者无法在没有相应私钥的情况下伪装成真实服务器。为了测试目的，你可以选择忽略远程主机提供的密钥。
- en: This example is the most secure way to connect. It uses a key to authenticate,
    as opposed to a password, and it verifies the public key of the remote server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是连接的最安全方式。它使用密钥进行身份验证，而不是密码，并且验证远程服务器的公钥。
- en: This method will use `ssh.ParseKnownHosts()`. This uses the standard `known_hosts`
    file. The `known_hosts` format is the standard for OpenSSH. The format is documented
    in the *sshd(8)* manual page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将使用 `ssh.ParseKnownHosts()`。它使用标准的 `known_hosts` 文件。`known_hosts` 格式是 OpenSSH
    的标准格式，文档可以参考 *sshd(8)* 手册页。
- en: Note that Go's `ssh.ParseKnownHosts()` will only parse a single entry, so you
    should create a unique file with a single entry for the server or ensure that
    the desired entry is at the top of the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go 的 `ssh.ParseKnownHosts()` 只会解析单一条目，因此你应创建一个包含单个条目的唯一文件，或者确保所需条目位于文件的顶部。
- en: 'To obtain the remote server''s public key for verification, use `ssh-keyscan`.
    This returns the server key in the `known_hosts` format that will be used in the
    following example. Remember, the Go `ssh.ParseKnownHosts` command only reads the
    first entry from a `known_hosts` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取远程服务器的公钥以进行验证，可以使用 `ssh-keyscan`。它将返回以 `known_hosts` 格式的服务器密钥，以下示例将使用该格式。记住，Go
    的 `ssh.ParseKnownHosts` 命令只会读取 `known_hosts` 文件中的第一条条目：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `ssh-keyscan` program will return multiple key types unless a key type
    is specified with the `-t` flag. Make sure that you choose the one with the desired
    key algorithm and that `ssh.ClientConfig()` has `HostKeyAlgorithm` listed to match.
    This example includes every possible `ssh.KeyAlgo*` option. I recommend that you
    choose the highest-strength algorithm possible and only allow that option:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh-keyscan` 程序会返回多种密钥类型，除非通过 `-t` 标志指定了密钥类型。确保选择与所需密钥算法匹配的类型，并且 `ssh.ClientConfig()`
    中列出的 `HostKeyAlgorithm` 也要匹配。此示例包括了所有可能的 `ssh.KeyAlgo*` 选项。我建议你选择最强的算法，并只允许该选项：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, in addition to the `ssh.KeyAlgo*` constants, there are `ssh.CertAlgo*`
    constants if certificates are used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了 `ssh.KeyAlgo*` 常量外，如果使用证书，还有 `ssh.CertAlgo*` 常量。
- en: Executing a command over SSH
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 SSH 命令
- en: Now that we have established multiple ways of authenticating and connecting
    to a remote SSH server, we need to put `ssh.Client` to work. So far we have only
    been printing out the client version. The first goal is to execute a single command
    and view the output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了多种身份验证和连接远程 SSH 服务器的方式，我们需要开始使用 `ssh.Client`。到目前为止，我们只是在打印客户端版本。第一个目标是执行一个命令并查看输出。
- en: Once `ssh.Client` is created, you can begin creating sessions. A client supports
    multiple sessions at once. A session has its own standard input, output, and error.
    They are standard reader and writer interfaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `ssh.Client`，你可以开始创建会话。一个客户端可以同时支持多个会话。每个会话都有自己的标准输入、输出和错误，它们是标准的读写接口。
- en: 'To execute a command there are a few options: `Run()`, `Start()`, `Output()`,
    and `CombinedOutput()`. They are all very similar, but behave a little differently:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令有几种选择：`Run()`、`Start()`、`Output()` 和 `CombinedOutput()`。它们非常相似，但行为略有不同：
- en: '`session.Output(cmd)`: The `Output()` function will execute the command, and
    return `session.Stdout` as a byte slice.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Output(cmd)`：`Output()` 函数将执行命令，并返回 `session.Stdout` 作为字节切片。'
- en: '`session.CombinedOutput(cmd)`: This does the same as `Output()`, but it returns
    both standard output and standard error combined.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.CombinedOutput(cmd)`：此函数与 `Output()` 相同，但它将返回标准输出和标准错误的组合。'
- en: '`session.Run(cmd)`: The `Run()` function will execute the command and wait
    for it to finish. It will fill the standard output and error buffers, but it won''t
    do anything with them. You have to manually read the buffers or set the session
    output to go to the Terminal output before calling `Run()` (for example, `session.Stdout
    = os.Stdout`). It will only return without an error if the program exited with
    an error code of `0` and there were no issues copying the standard output buffers.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Run(cmd)`：`Run()` 函数将执行命令并等待其完成。它会填充标准输出和错误缓冲区，但不会对它们做任何处理。你必须手动读取缓冲区，或者在调用
    `Run()` 前将会话输出设置为终端输出（例如，`session.Stdout = os.Stdout`）。只有当程序以错误代码 `0` 退出且没有出现标准输出缓冲区复制问题时，它才会返回并且不报错。'
- en: '`session.Start(cmd)`: The `Start()` function is similar to `Run()`, except
    that it will not wait for the command to finish. You must explicitly call `session.Wait()`
    if you want to block execution until the command is complete. This is useful for
    starting long running commands or if you want more control over the application
    flow.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session.Start(cmd)`：`Start()`函数与`Run()`类似，唯一的不同是它不会等待命令完成。如果你希望在命令完成之前阻塞执行，必须显式调用`session.Wait()`。这个方法对于启动长时间运行的命令或需要更多控制应用程序流程的场景非常有用。'
- en: 'A session can only perform one action. Once you call `Run()`, `Output()`, `CombinedOutput()`,
    `Start()`, or `Shell()`, you can''t use the session for executing any other commands.
    If you need to run multiple commands, you can string them together separated with
    a semicolon. For example, you can pass multiple commands in a single command string
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个会话只能执行一个操作。一旦调用了`Run()`、`Output()`、`CombinedOutput()`、`Start()`或`Shell()`，该会话就不能用于执行其他命令。如果你需要运行多个命令，可以将它们用分号分隔在一起。例如，可以像这样将多个命令传递到单个命令字符串中：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Otherwise, you can create a new session for each command you need to run. One
    session equates to one command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以为每个需要执行的命令创建一个新的会话。一个会话等同于一个命令。
- en: 'The following example connects to a remote SSH server using key authentication,
    and then it creates a session using `client.NewSession()`. The standard output
    from the session is then connected to our local Terminal standard output before
    calling `session.Run()`, which will execute the command on the remote server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用密钥认证连接到远程SSH服务器，然后使用`client.NewSession()`创建一个会话。会话的标准输出被连接到我们本地终端的标准输出，然后调用`session.Run()`，它将在远程服务器上执行命令：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Starting an interactive shell
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动交互式Shell
- en: In the previous example, we demonstrated how to run command strings. There is
    also an option to open a shell. By calling `session.Shell()`, an interactive login
    shell is executed, loading whatever default shell the user has and loading the
    default profile (for example, `.profile`). The call to `session.RequestPty()`
    is optional, but the shell works much better when requesting a psuedoterminal.
    You can set the terminal name to `xterm`, `vt100`, `linux`, or something custom.
    If you have issues with jumbled output due to color values being output, try `vt100`,
    and if that still does not work, use a nonstandard terminal name or a terminal
    name you know does not support colors. Many programs will disable color output
    if they do not recognize the terminal name. Some programs will not work at all
    with an unknown terminal type, such as `tmux`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们展示了如何运行命令字符串。还有一个选项是打开一个Shell。通过调用`session.Shell()`，会执行一个交互式登录Shell，加载用户的默认Shell并加载默认配置文件（例如，`.profile`）。调用`session.RequestPty()`是可选的，但当请求伪终端时，Shell的表现会更好。你可以将终端名称设置为`xterm`、`vt100`、`linux`，或自定义名称。如果由于输出颜色值而导致乱码，尝试使用`vt100`，如果仍然无法解决问题，可以使用非标准的终端名称，或使用你知道不支持颜色的终端名称。许多程序会在不识别终端名称时禁用颜色输出。某些程序在遇到未知终端类型时可能无法正常工作，例如`tmux`。
- en: More information about Go terminal mode constants is available at [https://godoc.org/golang.org/x/crypto/ssh#TerminalModes](https://godoc.org/golang.org/x/crypto/ssh#TerminalModes).
    Terminal mode flags are a POSIX standard and are defined in *RFC 4254*,* Encoding
    of Terminal Modes* (section 8), which you can find at [https://tools.ietf.org/html/rfc4254#section-8](https://tools.ietf.org/html/rfc4254#section-8).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Go终端模式常量的信息可以在[https://godoc.org/golang.org/x/crypto/ssh#TerminalModes](https://godoc.org/golang.org/x/crypto/ssh#TerminalModes)中找到。终端模式标志是POSIX标准，定义在*RFC
    4254*的*终端模式编码*（第8节）中，你可以在[https://tools.ietf.org/html/rfc4254#section-8](https://tools.ietf.org/html/rfc4254#section-8)找到相关内容。
- en: 'The following example connects to an SSH server using key authentication, and
    then creates a new session with `client.NewSession()`. Instead of executing a
    command with `session.Run()` like the previous example, we will use `session.RequestPty()`
    to get an interactive shell. Standard input, output, and error streams from the
    remote session are all connected to the local Terminal, so you can interact with
    it in real time just like any other SSH client (for example, PuTTY):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用密钥认证连接到SSH服务器，然后通过`client.NewSession()`创建一个新会话。与之前的示例不同，我们不会使用`session.Run()`执行命令，而是使用`session.RequestPty()`来获取一个交互式Shell。来自远程会话的标准输入、输出和错误流都会连接到本地终端，因此你可以像其他任何SSH客户端一样实时与其互动（例如，PuTTY）：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should now understand how to use the Go SSH
    client to connect and authenticate using a password or a private key. In addition,
    you should now understand how to execute a command on a remote server or how to
    begin an interactive session.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该已经理解如何使用 Go SSH 客户端通过密码或私钥进行连接和认证。此外，你现在应该了解如何在远程服务器上执行命令，或者如何开始交互式会话。
- en: How would you apply an SSH client programmatically? Can you think of any use
    cases? Do you manage multiple remote servers? Could you automate any tasks?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何以编程方式应用 SSH 客户端？你能想到什么使用场景吗？你是否管理多个远程服务器？你能否自动化某些任务？
- en: The SSH package also contains types and functions for creating an SSH server,
    but we have not covered them in this book. Read more about creating an SSH server
    at [https://godoc.org/golang.org/x/crypto/ssh#NewServerConn](https://godoc.org/golang.org/x/crypto/ssh#NewServerConn)
    and more about the SSH package overall at [https://godoc.org/golang.org/x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 包还包含用于创建 SSH 服务器的类型和函数，但我们在本书中没有涉及这些内容。关于创建 SSH 服务器的更多信息，请阅读 [https://godoc.org/golang.org/x/crypto/ssh#NewServerConn](https://godoc.org/golang.org/x/crypto/ssh#NewServerConn)，以及关于
    SSH 包的更多信息，请阅读 [https://godoc.org/golang.org/x/crypto/ssh](https://godoc.org/golang.org/x/crypto/ssh)。
- en: In the next chapter, we'll look at brute force attacks, where passwords are
    guessed until eventually a correct password is found. Brute forcing is something
    we can do with the SSH client, as well as other protocols and applications. Continue
    reading the next chapter to learn how to execute a brute force attack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论暴力破解攻击，即通过不断猜测密码，直到最终找到正确的密码。暴力破解是我们可以使用 SSH 客户端以及其他协议和应用程序进行的操作。继续阅读下一章，了解如何执行暴力破解攻击。
