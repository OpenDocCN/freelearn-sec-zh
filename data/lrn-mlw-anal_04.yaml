- en: Assembly Language and Disassembly Primer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编语言与反汇编入门
- en: Static analysis and dynamic analysis are great techniques to understand the
    basic functionality of malware, but these techniques do not provide all the required
    information regarding the malware's functionality. Malware authors write their
    malicious code in a high-level language, such as C or C++, which is compiled to
    an executable using a compiler. During your investigation, you will only have
    the malicious executable, without its source code. To gain a deeper understanding
    of a malware's inner workings and to understand the critical aspects of a malicious
    binary, code analysis needs to be performed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析和动态分析是理解恶意软件基本功能的绝佳技术，但这些技术并不能提供关于恶意软件功能的所有必要信息。恶意软件作者通常使用高级语言（如 C 或 C++）编写恶意代码，然后通过编译器将其编译成可执行文件。在你的调查过程中，你只能获得恶意可执行文件，而没有源代码。为了深入了解恶意软件的内部工作原理，并理解恶意二进制文件的关键方面，需要进行代码分析。
- en: This chapter will cover the concepts and skills required to perform code analysis.
    For a better understanding of the subject, this chapter will make use of relevant
    concepts from both C programming and assembly language programming. To understand
    the concepts covered in this chapter, you are expected to have a basic programming
    knowledge (preferably C programming). If you are not familiar with basic programming
    concepts, start with an introductory programming book (you can refer to the additional
    resources provided at the end of this chapter) and return to this chapter afterward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍进行代码分析所需的概念和技能。为了更好地理解该主题，本章将结合 C 编程和汇编语言编程中的相关概念。为了理解本章涉及的概念，要求你具备基本的编程知识（最好是
    C 编程）。如果你不熟悉基本的编程概念，可以从一本入门编程书籍开始学习（可以参考本章末尾提供的附加资源），然后再回来阅读本章。
- en: 'The following topics will be covered from a code analysis (reverse engineering)
    perspective:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码分析（逆向工程）角度将涵盖以下主题：
- en: Computer basics, memory, and the CPU
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机基础、内存和CPU
- en: Data transfer, arithmetic, and bitwise operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输、算术运算和位运算
- en: Branching and looping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支和循环
- en: Functions and stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和栈
- en: Arrays, strings, and structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组、字符串和结构体
- en: Concepts of the x64 architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x64架构的概念
- en: 1\. Computer Basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 计算机基础
- en: A computer is a machine that processes information. All of the information in
    the computer is represented in *bits*. A bit is an individual unit that can take
    either of the two values `0` or `1`. The collection of bits can represent a number,
    a character, or any other  piece of information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一种处理信息的机器。计算机中的所有信息都是通过*比特*表示的。比特是一个基本单位，它可以取值 `0` 或 `1`。比特的集合可以表示一个数字、一个字符或任何其他信息。
- en: '**Fundamental data types**:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本数据类型**：'
- en: 'A group of `8` bits makes a *byte*. A single byte is represented as two hexadecimal
    digits, and each hexadecimal digit is `4` bits in size and called a *nibble*.
    For example, the binary number `01011101` translates to `5D` in hexadecimal. The
    digit `5` (`0101`) and digit `D` (`1101`) are the `nibbles`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一组 `8` 个比特组成一个*字节*。一个字节用两个十六进制数字表示，每个十六进制数字是 `4` 比特大小，称为*半字节（nibble）*。例如，二进制数
    `01011101` 转换为十六进制是 `5D`。数字 `5`（`0101`）和数字 `D`（`1101`）就是这两个*半字节*：
- en: '![](../images/00060.gif)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00060.gif)'
- en: 'Apart from bytes, there are other data types, such as a `word`, which is `2`
    bytes (`16 bits`) in size, a `double word (dword)` is `4` bytes (`32 bits`), and
    a `quadword (qword)` is `8` bytes (`64 bits`) in size:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字节外，还有其他数据类型，例如 `word`，它是 `2` 字节（`16 位`）大小；`double word (dword)` 是 `4` 字节（`32
    位`）；`quadword (qword)` 是 `8` 字节（`64 位`）：
- en: '![](../images/00061.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00061.jpeg)'
- en: '**Data Interpretation**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据解释**：'
- en: A byte, or sequence of bytes, can be interpreted differently. For example, `5D`
    can represent the binary number `01011101`, or the decimal number `93`, or the
    character `]`. The byte `5D` can also represent a machine instruction, `pop ebp`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节或字节序列可以有不同的解释。例如，`5D` 可以表示二进制数 `01011101`，或者十进制数 `93`，或者字符 `]`。字节 `5D` 还可以表示一条机器指令，`pop
    ebp`。
- en: Similarly, the sequence of two bytes `8B EC` (`word`) can represent `short int
    35820` or a machine instruction, `mov ebp,esp`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，两个字节序列 `8B EC`（`word`）可以表示 `short int 35820` 或一条机器指令，`mov ebp,esp`。
- en: The double word (`dword`) value `0x010F1000` can be interpreted as an integer
    value `17764352`, or a memory address. It's all a matter of interpretation, and
    what a byte or sequence of bytes means depends on how it is used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 双字（`dword`）值 `0x010F1000` 可以解释为一个整数值 `17764352`，也可以解释为一个内存地址。这完全取决于如何解释字节，字节或字节序列的意义取决于其用途。
- en: 1.1 Memory
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 内存
- en: 'The *main memory (RAM)* stores the code (machine code) and data for the computer.
    A computer''s main memory is an array of bytes (sequence of bytes in hex format),
    with each byte labeled with a unique number, known as its *address*. The first
    address starts at `0`, and the last address depends on the hardware and software
    in use. The addresses and values are represented in hexadecimal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*主内存（RAM）* 存储计算机的代码（机器码）和数据。计算机的主内存是一个字节数组（十六进制格式的字节序列），每个字节都标有一个唯一的编号，称为 *地址*。第一个地址从
    `0` 开始，最后一个地址取决于所使用的硬件和软件。地址和值以十六进制表示：'
- en: '![](../images/00062.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00062.jpeg)'
- en: 1.1.1 How Data Resides In Memory
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1.1 数据在内存中的存储方式
- en: 'In memory, the data is stored in the *little-endian* format; that is, a low-order
    byte is stored at the lower address, and subsequent bytes are stored in successively
    higher addresses in the memory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，数据以 *小端* 格式存储；也就是说，低位字节存储在较低的地址，后续字节依次存储在内存中逐渐增高的地址：
- en: '![](../images/00063.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00063.jpeg)'
- en: 1.2 CPU
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 CPU
- en: The *Central Processing Unit (CPU)* executes instructions (also called *machine
    instructions*). The instructions that the CPU executes are stored in the memory
    as a sequence of bytes. While executing the instructions, the required data (which
    is also stored as a sequence of bytes) is fetched from memory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*中央处理单元（CPU）* 执行指令（也叫 *机器指令*）。CPU 执行的指令以字节序列的形式存储在内存中。在执行指令时，需要的数据（也以字节序列形式存储）从内存中提取。'
- en: The CPU itself contains a small collection of memory within its chip, called
    the *register set*. The registers are used to store values fetched from memory
    during execution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 本身在其芯片内包含了一小部分内存，称为 *寄存器组*。寄存器用于存储在执行过程中从内存中提取的值。
- en: 1.2.1 Machine Language
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.1 机器语言
- en: Each CPU has a set of instructions that it can execute. The instructions that
    the CPU executes make up the CPU’s machine language. These machine instructions
    are stored in the memory as a sequence of bytes that is fetched, interpreted,
    and executed by the CPU.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 CPU 都有一组它可以执行的指令。CPU 执行的指令构成了 CPU 的机器语言。这些机器指令以字节序列的形式存储在内存中，并被 CPU 提取、解释和执行。
- en: A *compiler* is a program that translates programs written in a programming
    language (like C or C++) into the machine language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译器* 是一种将用编程语言（如 C 或 C++）编写的程序转换为机器语言的程序。'
- en: 1.3 Program Basics
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 程序基础
- en: In this section, you will learn what happens during the compilation process
    and program execution, and how various computer components interact with each
    other while the program executes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习编译过程和程序执行过程中发生的事情，以及程序执行时各个计算机组件如何相互作用。
- en: 1.3.1 Program Compilation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.1 程序编译
- en: 'The following list outlines the executable compilation process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了可执行文件的编译过程：
- en: The source code is written in a high-level language, such as C or C++.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码是用高级语言编写的，例如 C 或 C++。
- en: The source code of the program is run through the compiler. The compiler then
    translates the statements written in a high-level language into an intermediate
    form called an *object file* or *machine code*, which is not human-readable and
    is meant for execution by the processor.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的源代码通过编译器进行处理。编译器将用高级语言编写的语句转换为一种称为 *目标文件* 或 *机器代码* 的中间形式，这种形式不可读，旨在供处理器执行。
- en: 'The object code is then passed through the linker. The linker links the object
    code with the required libraries (DLLs) to produce an executable that can be run
    on a system:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，目标代码会传递给链接器。链接器将目标代码与所需的库文件（DLL）链接，以生成可以在系统上运行的可执行文件：
- en: '![](../images/00064.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00064.jpeg)'
- en: 1.3.2 Program On Disk
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.2 硬盘上的程序
- en: 'Let''s try to understand how a compiled program appears on the disk, with an
    example. Let''s take an example of a simple C program that prints a string to
    the screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解编译后的程序在磁盘上的样子。我们以一个简单的 C 程序为例，程序将字符串打印到屏幕：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above program was passed through a compiler to generate an executable file
    (`print_string.exe`). Opening the compiled executable file in the PE Internals
    tool ([http://www.andreybazhan.com/pe-internals.html](http://www.andreybazhan.com/pe-internals.html))
    displays the five sections (`.text`, `.rdata`, `.data`, `.rsrc`, and `.reloc`)
    generated by the compiler. Information about the sections was provided in [Chapter
    2](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485), *Static Analysis.* Here,
    we will mainly focus on two sections: `.text` and `.data`. The content of the `.data`
    section is shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序经过编译器编译生成了一个可执行文件（`print_string.exe`）。在PE Internals工具中打开已编译的可执行文件（[http://www.andreybazhan.com/pe-internals.html](http://www.andreybazhan.com/pe-internals.html)）会显示由编译器生成的五个节（`.text`、`.rdata`、`.data`、`.rsrc`和`.reloc`）。关于这些节的信息可以在[第2章](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485)中找到，*静态分析*部分。这里我们将主要关注两个节：`.text`和`.data`。`.data`节的内容如下图所示：
- en: '![](../images/00065.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00065.jpeg)'
- en: In the preceding screenshot, you can see that the string `This is a simple program`,
    which we used in our program, is stored in the `.data` section at the file offset
    `0x1E00`. This string is not a code, but it is the data required by the program.
    In the same manner, the `.rdata` section contains read-only data and sometimes
    contains *import/export* information. The `.rsrc` section contains resources used
    by the executable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到我们在程序中使用的字符串`This is a simple program`存储在文件偏移量`0x1E00`的`.data`节中。这个字符串不是代码，而是程序所需的数据。同样，`.rdata`节包含只读数据，有时也包含*导入/导出*信息。`.rsrc`节包含可执行文件使用的资源。
- en: 'The content of the `.text` section is shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text`节的内容如下图所示：'
- en: '![](../images/00066.gif)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.gif)'
- en: 'The sequence of bytes (`35` bytes to be specific) displayed in the `.text`
    section (starting from the file offset `0x400`) is the *machine code*. The source
    code that we had written was translated into machine code (or machine language
    program) by the compiler. The machine code is not easy for humans to read, but
    the processor (CPU) knows how to interpret those sequences of bytes. The machine
    code contains instructions that will be executed by the processor. The compiler
    segregated the data and the code in different sections on the disk. For the sake
    of simplicity, we can think of an executable as containing code (`.text`) and
    data (`.data`, `.rdata`, and so on):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在`.text`节中的字节序列（具体来说是`35`个字节，从文件偏移量`0x400`开始）是*机器代码*。我们编写的源代码经过编译器转换成了机器代码（或机器语言程序）。机器代码对于人类来说不易阅读，但处理器（CPU）知道如何解读这些字节序列。机器代码包含处理器将执行的指令。编译器将数据和代码分隔到磁盘上的不同节中。为了简化起见，我们可以将可执行文件视为包含代码（`.text`）和数据（`.data`、`.rdata`等）：
- en: '![](../images/00067.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00067.jpeg)'
- en: 1.3.3 Program In Memory
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.3 程序在内存中的表现
- en: 'In the previous section, we examined the structure of the executable on the
    disk. Let''s try to understand what happens when an executable is loaded into
    the memory. When the executable is double-clicked, a process memory is allocated
    by the operating system, and the executable is loaded into the allocated memory
    by the operating system loader. The following simplified memory layout should
    help you to visualize the concept; note that the structure of the executable on
    the disk is similar to the structure of the executable in the memory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们检查了磁盘上可执行文件的结构。现在我们来理解当可执行文件被加载到内存时发生了什么。当双击可执行文件时，操作系统会为进程分配内存，并通过操作系统加载器将可执行文件加载到分配的内存中。以下简化的内存布局图有助于你理解这个概念；请注意，磁盘上可执行文件的结构与内存中的可执行文件结构相似：
- en: '![](../images/00068.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00068.jpeg)'
- en: In the preceding diagram, the heap is used for dynamic memory allocation during
    program execution, and its contents can vary. The stack is used for storing the
    local variables, function arguments, and the return address. You will learn about
    the stack in detail in later sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示意图中，堆用于程序执行过程中进行动态内存分配，其内容是可变的。栈用于存储局部变量、函数参数和返回地址。你将在后面的章节中详细了解栈。
- en: The memory layout shown previously is greatly simplified, and the positions
    of components may be in any order. The memory also contains various *Dynamic Link
    Libraries (DLLs)*, which are not shown in the preceding diagram, to keep it simple.
    You will learn about the process memory in detail in the upcoming chapters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面展示的内存布局大大简化了，组件的位置可以是任何顺序。内存中还包含了各种*动态链接库（DLLs）*，这些在前面的图示中没有展示，为了简化起见。你将在接下来的章节中详细了解进程内存。
- en: 'Now, let''s go back to our compiled executable (`print_string.exe`) and load
    it into the memory. The executable was opened in the *x64dbg* debugger, which
    loaded the executable in the memory (we will be covering *x64dbg* in a later chapter;
    for now, we will focus on the structure of the executable in memory). In the following
    screenshot, you can see that the executable was loaded at the memory address `0x010F0000`,
    and all the sections of the executable were also loaded into the memory. A point
    to remember is that the memory address that you are looking at is the virtual
    address, not the physical memory address. The virtual address will eventually
    be translated into a physical memory address (you will learn more about the virtual
    and physical address in later chapters):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们编译后的可执行文件（`print_string.exe`），并将其加载到内存中。该可执行文件已在*x64dbg*调试器中打开，调试器将可执行文件加载到了内存中（我们将在后面的章节中介绍*x64dbg*；现在我们将专注于可执行文件在内存中的结构）。在以下截图中，你可以看到可执行文件已加载到内存地址`0x010F0000`，并且可执行文件的所有部分也已加载到内存中。需要记住的一点是，你看到的内存地址是虚拟地址，而不是物理内存地址。虚拟地址最终会被转换为物理内存地址（你将在后面的章节中了解更多关于虚拟地址和物理地址的内容）：
- en: '![](../images/00069.gif)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00069.gif)'
- en: Examining the memory address of the `.data` section at `0x010F3000` displays
    the string `This is a simple program`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`.data`部分在内存地址`0x010F3000`的位置，可以看到字符串`This is a simple program`。
- en: '![](../images/00070.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.gif)'
- en: Examining the memory address of the `.text` section at `0x010F1000` displays
    the sequence of bytes, which is the machine code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`.text`部分在内存地址`0x010F1000`的位置，可以看到字节序列，这就是机器码。
- en: '![](../images/00071.gif)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.gif)'
- en: 'Once the executable that contains the code and data is loaded into the memory,
    the CPU fetches the machine code from memory, interprets it, and executes it.
    While executing the machine instructions, the required data will also be fetched
    from memory. In our example, the CPU fetches the machine code containing the instructions
    (to print on the screen) from the `.text` section, and it fetches the string (data)
    `This is a simple program`, to be printed from the `.data` section. The following
    diagram should help you to visualize the interactions between the CPU and the
    memory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含代码和数据的可执行文件被加载到内存中，CPU会从内存中取出机器码，解释并执行它。在执行机器指令时，所需的数据也会从内存中提取。在我们的示例中，CPU从`.text`部分获取包含指令（在屏幕上打印）的机器码，并从`.data`部分获取要打印的字符串（数据）`This
    is a simple program`。以下图示将帮助你可视化CPU和内存之间的交互：
- en: '![](../images/00072.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: While executing instructions, the program may also interact with the input/output
    devices. In our example, when the program is executed, the string is printed onto
    the computer screen (output device). If the machine code had an instruction to
    receive input, the processor (CPU) would have interacted with the input device
    (such as the keyboard).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行指令时，程序还可能与输入/输出设备交互。在我们的示例中，当程序执行时，字符串被打印到计算机屏幕上（输出设备）。如果机器码中有接收输入的指令，处理器（CPU）将与输入设备（例如键盘）进行交互。
- en: 'To summarize, the following steps are performed when a program is executed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，程序执行时会执行以下步骤：
- en: The program (which contains code and data) is loaded into the memory.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序（包含代码和数据）被加载到内存中。
- en: The CPU fetches the machine instruction, decodes it, and executes it.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU从内存中获取机器指令，解码并执行它。
- en: The CPU fetches the required data from memory; the data can also be written
    to the memory.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU从内存中获取所需的数据；数据也可以被写入内存。
- en: 'The CPU may interact with the input/output system, as necessary:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU可能会根据需要与输入/输出系统进行交互：
- en: '![](../images/00073.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: 1.3.4 Program Disassembly (From Machine code To Assembly code)
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.4 程序反汇编（从机器码到汇编代码）
- en: As you would expect, machine code contains information about the inner workings
    of the program. For example, in our program, the machine code included the instructions
    to print on the screen, but it would be painful for a human to try to understand
    the machine code (which is stored as a sequence of bytes).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，机器码包含了关于程序内部工作的详细信息。例如，在我们的程序中，机器码包含了在屏幕上打印的指令，但对于人类来说，尝试理解机器码（它是以字节序列形式存储的）会非常困难。
- en: A *disassembler/debugger* (like *IDA Pro* or *x64dbg*) is a program that translates
    machine code into a low-level code called *assembly code (assembly language program)*,
    which can be read and analyzed to determine the workings of a program. The following
    screenshot shows the machine code (a sequence of bytes in the `.text` section)
    translated into the assembly instructions representing `13` executable instructions
    (`push ebp`, `mov ebp,esp`, and so on). These translated instructions are called
    *assembly language instructions*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*反汇编器/调试器*（如*IDA Pro*或*x64dbg*）是一个将机器码翻译成低级代码（称为*汇编代码*，即汇编语言程序）的程序，可以被读取和分析，以确定程序的工作原理。下图显示了机器码（`.text`部分的字节序列）被翻译成表示`13`条可执行指令（`push
    ebp`、`mov ebp,esp`等）的汇编指令。这些翻译后的指令称为*汇编语言指令*。
- en: 'You can see that the assembly instructions are much easier to read than the
    machine code. Notice how a disassembler translated the byte `55` into a readable
    assembly instruction `push ebp`, and the next two bytes `8B EC` into `mov ebp,esp`;
    and so on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，汇编指令比机器码更容易阅读。注意，反汇编器是如何将字节`55`翻译为可读的汇编指令`push ebp`，并将接下来的两个字节`8B EC`翻译为`mov
    ebp,esp`，依此类推：
- en: '![](../images/00074.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: From a code analysis perspective, determining the program's functionality mainly
    relies on understanding these assembly instructions and how to interpret them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码分析的角度来看，确定程序的功能主要依赖于理解这些汇编指令以及如何解释它们。
- en: In the rest of the chapter, you will learn the skills required to understand
    the assembly code to reverse engineer the malicious binary. In the upcoming sections,
    you will learn the concepts of x86 assembly language instructions that are essential
    to perform code analysis; x86, also known as IA-32 (32-bit), is the most popular
    architecture for PCs. Microsoft Windows runs on an x86 (32-bit) architecture and
    Intel 64 (x64) architectures. Most malware that you will encounter are compiled
    for x86 (32 bit) architectures and can run on both 32 bit and 64 bit Windows.
    At the end of the chapter, you will understand the x64 architecture and the differences
    between x86 and x64.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将学习理解汇编代码所需的技能，以便逆向工程恶意二进制文件。在接下来的章节中，你将学习进行代码分析所必需的x86汇编语言指令的概念；x86，也称为IA-32（32位），是PC上最常见的架构。Microsoft
    Windows运行在x86（32位）架构和Intel 64（x64）架构上。你将遇到的大多数恶意软件都是为x86（32位）架构编译的，并且可以在32位和64位Windows上运行。章节末，你将理解x64架构以及x86和x64之间的区别。
- en: 2\. CPU Registers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. CPU寄存器
- en: As mentioned previously, the CPU contains special storage called *registers*.
    The CPU can access data in registers much faster than data in memory, because
    of which the values fetched from the memory are temporarily stored in these registers
    to perform operations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CPU包含称为*寄存器*的特殊存储器。由于CPU可以比内存中数据的访问速度快得多，因此从内存中提取的值会暂时存储在这些寄存器中，以便执行操作。
- en: 2.1 General-Purpose Registers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 通用寄存器
- en: 'The x86 CPU has eight general purpose registers: `eax`, `ebx`, `ecx`, `edx`, `esp`, `ebp`, `esi`,
    and `edi`. These registers are 32 bits (4 bytes) in size. A program can access
    registers as 32-bit (4 bytes), 16-bit (2 bytes), or 8-bit (1 byte) values. The
    lower 16 bits (2 bytes) of each of these registers can be accessed as `ax`, `bx`, `cx`, `dx`, `sp`, `bp`, `si`,
    and `di`. The lower 8 bits (1 byte) of `eax`, `ebx`, `ecx`, and `edx` can be referenced
    as `al`, `bl`, `cl`, and `dl`. The higher set of 8 bits can be accessed as `ah`, `bh`, `ch`,
    and `dh`. In the following diagram, the `eax` register contains the 4-byte value
    `0xC6A93174`. A program can access the lower 2 bytes (`0x3174`) by accessing the `ax`
    register, and it can access the lower byte (`0x74`) by accessing the `al` register,
    and the next byte (`0x31`) can be accessed by using the `ah` register:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: x86 CPU 有八个通用寄存器：`eax`，`ebx`，`ecx`，`edx`，`esp`，`ebp`，`esi` 和 `edi`。这些寄存器的大小为
    32 位（4 字节）。程序可以按 32 位（4 字节）、16 位（2 字节）或 8 位（1 字节）值来访问这些寄存器。这些寄存器的低 16 位（2 字节）可以作为
    `ax`，`bx`，`cx`，`dx`，`sp`，`bp`，`si` 和 `di` 来访问。`eax`，`ebx`，`ecx` 和 `edx` 的低 8 位（1
    字节）可以分别引用为 `al`，`bl`，`cl` 和 `dl`。高 8 位可以通过 `ah`，`bh`，`ch` 和 `dh` 来访问。在以下示意图中，`eax`
    寄存器包含 4 字节值 `0xC6A93174`。程序可以通过访问 `ax` 寄存器来访问低 2 字节（`0x3174`），通过访问 `al` 寄存器来访问低字节（`0x74`），而下一个字节（`0x31`）则可以通过使用
    `ah` 寄存器来访问：
- en: '![](../images/00075.gif)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.gif)'
- en: 2.2 Instruction Pointer (EIP)
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 指令指针（EIP）
- en: The CPU has a special register called `eip`; it contains the address of the
    next instruction to execute. When the instruction is executed, the `eip` will
    be pointing to the next instruction in the memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 有一个特殊的寄存器，叫做 `eip`；它包含下一条指令的地址。当指令执行时，`eip` 将指向内存中下一条要执行的指令。
- en: 2.3 EFLAGS Register
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 EFLAGS 寄存器
- en: The `eflags` register is a 32-bit register, and each bit in this register is
    a *flag*. The bits in `EFLAGS` registers are used to indicate the status of the
    computations and to control the CPU operations. The flag register is usually not
    referred to directly, but during the execution of computational or conditional
    instructions, each flag is set to either `1` or `0`. Apart from these registers,
    there are additional registers, which are called *segment registers* (`cs`, `ss`, `ds`, `es`, `fs`,
    and `gs`), which keep track of sections in the memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`eflags` 寄存器是一个 32 位的寄存器，寄存器中的每一位都是一个*标志*。`EFLAGS` 寄存器中的位用于指示计算的状态，并控制 CPU
    操作。标志寄存器通常不会直接引用，但在执行计算或条件指令时，每个标志位都会被设置为 `1` 或 `0`。除了这些寄存器外，还有一些其他寄存器，称为*段寄存器*（`cs`，`ss`，`ds`，`es`，`fs`，和
    `gs`），它们用于跟踪内存中的各个段。'
- en: 3\. Data Transfer Instructions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 数据传输指令
- en: 'One of the basic instructions in the assembly language is the `mov` instruction.
    As the name suggest, this instruction moves data from one location to another
    (from source to destination). The general form of the `mov` instruction is as
    follows; this is similar to the assignment operation in a high-level language:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中的基本指令之一是 `mov` 指令。顾名思义，这条指令将数据从一个位置移动到另一个位置（从源位置到目标位置）。`mov` 指令的一般形式如下；这类似于高级语言中的赋值操作：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are different variations of the `mov` instruction, which will be covered
    next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令有不同的变体，接下来将会介绍。'
- en: 3.1 Moving a Constant Into Register
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 将常量移入寄存器
- en: 'The first variation of the `mov` instruction is to move a *constant (or immediate
    value)* into a register. In the following examples, `;` (a semicolon) indicates
    the start of the comment; anything after the semicolon is not part of the assembly
    instruction. This is just a brief description to help you understand this concept:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令的第一种变体是将一个*常量（或立即数值）*移动到寄存器中。在以下示例中，`;`（分号）表示注释的开始；分号后面的内容不属于汇编指令。这只是一个简短的描述，帮助你理解这个概念：'
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 3.2 Moving Values From Register To Register
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 从寄存器到寄存器的值传送
- en: 'Moving a value from one register to another is done by placing the register
    names as operands to the `mov` instruction:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值从一个寄存器传送到另一个寄存器，可以通过将寄存器名称作为操作数放置到 `mov` 指令中来实现：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Following is an example of two assembly instructions. The first instruction
    moves the constant value `10` into the `ebx` register. The second instruction
    moves the value of `ebx` (in other words, `10`) into the `eax` register; as a
    result, the `eax` register will contain the value `10`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两条汇编指令的示例。第一条指令将常量值 `10` 移入 `ebx` 寄存器。第二条指令将 `ebx` 寄存器的值（即 `10`）移入 `eax`
    寄存器；因此，`eax` 寄存器将包含值 `10`：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3.3 Moving Values From Memory To Registers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 从内存到寄存器的值传送
- en: 'Before looking at the assembly instruction to move a value from the memory
    to a register, let''s try to understand how values reside in the memory. Let''s
    say you have defined a variable in your C program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看将值从内存移动到寄存器的汇编指令之前，我们先尝试理解值是如何存储在内存中的。假设你在 C 程序中定义了一个变量：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following list outlines what happens during the runtime of the program:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了程序运行时发生的事情：
- en: An integer is 4 bytes in length, so the integer `100` is stored as a sequence
    of 4 bytes (`00 00 00 64`) in the memory.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数占用 4 个字节，因此整数 `100` 作为 4 个字节（`00 00 00 64`）存储在内存中。
- en: The sequence of four bytes is stored in the *little-endian* format mentioned
    previously.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个字节的顺序是按照之前提到的*小端*格式存储的。
- en: 'The integer `100` is stored at some memory address. Let''s assume that `100`
    was stored at the memory address starting at `0x403000`; you can think of this
    memory address labeled as `val`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数 `100` 存储在某个内存地址。假设 `100` 存储在从 `0x403000` 开始的内存地址中；你可以将这个内存地址看作是标记为 `val`：
- en: '![](../images/00076.gif)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.gif)'
- en: 'To move a value from the memory into a register in assembly language, you must
    use the address of the value. The following assembly instruction will move the
    4 bytes stored at the memory address `0x403000` into the register `eax`. The square
    bracket specifies that you want the value stored at the memory location, rather
    than the address itself:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个值从内存移动到寄存器中，你必须使用该值的地址。以下汇编指令将把存储在内存地址 `0x403000` 处的 4 字节移入寄存器 `eax`。方括号表示你要的是存储在该内存位置的值，而不是地址本身：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that in the preceding instruction, you did not have to specify 4 bytes
    in the instruction; based on the size of the destination register (`eax`), it
    automatically determined how many bytes to move. The following screenshot will
    help you to understand what happens after executing the preceding instruction:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的指令中，你不需要在指令中指定 4 字节；根据目标寄存器（`eax`）的大小，它会自动确定移动多少字节。以下截图将帮助你理解执行前述指令后的情况：
- en: '![](../images/00077.gif)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00077.gif)'
- en: 'During reverse engineering, you will normally see instructions similar to the
    ones shown as below. The square brackets may contain a *register*, *a constant
    added to a register*, or *a register added to a register*. All of the following
    diagram instructions move values stored at the memory address specified within
    the square brackets to the register. The simplest thing to remember is that everything
    within the square brackets represents an address:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在逆向工程中，你通常会看到类似下面的指令。方括号中可能包含一个*寄存器*、*一个加到寄存器上的常量*，或者*一个寄存器加到另一个寄存器上*。所有以下图示的指令都将把存储在方括号中指定的内存地址的值移动到寄存器中。最简单的记法是，方括号中的一切都代表一个地址：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another instruction that you will normally come across is the `lea` instruction,
    which stands for *load effective address*; this instruction will load the address
    instead of the value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你通常会遇到的指令是 `lea` 指令，表示*加载有效地址*；这条指令将加载地址，而不是值：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sometimes, you will come across instructions like the ones that follow. These
    instructions are the same as the previously mentioned instructions and transfer
    data stored in a memory address (specified by `ebp-4`) into the register. The
    `dword ptr` just indicates that a 4-byte (`dword`) value is moved from the memory
    address specified by `ebp-4` into the `eax`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到类似以下的指令。这些指令与前面提到的指令相同，都是将存储在内存地址（由 `ebp-4` 指定）中的数据传送到寄存器中。`dword ptr`
    只是表示一个 4 字节（`dword`）的值从由 `ebp-4` 指定的内存地址移动到 `eax`：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 3.4 Moving Values From Registers To Memory
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 从寄存器到内存的值的移动
- en: 'You can move a value from a register to memory by swapping operands so that
    the memory address is on the left-hand side (destination) and the register is
    on the right-hand side (source):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过交换操作数，将值从寄存器移动到内存，使得内存地址位于左侧（目标），而寄存器位于右侧（源）：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sometimes, you will come across instructions like those that follow. These
    instructions move constant values into a memory location; `dword ptr` just specifies
    that a `dword` value (4 bytes) is moved into the memory location. Similarly, `word
    ptr` specifies that a `word` (2 bytes) is moved into the memory location:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到类似以下的指令。这些指令将常量值移动到内存位置；`dword ptr` 只是指定一个 `dword` 值（4 字节）被移动到内存位置。同样，`word
    ptr` 指定一个 `word`（2 字节）被移动到内存位置：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding case, if `ebx` contained the memory address `0x402000`, then
    the second instruction copies `100` as `00 00 00 64` (4 bytes) into the memory
    location starting at the address `0x402000`, and the third instruction copies
    `100` as `00 64` (2 bytes) into the memory location starting at `0x40200`, as
    shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的情况下，如果`ebx`包含内存地址`0x402000`，那么第二条指令将`100`以`00 00 00 64`（4字节）的形式复制到内存位置`0x402000`开始的地址，第三条指令将`100`以`00
    64`（2字节）的形式复制到内存位置`0x40200`开始的地址，如下所示：
- en: '![](../images/00078.gif)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00078.gif)'
- en: Let's take a look at a simple challenge.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的挑战。
- en: 3.5 Disassembly Challenge
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 拆解挑战
- en: 'The following is a disassembled output of a simple C code snippet. Can you
    figure out what this code snippet does, and can you translate it back to a pseudocode
    (high-level language equivalent)? Use all of the concepts that you have learned
    so far to solve the challenge. The answer to the challenge will be covered in
    the next section, and we will also look at the original C code snippet after we
    solve this challenge:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单C代码片段的反汇编输出。你能搞清楚这段代码做了什么吗？并且你能将它翻译回伪代码（高级语言等效代码）吗？请运用到目前为止你学到的所有概念来解决这个挑战。挑战的答案将在下一节中介绍，解决挑战后我们还将回顾原始的C代码片段：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 3.6 Disassembly Solution
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 反汇编解决方案
- en: The preceding program copies a value from one memory location to another. At ➊,
    the program copies a `dword` value `1` into a memory address (specified by `ebp-4`).
    At ➋, the same value is copied into the `eax` register, which is then copied into a
    different memory address, `ebp-8`, at ➌.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序将一个值从一个内存位置复制到另一个位置。在➊处，程序将`dword`值`1`复制到内存地址（由`ebp-4`指定）。在➋处，相同的值被复制到`eax`寄存器中，然后在➌处被复制到另一个内存地址`ebp-8`。
- en: 'The disassembled code might be difficult to understand initially, so let me
    break it down to make it simple. We know that in a high-level language like C,
    a variable that you define (for example, `int val;`) is just a symbolic name for
    a memory address (as mentioned previously). Going by that logic, let''s identify
    the memory address references and give them a symbolic name. In the disassembled
    program, we have two addresses (within square brackets): `ebp-4` and `ebp-8`.
    Let''s label them and give them symbolic names; let''s say, `ebp-4 = a` and `ebp-8
    = b`. Now, the program should look like the one shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编代码可能一开始难以理解，所以让我来分解一下，使其变得简单。我们知道，在像C这样的高级语言中，你定义的变量（例如`int val;`）其实只是一个内存地址的符号名称（如前所述）。根据这个逻辑，让我们识别内存地址引用并给它们起个符号名称。在反汇编程序中，我们有两个地址（方括号内）：`ebp-4`
    和 `ebp-8`。让我们给它们起名字，假设`ebp-4 = a`和`ebp-8 = b`。现在，程序应该像这样：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In a high-level language, when you assign a value to a variable, let''s say
    `val = 1`, the value `1` is moved into the address represented by the `val` variable.
    In assembly, this can be represented as `mov [val], 1`. In other words, `val =
    1` in a high-level language is the same as `mov [val],1` in assembly. Using this
    logic, the preceding program can be written into a high-level language equivalent:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，当你给一个变量赋值，比如`val = 1`，值`1`被移动到由`val`变量表示的地址。在汇编中，这可以表示为`mov [val], 1`。换句话说，`val
    = 1`在高级语言中与汇编中的`mov [val],1`是等效的。运用这个逻辑，之前的程序可以写成一个高级语言的等效代码：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Recall that, the registers are used by the CPU for temporary storage. So, let''s
    replace all of the register names with their values on the right-hand side of
    the `=` sign (for example, replace `eax` with its value, `a`, at ➍). The resultant
    code is shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，寄存器是CPU用于临时存储的地方。所以，让我们将所有寄存器名称替换为`=`符号右侧的值（例如，将`eax`替换为其值`a`，位于➍）。结果代码如下所示：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding program, the `eax` register is used to temporarily hold the
    value of `a`, so we can remove the entry at ➎ (that is remove the entry containing
    registers on the left side of the `=` sign). We are now left with the simplified
    code shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的程序中，`eax`寄存器用于临时存储`a`的值，因此我们可以删除第➎行的条目（即删除`=`符号左侧包含寄存器的条目）。现在我们得到的是简化后的代码，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In high-level languages, variables have data types. Let's try to determine the
    data types of these variables: `a` and `b`. Sometimes, it is possible to determine
    the data type by understanding how the variables are accessed and used. From the
    disassembled code, we know that the `dword` value (4 bytes) `1` was moved into
    the variable `a`, which was then copied to `b`. Now that we know these variables
    are 4 bytes in size, it means that they could be of the type `int`, `float`, or `pointer`.
     To determine the exact data type, let's consider the following.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中，变量有数据类型。让我们尝试确定这些变量`a`和`b`的数据类型。有时，可以通过了解变量如何被访问和使用来确定数据类型。从反汇编的代码中，我们知道`dword`值（4字节）`1`被移入变量`a`，然后又复制到`b`。现在我们知道这些变量的大小为4字节，这意味着它们可能是`int`、`float`或`指针`类型。为了确定确切的数据类型，让我们考虑以下内容。
- en: The variables `a` and `b` cannot be `float`, because, from the disassembled
    code, we know that `eax` was involved in the data transfer operation. If it was
    a floating point value, the floating point registers would have been used, instead
    of using a general purpose register such as `eax`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`和`b`不能是`float`类型，因为从反汇编代码中我们知道`eax`参与了数据传输操作。如果是浮点值，则会使用浮点寄存器，而不是使用像`eax`这样的通用寄存器。
- en: The variables `a` and `b` cannot be a `pointer` in this case, because the value
    `1` is not a valid address. So, we can guess that `a` and `b` should be of the
    type `int`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量`a`和`b`不能是`指针`，因为值`1`不是一个有效的地址。所以，我们可以猜测`a`和`b`应该是`int`类型。
- en: 'Based on these observations, we can now rewrite the program as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些观察结果，我们现在可以将程序重写如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have solved the challenge, let''s look at the original C code snippet
    of the disassembled output. The original C code snippet is shown as follows. Compare
    it with what we determined. Notice how it was possible to build a program similar
    to the original program (it is not always possible to get the exact C program
    back), and also, it''s now much easier to determine the functionality of the program:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个问题，让我们来看一下反汇编输出的原始C代码片段。原始C代码片段如下所示。将其与我们确定的结果进行对比。注意，尽管无法完全恢复原始的C程序（并不总是能恢复出完全相同的C程序），但我们仍然能够构建一个与原始程序类似的程序，现在也更容易确定程序的功能：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you are disassembling a bigger program, it would be hard to label all of
    the memory addresses. Typically, you will use the features of the disassembler
    or debugger to rename memory addresses and to perform code analysis. You will
    learn the features offered by the disassembler and how to use it for code analysis
    in the next chapter.  When you are dealing with bigger programs, it is a good
    idea to break the program into small blocks of code, translate it into some high-level
    language that you are familiar with, and then do the same thing for the rest of
    the blocks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在反汇编一个较大的程序，那么标记所有内存地址会非常困难。通常，你会使用反汇编器或调试器的功能来重命名内存地址并进行代码分析。你将在下一章学习如何使用反汇编器的功能进行代码分析。当你处理较大的程序时，最好将程序分解成小块代码，翻译成你熟悉的某种高级语言，然后对其余的代码块做同样的事情。
- en: 4\. Arithmetic Operations
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 算术操作
- en: 'You can perform addition, subtraction, multiplication, and division in assembly
    language. A addition and subtraction are performed using the `add` and `sub` instructions,
    respectively. These instructions take two operands: *destination* and *source*.
    The `add` instruction adds the source and destination and stores the result in
    the destination. The `sub` instruction subtracts the source from the destination
    operand, and the result is stored in the destination. These instructions set or
    clear flags in the `eflags` register, based on the operation. These flags can
    be used in the conditional statements. The `sub` instruction sets the zero flag, `(zf)`,
    if the result is zero, and the carry flag, `(cf)`, if the destination value is
    less than the source. The following outlines a few variations of these instructions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你可以执行加法、减法、乘法和除法。加法和减法分别使用`add`和`sub`指令进行。这些指令接受两个操作数：*目标*和*源*。`add`指令将源操作数与目标操作数相加，并将结果存储在目标中。`sub`指令从目标操作数中减去源操作数，结果存储在目标中。这些指令根据操作设置或清除`eflags`寄存器中的标志。这些标志可以在条件语句中使用。如果结果为零，`sub`指令会设置零标志`(zf)`，如果目标值小于源值，则设置进位标志`(cf)`。以下概述了这些指令的一些变体：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is a special increment (`inc`) and decrement (`dec`) instruction, which
    can be used to add `1` or subtract `1` from either a register or a memory location:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的增量（`inc`）和减量（`dec`）指令，可用于向寄存器或内存位置加`1`或减`1`：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Multiplication is done using the `mul` instruction. The `mul` instruction takes
    only one operand; that operand is multiplied by the content of either the `al`,
    `ax`, or `eax` register. The result of the multiplication is stored in either
    the `ax`, `dx and ax`, or `edx and eax` register.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法是使用`mul`指令完成的。`mul`指令只接受一个操作数；该操作数与`al`、`ax`或`eax`寄存器的内容相乘。乘法的结果存储在`ax`、`dx和ax`或`edx和eax`寄存器中。
- en: 'If the operand of the `mul` instruction is *8 bits (1 byte)*, then it is multiplied
    by the 8-bit `al` register, and the product is stored in the `ax` register. If
    the operand is *16 bits (2 bytes)*, then it is multiplied with the `ax` register,
    and the product is stored in the `dx` and `ax` register. If the operand is a *32-bit
    (4 bytes)*, then it is multiplied with the `eax` register, and the product is
    stored in the `edx` and `eax` register. The reason the product is stored in a
    register double the size is because when two values are multiplied, the output
    values can be much larger than the input values. The following outlines variations
    of `mul` instructions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mul`指令的操作数为*8位（1字节）*，则与8位`al`寄存器相乘，并将乘积存储在`ax`寄存器中。如果操作数为*16位（2字节）*，则与`ax`寄存器相乘，并将乘积存储在`dx`和`ax`寄存器中。如果操作数为*32位（4字节）*，则与`eax`寄存器相乘，并将乘积存储在`edx`和`eax`寄存器中。将乘积存储在比输入值大一倍的寄存器中的原因是，当两个值相乘时，输出值可能比输入值大得多。以下概述了`mul`指令的变体：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Division is performed using the `div` instruction. The `div` takes only one
    operand, which can be either a register or a memory reference. To perform division,
    you place the dividend (number to divide) in the `edx and eax` register, with
    `edx` holding the most significant *dword*. After the `div` instruction is executed,
    the quotient is stored in `eax`, and the remainder is stored in the `edx` register:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是使用`div`指令执行的。`div`只接受一个操作数，可以是寄存器或内存引用。要执行除法，将被除数（要除的数）放入`edx和eax`寄存器中，其中`edx`保存最高有效*dword*。执行`div`指令后，商存储在`eax`中，余数存储在`edx`寄存器中：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 4.1 Disassembly Challenge
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 反汇编挑战
- en: Let's take on another simple challenge. The following is a disassembled output
    of a simple C program. Can you figure out what this program does, and can you
    translate it back to a pseudocode?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接受另一个简单的挑战。以下是一个简单C程序的反汇编输出。您能够弄清楚这个程序的功能，并将其翻译回伪代码吗？
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 4.2 Disassembly Solution
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 反汇编解决方案
- en: 'You can read the code line by line and try to determine the program''s logic,
    but it would be easier if you translate it back to some high-level language. To
    understand the preceding program, let''s use the same logic that was covered previously.
    The preceding code contains four memory references. First, let''s label these
    addresses - `ebp-4=a`, `ebp-8=b` , `ebp-0Ch=c`, and `ebp-10H=d`. After labeling
    the addresses, it translates to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以逐行阅读代码并尝试确定程序的逻辑，但如果将其翻译回某种高级语言，则会更容易。为了理解前述程序，让我们使用之前介绍的相同逻辑。前述代码包含四个内存引用。首先，让我们标记这些地址
    - `ebp-4=a`、`ebp-8=b`、`ebp-0Ch=c`和`ebp-10H=d`。标记地址后，它翻译为以下内容：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s translate the preceding code into a pseudocode (high-level language
    equivalent). The code will as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将上述代码翻译成伪代码（高级语言等效）。代码如下：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replacing all of the register names with their corresponding values on the
    right-hand side of the `=` operator (in other words, at ➊), we get the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有寄存器名称替换为等号右侧（即➊处）的相应值，我们得到以下代码：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After removing all of the entries containing registers on the left-hand side
    of the `=` sign at ➋ (because registers are used for temporary calculations),
    we are left with the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在去除所有左侧含有寄存器的`=`符号处的条目后，我们得到以下代码：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have reduced the eight lines of assembly code to four lines of pseudocode.
    At this point, you can tell that the code performs addition and subtraction operations
    and stores the results. You can determine the variable types based on the sizes
    and how they are used in the code (context), as mentioned earlier. The variables
    `a` and `b` are used in addition and subtraction, so these variables have to be
    of integer data types, and the variables `c` and `d` store the results of integer
    addition and subtraction, so it can be guessed that they are also integer types.
    Now, the preceding code can be written as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已将八行汇编代码简化为四行伪代码。此时，你可以看出代码执行的是加法和减法操作，并将结果存储。你可以根据代码中变量的大小和使用方式（上下文）来推断变量类型，如前所述。变量`a`和`b`用于加法和减法，因此这些变量必须是整数类型，而变量`c`和`d`存储整数加法和减法的结果，因此可以推测它们也是整数类型。现在，前面的代码可以写成如下形式：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you are curious about how the original C program of the disassembled output
    looks, then the following is the original C program to satisfy your curiosity.
    Notice how we were able to write an assembly code back to its equivalent high-level
    language:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对反汇编输出的原始C程序感到好奇，以下是原始的C程序来满足你的好奇心。注意，我们是如何将汇编代码写回到其等效的高级语言中的：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 5\. Bitwise Operations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 位运算
- en: 'In this section, you will learn the assembly instructions that operate on the
    bits. The bits are numbered starting from the far right; the *rightmost bit (least
    significant bit)* has a bit position of `0`, and the bit position increases toward
    the left. The left-most bit is called the *most significant bit*. The following
    is an example showing the bits and the bit positions for a byte, `5D (0101 1101)`.
    The same logic applies to a `word`, `dword`, and `qword`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习操作位的汇编指令。位是从最右侧开始编号的；*最右边的位（最低有效位）*的位位置是`0`，位位置向左增加。最左边的位称为*最高有效位*。以下是一个示例，展示了一个字节`5D
    (0101 1101)`的位及其位位置。相同的逻辑适用于`word`、`dword`和`qword`：
- en: '![](../images/00079.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00079.jpeg)'
- en: 'One of the bitwise instructions is the `not` instruction; it takes only one
    operand (which serves as both the source and destination) and inverts all of the
    bits. If `eax` contained `FF FF 00 00 (11111111 11111111 00000000 00000000)`,
    then the following instruction would invert all of the bits and store it in the `eax`
    register. As a result, the `eax` would contain `00 00 FF FF (00000000 00000000
    11111111 11111111)`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算指令之一是`not`指令；它只需要一个操作数（既作为源操作数又作为目标操作数），并将所有位取反。如果`eax`寄存器包含`FF FF 00 00
    (11111111 11111111 00000000 00000000)`，则以下指令会将所有位取反，并将结果存储在`eax`寄存器中。因此，`eax`寄存器将包含`00
    00 FF FF (00000000 00000000 11111111 11111111)`：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `and`, `or`, and `xor` instructions perform bitwise `and`, `or`, and `xor`
    operations and store the results in the destination. These operations are similar
    to `and (&)`, `or (|)`, and `xor (^)` operations in the C or Python programming
    languages. In the following example, the `and` operation is performed on bit `0`
    of the `bl` register and the bit `0` of `cl`, bit `1` of `bl` and the bit `1`
    of `cl`, and so on. The result is stored in the `bl` register:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`、`or`和`xor`指令执行位与（`and`）、位或（`or`）和位异或（`xor`）操作，并将结果存储到目标位置。这些操作类似于C语言或Python语言中的`and
    (&)`、`or (|)`和`xor (^)`操作。以下示例中，`and`操作会对`bl`寄存器的位`0`和`cl`寄存器的位`0`、`bl`寄存器的位`1`和`cl`寄存器的位`1`等执行操作。结果存储在`bl`寄存器中：'
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, if `bl` contained `5 (0000 0101)` and `cl` contained
    `6 (0000 0110)`, then the result of the `and` operation would be `4 (0000 0100)`,
    as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果`bl`寄存器包含`5 (0000 0101)`，`cl`寄存器包含`6 (0000 0110)`，那么`and`操作的结果将是`4
    (0000 0100)`，如图所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, `or` and `xor` operations are performed on the corresponding bits
    of the operands. The following shows some of the example instructions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`or`和`xor`操作会对操作数的相应位执行操作。以下展示了一些示例指令：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `shr` (shift right) and `shl` (shift left) instructions take two operands
    (the destination and the count). The destination can be either a register or a
    memory reference. The general form is shown as follows. Both of the instructions
    shift the bits in the destination to the right or left by the number of bits specified
    by the count operand; these instructions perform the same operations as `shift
    left (<<)` and `shift right(>>)` in the C or Python programming languages:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`shr`（右移位）和`shl`（左移位）指令需要两个操作数（目标和计数）。目标可以是寄存器或内存引用。其一般形式如下所示。这两条指令将目标中的比特按照计数操作数指定的位数向右或向左移动；这些指令执行的操作与C或Python编程语言中的`shift
    left (<<)`和`shift right(>>)`相同：'
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the following example, the first instruction (`xor eax, eax`) clears the
    `eax` register, after which `4` is moved into the `al` register, and the content
    of the `al` register (which is `4 (0000 0100)`) is shifted left by `2` bits. As
    a result of this operation (the two left-most bits are removed, and the two `0`
    bits are appended to the right), after the operation the `al` register will contain
    `0001 0000` (which is `0x10`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，第一条指令（`xor eax, eax`）清空了`eax`寄存器，随后将`4`移入`al`寄存器，`al`寄存器的内容（即`4 (0000
    0100)`）被左移了`2`位。经过该操作后（最左侧的两个比特被移除，右侧添加了两个`0`比特），操作完成后，`al`寄存器将包含`0001 0000`（即`0x10`）：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For detailed information on how bitwise operators work, refer to [https://en.wikipedia.org/wiki/Bitwise_operations_in_C](https://en.wikipedia.org/wiki/Bitwise_operations_in_C)
    and [https://www.programiz.com/c-programming/bitwise-operators](https://www.programiz.com/c-programming/bitwise-operators).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关位运算符如何工作的详细信息，请参阅[https://en.wikipedia.org/wiki/Bitwise_operations_in_C](https://en.wikipedia.org/wiki/Bitwise_operations_in_C)和[https://www.programiz.com/c-programming/bitwise-operators](https://www.programiz.com/c-programming/bitwise-operators)。
- en: 'The `rol` (rotate left) and `ror` (rotate right) instructions are similar to
    shift instructions. Instead of removing the shifted bits, as with the shift operation,
    they are rotated to the other end. Some of the example instructions are shown
    here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`rol`（左循环移位）和`ror`（右循环移位）指令类似于移位指令。与移位操作不同，它们不会移除被移位的比特，而是将它们旋转到另一端。以下是一些示例指令：'
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, if `al` contained `0x44 (0100 0100)`, then the result
    of the `rol` operation would be `0x11 (0001 0001)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果`al`包含`0x44 (0100 0100)`，则`rol`操作的结果将是`0x11 (0001 0001)`。
- en: 6\. Branching And Conditionals
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 分支与条件语句
- en: 'In this section, we will focus on branching instructions. So far, you have
    seen instructions that execute sequentially; but many times, your program will
    need to execute code at a different memory address (like an `if/else` statement,
    looping, functions, and so on). This is achieved by using branching instructions.
    Branching instructions transfer the control of execution to a different memory
    address. To perform branching, jump instructions are typically used in the assembly
    language. There are two kinds of jumps: *conditional* and *unconditional*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点讨论分支指令。到目前为止，你已经看到了按顺序执行的指令；但是在许多情况下，你的程序需要在不同的内存地址执行代码（如`if/else`语句、循环、函数等）。这可以通过使用分支指令来实现。分支指令将执行控制转移到不同的内存地址。为了进行分支，汇编语言中通常使用跳转指令。跳转分为两种：*条件跳转*和*无条件跳转*。
- en: 6.1 Unconditional Jumps
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 无条件跳转
- en: 'In an *unconditional* jump, the jump is always taken. The `jmp` instruction
    tells the CPU to execute code at a different memory address. This is similar to
    the `goto` statement in the C programming language. When the following instruction
    is executed, the control is transferred to the jump address, and the execution
    starts from there:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在*无条件*跳转中，跳转总是会发生。`jmp`指令告诉CPU去执行不同内存地址的代码。这类似于C语言中的`goto`语句。当执行以下指令时，控制权会转移到跳转地址，并从那里开始执行：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6.2 Conditional Jumps
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 条件跳转
- en: 'In *conditional* jumps, the control is transferred to a memory address based
    on some condition. To use a conditional jump, you need instructions that can alter
    the flags (*set* or *clear*). These instructions can be performing an *arithmetic*
    operation or a *bitwise* operation. The x86 instruction provides the `cmp` instruction,
    which subtracts the *second operand (source operand)* from the *first operand
    (destination operation)* and alters the flags without storing the difference in
    the destination. In the following instruction, if the `eax` contained the value
    `5`, then `cmp eax,5` would set the zero flag (`zf=1`), because the result of
    this operation is zero:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在*条件*跳转中，控制会根据某些条件转移到一个内存地址。要使用条件跳转，你需要能够改变标志（*设置*或*清除*）的指令。这些指令可以执行*算术*操作或*按位*操作。x86
    指令提供了 `cmp` 指令，它将*第二操作数（源操作数）*从*第一操作数（目标操作数）*中减去，并在不将差值存储到目标中的情况下改变标志。在以下指令中，如果
    `eax` 包含值 `5`，那么 `cmp eax,5` 会设置零标志（`zf=1`），因为这次操作的结果为零：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another instruction that alters the flags without storing the result is the
    `test` instruction. The `test` instruction performs a bitwise `and` operation
    and alters the flags without storing the result. In the following instruction,
    if the value of `eax` was zero, then the zero flag would be set (`zf=1`), because
    when you `and` `0` with `0` you get `0`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种改变标志而不存储结果的指令是 `test` 指令。`test` 指令执行按位 `and` 操作，并在不存储结果的情况下改变标志。在以下指令中，如果
    `eax` 的值为零，那么零标志将被设置（`zf=1`），因为当你 `and` `0` 与 `0` 时，结果是 `0`：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Both `cmp` and `test` instructions are normally used along with the conditional
    `jump` instruction for decision making.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 和 `test` 指令通常与条件 `jump` 指令一起使用，用于决策判断。'
- en: 'There are a few variations of conditional jump instructions; the general format
    is shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转指令有几种变体；这里展示了其一般格式：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `cc` in the preceding format represents conditions. These conditions are
    evaluated based on the bits in the `eflags` register. The following table outlines
    the different conditional jump instructions, their aliases, and the bits used
    in the `eflags` register to evaluate the condition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式中的 `cc` 表示条件。这些条件是根据 `eflags` 寄存器中的位来评估的。以下表格列出了不同的条件跳转指令、它们的别名以及用来评估条件的
    `eflags` 寄存器中的位：
- en: '| Instruction | Description | Aliases | Flags |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 | 别名 | 标志 |'
- en: '| `jz` | jump if zero | `je` | `zf=1` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `jz` | 如果为零则跳转 | `je` | `zf=1` |'
- en: '| `jnz` | jump if not zero | `jne` | `zf=0` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `jnz` | 如果不为零则跳转 | `jne` | `zf=0` |'
- en: '| `jl` | jump if less | `jnge` | `sf=1` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `jl` | 如果小于则跳转 | `jnge` | `sf=1` |'
- en: '| `jle` | jump if less or equal | `jng` | `zf=1 or sf=1` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `jle` | 如果小于或等于则跳转 | `jng` | `zf=1 或 sf=1` |'
- en: '| `jg` | jump if greater | `jnle` | `zf=0 and sf=0` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `jg` | 如果大于则跳转 | `jnle` | `zf=0 和 sf=0` |'
- en: '| `jge` | jump if greater or equal  | `jnl` | `sf=0` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `jge` | 如果大于或等于则跳转 | `jnl` | `sf=0` |'
- en: '| `jc` | jump if carry | `jb,jnae` | `cf=1` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `jc` | 如果进位则跳转 | `jb,jnae` | `cf=1` |'
- en: '| `jnc` | jump if not carry | `jnb,jae` | ` .` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `jnc` | 如果无进位则跳转 | `jnb,jae` | ` .` |'
- en: 6.3 If Statement
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 `if` 语句
- en: 'From a reverse engineering perspective, it is important to identify the branching/conditional
    statements. To do that, it is essential to understand how branching/conditional
    statements (like `if, if-else` and `if-else if-else`) are translated into assembly
    language. Let''s look at an example of a simple C program and try to understand
    how the `if` statement is implemented at the assembly level:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从逆向工程的角度来看，识别分支/条件语句非常重要。为了做到这一点，理解分支/条件语句（如 `if`、`if-else` 和 `if-else if-else`）是如何翻译成汇编语言是至关重要的。让我们看一个简单的
    C 程序的例子，并尝试理解 `if` 语句是如何在汇编层面实现的：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding C program, if the condition is true (`if x==0`), the code
    inside the `if` block is executed; otherwise, it will skip the `if` block and
    control is transferred to `x=2`. Think of a *control transfer* as a *jump*. Now,
    ask yourself: When will the jump be taken? The jump will be taken when `x` is
    not equal to `0`. That''s exactly how the preceding code is implemented in assembly
    language (shown as follows); notice that in the first assembly instruction, the
    `x` is compared with `0`, and in the second instruction, the jump will be taken
    to `end_if` when `x` is not equal to `0` (in other words, it will skip `mov dword
    ptr [x],5` and execute `mov dword, ptr[x],2`). Notice how the equal to condition
    (`==`) in the C program was reversed to `not equal to` (`jne`) in the assembly
    language:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的C程序中，如果条件为真（`if x==0`），则执行`if`块内的代码；否则，跳过`if`块，控制转移到`x=2`。可以把*控制转移*理解为*跳转*。现在，问问自己：什么时候会发生跳转？当`x`不等于`0`时就会发生跳转。这正是前述代码在汇编语言中的实现方式（如下所示）；请注意，在第一条汇编指令中，`x`与`0`进行了比较，第二条指令中，当`x`不等于`0`时，将跳转到`end_if`（换句话说，它会跳过`mov
    dword ptr [x],5`并执行`mov dword ptr [x],2`）。请注意，C程序中的相等条件（`==`）在汇编语言中被反转为“不等于”（`jne`）：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following screenshot shows the C programming statements and the corresponding
    assembly instructions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了C语言编程语句和对应的汇编指令：
- en: '![](../images/00080.gif)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00080.gif)'
- en: 6.4 If-Else Statement
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 If-Else 语句
- en: 'Now, let''s try to understand how the `if/else` statement is translated to
    assembly language. Let''s take an example of the following C code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大家一起看看`if/else`语句是如何转换为汇编语言的。我们以以下C代码为例：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, try to determine under what circumstances the jump would
    be taken (control would be transferred). There are two circumstances: the jump
    will be taken to the `else` block if the `x` is not equal to `0`, or, if `x` is
    equal to `0` (`if x == 0`), then after the execution of `x=5` (the end of the `if`
    block), a jump will be taken to bypass the `else` block, to execute the code after
    the `else` block.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，尝试确定在什么情况下会发生跳转（控制会被转移）。有两种情况：如果`x`不等于`0`，跳转到`else`块；或者，如果`x`等于`0`（`if
    x == 0`），那么在执行`x=5`（`if`块的结尾）后，将跳转到跳过`else`块，直接执行`else`块后的代码。
- en: 'The following is the assembly translation of the C program; notice that in
    the first line, the value of `x` is compared with `0`, and the jump (conditional
    jump) will be taken to the `else` block if the `x` is not equal to `0` (the condition
    was reversed, as mentioned previously). Before the `else` block, notice the unconditional
    jump to `end`. This jump ensures that if `x` is equal to `0`, after executing
    the code inside of the `if` block, the `else` block is skipped and the control
    reaches the end:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该C程序的汇编语言翻译；请注意，在第一行中，`x`的值与`0`进行了比较，如果`x`不等于`0`（条件被反转，如前所述），将跳转到`else`块。在`else`块之前，请注意有一个无条件跳转到`end`。这个跳转确保了如果`x`等于`0`，执行完`if`块内的代码后，跳过`else`块并直接到达程序末尾：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 6.5 If-Elseif-Else Statement
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 If-Elseif-Else 语句
- en: 'The following is a C code containing `if-ElseIf-else` statements:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含`if-ElseIf-else`语句的C代码：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From the preceding code, let''s try to determine a situation when jumps (control
    transfers) will be taken. There are two conditional jump points; if `x` is not
    equal to `0`, it will jump to the `else_if` block, and if `x` is not equal to
    `1` (a condition check in `else if`), then the jump is taken to `else`. There
    are also two unconditional jumps: inside the `if` block after `x=5` (the end of
    the `if` block) and inside of the `else if` after `x=6` (the end of the `else
    if` block). Both of these unconditional jumps skip the `else` statement to reach
    the end.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述代码，尝试确定何时会发生跳转（控制转移）。有两个条件跳转点；如果`x`不等于`0`，将跳转到`else_if`块，如果`x`不等于`1`（这是`else
    if`中的条件检查），跳转将发生到`else`。此外，还有两个无条件跳转：在`if`块内`x=5`（`if`块结束时）和在`else if`内`x=6`（`else
    if`块结束时）。这两个无条件跳转跳过了`else`语句，直接到达程序末尾。
- en: 'The following is the translated assembly language showing the conditional and
    unconditional jumps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示条件跳转和无条件跳转的汇编语言翻译：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 6.6 Disassembly Challenge
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 汇编反汇编挑战
- en: 'The following is the disassembled output of a program; let''s translate the
    following code to its high-level equivalent. Use the techniques and the concepts
    that you learned previously to solve this challenge:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的反汇编输出；让我们将以下代码转换为它的高级语言等效形式。运用你之前学到的技术和概念来解决这个挑战：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 6.7 Disassembly Solution
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 反汇编解决方案
- en: 'Let''s start by assigning the symbolic names to the address (`ebp-4`). After
    assigning the symbolic names to the memory address references, we get the following
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从为地址（`ebp-4`）分配符号名称开始。将符号名称分配给内存地址引用后，我们得到以下代码：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, notice the `cmp` and `jnz` instructions at ➊ and ➋ (this
    is a conditional statement) and note that `jnz` is the same as `jne` (`jump if
    not equal to`). Now that we have identified the conditional statement, let''s
    try to determine what type of conditional statement this is (`if`, or `if/else`,
    or `if/else if/else`, and so on); to do that, focus on the jumps. The conditional
    jump at ➋ is taken to `loc_401010C`, and before the `loc_40101C`, there is an
    unconditional jump at ➌ to `loc_401025`. From what we learned previously, this
    has the characteristics of an `if-else` statement. To be precise, the code from ➍ to ➌ is
    part of the `if` block and the code from ➎ to ➏ is part of the `else` block. Let''s
    rename `loc_40101C` to `else` and `loc_401025` to `end` for better readability:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意 ➊ 和 ➋ 处的 `cmp` 和 `jnz` 指令（这是一个条件语句），并注意 `jnz` 与 `jne` 相同（`跳转如果不相等`）。既然我们已经确定了条件语句，让我们尝试确定这是什么类型的条件语句（`if`、`if/else`、`if/else
    if/else` 等等）；为此，请关注跳转。➋ 处的条件跳转跳转到 `loc_401010C`，而在 `loc_40101C` 之前，有一个无条件跳转到 `loc_401025`。根据我们之前学到的知识，这具备了
    `if-else` 语句的特征。准确来说，➍ 到 ➌ 之间的代码是 `if` 块的一部分，而 ➎ 到 ➏ 之间的代码是 `else` 块的一部分。为了提高可读性，我们将
    `loc_40101C` 重命名为 `else`，将 `loc_401025` 重命名为 `end`：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding assembly code, `x` is assigned a value of `1` at ➐; the value
    of `x` is compared with `0`, and if it is equal to `0` (➊ and ➋), the value of
    `x` is `xor` with `2`, and the result is stored in `x` (➍ to ➑). If `x` is not
    equal to `0`, then the value of `x` is `xor` with `3` (➎ to ➏).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的汇编代码中，`x` 在 ➐ 处被赋值为 `1`；`x` 的值与 `0` 比较，如果等于 `0`（➊ 和 ➋），则 `x` 与 `2` 做异或运算，并将结果存储回
    `x`（➍ 到 ➑）。如果 `x` 不等于 `0`，则 `x` 与 `3` 做异或运算（➎ 到 ➏）。
- en: Reading the assembly code is slightly tricky, so let's write the preceding code
    in a high-level language equivalent. We know that ➊ and ➋ is an `if` statement,
    and you can read it as `jump is taken to else, if x is not equal to 0` (remember
    `jnz` is an alias for `jne`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读汇编代码有点复杂，因此让我们将前面的代码写成高级语言的等效代码。我们知道 ➊ 和 ➋ 是一个 `if` 语句，你可以将其理解为“如果 `x` 不等于
    0，则跳转到 `else`” （记住 `jnz` 是 `jne` 的别名）。
- en: 'If you recall, looking at how the C code was translated to assembly, the condition
    in the `if` statement was reversed when translated to assembly code. Since we
    are now looking at the assembly code, to write these statements back to a high-level
    language, you need to reverse the condition. To do that, ask yourself this question, 
    at ➋, when will the jump not be taken?. The jump will not be taken when `x` is
    equal to `0`, so you can write the preceding code to a pseudocode, as follows.
    Note that in the following code, the `cmp` and `jnz` instruction is translated
    to an `if` statement; also, note how the condition is reversed:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想一下，观察 C 代码如何转换为汇编，条件在转换为汇编代码时被反转了。既然我们现在看到的是汇编代码，为了将这些语句写回到高级语言，你需要反转条件。为此，问问自己这个问题：在
    ➋ 处，何时跳转不会发生？跳转不会发生的情况是当 `x` 等于 `0` 时，因此你可以将前面的代码写成伪代码，如下所示。请注意，在以下代码中，`cmp` 和
    `jnz` 指令被转换为一个 `if` 语句；另外，注意条件是如何被反转的：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have identified the conditional statements, next let''s replace
    all of the registers on the right-hand side of the `=` operator (at ➒) with their
    corresponding values. After doing that, we get the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了条件语句，接下来让我们将 `=` 操作符右侧的所有寄存器（在 ➒ 处）替换为它们对应的值。这样做之后，我们得到以下代码：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Removing all of the entries containing the registers on the left-hand side
    of the `=` operator (at ➓), we get the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 移除所有包含在 `=` 操作符左侧的寄存器（在 ➓ 处），我们得到以下代码：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you are curious, the following is the original C program of the disassembled
    output used in the disassembly challenge; compare it with what we got in the preceding
    code snippet. As you can see, we were able to reduce multiple lines of assembly
    code back to their high-level language equivalent. Now, the code is much easier
    to understand, as compared to reading the assembly code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，下面是拆解挑战中使用的原始 C 程序，与你在前面的代码片段中看到的进行比较。正如你所见，我们能够将多行汇编代码还原回它们对应的高级语言代码。现在，相比直接阅读汇编代码，这段代码更容易理解：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 7\. Loops
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 循环
- en: 'Loops execute a block of code until some condition is met. The two most common
    types of loops are `for` and `while`. The jumps and conditional jumps that you
    have seen so far have been jumping forward. The loops jump backward. First, let''s
    understand the functionality of a `for` loop. The general form of a `for` loop
    is shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会执行一段代码，直到某个条件满足为止。最常见的两种循环类型是 `for` 和 `while`。到目前为止，你看到的跳转和条件跳转都是向前跳转，而循环是向后跳转的。首先，让我们理解
    `for` 循环的功能。`for` 循环的一般形式如下所示：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here's how the `for` statement works. The `initialization` statement is executed
    only once, after which the `condition` is evaluated; if the condition is true,
    the block of code inside the `for` loop is executed, and then the `update_statement`
    is executed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `for` 语句的工作原理。`initialization` 语句只执行一次，之后会评估 `condition`；如果条件为真，则执行 `for`
    循环内部的代码块，然后执行 `update_statement`。
- en: 'A `while` loop is the same as a `for` loop. In `for`, the `initialization`,
    `condition`, and `update_statment` are specified together, whereas in a `while`
    loop, the `initialization` is kept separate from the `condition` check, and the
    `update_statement` is specified inside the loop. The general form of a `while`
    loop is shown here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 `for` 循环相同。在 `for` 循环中，`initialization`、`condition` 和 `update_statment`
    一起指定，而在 `while` 循环中，`initialization` 与 `condition` 检查是分开的，并且 `update_statement`
    在循环内部指定。`while` 循环的一般形式如下所示：'
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s try to understand how the loop is implemented at the assembly level
    with the help of the following code snippet from a simple C program:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下来自简单 C 程序的代码片段，了解循环在汇编级别是如何实现的：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code can be written using a `while` loop, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以使用 `while` 循环来编写，如下所示：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We know that a jump is used to implement conditionals and loops, so let's think
    in terms of jumps. In the `while` and `for` loops, let's try to determine all
    the situations when the jumps will be taken. In both cases, when `i` becomes greater
    than or equal to `5`, a jump will be taken, which will transfer the control outside
    of the loop (in other words, after the loop). When `i` is less than `5`, the code
    inside the `while` loop is executed and after `i++` backward jump will be taken,
    to check the condition.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，跳转用于实现条件和循环，因此让我们从跳转的角度来思考。在 `while` 和 `for` 循环中，我们试图确定所有会导致跳转的情况。在这两种情况下，当
    `i` 大于或等于 `5` 时，跳转会发生，控制会转移到循环外（换句话说，跳到循环之后）。当 `i` 小于 `5` 时，`while` 循环内部的代码会执行，且在执行
    `i++` 后会进行向后的跳转，以再次检查条件。
- en: 'This is how the preceding code is implemented in assembly language (shown as
    follows). In the following assembly code, at ➊, notice a backward jump to an address
    (labeled as `while_start`); this indicates a loop. Inside of the loop, the condition
    is checked at ➋ and ➌ by using `cmp` and `jge` (jump if greater than or equal
    to) instructions; here, the code is checking if `i` is greater than or equal to
    `5`. If this condition is met, then the jump is taken to `end` (outside of the
    loop). Notice how the `less than` (`<`) condition in C programming is reversed
    to `greater than or equal to` (`>=`) at ➌, using the `jge` instruction. The initialization
    is performed at ➍, where `i` is assigned the value of `0`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码在汇编语言中的实现方式（如下所示）。在下面的汇编代码中，在 ➊ 处，注意有一个跳转到某个地址（标记为 `while_start`）；这表示一个循环。在循环内部，条件在
    ➋ 和 ➌ 通过使用 `cmp` 和 `jge`（如果大于或等于则跳转）指令进行检查；这里的代码在检查 `i` 是否大于或等于 `5`。如果满足该条件，则跳转到
    `end`（跳出循环）。注意，在 ➌ 处，C 语言中的 `小于` (`<`) 条件通过 `jge` 指令被反转为 `大于或等于` (`>=`)。初始化在 ➍
    处进行，其中 `i` 被赋值为 `0`：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following diagram shows the C programming statements and the corresponding
    assembly instructions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 C 编程语句和对应的汇编指令：
- en: '![](../images/00081.gif)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00081.gif)'
- en: 7.1 Disassembly Challenge
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 拆解挑战
- en: 'Let''s translate the following code into its high-level equivalent. Use the
    techniques and the concepts that you have learned so far to solve this challenge:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码转换为其高级等效代码。使用你到目前为止学到的技术和概念来解决这个挑战：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 7.2 Disassembly Solution
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 反汇编解决方案
- en: 'The preceding code consists of two memory addresses (`ebp-4` and `ebp-8`);
    let''s rename `ebp-4` to `x` and `ebp-8` to `y`. The modified code is shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含两个内存地址（`ebp-4`和`ebp-8`）；我们将`ebp-4`重命名为`x`，将`ebp-8`重命名为`y`。修改后的代码如下所示：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding code, at ➊, there is a backward jump to `loc_401014`, indicating
    a loop; so, let''s rename `loc_401014` to `loop`. At ➋ and ➌, there is a condition
    check for the variable `x` (using `cmp` and `jge`); the code is checking whether `x`
    is greater than or equal to `4`. If the condition is met, it will jump outside
    of the loop to `loc_40102E` (at ➍). The value of `x` is incremented to `1` (from ➎ to ➏),
    which is the update statement. Based on all of this information, it can be deduced
    that `x` is the loop variable that controls the loop. Now, we can write the preceding
    code to a high-level language equivalent; but to do that, remember that we need
    to reverse the condition from `jge`  (`jump if greater than or equal to`) to `jump
    if less than`. After the changes, the code looks as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在➊处，有一个跳转到`loc_401014`的操作，表示这是一个循环；因此，我们将`loc_401014`重命名为`loop`。在➋和➌处，检查变量`x`的条件（使用`cmp`和`jge`）；代码在检查`x`是否大于或等于`4`。如果条件成立，它将跳出循环，跳转到`loc_40102E`（在➍处）。`x`的值会增加`1`（从➎到➏），这就是更新语句。基于这些信息，可以推测`x`是控制循环的循环变量。现在，我们可以将前面的代码写成高级语言的等效代码；但为了做到这一点，记住我们需要将条件从`jge`（`大于或等于时跳转`）反转为`小于时跳转`。修改后的代码如下所示：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Replacing all of the registers on the right-hand side of the `=` operator (at
    ➐) with their previous values, we get the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将`=`运算符右侧的所有寄存器（在➐处）替换为它们之前的值，我们得到以下代码：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, removing all of the entries containing registers on the left-hand side
    of the `=` sign (at ➑), we get the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去除所有在`=`符号左侧包含寄存器的条目（在➑处），我们得到以下代码：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you are curious, the following is the original C program of the disassembled
    output. Compare the preceding code that we determined with the code that follows
    from the original program; notice how it was possible to reverse engineer and
    decompile the disassembled output to its original equivalent:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到好奇，以下是反汇编输出的原始C程序。比较我们之前确定的代码和下面来自原始程序的代码；注意到如何逆向工程并反编译反汇编输出到其原始等效代码：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 8\. Functions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 函数
- en: 'A function is a block of code that performs specific tasks; normally, a program
    contains many functions. When a function is called, the control is transferred
    to a different memory address. The CPU then executes the code at that memory address,
    and it comes back (control is transferred back) after it finishes running the
    code. The function contains multiple components: a function can take data as input
    via parameters, it has a body that contains the code it executes, it contains
    local variables that are used to temporarily store values, and it can output data.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个执行特定任务的代码块；通常，程序包含许多函数。当调用一个函数时，控制权会转移到不同的内存地址。然后，CPU执行该内存地址处的代码，并在代码执行完毕后返回（控制权转移回来）。函数包含多个组成部分：函数可以通过参数接收数据作为输入，具有包含执行代码的函数体，包含用于临时存储值的局部变量，并且可以输出数据。
- en: The parameters, local variables, and function flow controls are all stored in
    an important area of the memory called the *stack*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、局部变量和函数控制流都存储在内存中的一个重要区域——*栈*。
- en: 8.1 Stack
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 栈
- en: 'The stack is an area of the memory that gets allocated by the operating system
    when the thread is created. The stack is organized in a *Last-In-First-Out (LIFO)*
    structure, which means that the most recent data that you put in the stack will
    be the first one to be removed from the stack. You put data (called *pushing*)
    onto the stack by using the `push` instruction, and you remove data (called *popping*)
    from the stack using the `pop` instruction. The `push` instruction pushes a *4-byte*
    value onto the stack, and the `pop` instruction pops a *4-byte* value from the
    top of the stack. The general forms of the `push` and `pop` instructions are shown
    here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是操作系统在创建线程时分配的一块内存区域。栈是以 *后进先出（LIFO）* 的结构组织的，这意味着你压入栈中的最新数据将是第一个从栈中移除的数据。你通过使用
    `push` 指令将数据（称为 *压栈*）压入栈中，使用 `pop` 指令从栈中移除数据（称为 *弹栈*）。`push` 指令将一个 *4字节* 的值压入栈中，`pop`
    指令从栈顶弹出一个 *4字节* 的值。`push` 和 `pop` 指令的通用形式如下所示：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The stack grows from higher addresses to lower addresses. This means when a
    stack is created, the `esp` register (also called the *stack pointer*) points
    to the top of the stack (higher address), and as you `push` data into the stack,
    the `esp` register decrements by `4` (`esp-4`) to a lower address. When you `pop`
    a value, the `esp` increments by `4` (`esp+4`). Let''s look at the following assembly
    code and try to understand the inner workings of the stack:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是从高地址增长到低地址的。这意味着，当栈被创建时，`esp` 寄存器（也称为 *栈指针*）指向栈顶（高地址），随着你使用 `push` 指令将数据压入栈中，`esp`
    寄存器会减少 `4`（`esp-4`）指向一个更低的地址。当你使用 `pop` 指令弹出一个值时，`esp` 会增加 `4`（`esp+4`）。让我们看看以下汇编代码，尝试理解栈的内部运作：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before executing the preceding instructions, the `esp` register points to the
    top of the stack (for example, at address `0xff8c`), as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述指令之前，`esp` 寄存器指向栈顶（例如，地址为 `0xff8c`），如图所示：
- en: '![](../images/00082.gif)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00082.gif)'
- en: 'After the first instruction is executed (`push 3`), `ESP` is decremented by
    `4` (because the `push` instruction pushes a *4-byte* value onto the stack), and
    the value `3` is placed on the stack; now, `ESP` points to the top of the stack
    at `0xff88`. After the second instruction (`push 4`), `esp` is decremented by
    `4`; now, `esp` contains `0xff84`, which is now the top of the stack. When `pop
    ebx` is executed, the value `4` from the top of the stack is moved to the `ebx`
    register, and `esp` is incremented by `4` (because `pop` removes a *4-byte* value
    from the stack). So, `esp` now points to the stack at `0xff88`. Similarly, when
    the `pop edx` instruction is executed, the value `3` from the top of the stack
    is placed in the `edx` register, and `esp` comes back to its original position
    at `0xff8c`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行第一条指令（`push 3`）后，`ESP` 被减去 `4`（因为 `push` 指令将一个 *4字节* 的值压入栈中），并且值 `3` 被放入栈中；此时，`ESP`
    指向栈顶，地址为 `0xff88`。执行第二条指令（`push 4`）后，`esp` 再次减去 `4`；此时，`esp` 的值为 `0xff84`，它现在是栈顶。当执行
    `pop ebx` 时，栈顶的值 `4` 被移到 `ebx` 寄存器中，`esp` 增加了 `4`（因为 `pop` 从栈中移除一个 *4字节* 的值）。因此，`esp`
    此时指向栈顶，地址为 `0xff88`。同样地，当执行 `pop edx` 指令时，栈顶的值 `3` 被放入 `edx` 寄存器中，`esp` 返回到原来的位置
    `0xff8c`：
- en: '![](../images/00083.gif)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00083.gif)'
- en: In the preceding diagram, the values popped from the stack are physically still
    present in memory, even though they are logically removed. Also, notice how the
    most recently pushed value (`4`) was the first to be removed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，虽然栈中的值从逻辑上被移除，但它们在内存中物理上仍然存在。而且，注意到最近压入的值（`4`）是第一个被移除的。
- en: 8.2 Calling Function
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 调用函数
- en: 'The `call` instruction in the assembly language can be used to call a function.
    The general form of the `call` looks as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中的 `call` 指令可以用来调用一个函数。`call` 指令的通用形式如下所示：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: From a code analysis perspective, think of `some_function` as an address containing
    a block of code. When the `call` instruction is executed, the control is transferred
    to `some_function` (a block of code), but before that, it stores the address of
    the next instruction (the instruction following `call <some_function>`) by pushing
    it onto the stack. The address following the `call` which is pushed onto the stack
    is called the *return address*. Once `some_function` finishes executing, the return
    address that was stored on the stack is popped from the stack, and the execution
    continues from the popped address.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码分析的角度来看，可以将`some_function`视为一个包含代码块的地址。当执行`call`指令时，控制权转移到`some_function`（一个代码块），但在此之前，它会通过将下一个指令的地址（即`call
    <some_function>`后面的指令）推入堆栈来保存该地址。推入堆栈的`call`指令后的地址被称为*返回地址*。一旦`some_function`执行完毕，存储在堆栈上的返回地址会从堆栈中弹出，执行将从弹出的地址继续。
- en: 8.3 Returning From Function
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 从函数返回
- en: In assembly language, to return from a function, you use the `ret` instruction.
    This instruction pops the address from the top of the stack; the popped address
    is placed in the `eip` register, and the control is transferred to the popped
    address.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，要从函数返回，使用`ret`指令。该指令从堆栈顶端弹出地址；弹出的地址会被放入`eip`寄存器中，然后控制权转移到该弹出的地址。
- en: 8.4 Function Parameters And Return Values
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 函数参数和返回值
- en: In the `x86` architecture, the parameters that a function accepts are pushed
    onto the stack, and the return value is placed in the `eax` register.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`x86`架构中，函数接受的参数会被推入堆栈中，返回值则放置在`eax`寄存器中。
- en: 'In order to understand the function, let''s take an example of a simple C program.
    When the following program is executed, the `main()` function calls the `test`
    function and passes two integer arguments: `2` and `3`. Inside the `test` function,
    the value of arguments is copied to the local variables `x` and `y`, and the `test`
    returns a value of `0` (`return value`):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个函数，让我们以一个简单的C程序为例。当执行以下程序时，`main()`函数调用`test`函数并传递两个整数参数：`2`和`3`。在`test`函数内部，参数的值被复制到局部变量`x`和`y`中，并且`test`返回一个值`0`（`返回值`）：
- en: '[PRE68]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'First, let''s see how the statements inside the `main()` function are translated
    into assembly instructions:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`main()`函数中的语句如何被翻译成汇编指令：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The first three instructions, ➊, ➋, and ➌, represent the function call `test(2,3)`.
    The arguments (`2` and `3`) are pushed onto the stack before the function call
    in the reverse order (from right to left), and the second argument, `3`, is pushed
    before the first argument, `2`. After pushing the arguments, the function, `test()`,
    is called at ➌; as a result, the address of the next instruction, `add esp,8`,
    is pushed onto the stack (this is the *return address*), and then the control
    is transferred to the start address of the `test` function. Let''s assume that
    before executing the instructions ➊, ➋, ➌, the `esp` (stack pointer) was pointing
    to the top of the stack at the address `0xFE50`. The following diagram depicts
    what happens before and after executing  ➊, ➋, and ➌:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 前三条指令，➊、➋和➌，表示函数调用`test(2,3)`。参数（`2`和`3`）在函数调用之前按反向顺序（从右到左）推入堆栈，第二个参数`3`在第一个参数`2`之前被推入堆栈。推送参数后，函数`test()`在➌处被调用；结果，下一个指令`add
    esp,8`的地址被推入堆栈（这就是*返回地址*），然后控制权转移到`test`函数的起始地址。假设在执行指令➊、➋、➌之前，`esp`（栈指针）指向堆栈顶部的地址`0xFE50`。以下图示展示了执行➊、➋、➌前后发生的情况：
- en: '![](../images/00084.gif)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00084.gif)'
- en: 'Now, let''s focus on the `test` function, as shown here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们聚焦于`test`函数，如下所示：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following is the assembly translation of the `test` function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`test`函数的汇编语言翻译：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The first instruction ➍ saves the `ebp` (also called the *frame pointer*) on
    the stack; this is done so that it can be restored when the function returns.
    As a result of pushing the value of `ebp` onto the stack, the `esp` register will
    be decremented by `4`. In the next instruction, at ➎, the value of `esp` is copied
    into `ebp`; as a result, both `esp` and `ebp` point at the top of the stack, shown
    as follows. The `ebp` from now on will be kept at a fixed position, and the application
    will use `ebp` to reference function arguments and the local variables:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令➍将`ebp`（也叫*帧指针*）保存在堆栈中；这样做是为了在函数返回时能够恢复它。由于将`ebp`的值压入堆栈，`esp`寄存器将减少`4`。在下一条指令（➎）中，`esp`的值被复制到`ebp`中；因此，`esp`和`ebp`都指向堆栈的顶部，如下所示。从现在开始，`ebp`将保持在固定位置，应用程序将使用`ebp`来引用函数参数和局部变量：
- en: '![](../images/00085.gif)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00085.gif)'
- en: You will normally find `push ebp` and `mov ebp, esp` at the start of most functions;
    these two instructions are called *function prologue*. These instructions are
    responsible for setting up the environment for the function. At ➏ and ➐, the two
    instructions (`mov esp,ebp` and `pop ebp`) perform the reverse operation of *function
    prologue*. These instructions are called *function epilogue*, and they restore
    the environment after the function is executed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会在大多数函数的开始找到`push ebp`和`mov ebp, esp`这两条指令；这两条指令被称为*函数前导*。这些指令负责为函数设置环境。在➏和➐处，两个指令（`mov
    esp,ebp`和`pop ebp`）执行*函数前导*的逆操作。这些指令被称为*函数尾部*，它们在函数执行完毕后恢复环境。
- en: 'At ➑, `sub esp,8` further decrements the `esp` register. This is done to allocate
    space for the local variables (`x` and `y`). Now, the stack looks as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在➑处，`sub esp,8`进一步减少了`esp`寄存器的值。这样做是为了为局部变量（`x`和`y`）分配空间。现在，堆栈看起来如下所示：
- en: '![](../images/00086.gif)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00086.gif)'
- en: Notice that the `ebp` is still at a fixed position, and function arguments can
    be accessed at a positive offset from `ebp` (`ebp + some value`). The local variables
    can be accessed at a negative offset from `ebp` (`ebp - some value`). For example,
    in the preceding diagram, the first argument (`2`) can be accessed at the address
    `ebp+8` (which is the value of `a`), and the second argument can be accessed at
    the address `ebp+0xc` (which is the value of `b`). The local variables can be
    accessed at the addresses `ebp-4` (local variable `x`) and `ebp-8` (local variable
    `y`).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ebp`仍然位于固定位置，函数参数可以通过从`ebp`的正偏移量来访问（`ebp + 某个值`）。局部变量可以通过从`ebp`的负偏移量来访问（`ebp
    - 某个值`）。例如，在上图中，第一个参数（`2`）可以通过地址`ebp+8`访问（即`a`的值），第二个参数可以通过地址`ebp+0xc`访问（即`b`的值）。局部变量可以通过地址`ebp-4`（局部变量`x`）和`ebp-8`（局部变量`y`）访问。
- en: Most compilers (such as Microsoft Visual C/C++ compiler) make use of fixed `ebp`
    based stack frames to reference the function arguments and the local variables.
    The GNU compilers (such as gcc) do not use `ebp` based stack frames by default,
    but they make use of a different technique, where the `ESP` (stack pointer) register
    is used to reference the function parameters and local variables.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器（如微软的Visual C/C++编译器）使用基于固定`ebp`的堆栈帧来引用函数参数和局部变量。GNU编译器（如gcc）默认不使用基于`ebp`的堆栈帧，但它们使用一种不同的技术，其中使用`ESP`（堆栈指针）寄存器来引用函数参数和局部变量。
- en: 'The actual code inside of the function is between ➑ and ➏, which is shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部的实际代码位于➑和➏之间，如下所示：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can rename the argument `ebp+8` as `a` and `ebp+0Ch` as `b`. The address `ebp-4` can
    be renamed as the variable `x`, and `ebp-8` as the variable `y`, as shown here:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将参数`ebp+8`重命名为`a`，将`ebp+0Ch`重命名为`b`。地址`ebp-4`可以重命名为变量`x`，`ebp-8`重命名为变量`y`，如下所示：
- en: '[PRE73]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using the techniques covered previously, the preceding statements can be translated
    to the following pseudocode:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面讲解的技巧，以上语句可以翻译为以下伪代码：
- en: '[PRE74]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At ➒, `xor eax,eax` sets the value of `eax` to `0`. This is the return value
    (`return 0`). The return value is always stored in the `eax` register. The *function
    epilogue* instructions at ➏ and ➐ restore the function environment. The instruction
    `mov esp,ebp` at ➏ copies the value of `ebp` into `esp`; as a result, `esp` will
    point to the address where `ebp` is pointing. The `pop ebp` at ➐ restores the
    old `ebp` from the stack; after this operation, `esp` will be incremented by `4`.
    After the execution of the instructions at ➏ and ➐, the stack will look like the
    one shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在➒处，`xor eax,eax`将`eax`的值设置为`0`。这是返回值（`return 0`）。返回值总是存储在`eax`寄存器中。在➏和➐处的*函数尾部*指令恢复了函数环境。➏处的指令`mov
    esp,ebp`将`ebp`的值复制到`esp`中；结果，`esp`将指向`ebp`所指向的地址。➐处的`pop ebp`从栈中恢复旧的`ebp`；此操作后，`esp`将增加`4`。执行完➏和➐处的指令后，栈的状态如下所示：
- en: '![](../images/00087.gif)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00087.gif)'
- en: 'At ➓, when the `ret` instruction is executed, the return address on top of
    the stack is popped out and placed in the `eip` register. Also, the control is
    transferred to the return address (which is `add esp,8` in the `main` function).
    As a result of popping the return address, `esp` is incremented by `4`.  At this
    point, the control is returned to the `main` function from the `test` function.
    The instruction `add esp,8` inside of `main` cleans up the stack, and the `esp`
    is returned  to its original position (the address `0xFE50`, from where we started),
    as follows. At this point, all of the values on the stack are logically removed,
    even though they are physically present. This is how the function works:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在➓处，当执行`ret`指令时，栈顶的返回地址被弹出并放入`eip`寄存器中。同时，控制转移到返回地址（即`main`函数中的`add esp,8`）。由于弹出了返回地址，`esp`增加了`4`。此时，控制从`test`函数返回到`main`函数。`main`中的指令`add
    esp,8`清理了栈，`esp`被恢复到其原始位置（地址`0xFE50`，即我们开始的地方），如下所示。此时，栈上的所有值从逻辑上被移除，尽管它们在物理上仍然存在。函数的工作原理就是如此：
- en: '![](../images/00088.gif)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00088.gif)'
- en: In the previous example, the `main` function called the `test` function and
    passed the parameters to the `test` function by pushing them onto the stack (in
    the right-to-left order). The `main` function is known as the *caller* (or the
    *calling function*) and `test` is the *callee* (or the *called functio*n). The
    `main` function (caller), after the function call, cleaned up the stack using
    `add esp,8` instruction. This instruction has the effect of removing the parameters
    that were pushed onto the stack and adjusts the stack pointer (`esp`) back to
    where it was before the function call; such a function is said to be using `cdecl`
    calling convention. The calling convention dictates how the parameters should
    be passed and who (*caller* or the *callee*) is responsible for removing them
    from the stack once the called function has completed. Most of the compiled C
    programs typically follow the `cdecl` calling convention. In the `cdecl` convention,
    the *caller* pushes the parameters in the right-to-left order on the stack and
    the *caller* itself cleans up the stack after the function call. There are other
    calling conventions such as `stdcall` and `fastcall`. In `stdcall`, parameters
    are pushed onto the stack (right-to-left order) by the *caller* and the *callee,*
    (*called function*) is responsible for cleaning up the stack. Microsoft Windows
    utilizes the `stdcall` convention for the functions (API) exported by the DLL
    files. In the `fastcall` calling convention, first few parameters are passed to
    a function by placing them in the registers, and any remaining parameters are
    placed on the stack in right-to-left order and the *callee* cleans up the stack
    similar to the `stdcall` convention. You will typically see 64-bit programs following
    the `fastcall` calling convention.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，`main`函数调用了`test`函数，并通过将参数压入栈中（从右到左的顺序）传递给了`test`函数。`main`函数被称为*调用者*（或*调用函数*），而`test`是*被调用者*（或*被调用函数*）。`main`函数（调用者）在函数调用后，通过执行`add
    esp,8`指令清理栈。该指令的作用是移除压入栈中的参数，并将栈指针（`esp`）恢复到函数调用前的位置；这样的函数被认为使用了`cdecl`调用约定。调用约定决定了如何传递参数以及在被调用函数完成后，谁（*调用者*或*被调用者*）负责从栈中移除这些参数。大多数编译后的C程序通常遵循`cdecl`调用约定。在`cdecl`约定中，*调用者*将参数按从右到左的顺序压入栈中，且*调用者*在函数调用后负责清理栈。还有其他的调用约定，如`stdcall`和`fastcall`。在`stdcall`中，参数由*调用者*按从右到左的顺序压入栈中，且*被调用者*（*被调用函数*）负责清理栈。微软Windows利用`stdcall`约定来处理DLL文件导出的函数（API）。在`fastcall`调用约定中，前几个参数通过放入寄存器传递给函数，剩余的参数则按从右到左的顺序压入栈中，*被调用者*类似于`stdcall`约定负责清理栈。你通常会看到64位程序遵循`fastcall`调用约定。
- en: 9\. Arrays And Strings
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 数组与字符串
- en: 'An array is a list consisting of the same data types. The array elements are
    stored in contiguous locations in the memory, which makes it easy to access array
    elements. The following defines an integer array of three elements, and each element
    of this array occupies 4 bytes in the memory (because an integer is 4 bytes in
    length):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是由相同数据类型组成的列表。数组元素存储在内存中的连续位置，这使得访问数组元素变得非常方便。以下定义了一个包含三个元素的整数数组，数组的每个元素在内存中占用4个字节（因为一个整数是4个字节长）：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The array name `nums` is a pointer constant that points to the first element
    of the array (that is, the array name points to the `base address` of the array).
    In a high-level language, to access the elements of the array, you use the array
    name along with the `index`. For example, you can access the first element using
    `nums[0]`, the second element using `nums[1]`, and so on:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 数组名称`nums`是一个指向数组第一个元素的常量指针（也就是说，数组名称指向数组的`基地址`）。在高级语言中，访问数组元素时，你可以使用数组名称和`索引`。例如，你可以通过`nums[0]`访问第一个元素，通过`nums[1]`访问第二个元素，以此类推：
- en: '![](../images/00089.gif)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00089.gif)'
- en: 'In assembly language, the address of any element in the array is computed using
    three things:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，数组中任何元素的地址是通过三样东西计算得出的：
- en: The base address of the array
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的基地址
- en: The index of the element
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的索引
- en: The size of each element in the array
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中每个元素的大小
- en: 'When you use `nums[0]` in a high-level language, it is translated to `[nums+0*<size_of_each_element_in_bytes>]`,
    where `0` is the index and `nums` represents the base address of the array. From
    the preceding example, you can access the elements of the integer array (the size
    of each element is 4 bytes) as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在高级语言中使用 `nums[0]` 时，它被翻译为 `[nums+0*<每个元素的字节大小>]`，其中 `0` 是索引，`nums` 表示数组的基址。从前面的例子中，你可以按如下方式访问整型数组的元素（每个元素的大小为
    4 字节）：
- en: '[PRE76]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A general form for the `nums` integer array can be represented as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`nums` 整型数组的一般形式可以表示如下：'
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following shows the general format for accessing the elements of an array:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了访问数组元素的一般格式：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 9.1 Disassembly Challenge
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 反汇编挑战
- en: 'Translate the following code to its high-level equivalent. Use the techniques
    and the concepts that you have learned so far to solve this challenge:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码翻译为其高级等价形式。使用你目前为止学到的技巧和概念来解决这个挑战：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 9.2 Disassembly Solution
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 反汇编解决方案
- en: 'In the preceding code, the first two instructions (`push ebp` and `mov ebp,
    esp`) represent *function prologue*. Similarly, the two lines before the last
    instruction, `ret`, represent the *function epilogue* (`mov esp,ebp` and `pop
    ebp`). We know that the *function prologue* and *epilogue* are not part of the
    code, but they are used to set up the environment for the function, and hence
    they can be removed to simplify the code. The third instruction, `sub,14h`, suggests
    that `20 (14h)` bytes are allocated for local variables; we know that this instruction
    is also not part of the code (it''s just used for allocating space for local variables),
    and can also be ignored. After removing the instructions that are not part of
    the actual code, we are left with the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，前两条指令（`push ebp` 和 `mov ebp, esp`）代表了*函数序言*。类似地，倒数第二条指令前的两行（`mov esp,ebp`
    和 `pop ebp`）代表了*函数尾声*。我们知道，*函数序言*和*尾声*并不是代码的核心部分，但它们用于为函数设置环境，因此可以移除以简化代码。第三条指令，`sub,14h`，表明为局部变量分配了`20
    (14h)`字节空间；我们知道，这条指令同样不是代码的一部分（它只是用于为局部变量分配空间），也可以忽略。去除这些不属于实际代码的指令后，我们得到以下内容：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The backward jump at ➊, to `loc_401022`, indicates the loop, and the code between
    ➊ and ➋ is the part of the loop. Let's identify the `loop variable`, the `loop
    initialization`, the `condition check`, and the `update statement`. The two instructions
    at ➌ is a condition check that is checking whether the value of `[ebp-4]` is `greater
    than or equal to` `3`; when this condition is met, a jump is taken outside of
    the loop. The same variable, `[ebp-4]`, is initialized to `0` at ➍ before the
    condition check at ➌, and the variable is incremented using the instructions at
    ➎. All of these details suggest that `ebp-4` is the loop variable, so we can rename `ebp-4`
    as `i` (`ebp-4=i`).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处的回退跳转到 `loc_401022` 表示循环，➊ 和 ➋ 之间的代码是循环的一部分。让我们来识别 `循环变量`、`循环初始化`、`条件检查`
    和 `更新语句`。在 ➌ 处的两条指令是条件检查，它检查 `[ebp-4]` 的值是否 `大于或等于` `3`；当此条件满足时，跳转到循环外部。同样的变量
    `[ebp-4]` 在 ➍ 处被初始化为 `0`，并在 ➎ 处使用指令进行递增。所有这些细节表明，`ebp-4` 是循环变量，因此我们可以将 `ebp-4`
    重命名为 `i`（`ebp-4=i`）。
- en: At ➏, the instruction `[ebp+eax*4-14h]` represents array access. Let's try to
    identify the components of the array (the `base address`, `index`, and the `size`
    of each element). We know that local variables (including elements of an array)
    are accessed as `ebp-<somevalue>` (in other words, the negative offset from `ebp`),
    so we can rewrite `[ebp+eax*4-14h]` as `[ebp-14h+eax*4]`. Here, `ebp-14h` represents
    the base address of the array on the stack, `eax` represents the `index`, and
    `4` is the size of each element of the array. Since `ebp-14h` is the base address,
    which means this address also represents the first element of the array, if we
    assume the array name is `val`, then `ebp-14h = val[0]`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏ 处，指令 `[ebp+eax*4-14h]` 代表数组访问。我们来尝试识别数组的各个组成部分（`基址`、`索引`和每个元素的`大小`）。我们知道，局部变量（包括数组元素）是通过
    `ebp-<某个值>`（即 `ebp` 的负偏移量）来访问的，因此我们可以将 `[ebp+eax*4-14h]` 重写为 `[ebp-14h+eax*4]`。这里，`ebp-14h`
    表示数组在栈上的基址，`eax` 表示 `索引`，而 `4` 是数组每个元素的大小。由于 `ebp-14h` 是基址，意味着该地址也代表数组的第一个元素，如果我们假设数组名为
    `val`，那么 `ebp-14h = val[0]`。
- en: 'Now that we have determined the first element of the array, let''s try to find
    the other elements. From the array notation,  in this case, we know that the size
    of each element is `4` bytes. So, if `val[0] = ebp-14h`, then `val[1]` should
    be at the next highest address, which is `ebp-10h`, and `val[2]` should be at
    `ebp-0Ch`, and so on. Notice that `ebp-10h` and `ebp-0Ch` are referenced at ➐
    and ➑. Let''s rename `ebp-10h` as `val[1]` and `ebp-14h` as `val[2]`. We still
    haven''t figured out how many elements this array contains. First, let''s replace
    all of the determined values and write the preceding code in a high-level language
    equivalent. The last two instructions, `xor eax,eax` and `ret`, can be written
    as `return 0`, so the pseudocode now looks as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了数组的第一个元素，接下来让我们尝试找出其他元素。从数组表示法来看，在这种情况下，我们知道每个元素的大小是`4`字节。所以，如果`val[0]
    = ebp-14h`，那么`val[1]`应该位于下一个更高的地址，即`ebp-10h`，`val[2]`应该在`ebp-0Ch`，依此类推。注意到`ebp-10h`和`ebp-0Ch`在➐和➑处被引用。我们将`ebp-10h`重命名为`val[1]`，将`ebp-14h`重命名为`val[2]`。我们仍然没有弄清楚这个数组包含多少个元素。首先，让我们替换所有已确定的值，并将前面的代码写成高级语言等效的形式。最后两条指令`xor
    eax,eax`和`ret`可以写为`return 0`，所以伪代码现在如下所示：
- en: '[PRE81]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Replacing all of the register names on the right-hand side of the `=` operator
    at ➒ with their corresponding values, we will get the following code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在➒处，将所有在`=`运算符右侧的寄存器名称替换为其对应的值，我们将得到以下代码：
- en: '[PRE82]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Removing all of the entries containing register names on the left-hand side
    of the `=` operator at ➓, we get the following code:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 删除在➓处`=`运算符左侧包含寄存器名称的所有条目，我们得到以下代码：
- en: '[PRE83]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: From what we learned previously, when we access an element of the integer array
    using `nums[0]`, it is the same as `[nums+0*4]`, and `nums[1]` is the same as
    `[nums+1*4]`, which means that the general form of `nums[i]` can be represented
    as `[nums+i*4]` that is, `nums[i] = [nums+i*4]`. Going by that logic, we can replace
    `[val+i*4]` with `val[i]` in the preceding code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前学到的知识，当我们使用`nums[0]`访问整数数组的元素时，它与`[nums+0*4]`是一样的，`nums[1]`与`[nums+1*4]`是一样的，这意味着`nums[i]`的一般形式可以表示为`[nums+i*4]`，也就是`nums[i]
    = [nums+i*4]`。根据这个逻辑，我们可以在前面的代码中将`[val+i*4]`替换为`val[i]`。
- en: 'Now, we are left with the address `ebp-8` in the preceding code; this could
    be a local variable, or it could be the fourth element in the array `val[3]` (it''s
    really hard to say). If we assume it as a local variable and rename `ebp-8` as
    `x` (`ebp-8=x`), then the resultant code will look as shown below. From the following
    code, we can tell that the code probably iterates through each element of the
    array (using the index variable `i`) and assigns the value to the variable `x`.
    From the code, we can gather one extra piece of information: if the index `i` was
    used for iterating through each element of the array, then we can guess that the
    array probably has three elements (because the index `i` takes a maximum value
    of `2` before exiting the loop):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在前面的代码中剩下了地址`ebp-8`；这可能是一个局部变量，也可能是数组`val[3]`的第四个元素（很难说）。如果我们假设它是局部变量，并将`ebp-8`重命名为`x`（`ebp-8=x`），那么得到的代码将如下所示。从以下代码中，我们可以看出，代码可能在循环遍历数组的每个元素（使用索引变量`i`），并将值分配给变量`x`。从代码中，我们还可以得出一个额外的信息：如果索引`i`被用来遍历数组的每个元素，那么我们可以猜测该数组可能包含三个元素（因为在退出循环之前，索引`i`的最大值为`2`）：
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Instead of treating `ebp-8` as the local variable `x`, if you treat `ebp-8` as
    the array''s fourth element (`ebp-8 = val[3]`), then the code will be translated
    to the following. Now, the code can be interpreted differently, that is, the array
    now has four elements and the code iterates through the first three elements.
    In every iteration, the value is assigned to the fourth element:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`ebp-8`视为局部变量`x`，不再将`ebp-8`视为数组的第四个元素（`ebp-8 = val[3]`），那么代码将转换为以下形式。现在，代码可以被不同地解释，即数组现在有四个元素，代码会遍历前三个元素。在每次迭代中，值被赋给第四个元素：
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As you might have guessed from the preceding example, it is not always possible
    to decompile the assembly code to its original form accurately, because of the
    way the compiler generates code (and also, the code might not have all of the
    required information). However, this technique should help to determine the program''s
    functionality. The original C program of the disassembled output is shown as follows;
    notice the similarities between what we determined previously and the original
    code here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的例子中可能已经猜到的那样，通常无法准确地将汇编代码反编译回原始形式，因为编译器生成代码的方式（而且，代码可能没有所有所需的信息）。不过，这种技术应该有助于确定程序的功能。下面显示的是反汇编输出的原始C程序；注意我们之前确定的内容与这里的原始代码之间的相似性：
- en: '[PRE86]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 9.3 Strings
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 字符串
- en: 'A string is an array of characters. When you define a string, shown as follows,
    a *null terminator* (*string terminator*) is added at the end of every string.
    Each element occupies 1 byte of memory (in other words, each ASCII character is
    1 byte in length):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符数组。当你定义一个字符串时，如下所示，会在每个字符串的末尾添加一个*空终止符*（*字符串终止符*）。每个元素占用1字节内存（换句话说，每个ASCII字符的长度是1字节）：
- en: '[PRE87]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The string name `str` is a pointer variable that points to the first character
    in the string (in other words, it points to the base address of the character
    array). The following diagram shows how these characters reside in memory:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串名`str`是一个指针变量，它指向字符串中的第一个字符（换句话说，它指向字符数组的基地址）。下图显示了这些字符在内存中的存储方式：
- en: '![](../images/00090.gif)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.gif)'
- en: 'From the preceding example, you can access the elements of a character array
    (string), as shown here:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你可以访问字符数组（字符串）的元素，如下所示：
- en: '[PRE88]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The general form for the character array can be represented as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数组的一般形式可以表示如下：
- en: '[PRE89]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 9.3.1 String Instructions
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.1 字符串指令
- en: The x86 family of processors provides string instructions, which operate on
    strings. These instructions step through the string (character array) and are
    suffixed with `b`, `w`, and `d`, which indicating the size of data to operate
    on (`1`, `2`, or `4` bytes). The string instructions make use of the registers
    `eax`, `esi`, and `edi`. The register `eax`, or its sub-registers `ax` and `al`,
    are used to hold values. The register `esi` acts as the *source address register*
    (it holds the address of the source string), and `edi` is the *destination address
    register* (it holds the address of the destination string).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: x86系列处理器提供了字符串指令，这些指令用于操作字符串。指令逐步遍历字符串（字符数组），并以`b`、`w`和`d`作为后缀，表示操作数据的大小（`1`、`2`或`4`字节）。字符串指令使用寄存器`eax`、`esi`和`edi`。寄存器`eax`，或其子寄存器`ax`和`al`，用于存储值。寄存器`esi`充当*源地址寄存器*（存储源字符串的地址），而`edi`是*目标地址寄存器*（存储目标字符串的地址）。
- en: After performing a string operation, the `esi` and `edi` registers are either
    automatically incremented or decremented (you can think of `esi` and `edi` as
    source and destination index registers). The `direction flag (DF)` in the `eflags`
    register determines whether `esi` and `edi` should be incremented or decremented.
    The `cld` instruction clears the direction flag (`df=0`); if `df=0`, then the
    index registers (`esi` and `edi`) are incremented. The `std` instruction sets
    the direction flag (`df=1`); in such a case, `esi` and `edi` are decremented.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完字符串操作后，`esi`和`edi`寄存器会自动递增或递减（你可以将`esi`和`edi`视为源索引和目标索引寄存器）。`eflags`寄存器中的`方向标志（DF）`决定了`esi`和`edi`是否应该递增或递减。`cld`指令清除方向标志（`df=0`）；如果`df=0`，那么索引寄存器（`esi`和`edi`）会递增。`std`指令设置方向标志（`df=1`）；在这种情况下，`esi`和`edi`会递减。
- en: 9.3.2 Moving From Memory To Memory (movsx)
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.2 从内存到内存的移动（movsx）
- en: 'The `movsx` instructions are used to move a sequence of bytes from one memory
    location to another. The `movsb` instruction is used to move `1` byte from the
    address specified by the `esi` register to the address specified by the `edi`
    register. The `movsw, movsd` instructions move `2` and `4` bytes from the address
    specified by the `esi` to the address specified by `edi`. After the value is moved,
    the `esi` and `edi` registers are incremented/decremented by `1`, `2`, or `4`
    bytes, based on the size of the data item. In the following assembly code, let''s
    assume that the address labeled as `src` contained the string `"Good"`, followed
    by a *null terminator* (`0x0`). After executing the first instruction at ➊, `esi`
    will contain the start address of the string `"Good"` (in other words, `esi` will
    contain the address of the first character, `G`), and the instruction at ➋ will
    set `EDI` to contain the address of a memory buffer (`dst`). The instruction at ➌ will
    copy 1 byte (the character `G`) from the address specified by `esi` to the address
    specified by `edi`. After executing the instruction at ➌, both `esi` and `edi`
    will be incremented by `1`, to contain the next address:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsx` 指令用于将一系列字节从一个内存位置移动到另一个位置。`movsb` 指令用于将 1 字节从由 `esi` 寄存器指定的地址复制到由 `edi`
    寄存器指定的地址。`movsw, movsd` 指令将 2 字节和 4 字节从 `esi` 指定的地址复制到 `edi` 指定的地址。数据移动后，`esi`
    和 `edi` 寄存器会根据数据项的大小，分别增加或减少 1、2 或 4 字节。在以下汇编代码中，假设标记为 `src` 的地址包含字符串 `"Good"`，并紧跟一个
    *空字符终止符*（`0x0`）。在执行 ➊ 指令后，`esi` 将包含字符串 `"Good"` 的起始地址（换句话说，`esi` 将包含字符 `G` 的地址），而
    ➋ 指令将设置 `EDI` 包含一个内存缓冲区（`dst`）的地址。执行 ➌ 指令时，将会把 1 字节（字符 `G`）从 `esi` 指定的地址复制到 `edi`
    指定的地址。执行完 ➌ 指令后，`esi` 和 `edi` 都会增加 1，以指向下一个地址：'
- en: '[PRE90]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following screenshot will help you to understand what happens before and
    after executing the `movsb` instruction at ➌. Instead of `movsb`, if `movsw` is
    used, then 2 bytes will be copied from `src` to `dst`, and `esi` and `edi` will
    be incremented by `2`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将帮助你理解在执行 `movsb` 指令之前和之后发生了什么。若使用的是 `movsw` 而非 `movsb`，则会将 2 字节从 `src`
    复制到 `dst`，同时 `esi` 和 `edi` 会各自增加 `2`：
- en: '![](../images/00091.gif)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00091.gif)'
- en: 9.3.3 Repeat Instructions (rep)
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.3 重复指令（rep）
- en: 'The `movsx` instruction can only copy `1`, `2`, or `4` bytes, but to copy the
    multi-byte content, the `rep` instruction is used, along with the string instruction.
    The `rep` instruction depends on the `ecx` register, and it repeats the string
    instruction the number of times specified by the `ecx` register. After the `rep`
    instruction is executed, the value of `ecx` is decremented. The following assembly
    code copies the string `"Good"` (along with a *null terminator*) from `src` to
    `dst`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsx` 指令只能复制 1、2 或 4 字节，但要复制多字节内容时，需配合 `rep` 指令和字符串指令使用。`rep` 指令依赖于 `ecx`
    寄存器，并根据 `ecx` 寄存器指定的次数重复执行字符串指令。执行完 `rep` 指令后，`ecx` 的值会递减。以下汇编代码将字符串 `"Good"`（包括
    *空字符终止符*）从 `src` 复制到 `dst`：'
- en: '[PRE91]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `rep` instruction, when used with the `movsx` instruction, is equivalent
    to the `memcpy()` function in C programming. The `rep` instruction has multiple
    forms, which allows early termination, based on the condition that occurs during
    the execution of the loop. The following table outlines different forms of `rep`
    instructions and their conditions:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`rep` 指令与 `movsx` 指令一起使用时，相当于 C 编程中的 `memcpy()` 函数。`rep` 指令有多种形式，允许在执行循环时，根据条件提前终止。下表列出了不同形式的
    `rep` 指令及其条件：'
- en: '| Instruction | Condition |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 条件 |'
- en: '| `rep` | Repeats until `ecx=0` |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `rep` | 重复直到 `ecx=0` |'
- en: '| `repe, repz` | Repeats until `ecx=0` or `ZF=0` |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `repe, repz` | 重复直到 `ecx=0` 或 `ZF=0` |'
- en: '| `repne, repnz` | Repeat until `ecx=0` or `ZF=1` |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `repne, repnz` | 重复直到 `ecx=0` 或 `ZF=1` |'
- en: 9.3.4 Storing Value From Register to Memory (stosx)
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.4 从寄存器存储值到内存（stosx）
- en: 'The `stosb` instruction is used to move a byte from the CPU''s `al` register
    to the memory address specified by `edi` (the *destination index register*). Similarly,
    the `stosw` and `stosd` instructions move data from `ax` (2 bytes) and `eax` (4
    bytes) to the address specified by `edi`. Normally, the `stosb` instruction is
    used along with the `rep` instruction to initialize all of the bytes of the buffer
    to some value. The following assembly code fills the destination buffer with `5`
    double words (`dword`), all of them equal to `0` (in other words, it initializes
    `5*4 = 20` bytes of memory to `0`). The `rep` instruction, when used with `stosb`,
    is equivalent to the `memset()` function in C programming:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`stosb`指令将一个字节从CPU的`al`寄存器移动到由`edi`指定的内存地址（*目标索引寄存器*）。同样，`stosw`和`stosd`指令将数据从`ax`（2字节）和`eax`（4字节）移动到由`edi`指定的地址。通常，`stosb`指令与`rep`指令一起使用，用于将缓冲区的所有字节初始化为某个值。以下汇编代码将目标缓冲区填充为`5`个双字（`dword`），所有值为`0`（换句话说，它将`5*4=20`字节的内存初始化为`0`）。当`stosb`与`rep`一起使用时，它相当于C编程中的`memset()`函数：'
- en: '[PRE92]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 9.3.5 Loading From Memory to Register (lodsx)
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.5 从内存加载到寄存器（lodsx）
- en: The `lodsb` instruction moves a byte from a memory address specified by `esi`
    (the *source index register*) to the `al` register. Similarly, the `lodsw` and
    `lodsd` instructions move 2 bytes and 4 bytes of data from the memory address
    specified by `esi` to the `ax` and `eax` registers.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`lodsb`指令将由`esi`指定的内存地址中的一个字节移到`al`寄存器中。同样，`lodsw`和`lodsd`指令将由`esi`指定的内存地址中的2个字节和4个字节数据分别移到`ax`和`eax`寄存器中。'
- en: 9.3.6 Scanning Memory (scasx)
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.6 扫描内存（scasx）
- en: The `scasb` instruction is used to search (or scan) for the presence or absence
    of a byte value in a sequence of bytes. The byte to search for is placed in the
    `al` register, and the memory address (buffer) is placed in the `edi` register.
    The `scasb` instruction is mostly used with the `repne` instruction (`repne scasb`),
    with `ecx` set to the buffer length; this iterates through each byte until it
    finds the specified byte in the `al` register, or until `ecx` becomes `0`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`scasb`指令用于在字节序列中搜索（或扫描）某个字节值的存在或不存在。要搜索的字节值放置在`al`寄存器中，内存地址（缓冲区）放置在`edi`寄存器中。`scasb`指令通常与`repne`指令一起使用（`repne
    scasb`），并将`ecx`设置为缓冲区的长度；这会逐个字节地检查，直到找到`al`寄存器中的指定字节，或者直到`ecx`变为`0`。'
- en: 9.3.7 Comparing Values in Memory (cmpsx)
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3.7 比较内存中的值（cmpsx）
- en: The `cmpsb` instruction is used to compare a byte in the memory address specified
    by `esi` with a byte in the memory address specified by `edi`, to determine if
    they contain the same data. The `cmpsb` is normally used with `repe` (`repe cmpsb`)
    to compare two memory buffers; in this case, `ecx` will be set to the buffer length,
    and the comparison will continue until `ecx=0` or the buffers are not equal.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmpsb`指令用于比较由`esi`指定的内存地址中的一个字节与由`edi`指定的内存地址中的一个字节，以确定它们是否包含相同的数据。`cmpsb`通常与`repe`（`repe
    cmpsb`）一起使用，用于比较两个内存缓冲区；在这种情况下，`ecx`将被设置为缓冲区的长度，比较会持续进行，直到`ecx=0`或者两个缓冲区不相等。'
- en: 10\. Structures
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 结构体
- en: 'A structure groups different types of data together; each element of the structure
    is called a *member*. The structure members are accessed using constant offsets.
    To understand the concept, take a look at the following C program. The `simpleStruct`
    definition contains three member variables (`a`,  `b`, and `c`) of different data
    types. The `main` function defines the structure variable (`test_stru`) at ➊, and
    the address of the structure variable (`&test_stru`) is passed as the first argument at ➋
    to the `update` function. Inside of the `update` function, the member variables
    are assigned values:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体将不同类型的数据组合在一起；结构体的每个元素称为*成员*。结构体成员通过常量偏移量进行访问。为了理解这个概念，来看一下以下的C程序。`simpleStruct`定义包含三个不同数据类型的成员变量（`a`、`b`
    和 `c`）。`main`函数在➊处定义了结构体变量（`test_stru`），并将结构体变量的地址（`&test_stru`）作为第一个参数在➋处传递给`update`函数。在`update`函数内部，成员变量被赋予了值：
- en: '[PRE93]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In order to understand how the members of the structures are accessed, let''s
    look at the disassembled output of the `update` function. At ➌, the base address
    of the structure is moved into the `eax` register (remember, `ebp+8` represents
    the first argument; in our case, the first argument contains the `base address`
    of the `structure`). At this stage, `eax` contains the base address of the structure.
    At ➍, the integer value `6` is assigned to the first member by adding the offset
    `0` to the base address (`[eax+0]` which is the same as `[eax]`). Because the
    integer occupies `4` bytes, notice at ➎ the `short int value 7` (in `cx`) is assigned
    to the second member by adding the offset `4` to the `base address`. Similarly,
    the value `41h` (`A`) is assigned to the third member by adding `6` to the base
    address at ➏:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解结构体成员是如何访问的，让我们来看一下`update`函数的反汇编输出。在➌位置，结构体的基地址被移动到`eax`寄存器中（记住，`ebp+8`表示第一个参数；在我们的例子中，第一个参数包含了`structure`的`base
    address`）。此时，`eax`寄存器包含了结构体的基地址。在➍位置，整数值`6`通过将偏移量`0`加到基地址上（`[eax+0]`，也就是`[eax]`）赋值给第一个成员。因为整数占用`4`字节，注意到在➎位置，`short
    int值7`（存储在`cx`寄存器中）通过将偏移量`4`加到基地址上赋值给第二个成员。类似地，`41h`（即`A`）的值在➏位置通过将偏移量`6`加到基地址上赋值给第三个成员：
- en: '[PRE94]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'From the preceding example, it can be seen that each member of the structure
    has its own *offset* and is accessed by adding the *constant offset* to the *base
    address*; so, the general form can be written as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子可以看出，每个结构体成员都有自己的*偏移量*，并通过将*常量偏移量*加到*基地址*来访问；因此，通用形式可以写成如下：
- en: '`[base_address + constant_offset]`'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`[base_address + constant_offset]`'
- en: 'Structures may look very similar to arrays in the memory, but you need to remember
    a few points to distinguish between them:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体在内存中看起来与数组非常相似，但你需要记住一些要点来区分它们：
- en: Array elements always have the same data types, whereas structures need not
    have the same data types.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组元素始终具有相同的数据类型，而结构体的成员不必具有相同的数据类型。
- en: Array elements are mostly accessed by a variable offset from the base address
    (such as `[eax + ebx]` or `[eax+ebx*4]`), whereas structures are mostly accessed
    using constant offsets from the base address (for example, `[eax+4]`).
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组元素大多是通过相对于基地址的变量偏移量访问（例如，`[eax + ebx]` 或 `[eax+ebx*4]`），而结构体则大多是通过相对于基地址的常量偏移量访问（例如，`[eax+4]`）。
- en: 11\. x64 Architecture
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. x64架构
- en: 'Once you understand the concepts of x86 architecture, it''s much easier to
    understand x64 architecture. The x64 architecture was designed as an extension
    to x86 and has a strong resemblance with x86 instruction sets, but there are a
    few differences that you need to be aware of from a code analysis perspective.
    This section covers some of the differences in the x64 architecture:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了x86架构的概念，就更容易理解x64架构了。x64架构是作为x86的扩展设计的，与x86的指令集非常相似，但从代码分析的角度看，仍然有一些你需要注意的区别。本节涵盖了一些x64架构的差异：
- en: The first difference is that the 32-bit (4 bytes) general purpose registers
    `eax`, `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp`, and `esp` are extended to 64
    bits (8 bytes); these registers are named `rax`, `rbx`, `rcx`, `rdx`, `rsi`, `rdi`, `rbp`,
    and `rsp`. The eight new registers are named `r8`, `r9`, `r10`, `r11`, `r12`,
    `r13`, `r14`, and `r15`. As you might expect, a program can access the register
    as 64-bit (`RAX`, `RBX`, and so on), 32-bit (`eax`, `ebx`, etc), 16-bit (`ax`, `bx`,
    and so on), or 8-bit (`al`, `bl`, and so on). For example, you can access the
    lower half of the `RAX` register as `EAX` and the lowest word as `AX.` You can
    access the registers `r8-r15` as `byte`, `word`, `dword`, or `qword` by appending
    `b, w, d` or `q` to the register name.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个区别是，32位（4字节）通用寄存器`eax`、`ebx`、`ecx`、`edx`、`esi`、`edi`、`ebp`和`esp`被扩展为64位（8字节）；这些寄存器被命名为`rax`、`rbx`、`rcx`、`rdx`、`rsi`、`rdi`、`rbp`和`rsp`。新增的八个寄存器命名为`r8`、`r9`、`r10`、`r11`、`r12`、`r13`、`r14`和`r15`。如你所料，程序可以将寄存器访问为64位（`RAX`、`RBX`等）、32位（`eax`、`ebx`等）、16位（`ax`、`bx`等）或8位（`al`、`bl`等）。例如，你可以将`RAX`寄存器的下半部分访问为`EAX`，并将最底层的字访问为`AX`。你可以通过在寄存器名称后附加`b`、`w`、`d`或`q`来访问寄存器`r8-r15`的字节、字、双字或四字。
- en: x64 architecture can handle 64-bit (8 bytes) data, and all of the addresses
    and pointers are 64 bits (8 bytes) in size.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x64架构可以处理64位（8字节）数据，所有的地址和指针都是64位（8字节）大小。
- en: The x64 CPU has a 64-bit instruction pointer `(rip)` that contains the address
    of the next instruction to execute, and it also has a 64-bit flags register `(rflags)`,
    but currently, only the lower 32 bits are used `(eflags)`.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x64 CPU具有一个64位的指令指针`(rip)`，它包含下一条将执行的指令的地址，并且还具有一个64位的标志寄存器`(rflags)`，但目前只使用低32位`(eflags)`。
- en: The x64 architecture supports `rip-relative` addressing. The `rip` register
    can now be used to reference memory locations; that is, you can access data at
    a location which is at some offset from the current *instruction pointer*.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x64架构支持`rip-relative`寻址。现在可以使用`rip`寄存器来引用内存位置；也就是说，你可以访问当前*指令指针*偏移一定量的数据。
- en: 'Another major difference is that in the x86 architecture, the function parameters
    are pushed onto the stack as mentioned previously, whereas in the x64 architecture,
    the first four parameters are passed in the `rcx`, `rdx`, `r8`, and `r9` registers,
    and if the program contains additional parameters they are stored on the stack.
    Let''s look at an example of simple C code (the `printf` function); this function
    takes six parameters:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个主要的区别是，在x86架构中，函数参数是按之前提到的方式推送到栈上的，而在x64架构中，前四个参数通过`rcx`、`rdx`、`r8`和`r9`寄存器传递，如果程序包含额外的参数，它们则存储在栈上。我们来看一个简单的C代码示例（`printf`函数）；该函数有六个参数：
- en: '[PRE95]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following is the disassembly of the C code compiled for a 32-bit (x86)
    processor; in this case, all of the parameters are pushed onto the stack (in reverse
    order), and after the call to `printf`,  `add esp,18h` is used to clean up the
    stack. So, it is easy to tell that the `printf` function takes six parameters:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为32位（x86）处理器编译的C代码的反汇编；在这种情况下，所有参数都按逆序推送到栈上，在调用`printf`后，使用`add esp,18h`来清理栈。因此，很容易判断`printf`函数有六个参数：
- en: '[PRE96]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is the disassembly of the C code compiled for a 64-bit (x64)
    processor. The first instruction, at ➊, allocates `0x38` (`56` bytes) of space
    on the stack. The first, second, third, and fourth parameters are stored in the
    `rcx, rdx, r8` and `r9` register (before the `call` to `printf`), at  ➋, ➌, ➍, ➎.
    The fifth and the sixth parameters are stored on the stack (in the allocated space),
    using instructions at ➏ and ➐. The `push` instruction was not used in this case,
    making it difficult to determine if the memory address is a *local variable* or
    a *parameter* to the function. In this case, the format string helps to determine
    the number of parameters passed to the `printf` function, but in other cases,
    it''s not that easy:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为64位（x64）处理器编译的C代码的反汇编。第一个指令，在➊位置，分配了`0x38`（即56字节）空间到栈上。第一个、第二个、第三个和第四个参数存储在`rcx`、`rdx`、`r8`和`r9`寄存器中（在调用`printf`之前），分别位于➋、➌、➍、➎。第五个和第六个参数存储在栈上（在分配的空间中），使用的指令位于➏和➐。在此情况下，没有使用`push`指令，因此很难判断内存地址是*局部变量*还是函数的*参数*。在此情况下，格式字符串有助于确定传递给`printf`函数的参数数量，但在其他情况下则不容易：
- en: '[PRE97]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Intel 64 (x64) and IA-32 (x86) architecture consist of many instructions. If
    you come across an assembly instruction that is not covered in this chapter, you
    can download the latest Intel architecture manuals from [https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm),
    and the instruction set reference (*volumes 2A, 2B, 2C, and 2D*) can be downloaded
    from [https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf](https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔64位（x64）和IA-32（x86）架构包含许多指令。如果你遇到本章没有涉及的汇编指令，可以从[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)下载最新的英特尔架构手册，指令集参考（*卷2A、2B、2C和2D*）可以从[https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf](https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf)下载。
- en: 11.1 Analyzing 32-bit Executable On 64-bit Windows
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.1 分析64位Windows上的32位可执行文件
- en: The 64-bit Windows operating system can run a 32-bit executable; to do that,
    Windows developed a subsystem called *WOW64* (Windows 32-bit on Windows 64-bit).
    WOW64 subsystem allows for the execution of 32-bit binaries on 64-bit Windows.
    When you run an executable, it needs to load the DLLs to call the API functions
    to interact with the system. The 32-bit executable cannot load 64-bit DLLs (and
    a 64-bit process cannot load 32-bit DLLs), so Microsoft separated the DLLs for
    both 32-bit and 64-bit. The 64-bit binaries are stored in the `\Windows\system32`
    directory, and the 32-bit binaries are stored in the `\Windows\Syswow64` directory.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 64位Windows操作系统可以运行32位可执行文件；为此，Windows开发了一个名为*WOW64*（Windows 32位在Windows 64位上的子系统）的子系统。WOW64子系统允许在64位Windows上执行32位二进制文件。当你运行一个可执行文件时，它需要加载DLL以调用API函数与系统进行交互。32位可执行文件不能加载64位DLL（而64位进程也不能加载32位DLL），因此微软为32位和64位分别提供了不同的DLL。64位二进制文件存储在`\Windows\system32`目录下，而32位二进制文件存储在`\Windows\Syswow64`目录下。
- en: The 32-bit applications, when running under 64-bit Windows (Wow64), can behave
    differently, as compared to how they behave on the native 32-bit Windows. When
    you are analyzing a 32-bit malware on 64-bit Windows, if you find malware accessing
    the `system32` directory, it is really accessing the `syswow64` directory (the
    operating system automatically redirects it to the `Syswow64` directory). If a
    32-bit malware (when executed on 64-bit Windows) is writing a file in the `\Windows\system32`
    directory, then you need to check the file in the `\Windows\Syswow64` directory.
    Similarly, access to `%windir%\regedit.exe` is redirected to `%windir%\SysWOW64\regedit.exe`.
    The difference in behavior can create confusion during analysis, so it is essential
    to understand this difference, and to avoid confusion during analysis, it is better
    to analyze a 32-bit binary in a 32-bit Windows environment.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 32位应用程序在64位Windows（Wow64）下运行时，可能表现与在本机32位Windows上的行为不同。当你在64位Windows上分析32位恶意软件时，如果你发现恶意软件访问了`system32`目录，实际上它是在访问`syswow64`目录（操作系统会自动将其重定向到`Syswow64`目录）。如果一个32位恶意软件（在64位Windows上执行时）在`\Windows\system32`目录写入文件，那么你需要检查`\Windows\Syswow64`目录中的文件。类似地，访问`%windir%\regedit.exe`会被重定向到`%windir%\SysWOW64\regedit.exe`。这种行为差异可能会在分析时造成混淆，因此理解这种差异非常重要，为了避免混淆，最好在32位Windows环境中分析32位二进制文件。
- en: To get an idea of how WOW64 subsystem can impact your analysis, refer to *The
    WOW-Effect *by Christian Wojner ([http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf](http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf))
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解WOW64子系统如何影响你的分析，请参考*The WOW-Effect* by Christian Wojner ([http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf](http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf))
- en: 12\. Additional Resources
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12\. 额外资源
- en: 'The following are some of the additional resources to help you gain a deeper
    understanding of C programming, x86, and x64 assembly language programming:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外的资源，帮助你更深入地了解C编程、x86和x64汇编语言编程：
- en: '*Learn C:* [https://www.programiz.com/c-programming](https://www.programiz.com/c-programming)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习C语言:* [https://www.programiz.com/c-programming](https://www.programiz.com/c-programming)'
- en: '*C Programming Absolute Beginner''s Guide* by Greg Perry and Dean Miller'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Greg Perry和Dean Miller的*C编程绝对初学者指南*
- en: '*x86 Assembly Programming Tutorial*: [https://www.tutorialspoint.com/assembly_programming/](https://www.tutorialspoint.com/assembly_programming/)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x86汇编编程教程*：[https://www.tutorialspoint.com/assembly_programming/](https://www.tutorialspoint.com/assembly_programming/)'
- en: 'Dr. Paul Carter''s *PC Assembly Language*: [http://pacman128.github.io/pcasm/](http://pacman128.github.io/pcasm/)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保罗·卡特博士的*PC汇编语言*：[http://pacman128.github.io/pcasm/](http://pacman128.github.io/pcasm/)
- en: '*Introductory Intel x86 - Architecture, Assembly, Applications, and Alliteration*:
    [http://opensecuritytraining.info/IntroX86.html](http://opensecuritytraining.info/IntroX86.html)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intel x86简介 - 架构、汇编、应用程序和修辞*: [http://opensecuritytraining.info/IntroX86.html](http://opensecuritytraining.info/IntroX86.html)'
- en: '*Assembly language Step by Step* by Jeff Duntemann'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jeff Duntemann的*汇编语言逐步学习*
- en: '*Introduction to 64-bit Windows Assembly Programming* by Ray Seyfarth'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ray Seyfarth的*64位Windows汇编编程入门*
- en: '*x86 Disassembly*: [https://en.wikibooks.org/wiki/X86_Disassembly](https://en.wikibooks.org/wiki/X86_Disassembly)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x86反汇编*：[https://en.wikibooks.org/wiki/X86_Disassembly](https://en.wikibooks.org/wiki/X86_Disassembly)'
- en: 13\. Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13\. 总结
- en: In this chapter, you learned the concepts and techniques required to understand
    and interpret assembly code. This chapter also highlighted the key differences
    between the x32 and x64 architectures. The disassembly and decompiling (static
    code analysis) skills that you learned in this chapter will help you to gain a
    deeper understanding of how malicious code works, at a low level. In the next
    chapter, we will look at code analysis tools (disassemblers and debuggers), and
    you will learn how the various features offered by these tools can ease your analysis
    and help you inspect the code associated with the malicious binary.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了理解和解释汇编代码所需的概念和技巧。本章还强调了x32和x64架构之间的关键区别。你在本章中学习的反汇编和反编译（静态代码分析）技巧将帮助你更深入地理解恶意代码如何在底层运行。在下一章，我们将介绍代码分析工具（反汇编器和调试器），你将学习这些工具提供的各种功能如何简化你的分析，并帮助你检查与恶意二进制文件相关的代码。
