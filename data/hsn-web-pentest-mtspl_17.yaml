- en: Penetration Testing on Technological Platforms - Jenkins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术平台上的渗透测试 - Jenkins
- en: In the previous chapters, we looked at how to exploit JBoss and Apache Tomcat.
    In this chapter, we will look at Jenkins. Jenkins is a popular tool that's used
    to automate the non-human part of the software development process. In a **Business-to-Consumer**
    (**B2C**) relationship, a model where the company is providing services such as
    e-payment, e-commerce, online mobile and dish recharge plans, and so on to a consumer,
    the developers have a significant load on them. Due to the frequent updates that
    occur on the staging and production servers, the environment becomes complicated
    for the developers. To work more efficiently on the updates for the software and
    be able to launch them on time, a company will opt to use a platform engine to
    try and help pipeline the updates and manage them with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看了如何利用JBoss和Apache Tomcat。在本章中，我们将看看Jenkins。Jenkins是一个流行的工具，用于自动化软件开发过程中的非人工部分。在**企业对消费者**（**B2C**）关系中，公司提供诸如电子支付、电子商务、在线手机和卫星充值计划等服务给消费者，开发人员承担着重要的工作。由于在分期和生产服务器上频繁更新，环境对开发人员来说变得复杂。为了更有效地处理软件更新并能够及时发布它们，公司将选择使用一个平台引擎来尝试帮助管道化更新并轻松管理它们。
- en: Jenkins is one such platform engine. It handles the deployment and management
    of source codes that need to be deployed on different servers at different times
    of the day. Since Jenkins handles sensitive information when it manages the source
    code for a company, it is a hot target for those who are focused on industrial
    cyber-espionage. Once the threat actor is able to gain access to the Jenkins platform,
    they can access the source code (blueprints) of the services that are being offered
    by the organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是这样一个平台引擎。它处理需要在不同时间部署到不同服务器上的源代码的部署和管理。由于Jenkins在管理公司的源代码时处理敏感信息，因此它是那些专注于工业间谍活动的人的热门目标。一旦威胁行为者能够访问Jenkins平台，他们就可以访问组织提供的服务的源代码（蓝图）。
- en: 'As a penetration tester, we have to make sure the client''s organization has
    instances such as Jenkins fully patched. In this chapter, we will explore the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员，我们必须确保客户组织的实例（如Jenkins）已经完全打补丁。在本章中，我们将探讨以下主题：
- en: Introduction to Jenkins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins简介
- en: Jenkins terminology
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins术语
- en: Jenkins reconnaissance and enumeration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins侦察和枚举
- en: Exploiting Jenkins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Jenkins
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的技术要求：
- en: Jenkins instance: [https://jenkins.io/download/](https://jenkins.io/download/)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins实例：[https://jenkins.io/download/](https://jenkins.io/download/)
- en: The Metasploit Framework
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metasploit框架
- en: Introduction to Jenkins
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins简介
- en: Jenkins is an open source tool. It is built using Java, which helps with continuous
    integration when using plugins. For example, if we want to integrate Git, we need
    to install the git plugin. Jenkins supports hundreds of plugins, which makes it
    practically compatible with almost every tool. It does this to ensure **Continuous
    Integration** (**CI**) and **Continuous Delivery** (**CD**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个开源工具。它是使用Java构建的，可以通过插件实现持续集成。例如，如果我们想要集成Git，我们需要安装git插件。Jenkins支持数百种插件，几乎与每种工具兼容。它这样做是为了确保**持续集成**（**CI**）和**持续交付**（**CD**）。
- en: 'The following are some of the key features of Jenkins:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Jenkins的一些关键特性：
- en: Provides CI and CD
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供CI和CD
- en: Plugin-based architecture
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于插件的架构
- en: Extensible
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展
- en: Distributed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式
- en: Easy to configure
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于配置
- en: Jenkins terminology
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins术语
- en: Before we dive into how to enumerate and exploit Jenkins, we need to understand
    some of the basic terminologies that may come up in the later sections of this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究如何枚举和利用Jenkins之前，我们需要了解一些基本术语，这些术语可能会在本章的后面部分出现。
- en: The Stapler library
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stapler库
- en: 'Stapler is a library used by Jenkins that allows objects to be mapped to URLs
    automatically. It solves the problem of mapping relative URLs in complex applications
    such as **Expression Language** (**EL**) ([http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html](http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html)).
    It takes an object and a URL and then evaluates the URL against the object. It
    repeats this process until it hits either a static resource, a view (such as JSP,
    Jelly, Groovy, and so on), or an action method. The following diagram shows this
    process in more detail:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Stapler是Jenkins使用的一个库，它允许对象自动映射到URL。它解决了在复杂应用程序中映射相对URL的问题，例如**表达式语言**（**EL**）([http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html](http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html))。它接受一个对象和一个URL，然后根据对象评估URL。它重复这个过程，直到找到静态资源、视图（如JSP、Jelly、Groovy等）或操作方法。以下图表更详细地显示了这个过程：
- en: '![](img/642f371b-7343-4276-b121-cd6780b082dd.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/642f371b-7343-4276-b121-cd6780b082dd.png)'
- en: '(Credits: [http://stapler.kohsuke.org/what-is.html](http://stapler.kohsuke.org/what-is.html))'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[http://stapler.kohsuke.org/what-is.html](http://stapler.kohsuke.org/what-is.html)）
- en: As shown in the preceding diagram, the root object is mapped to the URL, while
    every other object is mapped as a separate path until a resource is found.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，根对象映射到URL，而每个其他对象都映射为单独的路径，直到找到资源。
- en: URL routing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL路由
- en: 'URL routing is used by Jenkins to process the URL paths; let''s take a look:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins使用URL路由来处理URL路径；让我们来看一下：
- en: 'Models:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型：
- en: '`getLog()` will traverse to `/log/`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLog()`将遍历到`/log/`'
- en: '`getJob("foo")` will be traversed as `/job/foo`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`getJob("foo")`将被遍历为`/job/foo`'
- en: Action methods
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作方法
- en: '`doArtifact(...) action in getJob("foo")` will become `/job/foo/1/artifact`,
    where 1 is the dynamic getter.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`doArtifact(...) action in getJob("foo")`将变成`/job/foo/1/artifact`，其中1是动态获取器。'
- en: Apache Groovy
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Groovy
- en: Apache Groovy is a multi-faceted programming language that supports static typing
    and static compilation. The key point for users to remember here is that Groovy
    supports runtime and compile-time meta-programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Groovy是一种多功能的编程语言，支持静态类型和静态编译。用户在这里需要记住的关键点是Groovy支持运行时和编译时的元编程。
- en: Meta-programming
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: Meta-programming is a technique that allows computer programs to consider other
    programs as their input data. So, a program can be designed to read/write/modify
    other programs, or even itself. If a program simply reports on itself, this is
    known as **introspection,** while if the program modifies itself, this is known
    as **reflection**. A lot of languages support meta-programming – PHP, Python,
    Apache Groovy, and compilers are some examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是一种允许计算机程序将其他程序视为其输入数据的技术。因此，程序可以被设计为读取/写入/修改其他程序，甚至是自身。如果一个程序只是报告自身，这被称为**内省**，而如果程序修改自身，则被称为**反射**。许多语言支持元编程
    - PHP、Python、Apache Groovy和编译器是一些例子。
- en: 'Let''s try to further our understanding with an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过一个例子进一步理解：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the preceding program creates another program, `programs`, which
    prints numbers `1-500`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的程序创建了另一个程序`programs`，它打印数字`1-500`。
- en: Abstract syntax tree
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象语法树
- en: An **Abstract Syntax Tree** (**AST**) is a representation of the structural
    and content-related details of a program. It does not include inessential punctuation
    and delimiters. AST is used by compilers for parsing, type resolution, flow analysis,
    and code generation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象语法树**（**AST**）是程序的结构和内容相关细节的表示。它不包括不必要的标点和分隔符。编译器使用AST进行解析、类型解析、流分析和代码生成。'
- en: Pipeline
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: The Jenkins pipeline is a combination of plugins that work together and help
    with continuous delivery. The pipeline can be implemented as code using JenkinsFile,
    and this can be defined using a **domain-specific language** (**DSL**). Pipelines
    in Jenkins are built with Groovy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins管道是一组一起工作并帮助进行持续交付的插件的组合。管道可以作为JenkinsFile的代码实现，并且可以使用**领域特定语言**（**DSL**）进行定义。Jenkins中的管道是用Groovy构建的。
- en: Jenkins reconnaissance and enumeration
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins侦察和枚举
- en: Enumeration for Jenkins is a very important aspect of penetration testing. Activity information
    that's retrieved while performing reconnaissance and enumeration can help penetration
    testers exploit the Jenkins instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对Jenkins进行枚举是渗透测试的一个非常重要的方面。在执行侦察和枚举时检索到的活动信息可以帮助渗透测试人员利用Jenkins实例。
- en: There are a few ways to determine the installation and version detection processes
    of Jenkins. We will go through these now and then cover how to exploit Jenkins.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确定Jenkins的安装和版本检测过程。我们现在将介绍这些，然后讨论如何利用Jenkins。
- en: Detecting Jenkins using favicon hashes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网站图标哈希检测Jenkins
- en: Jenkins has a very unique favicon, and when converted into hash form, it becomes
    `81586312`. This hash can be used to identify a Jenkins installation; it can even
    be used on Shodan to identify systems running Jenkins.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins有一个非常独特的网站图标，当转换为哈希形式时，变成了`81586312`。这个哈希可以用来识别Jenkins安装；甚至可以在Shodan上用来识别运行Jenkins的系统。
- en: 'The following screenshot shows how the hash value is used to identify Jenkins:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了哈希值如何用于识别Jenkins：
- en: '![](img/0f86a715-c06d-4d3c-a260-533243fc15ca.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f86a715-c06d-4d3c-a260-533243fc15ca.png)'
- en: 'We can also use different Jenkins HTTP response headers to find the Jenkins
    instance. For example, to find a specific version of Jenkins, we can use the `X-Jenkins`
    header, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用不同的Jenkins HTTP响应头来找到Jenkins实例。例如，要找到特定版本的Jenkins，我们可以使用`X-Jenkins`头，如下图所示：
- en: '![](img/93e9f548-629d-4fa0-9217-6bb57a1bf218.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93e9f548-629d-4fa0-9217-6bb57a1bf218.png)'
- en: Let's see what other HTTP response headers we can use to identify the Jenkins
    instance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他HTTP响应头可以用来识别Jenkins实例。
- en: Detecting Jenkins using HTTP response headers
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP响应头检测Jenkins
- en: 'One of the most common ways of detecting a Jenkins instance is by analyzing
    the HTTP response headers. Jenkins puts a lot of information into its response
    headers, such as the version''s disclosure information, **command-line interface**
    (**CLI**) port, user and group permissions, and more, all of which can be used
    for further exploitation. A response header from a Jenkins instance can be seen
    in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 检测Jenkins实例最常见的方法之一是分析HTTP响应头。Jenkins将大量信息放入其响应头中，例如版本披露信息、**命令行接口**（**CLI**）端口、用户和组权限等，所有这些都可以用于进一步的利用。以下是Jenkins实例的响应头截图：
- en: '![](img/984d8558-75f7-4827-b861-dec55222766c.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/984d8558-75f7-4827-b861-dec55222766c.png)'
- en: 'The following are some of the HTTP server response headers for Jenkins instances
    that can be used for detection:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以用于检测Jenkins实例的HTTP服务器响应头：
- en: '`X-Hudson`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Hudson`'
- en: '`X-Jenkins`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins`'
- en: '`X-Jenkins-Session`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-Session`'
- en: '`X-You-Are-Authenticated-As`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-You-Are-Authenticated-As`'
- en: '`X-You-Are-In-Group-Disabled`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-You-Are-In-Group-Disabled`'
- en: '`X-Required-Permission`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Required-Permission`'
- en: '`X-Permission-Implied-By`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Permission-Implied-By`'
- en: '`X-Hudson-CLI-Port`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Hudson-CLI-Port`'
- en: '`X-Jenkins-CLI-Port`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-CLI-Port`'
- en: '`X-Jenkins-CLI2-Port`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-CLI2-Port`'
- en: '`X-SSH-Endpoint`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-SSH-Endpoint`'
- en: '`X-Hudson-JNLP-Port`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Hudson-JNLP-Port`'
- en: '`X-Jenkins-JNLP-Port`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-JNLP-Port`'
- en: '`X-Jenkins-JNLP-Host`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-JNLP-Host`'
- en: '`X-Instance-Identity`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Instance-Identity`'
- en: '`X-Jenkins-Agent-Protocols`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Jenkins-Agent-Protocols`'
- en: Now that we have learned some common ways to detect Jenkins manually, let's
    move on to the next phase of penetration testing – enumeration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了一些手动检测Jenkins的常见方法，让我们继续进行渗透测试的下一个阶段 - 枚举。
- en: Jenkins enumeration using Metasploit
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit进行Jenkins枚举
- en: Now that we have covered the manual way of enumerating Jenkins, let's move on
    and look at the Metasploit Framework's auxiliary `jenkins_enum`, which takes enumeration
    one step further.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了手动枚举Jenkins的方法，让我们继续看看Metasploit框架的辅助`jenkins_enum`，它可以进一步进行枚举。
- en: 'The Metasploit module also has an auxiliary that uses methods similar to the
    ones described in the previous section to perform the recon. This includes looking
    for the response header value, that is, `X-Jenkins`, as well as the HTML source
    for the keyword. The auxiliary can be loaded using the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit模块还有一个辅助程序，使用与前一节描述的方法类似的方法来执行recon。这包括查找响应头值，即`X-Jenkins`，以及关键字的HTML源。可以使用以下命令加载辅助程序：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/da68f422-f94b-41d7-a349-01a689bdeb27.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da68f422-f94b-41d7-a349-01a689bdeb27.png)'
- en: 'After setting the options shown in the preceding screenshot, running the auxiliary
    will detect the version number, as well as perform basic checks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中设置选项后，运行辅助程序将检测版本号，并执行基本检查：
- en: '![](img/b480c4b8-93a6-4c17-b729-db556e6a772f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b480c4b8-93a6-4c17-b729-db556e6a772f.png)'
- en: 'Now, we can dive a little deeper and examine the source code of the auxiliary
    in order to understand what exactly the script is doing. By looking at the following
    screenshot, we can see that the script checks for the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以深入一点，检查辅助程序的源代码，以了解脚本到底在做什么。通过查看以下截图，我们可以看到脚本检查以下内容：
- en: '`/view/All/newJobs`: Shows a list of jobs'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /view/All/newJobs：显示作业列表
- en: '`/asynchPeople`: Shows a list of users'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/asynchPeople`：显示用户列表'
- en: '`/systemInfo`: Prints the system''s information:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/systemInfo`：打印系统信息：'
- en: '![](img/7db89125-63ea-45f8-9825-c54e6781c96c.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7db89125-63ea-45f8-9825-c54e6781c96c.png)'
- en: 'The following command shows another auxiliary in Metasploit that allows us
    to brute-force the credentials of Jenkins:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示Metasploit中的另一个辅助程序，允许我们暴力破解Jenkins的凭据：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](img/08016e9d-8559-4ad5-9139-80efd0a3b52d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08016e9d-8559-4ad5-9139-80efd0a3b52d.png)'
- en: 'After we''ve set the required options and run the module, we''ll see that the
    auxiliary returns the valid credentials. This can be seen in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了所需的选项并运行模块之后，我们将看到辅助程序返回有效的凭据。这可以在以下截图中看到：
- en: '![](img/fc73dd5e-f11e-4839-8bba-faaa47f39b70.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc73dd5e-f11e-4839-8bba-faaa47f39b70.png)'
- en: Let's now explore Jenkins in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在下一节中探索Jenkins。
- en: Exploiting Jenkins
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Jenkins
- en: Once enumeration is complete, and if a vulnerable version of Jenkins has been
    found, we can move on to the exploitation phase. In this section, we will learn
    about the various exploits that can be discovered by `@orangetsai` and how they
    can be chained together to execute system commands on a Jenkins server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦枚举完成，并且找到了一个有漏洞的Jenkins版本，我们就可以继续进行利用阶段。在本节中，我们将学习`@orangetsai`发现的各种利用方式，以及它们如何被链接在一起来在Jenkins服务器上执行系统命令。
- en: First, we will look at two of the most famous exploits of 2019, discovered by
    `@orangetsai` ([https://blog.orange.tw/](https://blog.orange.tw/)), which exploited
    Jenkins and returned a shell. These exploits were later added to Metasploit as
    unauthenticated RCEs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下2019年最著名的两个利用，由`@orangetsai`（[https://blog.orange.tw/](https://blog.orange.tw/)）发现，利用了Jenkins并返回了一个shell。这些利用后来被添加到Metasploit作为未经身份验证的RCE。
- en: Jenkins ACL bypass
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins ACL绕过
- en: 'After the script console exploits of Jenkins became well known, a lot of people
    started configuring Jenkins with anonymous read access set to **disabled** in
    the global security configuration settings:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins的脚本控制台利用变得广为人知之后，很多人开始在全局安全配置设置中将匿名读取访问权限设置为**禁用**：
- en: '![](img/bd926542-db9b-401f-b9cc-e91dd476c493.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd926542-db9b-401f-b9cc-e91dd476c493.png)'
- en: 'With this setting, anonymous users could no longer see anything except the
    specific whitelisted items shown in the following screenshot (these were provided
    at the following URL: [https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258](https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258)):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，匿名用户除了在以下截图中显示的特定白名单项目之外，将不再看到任何内容（这些项目在以下URL提供：[https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258](https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258)）：
- en: '![](img/dcbef755-cc87-49f7-9dd7-c3b166e1938d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcbef755-cc87-49f7-9dd7-c3b166e1938d.png)'
- en: We already know that Jenkins is based on Java and that, in Java, everything
    is a subclass of `java.lang.Object`. In this manner, all objects have `getClass()`,
    and the name of `getClass()` matches the naming convention rule. Therefore, one
    way to bypass this whitelist is to use the whitelisted objects as an entrance
    and jump to other objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Jenkins是基于Java的，并且在Java中，一切都是`java.lang.Object`的子类。因此，所有对象都有`getClass()`，并且`getClass()`的名称符合命名约定规则。因此，绕过这个白名单的一种方法是使用白名单对象作为入口，然后跳转到其他对象。
- en: 'Orange discovered that calling the objects (listed here) leads to ACL bypass
    and that the search method can be accessed successfully:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Orange发现调用这些对象（在此处列出）会导致ACL绕过，并且可以成功访问搜索方法：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The routing mechanism shown in the preceding objects is mapped in the following
    URL format:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述对象中显示的路由机制映射在以下URL格式中：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the URL provided, we can see that no action is allowed unless we are logged
    in:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从提供的URL中，我们可以看到除非我们登录，否则不允许任何操作：
- en: '![](img/49e63cbb-37c0-4d3e-a2eb-8149b638fab2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49e63cbb-37c0-4d3e-a2eb-8149b638fab2.png)'
- en: 'Now, let''s see what happens when we use the ACL bypass:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们使用ACL绕过时会发生什么：
- en: '![](img/0be6ed36-35e4-4516-a0c3-63a0c3559755.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0be6ed36-35e4-4516-a0c3-63a0c3559755.png)'
- en: We successfully bypassed the ACL and performed a search.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功绕过了ACL并进行了搜索。
- en: Understanding Jenkins unauthenticated RCE
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Jenkins未经身份验证的RCE
- en: 'Chaining the ACL bypass vulnerability with the sandbox bypass gives us **remote
    code execution** (**RCE**). Metasploit already has a module that exploits these
    vulnerabilities and executes our shellcode. Let''s take a look how it can be used
    before we learn about how the exploit works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将ACL绕过漏洞与沙盒绕过链接在一起，给我们**远程代码执行**（**RCE**）。Metasploit已经有一个利用这些漏洞并执行我们的shellcode的模块。在了解利用的工作原理之前，让我们看看它如何使用：
- en: 'We can load the exploit module by using the following command in msfconsole:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在msfconsole中使用以下命令加载利用模块：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面命令的输出：
- en: '![](img/d26775f7-8b3d-4292-91ab-baf68066f517.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d26775f7-8b3d-4292-91ab-baf68066f517.png)'
- en: 'Next, we set the required options and run the exploit, as shown in the following
    screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置所需的选项并运行利用，如下面的屏幕截图所示：
- en: '![](img/5d654f41-951a-4dac-a8bb-07f8d898dfc4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d654f41-951a-4dac-a8bb-07f8d898dfc4.png)'
- en: 'Now that we have a reverse shell, let''s read the source code of the exploit
    and try to understand how it works. By looking at the source code, we can see
    the various CVEs that were used in the exploit, as well as the author''s details:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个反向shell，让我们阅读利用的源代码并尝试理解它是如何工作的。通过查看源代码，我们可以看到利用中使用的各种CVE，以及作者的详细信息：
- en: '![](img/87ec3c85-0d1c-4ccc-a033-439673db3a2c.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87ec3c85-0d1c-4ccc-a033-439673db3a2c.png)'
- en: 'Looking at the source code for the module, we can see that the module is requesting `/search/index`
    using a `GET` HTTP method with the `q=a` parameter:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看模块的源代码，我们可以看到模块正在使用`GET` HTTP方法请求`/search/index`并带有`q=a`参数：
- en: '![](img/e0ba3338-48b1-4a35-85e4-e794bc436d96.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0ba3338-48b1-4a35-85e4-e794bc436d96.png)'
- en: 'As we can see, the exploit confirms whether the application is running Jenkins
    or not by checking the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，利用通过检查以下内容来确认应用程序是否正在运行Jenkins：
- en: The ACL bypass to call for the search function
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用搜索功能的ACL绕过
- en: The response headers for X-Jenkins value
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-Jenkins值的响应头
- en: The body of the HTML page for the keyword administrator after calling the search
    URL
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用搜索URL后关键字管理员的HTML页面正文
- en: 'Here, we can see that something related to Groovy''s `doCheckScriptCompile`
    method is being mentioned. `doCheckScriptCompile` is a method that allows developers
    to check for syntax errors. To parse the syntax, an AST parser is used (see the
    *Jenkins terminology* section of this chapter for more details):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与Groovy的`doCheckScriptCompile`方法有关的内容。`doCheckScriptCompile`是一个允许开发人员检查语法错误的方法。为了解析语法，使用了AST解析器（有关更多详细信息，请参见本章的*Jenkins术语*部分）：
- en: '![](img/26e0ac8f-3aca-4867-9030-52c24e04a831.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26e0ac8f-3aca-4867-9030-52c24e04a831.png)'
- en: To be able to achieve successful RCE, we need to send the code that's executed
    when it's sent through `doCheckScriptCompile()`. This is where meta-programming
    comes in. Groovy is meta-programming friendly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够成功实现RCE，我们需要发送通过`doCheckScriptCompile()`时执行的代码。这就是元编程的作用。Groovy对元编程很友好。
- en: 'When we take a look at the Groovy reference manual, we''ll come across `@groovy.transform.ASTTest`,
    which has the following description:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看Groovy参考手册时，我们会遇到`@groovy.transform.ASTTest`，它有以下描述：
- en: '![](img/0639822c-f95e-4042-96d1-674ec5b3eca4.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0639822c-f95e-4042-96d1-674ec5b3eca4.png)'
- en: 'This implies that the following piece of code will be executed when it''s passed
    through `@ASTTest`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当通过`@ASTTest`传递时，将执行以下代码：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So far, the exploit can be written like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，利用可以这样编写：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The URL is calling the `workflow-cps` plugin of Jenkins, which has the `checkScriptCompile`
    method. URL for the hosted code is
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: URL正在调用Jenkins的`workflow-cps`插件，该插件具有`checkScriptCompile`方法。托管代码的URL是
- en: '[https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java](https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java)
    which can be seen as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java](https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java)
    可以如下所示：'
- en: '![](img/92459083-6566-4699-8312-47a5238659b6.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92459083-6566-4699-8312-47a5238659b6.png)'
- en: 'However, this version of the exploit will only work if the **Pipeline Shared
    Groovy Libraries Plugin** does not exist in Jenkins. This is why, if we look further
    down the exploit code, we will see something related to `@Grab` being used in
    the final payload mentioned in the comments, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个版本的利用只有在Jenkins中不存在**Pipeline Shared Groovy Libraries Plugin**时才能工作。这就是为什么，如果我们进一步查看利用代码，我们将看到与最终载荷中提到的`@Grab`相关的内容，如下所示：
- en: '![](img/0b54ba3b-c835-4bc3-99f4-9920a7930eeb.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b54ba3b-c835-4bc3-99f4-9920a7930eeb.png)'
- en: 'Now, we need to understand what `@Grab` is. As per Groovy''s official documentation,
    Grape is a JAR dependency manager that allows developers to manage and add Maven
    repository dependencies to their classpaths, as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要了解`@Grab`是什么。根据Groovy的官方文档，Grape是一个JAR依赖管理器，允许开发人员管理和添加Maven存储库依赖项到他们的类路径，如下面的屏幕截图所示：
- en: '![](img/8565ff3b-f819-47b5-b6d8-d965c29162f5.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8565ff3b-f819-47b5-b6d8-d965c29162f5.png)'
- en: 'So, `@Grab` will import the dependencies from the mentioned repository and
    add them to the code. Now, a question arises: "What if the repository is not on
    Maven?" In our case, because it''s in the shellcode, Grape will allow us to specify
    the URL, as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`@Grab`将从所述存储库导入依赖项并将其添加到代码中。现在，一个问题出现了：“如果存储库不在Maven上怎么办？”在我们的情况下，因为它在shellcode中，Grape将允许我们指定URL，如下面的屏幕截图所示：
- en: '![](img/8f39306c-6f4b-4973-9df3-cd971a0d1da7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f39306c-6f4b-4973-9df3-cd971a0d1da7.png)'
- en: 'Here, the following code will download the JAR from [http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar](http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以下代码将从[http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar](http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar)下载JAR文件：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have downloaded the malicious JAR from the server, the next task
    is to execute it. For this, we need to take a deep dive into the source code of
    the Groovy core, which is where Grape is implemented ([https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy](https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从服务器下载了恶意的JAR文件，下一个任务是执行它。为此，我们需要深入研究Groovy核心的源代码，这是Grape实现的地方（[https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy](https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy)）。
- en: 'There''s a method we can use to process the ZIP ( JAR) file and check for two
    methods in the specific directory. Note the last few lines shown in the following
    screenshot – there''s a function called `processRunners()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一种方法来处理ZIP（JAR）文件，并检查特定目录中的两种方法。请注意以下截图中显示的最后几行 - 有一个名为`processRunners()`的函数：
- en: '![](img/4a8afec0-a923-46a6-aaf1-35ae68720053.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a8afec0-a923-46a6-aaf1-35ae68720053.png)'
- en: 'By taking a look at the following function, we can see that `newInstance()`
    is being called. This means a constructor can be called:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看以下函数，我们可以看到正在调用`newInstance()`。这意味着可以调用一个构造函数：
- en: '![](img/d232cc35-0555-4e5a-9dbb-574883056dba.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d232cc35-0555-4e5a-9dbb-574883056dba.png)'
- en: 'In short, if we create a malicious JAR and put a class file in the `META-INF/services/org.codehaus.groovy.plugins.Runners` folder,
    inside the JAR file, we will be able to invoke a constructor with our code, as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们创建一个恶意的JAR文件，并将一个类文件放在`META-INF/services/org.codehaus.groovy.plugins.Runners`文件夹中，我们就能够调用一个包含我们代码的构造函数，如下所示：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will lead to code execution!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致代码执行！
- en: 'So, if we return to the source code of the exploit, as shown in the following
    screenshot, we should be able to completely understand how it works:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们回到利用的源代码，如下图所示，我们应该能够完全理解它的工作原理：
- en: '![](img/16c4f78f-0971-437e-a301-7a0c6fd89cdf.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16c4f78f-0971-437e-a301-7a0c6fd89cdf.png)'
- en: '`checkScriptCompile` is used to pass the syntax of the program.`@Grabconfig`
    is used to disable the checksum of the file being fetched.`@GrabResolver` is used
    to fetch external dependencies (a malicious JAR file).`Import` is used to execute
    the constructor where the shellcode is written.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkScriptCompile`用于传递程序的语法。`@Grabconfig`用于禁用被获取文件的校验和。`@GrabResolver`用于获取外部依赖（恶意的JAR文件）。`Import`用于执行包含shellcode的构造函数。'
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about Jenkins and its basic terminology. We covered
    how to detect the installation of Jenkins manually, as well as by using the Metasploit
    Framework. Then, we learned how to exploit Jenkins, as well as how the exploit
    works. Understanding how these exploits work is important if you wish to help
    the company you're working to apply better patches and have a pentester develop
    better exploits or bypasses.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Jenkins及其基本术语。我们介绍了如何手动检测Jenkins的安装，以及如何使用Metasploit Framework进行检测。然后，我们学习了如何利用Jenkins，以及利用的原理。了解这些利用的原理对于希望帮助所在公司应用更好的补丁并让渗透测试人员开发更好的利用或绕过的人来说是很重要的。
- en: Our main goal should always be to learn as much as we can about technology.
    From a pentester's perspective, the more they know, the greater their chances
    are of being able to exploit, and from a blue teams/SOC team's perspective, more
    information about the technology they have installed helps them prevent attacks
    being performed on it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标应该始终是尽可能多地了解技术。从渗透测试人员的角度来看，他们了解得越多，他们能够利用的机会就越大，而从蓝队/SOC团队的角度来看，对他们安装的技术有更多的了解可以帮助他们防止对其进行攻击。
- en: In the next chapter, we will look at exploiting bugs in the application logic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何利用应用逻辑中的漏洞。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we identify the Jenkins instance in a black-box penetration test?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑盒渗透测试中，我们如何识别Jenkins实例？
- en: Are there any other ways to identify the Jenkins instance?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有其他方法可以识别Jenkins实例吗？
- en: I have identified the Jenkins instance from the HTTP headers, but the page isn't
    accessible. How can I make the page accessible?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经从HTTP头中识别出了Jenkins实例，但页面无法访问。我该如何使页面可访问？
- en: What can I do once I have access to the Jenkins panel?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我能够访问Jenkins面板，我可以做些什么？
- en: Further reading
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following links cover Jenkins exploits in more detail:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接更详细地介绍了Jenkins的漏洞利用：
- en: Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE: [https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE: [https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
- en: Jenkins Security Advisory 2019-01-08: [https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266](https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins Security Advisory 2019-01-08: [https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266](https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266)
- en: Dependency management with Grape: [http://docs.groovy-lang.org/latest/html/documentation/grape.html](http://docs.groovy-lang.org/latest/html/documentation/grape.html)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Grape进行依赖管理： [http://docs.groovy-lang.org/latest/html/documentation/grape.html](http://docs.groovy-lang.org/latest/html/documentation/grape.html)
