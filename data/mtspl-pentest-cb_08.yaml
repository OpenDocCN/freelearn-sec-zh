- en: Chapter 8. Working with Exploits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用利用
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Exploiting the module structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用模块结构
- en: Common exploit mixins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的利用混合
- en: Working with msfvenom
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用msfvenom
- en: Converting exploit to a Metasploit module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将利用转换为Metasploit模块
- en: Porting and testing the new exploit module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植和测试新的利用模块
- en: Fuzzing with Metasploit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Metasploit进行模糊测试
- en: Writing a simple FileZilla FTP fuzzer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的FileZilla FTP模糊器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Let us start this chapter with a formal introduction to exploits. **Exploit**
    can be a piece of software, a chunk of data or a sequence of commands that takes
    advantage of vulnerability or a bug in another software to execute user-intended
    instructions. These user-intended instructions can cause unusual behavior in the
    vulnerable software. Exploits play a vital role in penetration testing as it can
    provide an easy entry into the target system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从正式介绍利用开始这一章。**利用**可以是一段软件、一段数据或一系列命令，利用另一种软件中的漏洞或错误执行用户预期的指令。这些用户预期的指令可能会导致受影响软件的异常行为。利用在渗透测试中起着至关重要的作用，因为它可以为目标系统提供一个简单的入口。
- en: So far, we have used the power of exploits extensively to perform penetration
    testing. The point to note here is that we cannot directly use any stand-alone
    proof of concept or exploit code into the Metasploit framework. We will have to
    convert it into a framework understandable module. The process is similar to development
    of auxiliary modules with some additional fields. This chapter will cover every
    detail that you need to know while you are working with exploits within the framework.
    We will not be covering those aspects which are related to developing exploits
    as it is a separate area of study. Here, we will use the available proof of concepts
    of exploits and see how it can be added into the framework. We will also learn
    about some important mixins that can ease the process of converting exploits into
    the Metasploit module. At the end, we will cover some recipes focusing on fuzzing
    modules. So let us move ahead with the recipes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经广泛使用利用的力量进行渗透测试。这里需要注意的一点是，我们不能直接将任何独立的概念验证或利用代码直接用于Metasploit框架。我们必须将其转换为框架可理解的模块。这个过程与开发辅助模块类似，但有一些额外的字段。本章将涵盖您在框架内使用利用时需要了解的每一个细节。我们不会涵盖与开发利用相关的方面，因为这是一个独立的研究领域。在这里，我们将使用现有的利用概念验证，并看看如何将其添加到框架中。我们还将学习一些重要的混合技术，可以简化将利用转换为Metasploit模块的过程。最后，我们将涵盖一些关于模糊测试模块的配方。让我们继续前进吧。
- en: Exploiting the module structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用模块结构
- en: It is very essential to understand the exploit module structure as it will help
    us in proper analysis of different exploit modules. As the Metasploit framework
    is an open source project, its development depends on the contribution from the
    community. Developers from around the globe convert proof of concepts of various
    exploits into the Metasploit module, so that it can be used by everyone. Hence,
    you can also contribute to the community by converting newly discovered exploits
    into modules. Also, there can be a situation where you need a particular exploit
    which is not in the framework. Knowledge about the exploit module structure will
    help you in easily converting the exploit into a module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解利用模块结构非常重要，因为它将帮助我们正确分析不同的利用模块。由于Metasploit框架是一个开源项目，其发展取决于社区的贡献。来自全球各地的开发人员将各种漏洞的概念转化为Metasploit模块，以便每个人都可以使用。因此，您也可以通过将新发现的漏洞转换为模块来为社区做出贡献。此外，可能会出现需要特定漏洞但框架中没有的情况。了解利用模块结构将帮助您轻松地将漏洞转换为模块。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let us start the recipe with understanding the modular structure of exploits
    within the framework. It is similar to an auxiliary structure with some specific
    fields. You can find the exploit modules in the `/pentest/exploits/framework3`
    directory. Let us analyze the structure of exploits in MSF.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解框架内利用的模块化结构开始这个配方。它与辅助结构类似，但有一些特定的字段。您可以在`/pentest/exploits/framework3`目录中找到利用模块。让我们分析一下MSF中的利用结构。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As we said earlier, the format of an exploit module is similar to auxiliary
    with some specific additions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，利用模块的格式与辅助模块类似，但有一些特定的添加：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The module starts with including the MSF core libraries into the script, along
    with the declaration of a class which extends the properties relevant to the exploit.
    In this example, the `Metasploit3` class extends `Remote Exploit` libraries. Further,
    the script includes other libraries such as TCP:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块以将MSF核心库包含到脚本中开始，并声明一个类，该类扩展了与利用相关的属性。在这个例子中，`Metasploit3`类扩展了`Remote Exploit`库。此外，脚本还包括其他库，如TCP：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we have the `initialize` function that is used to initialize the different
    values and content definition about the modules. Some of the primary definitions
    of this function include `Name, Description, Author, Version`, and so on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`initialize`函数，用于初始化有关模块的不同值和内容定义。此函数的一些主要定义包括`Name，Description，Author，Version`等：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we have the register options part of the script which is responsible
    for providing essential and default values of the script. The values can be changed
    according to users needs as well. So far, it has been very much similar to auxiliary
    modules. The difference lies in defining the `exploit()` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有脚本的注册选项部分，负责提供脚本的基本和默认值。这些值可以根据用户的需求进行更改。到目前为止，它与辅助模块非常相似。不同之处在于定义`exploit()`函数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the main exploit body of the module that contains the shell code or
    the exploit pattern. The content of this function varies from exploit to exploit.
    Some of the key features that may exist in a remote exploit are listed in the
    body of the function. `connect()` is used to open a remote connection with the
    target. It is a function defined in the `Remote::TCP` library. A payload is also
    an essential part of the exploit body which helps in setting up back connections.
    We can also define handlers in the exploit body depending on the need.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块的主要利用主体，包含shell代码或利用模式。这个函数的内容因利用而异。可能存在于远程利用中的一些关键特性列在函数体中。`connect()`用于与目标打开远程连接。它是在`Remote::TCP`库中定义的函数。有效载荷也是利用主体的一个重要部分，它有助于建立反向连接。我们还可以根据需要在利用主体中定义处理程序。
- en: Optionally, you can also declare a vulnerability test function, `check()`, which
    verifies whether the target is vulnerable or not. It verifies for all options
    except the payload.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您还可以声明一个漏洞测试函数`check()`，用于验证目标是否存在漏洞。它验证除有效载荷之外的所有选项。
- en: This was a basic introduction to exploit modules of Metasploit. In the later
    recipes, we will discuss some core concepts related to exploits in the framework.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Metasploit的利用模块的基本介绍。在后面的配方中，我们将讨论与框架中的利用相关的一些核心概念。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The exploit module structure we just analyzed is Metasploit's way of making
    things understandable. Consider the function `def initialize()`. This part helps
    the module in picking up common exploit definitions. Similarly, `register_options()`
    is used by Metasploit to pick up different parameters or assign default parameter
    values to the exploit module. This is where modular architecture becomes handy.
    Later in this chapter, we will see how to convert an existing exploit code into
    a Metasploit module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚分析的利用模块结构是Metasploit使事情变得可理解的方式。考虑函数`def initialize()`。这部分帮助模块捡起常见的利用定义。同样，`register_options()`被Metasploit用来捡起不同的参数或为利用模块分配默认参数值。这就是模块化架构变得方便的地方。在本章的后面，我们将看到如何将现有的利用代码转换为Metasploit模块。
- en: Common exploit mixins
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的利用混合物
- en: Mixins are a comprehensive mechanism in Ruby language to include functionality
    into a module. Mixins provide a way to have multiple-inheritance in a single-inheritance
    language like Ruby. Using mixins in exploit modules can help in calling different
    functions that the exploit will require. In this recipe, we will learn about some
    important Metasploit exploit mixins.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 混合物是Ruby语言中包含功能到模块的一个全面机制。混合物提供了一种在单一继承语言中实现多重继承的方式，比如Ruby。在利用模块中使用混合物可以帮助调用利用所需的不同函数。在这个配方中，我们将学习一些重要的Metasploit利用混合物。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us take a quick look at some of the common exploit mixins. Then, we will
    see its implementation in an existing exploit module.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下一些常见的利用混合物。然后，我们将看到它在现有的利用模块中的实现。
- en: '`Exploit::Remote::TCP:` This mixin provides TCP functionality to the module.
    It can be used to set up a TCP connection. `connect()` and `disconnect()` functions
    are responsible for setting up and terminating connections respectively. It requires
    different parameters, such as `RHOST, RPORT, SSL`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::TCP:` 这个混合物为模块提供了TCP功能。它可以用来建立TCP连接。`connect()`和`disconnect()`函数分别负责建立和终止连接。它需要不同的参数，比如`RHOST,
    RPORT, SSL`。'
- en: '`Exploit::Remote::UDP:` This mixin is used for UDP functionality in the module.
    UDP is generally treated as a faster mode of connectivity over TCP so it can also
    be a handy option when dealing with modules. This mixin further includes `Rex::Socket::UDP`
    which removes the overhead of worrying about setting socket connections with the
    target.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::UDP:` 这个混合物用于模块中的UDP功能。UDP通常被视为比TCP更快的连接模式，因此在处理模块时也可以是一个方便的选项。这个混合物进一步包括`Rex::Socket::UDP`，它消除了担心与目标建立套接字连接的开销。'
- en: '`Exploit::Remote::DCERPC:` This mixin provides utility methods for interacting
    with a DCE/RPC service on a remote machine. The methods of this mixin are generally
    useful in the context of exploitation. This mixin extends the TCP mixin. `dcerpc_call(),
    dcerpc_bind()`, and so on are some useful functions of the DCE/RPC mixin.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::DCERPC:` 这个混合物提供了与远程机器上的DCE/RPC服务进行交互的实用方法。这个混合物的方法通常在利用的上下文中非常有用。这个混合物扩展了TCP混合物。`dcerpc_call(),
    dcerpc_bind()`等等是DCE/RPC混合物的一些有用函数。'
- en: '`Exploit::Remote::SMB:` This mixin defines functions that can help in communicating
    with the SMB service on the remote target. `smb_login(), smb_create(),and` so
    on are some useful functions present in this mixin.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::SMB:` 这个混合物定义了可以帮助与远程目标上的SMB服务进行通信的函数。`smb_login(), smb_create()`等等是这个混合物中存在的一些有用的函数。'
- en: '`Exploit::BruteTargets:` This is an interesting mixin that is used to brute
    force the target. It uses the `exploit_target(target)` function to receive the
    remote target IP and perform brute force. This mixin can be easily extended in
    different brute force exploits.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::BruteTargets:` 这是一个有趣的混合物，用于对目标进行暴力破解。它使用`exploit_target(target)`函数来接收远程目标IP并执行暴力破解。这个混合物可以很容易地在不同的暴力破解利用中扩展。'
- en: '`Exploit::Remote::Ftp:` This mixin can be used to exploit an FTP service on
    the remote target. The mixin includes `Remote::TCP` in order to setup a connection
    with the remote target. It uses the `connect()` function that receives values
    of `RHOST` and `RPORT` in order to connect with the FTP server on the remote system.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::Ftp:` 这个混合物可以用来利用远程目标上的FTP服务。混合物包括`Remote::TCP`以便与远程目标建立连接。它使用`connect()`函数，该函数接收`RHOST`和`RPORT`的值，以便与远程系统上的FTP服务器连接。'
- en: '`Exploit::Remote::MSSQL:` This mixin helps in querying with the remote database.
    The `Mssql_ping()` function queries for the database availability and stores the
    ping response as hash. The `Mssql_xpcmdshell()` function is used to execute system
    commands using `xp_cmdshell`. This mixin is very handy when dealing with exploits
    related to MS SQL.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Remote::MSSQL:`这个混合物有助于与远程数据库查询。`Mssql_ping()`函数查询数据库的可用性，并将ping响应存储为哈希。`Mssql_xpcmdshell()`函数用于使用`xp_cmdshell`执行系统命令。在处理与MS
    SQL相关的利用时，这个混合物非常方便。'
- en: '`Exploit::Capture:` This mixin is helpful in sniffing data packets flowing
    in the network. The `open_pcap()` function is used to setup a device for capturing
    packets flowing through it. This mixin requires presence of pcap installed on
    the machine. Two important functions of this mixin include `inject(pkt="", pcap=self.capture)`
    and `inject_reply()`. The former is responsible for injecting packets into networking
    devices while the latter function is responsible for reporting the resultant packet
    returned by the device depending upon the injected packet.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exploit::Capture:`这个混合物有助于嗅探网络中流动的数据包。`open_pcap()`函数用于设置设备以捕获通过它流动的数据包。这个混合物需要机器上安装了pcap。这个混合物的两个重要函数包括`inject(pkt="",
    pcap=self.capture)`和`inject_reply()`。前者负责将数据包注入到网络设备中，而后者负责报告由设备返回的结果数据包，具体取决于注入的数据包。'
- en: These are some of the important exploit mixins that can be very handy when you
    are working with exploit modules within the framework. Use of mixins reduces the
    overhead of recoding same modules repeatedly. This is the reason why modular architecture
    is very flexible as it facilitates code reuse.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些在框架内使用利用模块时非常方便的重要利用混合物。使用混合物可以减少重复编写相同模块的开销。这就是为什么模块化架构非常灵活的原因，因为它促进了代码重用。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As stated earlier, mixins are used to provide multiple-inheritance in a single-inheritance
    language like Ruby. What we mean by that is we can call different functionalities
    in any module depending on our need. For example, if we want to establish a TCP
    connection in our exploit module, it is not required to define a complete function
    for it. We can simply call the mixin, `Exploit::Remote::TCP`, in our module and
    leverage its functionality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，混合物用于在单继承语言（如Ruby）中提供多重继承。我们的意思是，根据需要，我们可以在任何模块中调用不同的功能。例如，如果我们想在我们的利用模块中建立TCP连接，就不需要为此定义一个完整的函数。我们可以简单地在我们的模块中调用混合物`Exploit::Remote::TCP`，并利用它的功能。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us list some more important mixins.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些更重要的混合物。
- en: Some more mixins
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些更多的混合物
- en: Apart from the previously mentioned mixins, there are many more crucial mixins
    present in the framework. These include `fileformat, imap, java, smtp, she`, and
    so on. You can find these mixins at `lib/msf/core/exploit`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的混合物之外，框架中还有许多其他关键的混合物。这些包括`fileformat, imap, java, smtp, she`等等。您可以在`lib/msf/core/exploit`中找到这些混合物。
- en: Working with msfvenom
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用msfvenom
- en: We have read about `mefencode` and `msfpayload` in [Chapter 4](ch04.html "Chapter 4. Client-side
    Exploitation and Antivirus Bypass"), *Client-side Exploitation and Antivirus Bypass*.
    Let us take a small recap. `msfpayload` is used to generate binary from the payload,
    whereas `msfencode` is used for encoding the binary using different encoding techniques.
    Here we will discuss another Metasploit tool which is a combination of both. This
    tool can play an important role in generating exploits that can execute stealthily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](ch04.html "第4章。客户端利用和防病毒绕过")中阅读了有关`mefencode`和`msfpayload`的内容，*客户端利用和防病毒绕过*。让我们进行一个小小的回顾。`msfpayload`用于从有效负载生成二进制，而`msfencode`用于使用不同的编码技术对二进制进行编码。在这里，我们将讨论另一个Metasploit工具，它结合了两者。这个工具在生成可以悄悄执行的利用方面起着重要作用。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start our experiment with `msfvenom`, launch the terminal window and pass
    on the `msfvenom -h` command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的`msfvenom`实验，启动终端窗口并传递`msfvenom -h`命令。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let us take a look at various available options:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看各种可用选项：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are some interesting parameters to look at. The `-n` parameter creates
    an NOP sled of size of the payload. Another interesting parameter is `-b` which
    gives us the power of avoiding common characters of an exploit such as `\x00`.
    This can be really helpful in evading antivirus programs. The rest of the parameters
    are similar to those we can find in `msfpayload` and `msfencode`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的参数需要注意。`-n`参数创建有效负载大小的NOP滑坡。另一个有趣的参数是`-b`，它使我们有能力避免利用中的常见字符，如`\x00`。这在规避防病毒程序方面非常有帮助。其余的参数与我们可以在`msfpayload`和`msfencode`中找到的参数类似。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An NOP slide, NOP sled or NOP ramp is a sequence of NOP (no-operation) instructions
    that are meant to "slide" the CPU's instruction execution flow to its final, desired,
    destination.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: NOP滑坡，NOP滑梯或NOP坡是一系列NOP（无操作）指令，旨在“滑动”CPU的指令执行流到最终期望的目的地。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To use `msfvenom`, we will have to pass a payload along with an encoding style.
    Let us perform this task on the terminal window:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`msfvenom`，我们将不得不传递有效负载以及编码样式。让我们在终端窗口上执行这个任务：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the different parameters that have been passed along with the payload.
    The presence of the `-b` parameter will avoid the use of `\x00` (null bytes) in
    the shell code. We can use this shell code in our exploit program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意已传递的不同参数。`-b`参数的存在将避免在shell代码中使用`\x00`（空字节）。我们可以在我们的利用程序中使用这个shell代码。
- en: '`msfvenom` can be a very handy tool in quickly generating shell codes using
    different payloads available in the framework. These shell codes can be implemented
    in the exploit code in order to provide back connection with the attacker once
    the vulnerability has been exploited.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfvenom`可以是一个非常方便的工具，可以快速生成使用框架中可用的不同有效负载的shell代码。这些shell代码可以在利用代码中实现，以便在利用漏洞后与攻击者提供反向连接。'
- en: Converting exploit to a Metasploit module
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将利用转换为Metasploit模块
- en: So far, we have used exploit modules in order to compromise our target. In this
    recipe, we will take our module usage experience to the next level. We will try
    and develop a complete exploit module using an available proof of concept. Knowledge
    of converting exploits to a module is essential in order to convert any new exploit
    into a framework module and perform penetration testing without waiting for updates
    to come from the Metasploit team. Also, it is not possible that every exploit
    will be available in the form of a module within the framework. So let us move
    ahead with the recipe and see how we can build our own exploit modules using an
    available PoC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用利用模块来 compromise 我们的目标。在这个配方中，我们将把我们的模块使用经验提升到一个新的水平。我们将尝试使用可用的概念验证来开发一个完整的利用模块。将利用转换为模块的知识对于将任何新的利用转换为框架模块并执行渗透测试而不必等待Metasploit团队的更新是必不可少的。此外，并不是每个利用都会以框架模块的形式可用。因此，让我们继续进行配方，并看看我们如何使用可用的概念验证构建我们自己的利用模块。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start with, let us select any exploit which we can convert into a module.
    Let us consider the gAlan Zero day exploit that can be downloaded from [http://www.exploit-db.com/exploits/10339](http://www.exploit-db.com/exploits/10339).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们选择任何可以转换为模块的利用。让我们考虑可以从[http://www.exploit-db.com/exploits/10339](http://www.exploit-db.com/exploits/10339)下载的gAlan零日利用。
- en: '**gAlan** is an audio-processing tool (both on-line and off-line) for X Windows
    and Win32\. It allows you to build synthesizers, effects chains, mixers, sequencers,
    drum-machines, and so on in a modular fashion by linking together icons representing
    primitive audio-processing components.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**gAlan**是一个音频处理工具（在线和离线），适用于X Windows和Win32。它允许您以模块化的方式通过链接表示原始音频处理组件的图标来构建合成器、效果链、混音器、序列器、鼓机等。'
- en: An exploit for gAlan will function only when the victim is using this application
    and the attacker has the knowledge about this beforehand. Hence, it is imperative
    for the attacker to know which applications are installed on the victim's machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于gAlan的利用只有在受害者使用该应用程序并且攻击者事先知道这一点时才会起作用。因此，攻击者必须知道受害者机器上安装了哪些应用程序。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Before we begin with the exploit conversion, it is imperative to know a little
    about Stack Overflow attacks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始利用转换之前，有必要了解一些关于堆栈溢出攻击的知识。
- en: In software, a stack overflow occurs when too much memory is used on the call
    stack. The call stack is the runtime stack of the software that contains a limited
    amount of memory, often determined at the start of the program. The size of the
    call stack depends on many factors, including the programming language, machine
    architecture, multi-threading, and amount of available memory. When a program
    attempts to use more space than is available on the call stack, the stack is said
    to overflow, typically resulting in a program crash. Essentially, `ESP, EIP`,
    and `EAX` are the registers which are mostly attacked during an exploit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，堆栈溢出发生在调用堆栈上使用了太多内存时。调用堆栈是包含有限内存量的软件的运行时堆栈，通常在程序开始时确定。调用堆栈的大小取决于许多因素，包括编程语言、机器架构、多线程和可用内存量。当程序尝试使用的空间超过调用堆栈上可用的空间时，堆栈被认为溢出，通常导致程序崩溃。基本上，`ESP`、`EIP`和`EAX`是在利用期间经常受到攻击的寄存器。
- en: '`ESP:` Points to the top of the stack'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ESP:` 指向堆栈顶部'
- en: '`EIP:` Points to the location of the next instruction'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EIP:` 指向下一条指令的位置'
- en: '`EAX:` The instruction to be executed'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EAX:` 要执行的指令'
- en: As in a stack all the registers are stored linearly, we need to know the exact
    buffer size of the `EIP` register, so that overflowing it will give us the `EAX`
    and subsequent execution of the payload.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在堆栈中所有寄存器都是线性存储的，我们需要知道`EIP`寄存器的确切缓冲区大小，以便溢出它将给我们`EAX`和随后执行有效载荷。
- en: Once we have the proof of concept of the exploit, the next step will be to collect
    as much information about the exploit as possible. Let us take a good look at
    the proof of concept. The first few lines consist of the shellcode that is stored
    in the `$shellcode` variable. This can be generated using any of the payloads
    available in the framework using either `msfpayload` or `msfvenom:`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了利用的概念验证，下一步将是尽可能收集有关利用的信息。让我们仔细看看概念验证。前几行包括存储在`$shellcode`变量中的shellcode。这可以使用框架中可用的任何有效载荷使用`msfpayload`或`msfvenom`生成。
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main exploit code starts with `$magic` which contains a four byte string.
    Then, we have the `$addr` variable which contains the location of the `ESP` stack
    pointer. Then we have the `$filename` variable containing the filename to be created
    as a post exploitation phase. `$retaddr` contains the location of the return address
    where the stack pointer will point and lead to the execution of the exploit code
    after the overflow. Finally, we have the execution of the payload, which is responsible
    for the exploitation and shellcode execution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的利用代码以`$magic`开头，其中包含一个四字节的字符串。然后，我们有`$addr`变量，其中包含`ESP`堆栈指针的位置。然后我们有`$filename`变量，其中包含要在后期创建的文件名。`$retaddr`包含堆栈指针将指向并导致溢出后利用代码执行的返回地址的位置。最后，我们有有效载荷的执行，负责利用和shellcode执行。
- en: We know from the exploit that our shellcode can reach to a maximum of 700 bytes.
    Also the total length of our payload is 1214 bytes. This information will be helpful
    in building our module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从利用中知道我们的shellcode最多可以达到700字节。我们有效载荷的总长度为1214字节。这些信息将有助于构建我们的模块。
- en: 'We can either use a repeated return address or we can also find the size when
    `EIP` gets overridden. Metasploit has an excellent tool called `pattern_create.rb`
    which can assist in finding the exact location where `EIP` gets overridden. This
    tool generates a string of unique patterns that can be passed to the exploit code
    and by using a debugger; we can find which string pattern is stored in `EIP`.
    Let us create a string of 5000 characters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用重复的返回地址，也可以找到`EIP`被覆盖时的大小。Metasploit有一个名为`pattern_create.rb`的优秀工具，可以帮助找到`EIP`被覆盖的确切位置。这个工具生成一串唯一模式的字符串，可以传递给利用代码，并通过调试器，我们可以找到`EIP`中存储的字符串模式。让我们创建一个5000个字符的字符串：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, edit the exploit script to replace `$payload` with another test variable
    `$junk` and copy the string of 5000 characters in this variable. Now, test the
    application with this script and check which pattern is stored in `EIP`. I am
    assuming that you are aware of the basics of reversing and debugging applications.
    Suppose the string pattern stored in `EIP` is "234abc". Now we will use another
    Metasploit tool called `pattern_offset.rb` to calculate the position where this
    pattern exists in the string we passed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑利用脚本，将`$payload`替换为另一个测试变量`$junk`，并将5000个字符的字符串复制到这个变量中。现在，使用这个脚本测试应用程序，并检查`EIP`中存储的模式。我假设您已经了解了反向和调试应用程序的基础知识。假设存储在`EIP`中的字符串模式是"234abc"。现在我们将使用另一个Metasploit工具称为`pattern_offset.rb`来计算我们传递的字符串中存在这个模式的位置：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So the total number of bytes to be passed so as to get the exact location of
    `EIP` is 1032.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要传递的总字节数，以便获得`EIP`的确切位置，为1032。
- en: Now we have collected enough information about the exploit and we are ready
    to convert it into a Metasploit module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了关于利用的足够信息，我们准备将其转换为Metasploit模块。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let us start building our module. The first and foremost line of script will
    be importing libraries and creating the parent class. Then, we will define the
    `initialize()` function which will contain information about the exploit and also
    register options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的模块。脚本的第一行将是导入库并创建父类。然后，我们将定义包含有关利用的信息并注册选项的`initialize()`函数：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, it was simple and straightforward. The twist begins with defining the
    `exploit()` function. Let us see how we can do this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很简单明了。转折点在于定义`exploit()`函数。让我们看看如何做到这一点。
- en: We will start with the first four bytes of the original exploit script, that
    is, `$magic = "Mjik"`;
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从原始利用脚本的前四个字节开始，即`$magic = "Mjik"`;
- en: It will be replaced with `sploit = "Mjik"` in our module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在我们的模块中被替换为`sploit = "Mjik"`。
- en: 'Then, we move ahead and build our buffer. As we have found the position where
    `EIP` has been overwritten, we can replace the repeated return address value by:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续构建我们的缓冲区。由于我们已经找到了`EIP`被覆盖的位置，我们可以将重复的返回地址值替换为：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we will have to add our nop slide. So that part of the exploit script
    changes to the following line in the module:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们的nop滑块。因此，利用脚本的这部分将更改为模块中的以下行：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we build the complete shellcode:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建完整的shellcode：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, we can combine these lines of script under the `exploit()` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将这些脚本行组合在`exploit()`函数下。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This was a short and simple demonstration of how we can convert an existing
    exploit into a Metasploit module. The difficulty level of this process can vary
    from exploit to exploit. The best way to learn more about it is by viewing the
    available exploit modules in the Metasploit library. In the next recipe, we will
    learn how to port this exploit module into the framework so that we can use it
    for penetration testing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单明了的演示，说明了我们如何将现有的利用转换为Metasploit模块。这个过程的难度水平可能因利用而异。了解更多的最佳方法是查看Metasploit库中可用的利用模块。在下一个示例中，我们将学习如何将这个利用模块移植到框架中，以便我们可以将其用于渗透测试。
- en: Porting and testing the new exploit module
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植和测试新的利用模块
- en: In the previous recipe, we learned about developing a complete exploit module
    for Metasploit using the available proof of concept. In this recipe, we will save
    the module in an appropriate location and then test it to see whether everything
    goes fine.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何使用现有的概念来开发Metasploit的完整利用模块。在这个示例中，我们将把模块保存在一个合适的位置，然后测试它，看看是否一切顺利。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is very essential to take care of the folder where we are going to store
    our exploit module. This can help you in keeping a track of different modules
    and also facilitates the framework in understanding the basic module usage. Now
    that you have the complete module script, let us find out an appropriate location
    to save it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意我们将存储利用模块的文件夹。这可以帮助您跟踪不同的模块，并且还可以帮助框架了解基本模块的使用。现在您有了完整的模块脚本，让我们找一个合适的位置来保存它。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As this is an exploit module, targeting the Windows operating system which affects
    a particular file format, we will have to select the module location accordingly.
    Looking at the `modules/exploits/windows` directory you can find a specific folder
    for `fileformat` exploit modules. This is the location where we can save our module.
    Let us save it as `galan_fileformat_bof.rb`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个利用模块，针对影响特定文件格式的Windows操作系统，我们将不得不相应地选择模块位置。查看`modules/exploits/windows`目录，您可以找到一个特定的文件夹用于`fileformat`利用模块。这是我们可以保存模块的位置。让我们将其保存为`galan_fileformat_bof.rb`。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The next and final task will be to check if our module is functioning fine
    or not. We have already worked a lot with modules so far, so this step will be
    easy going. We will follow the same process that we have used so far:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个和最后的任务将是检查我们的模块是否正常运行。到目前为止，我们已经与模块一起工作了很多，所以这一步将很容易。我们将遵循迄今为止我们所使用的相同过程：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the exploit command is passed, the module will execute and create a file
    that can be used to cause an overflow on the target machine.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦传递了利用命令，模块将执行并创建一个文件，可以用来在目标机器上引起溢出。
- en: This completes our module creation and execution process. You might have seen
    that the process is straightforward. The real effort lies in proper conversion
    of exploit scripts into a framework module. You can debug or modify any existing
    module according to your need. You can also submit any newly created module to
    the Metasploit community to help others benefit from it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的模块创建和执行过程。您可能已经看到，该过程很简单。真正的努力在于将利用脚本正确转换为框架模块。您可以根据需要调试或修改任何现有模块。您还可以将任何新创建的模块提交给Metasploit社区，以帮助其他人从中受益。
- en: Fuzzing with Metasploit
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit进行模糊测试
- en: Fuzz testing or Fuzzing is a software testing technique which consists of finding
    implementation bugs using random data injection. Fuzz scripts generate malformed
    data and pass it to the particular target entity to verify its overflow capacity.
    Metasploit provides several fuzzing modules that can be helpful in exploit development.
    Let us explore more about the basics of fuzzing and how Metasploit modules can
    be used as potential fuzzers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试或模糊是一种软件测试技术，它包括使用随机数据注入来查找实现错误。模糊脚本生成格式不正确的数据，并将其传递给特定的目标实体，以验证其溢出容量。Metasploit提供了几个模糊模块，这些模块在利用开发中可能会有所帮助。让我们更多地了解一下模糊测试的基础知识，以及如何使用Metasploit模块作为潜在的模糊器。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we jump to Metasploit fuzzer modules, let us have a brief overview of
    fuzzing and its types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳转到Metasploit模糊器模块之前，让我们简要概述一下模糊测试及其类型。
- en: Fuzzing is treated as a black box testing technique where we test for the maximum
    overflow capacity of the software. Fuzzing is actively used to find bugs in applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试被视为一种黑盒测试技术，用于测试软件的最大溢出容量。模糊测试被积极用于查找应用程序中的错误。
- en: Fuzzers can be used to test software, protocols, and file formats. Fuzzers automate
    the process of data generation and injection. We can control the size of data
    or packet to be injected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊器可用于测试软件、协议和文件格式。模糊器自动化了数据生成和注入的过程。我们可以控制要注入的数据或数据包的大小。
- en: 'A fuzzer would try combinations of attacks on:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊器将尝试对攻击进行组合：
- en: Numbers (signed/unsigned integers, float, and so on)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字（有符号/无符号整数，浮点数等）
- en: Chars (URLs and command-line inputs)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符（URL和命令行输入）
- en: 'Metadata: user-input text (the `id3` tag)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据：用户输入文本（`id3`标签）
- en: Pure binary sequences
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯二进制序列
- en: Depending upon the type of an application or a protocol we are targeting, we
    can set up our fuzzer to generate data/packets to test its overflow. Metasploit
    contains several fuzzer modules that can be used to test applications and protocols
    against black box testing. These modules can be located at `modules/auxiliary/fuzzers`.
    Let us analyze the implementation of these modules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所针对的应用程序或协议的类型，我们可以设置我们的模糊器以生成数据/数据包来测试其溢出。Metasploit包含几个模糊器模块，可用于对应用程序和协议进行黑盒测试。这些模块可以位于`modules/auxiliary/fuzzers`。让我们分析这些模块的实现。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let us experiment with a protocol-based fuzzer module. Metasploit has an FTP
    module named `client_ftp.rb` which acts as an FTP server and sends responses to
    the FTP client:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用基于协议的模糊器模块。Metasploit有一个名为`client_ftp.rb`的FTP模块，它充当FTP服务器并向FTP客户端发送响应：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see there are many interesting parameters available to us. Let us find
    out what functionality each parameter holds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们有许多有趣的参数可供使用。让我们找出每个参数所具有的功能。
- en: The `CYCLIC` option is used to set up a cyclic pattern as fuzz data. This is
    done to determine offsets as every fourth byte of string is unique. If it is set
    to false, then the fuzzer will use a string of A's as the fuzz data.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CYCLIC`选项用于设置循环模式作为模糊数据。这是为了确定偏移量，因为字符串的每四个字节都是唯一的。如果设置为false，则模糊器将使用一串A作为模糊数据。'
- en: The `ENDSIZE` option defines the maximum length of fuzz data to send back to
    the FTP client. By default, it is set as 20000 bytes.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENDSIZE`选项定义了发送回FTP客户端的模糊数据的最大长度。默认情况下，它设置为20000字节。'
- en: The `ERROR` option, if set to true, will reply to the FTP client using error
    codes.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将`ERROR`选项设置为true，则将使用错误代码回复FTP客户端。
- en: The `EXTRALINE` option is a fuzz test for directory listing. Some FTP clients
    can crash if a very large directory name request is sent to the client.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTRALINE`选项是用于目录列表的模糊测试。如果向客户端发送一个非常大的目录名称请求，一些FTP客户端可能会崩溃。'
- en: The `FUZZCMDS` option allows us to define which response needs to be fuzzed.
    The possible requests are `LIST, NLST, LS, RETR`. We can also set `*` to fuzz
    all commands.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FUZZCMDS`选项允许我们定义哪个响应需要进行模糊处理。可能的请求包括`LIST、NLST、LS、RETR`。我们还可以设置`*`以模糊处理所有命令。'
- en: The `SRVHOST` option is the IP address where the fuzzer will bind with the FTP
    server. For a local machine, we can use `0.0.0.0`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRVHOST`选项是模糊器将与FTP服务器绑定的IP地址。对于本地机器，我们可以使用`0.0.0.0`。'
- en: The `SRVPORT` option is the FTP server port which is by default 21.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRVPORT`选项是FTP服务器端口，默认为21。'
- en: The `STARTSIZE` option is used to define the initial data length of the fuzz
    data.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTSIZE`选项用于定义模糊数据的初始数据长度。'
- en: The `STEPSIZE` option is used to define the increment each time the overflow
    fails.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STEPSIZE`选项用于定义每次溢出失败时的增量。'
- en: 'One should be careful when working with fuzzers. If the right parameter values
    are not passed, then fuzz testing might fail. You can always refer to the module
    source code to understand the fuzzer deeply. Let us run our FTP client fuzzer
    and see what output is returned:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模糊器时应谨慎。如果未传递正确的参数值，则模糊测试可能会失败。您可以随时参考模块源代码，以深入了解模糊器。让我们运行我们的FTP客户端模糊器，看看返回的输出是什么：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output has several things to note. First of all, the FTP server is started
    on the attacking machine. Then, it connects back with the FTP client. Then, it
    starts sending different response commands to the client machine. The fuzzing
    process starts with the `NLST` command. Then, it moves on to LIST and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出有几个需要注意的地方。首先，FTP服务器在攻击机器上启动。然后，它会与FTP客户端连接。然后，它开始向客户端机器发送不同的响应命令。模糊处理过程从`NLST`命令开始。然后，它继续到LIST等等。
- en: This was a small demonstration of how fuzzer modules work. In the next recipe,
    we will take a deeper look into protocol fuzzing by building our own fuzzing module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是fuzzer模块如何工作的简单演示。在下一个示例中，我们将深入研究通过构建我们自己的模糊模块来进行协议模糊。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Fuzzers create different test cases according to the application we want to
    fuzz. In our example, the FTP server can be fuzzed by sending random data packets
    and then analyzing their response. The data packets can fuzz the following attributes
    over a network:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Fuzzers根据我们想要模糊的应用程序创建不同的测试用例。在我们的例子中，FTP服务器可以通过发送随机数据包然后分析其响应来进行模糊处理。数据包可以模糊网络上的以下属性：
- en: '**Packet header:** Fuzzers can insert random data packets of arbitrary length
    and value in the headers and analyze their response.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包头：**模糊器可以在标头中插入任意长度和值的随机数据包并分析其响应。'
- en: '**Packet checksum:** The checksum values can also be manipulated under specific
    conditions using fuzzers.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包校验和：**在特定条件下，模糊器也可以操纵校验和值。'
- en: '**Packet size:** Data packets of arbitrary length can also be sent to the network
    application in order to determine a crash.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据包大小：**可以向网络应用程序发送任意长度的数据包以确定崩溃。'
- en: Once a crash or overflow has been reported, the fuzzer can return its test case
    to provide the overflow data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦崩溃或溢出被报告，fuzzer可以返回其测试用例以提供溢出数据。
- en: Writing a simple FileZilla FTP fuzzer
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的FileZilla FTP fuzzer
- en: We analyzed the working of fuzzer modules in our previous recipe. Let us take
    it a step ahead by building our own small FTP fuzzer that can be used against
    the FileZilla FTP server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个示例中分析了fuzzer模块的工作原理。让我们通过构建我们自己的小型FTP fuzzer来进一步深入了解FileZilla FTP服务器。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The basic template to build a fuzzer will be similar to the one we discussed
    for the development of an auxiliary module. So our basic template should look
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建fuzzer的基本模板将类似于我们讨论过的用于开发辅助模块的模板。因此，我们的基本模板应如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So we have imported the MSF libraries, created a class, and defined our options.
    The next step will be to define the main body of the fuzzer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经导入了MSF库，创建了一个类，并定义了我们的选项。下一步将是定义fuzzer的主体。
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let us analyze the script. The script begins with creating a UDP socket that
    will be required to establish a connection with the FileZilla server. Then, we
    declare variables `startsize` and `count` which holds the values for starting
    the data size of the fuzzer and increment length respectively. Then, we set up
    a loop under which we declare our evil string and a payload format that will be
    sent as a packet (pkt).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析脚本。脚本以创建UDP套接字开始，该套接字将需要与FileZilla服务器建立连接。然后，我们声明变量`startsize`和`count`，它们分别保存fuzzer的数据大小起始值和增量长度的值。然后，我们设置一个循环，在该循环下我们声明我们的恶意字符串和将作为数据包（pkt）发送的有效负载格式。
- en: Then, the script tries to send the data packet to the server using the `udp_sock_sendto`
    function and its response is captured using `resp=udp_sock.get()`. Further, the
    count of the packet is increased by 100 every time the response is received.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本尝试使用`udp_sock_sendto`函数将数据包发送到服务器，并使用`resp=udp_sock.get()`捕获其响应。此外，每次接收到响应时，数据包的计数都会增加100。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To start working with the module, we will have to save it under `modules/auxiliary/fuzzers/ftp`.
    Let us name the fuzzer module as `filezilla_fuzzer.rb:`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用该模块，我们需要将其保存在`modules/auxiliary/fuzzers/ftp`下。让我们将fuzzer模块命名为`filezilla_fuzzer.rb：`
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, our module is working fine and displaying the available options to us.
    Let us pass the respective values and see what happens when we pass the `run`
    command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的模块运行正常，并向我们显示可用的选项。让我们传递相应的值并查看我们传递`run`命令时会发生什么：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Bingo! The fuzzer starts sending strings to the server and continues the process
    unless the server crashes or the loop ends. If the loop ends before the crash,
    then you can modify the script to send a bigger string length. This is a simple
    demonstration of using Metasploit to fuzz software. Generally it is not recommended
    to use Metasploit as a fuzzing platform for large software. We have several dedicated
    frameworks that are specially made for fuzzing software and applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！fuzzer开始向服务器发送字符串，并在服务器崩溃或循环结束之前继续该过程。如果循环在崩溃之前结束，那么您可以修改脚本以发送更大的字符串长度。这是使用Metasploit模糊软件的简单演示。通常不建议将Metasploit用作大型软件的模糊平台。我们有几个专门用于模糊软件和应用程序的专用框架。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let us give a quick look to a fuzzing framework that you can work on if you
    want to enhance your knowledge of fuzzing and exploit development.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下一个模糊框架，如果您想增强您对模糊和利用开发的了解，可以在其上工作。
- en: Antiparser fuzzing framework
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Antiparser模糊框架
- en: Antiparser is a fuzzing framework written in python. It assists in the creation
    of random data specifically for the construction of fuzzers. This framework can
    be used to develop fuzzers that will run across multiple platforms as the framework
    depends solely on the availability of a Python interpreter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Antiparser是用Python编写的模糊框架。它有助于专门用于构建fuzzer的随机数据的创建。该框架可用于开发将在多个平台上运行的fuzzer，因为该框架仅取决于Python解释器的可用性。
- en: Antiparser can be downloaded from [http://sourceforge.net/projects/antiparser/](http://sourceforge.net/projects/antiparser/).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Antiparser可以从[http://sourceforge.net/projects/antiparser/](http://sourceforge.net/projects/antiparser/)下载。
