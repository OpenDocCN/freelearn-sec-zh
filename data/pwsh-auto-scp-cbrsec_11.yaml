- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: AppLocker, Application Control, and Code Signing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppLocker、应用程序控制和代码签名
- en: In an enterprise environment, it is critical to keep control over what software
    is installed and what software is being kept out of the environment – not only
    to keep an overview of what software is available but also to help fight against
    threats such as malicious scripts or malware such as ransomware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，控制安装了哪些软件以及哪些软件被排除在环境之外至关重要——不仅为了保持对可用软件的概览，还为了帮助抵御恶意脚本或恶意软件（如勒索病毒）等威胁。
- en: But how can code signing and application control help you secure your environment
    in a better way and how can it be implemented? What do you need to do when planning
    for implementing an application control solution and what built-in application
    control solutions are available on Windows operating systems?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，代码签名和应用程序控制如何帮助您更好地保护环境，如何实施它们呢？在规划实施应用程序控制解决方案时，您需要做什么，并且Windows操作系统上有哪些内建的应用程序控制解决方案？
- en: 'We’ll explore this and much more in this chapter about AppLocker, application
    control, and code signing. In this chapter, you will get a deeper understanding
    of the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨关于AppLocker、应用程序控制和代码签名的内容。您将在本章中对以下主题有更深入的了解：
- en: Preventing unauthorized script execution with code signing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码签名防止未经授权的脚本执行
- en: Controlling applications and scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制应用程序和脚本
- en: Getting familiar with Microsoft AppLocker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Microsoft AppLocker
- en: Exploring Windows Defender Application Control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Windows Defender应用程序控制
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get the most out of this chapter, ensure that you have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，请确保您具备以下条件：
- en: PowerShell 7.3 and above
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 7.3及以上版本
- en: Installed Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装的Visual Studio Code
- en: A virtual machine running Windows 10 or above for test purposes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试目的的运行Windows 10或以上版本的虚拟机
- en: 'Access to the GitHub repository for **Chapter11**: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11章**的GitHub仓库访问：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11)'
- en: Preventing unauthorized script execution with code signing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码签名防止未经授权的脚本执行
- en: If you want to verify that the executed script is legit code and is allowed
    to be executed by your company, you want to implement a proper code-signing strategy.
    It’s a brilliant way to protect your regularly executed scripts against tampering
    – or at least if someone were to tamper with your scripts, they would not be executed
    if your environment is configured in the right way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想验证执行的脚本是否是合法代码，并且是否允许公司执行，您需要实施一个适当的代码签名策略。这是保护您定期执行的脚本不被篡改的绝妙方法——或者至少，如果有人篡改了您的脚本，在您的环境配置正确的情况下，它们将不会被执行。
- en: It’s important to note that dynamic runtimes can pose a common blind spot when
    implementing application control policies. While PowerShell made a significant
    impact to ensure that the PowerShell runtime can be restricted by application
    control rules, other dynamic runtimes such as Python, Node, Perl, PHP, and more
    may still allow you to run unrestricted code, which might present a vulnerability
    if it’s not managed appropriately. If other dynamic runtimes are not needed on
    your clients, it’s better to block them or restrict them as much as possible to
    maintain a strong security posture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，动态运行时在实施应用程序控制策略时可能会成为一个常见的盲点。虽然PowerShell在确保PowerShell运行时可以通过应用程序控制规则进行限制方面取得了显著进展，但其他动态运行时，如Python、Node、Perl、PHP等，可能仍然允许您运行未受限制的代码，这可能会带来漏洞，尤其是如果没有适当管理的话。如果您的客户端不需要其他动态运行时，最好将它们阻止或尽可能限制，以保持强大的安全态势。
- en: 'The WSH language family has implemented application control awareness in a
    quite straightforward manner: they simply prevent the execution of any scripts
    that are not permitted by the policy.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WSH语言家族通过一种非常直接的方式实现了应用程序控制意识：它们只是阻止执行任何不被政策允许的脚本。
- en: When we talked about **execution policies** in earlier chapters, such as [*Chapter
    1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting Started with PowerShell*,
    we looked at the **AllSigned** or **RemoteSigned** parameters. If **AllSigned**
    is configured, all unsigned PowerShell scripts are prevented from running – if
    **RemoteSigned** is configured, only local unsigned scripts are allowed. Of course,
    the execution policy can be bypassed at any time as it’s not a security boundary
    – however, this prevents your users from unintentionally running scripts they
    don’t know.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在早些章节讨论**执行策略**时，例如在[*第1章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)，*PowerShell入门*中，我们查看了**AllSigned**或**RemoteSigned**参数。如果配置了**AllSigned**，则所有未签名的PowerShell脚本将被阻止运行；如果配置了**RemoteSigned**，则仅允许本地未签名脚本。当然，执行策略可以随时被绕过，因为它不是安全边界—但是，这可以防止用户无意中运行他们不知情的脚本。
- en: Combining code signing with other tools such as AppLocker or **WDAC** is powerful
    as you can ensure that no other scripts except for the configured signed ones
    are allowed in your infrastructure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码签名与其他工具（如AppLocker或**WDAC**）结合使用非常强大，因为你可以确保在你的基础设施中，只有配置的签名脚本可以运行，其他任何脚本都不被允许。
- en: But to start with code signing, we first need a certificate to sign the code
    with. There are several options as to what kind of certificate you can use. You
    could either use a self-signed certificate or a corporate one (either on a forest
    or a public level) that your company paid for.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但要开始代码签名，首先我们需要一个证书来签署代码。你可以选择使用不同类型的证书。你可以选择自签名证书或公司为你购买的企业证书（可以是森林级或公共级证书）。
- en: Self-signed certificates are usually for testing purposes only and if you want
    to take your code-signing infrastructure into production, you should at least
    consider using a certificate signed by your corporate **certificate authority**
    (**CA**) to make your deployment more secure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书通常仅用于测试目的，如果你希望将代码签名基础设施投入生产环境，你至少应该考虑使用由公司**证书授权机构**（**CA**）签名的证书，以使你的部署更加安全。
- en: 'The following figure should provide you with an overview of some different
    scenarios when it comes to code signing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示应为你提供一个关于代码签名不同场景的概览：
- en: '![Figure 11.1 – Overview of the different possibilities of code-signing certificates](image/B16679_11_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 代码签名证书的不同可能性概览](image/B16679_11_001.jpg)'
- en: Figure 11.1 – Overview of the different possibilities of code-signing certificates
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 代码签名证书的不同可能性概览
- en: In this chapter, we will use a self-signed certificate to sign our scripts –
    please make sure you adjust your certificate if you want to use it in production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将使用自签名证书来签署我们的脚本—如果你希望在生产环境中使用，请确保调整你的证书。
- en: A self-signed certificate is only valid on your local computer and can be created
    using the **New-SelfSignedCertificate** cmdlet. In earlier days, **makecert.exe**
    was used to create self-signed certificates, but ever since **New-SelfSignedCertificate**
    was introduced with Windows 8, you can simply create self-signed certificates
    and sign scripts using PowerShell.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书仅在本地计算机上有效，可以使用**New-SelfSignedCertificate** cmdlet 创建。在早期，**makecert.exe**
    被用来创建自签名证书，但自从Windows 8引入了**New-SelfSignedCertificate**后，你可以直接使用PowerShell创建自签名证书并签署脚本。
- en: Certificates created using this cmdlet can be stored either in the current user’s
    personal certificate store by going to **Certificates** | **Current User** | **Personal**
    (**Cert:\CurrentUser\My**) or the local machine’s personal certificate store by
    going to **Certificates** | **Local Computer** | **Personal** (**Cert:\LocalMachine\My**).
    Certificates that are created in the local computer’s certificate store are available
    computer-wide, while the ones created in the current user’s store are scoped to
    the current user only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 cmdlet 创建的证书可以存储在当前用户的个人证书存储中，路径为**证书** | **当前用户** | **个人**（**Cert:\CurrentUser\My**），也可以存储在本地计算机的个人证书存储中，路径为**证书**
    | **本地计算机** | **个人**（**Cert:\LocalMachine\My**）。在本地计算机的证书存储中创建的证书可供整个计算机使用，而在当前用户存储中创建的证书仅限于当前用户。
- en: 'Let’s create a self-signed certificate and add it to the computer’s root certificate
    store, as well as to the computer’s **Trusted Publishers** store. First, we must
    create a new certificate called **"Test Certificate"** in the local machine’s
    certificate store and save the output in the **$testCert** variable. We will need
    this variable later to register the **authenticode certificate**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自签名证书并将其添加到计算机的根证书存储区，以及计算机的**受信任发布者**存储区。首先，我们必须在本地计算机的证书存储区中创建一个名为**“测试证书”**的新证书，并将输出保存在**$testCert**变量中。我们稍后将需要这个变量来注册**authenticode
    证书**：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we’ve done this, we will add the authenticode certificate to our computer’s
    root certificate store. A root certificate store is a list of trusted root CA
    certificates, so every certificate in this store will be trusted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将把 authenticode 证书添加到计算机的根证书存储区。根证书存储区是一个受信任的根 CA 证书列表，因此存储区中的每个证书都会被信任。
- en: 'We must move the newly created certificate from the intermediate CA store to
    the **root** **certificate store**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将新创建的证书从中间 CA 存储移动到**根** **证书存储区**：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, your certificate should be available in two different locations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的证书应该出现在两个不同的位置：
- en: '**The local machine’s personal certificate store**: This certificate will be
    used as the code-signing certificate.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地计算机的个人证书存储区**：此证书将作为代码签名证书使用。'
- en: '**The local machine’s root certificate store**: Adding the certificate to the
    machine’s root certificate store ensures that the local computer trusts certificates
    in the personal as well as the **Trusted Publishers** certificate store.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地计算机的根证书存储区**：将证书添加到计算机的根证书存储区可以确保本地计算机信任个人证书存储区以及**受信任发布者**证书存储区中的证书。'
- en: 'You can verify that all the certificates are in the right place by either using
    PowerShell or by using **mmc** with the local computer’s certificate snap-in (run
    **mmc**, add the **Certificates** snap-in, and add the local computer scope),
    as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 PowerShell 或者通过使用**mmc**和本地计算机的证书管理单元来验证所有证书是否都在正确的位置（运行**mmc**，添加**证书**管理单元，并选择本地计算机范围），如下图所示：
- en: '![Figure 11.2 – Looking for the newly created Test Certificate](image/B16679_11_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 查找新创建的测试证书](image/B16679_11_002.jpg)'
- en: Figure 11.2 – Looking for the newly created Test Certificate
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 查找新创建的测试证书
- en: 'If you want to use PowerShell to check if all the certificates were created,
    run the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 PowerShell 检查所有证书是否已创建，可以运行以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see the output of this command in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中看到此命令的输出：
- en: '![Figure 11.3 – Verifying that all the certificates are in the right place](image/B16679_11_003.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 验证所有证书是否都在正确的位置](image/B16679_11_003.jpg)'
- en: Figure 11.3 – Verifying that all the certificates are in the right place
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 验证所有证书是否都在正确的位置
- en: Now that we have created our local certificate, we can start self-signing scripts
    using the **Set-AuthenticodeSignature** cmdlet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了本地证书，可以开始使用**Set-AuthenticodeSignature** cmdlet 来对脚本进行自签名。
- en: 'For this example, I am reusing the **HelloWorld.ps1** PowerShell script that
    we created in [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting
    Started with PowerShell*, which can be downloaded from this book’s GitHub repository:
    [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我重用了我们在[*第 1 章*](B16679_01_Final_PD.xhtml#_idTextAnchor016)中创建的**HelloWorld.ps1**
    PowerShell 脚本，*开始使用 PowerShell*，该脚本可以从本书的 GitHub 仓库下载：[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1)。
- en: Save the script under **C:\tmp\HelloWorld.ps1**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存在**C:\tmp\HelloWorld.ps1**下。
- en: If you still have the **$testCert** variable available in your session, which
    we used earlier when creating the certificate, you can, of course, reuse it, but
    most of the time, when you want to sign a script, time has already passed and
    you’ve closed the session so that the variable isn’t available for you to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在会话中仍然可以使用之前创建证书时使用的**$testCert**变量，你当然可以重用它，但大多数情况下，当你想要签署脚本时，时间已经过去，你可能已经关闭了会话，这样该变量就无法使用了。
- en: 'Therefore, first, assign the certificate to a variable that you will use to
    sign your script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，将证书分配给一个变量，以便您用它来签署脚本：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure you specify the correct name of the certificate that you created earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保指定您之前创建的证书的正确名称。
- en: To ensure that the signature on the file remains valid, even after the certificate
    expires after a year, it is important to use a trustworthy timestamp server when
    signing the script. You can do this using **Set-AuthenticodeSignature**. The timestamp
    server adds a timestamp to the signed code that indicates the exact date and time
    when the code was signed. This timestamp is used to prove that the code was signed
    before the certificate expired, even if the certificate has since expired.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保文件上的签名保持有效，即使证书在一年后过期，在签名脚本时使用一个可信的时间戳服务器也非常重要。您可以使用**Set-AuthenticodeSignature**来做到这一点。时间戳服务器会将时间戳添加到签名代码中，表示代码签名的确切日期和时间。这个时间戳用于证明代码是在证书过期之前签名的，即使证书已经过期。
- en: 'Therefore, it is recommended to always use a reliable and well-known timestamp
    server to ensure the longevity and authenticity of your signed code. The **Time-Stamp
    Protocol** (**TSP**) standard is defined in **RFC3161** and you can read more
    about it here: [https://www.ietf.org/rfc/rfc3161.txt](https://www.ietf.org/rfc/rfc3161.txt).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议始终使用一个可靠且知名的时间戳服务器，以确保签名代码的长期有效性和真实性。**时间戳协议**（**TSP**）标准定义在**RFC3161**中，您可以在这里阅读更多内容：[https://www.ietf.org/rfc/rfc3161.txt](https://www.ietf.org/rfc/rfc3161.txt)。
- en: 'There’s a great (but of course non-complete) list that’s been published by
    David Manouchehri that you can use to choose your preferred timestamp server:
    [https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710](https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由David Manouchehri发布了一个很棒（但当然不是完整的）列表，您可以使用它来选择您首选的时间戳服务器：[https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710](https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710)。
- en: 'For our example, I am using the **http://timestamp.digicert.com** server:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我使用的是**http://timestamp.digicert.com**服务器：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the script has been signed successfully, the output will look similar
    to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本成功签名，输出将类似于以下内容：
- en: '![Figure 11.4 – Script signed successfully](image/B16679_11_004.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 脚本签名成功](image/B16679_11_004.jpg)'
- en: Figure 11.4 – Script signed successfully
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 脚本签名成功
- en: 'You can verify that a script has been signed by using the **Get-AuthenticodeSignature
    -FilePath C:\tmp\HelloWorld.ps1 | Format-List** command, as shown in the following
    screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用**Get-AuthenticodeSignature -FilePath C:\tmp\HelloWorld.ps1 | Format-List**命令来验证脚本是否已签名，如以下截图所示：
- en: '![Figure 11.5 – Verifying that a file has been signed](image/B16679_11_005.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 验证文件是否已签名](image/B16679_11_005.jpg)'
- en: Figure 11.5 – Verifying that a file has been signed
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 验证文件是否已签名
- en: 'But this is not the only way to verify that a file has been signed. If you
    right-click on a signed file and open its properties, under the **Digital Signatures**
    tab, you will see that the certificate you used for signing was added:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是验证文件是否已签名的唯一方法。如果您右键点击一个已签名的文件并打开其属性，在**数字签名**选项卡下，您将看到用于签名的证书已被添加：
- en: '![Figure 11.6 – Verifying that a file has been signed using file properties](image/B16679_11_006.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 使用文件属性验证文件是否已签名](image/B16679_11_006.jpg)'
- en: Figure 11.6 – Verifying that a file has been signed using file properties
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 使用文件属性验证文件是否已签名
- en: 'Also, if you open the newly signed script, you will see that its content has
    changed: instead of only the code, you will see the signature as well – introduced
    by **# SIG # Begin signature block** and closed out by **# SIG # End signature
    block** and in between a huge signature block. As shown in the following screenshot,
    I have shortened the signature block as the signature would be too big to show
    as a figure in this book:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，如果您打开新签名的脚本，您会看到其内容发生了变化：除了代码之外，您还会看到签名——由**# SIG # Begin signature block**引入，并由**#
    SIG # End signature block**结束，中间是一个巨大的签名块。如以下截图所示，我已经缩短了签名块，因为签名会太大，无法在本书中显示为图片：'
- en: '![Figure 11.7 – The signed file now contains a signature block](image/B16679_11_007.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 签名后的文件现在包含签名块](image/B16679_11_007.jpg)'
- en: Figure 11.7 – The signed file now contains a signature block
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 签名后的文件现在包含签名块
- en: 'If we were to enable **ExecutionPolicy AllSigned** and attempt to run the self-signed
    script, we’d be asked if we really want to run software from this untrusted publisher:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用**ExecutionPolicy AllSigned**并尝试运行自签名脚本，则会询问我们是否真的想要从此不受信任的发布者运行软件：
- en: '![Figure 11.8 – The ExecutionPolicy prompt](image/B16679_11_008.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 执行策略提示](image/B16679_11_008.jpg)'
- en: Figure 11.8 – The ExecutionPolicy prompt
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 执行策略提示
- en: To execute this script, we must select **[R] Run once**. If you want to permanently
    run scripts from this publisher without being prompted each time, you can use
    the **[A] Always** **Run** option.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此脚本，我们必须选择**[R] Run once**。如果您希望每次都无需提示即可永久运行来自此发布者的脚本，可以使用**[A] Always**
    **Run**选项。
- en: If you want to run scripts from this publisher without being prompted at all,
    you can add the self-signed certificate to the **Trusted Publishers** store. This
    allows you to establish a trusted relationship between the publisher and your
    computer, ensuring that scripts from the publisher are automatically trusted and
    executed without interruptions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望无需任何提示即可运行来自此发布者的脚本，可以将自签名证书添加到**受信任的发布者**存储中。这允许您在发布者和您的计算机之间建立一个信任关系，确保来自发布者的脚本自动受信并且无中断地执行。
- en: 'If we want to permanently run scripts from this publisher without being prompted,
    we need to add our self-signed certificate to the computer’s **Trusted Publishers**
    **certificate store**:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望永久运行来自此发布者的脚本而无需提示，我们需要将自签名证书添加到计算机的**受信任的发布者**证书存储中：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By adding the certificate to the **Trusted Publishers** store, you can ensure
    that all the code signed by your self-signed certificate can be trusted. Since
    it is not possible to copy certificates from one store to another by using **Copy-Item**,
    we must use the **Certificate Store API** interface to access the **Trusted Publishers**
    certificate store, then open it with read/write permissions, add the certificate
    that we created earlier, and close the store again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将证书添加到**受信任的发布者**存储中，您可以确保所有由您的自签名证书签名的代码都是可信的。由于不能使用**Copy-Item**从一个存储复制证书到另一个存储，因此我们必须使用**证书存储
    API**接口来访问**受信任的发布者**证书存储，然后以读写权限打开它，添加我们之前创建的证书，然后再次关闭存储。
- en: 'Now, if we execute the **HelloWorld.ps1** script again, it will run without
    prompting us, whereas an unsigned file would be rejected:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次执行**HelloWorld.ps1**脚本，它将在不提示我们的情况下运行，而未经签名的文件将被拒绝：
- en: '![Figure 11.9 – A signed file can be executed without any problems](image/B16679_11_009.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 经过签名的文件可以无问题执行](image/B16679_11_009.jpg)'
- en: Figure 11.9 – A signed file can be executed without any problems
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 经过签名的文件可以无问题执行
- en: If you have any application control mechanism in place, such as AppLocker or
    WDAP, only a signed file will be allowed to run – *if* the publisher was added
    as a trusted source for the application control mechanism to run. Depending on
    the application control system in use, this can be done using, for example, a
    **publisher rule** in a policy, or another similar mechanism to trust the publisher.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经实施了任何应用程序控制机制，例如 AppLocker 或 WDAP，则只允许运行经过签名的文件 – *如果* 发布者已添加为信任的应用程序控制机制运行的可信来源。根据所使用的应用程序控制系统，可以通过策略中的**发布者规则**或其他类似机制来信任发布者。
- en: 'Since script signing adds a signature for exactly the file you signed, the
    file cannot be modified if the signature should remain valid. If you were to modify
    the content of the signed file and verify the signature using **Get-AuthenticodeSignature**,
    you would see that the hash of the signature does not match the content of the
    file anymore. Therefore, the signature will be invalid and the file cannot be
    executed any longer if protection mechanisms against unsigned scripts have been
    applied:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本签名为签署的确切文件添加了签名，如果要保持签名的有效性，则无法修改该文件。如果您修改了已签名文件的内容，并使用**Get-AuthenticodeSignature**验证签名，您会发现签名的哈希值不再与文件内容匹配。因此，签名将无效，如果已应用未签名脚本的保护机制，则无法再执行该文件：
- en: '![Figure 11.10 – HashMismatch after changing the signed file’s content](image/B16679_11_010.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 修改已签名文件内容后的哈希不匹配](image/B16679_11_010.jpg)'
- en: Figure 11.10 – HashMismatch after changing the signed file’s content
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 修改已签名文件内容后的哈希不匹配
- en: Therefore, whenever you modify the content of a signed file, you will need to
    sign it once more. If you have a **continuous integration/continuous delivery**
    (**CI/CD**) pipeline in place, script signing can easily be automated using the
    **Set-AuthenticodeSignature** cmdlet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当您修改已签名文件的内容时，您需要再次对其进行签名。如果您有一个**持续集成/持续交付**（**CI/CD**）管道，脚本签名可以通过**Set-AuthenticodeSignature**
    cmdlet轻松自动化。
- en: There are several ways to build a CI/CD pipeline if you are new to this concept.
    Just to mention a few, a CI/CD pipeline can, for example, be realized using Azure
    DevOps or GitHub.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是CI/CD概念的初学者，有多种方法可以构建CI/CD管道。仅举几例，CI/CD管道可以通过Azure DevOps或GitHub来实现。
- en: 'The following are some resources to help you get started with this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助您入门的资源：
- en: '*Design a CI/CD pipeline using Azure* *DevOps*: [https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture](https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Azure设计CI/CD管道* *DevOps*：[https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture](https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture)'
- en: )
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*How to build a CI/CD pipeline with GitHub Actions in four simple* *steps*:
    [https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/](https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/
    )'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何用GitHub Actions构建CI/CD管道的四个简单步骤*：[https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/](https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/)'
- en: 'It’s important to also make sure you apply code signing best practices when
    you are planning to use code signing in your production environment. Microsoft
    has published a *Code Signing Best Practices* document for this, which you use
    as a reference: http://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/best_practices.doc.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，确保在计划在生产环境中使用代码签名时，遵循最佳实践也非常重要。微软发布了一个*代码签名最佳实践*文档，您可以将其作为参考：[http://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/best_practices.doc](http://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/best_practices.doc)
- en: Code signing is a great way to ensure that your scripts are legit and were not
    tampered with. But as you learned earlier in this book, the execution policy alone
    is not a security boundary and can easily be bypassed. Therefore, only relying
    on the execution policy is not a good idea. If you want to prevent unauthorized
    scripts from running in your environment, you need to implement an application
    control solution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码签名是确保您的脚本合法且未被篡改的好方法。但正如您在本书前面学到的，仅凭执行策略并不是安全边界，且很容易被绕过。因此，仅依赖执行策略并不是一个好主意。如果您想防止未经授权的脚本在您的环境中运行，您需要实施应用程序控制解决方案。
- en: Controlling applications and scripts
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制应用程序和脚本
- en: An application control solution not only protects against unauthorized PowerShell
    scripts; it can also be used to define which applications, executables, and DLLs
    are allowed to run in the environment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制解决方案不仅可以防止未经授权的PowerShell脚本，还可以用于定义哪些应用程序、可执行文件和DLL被允许在环境中运行。
- en: It is important to keep in mind that while PowerShell attacks may seem like
    a concern for many professionals, they represent a relatively small portion of
    the malware that makes its way onto systems. It is essential to not overlook the
    danger posed by traditional executable and DLL attacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的是，尽管PowerShell攻击可能是许多专业人员关心的问题，但它们只占通过系统传播的恶意软件的一小部分。必须重视传统的可执行文件和DLL攻击所带来的威胁，切勿忽视这一点。
- en: Application control solutions often provide a possibility to also just prohibit
    single unwanted applications, but the desired outcome should always be to prohibit
    everything and configure all allowed applications. As you may recall from [*Chapter
    5*](B16679_05_Final_PD.xhtml#_idTextAnchor110), *PowerShell Is Powerful – System
    and API Access*, even if you block **PowerShell.exe** in your environment, it
    is still possible to run it by just using the native API functions, irrespective
    of whether it makes sense to block PowerShell (you shouldn’t, of course; it’s
    better to implement and leverage a proper logging and security strategy instead).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制解决方案通常提供禁止单个不需要的应用程序的功能，但理想的结果应始终是禁止所有应用程序并配置所有允许的应用程序。如您在[*第5章*](B16679_05_Final_PD.xhtml#_idTextAnchor110)中所回忆的，*PowerShell非常强大——系统和API访问*，即使您在环境中阻止了**PowerShell.exe**，也仍然可以通过使用本地API函数来运行它，无论是否有必要阻止PowerShell（当然，您不应该这么做；更好的做法是实施并利用正确的日志记录和安全策略）。
- en: If you were to only prohibit unwanted applications, attackers would always find
    a way to circumvent your restrictions – there’s just too much to block and only
    prohibiting unwanted applications would make your environment always vulnerable
    to attacks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是禁止不需要的应用程序，攻击者总是能找到绕过你限制的方法——要屏蔽的东西实在太多，仅仅禁止不需要的应用程序会让你的环境始终处于攻击的脆弱状态。
- en: It’s better to directly start by auditing what software is used and needed in
    your environment, implementing a proper application control strategy, and preventing
    everything else from being run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从直接审计你环境中使用和需要的软件开始，实施适当的应用控制策略，并防止其他一切程序的运行。
- en: There are many application control tools on the market, but in this book, we
    will only look at Microsoft AppLocker and WDAC.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多应用控制工具，但在本书中，我们只关注微软的AppLocker和WDAC。
- en: Planning for application control
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用控制规划
- en: Before applying strict rules to enforce application control to your production
    environment, make sure that you always audit and create a software catalog of
    the applications used. You don’t want to impact your employees in such a way that
    they are no longer able to work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在将严格的规则强制应用于你的生产环境之前，确保你始终审计并创建一个已使用应用程序的软硬件目录。你不希望对员工产生如此大的影响，导致他们无法正常工作。
- en: 'Even if you are only implementing an audit policy, you have already significantly
    improved the signal-to-noise ratio in your SIEM. Consider this scenario: before
    implementing application control, your SIEM is flooded with thousands of events
    every day from known and authorized applications, making it extremely challenging
    to identify potential malware or unwanted software.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你只是实施审计策略，你也已经显著改善了SIEM中的信噪比。考虑一下这种情况：在实施应用控制之前，你的SIEM每天都会被成千上万的事件淹没，这些事件来自已知和授权的应用程序，这使得识别潜在的恶意软件或不需要的软件变得极其具有挑战性。
- en: But if you are only able to implement 80% of an application control policy,
    and therefore only enable auditing, the number of events already decreases to
    a manageable level. In this case, you would be left with only a few hundred events
    per day, which contain legitimate software operations and a potential subset of
    unwanted software or malware. This approach already reduces the noise in your
    SIEM significantly and enables you to defend your environment in a much better
    way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你只能实施80%的应用控制策略，因此只启用审计功能，那么事件的数量就会减少到一个可管理的水平。在这种情况下，你每天只会剩下几百个事件，这些事件包含合法的软件操作以及潜在的不需要的软件或恶意软件。这种方法已经显著减少了你的SIEM中的噪音，并使你能够以更好的方式保护你的环境。
- en: 'Once you have created the first policy, make sure you test it before rolling
    it out. Once you are ready to deploy it, follow the following rollout strategy:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了第一个策略，确保在推出之前进行测试。一旦你准备好部署，按照以下推出策略进行：
- en: Test your policy in a test environment.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试环境中测试你的策略。
- en: It can be very useful to announce your configuration changes as early as possible
    so that your employees can plan better.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽早宣布你的配置更改是非常有用的，这样员工就能更好地进行规划。
- en: Divide your tech department into several groups, then slowly roll out the policy
    for the first group, review audit logs, and fix problems on the fly. Once fixed,
    roll out the policy to the next group and so on.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的技术部门划分为几个小组，然后慢慢为第一个小组推出策略，审查审计日志，并及时修复问题。一旦修复完毕，就为下一个小组推出策略，依此类推。
- en: If everything worked during the last deployment step, enroll your policy for
    power users in your environment. Needless to say, always communicate it to the
    people who’d be affected before rolling out such a policy.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在上一步部署时一切正常，将你的策略推广到你环境中的高级用户。不言而喻，在推出此类策略之前，始终与可能受影响的人进行沟通。
- en: After fixing all probable configuration issues, slowly roll out the policy department
    by department. Always make sure you divide each group into sub-groups and communicate
    it to the affected employees before enforcing changes.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修复所有可能的配置问题后，慢慢按部门推出策略。始终确保你将每个小组划分为子小组，并在强制更改之前与受影响的员工进行沟通。
- en: Always review your blocked applications regularly. This not only helps you identify
    problems your users might have but also helps you spot the beginning of an attack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 定期审查你封锁的应用程序。这不仅有助于你识别用户可能遇到的问题，还能帮助你发现攻击的初期迹象。
- en: It takes some time to identify which applications are in use and to adjust your
    configuration accordingly, but it is worth the effort and it will help you harden
    your environment enormously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 确定正在使用哪些应用程序并相应调整配置需要一些时间，但这是值得的，它将大大帮助您加固环境。
- en: First, let’s look at which application control options are available on Windows
    operating systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看在 Windows 操作系统上有哪些可用的应用程序控制选项。
- en: Built-in application control solutions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内建的应用程序控制解决方案
- en: Over the years, Microsoft has worked on several solutions for application control,
    starting with SRP with Windows XP to AppLocker, which was introduced with Windows
    8 – until they finally released WDAC with Windows 10.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，微软一直在开发多种应用程序控制解决方案，从 Windows XP 的 SRP 到 Windows 8 引入的 AppLocker，再到最终在 Windows
    10 中发布的 WDAC。
- en: Over the years, capabilities have been improved enormously and each tool brought
    advantages to their former versions. If possible, always use WDAC for application
    control as it will be continuously improved. But if you are still using older
    operating system versions that you need to restrict, it is possible to run all
    three solutions in parallel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，功能得到了极大的改进，每个工具都为其前版本带来了优势。如果可能，请始终使用 WDAC 进行应用程序控制，因为它会不断得到改进。但如果您仍在使用需要限制的较旧操作系统版本，可以同时运行这三种解决方案。
- en: 'The following figure provides you with a simplified comparison of all three
    solutions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下图为您提供了这三种解决方案的简化比较：
- en: '![Figure 11.11 – Simplified comparison of SRP, AppLocker, and WDAC](image/B16679_11_011.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – SRP、AppLocker 和 WDAC 的简化比较](image/B16679_11_011.jpg)'
- en: Figure 11.11 – Simplified comparison of SRP, AppLocker, and WDAC
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – SRP、AppLocker 和 WDAC 的简化比较
- en: 'Of course, this is not a complete list of all features. Please refer to the
    following links for a more detailed overview of which differences exist between
    SRP, AppLocker, and WDAC:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是所有功能的完整列表。请参阅以下链接，了解 SRP、AppLocker 和 WDAC 之间的差异的更详细概述：
- en: '*What features are different between Software Restriction Policies and* *AppLocker?*:
    [https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件限制策略与* *AppLocker 之间有哪些功能不同？*: [https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker'
- en: )
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Windows Defender Application Control and AppLocker feature* *availability*:
    [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows Defender 应用程序控制和 AppLocker 功能* *可用性*: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability)'
- en: These solutions are huge topics, so you will only find an overview of each technology,
    as well as some tips and tricks that will help you start implementing your own
    application control rules. As the focus of this book is PowerShell, we will also
    focus mostly on restricting and using PowerShell in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案是庞大的话题，因此您只会看到每种技术的概述，以及一些帮助您开始实施自己应用程序控制规则的技巧。由于本书的重点是 PowerShell，我们将在本章中主要关注限制和使用
    PowerShell。
- en: Getting familiar with Microsoft AppLocker
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Microsoft AppLocker
- en: AppLocker is Microsoft’s successor to SRP and was introduced with Windows 7\.
    You can use it to extend SRP’s function, as well as its features.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: AppLocker 是微软推出的 SRP 的继任者，并在 Windows 7 中引入。您可以使用它扩展 SRP 的功能以及它的特性。
- en: 'In comparison to SRP, AppLocker policies can be scoped to specific users or
    groups and it’s also possible to audit before you enforce rules. It is possible
    to deploy SRP and AppLocker policies in parallel in various ways; take a look
    at the following documentation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SRP 相比，AppLocker 策略可以限制特定的用户或组，并且也可以在强制执行规则之前进行审计。可以通过多种方式并行部署 SRP 和 AppLocker
    策略；请查看以下文档：
- en: '*Use AppLocker and Software Restriction Policies in the same* *domain*: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在同一* *域中使用 AppLocker 和软件限制策略*：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain)'
- en: '*Use Software Restriction Policies and AppLocker* *policies*: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用软件限制策略和 AppLocker* *策略*：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies)'
- en: Computers on which you want to deploy AppLocker need to have an operating system
    installed that allows AppLocker policies to be enforced, such as Windows Enterprise.
    You can also create AppLocker rules on a computer running Windows Professional.
    However, it is only possible to enforce AppLocker rules on Windows Professional
    and other operating system versions if they are managed with Intune. If AppLocker
    rules are not enforced, they don’t apply and give you no protection at all.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署 AppLocker 的计算机需要安装允许强制执行 AppLocker 策略的操作系统，如 Windows Enterprise。你也可以在运行
    Windows Professional 的计算机上创建 AppLocker 规则。然而，只有当这些系统通过 Intune 进行管理时，才能强制执行 AppLocker
    规则。如果没有强制执行 AppLocker 规则，它们将不生效，且无法提供任何保护。
- en: If you want to restrict applications on unsupported operating systems, you can
    either deploy SRP rules in parallel or use WDAC.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想限制在不受支持的操作系统上的应用程序，可以同时部署 SRP 规则，或者使用 WDAC。
- en: For AppLocker to work properly, it is required that the **Application Identity**
    service is running.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 AppLocker 正常工作，要求 **应用程序身份** 服务必须在运行。
- en: Deploying AppLocker
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 AppLocker
- en: You can deploy AppLocker using GPO, Intune, **Microsoft Configuration Manager**,
    and PowerShell. Of course, you can also use Local Group Policy Editor for testing
    purposes. However, it is not possible to enforce AppLocker rules using this method,
    so you should avoid it in production.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 GPO、Intune、**Microsoft 配置管理器**和 PowerShell 部署 AppLocker。当然，你也可以使用本地组策略编辑器进行测试。但通过此方法无法强制执行
    AppLocker 规则，因此你应避免在生产环境中使用。
- en: 'When working with AppLocker, there are five different rule types that you can
    configure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 AppLocker 时，你可以配置五种不同的规则类型：
- en: '**Executable Rules**: Using **Executable Rules**, you can restrict executables
    that end in **.exe** and **.com**.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可执行规则**：使用 **可执行规则**，你可以限制以 **.exe** 和 **.com** 结尾的可执行文件。'
- en: '**Windows Installer Rules**: By configuring **Windows Installer Rules**, you
    can restrict **.msi**, **.mst**, and **.msp** Windows Installer files.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 安装程序规则**：通过配置 **Windows 安装程序规则**，你可以限制 **.msi**、**.mst** 和 **.msp**
    Windows 安装程序文件。'
- en: '**Script Rules**: With **Script Rules**, you can restrict **.ps1**, **.bat**,
    **.cmd**, **.vbs**, and **.js** script files.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本规则**：使用 **脚本规则**，你可以限制 **.ps1**、**.bat**、**.cmd**、**.vbs** 和 **.js** 脚本文件。'
- en: '**DLL rules**: You can use DLL rules to restrict **.dll** and **.****ocx**
    files.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DLL 规则**：你可以使用 DLL 规则来限制 **.dll** 和 **.ocx** 文件。'
- en: Although DLL rules were once considered optional due to concerns about performance,
    in today’s security landscape, an app control system without DLL enforcement enabled
    is incomplete and leaves your environment vulnerable. These rules have to be enabled
    before they can be used and configured using GPO or a local Group Policy. If you
    are using GPOs for your configuration, go to **Computer Configuration** | **Policies**
    | **Windows Settings** | **Security Settings** | **Application Control Policies**
    | **AppLocker**. Then, right-click **AppLocker** and select **Properties** | **Advanced**
    | **Enable the DLL** **rule collection.**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于性能问题，DLL 规则曾经被认为是可选的，但在当今的安全环境中，没有启用 DLL 强制执行的应用程序控制系统是不完整的，会使您的环境容易受到攻击。这些规则必须在使用和配置之前启用，并且可以使用
    GPO 或本地组策略进行配置。如果您正在使用 GPO 进行配置，请转到**计算机配置** | **策略** | **Windows 设置** | **安全设置**
    | **应用程序控制策略** | **AppLocker**。然后，右键单击**AppLocker**，选择**属性** | **高级** | **启用 DLL
    规则集合**。
- en: '**Packaged app Rules**: Using **Packaged app Rules**, you can restrict **.appx**
    package files.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包应用规则**：使用**打包应用规则**，您可以限制**.appx**包文件。'
- en: For every rule you create, you need to select an action. Here, you must decide
    whether a file should be allowed or blocked by choosing either **Allow** or **Deny**.
    Usually, you want to block everything and only allow the selected applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您创建的每个规则，您需要选择一个操作。在这里，您必须决定文件是应该被允许还是被阻止，通过选择**允许**或**拒绝**。通常，您希望阻止一切，只允许选定的应用程序。
- en: Using AppLocker rules, it is also possible to scope the rule to a particular
    **User or group**. If nothing is specified in particular, the rule applies to
    **Everyone**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AppLocker 规则，也可以将规则范围限定到特定的**用户或组**。如果没有特别指定，规则适用于**所有人**。
- en: 'You will also need to decide on the *primary condition* that the rule should
    contain. For **Packaged app Rules**, you can only configure a **Publisher** condition;
    for all other rules, **Path** and **File hash** conditions can be applied – in
    addition to the **Publisher** conditions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要决定规则应包含的*主要条件*。对于**打包应用规则**，您只能配置一个**发布者**条件；对于所有其他规则，可以应用**路径**和**文件哈希**条件
    - 除了**发布者**条件：
- en: '**Path**: Using the **Path** condition, you can specify a path that will be
    either allowed or denied by your rule. You can also define an exception. Using
    the **Path** condition is the most insecure condition as file and path names can
    easily be changed to bypass your rules. If possible, try to avoid path rules.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：使用**路径**条件，您可以指定一个路径，该路径将被规则允许或拒绝。您还可以定义一个异常。使用**路径**条件是最不安全的条件，因为文件和路径名称很容易被更改以绕过您的规则。如果可能的话，尽量避免路径规则。'
- en: '**Publisher**: When using the **Publisher** condition, a file needs to be digitally
    signed. Using this condition, you can not only specify the publisher – you can
    also specify the product name, the filename, as well as the file version that
    a file should have to be allowed or denied. It is also possible to define exceptions.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：使用**发布者**条件时，文件需要进行数字签名。使用此条件，您不仅可以指定发布者 - 还可以指定产品名称、文件名以及文件版本，以确定文件是否应该被允许或拒绝。也可以定义异常。'
- en: '**File hash**: A cryptographic file hash will be calculated for this file.
    If the file changes, the file hash will change as well. Therefore, a hash can
    only apply to one file and you need to configure a file hash condition for every
    file you want to allow or deny if this condition is used.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件哈希**：将为此文件计算一个加密文件哈希。如果文件发生更改，文件哈希也将发生变化。因此，哈希只能应用于一个文件，如果使用此条件，您需要为要允许或拒绝的每个文件配置一个文件哈希条件。'
- en: All these rules, actions, user scopes, and conditions apply to all configuration
    methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些规则、操作、用户范围和条件都适用于所有配置方法。
- en: 'Configuring AppLocker in your environment can take some time, but it is worth
    it once you have implemented it. To help you with your initial configuration,
    Aaron Margosis released *AaronLocker* on GitHub: [https://github.com/microsoft/AaronLocker](https://github.com/microsoft/AaronLocker).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的环境中配置 AppLocker 可能需要一些时间，但一旦实施，它就是值得的。为了帮助您进行初始配置，Aaron Margosis 在 GitHub
    上发布了 *AaronLocker*：[https://github.com/microsoft/AaronLocker](https://github.com/microsoft/AaronLocker)。
- en: This script and documentation collection should help make your initial configuration,
    as well as the maintenance of your AppLocker rules, as easy as possible.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本和文档集合应该有助于使您的初始配置以及维护您的 AppLocker 规则尽可能简单。
- en: Behind AaronLocker – Where Did the Name Come From?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: AaronLocker 的背后 - 名字是从哪里来的？
- en: The name *AaronLocker* was not Aaron’s idea himself – it was the idea of my
    friend and long-time mentor Chris Jackson, who unfortunately passed away some
    time ago (rest in peace, Chris!). Aaron was not especially fond to call his product
    after his first name, but since he could not think of a better name, he gave in
    to Chris’ idea and so the name *AaronLocker* was born.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*AaronLocker*这个名字并不是Aaron自己想出来的——这是我的朋友兼长期导师Chris Jackson的主意。不幸的是，他在不久前去世了（愿Chris安息！）。Aaron并不特别喜欢将他的产品命名为自己的名字，但由于他一时想不出更好的名字，于是他妥协了，接受了Chris的建议，*AaronLocker*这个名字也就诞生了。'
- en: However, we have only learned what AppLocker rules consist of and not how to
    deploy and configure them using different deployment methods. Therefore, as a
    next step, we’ll explore how AppLocker can be managed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们目前仅了解了AppLocker规则的组成部分，并未学习如何通过不同的部署方法来部署和配置这些规则。因此，接下来的步骤是探索如何管理AppLocker。
- en: GPO
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPO
- en: 'If you are using GPOs or Local Group Policy for your configuration, navigate
    to **Computer Configuration** | **Policies** | **Windows Settings** | **Security
    Settings** | **Application Control Policies** | **AppLocker**. In this section,
    you will find the **Executable Rules**, **Windows Installer Rules**, **Script
    Rules**, and **Packaged app Rules** options, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用GPO或本地组策略进行配置，请导航到**计算机配置** | **策略** | **Windows 设置** | **安全设置** | **应用程序控制策略**
    | **AppLocker**。在此部分，您将看到**可执行规则**、**Windows安装程序规则**、**脚本规则**和**打包应用规则**选项，如下所示：
- en: '![Figure 11.12 – Configuring AppLocker using GPO](image/B16679_11_012.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 使用GPO配置AppLocker](image/B16679_11_012.jpg)'
- en: Figure 11.12 – Configuring AppLocker using GPO
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 使用GPO配置AppLocker
- en: To enable the enforcement or auditing behavior, right-click on AppLocker and
    select **Properties**. In the window that appears, you can configure which AppLocker
    rules should be enforced or audited.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用强制执行或审计行为，右键单击**AppLocker**并选择**属性**。在弹出的窗口中，您可以配置哪些AppLocker规则应被强制执行或审计。
- en: If you are using GPOs as a configuration method, make sure that all the systems
    you want to configure have at least Windows 10 Enterprise installed. Otherwise,
    you cannot enforce AppLocker rules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用GPO作为配置方法，请确保您要配置的所有系统至少安装了Windows 10企业版。否则，您无法强制执行AppLocker规则。
- en: If you also want to enable DLL rules, you can do this by right-clicking on **AppLocker**
    and selecting **Properties** | **Advanced** | **Enable the DLL rule collection**.
    Refer to the descriptions of the DLL rules to learn more about them. After enabling
    DLL rules, they will show up under AppLocker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还想启用DLL规则，可以通过右键单击**AppLocker**并选择**属性** | **高级** | **启用DLL规则集合**来实现。请参考DLL规则的描述以了解更多信息。启用DLL规则后，它们将在AppLocker下显示。
- en: Intune
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Intune
- en: 'Before you can configure AppLocker via Intune, you will need to create an AppLocker
    policy using GPO or Local Group Policy. Once your configuration is ready, export
    it by right-clicking on **AppLocker** and selecting **Export Policy**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在您通过Intune配置AppLocker之前，您需要使用GPO或本地组策略创建一个AppLocker策略。配置完成后，通过右键单击**AppLocker**并选择**导出策略**来导出策略：
- en: '![Figure 11.13 – Exporting the AppLocker policy](image/B16679_11_013.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 导出AppLocker策略](image/B16679_11_013.jpg)'
- en: Figure 11.13 – Exporting the AppLocker policy
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 导出AppLocker策略
- en: A window will appear where you need to select where your exported policy should
    be saved to. Select a path and confirm it; your AppLocker policy will be successfully
    exported as a **.****xml** file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将弹出一个窗口，您需要选择导出策略保存的路径。选择一个路径并确认；您的AppLocker策略将成功导出为**.****xml**文件。
- en: Unfortunately, you cannot just copy and paste the content of the file into your
    Intune configuration. Therefore, open the file with an editor and search for each
    rule type for its section. This is indicated by the **<RuleCollection …> … </RuleCollection>**
    tags from **RuleCollection**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，您不能仅将文件内容复制并粘贴到Intune配置中。因此，使用编辑器打开文件并搜索每个规则类型的部分。该部分由**<RuleCollection
    …> … </RuleCollection>**标签表示，来自**RuleCollection**。
- en: 'There’s one **RuleCollection** section for every rule type, so if you want
    to get the **RuleCollection** section for all executable files, select everything
    between **<RuleCollection Type="Exe" EnforcementMode="NotConfigured">**, including
    the surrounding tags, as shown in the following screenshot. If needed, repeat
    this for the other available rule types:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每种规则类型都有一个**RuleCollection**部分，因此，如果您想获取所有可执行文件的**RuleCollection**部分，请选择**<RuleCollection
    Type="Exe" EnforcementMode="NotConfigured">**之间的所有内容，包括周围的标签，如下图所示。如有需要，重复此操作以获取其他可用规则类型的部分：
- en: '![Figure 11.14 – Selecting the RuleCollection section for executable rules](image/B16679_11_014.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 选择可执行规则的 RuleCollection 部分](image/B16679_11_014.jpg)'
- en: Figure 11.14 – Selecting the RuleCollection section for executable rules
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 选择可执行规则的 RuleCollection 部分
- en: 'Configuring AppLocker using Intune relies on the AppLocker **configuration
    service provider** (**CSP**): [https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp](https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Intune 配置 AppLocker 依赖于 AppLocker **配置服务提供程序**（**CSP**）：[https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp](https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp).
- en: The CSP provides an interface that allows **mobile device management** (**MDM**)
    solutions to control, configure, read, delete, and edit the configuration settings
    of the device that’s being managed. A custom configuration for a Windows 10 device
    can be configured using the **Open Mobile Alliance Uniform Resource Identifier**
    (**OMA-URI**) string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CSP 提供了一个接口，允许**移动设备管理**（**MDM**）解决方案控制、配置、读取、删除和编辑正在管理的设备的配置设置。可以使用**开放移动联盟统一资源标识符**（**OMA-URI**）字符串配置
    Windows 10 设备的自定义配置。
- en: 'Thanks to Intune and the AppLocker CSP, most operating systems can be configured
    to use AppLocker in Enforcement mode:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Intune 和 AppLocker CSP，大多数操作系统可以配置为在执行模式下使用 AppLocker：
- en: '*Configuration Service* *Provider*: [https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support](https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置服务* *提供程序*: [https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support](https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support)'
- en: )
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Deploy OMA-URIs to target a CSP through Intune, and a comparison to* *on-premises*:
    [https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune](https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过 Intune 部署 OMA-URI 以针对 CSP，及与* *本地部署的对比*: [https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune](https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune)'
- en: Now, in Intune, go to **Devices** | **Configuration Profiles** and click on
    **Create Profile**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Intune 中，转到 **设备** | **配置文件**，然后点击 **创建配置文件**。
- en: 'Select **Windows 10 and Later** under **Platform**, **Templates** under **Profile
    Type**, and **Custom** under **Template**, then click **Create**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **平台**下选择**Windows 10 及以后版本**，在**配置文件类型**下选择**模板**，在**模板**下选择**自定义**，然后点击
    **创建**：
- en: '![Figure 11.15 – Create a profile](image/B16679_11_015.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 创建配置文件](image/B16679_11_015.jpg)'
- en: Figure 11.15 – Create a profile
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 创建配置文件
- en: On the next page, name your AppLocker policy – for example, **AppLocker Policy**
    – and click **Next**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页中，为您的 AppLocker 策略命名—例如，**AppLocker 策略**—然后点击 **下一步**。
- en: In the **OMA-URI Settings** section, select **Add** to add your AppLocker rule
    configuration. This is where you create the actual policy, using the snippet from
    your **.****xml** export.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **OMA-URI 设置**部分，选择 **添加** 来添加您的 AppLocker 规则配置。在这里，您将使用从 **.xml** 导出的片段创建实际的策略。
- en: First, type a name that represents the policy well, such as **Exe Policy**,
    if you want to start configuring the policy for **.exe** files in your environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入一个能够很好地代表策略的名称，例如 **Exe 策略**，如果您想开始为您的环境中的 **.exe** 文件配置策略。
- en: 'In the **OMA-URI** field, type the string according to the policy you are just
    configuring:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **OMA-URI** 字段中，按照您刚刚配置的策略输入字符串：
- en: '**Exe**: **./Vendor/MSFT/AppLocker/AppLocker/ApplicationLaunchRestrictions/apps/EXE/Policy**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exe**: **./Vendor/MSFT/AppLocker/AppLocker/ApplicationLaunchRestrictions/apps/EXE/Policy**'
- en: '**MSI**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/MSI/Policy**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSI**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/MSI/Policy**'
- en: '**Script**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/Script/Policy**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/Script/Policy**'
- en: '**DLL**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/DLL/Policy**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DLL**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/DLL/Policy**'
- en: '**Appx**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/StoreApps/Policy**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Appx**: **./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/StoreApps/Policy**'
- en: 'Change **Data type** to **String** and paste the **RuleCollection** lines that
    you copied earlier from the exported **.xml** file. Click **Save**. Add a policy
    using the **OMA-URI Settings** area for every rule type you want to configure.
    Once you are finished, click **Review + save** to save your configuration:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将**数据类型**更改为**字符串**，并粘贴你之前从导出的**.xml**文件中复制的**RuleCollection**行。点击**保存**。对于每个要配置的规则类型，在**OMA-URI
    设置**区域中添加一个策略。一旦完成，点击**审核 + 保存**以保存你的配置：
- en: '![Figure 11.16 – Configuring the OMA-URI settings](image/B16679_11_016.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 配置 OMA-URI 设置](image/B16679_11_016.jpg)'
- en: Figure 11.16 – Configuring the OMA-URI settings
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 配置 OMA-URI 设置
- en: As a next step, you can add computer groups to which these rules should apply.
    Click **Next** until you are in the **Review + create** section and review your
    rules. If everything seems fine, click **Create** to create your AppLocker rules.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，你可以添加这些规则应该应用的计算机组。点击**下一步**直到进入**审核 + 创建**部分，审查你的规则。如果一切正常，点击**创建**来创建你的
    AppLocker 规则。
- en: Microsoft Configuration Manager
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微软配置管理器
- en: '**Configuration Manager** was formerly known as **System Center Configuration
    Manager** (**SCCM**). Configuration Manager contains a lot of preconfigured configuration
    options and packages, but unfortunately, there is no preconfigured option for
    AppLocker. However, it still can be deployed using custom configuration options.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置管理器**以前被称为**系统中心配置管理器**（**SCCM**）。配置管理器包含许多预配置的配置选项和软件包，但不幸的是，没有为 AppLocker
    预配置的选项。然而，它仍然可以通过自定义配置选项进行部署。'
- en: 'Under **Compliance Settings**, create a new **Configuration Item**; in the
    **Create Configuration Item Wizard** area, specify a name for your new policy
    and select **Windows 8.1 and Windows 10** under **Settings for devices managed
    without the Configuration** **Manager client**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在**合规性设置**下，创建一个新的**配置项**；在**创建配置项向导**区域，指定新策略的名称，并在**没有配置管理器客户端的设备设置**下选择**Windows
    8.1 和 Windows 10**：
- en: '![Figure 11.17 – Creating a custom AppLocker policy using Configuration Manager](image/B16679_11_017.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 使用配置管理器创建自定义 AppLocker 策略](image/B16679_11_017.jpg)'
- en: Figure 11.17 – Creating a custom AppLocker policy using Configuration Manager
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 使用配置管理器创建自定义 AppLocker 策略
- en: Similar to the configuration with Intune, we can also use AppLocker CSP for
    the configuration with Configuration Manager.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用 Intune 进行的配置，我们也可以使用 AppLocker CSP 来配置配置管理器。
- en: Next, select for which platforms you want to configure AppLocker – in my example,
    I chose **Windows 10** only and clicked **Next**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择你要配置 AppLocker 的平台——在我的示例中，我只选择了**Windows 10**并点击**下一步**。
- en: As a next step, don’t select any device settings; instead, check the **Configure
    additional settings that are not in the default setting groups** checkbox and
    click **Next**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，不要选择任何设备设置；相反，勾选**配置不在默认设置组中的附加设置**复选框，然后点击**下一步**。
- en: 'In the **Additional Settings** pane, click **Add**. The **Browse Settings**
    window will open. Now, click **Create Setting…**. A new window called **Create
    Setting** will open, as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在**附加设置**窗格中，点击**添加**。将打开**浏览设置**窗口。接下来，点击**创建设置…**。一个名为**创建设置**的新窗口将打开，如下所示：
- en: '![Figure 11.18 – Specifying the policy’s name and the OMA-URI](image/B16679_11_018.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – 指定策略的名称和 OMA-URI](image/B16679_11_018.jpg)'
- en: Figure 11.18 – Specifying the policy’s name and the OMA-URI
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – 指定策略的名称和 OMA-URI
- en: In the **Create Setting** dialog, enter the setting’s **Name** and specify the
    string of the OMA-URI, as we did in the *Intune configuration* section (this is
    also where you can find the summarized OMA-URI strings in this book). Click **OK**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在**创建设置**对话框中，输入设置的**名称**并指定 OMA-URI 的字符串，就像我们在*Intune 配置*部分所做的那样（这也是你可以在本书中找到总结的
    OMA-URI 字符串的地方）。点击**确定**。
- en: As a next step, specify the rules for this setting by double clicking the setting
    that you just created and enter a meaningful **Name**, select **Value** under
    **Rule type**, and ensure **EXE Policy** (or the setting name that you configured
    earlier) **Equals** the *RuleCollection XML snippet* that we created earlier in
    the **Intune** section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，通过双击刚刚创建的设置来指定此设置的规则，并输入一个有意义的**名称**，在**规则类型**下选择**值**，并确保**EXE 策略**（或你之前配置的设置名称）**等于**我们在**Intune**部分创建的*RuleCollection
    XML 片段*。
- en: Usually, Configuration Manager items are used to query a state. If the state
    is different from the desired outcome, you can optionally configure the rule to
    be remediated automatically by checking the **Remediate noncompliant rules when**
    **supported** option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，配置管理器项目用于查询状态。如果状态与期望的结果不同，你可以选择配置规则，使其在**支持**的情况下自动修复不合规的规则。
- en: Repeat this step for every rule type that you want to configure until all the
    rules are configured accordingly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对每种规则类型重复此步骤，直到所有规则都按要求配置完毕。
- en: Click **Next** until **Create Configuration Item Wizard task** shows up as completed
    successfully.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**，直到**创建配置项向导任务**显示为成功完成。
- en: Now, create a **Configuration Baseline** task, enter a meaningful name, and
    click **Add**. Select the formerly created policy to be added to this baseline
    and confirm this with **OK**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个**配置基准**任务，输入一个有意义的名称，然后点击**添加**。选择之前创建的策略将其添加到此基准，并点击**确定**确认。
- en: Last, but not least, **Deploy** the new configuration baseline by selecting
    the baseline and configuring a **compliance evaluation schedule** to define in
    which interval the baseline is checked and applied. In my case, I have stated
    that this baseline should be run daily. Again, confirm this with **OK**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，通过选择基准并配置**合规评估计划**来**部署**新的配置基准，以定义检查和应用基准的间隔时间。在我的例子中，我已经设置该基准应该每天运行一次。再次确认此操作并点击**确定**。
- en: PowerShell
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell
- en: Of course, you can also use PowerShell to configure and read AppLocker rules.
    You can use the module AppLocker for this, which already contains several functions
    to help you with this job.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用 PowerShell 配置和读取 AppLocker 规则。可以使用名为 AppLocker 的模块，该模块已经包含了多个功能，帮助你完成这项工作。
- en: 'The following screenshot provides an overview of all AppLocker-related PowerShell
    commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图提供了所有与 AppLocker 相关的 PowerShell 命令的概览：
- en: '![Figure 11.19 – Functions within the AppLocker module](image/B16679_11_019.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – AppLocker 模块中的功能](image/B16679_11_019.jpg)'
- en: Figure 11.19 – Functions within the AppLocker module
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – AppLocker 模块中的功能
- en: At first glance, it looks like the module provides very limited functionality,
    but let’s look deeper into each function; they have way more functionality than
    you would expect and allow you to work even more efficiently than with the user
    interface.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这个模块提供的功能非常有限，但让我们深入研究每个函数，它们的功能比你预期的要多得多，允许你比使用用户界面更加高效地工作。
- en: '**Get-AppLockerPolicy** helps you find out if there is an AppLocker policy
    in place. Using the **-Effective** parameter, you can see if a policy has been
    specified at all:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Get-AppLockerPolicy**帮助你找出是否存在 AppLocker 策略。使用**-Effective**参数，你可以看到是否已经指定了策略：'
- en: '![Figure 11.20 – Getting the effective AppLocker policy using the Get-AppLocker
    policy](image/B16679_11_020.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – 使用 Get-AppLockerPolicy 获取有效的 AppLocker 策略](image/B16679_11_020.jpg)'
- en: Figure 11.20 – Getting the effective AppLocker policy using the Get-AppLocker
    policy
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – 使用 Get-AppLockerPolicy 获取有效的 AppLocker 策略
- en: You can also use the **-Local** parameter to see what is defined in the local
    AppLocker policy. The **-Domain** parameter, combined with the **-Ldap** parameter,
    helps you see the current domain-configured AppLocker policy. And of course, you
    can also investigate a policy out of a **.xml** file using the **-****Xml** parameter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用**-Local**参数查看本地 AppLocker 策略中定义的内容。**-Domain**参数与**-Ldap**参数结合使用，帮助你查看当前域配置的
    AppLocker 策略。当然，你还可以使用**-Xml**参数从**.xml**文件中调查策略。
- en: 'Using **Get-AppLockerFileInformation** allows you to get all the information
    from either a file, a path, or an event log:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Get-AppLockerFileInformation**可以获取来自文件、路径或事件日志的所有信息：
- en: '![Figure 11.21 – Retrieving AppLocker file information using Get-AppLockerFileInformation](image/B16679_11_021.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.21 – 使用 Get-AppLockerFileInformation 检索 AppLocker 文件信息](image/B16679_11_021.jpg)'
- en: Figure 11.21 – Retrieving AppLocker file information using Get-AppLockerFileInformation
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 – 使用 Get-AppLockerFileInformation 检索 AppLocker 文件信息
- en: In the preceding screenshot, you can see the AppLocker information of both demo
    scripts from our code signing example earlier. Usually, if the script had been
    signed by a corporate or public CA, you would also see the publisher information,
    but since we used a self-signed script, which is only meant for testing purposes,
    this certificate has no publisher and therefore we cannot use it to create an
    AppLocker publisher rule.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到我们代码签名示例中两个演示脚本的AppLocker信息。通常，如果脚本是由企业或公共CA签名的，你还会看到发布者信息，但由于我们使用的是自签名脚本，这个证书仅用于测试目的，因此没有发布者信息，因此我们无法使用它来创建AppLocker发布者规则。
- en: Usually, the most common way to generate AppLocker rules is by creating a policy
    based on a **golden image** of a server or client system, instead of manually
    selecting individual files and directories. To do this, you can use the **Get-AppLockerFileInformation**
    cmdlet to identify all the files that are authorized to run on the image and then
    use the **New-AppLockerPolicy** cmdlet to automatically generate the corresponding
    AppLocker rules for each file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成AppLocker规则最常见的方法是基于服务器或客户端系统的**黄金镜像**创建策略，而不是手动选择单个文件和目录。为此，你可以使用**Get-AppLockerFileInformation**
    cmdlet来识别图像上所有被授权运行的文件，然后使用**New-AppLockerPolicy** cmdlet为每个文件自动生成相应的AppLocker规则。
- en: 'The following example takes all the files in the **C:\** drive and generates
    a rule for each – the resulting file will be saved under **C:\tmp\Applocker.xml**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将**C:\**驱动器中的所有文件进行处理，并为每个文件生成一个规则—生成的文件将保存在**C:\tmp\Applocker.xml**中：
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the file has been created, you will need to test and fine-grain it to deploy
    AppLocker rules for your golden image.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件创建完成，你需要对其进行测试和微调，以便为你的黄金镜像部署AppLocker规则。
- en: 'Another very effective way to deploy AppLocker is to capture events from existing
    *known good* systems that have the required software installed and are considered
    uncompromised. Using those events to generate a policy with PowerShell can save
    you a lot of time and effort. It is even possible to pipe in file information
    from event logs to automatically generate AppLocker rules. This can be especially
    useful when dealing with large and complex environments where manually creating
    rules can be a daunting task:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常有效的部署AppLocker的方法是捕获来自现有*已知良好*系统的事件，这些系统已安装所需的软件，并且被认为是没有被攻击的。使用这些事件通过PowerShell生成策略可以节省你大量的时间和精力。甚至可以通过管道输入事件日志中的文件信息来自动生成AppLocker规则。当处理大型复杂环境时，这尤其有用，因为手动创建规则可能是一个艰巨的任务：
- en: '[PRE7]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can then use the **Set-AppLockerPolicy** cmdlet to configure Group Policy
    or Local Group Policy with the specified AppLocker configuration:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用**Set-AppLockerPolicy** cmdlet来配置组策略或本地组策略，并应用指定的AppLocker配置：
- en: '[PRE8]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To configure GPO on a remote domain controller, make sure you use the **-Ldap**
    parameter and configure the LDAP path to where the policy is located. If you want
    to merge the existing policy with a newly configured one, make sure you specify
    the **-****Merge** parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程域控制器上配置GPO，确保使用**-Ldap**参数，并配置LDAP路径到策略所在的位置。如果你想将现有策略与新配置的策略合并，确保指定**-Merge**参数。
- en: This cmdlet only works with Group Policy or local policy. If you have AppLocker
    configured via AppLocker CSP, this cmdlet won’t work.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此cmdlet仅适用于组策略或本地策略。如果你通过AppLocker CSP配置了AppLocker，则此cmdlet将无法工作。
- en: 'Using the **Test-AppLockerPolicy** cmdlet, you can test your AppLocker policy
    to find out if a certain file would be allowed to be executed if the specified
    policy were to apply:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Test-AppLockerPolicy** cmdlet，你可以测试AppLocker策略，看看在指定策略应用的情况下，某个文件是否会被允许执行：
- en: "![Figure 11.22 – Using Test-AppLockerPolicy to find out \uFEFFwhether notepad.exe\
    \ or putty.exe would be allowed to run](image/B16679_11_022.jpg)"
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 使用Test-AppLockerPolicy来查看notepad.exe或putty.exe是否被允许运行](image/B16679_11_022.jpg)'
- en: Figure 11.22 – Using Test-AppLockerPolicy to find out whether notepad.exe or
    putty.exe would be allowed to run
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 使用Test-AppLockerPolicy来查看notepad.exe或putty.exe是否被允许运行
- en: In this screenshot, you can see that using this AppLocker policy, **notepad.exe**
    would be allowed to run, while **putty.exe** would be prohibited as no matching
    allow rule has been configured.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，你可以看到，使用此AppLocker策略，**notepad.exe**将被允许运行，而**putty.exe**将被禁止运行，因为没有配置匹配的允许规则。
- en: Before you start deploying AppLocker in Enforce Rules Enforcement mode, you
    will want to audit what applications and scripts can be used in your environment
    regularly using **Audit only Enforcement** mode. This will let you allowlist them
    before you enforce your rules. You can do this using the logging capability by
    reviewing event logs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始以强制规则执行模式部署AppLocker之前，您需要定期使用**仅审核执行**模式审核哪些应用程序和脚本可以在您的环境中使用。这样，您可以在执行规则之前将它们列入允许名单。您可以通过查看事件日志来利用日志功能实现这一点。
- en: Audit AppLocker events
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审核AppLocker事件
- en: When using event logs, you can not only find out which applications would have
    been blocked when using **Audit only Enforcement** mode – you can also find a
    lot more interesting information on how your AppLocker policies were applied or
    what applications did run in **Enforce Rules** **Enforcement** mode.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件日志时，您不仅可以找出在使用**仅审核执行**模式时哪些应用程序会被阻止——还可以获得更多有趣的信息，了解您的AppLocker策略是如何应用的，或者哪些应用程序在**强制规则**
    **执行**模式下运行。
- en: 'Using PowerShell, you can quickly get an overview of all AppLocker-related
    event logs by running **Get-WinEvent -****ListLog *AppLocker***:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PowerShell，您可以通过运行**Get-WinEvent -****ListLog *AppLocker***快速概览所有与AppLocker相关的事件日志：
- en: '![Figure 11.23 – AppLocker event logs](image/B16679_11_023.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – AppLocker事件日志](image/B16679_11_023.jpg)'
- en: Figure 11.23 – AppLocker event logs
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – AppLocker事件日志
- en: To get all the event IDs from a particular log, use **Get-WinEvent**, followed
    by the name of the event log. If you want to get all event IDs from the **Microsoft-Windows-AppLocker/EXE
    and DLL** log, for example, you can run **Get-WinEvent "Microsoft-Windows-AppLocker/EXE**
    **and DLL"**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 若要从特定日志中获取所有事件ID，使用**Get-WinEvent**，后跟事件日志的名称。例如，如果您想获取**Microsoft-Windows-AppLocker/EXE
    和 DLL**日志中的所有事件ID，您可以运行**Get-WinEvent "Microsoft-Windows-AppLocker/EXE** **and
    DLL"**。
- en: You can find more detailed information on AppLocker event logs and all event
    IDs in [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090), *Detection –
    Auditing* *and Monitoring*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第4章*](B16679_04_Final_PD.xhtml#_idTextAnchor090)中找到关于AppLocker事件日志及所有事件ID的更多详细信息，*检测
    – 审核* *和监控*。
- en: 'To plan for your AppLocker deployment, it can be also very useful to review
    the statistics of what applications were allowed, denied, or audited. You can
    achieve this using **Get-AppLockerFileInformation**, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划AppLocker部署时，查看哪些应用程序被允许、拒绝或审核的统计数据也是非常有用的。您可以使用**Get-AppLockerFileInformation**来实现这一点，如下图所示：
- en: '![Figure 11.24 – Reviewing the statistics of audited applications](image/B16679_11_024.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – 审核应用程序的统计数据](image/B16679_11_024.jpg)'
- en: Figure 11.24 – Reviewing the statistics of audited applications
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 审核应用程序的统计数据
- en: Using **EventType**, you can choose between **Allowed**, **Denied**, or **Audited**.
    By doing this, you can see all the information about the file, as well as how
    often it tried to run the application and the decision of whether a file was or
    would have been allowed or denied.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**EventType**，您可以选择**已允许**、**已拒绝**或**已审核**。这样，您可以查看有关文件的所有信息，以及它尝试运行应用程序的频率和文件是否被允许或是否会被拒绝的决定。
- en: 'Please refer to the following link to learn more about how to monitor application
    usage with AppLocker: [https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接了解如何使用AppLocker监控应用程序使用情况：[https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker)。
- en: Exploring Windows Defender Application Control
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Windows Defender应用程序控制
- en: With its introduction in Windows 10, **Windows Defender Application Control**
    (**WDAC**) allows organizations to control the applications and drivers that are
    used in their environment. WDAC is implemented as part of the operating system
    and was also known under the name **Device Guard**.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Windows 10的推出，**Windows Defender应用程序控制**（**WDAC**）允许组织控制其环境中使用的应用程序和驱动程序。WDAC作为操作系统的一部分实现，也曾以**设备保护**的名称出现。
- en: It is recommended to use WDAC in combination with **virtualization-based security**
    (**VBS**). When used with VBS, WDAC’s security is enforced by hypervisor isolation,
    which makes it even harder for an adversary to circumvent your configured application
    control restrictions. While VBS is technically not required for WDAC, it can significantly
    enhance your overall system security and should always be enabled if possible.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将 WDAC 与 **基于虚拟化的安全**（**VBS**）结合使用。与 VBS 配合使用时，WDAC 的安全性通过虚拟化隔离得到加强，使得攻击者更难绕过你配置的应用控制限制。虽然技术上
    VBS 对 WDAC 并不是必需的，但它可以显著增强系统的整体安全性，且如果可能的话应始终启用。
- en: In comparison to AppLocker rules, WDAC rules are deployed to the whole machine
    and affect every user logging on to this machine. But WDAC also offers more features
    and is considered more secure than AppLocker. Its principle is to trust nothing
    before its trust has been earned.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AppLocker 规则相比，WDAC 规则会部署到整个机器，并影响每个登录到此机器的用户。但 WDAC 还提供更多功能，并被认为比 AppLocker
    更安全。其原则是在信任被获得之前不信任任何东西。
- en: Applications that are installed from the Microsoft AppStore are, for example,
    considered trustworthy, as every app that makes it into the store undergoes a
    strict review process. Default Windows applications are also considered trustworthy
    and do not need to be separately allowlisted. Other applications can also earn
    trust via Microsoft Intelligence Security Graph.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从微软应用商店安装的应用程序被认为是可信的，因为每个进入商店的应用都经过严格的审核过程。默认的 Windows 应用程序也被认为是可信的，无需单独列入允许名单。其他应用程序也可以通过
    Microsoft Intelligence Security Graph 获得信任。
- en: Whether an application is allowed to be executed on a system or not is ensured
    by so-called **code** **integrity policies**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 是否允许应用程序在系统上执行由所谓的 **代码** **完整性策略** 来确保。
- en: Creating code integrity policies
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建代码完整性策略
- en: '**Code integrity** ensures that only trusted system files and drivers are loaded
    into memory during system boot and runtime. It verifies the digital signatures
    of files before allowing them to run, and it prevents unsigned or improperly signed
    files from loading.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码完整性**确保只有受信任的系统文件和驱动程序在系统启动和运行时被加载到内存中。它在允许文件运行之前验证文件的数字签名，并防止未签名或签名不正确的文件加载。'
- en: The policy with which you configure custom WDAC rules is called a **code integrity
    policy** (**CI policy**). Similar to other application control mechanisms, it
    is useful to first deploy your policies in audit mode and monitor for unexpected
    behaviors before turning on enforcement mode.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置自定义 WDAC 规则的策略称为 **代码完整性策略**（**CI 策略**）。与其他应用程序控制机制类似，建议先在审计模式下部署策略，并在启用强制执行模式之前监控是否有意外行为。
- en: 'On every Windows system that supports WDAC, you can find some example policies
    under **C:\Windows\schemas\CodeIntegrity\ExamplePolicies**, as shown in the following
    screenshot:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个支持 WDAC 的 Windows 系统中，你可以在 **C:\Windows\schemas\CodeIntegrity\ExamplePolicies**
    下找到一些示例策略，如以下截图所示：
- en: '![Figure 11.25 – Built-in example code integrity policies](image/B16679_11_025.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25 – 内置示例代码完整性策略](image/B16679_11_025.jpg)'
- en: Figure 11.25 – Built-in example code integrity policies
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25 – 内置示例代码完整性策略
- en: 'If you create custom policies, it makes sense to start from an existing example
    policy and then modify it accordingly to build your very own custom policy. The
    following list will help you determine which **example policy** would be the best
    base to add your custom rules:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建自定义策略，建议从现有的示例策略开始，然后根据需要进行修改，以构建你自己的自定义策略。以下列表将帮助你确定哪个 **示例策略** 最适合作为添加自定义规则的基础：
- en: '**AllowAll.xml**: This can be a good base if you are planning to prohibit unwanted
    applications – you just need to add all deny rules. Please keep in mind that the
    best option to protect your systems against unauthorized access is to control
    all applications and only allow the selected ones.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowAll.xml**：如果你打算禁止不需要的应用程序，这是一个很好的基础——你只需要添加所有拒绝规则。请记住，保护系统免受未经授权访问的最佳方法是控制所有应用程序，只允许选定的应用程序。'
- en: '**AllowAll_EnableHVCI.xml**: By applying this policy, you can enable **memory
    integrity**/**hypervisor-protected code integrity** to safeguard against memory
    attacks. Please refer to the following documentation to learn more about this
    topic: [https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78](https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowAll_EnableHVCI.xml**：应用此策略后，您可以启用**内存完整性**/**虚拟化保护代码完整性**，以防止内存攻击。有关此主题的更多信息，请参阅以下文档：[https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78](https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78)。'
- en: '**AllowMicrosoft.xml**: This allows Windows, third-party hardware and software
    kernel drivers, and Windows Store apps, as well as apps that were signed by the
    Microsoft product root certificate.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowMicrosoft.xml**：此策略允许Windows、第三方硬件和软件内核驱动程序、Windows商店应用以及由Microsoft产品根证书签名的应用。'
- en: '**DefaultWindows_Audit.xml**: Audit mode allows Windows, third-party hardware
    and software kernel drivers, and Windows Store apps.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefaultWindows_Audit.xml**：审计模式允许Windows、第三方硬件和软件内核驱动程序以及Windows商店应用。'
- en: '**DefaultWindows_Enforced.xml**: Enforced mode allows Windows, third-party
    hardware and software kernel drivers, and Windows Store apps but blocks everything
    else that is not configured.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefaultWindows_Enforced.xml**：强制模式允许Windows、第三方硬件和软件内核驱动程序以及Windows商店应用，但阻止所有未配置的内容。'
- en: '**DenyAllAudit.xml**: This policy was created to track all binaries on critical
    systems – it audits what was to happen if everything was blocked. If enabled,
    this policy can cause long boot times on Windows Server 2019 operating systems.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DenyAllAudit.xml**：此策略用于跟踪关键系统上的所有二进制文件——它审计如果所有内容被阻止时将会发生什么。如果启用此策略，可能会导致Windows
    Server 2019操作系统长时间启动。'
- en: In most use cases, the **DefaultWindows_Audit.xml** and **DefaultWindows_Enforced.xml**
    policies are the best options to create a custom policy and extend them with custom
    rules as needed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数使用场景中，**DefaultWindows_Audit.xml**和**DefaultWindows_Enforced.xml**策略是创建自定义策略并根据需要通过自定义规则扩展它们的最佳选择。
- en: 'There’s also a list of Microsoft recommended block rules that you should follow:
    https://learn[.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一份Microsoft推荐的阻止规则列表，您应当遵循：[https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules)。
- en: The recommendations in this list can also help you mitigate downgrade attacks.
    This is an attack in which an attacker uses the older PowerShell v2 to bypass
    the security features and logging mechanisms of newer versions. We explored this
    attack in [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090), *Detection
    – Auditing* *and Monitoring*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的建议还可以帮助您减轻降级攻击。这是一种攻击，攻击者利用旧版PowerShell v2绕过较新版本的安全功能和日志机制。我们在[*第4章*](B16679_04_Final_PD.xhtml#_idTextAnchor090)中探讨了这种攻击，*检测
    – 审计* *和监控*。
- en: Although many items on this list may be permitted by default in common policies,
    it is important to carefully consider what executables and binaries are explicitly
    needed in your scenario and block all unnecessary ones.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此列表中的许多项目在常见策略中默认可能是允许的，但重要的是要仔细考虑在您的场景中明确需要哪些可执行文件和二进制文件，并阻止所有不必要的文件。
- en: On devices that are managed using Configuration Manager, there is an additional
    example policy under **C:\Windows\CCM\DeviceGuard**. This policy can be used as
    a base policy to deploy WDAC policies with Configuration Manager.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用配置管理器管理的设备上，**C:\Windows\CCM\DeviceGuard**目录下有一个额外的示例策略。此策略可以作为基础策略，用于通过配置管理器部署WDAC策略。
- en: 'Once you have selected an example policy that you want to use as your base,
    you can start modifying a copy of the selected policy. There are many options
    that you can configure, so you might want to get started by checking out all the
    available configuration options in the official documentation: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了你想用作基础的示例策略，你可以开始修改所选策略的副本。你可以配置许多选项，所以你可能想要通过查看官方文档中所有可用的配置选项来开始：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create)。
- en: 'You can either edit an example policy XML file or automate the process of creating
    code integrity policies using PowerShell. The following screenshot shows which
    cmdlets are available to operate code integrity policies:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编辑示例策略XML文件，或者使用PowerShell自动化创建代码完整性策略的过程。以下截图显示了可以操作代码完整性策略的cmdlet：
- en: '![Figure 11.26 – Code integrity policy-related cmdlets](image/B16679_11_026.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.26 – 代码完整性策略相关的cmdlet](image/B16679_11_026.jpg)'
- en: Figure 11.26 – Code integrity policy-related cmdlets
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.26 – 代码完整性策略相关的cmdlet
- en: 'One possibility is, for example, the WDAC Policy Wizard, which utilizes the
    WDAC CI cmdlets that we will look into in the following sections and acts as a
    wrapper to create CI policies with the help of a GUI. You can download this helpful
    tool from the official website: [https://webapp-wdac-wizard.azurewebsites.net/](https://webapp-wdac-wizard.azurewebsites.net/).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是，使用WDAC策略向导，它利用了我们将在后续章节中查看的WDAC CI cmdlet，并作为一个包装器，通过图形用户界面（GUI）来创建CI策略。你可以从官方网站下载这个有用的工具：[https://webapp-wdac-wizard.azurewebsites.net/](https://webapp-wdac-wizard.azurewebsites.net/)。
- en: 'It is also possible to create a custom XML policy using the **New-CIPolicy**
    cmdlet: one option is to scan a reference system and create a reference XML policy.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用**New-CIPolicy** cmdlet创建自定义的XML策略：一种方法是扫描参考系统并创建一个参考XML策略。
- en: Scanning a reference system to create an XML CI policy
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描参考系统以创建XML CI策略
- en: The following example shows how to scan the System32 path and the Program Files
    folder, and subsequently merge both policies into one.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何扫描System32路径和Program Files文件夹，并随后将两者的策略合并为一个。
- en: 'First, let’s scan the Windows System32 path:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扫描Windows System32路径：
- en: '[PRE9]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While the **-ScanPath** parameter indicates the path that should be scanned
    by **New-CIPolicy**, the **-UserPEs** parameter indicates that user-mode files
    will be scanned as well. Only use the **-UserPEs** and **-ScanPath** parameters
    if you are not providing driver files or rules but want to scan a reference system
    or path instead.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**-ScanPath**参数表示应该被**New-CIPolicy**扫描的路径，**-UserPEs**参数表示也会扫描用户模式文件。只有在你没有提供驱动程序文件或规则，而是希望扫描参考系统或路径时，才使用**-UserPEs**和**-ScanPath**参数。
- en: Using the **-FilePath** parameter, you can specify the output folder where your
    newly created CI policy should be saved. In this case, we have saved it to **C:\AppControlPolicies\Windows.xml**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**-FilePath**参数，你可以指定新创建的CI策略应该保存到的输出文件夹。在此示例中，我们将其保存到了**C:\AppControlPolicies\Windows.xml**。
- en: There is also the **-Level** parameter, which indicates the level of the CI
    policy. Using it, you can specify what kind of files are allowed to run. In this
    case, the policy is set to the **Publisher** level, which means that all the code
    must be signed by a trusted publisher so that it can run.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 还有**-Level**参数，表示CI策略的级别。通过它，你可以指定允许运行哪些类型的文件。在此情况下，策略被设置为**Publisher**级别，意味着所有代码必须由受信任的发布者签名才能运行。
- en: 'The following levels can also be used:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用以下级别：
- en: '**None**: Disables code integrity enforcement. No rules are enforced. This
    level makes no sense if you want to configure a robust CI policy.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None**：禁用代码完整性强制执行。没有规则被执行。如果你想配置一个稳健的CI策略，这个级别没有意义。'
- en: '**Hash**: Allows an application to run only if its hash matches a specified
    value.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hash**：仅允许在其哈希值与指定值匹配时，应用程序才能运行。'
- en: '**FileName**: Allows an application to run only if it is located in a specific
    file path. This level might sound tempting at first, but it opens up more risks.
    If an adversary were to access files on the system, they could easily replace
    existing files with malicious files. It’s best not to use this option.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FileName**：仅允许在应用程序位于特定文件路径时运行。这个级别一开始可能听起来很诱人，但它带来了更多的风险。如果攻击者能够访问系统上的文件，他们可能会轻松地将现有文件替换为恶意文件。最好不要使用这个选项。'
- en: '**SignedVersion**: Allows an application to run only if it has a specific signed
    version.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SignedVersion**：仅允许在应用程序具有特定签名版本时运行。'
- en: '**Publisher**: Allows an application to run only if it is signed by a specified
    publisher.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Publisher**：仅允许在应用程序由指定发布者签名时运行。'
- en: '**FilePublisher**: Allows an application to run only if it is signed by a specified
    publisher and is located in a specific file path.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FilePublisher**：仅允许在应用程序由指定发布者签名且位于特定文件路径时运行。'
- en: '**LeafCertificate**: Allows an application to run only if it is signed by a
    specified leaf certificate.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LeafCertificate**：仅允许在应用程序由指定的叶证书签名时运行。'
- en: '**PcaCertificate**: Allows an application to run only if it is signed by a
    specified PCA certificate.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PcaCertificate**：仅允许在应用程序由指定PCA证书签名时运行。'
- en: '**RootCertificate**: Allows an application to run only if it is signed by a
    specified root certificate.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RootCertificate**：仅允许在应用程序由指定根证书签名时运行。'
- en: '**WHQL**: Allows only signed drivers that are **Windows Hardware Quality Labs**
    (**WHQL**) certified to be loaded.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHQL**：仅允许加载经过**Windows硬件质量实验室**（**WHQL**）认证的签名驱动程序。'
- en: '**WHQLPublisher**: Allows only signed drivers that are WHQL certified and signed
    by a specific publisher to be loaded.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHQLPublisher**：仅允许加载经过WHQL认证并由特定发布者签名的驱动程序。'
- en: '**WHQLFilePublisher**: Allows only signed drivers that are WHQL certified,
    signed by a specific publisher, and located in a specific file path to be loaded.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHQLFilePublisher**：仅允许加载经过WHQL认证、由特定发布者签名并位于特定文件路径的签名驱动程序。'
- en: 'Next, let’s scan the **Program Files** folder to create a policy from the specified
    reference system:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们扫描**Program Files**文件夹，以从指定的参考系统创建策略：
- en: '[PRE10]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we have included our user-mode files in the scan and want to ensure that
    all the files included in our policy are signed by a specified publisher. We must
    define that the newly created policy will be saved to **C:\AppControlPolicies\ProgramFiles.xml**.
    To avoid script files from being included in this reference policy, we must specify
    the **-****NoScript** parameter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们已将用户模式文件包含在扫描中，并希望确保所有包含在策略中的文件都由指定发布者签名。我们必须定义将新创建的策略保存到**C:\AppControlPolicies\ProgramFiles.xml**。为了避免脚本文件被包含在这个参考策略中，我们必须指定**-NoScript**参数。
- en: Using the **-Fallback** parameter, you can specify a fallback order; in this
    case, if there is no match at the **FilePublisher** level, the policy engine will
    fall back to the **SignedVersion**, **FilePublisher**, and **Hash** levels – exactly
    in this order.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**-Fallback**参数，您可以指定回退顺序；在这种情况下，如果在**FilePublisher**级别没有匹配项，策略引擎将回退到**SignedVersion**、**FilePublisher**和**Hash**级别——恰好是这个顺序。
- en: 'Last, but not least, we need to merge the policies into one. To do so, we can
    use the **Merge-CIPolicy** cmdlet:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要将策略合并为一个。为此，我们可以使用**Merge-CIPolicy** cmdlet：
- en: '[PRE11]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the **-PolicyPaths** parameter, we can specify which policies should be
    merged, while with **-OutputFilePath**, we can define where the merged policy
    will be saved to. In this example, we’ll save the final policy under **C:\AppControlPolicies\AppControlPolicy.xml**.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**-PolicyPaths**参数，我们可以指定应合并的策略，而使用**-OutputFilePath**，我们可以定义合并后的策略保存的位置。在这个例子中，我们将把最终的策略保存到**C:\AppControlPolicies\AppControlPolicy.xml**。
- en: The policy is created in audit mode so that it can’t block and only audit the
    use of applications. This is especially useful for testing and evaluating what
    applications should be blocked.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 策略以审计模式创建，因此它无法阻止应用程序，只会审计应用程序的使用。这对于测试和评估哪些应用程序应该被阻止非常有用。
- en: 'Once you are ready to apply a block policy to your systems, you can remove
    the audit-only configuration from your policy using the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好将阻止策略应用到您的系统，您可以使用以下命令从您的策略中移除仅审计配置：
- en: '[PRE12]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To deploy your newly generated policy, you will need to convert it into binary
    format.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署新生成的策略，您需要将其转换为二进制格式。
- en: Converting the XML file into a binary CI policy
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将XML文件转换为二进制CI策略
- en: 'Once you have obtained your CI policy XML configuration file, you will need
    to convert it into binary format to deploy it. This can be done using the **ConvertFrom-CIPolicy**
    cmdlet:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了 CI 策略的 XML 配置文件，你需要将其转换为二进制格式以进行部署。可以使用 **ConvertFrom-CIPolicy** cmdlet
    完成此操作：
- en: '[PRE13]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the **AppControlPolicy.xml** CI policy, which we generated earlier, will
    be compiled into the **AppControlPolicy.bin** binary file and saved under **C:\Windows\System32\CodeIntegrity\AppControlPolicy.bin**.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们之前生成的 **AppControlPolicy.xml** CI 策略将被编译成 **AppControlPolicy.bin** 二进制文件，并保存在
    **C:\Windows\System32\CodeIntegrity\AppControlPolicy.bin** 下。
- en: If a binary CI policy is saved under **C:\Windows\System32\CodeIntegrity\**,
    it will be enabled immediately after the affected system is restarted. Once the
    policy is removed again and the system is restarted, all changes introduced by
    the CI policy are reverted.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个二进制 CI 策略保存在 **C:\Windows\System32\CodeIntegrity\** 下，那么在相关系统重启后，它会立即启用。策略被移除后，再次重启系统，CI
    策略引入的所有更改都会被撤销。
- en: Of course, you can also save the converted CI policy under another path of your
    choice if you plan to deploy WDAC using Intune, MEM, GPO, or another deployment
    mechanism that requires a binary configuration file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你计划使用 Intune、MEM、GPO 或其他需要二进制配置文件的部署机制来部署 WDAC，你也可以将转换后的 CI 策略保存在你选择的其他路径下。
- en: There are also other ways to create a CI policy XML file – for example, from
    audited events.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以创建 CI 策略 XML 文件——例如，从审核事件中创建。
- en: Using audited events from the event log as a reference
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件日志中的审核事件作为参考
- en: Another way to create a WDAC policy is by running WDAC in audit mode and using
    the audit log to create the policy. Similar to AppLocker, if WDAC is running in
    audit mode, any application that would be blocked if the current WDAC configuration
    was enabled is logged to the audit log.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 WDAC 策略的另一种方式是通过在审计模式下运行 WDAC，并使用审计日志来创建策略。类似于 AppLocker，如果 WDAC 处于审计模式，则任何在当前
    WDAC 配置启用时会被阻止的应用程序都会被记录到审计日志中。
- en: 'Depending on the application type, these events can be found in one of the
    following event logs:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序类型，这些事件可以在以下某个事件日志中找到：
- en: '**Binary-related events**: **Applications and Services Logs** | **Microsoft**
    |**Windows** | **CodeIntegrity** | **Operational**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制相关事件**: **应用程序和服务日志** | **Microsoft** | **Windows** | **CodeIntegrity**
    | **操作**'
- en: '**MSI and script-related events**: **Applications and Services Logs** | **Microsoft**
    | **Windows** | **AppLocker** | **MSI** **and Script**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSI 和脚本相关事件**: **应用程序和服务日志** | **Microsoft** | **Windows** | **AppLocker**
    | **MSI** **和脚本**'
- en: 'All events logged to these event logs can now be leveraged to either create
    a completely new CI policy or to merge audited configurations into an existing
    policy:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 记录到这些事件日志中的所有事件现在可以被用来创建一个全新的 CI 策略，或者将审核的配置合并到现有策略中：
- en: '[PRE14]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command creates a new CI policy under the **C:\AppControlPolicies\AuditEvents.xml**path.
    The **-Audit** parameter specifies that the actual audit events from the event
    log should be used to create the policy.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会在 **C:\AppControlPolicies\AuditEvents.xml** 路径下创建一个新的 CI 策略。**-Audit** 参数指定应使用事件日志中的实际审计事件来创建策略。
- en: The **-MultiplePolicyFormat** parameter enables us to use multiple policies
    at the same time since the policy will be stored in a multiple-policy format,
    as introduced in Windows 10.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**-MultiplePolicyFormat** 参数使我们能够同时使用多个策略，因为策略将以多策略格式存储，这一格式在 Windows 10 中被引入。'
- en: Now, you can review and edit the newly created policy before merging it with
    other existing policies and/or converting it into binary format for further use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在将新创建的策略与其他现有策略合并和/或将其转换为二进制格式以供进一步使用之前，进行审核和编辑。
- en: Creating a CI policy using the New-CIPolicyRule cmdlet
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 New-CIPolicyRule cmdlet 创建 CI 策略
- en: 'If you want to define what applications should appear in your CI policy more
    granularly, the **New-CIPolicyRule** cmdlet can help you out:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更精细地定义哪些应用程序应该出现在你的 CI 策略中，**New-CIPolicyRule** cmdlet 可以帮助你：
- en: '[PRE15]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code would create one CI policy rule for the *Notepad++* folder
    and its subfolders, as well as one for the *PowerShell 7* path, and saves both
    rules in the **$****Rules** variable.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将为*Notepad++* 文件夹及其子文件夹创建一个 CI 策略规则，并为*PowerShell 7*路径创建另一个规则，并将这两个规则保存在**$****Rules**变量中。
- en: Then, both rules can be used to create a new CI policy that is saved under the
    **C:\AppControlPolicies\GranularAppControlPolicy.xml** path.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两个规则可以用来创建一个新的 CI 策略，并保存在 **C:\AppControlPolicies\GranularAppControlPolicy.xml**
    路径下。
- en: Later, you can either combine it with other policies using **Merge-CIPolicy**
    or convert it into binary format with the help of **ConvertFrom-CIPolicy** so
    that you can use it for other purposes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以使用**Merge-CIPolicy**将其与其他策略结合，或借助**ConvertFrom-CIPolicy**将其转换为二进制格式，以便用于其他用途。
- en: 'You can use the ConfigCI PowerShell module to explore other ways of working
    with code integrity: [https://learn.microsoft.com/en-us/powershell/module/configci](https://learn.microsoft.com/en-us/powershell/module/configci).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ConfigCI PowerShell 模块来探索与代码完整性相关的其他操作方式：[https://learn.microsoft.com/en-us/powershell/module/configci](https://learn.microsoft.com/en-us/powershell/module/configci)。
- en: Although it is not technically required, virtualization-based security features
    such as Secure Boot should be enabled so that code integrity functions properly.
    Secure Boot ensures that the system only boots to a trusted state, and that all
    boot files are signed with trusted signatures. This prevents the boot process
    from being tampered with and ensures the integrity of the operating system and
    its drivers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲并非强制要求，但应启用基于虚拟化的安全功能，如安全启动，以确保代码完整性正常工作。安全启动确保系统仅以受信任的状态启动，并且所有启动文件都带有受信任的签名。这防止了启动过程被篡改，并确保操作系统及其驱动程序的完整性。
- en: Virtualization-based security (VBS)
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于虚拟化的安全（VBS）
- en: VBS uses virtualization as a base to isolate areas in memory from the *normal*
    operating system. By doing this, the isolated area can be protected in a better
    way by encrypting the available memory and the communication to and from this
    memory area.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: VBS 使用虚拟化作为基础，将内存中的某些区域与*普通*操作系统隔离。通过这种方式，可以通过加密可用内存和与该内存区域的通信，更好地保护被隔离的区域。
- en: Through this isolation, those memory areas can be better protected against vulnerabilities
    that are active in the operating system.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种隔离，内存区域可以更好地保护，免受操作系统中活跃漏洞的影响。
- en: One example of this is protecting credentials in the **local security authority**
    (**LSA**), which makes it harder to extract and steal credentials from the operating
    system.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是保护**本地安全机构**（**LSA**）中的凭证，这使得从操作系统中提取和窃取凭证变得更加困难。
- en: Another example is **hypervisor-protected code integrity** (**HVCI**), which
    uses VBS for code integrity.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是**虚拟化保护的代码完整性**（**HVCI**），它使用 VBS 来实现代码完整性。
- en: Hypervisor-protected code integrity (HVCI)
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟化保护的代码完整性（HVCI）
- en: HVCI, also called **memory integrity**, is the key component of VBS. HVCI leverages
    VBS technology to protect against kernel-mode attacks by ensuring the integrity
    of the kernel and critical system components. It does so by allowing only trusted
    and authorized code to run in kernel mode.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: HVCI，也叫做**内存完整性**，是 VBS 的关键组件。HVCI 利用 VBS 技术通过确保内核和关键系统组件的完整性，防止内核模式攻击。它通过仅允许受信任和授权的代码在内核模式下运行来实现这一点。
- en: If HVCI is active, the CI functionality is forwarded to a secure virtual environment
    on the same machine, in which the WDAC functionality itself is executed to ensure
    integrity. As mentioned previously, HVCI uses VBS technology to protect against
    kernel-mode attacks. It enforces the integrity of the kernel and critical system
    components by verifying that only known and trusted code can run in kernel mode.
    But technically, VBS is not required for WDAC.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HVCI 激活，CI 功能会被转发到同一台机器上的一个安全虚拟环境中，在该环境中执行 WDAC 功能以确保完整性。如前所述，HVCI 使用 VBS
    技术防止内核模式攻击。它通过验证仅允许已知和受信任的代码在内核模式下运行，来强制执行内核和关键系统组件的完整性。但从技术上讲，VBS 对于 WDAC 并不是必须的。
- en: HVCI utilizes hardware features such as virtualization extensions in modern
    CPUs and the **Trusted Platform Module** (**TPM**) to create a secure execution
    environment. The TPM is used to store a hash of the system’s boot firmware, UEFI,
    and operating system binaries. During system boot, the TPM measures these components
    and provides the measurements to the HVCI system. HVCI uses these measurements
    to verify that only known and trusted components are loaded into memory, thus
    preventing unauthorized code from running in kernel mode.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: HVCI 利用现代 CPU 中的硬件特性，如虚拟化扩展和**受信任的平台模块**（**TPM**），来创建一个安全的执行环境。TPM 用于存储系统引导固件、UEFI
    和操作系统二进制文件的哈希值。在系统启动过程中，TPM 会对这些组件进行度量，并将度量结果提供给 HVCI 系统。HVCI 使用这些度量结果验证是否只有已知和受信任的组件被加载到内存中，从而防止未经授权的代码在内核模式下运行。
- en: 'If you want to enable HVCI options for a CI policy, you can use the **Set-HVCIOptions**
    cmdlet:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为 CI 策略启用 HVCI 选项，可以使用**Set-HVCIOptions** cmdlet：
- en: '[PRE16]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can take this even further by using the **-****Strict** parameter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用**-Strict**参数进一步加强这一点：
- en: '[PRE17]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the **-Strict** option is used, this means that only Microsoft and WHQL-signed
    drivers will be allowed to load after this policy is applied.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了**-Strict**选项，这意味着在应用此策略后，只允许加载 Microsoft 和 WHQL 签名的驱动程序。
- en: 'To remove all HVCI settings from a CI policy, you can specify the **-****None**
    parameter:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 CI 策略中删除所有 HVCI 设置，您可以指定**-None**参数：
- en: '[PRE18]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another helpful VBS feature is Secure Boot, which helps you significantly enhance
    the security of your Windows systems.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 VBS 功能是安全启动，它可以显著增强您的 Windows 系统的安全性。
- en: Enabling Secure Boot
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用安全启动
- en: '**Secure Boot** ensures that the system is booted into a trusted state. This
    means that all files that are used to boot the system need to be signed with signatures
    that are trusted by the organization. By doing this, the system will not be booted
    if those files have been tampered with. The device needs to have a TPM chip to
    support Secure Boot.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动**确保系统以受信任的状态启动。这意味着所有用于启动系统的文件必须具有经组织信任的签名。通过这样做，如果这些文件被篡改，系统将无法启动。设备需要配备
    TPM 芯片才能支持安全启动。'
- en: 'To verify if Secure Boot is enabled on your computer, you can utilize the **Confirm-SecureBootUEFI**
    cmdlet:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的计算机是否启用了安全启动，您可以使用**Confirm-SecureBootUEFI** cmdlet：
- en: '[PRE19]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If Secure Boot is enabled, the cmdlet will return **True**, as shown in the
    following screenshot; if not, **False** will be returned:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了安全启动，cmdlet 将返回**True**，如下图所示；如果没有启用，则返回**False**：
- en: '![Figure 11.27 – Secure Boot is enabled](image/B16679_11_027.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.27 – 启用安全启动](image/B16679_11_027.jpg)'
- en: Figure 11.27 – Secure Boot is enabled
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.27 – 启用安全启动
- en: 'If the hardware of your PC does not support Secure Boot, you will receive an
    error message stating **Cmdlet not supported on** **this platform.**:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 PC 硬件不支持安全启动（Secure Boot），您将收到一条错误信息，提示**此平台不支持 Cmdlet**。
- en: '![Figure 11.28 – The hardware does not support Secure Boot](image/B16679_11_028.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.28 – 硬件不支持安全启动](image/B16679_11_028.jpg)'
- en: Figure 11.28 – The hardware does not support Secure Boot
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.28 – 硬件不支持安全启动
- en: 'Have a look at the following links if you want to learn more about Secure Boot:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于安全启动的信息，请查看以下链接：
- en: '*Secure Boot*: [https://learn.microsoft.com/en-us/powershell/module/ secureboot](https://learn.microsoft.com/en-us/powershell/module/secureboot)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全启动*：[https://learn.microsoft.com/en-us/powershell/module/secureboot](https://learn.microsoft.com/en-us/powershell/module/secureboot)'
- en: '*Secure Boot* *Landing*: https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/secure-boot-landing'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全启动* *着陆页*：[https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/secure-boot-landing](https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/secure-boot-landing)'
- en: Adversaries often use malicious drivers and manipulated system files. Secure
    Boot, when combined with code integrity, ensures that the booted operating system,
    as well as its used drivers, can be trusted.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者常常使用恶意驱动程序和篡改的系统文件。安全启动与代码完整性结合使用，确保已启动的操作系统及其使用的驱动程序是可信的。
- en: Deploying WDAC
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 WDAC
- en: 'There are different ways to deploy WDAC: MDM or Intune, Configuration Manager,
    GPO, and PowerShell.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 WDAC 有多种方式：MDM 或 Intune、配置管理器（Configuration Manager）、组策略（GPO）以及 PowerShell。
- en: 'As describing every deployment method in detail would exceed the capacity of
    this book, please refer to the official deployment guide, where you can find detailed
    instructions for every deployment method: https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control-deployment-guide.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于详细描述每种部署方法会超出本书的篇幅，请参阅官方部署指南，您可以在其中找到每种部署方法的详细说明：https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control-deployment-guide。
- en: In the following sections, we will explore the pros and cons of each different
    deployment method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨每种不同部署方法的优缺点。
- en: GPO
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组策略（GPO）
- en: Group Policy is not the preferred method to configure WDAC; it only supports
    single-policy format **CI policies** with a **.bin**, **.p7b**, or **.p7** file
    type. This format was used for devices before Windows 10 version 1903\. As a best
    practice, use a deployment mechanism other than GPO.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 组策略并不是配置 WDAC 的首选方法；它只支持单一策略格式的**CI 策略**，并且文件类型为 **.bin**、**.p7b** 或 **.p7**。这种格式用于
    Windows 10 版本 1903 之前的设备。作为最佳实践，应使用除 GPO 之外的部署机制。
- en: However, if you want to use this deployment method anyway, you can find the
    WDAC GPO setting under **Computer Configuration** | **Administrative Templates**
    | **System** | **Device Guard** | **Deploy Windows Defender Application Control**.
    Using this, you can deploy a CI policy.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你仍然希望使用这种部署方式，可以在**计算机配置** | **管理模板** | **系统** | **设备保护** | **部署Windows
    Defender应用程序控制**下找到WDAC GPO设置。通过此设置，你可以部署CI策略。
- en: The binary CI policy that you want to deploy needs to be located either on a
    file share or copied to the local system of each machine that you want to restrict.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要部署的二进制CI策略需要位于文件共享中，或者复制到每台你想要限制的机器的本地系统上。
- en: 'Detailed documentation on how to deploy WDAC using GPO can be found here: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何通过GPO部署WDAC的详细文档，可以在这里找到：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy)。
- en: Intune
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Intune
- en: You can use an MDM solution to configure WDAC, such as Intune. Using Intune,
    application control comes with some built-in policies that you can configure so
    that your clients can only run Windows components, third-party hardware and software
    kernel drivers, apps from the Microsoft store, and applications with a good reputation
    that are trusted by Microsoft Intelligence Security Graph (optional).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用MDM解决方案来配置WDAC，例如Intune。通过Intune，应用控制内置了一些可配置的策略，你可以配置这些策略，以便客户机只能运行Windows组件、第三方硬件和软件内核驱动程序、来自Microsoft
    Store的应用，以及由Microsoft Intelligence Security Graph信任的信誉良好的应用（可选）。
- en: Of course, it is also possible to create custom WDAC policies using OMA-URI,
    which can be done similarly to configuring AppLocker policies using Intune.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以使用OMA-URI创建自定义的WDAC策略，这与通过Intune配置AppLocker策略的方式类似。
- en: 'In every XML CI policy file, you can find a policy ID. Copy this ID and replace
    **{PolicyID}** in the following string to get the OMA-URI for your custom policy:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个XML CI策略文件中，你可以找到一个策略ID。复制此ID，并将**{PolicyID}**替换为以下字符串，以获取自定义策略的OMA-URI：
- en: '[PRE20]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please note that you also need to replace the curly brackets. The following
    screenshot shows where you can find **PolicyID**:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你还需要替换大括号。以下截图显示了你可以找到**PolicyID**的位置：
- en: '![Figure 11.29 – You can find the policy ID in the XML CI policy file](image/B16679_11_029.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图11.29 – 你可以在XML CI策略文件中找到策略ID](image/B16679_11_029.jpg)'
- en: Figure 11.29 – You can find the policy ID in the XML CI policy file
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 – 你可以在XML CI策略文件中找到策略ID
- en: 'Using this **PolicyID**, the corresponding OMA-URI would be as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此**PolicyID**，相应的OMA-URI如下所示：
- en: '[PRE21]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can learn more about how to use Intune for deploying WDAC at [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune)了解更多关于如何使用Intune部署WDAC的信息。
- en: Microsoft Configuration Manager
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Microsoft配置管理器
- en: When using Configuration Manager, it becomes a trustworthy source itself. This
    means that every application and piece of software that was installed over Configuration
    Manager becomes trustworthy and is allowed to run. This option needs to be configured
    through a built-in policy first.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置管理器时，它本身会成为一个可信源。这意味着通过配置管理器安装的每个应用程序和软件都被视为可信并允许运行。此选项需要通过内置策略进行配置。
- en: 'Similar to deploying with Intune, Configuration Manager also provides some
    more built-in policies so that you can configure your clients to only run Windows
    components and apps from the Microsoft Store. It is also optional to trust apps
    with a good reputation, verified by the **Intune Service Gateway** (**ISG**).
    Configuration Manager comes with another optional built-in policy: it is possible
    to allow apps and other executables that were already installed in a defined folder.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用 Intune 部署，Configuration Manager 还提供了一些内置的策略，使您可以配置客户端仅运行来自 Microsoft Store
    的 Windows 组件和应用程序。您还可以选择信任具有良好声誉的应用程序，这些应用程序已由**Intune 服务网关**（**ISG**）验证。Configuration
    Manager 还带有另一个可选的内置策略：可以允许已经安装在指定文件夹中的应用程序和其他可执行文件。
- en: You can learn more about WDAC can be deployed using Configuration Manager at
    [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接了解更多关于如何使用 Configuration Manager 部署 WDAC：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm)。
- en: PowerShell
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell
- en: 'Depending on the operating system, there are different ways to deploy WDAC
    using PowerShell since not all capabilities are available for every operating
    system version. The **WDAC policy refresh tool** also needs to be downloaded and
    deployed to every managed endpoint: [https://www.microsoft.com/en-us/download/details.aspx?id=102925](https://www.microsoft.com/en-us/download/details.aspx?id=102925).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作系统的不同，使用 PowerShell 部署 WDAC 的方式也有所不同，因为并非所有操作系统版本都具备所有功能。**WDAC 策略刷新工具**也需要下载并部署到每个受管理的端点：[https://www.microsoft.com/en-us/download/details.aspx?id=102925](https://www.microsoft.com/en-us/download/details.aspx?id=102925)。
- en: For this method, you will also need the policy’s binary to copy it to each managed
    endpoint. However, compared to GPO, you can deploy multiple WDAC policies. To
    deploy signed policies, you will also need to copy the binary policy file to the
    device’s EFI partition. Signed policies provide an additional layer of security
    by ensuring that only policies signed by trusted entities are applied to the endpoint.
    This step will be done automatically if Intune or the CSP is used for deployment.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种方法，您还需要获取策略的二进制文件并将其复制到每个受管理的端点。然而，与 GPO 相比，您可以部署多个 WDAC 策略。要部署签名策略，您还需要将二进制策略文件复制到设备的
    EFI 分区。签名策略通过确保仅应用由受信任实体签名的策略，为端点提供额外的安全层。如果使用 Intune 或 CSP 进行部署，此步骤将自动完成。
- en: 'Matt Graeber’s **WDACTools** is also a valuable resource for streamlining your
    deployment process. These tools were specifically designed to simplify the process
    of building, configuring, deploying, and auditing WDAC policies. You can download
    them from Matt’s GitHub repository: [https://github.com/mattifestation/WDACTools](https://github.com/mattifestation/WDACTools).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Matt Graeber 的 **WDACTools** 也是简化部署过程的宝贵资源。这些工具专门设计用于简化构建、配置、部署和审核 WDAC 策略的过程。您可以从
    Matt 的 GitHub 仓库下载它们：[https://github.com/mattifestation/WDACTools](https://github.com/mattifestation/WDACTools)。
- en: For detailed information on how to deploy WDAC using PowerShell, please refer
    to [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用 PowerShell 部署 WDAC 的详细信息，请参阅：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script)。
- en: How does PowerShell change when application control is enforced?
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当强制执行应用程序控制时，PowerShell 会发生什么变化？
- en: When application control is enforced, PowerShell acts as a safeguard to prevent
    the misuse of its features by potential adversaries. By proactively implementing
    application control measures, PowerShell ensures that its powerful scripting language
    cannot be easily abused by attackers to bypass imposed restrictions.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当强制执行应用程序控制时，PowerShell 充当保护措施，防止潜在对手滥用其功能。通过主动实施应用程序控制措施，PowerShell 确保其强大的脚本语言不能被攻击者轻易滥用，从而绕过已施加的限制。
- en: PowerShell can be restricted in several ways, including disabling the ability
    to run PowerShell scripts or only allowing signed PowerShell scripts to run.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell可以通过多种方式受到限制，包括禁用运行PowerShell脚本的能力或只允许运行已签名的PowerShell脚本。
- en: In [*Chapter 5*](B16679_05_Final_PD.xhtml#_idTextAnchor110), *PowerShell Is
    Powerful – System and API Access*, we discussed how it is possible to use PowerShell
    to run arbitrary **.NET** code or even execute compiled code if the system is
    not restricted. This can make it very difficult to protect against malicious code.
    With application control enforced, it’s possible to eliminate unconstrained code
    execution methods such as **Add-Type**, arbitrary .NET scripting, and other options
    that are typically used to bypass security mechanisms.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B16679_05_Final_PD.xhtml#_idTextAnchor110)，*PowerShell的强大——系统和API访问*中，我们讨论了如何在系统不受限制的情况下，使用PowerShell运行任意**.NET**代码，甚至执行编译后的代码。这会使防范恶意代码变得非常困难。在强制应用控制的情况下，可以消除如**Add-Type**、任意.NET脚本和其他常用绕过安全机制的代码执行方法。
- en: PowerShell includes a built-in **Constrained Language mode**, which we explored
    in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278), *Language Modes
    and Just Enough Administration (JEA)*. Constrained Language mode limits PowerShell
    and restricts the user from executing risky language elements, such as accessing
    arbitrary APIs.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell包括内置的**受限语言模式**，我们在[*第10章*](B16679_10_Final_PD.xhtml#_idTextAnchor278)，*语言模式与足够的管理权限（JEA）*中进行了探讨。受限语言模式限制了PowerShell，阻止用户执行危险的语言元素，如访问任意API。
- en: This means that certain *dangerous* language elements such as **Add-Type**,
    **COM objects**, and some .NET types that can be utilized to execute arbitrary
    code cannot be used. If enforced, Constrained Language mode can limit the attacker’s
    ability to execute arbitrary code and modify system configurations. In Constrained
    Language mode, the PowerShell environment retains only the core basic features
    of a traditional less powerful interactive shell, similar to CMD, Windows Explorer,
    or Bash.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着某些*危险*的语言元素，如**Add-Type**、**COM对象**和一些可以用于执行任意代码的.NET类型，无法使用。如果强制执行，受限语言模式（Constrained
    Language mode）可以限制攻击者执行任意代码和修改系统配置的能力。在受限语言模式下，PowerShell环境仅保留传统较弱交互式shell的核心基本功能，类似于CMD、Windows资源管理器或Bash。
- en: One effective approach to ensure that PowerShell code is trusted is to enforce
    the use of **signed scripts**. With application control in place, if a script
    is trusted and allowed to run in **Full Language mode**, it is executed accordingly.
    But if it is not trusted, a script will always run in Constrained Language mode,
    which means that the script will fail if it attempts to call arbitrary APIs and
    other risky language elements.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 确保PowerShell代码可信任的一种有效方法是强制使用**签名脚本**。在应用控制的情况下，如果脚本被信任并允许在**完全语言模式**下运行，则会按照要求执行。但是，如果脚本不被信任，则它将始终在受限语言模式下运行，这意味着如果脚本尝试调用任意API和其他危险语言元素，将会失败。
- en: 'When application control is enforced, and therefore PowerShell were to run
    in Constrained Language mode, if you were to try to call methods directly from
    .NET, they would fail, as shown in the following screenshot:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用控制被强制执行，并且PowerShell在受限语言模式下运行时，如果你尝试直接从.NET调用方法，它们将会失败，如下图所示：
- en: '![Figure 11.30 – .NET types cannot be accessed with application control enabled](image/B16679_11_030.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图11.30 – 启用应用控制时，无法访问.NET类型](image/B16679_11_030.jpg)'
- en: Figure 11.30 – .NET types cannot be accessed with application control enabled
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 – 启用应用控制时，无法访问.NET类型
- en: 'Using **Add-Type** to add and access your C types from PowerShell would also
    not work – you would get the following error message:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Add-Type**从PowerShell中添加并访问C类型也会失效——你会收到以下错误消息：
- en: '![Figure 11.31 – Add-Type fails when application control is enforced](image/B16679_11_031.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图11.31 – 强制执行应用控制时，Add-Type失败](image/B16679_11_031.jpg)'
- en: Figure 11.31 – Add-Type fails when application control is enforced
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 – 强制执行应用控制时，Add-Type失败
- en: These are not the only commands that would fail, but they should demonstrate
    how the PowerShell experience is different with application control enabled.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是唯一会失败的命令，但它们应该能演示启用应用控制后，PowerShell体验的不同。
- en: If you allow signed Windows files with your application control policy, this
    means that PowerShell modules that come with your Windows installation will also
    be allowed to run in Full Language mode. However, custom-created modules would
    run in Constrained language mode, unless they have been configured to be trusted
    in your application control setup. This effectively reduces the attack surface
    of the system.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您允许在应用控制策略中使用签名的 Windows 文件，这意味着与 Windows 安装一起提供的 PowerShell 模块也将被允许在完整语言模式下运行。然而，自定义创建的模块将以受限语言模式运行，除非它们已在您的应用控制设置中被配置为可信。这有效地减少了系统的攻击面。
- en: As mentioned earlier in this chapter, at the time of writing, PowerShell and
    the WSH family are the only dynamic runtimes that can be restricted using application
    control, while others still allow unrestricted code execution. Therefore, PowerShell
    is a huge advantage when locking down your environment with application control
    policies.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，在撰写时，PowerShell 和 WSH 家族是唯一可以通过应用控制进行限制的动态运行时，而其他运行时仍然允许无限制的代码执行。因此，PowerShell
    在使用应用控制策略锁定环境时具有巨大优势。
- en: In summary, enforcing application control mechanisms such as WDAC and AppLocker
    can have a significant impact on improving PowerShell security. It’s possible
    to limit the ability of PowerShell scripts to execute arbitrary code or modify
    system configurations by enforcing constraints such as Constrained Language mode.
    By implementing these measures, it’s possible to reduce the attack surface of
    the system significantly and make it more difficult for attackers to execute malicious
    code.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，实施应用控制机制，如 WDAC 和 AppLocker，可以显著提升 PowerShell 安全性。通过强制执行如受限语言模式等约束，限制 PowerShell
    脚本执行任意代码或修改系统配置的能力。通过实施这些措施，显著减少系统的攻击面，并使攻击者更难执行恶意代码。
- en: Summary
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to configure your existing PowerShell scripts
    as trustworthy and how to allowlist them, but not just PowerShell scripts. At
    this point, you should have a good understanding of how you can implement a proper
    application control solution for all the applications in your environment.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何将现有的 PowerShell 脚本配置为可信，并将其加入允许列表，但不仅仅是 PowerShell 脚本。在这一点上，您应该已经对如何为环境中的所有应用程序实现适当的应用控制解决方案有了充分的理解。
- en: First, you explored how to sign your code and how to create a self-signed script
    that you can use for testing purposes. With this knowledge, you can easily transfer
    to your enterprise scenario, in which you might already have corporate-signed
    or public-signed certificates in use.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您了解了如何签署您的代码，以及如何创建一个自签名脚本，供测试使用。掌握了这些知识后，您可以轻松地转移到企业环境中，您可能已经在使用企业签名或公共签名的证书。
- en: 'Next, we dove into application control and learned what built-in application
    control solutions exist: SRP, AppLocker, and WDAC. You should now also be familiar
    with how to plan for allowlisting applications in your environment.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入研究了应用控制，并了解了现有的内建应用控制解决方案：SRP、AppLocker 和 WDAC。现在，您也应该熟悉如何规划在您的环境中进行允许列表配置。
- en: Then, we explored AppLocker and WDAC and learned how to audit AppLocker and
    WDAC. We also investigated how to configure AppLocker to avoid a possible PowerShell
    downgrade attack.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探索了 AppLocker 和 WDAC，并学习了如何审计 AppLocker 和 WDAC。我们还研究了如何配置 AppLocker 以避免可能的
    PowerShell 降级攻击。
- en: Last but not least, we learned that whenever possible, WDAC is the most secure
    option, followed by AppLocker. However, both can be combined in the same environment,
    depending on your operating systems and use cases.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们了解到，每当可能时，WDAC 是最安全的选项，其次是 AppLocker。然而，二者可以根据操作系统和使用场景在同一环境中结合使用。
- en: However, only restricting scripts and applications is not enough for a secure
    and hardened environment. In the next chapter, we’ll explore how the Windows **Antimalware
    Scan Interface** (**AMSI**) can protect you from malicious code that is run directly
    in the console or in memory.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅限制脚本和应用程序还不足以确保环境的安全性和强化。在下一章中，我们将探讨 Windows **恶意软件扫描接口**（**AMSI**）如何保护您免受直接在控制台或内存中运行的恶意代码攻击。
- en: Further reading
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    take a look at the following resources:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索本章中提到的一些话题，可以参考以下资源：
- en: '**Certificate operations**:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**证书操作**：'
- en: 'New-SelfSignedCertificate: [https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate](https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: New-SelfSignedCertificate：[https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate](https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate)
- en: 'Set-AuthenticodeSignature: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set-AuthenticodeSignature：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature)
- en: 'Get-AuthenticodeSignature: [https://docs.microsoft.com/en-us/powershell/wwmodule/microsoft.powershell.security/get-authenticodesignature](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-authenticodesignature)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Get-AuthenticodeSignature：[https://docs.microsoft.com/en-us/powershell/wwmodule/microsoft.powershell.security/get-authenticodesignature](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-authenticodesignature)
- en: '**CI/CD**:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI/CD**：'
- en: 'CI/CD: The what, why, and how: [https://resources.github.com/ci-cd/](https://resources.github.com/ci-cd/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD：是什么，为什么，如何：[https://resources.github.com/ci-cd/](https://resources.github.com/ci-cd/)
- en: 'About continuous integration: [https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于持续集成：[https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)
- en: '**Application control**:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用控制**：'
- en: 'Application Control for Windows: [https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 的应用程序控制：[https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control)
- en: 'Authorize reputable apps with the Intelligent Security Graph (ISG): [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能安全图（ISG）授权可信应用：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph)
- en: 'Enable virtualization-based protection of code integrity: [https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity](https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用基于虚拟化的代码完整性保护：[https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity](https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity)
- en: 'ConfigCI module reference (ConfigCI): [https://docs.microsoft.com/en-us/powershell/module/configci](https://docs.microsoft.com/en-us/powershell/module/configci)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigCI 模块参考（ConfigCI）：[https://docs.microsoft.com/en-us/powershell/module/configci](https://docs.microsoft.com/en-us/powershell/module/configci)
- en: 'Understand Windows Defender Application Control (WDAC) policy rules and file
    rules: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Windows Defender 应用程序控制（WDAC）策略规则和文件规则：[https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create)
- en: 'Understanding WDAC Policy Settings: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 WDAC 策略设置：[https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings](https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings)
- en: 'Use multiple Windows Defender Application Control Policies: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个 Windows Defender 应用程序控制策略：[https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies](https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies)
- en: 'Use signed policies to protect Windows Defender Application Control against
    tampering: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用签名策略来保护 Windows Defender 应用程序控制免受篡改：[https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering](https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering)
- en: 'Windows Defender Application Control management with Configuration Manager:
    [https://learn.microsoft.com/en-us/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager](https://learn.microsoft.com/en-us/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置管理器管理 Windows Defender 应用程序控制：[https://learn.microsoft.com/zh-cn/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager](https://learn.microsoft.com/zh-cn/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager)
- en: 'Windows Defender Application Control Wizard: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Defender 应用程序控制向导：[https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard](https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard)
- en: '**AppLocker**:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**AppLocker**:'
- en: 'AppLocker Operations Guide: [https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10)](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10))'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppLocker 操作指南：[https://learn.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10)](https://learn.microsoft.com/zh-cn/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10))
- en: 'Enable the DLL rule collection: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 DLL 规则集合：[https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection](https://learn.microsoft.com/zh-cn/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection)
- en: 'You can also find all the links mentioned in this chapter in the GitHub repository
    for [*Chapter 11*](B16679_11_Final_PD.xhtml#_idTextAnchor306) – no need to manually
    type in every link: https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter11/Links.md.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 仓库中找到本章提到的所有链接，无需手动输入每个链接：[*第 11 章*](B16679_11_Final_PD.xhtml#_idTextAnchor306)
    – https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter11/Links.md。
