- en: Malware Obfuscation Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件混淆技术
- en: The term *obfuscation* refers to a process of obscuring meaningful information.
    Malware authors often use various obfuscation techniques to hide the information
    and to modify the malicious content to make detection and analysis difficult for
    a security analyst. Adversaries typically use *encoding/encryptio*n techniques
    to conceal the information from the security products. In addition to using encoding/encryption,
    an attacker uses a program such as packers to obfuscate the malicious binary content,
    which makes analysis and reverse engineering much more difficult. In this chapter,
    we will look at identifying these obfuscation techniques and how to decode/decrypt
    and unpack the malicious binaries. We will begin by looking at the encoding/encryption
    techniques, and later we will look at the unpacking techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*混淆*一词指的是掩盖有意义信息的过程。恶意软件作者通常使用各种混淆技术来隐藏信息，并修改恶意内容，以使安全分析师难以进行检测和分析。对手通常使用*编码/加密*技术来隐藏信息，防止安全产品检测。除了使用编码/加密之外，攻击者还会使用像打包器这样的程序来混淆恶意的二进制内容，这使得分析和逆向工程变得更加困难。在本章中，我们将讨论如何识别这些混淆技术，以及如何解码/解密和解包恶意二进制文件。我们将首先研究编码/加密技术，之后再研究解包技术。'
- en: 'Adversaries typically use encoding and encryption for the following reasons:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对手通常使用编码和加密的原因如下：
- en: To conceal command and control communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了隐蔽命令与控制通信
- en: To hide from a signature-based solution such as Intrusion prevention systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避开基于签名的解决方案，如入侵防御系统
- en: To obscure the content of the configuration file used by the malware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了混淆恶意软件使用的配置文件内容
- en: To encrypt information to be exfiltrated from the victim system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了加密将从受害系统中泄露的信息
- en: To obfuscate strings in the malicious binary to hide from static analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在恶意二进制文件中混淆字符串，以避开静态分析
- en: Before we delve into how malware uses an encryption algorithm, let's try to
    understand the basics and some of the terms that we will use throughout this chapter.
    A *plaintext* refers to an unencrypted message; this might be a command and control
    (C2) traffic or content of the file that malware wants to encrypt. A *ciphertext*
    refers to an encrypted message; this might be an encrypted executable or encrypted
    command that malware receives from the C2 server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解恶意软件如何使用加密算法之前，先让我们了解一些基础概念和本章中会使用的术语。*明文*指的是未加密的消息；这可能是命令与控制（C2）流量或恶意软件想要加密的文件内容。*密文*指的是加密后的消息；这可能是恶意软件从C2服务器接收到的加密可执行文件或加密命令。
- en: 'Malware encrypts the *plaintext*, by passing it as input along with the *key*
    to an encryption function, which produces a *ciphertext*. The resultant ciphertext
    is typically used by the malware to write to file or send over the network:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通过将*明文*与*密钥*一起传递给加密函数来加密，生成*密文*。生成的密文通常会被恶意软件用于写入文件或通过网络发送：
- en: '![](../images/00281.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00281.jpeg)'
- en: 'In the same manner, malware may receive an encrypted content from the C2 server
    or from the file and then decrypt it by passing the *encrypted content* and the
    *key* to the decryption function, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式，恶意软件可能会从C2服务器或文件接收加密内容，然后通过将*加密内容*和*密钥*传递给解密函数来解密，过程如下：
- en: '![](../images/00282.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00282.jpeg)'
- en: While analyzing malware, you may want to understand how a particular content
    is encrypted or decrypted. To do this, you will mainly focus on identifying either
    the encryption or the decryption function and the key used to encrypt or decrypt
    the content. For instance, if you wish to determine how the network content is
    encrypted, then you will likely find the encryption function just before the network
    output operation (such as `HttpSendRequest()`). In the same manner, if you wish
    to know how the encrypted content from the C2 is decrypted, then you are likely
    to find the decryption function after the content is retrieved from C2 using an
    API such as `InternetReadFile()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析恶意软件时，你可能想了解某一特定内容是如何加密或解密的。为此，你将主要关注识别加密或解密函数，以及用于加密或解密内容的密钥。例如，如果你想确定网络内容是如何加密的，那么你很可能会在网络输出操作之前找到加密函数（如`HttpSendRequest()`）。同样，如果你想了解C2的加密内容是如何解密的，那么你很可能会在通过API（如`InternetReadFile()`）从C2获取内容后找到解密函数。
- en: Once the encryption/decryption function is identified, examining these functions
    will give you an idea as to how the content is encrypted/decrypted, the key used,
    and the algorithm used to obfuscate the data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了加密/解密功能，检查这些函数将帮助你了解内容是如何被加密/解密的、使用了什么密钥，以及采用了什么算法来混淆数据。
- en: 1\. Simple Encoding
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 简单编码
- en: Most of the time, attackers use very simple encoding algorithms such as `Base64
    encoding` or `xor encryption` to obscure the data. The reason why attackers use
    simple algorithms because they are easy to implement, takes fewer system resources,
    and are just enough to obscure the content from the security products and the
    security analyst.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，攻击者使用非常简单的编码算法，如`Base64编码`或`异或加密`来混淆数据。攻击者之所以使用简单的算法，是因为它们易于实现，占用的系统资源较少，且足以让安全产品和安全分析人员无法轻易识别内容。
- en: 1.1 Caesar Cipher
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 凯撒密码
- en: '*Ceaser cipher*, also known as *shift cipher*, is a traditional cipher and
    is one of the simplest encoding techniques. It encodes the message by shifting
    each letter in the plaintext with some fixed number of positions down the alphabet.
    For example, if you shift character `''A''` down `3` positions, then you will
    get `''D''`, and `''B''` will be `''E''` and so on,  wrapping back to `''A''`
    when the shift reaches `''X''`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*凯撒密码*，也称为*移位密码*，是一种传统的密码算法，是最简单的编码技术之一。它通过将明文中的每个字母按一定的固定位置向下移动来加密信息。例如，如果你将字符`''A''`向下移动`3`个位置，那么你将得到`''D''`，`''B''`则变为`''E''`，依此类推，当移位达到`''X''`时会回绕到`''A''`。'
- en: 1.1.1 Working Of Caesar Cipher
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1.1 凯撒密码的工作原理
- en: 'The best way to understand Caesar cipher is to write down the letters from
    `A` to `Z` and assign an index, from `0` to `25`, to these letters, as follows
    In other words, `''A''` corresponds to index `0`, `''B''` corresponds to index
    `1`, and so on. A group of all the letters from `A` to `Z` is called the *character
    set*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解凯撒密码的最佳方式是将字母从`A`到`Z`写下来，并为这些字母分配索引，从`0`到`25`，如下所示。换句话说，`'A'`对应索引`0`，`'B'`对应索引`1`，依此类推。所有字母从`A`到`Z`的集合叫做*字符集*：
- en: '![](../images/00283.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00283.jpeg)'
- en: Now, let's say you want to shift the letters by three positions, then `3` becomes
    your key. To encrypt the letter `'A'`, add the index of letter `A`, which is `0`,
    to the key `3`; this results in `0+3 = 3`. Now use the result `3` as an index
    to find the corresponding letter, which is `'D'`, so `'A'` is encrypted to `'D'`.
    To encrypt `'B'`, you will add the index of `'B' (1)` to the key `3`, which results
    in `4`, and the index `4` is associated with `'E'`, so `'B'` encrypts to `'E'`,
    and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想将字母偏移三位，那么`3`就是你的密钥。要加密字母`'A'`，将字母`A`的索引（即`0`）加到密钥`3`上；这就得到`0+3 = 3`。然后，使用结果`3`作为索引来查找对应的字母，即`'D'`，所以`'A'`被加密为`'D'`。要加密`'B'`，你将字母`'B'`的索引（即`1`）加到密钥`3`上，这就得到`4`，索引`4`对应字母`'E'`，因此`'B'`被加密为`'E'`，依此类推。
- en: 'The problem with the previous technique arises when we reach `''X''`, which
    has an index of `23`. When we add `23+3`, we get `26`, but we know that there
    is no character associated with index `26` because the maximum index value is
    `25`. We also know that index `26`, should wrap back to index `0` (which is associated
    with `''A''`). To solve this problem, we use the *modulus* operation with the
    length of the character set. In this case, the length of the character set `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
    is `26`. Now, to encrypt `''X''`, we use the index of `''X'' (23)` and add it
    to the `key (3)` and perform the modulus operation with the length of the character
    set `(26)`, as follows. The result of this operation is `0`, which is used as
    the index to find the corresponding character, that is, `''A''`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前技术的问题出现在当我们到达`'X'`时，它的索引为`23`。当我们将`23+3`时得到`26`，但我们知道索引`26`没有对应的字符，因为最大索引值是`25`。我们也知道索引`26`应该回绕到索引`0`（对应字母`'A'`）。为了解决这个问题，我们使用*取模*操作，取字符集的长度。在这种情况下，字符集`ABCDEFGHIJKLMNOPQRSTUVWXYZ`的长度是`26`。现在，为了加密`'X'`，我们使用`'X'`的索引（`23`）加上密钥（`3`），然后对字符集长度（`26`）进行取模操作，结果为`0`，这个结果作为索引来查找对应的字符，即`'A'`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The modulus operation allows you to cycle back around to the beginning. You
    can use the same logic to encrypt all the characters (from `A` to `Z`) in the
    character set and wrap back to the beginning. In *Caesar cipher*, you can get
    the index of the encrypted (ciphertext) character using:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 取模操作允许你回到开头。你可以使用相同的逻辑来加密字符集中的所有字符（从`A`到`Z`），并在回绕到起点时继续。在*凯撒密码*中，你可以使用以下公式获取加密（密文）字符的索引：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same manner, you can get the index of the plaintext (decrypted) character
    using:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式，你可以使用以下方法获取明文（解密后的）字符的索引：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following diagram shows the character set, the encryption, and the decryption
    of the text `"ZEUS"` using `3` as the key (shifting three positions). After encryption,
    the text `"ZEUS"` is translated to `"CHXV"`, and then the decryption translates
    it back to `"ZEUS"`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了使用 `3` 作为密钥（移动三个位）的字符集、加密和解密文本 `"ZEUS"` 的过程。加密后，文本 `"ZEUS"` 被转换为 `"CHXV"`，然后解密过程将其还原为
    `"ZEUS"`。
- en: '![](../images/00284.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00284.jpeg)'
- en: 1.1.2 Decrypting Caesar Cipher In Python
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1.2 使用 Python 解密凯撒密码
- en: 'The following is an example of a simple Python script that decrypts the string
    `"CHXV"` back to `"ZEUS"`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的 Python 脚本示例，它将字符串 `"CHXV"` 解密回 `"ZEUS"`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some malware samples may use a modified version of Caesar (shift) cipher; in
    that case, you can modify the previously mentioned script to suit your needs.
    The malware *WEBC2-GREENCAT*, used by the APT1 group, fetched the content from
    the C2 server and decrypted the content using the modified version of caesar cipher.
    It used a 66-character' character set, `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._/-`,
    and a key of `56`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件样本可能使用了修改版的凯撒（移位）密码；在这种情况下，你可以修改前面提到的脚本以满足你的需求。APT1 组使用的恶意软件 *WEBC2-GREENCAT*
    从 C2 服务器获取内容，并使用修改版的凯撒密码对内容进行解密。它使用了一个包含 66 个字符的字符集 `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._/-`，密钥为
    `56`。
- en: 1.2 Base64 Encoding
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 Base64 编码
- en: Using Caesar cipher, an attacker can encrypt letters, but it is not good enough
    to encrypt binary data. Attackers use various other encoding/encryption algorithms
    to encrypt binary data. `Base64` encoding allows an attacker to encode binary
    data to an ASCII string format. For this reason, you will often see attackers
    using `Base64`-encoded data in plain text protocols such as HTTP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用凯撒密码，攻击者可以加密字母，但它并不足以加密二进制数据。攻击者使用其他各种编码/加密算法来加密二进制数据。`Base64` 编码允许攻击者将二进制数据编码为
    ASCII 字符串格式。因此，你经常会看到攻击者在 HTTP 等明文协议中使用 `Base64` 编码的数据。
- en: 1.2.1 Translating Data To Base64
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.1 将数据转换为 Base64
- en: 'Standard Base64 encoding consists of the following 64-character set. Each 3
    bytes (24 bits) of the binary data that you want to encode is translated into
    four characters from the character set mentioned later. Each translated character
    is 6 bits in size. In addition to the following characters, the `=` character
    is used for padding:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Base64 编码由以下 64 个字符组成。每 3 个字节（24 位）的二进制数据将被转换为字符集中的四个字符。每个转换后的字符是 6 位大小。除了以下字符外，`=`
    字符用于填充：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To understand how the data is translated into `Base64` encoding, first, build
    the `Base64` index table by assigning index `0` to `63` to the letters in the
    character set, as shown here. As per the following table, the index `0` corresponds
    to the letter `A` and the index `62` corresponds to `+`, and so on:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解数据是如何转换为 `Base64` 编码的，首先，通过将 `0` 到 `63` 的索引分配给字符集中的字母，构建 `Base64` 索引表，如下所示。根据下表，索引
    `0` 对应字母 `A`，索引 `62` 对应字符 `+`，依此类推：
- en: '![](../images/00285.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00285.jpeg)'
- en: 'Now, let''s say we want to `Base64` encode the text `"One"`. To do this, we
    need to convert the letters to their corresponding bit values, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们要对文本 `"One"` 进行 `Base64` 编码。为此，我们需要将字母转换为相应的位值，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Base64` algorithm processes 3 bytes (24 bits) at a time; in this case,
    we have exactly `24` bits that are placed next to each other, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base64` 算法一次处理 3 个字节（24 位）；在这种情况下，我们有恰好 `24` 位，它们被按顺序排列，如下所示：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `24` bits are then split into four parts, each consisting of `6` bits and
    converted to its equivalent decimal value. The decimal value is then used as an
    index to find the corresponding value in the `Base64` index table, so the text
    `One` encodes to `T25l`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这 `24` 位数据拆分为四个部分，每部分包含 `6` 位，并转换为相应的十进制值。然后使用这些十进制值作为索引，查找 `Base64` 索引表中对应的值，因此文本
    `One` 编码为 `T25l`：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Decoding Base64 is a reverse process, but it is not essential to understand
    the workings of `Base64` encoding or decoding, because there are python modules
    and tools that allow you to decode `Base64`-encoded data without having to understand
    the algorithm. Understanding it will help in situations where attackers use a
    custom version of `Base64` encoding.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解码 Base64 是一个逆向过程，但理解 `Base64` 编码或解码的工作原理并非必须，因为有 Python 模块和工具可以帮助你解码 `Base64`
    编码的数据，而无需理解算法。理解这一点有助于在攻击者使用自定义版本的 `Base64` 编码时应对。
- en: 1.2.2 Encoding And Decoding Base64
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.2 编码与解码 Base64
- en: 'To encode data in `Python(2.x)` using `Base64`, use the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `Python(2.x)` 中使用 `Base64` 编码数据，可以使用以下代码：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To decode `base64` data in python, use the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中解码 `base64` 数据，请使用以下代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*CyberChef* by GCHQ is a great web application that allows you to carry out
    all kinds of encoding/decoding, encryption/decryption, compression/decompression,
    and data analysis operations within your browser. You can access CyberChef at [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/),
    and more details can be found at [https://github.com/gchq/CyberChef.](https://github.com/gchq/CyberChef)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*CyberChef* 是由 GCHQ 开发的一款优秀的网络应用程序，允许你在浏览器中执行各种编码/解码、加密/解密、压缩/解压缩和数据分析操作。你可以访问
    CyberChef 网站 [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)，更多信息请参考
    [https://github.com/gchq/CyberChef](https://github.com/gchq/CyberChef)。'
- en: 'You can also use a tool such as *ConverterNET* ([http://www.kahusecurity.com/tools/](http://www.kahusecurity.com/tools/))
    to encode/decode `base64` data. *ConvertNET* offers various features and allows
    you to convert data to/from many different formats. To encode, enter the text
    to encode in the input field and press the Text to Base64 button. To decode, enter
    the encoded data in the input field and press the Base64 to Text button. The following
    screenshot shows the `Base64` encoding of the string `Hi` using ConverterNET:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用像 *ConverterNET* 这样的工具 ([http://www.kahusecurity.com/tools/](http://www.kahusecurity.com/tools/))
    来编码/解码 `base64` 数据。*ConvertNET* 提供多种功能，允许你将数据转换为不同格式的输入/输出。要进行编码，输入要编码的文本并点击“Text
    to Base64”按钮。要进行解码，输入已编码的数据并点击“Base64 to Text”按钮。下图展示了使用 ConverterNET 对字符串 `Hi`
    进行 `Base64` 编码的过程：
- en: '![](../images/00286.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00286.jpeg)'
- en: The `=` character at the end of the encoded string is the padding character.
    If you recall, the algorithm converts the three bytes of input into four characters,
    and as `Hi` has only two characters, it is padded to make it three characters;
    whenever padding is used, you will see the `=` characters at the end of the `Base64`-encoded
    string. What this means is the length of a valid `Base64`-encoded string will
    always be multiples of `4`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编码字符串末尾的 `=` 字符是填充字符。回想一下，算法将三字节的输入转换为四个字符，而 `Hi` 只有两个字符，所以它被填充以使其变为三个字符；每当使用填充时，你都会在
    `Base64` 编码字符串的末尾看到 `=` 字符。这意味着有效的 `Base64` 编码字符串的长度总是 `4` 的倍数。
- en: 1.2.3 Decoding Custom Base64
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.3 解码自定义 Base64
- en: Attackers use different variations of `Base64` encoding; the idea is to prevent
    the `Base64` decoding tools from decoding the data successfully. In this section,
    you will understand some of these techniques.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使用不同的 `Base64` 编码变体；目的是防止 `Base64` 解码工具成功解码数据。在本节中，你将了解这些技巧中的一些。
- en: 'Some malware samples remove the padding character `(=)` from the end. A C2
    communication made by a malware sample (*Trojan Qidmorks*) is shown later. The
    following post payload looks like it is encoded with `base64` encoding:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件样本会从末尾去掉填充字符 `(=)`。稍后会展示一个恶意软件样本（*Trojan Qidmorks*）的 C2 通信。以下的 POST 有效负载看起来像是使用
    `base64` 编码进行编码的：
- en: '![](../images/00287.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00287.jpeg)'
- en: 'When you try to decode the `POST` payload, you get the `Incorrect` padding
    error as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试解码 `POST` 有效负载时，会收到如下的 `Incorrect` 填充错误：
- en: '![](../images/00288.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00288.jpeg)'
- en: 'The reason for this error is that the length of the encoded string `(150)`
    is not multiples of `4`. In other words, two characters are missing from the Base64-encoded
    data, which is very likely to be padding characters (`==`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的原因是编码字符串的长度 `(150)` 不是 `4` 的倍数。换句话说，`Base64` 编码的数据缺少两个字符，这很可能是填充字符（`==`）：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Appending two padding characters `(==)` to the encoded string successfully
    decodes the data, as shown here. From the decoded data, it can be seen that malware
    sends the operating system version (`6.1` that represents Windows 7), the privilege
    level of the user, and the parent process to the C2 server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向编码字符串添加两个填充字符`(==)`可以成功解码数据，如下所示。从解码后的数据中可以看到，恶意软件将操作系统版本（表示Windows 7的`6.1`）、用户的权限级别和父进程发送到C2服务器：
- en: '![](../images/00289.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00289.jpeg)'
- en: 'Sometimes, malware authors use a slight variation of `base64` encoding. For
    instance, an attacker can use a character set where characters `-` and `_` are
    used in place of `+` and `/` (63^(rd) and 64^(th) characters) as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，恶意软件作者会使用`base64`编码的轻微变种。例如，攻击者可以使用一个字符集，其中字符`-`和`_`代替了`+`和`/`（第63和64个字符），如图所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you identify the characters that are replaced in the original character
    set to encode the data, then you can use the code such as the one shown here.
    The idea here is to replace the modified characters back to the original characters
    in the standard character set and then decode it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出在原始字符集中被替换的字符来编码数据，那么你可以使用类似如下的代码。这里的思路是将修改过的字符替换回标准字符集中的原始字符，然后进行解码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sometimes, malware authors alter the order of the characters in the character
    set. For example, they may use the following character set instead of the standard
    character set:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，恶意软件作者会改变字符集中的字符顺序。例如，他们可能会使用以下字符集，而不是标准字符集：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When attackers use a nonstandard `Base64` character set, you can decode the
    data using the following code. Note that in the following code, in addition to
    the `64` characters, the variables `chr_set` and `non_chr_set` also include the
    padding character `=` (65^(th) character), which is required for proper decoding:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者使用非标准的`Base64`字符集时，你可以使用以下代码解码数据。请注意，在以下代码中，除了`64`个字符外，变量`chr_set`和`non_chr_set`还包括填充字符`=`（第65个字符），这是正确解码所必需的：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also perform custom Base64 decoding using the *ConverterNET* tool by
    selecting Conversions | Convert Custom Base64. Just enter the custom `Base64`
    character set in the Alphabet field, and then enter the data to decode in the
    Input field and press the Decode button, as shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用*ConverterNET*工具执行自定义Base64解码，选择Conversions | Convert Custom Base64。只需在Alphabet字段中输入自定义的`Base64`字符集，然后在Input字段中输入要解码的数据，按下Decode按钮，如下所示：
- en: '![](../images/00290.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00290.jpeg)'
- en: 1.2.4 Identifying Base64
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2.4 识别Base64
- en: 'You can identify a binary using base64 encoding by looking for a long string
    comprising the `Base64` character set (alphanumeric characters,  `+` and `/`).
    The following screenshot shows the `Base64` character set in the malicious binary,
    suggesting that malware probably uses `Base64` encoding:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查找包含`Base64`字符集（字母数字字符，`+`和`/`）的长字符串来识别使用了Base64编码的二进制文件。以下截图显示了恶意二进制文件中的`Base64`字符集，表明恶意软件可能使用了`Base64`编码：
- en: '![](../images/00291.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00291.jpeg)'
- en: 'You can use the strings *cross-references* feature (*covered in Chapter 5*)
    to locate the code where the `Base64` character set is being used, as shown in
    the following screenshot. Even though it is not necessary to know where the `Base64`
    character set is used in the code to decode `Base64` data, sometimes, locating
    it can be useful, such as in cases where malware authors use `Base64` encoding
    along with other encryption algorithms. For instance, if malware encrypts the
    C2 network traffic with some encryption algorithm and then uses `Base64` encoding;
    in that case, locating the `Base64` character set will likely land you in the
    `Base64` function. You can then analyze the `Base64` function or identify the
    function that calls the `Base64` function ( Using *Xrefs to* feature), which will probably lead
    you to the encryption function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用字符串*交叉引用*功能（*在第5章中介绍*）来定位`Base64`字符集所在的代码，如下图所示。尽管在解码`Base64`数据时，了解`Base64`字符集在代码中使用的位置并非必须，但有时定位它会很有用，比如当恶意软件作者将`Base64`编码与其他加密算法一起使用时。例如，如果恶意软件使用某种加密算法加密C2网络流量，然后使用`Base64`编码；在这种情况下，定位`Base64`字符集可能会让你进入`Base64`函数。然后，你可以分析`Base64`函数或识别调用`Base64`函数的函数（使用*Xrefs
    to*功能），这可能会引导你到加密函数：
- en: '![](../images/00292.jpeg)You can use string cross-references in *x64dbg;* to
    do this, make sure that the debugger is paused anywhere inside the module and
    then right-click on the disassembly window (CPU window) and select Search for
    | Current Module | String references.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00292.jpeg)你可以在*x64dbg*中使用字符串交叉引用；为此，确保调试器在模块内的某个地方暂停，然后右键点击反汇编窗口（CPU窗口），选择搜索
    | 当前模块 | 字符串引用。'
- en: 'Another method to detect the presence of the `Base64` character set in the
    binary is using a *YARA* rule (YARA was covered in [Chapter 2](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485),
    *Static Analysis*) such as the one shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 检测二进制文件中是否存在`Base64`字符集的另一种方法是使用*YARA*规则（YARA在[第2章](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485)，*静态分析*中有介绍），如这里所示：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 1.3 XOR Encoding
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 XOR 编码
- en: 'Apart from `Base64` encoding, another common encoding algorithm used by the
    malware authors is the `XOR` encoding algorithm. `XOR` is a bitwise operation
    (like `AND`*,* `OR`, and `NOT`), and it is performed on the corresponding bits
    of the operands. The following table depicts the properties of the `XOR` operation.
    In the `XOR` operation, when both the bits are the same, the result is `0`; otherwise,
    the result is `1`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Base64`编码之外，恶意软件作者常用的另一种编码算法是`XOR`编码算法。`XOR`是一种按位操作（类似于`AND`、`OR`和`NOT`），它作用于操作数的相应位。下表显示了`XOR`操作的性质。在`XOR`操作中，当两个位相同时，结果为`0`；否则，结果为`1`：
- en: '| **A** | **B** | **A^B** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A^B** |'
- en: '| `0` | `0` | `0` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` |'
- en: '| `1` | `0` | `1` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` |'
- en: '| `0` | `1` | `1` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` |'
- en: '| `1` | `1` | `0` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` |'
- en: 'For example, when you `XOR` `2` and `4`, that is, `2 ^ 4`, the result is `6`.
    The way it works is shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你对`2`和`4`进行`XOR`，即`2 ^ 4`时，结果是`6`。它的工作原理如下：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 1.3.1 Single Byte XOR
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.1 单字节 XOR
- en: 'In a single byte `XOR`, each byte from the plaintext is `XORed` with the encryption
    key. For example, if an attacker wants to encrypt plaintext `cat` with a key of
    `0x40`, then each character (byte) from the text is `XORed` with `0x40`, which
    results in the cipher-text `#!4`. The following diagram displays the encryption
    process of each individual characters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在单字节`XOR`中，明文中的每个字节都与加密密钥进行`XOR`操作。例如，如果攻击者想要使用`0x40`作为密钥加密明文`cat`，那么文本中的每个字符（字节）都会与`0x40`进行`XOR`运算，结果是密文`#!4`。下图显示了每个字符的加密过程：
- en: '![](../images/00293.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00293.jpeg)'
- en: 'Another interesting property of `XOR` is that when you `XOR` the *ciphertext*
    with the same key used to encrypt, you get back the *plain text*. For example,
    if you take the ciphertext `#!4` from the previous example and `XOR` it with `0x40`
    (key), you get back `cat`. This means that if you know the key, then the same
    function can be used to both encrypt and decrypt the data. The following is a
    simple python script to perform `XOR` decryption (the same function can be used
    to perform `XOR` encryption as well):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`XOR`的另一个有趣的性质是，当你用相同的密钥对*密文*进行`XOR`操作时，可以恢复*明文*。例如，如果你将之前例子中的密文`#!4`与`0x40`（密钥）进行`XOR`运算，你就会得到`cat`。这意味着如果你知道密钥，那么同一个函数可以用来同时加密和解密数据。以下是一个简单的Python脚本，用于执行`XOR`解密（同一个函数也可以用于执行`XOR`加密）：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With an understanding of the `XOR` encoding algorithm, let''s look at an example
    of a keylogger, which encodes all the typed keystrokes to a file. When this sample
    is executed, it logs the keystrokes, and it opens a file (where all the keystrokes
    will be logged) using the `CreateFileA()` API, as shown later. It then writes
    the logged keystrokes to the file using the `WriteFile()` API. Note how the malware
    calls a function (renamed as `enc_function`) after the call to `CreateFileA()`
    and before the call to `WriteFile()`; this function encodes the content before
    writing it to the file. The `enc_function` takes two arguments; the ^(1st) argument
    is the buffer containing the data to encrypt, and the 2^(nd) argument is the length
    of the buffer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了`XOR`编码算法之后，让我们看一个键盘记录器的例子，它将所有的按键输入编码到一个文件中。当该示例被执行时，它会记录按键输入，并使用`CreateFileA()`
    API打开一个文件（所有按键输入将记录到此文件中），如后面所示。然后，它使用`WriteFile()` API将记录的按键输入写入文件。请注意恶意软件在调用`CreateFileA()`之后、`WriteFile()`之前调用了一个函数（重命名为`enc_function`）；这个函数在将内容写入文件之前对其进行编码。`enc_function`接受两个参数；第一个参数是包含待加密数据的缓冲区，第二个参数是缓冲区的长度：
- en: '![](../images/00294.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00294.jpeg)'
- en: 'Examining the `enc_function` shows that the malware uses single byte `XOR`.
    It reads each character from the data buffer and encodes with a key of `0x5A`,
    as shown here. In the following XOR loop, the `edx` register points to the data
    buffer, the `esi` register contains the length of the buffer, and the `ecx` register
    acts as an index into the data buffer that is incremented at the end of the loop,
    and loop is continued as long as the index value `(ecx)` is less than the length
    of the buffer `(esi)`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `enc_function` 显示恶意软件使用单字节 `XOR`。它从数据缓冲区读取每个字符，并使用 `0x5A` 的密钥进行编码，如下所示。在以下的
    XOR 循环中，`edx` 寄存器指向数据缓冲区，`esi` 寄存器包含缓冲区的长度，而 `ecx` 寄存器作为数据缓冲区的索引，在每次循环结束时递增，当索引值
    `(ecx)` 小于缓冲区的长度 `(esi)` 时，循环继续：
- en: '![](../images/00295.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00295.jpeg)'
- en: 1.3.2 Finding XOR Key Through Brute-Force
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.2 通过暴力破解寻找 XOR 密钥
- en: 'In a single byte `XOR`, the length of the key is one byte, so there can be
    only `255` possible keys `(0x0 - 0xff)` with the exception of `0` as the *ke*y
    because XORing any value with `0` will give the same value as result (that is,
    no encryption). Since there are only `255` keys, you can try all possible keys
    on the encrypted data. This technique is useful if you know what to find in the
    decrypted data. For example, upon executing a malware sample, let''s say the malware
    gets the computer hostname `mymachine` and concatenates with some data and performs
    single byte xor encryption, which encrypts it to a ciphertext `lkwpjeia>i}ieglmja`.
    Let''s assume that this ciphertext is exfiltrated in a C2 communication. Now,
    to determine the key used to encrypt the ciphertext, you can either analyze the
    encryption function or brute-force it. The following python commands implement
    the brute-force technique; since we expect the decrypted string to contain `"mymachine"`,
    the script decrypts the encrypted string (ciphertext) with all possible keys and
    displays the key and the decrypted content when `"mymachine"` is found. In the
    later-mentioned example, you can see the key was determined as `4` and the decrypted
    content `hostname:mymachine`, includes the hostname `mymachine`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在单字节 `XOR` 中，密钥的长度为一个字节，因此只有 `255` 个可能的密钥 `(0x0 - 0xff)`，`0` 除外作为 *ke*y，因为任何值与
    `0` 做 `XOR` 运算都会得到相同的结果（即无加密）。由于只有 `255` 个密钥，你可以尝试对加密数据进行所有可能的密钥破解。如果你知道在解密后的数据中要查找的内容，这种技术非常有用。例如，当执行一个恶意软件样本时，假设恶意软件获取了计算机的主机名
    `mymachine`，并与一些数据连接后，进行单字节 `XOR` 加密，最终加密为密文 `lkwpjeia>i}ieglmja`。假设该密文被在 C2 通信中外泄。现在，要确定用于加密密文的密钥，你可以分析加密函数或进行暴力破解。以下
    Python 命令实现了暴力破解技术；因为我们期望解密后的字符串包含 `"mymachine"`，所以脚本会尝试用所有可能的密钥解密加密字符串（密文），并在找到
    `"mymachine"` 时显示密钥和解密后的内容。在后面提到的示例中，你可以看到密钥被确定为 `4`，解密后的内容 `hostname:mymachine`
    包含了主机名 `mymachine`：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use a tool such as *ConverterNET* to brute-force and determine
    the key. To do this, select Tools | Key Search/Convert. In the window that pops
    up, enter the encrypted content and the match string and press the Search button.
    If the key is found, it is displayed in the Result field as shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用诸如 *ConverterNET* 之类的工具来暴力破解并确定密钥。操作步骤是，选择工具 | 密钥搜索/转换。在弹出的窗口中，输入加密内容和匹配字符串，点击搜索按钮。如果找到密钥，它会显示在结果字段中，如下所示：
- en: '![](../images/00296.jpeg)The brute-force technique is useful in determining
    the `XOR` key used to encrypt a PE file (such as EXE or DLL). Just look for the
    match string `MZ` or `This program cannot be run in DOS mode` in the decrypted
    content.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00296.jpeg)暴力破解技术在确定用于加密 PE 文件（如 EXE 或 DLL）的 `XOR` 密钥时非常有用。只需在解密后的内容中查找匹配的字符串
    `MZ` 或 `This program cannot be run in DOS mode`。'
- en: 1.3.3 NULL Ignoring XOR Encoding
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.3 NULL 忽略 XOR 编码
- en: 'In `XOR` encoding, when a null byte `(0x00)` is `XORed` with a key, you get
    back the key as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `XOR` 编码中，当一个空字节 `(0x00)` 与密钥 `XOR` 时，会返回该密钥，如下所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What this means is that whenever a buffer containing a large number of null
    bytes is encoded, the single byte xor key becomes clearly visible. In the following
    example, the `plaintext` variable is assigned a string containing three null bytes
    at the end, which is encrypted with a key `0x4b`  (character `K`), and the encrypted
    output is printed both in hex string format and text format. Note how the three
    `null` bytes in `plaintext` variable are translated to `XOR` key values `0x4b
    0x4b 0x4b` or (`KKK`) in the encrypted content. This property of `XOR` makes it
    easy to spot the key if the null bytes are not ignored:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，每当一个包含大量空字节的缓冲区被编码时，单字节XOR密钥会变得非常明显。在以下示例中，`plaintext`变量被分配了一个字符串，其中包含三个空字节，并使用密钥`0x4b`（字符`K`）加密，且加密后的输出以十六进制字符串格式和文本格式同时打印。请注意，`plaintext`变量中的三个`null`字节在加密内容中被转换为`XOR`密钥值`0x4b
    0x4b 0x4b`（或`KKK`）。这种`XOR`的特性使得如果没有忽略空字节，容易识别出密钥。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot shows the `XOR`-encrypted communication of a malware
    sample (*HeartBeat RAT*). Note the presence of the byte `0x2` spread all over
    the place; this is due to malware encrypting a large buffer (containing null bytes)
    with the `XOR` key of `0x2`. For more information on the reverse engineering of
    this malware, refer to the author''s Cysinfo meet presentation at [https://cysinfo.com/session-10-part-1-reversing-decrypting-communications-of-heartbeat-rat/](https://cysinfo.com/session-10-part-1-reversing-decrypting-communications-of-heartbeat-rat/):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了一个恶意软件样本的`XOR`加密通信（*HeartBeat RAT*）。请注意，字节`0x2`出现在整个加密内容中；这是因为恶意软件使用`0x2`的`XOR`密钥对一个包含空字节的较大缓冲区进行了加密。有关该恶意软件的逆向工程更多信息，请参考作者在Cysinfo会议上的演讲：[https://cysinfo.com/session-10-part-1-reversing-decrypting-communications-of-heartbeat-rat/](https://cysinfo.com/session-10-part-1-reversing-decrypting-communications-of-heartbeat-rat/)。
- en: '![](../images/00297.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00297.jpeg)'
- en: 'To avoid the null byte problem, malware authors ignore the null byte `(0x00)`
    and the *encryption key* during encryption, as shown in the commands mentioned
    here. Note that, in the following code, the plaintext characters are encrypted
    with the key `0x4b`, except the null byte (`0x00`) and the encryption key byte
    (`0x4b`); as a result of this, in the encrypted output, the null bytes are preserved
    without giving away the encryption key. As you can see, when an attacker uses
    this technique, it is not easy to determine the *key* just by looking at the encrypted
    content:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免空字节问题，恶意软件作者在加密过程中忽略空字节`(0x00)`和*加密密钥*，如这里提到的命令所示。请注意，在下面的代码中，明文字符使用密钥`0x4b`进行加密，除了空字节（`0x00`）和加密密钥字节（`0x4b`）；因此，在加密后的输出中，空字节被保留，而不会泄露加密密钥。如你所见，当攻击者使用此技术时，仅通过查看加密内容很难确定*密钥*。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 1.3.4 Multi-byte XOR Encoding
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.4 多字节 XOR 编码
- en: 'Attackers commonly use multi-byte `XOR` because it provides better defense
    against the brute-force technique. For example, if a malware author uses 4-byte
    `XOR` key to encrypt the data and then to brute-force, you will need to try `4,294,967,295
    (0xFFFFFFFF)` possible keys instead of `255 (0xFF)` keys. The following screenshot
    shows the `XOR` decryption loop of the malware (*Taidoor*). In this case, *Taidoor*
    extracted the encrypted PE (exe) file from its resource section and decrypted
    it using the 4-byte `XOR` key `0xEAD4AA34`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者通常使用多字节`XOR`，因为它能更好地防御暴力破解技术。例如，如果恶意软件作者使用4字节`XOR`密钥加密数据，然后进行暴力破解，你将需要尝试`4,294,967,295
    (0xFFFFFFFF)`个可能的密钥，而不是`255 (0xFF)`个密钥。以下截图展示了恶意软件（*Taidoor*）的`XOR`解密循环。在这种情况下，*Taidoor*从其资源部分提取了加密的PE（exe）文件，并使用4字节`XOR`密钥`0xEAD4AA34`对其进行了解密。
- en: '![](../images/00298.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00298.jpeg)'
- en: 'The following screenshot shows the encrypted resource in the *Resource Hacker*
    tool. The resource can be extracted and saved to a file by right-clicking on the
    resource and then selecting **Save Resource to a *.bin file**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了*Resource Hacker*工具中的加密资源。可以通过右键点击资源并选择**将资源保存为*.bin文件**来提取并保存该资源。
- en: '![](../images/00299.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00299.jpeg)'
- en: 'The following is a python script that decodes the encoded resource using a `4-byte
    XOR` key `0xEAD4AA34` and writes the decoded content to a file (`decrypted.bin`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Python脚本，它使用`4字节 XOR`密钥`0xEAD4AA34`解码编码的资源，并将解码后的内容写入文件（`decrypted.bin`）：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The decrypted content is a PE (executable file) as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的内容是一个PE（可执行文件），如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 1.3.5 Identifying XOR Encoding
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3.5 识别 XOR 编码
- en: 'To identify XOR encoding, load the binary in IDA and search for the `XOR` instruction
    by selecting Search | text. In the dialog that appears, enter `xor` and select
    Find all occurrences as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别 XOR 编码，在 IDA 中加载二进制文件并通过选择 搜索 | 文本 来搜索 `XOR` 指令。在弹出的对话框中，输入 `xor` 并选择 查找所有匹配项，如下所示：
- en: '![](../images/00300.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00300.jpeg)'
- en: 'When you click on OK, you will be presented with all the occurrences of `XOR.`
    It is very common to see the `XOR` operation where the operands are the same registers,
    such as `xor eax,eax` or `xor ebx,ebx`. These instructions are used by the compiler
    to zero out register values, and you can ignore these instructions. To identify
    `XOR` encoding, look for *(a)* `XOR` of a register (or memory reference) with
    a constant value such as the one shown here, or *(b)* look for `XOR` of a register
    (or memory reference) with a different register (or memory reference). You can
    navigate to the code by double-clicking on the entry:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“确定”时，所有 `XOR` 的出现位置会被显示出来。通常可以看到 `XOR` 操作，其中操作数是相同的寄存器，如 `xor eax,eax`
    或 `xor ebx,ebx`。这些指令是编译器用来清零寄存器值的，你可以忽略这些指令。要识别 `XOR` 编码，可以查找 *(a)* 具有常量值的寄存器（或内存引用）与
    `XOR` 操作，如下所示，或者 *(b)* 查找寄存器（或内存引用）之间的 `XOR` 操作。你可以通过双击条目跳转到代码：
- en: '![](../images/00301.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00301.jpeg)'
- en: 'The following are some of the tools you can use to determine the `XOR` key.
    In addition to using XOR encoding, attackers may also use `ROL, ROT or SHIFT`
    operations to encode data. *XORSearch* and *Balbuzard* mentioned here also support `ROL`,
    `ROT`, and `Shift` operations in addition to `XOR`. *CyberChef* supports almost
    all types of encoding, encryption, and compression algorithms:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以用来确定 `XOR` 密钥的工具。除了使用 XOR 编码外，攻击者还可能使用 `ROL, ROT 或 SHIFT` 操作来编码数据。这里提到的
    *XORSearch* 和 *Balbuzard* 除了支持 `XOR` 外，还支持 `ROL`、`ROT` 和 `Shift` 操作。*CyberChef*
    支持几乎所有类型的编码、加密和压缩算法：
- en: '*CyberChef:* [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CyberChef:* [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/)'
- en: '*XORSearch* by Didier Stevens: [https://blog.didierstevens.com/programs/xorsearch/](https://blog.didierstevens.com/programs/xorsearch/)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XORSearch* 由 Didier Stevens 开发: [https://blog.didierstevens.com/programs/xorsearch/](https://blog.didierstevens.com/programs/xorsearch/)'
- en: '*Balbuzard:* [https://bitbucket.org/decalage/balbuzard/wiki/Home](https://bitbucket.org/decalage/balbuzard/wiki/Home)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Balbuzard:* [https://bitbucket.org/decalage/balbuzard/wiki/Home](https://bitbucket.org/decalage/balbuzard/wiki/Home)'
- en: '*unXOR:* [https://github.com/tomchop/unxor/#unxor](https://github.com/tomchop/unxor/#unxor)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*unXOR:* [https://github.com/tomchop/unxor/#unxor](https://github.com/tomchop/unxor/#unxor)'
- en: '*brxor.py:* [https://github.com/REMnux/distro/blob/v6/brxor.py](https://github.com/REMnux/distro/blob/v6/brxor.py)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*brxor.py:* [https://github.com/REMnux/distro/blob/v6/brxor.py](https://github.com/REMnux/distro/blob/v6/brxor.py)'
- en: '*NoMoreXOR.py:* [https://github.com/hiddenillusion/NoMoreXOR](https://github.com/hiddenillusion/NoMoreXOR)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NoMoreXOR.py:* [https://github.com/hiddenillusion/NoMoreXOR](https://github.com/hiddenillusion/NoMoreXOR)'
- en: 2\. Malware Encryption
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 恶意软件加密
- en: 'Malware authors often use simple encoding techniques, because it is just enough
    to obscure the data, but sometimes, attackers also use encryption. To identify
    the use of cryptographic functionality in the binary, you can look for cryptographic
    indicators (signatures) such as:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者常常使用简单的编码技术，因为仅仅掩盖数据就足够了，但有时，攻击者也会使用加密。要识别二进制文件中加密功能的使用，可以查找加密指示符（签名），例如：
- en: Strings or imports that reference cryptographic functions
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用加密函数的字符串或导入
- en: Cryptographic constants
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密常量
- en: Unique sequences of instructions used by cryptographic routines
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密例程使用的独特指令序列
- en: 2.1 Identifying Crypto Signatures Using Signsrch
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 使用 Signsrch 识别加密签名
- en: 'A useful tool to search for the cryptographic signatures in a file or process
    is *Signsrch*, which can be downloaded from [http://aluigi.altervista.org/mytoolz.htm](http://aluigi.altervista.org/mytoolz.htm).
    This tool relies on cryptographic signatures to detect encryption algorithms. 
    The cryptographic signatures are located in a text file, `signsrch.sig`. In the
    following output, when `signsrch` is run with the `-e` option, it displays the
    relative virtual addresses where the `DES` signatures were detected in the binary:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的工具是 *Signsrch*，可以用来搜索文件或进程中的加密签名，下载地址是 [http://aluigi.altervista.org/mytoolz.htm](http://aluigi.altervista.org/mytoolz.htm)。该工具依赖加密签名来检测加密算法。加密签名位于文本文件
    `signsrch.sig` 中。在以下输出中，当使用 `-e` 选项运行 `signsrch` 时，它会显示在二进制文件中检测到的 `DES` 签名的相对虚拟地址：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you know the address where the cryptographic indicators are found, you
    can use IDA to navigate to the address. For example, if you want to navigate to
    the address `00410438` (`DES initial permutation IP`), load the binary in IDA
    and select Jump | Jump to address (or *G* hotkey) and enter the address as shown
    here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了加密指示器所在的地址，你可以使用 IDA 导航到该地址。例如，如果你想导航到地址 `00410438`（`DES初始置换IP`），在 IDA
    中加载二进制文件，然后选择 Jump | Jump to address（或按 *G* 热键），并输入地址，如下所示：
- en: '![](../images/00302.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00302.jpeg)'
- en: 'Once you click on OK, you will reach the address containing the indicator (in
    this case, `DES initial permutation IP`, labeled as `DES_ip`) as shown in the
    following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击确认（OK），你将到达包含指示器的地址（在此案例中，`DES初始置换IP`，标记为`DES_ip`），如下图所示：
- en: '![](../images/00303.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00303.jpeg)'
- en: 'Now, to know where and how this crypto indicator is used in the code, you can
    use the cross-references (*Xrefs-to*) feature. Using the cross-references (*Xrefs
    to*) feature shows that `DES_ip` is referenced within a function `sub_4032B0`
    at address `0x4032E0` (`loc_4032E0`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要了解此加密指示器在代码中如何使用，你可以使用交叉引用（*Xrefs-to*）功能。使用交叉引用（*Xrefs to*）功能显示 `DES_ip`
    在地址 `0x4032E0` 的 `sub_4032B0` 函数中被引用（`loc_4032E0`）：
- en: '![](../images/00304.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00304.jpeg)'
- en: 'Now, navigating to the address `0x4032E0` directly lands you inside the `DES`
    encryption function, as shown in the following screenshot. Once the encryption
    function is found, you can use cross-references to examine it further to understand
    in what context the encryption function gets called and the key that is used to
    encrypt the data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直接导航到地址 `0x4032E0` 会带你进入 `DES` 加密函数，如下图所示。找到加密函数后，你可以使用交叉引用进一步检查它，以了解加密函数被调用的上下文以及用于加密数据的密钥：
- en: '![](../images/00305.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00305.jpeg)'
- en: 'Instead of using the `-e` option to locate the signature and then manually
    navigating to the code where the signature is used, you can use the `-F` option,
    which will give you the address of the first instruction where the crypto indicator
    is used. In the following output, running `signsrch` with the `-F` option directly
    displays the address `0x4032E0` where the crypto indicator `DES initial permutation
    IP` (`DES_ip`) is used in the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `-e` 选项定位签名然后手动导航到使用该签名的代码不同，你可以使用 `-F` 选项，它会直接给出加密指示器在代码中使用的第一条指令的地址。在以下输出中，运行
    `signsrch` 并加上 `-F` 选项，会直接显示加密指示器 `DES初始置换IP`（`DES_ip`）在代码中使用的地址 `0x4032E0`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `-e` and `-F` options display the addresses relative to the *preferred
    base address* specified in the PE header. For instance, if the *preferred base
    address* of the binary is `0x00400000`, then the addresses returned by the `-e`
    and `-F` options are determined by adding the relative virtual address with the
    preferred base address `0x00400000`. When you run (or debug) the binary, it can
    be loaded at any address other than the preferred base address (for example, `0x01350000`).
    If you wish to locate the address of the crypto indicator in a running process
    or while you are debugging a binary (in IDA or x64dbg), then you can run the `signsrch`
    with the **`-P <pid or process name>`** option. The `-P` option automatically
    determines the base address where the executable is loaded, and then calculates
    the virtual address of crypto signatures, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 和 `-F` 选项会显示相对于 PE 头中指定的 *首选基地址* 的地址。例如，如果二进制文件的 *首选基地址* 是 `0x00400000`，则
    `-e` 和 `-F` 选项返回的地址是通过将相对虚拟地址与首选基地址 `0x00400000` 相加来确定的。当你运行（或调试）二进制文件时，它可能会加载到除首选基地址以外的任何地址（例如
    `0x01350000`）。如果你希望定位运行中进程或在调试二进制文件时（在 IDA 或 x64dbg 中）中的加密指示器地址，你可以使用 `signsrch`
    命令并加上 **`-P <pid 或进程名称>`** 选项。`-P` 选项会自动确定可执行文件加载的基地址，然后计算加密签名的虚拟地址，如下所示：'
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In addition to detecting encryption algorithms, *Signsrch* can detect compression
    algorithms, some anti-debugging code, and Windows cryptographic functions, which
    normally starts with `Crypt` such as `CryptDecrypt()` and `CryptImportKey()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检测加密算法，*Signsrch* 还可以检测压缩算法、一些反调试代码以及 Windows 加密函数，这些函数通常以 `Crypt` 开头，如 `CryptDecrypt()`
    和 `CryptImportKey()`。
- en: 2.2 Detecting Crypto Constants Using FindCrypt2
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 使用 FindCrypt2 检测加密常量
- en: '*Findcrypt2* ([http://www.hexblog.com/ida_pro/files/findcrypt2.zip](http://www.hexblog.com/ida_pro/files/findcrypt2.zip))
    is an IDA Pro plug-in that searches for cryptographic constants used by many different
    algorithms in memory. To use the plugin, download it, and copy the `findcrypt.plw`
    file into the IDA plugins folder. Now, when you load the binary, the plugin is
    automatically run, or you can manually invoke it by selecting Edit | Plugins |
    Find crypt v2. The results of the plugin are displayed in the output window:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Findcrypt2* ([http://www.hexblog.com/ida_pro/files/findcrypt2.zip](http://www.hexblog.com/ida_pro/files/findcrypt2.zip))
    是一个 IDA Pro 插件，用于在内存中搜索由多种不同算法使用的加密常量。要使用该插件，请下载它，并将 `findcrypt.plw` 文件复制到 IDA
    插件文件夹中。现在，当你加载二进制文件时，插件会自动运行，或者你可以通过选择 编辑 | 插件 | Find crypt v2 手动调用它。插件的结果会显示在输出窗口中：'
- en: '![](../images/00306.jpeg)The *FindCrypt2* plugin can also be run when in the
    debugging mode. *FindCrypt2* works well if you are using IDA 6.x or a lower version;
    at the time of writing this book, it did not seem to work with IDA 7.x version
    (possible due to changes in the IDA 7.x API).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00306.jpeg) *FindCrypt2* 插件也可以在调试模式下运行。如果你使用的是 IDA 6.x 或更低版本，*FindCrypt2*
    能很好地工作；在撰写本书时，它似乎无法与 IDA 7.x 版本兼容（可能是由于 IDA 7.x API 的变化）。'
- en: 2.3 Detecting Crypto Signatures Using YARA
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 使用 YARA 检测加密签名
- en: Another way to identify the use of cryptography in a binary is by scanning the
    binary with YARA rules containing crypto signatures. You can either write your
    own YARA rules, or you can download the YARA rules written by other security researchers
    (such as at [https://github.com/x64dbg/yarasigs/blob/master/crypto_signatures.yara](https://github.com/x64dbg/yarasigs/blob/master/crypto_signatures.yara))
    and then scan the binary with the YARA rules.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种识别二进制文件中加密使用的方法是通过扫描二进制文件并使用包含加密签名的 YARA 规则。你可以编写自己的 YARA 规则，也可以下载其他安全研究人员编写的
    YARA 规则（例如在 [https://github.com/x64dbg/yarasigs/blob/master/crypto_signatures.yara](https://github.com/x64dbg/yarasigs/blob/master/crypto_signatures.yara)），然后使用这些
    YARA 规则扫描二进制文件。
- en: 'The *x64dbg* integrates YARA; this is useful if you wish to scan for the crypto
    signatures in a binary while debugging. You can load the binary into *x64dbg*
    (make sure the execution is paused somewhere in the binary), then right-click
    on the CPU window and select YARA (or *Ctrl + Y*); this will bring up the Yara
    dialog shown here. Click on File and loacte the file containing *YARA* rules.
    You can also load multiple files containing YARA rules from a directory by clicking
    on the Directory button:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*x64dbg* 集成了 YARA；如果你希望在调试时扫描二进制文件中的加密签名，这非常有用。你可以将二进制文件加载到 *x64dbg* 中（确保执行在二进制文件中的某个位置暂停），然后右键单击
    CPU 窗口并选择 YARA（或按 *Ctrl + Y*）；这将弹出显示此处的 YARA 对话框。点击文件并定位包含 *YARA* 规则的文件。你还可以通过点击目录按钮加载包含
    YARA 规则的多个文件：'
- en: '![](../images/00307.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00307.jpeg)'
- en: 'The following screenshot shows the *cryptographic constants* detected in a
    malicious binary as a result of scanning it with the YARA rules containing the
    crypto signatures. Now you can right-click on any of the entries and select Follow
    in Dump to look at the data in the dump window, or, if the signature is related
    to the cryptographic routine, then you can double-click on any of the entries
    to navigate to the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了通过使用包含加密签名的 YARA 规则扫描恶意二进制文件后，检测到的 *加密常量*。现在，你可以右键单击任何条目并选择 “Follow in
    Dump” 以查看转储窗口中的数据，或者如果签名与加密例程相关联，你可以双击任何条目以跳转到相应的代码：
- en: '![](../images/00308.jpeg)Encryption algorithms such as RC4 do not use Cryptographic
    constants because of which it is not easy to detect it using Crypto signatures.
    Often, you will see attackers using RC4 to encrypt the data because it is easy
    to implement; the steps used in RC4 are explained in detail in this Talos blog
    post: [http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html](http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00308.jpeg) 像 RC4 这样的加密算法不使用加密常量，因此很难通过加密签名来检测它。攻击者通常使用 RC4 加密数据，因为它易于实现；RC4
    中使用的步骤在这篇 Talos 博客文章中有详细解释：[http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html](http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html)。'
- en: 2.4 Decrypting In Python
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用 Python 解密
- en: After you have identified the encryption algorithm and the key used to encrypt
    the data, you can decrypt the data using the *PyCryto* ([https://www.dlitz.net/software/pycrypto/](https://www.dlitz.net/software/pycrypto/))
    Python module. To install *PyCrypto,* you can use `apt-get install python-crypto`
    or `pip install pycrypto` or compile it from the source. Pycrypto supports hashing
    algorithms such as `MD2`,  `MD4`, `MD5`,  `RIPEMD`, ` SHA1`, and `SHA256`. It
    also supports encryption algorithms such as `AES`,  `ARC2`,  `Blowfish`,  `CAST`, 
    `DES`,  `DES3 (Triple DES)`,   `IDEA`,  `RC5` and `ARC4`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在你识别出加密算法和用于加密数据的密钥后，可以使用*PyCrypto*（[https://www.dlitz.net/software/pycrypto/](https://www.dlitz.net/software/pycrypto/)）Python模块来解密数据。要安装*PyCrypto*，你可以使用`apt-get
    install python-crypto`或`pip install pycrypto`，或者从源代码编译。PyCrypto支持多种哈希算法，如`MD2`、`MD4`、`MD5`、`RIPEMD`、`SHA1`和`SHA256`。它还支持加密算法，如`AES`、`ARC2`、`Blowfish`、`CAST`、`DES`、`DES3
    (Triple DES)`、`IDEA`、`RC5`和`ARC4`。
- en: 'The following Python commands demonstrate how to generate `MD5`, `SHA1`, and
    `SHA256` hashes using the *Pycrypto* module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python命令演示了如何使用*Pycrypto*模块生成`MD5`、`SHA1`和`SHA256`哈希：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To decrypt the content, import the appropriate encryption modules from `Crypto.Cipher`.
    The following example shows how to encrypt and decrypt using DES in ECB mode:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密内容，请从`Crypto.Cipher`导入适当的加密模块。以下示例演示了如何在ECB模式下使用DES进行加密和解密：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 3\. Custom Encoding/Encryption
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 自定义编码/加密
- en: 'Sometimes, attackers use custom encoding/encryption schemes, which makes it
    difficult to identify the crypto (and the key), and it also makes reverse engineering
    harder. One of the custom encoding methods is to use a combination of encoding
    and encryption to obfuscate the data; an example of such a malware is *Etumbot* ([https://www.arbornetworks.com/blog/asert/illuminating-the-etumbot-apt-backdoor/](https://www.arbornetworks.com/blog/asert/illuminating-the-etumbot-apt-backdoor/)).
    The *Etumbot* malware sample, when executed, obtains the `RC4` key from the C2
    server; it then uses the obtained `RC4` key to encrypt the system information
    (such as hostname, username, and IP address), and the encrypted content is further
    encoded using custom `Base64` and exfiltrated to the C2\. The C2 communication
    containing the obfuscated content is shown later. For reverse engineering details
    of this sample, refer to the Author''s presentation and the video demo ([https://cysinfo.com/12th-meetup-reversing-decrypting-malware-communications/](https://cysinfo.com/12th-meetup-reversing-decrypting-malware-communications/)):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，攻击者使用自定义编码/加密方案，这使得识别加密方式（及密钥）变得困难，也使逆向工程更加复杂。自定义编码方法之一是使用编码和加密的组合来混淆数据；例如，*Etumbot*（[https://www.arbornetworks.com/blog/asert/illuminating-the-etumbot-apt-backdoor/](https://www.arbornetworks.com/blog/asert/illuminating-the-etumbot-apt-backdoor/)）就是这样的恶意软件。当执行*Etumbot*恶意软件样本时，它会从C2服务器获取`RC4`密钥；然后，它使用获取的`RC4`密钥对系统信息（如主机名、用户名和IP地址）进行加密，接着使用自定义`Base64`对加密内容进行进一步编码，并将其外泄到C2。包含混淆内容的C2通信稍后会展示。有关此样本的逆向工程细节，请参考作者的演讲和视频演示（[https://cysinfo.com/12th-meetup-reversing-decrypting-malware-communications/](https://cysinfo.com/12th-meetup-reversing-decrypting-malware-communications/)）：
- en: '![](../images/00309.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00309.jpeg)'
- en: 'To deobfuscate the content, it needs to be decoded using custom `Base64` first
    and then decrypted using `RC4`; these steps are performed using the following
    python commands. The output displays the decrypted system information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要解混淆内容，首先需要使用自定义`Base64`解码，然后再使用`RC4`解密；这些步骤可以通过以下Python命令完成。输出将显示解密后的系统信息：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Instead of using a combination of standard encoding/encryption algorithms,
    some malware authors implement a completely new encoding/encryption schemes. An
    example of such a malware is the one used by the *APT1* group. This malware decrypts
    a string to a URL; to do this, malware calls a user-defined function (renamed
    as `Decrypt_Func` in the later-mentioned screenshot), which implements the custom
    encryption algorithm. The `Decrypt_Func` accepts three arguments; the 1^(st) argument
    is the buffer containing encrypted content, the 2^(nd) argument is a buffer where
    the decrypted content will be stored, and the 3^(rd) argument is the length of
    the buffer. In the following screenshot, the execution is paused before executing `Decrypt_Func`,
    and it shows the ^(1st) argument (buffer containing encrypted content):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者并没有使用标准的编码/加密算法的组合，而是实现了全新的编码/加密方案。一个这样的恶意软件例子是*APT1*组使用的恶意软件。这个恶意软件将一个字符串解密为网址；为此，恶意软件调用了一个用户定义的函数（在后面提到的截图中将其重命名为`Decrypt_Func`），该函数实现了自定义的加密算法。`Decrypt_Func`接受三个参数；第1个参数是包含加密内容的缓冲区，第2个参数是存储解密内容的缓冲区，第3个参数是缓冲区的长度。在下面的截图中，执行在调用`Decrypt_Func`之前暂停，显示了第1个参数（包含加密内容的缓冲区）：
- en: '![](../images/00310.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00310.jpeg)'
- en: 'Depending on your objective, you can either analyze the `Decrypt_Func` to understand
    the workings of the algorithm and then write a decryptor as covered in the author''s
    presentation ([https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/](https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/)),
    or you can allow the malware to decrypt the content for you. To let the malware
    decrypt the content, just *step over* the `Decrypt_Func` (which will finish executing
    the decryption function) and then inspect the 2^(nd) argument (buffer where the
    decrypted content is stored). The following screenshot shows the decrypted buffer
    (2^(nd) argument) containing the malicious URL:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的目标，你可以分析`Decrypt_Func`来理解算法的工作原理，然后按照作者的演示中所讲的内容编写解密器（[https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/](https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/)），或者你也可以让恶意软件为你解密内容。要让恶意软件解密内容，只需*跳过*`Decrypt_Func`（它会执行完解密功能），然后检查第2个参数（存储解密内容的缓冲区）。下图显示了解密后的缓冲区（第2个参数），其中包含恶意网址：
- en: '![](../images/00311.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00311.jpeg)'
- en: 'The previously mentioned technique of allowing the malware to decode the data
    is useful if the decryption function is called few times. If the decryption function
    is called multiple times in a program, it would be more efficient to automate
    the decoding process using debugger scripting (*covered in* [Chapter 6](part0184.html#5FF7G0-ac10ba3f98854c44bac1c2c5641ca485),
    *Debugging Malicious Binary*) rather than doing it manually. To demonstrate this,
    consider the code snippet from a 64-bit malware sample (in the following screenshot).
    Note how the malware calls a function (renamed as `dec_function`) multiple times;
    if you look at the code, you will note that an encrypted string is passed to this
    function as the 1^(st) argument (in `rcx` register), and after executing the function,
    the return value in `eax` contains the address of the buffer where the decrypted
    content is stored:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的让恶意软件解码数据的技术，如果解密函数被调用的次数不多，还是比较有用的。如果解密函数在程序中被调用了多次，使用调试器脚本自动化解码过程会更高效（*详见*
    [第6章](part0184.html#5FF7G0-ac10ba3f98854c44bac1c2c5641ca485)，*恶意二进制调试*），而不是手动操作。为了演示这一点，请看下面这段64位恶意软件的代码片段（在下面的截图中）。注意恶意软件多次调用了一个函数（在稍后的截图中将其重命名为`dec_function`）；如果你查看代码，会发现一个加密的字符串作为第1个参数（存放在`rcx`寄存器中）传递给了这个函数，执行该函数后，`eax`中的返回值包含了存储解密内容的缓冲区地址：
- en: '![](../images/00312.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00312.jpeg)'
- en: 'The following screenshot displays the *cross-references* to the `dec_function`;
    as you can see, this function is called multiple times in the program:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了对`dec_function`的*交叉引用*；如你所见，程序中多次调用了这个函数：
- en: '![](../images/00313.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00313.jpeg)'
- en: 'Each time `dec_function` is called, it decrypts a string. To decrypt all the
    strings passed to this function, we can write an *IDAPython* script (such as the
    one shown here):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`dec_function`时，它都会解密一个字符串。为了解密传递给这个函数的所有字符串，我们可以编写一个*IDAPython*脚本（例如下面显示的脚本）：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we have renamed the decryption function to `dec_function`, it is accessible
    from the names window in IDA. The previous script iterates through the names window
    to identify the `dec_function` and performs the following steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将解密函数重命名为`dec_function`，它可以从IDA中的名称窗口访问。之前的脚本会遍历名称窗口来识别`dec_function`并执行以下步骤：
- en: If the `dec_function` is present, it determines the address of `dec_function`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`dec_function`存在，它会确定`dec_function`的地址。
- en: It uses the address of `dec_function` to determine the cross-references (`Xrefs
    to`) to `dec_function`, which gives all the addresses where `dec_function` is
    called.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`dec_function`的地址来确定`dec_function`的交叉引用（`Xrefs to`），从而列出所有调用`dec_function`的地址。
- en: It sets the breakpoint on all the addresses where `dec_function` is called.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在`dec_function`被调用的所有地址上设置断点。
- en: It starts the debugger automatically, and when the breakpoint is hit at `dec_function`,
    it reads the encrypted string from the address pointed to by the `rcx` register.
    A point to remember is, for the IDA debugger to start automatically, be sure to
    select the debugger (such as Local Windows debugger), either from the Toolbar
    area or by choosing **Debugger | Select debugger**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会自动启动调试器，当在`dec_function`处命中断点时，它会从`rcx`寄存器指向的地址读取加密字符串。需要注意的是，为了让IDA调试器自动启动，请确保选择调试器（例如，本地Windows调试器），可以通过工具栏区域选择，或者选择**Debugger
    | Select debugger**。
- en: It then *steps over* the function to execute the decryption function (`dec_function`)
    and reads the return value `(rax)`, which contains the address of the decrypted
    string. It then prints the decrypted string.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它会*跳过*该函数，执行解密函数（`dec_function`），并读取返回值`(rax)`，该返回值包含解密后字符串的地址。接着，它会打印出解密后的字符串。
- en: It repeats the previous steps, to decrypt each string passed to `dec_function`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它重复之前的步骤，解密每个传递给`dec_function`的字符串。
- en: 'After running the previous script, the encrypted strings and their corresponding
    decrypted strings are displayed in the output window as shown here. From the output,
    you can see that the malware decrypts the file names, registry name, and API function
    names during runtime to avoid suspicion. In other words, these are the strings
    the attacker wants to hide from static analysis:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完之前的脚本后，加密字符串及其对应的解密字符串会显示在输出窗口中，如下所示。从输出中可以看到，恶意软件在运行时解密文件名、注册表名称和API函数名称，以避免引起怀疑。换句话说，这些是攻击者希望从静态分析中隐藏的字符串：
- en: '![](../images/00314.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00314.jpeg)'
- en: 4\. Malware Unpacking
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 恶意软件解包
- en: Attackers go to great lengths to protect their binary from anti-virus detection
    and to make it difficult for a malware analyst to perform static analysis and
    reverse engineering. Malware authors often use *packers* and *cryptors* (*see*
    [Chapter 2](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485)*, Static Analysis,
    for a basic introduction to packers and how to detect them*) to obfuscate the
    executable content. A *packer* is a program that takes a normal executable, compresses
    its contents, and generates a new obfuscated executable. A *cryptor* is like a
    packer instead of compressing the binary; it encrypts it. In other words, a packer
    or cryptor transforms an executable into a form that is difficult to analyze.
    When a binary is packed, it reveals very less information; you will not find strings
    revealing any valuable information, the number of imported functions will be lower,
    and the program instructions will be obscured. To make sense of a packed binary,
    you need to remove the obfuscation layer (unpack) applied to the program; to do
    this, it is important to first understand the workings of a packer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者会尽力保护其二进制文件免受防病毒检测，并使恶意软件分析师很难进行静态分析和逆向工程。恶意软件作者通常使用*压缩器*和*加密器*（*参见* [第2章](part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485)，静态分析，了解压缩器及其检测方法），来混淆可执行内容。*压缩器*是一种程序，它将普通的可执行文件压缩其内容，并生成一个新的混淆可执行文件。*加密器*与压缩器类似，不是压缩二进制文件，而是加密它。换句话说，压缩器或加密器将可执行文件转换为一种难以分析的形式。当一个二进制文件被压缩时，它显示的信息非常少；你不会找到任何包含有价值信息的字符串，导入的函数数量会较少，程序指令也会被模糊化。要理解一个被压缩的二进制文件，你需要去除应用于程序的混淆层（解包）；为此，首先了解压缩器的工作原理非常重要。
- en: 'When a normal executable is passed through a packer, the executable content
    is compressed, and it adds an *unpacking stub* (*decompression routine*). The
    packer then modifies the executable''s entry point to the location of the stub
    and generates a new packed executable. When the packed binary is executed, the
    unpacking stub extracts the original binary (during runtime) and then triggers
    the execution of the original binary by transferring the control to the *original
    entry point (OEP)* as depicted in the following diagram:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个普通的可执行文件经过打包器处理时，可执行内容会被压缩，并添加一个*解包存根*（*解压例程*）。打包器随后修改可执行文件的入口点，将其指向存根的位置，并生成一个新的打包可执行文件。当打包的二进制文件被执行时，解包存根会在运行时提取原始二进制文件，并通过将控制权转移到*原始入口点（OEP）*来触发原始二进制文件的执行，以下图所示：
- en: '![](../images/00315.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00315.jpeg)'
- en: To unpack a packed binary, you can either use automated tools or do it manually.
    The automated approach saves time, but it's not completely reliable (sometimes
    it works and sometimes it doesn't), whereas the manual method is time-consuming,
    but once you acquire the skills, it is the most reliable method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 解包一个打包的二进制文件时，可以使用自动化工具或手动操作。自动化方法节省时间，但并非完全可靠（有时有效，有时无效），而手动方法虽然耗时，但一旦掌握技能，它是最可靠的方法。
- en: 4.1 Manual Unpacking
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 手动解包
- en: 'To unpack the binary packed with a packer, we normally perform the following
    general steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包被打包器打包的二进制文件，通常需要执行以下一般步骤：
- en: The first step is to identify the *OEP;* as mentioned previously, when a packed
    binary is executed, it extracts the original binary, and at some point, it transfers
    control to the *OEP*. The original entry point (OEP) is the address of the malware's
    first instruction (where malicious code begins) before it was packed. In this
    step, we identify the instruction in the packed binary that will jump (lead us)
    to the OEP.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是确定*OEP*；如前所述，当一个打包的二进制文件被执行时，它会提取原始二进制文件，并在某个时刻将控制权转移到*OEP*。原始入口点（OEP）是恶意软件的第一条指令的地址（恶意代码的起始位置），即在打包之前的位置。在此步骤中，我们需要识别打包二进制文件中的指令，这条指令会跳转（引导我们）到
    OEP。
- en: The next step involves executing the program until the OEP is reached; the idea
    is to allow the malware stub to unpack itself in memory and pause at the OEP (before
    executing malicious code).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是执行程序，直到到达 OEP；其目的是让恶意软件的存根在内存中自解包并暂停在 OEP 处（在执行恶意代码之前）。
- en: The third step involves dumping the unpacked process from the memory to disk.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是将解包后的进程从内存转储到磁盘。
- en: The final step involves fixing the *Import Address Table (IAT)* of the dumped
    file.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是修复*导入地址表（IAT）*，即转储文件的导入地址表。
- en: In the next few sections, we will look at these steps in detail. To demonstrate
    the previous concepts, we will use a malware packed with the *UPX packer* ([https://upx.github.io/](https://upx.github.io/)).
    The tools and techniques covered in the next few sections should give you an idea
    of the manual unpacking process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细探讨这些步骤。为了演示之前的概念，我们将使用一个被*UPX 打包器*打包的恶意软件（[https://upx.github.io/](https://upx.github.io/)）。接下来几节中介绍的工具和技术将帮助你了解手动解包过程。
- en: 4.1.1 Identifying The OEP
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1.1 确定 OEP
- en: 'In this section, you will understand the techniques to identify the OEP in
    the packed binary. In the following screenshot, examining the packed binary in *pestudio* ([https://www.winitor.com/](https://www.winitor.com/)) shows
    many indicators that suggest the file is packed. The packed binary contains three
    sections, `UPX0`, `UPX1`, and `.rsrc`. From the screenshot, you can see that the
    entry point of the packed binary is in the `UPX1` section, so the execution begins
    here, and this section contains the decompression stub that will unpack the original
    executable at runtime. Another indicator is that the raw-size of the `UPX0` section
    is `0`, but the virtual-size is `0x1f000`; this suggests that the `UPX0` section
    does not occupy any space on the disk, but it occupies space in memory; to be
    specific, it occupies a size of `0x1f000` bytes (this is because the malware decompresses
    the executable in memory and stores it in the `UPX0` section during runtime).
    Also, the `UPX0` section has a `read`, `write`, `execute` permission, most likely
    because after decompressing the original binary, the malicious code will start
    executing in `UPX0`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助您理解识别打包二进制文件中 OEP 的技巧。在以下截图中，使用 *pestudio*（[https://www.winitor.com/](https://www.winitor.com/)）检查打包二进制文件显示了许多提示，表明该文件被打包。打包二进制文件包含三个部分，`UPX0`、`UPX1`
    和 `.rsrc`。从截图中可以看出，打包二进制文件的入口点在 `UPX1` 部分，因此执行从这里开始，这一部分包含将在运行时解压原始可执行文件的解压存根。另一个指示是，`UPX0`
    部分的原始大小为 `0`，但虚拟大小为 `0x1f000`；这表明 `UPX0` 部分在磁盘上不占用任何空间，但在内存中占用空间；具体来说，它在内存中占用了
    `0x1f000` 字节的大小（这是因为恶意软件在内存中解压可执行文件，并在运行时将其存储在 `UPX0` 部分）。此外，`UPX0` 部分具有 `读`、`写`、`执行`
    权限，很可能是因为解压原始二进制文件后，恶意代码将在 `UPX0` 中开始执行：
- en: '![](../images/00316.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00316.jpeg)'
- en: 'Another indicator is that the packed binary contains obfuscated strings, and
    when you load the binary in IDA, IDA recognizes that the import address table
    (*IAT*) is in a nonstandard location and displays the following warning; this
    is due to `UPX` packing all the sections and *IAT*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个指示是，打包二进制文件包含了混淆的字符串，当您在 IDA 中加载二进制文件时，IDA 识别出导入地址表（*IAT*）位于非标准位置，并显示以下警告；这是由于
    `UPX` 打包了所有部分和 *IAT*：
- en: '![](../images/00317.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00317.jpeg)'
- en: 'The binary consists of only one built-in function and only 5 imported functions;
    all these indicators suggest that the binary is packed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该二进制文件仅包含一个内建函数和 5 个导入函数；所有这些指示都表明该二进制文件已被打包：
- en: '![](../images/00318.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00318.jpeg)'
- en: 'To find the OEP, you will need to locate the instruction in the packed program
    that transfers control to the OEP. Depending on the packer, this can be simple
    or challenging; you will normally focus on those instructions that transfer control
    to an unclear destination. Examining the flowchart of the function in the packed
    binary shows a jump to a location, which is highlighted in red by IDA:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 OEP，您需要定位程序中将控制转移到 OEP 的指令。根据打包器的不同，这可能简单也可能具有挑战性；通常，您需要关注那些将控制转移到不明确目的地的指令。检查打包二进制文件中函数的流程图会看到跳转到一个位置，该位置在
    IDA 中被标红：
- en: '![](../images/00319.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00319.jpeg)'
- en: 'The red color is IDA''s way of saying it cannot analyze because the jump destination
    is unclear. The following screenshot shows the jump instruction:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 红色是 IDA 无法分析的标志，因为跳转目的地不明确。以下截图显示了跳转指令：
- en: '![](../images/00320.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00320.jpeg)'
- en: Double-clicking on the *jump destination* `(byte_40259B)` shows that the jump
    will be taken to `UPX0` (from `UPX1`). In other words, upon execution, the malware
    executes decompression stub in `UPX1`, which unpacks the original binary, copies
    unpacked code in `UPX0`, and the jump instruction will most likely transfer the
    control to the unpacked code in `UPX0` (from `UPX1`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 *跳转目的地* `(byte_40259B)` 显示跳转将到达 `UPX0`（从 `UPX1`）。换句话说，执行时，恶意软件将在 `UPX1` 执行解压缩存根，这将解压原始二进制文件，将解压后的代码复制到
    `UPX0`，并且跳转指令很可能将控制转移到 `UPX0` 中解压后的代码（从 `UPX1`）。
- en: '![](../images/00321.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00321.jpeg)'
- en: At this point, we have located the instruction that we believe will jump to
    the `OEP`. The next step is to load the binary in a debugger and set a *breakpoint*
    at the instruction performing the jump and execute until it reaches that instruction.
    To do that, the binary was loaded into *x64dbg* (you can also use the IDA debugger
    and follow the same steps) and a *breakpoint* was set and executed until the jump
    instruction. As shown in the following screenshot, the execution is paused at
    that jump instruction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，我们已经找到了我们认为会跳转到`OEP`的指令。下一步是将二进制文件加载到调试器中，并在执行跳转的指令处设置*断点*，然后执行直到到达该指令。为此，二进制文件已加载到*x64dbg*中（你也可以使用IDA调试器并按照相同的步骤操作），并在跳转指令处设置了*断点*，执行直到跳转指令。如下面的截图所示，执行在该跳转指令处暂停。
- en: '![](../images/00322.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00322.jpeg)'
- en: 'You can now assume that the malware has finished unpacking; now, you can press
    *F7* once (step into), which takes you to the original entry point at address
    `0x0040259B.` At this point, we are at the malware''s first instruction (after
    unpacking):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以假设恶意软件已经完成解压；接下来，你可以按一次*F7*（进入），这将带你到原始入口点地址`0x0040259B`。此时，我们来到了恶意软件的第一条指令（解压后）：
- en: '![](../images/00323.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00323.jpeg)'
- en: 4.1.2 Dumping Process Memory With Scylla
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1.2 使用Scylla转储进程内存
- en: 'Now that we have located the OEP, the next step is to dump the process memory
    to disk. To dump the process, we will use a tool named *Scylla* ([https://github.com/NtQuery/Scylla](https://github.com/NtQuery/Scylla));
    it is a great tool to dump the process memory and to rebuild the import address
    table. One of the great features of *x64dbg* is that it integrates *Scylla*, and
    Scylla can be launched by clicking on Plugins | Scylla, (or *Ctrl* *+ I*). To
    dump the process memory, while the execution is paused at the OEP, launch Scylla,
    make sure that the OEP field is set to correct address as follows; if not you
    need to set it manually and click on the Dump button and save the dumped executable
    to disk (in this case, it was saved as `packed_dump.exe`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了OEP，下一步是将进程内存转储到磁盘。为了转储进程，我们将使用名为*Scylla*的工具（[https://github.com/NtQuery/Scylla](https://github.com/NtQuery/Scylla)）；这是一个很棒的工具，可以用来转储进程内存并重建导入地址表。*x64dbg*的一个优点是它集成了*Scylla*，你可以通过点击插件
    | Scylla来启动它（或者按*Ctrl* + *I*）。要转储进程内存，当执行在OEP处暂停时，启动Scylla，确保OEP字段设置为正确的地址，如下所示；如果没有，你需要手动设置它，然后点击Dump按钮并将转储的可执行文件保存到磁盘（在这种情况下，它被保存为`packed_dump.exe`）：
- en: '![](../images/00324.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00324.jpeg)'
- en: 'Now, when you load the dumped executable into IDA, you will see the entire
    list of built-in functions (which was not visible in the packed program before),
    and the function code is no longer obfuscated, but still, the *imports* are not
    visible, and the API call displays addresses instead of names. To overcome this
    problem, you need to rebuild the import table of the packed binary:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你将转储的可执行文件加载到IDA时，你将看到所有内置函数的完整列表（这在打包程序中是不可见的），并且函数代码不再被混淆，但*导入*仍然不可见，API调用显示的是地址而不是名称。为了克服这个问题，你需要重建打包二进制文件的导入表：
- en: '![](../images/00325.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00325.jpeg)'
- en: 4.1.3 Fixing The Import Table
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1.3 修复导入表
- en: 'To fix the imports, go back to *Scylla*, and click on the IAT Autosearch button,
    which will scan the memory of the process to locate the import table; if found,
    it populates the VA and the size fields with appropriate values. To get the list
    of imports, click on the Get Imports button. The list of imported functions determined
    using this method is shown here. Sometimes, you may note invalid entries (with
    no tick mark next to the entry) in the results; in such case, right-click those
    entries and choose Cut Thunk to delete them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复导入，返回到*Scylla*，点击IAT Autosearch按钮，它将扫描进程内存以定位导入表；如果找到了，它将填充VA和大小字段并显示适当的值。要获取导入列表，点击Get
    Imports按钮。使用这种方法确定的导入函数列表如下所示。有时，你可能会在结果中看到无效条目（没有勾选标记的条目）；在这种情况下，右键点击这些条目并选择Cut
    Thunk来删除它们：
- en: '![](../images/00326.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00326.jpeg)'
- en: 'After determining the imported functions using the previous step, you need
    to apply the patch to the dumped executable (`packed_dump.exe`). To do that, click
    on the Fix Dump button, which will launch the file browser where you can select
    the file that you dumped before. *Scylla* will patch the binary with the determined
    import functions, and a new file will be created with a file name containing `_SCY`
    at the end (such as `packed_dumped_SCY.exe`). Now, when you load the patched file
    in IDA, you will see references to the imported function, as shown here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用前一步确定了导入函数后，您需要将补丁应用到已转储的可执行文件（`packed_dump.exe`）。为此，请点击“Fix Dump”按钮，启动文件浏览器，您可以选择之前转储的文件。*Scylla*
    会使用已确定的导入函数对二进制文件进行补丁处理，并创建一个新的文件，文件名末尾会包含 `_SCY`（例如 `packed_dumped_SCY.exe`）。现在，当您在
    IDA 中加载已修补的文件时，您将看到导入函数的引用，如下所示：
- en: '![](../images/00327.jpeg)When you are dealing with some of the packers, the IAT
    Autosearch button in Scylla may not be able to find the module''s import table;
    in such a case, you may need to put in some extra effort to manually determine
    the start of the import table and the size of the import table and enter them
    in the VA and the Size fields.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00327.jpeg)当您处理某些打包工具时，Scylla 中的 IAT 自动搜索按钮可能无法找到模块的导入表；在这种情况下，您可能需要额外的努力来手动确定导入表的起始位置和大小，并将它们输入到
    VA 和大小字段中。'
- en: 4.2 Automated Unpacking
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 自动解包
- en: 'There are various tools that allow you to unpack the malware packed with common
    packers such as *UPX*, *FSG*, and *AsPack*. Automated tools are great for known
    packers and can save time, but remember, it may not always work; that is when
    the manual unpacking skills will help. *TitanMist* by ReversingLabs ([https://www.reversinglabs.com/open-source/titanmist.html](https://www.reversinglabs.com/open-source/titanmist.html))
    is a great tool that consists of various *packer signatures* and *unpacking scripts*.
    After you download and extract it, you can run it against the packed binary using
    the command shown here; using `-i`, you specify the input file (packed file),
    and `-o` specifies the output filename, and `-t` specifies the type of unpacker.
    In the later-mentioned command, *TitanMist* was run against the binary packed
    with *UPX; *note how it automatically identified the packer and performed the
    unpacking process. The tool automatically identified the OEP and import table,
    dumped the process, fixed the imports, and applied the patch to the dumped process:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种工具可以解包使用常见打包工具如 *UPX*、*FSG* 和 *AsPack* 打包的恶意软件。自动化工具对于已知的打包工具非常有效，可以节省时间，但请记住，它并不总是有效；这时，手动解包技巧将派上用场。ReversingLabs
    的 *TitanMist* ([https://www.reversinglabs.com/open-source/titanmist.html](https://www.reversinglabs.com/open-source/titanmist.html))
    是一个很棒的工具，包含各种 *打包工具签名* 和 *解包脚本*。下载并解压后，您可以使用如下命令运行它来对打包的二进制文件进行解包；使用 `-i` 来指定输入文件（打包文件），`-o`
    指定输出文件名，`-t` 指定解包器的类型。在后面提到的命令中，*TitanMist* 被用来处理一个使用 *UPX* 打包的二进制文件；请注意它是如何自动识别打包工具并执行解包过程的。该工具自动识别了
    OEP 和导入表，转储了进程，修复了导入项，并将补丁应用到转储的进程中：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another option is to use the IDA Pro''s *Universal PE Unpacker plugin*. This
    plugin relies on debugging the malware, to determine when the code jumps to the
    OEP. For detailed information on this plugin, refer to this article ([https://www.hex-rays.com/products/ida/support/tutorials/unpack_pe/unpacking.pdf](https://www.hex-rays.com/products/ida/support/tutorials/unpack_pe/unpacking.pdf)).
    To invoke this plugin, load the binary into IDA and select Edit | Plugins | Universal
    PE unpacker. Running the plugin launches the program in the debugger, and it tries
    to suspend it, as soon as the packer finishes unpacking. After loading the *UPX-*packed
    malware (the same sample used in manual unpacking) in IDA and launching the plugin,
    the following dialog is displayed. In the following screenshot, IDA set the start
    address and end address to the range of the `UPX0` section; this range is treated
    as the `OEP` range. In other words, when the execution reaches this section (from
    `UPX1`, which contains decompression stub), IDA will suspend the program execution,
    giving you a chance to take further action:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用IDA Pro的*Universal PE Unpacker插件*。这个插件依赖于调试恶意软件，以确定代码何时跳转到OEP。有关此插件的详细信息，请参考这篇文章（[https://www.hex-rays.com/products/ida/support/tutorials/unpack_pe/unpacking.pdf](https://www.hex-rays.com/products/ida/support/tutorials/unpack_pe/unpacking.pdf)）。要调用此插件，将二进制文件加载到IDA中，选择编辑
    | 插件 | Universal PE unpacker。运行插件后，程序将在调试器中启动，并尝试在打包程序解包完成时暂停。将*UPX-*打包的恶意软件（与手动解包中使用的示例相同）加载到IDA中并启动插件后，将显示以下对话框。在以下截图中，IDA将起始地址和结束地址设置为`UPX0`段的范围；这个范围被视为`OEP`范围。换句话说，当执行到达此段时（从包含解压缩存根的`UPX1`段），IDA将暂停程序执行，给你机会采取进一步的行动：
- en: '![](../images/00328.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00328.jpeg)'
- en: 'In the following screenshot, note how IDA automatically determined the OEP
    address and then showed the following dialog:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，注意IDA如何自动确定OEP地址，并显示出以下对话框：
- en: '![](../images/00329.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00329.jpeg)'
- en: 'If you click on the Yes button, the execution is stopped, and the process is
    exited but before that, IDA automatically determines the import address table
    (IAT) and it creates a new segment to rebuild the import section of the program.
    At this point, you can analyze the unpacked code. The following screenshot shows
    the newly rebuilt import address table:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击“Yes”按钮，执行将停止，进程将退出，但在此之前，IDA会自动确定导入地址表（IAT），并创建一个新段来重建程序的导入部分。此时，你可以分析已解包的代码。以下截图展示了新重建的导入地址表：
- en: '![](../images/00330.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00330.jpeg)'
- en: Instead of clicking the YES button, if you click on the No button, then IDA
    will pause the debugger execution at the OEP, and At this point, you can either
    debug the unpacked code or manually dump the executable, fix the imports using
    a tool such as *Scylla* by entering the proper OEP (as covered in *Section 4.1
    manual unpacking*).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不点击“YES”按钮，而是点击“No”按钮，IDA将会在OEP处暂停调试器的执行，接下来你可以选择调试已解包的代码，或者手动导出可执行文件，使用像*Scylla*这样的工具修复导入项，通过输入正确的OEP（如在*第4.1节手动解包*中讲解的那样）。
- en: 'In *x64dbg,* you can perform automated unpacking using unpacking scripts, which
    can be downloaded from [https://github.com/x64dbg/Scripts](https://github.com/x64dbg/Scripts).
    To unpack, make sure that the binary is loaded and paused at the entry point.
    Depending on the packer you are dealing with, you need to load the appropriate
    unpacker script by right-clicking on the script pane and then by selecting Load
    Script | Open (or *Ctrl + O*). The following screenshot shows the contents of
    the UPX unpacker script:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x64dbg*中，你可以使用解包脚本进行自动化解包，这些脚本可以从[https://github.com/x64dbg/Scripts](https://github.com/x64dbg/Scripts)下载。要进行解包，确保二进制文件已加载并暂停在入口点。根据你使用的打包工具，你需要通过右键点击脚本面板然后选择加载脚本
    | 打开（或 *Ctrl + O*）来加载相应的解包脚本。以下截图展示了UPX解包脚本的内容：
- en: '![](../images/00331.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00331.jpeg)'
- en: 'After loading the script, run the script by right-clicking on the script pane
    and by selecting Run. If the script successfully unpacks it, a message box pops
    up saying Script Finished and the execution will be paused at the OEP. The following
    screenshot shows the breakpoint (In the CPU pane) automatically set at the OEP
    as a result of running the UPX unpacker script. Now, you can start debugging the
    unpacked code or you can use *Scylla* to dump the process and fix the imports
    (as described in *section 4.1 manual unpacking*):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 加载脚本后，右键点击脚本窗格并选择“运行”以运行脚本。如果脚本成功解包，将弹出一个消息框，显示“脚本完成”，并且执行会暂停在OEP处。以下截图显示了在运行UPX解包脚本后，自动在OEP处设置的断点（在CPU窗格中）。现在，你可以开始调试解包后的代码，或者使用*Scylla*来转储进程并修复导入（如*第4.1节手动解包*所述）：
- en: '![](../images/00332.jpeg)In addition to the earlier-mentioned tools, there
    are various other resources that can help you with automatic unpacking. See *Ether
    Unpack Service*: [http://ether.gtisc.gatech.edu/web_unpack/](http://ether.gtisc.gatech.edu/web_unpack/),
    *FUU (Faster Universal Unpacker)*: [https://github.com/crackinglandia/fuu.](https://github.com/crackinglandia/fuu)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00332.jpeg)除了前面提到的工具外，还有其他各种资源可以帮助你进行自动解包。请参见*Ether Unpack Service*：[http://ether.gtisc.gatech.edu/web_unpack/](http://ether.gtisc.gatech.edu/web_unpack/)，*FUU
    (Faster Universal Unpacker)*：[https://github.com/crackinglandia/fuu.](https://github.com/crackinglandia/fuu)'
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Malware authors use obfuscation techniques to conceal the data and to hide information
    from the security analyst. In this chapter, we looked at various encoding, encryption,
    and packing techniques commonly used by the malware authors, and we also looked
    at different strategies to deobfuscate the data. In the next chapter, you will
    be introduced to the concept of memory forensics, and you will understand how
    to use memory forensics to investigate malware capabilities.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用混淆技术来隐藏数据并避开安全分析员的检测。在本章中，我们介绍了恶意软件作者常用的各种编码、加密和打包技术，并探讨了不同的去混淆策略。在下一章，你将接触到内存取证的概念，并了解如何利用内存取证来调查恶意软件的能力。
