- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Client-Side Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端测试
- en: When tackling client-side testing, the types of attacks are focused purely on
    the client (browser) and not vectors that move to exploit the server side of an
    application’s architecture. These types of attacks focus on client-side components
    of a system or application, such as the web browser or operating system. To find
    vulnerabilities and flaws, testers may employ a range of tools and methodologies,
    including manual testing, automated testing tools, and network scanners. You will
    learn to actively attack common issues, such as **document object model** **(DOM)-based
    cross-site scripting** (**XSS**), **JavaScript execution** such as disclosing
    an end user’s session cookies, **HTML injection**, where an attacker injects malicious
    code, **client-side URL redirect**, where an attacker manipulates a website or
    web application to redirect a victim’s client, **cross-origin resource sharing**,
    which exploits vulnerabilities in a web application’s security policy to access
    resources or data and **testing WebSockets**, where an attacker leverages WebSocket
    protocol flaws to intercept, tamper with, or falsify communications transmitted
    between a client and server. The purpose of client-side pen testing is to find
    and report vulnerabilities and flaws that attackers can potentially exploit. Organizations
    can improve the security of their systems and guard against possible attacks by
    detecting and fixing these vulnerabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行客户端测试时，攻击类型主要集中在客户端（浏览器）上，而非攻击应用架构的服务器端。这些攻击类型专注于系统或应用的客户端组件，例如网页浏览器或操作系统。为了发现漏洞和缺陷，测试人员可能会采用一系列工具和方法，包括手动测试、自动化测试工具和网络扫描器。你将学习主动攻击常见问题，如**文档对象模型**
    (**DOM**) 基于的跨站脚本攻击 (**XSS**)、**JavaScript 执行**（例如泄露最终用户的会话 Cookie）、**HTML 注入**（攻击者注入恶意代码）、**客户端
    URL 重定向**（攻击者操控网站或 Web 应用，将受害者客户端重定向）、**跨源资源共享**（利用 Web 应用的安全策略漏洞访问资源或数据）以及**WebSockets
    测试**（攻击者利用 WebSocket 协议漏洞拦截、篡改或伪造客户端与服务器之间的通信）。客户端渗透测试的目的是发现并报告攻击者可能利用的漏洞和缺陷。通过检测并修复这些漏洞，组织可以提升系统安全，防止潜在攻击。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将涵盖以下实验内容：
- en: Testing for DOM-based cross-site scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试基于 DOM 的跨站脚本攻击
- en: Testing for JavaScript execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 JavaScript 执行
- en: Testing for HTML injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 HTML 注入
- en: Testing for client-side URL redirect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试客户端 URL 重定向
- en: Testing cross-origin resource sharing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试跨源资源共享
- en: Testing WebSockets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 WebSockets
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, it is required that you utilize a common browser such as Mozilla
    Firefox. You will also utilize your PortSwigger account to access the PortSwigger
    Academy labs that will be used in this chapter’s recipes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节要求使用常见的浏览器，例如 Mozilla Firefox。你还需要使用你的 PortSwigger 账户访问将在本章节实验中使用的 PortSwigger
    Academy 实验室。
- en: Testing for DOM-based cross-site scripting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试基于 DOM 的跨站脚本攻击
- en: This is opposed to reflected cross-site scripting, where malicious JavaScript
    is returned by the web server, or stored XSS, where attacks are permanently stored
    on the target server or database. Both of those attacks are server-side injection
    issues. When it comes to DOM XSS, it is purely client side. **DOM XSS** is an
    attack against the client (browser) DOM environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这与反射型跨站脚本攻击相对，反射型跨站脚本攻击是恶意 JavaScript 被 Web 服务器返回，或者存储型 XSS 攻击，是攻击被永久存储在目标服务器或数据库中。这两种攻击都是服务器端注入问题。而
    DOM XSS 是纯粹的客户端攻击。**DOM XSS** 是针对客户端（浏览器）DOM 环境的攻击。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个 PortSwigger Academy 账户以及 ZAP 来拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, users will attack the search query tracking feature, which has
    a DOM-based XSS vulnerability. This weakness makes use of the **document.write**
    JavaScript function to output data to the web page. Then data from **location.search**,
    which can be modified using the URL, passes to the **document.write** method.
    To complete the lab, a DOM XSS attack needs to call an **alert** function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，用户将攻击具有基于 DOM 的 XSS 漏洞的搜索查询跟踪功能。这个弱点利用了 **document.write** JavaScript
    函数将数据输出到网页。然后，**location.search** 中的数据可以通过 URL 修改并传递给 **document.write** 方法。要完成实验，DOM
    XSS 攻击需要调用 **alert** 函数。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Examining the page source code can be very helpful in discovering DOM XSS vulnerabilities
    that can be exploited by looking for common DOM elements that are used when creating
    attacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 检查页面源代码可以帮助你发现可被利用的 DOM XSS 漏洞，方法是寻找在创建攻击时常用的 DOM 元素。
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink)).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至使用 ZAP 代理的浏览器的 URL，并登录 PortSwigger Academy 网站以启动实验室 ([https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-document-write-sink))。
- en: Once the lab loads, you’ll be at a main blog page with a search bar. Here, enter
    any word or letters into it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实验室加载完成，你将看到一个包含搜索栏的主博客页面。在这里，输入任何单词或字母。
- en: The application will attempt to look up your word and will be displayed back
    to you in single quotations. Right-click the result and select **Inspect**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将尝试查找你的词，并以单引号形式显示给你。右键点击结果并选择 **检查**。
- en: 'You’ll notice that your random string is placed inside an **img src** attribute,
    as shown in *Figure 9**.1*:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到你的随机字符串被放置在 **img src** 属性中，如 *图 9.1* 所示：
- en: '![Figure 9.1 – Inspect search results](image/Figure_9.1_B18829.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 检查搜索结果](image/Figure_9.1_B18829.jpg)'
- en: Figure 9.1 – Inspect search results
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 检查搜索结果
- en: 'Within the search bar, input a malicious **img** attribute, such as the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏内，输入一个恶意的 **img** 属性，例如以下内容：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This HTML JavaScript will then be executed by the browser to create an alert
    popup displaying the text, **2**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 HTML JavaScript 代码将被浏览器执行，创建一个弹出警告显示文本 **2**：
- en: '![Figure 9.2 – Exploited DOM XSS payload](image/Figure_9.2_B18829.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 被利用的 DOM XSS 有效载荷](image/Figure_9.2_B18829.jpg)'
- en: Figure 9.2 – Exploited DOM XSS payload
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 被利用的 DOM XSS 有效载荷
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The DOM is a programming interface for online content that enables applications
    to alter the document’s structure, design, and content that represents the web
    page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 是一个用于在线内容的编程接口，它使应用程序能够更改文档的结构、设计和内容，这些内容代表了网页。
- en: 'DOM-based XSS flaws often appear when any JavaScript property accepts data
    input from one of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 DOM 的 XSS 漏洞通常出现在以下任何 JavaScript 属性接受数据输入时：
- en: A **source** (**location.search**) that an attacker can control
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **来源** (**location.search**)，攻击者可以控制。
- en: A URL (**document.referrer**)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 URL (**document.referrer**)
- en: A user’s cookies (**document.cookie**)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的 cookies (**document.cookie**)
- en: A **sink** (**eval(), document.body.innerHTML**) that accepts harmful JavaScript
    functions or DOM objects
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **接收点** (**eval(), document.body.innerHTML**)，它接受有害的 JavaScript 函数或 DOM 对象。
- en: Any of these could permit dynamic code execution leading to exploitation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的任何一个都可能允许动态代码执行，导致被利用。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Several data sources inside the DOM are vulnerable to XSS attacks, as shown
    in the following list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 中的多个数据源容易受到 XSS 攻击，如下所示：
- en: '**Input fields**: For example, text boxes and form fields can be vulnerable
    to XSS attacks if the user’s input is not properly sanitized before being shown
    on the website.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入字段**：例如，文本框和表单字段如果用户的输入在展示到网站上之前没有经过适当清理，可能会受到 XSS 攻击的威胁。'
- en: '**Query strings**: Where attackers can inject malicious code into a web page
    using the query string of a URL. This might happen if the program fails to verify
    or sanitize the query string before presenting it on the page.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询字符串**：攻击者可以利用 URL 的查询字符串向网页注入恶意代码。如果程序在展示页面之前未能验证或清理查询字符串，就可能发生这种情况。'
- en: '**Cookies**: If they are not adequately encrypted or include unsanitized user
    input, cookies might be vulnerable to XSS attacks.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookies**：如果它们没有被适当加密或包含未经清理的用户输入，cookies 可能会受到 XSS 攻击的威胁。'
- en: '**Document properties**: The title and URL of a document might be vulnerable
    to XSS attacks if they are not properly sanitized before being shown on the page.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档属性**：如果文档的标题和 URL 在展示之前没有被正确清理，它们可能会受到 XSS 攻击的威胁。'
- en: '**JavaScript variables**: If they include unsanitized user input, JavaScript
    variables might be vulnerable to XSS attacks.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 变量**：如果它们包含未经清理的用户输入，JavaScript 变量可能会受到 XSS 攻击的威胁。'
- en: '**HTML attributes**: HTML attributes containing unsanitized user input, such
    as the **src** attribute of an **image** tag, might be vulnerable to XSS attacks.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML 属性**：包含未经清理的用户输入的 HTML 属性，如 **image** 标签的 **src** 属性，可能会受到 XSS 攻击的威胁。'
- en: 'jQuery is a popular JavaScript library commonly used to manipulate the DOM.
    Several jQuery functions can potentially lead to DOM-based XSS vulnerabilities
    if they are used improperly, as listed here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个常用的JavaScript库，通常用于操作DOM。如果不正确使用，多个jQuery函数可能会导致基于DOM的XSS漏洞，如此处所列。
- en: '**html()**: This function sets the HTML content of an element. If it is used
    to set the HTML content of an element to unsanitized user input, it can potentially
    lead to a DOM XSS vulnerability.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**html()**：此函数设置元素的HTML内容。如果用于将元素的HTML内容设置为未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: '**append()**: This function inserts content at the end of an element. If it
    is used to insert unsanitized user input at the end of an element, it can potentially
    lead to a DOM XSS vulnerability.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**append()**：此函数将在元素的末尾插入内容。如果用于在元素末尾插入未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: '**prepend()**: This function inserts content at the beginning of an element.
    If it is used to insert unsanitized user input at the beginning of an element,
    it can potentially lead to a DOM XSS vulnerability.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**prepend()**：此函数将在元素的开头插入内容。如果用于在元素开头插入未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: '**before()**: This function inserts content before an element. If it is used
    to insert unsanitized user input before an element, it can potentially lead to
    a DOM XSS vulnerability.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**before()**：此函数将在一个元素之前插入内容。如果用于在元素之前插入未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: '**after()**: This function inserts content after an element. If it is used
    to insert unsanitized user input after an element, it can potentially lead to
    a DOM XSS vulnerability.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**after()**：此函数将在元素之后插入内容。如果用于在元素之后插入未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: '**text()**: This function sets the text content of an element. If it is used
    to set the text content of an element to unsanitized user input, it can potentially
    lead to a DOM XSS vulnerability.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text()**：此函数设置元素的文本内容。如果用于将元素的文本内容设置为未经清理的用户输入，可能会导致DOM XSS漏洞。'
- en: It is important for web developers to properly sanitize all user input before
    coding with any of these functions, as well as **add()**, **animate()**, **insertAfter()**,
    **insertBefore()**, **replaceAll()**, **replaceWith()**, **wrap()**, **wrapInner()**,
    **wrapAll()**, **has()**, **constructor()**, **init()**, **index()**, **jQuery.parseHTML()**,
    and **$.parseHTML()**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页开发者来说，在使用任何这些函数进行编码之前，正确地清理所有用户输入是非常重要的，包括**add()**、**animate()**、**insertAfter()**、**insertBefore()**、**replaceAll()**、**replaceWith()**、**wrap()**、**wrapInner()**、**wrapAll()**、**has()**、**constructor()**、**init()**、**index()**、**jQuery.parseHTML()**和**$.parseHTML()**。
- en: 'For other payloads, visit the following GitHub pages:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他载荷，请访问以下GitHub页面：
- en: '*PayloadsAllTheThings*: [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PayloadsAllTheThings*：[https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)'
- en: '*SecLists*: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SecLists*：[https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/XSS)'
- en: '*XSS Payload* *List*: [https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XSS Payload* *List*：[https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)'
- en: Important note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If downloading/cloning any of the repositories, ensure you have the right to
    install them as some lists, such as SecLists contain malicious payloads. If installed
    on a work laptop, you will likely have an endpoint detection and response solution
    or other security tool flag you for having malicious content, and someone from
    IT may be asking you why it’s on your workstation. Avoid getting in trouble.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载/克隆任何仓库，请确保你有安装它们的权限，因为某些列表（如SecLists）包含恶意载荷。如果在工作笔记本上安装，可能会触发端点检测和响应解决方案或其他安全工具，标记你有恶意内容，IT人员可能会问你为什么它在你的工作站上。避免惹上麻烦。
- en: Testing for JavaScript execution
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试JavaScript执行
- en: JavaScript execution is the ability to inject and execute JavaScript in a website
    even if the website has some kind of protection, such as encoding certain characters.
    For many attackers, simple encoding of characters is not always a challenge; they
    find a way to bypass this encoding by creating a more complicated payload that
    is converted by the backend server as JavaScript and is allowed to run on the
    website.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 执行是指即使网站有某种保护措施（例如对某些字符进行编码），也能在网站中注入并执行 JavaScript。对于许多攻击者来说，简单的字符编码并不总是一个挑战；他们通过创建更复杂的负载，绕过该编码方式，让后端服务器将其转换为
    JavaScript，并允许其在网站上执行。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验室需要一个 PortSwigger Academy 账号以及 ZAP 来拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we are going to bypass an encoding mechanism to deliver our
    payload. You’ll see that we can inject JavaScript into the page and activate the
    payload because we’ll discover a way to get around the encoding method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将绕过编码机制来传递我们的负载。你将看到我们如何向页面注入 JavaScript 并激活负载，因为我们会发现绕过编码方法的途径。
- en: 'Take the following steps to get started:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded)).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器通过 ZAP 代理访问 URL，并登录 PortSwigger Academy 网站启动实验室（[https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded)）。
- en: 'In the application, enter any string within the **Search** field, as shown
    in *Figure 9**.3*, and then click on **Search**:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中，在 **Search** 字段中输入任何字符串，如 *图 9.3* 所示，然后点击 **Search**：
- en: '![Figure 9.3 – The web app search field](image/Figure_9.3_B18829.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – Web 应用的搜索字段](image/Figure_9.3_B18829.jpg)'
- en: Figure 9.3 – The web app search field
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Web 应用的搜索字段
- en: 'Next, go into ZAP and look at the **Sites** window. Look for the lab URL and
    click on it, as shown in *Figure 9**.4*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入 ZAP 并查看 **Sites** 窗口。查找实验室 URL 并点击，如 *图 9.4* 所示：
- en: '![Figure 9.4 – The Sites window](image/Figure_9.4_B18829.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Sites 窗口](image/Figure_9.4_B18829.jpg)'
- en: Figure 9.4 – The Sites window
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Sites 窗口
- en: After you have selected the URL path, right-click on the drop-down menu and
    select **Open/Resend with** **Request Editor**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择了 URL 路径后，右键单击下拉菜单并选择 **Open/Resend with** **Request Editor**。
- en: 'Look for the **search=** field in the URL (see Figure 9.5):'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 URL 中的 **search=** 字段（见图 9.5）：
- en: '![Figure 9.5 – The search= field in Manual Request Editor](image/Figure_9.5_B18829.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – Manual Request Editor 中的 search= 字段](image/Figure_9.5_B18829.jpg)'
- en: Figure 9.5 – The search= field in Manual Request Editor
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Manual Request Editor 中的 search= 字段
- en: 'Edit the **search=** field to set the payload to **`-alert(1)-`**, as shown
    in *Figure 9**.6*, and press **Send** to forward the request:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **search=** 字段，将负载设置为 **`-alert(1)-`**，如 *图 9.6* 所示，然后按 **Send** 发送请求：
- en: '![Figure 9.6 – Set the payload in the search= field](image/Figure_9.6_B18829.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 在 search= 字段中设置负载](image/Figure_9.6_B18829.jpg)'
- en: Figure 9.6 – Set the payload in the search= field
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 在 search= 字段中设置负载
- en: 'Once you receive the response in **Manual Request Editor**, scroll down to
    where the code is returned within the website page, as shown in *Figure 9**.7*.
    As you will notice, the payload is not inside single quotes, but the **alert(1)**
    value is sent to the **searchTerms** object, which triggers the XSS payload in
    the browser:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在 **Manual Request Editor** 中收到响应，向下滚动到页面中返回代码的位置，如 *图 9.7* 所示。你会注意到，负载并不在单引号内，而是
    **alert(1)** 的值被发送到 **searchTerms** 对象，这在浏览器中触发了 XSS 负载：
- en: '![Figure 9.7 – Successful code returned](image/Figure_9.7_B18829.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 成功返回的代码](image/Figure_9.7_B18829.jpg)'
- en: Figure 9.7 – Successful code returned
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 成功返回的代码
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: JavaScript execution vulnerabilities open the application to many common vulnerabilities,
    such as XSS and any payload created with JavaScript. JavaScript execution takes
    advantage of website vulnerabilities that allow a user control input to be returned
    to the website allowing the payload to be triggered there.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 执行漏洞使应用程序暴露于许多常见漏洞中，例如 XSS 以及任何由 JavaScript 创建的负载。JavaScript 执行利用了允许用户控制输入并返回到网站的漏洞，使得负载可以在那里被触发。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Attackers will use several techniques to help bypass protections. A common technique
    used is *URL encoding* aka *percent-encoding*, where certain characters in a URL
    or form field are replaced with their hexadecimal equivalent preceded by a percent
    symbol (**%**). For example, a very famous hacker character is the single quote
    (**'**), which is encoded as **%27**. Attackers use this technique to bypass security
    filters or to inject malicious code into a web application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者将使用多种技术来帮助绕过保护措施。一种常用的技术是*URL编码*，也称为*百分号编码*，其中URL或表单字段中的某些字符被替换为它们的十六进制等效值，并在前面加上百分号符号（**%**）。例如，一个非常著名的黑客字符是单引号（**'**），它被编码为**%27**。攻击者使用这种技术绕过安全过滤器或向Web应用程序注入恶意代码。
- en: When this fails, another technique to bypass security is known as *double encoding*.
    This is when encoded values such as **%27** are encoded again to become **%2527**.
    This helps bypass filters that only check for a single encoded value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当这失败时，另一种绕过安全性的技术称为*双重编码*。这就是将像**%27**这样的编码值再次编码，变成**%2527**。这有助于绕过只检查单一编码值的过滤器。
- en: The last technique is called *Unicode encoding*, which allows attackers to bypass
    blacklist-based input validation filters by using alternative encodings for potentially
    dangerous characters. In our same example, **%27** becomes **U+0025U+0027** or
    even further written as **U+0025U+0032U+0037**. These attacks can also become
    more complex by representing the single quote in its Unicode-encoded form as a
    full-width apostrophe (**U+FF07**) or encoded as **%EF%BC%87** in UTF-8 form.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种技术叫做*Unicode编码*，它允许攻击者通过使用潜在危险字符的替代编码来绕过基于黑名单的输入验证过滤器。在我们相同的例子中，**%27**变为**U+0025U+0027**，甚至可以进一步写为**U+0025U+0032U+0037**。这些攻击还可以通过将单引号表示为其Unicode编码形式的全角撇号（**U+FF07**）或用UTF-8形式编码为**%EF%BC%87**来变得更加复杂。
- en: When testing, it’s good to attempt various attacks to understand how the application
    is being protected and that fields are properly validating input or being parameterized
    in the case of SQL statements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，最好尝试多种攻击方法，以了解应用程序如何受到保护，以及字段是否正确验证输入或在SQL语句的情况下进行参数化。
- en: Testing for HTML injection
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试HTML注入
- en: HTML injection is when a user has access to an **input** parameter on the web
    application and can inject arbitrary HTML code into that web page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTML注入是指用户可以访问Web应用程序中的**输入**参数，并能将任意HTML代码注入到该网页中。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验需要一个PortSwigger Academy账户和ZAP来拦截从服务器到浏览器的请求和响应。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, you will utilize the search blog feature, which has a vulnerability
    to DOM-based XSS. The attack will make use of an **innerHTML** assignment that
    modifies a **div** element’s HTML contents using information from **location.search**.
    The result will be performing a cross-site scripting attack that calls the **alert**
    function to finish the lab.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将利用搜索博客功能，它存在DOM型XSS漏洞。攻击将利用**innerHTML**赋值来修改**div**元素的HTML内容，使用来自**location.search**的信息。结果将执行一个跨站脚本攻击，调用**alert**函数以完成实验。
- en: 'Perform the following steps to get started:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink)).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器通过ZAP代理访问URL并登录PortSwigger Academy网站以启动实验（[https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink](https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink)）。
- en: 'Within the lab application, type the following HTML payload into the **Search**
    field:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实验应用程序中，将以下HTML负载输入到**搜索**字段中：
- en: '[PRE1]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you click **Search**, the payload will execute, as shown in *Figure 9**.8*,
    completing the lab:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你点击**搜索**，负载将会执行，如*图9.8*所示，完成实验：
- en: '![Figure 9.8 – The alert payload](image/Figure_9.8_B18829.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 警报负载](image/Figure_9.8_B18829.jpg)'
- en: Figure 9.8 – The alert payload
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 警报负载
- en: Once successful you’ll see the alert payload and the PortSwigger Academy labs
    should congratulate you. Well done!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功，你将看到警报负载，PortSwigger Academy实验会祝贺你。做得好！
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This works because the **src** attribute’s value (**1**) is incorrect, thus
    throwing an error. But because of the error, the **alert()** function in the payload
    is called once the **onerror** event handler is activated. The following result
    occurs whenever the client attempts to load the web page that contains the malicious
    post request that executes the payload.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为**src**属性的值（**1**）不正确，从而抛出错误。但由于这个错误，一旦**onerror**事件处理程序被激活，负载中的**alert()**函数将被调用。每当客户端尝试加载包含执行负载的恶意POST请求的网页时，都会发生以下结果。
- en: When the output is not properly encoded and user input is not properly sanitized,
    this opens up the application to injection vulnerabilities, where an attacker
    is able to craft a malicious HTML page to a target that processes it. The victim’s
    browser will then parse and execute the entire crafted page since it will be unable
    to understand legitimate code, the good parts of the page, from the malicious
    HTML code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当输出未正确编码且用户输入未经过适当清理时，应用程序会暴露于注入漏洞，攻击者可以精心设计恶意 HTML 页面并将其发送给目标进行处理。受害者的浏览器将解析并执行整个构造的页面，因为它无法理解合法代码和恶意
    HTML 代码中的好部分。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'HTML injection works similarly to JavaScript execution as they both involve
    injecting malicious code into a web application and getting the browser to execute
    the code. HTML injection is the practice of injecting HTML code into a website,
    usually via changing input fields or URL parameters. The browser then renders
    the injected code, which may alter the website’s structure and design. Alternatively,
    JavaScript injection entails inserting JavaScript code. There are several ways
    an attacker can perform HTML injection, as seen here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 注入与 JavaScript 执行类似，都是通过将恶意代码注入到 Web 应用程序中，并让浏览器执行这些代码。HTML 注入是将 HTML 代码注入到网站中，通常通过更改输入字段或
    URL 参数来实现。浏览器随后会渲染这些注入的代码，这可能会改变网站的结构和设计。或者，JavaScript 注入是指插入 JavaScript 代码。攻击者可以通过多种方式执行
    HTML 注入，如下所示：
- en: '**Stealing user data**: When a web page loads, an attacker might inject JavaScript
    code to steal user information, such as login credentials. For instance, the attacker
    may insert code that generates a hidden form on the website and automatically
    populates it onto a server under their control, allowing them to receive the user’s
    information. For example, this could look like the following code:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窃取用户数据**：当网页加载时，攻击者可能会注入 JavaScript 代码来窃取用户信息，如登录凭证。例如，攻击者可能插入代码，生成一个隐藏的表单，并自动将其填充到他们控制的服务器上，从而让他们接收用户的信息。例如，代码可能如下所示：'
- en: '[PRE2]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Redirecting users**: An attacker could inject JavaScript code into a web
    page that redirects users to a malicious website. For example, the attacker could
    inject code that changes the value of the **location** property in the browser,
    causing the user to be redirected to a phishing site that mimics a proper site:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重定向用户**：攻击者可以将 JavaScript 代码注入网页，将用户重定向到恶意网站。例如，攻击者可以注入代码，改变浏览器中**location**属性的值，从而导致用户被重定向到一个模仿合法网站的钓鱼网站：'
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Phishing**: An attacker may inject JavaScript code into a web page to direct
    users to a malicious website. For instance, the attacker may include code that
    alters the location field’s value and directs the visitor to a phishing web page
    that perfectly resembles a legitimate website:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络钓鱼**：攻击者可能将 JavaScript 代码注入到网页中，将用户引导到恶意网站。例如，攻击者可能会包含代码，修改位置字段的值，并将访问者引导到一个看起来与合法网站完全相似的钓鱼网页：'
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**SQL injection**: An attacker could insert SQL queries into a web application,
    which could give them unauthorized access to the database and allow them to extract,
    change, or remove data. For instance, the attacker may insert code that returns
    all the information from the **users** table, such as **UNION SELECT *** **FROM
    users"**:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL 注入**：攻击者可能将 SQL 查询插入到 Web 应用程序中，这可能让他们未经授权访问数据库，并允许他们提取、修改或删除数据。例如，攻击者可能会插入代码，返回**users**表中的所有信息，例如**UNION
    SELECT *** **FROM users"**：'
- en: '[PRE29]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Testing for client-side URL redirect
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端 URL 重定向
- en: URL redirect attacks (open redirection) occur when applications allow untrusted
    user input where an attacker serves a user a hyperlink. This hyperlink then sends
    them to an external URL that’s different from the intended web page the user was
    attempting to access. In layman’s terms, it’s when an attacker sends a user from
    the current page to a new URL.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: URL 重定向攻击（开放重定向）发生在应用程序允许不受信任的用户输入的情况下，攻击者向用户提供一个超链接。然后，这个超链接会将他们发送到一个与用户试图访问的目标网页不同的外部
    URL。通俗地说，当攻击者将用户从当前页面发送到一个新的 URL 时，就会发生这种情况。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验需要一个 PortSwigger Academy 账户和 ZAP 来拦截服务器发送到浏览器的请求和响应。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, the lab uses **open authorization** (**OAuth**) services to
    authenticate the fake social media account. You, the attacker, will exploit a
    misconfiguration in OAuth to steal authorization tokens linked to another user’s
    account to gain access and remove a user, Carlos:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，实验使用**开放授权**（**OAuth**）服务来验证虚假社交媒体账户。你，作为攻击者，将利用 OAuth 中的配置错误来窃取与另一个用户账户相关的授权令牌，以获取访问权限并移除用户
    Carlos：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri](https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri)).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器代理到 ZAP 的 URL 中导航，并登录到 PortSwigger Academy 网站以启动实验（[https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri](https://portswigger.net/web-security/oauth/lab-oauth-account-hijacking-via-redirect-uri)）。
- en: 'First, ensure you are capturing requests in ZAP. Then click on **My account**
    and use the credentials provided to log in via OAuth. A message on the web page
    will indicate that you are being redirected. In addition, in the URL, you will
    see that you are using OAuth (shown in *Figure 9**.9*):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确保在 ZAP 中捕获请求。然后点击**我的账户**，使用提供的凭据通过 OAuth 登录。网页上会显示一个消息指示你正在被重定向。此外，在 URL
    中，你会看到你正在使用 OAuth（如*图 9**.9*所示）：
- en: '![Figure 9.9 – The OAuth URL](image/Figure_9.9_B18829.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – OAuth URL](image/Figure_9.9_B18829.jpg)'
- en: Figure 9.9 – The OAuth URL
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – OAuth URL
- en: Log out by clicking **My Account** and then log back in again.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**我的账户**注销，然后再次登录。
- en: You’ll notice you are logged in immediately. This is because there is still
    an active session with the OAuth service; therefore, you don’t need to provide
    a username and password to re-authenticate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你立即登录了。这是因为仍然存在与 OAuth 服务的活动会话；因此，你无需提供用户名和密码进行重新验证。
- en: 'In ZAP, look in the **History** tab, where the most recent OAuth request can
    be found. Begin by typing **GET /auth?client_id=[...]**. You are immediately redirected
    to **redirect_uri** after this request has been sent together with the authorization
    code in the request message (see *Figure 9**.10*):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ZAP 中，查看**历史**选项卡，可以找到最近的 OAuth 请求。首先输入**GET /auth?client_id=[...]**。在发送此请求后，立即被重定向到**redirect_uri**，并在请求消息中连同授权码一起发送（见*图
    9**.10*）：
- en: '![Figure 9.10 – Authorization request](image/Figure_9.10_B18829.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 授权请求](image/Figure_9.10_B18829.jpg)'
- en: Figure 9.10 – Authorization request
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 授权请求
- en: Right-click and open this **/auth?client_id=** request in **Manual** **Request
    Editor**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并在**手动** **请求编辑器**中打开此**/auth?client_id=**请求。
- en: 'In this request (see *Figure 9**.11*), you can send any random value as the
    **redirect_uri** without causing errors. This is the parameter that you’ll use
    to create the malicious redirect URL:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个请求中（见*图 9**.11*），你可以发送任意随机值作为**redirect_uri**而不会引起错误。这是你将用来创建恶意重定向 URL 的参数：
- en: '![Figure 9.11 – The redirect_uri manipulation](image/Figure_9.11_B18829.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 重定向 URI 操纵](image/Figure_9.11_B18829.jpg)'
- en: Figure 9.11 – The redirect_uri manipulation
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 重定向 URI 操纵
- en: Next, input the exploit server **Uniform Resource Identifier** (**URI**) as
    **redirect_uri**. Then right-click and copy the request URL. Enter this URL into
    the browser address bar, and press enter to send the request. You’ll see the web
    page open with the default message that was in the body on the exploit server
    page; *Hello world!*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将利用漏洞服务器的**统一资源标识符**（**URI**）作为**redirect_uri**。然后右键单击并复制请求 URL。将此 URL 输入到浏览器地址栏中，然后按回车键发送请求。你会看到网页打开，并显示在漏洞服务器页面上的默认消息；*Hello
    world!*。
- en: 'Look back inside the exploit server’s access log, and you’ll see that there’s
    a log entry with your authorization code. This lets you know that the authorization
    code is leaking to an external domain (see *Figure 9**.12*):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到漏洞服务器的访问日志，你会看到有一条日志记录了你的授权码。这表明授权码泄露到外部域（见*图 9.12*）：
- en: '![Figure 9.12 – The exploit server access log with the authorization code](image/Figure_9.12_B18829.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 带有授权码的漏洞服务器访问日志](image/Figure_9.12_B18829.jpg)'
- en: Figure 9.12 – The exploit server access log with the authorization code
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 带有授权码的漏洞服务器访问日志
- en: 'Now hold on to that same URL but go back to the main exploit server page and
    paste this into an iframe (see the following code snippet) of the body: **OAUTH-ID**,
    **CLIENT-ID** (the OAuth ID from when you first logged in), and **EXPLOIT-ID**
    (the ID of the exploit server) are correct:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保留该URL，但返回到主漏洞服务器页面，并将其粘贴到body的iframe中（请参阅以下代码片段），确保**OAUTH-ID**、**CLIENT-ID**（你第一次登录时的OAuth
    ID）和**EXPLOIT-ID**（漏洞服务器的ID）是正确的：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, click **Store** at the bottom to upload the exploit. Once this is done,
    *do not* click **View exploit** but copy the entire URL from **src" "**, open
    a new browser tab, paste the URL into the address bar, and navigate to it. Again,
    as before, this will open an iframe that shows the exploit server web page inside.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击底部的**Store**按钮上传漏洞。一旦完成，*不要*点击**View exploit**，而是从**src" "**复制整个网址，打开一个新的浏览器标签页，将网址粘贴到地址栏并访问它。如前所述，这将打开一个iframe，展示漏洞服务器网页。
- en: 'Close the browser tab and go back to the exploit server and check the **Access
    log**. You’ll see the log shows a **GET /?code=** request with a newly generated
    code, as seen in *Figure 9**.13*. This is your code but it will allow you to understand
    whether the exploit is working:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器标签页，返回漏洞服务器并检查**Access log**。你将看到日志显示一个**GET /?code=**请求，带有新生成的代码，如*图 9.13*所示。这是你的代码，但它能让你判断漏洞是否有效：
- en: '![Figure 9.13 – The access logs of the iframe payload](image/Figure_9.13_B18829.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – iframe负载的访问日志](image/Figure_9.13_B18829.jpg)'
- en: Figure 9.13 – The access logs of the iframe payload
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – iframe负载的访问日志
- en: 'Deliver the same exploit to the victim, then go back to the **Access Log**
    and look for a newly generated code from a different IP address. Copy the victim’s
    code from the result in the log:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的漏洞交付给受害者，然后返回**Access Log**，查找来自不同IP地址的新生成代码。从日志中的结果复制受害者的代码：
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If there’s a dash (**-**) at the end of the code string, be sure to copy this
    dash along with the entire code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码字符串的末尾有一个破折号（**-**），请确保将这个破折号和整个代码一起复制。
- en: '![Figure 9.14 – The victim payload response](image/Figure_9.14_B18829.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 受害者负载响应](image/Figure_9.14_B18829.jpg)'
- en: Figure 9.14 – The victim payload response
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 受害者负载响应
- en: '*Log out* of the entire website first and with the new captured code, craft
    a new **oauth-callback** URL and paste it into the address bar of the browser
    and navigate to it:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*先登出*整个网站，使用新捕获的代码，构造一个新的**oauth-callback** URL并将其粘贴到浏览器的地址栏中访问：'
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OAuth will auto-complete authentication and log you in as the administrator.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth会自动完成身份验证并将你登录为管理员。
- en: Go to the **Admin** panel.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Admin**面板。
- en: Delete Carlos.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除Carlos。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The OAuth 2.0 framework is a very common tool used for authentication, yet it
    is common for vulnerabilities to occur due to misconfigurations. One essential
    component of the OAuth flow is redirect URLs. The authorization server will direct
    the user back to the application once the user has successfully authorized a certain
    application. It is essential that the service does not reroute the customer to
    random places since the redirect URL includes crucial information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0框架是一个常见的身份验证工具，但由于配置错误，常常会出现漏洞。OAuth流程的一个重要组件是重定向URL。授权服务器将在用户成功授权某个应用后将用户引导回应用。至关重要的是，服务不能将客户重定向到随机位置，因为重定向URL包含关键信息。
- en: OAuth providers are a prime target for phishing attacks since they fail to validate
    **redirect_uri** when delivering the **access_token** through the browser redirect.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth提供者是网络钓鱼攻击的主要目标，因为它们在通过浏览器重定向传递**access_token**时未验证**redirect_uri**。
- en: In this attack, the threat actor provides the target with a URL to a trusted
    authentication portal, and by using this authentication portal, the malicious
    user can send the victim’s secret **access_token** to their controlled web server,
    which allows the attacker access to unintended resources.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次攻击中，威胁行为者向目标提供一个指向受信任认证门户的 URL，利用该认证门户，恶意用户可以将受害者的**access_token**发送到他们控制的
    web 服务器，从而允许攻击者访问未授权的资源。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Users can offer access to their resources (i.e., data or an API) to a third-party
    application using the OAuth protocol without disclosing their login information.
    The following three key elements generally make up the OAuth authentication process:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过 OAuth 协议向第三方应用程序提供资源访问权限（即数据或 API），而无需透露他们的登录信息。OAuth 身份验证过程通常由以下三个关键元素组成：
- en: '**The client application**: This is a third-party program that seeks to gain
    access to the user’s resources. It must be registered with the OAuth provider
    and be equipped with a client ID and secret.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端应用程序**：这是一个第三方程序，旨在获取对用户资源的访问权限。它必须在 OAuth 提供者处注册，并配备客户端 ID 和密钥。'
- en: '**The authorization server**: This is the server responsible for managing the
    user’s resources and authenticating the user. It is normally managed by the OAuth
    provider (such as Google, Facebook, Twitter, Linkedin, Windows Live, etc.) and
    is in charge of providing client application access.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这是负责管理用户资源并进行用户身份验证的服务器。通常由 OAuth 提供者（如 Google、Facebook、Twitter、Linkedin、Windows
    Live 等）管理，负责为客户端应用程序提供访问权限。'
- en: '**The resource owner**: This is the user who has access to the resources that
    the client application wishes to use. The resource owner must provide the client
    application access to their resources.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源拥有者**：这是拥有客户端应用程序希望使用的资源的用户。资源拥有者必须授权客户端应用程序访问他们的资源。'
- en: The client application redirects the user to the authorization server’s login
    page during the OAuth authentication procedure. After that, the user inputs their
    login information and gives access to the client application. The authorization
    server then refers the user back to the client application, providing the client
    with an access token to access the user’s resources.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OAuth 身份验证过程中，客户端应用程序将用户重定向到授权服务器的登录页面。之后，用户输入登录信息并授权客户端应用程序。授权服务器随后将用户重定向回客户端应用程序，提供一个访问令牌，允许客户端访问用户的资源。
- en: Important note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Additional components, such as the resource server, which stores the user’s
    resources, and the token endpoint, which gives the access token, may be included
    in some implementations of OAuth.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 OAuth 实现中，可能还包括额外的组件，例如存储用户资源的资源服务器，以及提供访问令牌的令牌端点。
- en: After a user grants access to a client application, an attacker can send them
    to a malicious website using an *OAuth redirection attack* (also called an *open
    redirection attack*). This can be accomplished by fooling the user into clicking
    on a link containing a malicious redirect URI or changing the redirect URI that
    the client application uses. The attacker can take the access token and use it
    to access the user’s resources once the user has been forcibly redirected to the
    malicious website.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户授权客户端应用程序后，攻击者可以通过 *OAuth 重定向攻击*（也称为 *开放重定向攻击*）将用户引导到恶意网站。这可以通过诱使用户点击包含恶意重定向
    URI 的链接或更改客户端应用程序使用的重定向 URI 来实现。一旦用户被强制重定向到恶意网站，攻击者就可以获取访问令牌并利用它访问用户的资源。
- en: 'Here is a simplified example of an attacker’s URL string that could be used
    to execute this type of attack:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的示例，展示了攻击者可能用来执行这种攻击的 URL 字符串：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The redirect URI of the client application, the authorization endpoint of the
    legal OAuth provider, and a **query** parameter pointing to the attacker’s website
    are all included in this example’s URL string. The attacker’s website will serve
    as the redirect URI when the victim clicks the link, which causes their browser
    to submit a request with this URL string to the authentic OAuth provider’s website.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的 URL 字符串中包含了客户端应用程序的重定向 URI、合法 OAuth 提供者的授权端点，以及一个指向攻击者网站的 **query** 参数。受害者点击链接后，攻击者的网站将充当重定向
    URI，导致浏览器向合法的 OAuth 提供者网站提交带有该 URL 字符串的请求。
- en: Testing cross-origin resource sharing
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试跨域资源共享
- en: To understand **cross-origin resource sharing** (**CORS**) vulnerability, first,
    you have to understand the same-origin policy. The same-origin policy was created
    to restrict the ability of websites to access resources that are not from the
    source domain. Although for some websites the same-origin policy is a problem,
    many websites nowadays interact with subdomains or third-party websites that need
    cross-origin exceptions. CORS was created to resolve this issue.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 **跨域资源共享** (**CORS**) 漏洞，首先需要理解同源策略。同源策略的目的是限制网站访问来自不同源域的资源。虽然对于某些网站，同源策略是一个问题，但如今许多网站与子域或第三方网站进行交互，需要跨域例外。CORS
    就是为了解决这个问题而创建的。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser. The login credentials for the lab
    web application are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验要求拥有 PortSwigger Academy 账户和 ZAP，以拦截来自服务器到浏览器的请求和响应。实验网页应用的登录凭证如下：
- en: '**Username**: **wiener**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名**: **wiener**'
- en: '**Password**: **peter**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**: **peter**'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, the lab introduces a vulnerable website with an insecure CORS
    configuration to trust all origins. To solve this, we’ll form a malicious JavaScript
    function using CORS to retrieve an administrator’s API key and then upload the
    code to the server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，实验引入了一个存在安全隐患的网站，它的 CORS 配置不安全，信任所有来源。为了解决这个问题，我们将使用 CORS 构建一个恶意的 JavaScript
    函数，以获取管理员的 API 密钥，然后将代码上传到服务器。
- en: 'Take the following steps to get started:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始操作：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器代理至 ZAP 的 URL，登录 PortSwigger Academy 网站并启动实验
- en: ([https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack](https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack](https://portswigger.net/web-security/cors/lab-basic-origin-reflection-attack)).
- en: Fire up ZAP and ensure you use either the manual explorer and launch the Firefox
    browser or have a browser extension tool enabled for proxying the page.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 ZAP，并确保你使用手动探索器并启动 Firefox 浏览器，或者启用浏览器扩展工具以代理该页面。
- en: Once the lab loads and you reach the homepage of the application, click **My
    Account**. Use the credentials provided to log in and access the **Account** page.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实验加载并进入应用程序的主页，点击 **我的账户**。使用提供的凭证登录并访问 **账户** 页面。
- en: 'Review the history and look at the response header (see *Figure 9**.15*), which
    will have your key that was retrieved by an AJAX request to **/accountDetails**.
    Within the same response, you will see the **Access-Control-Allow-Credentials**
    header. This lets us know it may be CORS:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看历史记录并查看响应头（参见 *图 9.15*），其中会显示你通过 AJAX 请求 **/accountDetails** 获取的密钥。在同一响应中，你将看到
    **Access-Control-Allow-Credentials** 头部。这表明可能存在 CORS 问题：
- en: '![Figure 9.15 – The API key response header](image/Figure_9.15_B18829.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – API 密钥响应头](image/Figure_9.15_B18829.jpg)'
- en: Figure 9.15 – The API key response header
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – API 密钥响应头
- en: 'Next, right-click the request and open it in **Manual Request Editor**. Then
    resubmit the request with the added header (see *Figure 9**.16*):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键点击请求并在 **手动请求编辑器** 中打开它。然后使用添加的头部重新提交请求（参见 *图 9.16*）：
- en: '[PRE36]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we see the **origin** header where we inputted our domain reflected back
    to us:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 **origin** 头部，输入的域名被反射回来了：
- en: '![Figure 9.16 – Added origin header](image/Figure_9.16_B18829.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 添加的来源头部](image/Figure_9.16_B18829.jpg)'
- en: Figure 9.16 – Added origin header
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 添加的来源头部
- en: 'You’ll see that the URL we entered as **origin** is reflected back in the **Access-Control-Allow-Origin**
    header:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到我们输入的 **origin** URL 在 **Access-Control-Allow-Origin** 头中被反射回来：
- en: '![Figure 9.17 – The response header showing origin](image/Figure_9.17_B18829.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 显示来源的响应头](image/Figure_9.17_B18829.jpg)'
- en: Figure 9.17 – The response header showing origin
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 显示来源的响应头
- en: 'In the lab at the top of the browser, click **Go to exploit server** and enter
    the following payload HTML script. Be sure to replace **<random-string>** with
    your unique lab URL that generates when you first start the lab:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器顶部的实验中，点击 **Go to exploit server** 并输入以下有效负载 HTML 脚本。确保将 **<random-string>**
    替换为首次启动实验时生成的唯一实验 URL：
- en: '[PRE37]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In *Figure 9**.18*, we see the lab header, which shows the **Go to exploit
    server** button and the **Submit solution** button to solve the lab:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 9.18* 中，我们看到实验室头部，显示了 **Go to exploit server** 按钮和 **Submit solution**
    按钮，用于解决实验：
- en: '![Figure 9.18 – Link to the exploit server](image/Figure_9.18_B18829.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 链接到漏洞利用服务器](image/Figure_9.18_B18829.jpg)'
- en: Figure 9.18 – Link to the exploit server
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 链接到漏洞利用服务器
- en: 'Click **View exploit** at the bottom of the page. This will help ensure that
    the exploit works and that you have landed on the log page with your API key in
    the URL, as shown in *Figure 9**.20*:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的**查看漏洞利用**。这将有助于确保漏洞利用有效，并且你已经到达了带有 API 密钥的日志页面，如*图 9.20*所示：
- en: '![Figure 9.19 – View exploit logs](image/Figure_9.19_B18829.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 查看漏洞利用日志](image/Figure_9.19_B18829.jpg)'
- en: Figure 9.19 – View exploit logs
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 查看漏洞利用日志
- en: 'Go back to the exploit server and first click **Store**, then click **Deliver
    exploit to victim** to send the exploit:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回漏洞利用服务器，首先点击**存储**，然后点击**向受害者发送漏洞利用**以发送漏洞利用：
- en: '![Figure 9.20 – The Deliver exploit to victim button](image/Figure_9.20_B18829.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 向受害者发送漏洞利用按钮](image/Figure_9.20_B18829.jpg)'
- en: Figure 9.20 – The Deliver exploit to victim button
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 向受害者发送漏洞利用按钮
- en: 'After sending the exploit, click **Access log** to retrieve the administrator’s
    API key from the **/log?key=** log entry. For an easier way of searching, look
    at the IP address in the left column:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送漏洞利用后，点击**访问日志**，从**/log?key=**日志条目中提取管理员的 API 密钥。为了便于搜索，可以查看左侧列中的 IP 地址：
- en: '![Figure 9.21 – The Admin’s API key](image/Figure_9.21_B18829.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 管理员的 API 密钥](image/Figure_9.21_B18829.jpg)'
- en: Figure 9.21 – The Admin’s API key
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 管理员的 API 密钥
- en: To complete, use the **Submit solution** button that’s at the top of the lab
    web page. It can be seen from either the main lab page or when osn the exploit
    server page.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成，请使用位于实验网页顶部的**提交解决方案**按钮。无论是从主实验页面还是从漏洞利用服务器页面，都可以看到该按钮。
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'CORS allows websites to request resources from other websites by utilizing
    HTTP headers to set the allowed origins. The headers used by CORS are **Access-Control-Allow-Origin**
    and **Access-Control-Allow-Credentials**. **Access-Control-Allow-Origin** has
    three values, which are: a wild card **(*)** that allows all origins, **<origin>**
    that specifies only one origin, and **null**, which is used for multiple reasons,
    some of them are when the website is receiving cross-origin redirects or using
    **file: protocol**. The **Access-Control-Allow-Credentials** header only takes
    a **true** value and is used to send authentication information.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 允许网站通过利用 HTTP 头部设置允许的来源，从其他网站请求资源。CORS 使用的头部是**Access-Control-Allow-Origin**和**Access-Control-Allow-Credentials**。**Access-Control-Allow-Origin**有三个值：一个是通配符**(*)**，表示允许所有来源，一个是**<origin>**，表示仅允许指定的来源，另一个是**null**，用于多种情况，其中之一是在网站接收跨来源重定向或使用**file:协议**时。**Access-Control-Allow-Credentials**头部仅接受**true**值，用于发送认证信息。
- en: This vulnerability arises as a result of misconfiguration. Misconfiguration
    could be but is not limited to, allowing all origins or accepting all origins
    ending in a specific string, such as **zapproxy.com**. An attacker could register
    **attackersitezapproxy.com**, and this origin will be accepted.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种漏洞源于配置错误。配置错误可能包括但不限于允许所有来源或接受以特定字符串结尾的所有来源，如**zapproxy.com**。攻击者可能会注册**attackersitezapproxy.com**，并且这个来源将被接受。
- en: The impact of CORS vulnerabilities depends on which header is set and the information
    that the website provides. If the **Access-Control-Allow-Credentials** is set
    to **true**, an attacker could extract authentication information from the website.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 漏洞的影响取决于设置的头部和网站提供的信息。如果**Access-Control-Allow-Credentials**设置为**true**，攻击者可以从网站中提取认证信息。
- en: There's more...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'CORS attacks can be used with other forms of attacks to exploit additional
    vulnerabilities in a targeted server. Here are some types of attacks that may
    be combined with CORS:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 攻击可以与其他形式的攻击结合使用，以利用目标服务器中的其他漏洞。以下是可能与 CORS 结合使用的一些攻击类型：
- en: '**XSS**: A CORS attack can be used by an attacker to circumvent the same-origin
    policy and inject malicious code into a website, allowing them to steal sensitive
    information from website visitors'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSS**：攻击者可以利用 CORS 攻击绕过同源策略，将恶意代码注入到网站中，从而盗取网站访问者的敏感信息'
- en: '**CSRF**: An attacker can employ a CORS attack to fool a server into believing
    that a request is coming from a trustworthy source, allowing them to undertake
    activities on behalf of a genuine user'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSRF**：攻击者可以利用 CORS 攻击欺骗服务器，使其相信请求来自可信来源，从而允许攻击者代表真实用户执行操作'
- en: '**Phishing**: An attacker can use a CORS attack to generate a bogus login page
    on a malicious website and then use the CORS attack to access the user’s personal
    information after their credentials are entered'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**钓鱼攻击**：攻击者可以利用 CORS 攻击在恶意网站上生成一个虚假的登录页面，然后通过 CORS 攻击在用户输入凭证后访问用户的个人信息。'
- en: An attacker often initiates these sorts of attacks by modifying the request
    headers to fool the server into thinking the request is coming from a trustworthy
    origin, generating phony login pages, or injecting malicious code. The attacker
    must also be able to steal the authentication tokens or obtain the sensitive data
    that is being exposed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者通常通过修改请求头发起这些攻击，欺骗服务器使其认为请求来自可信的来源，生成虚假的登录页面，或注入恶意代码。攻击者还必须能够窃取身份验证令牌或获取正在暴露的敏感数据。
- en: Testing WebSockets
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 WebSockets
- en: WebSockets are an ongoing, two-way channel of communication between a client
    and backend service, such as a database or an API service. WebSockets may transmit
    any number of protocols and offer server-to-client message delivery without polling
    (the process of one program or device repeatedly checking the status of other
    programs or devices).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 是客户端和后端服务（如数据库或 API 服务）之间持续的双向通信通道。WebSockets 可以传输任意数量的协议，并且提供服务器到客户端的消息传递，无需轮询（即一个程序或设备反复检查其他程序或设备的状态的过程）。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This lab requires a PortSwigger Academy account and ZAP to intercept requests
    and responses from the server to your browser.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验需要一个 PortSwigger Academy 账户和 ZAP，用于拦截从服务器到浏览器的请求和响应。
- en: Before starting the lab, within ZAP, go to **Tools**, **Options**, and scroll
    down to the **WebSockets** section. Here you must enable **Break on enabled ‘all
    request/response break buttons’**. Otherwise, you will not be able to capture
    the WebSocket request and manipulate it to complete this lab.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实验前，在 ZAP 中，进入 **工具**，**选项**，并向下滚动至 **WebSockets** 部分。在此，您必须启用 **在启用‘所有请求/响应断点按钮’时中断**。否则，您将无法捕获
    WebSocket 请求并进行操作以完成此实验。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: WebSockets are being used to implement the live chat feature in this online
    store.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 被用来实现这个在线商店中的实时聊天功能。
- en: In this recipe, a fictitious support representative, aka a bot, will read the
    chat message requests you send. While interpreting the responses, we’ll use a
    WebSocket message to create an **alert()** popup on the support agent’s browser.
    If successful, it will automatically complete the lab.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，一位虚拟的支持代表，也就是机器人，将读取您发送的聊天消息请求。在解读响应时，我们将使用 WebSocket 消息在支持代表的浏览器中创建一个
    **alert()** 弹出窗口。如果成功，它将自动完成实验。
- en: 'Take the following steps to get started:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: Navigate to the URL with the browser proxied to ZAP and log into the PortSwigger
    Academy website to launch the lab ([https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities](https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities)).
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器代理至 ZAP，导航至网址并登录 PortSwigger Academy 网站以启动实验室（[https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities](https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities)）。
- en: Within ZAP, enter the scoped URL into the manual explorer and launch the browser
    to open up Firefox. Click **Continue to** **your target**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ZAP 中，输入范围 URL 到手动浏览器并启动浏览器打开 Firefox。点击 **继续到** **您的目标**。
- en: In the upper right-hand corner of the web application, click **Live chat** and
    send a random chat message.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页应用的右上角，点击 **实时聊天** 并发送一条随机聊天消息。
- en: 'Go to the WebSockets **History** tab in ZAP, and look for the chat message
    that you previously sent in the original WebSocket message (see *Figure 9**.22*):'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ZAP 的 WebSockets **历史** 标签中，查找您之前在原始 WebSocket 消息中发送的聊天消息（参见 *图 9.22*）：
- en: '![Figure 9.22 – The WebSockets History tab](image/Figure_9.22_B18829.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – WebSockets 历史标签](image/Figure_9.22_B18829.jpg)'
- en: Figure 9.22 – The WebSockets History tab
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – WebSockets 历史标签
- en: 'Back within the application, send another new message, but this time containing
    a less-than character:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回应用中，发送另一条新消息，但这次包含一个小于符号：
- en: '[PRE47]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Look back in the ZAP WebSocket history to find the corresponding WebSocket
    message and observe that the less-than symbol has been converted to HTML-encoded
    by the client before sending, as in *Figure 9**.23*:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 ZAP WebSocket 历史记录中，找到相应的 WebSocket 消息，并观察到小于符号已经在客户端发送之前被转化为 HTML 编码，如 *图
    9.23* 所示：
- en: '![Figure 9.23 – HTML-encoded less-than character](image/Figure_9.23_B18829.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图9.23 – HTML编码的小于字符](image/Figure_9.23_B18829.jpg)'
- en: Figure 9.23 – HTML-encoded less-than character
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 – HTML编码的小于字符
- en: 'Again, send another chat message, but this time set a breakpoint, and while
    your message is in transit, manipulate the request to contain the following payload:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次发送另一条聊天消息，但这次设置一个断点，在消息传输过程中，操控请求使其包含以下载荷：
- en: '[PRE48]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Important note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the **Live Chat** feature of the web application stops working or the chat
    says **Disconnected**, open a new **Live Chat** to continue the recipe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网页应用程序的**实时聊天**功能停止工作或聊天显示**断开连接**，打开一个新的**实时聊天**继续该过程。
- en: 'The browser will trigger an alert, which will also happen on the support agent’s
    client side:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将触发警报，支持代理客户端也会发生此操作：
- en: '![Figure 9.24 – A JavaScript alert](image/Figure_9.24_B18829.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图9.24 – 一个JavaScript警报](image/Figure_9.24_B18829.jpg)'
- en: Figure 9.24 – A JavaScript alert
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 – 一个JavaScript警报
- en: 'In the first screenshot, you see the alert box pop up on the client side. Over
    in the chat message in *Figure 9**.25*, you see a blank HTML icon for the image
    tag. This is our malicious payload:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个截图中，你会看到警报框在客户端弹出。聊天消息在*图9.25*中显示时，图像标签的HTML图标为空白。这是我们的恶意载荷：
- en: '![Figure 9.25 – A successful attack shown in a chat](image/Figure_9.25_B18829.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图9.25 – 在聊天中展示的成功攻击](image/Figure_9.25_B18829.jpg)'
- en: Figure 9.25 – A successful attack shown in a chat
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – 在聊天中展示的成功攻击
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: According to RFC 6455, the WebSocket Protocol enables two-way communication
    between a client running erroneous code in an organized element and a remote host
    that has granted permission for communications from that code. This uses the origin-based
    security concept, widely utilized by online browsers. The protocol starts with
    a handshake and then layers the **Transmission Control Protocol** (**TCP**) with
    some simple message framing. This technology’s objective is to give browser-based
    applications that require two-way communication with servers a method of doing
    so without having to initiate several HTTP connections (that is, by utilizing
    **XMLHttpRequest** or **<iframe>s** and lengthy polling).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 6455，WebSocket协议允许客户端在运行错误代码的组织元素中与远程主机进行双向通信，前提是远程主机已允许来自该代码的通信。这使用了基于来源的安全概念，广泛应用于在线浏览器。该协议以握手开始，然后将**传输控制协议**（**TCP**）与一些简单的消息框架进行分层。该技术的目标是为需要与服务器进行双向通信的浏览器应用程序提供一种方法，而无需启动多个HTTP连接（即，利用**XMLHttpRequest**或**<iframe>**和长时间轮询）。
- en: Important note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some assaults may result in the loss of your connection, in which case you must
    create a new one.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一些攻击可能会导致你失去连接，这时你需要创建一个新的连接。
- en: 'Practically any web security flaw may occur in regard to WebSockets:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何与WebSocket相关的网页安全漏洞都有可能发生：
- en: Improper handling of user input when transferred to the server creates flaws
    such as SQL injection or **XML external entity** (**XXE**) injection
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入处理不当时传送到服务器会导致漏洞，如SQL注入或**XML外部实体**（**XXE**）注入
- en: Blind WebSocket vulnerabilities may need to be exploited through out-of-band
    (OAST) methods
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket的盲点漏洞可能需要通过带外（OAST）方法来利用
- en: XSS or other client-side vulnerabilities may result if attacker-controlled data
    is sent over WebSockets to other application users
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过WebSocket将攻击者控制的数据发送给其他应用程序用户，可能会导致XSS或其他客户端漏洞
- en: There's more...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When initializing your methodology before attacking a WebSocket, look at the
    JavaScript files or the page’s source code to discover the WebSocket endpoints.
    Look for the following in the JavaScript code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击WebSocket之前初始化你的方法时，查看JavaScript文件或页面源代码，查找WebSocket端点。在JavaScript代码中寻找以下内容：
- en: '**wss://**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wss://**'
- en: '**ws://**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ws://**'
- en: '**websocket**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**websocket**'
- en: A WebSocket URL will be formatted as **wss://example.com** (**wss://** for a
    **secure socket layer** (**SSL**) connection). Similar to **https://**, and **ws://**,
    which is like **http://**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket的URL格式将是**wss://example.com**（**wss://**用于**安全套接字层**（**SSL**）连接）。类似于**https://**，以及**ws://**，就像**http://**一样。
- en: Next, to determine whether the WebSocket endpoint is accepting connections from
    other origins within ZAP, examine the connections. Send a request from the **Manual
    Request Editor** with your origin specified in the **origin** header value. If
    the connection is successful, the server will reply with a status code **101**,
    and your requested origin will be mirrored *or* notated with a wildcard (*****)
    in the **origin** header of the response.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要确定WebSocket端点是否在ZAP中接受来自其他源的连接，请检查连接。通过**手动请求编辑器**发送请求，并在**origin**头中指定你的源。如果连接成功，服务器将回复状态码**101**，且你的请求源将被反映或在响应的**origin**头中以通配符（*****）表示。
- en: See also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*RFC6455: The WebSocket* *Protocol*: [https://www.rfc-editor.org/rfc/rfc6455](https://www.rfc-editor.org/rfc/rfc6455)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*RFC6455: WebSocket* *协议*: [https://www.rfc-editor.org/rfc/rfc6455](https://www.rfc-editor.org/rfc/rfc6455)'
