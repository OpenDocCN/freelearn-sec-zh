- en: Windows Privilege Escalation and Maintaining Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows权限提升和保持访问
- en: In this chapter, you will learn how, once you have exploited a system, you can
    elevate your privileges to system level access. You will also learn how to obtain
    information from a system even when an exploit does go wrong. There aren't any
    total failures; there is always something to learn even when things do go wrong.
    You will learn how to add persistence to your exploit to maintain future access
    to your victim's machine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习一旦利用了系统，如何将您的权限提升到系统级别访问。您还将学习即使攻击失败时如何从系统中获取信息。没有完全的失败；即使事情出错时，总是有东西可以学习。您将学习如何向您的攻击添加持久性，以保持对受害者机器的未来访问。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Windows privilege escalation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows权限提升
- en: MS16-032 Secondary Logon Handle Privilege Escalation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MS16-032次要登录句柄权限提升
- en: Windows Escalate Service Permissions Local Privilege Escalation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows提升服务权限本地权限提升
- en: Maintaining access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持访问
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need, for this chapter, a target Windows machine and a running instance
    of Kali.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要一个目标Windows机器和一个正在运行的Kali实例。
- en: Windows privilege escalation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows权限提升
- en: Privilege escalation is gaining a higher level of access than the account being
    used has been given. In hacker terms, this is called **rooting the box**. This
    comes from the UNIX/Linux world, where root is the administrator account. With
    this level of access, you own the box. In Windows systems, the administrator account
    has admin-level access and can do just about anything to the system. Still, in
    Windows, there is an even higher level of access, called system. With this account,
    you have full control over all levels of the system. This is the level of access
    that we want.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特权提升是获得比所使用的帐户被赋予的更高级别访问权限。在黑客术语中，这被称为**rooting the box**。这来自UNIX/Linux世界，其中root是管理员帐户。有了这个访问级别，你就拥有了这个系统。在Windows系统中，管理员帐户具有管理员级别的访问权限，并且可以对系统进行几乎任何操作。但是，在Windows中，还有更高级别的访问权限，称为系统。有了这个帐户，您可以完全控制系统的所有级别。这就是我们想要的访问级别。
- en: Gaining access to a user account is far easier than gaining the domain administrator's
    account in an attack. User accounts are far more numerous than administrator accounts,
    so snagging one of these off the wire (or wirelessly) is easier simply by the
    numbers. User accounts are normally locked down, so you are not given any real
    access to the system level of the machine. Here, we are going to get around that.
    Once actual access to the machine is gained, escalating your rights is easy, as
    we shall see.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获得用户帐户的访问权限比攻击中获得域管理员帐户要容易得多。用户帐户比管理员帐户更多，因此仅仅通过数量来捕获其中一个（有线或无线）更容易。用户帐户通常被锁定，因此您无法获得对机器系统级别的任何真正访问权限。在这里，我们将绕过这一点。一旦获得对机器的实际访问权限，提升您的权限就很容易，我们将看到。
- en: In this chapter, we have a network with two servers and two workstations protected
    by a firewall to the internet. The network also has a wireless access point. As
    the attacker, we have breached the network through the wireless device and obtained
    user account hashes from the network using an SMB poisoning attack. Using these
    stolen credentials, we will access workstations on the network and work our way
    up the network ladder to get access to the domain controller.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有一个由防火墙保护的网络，其中有两台服务器和两台工作站。网络还有一个无线接入点。作为攻击者，我们通过无线设备侵入了网络，并使用SMB中毒攻击从网络中获取了用户帐户哈希。使用这些窃取的凭据，我们将访问网络上的工作站，并逐步提升网络阶梯，以获得对域控制器的访问权限。
- en: Escalating your privileges
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升您的权限
- en: We have run our SMB poisoning attack using the Responder tool and captured two
    accounts. One is the user account `fflintstone`, and we got lucky and also captured
    a NTLMv2 hash for the `Administrator` account. As we can see in the following
    screenshot, by running the attack to drop HTTP-NTLM support to basic, we have
    captured a plain-text password for `fflintstone`, so we have an encrypted password
    to work with. NTLMv2 hashes are different for V1 hashes in that V2 hashes are
    salted using the challenge and response given in the communication from server
    to client. So, we can't use the **pass the hash** method to log in by just using
    the hash in place of the actual password, but if hashes were the only thing captured,
    we could use password cracking tools, such as John, Hashcat, or Hydra, to easily
    crack this hash and obtain the actual password. Since we got lucky and obtained
    a clear text password, we will go with this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Responder工具运行了SMB中毒攻击，并捕获了两个帐户。一个是用户帐户`fflintstone`，我们很幸运地还捕获了`Administrator`帐户的一个NTLMv2哈希。正如我们在下面的屏幕截图中所看到的，通过运行攻击以将HTTP-NTLM支持降级为基本支持，我们捕获了`fflintstone`的明文密码，因此我们有一个加密密码可供使用。NTLMv2哈希与V1哈希不同，V2哈希使用服务器到客户端通信中给出的挑战和响应进行加盐。因此，我们不能仅仅使用哈希来代替实际密码进行登录，但如果只捕获到哈希，我们可以使用密码破解工具（如John、Hashcat或Hydra）轻松破解这个哈希并获得实际密码。由于我们很幸运地获得了明文密码，我们将使用这个密码。
- en: '![](img/65f8d640-7129-4eed-995a-ea88f1ec3db6.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65f8d640-7129-4eed-995a-ea88f1ec3db6.png)'
- en: Once we gain access to the victim's machine, we will need a payload to connect
    back to the attacking machine. So, let's use the MSFvenom tool to build a quick
    payload to upload to our victim.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了受害者的机器访问权限，我们将需要一个有效负载来连接到攻击机器。因此，让我们使用MSFvenom工具构建一个快速有效负载，以上传到我们的受害者。
- en: MSFvenom
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSFvenom
- en: MSFvenom is an exploit packing tool that comes with the Metasploit framework.
    MSFvenom has the ability to build everything, from simple exploits to complex
    exploits that contain code to obfuscate the exploit used to bypass anti-virus
    services. Here, we are going to build a simple exploit to run. Normally, I would
    build and run the simple exploit first, and if problems arise from the anti-virus,
    I would then try to build out one to bypass the anti-virus.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom是一个利用打包工具，配备了Metasploit框架。MSFvenom能够构建从简单利用到包含代码以混淆用于绕过反病毒服务的利用的复杂利用。在这里，我们将构建一个简单的利用来运行。通常，我会首先构建和运行简单的利用，如果反病毒出现问题，我会尝试构建一个绕过反病毒的利用。
- en: 'MSFvenom is a very powerful tool, as we can see from the following `help` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MSFvenom是一个非常强大的工具，我们可以从以下`help`文件中看到：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By running the `msfvenom --help-formats` command, we get a list of formats that
    the payload can be compiled as.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`msfvenom --help-formats`命令，我们可以得到有效负载可以编译为的格式列表。
- en: 'Executable formats are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行格式如下：
- en: '`asp`, `aspx`, `aspx-exe`, `axis2`, `dll`, `elf`, `elf-so`, `exe`, `exe-only`,
    `exe-service`, `exe-small`, `hta-psh`, `jar`, `jsp`, `loop-vbs`, `macho`, `msi`,
    `msi-nouac`, `osx-app`, `psh`, `psh-cmd`, `psh-net`, `psh-reflection`, `vba`,
    `vba-exe`, `vba-psh`, `vbs`, and `war`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp`，`aspx`，`aspx-exe`，`axis2`，`dll`，`elf`，`elf-so`，`exe`，`exe-only`，`exe-service`，`exe-small`，`hta-psh`，`jar`，`jsp`，`loop-vbs`，`macho`，`msi`，`msi-nouac`，`osx-app`，`psh`，`psh-cmd`，`psh-net`，`psh-reflection`，`vba`，`vba-exe`，`vba-psh`，`vbs`和`war`。'
- en: 'Transform formats are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 转换格式如下：
- en: '`bash`, `c`, `csharp`, `dw`, `dword`, `hex`, `java`, `js_be`, `js_le`, `num`,
    `perl`, `pl`, `powershell`, `ps1`, `py`, `python`, `raw`, `rb`, `ruby`, `sh`,
    `vbapplication`, and `vbscript`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash`，`c`，`csharp`，`dw`，`dword`，`hex`，`java`，`js_be`，`js_le`，`num`，`perl`，`pl`，`powershell`，`ps1`，`py`，`python`，`raw`，`rb`，`ruby`，`sh`，`vbapplication`和`vbscript`。'
- en: '![](img/5c558df9-d1e2-4a6c-b06c-6a9cb55f85d1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c558df9-d1e2-4a6c-b06c-6a9cb55f85d1.png)'
- en: 'Now that we have our payload, we need to put it up so we can download it from
    our victim''s machine. All Windows systems come with a built-in FTP client, which
    can be run from the either the command line interface or by using PowerShell.
    PowerShell scripting can also be used to fetch files using FTP or HTTP services.
    Personally, for this use, I like the plain and simple FTP client. Metasploit has
    a built-in FTP server just for this purpose. To start this service from the MSFconsole,
    run the following from the command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的有效负载，我们需要将其上传，以便我们可以从受害者的机器上下载它。所有Windows系统都配备了内置的FTP客户端，可以通过命令行界面或使用PowerShell来运行。PowerShell脚本也可以用于使用FTP或HTTP服务获取文件。就我个人而言，我喜欢简单的FTP客户端。Metasploit专门为此目的内置了FTP服务器。要从MSFconsole启动此服务，请从命令行运行以下命令：
- en: '`msfdb start`: This starts the Metasploit database'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msfdb start`：这将启动Metasploit数据库'
- en: '`mfsconsole`: This starts the console'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mfsconsole`：这将启动控制台'
- en: '`workspace <NameOfWorkspace>`: This puts you into your existing workspace'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workspace <NameOfWorkspace>`：这将使您进入现有的工作区'
- en: '`use auxiliary/server/ftp`: This puts you into the FTP server configuration'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use auxiliary/server/ftp`：这将使您进入FTP服务器配置'
- en: 'By running the `show options` command, we can see the options for the service
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`show options`命令，我们可以看到服务的选项如下：
- en: '![](img/67a9cd4a-b831-4365-b2be-edac425e7417.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67a9cd4a-b831-4365-b2be-edac425e7417.png)'
- en: We see the `FTPROOT` option is set to the `/tmp/ftproot` directory. For one-time
    use, you would need the run the `mkdir /tmp/ftproot` command, which will set up
    the directory for the service and allow you to copy your exploit to this directory.
    This works fine for one-time use, but when the system shuts down, the `/tmp` directory
    is emptied, so the directory and files are deleted. Sometimes, this is the result
    you want. I like to keep my files for later use, so I set up the following directory
    by running the `mkdir /var/ftproot` command. This directory will stay permanently,
    and any files or exploits will remain after a shutdown. We will leave the `FTPUSER`
    and `FTPPASS` fields blank and use an anonymous connection to fetch the file,
    since we are only going to have this service running for a short time. If you
    need to keep the service running for a while, or you are on a hostile network,
    it might be wise to set up these two options. We will need to set up the options
    as follows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`FTPROOT`选项设置为`/tmp/ftproot`目录。对于一次性使用，您需要运行`mkdir /tmp/ftproot`命令，这将设置服务的目录并允许您将您的利用程序复制到此目录。这对一次性使用很好，但当系统关闭时，`/tmp`目录会被清空，因此目录和文件会被删除。有时，这是您想要的结果。我喜欢保留我的文件以备后用，因此我通过运行`mkdir
    /var/ftproot`命令来设置以下目录。此目录将永久保留，任何文件或利用程序在关闭后仍将保留。我们将保留`FTPUSER`和`FTPPASS`字段为空，并使用匿名连接来获取文件，因为我们只会让此服务运行一段时间。如果您需要让服务运行一段时间，或者您在一个敌对网络上，可能明智地设置这两个选项。我们需要设置以下选项。
- en: 'Our attacking machine''s address is `172.16.42.215`, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们攻击机的地址是`172.16.42.215`，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to copy the exploit we built to the `ftproot` directory as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们构建的利用程序复制到`ftproot`目录中，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we need to use the `run` command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要使用`run`命令：
- en: '![](img/0f68015f-ff6a-4632-be02-8872918b47fa.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f68015f-ff6a-4632-be02-8872918b47fa.png)'
- en: This will start the FTP service. By running the `jobs` command, we can see the
    running service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动FTP服务。通过运行`jobs`命令，我们可以看到正在运行的服务。
- en: 'We now have a valid login with a payload set up on the FTP service, so we are
    ready for the attack. In our scan of the system, we see that the RDP service is
    running at port `3389`, so we will use the **rdesktop** application to connect
    to the system as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在FTP服务上设置了有效负载的有效登录，所以我们准备好发动攻击。在我们对系统的扫描中，我们看到RDP服务在端口`3389`上运行，因此我们将使用**rdesktop**应用程序连接到系统，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/2fc0e76f-edf0-44a2-9667-81aad699781b.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fc0e76f-edf0-44a2-9667-81aad699781b.png)'
- en: 'Click the Other User button to get to the default login screen, and enter the
    captured domain credentials:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“其他用户”按钮以进入默认登录屏幕，并输入捕获的域凭据：
- en: '![](img/91808fb5-d0c1-4299-bd5b-3774c594b331.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91808fb5-d0c1-4299-bd5b-3774c594b331.png)'
- en: 'Once we''re in, pull up either a command-line interface or a PowerShell window
    and download the file as follows. The attacking machine is at `172.16.42.215`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入，要么打开命令行界面，要么打开PowerShell窗口，并按照以下方式下载文件。攻击机器的IP地址是`172.16.42.215`：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It will ask for a user; enter anonymous and hit the *Enter* key. The service
    will then ask for a password. Again, just hit the *Enter* key, leaving the field
    blank.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它会要求一个用户名；输入`anonymous`并按下*Enter*键。然后，服务将要求密码。同样，只需按下*Enter*键，留空即可。
- en: 'This will work fine on this setup. Running the `dir` command, we can see our
    exploit; we are going to download it to the Windows `temp` directory by running
    the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在这个设置上正常工作。运行`dir`命令，我们可以看到我们的利用程序；我们将通过运行以下命令将其下载到Windows的`temp`目录中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/9c5d97a8-e4e5-4855-abfd-ab5a1b6765ba.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c5d97a8-e4e5-4855-abfd-ab5a1b6765ba.png)'
- en: 'The MSFconsole will also report the file download as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: MSFconsole还将报告文件下载如下：
- en: '![](img/74ff9117-3e5d-4517-9c3e-4120af57dff7.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74ff9117-3e5d-4517-9c3e-4120af57dff7.png)'
- en: Before running the exploit, we need to set up the exploit handler on the attacking
    machine. We will set up the Metasploit multi/handler for the exploit to connect
    to. The default payload for the handler is the `reverse_tcp` payload and runs
    on port `4444`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行利用程序之前，我们需要在攻击机器上设置利用处理程序。我们将为利用程序设置Metasploit多/处理程序，以便利用程序连接。处理程序的默认有效载荷是`reverse_tcp`有效载荷，并在端口`4444`上运行。
- en: 'When we built our exploit, we set it up to use the `reverse_https` to hide
    our traffic as HTTPS traffic, so we will have to change the defaults. From the
    MSFconsole, run the following commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的利用程序时，我们设置它使用`reverse_https`来隐藏我们的流量作为HTTPS流量，因此我们必须更改默认设置。从MSFconsole中运行以下命令：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/b70ea545-eef3-4bcd-ab4d-08565de7e39b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70ea545-eef3-4bcd-ab4d-08565de7e39b.png)'
- en: 'Running the `jobs` command, we can see that the handler is now running, and
    also that the FTP service is still running as well. We can now kill the FTP service
    by running the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`jobs`命令，我们可以看到处理程序现在正在运行，还有FTP服务也在运行。我们现在可以通过运行以下命令来终止FTP服务：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/a3ca6fec-55c4-49a8-b859-82054e93a8e2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3ca6fec-55c4-49a8-b859-82054e93a8e2.png)'
- en: 'We''re now ready to run our exploit on the victim''s machine. Run the following
    command from either the command-line window or from PowerShell:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在受害者的机器上运行我们的利用程序。从命令行窗口或PowerShell运行以下命令：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will fire up the exploit and connect to the handler on the attacker''s
    machine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动利用程序并连接到攻击者机器上的处理程序。
- en: '![](img/51077842-bbc8-4ae1-805b-8bed4f45a92c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51077842-bbc8-4ae1-805b-8bed4f45a92c.png)'
- en: 'On the attacker''s system, in Metasploit we can see the exploit connect to
    the handler. Then, by running the `sessions -l` command, we can see the running
    session. Next, by running the `sessions -i 2` command, we can start a Meterpreter
    shell on the machine. Then, by running the `sysinfo` command, we can see that
    we are connected to BO-SRV2:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击者的系统中，在Metasploit中，我们可以看到利用程序连接到处理程序。然后，通过运行`sessions -l`命令，我们可以看到正在运行的会话。接下来，通过运行`sessions
    -i 2`命令，我们可以在机器上启动一个Meterpreter shell。然后，通过运行`sysinfo`命令，我们可以看到我们连接到BO-SRV2：
- en: '![](img/1cd7a229-23ba-4192-b268-11701904142e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cd7a229-23ba-4192-b268-11701904142e.png)'
- en: From our session's information, we can see that we are connected as `LAB1\rred`.
    From earlier footprinting, we know this is a domain user account with no admin
    rights, so we need to elevate the account privileges to get our goodies. Let's
    run the `getsystem` command. This command uses 15 built-in methods to gain sysadmin
    privileges to the system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们会话的信息中，我们可以看到我们以`LAB1\rred`的身份连接。根据早期的足迹，我们知道这是一个没有管理员权限的域用户帐户，因此我们需要提升帐户权限以获取我们的好处。让我们运行`getsystem`命令。该命令使用15种内置方法来获取系统管理员权限。
- en: 'The following screenshot shows that it failed to get system access. Oops! Have
    a look at the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示未能获取系统访问权限。哎呀！看一下以下输出：
- en: '![](img/6724cab0-64ac-4855-b1d3-e6b8f5be53e2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6724cab0-64ac-4855-b1d3-e6b8f5be53e2.png)'
- en: We can check this failure by running the `getuid` command, which then responds
    by showing us that we are still connected as `LAB1\rred`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`getuid`命令来检查此失败，然后它会通过显示我们仍然以`LAB1\rred`的身份连接来做出响应。
- en: Persistence in penetration testing means more than having a continuously running
    exploit. Sometimes, it involves hammering at the system with many post exploits
    in order to elevate your privileges. Some exploits will work on some systems,
    then, at other times, they don't work. Persistence is the key. In exploiting this
    system, the writer had to go though a lot of `post/windows` and `exploit/windows/local`
    modules to eventually escalate his user rights. The `post` tools and exploits
    shown failed on this attack, but could be successful on another system. Once you
    have a Meterpreter shell, you will want to back out of the shell, but still maintain
    the connection by entering background and hitting the *Enter* key.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，持久性意味着不仅仅是持续运行利用程序。有时，它涉及使用许多后期利用程序对系统进行攻击，以提升权限。有些利用程序在某些系统上有效，而在其他时候则无效。持久性是关键。在利用这个系统时，作者不得不经历许多`post/windows`和`exploit/windows/local`模块，最终提升了他的用户权限。所示的`post`工具和利用程序在此次攻击中失败了，但在另一个系统上可能会成功。一旦你有了Meterpreter
    shell，你会想要退出shell，但仍然保持连接，方法是输入`background`并按下*Enter*键。
- en: You can find `post/windows` and `exploit/windows/local` by running the following
    commands. The results will show dates on the modules. You will want to use the
    modules that are older than the age of the target system. There isn't much use
    running an exploit for Windows 2000 on a system running Server 2008\. That exploit
    will have long been patched with a version update.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令找到`post/windows`和`exploit/windows/local`。结果将显示模块的日期。您将要使用比目标系统的年龄更老的模块。在运行Server
    2008的系统上运行Windows 2000的利用程序没有多大用处。该利用程序将已经通过版本更新进行了修补。
- en: '`search post/windows`: This will find the post modules'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search post/windows`：这将找到后期模块'
- en: '`search exploit/windows/local`: This will find the exploit that can be run
    on an active session'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search exploit/windows/local`：这将找到可以在活动会话上运行的利用程序'
- en: MS16-032 Secondary Logon Handle Privilege Escalation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MS16-032次要登录句柄权限提升
- en: 'Next, we are going to run the MS16-032 Secondary Logon Handle Privilege Escalation
    module. The module''s information states the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行MS16-032次要登录句柄权限提升模块。模块的信息如下：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'See the following references for more information on MS (MS16-032):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MS（MS16-032）的更多信息，请参阅以下参考资料：
- en: '[https://cvedetails.com/cve/CVE-2016-0099/](https://cvedetails.com/cve/CVE-2016-0099/)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cvedetails.com/cve/CVE-2016-0099/](https://cvedetails.com/cve/CVE-2016-0099/)'
- en: '[https://twitter.com/FuzzySec/status/723254004042612736](https://twitter.com/FuzzySec/status/723254004042612736)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://twitter.com/FuzzySec/status/723254004042612736](https://twitter.com/FuzzySec/status/723254004042612736)'
- en: '[https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html](https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html](https://googleprojectzero.blogspot.co.uk/2016/03/exploiting-leaked-thread-handle.html)'
- en: What this exploit does is create new processes with arbitrary tokens. This tricks
    the service into using privileged access tokens, thus bypassing the security restrictions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此漏洞的作用是使用任意令牌创建新进程。这会欺骗服务使用特权访问令牌，从而绕过安全限制。
- en: 'To use this module, run the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，请运行以下命令：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/29702ab4-d1de-4508-b362-c000b3730ea8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29702ab4-d1de-4508-b362-c000b3730ea8.png)'
- en: 'By running the `show options` command, we can see that there is only the `SESSION`
    option that must be set. By running the `sessions -l` command, we see our running
    session is `2`. To set this option, run the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`show options`命令，我们可以看到只有必须设置的`SESSION`选项。通过运行`sessions -l`命令，我们看到我们的运行会话是`2`。要设置此选项，请运行以下命令：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then run to fire off the exploit. We see that the exploit has failed. The exploit
    ran, but failed to fully execute. Reading the information on this exploit, we
    see that you must have two or more cores for this exploit to work. From other
    information gathered during the footprinting of the system, we can assume this
    system is a VM running on a single core. Failures can still provide more information
    about your target.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以触发漏洞。我们看到漏洞失败了。漏洞运行了，但未能完全执行。阅读有关此漏洞的信息，我们发现您必须拥有两个或更多核心才能使此漏洞起作用。从系统足迹收集的其他信息中，我们可以假设这个系统是在单核心上运行的虚拟机。失败仍然可以提供有关目标的更多信息。
- en: Windows Escalate Service Permissions Local Privilege Escalation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows提升服务权限本地权限提升
- en: The next module we will run is Windows Escalate Service Permissions Local Privilege
    Escalation module, which is dated 2012\. This is a local exploit, run through
    the running session. Again, we will use session 2.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行的下一个模块是Windows提升服务权限本地权限提升模块，日期为2012年。这是一个本地漏洞，通过运行会话运行。同样，我们将使用会话2。
- en: 'To use this module, run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，请运行以下命令：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The description from the module is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的描述如下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see in the following output, the exploit ran again, but still no
    joy. This may be a failure, but from the output, we now know that there aren''t
    any services running with weak configurations. From the session timing out, we
    now know that any approach attempting to trick services using this method is a
    bust:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在以下输出中所看到的，漏洞再次运行，但仍然没有成功。这可能是一个失败，但从输出中，我们现在知道没有任何使用弱配置运行的服务。从会话超时，我们现在知道任何尝试使用这种方法欺骗服务的方法都是失败的：
- en: '![](img/e8a1ad96-143f-47fd-88fb-ead2c34c83ea.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8a1ad96-143f-47fd-88fb-ead2c34c83ea.png)'
- en: Windows Escalate UAC Protection Bypass (ScriptHost Vulnerability)
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows提升UAC保护绕过（ScriptHost漏洞）
- en: 'This module attempts to bypass the UAC on Windows, using the VB scripting language,
    by exploiting the `cscript/wscript.exe` executable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块尝试绕过Windows上的UAC，使用VB脚本语言，通过利用`cscript/wscript.exe`可执行文件：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After running the module, we can see in the following screenshot that the user
    account we are trying to compromise needs to have administrator''s rights. Well,
    another failure, but again we learned that the account we are using doesn''t have
    many rights in the domain. We did get another account''s credentials; maybe that
    account has more rights:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模块后，我们可以在以下屏幕截图中看到，我们试图妥协的用户帐户需要具有管理员权限。嗯，又是一个失败，但我们再次得知，我们正在使用的帐户在域中没有太多权限。我们确实获得了另一个帐户的凭据；也许该帐户有更多权限：
- en: '![](img/a7ffeb76-5870-4a27-b3ce-3bdd91567466.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7ffeb76-5870-4a27-b3ce-3bdd91567466.png)'
- en: 'By running the `creds` command, we are given a list of the captured credentials.
    Note that there are non-replayable hashes, these aren''t much use, except for
    offline cracking, but we do have another account (`fflintstone`), which was captured
    with a plain-text password. We''ll try this one with our preceding exploit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`creds`命令，我们得到了一系列捕获的凭据。请注意，有不可重放的哈希，这些对离线破解并不太有用，但我们确实有另一个帐户（`fflintstone`），它使用明文密码捕获。我们将尝试使用我们之前的漏洞来尝试这个：
- en: '![](img/0b873077-a577-4a8e-a4ed-250aae94d136.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b873077-a577-4a8e-a4ed-250aae94d136.png)'
- en: Now, to get this to run, the multi/handler must have the user account changed,
    so we will need to kill session 2 and then RDP in as `fflintstone` and re-run
    the exploit to gain that user's rights. We will need to get back into the multi/handler
    module.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使其运行，必须更改multi/handler的用户帐户，因此我们需要终止会话2，然后以`fflintstone`的身份RDP登录，然后重新运行漏洞以获得该用户的权限。我们需要重新进入multi/handler模块。
- en: '`use exploit/multi/handler`: This puts you back into the handler'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use exploit/multi/handler`：这会将您带回处理程序'
- en: '`sessions -k 2`: This kills the running session 2'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessions -k 2`：这会终止运行的会话2'
- en: '`run -j`: This restarts the multi/handler to accept a new connection and runs
    it as a job in the background'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run -j`：这会重新启动multi/handler以接受新连接，并将其作为后台作业运行'
- en: '![](img/e9187b0c-0a39-4744-8bab-76fa71c31647.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9187b0c-0a39-4744-8bab-76fa71c31647.png)'
- en: Now after logging into an RDP session using the `fflintstone` account, we will
    run the payload again from either the command line or PowerShell.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`fflintstone`帐户登录RDP会话后，我们将再次从命令行或PowerShell运行有效负载。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/7fdc87d0-45c1-4aa8-b2bf-f44ad013fd0e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fdc87d0-45c1-4aa8-b2bf-f44ad013fd0e.png)'
- en: 'In the following screenshot, we can see that the handler on our Kali box has
    accepted the connection and set up a Meterpreter session on session 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到我们的Kali盒子上的处理程序已接受连接，并在会话3上设置了一个Meterpreter会话：
- en: '![](img/2f0ef787-59ec-40b2-9ed7-1e53f6a8393c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f0ef787-59ec-40b2-9ed7-1e53f6a8393c.png)'
- en: 'So, let''s now go back to the Bypass UAC exploit and run it in the new session.
    To do this, run the following commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在让我们回到绕过UAC利用程序，并在新会话中运行它。要做到这一点，运行以下命令：
- en: '`back`: This backs out of the handler without killing it, or any sessions'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`back`：这将退出处理程序而不终止它，或任何会话'
- en: '`use exploit/windows/local/bypassuac_vbs`: This puts you back into the module'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use exploit/windows/local/bypassuac_vbs`：这将使您重新进入模块'
- en: '`set session 3`: This sets the exploit to use session 3'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set session 3`：这将使利用程序使用会话3'
- en: '`exploit`: This fires it off'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exploit`：这将启动它'
- en: 'In the following screenshot, we can see that we still failed. It seems the
    UAC settings have a higher security setting that can''t be exploited. Again, persistence
    is the key:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到我们仍然失败了。看来UAC设置有更高的安全设置，无法被利用。再次，持久性是关键：
- en: '![](img/2d61ef9a-be1c-45ea-a9db-84105696ce8c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d61ef9a-be1c-45ea-a9db-84105696ce8c.png)'
- en: 'So, it seems that BO-SRV2 is pretty locked down from the accounts we have so
    far, so let''s go after another machine. We haven''t tried the domain controller
    so let''s move on to that. We log in as `LAB1\fflintstone` using RDP, and FTP
    our exploit over to the domain controller in the same way as we did on BO-SRV2\.
    In the following screenshot, we change to the `C:\Windows\Temp` directory into
    which we want to dump our exploit, and then connect back to our Kali machine and
    download the exploit as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看来BO-SRV2对我们目前拥有的帐户来说相当安全，所以让我们去攻击另一台机器。我们还没有尝试域控制器，所以让我们继续进行。我们以`LAB1\fflintstone`的身份使用RDP登录，并以与我们在BO-SRV2上相同的方式将我们的利用程序通过FTP传输到域控制器。在下面的截图中，我们切换到`C:\Windows\Temp`目录，然后连接回我们的Kali机器并下载利用程序，如下所示：
- en: '![](img/9241aead-3295-4274-a258-a9c23d45c3d2.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9241aead-3295-4274-a258-a9c23d45c3d2.png)'
- en: Again, we are ready to run the exploit and connect back to our Kali box. Be
    sure that you have your multi/handler set up and running! Now, run the executable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们准备运行利用程序并连接回我们的Kali盒子。确保您的多/处理程序设置并运行！现在，运行可执行文件。
- en: '`svchosts.exe`: This will start the exploit and you will see the session open
    on Kali.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`svchosts.exe`：这将启动利用程序，您将看到Kali上的会话打开。'
- en: '![](img/d6900f6e-7ed2-497f-b918-c2725400060b.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6900f6e-7ed2-497f-b918-c2725400060b.png)'
- en: 'We go back to our VBS bypass exploit and run it against this session. Oh no!
    We have another failure just like the last one on BO-SRV2:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到我们的VBS绕过利用程序，并针对这个会话运行它。哦不！我们像在BO-SRV2上一样又失败了：
- en: '![](img/4307a3d4-fdf1-4d85-8f70-149ad195fee2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4307a3d4-fdf1-4d85-8f70-149ad195fee2.png)'
- en: 'Now, it seems that all the servers'' security is set to high on all user accounts.
    We need to get this pesky UAC out of the way. This is also most likely the reason
    that our other attempts have failed. When the exploits run automatically, they
    get blocked by the UAC. We need to disable the UAC and get it out of the way.
    Since we have an RDP session and an account with some rights to the machine, we''ll
    use the GUI to disable the UAC, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，似乎所有服务器的安全性都针对所有用户帐户设置为高。我们需要摆脱这个讨厌的UAC。这很可能也是我们的其他尝试失败的原因。当利用程序自动运行时，它们会被UAC阻止。我们需要禁用UAC并将其排除在外。由于我们有一个RDP会话和一些对机器有一些权限的帐户，我们将使用GUI来禁用UAC，如下所示：
- en: Go to Control Panel.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往控制面板。
- en: Choose User Accounts.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择用户帐户。
- en: Click Turn User Account Control On or Off.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '单击打开或关闭用户帐户控制。 '
- en: Click through the UAC window.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击通过UAC窗口。
- en: Next, uncheck the checkbox.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，取消复选框。
- en: Press OK.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下确定。
- en: You will then be asked to restart the computer; go ahead.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会要求您重新启动计算机；继续。
- en: 'The following screenshot shows the UAC window:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的截图显示了UAC窗口：
- en: '![](img/5ae59f16-97fc-4a0a-9ac8-676d4444fc87.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ae59f16-97fc-4a0a-9ac8-676d4444fc87.png)'
- en: 'You may wonder why we didn''t do this on BO-SRV2\. Footprinting has shown us
    that BO-SRV2 is a file server on the network. A reboot of this system could alert
    users to our presence. Networks may have only a single file server, so it would
    be noticed if it was rebooted, but domain controllers are another story. We can
    reboot this system and no one will be any the wiser, unless there is a network
    monitoring service on the network that could tell on us. At the very least, the
    chance of getting caught is slimmer when rebooting the domain controller. Oh,
    yes; before rebooting the machine, right-click on the Taskbar, go to the Task
    Manager and check the Users tab to be sure you are the only one on the box. Rebooting
    while the administrator is on the box will mean that you are busted. We can see
    in the following screenshot that we are the only one on the system right now,
    so it safe to reboot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们没有在BO-SRV2上这样做。足迹显示，BO-SRV2是网络上的文件服务器。重新启动此系统可能会提醒用户我们的存在。网络可能只有一个文件服务器，因此如果重新启动它，就会被注意到，但域控制器是另一回事。我们可以重新启动此系统，没有人会知道，除非网络上有一个可以告诉我们的网络监控服务。至少，在重新启动域控制器时被抓住的机会较小。哦，是的；在重新启动机器之前，右键单击任务栏，转到任务管理器，并检查用户选项卡，确保您是唯一一个在盒子上的人。在管理员在盒子上时重新启动将意味着您被抓住了。我们可以在下面的截图中看到，我们现在是系统上唯一的一个人，所以安全地重新启动：
- en: '![](img/4db6dca3-7c50-415c-878f-a92fa617accd.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4db6dca3-7c50-415c-878f-a92fa617accd.png)'
- en: 'Now, after a reboot we start the process over. Be sure and have your multi/handler
    set up properly and running on your Kali machine. Log back into the victim''s
    machine and re-run your payload:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动后我们重新开始这个过程。确保您的Kali机器上的多/处理程序设置正确并运行。重新登录受害者的机器，并重新运行您的有效载荷：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will then see the Meterpreter session start on your Kali box, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将看到Meterpreter会话在您的Kali盒子上启动，如下所示：
- en: '![](img/2716de20-95ce-49fa-bf72-3e9b8878f8fa.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2716de20-95ce-49fa-bf72-3e9b8878f8fa.png)'
- en: 'Well, let''s see what we got this time! Open our Meterpreter session and see
    what happens. To open the session, do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看这次我们得到了什么！打开我们的Meterpreter会话，看看发生了什么。要打开会话，请执行以下操作：
- en: '`sessions -i 2`: The `-i` is to interact with the numbered session'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessions -i 2`: `-i` 是与编号会话进行交互'
- en: '`getuid`: This shows us that we are running as `fflintstone`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getuid`: 这显示我们正在以 `fflintstone` 身份运行'
- en: This is just for giggles, as it didn't work last time we ran it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了好玩，因为上次运行它没有起作用。
- en: '`getsystem`: Bingo! We have a winner! When we re-run `getuid`, we see we are
    now system. Yes, get up and do your happy dance: you now have system-level privileges!
    It''s fully pwned:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getsystem`: 中了！我们有赢家！当我们重新运行 `getuid` 时，我们看到我们现在是系统。是的，起身跳起您的快乐舞蹈：您现在拥有系统级别的特权！它完全被控制了：'
- en: '![](img/47855e4d-9bf9-4358-a17e-969ec44e82cd.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47855e4d-9bf9-4358-a17e-969ec44e82cd.png)'
- en: So, we have found out that the problem all along was the UAC, and that we didn't
    have the ability to bypass the prompt that normally appears on the screen. Even
    with administrator-level access, the UAC prompt killed our attempts to fully compromise
    the machine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经发现问题一直是 UAC，并且我们没有能力绕过通常出现在屏幕上的提示。即使具有管理员级别的访问权限，UAC 提示也会破坏我们完全攻陷机器的尝试。
- en: So, let's loot the system and gather our booty. This, as the domain controller,
    holds the keys to the kingdom. In a penetration test, once this is looted, it's
    game over. In a real world hack, once this is accomplished, your network is toast;
    without a complete rebuild of your entire network structure, you will never be
    absolutely sure that your attacker is completely locked out. To do this, we are
    going to use a `post` module to gather all the user accounts and their hashes.
    To do this, we will use the `post/windows/gather/smart_hashdump` module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们掠夺系统并收集我们的战利品。作为域控制器，它掌握着王国的钥匙。在渗透测试中，一旦被掠夺，游戏就结束了。在真实世界的黑客攻击中，一旦实现了这一点，您的网络就完蛋了；除非完全重建整个网络结构，否则您永远无法确定您的攻击者完全被锁在外面。为此，我们将使用
    `post` 模块来收集所有用户帐户及其哈希。为此，我们将使用 `post/windows/gather/smart_hashdump` 模块。
- en: 'The information on this module is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的信息如下：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Before setting up and running this module, first we want to get out of the Meterpreter
    shell without breaking the connection, then load the post module and run it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置和运行此模块之前，我们首先要退出 Meterpreter shell，而不中断连接，然后加载 post 模块并运行它。
- en: 'From the running Metetpreter shell, run these commands:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从正在运行的 Metetpreter shell 中运行这些命令：
- en: '`background`: This will background the session and not kill it.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background`: 这将使会话后台运行而不终止它。'
- en: '`use post/windows/gather/smart_hashdump`: This will load the `smart_hashdump`
    module.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use post/windows/gather/smart_hashdump`: 这将加载 `smart_hashdump` 模块。'
- en: '`show options`: This shows the options needed.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show options`: 这将显示所需的选项。'
- en: '`set SESSION 2`: This sets the session to use our running session.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set SESSION 2`: 这将设置会话以使用我们正在运行的会话。'
- en: '`show options`: Run this again to check your settings.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show options`: 再次运行此命令以检查您的设置。'
- en: '`exploit`: Exploit!!'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`利用`: 利用!!'
- en: '![](img/0d84fc61-e734-49c4-ae15-d501d97ab5b5.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d84fc61-e734-49c4-ae15-d501d97ab5b5.png)'
- en: Bingo! You are now the proud owner of the `LAB1.boweaver.net` domain. Note that
    all hashes from the domain, including machine accounts, have been looted. These
    hashes are not salted, unlike the hashes captured on the wire using NTLMv2, which
    is salted and non-replayable. These are straight NTLM hashes and can be used in
    **pass the hash** style attacks and logins to other systems. They can also be
    more easily cracked using offline password cracking tools to get the plain-text
    passwords.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 中了！您现在是 `LAB1.boweaver.net` 域的自豪所有者。请注意，域中的所有哈希，包括机器帐户，都已被掠夺。这些哈希不是经过盐处理的，不像使用
    NTLMv2 在线捕获的哈希，后者是经过盐处理且不可重放的。这些是直接的 NTLM 哈希，可以用于**传递哈希**风格的攻击和登录到其他系统。它们也可以更容易地使用离线密码破解工具进行破解，以获取明文密码。
- en: Also, note that not only have the creds been saved to the Metasploit database,
    they were also outputted to the file at `/root/.msf4/loot/20170709202230_lab1.boweaver.ne_172.16.42.5_windows.hashes_075027.txt`.
    This text file is in a format that can be imported into either John or Hashcat
    for offline cracking.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，凭证不仅已保存到 Metasploit 数据库中，还输出到了位于 `/root/.msf4/loot/20170709202230_lab1.boweaver.ne_172.16.42.5_windows.hashes_075027.txt`
    的文件中。这个文本文件是以一种格式保存的，可以导入到 John 或 Hashcat 进行离线破解。
- en: 'The following screenshot shows the results for a test domain for this book,
    so the output isn''t that large. In a large domain, this can be an incredibly
    large dump:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本书的测试域的结果，因此输出并不那么大。在大型域中，这可能是一个非常大的转储：
- en: '![](img/06396ab8-5349-4250-8e14-f81383e4aba2.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06396ab8-5349-4250-8e14-f81383e4aba2.png)'
- en: 'Hacker''s tip:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客提示：
- en: When dumping a large domain, sometimes you can find disabled accounts. It's
    better to enable one of these accounts for attack use, and elevate the privileges
    of this account, than to add a new account for attack use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在转储大型域时，有时可以找到已禁用的帐户。最好启用其中一个帐户进行攻击使用，并提升此帐户的特权，而不是添加新的帐户进行攻击使用。
- en: Maintaining access
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维持访问
- en: Once you have gained access and escalated your level of access, you will want
    to come back. If the system is breached using a vulnerability against an open
    port to the internet, then returning is not a big issue, unless the system gets
    patched. You can always just reuse your exploit and regain access to the internal
    network. If you have exploited the system using a phishing attack or a browser
    exploit, then your connection from the attack will happen only once when the link
    is clicked, or the browser exploit is run from the infected site. When attacking
    a user from a workstation in these ways, in order to return to the workstation
    and bypass the firewall, you will need something to maintain access. With systems
    behind a properly configured firewall, it is almost impossible to gain direct
    access without any ports open to the internet. All systems can, however, call
    out to the internet, so this is our attack vector and our way back in. This is
    why highly secured networks should always be air-gapped, with no physical way
    to call out to the public network. This is where small furry mammals with long
    tails and big ears come into play.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了访问权限并提升了你的访问级别，你会想要回来。如果系统是通过对互联网开放端口的漏洞而被入侵的，那么返回就不是一个大问题，除非系统被修补。你可以随时重复利用你的漏洞，并重新获得对内部网络的访问权限。如果你使用钓鱼攻击或浏览器漏洞来攻击系统，那么你的连接只会发生一次，当链接被点击时，或者从被感染的网站运行浏览器漏洞时。以这些方式攻击用户的工作站，为了返回工作站并绕过防火墙，你需要一些东西来维持访问。对于配置良好的防火墙后面的系统来说，几乎不可能在没有任何对互联网开放的端口的情况下直接获得访问权限。然而，所有系统都可以呼叫互联网，所以这是我们的攻击向量和我们返回的方式。这就是为什么高度安全的网络应该始终是空气隔离的，没有物理方式呼叫公共网络。这就是小而毛茸茸、尾巴长、耳朵大的哺乳动物发挥作用的地方。
- en: Remote Access Tools
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程访问工具
- en: '**Remote Access Tools** (**RATs**) are small programs that can be used to call
    out to a server and maintain a connection to that server, sometimes called a **Command
    and Control** server, or CnC. Using that connection from the server, the attacker
    can then access the victim''s internal network from the internal machine, or use
    it as a pivot to exploit the network from the attacker''s remote machine.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程访问工具**（**RATs**）是一种可以用来呼叫服务器并维持与该服务器的连接的小型程序，有时被称为**命令和控制**服务器，或CnC。使用来自服务器的连接，攻击者可以从内部机器访问受害者的内部网络，或者使用它作为一个Pivot来从攻击者的远程机器上攻击网络。'
- en: 'Pivots are my personal favorites. With pivots, there is no need to upload tools
    to another victim''s machine, which can trigger anti-virus software and other
    security monitoring that workstation during the upload. Once the RAT is in place,
    you can now pivot from the first victim''s machine. Also, it just isn''t practical
    to upload a version of something like Metasploit and install it on the victim''s
    machine. With a pivot there is no need to upload tools: you can use the tools
    installed on your system against the internal victim network just as if you were
    plugged into the internal network. The victim''s machine is now acting only as
    a router, and your remote Kali machine is now on the internal network. Metasploit
    has some handy-dandy pivots built right in. Remember, too, that if the network
    can be breached from a wireless access point, then you also have full access to
    the internal network, so there is no need to pivot.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Pivots是我个人最喜欢的。有了Pivots，就不需要将工具上传到另一个受害者的机器上，这可能会触发反病毒软件和其他安全监控工作站在上传过程中。一旦RAT就位，你现在可以从第一个受害者的机器上进行Pivot。此外，将像Metasploit这样的版本上传并安装到受害者的机器上是不切实际的。有了Pivot，就不需要上传工具：你可以使用你系统上安装的工具来对内部受害者网络进行攻击，就像你插入内部网络一样。受害者的机器现在只是作为一个路由器，你的远程Kali机器现在位于内部网络上。Metasploit内置了一些方便的Pivots。还要记住，如果网络可以从无线接入点被入侵，那么你也可以完全访问内部网络，所以没有必要进行Pivot。
- en: There are thousands of RATs available these days for any system, not just Windows.
    Android RATs are becoming widely used these days to breach cell phones and tablets
    and maintain access to these devices. We are going to custom-build some RATs using
    Metasploit's MSFvenom tool. I find that these work the best, and other tools,
    such as Mimikats, can be run through the connection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如今有成千上万的RAT可用于任何系统，不仅仅是Windows。Android RAT如今也被广泛用于入侵手机和平板电脑，并维持对这些设备的访问。我们将使用Metasploit的MSFvenom工具来定制一些RAT。我发现这些效果最好，其他工具，如Mimikats，可以通过连接运行。
- en: Metasploit's persistence_exe module
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metasploit的persistence_exe模块
- en: 'We are going to use our existing session first, to load a persistent executable
    on to the system, which will continue to call back to our multi/handler. Since
    we have this session already, and it has system-level access, loading this will
    be easy. To load the module, run the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要使用我们现有的会话，将一个持久的可执行文件加载到系统上，这将继续呼叫我们的多/handler。由于我们已经有了这个会话，并且它具有系统级别的访问权限，加载这个将会很容易。要加载模块，运行以下命令：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `persistence_exe` module''s information says the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`persistence_exe`模块的信息如下：'
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We see the RAT's name is set in the `REXENAME` to `default.exe`. If someone
    is auditing the process list, this will stick out as a malicious process, so let's
    rename it for a little more stealth. Earlier, we built our payload `svchosts.exe`.
    Notice this name is very close to the known running `svchost` executable, which
    will appear many times in the running processes of a normal running server. The
    name being close to the actual service name will give it a bit of stealth. Why
    build a new payload when we have a known working exploit?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到RAT的名称设置为`REXENAME`为`default.exe`。如果有人在审核进程列表，这将显得像一个恶意进程，所以让我们为它改个名字，更隐蔽一点。早些时候，我们构建了我们的有效载荷`svchosts.exe`。注意这个名字与已知运行的`svchost`可执行文件非常接近，这个文件在正常运行的服务器的运行进程中会出现很多次。名字接近实际服务名将使它更隐蔽一些。当我们有一个已知的有效利用时，为什么要构建一个新的有效载荷呢？
- en: 'Set up the module as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设置模块如下：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We see that it has uploaded the RAT and failed to open the System Manager,
    which has replied that the RPC server is unavailable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到它已经上传了RAT并且未能打开系统管理器，回复说RPC服务器不可用：
- en: '![](img/ed6bdb62-75a9-4988-b91d-c8b5dd19ae0b.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed6bdb62-75a9-4988-b91d-c8b5dd19ae0b.png)'
- en: 'On the domain controller, we can see that an application has crashed and a
    warning has popped up on the desktop. When attempting to be stealthy, this is
    not a good thing:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在域控制器上，我们可以看到一个应用程序崩溃并且桌面上弹出了一个警告。在试图隐蔽时，这不是一件好事：
- en: '![](img/891006ee-ba1f-4bba-bb82-27ebdbf6255a.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/891006ee-ba1f-4bba-bb82-27ebdbf6255a.png)'
- en: 'The error says the application ApacheBench has crashed. The Apache Web Server
    isn''t loaded on this machine, so the error could be coming from the HTTPS payload
    that we are using. So, let''s build another payload to use as the RAT, using a
    straight TCP connection. To build the payload from the command line, run the following
    commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 错误显示应用程序ApacheBench已崩溃。此计算机未加载Apache Web服务器，因此错误可能来自我们正在使用的HTTPS有效负载。因此，让我们构建另一个有效负载，以用作RAT，使用直接的TCP连接。要从命令行构建有效负载，请运行以下命令：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/b64246ba-c993-433b-9952-46cb6cad20ed.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b64246ba-c993-433b-9952-46cb6cad20ed.png)'
- en: 'We will need to set up a multi/handler for this payload:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为此有效负载设置一个多/处理程序：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now go back to the persistence module using the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令返回到持久性模块：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Reset the `REXEPATH` for the new payload:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为新有效负载重置`REXEPATH`：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/4bba8433-d724-4e24-93c6-9f43af76cb35.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bba8433-d724-4e24-93c6-9f43af76cb35.png)'
- en: As we can see, this time, the payload did successfully run and opened a new
    session. We also see that, again, the RPC server is unavailable, so the RAT didn't
    load as a service. So, the RAT is most likely not running as a service. Running
    as a service is the most optimal, but since it is giving us a problem, let's set
    the `STARTUP` to `USER`. With this configuration, we will have to wait until the
    user logs in again for the exploit to run. When using this setting, it's best
    to use an account that is frequently used. Checking the event logs will give you
    information on which users log in and the frequency of logins.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这次有效负载成功运行并打开了一个新的会话。我们还看到，RPC服务器再次不可用，因此RAT没有作为服务加载。因此，RAT很可能没有作为服务运行。作为服务运行是最理想的，但由于它给我们带来了问题，让我们将`STARTUP`设置为`USER`。使用此配置，我们必须等待用户再次登录才能运行漏洞利用。在使用此设置时，最好使用经常使用的帐户。检查事件日志将为您提供有关哪些用户登录以及登录频率的信息。
- en: 'Be sure to kill the session that the last run created, and then change the
    `STARTUP` setting as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保终止上次运行创建的会话，然后将`STARTUP`设置更改如下：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/32d1dc7c-4825-4f01-84a7-f40d8fe64ce9.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32d1dc7c-4825-4f01-84a7-f40d8fe64ce9.png)'
- en: 'Success! On this run, the module loaded the payload and set it to autorun,
    so we should be good to go. Let''s tests the results. When we ran this exploit,
    we didn''t restart our multi/handler to catch the payload, as it ran previously.
    We can see that no session was created, even with everything else showing a successful
    run of the exploit. When we set up and run the handler, we get a connection from
    the payload immediately:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！在此运行中，模块加载了有效负载并将其设置为自动运行，所以我们应该可以继续进行。让我们测试结果。当我们运行此漏洞时，我们没有重新启动我们的多/处理程序来捕获有效负载，因为它之前已经运行过。我们可以看到没有会话被创建，即使其他一切都显示漏洞的成功运行。当我们设置并运行处理程序时，我们立即从有效负载获得连接：
- en: '![](img/97b782d7-de9d-4836-97f8-9eaae4bc8ac8.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97b782d7-de9d-4836-97f8-9eaae4bc8ac8.png)'
- en: 'Let''s check whether it reconnects on the next login. Kill all the sessions
    in the system and log out of the RDP session. Next, restart the multi/handler
    for the next login:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查下次登录时是否重新连接。终止系统中的所有会话并注销RDP会话。接下来，重新启动多/处理程序以进行下次登录：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/0510cba3-bafb-40db-856a-25dc8c5388f4.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0510cba3-bafb-40db-856a-25dc8c5388f4.png)'
- en: 'When we log back in using an RDP session, we see that a new session has started
    on the running handler. We are able to interact with the session and gain system
    access from the Meterpreter shell:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用RDP会话重新登录时，我们看到一个新的会话已经在运行的处理程序上启动。我们能够与会话交互，并从Meterpreter shell获得系统访问权限：
- en: '![](img/dbf0a99b-45a3-4bde-89f9-df5488300aa5.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbf0a99b-45a3-4bde-89f9-df5488300aa5.png)'
- en: Windows registry-only persistence
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅限Windows注册表的持久性
- en: The Windows registry is a great place to hide malicious code. A lot of malware
    and spyware use methods like this to hide and run their payloads. The complexity
    of the registry and the system access level of the registry make it a great attack
    vector.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Windows注册表是隐藏恶意代码的好地方。许多恶意软件和间谍软件使用这样的方法来隐藏和运行它们的有效负载。注册表的复杂性和注册表的系统访问级别使其成为一个很好的攻击向量。
- en: 'We will run the following module on the current running session and attempt
    to get the payload to run with system level access. The module''s information
    is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在当前运行的会话上运行以下模块，并尝试以系统级访问权限运行有效负载。模块的信息如下：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will let the module run most of the settings with their defaults. We will
    run with the following commands:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让模块使用默认设置运行大部分设置。我们将使用以下命令运行：
- en: '`set SESSION 4`: Set to the current running session'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set SESSION 4`：设置为当前运行的会话'
- en: '`set STARTUP SYSTEM`: This will set the persistent payload to run as SYSTEM
    exploit'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set STARTUP SYSTEM`：这将设置持久有效负载以作为系统漏洞运行'
- en: '![](img/159b1ea5-1ef9-462c-972b-78f3dad47c98.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/159b1ea5-1ef9-462c-972b-78f3dad47c98.png)'
- en: Well, it appears that our exploit has failed. We got a warning that PowerShell
    is not available. The exploit did write to the registry, but note that a new session
    was not started when the run completed. This tells us that, since PowerShell wasn't
    found, we have a failure on our run. Since PowerShell can't be found, let's try
    an older means by adding persistence from the running session's Meterpreter shell
    and running the exploit from a VB script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们的漏洞利用失败了。我们收到了PowerShell不可用的警告。漏洞利用确实写入了注册表，但请注意，当运行完成时没有启动新会话。这告诉我们，由于未找到PowerShell，我们的运行失败了。由于找不到PowerShell，让我们尝试通过从运行会话的Meterpreter
    shell添加持久性并从VB脚本运行漏洞利用的旧方法。
- en: Something to remember is that this type of exploit doesn't require a login,
    so on a production system, this will be an open backdoor if not removed, and can
    be accessed by another attacker if left running on the machine.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，这种类型的利用不需要登录，因此在生产系统上，如果不删除，这将是一个开放的后门，并且如果在机器上继续运行，另一个攻击者可以访问它。
- en: 'You can read the help files for the persistence script by running the following
    commands from the running Meterpreter session. As you can see, the persistence
    script is listed as deprecated, but since the newer post exploits didn''t work,
    it''s best to fallback to an older method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从运行的Meterpreter会话中运行以下命令来阅读持久性脚本的帮助文件。正如您所看到的，持久性脚本被列为已弃用，但由于较新的后期利用未能奏效，最好回退到较旧的方法：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To set this up, we''ll use the following settings:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，我们将使用以下设置：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/d72f78a3-71d8-47c7-9ac6-1c48d6211492.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d72f78a3-71d8-47c7-9ac6-1c48d6211492.png)'
- en: 'Oh well; the unavailable RPC service got us again, so let''s give it a go with
    an even older method: the `AT` command. The `AT` command is the task scheduler,
    dates back to the days of NT 3.51, and runs only from the command line. This also
    gives it a bit of stealth, since tasks scheduled using `AT` don''t show in the
    GUI version of the task scheduler. They are two separate applications and don''t
    share jobs. The AT service is a lot like Cron on Linux and UNIX. There is an `AT`
    scheduler that runs on these systems also.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 哦好吧；不可用的RPC服务再次让我们失望，所以让我们尝试一个更古老的方法：`AT`命令。`AT`命令是任务计划程序，可以追溯到NT 3.51的时代，只能从命令行运行。这也使它具有一些隐蔽性，因为使用`AT`调度的任务不会显示在任务计划程序的GUI版本中。它们是两个独立的应用程序，不共享作业。AT服务很像Linux和UNIX上的Cron。这些系统上也有一个`AT`调度程序。
- en: 'So, to go to the remote shell from the Meterpreter run this command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要从Meterpreter转到远程shell，请运行此命令：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, move the payload from the `Temp` directory to the `Windows` directory,
    so the payload will run without using the full path to the payload:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将有效载荷从“Temp”目录移动到“Windows”目录，这样有效载荷将在不使用完整路径的情况下运行：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From the remote shell, run the following to be sure that the scheduler service
    is running:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程shell中运行以下命令，以确保计划程序服务正在运行：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/960aafe0-61b8-4baf-844d-68f778c06563.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/960aafe0-61b8-4baf-844d-68f778c06563.png)'
- en: 'Remember to start a multi/handler before the set time. When the time rolls
    around, we see that we now have a new running session:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住在设置时间之前启动multi/handler。当时间到来时，我们会看到我们现在有一个新的运行会话：
- en: '![](img/ecfea210-5743-459a-b611-c2d156936c64.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecfea210-5743-459a-b611-c2d156936c64.png)'
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to elevate privileges locally and remotely.
    We have shown how even exploits that have gone wrong can be a learning experience
    and can give us valuable information about our target and our target's network.
    We have learned several methods of maintaining persistence in our attacking system,
    and methods to hide these payloads from the user. We have learned how to disable
    UAC and bypass its security.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何在本地和远程提升权限。我们展示了即使利用出现问题也可以成为学习经验，并且可以为我们提供有关目标及其目标网络的宝贵信息。我们已经学会了在攻击系统中保持持久性的几种方法，并且学会了如何隐藏这些有效载荷。我们已经学会了如何禁用UAC并绕过其安全性。
- en: We have learned how to build a payload, bring it onto our compromised system,
    and use it to elevate our privileges from a normal user account to system-level
    access on a Windows system. We have also learned how to set this payload to run
    with persistence on our exploited machine, so that we can return later to the
    same compromised machine. We have also learned a valuable lesson on how to gain
    knowledge about a system from failed attempts to compromise it and used that knowledge
    to gain full access to the machine. Failures can be successes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何构建有效载荷，将其带入我们受损的系统，并将其用于将我们的权限从普通用户帐户提升到Windows系统上的系统级访问。我们还学会了如何设置此有效载荷以在我们受攻击的机器上持久运行，以便我们以后可以返回到同一受损的机器。我们还从未能成功入侵系统中获取知识的宝贵教训，并利用这些知识获得对机器的完全访问权限。失败也可以是成功。
