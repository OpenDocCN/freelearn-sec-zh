- en: '*Chapter 6*: Cryptography and the Penetration Tester'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：加密学与渗透测试者'
- en: Julius Caesar is known to have used encryption – a method known today as *Caesar’s
    cipher*. You may think the cipher of one of history’s most well-known military
    generals would be a fine example of security, but the method – a simple alphabet
    shift substitution cipher – is probably the easiest kind of code to break. It’s
    said that it was considered secure in his time because most of the people who
    may have intercepted his messages couldn’t read. Now that you have a fun tidbit
    of history, let’s be reminded that cryptography has come a very long way since
    then, and your pen testing clients will not be using Caesar’s cipher.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尤利乌斯·凯撒被认为使用了加密技术——这种方法今天被称为*凯撒密码*。你可能认为历史上最著名的军事将领之一使用的密码会是一个很好的安全示例，但这种方法——一种简单的字母表移位替换密码——可能是最容易破解的密码。人们说，在他那个时代，由于大多数可能会截获他信息的人都不会阅读，所以这种方法被认为是安全的。现在你知道了一些有趣的历史细节，也提醒我们加密学自那时以来已经取得了长足的进步，你的渗透测试客户不会再使用凯撒密码了。
- en: 'Cryptography is a funny topic in penetration testing: it’s such a fundamental
    part of the entire science of information security but is also often neglected
    in security testing. We’ve explored avoiding the task of attacking encryption
    by finding ways to trick an application into sending plaintext data, but such
    attacks are not compromises of an encryption algorithm. In this chapter, we’re
    going to take a look at a few examples of direct attacks against cryptographic
    implementations. We are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学是渗透测试中的一个有趣话题：它是信息安全整个科学中一个如此基础的部分，但在安全测试中往往被忽视。我们已经探讨过通过找到欺骗应用程序发送明文数据的方式来避免攻击加密的任务，但这些攻击并不是加密算法的破坏。在本章中，我们将查看一些直接攻击加密实现的示例。我们将覆盖以下主题：
- en: Bit-flipping attacks against cipher block chaining algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对密码块链接算法的比特翻转攻击
- en: Sneaking in malicious requests by calculating a hash that will pass verification;
    we’ll see how cryptographic padding helps us
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算能够通过验证的哈希来偷偷提交恶意请求；我们将看到加密填充如何帮助我们
- en: Padding oracle attacks; as the name suggests, we will continue to look at the
    padding concept
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充 Oracle 攻击；顾名思义，我们将继续探讨填充概念
- en: How to install a powerful web server stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装强大的 Web 服务器堆栈
- en: Installing two deliberately vulnerable web applications for testing in your
    home lab
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在家庭实验室中安装两个故意存在漏洞的 web 应用程序以进行测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的内容：
- en: Kali Linux running on a laptop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux 运行在笔记本电脑上
- en: The XAMPP web server stack software
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAMPP Web 服务器堆栈软件
- en: The Mutillidae II vulnerable web application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mutillidae II 漏洞 Web 应用程序
- en: Flipping the bit – integrity attacks against CBC algorithms
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻转比特——对 CBC 算法的完整性攻击
- en: When we consider attacks against cryptographic ciphers, we usually think about
    those attacks against the cipher itself that allow us to break the code and recover
    the plaintext. It’s important to remember that the message can be attacked, even
    when the cipher remains unbroken and the full message is unknown. Let’s consider
    a quick example with a plain stream cipher. Instead of XOR bits, we’ll just use
    decimal digits and modular arithmetic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑针对加密密码的攻击时，通常想到的是那些针对密码本身的攻击，这些攻击使我们能够破解密码并恢复明文。需要记住的是，即使密码没有被破解且完整信息未知，信息本身也可能受到攻击。我们来考虑一个简单的流密码的例子。我们将不使用异或位，而是使用十进制数字和模运算。
- en: XOR is the exclusive or operation. It simply compares two inputs and returns
    true if they are different. Of course, with binary, the inputs are either true
    (**1**) or false (**0**), so if the inputs are both **1** or both **0**, the result
    will be **0**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 异或（XOR）是“异或”运算。它只是比较两个输入，如果它们不同，则返回 true。当然，在二进制中，输入要么为真（**1**），要么为假（**0**），所以如果两个输入都是**1**或都是**0**，结果将是**0**。
- en: 'We’ll make our message **MEET AT NOON** while using **01** for **A**, **02**
    for **B**, and so on. Our key will be **48562879825463728830**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的消息为**MEET AT NOON**，使用**01**表示**A**，**02**表示**B**，依此类推。我们的密钥将是**48562879825463728830**：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s suppose we can’t crack the algorithm, but we can intercept the encrypted
    message in transit and flip some digits around. Using that same key, throwing
    in some random numbers would just result in nonsense when we decrypt. But let’s
    just change a few of the final digits – now, our key is **51512399837469870948**
    and suddenly, the plaintext becomes **MEET AT FOUR**. We didn’t attack the algorithm;
    we attacked the message and caused someone some trouble. Now, this is a very rough
    example designed to illustrate the concept of attacking messages. Now that we’ve
    had some fun with modular arithmetic, let’s dive into the more complex stuff.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们无法破解算法，但我们可以在传输过程中拦截到加密的消息，并对一些数字进行修改。使用相同的密钥，随便加一些随机数字，解密后得到的就是一堆无意义的东西。但如果我们只改变一些最后的数字——现在，我们的密钥是**51512399837469870948**，突然间，明文变成了
    **MEET AT FOUR**。我们没有攻击算法；我们攻击了**消息**，并且给某些人带来了麻烦。这只是一个粗略的例子，旨在说明攻击消息的概念。现在我们在模运算上玩得很开心，接下来让我们深入探讨更复杂的内容。
- en: Block ciphers and modes of operation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块密码和操作模式
- en: In our fun little example, we were working with a stream cipher; data is encrypted
    one bit at a time until it’s done. This is in contrast to a block cipher, which,
    as the name suggests, encrypts data in fixed-length blocks. From a security standpoint,
    this concept implies that secure encryption can easily be achieved for a single
    block of data; you could have high-entropy key material that’s the same length
    as the block. But our plaintext is never that short; the data is split into multiple
    blocks. How we repeatedly encrypt block after block and link everything together
    is called a **mode of operation**. As you can imagine, the design of a block cipher’s
    mode of operation is where security is made and broken.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个有趣的小例子中，我们使用的是流密码；数据是按位加密的，直到加密完成。这与块密码不同，块密码顾名思义，是以固定长度的块加密数据。从安全角度来看，这意味着单个数据块的安全加密可以很容易实现；你可以使用与块同样长的高熵密钥材料。但我们的明文数据从来不那么短；数据被拆分成多个块。我们如何不断加密一个又一个的块并将它们连接在一起，这就是所谓的**操作模式**。正如你所想的，块密码操作模式的设计就是安全性的所在，成功与失败的关键。
- en: 'Let’s look at probably the simplest (I prefer the word *medieval*) block cipher
    mode of operation, called **Electronic Codebook** (**ECB**) mode, so named because
    it’s inspired by the good old-fashioned literal codebook of wartime encryption
    efforts – you encrypt and decrypt blocks of text without using any of that information
    to influence other blocks. This would probably work just fine if you were encrypting
    random data, but who’s doing that? No one; human-composed messages have patterns
    in them. Now, we’ll provide a demonstration with **openssl** and **xxd** on Kali,
    which is a nice way to encrypt something and look at the actual result. I’m going
    to tell the world that I’m an elite hacker and I’m going to repeat the message
    over and over again – you know, for emphasis. I’ll encrypt it with AES-128 operating
    in ECB mode and then dump the result with **xxd**:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下可能是最简单的（我更喜欢用*中世纪*这个词）块密码操作模式，叫做**电子密码本**（**ECB**）模式，这个名字来源于二战时期的传统密码本
    – 你加密和解密文本块时，并不会利用任何其他信息去影响其他块。如果你加密的是随机数据，这样的模式可能完全可行，但谁会加密随机数据呢？没人；人类编写的消息中总是有规律的。现在，我们将使用
    **openssl** 和 **xxd** 在 Kali 上进行演示，这是一种很好的加密方法，并且可以查看实际结果。我打算告诉全世界我是一个精英黑客，并且我会反复重复这条信息——你知道的，就是为了强调。我将用
    AES-128 加密，操作模式是 ECB，然后使用 **xxd** 转储结果：
- en: '![Figure 6.1 – AES in ECB mode ](image/Figure_6.01_B17616.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – AES 在 ECB 模式下](image/Figure_6.01_B17616.jpg)'
- en: Figure 6.1 – AES in ECB mode
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – ECB 模式下的 AES
- en: 'Oh, nice. At first glance, I see just a bunch of random-looking hexadecimal
    characters jumbled together. A solid encrypted message should be indistinguishable
    from random data, so my work here is done. But, hark! Upon closer inspection,
    a very long string of characters repeats throughout:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，太好了。乍一看，我只看到一堆看起来随机的十六进制字符混杂在一起。一个可靠的加密信息应该无法与随机数据区分，因此我的工作完成了。但等等！仔细一看，确实有一长串字符在整个数据中重复出现：
- en: '![Figure 6.2 – A hex dump reveals a pattern ](image/Figure_6.02_B17616.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 十六进制转储揭示了一个模式](image/Figure_6.02_B17616.jpg)'
- en: Figure 6.2 – A hex dump reveals a pattern
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 十六进制转储揭示了一个模式
- en: You may look at this and think – *So what? You still don’t know what the message
    is*. In the realm of cryptanalysis, this is a major breakthrough. A simple rule
    of thumb about good encryption is that the ciphertext should have no relationship
    whatsoever with the plaintext. In this case, we already know something is repeating.
    The effort to attack the message is already underway.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看着这个想——*那又怎样？你仍然不知道消息是什么。* 在密码分析领域，这是一个重大突破。关于良好加密的简单经验法则是：密文应该与明文完全没有关系。在这个例子中，我们已经知道有些东西在重复。攻击消息的努力已经开始。
- en: Introducing block chaining
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍密码块链
- en: 'With ECB, we were at the mercy of our plaintext because each block has its
    own thing going on. Enter **cipher block chaining** (**CBC**), where we encrypt
    a block just like before – except before we encrypt the next block, we XOR the
    plaintext of the next block with the encrypted output of the previous block, creating
    a logical chain of blocks. I know what the hacker in you is thinking now: *if
    we XOR the plaintext block with the encrypted output of the previous block, what’s
    the XOR input for the first block?* Nothing gets past you. Yes, we need an initial
    value – appropriately called the **initialization vector** (**IV**):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECB 模式下，我们的明文是任凭摆布的，因为每个块都有自己独立的内容。于是有了**密码块链**（**CBC**），我们像以前一样对一个块进行加密——只是，在加密下一个块之前，我们先将下一个块的明文与前一个块的加密输出进行异或操作，创建一个块链。我知道你们这些黑客现在在想什么：*如果我们将明文块与前一个块的加密输出进行异或，那么第一个块的异或输入是什么？*
    你可真不放过任何细节。没错，我们需要一个初始值——恰如其分地被称为**初始化向量**（**IV**）：
- en: '![Figure 6.3 – Cipher block chaining in action ](image/Figure_6.03_B17616.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 密码块链操作](image/Figure_6.03_B17616.jpg)'
- en: Figure 6.3 – Cipher block chaining in action
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 密码块链操作
- en: The concept of an IV reminds me of when clients ask me, *what do you think of
    those password vault apps?* I tell them, they’re pretty great if you need help
    remembering passwords, and certainly better than using the same password for everything
    – but I just can’t shake that creepy feeling I get about the whole kit and caboodle
    depending on that one initial password. With CBC, security is highly reliant on
    that IV.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IV（初始化向量）的概念让我想起了客户问我，*你怎么看那些密码保管箱应用？* 我告诉他们，如果你需要帮助记住密码，它们确实很好，肯定比为所有账户使用相同密码要好——但我总是无法摆脱那种感觉，觉得整个系统都依赖于那个**唯一**的初始密码。使用
    CBC 时，安全性高度依赖于这个 IV。
- en: Setting up your bit-flipping lab
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的比特翻转实验室
- en: With a tiny bit of background out of the way, let’s dive in. We’re going to
    attack a web application to pull off the bit-flipping attack. What’s nice about
    this hands-on demonstration is that you’ll be left with a powerful web app hacking
    lab for your continued study. I bet some of you have worked with the famous **Damn
    Vulnerable Web App** (**DVWA**) before, but recently, I’ve found myself turning
    to the OWASP project Mutillidae II. I like to host Mutillidae II on the XAMPP
    server stack as its initial setup is fast and easy, and it’s a powerful combination;
    however, if you’re comfortable loading it into whatever web server solution you
    have, go for it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了一点背景知识后，我们开始吧。我们将对一个 Web 应用进行攻击，实施比特翻转攻击。这个实践演示的好处在于，你将拥有一个强大的 Web 应用黑客实验室，供你继续学习。我敢打赌，你们中的一些人可能之前接触过著名的**Damn
    Vulnerable Web App**（**DVWA**），但最近，我发现自己开始使用 OWASP 项目 Mutillidae II。我喜欢将 Mutillidae
    II 部署在 XAMPP 服务器堆栈上，因为其初始设置快速且简单，而且它是一个强大的组合；然而，如果你习惯使用你自己的 Web 服务器解决方案，也完全可以。
- en: 'If you’re following my lab, then first, download the XAMPP installer, **chmod**
    it to make it executable, and then run the installer. You can go to [www.apachefriends.org/download.xhtml](https://www.apachefriends.org/download.xhtml)
    to find both current and earlier versions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟着我的实验，那么首先下载 XAMPP 安装程序，**chmod** 使其具有执行权限，然后运行安装程序。你可以访问 [www.apachefriends.org/download.xhtml](https://www.apachefriends.org/download.xhtml)
    来找到当前和早期版本：
- en: '![Figure 6.4 – Installing XAMPP ](image/Figure_6.04_B17616.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 安装 XAMPP](image/Figure_6.04_B17616.jpg)'
- en: Figure 6.4 – Installing XAMPP
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 安装 XAMPP
- en: 'Once this has been installed, you can find **/opt/lampp** on your system. Next,
    we must use **git** to grab the Mutillidae II project from GitHub. We want everything
    in **/opt/lampp/htdocs**, so you can run the **git clone** command there or just
    use **mv** once you’ve grabbed everything:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以在系统上找到**/opt/lampp**。接下来，我们必须使用**git**从 GitHub 获取 Mutillidae II 项目。我们希望将所有内容放在**/opt/lampp/htdocs**，所以你可以在那里运行**git
    clone**命令，或者在获取所有文件后使用**mv**命令：
- en: '![Figure 6.5 – Installing Mutillidae II ](image/Figure_6.05_B17616.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 安装 Mutillidae II ](image/Figure_6.05_B17616.jpg)'
- en: Figure 6.5 – Installing Mutillidae II
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 安装 Mutillidae II
- en: 'We’re almost there, but there’s just one tweak we need to make before we get
    started. By default, no password is set for the root user in MySQL, but Mutillidae’s
    default configuration will try **mutillidae** as the password. It’s easier to
    just make the database configuration agree. So, find the database configuration
    and open it with nano (or your favorite editor) with the **nano /opt/lampp/htdocs/includes/database-config.inc**
    command, find the line where **DB_PASSWORD** is defined, and erase **mutillidae**
    so that the value is null:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们差不多完成了，但在开始之前还有一个调整需要做。默认情况下，MySQL 的 root 用户没有设置密码，但 Mutillidae 的默认配置会尝试使用
    **mutillidae** 作为密码。更直接的方法是让数据库配置匹配。找到数据库配置文件，并使用 **nano /opt/lampp/htdocs/includes/database-config.inc**
    命令打开它（或使用你喜欢的编辑器），找到定义 **DB_PASSWORD** 的那一行，删除 **mutillidae**，使该值为空：
- en: '![Figure 6.6 – Configuring the database ](image/Figure_6.06_B17616.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 配置数据库 ](image/Figure_6.06_B17616.jpg)'
- en: Figure 6.6 – Configuring the database
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 配置数据库
- en: 'At long last, we can start up XAMPP. Run **./lampp start**, grab a browser,
    and head on over to localhost:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，我们可以启动 XAMPP 了。运行 **./lampp start**，拿起浏览器，前往 localhost：
- en: '![Figure 6.7 – Starting up XAMPP ](image/Figure_6.07_B17616.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 启动 XAMPP ](image/Figure_6.07_B17616.jpg)'
- en: Figure 6.7 – Starting up XAMPP
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 启动 XAMPP
- en: 'When you first visit the page, you’ll probably see an error that says your
    database server is offline. The very first option below this error is a link that
    says, *Click here to attempt to set up the database*. Click that link, click **OK**,
    and the Mutillidae home page will load. Once you reach the home page, you must
    make some final tweaks: click **Toggle Security** so that you can enable client-side
    security, click **Toggle Hints** (when the option is visible) to disable hints,
    and then click **Enforce TLS** so that we can work with a more realistic target
    environment. (Keep in mind that your browser will warn you about the self-signed
    certificate; accept the risk and continue.) Now, take a breath and grab some coffee
    – we can start playing with our new toy.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次访问该页面时，可能会看到一个错误，提示你的数据库服务器离线。这个错误下方的第一个选项是一个链接，写着 *点击这里尝试设置数据库*。点击该链接，再点击
    **确定**，Mutillidae 首页将加载。进入首页后，你需要进行一些最后的调整：点击 **Toggle Security** 以启用客户端安全性，点击
    **Toggle Hints**（当该选项可见时）以禁用提示，然后点击 **Enforce TLS**，这样我们就可以在一个更真实的目标环境中进行工作。（记住，浏览器会警告你自签名证书的风险；接受风险并继续。）现在，深呼吸，喝口咖啡——我们可以开始玩我们的新玩具了。
- en: Manipulating the IV to generate predictable results
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操控 IV 以生成可预测的结果
- en: Navigate to OWASP 2017 on the left, then **Injection** | **Other**, and then
    **CBC Bit Flipping**. So, let’s get acquainted. Here, we’re currently running
    with **User ID** **174** with **Group ID** **235**. We need to be user **000**
    in group **000** to become the almighty root user. The site is protected with
    SSL, so intercepting the traffic in transit would be a bit of a pain. What else
    do you notice about this site?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航至 OWASP 2017，然后选择 **Injection** | **Other**，再选择 **CBC Bit Flipping**。那么，我们来了解一下。此时，我们正在使用
    **用户 ID** **174** 和 **组 ID** **235**。为了成为万能的 root 用户，我们需要将用户更改为 **000**，组更改为 **000**。该网站使用
    SSL 保护，因此拦截传输中的流量会有点麻烦。你还注意到这个网站的其他情况吗？
- en: How about the URL itself? That is, **https://127.0.0.1/index.php?page=view-user-privilege-level.php&iv=6bc24fc1ab650b25b4114e93a98f1eba**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 URL 呢？即，**https://127.0.0.1/index.php?page=view-user-privilege-level.php&iv=6bc24fc1ab650b25b4114e93a98f1eba**。
- en: Oh my – it’s an IV field, right there for the taking. We’ve seen how the IV
    is XOR with the plaintext before encryption to create the encrypted block, so
    manipulating the IV would necessarily change the encrypted output. First, let’s
    take a look at the IV itself: **6bc24fc1ab650b25b4114e93a98f1eba**. We know that
    it’s hexadecimal and it’s 32 characters long; thus, the length is 128 bits.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，原来是一个 IV 字段，就在那里等着我们。我们已经看到，IV 会与明文进行异或运算，在加密前创建加密块，因此操作 IV 必然会改变加密输出。首先，让我们来看一下这个
    IV 本身：**6bc24fc1ab650b25b4114e93a98f1eba**。我们知道它是十六进制的，长度为 32 个字符；因此，长度为 128 位。
- en: Remember when we experimented with CBC encryption with **openssl**? We used
    AES, which always has a 128-bit block size. Considering our IV is 128 bits long,
    the application may be AES-encrypting a single block of data, which would make
    it the first (and only) block, so CBC requires an IV. Remember that any plaintext
    block that’s shorter than the algorithm’s block size must be padded. Note what
    happens to the user data when you try changing the bytes at the end of the IV.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们用**openssl**实验CBC加密吗？我们使用了AES，AES的块大小始终是128位。考虑到我们的IV长度是128位，应用程序可能正在对单个数据块进行AES加密，这样它就是第一个（也是唯一的）数据块，因此CBC需要IV。请记住，任何比算法块大小短的明文块都必须进行填充。注意当你尝试改变IV末尾字节时，用户数据会发生什么。
- en: 'We can sit here analyzing all day but by now, you’ve probably figured out I
    like breaking things, so let’s modify the IV in the URL, submit it, and see if
    anything happens. I’m changing the initial character into a zero, making the IV
    **0bc24fc1ab650b25b4114e93a98f1eba**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以坐在这里分析一整天，但到现在你可能已经发现我喜欢破坏东西，所以我们来修改URL中的IV，提交它，看看会发生什么。我将初始字符改为零，使IV变为**0bc24fc1ab650b25b4114e93a98f1eba**：
- en: '![Figure 6.8 – Tweaking the IV ](image/Figure_6.08_B17616.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 调整IV](image/Figure_6.08_B17616.jpg)'
- en: Figure 6.8 – Tweaking the IV
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 调整IV
- en: Our IDs didn’t change, but check out what happened to the **Application ID**
    value. Now, it’s **!1B2**. It used to be **A1B2**. What if I change the first
    two hexadecimal digits to zeros? Our **Application ID** is now ***1B2**. If I
    change the first three, then the next character in the **Application ID** value
    falls apart because the resulting binary doesn’t have an ASCII representation.
    Now, we know that the first two hexadecimal characters in the IV (8 bits) modify
    the first ASCII character in the **Application ID** value (8 bits). This is a
    breakthrough that pretty much translates into the final stretch to privilege escalation
    because we’ve just established a direct relationship between the plaintext and
    the IV, which means we can figure out the ciphertext. And when we know two of
    the three, in any order, we can calculate the third by using simple binary XOR
    math. Now, we haven’t found the hexadecimal digits where the **User ID** and **Group
    ID** values can be manipulated just yet, but let’s take a quick break to see if
    we can figure out this relationship based on what we have so far.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ID没有变化，但看看**应用程序ID**值发生了什么。现在，它是**!1B2**。之前是**A1B2**。如果我将前两个十六进制数字改为零，会发生什么？我们的**应用程序ID**现在是***1B2**。如果我改动前三个，那么**应用程序ID**中的下一个字符就会崩溃，因为得到的二进制值没有ASCII表示。现在，我们知道IV中的前两个十六进制字符（8位）修改了**应用程序ID**值中的第一个ASCII字符（8位）。这是一个突破，几乎意味着特权提升的最后一程，因为我们刚刚建立了明文和IV之间的直接关系，这意味着我们可以解密密文。而当我们知道三个值中的两个时，不管顺序如何，我们都可以通过简单的二进制XOR运算算出第三个值。现在，我们还没有找到可以操作**用户ID**和**组ID**值的十六进制数字，但我们先休息一下，看看是否能根据已有的信息找出这个关系。
- en: 'We saw the **Application ID** value change from **A** to **!** to *****. Thus,
    the ID is represented in ASCII, the most common modern standard for character
    encoding. What’s important to us here is that a single ASCII character is 8 bits
    (1 byte) long. Hexadecimal, on the other hand, is simply a base 16 numeral system.
    We see hexadecimal everywhere in the gritty underbelly of computing because 16
    is a power of 2, which means converting from base 2 (that is, binary) to base
    16 is easy as pie. (How is pie easy? Never mind, I digress.) 2 to the power of
    4 equals 16, which means a hexadecimal digit is 4 bits long. Now, let’s get back
    to our lab:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到**应用程序ID**值从**A**变为**!**，然后变成了*****。因此，ID是用ASCII表示的，这是现代字符编码中最常见的标准。这里对我们重要的是，单个ASCII字符是8位（1字节）长。另一方面，十六进制仅仅是一个基数16的数字系统。我们在计算机的“肮脏底层”到处都能看到十六进制，因为16是2的幂，这意味着从二进制（也就是基数2）转换到十六进制非常容易。
    （怎么说“派”很容易呢？算了，我跑题了。）2的4次方等于16，这意味着一个十六进制数字是4位长。现在，让我们回到实验室：
- en: '![Table 6.1](image/Table_6.1_B17616.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![表6.1](image/Table_6.1_B17616.jpg)'
- en: Do you see our golden ticket yet? Well, let’s XOR the binary IV values with
    the known binary ASCII result in the **Application ID** value. If they match,
    then we have the value that was XORed with the IV values to generate the **Application
    ID** value. Remember, if we know two out of three, we know the third.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了我们的金色票据了吗？好吧，让我们将二进制IV值与**应用程序ID**值中的已知二进制ASCII结果进行XOR运算。如果它们匹配，那么我们得到了与IV值进行XOR运算生成**应用程序ID**值的那个值。记住，如果我们知道三个中的两个，就可以知道第三个。
- en: 'First, let’s look at the original IV:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看原始的IV：
- en: Hexadecimal **6b**: **0110 1011**
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '十六进制 **6b**: **0110 1011**'
- en: ASCII **A**: **0100 0001**
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ASCII **A**: **0100 0001**'
- en: XOR result: **0010 1010**
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'XOR 结果: **0010 1010**'
- en: 'Now, let’s look at our test manipulated IV:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们测试过的IV：
- en: Hexadecimal **00**:  **0000 0000**
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '十六进制 **00**: **0000 0000**'
- en: ASCII *****: **0010 1010**
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ASCII *****: **0010 1010**'
- en: XOR result: **0010 1010**
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'XOR 结果: **0010 1010**'
- en: 'And that, my friends, is why they call it bit-flipping. We figured out that
    the application is taking this byte of the IV and XORing it with **0010 1010**
    during decryption. Let’s test our theory by calculating what we’ll get if we replace
    the first two hexadecimal digits with, say, **45**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是，朋友们，为什么他们叫它位翻转。我们发现应用程序正在将IV中的这一字节与**0010 1010**进行XOR运算，发生在解密过程中。让我们通过计算，如果我们将前两个十六进制数字替换为**45**，会得到什么，来验证我们的理论：
- en: Hexadecimal **45**: **0100 0101**
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '十六进制 **45**: **0100 0101**'
- en: Ciphertext XOR: **0010 1010**
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '密文 XOR: **0010 1010**'
- en: Binary result: **0110 1111**
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '二进制结果: **0110 1111**'
- en: '**01101111** encodes to an ASCII **o** (lowercase **O**). So let’s test our
    theory and see if we end up with an **Application ID** of **o1B2**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**01101111** 编码为 ASCII **o**（小写字母**O**）。所以让我们验证一下我们的理论，看看是否最终会得到一个 **Application
    ID** 为 **o1B2**：'
- en: '![Figure 6.9 – Confirming our control over the Application ID property ](image/Figure_6.09_B17616.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 确认我们对应用程序ID属性的控制](image/Figure_6.09_B17616.jpg)'
- en: Figure 6.9 – Confirming our control over the Application ID property
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 确认我们对应用程序ID属性的控制
- en: Doesn’t that just get your blood pumping? This is an exciting breakthrough,
    but we just picked up on some behind-the-scenes mechanisms; we still aren’t root.
    So, let’s get to work on finding the bits we need to flip.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不会让你血脉喷张吗？这是一个令人兴奋的突破，但我们只是意识到了一些幕后机制；我们还不是root。所以，接下来让我们开始寻找需要翻转的位。
- en: Flipping to root – privilege escalation via CBC bit-flipping
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转到根目录 – 通过CBC位翻转实现特权提升
- en: You probably thought we could just step through hex pair by hex pair until we
    find the right spot and flip our way to victory. Not exactly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以为我们可以通过一个个十六进制对的方式逐步操作，直到找到正确的位置并翻转取得胜利。其实并不完全是这样。
- en: 'The way the **User ID** and **Group ID** values are encoded is a little funky,
    and there’s a different piece of ciphertext being XORed against when we work our
    way down the IV. So, at this point, it’s pure trial and error while relying on
    the hints we’ve already gathered. As I worked this one out, I took some notes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户ID**和**组ID**的编码方式有些奇怪，并且在我们向下处理IV时，有不同的密文被用来进行XOR操作。所以，在这一点上，完全是依赖我们已经收集到的线索进行反复试验。当我解决这个问题时，我做了一些笔记：'
- en: '![Figure 6.10 – A chart to link ciphertext to ID output ](image/Figure_6.10_B17616.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 用图表将密文与ID输出联系起来](image/Figure_6.10_B17616.jpg)'
- en: Figure 6.10 – A chart to link ciphertext to ID output
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 用图表将密文与ID输出联系起来
- en: 'It’s a little tedious, but I only needed to play with a few characters to understand
    what’s going on here. I discovered two main points:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点繁琐，但我只需要玩弄几个字符就能理解这里发生了什么。我发现了两个主要点：
- en: Though each position is 8 bits, only modifying the final 4 bits would change
    the **User ID**/**Group ID** value in that position. For example, I noted that
    when I replaced the two hexadecimal characters in a position with **00**, the
    result broke (that is, the resulting binary value isn’t ASCII-friendly).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然每个位置都是8位，但只修改最后4位就会改变该位置的**用户ID**/**组ID**值。例如，我注意到当我将一个位置的两个十六进制字符替换为**00**时，结果会崩溃（即结果的二进制值不适合ASCII编码）。
- en: I go and do the XOR calculation on the trailing 4 bits of each byte to find
    the key that I need and discover the value isn’t the same for all positions.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我对每个字节的后4位进行XOR计算，以找到我需要的密钥，并发现该值在所有位置并不相同。
- en: 'The hacker in you was already expecting unique XOR values for each character,
    right? The stream of bits that’s being XORed with the IV wouldn’t be a byte-long
    repeating pattern. The effort to discover these values pays off, though, because
    all we have to do now is calculate the XOR for each position: if we XOR the hexadecimal
    character in the IV with the hexadecimal of the **User ID**/**Group ID** value
    in that position, the result will be the enciphered bits at that position. And
    since we’re looking for all zeroes, the result for each position is the binary
    equivalent of the hexadecimal character we need to put in the IV instead of the
    original.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你是不是已经期待每个字符都有独特的XOR值了？与IV进行XOR运算的位流不会是一个字节长的重复模式。尽管如此，发现这些值的努力还是值得的，因为现在我们所需要做的就是计算每个位置的XOR：如果我们将IV中的十六进制字符与该位置上**用户ID**/**组ID**值的十六进制进行XOR运算，结果将是该位置的加密位。由于我们在寻找所有零，
    所以每个位置的结果就是我们需要放入IV中的十六进制字符，而不是原始字符。
- en: 'Let’s translate that conclusion with an example from the IV: position **09**
    is **b4**, which corresponds to the middle digit in the **Group ID** value, which
    is **3**. Hexadecimal **4** in binary is **0100** and hexadecimal **3** is **0011**. 
    **0100** XOR **0011** equals **0111**. **0111** is the binary equivalent of **7**,
    which means we would replace **b4** with **b7** to get a **0**.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用IV中的一个例子来解释这个结论：位置**09**是**b4**，它对应于**组ID**值中的中间数字**3**。十六进制**4**的二进制是**0100**，十六进制**3**的二进制是**0011**。**0100**
    XOR **0011**等于**0111**。**0111**是**7**的二进制等效值，这意味着我们将**b4**替换为**b7**，得到**0**。
- en: 'Now, I must repeat this calculation for all six positions and learn what I
    needed: the byte-long IV positions **05** through **10** correspond to the **User
    ID** and **Group ID** values, respectively, and the final 4 bits of each position
    need to be replaced with the hexadecimal values of (in order) **a2f774** to get
    root. Position **05** in the original IV was **ab**, so it becomes **aa**; position
    **06** was **65**, so it becomes **62**; and so on.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我必须对所有六个位置重复这个计算，并学到我需要的信息：字节长的IV位置**05**到**10**分别对应**用户ID**和**组ID**值，而每个位置的最后4位需要用（按顺序）**a2f774**的十六进制值替换以获得root。原始IV中的位置**05**是**ab**，所以它变成了**aa**；位置**06**是**65**，所以它变成了**62**；依此类推。
- en: 'Thus, the IV from the 5th byte to the 10th changes from **ab650b25b411** to **aa620f27b714**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，IV从第5字节到第10字节的变化从**ab650b25b411**变为**aa620f27b714**：
- en: '![Figure 6.11 – Correlating IV byte position with the IDs ](image/Figure_6.11_B17616.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 关联IV字节位置与ID](image/Figure_6.11_B17616.jpg)'
- en: Figure 6.11 – Correlating IV byte position with the IDs
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 关联IV字节位置与ID
- en: 'The moment of truth: I am going to change the IV from **6bc24fc1ab650b25b4114e93a98f1eba**
    to **6bc24fc1aa620f27b7144e93a98f1eba**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 真相时刻：我要将IV从**6bc24fc1ab650b25b4114e93a98f1eba**改为**6bc24fc1aa620f27b7144e93a98f1eba**：
- en: '![Figure 6.12 – Full control over the User and Group ID values ](image/Figure_6.12_B17616.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 完全控制用户和组ID值](image/Figure_6.12_B17616.jpg)'
- en: Figure 6.12 – Full control over the User and Group ID values
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 完全控制用户和组ID值
- en: Now that we’ve played with encryption, let’s take a look at cryptographic hashes
    and the clues they leave for us hackers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们玩了加密，让我们看看加密哈希以及它们为我们黑客留下的线索。
- en: Sneaking your data in – hash length extension attacks
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据潜入 – 哈希长度扩展攻击
- en: As you may recall from our brief introduction to hashes in [*Chapter 4*](B17616_04_Final_VK_ePub.xhtml#_idTextAnchor064),
    *Windows Passwords on the Network*, hashing isn’t encryption. An encrypted message
    can be decrypted into a readable message. A cryptographic hash, on the other hand,
    has no plaintext representation; it cannot be reversed. However, a particular
    input sent through a particular hashing algorithm will always result in the same
    hash output (called a one-way function). This makes hashing algorithms useful
    for integrity checks, as even a slight change to the input produces a radically
    different hash output. However, let’s consider the fact that a hash’s output is
    a fixed length, regardless of the message being hashed; for long messages, the
    hash function is done in rounds on blocks of message data, over and over until
    the entire message is hashed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，在我们简要介绍的 [*第4章*](B17616_04_Final_VK_ePub.xhtml#_idTextAnchor064)，*网络上的
    Windows 密码*，哈希并不是加密。加密消息可以被解密为可读的消息。而加密哈希，则没有明文表示；它无法被逆向。尽管如此，通过特定哈希算法处理的特定输入将始终产生相同的哈希输出（称为单向函数）。这使得哈希算法在完整性检查中非常有用，因为即使输入有微小变化，也会产生完全不同的哈希输出。然而，我们要考虑到哈希的输出是固定长度的，无论被哈希的消息多长；对于较长的消息，哈希函数是在消息数据的块上轮流进行的，一直到整个消息都被哈希完。
- en: With the result depending on all of the previous inputs, we could – in theory
    – add blocks to the message, and the data that was used as input to the next round
    would be the same as if the whole operation had ended on that last block. We’ll
    leverage that juicy tidbit to attack message authentication mechanisms with hash
    length extension attacks, with length extension referring to the fact that we’re
    adding our chosen data to the end of the message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果依赖于所有之前的输入，我们理论上可以向消息中添加数据块，并且用于下一轮的数据将与整个操作在最后一个数据块结束时的情况相同。我们将利用这一点来通过哈希长度扩展攻击攻击消息认证机制，长度扩展指的是我们将自己选择的数据添加到消息的末尾。
- en: This is a little more sophisticated than our bit-flipping adventure, so we’re
    going to introduce the inimitable web application testing framework Burp Suite
    to give us a bird’s-eye view. Burp Suite is powerful enough for it to be covered
    in several chapters, but in this demonstration, we’re going to set it up as a
    local proxy so that we can see and easily manipulate HTTP traffic in transit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们的位翻转冒险要复杂一些，所以我们将引入无与伦比的 Web 应用程序测试框架 Burp Suite，以便让我们俯瞰整个局面。Burp Suite
    强大到足以被涵盖在好几个章节中，但在本次演示中，我们将它设置为本地代理，以便能够查看并轻松地操作正在传输的 HTTP 流量。
- en: Setting up your hash attack lab
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的哈希攻击实验室
- en: Another great vulnerable web app to have in your repertoire is CryptOMG. If
    you’re following along with how I did it, it’s the same procedure here – install
    XAMPP, download and extract the contents of the CryptOMG ZIP file to the **htdocs**
    folder, and then run **./lampp start**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的脆弱 Web 应用程序是 CryptOMG。如果你跟着我之前的做法，它的步骤是一样的——安装 XAMPP，下载并解压 CryptOMG ZIP
    文件的内容到 **htdocs** 文件夹，然后运行 **./lampp start**。
- en: In with the Old
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版的开始
- en: Unlike Mutillidae II, CryptOMG isn’t being actively supported anymore and it
    depends on an older version of PHP. Therefore, you’ll need to dig into the older
    XAMPP installers on the Apache Friends website. It’s an intentionally vulnerable
    lab, so this doesn’t affect the details of the underlying vulnerability, which
    is still surprisingly common in internal assessments against dedicated appliances
    and home-grown applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Mutillidae II 不同，CryptOMG 不再被积极支持，并且它依赖于较旧版本的 PHP。因此，你需要访问 Apache Friends
    网站上的旧版本 XAMPP 安装程序。它是一个故意设计为脆弱的实验室，因此这不会影响底层漏洞的细节，这种漏洞在针对专用设备和自家开发的应用程序进行内部评估时依然出奇常见。
- en: 'The attack tool we’ll use for this demonstration, hash_extender, is worth keeping
    on your Kali installation for future use. Other tools can be used for the task
    (notably HashPump), but I prefer hash extender’s ease of use and integration into
    other tasks. The easiest way to get it running on Kali is by installing it with
    **git**. Note that we’re also making sure that the SSL development toolkit is
    installed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本次演示中使用的攻击工具，hash_extender，值得在你的 Kali 安装中保留以供将来使用。其他工具也可以用于该任务（特别是 HashPump），但我更喜欢
    hash_extender 的易用性以及它与其他任务的集成。最简单的在 Kali 上运行它的方法是通过 **git** 安装。请注意，我们还需要确保 SSL
    开发工具包已经安装：
- en: git clone https://github.com/iagox86/hash_extender
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git clone https://github.com/iagox86/hash_extender
- en: apt-get update && apt-get install libssl-dev
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt-get update && apt-get install libssl-dev
- en: cd hash_extender && make
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cd hash_extender && make
- en: Fire up the tool with no parameters with **./hash_extender** and get acquainted.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**./hash_extender**启动工具，无需任何参数，先熟悉一下。
- en: Understanding SHA-1’s running state and compression function
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SHA-1的运行状态和压缩函数
- en: In our browser window, let’s pick **Challenge 5** (gain access to **/etc/passwd**),
    change the algorithm to SHA-1, click **save**, and then click on **test**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的浏览器窗口中，选择**挑战5**（获取**/etc/passwd**的访问权限），将算法改为SHA-1，点击**保存**，然后点击**test**。
- en: 'Well, I don’t see much happening here. But that URL sure looks interesting.
    Check out the parameters visible to us (and, apparently, under our control): **http://127.0.0.1/ctf/challenge5/index.php?algo=sha1&file=test&hash=dd03bd22af3a4a0253a66621bcb
    80631556b100e**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我在这里没看到什么变化。但那个URL看起来很有趣。查看一下我们能看到的（显然是我们控制的）参数：**http://127.0.0.1/ctf/challenge5/index.php?algo=sha1&file=test&hash=dd03bd22af3a4a0253a66621bcb80631556b100e**。
- en: Clearly, **algo=sha1** is defining the algorithm we selected. But **file=test**
    and the **hash** field should be catching our attention, as they appear to work
    as a message authentication code mechanism for authorizing access to the file
    called **test**. If I modify the hash right now, I will get a **File Not Found**
    error. Let’s do a quick review of how this works before we conduct the attack.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，**algo=sha1**定义了我们选择的算法。但是**file=test**和**hash**字段应该引起我们的注意，因为它们看起来像是用于授权访问名为**test**的文件的消息认证码机制。如果我现在修改哈希值，我将收到**文件未找到**的错误。在我们进行攻击之前，先快速回顾一下它是如何工作的。
- en: In our example, access to the **test** file is authenticated with the attached
    hash. You might be thinking, *what good is that? All the signature will tell me
    is that no one modified the name of the file*. Well, unless we attach a secret
    to the message, in which case, we’re hashing the **secret + message**. Surely,
    based on what we know about hashes, only the **secret + message** would produce
    the correct hash. Hash functions are one-way functions, so it’s impossible to
    reverse and find the secret. We want to inject our data, so we must perform a
    directory traversal attack to obtain **/etc/passwd**; that is, request a file
    and provide a valid hash to validate the request. This seems impossible on the
    surface, but we’re missing two crucial mechanisms that are built into the hashing
    algorithm – padding and initial hash values (also called **registers**).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，访问**test**文件需要通过附加的哈希进行身份验证。你可能会想，*那有什么用呢？所有签名能告诉我的是文件的名字没有被修改*。好吧，除非我们在消息中附加了一个密钥，在这种情况下，我们要哈希的是**密钥
    + 消息**。根据我们对哈希的理解，只有**密钥 + 消息**才能生成正确的哈希。哈希函数是单向函数，因此无法逆向求解密钥。我们想要注入我们的数据，因此必须执行目录遍历攻击来获取**/etc/passwd**；也就是说，请求一个文件并提供一个有效的哈希来验证请求。表面上看，这似乎是不可能的，但我们忽略了两个关键机制，它们内置在哈希算法中——填充和初始哈希值（也称为**寄存器**）。
- en: 'SHA-1 is iterative. It takes a message and splits it into 512-bit blocks of
    data, and then applies a compression function to each block. There are two inputs
    to each round of the compression function: the 160-bit hash from the previous
    round, and the next 512-bit block of message data. I can hear you shouting at
    this book, *so, does that mean there’s an initialization vector?* Yes, there is.
    What’s interesting about SHA algorithms is that their initial hash value (IV)
    is standardized and fixed. In the case of SHA-1, the initial hash value is **67452301efcdab8998badcfe10325476c3d2e1f0**.
    With 3.97 bits of entropy, it’s a good random number (but of course, since it’s
    standardized, it isn’t random – the entire world knows it). That initial hash
    value is split into five 32-bit chunks. During the hashing process, the five chunks
    are stored in registers (H0 to H4). These values are known as the **running state**.
    When the whole message has been processed and the final block’s compression function
    has spat out the final 160-bit running state, that value is the actual SHA-1 hash
    for the whole message.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1是迭代的。它将消息拆分成512位的数据块，然后对每个数据块应用压缩函数。每轮压缩函数有两个输入：来自前一轮的160位哈希值，以及下一个512位的消息数据块。我能听到你在对着这本书喊，*那是不是意味着有初始化向量？*
    是的，确实有。SHA算法有一个有趣的特点，它们的初始哈希值（IV）是标准化且固定的。在SHA-1中，初始哈希值是**67452301efcdab8998badcfe10325476c3d2e1f0**。它有3.97位的熵，算是一个不错的随机数（但当然，由于它是标准化的，所以并不是随机的——全世界都知道它）。这个初始哈希值被拆分为五个32位的块。在哈希过程中，这五个块被存储在**寄存器**（H0到H4）中。这些值被称为**运行状态**。当整个消息处理完毕，最后一个数据块的压缩函数输出了最终的160位运行状态时，这个值就是整个消息的实际SHA-1哈希值。
- en: Simply put, whenever you see an SHA-1 hash, you’re seeing the final running
    state for the final 512-bit block of message data. The compression function took
    the previous running state as one of the inputs, going back to the beginning of
    the message and the specification-defined initial hash value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每当你看到一个 SHA-1 哈希值时，你看到的就是消息数据最终 512 位区块的最终运行状态。压缩函数将之前的运行状态作为输入之一，回到消息的起始部分和规范定义的初始哈希值。
- en: 'So, why do we care about all these nifty details? The key to how the length
    extension attack works is that the SHA-1 hash isn’t just the output of the entire
    operation; it’s the running state at that point in the hashing process. Suppose
    the hash process were to continue with another block of message data; the running
    state at the penultimate block would be exactly what we can see here. That running
    state came from the output of the last compression function, which itself took
    in the previous running state, and so on – until we’re back at the initial hash
    value as the 160-bit input and the first block of message data as the 512-bit
    input, which contains the unknown secret! First, we’ll create a new message with
    the attacker’s data on the end, plus whatever padding is needed to get us to a
    512-bit block. Then, we’ll take the original hash as the running state input to
    the compression function for the last block so that we end up with a new hash
    that fundamentally derives from the first secret block. We will never find out
    what the secret is, and we don’t have to – its DNA is built into the numbers we
    do have:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要关注这些细节呢？长度扩展攻击之所以有效的关键在于，SHA-1 哈希不仅仅是整个操作的输出；它是哈希过程中的一个运行状态。假设哈希过程继续进行，处理下一个消息数据区块；倒数第二个区块的运行状态正是我们在这里看到的内容。这个运行状态来自于上一个压缩函数的输出，而这个压缩函数本身也会接收前一个运行状态作为输入，依此类推——直到我们回到初始哈希值作为
    160 位输入，第一块消息数据作为 512 位输入，其中包含未知的秘密！首先，我们将创建一个新的消息，在末尾加入攻击者的数据，并加上填充以满足 512 位区块的要求。然后，我们将使用原始哈希作为压缩函数的运行状态输入，以处理最后一个区块，最终我们将得到一个新的哈希，它从第一个秘密区块中派生出来。我们永远不会知道秘密是什么，而且我们也不需要知道——它的“DNA”已经被嵌入到我们拥有的数字中。
- en: '![Figure 6.13 – The SHA-1 algorithm in action ](image/Figure_6.13_B17616.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – SHA-1 算法的实际应用](image/Figure_6.13_B17616.jpg)'
- en: Figure 6.13 – The SHA-1 algorithm in action
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – SHA-1 算法的实际应用
- en: 'I know what the hacker in you is saying at this point: *since the final block
    will have padding, we don’t know the length of the padding without knowing the
    length of the secret; therefore, we can’t slip our data in without knowledge of
    the secret’s length*. True, but elementary, Watson! We will rely on one of the
    most powerful, dangerous, mind-blowing hacking techniques known to mankind – we’ll
    just guess. The secret can’t be just any length; it has to fit in the block. This
    limits our guessing, making this feasible. But let’s make life a little easier
    by using Burp Suite to send the guesses.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道此时你心中的黑客在说：*由于最终区块会有填充，我们在不知道秘密长度的情况下无法得知填充长度；因此，我们无法在不了解秘密长度的情况下注入数据*。没错，但这太简单了，华生！我们将依赖于人类已知的最强大、最危险、最令人震惊的黑客技术之一——我们只需要猜测。秘密的长度不可能是任意的；它必须适应区块的大小。这限制了我们的猜测范围，使其变得可行。但为了让生活稍微轻松一点，我们可以使用
    Burp Suite 来发送这些猜测。
- en: Data injection with the hash length extension attack
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哈希长度扩展攻击进行数据注入
- en: 'Back to our demonstration. You may recall that the name of the file is **test**.
    This means that **test** is the actual data, and thus the 512-bit input to the
    compression function was made up of a secret, test, and padding. All we need to
    tell hash extender is the current hash, the original data, the range of byte length
    guesses for the secret, and the data we want to inject – it will do the rest by
    spitting out a hash for each guess. Then, we can construct a URL with our attacker
    data as the filename, as well as our new hash – if we get the length of the secret
    right, then our hash will pass validation. Let’s check out the command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的演示。你可能还记得文件的名称是**test**。这意味着**test**才是实际数据，因此，512位的压缩函数输入由一个秘密、test和填充组成。我们只需要告诉哈希扩展器当前的哈希值、原始数据、秘密长度猜测的字节范围，以及我们想要注入的数据——它会为每个猜测生成一个哈希值。然后，我们可以构建一个包含我们的攻击者数据作为文件名以及我们新的哈希的
    URL——如果我们正确猜出了秘密的长度，那么我们的哈希将通过验证。让我们看一下命令：
- en: ./hash_extender --data=test --signature=dd03bd22af3a4a0253a66621bcb80631556b100e
    --append=../../../../../../../etc/passwd --format=sha1 --secret-min=8 --secret-max=50
    --table --out-data-format=html > HashAttackLengthGuesses.txt
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ./hash_extender --data=test --signature=dd03bd22af3a4a0253a66621bcb80631556b100e
    --append=../../../../../../../etc/passwd --format=sha1 --secret-min=8 --secret-max=50
    --table --out-data-format=html > HashAttackLengthGuesses.txt
- en: 'The following terms were used in the preceding command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令中使用的术语：
- en: '**--data** defines the data that’s being validated. In the terminology we’ve
    been using so far, this would be our message when referring to **secret + message**.
    Remember, hash_extender is assuming that we know the data that’s being validated
    (in this case, the name of the file to be accessed); by definition, we don’t know
    anything about the secret. The only thing we hope to learn is the length of the secret,
    but that’s after trial and error.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--data** 定义了正在验证的数据。在我们之前使用的术语中，这就是我们在提到**secret + message**时所指的消息。请记住，hash_extender
    假设我们知道正在验证的数据（在这种情况下，是要访问的文件名）；按定义，我们对**secret**一无所知。我们唯一希望了解的是**secret**的长度，但这得通过反复试验来确定。'
- en: '**--signature** is the other part of the known parameters: the hash that we
    know correctly validates the unmodified message. Remember, we need to provide
    the running state that would be used as input to our next compression function
    round.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--signature** 是已知参数的另一部分：我们知道能够正确验证未修改消息的哈希。记住，我们需要提供将作为下一轮压缩函数输入的运行状态。'
- en: '**--append** is the data we’re sneaking in under the door. This is what is
    going to be retrieved, and what our specially generated attack hash is validating.
    For our attack, we’re trying to nab the **passwd** file from **etc**. We’re using
    the handy **../../../** to climb out of wherever we are in the filesystem back
    to **/**, and then jumping into **/etc/passwd**. Keep in mind that the number
    of jumps through parent folders is unknown since it would depend on the specific
    implementation of this web application, so I’m throwing out a guess for now. I’ll
    know later if I need to fix it. You don’t need a valid path to find the new hash!'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--append** 是我们悄悄塞进门下的数据。这是将被检索的数据，也是我们特别生成的攻击哈希正在验证的内容。在我们的攻击中，我们试图获取**etc**目录下的**passwd**文件。我们使用方便的**../../../**从当前文件系统路径返回到根目录**/**，然后跳转到**/etc/passwd**。请记住，通过父文件夹的跳转次数是未知的，因为它取决于这个
    Web 应用程序的具体实现，因此我现在先猜测一下。如果需要修改，我之后会知道的。你不需要有效路径来找到新的哈希！'
- en: '**--format** is the hash algorithm. You can know this for a fact, or perhaps
    you need to guess based on the length of the hash; this may also require some
    trial and error.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--format** 是哈希算法。你可以通过哈希长度来确定这个算法，或者可能需要通过一些试验和错误来猜测。'
- en: '**--secret-min** and **--secret-max** specify the range of secret length guesses
    in bytes. The individual circumstances of your test may require this to be used
    very carefully – for example, I’m using a pretty wide range here because I’m in
    my lab, planning on using Burp Suite and Intruder, and I know the web app doesn’t
    defend against rapid-fire requests. Some systems may lock you out! You may need
    to take the results and just punch in URLs manually, like in the good old days.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--secret-min** 和 **--secret-max** 指定了**secret**长度猜测的范围，以字节为单位。你的测试的具体情况可能要求你非常小心地使用这个范围——例如，我这里使用了一个相当宽的范围，因为我在实验室中，打算使用
    Burp Suite 和 Intruder，并且我知道该 Web 应用程序无法防御快速的请求。一些系统可能会把你锁定！你可能需要手动输入 URL，就像过去那样。'
- en: '**--table** is going to make our results look pretty by organizing them in
    a table format.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--table** 将通过将结果按表格格式组织起来，使我们的结果更加美观。'
- en: '**--out-data-format** is handy for situations where a system is expecting data
    in, for example, hexadecimal format. In our case, we would like the HTML output
    as we’re just going to feed this information into web requests.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--out-data-format** 在系统期望数据以例如十六进制格式呈现的情况下非常有用。在我们的案例中，我们希望以 HTML 格式输出，因为我们只是打算将这些信息输入到
    Web 请求中。'
- en: Finally, I told Linux to dump the output into a text file.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我让 Linux 将输出内容保存到一个文本文件中。
- en: Go ahead and take a peek at the result. You’ll see it’s a list of hashes lined
    up with the data we hope to inject; each line will have a different amount of
    padding as it is associated with a particular guess of the secret length. The
    wider the range you defined for **secret-min** and **secret-max**, the more lines
    you’ll have here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 继续查看结果。你会看到它是一个哈希值列表，和我们希望注入的数据排成一行；每一行会有不同数量的填充字符，具体取决于猜测的**secret**长度。你为**secret-min**和**secret-max**定义的范围越大，这里就会有更多的行。
- en: Now, I can fire up Burp Suite, which creates a local HTTP proxy on port **8080**
    by default. When I’m ready to let Burp Suite in on the action, I must configure
    my browser’s network settings to talk to my proxy at **127.0.0.1:8080**. Then,
    I must click the **test** link again on the CryptOMG page to create a new **GET**
    request to be intercepted by Burp Suite. When I see it, I must right-click on
    it and send it to Intruder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以启动Burp Suite，它默认在端口**8080**上创建一个本地HTTP代理。当我准备好让Burp Suite参与其中时，我必须配置浏览器的网络设置，将其连接到我的代理**127.0.0.1:8080**。然后，我必须再次点击CryptOMG页面上的**test**链接，创建一个新的**GET**请求，等待Burp
    Suite拦截。当我看到它时，我必须右键点击并将其发送到Intruder。
- en: 'Intruder is an aggressive tool for firing off requests with custom parameters
    that I define – these custom parameters are called payloads. Note that payloads
    are defined with sectional symbols. Simply highlight the text that you want to
    substitute with payloads and click the **Add** button on the right. We already
    know our algorithm is SHA-1 and we aren’t changing that, so I’ve only defined
    **file=** and **hash=** as payload positions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Intruder是一个激进的工具，用来发出带有自定义参数的请求，而这些自定义参数就是我们所定义的有效载荷。请注意，有效载荷是通过分隔符符号来定义的。只需高亮显示你希望替换为有效载荷的文本，然后点击右侧的**添加**按钮。我们已经知道我们的算法是SHA-1，并且不会改变它，所以我只定义了**file=**和**hash=**作为有效载荷位置：
- en: '![Figure 6.14 – Setting payload positions in Burp Suite ](image/Figure_6.14_B17616.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 在Burp Suite中设置有效载荷位置](image/Figure_6.14_B17616.jpg)'
- en: Figure 6.14 – Setting payload positions in Burp Suite
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 在Burp Suite中设置有效载荷位置
- en: Now, we click on the **Payloads** tab so that we can define what’s going to
    be placed in those payload positions we just defined. For this part, you’ll need
    to do a little preparation first. You need two separate lists for each payload
    position. hash_extender gave us everything we need but in a space-delimited text
    file. How you separate those columns is up to you (one method is to use spreadsheet
    software).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们点击**Payloads**标签，这样我们就可以定义刚才定义的有效载荷位置中将放置的内容。对于这部分内容，你需要先做一些准备工作。你需要为每个有效载荷位置准备两个单独的列表。hash_extender给了我们所需的一切，但它是一个以空格分隔的文本文件。如何分隔这些列由你决定（其中一种方法是使用电子表格软件）。
- en: I define the payload sets in order of position; for example, since the **file=**
    parameter is the first position I will encounter while reading from left to right,
    I must make the list of attacker data **Payload set 1**. Then, my list of hashes
    goes in **Payload set 2**. Now, the fun can begin – weapons free!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我按照位置顺序定义有效载荷集合；例如，由于**file=**参数是我从左到右读取时遇到的第一个位置，所以我必须将攻击者数据列表设为**Payload set
    1**。然后，我的哈希列表放入**Payload set 2**。现在，乐趣可以开始了——武器解除！
- en: '![Figure 6.15 – Configuring payload sets ](image/Figure_6.15_B17616.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 配置有效载荷集合](image/Figure_6.15_B17616.jpg)'
- en: Figure 6.15 – Configuring payload sets
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 配置有效载荷集合
- en: 'Kick back with a cup of coffee as Intruder fires off **GET** request after
    **GET** request, each one with customized parameters based on our payload definitions.
    So, what happens if a particular filename and verification hash combination is
    wrong? We just get a **File Not Found** error – in HTTP status code terms, a 404\.
    A total of 27 requests later, check out our **status** column — we received an
    HTTP 200 code. Bingo – we created a malicious request and had the hash verified.
    Let’s click the **Response** tab and revel in the treasures of our find. Uh oh
    – *failed to open stream: no such file or directory*? What’s going on here?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 拿上一杯咖啡，放松一下，随着Intruder发出一个又一个**GET**请求，每个请求都根据我们的有效载荷定义包含了自定义参数。那么，如果某个特定的文件名和验证哈希组合是错误的，会发生什么呢？我们会收到**文件未找到**的错误——在HTTP状态码中，就是404。总共发出了27个请求后，检查我们的**状态**列——我们收到了HTTP
    200代码。 bingo——我们创建了一个恶意请求并验证了哈希。让我们点击**Response**标签，沉浸在我们发现的宝藏中。糟糕——*无法打开流：没有这样的文件或目录*？这怎么回事？
- en: 'One thing we know for sure is the byte length of the secret. Note the number
    of guesses with the same hash, but only the request succeeded. That’s because
    finding the hash was only part of the fun – we needed the exact length of the secret.
    Each item in the **Payload1** column is our data with varying padding lengths.
    Since we defined our exact range, it’s a matter of counting the requests needed
    to succeed. We’re on the 26th request and started with 8 bytes for a secret length,
    so the length of the secret is 34 bytes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确定的一件事是**密钥的字节长度**。请注意，具有相同哈希值的猜测数量，但只有请求成功了。那是因为找到哈希值只是乐趣的一部分——我们需要的是密钥的确切长度。**Payload1**
    列中的每一项都是我们的数据，具有不同的填充长度。由于我们已经定义了确切的范围，现在只是数一下成功所需的请求次数而已。我们已经是第 26 次请求，从 8 字节的密钥长度开始，所以密钥的长度是
    34 字节：
- en: '![Figure 6.16 – Finding our golden ticket ](image/Figure_6.16_B17616.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 找到我们的黄金票](image/Figure_6.16_B17616.jpg)'
- en: Figure 6.16 – Finding our golden ticket
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 找到我们的黄金票
- en: As for the file not found problem, we simply didn’t climb the right number of
    parent folders to get to **/etc/passwd**. Despite this, we provided data with
    the correct padding length and a valid hash, so the system considers us authorized;
    it’s simply telling us it can’t find what we’re allowed to steal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 至于文件未找到的问题，我们只是没有爬到正确的父文件夹级别以访问**/etc/passwd**。尽管如此，我们提供了正确填充长度和有效哈希的数据，因此系统认为我们是被授权的；它只是告诉我们它找不到我们有权限窃取的内容。
- en: 'Now that we know the length of the secret, we can just go back to manual requests.
    This part will take good old-fashioned trial and error. I’ll just keep adding
    jumps until I get there. It won’t take long before I’ve convinced the host to
    spit out the **passwd** file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了密钥的长度，我们可以回到手动请求。这一部分将需要传统的“试错法”。我将继续添加跳跃，直到成功。过不了多久，我就能说服主机吐出**passwd**文件：
- en: '![Figure 6.17 – Capturing the flag ](image/Figure_6.17_B17616.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 捕获标志](image/Figure_6.17_B17616.jpg)'
- en: Figure 6.17 – Capturing the flag
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 捕获标志
- en: Now, we’re going to look at things a little differently – this time, we’ll look
    at ciphertext with padding and an authority who helpfully lets us know when the
    padding is broken. We’ll discover that it’s just a little too much information
    for the bad guys.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以不同的方式看待问题——这一次，我们将查看带有填充的密文，以及一个在填充破坏时会友好地告诉我们的权威。我们将发现，这对坏人来说信息有点太多了。
- en: Busting the padding oracle with PadBuster
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PadBuster 破解填充 oracle
- en: 'Secure cryptosystems shouldn’t reveal any plaintext-relevant information about
    encrypted messages. Oracle attacks are powerful demonstrations of how you don’t
    need much seemingly meaningless information to end up with a full decrypted message.
    Our CryptOMG web app provides a challenge that can be defeated by exploiting a
    padding oracle: a system that gives us information about the validity of padding
    in a decryption process without revealing the key or message. Let’s start some
    conversations with our oracle and see what these responses look like.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的加密系统不应该泄露任何与加密消息相关的明文信息。Oracle 攻击强有力地展示了即使是一些看似无意义的信息，也能使你获得完整的解密消息。我们的 CryptOMG
    网络应用提供了一个可以通过利用填充 oracle 来解决的挑战：这是一个在解密过程中告诉我们填充有效性而不泄露密钥或消息的系统。让我们开始和我们的 oracle
    进行一些对话，看看这些响应是什么样的。
- en: Interrogating the padding oracle
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 询问填充 oracle
- en: 'Let’s load up the CryptOMG main page and select the first challenge (like last
    time, we’re out to get **/etc/passwd**). On the test page, there’s nothing of
    interest in the actual content of the page, so let’s examine the URL: **http://127.0.0.1/ctf/challenge1/index.php?cipher=3&encoding=2&c=81c14e504d73a84cc
    6279ab62d3259f6e2a2f52dbc5387d57911ee7565c5a829**.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载 CryptOMG 主页面并选择第一个挑战（和上次一样，我们的目标是**/etc/passwd**）。在测试页面中，页面的实际内容没有任何有趣的地方，所以让我们检查一下
    URL：**http://127.0.0.1/ctf/challenge1/index.php?cipher=3&encoding=2&c=81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d57911ee7565c5a829**。
- en: Take a look at the **c=** field. That’s 64 hexadecimal characters (256 bits).
    It’s safe to say that we’re dealing with some sort of ciphertext. Again, in the
    spirit of just breaking things to see what happens, let’s flip some bits around.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**c=**字段。那是64个十六进制字符（256位）。可以肯定地说，我们正在处理某种密文。再次提醒，以一种仅仅为了打破东西看看会发生什么的精神，让我们翻转一些位。
- en: 'First, let’s modify some bits at the beginning of the string and resubmit the
    request:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改字符串开头的一些位，并重新提交请求：
- en: '![Figure 6.18 – Tweaking bits but no server error ](image/Figure_6.18_B17616.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 修改位，但没有服务器错误](image/Figure_6.18_B17616.jpg)'
- en: Figure 6.18 – Tweaking bits but no server error
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 调整比特但无服务器错误
- en: This is interesting because this error suggests the decryption was successful.
    The server is telling us that it decrypted a request for a file; the problem is
    that the file doesn’t exist. The fact that the server is telling us this means
    it understood our request – and this is despite not knowing the encrypted message.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为这个错误表明解密成功了。服务器告诉我们解密了一个文件请求；问题在于该文件不存在。服务器告诉我们这一点意味着它理解了我们的请求 - 尽管不知道加密消息的内容。
- en: 'Now, let’s try modifying some bits around the trailing half of the 256-bit
    encrypted value and resubmit it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着修改一些位于256位加密值尾部的位，并重新提交它：
- en: '![Figure 6.19 – Padding oracle telling us we broke the padding ](image/Figure_6.19_B17616.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 填充神谕告诉我们我们已经破解了填充](image/Figure_6.19_B17616.jpg)'
- en: Figure 6.19 – Padding oracle telling us we broke the padding
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 填充神谕告诉我们我们已经破解了填充
- en: We’ve all had that one friend who just talks too much and ends up giving away
    too much information. In this case, our friend is an oracle – a system that inadvertently
    reveals information that’s useful in an attack, even though the information itself
    is supposed to be meaningless. We’ve just learned that there is padding in this
    message, making it a block cipher; let’s assume AES in CBC mode. And, most importantly,
    we know that the target is functioning as a padding oracle, letting us know the
    validity status of the padding in the encrypted message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都有那种总是说太多话，最终泄露了太多信息的朋友。在这种情况下，我们的朋友是一个神谕 - 一个无意中透露有用攻击信息的系统，即使信息本身应该是无意义的。我们刚刚得知这条消息中有填充，使其成为块密码；让我们假设是AES的CBC模式。最重要的是，我们知道目标正在作为填充神谕运行，告诉我们加密消息中填充的有效性状态。
- en: Let’s bust out PadBuster to attack the padding oracle in this demonstration.
    Once we’ve nabbed our **passwd** file, we can take a look at what happened behind
    the scenes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用PadBuster攻击这个演示中的填充神谕。一旦我们获取了我们的 **passwd** 文件，我们就可以看看幕后发生了什么。
- en: Decrypting a CBC block with PadBuster
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PadBuster解密CBC块
- en: 'First, we need to install PadBuster:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装PadBuster：
- en: apt install padbuster
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: apt install padbuster
- en: 'If you run PadBuster with no parameters, you’ll get a help screen that gives
    you its simple usage requirements: you just need that URL, the encrypted block
    of data itself, and the block size (in bytes). Since we’re assuming AES, the block
    size would be 128 bits (*128 / 8 = 16* bytes):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不带任何参数运行PadBuster，您将获得一个帮助屏幕，向您提供其简单的使用要求：您只需要URL、加密数据块本身和块大小（以字节为单位）。由于我们假设是AES，块大小将是128位（*128
    / 8 = 16* 字节）：
- en: padbuster "http://127.0.0.1/ctf/challenge1/index.php?cipher=
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: padbuster "http://127.0.0.1/ctf/challenge1/index.php?cipher=
- en: 3&encoding=2&c=81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 3&encoding=2&c=81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d
- en: 57911ee7565c5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 57911ee7565c5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc
- en: 5387d57911ee7565c5a829 16 -noiv -encoding 1
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 5387d57911ee7565c5a829 16 -noiv -encoding 1
- en: 'Don’t worry about the fact that the encrypted message here doesn’t match the
    one in your lab; it changes with every session. The basic usage format is **padbuster
    "[url]" [message] [block size]** but we’ve added two options to the end:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这里的加密消息与您实验室中的不匹配；它每次会话都会更改。基本使用格式是 **padbuster "[url]" [message] [block
    size]**，但我们在结尾添加了两个选项：
- en: '**-noiv** is specifying that there is no IV known to us; it isn’t in the URL
    like in our previous demonstration, so we’re roughing it without it as it will
    be derived from the first **[block size]** bytes.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-noiv** 指定我们没有已知的初始向量；它不像在我们之前的演示中在URL中，所以我们在没有它的情况下粗略推测，因为它将从第一个 **[块大小]**
    字节中派生。'
- en: '**-encoding 1** is important since we’re letting PadBuster know to use lower
    hexadecimal (lowercase letters) encoding.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-encoding 1** 非常重要，因为我们告知PadBuster使用较低的十六进制（小写字母）编码。'
- en: 'When we execute the command, PadBuster has a chat with the oracle. A table
    is shown to us with response signatures based on the oracle’s answers. PadBuster
    will recommend one for you, but we already saw a 500 status code when we tampered
    with the padding, so that’s what we should pick here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行命令时，PadBuster与神谕进行交流。我们看到了一个包含基于神谕答案的响应签名的表格。PadBuster会为您推荐一个，但我们在篡改填充时已经看到了500状态代码，所以这是我们应该选择的：
- en: '![Figure 6.20 – Response analysis in PadBuster ](image/Figure_6.20_B17616.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20 – PadBuster中的响应分析](image/Figure_6.20_B17616.jpg)'
- en: Figure 6.20 – Response analysis in PadBuster
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – PadBuster中的响应分析
- en: 'PadBuster then gets to work decrypting based on the information it gathered.
    After about 10 seconds, we will get our decrypted result: some random ASCII characters,
    a pipe symbol, and the file path. Now that we know how the message is formatted,
    we’re going to reverse the process to generate an encrypted message with our request
    in it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，PadBuster开始基于它收集到的信息进行解密。大约10秒钟后，我们将得到解密结果：一些随机的ASCII字符，一个管道符号，和文件路径。现在我们知道了消息的格式，我们将逆向处理，生成一个包含请求的加密消息：
- en: '![Figure 6.21 – Decrypted data in different formats ](image/Figure_6.21_B17616.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.21 – 不同格式的解密数据](image/Figure_6.21_B17616.jpg)'
- en: Figure 6.21 – Decrypted data in different formats
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 不同格式的解密数据
- en: 'We’re just going back and using the same command but with the **plaintext**
    flag at the end. That’s it. PadBuster makes this *too* simple:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是回过头来，使用相同的命令，但在最后加上**plaintext**标志。就这样。PadBuster让这一切变得*太*简单了：
- en: padbuster "**http://127.0.0.1/ctf/challenge1/?&c=** 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d57911ee7565c
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: padbuster "**http://127.0.0.1/ctf/challenge1/?&c=** 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d57911ee7565c
- en: 5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d
- en: 57911ee7565c5a829 16 -noiv -encoding 1 -plaintext "lFA5\\C84VQE_T|../../../../../../../../../etc/passwd"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 57911ee7565c5a829 16 -noiv -encoding 1 -plaintext "lFA5\\C84VQE_T|../../../../../../../../../etc/passwd"
- en: 'This will spit out an encrypted value. Now, we merely need to replace the **c=**
    value in the URL with the following string:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个加密值。现在，我们只需将URL中的**c=**值替换为以下字符串：
- en: '![Figure 6.22 – The encrypted value we need to send ](image/Figure_6.22_B17616.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.22 – 我们需要发送的加密值](image/Figure_6.22_B17616.jpg)'
- en: Figure 6.22 – The encrypted value we need to send
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 我们需要发送的加密值
- en: 'Now, we can drop that in the URL and hit *Enter*, and voila – the server understood
    our request:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其粘贴到URL中并按*Enter*，瞧！——服务器理解了我们的请求：
- en: '![Figure 6.23 – Captured flag ](image/Figure_6.23_B17616.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 捕获的标志](image/Figure_6.23_B17616.jpg)'
- en: Figure 6.23 – Captured flag
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 捕获的标志
- en: So, how did PadBuster pull off this magical feat? Let’s take a look at the standards
    behind padding in encryption.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，PadBuster是如何完成这一神奇的壮举的呢？让我们来看看加密中填充的标准。
- en: Behind the scenes of the oracle padding attack
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle填充攻击的幕后
- en: PadBuster speaks the language of padding. That’s just a poetic way of saying
    that padding is not arbitrary; it follows a standard and PadBuster creates requests
    accordingly. The padding that we encounter in the operation of CBC mode ciphers
    is called **PKCS#5**/**PKCS#7** padding.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PadBuster讲的是填充的“语言”。这只是一种诗意的说法，意思是填充并非随意的；它遵循一个标准，而PadBuster根据这个标准生成请求。在CBC模式加密算法的操作中，我们遇到的填充被称为**PKCS#5**/**PKCS#7**填充。
- en: That initialism isn’t as scary as it looks; it just means **Public Key Cryptography
    Standards**, a family of standards that started as descriptions of proprietary
    technology in the 1990s. *#5* and *#7* refer to the fifth and seventh of those
    standards, respectively. They describe more than padding, but the particular method
    of padding that’s relevant here comes from these standards. We’re using both interchangeably
    here because the only difference between *#5* and *#7* is that *#7* defines block
    sizes of 8 or 16 bytes (64 bits and 128 bites); *#5* only defines block sizes
    of 8 bytes/64 bits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缩写并不像看起来那么可怕；它只是指**公钥密码学标准**，这是一个始于1990年代描述专有技术的标准系列。*#5*和*#7*分别指代这两个标准中的第五和第七个标准。它们描述的不仅仅是填充，但这里相关的填充方法就来源于这些标准。我们在这里交替使用这两者，因为*#5*和*#7*之间的唯一区别是，*#7*定义了8或16字节（64位和128位）的块大小；而*#5*仅定义了8字节/64位的块大小。
- en: The concept is pretty simple. As we know, the heart of a block cipher is its
    fixed-length block of data. Of course, messages that need to be encrypted are
    not of a fixed length; they may be as short as Hello, World! or as long as the
    Zimmermann Telegram. This is where padding comes in. *PKCS#5*/*PKCS#7* uses padding
    bytes, which are nothing more than a hexadecimal number. The number is equal to
    the number of padding bytes. For example, if there are five padding bytes, they’ll
    all be 0x05\. If a message happens to be evenly divisible by the block size, then
    an additional block of nothing but padding bytes (the value of which is, by definition,
    equal to the block size in bytes) is appended to the message. The purpose of this
    is to provide the error-checking mechanism inherent to this design. So, if I come
    along and decrypt a message only to find five padding bytes with the value 0x07,
    then guess what prophecy this wise oracle is telling me? A padding error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很简单。正如我们所知，块加密的核心是其固定长度的数据块。当然，需要加密的消息长度并不是固定的；它们可以像“Hello, World!”一样短，也可以像齐默曼电报那样长。此时填充就派上用场了。*PKCS#5*/*PKCS#7*使用填充字节，这些字节实际上只是十六进制数字。这个数字等于填充字节的数量。例如，如果有五个填充字节，它们都将是0x05。如果消息恰好可以被块大小整除，那么就会附加一个额外的块，内容全部为填充字节（其值根据定义等于块大小的字节数）。这样做的目的是提供这种设计固有的错误检查机制。所以，如果我来解密一条消息，结果发现有五个填充字节，值为0x07，那么你猜这个聪明的oracle告诉我什么预言？填充错误。
- en: 'Thus, the oracle can tell us one of three things when we pass encrypted data
    to the target:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们将加密数据传递给目标时，oracle可以告诉我们三件事中的一件：
- en: The encrypted data was padded correctly and contains valid server data once
    decrypted. This is a completely normal operation. The server responds with HTTP
    200 OK.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密数据正确填充，并且解密后包含有效的服务器数据。这是完全正常的操作。服务器响应为HTTP 200 OK。
- en: The encrypted data was padded correctly and contains invalid server data once
    decrypted. This is just like sending something unexpected to a server without
    encryption, such as a file request for a non-existent file. This is technically
    an HTTP 200, but typically with a custom error (for example, **File Not Found**).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密数据正确填充，并且解密后包含无效的服务器数据。这就像没有加密地发送一些意外数据到服务器，例如请求一个不存在的文件。这在技术上是HTTP 200，但通常会有一个自定义错误（例如，**文件未找到**）。
- en: The encrypted data was padded incorrectly, which breaks the decryption process,
    so nothing gets passed to the server. This causes a cryptographic exception and
    the response is an HTTP 500 Internal Server Error.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密数据的填充不正确，这会破坏解密过程，因此没有任何数据传递到服务器。这会导致一个加密异常，响应为HTTP 500内部服务器错误。
- en: 'This is half of the recipe for compromise. The other half is the concept we
    introduced at the beginning of this chapter: when you know two out of three binary
    values that have an XOR relationship to each other, you can easily find out what
    the missing field is. So, we must tweak the enciphered bits and repeatedly submit
    our modified requests, chatting with the oracle for state feedback, until we stop
    breaking decryption and the oracle tells us *the padding looks good*. With the
    oracle confirming the correct padding, this attack becomes a form of known-plaintext
    cryptanalysis, allowing us to decrypt the message.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是破解的一半。另一半是我们在本章开始时介绍的概念：当你知道三种二进制值中两个具有异或关系时，你可以轻松找出缺失的字段是什么。所以，我们必须调整加密的位并反复提交我们修改过的请求，和oracle（预言机）进行状态反馈对话，直到我们不再破坏解密并且oracle告诉我们*填充看起来很好*。随着oracle确认正确的填充，这个攻击变成了一种已知明文的密码分析方法，使我们能够解密消息。
- en: Recall that block ciphers have an IV to serve as the last block to start the
    block-chaining process; in these attacks, the IV is not always known to the attacker
    and, indeed, in our lab, none have been defined for us. PadBuster can work with
    this via the **-noiv** flag and thus uses the first bytes as an IV; the number
    of bytes used as an IV is defined in the block size parameter. We also know that
    CBC mode ciphers XOR the intermediary bits (that is, the bits after the encryption
    process) with the corresponding bits from the previous block (block chaining),
    so once decryption has begun, PadBuster works backward.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，块加密算法有一个IV（初始化向量）作为最后一个块来启动块链过程；在这些攻击中，IV并不总是已知的，实际上，在我们的实验中，没有为我们定义任何IV。PadBuster可以通过**-noiv**标志来实现这一点，并因此使用第一个字节作为IV；用作IV的字节数在块大小参数中定义。我们还知道，CBC模式加密会将中间位（即加密过程后的位）与前一个块的相应位进行异或（块链），因此一旦解密开始，PadBuster就会向后工作。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored some basic cryptography attacks. We started with
    cipher block chaining bit-flipping and learned how to modify the initialization
    vector predictably. Then, we leveraged this information to compromise the lab
    server. Here, we explored hash length extension attacks by exploiting flaws in
    message verification methods. We did this by leveraging the core compression functionality
    of the hash algorithm to produce an attacking hash that will pass verification.
    To prepare for this demonstration, we installed a powerful web and database server
    stack on Kali to host a vulnerable web app for legal study and testing in our
    home lab. We exploited the same lab environment in the final section on padding
    oracle attacks, which built upon the core knowledge that was introduced earlier
    in this book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们探讨了一些基本的密码学攻击。我们从密码块链接的比特翻转开始，学习了如何可预测地修改初始化向量。然后，我们利用这些信息突破了实验室服务器的防护。在这里，我们通过利用消息验证方法中的漏洞，探索了哈希长度扩展攻击。我们通过利用哈希算法的核心压缩功能，生成一个攻击哈希，使其能够通过验证。为了准备这个演示，我们在Kali上安装了一个强大的Web和数据库服务器堆栈，用于托管一个脆弱的Web应用，以便在我们家的实验室进行合法的学习和测试。在关于填充oracle攻击的最后部分中，我们利用了之前本书介绍的核心知识，继续突破实验室环境。
- en: With some cryptography basics out of the way in this chapter, we’ll jump back
    into the cockpit of Metasploit as we look at more advanced strategies.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了一些基本的密码学知识后，我们将再次进入Metasploit的控制台，深入了解更多高级策略。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试您对本章内容的理解：
- en: Calculate the output of this exclusive **or** operation: **001011100101010** ⊕ **1111000110100101**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算此异或**or**运算的结果：**001011100101010** ⊕ **1111000110100101**。
- en: ECB in 3DES-128-ECB stands for __________.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3DES-128-ECB中的ECB代表__________。
- en: _______ is employed to ensure the message is divisible by the algorithm’s block
    length.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: _______用于确保消息可以被算法的块长度整除。
- en: PadBuster needs upper hexadecimal numbers defined with the _________ flag.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PadBuster需要使用_________标志来定义大写十六进制数。
- en: How many payload sets would you need to define for Burp Suite’s Intruder if
    the attack packet has four payload positions?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果攻击数据包有四个有效负载位置，那么您需要在Burp Suite的Intruder中定义多少个有效负载集？
- en: The SHA-1 compression function takes ______-bit and _____-bit inputs.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SHA-1压缩函数接受_________位和_________位的输入。
- en: The padding oracle attack gets its name from a 1994 flaw in Oracle 7.2\. (True
    | False)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充oracle攻击得名于1994年Oracle 7.2中的漏洞。（正确 | 错误）
