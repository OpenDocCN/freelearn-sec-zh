- en: Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机发现
- en: 'This chapter will include the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括以下几种方法：
- en: Using Scapy to perform host discovery (layers 2/3/4)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scapy 执行主机发现（第2/3/4层）
- en: Using Nmap to perform host discovery (layers 2/3/4)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nmap 执行主机发现（第2/3/4层）
- en: Using ARPing to perform host discovery (layer 2)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ARPing 执行主机发现（第2层）
- en: Using netdiscover to perform host discovery (layer 2)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 netdiscover 执行主机发现（第2层）
- en: Using Metasploit to perform host discovery (layer 2)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Metasploit 执行主机发现（第2层）
- en: Using ICMP to perform host discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ICMP 执行主机发现
- en: Using fping to perform host discovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fping 执行主机发现
- en: Using hping3 to perform host discovery (layers 3/4)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 hping3 执行主机发现（第3/4层）
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: '**Discovery scanning** is the process of identifying live hosts on a network.
    In the context of'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机发现扫描**是识别网络中在线主机的过程。在渗透测试中，通常执行此操作以识别潜在的攻击目标。'
- en: penetration testing, this is usually performed to identify potential targets
    for attack. The
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试中，通常执行此操作以识别潜在的攻击目标。
- en: objective here is not to exhaust resources in gathering information about targets,
    but instead, to merely find out where the targets are logically located. The final
    product of our discovery should be a list of IP addresses that we can then use
    for further analysis. In this chapter, we will discuss how to discover hosts on
    a network by using protocols operating at layer 2, layer 3, and layer 4 of the
    OSI model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是耗尽资源来收集关于目标的信息，而是仅仅找到目标在逻辑上的位置。我们的最终发现结果应是一个 IP 地址列表，之后可以用于进一步分析。在本章中，我们将讨论如何通过使用在
    OSI 模型第2层、第3层和第4层的协议来发现网络中的主机。
- en: Knowing the OSI model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 OSI 模型
- en: 'Prior to addressing each of the scanning techniques specifically, we should
    address a few underlying principles. The **Open Systems Interconnection** (**OSI**)
    model is an **International Organization for Standardization** (**ISO**) standard
    that defines how networked systems communicate. This model is divided into seven
    layers that define how application content can be sent by one system and/or received
    by another. The upper layers (5-7) of the OSI model primarily function to interact
    with the user, whereas the lower layers (1-4) deal with encoding, formatting,
    and transmission. These layers consist of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体讨论每种扫描技术之前，我们应先介绍一些基本原则。**开放系统互联**（**OSI**）模型是**国际标准化组织**（**ISO**）的标准，定义了网络系统之间的通信方式。该模型分为七层，定义了应用内容如何由一个系统发送或由另一个系统接收。OSI
    模型的上层（5-7层）主要用于与用户交互，而下层（1-4层）则处理编码、格式化和传输。这些层包括：
- en: '| **OSI model** | **Layer description** | **Protocols** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **OSI 模型** | **层描述** | **协议** |'
- en: '| Layer 7: Application | This layer involves the application software that
    is sending and receiving data | HTTP, FTP, and Telnet |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 第7层：应用层 | 该层涉及发送和接收数据的应用软件 | HTTP、FTP 和 Telnet |'
- en: '| Layer 6: Presentation | This layer defines how data is formatted or organized
    | ASCII, JPEG, PDF, PNG, and DOCX |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 第6层：表示层 | 该层定义数据的格式或组织方式 | ASCII、JPEG、PDF、PNG 和 DOCX |'
- en: '| Layer 5: Session | This layer involves application session control, management,
    synchronization, and termination | NetBIOS, PPTP, RPC, and SOCKS |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 第5层：会话层 | 该层涉及应用会话控制、管理、同步和终止 | NetBIOS、PPTP、RPC 和 SOCKS |'
- en: '| Layer 4: Transport | This layer involves end-to-end communication services
    | TCP and UDP |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 第4层：传输层 | 该层涉及端到端的通信服务 | TCP 和 UDP |'
- en: '| Layer 3: Network | This layer involves logical system addressing | IPv4,
    IPv6, ICMP, and IPSec |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 第3层：网络层 | 该层涉及逻辑系统寻址 | IPv4、IPv6、ICMP 和 IPSec |'
- en: '| Layer 2: Data link | This layer involves physical system addressing | ARP
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 第2层：数据链路层 | 该层涉及物理系统寻址 | ARP |'
- en: '| Layer 1: Physical | This layer involves the data stream that is passed over
    the wire |  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 第1层：物理层 | 该层涉及通过电缆传输的数据流 |  |'
- en: The lower layers of the OSI model are largely used to ensure that network traffic
    successfully arrives at its intended destination. Many of the commonly used protocols
    at these lower layers necessitate a response from the destination system and,
    as such, can be leveraged by potential attackers to identify live systems. Techniques
    discussed in the remainder of this section will leverage protocols used in layers
    2, 3, and 4 to discover live network systems. Prior to addressing each of the
    specific recipes, we will briefly discuss the protocols used and how they can
    be leveraged for discovery.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 模型的较低层主要用于确保网络流量成功到达预定目的地。在这些较低层中，许多常用协议需要目标系统的响应，因此，潜在的攻击者可以利用这些协议识别存活的系统。本节剩余部分讨论的技术将利用第二、三、四层的协议来发现存活的网络系统。在详细讨论每个具体方法之前，我们将简要介绍所使用的协议及其如何被用于发现。
- en: 'The pros and cons of layer 2 discovery with ARP are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ARP 进行第二层发现的优缺点如下：
- en: '**Pros**:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Very fast
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常快
- en: Highly reliable
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可靠
- en: '**Cons**:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Cannot discover remote systems (non-routable protocol)
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法发现远程系统（不可路由协议）
- en: Layer 2 discovery scanning is performed using **Address Resolution Protocol**
    (**ARP**) traffic. ARP is a layer 2 protocol that primarily serves the function
    of translating logical layer 3 IP addresses to physical layer 2 MAC addresses.
    When a system needs to locate the physical address that corresponds to a destination
    IP address, it will broadcast an ARP request packet on the local network segment.
    This ARP request simply asks the entire network, "Who has this IP address?" The
    system with the specified IP address will then directly respond to the inquiring
    system with an ARP reply that contains its layer 2 MAC address. The inquiring
    system will update its ARP cache, which is a temporary record of IP address and
    MAC address associations, and will then initiate its communications with the host.
    ARP can be useful in discovering live hosts on a network, because it does not
    employ any form of identification or authorization prior to responding to requests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层发现扫描使用 **地址解析协议**（**ARP**）流量进行。ARP 是一个第二层协议，主要用于将逻辑第三层 IP 地址转换为物理第二层 MAC
    地址。当系统需要定位与目标 IP 地址对应的物理地址时，它会在本地网络段广播一个 ARP 请求包。这个 ARP 请求实际上是在问整个网络：“谁拥有这个 IP
    地址？”具有指定 IP 地址的系统会直接回复询问系统，发送包含其第二层 MAC 地址的 ARP 回复。询问系统会更新其 ARP 缓存，这是一个记录 IP 地址与
    MAC 地址关联的临时记录，然后开始与该主机进行通信。ARP 可以用于发现网络中的存活主机，因为它在响应请求之前不采用任何形式的身份验证或授权。
- en: As a result of this, it is possible and even trivial for an intruder to connect
    to a local network and enumerate live hosts. This can be performed by sending
    a series of ARP requests for a comprehensive list of IP addresses and then recording
    a list of queried IP addresses for which responses were received. ARP discovery
    has both advantages and disadvantages. It is useful in discovery scanning because
    it is the fastest and most reliable discovery protocol. Unfortunately, it is also
    a non-routable protocol and can only be used to discover hosts on the local subnet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，入侵者连接到本地网络并枚举存活主机变得可能且简单。可以通过发送一系列 ARP 请求来获取完整的 IP 地址列表，然后记录接收到响应的查询 IP
    地址。ARP 发现既有优点也有缺点。它在发现扫描中非常有用，因为它是最快且最可靠的发现协议。不幸的是，它也是一个不可路由的协议，只能用于发现本地子网中的主机。
- en: 'The pros and cons of layer 3 discovery with ICMP are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ICMP 进行第三层发现的优缺点如下：
- en: '**Pros**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Can discover remote systems (routable protocol)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发现远程系统（可路由协议）
- en: Still relatively fast
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然相对较快
- en: '**Cons**:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Slower than ARP discovery
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比 ARP 发现慢
- en: Often filtered by firewalls
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常被防火墙过滤
- en: Layer 3 discovery is probably the most commonly known and used discovery technique
    among network administrators and technicians. The famous ping command-line utility,
    which is found natively on both Windows and *nix systems, uses layer 3 discovery.
    This form of discovery makes use of Internet Control Message Protocol (ICMP).
    While ICMP has several functions, one that can be particularly useful to identify
    live systems is the use of echo request and echo response messages. An ICMP echo
    request is the technical equivalent of one system asking another system, "Are
    you there?" An ICMP echo response is how the receiving system can answer, "Yes
    I am." To determine whether a host exists at a particular IP address, a system
    can send an ICMP echo request to that address. If there is a host with that IP
    address and everything works as desired, the host will then return an ICMP echo
    reply. This protocol can be leveraged in the host discovery by performing this
    sequence in a loop for a comprehensive list of IP addresses.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 层 3 发现可能是网络管理员和技术人员最常用的发现技术。著名的 ping 命令行工具，它在 Windows 和 *nix 系统上都可以找到，使用的是层
    3 发现。此形式的发现使用了互联网控制消息协议（ICMP）。虽然 ICMP 有多个功能，其中一个特别有用来识别活动系统的是使用回显请求和回显响应消息。ICMP
    回显请求是一个系统向另一个系统发出“你在吗？”的技术等价物。ICMP 回显响应则是接收系统可以回答“我在”的一种方式。为了确定某个 IP 地址上是否存在主机，系统可以向该地址发送
    ICMP 回显请求。如果该 IP 地址上有主机且一切按预期工作，主机将返回 ICMP 回显回复。这个协议可以通过在 IP 地址列表上循环执行该序列来进行主机发现。
- en: The output would consist of a list of only the IP addresses for which a reply
    was received. Layer 3 discovery is effective because it uses a routable protocol
    to identify live hosts. However, there are also certain disadvantages associated
    with its use. ICMP discovery is not as fast as ARP discovery. Also, ICMP discovery
    is not as reliable as ARP discovery, as some hosts are intentionally configured
    to not respond to ICMP traffic, and firewalls are frequently configured to drop
    ICMP traffic. Nonetheless, it is a fast and commonly used approach to discovering
    potential targets on a remote address range.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将仅包括那些收到回复的 IP 地址列表。层 3 发现是有效的，因为它使用可路由协议来识别活动主机。然而，使用它也有一些缺点。ICMP 发现没有 ARP
    发现快。而且，ICMP 发现不如 ARP 发现可靠，因为有些主机被故意配置为不响应 ICMP 流量，防火墙也常常被配置为丢弃 ICMP 流量。尽管如此，它仍然是一种快速且常用的发现潜在目标的方式，适用于远程地址范围。
- en: Layer 4 discovery is highly effective because publicly routable systems are
    usually only in the public IP space, as they host networked services that are
    available over **Transmission Control Protocol** (**TCP**) or **User Datagram
    Protocol** (**UDP**). In poorly secured environments, a reply can often be solicited
    from a remote server by sending nearly any UDP or TCP request to its IP address.
    However, if stateful filtering is employed, it may be possible to only solicit
    a response from a remote service with a SYN request directed to a port address
    associated with a live service. Even in highly secure environments with advanced
    filtering, discovery is possible in most cases if the right request is supplied.
    However, with 65,536 possible port addresses for both UDP and TCP services, a
    fully comprehensive discovery process can be very time consuming. The best approach
    to layer 4 discovery with both TCP and UDP techniques is to find the right balance
    between thoroughness and expediency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 层 4 发现非常有效，因为公开可路由的系统通常仅存在于公共 IP 空间，因为它们托管的网络服务是通过**传输控制协议**（**TCP**）或**用户数据报协议**（**UDP**）提供的。在安全性较差的环境中，可以通过向远程服务器的
    IP 地址发送几乎任何 UDP 或 TCP 请求来引发回复。然而，如果使用了有状态过滤，则可能只能通过向与活动服务相关联的端口地址发送 SYN 请求，才能从远程服务获得回复。即使在具有高级过滤的高度安全环境中，只要提供了正确的请求，大多数情况下仍然可以进行发现。然而，由于
    UDP 和 TCP 服务有 65,536 个可能的端口地址，全面的发现过程可能会非常耗时。层 4 发现的最佳方法是找到 TCP 和 UDP 技术之间的彻底性与迅速性的平衡。
- en: 'The pros and cons of layer 4 discovery with TCP are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 层 4 发现通过 TCP 的优缺点如下：
- en: '**Pros**:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Can discover remote systems (routable protocol)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发现远程系统（可路由协议）
- en: More reliable than ICMP (filters are less common or selectively implemented)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比 ICMP 更可靠（过滤较少或选择性实施）
- en: '**Cons**:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Stateful firewall filters can produce unreliable results
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态防火墙过滤器可能会产生不可靠的结果
- en: Thorough discovery can be time consuming
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彻底的发现过程可能会很耗时
- en: Layer 4 discovery with TCP consists of sending TCP packets to potential destination
    addresses with various TCP flag bits activated. Different flag configurations
    can trigger various responses that can be used to identify live hosts. Unsolicited
    TCP finish (**FIN**) or **acknowledge** (**ACK**) packets can often trigger **reset**
    (**RST**) responses from a remote server. The **synchronize** (**SYN**) packets
    sent to a remote server can commonly trigger SYN+ACK or RST responses, depending
    on the status of the service. The intention is not to solicit a particular response,
    but instead to solicit any response. Any response from a given IP address is a
    confirmation that a live system is present.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TCP 进行第 4 层探测是通过向潜在目标地址发送带有各种 TCP 标志位的 TCP 数据包来完成的。不同的标志配置可以触发不同的响应，用于识别在线主机。未经请求的
    TCP 结束（**FIN**）或 **确认（**ACK**）数据包通常会触发远程服务器的 **重置（**RST**）响应。发送到远程服务器的 **同步（**SYN**）数据包通常会触发
    SYN+ACK 或 RST 响应，具体取决于服务的状态。目的是不是为了请求特定的响应，而是为了请求任何响应。来自给定 IP 地址的任何响应都确认了一个在线系统的存在。
- en: 'The pros and cons of layer 4 discovery with UDP are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UDP 进行第 4 层探测的优缺点如下：
- en: '**Pros**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Can discover remote systems (routable protocol)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发现远程系统（可路由协议）
- en: Can even discover remote hosts with all TCP services filtered
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至可以发现所有 TCP 服务都被过滤的远程主机
- en: '**Cons**:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Inconsistent use and filtering of ICMP port-unreachable responses makes indiscriminate
    discovery unreliable
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ICMP 端口不可达响应的不一致使用和过滤使得不加区别的探测变得不可靠
- en: Service-specific probe techniques limit thoroughness and increase the required
    scan time
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定服务探测技术限制了彻底性，并增加了所需的扫描时间
- en: UDP discovery involves sending UDP probe packets to various destination ports
    in an attempt to solicit a response from live hosts. UDP discovery can sometimes
    be effective in identifying live hosts that have all TCP services filtered. However,
    UDP discovery can be tricky because while some UDP services will reply to UDP
    packets with ICMP port-unreachable responses, others will only reply to unique
    requests that specifically correspond to a running service. Additionally, ICMP
    traffic is commonly filtered by egress restrictions on firewalls, making it difficult
    to perform indiscriminate UDP discovery. As such, effective UDP discovery scanning
    often requires unique techniques that vary from service to service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 探测涉及向不同的目标端口发送 UDP 探测数据包，试图从在线主机获取响应。UDP 探测有时能有效识别所有 TCP 服务被过滤的在线主机。然而，UDP
    探测可能很棘手，因为一些 UDP 服务会回复 ICMP 端口不可达响应，而另一些则仅会回复特定请求，这些请求与正在运行的服务相对应。此外，ICMP 流量通常会被防火墙的出站限制过滤，这使得执行不加区别的
    UDP 探测变得困难。因此，有效的 UDP 探测扫描通常需要不同的技术，这些技术根据服务的不同而有所不同。
- en: Using Scapy to perform host discovery (layers 2/3/4)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scapy 执行主机发现（第 2/3/4 层）
- en: 'Scapy is a powerful interactive tool that can be used to capture, analyze,
    manipulate, and even create protocol-compliant network traffic, which can then
    be injected into the network. Scapy is also a library that can be used in Python,
    thereby offering the capability to create highly effective scripts to perform
    network traffic handling and manipulation. We will demonstrate here how to use
    Scapy to perform discovery in layers 2, 3, and 4:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 是一个功能强大的交互式工具，可以用来捕获、分析、操作，甚至创建符合协议的网络流量，然后将其注入到网络中。Scapy 还是一个可以在 Python
    中使用的库，提供了创建高效脚本来执行网络流量处理和操作的能力。我们将在这里演示如何使用 Scapy 在第 2、3 和 4 层执行探测：
- en: First, we will use Scapy and Python to perform ARP discovery in layer 2.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Scapy 和 Python 在第 2 层执行 ARP 探测。
- en: Next, we will use Scapy to inject and analyze ICMP traffic in layer 3.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Scapy 在第 3 层注入并分析 ICMP 流量。
- en: Finally, we will use Scapy and Python to perform layer 4 discovery using both
    UDP and TCP.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 Scapy 和 Python 执行第 4 层探测，使用 UDP 和 TCP。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To use Scapy to perform ARP discovery, you will need to have at least one system
    on the **local area network** (**LAN**) that will respond to ARP requests. In
    the examples provided, a combination of Linux and Windows systems are used. For
    more information on setting up systems in a local lab environment, refer to the
    *Installing Metasploitable2* and *Installing Windows Server* recipes in [Chapter
    1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Scapy 执行 ARP 发现，你需要至少一台 **局域网**（**LAN**）中的系统来响应 ARP 请求。在提供的示例中，使用了 Linux
    和 Windows 系统的组合。有关在本地实验环境中设置系统的更多信息，请参见 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 和 *安装 Windows Server* 配方，*入门指南*。
- en: Using Scapy to perform layer 3 and layer 4 discovery does not require a lab
    environment, as many systems on the Internet will reply to ICMP echo requests
    as well as both TCP and UDP traffic. However, it is highly recommended that you
    perform any type of network scanning exclusively in your own lab unless you are
    thoroughly familiar with the legal regulations imposed by any governing authorities
    to whom you are subject. If you wish to perform this technique within your lab,
    you will need to have at least one system that will respond to ICMP, TCP, and
    UDP requests. In the examples provided, a combination of Linux and Windows systems
    are used. For more information on setting up systems in a local lab environment,
    refer to the *Installing Metasploitable2* and *Installing Windows Server* recipes
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Scapy 执行第 3 层和第 4 层的发现不需要实验环境，因为互联网上的许多系统会回复 ICMP 回显请求，以及 TCP 和 UDP 流量。然而，强烈建议你仅在自己的实验室中进行任何类型的网络扫描，除非你已经完全熟悉适用于你的法律规定。如果你希望在实验室中执行此技术，你将需要至少一台可以响应
    ICMP、TCP 和 UDP 请求的系统。在提供的示例中，使用了 Linux 和 Windows 系统的组合。有关在本地实验环境中设置系统的更多信息，请参见
    [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的 *安装 Metasploitable2*
    和 *安装 Windows Server* 配方，*入门指南*。
- en: Additionally, this section will require a script to be written to the filesystem,
    using a text editor such as Vim or GNU nano. For more information on writing scripts,
    refer to the *Using text editors (Vim and GNU nano)* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)*,
    Getting Started*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本节需要将脚本写入文件系统，可以使用 Vim 或 GNU nano 等文本编辑器。有关编写脚本的更多信息，请参见 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *使用文本编辑器（Vim 和 GNU nano）* 配方，*入门指南*。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's go through the discovery steps layer by layer. In this layer, we will
    use Scapy to perform discovery at layers 2, 3, and 4.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐层了解发现过程。在这一层中，我们将使用 Scapy 在第 2、3 和 4 层进行发现。
- en: Layer 2 discovery - ARP
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 层发现 - ARP
- en: 'To understand how ARP discovery works, we will start by using Scapy to craft
    custom packets that will allow us to identify hosts on the LAN using ARP:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 ARP 发现的工作原理，我们将从使用 Scapy 构建自定义数据包开始，这将允许我们通过 ARP 在局域网上识别主机：
- en: 'To begin using Scapy in Kali Linux, enter the `scapy` command from the Terminal.
    You can then use the `display()` function to see the default configurations for
    any ARP object created in Scapy in the following manner:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Kali Linux 中开始使用 Scapy，请从终端输入 `scapy` 命令。然后，你可以使用 `display()` 函数查看任何在 Scapy
    中创建的 ARP 对象的默认配置，如下所示：
- en: '![](../images/00576.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00576.jpeg)'
- en: Notice that both the IP and MAC source addresses are automatically configured
    to the values associated with the host on which Scapy is being run. Except in
    the case that you are spoofing an alternate source address, these values will
    never have to be changed for any Scapy object. The default opcode value for ARP
    is automatically set to `who-has`, which designates that the packet will be requesting
    an IP and MAC association. In this case, the only value we need to supply is the
    destination IP address. To do this, we can create an object using the ARP function
    by setting it equal to a variable. The name of the variable is irrelevant (in
    the example provided, the variable name, `arp_request`, is used).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，IP 和 MAC 源地址都会自动配置为与运行 Scapy 的主机关联的值。除非你正在伪造一个替代源地址，否则这些值不需要为任何 Scapy 对象进行更改。ARP
    的默认操作码值自动设置为 `who-has`，这表示数据包将请求 IP 和 MAC 地址的关联。在这种情况下，我们只需要提供目标 IP 地址。为此，我们可以通过将
    ARP 函数赋值给一个变量来创建一个对象。变量名无关紧要（在示例中，使用了变量名 `arp_request`）。
- en: 'Have a look at the following commands:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下命令：
- en: '![](../images/00635.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00635.jpeg)'
- en: 'Notice that the `display()` function can also be applied to the created ARP
    object to verify that the configuration values have been updated. For this exercise,
    use a destination IP address that corresponds to a live machine in your lab network.
    The `sr1()` function can then be used to send the request over the wire and return
    the first response:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`display()`函数也可以应用于创建的ARP对象，以验证配置值是否已更新。对于这个练习，请使用一个对应于你实验室网络中活动机器的目标IP地址。然后可以使用`sr1()`函数通过网络发送请求并返回第一个响应：
- en: '![](../images/00004.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00004.jpeg)'
- en: Alternatively, you can perform the same task by calling the function directly
    and passing any special configurations as arguments to it, as shown in the following
    screenshot. This can avoid the clutter of using unnecessary variables and can
    also allow the completion of the entire task in a single line of code.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以直接调用该函数并传递任何特殊配置作为参数来执行相同的任务，如下图所示。这可以避免使用不必要的变量杂乱，并且还可以通过一行代码完成整个任务。
- en: '![](../images/00132.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00132.jpeg)'
- en: Notice that in each of these cases, a response is returned, indicating that
    the IP address of `172.16.69.128` is at the MAC address of `00:0C:29:96:81:f2`.
    If you perform the same task, but instead assign a destination IP address that
    does not correspond to a live host on your lab network, you will not receive any
    response, and the function will continue to analyze the incoming traffic on the
    local interface indefinitely.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在这些情况下，都会返回一个响应，表示`172.16.69.128`的IP地址对应于`00:0C:29:96:81:f2`的MAC地址。如果你执行相同的任务，但将目标IP地址分配为不对应于你实验室网络中活动主机的地址，则不会收到任何响应，函数将继续无限期地分析本地接口上的传入流量。
- en: 'You can forcibly terminate the function using *Ctrl *+ *C*. Alternatively,
    you can specify a timeout argument to avoid this problem. Using timeouts will
    become critical when Scapy is employed in Python scripting. To use a timeout,
    an additional argument should be supplied to the send/receive function, specifying
    the number of seconds to wait for an incoming response:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用*Ctrl* + *C*强制终止该函数。或者，你可以指定超时参数来避免这个问题。当Scapy在Python脚本中使用时，超时将变得至关重要。要使用超时，应该向发送/接收函数提供一个额外的参数，指定等待响应的秒数：
- en: '![](../images/00136.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00136.jpeg)'
- en: 'By employing the timeout function, a request sent to a non-responsive host
    will return after the specified amount of time, indicating that `0` answers were
    captured. Additionally, the responses received by this function can also be set
    to a variable, and subsequent handling can be performed on the response by calling
    this variable:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用超时函数，发送到未响应主机的请求将在指定时间后返回，表示捕获了`0`个答案。此外，通过调用该变量，还可以将此函数接收到的响应设置为一个变量，随后可以对响应进行处理：
- en: '![](../images/00285.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00285.jpeg)'
- en: 'Scapy can also be used as a library within the Python scripting language. This
    can be used to effectively automate redundant tasks performed in Scapy. Python
    and Scapy can be used to loop through each of the possible host addresses within
    the local subnet in sequence and send ARP requests to each one. An example of
    a functional script that could be used to perform layer 2 discovery on a sequential
    series of hosts might look like the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scapy也可以作为Python脚本语言中的一个库来使用。这可以有效地自动化在Scapy中执行的冗余任务。Python和Scapy可以用来按顺序循环遍历本地子网中的每个可能的主机地址，并向每个地址发送ARP请求。一个可用于在一系列主机上执行二层发现的功能脚本示例如下：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line of the script indicates where the Python interpreter is located
    so that the script can be executed without it being passed to the interpreter.
    The script then imports all the Scapy functions and also defines Scapy logging
    levels to eliminate unnecessary output in the script.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本的第一行指明了Python解释器的位置，这样可以在不将其传递给解释器的情况下执行脚本。然后脚本导入了所有Scapy函数，并且定义了Scapy日志级别，以消除脚本中不必要的输出。
- en: The subprocess library is also imported to facilitate easy extraction of information
    from system calls. The second block of code is a conditional test that evaluates
    whether the required argument is supplied to the script. If the required argument
    is not supplied upon execution, the script will then output an explanation of
    the appropriate script usage. This explanation includes the usage of the tool,
    an example, and explanation of the task that will be performed by this example.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程库也被导入，以便从系统调用中轻松提取信息。第二段代码是一个条件判断，评估是否向脚本提供了所需的参数。如果执行时没有提供所需的参数，脚本将输出一个关于如何使用脚本的说明。该说明包括工具的用法、示例以及此示例将执行的任务的解释。
- en: After this block of code, there is a single isolated line of code that assigns
    the provided argument to the interface variable. The next block of code utilizes
    the `check_output()` subprocess function to perform an `ifconfig` system call
    that also utilizes `grep` and `cut` to extract the IP address from the local interface
    that was supplied as an argument. This output's then assigned to the `ip` variable.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这段代码之后，有一行独立的代码，它将提供的参数赋值给接口变量。接下来的代码块使用`check_output()`子进程函数执行`ifconfig`系统调用，并结合`grep`和`cut`提取从提供的本地接口中获取的IP地址。然后将此输出赋值给`ip`变量。
- en: The `split` function is then used to extract the `/24` network prefix from the
    IP address string. For example, if the `ip` variable contains the `192.168.11.4`
    string, then the value of `192.168.11` will be assigned to the `prefix` variable.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用`split`函数从IP地址字符串中提取`/24`网络前缀。例如，如果`ip`变量包含`192.168.11.4`字符串，则`192.168.11`的值将被赋值给`prefix`变量。
- en: The final block of code is a `for` loop that performs the actual scanning. The
    `for` loop cycles through all values between `0` and `254`, and for each iteration,
    the value is then appended to the network prefix. In the case of the example provided
    earlier, an ARP request would be broadcast for each IP address between `192.168.11.0`
    and `192.168.11.254`. For each live host that does reply, the corresponding IP
    address is then printed to the screen to indicate that the host is alive on the
    LAN.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一段代码是一个`for`循环，用于执行实际的扫描。`for`循环遍历从`0`到`254`之间的所有值，每次迭代时，该值会被追加到网络前缀中。在前面的例子中，对于每个`192.168.11.0`到`192.168.11.254`之间的IP地址，会广播一个ARP请求。对于每个有响应的活跃主机，相关的IP地址会被打印到屏幕上，表示该主机在局域网中是活跃的。
- en: 'Once the script has been written to the local directory, you can execute it
    in the Terminal using a period and forward slash, followed by the name of the
    executable script. Have a look at the following command used to execute the script:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本被写入本地目录，可以使用终端中的点和正斜杠，后跟可执行脚本的名称来执行它。请查看以下执行脚本的命令：
- en: '![](../images/00518.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00518.jpeg)'
- en: 'If the script is executed without any arguments supplied, the usage is output
    to the screen. The usage output indicates that this script requires a single argument
    that defines what interface should be used to perform the scan. In the following
    example, the script is executed using the `eth0` interface:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本在执行时没有提供任何参数，则会输出用法说明。用法输出指示该脚本需要一个定义扫描所用接口的参数。在以下示例中，脚本使用`eth0`接口执行：
- en: '![](../images/00520.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00520.jpeg)'
- en: 'Once run, the script will determine the local subnet of the supplied interface,
    perform the ARP scan on this subnet, and then output a list of live IP addresses
    based on the responses from the hosts to which these IPs are assigned. Additionally,
    Wireshark can be run at the same time as the script is running, to observe how
    a request is broadcast for each address in sequence and how live hosts respond
    to these requests, as seen in the following screenshot:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本运行后，它将确定所提供接口的本地子网，执行该子网的ARP扫描，并基于主机对这些IP地址的响应输出活动的IP地址列表。此外，可以在脚本运行的同时运行Wireshark，以观察每个地址的请求如何依次广播，以及活跃主机如何响应这些请求，如下图所示：
- en: '![](../images/00458.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00458.jpeg)'
- en: 'Additionally, one can easily redirect the output of the script to a text file
    that can then be used for subsequent analysis. The output can be redirected using
    the greater-than sign followed by the name of the text file. An example of this
    is as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还可以轻松地将脚本的输出重定向到文本文件中，然后用于后续分析。可以使用大于号（`>`）后跟文本文件名来重定向输出。以下是一个示例：
- en: '![](../images/00525.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00525.jpeg)'
- en: 'Once output has been redirected to the output file (`output.txt`), you can
    use the `ls` command to verify that the file was written to the filesystem, or
    you can use the `cat` command to view the contents of the file. This script can
    also be easily modified to only perform ARP requests against certain IP addresses
    contained within a text file. To do this, we would first need to create a list
    of IP addresses that we desire to scan. For this purpose, you can use either the
    GNU nano or Vim text editors. To evaluate the functionality of the script, include
    some addresses that were earlier discovered to be live and some other randomly
    selected addresses in the same range that do not correspond to any live host.
    To create the input file in either Vim or GNU nano, use one of the following commands:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输出被重定向到输出文件（`output.txt`），你可以使用`ls`命令验证该文件是否已写入文件系统，或者使用`cat`命令查看文件的内容。该脚本也可以很容易地修改，仅对文本文件中包含的某些
    IP 地址执行 ARP 请求。为此，我们首先需要创建一个我们希望扫描的 IP 地址列表。你可以使用 GNU nano 或 Vim 文本编辑器。为了评估脚本的功能，包含一些之前发现的活动地址，以及同一范围内随机选择的其他地址，这些地址不对应任何活动主机。要在
    Vim 或 GNU nano 中创建输入文件，可以使用以下命令之一：
- en: '![](../images/00237.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00237.jpeg)'
- en: 'Once the input file (`iplist.txt`) has been created, you can verify its contents
    using the `cat` command. Assuming that the file was created correctly, you should
    see the same list of IP addresses that you entered into the text editor:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了输入文件（`iplist.txt`），你可以使用`cat`命令验证其内容。如果文件正确创建，你应该看到你在文本编辑器中输入的相同 IP 地址列表：
- en: '![](../images/00251.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00251.jpeg)'
- en: 'To create a script that will accept a text file as input, we can either modify
    the existing script from the previous exercise or create a new script file. To
    utilize this list of IP addresses in our script, we will need to perform some
    file handling in Python. An example of a working script might look like the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个接受文本文件作为输入的脚本，我们可以修改前一个练习中的现有脚本，或创建一个新的脚本文件。为了在脚本中使用这份 IP 地址列表，我们需要在 Python
    中执行一些文件操作。一个可行的脚本示例如下所示：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The only real difference between this script and the one that was previously
    used to cycle through a sequential series is the creation of a variable called
    `file` rather than `interface`. The `open()` function is then used to create an
    object by opening the `iplist.txt` file in the same directory as the script. The
    `r` value is also passed to the function to specify read-only access to the file.
    The `for` loop cycles through each IP address listed in the file and then outputs
    IP addresses that reply to the broadcast ARP requests. This script can be executed
    in the same manner as discussed earlier:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本与之前用于循环遍历序列的脚本之间唯一的区别，是创建了一个名为`file`的变量，而不是`interface`。然后使用`open()`函数打开与脚本位于同一目录中的`iplist.txt`文件来创建一个对象。`r`值也传递给该函数，以指定对文件的只读访问。`for`循环遍历文件中列出的每个
    IP 地址，并输出对广播 ARP 请求做出响应的 IP 地址。此脚本可以按照前面讨论的相同方式执行：
- en: '![](../images/00021.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: 'If the script is executed without any arguments supplied, the usage is output
    to the screen. The usage output indicates that this script requires a single argument
    that defines the input list of IP addresses to be scanned. In the following example,
    the script is executed using an `iplist.txt` file in the execution directory:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本在没有任何参数的情况下执行，使用方法将输出到屏幕。该输出提示此脚本需要一个参数，该参数定义了要扫描的 IP 地址输入列表。在以下示例中，脚本使用执行目录中的`iplist.txt`文件执行：
- en: '![](../images/00088.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00088.jpeg)'
- en: 'Once run, the script will only output the IP addresses that are in the input
    file and are also responding to ARP request traffic. Each of these addresses represents
    a system that is alive on the LAN. In the same manner as discussed earlier, the
    output of this script can be easily redirected to a file using the greater-than
    sign followed by the desired name of the output file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，脚本将只输出输入文件中存在并且对 ARP 请求流量有响应的 IP 地址。每个地址都表示局域网中活跃的系统。如前所述，脚本的输出可以轻松地通过大于符号重定向到文件，并指定输出文件的名称：
- en: '![](../images/00153.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00153.jpeg)'
- en: Once the output has been redirected to the output file, you can use the `ls`
    command to verify that the file was written to the filesystem, or you can use
    the `cat` command to view the contents of the file.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输出被重定向到输出文件，你可以使用 `ls` 命令来验证文件是否已写入文件系统，或者你可以使用 `cat` 命令来查看文件的内容。
- en: Layer 3 discovery - ICMP
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三层发现 - ICMP
- en: 'In order to send an ICMP echo request using Scapy, we will need to start stacking
    layers to send requests. A good rule of thumb when stacking packets is to work
    up through the layers of the OSI model. You can stack multiple layers by separating
    each layer with a forward slash. To generate an ICMP echo request, an IP layer
    needs to be stacked with an ICMP request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Scapy 发送 ICMP 回显请求，我们需要开始堆叠层以发送请求。堆叠数据包时的一个好规则是沿着 OSI 模型的层次结构进行操作。你可以通过使用斜杠分隔每一层来堆叠多个层。为了生成
    ICMP 回显请求，需要将 IP 层与 ICMP 请求层堆叠在一起：
- en: 'To get started, use the `scapy` command to open the Scapy interactive console,
    and then assign an `IP` object to a variable:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，使用 `scapy` 命令打开 Scapy 交互式控制台，然后将 `IP` 对象分配给一个变量：
- en: '![](../images/00334.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00334.jpeg)'
- en: 'In the example provided, the `display()` function was used to view the default
    configurations of the object attributes after it was assigned to the `ip` variable.
    By default, the `IP` object is configured to send and receive using the loopback
    IP address of `127.0.0.1`. To change any attribute of an object in Scapy, you
    need to set `[object].[attribute]` equal to the desired value. In this case, we
    want to change the destination IP address to the address of the system that we
    would like to send the ICMP request to, as shown in the following set of commands:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，`display()` 函数用于查看对象属性在分配给 `ip` 变量后默认的配置。默认情况下，`IP` 对象被配置为使用回环 IP 地址
    `127.0.0.1` 进行发送和接收。要更改 Scapy 中对象的任何属性，你需要将 `[object].[attribute]` 设置为所需的值。在这种情况下，我们希望将目标
    IP 地址更改为我们希望发送 ICMP 请求的系统的地址，具体操作如以下命令所示：
- en: '![](../images/00302.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00302.jpeg)'
- en: 'After assigning the new value to the destination address attribute, the changes
    can be verified by calling the `display()` function once again. Notice that when
    the destination IP address value is changed to any other value, the source address
    is also automatically updated from the loopback address to the IP address associated
    with the default interface. Now that the attributes of the `IP` object have been
    appropriately modified, we will need to create the second layer in our packet
    stack. The next layer to be added to the stack is the ICMP layer, which we will
    assign to a separate variable:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将新值分配给目标地址属性后，可以通过再次调用 `display()` 函数来验证更改。请注意，当目标 IP 地址值更改为任何其他值时，源地址也会自动从回环地址更新为与默认接口关联的
    IP 地址。现在，`IP` 对象的属性已经适当修改，我们需要在我们的数据包堆栈中创建第二层。接下来要添加到堆栈的层是 ICMP 层，我们将把它分配给一个单独的变量：
- en: '![](../images/00351.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00351.jpeg)'
- en: 'In the example provided, the ICMP object was initialized with the `ping` variable
    name. The `display()` function can then be called to display the default configurations
    of the ICMP attributes. To perform an ICMP echo request, the default configurations
    are sufficient. Now that both layers have been configured correctly, they can
    be stacked in preparation to send. In Scapy, layers can be stacked by separating
    each layer with a forward slash. Have a look at the following set of commands:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，ICMP 对象被初始化为 `ping` 变量名。然后，可以调用 `display()` 函数来显示 ICMP 属性的默认配置。要执行 ICMP
    回显请求，默认配置已足够。现在，两个层已经正确配置，它们可以堆叠起来准备发送。在 Scapy 中，可以通过使用斜杠分隔每一层来堆叠层。请看以下命令：
- en: '![](../images/00672.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00672.jpeg)'
- en: 'Once the stacked layers have been assigned to a variable, the `display()` function
    will then show the entire stack. The process of stacking layers in this manner
    is often referred to as datagram encapsulation. Now that the layers have been
    stacked, the request is ready to be sent across the wire. This can be done using
    the `sr1()` function in Scapy:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦堆叠的层被分配给变量，`display()` 函数将显示整个堆栈。以这种方式堆叠层的过程通常被称为数据报封装。现在，层已经堆叠完毕，请求已经准备好通过网络发送。这可以通过
    Scapy 中的 `sr1()` 函数完成：
- en: '![](../images/00057.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00057.jpeg)'
- en: 'In the example provided, the `sr1()` function is assigned to the `ping_reply`
    variable. This executes the function and then passes the result to this variable.
    After receiving the response, the `display()` function is used on the `ping_reply`
    variable to see the contents of the response. Notice that this packet was sent
    from the host to which we sent the initial request, and the destination address
    is the IP address of our Kali system. Additionally, notice that the ICMP type
    of the response is an echo reply. This process of sending and receiving ICMP with
    Scapy may seem functional, based on this example, but if you attempt to use the
    same process with a non-responsive target address, you will quickly notice the
    problem:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，`sr1()`函数被分配给`ping_reply`变量。这将执行该函数，并将结果传递给该变量。在收到回应后，`display()`函数被应用于`ping_reply`变量，以查看响应的内容。请注意，该数据包是从我们发送初始请求的主机发送的，目标地址是我们Kali系统的IP地址。另外，请注意，响应的ICMP类型是回显应答。根据这个示例，使用Scapy发送和接收ICMP似乎是功能正常的，但如果你尝试用一个没有响应的目标地址进行相同的操作，你会很快发现问题：
- en: '![](../images/00585.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00585.jpeg)'
- en: 'The example output was truncated, but this output will continue indefinitely
    until you force an escape with *Ctrl* + *C*. Without supplying a timeout value
    to the function, the `sr1()` function will continue to listen until a response
    is received. If a host is not alive or if the IP address is not associated with
    any host, no response will be sent, and the function will not exit. To use this
    function effectively within a script, a timeout value should be defined:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例输出被截断，但这个输出会持续不断，直到你通过*Ctrl* + *C*强制中断。如果没有向函数提供超时值，`sr1()`函数将继续监听，直到收到响应。如果主机未启动或IP地址未与任何主机关联，将不会发送响应，函数也不会退出。为了在脚本中有效使用此函数，应该定义一个超时值：
- en: '![](../images/00596.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00596.jpeg)'
- en: 'By supplying a timeout value as a second argument passed to the `sr1()` function,
    the process will then exit if no response is received within the designated number
    of seconds. In the example provided, the `sr1()` function is used to send the
    ICMP request to a nonresponsive address that is exited after 1 second because
    no response was received. In the examples provided so far, we have assigned functions
    to variables to create objects that are persistent and can be manipulated. However,
    these functions do not have to be assigned to variables but can also be generated
    by calling the functions directly:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将超时值作为第二个参数传递给`sr1()`函数，若在指定的秒数内未收到响应，过程将退出。在提供的示例中，`sr1()`函数用于向一个没有响应的地址发送ICMP请求，1秒后退出，因为没有收到回应。在目前提供的示例中，我们已经将函数分配给变量，创建了可以持久化并可操作的对象。然而，这些函数不一定要分配给变量，也可以通过直接调用函数来生成：
- en: '![](../images/00270.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00270.jpeg)'
- en: 'In the example provided here, all of the work that was done earlier with four
    separate commands can actually be accomplished with a single command by directly
    calling the functions. Notice that if an ICMP request is sent to an IP address
    that does not reply within the timeframe specified by the timeout value, calling
    the object will result in an exception. As no response was received, the answer
    variable in this example that was set equal to the response is never initialized:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里提供的示例中，之前通过四个独立命令完成的所有工作实际上可以通过直接调用函数来通过单个命令完成。请注意，如果向一个在超时值指定的时间内没有回复的IP地址发送ICMP请求，调用该对象将会导致异常。由于没有收到回应，本示例中设置为响应的答案变量从未被初始化：
- en: '![](../images/00347.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00347.jpeg)'
- en: 'Knowledge of these varied responses can be used to generate a script that will
    perform ICMP requests on multiple IP addresses in sequence. The script will loop
    through all of the possible values for the last octet in the destination IP address,
    and for each value, it will send an ICMP request. As each `sr1()` function is
    returned, the response is evaluated to determine whether an echo response was
    received:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些不同的响应知识可以用来生成一个脚本，该脚本会依次对多个IP地址执行ICMP请求。脚本将循环通过目标IP地址中最后一个八位字节的所有可能值，并为每个值发送一个ICMP请求。每次返回`sr1()`函数时，都会评估响应以确定是否收到回显响应：
- en: '[PRE2]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line of the script indicates where the Python interpreter is located
    so that the script can be executed without it being passed to the interpreter.
    The script then imports all Scapy functions and also defines Scapy logging levels
    to eliminate unnecessary output in the script.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本的第一行指示了Python解释器的位置，以便可以在不将其传递给解释器的情况下执行脚本。然后，脚本导入所有Scapy函数，并定义Scapy日志级别，以消除脚本中不必要的输出。
- en: The second block of code is a conditional test that evaluates whether the required
    argument is supplied to the script. If the required argument is not supplied upon
    execution, the script will then output an explanation of appropriate script usage.
    This explanation includes the usage of the tool, an example, and an explanation
    of the task that will be performed by this example.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二块代码是一个条件测试，用于评估是否已为脚本提供所需的参数。如果在执行时没有提供所需的参数，脚本将输出适当脚本使用的说明。该说明包括工具的使用方法、一个示例以及通过此示例将执行的任务的解释。
- en: After this block of code, the supplied value is assigned to the `address` variable.
    That value is then used to extract the network prefix. For example, if the `address`
    variable contains the `192.168.11.0` string , the value of `192.168.11` will be
    assigned to the `prefix` variable.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此块代码之后，提供的值将分配给`address`变量。然后使用该值提取网络前缀。例如，如果`address`变量包含`192.168.11.0`字符串，则`192.168.11`的值将被分配给`prefix`变量。
- en: The final block of code is a `for` loop that performs the actual scanning. The
    `for` loop cycles through all values between `0` and `254`, and for each iteration,
    the value is then appended to the network prefix. In the case of the example provided
    earlier, an ICMP echo request would be sent to each IP address between `192.168.11.0`
    and `192.168.11.254`. For each live host that does reply, the corresponding IP
    address is then printed to the screen to indicate that the host is alive on the
    LAN.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一块代码是一个`for`循环，用于执行实际的扫描。`for`循环会遍历`0`到`254`之间的所有值，并且对于每次迭代，值会附加到网络前缀上。在前面提供的示例中，ICMP回显请求将发送到`192.168.11.0`到`192.168.11.254`之间的每个IP地址。对于每个有响应的活动主机，相应的IP地址将打印到屏幕上，以指示该主机在局域网中处于活动状态。
- en: 'Once the script has been written to the local directory, you can execute it
    in the Terminal using a period and forward slash, followed by the name of the
    executable script:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本被写入本地目录，你可以使用一个点和正斜杠，在终端中执行该脚本，后跟可执行脚本的名称：
- en: '![](../images/00631.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00631.jpeg)'
- en: 'If the script is executed without any arguments supplied, the usage is output
    to the screen. The usage output indicates that this script requires a single argument
    that defines the `/24` network to scan. In the example provided, the script is
    executed using the `172.16.36.0` network address. The script then outputs a list
    of live IP addresses in the `/24` network range. This output can also be redirected
    to an output text file using a greater-than sign followed by the output filename.
    An example of this is as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本在没有任何参数的情况下执行，使用方法将输出到屏幕上。该使用说明表明此脚本需要一个参数，用于定义要扫描的`/24`网络。在提供的示例中，脚本使用`172.16.36.0`网络地址执行。然后，脚本输出`/24`网络范围内的活动IP地址列表。此输出还可以通过大于号后跟输出文件名来重定向到输出文本文件中。以下是一个示例：
- en: '![](../images/00512.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00512.jpeg)'
- en: 'The `ls` command can then be used to verify that the output file was written
    to the filesystem, or the `cat` command can be used to view its contents. This
    script can also be modified to accept a list of IP addresses as input. To do this,
    the `for` loop must be changed to loop through the lines that are read from the
    specified text file. An example of this can be seen as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以使用`ls`命令来验证输出文件是否已写入文件系统，或者使用`cat`命令查看其内容。此脚本也可以修改为接受一系列IP地址作为输入。为此，`for`循环必须更改为循环读取指定文本文件中的行。以下是一个示例：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The only major difference from the prior script is that this one accepts an
    input `filename` as an argument and then loops through each IP address listed
    in this file to scan. Similar to the other script, the resulting output will include
    a simple list of IP addresses associated with systems that responded to the ICMP
    echo request with an ICMP echo response:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的脚本相比，唯一的主要区别是此脚本接受一个输入`filename`作为参数，然后循环扫描此文件中列出的每个IP地址。与另一个脚本类似，最终的输出将包括一个简单的IP地址列表，列出那些对ICMP回显请求做出响应的系统的IP地址：
- en: '![](../images/00478.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00478.jpeg)'
- en: 'The output of this script can be redirected to an output file in the same way.
    Execute the script with the input file supplied as an argument and then redirect
    the output using a greater-than sign followed by the name of the output text file.
     An example of this can be seen as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本的输出可以像这样重定向到输出文件。执行脚本时，输入文件作为参数提供，然后通过大于符号和输出文本文件的名称重定向输出。以下是一个示例：
- en: '![](../images/00637.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00637.jpeg)'
- en: Layer 4 discovery - TCP and UDP
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4层发现 - TCP和UDP
- en: To verify that an RST response is received from a live host, we can use Scapy
    to send a TCP ACK packet to a known live host. In the example provided, the ACK
    packet will be sent to the TCP destination port `80`. This port is commonly used
    to run HTTP web services. The host used in the demonstration currently has an
    Apache service running on this port.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证从活跃主机收到RST响应，我们可以使用Scapy发送一个TCP ACK数据包到已知的活跃主机。在提供的示例中，ACK数据包将被发送到TCP目标端口`
    80 `。该端口通常用于运行HTTP Web服务。演示中使用的主机目前在此端口上运行Apache服务。
- en: 'To do this, we need to build each of the layers of our request. The first layer
    to be built is the IP layer. Have a look at the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们需要构建请求的每一层。首先要构建的层是IP层。请看以下命令：
- en: '![](../images/00484.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00484.jpeg)'
- en: 'Here, we have initialized the `i` variable as an `IP` object and then reconfigured
    the standard configurations to set the destination address to the IP address of
    our target server. Notice that the source IP address is automatically updated
    when any IP address other than the loopback address is provided for the destination
    address. The next layer we need to build is our TCP layer. This can be seen in
    the commands that follow:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将` i `变量初始化为` IP `对象，然后重新配置标准配置，将目标地址设置为我们目标服务器的IP地址。请注意，当目标地址提供了除回环地址以外的任何IP地址时，源IP地址会自动更新。接下来，我们需要构建的层是TCP层。可以在以下命令中看到：
- en: '![](../images/00486.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00486.jpeg)'
- en: 'Here, we have initialized the `t` variable as a `TCP` object. Notice that the
    default configurations for the object already have the destination port set to
    HTTP or port `80`. Here, we only needed to change the TCP flags from SYN (`S`)
    to ACK (`A`). Now, the stack can be built by separating each of the layers with
    a forward slash, as seen in the following commands:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将` t `变量初始化为` TCP `对象。请注意，对象的默认配置已经将目标端口设置为HTTP或端口` 80 `。在这里，我们只需要将TCP标志从SYN（`
    S `）更改为ACK（` A `）。现在，可以通过用正斜杠分隔每一层来构建堆栈，具体见以下命令：
- en: '![](../images/00489.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00489.jpeg)'
- en: 'Here, we have set the entire request stack equal to the request variable. Now,
    the request can be sent across the wire with the send and receive function, and
    then the response can be evaluated to determine the status of the target address:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将整个请求堆栈设置为请求变量。现在，可以通过发送和接收函数将请求发送到网络中，然后评估响应以确定目标地址的状态：
- en: '![](../images/00026.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: 'Notice that the remote system responds with a TCP packet that has the RST flag
    set. This is indicated by the `R` value assigned to the `flags` attribute. The
    entire process of stacking the request and sending and receiving the response
    can be compressed into a single command by calling the functions directly:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，远程系统响应了一个TCP数据包，并且设置了RST标志。这由分配给` flags `属性的` R `值表示。请求堆栈的整个过程以及发送和接收响应，可以通过直接调用函数将其压缩为单个命令：
- en: '![](../images/00493.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00493.jpeg)'
- en: 'Now that we have identified the response associated with an ACK packet sent
    to an open port on a live host, let''s attempt to send a similar request to a
    closed port on a live system and identify whether there is any variation in response:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经确定了与发送到活跃主机开放端口的ACK数据包相关的响应，接下来让我们尝试向活跃系统的关闭端口发送类似的请求，并确定响应中是否有任何变化：
- en: '![](../images/00495.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00495.jpeg)'
- en: 'In this request, the destination TCP port was changed from the default port
    `80` to the port `1111` (a port on which no service is running). Notice that the
    response that is returned from both an open port and a closed port on a live system
    is the same. Regardless of whether this is a service actively running on the scanned
    port, a live system will return an RST response. Additionally, it should be noted
    that if a similar scan is sent to an IP address that is not associated with a
    live system, no response will be returned. This can be verified by modifying the
    destination IP address in the request to one that is not associated with an actual
    system on the network:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个请求中，目标 TCP 端口从默认端口`80`更改为端口`1111`（一个没有服务运行的端口）。请注意，从开放端口和关闭端口返回的响应是相同的。无论扫描端口上是否有服务在运行，活跃的系统都会返回一个
    RST 响应。此外，还应注意，如果类似的扫描发送到与活跃系统无关的 IP 地址，则不会返回任何响应。可以通过将请求中的目标 IP 地址修改为与网络上实际系统无关的地址来验证这一点：
- en: '![](../images/00066.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: 'So, in review, we discovered that an ACK packet sent to a live host on any
    port, regardless of the port status, will return an RST packet, but no response
    will be received from an IP if no live host is associated with it. This is excellent
    news because it means that we can perform a discovery scan on a large number of
    systems by only interacting with a single port on each system. Using Scapy in
    conjunction with Python, we can quickly loop through all of the addresses in a
    `/24` network range and send a single ACK packet to only one TCP port on each
    system. By evaluating the response returned by each host, we can easily output
    a list of live IP addresses:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，回顾一下，我们发现无论端口状态如何，发送到任何端口的 ACK 数据包都会返回一个 RST 数据包，但如果没有活跃主机与该 IP 地址关联，则不会收到响应。这是一个好消息，因为它意味着我们可以通过只与每个系统的单个端口进行交互，在大量系统上执行发现扫描。结合使用
    Scapy 和 Python，我们可以快速循环遍历`/24`网络范围内的所有地址，并仅向每个系统的一个 TCP 端口发送一个 ACK 数据包。通过评估每个主机返回的响应，我们可以轻松输出一个活跃
    IP 地址列表：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The example script that is provided is fairly simple. While looping through
    each of the possible values for the last octet in the IP address, the ACK packet
    is sent to the TCP port `80`, and the response is evaluated to determine whether
    the integer conversion of the TCP flag within the response has the value of `4`
    (the value associated with a solitary RST flag). If the packet has an RST flag,
    the script outputs the IP address of the system that returned the response. If
    no response is received, Python is unable to test the value of the response variable
    as no value is assigned to it. As such, an exception will occur if no response
    is returned. If an exception is returned, the script will then pass. The resulting
    output is a list of live target IP addresses. This script can be executed using
    a period and forward slash, followed by the name of the executable script:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的示例脚本相对简单。在循环遍历 IP 地址最后一个八位字节的所有可能值时，ACK 数据包被发送到 TCP 端口`80`，并评估响应以确定响应中 TCP
    标志的整数值是否为`4`（与单独的 RST 标志相关的值）。如果数据包有 RST 标志，脚本将输出返回响应的系统的 IP 地址。如果没有收到响应，则 Python
    无法测试响应变量的值，因为没有为其分配任何值。因此，如果没有返回响应，将发生异常。如果返回异常，脚本将继续运行。最终输出是一个活跃目标 IP 地址的列表。可以使用一个句点和斜杠，然后是可执行脚本的名称来执行此脚本：
- en: '![](../images/00232.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00232.jpeg)'
- en: 'Similar discovery methods can be used to perform layer 4 discovery using the
    UDP protocol. To determine whether we can discover a host using the UDP protocol,
    we need to determine how to trigger a response from any live host with UDP, regardless
    of whether the system has a service running on the UDP port. To attempt this,
    we will first build our request stack in Scapy:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用类似的发现方法，通过 UDP 协议执行第 4 层的发现。为了确定我们是否能够使用 UDP 协议发现主机，我们需要确定如何触发任何活跃主机的响应，无论系统是否在
    UDP 端口上运行服务。为了尝试这个方法，我们将首先在 Scapy 中构建请求栈：
- en: '![](../images/00503.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00503.jpeg)'
- en: 'Notice that the default source and destination port for the UDP object is DNS.
    This is a commonly used service that can be used to resolve domain names to IP
    addresses. Sending the request as it is will prove to be of very little help in
    determining whether the IP address is associated with a live host. An example
    of sending this request can be seen in the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，UDP对象的默认源端口和目标端口是DNS。这是一个常用的服务，可以用于将域名解析为IP地址。按原样发送请求对于判断IP地址是否与活动主机相关联几乎没有帮助。发送此请求的示例如下所示：
- en: '![](../images/00647.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00647.jpeg)'
- en: 'Despite the fact that the host associated with the destination IP address is
    alive, we receive no response. Ironically, the lack of response is actually due
    to the fact that the DNS service is in use on the target system. Despite what
    you might naturally think, it can sometimes be more effective to attempt to identify
    hosts by probing UDP ports that are not running services, assuming that ICMP traffic
    is not blocked by a firewall. This is because live services are often configured
    to only respond to requests that contain specific content. Now, we will attempt
    to send the same request to a different UDP port that is not in use:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管与目标IP地址相关联的主机是活动的，但我们没有收到任何响应。具有讽刺意味的是，没有响应的原因实际上是目标系统上正在使用DNS服务。尽管你可能会自然地认为，相反的做法有时可以通过探测那些没有运行服务的UDP端口来更有效地识别主机，前提是ICMP流量没有被防火墙阻止。这是因为，活动的服务通常配置为仅响应包含特定内容的请求。现在，我们将尝试向一个未使用的不同UDP端口发送相同的请求：
- en: '![](../images/00023.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: By changing the request destination to port `123` and then resending it, we
    now receive a response indicating that the destination port is unreachable. If
    you examine the source IP address of this response, you can see that it was sent
    from the host to which the original request was sent. This response then confirms
    that the host at the original destination IP address is alive. Unfortunately,
    a response is not always returned in these circumstances. The effectiveness of
    this technique largely depends on the systems that you are probing and their configurations.
    It is because of this that UDP discovery is often more difficult to perform than
    TCP discovery. It is never as easy as just sending a TCP packet with a single
    flag lit up. In the case that services do exist, service-specific probes are often
    needed.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将请求的目标端口更改为`123`并重新发送，我们现在收到的响应表明目标端口不可达。如果你检查此响应的源IP地址，你会看到它是从原始请求发送到的主机发送的。这一响应确认了原始目标IP地址上的主机是活动的。不幸的是，在这些情况下，响应并不总是会返回。此技术的有效性很大程度上取决于你正在探测的系统及其配置。正因如此，UDP发现通常比TCP发现更难执行。它永远不像简单地发送一个带有单个标志的TCP数据包那么容易。如果确实存在服务，通常需要特定服务的探测。
- en: Fortunately, there are a variety of fairly complex UDP-scanning tools that can
    employ a range of UDP requests and service-specific probes to determine whether
    a live host is associated with any given IP address.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有多种相当复杂的UDP扫描工具，可以使用一系列的UDP请求和特定服务探测来判断某个活动主机是否与给定的IP地址相关联。
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: ARP layer 2 discovery is possible in Scapy by employing the use of the `sr1()`
    (send/receive one) function. This function injects a packet, as defined by the
    supplied argument, and then waits to receive a single response. In this case,
    a single ARP request is broadcast, and the function will return the response.
    The Scapy library makes it possible to easily integrate this technique into a
    script and enables the testing of multiple systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scapy中，通过使用`sr1()`（发送/接收一个）函数，可以进行ARP第2层发现。该函数注入一个由提供的参数定义的数据包，然后等待接收单个响应。在这种情况下，会广播一个ARP请求，函数将返回响应。Scapy库使得将此技术轻松集成到脚本中，并能够测试多个系统。
- en: ICMP layer 3 discovery was performed here with Scapy by crafting a request that
    includes both an IP layer and an appended ICMP request. The IP layer allowed the
    packet to be routed outside the local network, and the ICMP request was used to
    solicit a response from the remote system. Using this technique in a Python script,
    this task can be performed in sequence to scan multiple systems or entire network
    ranges.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用Scapy进行了ICMP第3层发现，通过构造一个包含IP层和附加ICMP请求的请求来实现。IP层允许数据包被路由到本地网络之外，而ICMP请求则用来从远程系统获取响应。使用这种技术在Python脚本中，可以按顺序执行此任务，以扫描多个系统或整个网络范围。
- en: TCP and UDP layer 4 discovery methods were used by Scapy to craft custom requests
    to identify live hosts using each of these protocols. In the case of TCP, the
    custom ACK packets were constructed and sent to an arbitrary port on each target
    system. If an RST reply was received, the system was identified as alive. Alternatively,
    empty UDP requests were sent to arbitrary ports to attempt to solicit an ICMP
    port unreachable response. Responses were used as an indication of a live system.
    Each of these techniques can be used in a Python script to perform discovery against
    multiple hosts or against a range of addresses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy使用TCP和UDP第四层发现方法，构建自定义请求，通过每个协议识别存活的主机。在TCP的情况下，构建并发送自定义ACK数据包到每个目标系统的任意端口。如果收到RST回复，则系统被识别为存活。或者，向任意端口发送空的UDP请求，试图引发ICMP端口不可达响应。通过响应来判断系统是否存活。这些技术中的每一种都可以在Python脚本中使用，用于对多个主机或地址范围执行发现。
- en: Using Nmap to perform host discovery (layers 2/3/4)
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nmap执行主机发现（第二、三、四层）
- en: '**Network Mapper** (**Nmap**) is one of the most effective and functional tools
    in Kali Linux. Nmap can be used to perform a large range of different scanning
    techniques and is highly customizable. This tool will be addressed frequently
    throughout the course of this book. In this recipe, we will discuss how to use
    Nmap to perform layer 2 scanning with ARP, layer 3 scanning with ICMP, and layer
    4 scanning utilizing TCP/UDP.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络映射器**（**Nmap**）是Kali Linux中最有效和最具功能性的工具之一。Nmap可用于执行多种不同的扫描技术，并且高度可定制。本书中将频繁提到这个工具。在本节中，我们将讨论如何使用Nmap执行ARP的第二层扫描、ICMP的第三层扫描，以及利用TCP/UDP的第四层扫描。'
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Nmap to perform ARP discovery, you will need to have at least one system
    on the LAN that will respond to ARP requests. In the examples provided, a combination
    of Linux and Windows systems are used. For more information on setting up systems
    in a local lab environment, refer to the *Installing Metasploitable2* and *Installing
    Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用Nmap执行ARP发现，你需要在局域网上至少有一台系统能够响应ARP请求。在所提供的示例中，使用了Linux和Windows系统的组合。关于在本地实验室环境中设置系统的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)《入门》中的*安装Metasploitable2*和*安装Windows
    Server*的配方。
- en: Using Nmap to perform layer 3 and layer 4 discovery does not require a lab environment,
    as many systems on the Internet will reply to ICMP echo requests, as well as both
    TCP and UDP traffic. However, it is highly recommended that you perform any type
    of network scanning exclusively in your own lab unless you are thoroughly familiar
    with the legal regulations imposed by any governing authorities to whom you are
    subject. If you wish to perform this technique within your lab, you will need
    to have at least one system that will respond to ICMP, TCP, and UDP requests.
    In the examples provided, a combination of Linux and Windows systems are used.
    For more information on setting up systems in a local lab environment, refer to
    the the *Installing Metasploitable2* and *Installing Windows Server* recipes in
    [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting Started*.
    Additionally, this section will require a script to be written to the filesystem,
    using a text editor such as Vim or GNU nano. For more information on writing scripts,
    refer to the *Using text editors (VIM and GNU nano)* recipe in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nmap执行第三层和第四层发现不需要实验室环境，因为互联网上许多系统都会回复ICMP回显请求，以及TCP和UDP流量。然而，强烈建议你仅在自己的实验室环境中进行任何类型的网络扫描，除非你对所受管辖的法律规定非常熟悉。如果你希望在实验室中执行该技术，你至少需要有一个系统能够响应ICMP、TCP和UDP请求。在所提供的示例中，使用了Linux和Windows系统的组合。关于在本地实验室环境中设置系统的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)《入门》中的*安装Metasploitable2*和*安装Windows
    Server*的配方。此外，本节将需要编写脚本到文件系统中，可以使用如Vim或GNU nano的文本编辑器进行编写。关于编写脚本的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)《入门》中的*使用文本编辑器（VIM和GNU
    nano）*配方。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: As in the previous recipe, we'll go through this layer by layer.  In this layer,
    we will use Nmap to perform discovery at layers 2, 3, and 4.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如同前面的方法，我们将逐层进行。在这一层，我们将使用Nmap执行第二、三、四层的发现。
- en: Layer 2 discovery - ARP
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二层发现 - ARP
- en: 'Nmap is another option for performing automated layer 2 discovery scans with
    a single command. The `-sn` option is referred to by Nmap as a ping scan. Although
    the term **ping scan** naturally leads you to think that layer 3 discovery is
    being performed, it is actually adaptive:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap是执行自动化第二层发现扫描的另一种选择，只需一个命令即可完成。Nmap将`-sn`选项称为ping扫描。尽管**ping扫描**这个术语自然让你认为是在进行第三层发现，但它实际上是自适应的：
- en: 'Assuming that addresses on the same local subnet are specified as the argument,
    a layer 2 scan can be performed with the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设指定的是同一局域网子网中的地址作为参数，可以使用以下命令执行第二层扫描：
- en: '![](../images/00091.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00091.jpeg)'
- en: 'This command will send an ARP request to the LAN broadcast address and will
    determine whether the host is alive, based on the response that is received. Alternatively,
    if the command is used against an IP address of a host that is not alive, the
    response will indicate that the host is down:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将向局域网广播地址发送ARP请求，并根据接收到的响应判断主机是否存活。或者，如果命令用于扫描不活跃的主机的IP地址，响应将指示该主机已关闭：
- en: '![](../images/00675.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00675.jpeg)'
- en: 'This command can be modified to perform layer 2 discovery on a sequential series
    of IP addresses, using dash notation. To scan a full `/24` range, you can use
    `0-255`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以修改此命令，通过破折号表示法对一系列IP地址进行第二层发现扫描。要扫描完整的`/24`地址范围，可以使用`0-255`：
- en: '![](../images/00159.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00159.jpeg)'
- en: 'Using this command will send out broadcast ARP requests for all hosts within
    that range and will determine each host that is actively responding. This scan
    can also be performed against an input list of IP addresses, using the `-iL` option:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令将会向该范围内的所有主机广播ARP请求，并确定每个积极响应的主机。此扫描也可以通过输入IP地址列表来执行，使用`-iL`选项：
- en: '![](../images/00305.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00305.jpeg)'
- en: 'When the `-sn` option is used, Nmap will first attempt to locate the host using
    layer 2 ARP requests, and it will only use layer 3 ICMP requests if the host is
    not located on the LAN. Notice how an Nmap ping scan performed against the hosts
    on the local network (on the `172.16.36.0/24` private range) returns MAC addresses.
    This is because the MAC addresses are returned by the ARP response from the hosts.
    However, if the same Nmap ping scan is performed against remote hosts on a different
    LAN, the response will not include system MAC addresses:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`-sn`选项时，Nmap会首先尝试通过第二层ARP请求来定位主机，如果主机未在局域网内找到，才会使用第三层ICMP请求。注意，针对本地网络（`172.16.36.0/24`私有地址范围）的Nmap
    ping扫描会返回MAC地址，这是因为MAC地址是通过ARP响应从主机处返回的。然而，如果相同的Nmap ping扫描针对远程网络上的主机进行，响应中将不会包含系统的MAC地址：
- en: '![](../images/00195.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00195.jpeg)'
- en: When performed against a remote network range (public range `74.125.21.0/24`),
    you can see that layer 3 discovery was used, as no MAC addresses were returned.
    This demonstrates that when possible, Nmap will automatically leverage the speed
    of layer 2 discovery, but when necessary, it will use routable ICMP requests to
    discover remote hosts on layer 3\. This can also be seen if you use Wireshark
    to monitor traffic while an Nmap ping scan is performed against hosts on the local
    network.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当针对远程网络范围（公用地址范围`74.125.21.0/24`）执行时，可以看到使用了第三层发现，因为没有返回MAC地址。这表明，当可能时，Nmap会自动利用第二层发现的速度，但在必要时，它会使用可路由的ICMP请求来发现第三层上的远程主机。如果你在进行Nmap
    ping扫描时使用Wireshark监控流量，也可以看到这一点，尤其是当扫描本地网络上的主机时。
- en: 'In the following screenshot, you can see that Nmap utilizes ARP requests to
    identify hosts on the local segment:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到Nmap利用ARP请求识别本地段上的主机：
- en: '![](../images/00209.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00209.jpeg)'
- en: Layer 3 discovery - ICMP
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三层发现 - ICMP
- en: Nmap is an adaptive tool that will automatically adjust and use layer 2, layer
    3, or layer 4 discovery as needed. If the `-sn` option is used in Nmap to scan
    IP addresses that do not exist on the local network segment, ICMP echo requests
    will be used to determine whether the hosts are alive and responding.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap是一个自适应工具，会根据需要自动调整并使用第二层、第三层或第四层发现技术。如果在Nmap中使用`-sn`选项扫描本地网络段上不存在的IP地址，将使用ICMP回显请求来确定主机是否存活并响应。
- en: 'To perform an ICMP scan of a single target, use Nmap with the `-sn` option,
    and pass the IP address to be scanned as an argument:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行单个目标的ICMP扫描，使用带有`-sn`选项的Nmap，并将要扫描的IP地址作为参数传递：
- en: '![](../images/00523.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00523.jpeg)'
- en: 'The output of this command will indicate whether the device is up and will
    also provide details about the scan performed. Additionally, notice that the system
    name is also identified. Nmap also performs DNS resolution to provide this information
    in the scan output. It can also be used to scan a sequential range of IP addresses,
    using dash notation. Nmap is multithreaded by default and runs multiple processes
    in parallel. As such, Nmap is very fast in returning scan results. Have a look
    at the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令的输出将指示设备是否在线，并提供有关执行的扫描的详细信息。另外，请注意也识别了系统名称。Nmap还执行DNS解析以在扫描输出中提供此信息。它还可以用来扫描顺序范围内的IP地址，使用破折号表示法。Nmap默认是多线程的，并行运行多个进程。因此，Nmap在返回扫描结果方面非常快速。请看以下命令：
- en: '![](../images/00526.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00526.jpeg)'
- en: 'In the example provided, Nmap is used to scan an entire `/24` network range.
    For convenience of viewing, the output of this command was truncated. By analyzing
    the traffic passing across the interface with Wireshark, you may notice that the
    addresses are not sequentially scanned. This can be seen in the following screenshot.
    This is further evidence of the multithreaded nature of Nmap and illustrates how
    processes are initiated from addresses in a queue as other processes complete:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，Nmap用于扫描整个`/24`网络范围。为了方便查看，该命令的输出被截断了。通过使用Wireshark分析通过接口传递的流量，您可能会注意到地址并未按顺序扫描。这可以在以下截图中看到。这进一步证明了Nmap的多线程特性，并说明了如何从队列中启动地址作为其他进程完成：
- en: '![](../images/00660.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00660.jpeg)'
- en: 'Alternatively, Nmap can also be used to scan IP addresses from an input text
    file. This can be done using the `-iL` option, followed by the name of the file
    or file path:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，Nmap也可以用来扫描输入文本文件中的IP地址。可以使用`-iL`选项，后跟文件名或文件路径来实现：
- en: '![](../images/00529.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00529.jpeg)'
- en: 'In the example provided, a list of six IP addresses exists in the execution
    directory. This list is then input into Nmap, and each of the listed addresses
    is scanned in an attempt to identify live hosts:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，执行目录中存在一个包含六个IP地址的列表。然后将此列表输入到Nmap中，并尝试识别列出的每个地址的活动主机：
- en: '![](../images/00280.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00280.jpeg)'
- en: Layer 4 discovery - TCP and UDP
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四层发现 - TCP和UDP
- en: 'There are options in Nmap to discover hosts with both TCP and UDP. UDP discovery
    with Nmap is already configured to use unique payloads necessary to trigger replies
    from less-responsive port services:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap中有用于同时发现TCP和UDP主机的选项。Nmap的UDP发现已经配置使用唯一的负载以触发来自响应速度较慢的端口服务的回复：
- en: 'To perform a discovery scan with UDP, use the `-PU` option in conjunction with
    the port to test:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行UDP发现扫描，请与要测试的端口一起使用`-PU`选项：
- en: '![](../images/00534.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00534.jpeg)'
- en: 'Similarly, it is also possible to configure an Nmap UDP ping request to a series
    of IP addresses as defined by an input list. Here, in the example provided, we
    will use the `iplist.txt` file in the same directory to scan each host listed
    within:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，也可以配置Nmap UDP ping请求到由输入列表定义的一系列IP地址。在这里，我们将使用同一目录中的`iplist.txt`文件来扫描列出的每个主机：
- en: '![](../images/00253.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00253.jpeg)'
- en: Although the output from each of these examples indicated that six hosts were
    discovered, this does not necessarily indicate that the six hosts were all discovered
    by means of the UDP discovery method. In addition to the probing performed on
    UDP port `53`, Nmap also will utilize any other discovery technique it can to
    discover hosts within the designated range or within the input list. Although
    the `-sn` option is effective in preventing Nmap from performing a TCP port scan,
    it does not completely isolate our UDP ping request.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然这些示例中的每一个输出都表明发现了六台主机，但这并不一定表示这六台主机都是通过UDP发现方法发现的。除了对UDP端口`53`进行探测外，Nmap还将利用任何其他发现技术来发现指定范围或输入列表中的主机。尽管`-sn`选项有效地防止Nmap执行TCP端口扫描，但它并不能完全隔离我们的UDP
    ping请求。
- en: 'Although there is no effective way to isolate just this task, you can determine
    what hosts were discovered via UDP requests by analyzing the traffic in Wireshark
    or TCPdump. Alternatively, Nmap can also be used to perform a TCP ACK ping in
    the same fashion as was discussed with Scapy. To use ACK packets to identify live
    hosts, use the `-PA` option in conjunction with the port that you would like to
    use:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然没有有效的方法来单独隔离这个任务，但你可以通过在Wireshark或TCPdump中分析流量来确定哪些主机是通过UDP请求发现的。或者，Nmap也可以像我们在Scapy中讨论的那样执行TCP
    ACK ping。要使用ACK数据包识别存活主机，请结合使用`-PA`选项和你想使用的端口：
- en: '![](../images/00327.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00327.jpeg)'
- en: 'The TCP ACK ping-discovery method can also be performed on a range of hosts
    using dash notation, or can be performed on specified host addresses based on
    an input list:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP ACK ping发现方法也可以使用短横符号表示的主机范围进行操作，或者可以基于输入列表在指定的主机地址上执行：
- en: '![](../images/00540.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00540.jpeg)'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Nmap performs layer 2 scanning by sending out ARP requests to the broadcast
    address for a series of IP addresses and identifies live hosts by flagging responses.
    However, because this functionality is already integrated into Nmap, it can be
    executed by simply providing the appropriate arguments.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap通过向一系列IP地址的广播地址发送ARP请求来执行第2层扫描，并通过标记响应来识别存活主机。然而，由于此功能已集成到Nmap中，因此只需提供适当的参数即可执行。
- en: Nmap performs layer 3 scanning by sending out ICMP echo requests for each IP
    address within the supplied range or text file. As Nmap is a multithreaded tool,
    multiple requests are sent out in parallel, and results are quickly returned to
    the user. As Nmap's discovery function is adaptive, it will only use ICMP discovery
    if ARP discovery cannot effectively locate the host on the local subnet. Alternatively,
    if neither ARP discovery nor ICMP discovery is effective in identifying a live
    host at a given IP address, layer 4 discovery techniques will be employed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap通过向提供的IP地址范围或文本文件中的每个IP地址发送ICMP回显请求来执行第3层扫描。由于Nmap是一个多线程工具，多个请求会并行发送，结果会迅速返回给用户。由于Nmap的发现功能具有适应性，它只有在ARP发现无法有效定位本地子网中的主机时，才会使用ICMP发现。或者，如果ARP发现和ICMP发现都无法有效识别给定IP地址上的存活主机，则将采用第4层发现技术。
- en: Nmap performs layer 4 scanning by sending a series of TCP ACK packets to arbitrary
    ports on the target system and attempts to solicit an RST response as an indication
    of a live system. The technique used by Nmap to perform UDP discovery, however,
    is somewhat different than the technique we discussed with Scapy. Rather than
    merely relying on ICMP host-unreachable responses, which can be inconsistent and/or
    blocked, Nmap also performs host discovery by delivering service-specific requests
    to targeted ports in an attempt to solicit a response.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap通过向目标系统的任意端口发送一系列TCP ACK数据包来执行第4层扫描，并尝试获取RST响应，作为系统存活的指示。然而，Nmap用于执行UDP发现的技术与我们在Scapy中讨论的技术略有不同。Nmap不仅仅依赖于ICMP主机不可达响应（这些响应可能不一致或被阻塞），还通过向目标端口发送特定服务的请求，尝试获取响应来执行主机发现。
- en: Using ARPing to perform host discovery (layer 2)
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARPing执行主机发现（第2层）
- en: ARPing is a command-line network utility that has a functionality similar to
    the commonly used `ping` utility. This tool can identify whether a live host is
    on a local network at a given IP by supplying that IP address as an argument.
    This recipe will discuss how to use ARPing to scan for live hosts on a network.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ARPing是一个命令行网络工具，功能类似于常用的`ping`工具。通过提供IP地址作为参数，该工具可以判断给定IP是否为本地网络上的存活主机。本文将讨论如何使用ARPing扫描网络中的存活主机。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use ARPing to perform ARP discovery, you will need to have at least one system
    on the LAN that will respond to ARP requests. In the examples provided, a combination
    of Linux and Windows systems is used. For more information on setting up systems
    in a local lab environment, refer to the *Installing Metasploitable2* and *Installing
    Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*. Additionally, this section will require a script to be written
    to the filesystem, using a text editor such as Vim or GNU nano. For more information
    on writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ARPing 执行 ARP 发现，你需要确保局域网中至少有一台系统能够响应 ARP 请求。在提供的示例中，使用了 Linux 和 Windows
    系统的组合。有关如何在本地实验环境中设置系统的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 和 *安装 Windows Server* 相关内容，*入门* 部分。此外，本节还需要编写一个脚本到文件系统中，可以使用
    Vim 或 GNU nano 等文本编辑器进行编辑。有关编写脚本的更多信息，请参阅 [第 1 章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *使用文本编辑器（Vim 和 GNU nano）* 相关内容，*入门* 部分。
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'ARPing is a tool that can be used to send ARP requests and identify whether
    a host is alive and responding:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ARPing 是一种工具，可以用来发送 ARP 请求，并识别主机是否存活并响应：
- en: 'The tool is used by simply passing an IP address as an argument to it:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该工具的使用方法是简单地将 IP 地址作为参数传递给它：
- en: '![](../images/00462.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00462.jpeg)'
- en: In the example provided, a single ARP request is sent to the broadcast address,
    requesting the physical location of the `172.16.36.135` IP address. As indicated
    by the output, a single reply was received by the host with the `00:0C:29:3D:84:32`
    MAC address. This tool can be more effectively used for layer 2 discovery scanning
    if a bash script is used to perform this action on multiple hosts simultaneously.
    In order to test the responses of each instance in bash, we should determine a
    unique string that is included in the response, indicating a live host, but not
    included when no response is received.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，发送了一个 ARP 请求到广播地址，请求 `172.16.36.135` IP 地址的物理位置。正如输出所示，主机 `00:0C:29:3D:84:32`
    的 MAC 地址收到了一条单一的回复。若使用 bash 脚本同时对多个主机执行该操作，则此工具在进行第二层发现扫描时能更有效地使用。为了测试 bash 中每个实例的响应，我们应该确定一个唯一的字符串，该字符串出现在响应中，表明存在活动主机，而当没有收到响应时，则不包含该字符串。
- en: 'To identify a unique string, an ARPing request should be made to a non-responsive
    IP address:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了识别一个唯一的字符串，应该向一个没有响应的 IP 地址发送 ARPing 请求：
- en: '![](../images/00465.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00465.jpeg)'
- en: 'By analyzing varying responses from successful and unsuccessful ARPings, one
    might notice that the unique bytes from a string only exist in the response if
    there is a live host associated with the provided IP address, and it is also within
    a line that includes the IP address. By grepping this response, we can extract
    the IP address for each responding host:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分析成功和失败的 ARPing 响应，可以注意到，只有在与提供的 IP 地址相关联的主机存在时，字符串中的唯一字节才会出现在响应中，并且该字节也会出现在包含
    IP 地址的行内。通过对该响应进行 grep 操作，我们可以提取每个响应主机的 IP 地址：
- en: '![](../images/00141.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00141.jpeg)'
- en: 'Grepping for this unique string when performing an ARPing against an actual
    host IP returns a line with that IP address included, as seen in the first response
    from the previous set of commands. Performing the same task against an IP address
    that is not associated with an actual host returns nothing, as seen in the last
    response from the previous set of commands. Using `cut` with a specially crafted
    delimiter (`-d`) and the field (`-f`) values, we can quickly extract the IP address
    from this string. The command-line function `cut` can be used in bash to separate
    a line into an array, based on a specified delimiter. A specific value can then
    be returned from the `cut` function by specifying the field. By piping over the
    output multiple times, we can easily extract the MAC address from the returned
    string. Have a look at the following set of commands:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对实际主机 IP 地址执行 ARPing 时，使用 grep 查找该唯一字符串会返回一行，其中包含该 IP 地址，如前面一组命令中的第一次响应所示。当对一个没有实际主机关联的
    IP 地址执行相同的操作时，则不会返回任何内容，如前面一组命令中的最后一次响应所示。通过使用 `cut` 命令，并指定特定的分隔符（`-d`）和字段（`-f`）值，我们可以快速从该字符串中提取
    IP 地址。命令行功能 `cut` 可以在 bash 中用来基于指定的分隔符将一行分隔成数组，然后可以通过指定字段返回特定值。通过多次管道操作输出，我们可以轻松地从返回的字符串中提取
    MAC 地址。请查看以下命令集：
- en: '![](../images/00271.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00271.jpeg)'
- en: 'We can easily extract the IP address from the returned string by merely manipulating
    the delimiter and field values supplied to the `cut` function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需通过操作分隔符和传递给`cut`函数的字段值，就可以轻松从返回的字符串中提取IP地址：
- en: '![](../images/00290.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00290.jpeg)'
- en: 'Upon identifying how to extract the IP address from a positive ARPing response,
    we can easily pass this task through a loop in a bash script and output a list
    of live IP addresses. An example of a script that uses this technique is as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在识别出如何从正面ARPing响应中提取IP地址后，我们可以轻松地通过循环将此任务传递给bash脚本，并输出活动IP地址的列表。使用此技术的脚本示例如下：
- en: '[PRE5]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the bash script that is provided, the first line defines the location of
    the bash interpreter. The block of code that follows performs a test to determine
    whether the expected argument was supplied. This is determined by evaluating whether
    the number of supplied arguments is not equal to `1`. If the expected argument
    is not supplied, the usage of the script is output, and the script exits. The
    usage output indicates that the script is expecting the local interface name as
    an argument.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供的bash脚本中，第一行定义了bash解释器的位置。随后的代码块执行了一个测试，以确定是否提供了预期的参数。通过评估提供的参数数量是否不等于`1`来进行此判断。如果未提供预期的参数，则输出脚本的使用方式，并且脚本退出。使用方式的输出指示脚本期望本地接口名称作为参数。
- en: The next block of code assigns the supplied argument to the `interface` variable.
    The `interface` value is then supplied to `ifconfig`, and the output is then used
    to extract the network prefix. For example, if the IP address of the supplied
    interface is `192.168.11.4`, the prefix variable would be assigned `192.168.11`.
    A `for` loop is then used to cycle through the values of the last octet to generate
    each possible IP address in the local `/24` network. For each possible IP address,
    a single `arping` command is issued. The response for each of these requests is
    then piped over, and then `grep` is used to extract lines with the `bytes from`
    phrase. As discussed earlier, this will only extract lines that include the IP
    address of live hosts.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个代码块将提供的参数分配给`interface`变量。然后，`interface`值被传递给`ifconfig`，并使用该输出提取网络前缀。例如，如果提供的接口的IP地址是`192.168.11.4`，则前缀变量将被分配为`192.168.11`。接着，使用`for`循环遍历最后一个八位字节的值，生成本地`/24`网络中的每个可能IP地址。对于每个可能的IP地址，都会发出一个`arping`命令。然后，将每个请求的响应传递过来，并使用`grep`提取包含`bytes
    from`短语的行。如前所述，这将仅提取包含活动主机IP地址的行。
- en: Finally, a series of `cut` functions are used to extract the IP address from
    this output.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用一系列`cut`函数从该输出中提取IP地址。
- en: 'Notice that an ampersand is used at the end of the `for` loop task instead
    of a semicolon. The ampersand allows the tasks to be performed in parallel instead
    of in sequence. This drastically reduces the amount of time required to scan the
    IP range. Have a look at the following set of commands:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在`for`循环任务的末尾使用了与分号不同的&符号。该符号允许任务并行执行，而不是顺序执行。这大大减少了扫描IP范围所需的时间。请看以下一组命令：
- en: '![](../images/00471.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00471.jpeg)'
- en: 'One can easily redirect the output of the script to a text file that can then
    be used for subsequent analysis. The output can be redirected using the greater-than
    sign, followed  by the name of the text file. An example of this can be seen here:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以轻松地将脚本的输出重定向到一个文本文件，供后续分析使用。输出可以通过大于号进行重定向，后面跟着文本文件的名称。这里可以看到一个示例：
- en: '![](../images/00463.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00463.jpeg)'
- en: 'Once the output has been redirected to the output file, you can use the `ls`
    command to verify that the file was written to the filesystem, or you can use
    the `cat` command to view the contents of the file. This script can also be modified
    to read from an input file and only verify that the hosts listed in this file
    are alive. For the following script, you will need an input file with a list of
    IP addresses. For this, we can use the same input file that was used for the Scapy
    script, discussed in the previous recipe:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输出被重定向到输出文件中，你可以使用`ls`命令验证该文件是否已写入文件系统，或者可以使用`cat`命令查看文件内容。这个脚本也可以修改为从输入文件读取，并仅验证该文件中列出的主机是否存活。对于以下脚本，你需要一个包含IP地址列表的输入文件。为此，我们可以使用上一个脚本中讨论的Scapy脚本所用的相同输入文件：
- en: '[PRE6]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only major difference between this script and the preceding one is that
    rather than supplying an interface name, the filename of the input list is supplied
    upon the execution of the script. This argument is passed to the `file` variable.
    The `for` loop is then used to loop through each value in this file to perform
    the ARPing task. To execute the script, use a period and forward slash, followed
    by the name of the executable script:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本与前一个脚本的主要区别在于，它不再提供接口名称，而是在执行脚本时提供输入列表的文件名。这个参数会传递给 `file` 变量。然后使用 `for`
    循环遍历文件中的每个值以执行 ARPing 任务。要执行脚本，使用一个句点和正斜杠，后面跟上可执行脚本的名称：
- en: '![](../images/00530.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00530.jpeg)'
- en: 'Executing the script without any arguments supplied will return the usage of
    the script. This usage indicates that an input file should be supplied as an argument.
    When this is done, the script is executed, and a list of live IP addresses is
    returned from the input list of IP addresses. In the same manner as discussed
    earlier, the output of this script can easily be redirected to an output file
    using the greater-than sign. An example of this can be seen as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果执行脚本时没有提供任何参数，则会返回脚本的使用说明。这些使用说明表明应将输入文件作为参数提供。当完成此操作后，脚本将执行，并返回输入的 IP 地址列表中的活动
    IP 地址。像前面讨论的那样，脚本的输出可以很容易地重定向到一个输出文件中，使用大于符号。以下是一个示例：
- en: '![](../images/00649.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00649.jpeg)'
- en: Once the output has been redirected to the output file, you can use the `ls`
    command to verify that the file was written to the filesystem, or you can use
    the `cat` command to view the contents of the file.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦输出被重定向到输出文件，您可以使用 `ls` 命令验证文件是否已写入文件系统，或者使用 `cat` 命令查看文件的内容。
- en: How it works…
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: ARPing is a tool that was written with the intention of validating whether a
    single host is online. However, the simplicity of its use makes it easy to manipulate
    it in bash to scan multiple hosts in sequence. This is done by looping through
    a series of IP addresses, which are then supplied to the utility as arguments.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ARPing 是一个旨在验证单个主机是否在线的工具。然而，它简单易用，使得在 bash 中操作它扫描多个主机变得非常容易。这是通过循环一系列 IP 地址实现的，然后将这些地址作为参数传递给该工具。
- en: Using netdiscover to perform host discovery (layer 2)
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 netdiscover 执行主机发现（第二层）
- en: The netdiscover tool is a tool that is used to identify network hosts through
    both active and passive ARP analysis. It was primarily written to be used on a
    wireless interface; however, it is functional in a switched environment as well.
    In this specific recipe, we will discuss how to use netdiscover for both active
    and passive scanning.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: netdiscover 工具用于通过主动和被动的 ARP 分析来识别网络主机。它最初是为无线接口编写的，但在交换环境中也可以使用。在本食谱中，我们将讨论如何使用
    netdiscover 进行主动和被动扫描。
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use netdiscover to perform ARP discovery, you will need to have at least
    one system on the LAN that will respond to ARP requests. In the examples provided,
    a combination of Linux and Windows systems are used. For more information on setting
    up systems in a local lab environment, refer to the *Installing Metasploitable2*
    and *Installing Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 netdiscover 执行 ARP 发现，您需要至少有一个系统在局域网中能够响应 ARP 请求。在提供的示例中，使用了 Linux 和 Windows
    系统的组合。有关在本地实验环境中设置系统的更多信息，请参阅 [第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的
    *安装 Metasploitable2* 和 *安装 Windows Server* 相关内容，*入门*。
- en: How to do it…
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: A tool that was specifically designed to perform layer 2 discovery is netdiscover.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专门设计用于执行第二层发现的工具是 netdiscover。
- en: The `netdiscover` command can be used to scan a range of IP addresses by passing
    the network range in CIDR notation as an argument while using the `-r` option.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`netdiscover` 命令可以通过传递 CIDR 表示法的网络范围作为参数，同时使用 `-r` 选项，扫描一系列 IP 地址。'
- en: '![](../images/00650.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00650.jpeg)'
- en: 'The output generates a table that lists live IP addresses, corresponding MAC
    addresses, the number of responses, the length of responses, and MAC vendor:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将生成一个表格，列出活动 IP 地址、相应的 MAC 地址、响应次数、响应长度以及 MAC 供应商：
- en: '![](../images/00027.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'The `netdiscover` command can also be used to scan IP addresses from an input
    text file. Instead of passing the CIDR range notation as an argument, the `-l`
    option can be used in conjunction with the name or path of an input file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`netdiscover`命令也可以用来扫描来自输入文本文件的IP地址。与其将CIDR范围表示法作为参数传递，不如使用`-l`选项，配合输入文件的名称或路径：'
- en: '![](../images/00678.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00678.jpeg)'
- en: 'After running the command, we see the results displayed in the Terminal window:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们可以在终端窗口中看到显示的结果：
- en: '![](../images/00160.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00160.jpeg)'
- en: 'Another unique feature that sets this tool apart from the others is the capability
    to perform passive discovery. Broadcasting ARP requests for every IP address in
    an entire subnet can sometimes trigger alerts or responses from security devices
    such as **intrusion detection systems** (**IDS**) or **intrusion prevention systems**
    (**IPS**). A stealthier approach is to listen for the ARP traffic, as the scanning
    system naturally interacts with other systems on the network, and then record
    the data collected from ARP responses. This passive scanning technique can be
    performed using the `-p` option:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个工具与其他工具的一个独特之处在于它能够执行被动发现。对整个子网中的每个IP地址广播ARP请求有时会触发安全设备（如**入侵检测系统**（**IDS**）或**入侵防御系统**（**IPS**））的警报或响应。一个更加隐蔽的方法是监听ARP流量，因为扫描系统会自然地与网络中的其他系统交互，然后记录从ARP响应中收集的数据。这种被动扫描技术可以使用`-p`选项执行：
- en: '![](../images/00491.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00491.jpeg)'
- en: This technique will be significantly slower in gathering information, as the
    requests have to come in as a result of normal network interactions, but it will
    also be unlikely to draw any unwanted attention. This technique is much more effective
    if it is run on a wireless network, as a promiscuous wireless adapter will receive
    ARP replies intended for other devices.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种技术在收集信息时会明显更慢，因为请求必须通过正常的网络交互来获得，但它也不太可能引起任何不必要的注意。如果在无线网络上运行，这种技术会更为有效，因为混杂模式的无线适配器会接收到其他设备的ARP回复。
- en: To work effectively in a switched environment, you would need access to SPAN
    or TAP, or need to overload the CAM tables to force the switch to start broadcasting
    all traffic.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在交换环境中有效工作，你需要访问SPAN或TAP，或者需要超载CAM表以迫使交换机开始广播所有流量。
- en: How it works…
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The underlying principle that describes ARP discovery with netdiscover is essentially
    the same as what we discussed with the previous layer 2 discovery approaches.
    The major differences between this tool and some of the others that we have discussed
    include the passive discovery mode and inclusion of the MAC vendor in the output.
    Passive mode is, in most cases, useless on a switched network, because the receipt
    of an ARP response will still require some interaction with discovered clients,
    albeit independent of the netdiscover tool. Nonetheless, it is important to understand
    this feature and its potential usefulness in a broadcast network such as a hub
    or wireless network. The netdiscover tool identifies the MAC vendor by evaluating
    the first half (first three octets `/24` bits) of the returned MAC address. This
    portion of the address identifies the manufacturer of the network interface and
    is often a good indication of the hardware manufacturer for the rest of the device.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用netdiscover进行ARP发现的基本原理与我们之前讨论的第2层发现方法本质相同。这种工具与我们讨论过的一些其他工具的主要区别包括被动发现模式和输出中包含MAC厂商信息。在大多数情况下，被动模式在交换网络中没有用，因为接收ARP响应仍然需要与发现的客户端进行某些交互，尽管这些交互与netdiscover工具无关。然而，理解这个功能及其在广播网络（如集线器或无线网络）中的潜在用途仍然很重要。netdiscover工具通过评估返回的MAC地址的前半部分（前三个八位组`/24`位）来识别MAC厂商。这部分地址标识了网络接口的制造商，通常能很好地指示设备的硬件制造商。
- en: Using Metasploit to perform host discovery (layer 2)
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Metasploit进行主机发现（第2层）
- en: Metasploit is primarily an exploitation tool, and this functionality will be
    discussed in great length in the upcoming chapters. However, in addition to its
    primary function, Metasploit also has a number of auxiliary modules that can be
    used for various scanning and information gathering tasks. One auxiliary module
    in particular can be used to perform ARP scanning on the local subnet. This is
    helpful for many, as Metasploit is a tool that most penetration testers are familiar
    with, and the integration of this function into Metasploit reduces the total number
    of tools required for the duration of a given test. This specific recipe will
    demonstrate how to use Metasploit to perform ARP discovery.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit主要是一种漏洞利用工具，接下来的章节将详细讨论其功能。然而，除了其主要功能外，Metasploit还拥有许多辅助模块，可以用于各种扫描和信息收集任务。特别有一个辅助模块，可以在本地子网上执行ARP扫描。这对于许多人来说非常有用，因为Metasploit是大多数渗透测试人员熟悉的工具，将此功能集成到Metasploit中，可以减少在测试过程中所需的工具数量。本教程将演示如何使用Metasploit执行ARP发现。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Metasploit to perform ARP discovery, you will need to have at least one
    system on the LAN that will respond to ARP requests. In the examples provided,
    a combination of Linux and Windows systems is used. For more information on setting
    up systems in a local lab environment, refer to the *Installing Metasploitable2*
    and *Installing Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Metasploit执行ARP发现，您需要在局域网中至少有一台能够响应ARP请求的系统。在提供的示例中，使用了Linux和Windows系统的组合。如需了解如何在本地实验环境中设置系统，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*和*安装Windows
    Server*章节。
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Although often considered an exploitation framework, Metasploit also has a large
    number of auxiliary modules that can be useful in scanning and information gathering.
    There is one auxiliary module in particular that can be used to perform layer
    2 discovery.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Metasploit通常被视为一种漏洞利用框架，但它也拥有大量可用于扫描和信息收集的辅助模块。其中有一个辅助模块，可以用于执行第2层发现。
- en: 'To start the Metasploit framework, use the `msfconsole` command. Then, the
    `use` command in conjunction with the desired module can be used to configure
    the scan:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Metasploit框架时，使用`msfconsole`命令。然后，可以使用`use`命令配合所需的模块来配置扫描：
- en: '![](../images/00309.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00309.jpeg)'
- en: 'Once the module has been selected, you can view the configurable options using
    the `show options` command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模块后，可以使用`show options`命令查看可配置的选项：
- en: '![](../images/00054.jpeg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00054.jpeg)'
- en: These are configuration options that specify information about the targets to
    be scanned, the scanning system, and scan settings. Most of the information for
    this particular scan can be collected by examining the interface configurations
    of the scanning system. Conveniently, system shell commands can be passed while
    in the Metasploit Framework Console.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是配置选项，用于指定扫描目标、扫描系统和扫描设置的信息。大多数关于此次扫描的信息可以通过检查扫描系统的接口配置来收集。方便的是，可以在Metasploit框架控制台中传递系统
    shell 命令。
- en: 'In the following example, a system call is made to execute `ifconfig` without
    ever leaving the Metasploit Framework Console interface:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，系统调用在不离开Metasploit框架控制台界面的情况下执行`ifconfig`命令：
- en: '![](../images/00479.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00479.jpeg)'
- en: 'The interface to be used for this scan is the `eth1` interface. As layer 2
    scans are only effective for identifying live hosts on the local subnet, we should
    look to the scanning system IP and subnet mask to determine the range to scan.
    In this case, the IP address and subnet mask indicate that we should scan the
    `172.16.69.0/24` range. Additionally, the source IP address and MAC address of
    the scanning system can be identified in these configurations. To define the configurations
    in Metasploit, use the `set` command, followed by the variable to be defined and
    then the value that you want to assign it:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本次扫描使用的接口是`eth1`接口。由于第2层扫描仅对识别本地子网中的活动主机有效，我们应根据扫描系统的IP地址和子网掩码来确定扫描范围。在此案例中，IP地址和子网掩码表明我们应该扫描`172.16.69.0/24`范围。此外，扫描系统的源IP地址和MAC地址可以在这些配置中找到。要在Metasploit中定义这些配置，请使用`set`命令，后接要定义的变量和要赋予它的值：
- en: '![](../images/00500.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00500.jpeg)'
- en: 'Once the scan configurations have been set, the settings can be reviewed again
    by using the `show options` command. This should now display all the values that
    were previously set:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好扫描配置后，可以使用`show options`命令再次查看设置。这时应该显示出所有之前设置的值：
- en: '![](../images/00094.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00094.jpeg)'
- en: 'Upon verifying that all the settings are configured correctly, the scan can
    then be launched using the `run` command. This particular module will then print
    out any live hosts discovered with ARP. It will also indicate the **network interface
    card** (**NIC**) vendor, as defined by the first 3 bytes in the MAC address of
    the discovered hosts:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认所有设置正确配置后，可以使用`run`命令启动扫描。这个特定模块将打印出通过ARP发现的所有活动主机。它还会显示**网络接口卡**（**NIC**）的供应商信息，该信息由发现主机的MAC地址的前三个字节定义：
- en: '![](../images/00108.jpeg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00108.jpeg)'
- en: How it works…
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运作…
- en: The underlying principle for how ARP discovery is performed by Metasploit is
    once again the same. A series of ARP requests is broadcast, and the ARP responses
    are recorded and output. The output of the Metasploit auxiliary module provides
    the IP address of all live systems, and then it also provides the MAC vendor name
    in parentheses.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit执行ARP发现的基本原理依然是一样的。一系列ARP请求会广播出去，ARP响应会被记录并输出。Metasploit辅助模块的输出提供了所有活动系统的IP地址，并在括号中提供了MAC供应商名称。
- en: Using hping3 to perform host discovery (layers 3/4)
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用hping3进行主机发现（第3/4层）
- en: An even more versatile discovery tool that can be used to perform host discovery
    in multiple different ways is `hping3`. It is more powerful than `fping` in the
    sense that it can employ multiple different types of discovery techniques but
    is less useful as a scanning tool because it can only be used to target a single
    host. However, this shortcoming can be overcome using bash scripting. This recipe
    will demonstrate how to use `hping3` to perform layer 3 and layer 4 discovery
    on remote hosts.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更为多功能的发现工具是`hping3`，它可以用来通过多种不同方式进行主机发现。与`fping`相比，它更强大，因为它可以采用多种不同的发现技术，但作为扫描工具，它的作用较小，因为它只能针对单一主机进行扫描。然而，通过bash脚本，可以克服这一不足。本教程将演示如何使用`hping3`在远程主机上执行第3层和第4层的发现。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using `hping3` to perform layer 3 discovery does not require a lab environment,
    as many systems on the Internet will reply to ICMP echo requests as well as both
    TCP and UDP traffic. However, it is highly recommended that you perform any type
    of network scanning exclusively in your own lab unless you are thoroughly familiar
    with the legal regulations imposed by any governing authorities to whom you are
    subject. If you wish to use this technique within your lab, you will need to have
    at least one system that will respond to ICMP, TCP, and UDP requests. In the examples
    provided, a combination of Linux and Windows systems are used. For more information
    on setting up systems in a local lab environment, refer to the *Installing Metasploitable2*
    and *Installing Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*. Additionally, this section will require a script to be written
    to the filesystem, using a text editor such as Vim or GNU nano. For more information
    on writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hping3`进行第3层发现不需要实验环境，因为互联网上许多系统都会回应ICMP回显请求，以及TCP和UDP流量。然而，强烈建议你仅在自己的实验室内进行任何类型的网络扫描，除非你完全了解自己所受管辖的相关法律规定。如果你希望在实验室中使用此技术，你至少需要有一台能响应ICMP、TCP和UDP请求的系统。在提供的示例中，使用了Linux和Windows系统的组合。有关在本地实验室环境中设置系统的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*和*安装Windows
    Server*。此外，本节还需要编写脚本并将其保存到文件系统中，可以使用Vim或GNU nano等文本编辑器。有关编写脚本的更多信息，请参考[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*使用文本编辑器（Vim和GNU
    nano）*。
- en: How to do it…
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: As before, we will look at this layer by layer.  Let's go through the discovery
    steps layer by layer.  In this layer, we will use hping3 to perform discovery
    at layers 3 and 4.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们将逐层分析。让我们逐层进行发现步骤。在这一层，我们将使用hping3在第3层和第4层执行发现。
- en: Layer 3 discovery - ICMP
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3层发现 - ICMP
- en: The `hping3` command is a very powerful discovery utility that has a large range
    of options and modes that it can operate in. It is capable of performing discovery
    in both layer 3 and layer 4.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`hping3`命令是一款功能强大的发现工具，具有广泛的选项和模式可供选择。它能够在第3层和第4层进行发现操作。'
- en: 'To perform basic ICMP discovery of a single host address using `hping3`, you
    merely need to pass the IP address to be tested and the desired scanning mode
    of ICMP to it:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`hping3`执行单一主机地址的基本ICMP发现，只需传递要测试的IP地址和所需的ICMP扫描模式：
- en: '![](../images/00510.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00510.jpeg)'
- en: 'In the demonstration provided, the process was stopped using *Ctrl* + *C*.
    Similar to the standard `ping` utility, the `hping3` ICMP mode will continue indefinitely
    unless a specific number of packets is specified in the initial command. To define
    the number of attempts to be sent, the `-c` option should be included with an
    integer value that indicates the desired number of attempts:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的演示中，处理过程是通过*Ctrl* + *C*停止的。类似于标准的`ping`工具，`hping3`的ICMP模式将继续运行，除非在初始命令中指定了发送的数据包数量。为了定义发送的尝试次数，应包括`-c`选项，并提供一个整数值来表示所需的尝试次数：
- en: '![](../images/00112.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00112.jpeg)'
- en: Although `hping3` does not support the scanning of multiple systems by default,
    this can easily be scripted out with bash scripting. In order to do this, we must
    first identify the distinctions between the output associated with a live address
    and the output associated with a nonresponsive address.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然`hping3`默认不支持扫描多个系统，但可以通过bash脚本轻松实现。为了做到这一点，我们必须首先识别与活动地址相关的输出与与无响应地址相关的输出之间的区别。
- en: 'To do this, we should use the same command on an IP address to which no host
    is assigned:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们应该在没有主机分配的IP地址上使用相同的命令：
- en: '![](../images/00145.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00145.jpeg)'
- en: By identifying the responses associated with each of these requests, we can
    determine a unique string that we can `grep` for; this string will isolate the
    successful ping attempts from the unsuccessful ones. With `hping3`, you may notice
    that the length value is only presented in the case that a response is returned.
    Based on this, we can extract the successful attempts by grepping for `len`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过识别与每个请求相关的响应，我们可以确定一个唯一的字符串，可以用来`grep`；这个字符串将从不成功的ping尝试中隔离出成功的尝试。在`hping3`中，您可能会注意到，长度值仅在返回响应的情况下显示。基于此，我们可以通过grep查找`len`来提取成功的尝试。
- en: 'To determine the effectiveness of this approach in a script, we should attempt
    to concatenate the two previous commands and then pipe over the output to our
    `grep` function. Assuming that the string we have selected is truly unique to
    successful attempts, we should only see the output associated with the live host:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定这种方法在脚本中的有效性，我们应该尝试将前两个命令连接在一起，然后将输出通过管道传递给`grep`函数。假设我们选择的字符串对于成功的尝试是唯一的，那么我们应该只看到与活动主机相关的输出：
- en: '![](../images/00514.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00514.jpeg)'
- en: 'Despite the desired outcome, the `grep` function, in this case, does not appear
    to be effectively applied to the output. As the output display handling in `hping3`
    makes it difficult to pipe over to a `grep` function and only extract the desired
    lines, we can attempt to work around this by other means. Specifically, we will
    attempt to determine whether the output can be redirected to a file, and then
    we can `grep` directly from the file. To do this, we will attempt to pass the
    output for both the commands used earlier to the `handle.txt` file:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管期望的结果是如此，但在此情况下，`grep`函数似乎并未有效地应用于输出。由于`hping3`的输出显示处理方式使得很难将其管道传递给`grep`函数并只提取所需的行，我们可以尝试通过其他方式解决这个问题。具体来说，我们将尝试确定是否可以将输出重定向到文件中，然后直接从文件中使用`grep`。为此，我们将尝试将之前使用的两个命令的输出传递到`handle.txt`文件中：
- en: '![](../images/00176.jpeg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00176.jpeg)'
- en: 'While this attempt was not completely successful as the output was not totally
    redirected to the file, we can see by reading the file that enough is output to
    create an effective script. Specifically, we are able to redirect a unique line
    that is only associated with successful ping attempts and that contains the corresponding
    IP address in the line. To verify that this workaround might be possible, we will
    attempt to loop through each of the addresses in the `/24` range and then pass
    the results to the `handle.txt` file:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管这个尝试并不完全成功，因为输出并没有完全重定向到文件中，但通过读取文件，我们可以看到足够的输出内容，足以创建一个有效的脚本。具体来说，我们能够重定向一个仅与成功的
    ping 尝试相关的独特行，并且该行中包含相应的 IP 地址。为了验证这个变通方法是否可行，我们将尝试遍历 `/24` 范围内的每个地址，然后将结果传递到
    `handle.txt` 文件中：
- en: '![](../images/00421.jpeg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00421.jpeg)'
- en: 'We can now open the `handle.txt` file and see the output of our script:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以打开 `handle.txt` 文件，查看脚本的输出：
- en: '![](../images/00496.jpeg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00496.jpeg)'
- en: 'Despite doing this, there is still a large amount of output (the provided output
    is truncated for convenience) that consists of all the parts of the output that
    were not redirected to the file. However, the success of the following script
    is not contingent upon the excessive output of this initial loop, but rather on
    the ability to extract the necessary information from the output file:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管进行了这些操作，仍然会有大量输出（为方便起见，提供的输出已被截断），这些输出包含了所有未重定向到文件的部分。然而，以下脚本的成功并不依赖于初始循环中的过多输出，而是依赖于从输出文件中提取必要信息的能力：
- en: '![](../images/00563.jpeg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00563.jpeg)'
- en: 'After completing the scan loop, the output file can be identified in the current
    directory using the `ls` command, and then the unique string of `len` can be grepped
    directly from this file. Here in the output, we can see that each of our live
    hosts is listed. At this point, the only remaining task is to extract the IP addresses
    from this output and then recreate this entire process as a single functional
    script. Have a look at the following set of commands:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成扫描循环后，可以使用 `ls` 命令在当前目录中识别输出文件，然后可以直接从该文件中使用 `grep` 提取包含 `len` 的唯一字符串。在输出中，我们可以看到列出了每个活动主机。此时，剩下的唯一任务就是从该输出中提取
    IP 地址，然后将整个过程重构为一个功能性脚本。请看以下一组命令：
- en: '![](../images/00625.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00625.jpeg)'
- en: 'By piping over the output to a series of `cut` functions, we can extract the
    IP addresses from the output. Now that we have successfully identified a way to
    scan multiple hosts and easily identify the results, we should integrate it into
    a script. An example of a functional script that would tie all of these operations
    together is as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将输出管道传递到一系列 `cut` 函数中，我们可以从输出中提取 IP 地址。现在，我们已经成功找到了扫描多个主机并轻松识别结果的方法，接下来我们应该将其集成到一个脚本中。以下是一个示例，展示了如何将这些操作整合到一个功能性脚本中：
- en: '[PRE7]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the bash script that is provided, the first line defines the location of
    the bash interpreter. The block of code that follows performs a test to determine
    whether the one argument that was expected was supplied. This is determined by
    evaluating whether the number of supplied arguments is not equal to `1`. If the
    expected argument is not supplied, the usage of the script is output, and the
    script exits. The usage output indicates that the script is expecting the `/24`
    network address as an argument.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供的 bash 脚本中，第一行定义了 bash 解释器的位置。接下来的代码块执行一个测试，判断是否提供了预期的一个参数。通过评估传入的参数数量是否不等于
    `1` 来确定这一点。如果没有提供预期的参数，则输出脚本的使用方式，并退出脚本。使用输出会指示脚本预期 `/24` 网络地址作为参数。
- en: The next line of code extracts the network prefix from the supplied network
    address. For example, if the network address supplied was `192.168.11.0`, the
    prefix variable would be assigned the value `192.168.11`. The `hping3` operation
    is then performed on each address within the `/24` range, and the resulting output
    of each task is placed into the `handle.txt` file.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行代码从提供的网络地址中提取网络前缀。例如，如果提供的网络地址是 `192.168.11.0`，则前缀变量将被赋值为 `192.168.11`。然后在
    `/24` 范围内的每个地址上执行 `hping3` 操作，并将每个任务的输出结果放入 `handle.txt` 文件中。
- en: Once completed, `grep` is used to extract the lines that are associated with
    live host responses from the `handle.txt` file and then extract the IP addresses
    from those lines. The resulting IP addresses are then passed into an `output.txt`
    file, and the temporary `handle.txt` file is removed from the directory.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后，`grep`用于从`handle.txt`文件中提取与活动主机响应相关的行，然后从这些行中提取IP地址。最终的IP地址将被传入`output.txt`文件，并从目录中删除临时的`handle.txt`文件。
- en: 'This script can be executed using a period and forward slash, followed by the
    name of the executable script:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本可以通过一个句点和正斜杠来执行，后面跟着可执行脚本的名称：
- en: '![](../images/00673.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00673.jpeg)'
- en: 'Once completed, the script should return an `output.txt` file to the execution
    directory. This can be verified using `ls`, and the `cat` command can be used
    to view the contents of this file:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，脚本应该将`output.txt`文件返回到执行目录。可以使用`ls`进行验证，并可以使用`cat`命令查看此文件的内容：
- en: '![](../images/00267.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00267.jpeg)'
- en: When the script is run, you will still see the same large amount of output that
    was seen when originally looping through the task. Fortunately, your list of discovered
    hosts will not be lost in this output, as it is conveniently written to your output
    file each time.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本运行时，你仍然会看到与最初循环执行任务时相同的大量输出。幸运的是，你发现的主机列表不会在这些输出中丢失，因为它会每次方便地写入到输出文件中。
- en: Layer 4 discovery - TCP and UDP
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4层发现 - TCP和UDP
- en: Unlike Nmap, `hping3` makes it very easy to identify hosts that are discovered
    by UDP probes by isolating the task.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与Nmap不同，`hping3`通过隔离任务，使得通过UDP探测发现的主机非常容易识别。
- en: 'By specifying the UDP mode with the `--udp` option, UDP probes can be transmitted
    in attempts to trigger replies from live hosts:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`--udp`选项指定UDP模式，可以尝试通过UDP探测来触发活动主机的响应：
- en: '![](../images/00533.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00533.jpeg)'
- en: 'In the demonstration provided, the process was stopped using *Ctrl* + *C*.
    When using `hping3` in UDP mode, discovery will continue indefinitely unless a
    specific number of packets is defined in the initial command. To define the number
    of attempts to be sent, the `-c` option should be included with an integer value
    that indicates the desired number of attempts:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的演示中，使用*Ctrl* + *C*停止了该过程。当在UDP模式下使用`hping3`时，发现过程将无限继续，除非在初始命令中定义了特定的包数。要定义发送的尝试次数，应该使用`-c`选项，并附上一个表示所需尝试次数的整数值：
- en: '![](../images/00295.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00295.jpeg)'
- en: 'Although `hping3` does not support the scanning of multiple systems by default,
    using bash scripting we can filter our results to show only live addresses. In
    order to do this, we must first identify the distinctions between the output associated
    with a live address and the output associated with a nonresponsive address. To
    do this, we should use the same command on an IP address to which no host is assigned:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管`hping3`默认不支持扫描多个系统，但通过使用bash脚本，我们可以过滤结果，仅显示活动地址。为此，我们首先需要识别与活动地址相关的输出与与无响应地址相关的输出之间的区别。为此，我们应该对一个没有主机分配的IP地址使用相同的命令：
- en: '![](../images/00308.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00308.jpeg)'
- en: By identifying the responses associated with each of these requests, we can
    determine a unique string that we can `grep`; this string will isolate the successful
    discovery attempts from the unsuccessful ones. In the previous requests, you may
    have noticed that the phrase `ICMP Port Unreachable` is only presented in the
    case that a response is returned. Based on this, we can extract the successful
    attempts by grepping for `Unreachable`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过识别与每个请求相关的响应，我们可以确定一个独特的字符串，可以使用`grep`进行筛选；这个字符串将把成功的发现尝试与不成功的尝试区分开。在之前的请求中，你可能已经注意到，短语`ICMP
    Port Unreachable`只有在返回响应的情况下才会出现。基于此，我们可以通过grep搜索`Unreachable`来提取成功的尝试。
- en: 'To determine the effectiveness of this approach in a script, we should attempt
    to concatenate the two previous commands and then pipe over the output to our
    `grep` function. Assuming that the string we have selected is truly unique to
    successful attempts, we should only see the output associated with the live host:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定这种方法在脚本中的有效性，我们应该尝试将之前的两个命令连接起来，然后将输出通过管道传递给`grep`函数。假设我们选择的字符串确实是成功尝试的唯一标识，我们应该只看到与活动主机相关的输出：
- en: '![](../images/00537.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00537.jpeg)'
- en: 'Despite the desired outcome, the `grep` function, in this case, does not appear
    to be effectively applied to the output. As the output display handling in `hping3`
    makes it difficult to pipe over to a `grep` function and only extract the desired
    lines, we can attempt to work around this by other means. Specifically, we will
    attempt to determine whether the output can be redirected to a file, and then
    we can grep directly from the file. To do this, we will attempt to pass the output
    for both the commands used earlier to the `handle.txt` file:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管期望的结果是如此，但在这种情况下，`grep`函数似乎并未有效地应用于输出。由于`hping3`的输出显示处理使得难以将其传递给`grep`函数并仅提取所需的行，我们可以尝试通过其他方式解决这个问题。具体来说，我们将尝试确定输出是否可以重定向到文件，然后可以直接从文件中grep。为此，我们将尝试将之前使用的两个命令的输出传递到`handle.txt`文件中：
- en: '![](../images/00445.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00445.jpeg)'
- en: 'While this attempt was not completely successful as the output was not totally
    redirected to the file, we can see by reading the file that enough is output to
    create an effective script. Specifically, we are able to redirect a unique line
    that is only associated with successful ping attempts and that contains the corresponding
    IP address in the line. To check whether this workaround is possible, we will
    attempt to loop through each of the addresses in the `/24` range and then pass
    the results to the `handle.txt` file:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管这一尝试没有完全成功，因为输出没有完全重定向到文件，但通过阅读文件我们可以看到足够的输出用于创建有效的脚本。具体来说，我们能够重定向一个仅与成功的ping尝试相关并包含相应IP地址的唯一行。为了检查这种解决方法是否可行，我们将尝试循环遍历`/24`范围内的每个地址，然后将结果传递到`handle.txt`文件中：
- en: '![](../images/00349.jpeg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00349.jpeg)'
- en: 'We can now view the results by viewing the contents of `handle.txt`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过查看`handle.txt`的内容来查看结果：
- en: '![](../images/00352.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00352.jpeg)'
- en: 'By doing this, there is still a large amount of output (the provided output
    is truncated for convenience) that consists of all the parts of output that were not
    redirected to the file. However, the success of the script is not contingent upon
    the excessive output of this initial loop, but rather on the ability to extract
    the necessary information from the output file. This can be seen in the following
    commands:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这种方式，仍然有大量的输出（为了方便，提供的输出已被截断），它包含了所有未重定向到文件的输出部分。然而，脚本的成功并不取决于这个初始循环的过多输出，而是取决于从输出文件中提取必要信息的能力。这可以通过以下命令看到：
- en: '![](../images/00041.jpeg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: 'After completing the scan loop, the output file can be identified in the current
    directory using the `ls` command, and then the unique string of `Unreachable`
    can be grepped directly from this file, as shown in the next command. Here, in
    the output, we can see that each of our live hosts discovered by UDP probing is
    listed. At this point, the only remaining task is to extract the IP addresses
    from this output and then recreate this entire process as a single functional
    script:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成扫描循环后，可以使用`ls`命令在当前目录中识别输出文件，然后直接从该文件中grep出`Unreachable`的唯一字符串，如下所示。在输出中，我们可以看到通过UDP探测发现的每个存活主机都被列出。此时，唯一剩下的任务是从这个输出中提取IP地址，并将整个过程重新构建成一个单一的功能脚本：
- en: '![](../images/00359.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00359.jpeg)'
- en: 'By piping over the output to a series of `cut` functions, we can extract the
    IP addresses from the output. Now that we have successfully identified a way to
    scan multiple hosts and easily identify the results, we should integrate it into
    a script:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将输出传递给一系列的`cut`函数，我们可以从输出中提取IP地址。现在，我们已经成功找到了一种扫描多个主机并轻松识别结果的方法，接下来应该将其集成到脚本中：
- en: '[PRE8]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the bash script that is provided, the first line defines the location of
    the bash interpreter. The block of code that follows performs a test to determine
    whether the one argument that was expected was supplied. This is determined by
    evaluating whether the number of supplied arguments is not equal to `1`. If the
    expected argument is not supplied, the usage of the script is output, and the
    script exits. The usage output indicates that the script is expecting the `/24`
    network address as an argument.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供的bash脚本中，第一行定义了bash解释器的位置。接下来的代码块执行了一个测试，以确定是否提供了预期的一个参数。这是通过评估提供的参数数量是否不等于`1`来确定的。如果没有提供预期的参数，脚本会输出用法并退出。用法输出指示该脚本期望将`/24`网络地址作为参数。
- en: The next line of code extracts the network prefix from the supplied network
    address. For example, if the network address supplied was `192.168.11.0`, the
    prefix variable would be assigned a value of `192.168.11`. The `hping3` operation
    is performed on each address within the `/24` range, and the resulting output
    of each task is placed into the `handle.txt` file.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行代码从提供的网络地址中提取网络前缀。例如，如果提供的网络地址是`192.168.11.0`，则前缀变量将被赋值为`192.168.11`。`hping3`操作将在`/24`范围内的每个地址上执行，且每个任务的输出结果将被写入`handle.txt`文件中。
- en: Once this is complete, `grep` is used to extract the lines that are associated
    with live host responses from the `handle.txt` file and then extract the IP addresses
    from those lines.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后，使用`grep`从`handle.txt`文件中提取与活跃主机响应相关的行，然后从这些行中提取IP地址。
- en: 'The resulting IP addresses are then passed into an `output.txt` file, and the
    temporary `handle.txt` file is removed from the directory:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果IP地址将被传入`output.txt`文件中，并且临时的`handle.txt`文件将从目录中删除：
- en: '![](../images/00363.jpeg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00363.jpeg)'
- en: 'We can now view the contents of our `output.txt` file:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看`output.txt`文件的内容：
- en: '![](../images/00365.jpeg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00365.jpeg)'
- en: 'When the script is run, you will still see the same large amount of output
    that was seen when originally looping through the task. Fortunately, your list
    of discovered hosts will not be lost in this output, as it is conveniently written
    to your output file each time. You can also use `hping3` to perform TCP discovery.
    TCP mode is actually the default discovery mode used by `hping3`, and this mode
    can be used by just passing the IP address to be scanned to `hping3`:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本运行时，你仍然会看到最初遍历任务时看到的大量输出。幸运的是，你发现的主机列表不会丢失在这些输出中，因为它会在每次输出时方便地写入你的输出文件中。你还可以使用`hping3`进行TCP发现。TCP模式实际上是`hping3`的默认发现模式，通过将要扫描的IP地址传递给`hping3`即可使用该模式：
- en: '![](../images/00369.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00369.jpeg)'
- en: 'In the same way that we created a bash script to cycle through a `/24` network
    and perform UDP discovery using `hping3`, we can create a similar script for TCP
    discovery. First, a unique phrase that exists in the output associated with a
    live host but not in the output associated with a nonresponsive host must be identified.
    To do this, we must evaluate the response for each:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们为循环遍历`/24`网络并使用`hping3`进行UDP发现编写的bash脚本一样，我们可以为TCP发现编写一个类似的脚本。首先，必须确定在与活跃主机相关的输出中存在但在与无响应主机相关的输出中不存在的唯一短语。为此，我们需要评估每个主机的响应：
- en: '![](../images/00372.jpeg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00372.jpeg)'
- en: 'In this case, the length value is only present in the output associated with
    a live host. Once again, we can develop a script that redirects the output to
    a temporary `handle.txt` file and then greps the output from this file to identify
    live hosts:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，长度值仅出现在与活跃主机相关的输出中。我们可以再次编写一个脚本，将输出重定向到临时的`handle.txt`文件，然后通过`grep`命令从该文件中提取活跃主机：
- en: '[PRE9]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This script will perform in a way similar to the one developed for UDP discovery.
    The only differences are in the command performed in the loop sequence, grep value,
    and the process to extract the IP address. Once run, this script will produce
    an `output.txt` file that will contain a list of the IP addresses associated with
    the hosts discovered by TCP discovery:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本的运行方式与为UDP发现编写的脚本类似。唯一的不同之处在于循环序列中执行的命令、grep值以及提取IP地址的过程。运行后，脚本将生成一个`output.txt`文件，其中包含通过TCP发现识别到的主机的IP地址列表：
- en: '![](../images/00125.jpeg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00125.jpeg)'
- en: 'You can confirm that the output file was written to the execution directory
    using the `ls` command and read its contents using the `cat` command. This can
    be seen in the following example:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`ls`命令确认输出文件已写入执行目录，并使用`cat`命令读取其内容。以下示例可以看到这一点：
- en: '![](../images/00379.jpeg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00379.jpeg)'
- en: How it works…
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: To effectively use `hping3` for layer 3 discovery, a bash script was used to
    perform an ICMP echo request in sequence. This was possible due to the unique
    response that was generated by a successful and unsuccessful request. By passing
    the function through a loop and then grepping for the unique response, we could
    effectively develop a script that performs ICMP discovery against multiple systems
    in sequence and then outputs a list of live hosts.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用`hping3`进行第3层发现，使用了一个bash脚本按顺序执行ICMP回显请求。这得益于成功和失败请求所生成的独特响应。通过在循环中传递该功能，并使用`grep`查找独特的响应，我们能够有效地开发一个脚本，在多个系统上顺序执行ICMP发现，并输出存活主机的列表。
- en: For layer 4 discovery, `hping3` uses ICMP host-unreachable responses to identify
    live hosts with UDP requests and uses null-flag scanning to identify live hosts
    with TCP requests. For UDP discovery, a series of null UDP requests is sent to
    arbitrary destination ports in an attempt to solicit a response. For TCP discovery,
    a series of TCP requests is sent to destination port `0` with no flag bits activated.
    In the example provided, this solicited a response with the ACK+RST flags activated.
    Each of these tasks was passed through a loop in bash to perform scanning on multiple
    hosts or a range of addresses.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第4层发现，`hping3`使用ICMP主机不可达响应来通过UDP请求识别存活主机，并使用空标志扫描通过TCP请求识别存活主机。对于UDP发现，一系列空的UDP请求会发送到任意目的端口，试图引发响应。对于TCP发现，一系列TCP请求会发送到目的端口`0`，且没有激活任何标志位。在提供的示例中，这引发了带有ACK+RST标志的响应。每个任务都通过bash中的循环执行，以对多个主机或地址范围进行扫描。
- en: Using ICMP to perform host discovery
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ICMP进行主机发现
- en: Layer 3 discovery is probably the most commonly used tool among network administrators
    and technicians. It uses the famous ICMP `ping` utility to identify live hosts.
    This recipe will demonstrate how to use the `ping` utility to perform layer 3
    discovery on remote hosts.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 第3层发现可能是网络管理员和技术人员最常用的工具。它使用著名的ICMP `ping`工具来识别存活主机。本节将演示如何使用`ping`工具对远程主机执行第3层发现。
- en: Getting ready
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using `ping` to perform layer 3 discovery does not require a lab environment,
    as many systems on the Internet will reply to ICMP echo requests. However, it
    is highly recommended you perform any type of network scanning exclusively in
    your own lab unless you are thoroughly familiar with the legal regulations imposed
    by any governing authorities to whom you are subject. If you wish to use this
    technique within your lab, you will need to have at least one system that will
    respond to ICMP requests. In the examples provided, a combination of Linux and
    Windows systems is used. For more information on setting up systems in a local
    lab environment, refer to the *Installing Metasploitable2* and *Installing Windows
    Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*. Additionally, this section will require a script to be written
    to the filesystem, using a text editor such as Vim or GNU nano. For more information
    on writing scripts, refer to the *Using text editors (Vim and GNU nano)* recipe
    in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426), *Getting
    Started*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ping`进行第3层发现无需实验室环境，因为互联网上许多系统会响应ICMP回显请求。然而，强烈建议你仅在自己的实验室环境中执行任何类型的网络扫描，除非你完全了解适用的法律法规。如果你希望在实验室中使用此技术，至少需要一台能够响应ICMP请求的系统。在提供的示例中，使用了Linux和Windows系统的组合。有关在本地实验室环境中设置系统的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*和*安装Windows
    Server*食谱，*入门*部分。此外，本节需要编写一个脚本到文件系统中，可以使用文本编辑器如Vim或GNU nano。有关编写脚本的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*使用文本编辑器（Vim和GNU
    nano）*食谱，*入门*部分。
- en: How to do it…
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Most people who work in the IT industry are fairly familiar with the `ping`
    tool. To determine whether a host is alive using `ping`, you merely need to pass
    an argument to the command to define the IP address that you wish to test:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数在IT行业工作的人都对`ping`工具相当熟悉。要使用`ping`来判断主机是否存活，只需向命令传递一个参数，定义你想要测试的IP地址：
- en: '![](../images/00382.jpeg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00382.jpeg)'
- en: 'When this command is issued, an ICMP echo request will be sent directly to
    the IP address provided. Several conditions must be true in order to receive a
    reply to this ICMP echo request. These conditions are as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发出此命令时，ICMP 回显请求将直接发送到提供的 IP 地址。为了收到该 ICMP 回显请求的回复，必须满足几个条件。这些条件如下：
- en: The IP address tested must be assigned to a system
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的 IP 地址必须分配给某个系统
- en: The system must be alive and online
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统必须是活跃且在线的
- en: There must be an available route from the scanning system to the target IP
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描系统到目标 IP 必须有可用的路由
- en: The system must be configured to respond to ICMP traffic
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统必须配置为响应 ICMP 流量
- en: There should not be any host-based or network firewall between the scanning
    system and the target IP that is configured to drop ICMP traffic
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描系统和目标 IP 之间不应有任何主机或网络防火墙被配置为丢弃 ICMP 流量
- en: As you can see, there are a lot of variables that have to be factored into the
    success of ICMP discovery. It is for this reason that ICMP can be somewhat unreliable,
    but unlike ARP, it is a routable protocol and can be used to discover hosts outside
    of the LAN. Notice that in the previous example, `^C` appears in the output presented
    from the `ping` command. This signifies that an escape sequence (specifically,
    *Ctrl* + *C*) was used to stop the process. Unlike Windows, the `ping` command
    integrated into Linux operating systems will, by default, ping a target host indefinitely.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，有很多变量需要考虑到 ICMP 发现的成功。这也是 ICMP 可能不太可靠的原因，但与 ARP 不同，ICMP 是可路由的协议，并且可以用于发现局域网之外的主机。注意，在前面的例子中，`^C`
    出现在 `ping` 命令的输出中。这表示使用了一个转义序列（特别是 *Ctrl* + *C*）来停止该过程。与 Windows 不同，Linux 操作系统中集成的
    `ping` 命令默认会无限期地 ping 目标主机。
- en: 'However, the `-c` option can be used to specify the number of ICMP requests
    to be sent. Using this option, the process will end gracefully once the timeout
    has been reached or replies have been received for each sent packet. Have a look
    at the following command:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，`-c` 选项可以用来指定要发送的 ICMP 请求数。使用此选项时，一旦超时或每个发送的数据包都收到回复，过程将优雅地结束。请查看以下命令：
- en: '![](../images/00384.jpeg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00384.jpeg)'
- en: 'In the same way that ARPing can be used in a bash script to cycle through multiple
    IPs in parallel, `ping` can be used in conjunction with bash scripting to perform
    layer 3 discovery on multiple hosts in parallel. To write a script, we need to
    identify the varied responses associated with a successful and failed ping request.
    To do this, we should first ping a host that we know to be alive and responding
    to ICMP, and then follow it up with a ping request to a nonresponsive address.
    The following command demonstrates this:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像 ARPing 可以在 bash 脚本中用于并行循环多个 IP 地址一样，`ping` 也可以与 bash 脚本结合使用，在多个主机上并行执行第 3
    层发现。要编写脚本，我们需要识别与成功和失败的 ping 请求相关的不同响应。为此，我们应该首先 ping 一个我们知道是在线且响应 ICMP 的主机，然后再对一个没有响应的地址进行
    ping 请求。以下命令演示了这一点：
- en: '![](../images/00388.jpeg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00388.jpeg)'
- en: 'As with the ARPing requests, the bytes from a unique string are only present
    in the output associated with live IP addresses, and they are also on a line that
    contains this address. In the same fashion, we can extract the IP address from
    any successful ping request using a combination of `grep` and `cut`:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 ARPing 请求一样，来自唯一字符串的字节仅出现在与在线 IP 地址相关的输出中，并且它们也出现在包含此地址的行中。同样，我们可以使用 `grep`
    和 `cut` 的组合从任何成功的 ping 请求中提取 IP 地址：
- en: '![](../images/00198.jpeg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00198.jpeg)'
- en: 'By employing this task sequence in a loop that contains a range of target IP
    addresses, we can quickly identify live hosts that respond to ICMP echo requests.
    The output is a simple list of live IP addresses. An example script that uses
    this technique can be seen here:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在包含多个目标 IP 地址范围的循环中使用此任务序列，我们可以快速识别对 ICMP 回显请求做出响应的在线主机。输出结果是一个简单的在线 IP 地址列表。使用此技术的示例脚本可以在这里看到：
- en: '[PRE10]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the provided bash script, the first line defines the location of the bash
    interpreter. The block of code that follows performs a test to determine whether
    the one argument that was expected was supplied. This is determined by evaluating
    whether the number of supplied arguments is not equal to `1`. If the expected
    argument is not supplied, the usage of the script is output, and the script exits.
    The usage output indicates that the script is expecting the `/24` network address
    as an argument.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供的 Bash 脚本中，第一行定义了 Bash 解释器的位置。接下来的代码块执行一个测试，判断是否提供了预期的一个参数。这是通过检查提供的参数数量是否不等于
    `1` 来确定的。如果未提供预期的参数，脚本会输出用法信息，并退出。用法输出表明脚本期待 `/24` 网络地址作为参数。
- en: The next line of code extracts the network prefix from the supplied network
    address. For example, if the network address supplied was `192.168.11.0`, the
    prefix variable would be assigned `192.168.11`. A `for` loop is then used to cycle
    through the values of the last octet to generate each possible IP address in the
    local `/24` network. For each possible IP address, a single `ping` command is
    issued. The response for each of these requests is then piped over, and then `grep`
    is used to extract lines with the `bytes from` phrase. This will only extract
    lines that include the IP addresses of live hosts.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行代码从提供的网络地址中提取网络前缀。例如，如果提供的网络地址是 `192.168.11.0`，则前缀变量将被赋值为 `192.168.11`。然后使用
    `for` 循环遍历最后一个八位字节的值，生成本地 `/24` 网络中的每个可能 IP 地址。对于每个可能的 IP 地址，都会发出一个 `ping` 命令。每个请求的响应随后被管道传送，并使用
    `grep` 提取包含 `bytes from` 字符串的行。这将仅提取包含活跃主机 IP 地址的行。
- en: Finally, a series of `cut` functions is used to extract the IP address from
    that output. Notice that an ampersand is used at the end of the `for` loop task
    instead of a semicolon. The ampersand allows the tasks to be performed in parallel
    instead of in sequence. This drastically reduces the amount of time required to
    scan the IP range.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一系列 `cut` 函数用于从该输出中提取 IP 地址。注意，在 `for` 循环任务的末尾使用了一个与号（&），而不是分号。与号允许任务并行执行，而不是按顺序执行。这大大减少了扫描
    IP 范围所需的时间。
- en: 'The script can then be executed with a period and forward slash, followed by
    the name of the executable script:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以通过一个点和正斜杠来执行脚本，后跟可执行脚本的名称：
- en: '![](../images/00212.jpeg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00212.jpeg)'
- en: When executed without any arguments supplied, the script returns the usage.
    However, when executed with a network address value, the task sequence begins,
    and a list of live IP addresses is returned. As discussed in the previous scripts,
    the output of this script can also be redirected to a text file for later use.
    This can be done with a greater-than sign followed by the name of the output file.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当没有提供任何参数执行时，脚本返回用法信息。然而，当提供网络地址值时，任务序列开始，并返回一个活跃 IP 地址的列表。如前面脚本中所讨论，脚本的输出也可以重定向到文本文件以供后续使用。可以通过使用大于号并跟随输出文件的名称来完成此操作。
- en: '![](../images/00227.jpeg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00227.jpeg)'
- en: In the example provided, the `ls` command is used to confirm that the output
    file was created. The contents of this output file can be viewed by passing the
    filename as an argument to the `cat` command.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，使用 `ls` 命令确认输出文件已创建。可以通过将文件名作为参数传递给 `cat` 命令来查看该输出文件的内容。
- en: How it works…
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Ping is a well-known utility in the IT industry, and its existing functionality
    is already to identify live hosts. However, it was built with the intention of
    discovering whether a single host is alive and not as a scanning tool. The bash
    script in this recipe essentially does the same thing as using `ping` on every
    possible IP address in a `/24` CIDR range. However, rather than doing this tedious
    task manually, bash allows us to quickly and easily perform this task by passing
    the task sequence through a loop.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Ping 是 IT 行业中一个广为人知的工具，其现有功能已经能够识别活跃主机。然而，它的设计初衷是为了确定单个主机是否在线，而不是作为扫描工具。此处的
    Bash 脚本基本上实现了与在 `/24` CIDR 范围内每个可能的 IP 地址上使用 `ping` 相同的功能。但与手动执行这项繁琐任务不同，Bash
    允许我们通过循环快速简便地执行此任务。
- en: Using fping to perform host discovery
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fping 执行主机发现
- en: A tool that is very similar to the well-known `ping` utility is `fping.` However,
    it is also built with a number of additional features that are not present in
    `ping`. These additional features allow `fping` to be used as a functional scan
    tool, without additional modification. This recipe will demonstrate how to use
    `fping` to perform layer 3 discovery on remote hosts.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与知名`ping`工具非常相似的工具是`fping`。然而，它还内建了许多`ping`中没有的附加功能。这些附加功能使得`fping`可以作为一个功能强大的扫描工具使用，而无需额外的修改。本篇将演示如何使用`fping`对远程主机进行三层发现。
- en: Getting ready
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using `fping` to perform layer 3 discovery does not require a lab environment,
    as many systems on the Internet will reply to ICMP echo requests. However, it
    is highly recommended that you perform any type of network scanning exclusively
    in your own lab unless you are thoroughly familiar with the legal regulations
    imposed by any governing authorities to whom you are subject. If you wish to use
    this technique within your lab, you will need to have at least one system that
    will respond to ICMP requests. In the examples provided, a combination of Linux
    and Windows systems is used. For more information on setting up systems in a local
    lab environment, refer to the the *Installing Metasploitable2* and *Installing
    Windows Server* recipes in [Chapter 1](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426),
    *Getting Started*.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fping`进行三层发现不需要实验室环境，因为互联网上许多系统会对ICMP回显请求作出响应。然而，强烈建议您仅在自己的实验室中进行任何类型的网络扫描，除非您对所在地区的法律法规有充分了解。如果您希望在自己的实验室中使用此技术，您需要至少有一台能够响应ICMP请求的系统。在提供的示例中，使用了Linux和Windows系统的组合。有关在本地实验室环境中设置系统的更多信息，请参阅[第1章](part0026.html#OPEK1-cf89710d791c4a3bb78ec273d9322426)中的*安装Metasploitable2*和*安装Windows
    Server*。
- en: How to do it…
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作方法……
- en: The `fping` command is very similar to the `ping` utility with a few extras
    added on. It can be used in the same way that `ping` can be used to send an ICMP
    echo request to a single target to determine whether it is alive.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`fping`命令与`ping`工具非常相似，增加了一些附加功能。它可以像`ping`一样用于向单个目标发送ICMP回显请求，以确定该目标是否存活。'
- en: 'This is done by simply passing the IP address as an argument to the `fping`
    utility:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需将IP地址作为参数传递给`fping`工具即可：
- en: '![](../images/00400.jpeg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00400.jpeg)'
- en: 'Unlike the standard `ping` utility, `fping` will stop sending ICMP echo requests
    after it receives a single reply. Upon receiving a reply, it will indicate that
    the host corresponding to this address is alive. Alternatively, if a response
    is not received from the address, `fping` will, by default, make four attempts
    to contact the system prior to determining that the host is unreachable:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与标准的`ping`工具不同，`fping`在收到一个回复后会停止发送ICMP回显请求。收到回复后，它将表示与该地址对应的主机是存活的。或者，如果没有收到来自该地址的响应，`fping`默认会尝试四次与系统联系，然后才判断主机不可达：
- en: '![](../images/00254.jpeg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00254.jpeg)'
- en: 'This default number of connection attempts can be modified using the `-c` (count)
    option and supplying an integer value to it that defines the number of attempts
    to be made:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个默认的连接尝试次数可以通过使用`-c`（计数）选项来修改，并为其提供一个整数值，定义要进行的尝试次数：
- en: '![](../images/00269.jpeg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00269.jpeg)'
- en: When executed in this fashion, the output is slightly more cryptic but can be
    understood with careful analysis. The output for any host includes the IP address,
    the number of attempts made (`xmt`), the number of replies received (`rcv`), and
    the percentage of loss (`%loss`).
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式执行时，输出稍显难懂，但通过仔细分析可以理解。任何主机的输出包括IP地址、尝试次数（`xmt`）、收到的回复次数（`rcv`）和丢包百分比（`%loss`）。
- en: In the example provided, the first address was discovered to be online. This
    is evidenced by the fact that the number of bytes received and the latency of
    reply are both returned. You can also easily determine whether there is a live
    host associated with the provided IP address by examining the percentage loss.
    If the percentage loss is 100, no replies have been received. Unlike `ping`—which
    is most commonly used as a troubleshooting utility—`fping` was built with the
    integrated capability to scan multiple hosts.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供的示例中，发现第一个地址是在线的。这一点可以通过收到的字节数和回复延迟来证明。您还可以通过检查丢包百分比来轻松判断是否存在与所提供IP地址关联的存活主机。如果丢包百分比为100，则未收到任何回复。与`ping`（通常作为故障排除工具使用）不同，`fping`具备了扫描多个主机的集成功能。
- en: 'A sequential series of hosts can be scanned with `fping,` using the `-g` option
    to dynamically generate a list of IP addresses. To specify a range to scan, pass
    this argument to both the first and last IP address in the desired sequential
    range:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列连续的主机可以通过`fping`扫描，使用`-g`选项动态生成IP地址列表。要指定扫描范围，将该参数传递给所需连续范围内的第一个和最后一个IP地址：
- en: '![](../images/00282.jpeg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00282.jpeg)'
- en: 'The generate list option can also be used to generate a list based on the CIDR
    range notation. In the same way, `fping` will cycle through this dynamically generated
    list and scan each address:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成列表选项还可以基于CIDR范围表示法生成列表。同样，`fping`会循环遍历这个动态生成的列表并扫描每个地址：
- en: '![](../images/00415.jpeg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00415.jpeg)'
- en: 'Finally, `fping` can also be used to scan a series of addresses as specified
    by the contents of an input text file. To use an input file, use the `-f` (file)
    option and then supply the filename or path of the input file:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`fping`还可以通过输入文本文件的内容扫描一系列地址。要使用输入文件，请使用`-f`（文件）选项，并提供文件名或输入文件的路径：
- en: '![](../images/00417.jpeg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00417.jpeg)'
- en: How it works…
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `fping` tool performs ICMP discovery in the same manner as other tools that
    we discussed earlier. For each IP address, `fping` transmits one or more ICMP
    echo requests, and the received responses are then evaluated to identify live
    hosts. `fping` can also be used to scan a range of systems or an input list of
    IP addresses by supplying the appropriate arguments. As such, we do not have to
    manipulate the tool with bash scripting in the same way that was done with `ping`
    to make it an effective scanning tool.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`fping`工具执行ICMP发现的方式与我们之前讨论的其他工具相同。对于每个IP地址，`fping`会发送一个或多个ICMP回显请求，然后评估收到的响应，以识别活跃主机。`fping`还可以通过提供适当的参数来扫描一个系统范围或IP地址输入列表。因此，我们不需要像使用`ping`时那样通过bash脚本操作工具，使其成为有效的扫描工具。'
