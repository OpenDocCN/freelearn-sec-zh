- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Error Handling and Exception Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和异常测试
- en: In the previous chapter, you were introduced to the art of injecting code into
    legitimate input fields for API endpoints. Some of these types of threats use
    old techniques but they are still quite prevalent. One of them consists of fuzzing
    the text that will be injected. This may cause the target endpoint to misbehave
    simply because it was not prepared to receive unusual or bizarre input texts.
    This happens because the API endpoint is not correctly handling errors or the
    code implementing it is not treating eventual exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经接触到将代码注入合法输入字段的技术，适用于API端点。这些威胁中的一些使用的是旧技术，但依然非常普遍。其中一种方法是对将要注入的文本进行模糊测试（fuzzing）。这可能导致目标端点出现异常行为，仅仅因为它没有准备好接收不寻常或离奇的输入文本。这是因为API端点没有正确处理错误，或者实现它的代码没有处理可能出现的异常。
- en: Therefore, it is very important for API and application owners that both errors
    and exceptions are correctly tested and handled. And of course, you, as a pentester,
    cannot forget to add this to your testing notebook. Not only may vulnerabilities
    arise from bad error or exception handling. Valuable details on the infrastructure,
    such as frameworks, libraries, third-party software, operating system (including
    the kernel) version, and build number can be disclosed by an exception or an unforeseen
    error.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于API和应用程序的所有者来说，正确测试和处理错误和异常是非常重要的。当然，作为渗透测试员，你也不能忘记把这一点加入到测试笔记中。漏洞不仅可能源于错误或异常处理不当，异常或意外错误还可能泄露关于基础设施的有价值信息，比如框架、库、第三方软件、操作系统（包括内核）版本以及构建号。
- en: We’ll begin this chapter by talking about some general error codes and messages
    and how you can easily identify them. Next, we will dive into fuzzing and how
    this can trigger some hidden vulnerabilities. Finally, we’ll learn how to leverage
    our research efforts to reveal the data we are looking for.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从讨论一些常见的错误代码和消息开始，并介绍如何轻松识别它们。接下来，我们将深入探讨模糊测试（fuzzing），以及它如何触发一些隐藏的漏洞。最后，我们将学习如何利用我们的研究成果来揭示我们所寻找的数据。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Identifying error codes and messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别错误代码和消息
- en: Fuzzing for exception handling vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试异常处理漏洞
- en: Leveraging error responses for information disclosure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用错误响应进行信息泄露
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As we did for [*Chapter 5*](B19657_05.xhtml#_idTextAnchor078), we’ll leverage
    the same environment as the one pointed out in previous chapters. So, you’ll need
    a type 2 hypervisor, such as VirtualBox, and some Linux distribution, such as
    Ubuntu. Some other new relevant utilities will be mentioned in the corresponding
    sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 和[*第5章*](B19657_05.xhtml#_idTextAnchor078)一样，我们将使用与前几章所指出的相同环境。因此，你将需要一个2型虚拟化管理程序，如VirtualBox，以及一些Linux发行版，如Ubuntu。其他一些相关的新工具将在相应部分中提到。
- en: Identifying error codes and messages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别错误代码和消息
- en: In this section, we are going to learn about error codes and messages that can
    be provided by API endpoints when they are answering your requests. Error codes
    and messages are the cornerstones of effective API penetration testing. They act
    as a window into the API’s communication channels, revealing how they inform clients
    and users about issues encountered during request processing. By deciphering these
    messages, you can assess the strength and security of the API’s error-handling
    mechanisms. Scrutinizing error responses can expose potential security vulnerabilities
    such as information leaks, injection attacks, or weak input validation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习API端点在响应请求时可能提供的错误代码和消息。错误代码和消息是有效API渗透测试的基石。它们是API通信渠道的窗口，揭示了在请求处理过程中遇到问题时，API如何告知客户端和用户。通过解读这些消息，你可以评估API错误处理机制的强度和安全性。仔细审查错误响应可以揭示潜在的安全漏洞，如信息泄露、注入攻击或输入验证不严。
- en: One obvious approach to uncover error codes and messages is by checking the
    API documentation. In [*Chapter 3*](B19657_03.xhtml#_idTextAnchor042), you learned
    about the importance of this stage of pentesting. Another approach is manual testing.
    Here, pentesters craft requests with deliberately malformed data or incorrect
    inputs, observing the resulting error responses. Analyzing the structure and content
    of these responses provides insights into how the API handles various error scenarios.
    For instance, sending a request with an invalid authentication token might trigger
    a *401 Unauthorized* response, signifying a failed authentication attempt. Manually
    inspecting such responses can unveil valuable information about the API’s security
    posture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示错误代码和消息的一个显而易见的方法是检查 API 文档。在 [*第 3 章*](B19657_03.xhtml#_idTextAnchor042)
    中，你已经学习了这个渗透测试阶段的重要性。另一个方法是手动测试。在这里，渗透测试人员故意构造带有格式错误的数据或不正确输入的请求，观察返回的错误响应。分析这些响应的结构和内容可以提供有关
    API 如何处理各种错误场景的见解。例如，发送一个无效认证令牌的请求可能会触发 *401 Unauthorized* 响应，表示认证尝试失败。手动检查这些响应可以揭示
    API 安全状态的宝贵信息。
- en: Automated testing tools, such as Burp Suite and OWASP ZAP, are powerful allies
    in identifying error codes and messages. These tools can capture API requests
    and responses, enabling systematic analysis of error messages. By automating the
    process of sending requests with diverse payloads and inputs, you can efficiently
    identify potential vulnerabilities in the API’s error-handling mechanism. For
    example, Burp Suite’s **Intruder** tool can be used to send multiple requests
    with varying parameters, while its proxy feature allows for real-time capture
    and analysis of error responses. We’ve used both.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试工具，如 Burp Suite 和 OWASP ZAP，是识别错误代码和消息的强大工具。这些工具可以捕获 API 请求和响应，帮助系统地分析错误消息。通过自动化发送带有不同负载和输入的请求，你可以高效地识别
    API 错误处理机制中的潜在漏洞。例如，Burp Suite 的 **Intruder** 工具可以用来发送带有不同参数的多个请求，而它的代理功能则允许实时捕获和分析错误响应。我们已经使用过这两者。
- en: Beyond the conventional HTTP status codes, error messages often include additional
    details, such as error codes, descriptions, or even stack traces. These details
    offer valuable insights into the nature and root cause of the error, facilitating
    further investigation and exploitation (from an ethical pentesting perspective,
    of course). You should keep a keen eye on these details as they may reveal vulnerabilities
    or misconfigurations within the API. An error message containing a stack trace,
    for instance, might expose sensitive information about the underlying infrastructure,
    such as server paths or database queries. Analyzing such information can help
    you identify potential attack vectors and assess the severity of the vulnerability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的 HTTP 状态码，错误消息通常还包括额外的细节，如错误代码、描述，甚至堆栈跟踪。这些细节为错误的性质和根本原因提供了宝贵的线索，有助于进一步调查和利用（当然是从道德渗透测试的角度来看）。你应该密切关注这些细节，因为它们可能揭示
    API 中的漏洞或配置错误。例如，包含堆栈跟踪的错误消息可能暴露有关底层基础设施的敏感信息，如服务器路径或数据库查询。分析这些信息有助于你识别潜在的攻击向量，并评估漏洞的严重性。
- en: Furthermore, you can leverage parameter manipulation techniques to evoke specific
    error responses from the API. By modifying request parameters such as input data
    or HTTP headers, they can trigger different error scenarios and observe the API’s
    response. This approach allows you to systematically test the API’s error-handling
    capabilities and identify potential security weaknesses. For instance, sending
    requests with excessively large payloads or malformed data might cause the API
    to return error responses indicating input validation failures or buffer overflows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以利用参数操作技术来引发 API 的特定错误响应。通过修改请求参数，如输入数据或 HTTP 头部，它们可以触发不同的错误场景，并观察 API
    的响应。这种方法允许你系统地测试 API 的错误处理能力，并识别潜在的安全弱点。例如，发送过大负载或格式不正确的数据请求可能导致 API 返回错误响应，指示输入验证失败或缓冲区溢出。
- en: The consistency and predictability of error responses across different endpoints
    and input variations are crucial aspects of identifying error codes and messages.
    You can examine how the API handles errors under various conditions, such as different
    authentication states, input formats, or request methods. Consistent error handling
    is essential for ensuring the reliability and security of the API. Inconsistent
    or unpredictable error responses may indicate underlying vulnerabilities or implementation
    flaws that you could exploit.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应在不同端点和输入变化中的一致性和可预测性是识别错误代码和消息的关键因素。你可以检查API在不同条件下如何处理错误，比如不同的认证状态、输入格式或请求方法。一致的错误处理对于确保API的可靠性和安全性至关重要。不一致或不可预测的错误响应可能表明潜在的漏洞或实现缺陷，你可以利用这些问题。
- en: 'Let’s look at a practical example to illustrate the process of identifying
    error codes and messages. Imagine an API endpoint for user authentication that
    accepts username and password parameters via a POST request. We can send a request
    to this endpoint with invalid credentials and observe the resulting error response.
    Here’s an example request and response (command in a single line):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际的例子来说明如何识别错误代码和消息。假设有一个用户认证的API端点，它通过POST请求接受用户名和密码参数。我们可以向这个端点发送无效凭证，并观察返回的错误响应。以下是一个请求和响应示例（命令在一行中）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A possible answer could be as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的答案如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You receive not only an error code but also a message and more details. Let’s
    check out another type of error message that could reveal some more of this hypothetical
    API endpoint’s logic. We will try to log in with some generic user ID:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅会收到一个错误代码，还会得到一条消息和更多的详细信息。让我们来看另一种错误消息，它可能揭示出一些关于这个假设的API端点的逻辑。我们将尝试用一些通用的用户ID登录：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The endpoint returns the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点返回以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you know that only numeric values are accepted as user IDs. This tremendously
    reduces the search scope of a user enumeration task. Likewise, you can try to
    look for other error codes by using other API endpoints or HTTP verbs. As an exercise,
    the relevant dummy code implements an API with some endpoints and error messages.
    It can be found at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道只有数字值会被接受作为用户ID。这大大减少了用户枚举任务的搜索范围。同样，你也可以尝试通过使用其他API端点或HTTP动词来寻找其他错误代码。作为一个练习，相关的虚拟代码实现了一个带有端点和错误消息的API。可以在[https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/identify_error_codes.py)找到它。
- en: 'A Flask application listens on port TCP `5000` by default. You can change it
    by using the `port=` parameter as part of the `app.run` method. Let’s see how
    it works by running some `curl` commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flask应用程序默认监听TCP端口`5000`。你可以通过使用`port=`参数作为`app.run`方法的一部分来更改它。让我们通过运行一些`curl`命令来看一下它是如何工作的：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is quite straightforward. No surprises there! Now, let’s verify how the
    endpoint behaves when we provide a nonexistent user:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，没什么意外！现在，让我们验证一下当我们提供一个不存在的用户时，端点会如何表现：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: OK; that’s part of the application code too. What if we send something unexpected?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；这也是应用代码的一部分。如果我们发送一些意外的内容呢？
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This was directly answered by Flask (not the code I wrote) since it didn’t find
    any `user` endpoint that accepts a string as input. This is a well-known error
    message among Python applications and modules that make use of the Werkzeug module,
    a library that implements a **Web Server Gateway Interface** (**WSGI**). At least
    the message reveals that this API uses Python as its backend. In a real-world
    scenario, we would have had a fingerprinting win!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Flask直接回答的（而不是我写的代码），因为它没有找到任何接受字符串作为输入的`user`端点。这是Python应用程序和模块中常见的错误消息，尤其是使用Werkzeug模块的应用程序，该模块实现了**Web服务器网关接口**（**WSGI**）。至少这个消息透露出该API使用Python作为后端。在真实场景中，我们本可以通过这个信息获得指纹识别的胜利！
- en: 'Moving forward, let’s try the other endpoints by causing a predicted error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过制造一个预测的错误来尝试其他端点：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll receive this message should you forget to provide a name, email, or
    both. But in the case of this code, even if you send all parameters as expected,
    the application will throw an exception to show you how this can be revealing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记提供姓名、电子邮件或两者，系统会返回此消息。但在这个代码的情况下，即使你按预期发送了所有参数，应用程序仍会抛出异常，向你展示这可能带来多少信息泄露：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is what we received as output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们收到的输出结果：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See how dangerous badly treated exceptions can be? You have not only discovered
    that the endpoint uses Python behind the scenes but also part of the directory
    structure, including the Python version being used. The other endpoints will throw
    analogous messages. In the next section, we will play with fuzzing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看看异常处理不当有多危险？你不仅发现了该端点背后使用的是 Python，还揭示了部分目录结构，包括正在使用的 Python 版本。其他端点也会抛出类似的消息。在下一部分，我们将进行模糊测试。
- en: Fuzzing for exception handling vulnerabilities
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理漏洞的模糊测试
- en: In [*Chapter 4*](B19657_04.xhtml#_idTextAnchor056), you quickly experimented
    with fuzzing by taking part in the exercises that we conducted with Burp Suite.
    Now, we are going to dive deeper into this technique. Fuzzing is very important
    in the context of API pentesting since it can expose an application’s vulnerabilities
    and weaknesses when incorrectly handling unexpected input. The types of vulnerabilities
    that can be raised from such bad handling may vary from information disclosure
    to **denial-of-service** (**DoS**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19657_04.xhtml#_idTextAnchor056) 中，你通过参与我们使用 Burp Suite 进行的练习，快速尝试了模糊测试。现在，我们将更深入地探讨这一技术。模糊测试在
    API 渗透测试中非常重要，因为它可以暴露应用程序在错误处理意外输入时的漏洞和弱点。由于错误处理不当可能导致的漏洞类型从信息泄露到 **拒绝服务**（**DoS**）不等。
- en: A popular approach to fuzzing for exception handling vulnerabilities involves
    utilizing automated tools such as **American Fuzzy Lop** (**AFL**). AFL, created
    by Michal Zalewski and nowadays maintained by Google, is very good at creating
    random patterns to provide as input when testing API endpoints or apps. It operates
    by repeatedly modifying input files and monitoring the target application for
    crashes or unusual behavior. There are some good fuzzers out there you could leverage
    to fuzz API endpoints by bombarding them with requests containing malformed data,
    unexpected parameter values, or even specially crafted HTTP headers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的异常处理漏洞模糊测试方法是使用自动化工具，如 **American Fuzzy Lop**（**AFL**）。AFL 由 Michal Zalewski
    创建，并由 Google 维护，擅长生成随机模式作为输入进行 API 端点或应用程序的测试。它通过反复修改输入文件并监控目标应用程序是否发生崩溃或异常行为来运行。有一些很好的模糊测试工具可以用来通过向
    API 端点发送包含格式不正确数据、意外参数值甚至特制 HTTP 头部的请求来进行模糊测试。
- en: For instance, imagine an API endpoint that processes JSON payloads for user
    authentication. A fuzzing test involves generating a series of malformed JSON
    payloads. These payloads could contain missing or invalid key-value pairs, excessively
    large sizes, or unexpected data types. By observing the API’s response to these
    inputs, you can identify potential exception-handling vulnerabilities, such as
    crashes, memory leaks, or unexpected behavior.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个 API 端点，用于处理用户认证的 JSON 负载。模糊测试涉及生成一系列格式不正确的 JSON 负载。这些负载可能包含缺失或无效的键值对、过大的大小，或者意外的数据类型。通过观察
    API 对这些输入的响应，你可以发现潜在的异常处理漏洞，比如崩溃、内存泄漏或意外行为。
- en: AFL’s strength lies in its feedback-driven approach, making it particularly
    adept at identifying exception-handling vulnerabilities. As the tool discovers
    new inputs that trigger unique paths or behaviors within the target application,
    it prioritizes mutating those inputs to delve deeper into the application’s code
    base. This iterative process helps uncover subtle vulnerabilities that manual
    testing alone might miss.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AFL 的优势在于其基于反馈的驱动方法，使其在识别异常处理漏洞方面尤其高效。当该工具发现新的输入触发了目标应用程序内的独特路径或行为时，它会优先修改这些输入，深入探讨应用程序的代码库。这一迭代过程有助于揭示那些仅凭手动测试可能遗漏的细微漏洞。
- en: Another approach to fuzzing for exception-handling vulnerabilities involves
    meticulously mutating specific input parameters or request attributes. For instance,
    you might strategically inject special characters, boundary values, or unexpected
    data types into input fields to trigger exceptions or errors within the API’s
    processing logic. By meticulously crafting input payloads to target specific code
    paths or error-handling mechanisms, you can uncover vulnerabilities that might
    otherwise remain hidden.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模糊测试异常处理漏洞的方法是精心改变特定的输入参数或请求属性。例如，你可能会有策略地将特殊字符、边界值或意外的数据类型注入到输入字段中，以触发 API
    处理逻辑中的异常或错误。通过精心构造输入负载，针对特定的代码路径或错误处理机制，你可以揭示那些可能被忽视的漏洞。
- en: Open source fuzzing frameworks such as Sulley and Radamsa offer additional options
    for targeted fuzzing of API endpoints. These frameworks provide tools and libraries
    for generating and mutating input data, along with mechanisms for monitoring and
    analyzing the target application’s responses. By tailoring fuzzing campaigns to
    focus on specific input parameters or request attributes, you can efficiently
    pinpoint exception-handling vulnerabilities and assess their impact on the API’s
    security posture.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开源模糊框架，如Sulley和Radamsa，提供了针对API端点的有针对性的模糊选项。这些框架提供了用于生成和变异输入数据的工具和库，以及用于监视和分析目标应用程序响应的机制。通过将模糊测试活动定制为专注于特定输入参数或请求属性，您可以有效地找出异常处理漏洞并评估其对API安全姿态的影响。
- en: Although AFL is quite versatile and powerful, I faced some trouble while compiling
    it to run on non-Intel chips. This scenario is supported, but you need to either
    apply **Low-Level Virtual Machine** (**LLVM**) or **Quick Emulator** (**QEMU**),
    two widely used hardware emulators, to be able to run it on ARM, for example.
    Sulley, in turn, stopped being maintained. A new project was raised in its place
    – Boofuzz. It seems promising and has good quickstart examples. However, Radamsa
    was easy to compile and install even on OSs backed by non-Intel chips. Many of
    the fuzzers require you to apply the change to the application’s code, which is
    not exactly what we are looking for. We want to understand how a generic API endpoint
    behaves when it needs to process random/unexpected input. Finally, **Fuzz Faster
    U Fool** (**FFUF**) is a quick web fuzzer written in Golang. Its installation
    is quite simple, besides the fact it can work in combination with other fuzzers,
    such as Radamsa. The point is that the majority of these fuzzers are good for
    sending fuzzed data, not **files**. Therefore, we will do things differently.
    Here, we will combine a mutator with custom code. We can handle response status
    codes and show just what we want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AFL非常多才多艺且功能强大，但我在将其编译为在非英特尔芯片上运行时遇到了一些麻烦。这种情况得到支持，但您需要应用**低级虚拟机**（**LLVM**）或**快速模拟器**（**QEMU**），这两种广泛使用的硬件模拟器，才能在ARM等平台上运行。相反，Sulley停止维护。一个新项目取代了它
    - Boofuzz。它看起来很有前途，并且有很好的快速入门示例。然而，Radamsa很容易在非英特尔芯片支持的操作系统上编译和安装。许多模糊器要求您对应用程序的代码进行更改，这并不完全符合我们的要求。我们想要了解当需要处理随机/意外输入时，通用API端点的行为如何。最后，**Fuzz
    Faster U Fool**（**FFUF**）是用Golang编写的快速网络模糊器。它的安装非常简单，而且它可以与Radamsa等其他模糊器结合使用。关键是，这些模糊器中的大多数适用于发送模糊数据，而不是**文件**。因此，我们将采取不同的方法。在这里，我们将结合一个变异器和自定义代码。我们可以处理响应状态代码，并仅显示我们想要的内容。
- en: Hence, for our practical exercise, we will explore making requests with fuzzed
    data provided by Radamsa to illustrate the process of fuzzing for exception-handling
    vulnerabilities. We can leverage the same code that we’ve already shared but with
    at least one more endpoint. This new endpoint will accept and process CSV files
    to update user information. A fuzzing test like this might involve generating
    a series of malformed CSV files with unexpected column headers, delimiter characters,
    or row formats. By observing the API’s response to these inputs, you can cause
    potential vulnerabilities in its CSV parsing and exception-handling logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的实际练习，我们将探索使用Radamsa提供的模糊数据进行请求，以说明模糊处理异常处理漏洞的过程。我们可以利用我们已经分享的相同代码，但至少增加一个端点。这个新端点将接受并处理CSV文件以更新用户信息。这样的模糊测试可能涉及生成一系列格式不正确的CSV文件，其中包含意外的列标题、分隔符字符或行格式。通过观察API对这些输入的响应，您可以在其CSV解析和异常处理逻辑中引发潜在的漏洞。
- en: 'The relevant code, which has been written to be vulnerable, could look something
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码，已经编写成易受攻击的形式，可能如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is located at [https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码位于[https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py](https://github.com/PacktPublishing/Pentesting-APIs/blob/main/chapters/chapter06/vulnerable_code_to_fuzz.py)。
- en: 'Take the following files as two legitimate inputs for the `upload_csv()` endpoint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文件作为`upload_csv()`端点的两个合法输入：
- en: '![Figure 6.1 – The first CSV file containing legitimate data](img/B19657_06_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 - 包含合法数据的第一个CSV文件](img/B19657_06_01.jpg)'
- en: Figure 6.1 – The first CSV file containing legitimate data
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 包含合法数据的第一个CSV文件
- en: 'The following figure shows the second CSV file that contains legitimate data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了包含合法数据的第二个CSV文件：
- en: '![Figure 6.2 – The second CSV file containing legitimate data](img/B19657_06_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 - 包含合法数据的第二个CSV文件](img/B19657_06_02.jpg)'
- en: Figure 6.2 – The second CSV file containing legitimate data
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 包含合法数据的第二个CSV文件
- en: 'The first step is to generate (fuzzed) data based on these files. With the
    help of Radamsa, we can quickly create thousands of fuzzed CSV files. There is
    a fair number of websites that can generate random data and files based on some
    parameters. I’ve put one of them in the *Further reading* section. You can create
    the fuzzed files with the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是基于这些文件生成（模糊化）数据。借助Radamsa的帮助，我们可以快速创建成千上万个模糊化的CSV文件。有很多网站可以根据一些参数生成随机数据和文件。我在*进一步阅读*部分放了其中一个。你可以使用以下命令创建模糊化的文件：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Filenames begin with `1.csv` and go up to `1000.csv`. Any data inside the original
    files (`csvfile1.csv` and `csvfile2.csv`) is subject to be fuzzed. So, you may
    expect fuzzed CSV files to have weird headers, such as `email4294967297`, negative
    IDs, or strange email addresses. That’s exactly the intention here. The custom
    script code follows. Observe that we are only filtering response codes different
    from `200`. When this happens, we repeat the request to display the exact API
    endpoint’s output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名以`1.csv`开始，一直到`1000.csv`。原始文件（`csvfile1.csv`和`csvfile2.csv`）中的任何数据都可能被模糊化。因此，你可能会发现模糊化的CSV文件具有奇怪的标题，比如`email4294967297`，负ID或奇怪的电子邮件地址。这正是本意所在。下面是自定义脚本代码。请注意，我们只过滤与`200`不同的响应代码。当发生这种情况时，我们会重复请求以显示确切的API端点输出：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In my case, the code spotted two errors out of 1,000 attempts, which means
    only a 2% success. However, even less than 1% can do the trick. Let’s see what
    made the endpoint crazy:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，代码在1000次尝试中发现了两个错误，这意味着成功率只有2%。然而，即使不到1%也可能成功。让我们看看是什么让端点发疯了：
- en: '![Figure 6.3 – API endpoint throwing error messages with “500” error codes](img/B19657_06_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 - API端点抛出“500”错误代码的错误消息](img/B19657_06_03.jpg)'
- en: Figure 6.3 – API endpoint throwing error messages with “500” error codes
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 - API端点抛出“500”错误代码的错误消息
- en: 'Now, let’s have a quick look at what the `379.csv` file looks like. Observe
    the badly formatted header, which has been built like this on purpose:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下`379.csv`文件的内容。请注意，这个格式不良的标题是故意构建的：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The fuzzed `554.csv` file looks similar:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊化的`554.csv`文件看起来类似：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Observe that both input files have broken CSV structures. These could cause
    unexpected processing logic on the target API endpoint. What if, instead of 1,000
    attempts, we submitted 5,000 requests? Maybe this could result in something naughty
    happening with the target. Delete all the fuzzed CSV files Radamsa created previously
    and repeat the same `radamsa` command, replacing `1000` with `5000`. The partial
    output of this is shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个输入文件都有损坏的CSV结构。这可能导致目标API端点上意外的处理逻辑。如果我们提交5000个请求而不是1000次尝试，会发生什么呢？也许这会导致目标发生一些不好的事情。删除Radamsa之前创建的所有模糊化的CSV文件，并重复相同的`radamsa`命令，将`1000`替换为`5000`。部分输出如下所示：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In my case, this new set of files resulted in 41 errors, which represents less
    than 1% of the hit rate. OK, it didn’t work out as expected, but this doesn’t
    mean we’ve done it wrongly. As previously mentioned, you must have patience while
    dealing with fuzzing. You can combine techniques and tools to get different artifacts
    and try them against your targets. You can also generate files with more rows
    and columns. Sooner or later, you will eventually achieve success and cause a
    failure on the endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，这一新文件集导致了41个错误，这占了命中率的不到1%。好吧，事情并没有按预期进行，但这并不意味着我们做错了。正如之前提到的，处理模糊测试时必须要有耐心。你可以结合不同的技术和工具来获得不同的结果，并尝试对目标进行测试。你也可以生成更多行和列的文件。迟早，你最终会取得成功，并在端点上造成失败。
- en: In the next section, we are going to understand what we can discover based on
    the error messages an API endpoint throws when answering requests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解基于API端点在回答请求时抛出的错误消息，我们可以发现什么。
- en: Leveraging error responses for information disclosure
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用错误响应进行信息披露
- en: Cool! So, you’ve learned how to identify error codes and messages and you’ve
    practiced this with a generic API endpoint. It’s now time for you to learn what
    you can do with the answers you will receive from the requests you are making
    toward such endpoints. They can be quite revealing. And sometimes, we don’t even
    need to send pernicious payloads to cause them to fail. Sysadmins and developers
    may change configurations or parameters based on changes or new application releases,
    and the new scenarios can cause the API to stop working.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！你已经学会了如何识别错误代码和消息，并且在一个通用的 API 端点上进行了实践。现在是时候学习如何利用你从这些请求中获得的反馈信息了。它们可能会暴露出很多信息。有时，我们甚至不需要发送恶意负载就能使其失败。系统管理员和开发者可能会根据配置更改或新应用程序版本的发布来调整设置或参数，这些新场景可能会导致
    API 停止工作。
- en: 'You will see a couple of generic figures in the following sections that show
    real web applications’ error messages. Observe that in at least one of them, the
    application simply discloses the versions of both .NET Framework and ASP.NET.
    This is embarrassing. In this specific case, some changes to a `web.config` file
    could suppress that specific line. Likewise, lacking a **web application firewall**
    (**WAF**) can leave room for releasing more revealing error messages. WAFs can
    either filter those messages or provide less verbose ones. *Figure 6**.4* shows
    a .NET failure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你会看到几个通用的错误信息图例，这些图例展示了真实 web 应用程序的错误消息。请注意，在至少一个图例中，应用程序简单地泄露了 .NET
    Framework 和 ASP.NET 的版本信息。这是很尴尬的。在这种特定情况下，可以通过更改 `web.config` 文件来抑制该特定行。同样，缺少
    **Web 应用防火墙** (**WAF**) 可能会导致更多暴露的错误信息。WAF 可以过滤这些信息，或提供更简洁的错误消息。*图 6.4* 显示了一个
    .NET 错误：
- en: '![Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)](img/B19657_06_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 来自 .NET web 应用的错误信息（来源：Code Aperture）](img/B19657_06_04.jpg)'
- en: 'Figure 6.4 – Error message from a .NET web application (Source: Code Aperture)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 来自 .NET web 应用的错误信息（来源：Code Aperture）
- en: '*Figure 6**.5* shows a default Microsoft IIS error page:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.5* 显示了一个默认的 Microsoft IIS 错误页面：'
- en: '![Figure 6.5 – Microsoft IIS error page (Source: Microsoft)](img/B19657_06_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – Microsoft IIS 错误页面（来源：Microsoft）](img/B19657_06_05.jpg)'
- en: 'Figure 6.5 – Microsoft IIS error page (Source: Microsoft)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – Microsoft IIS 错误页面（来源：Microsoft）
- en: At the beginning of this chapter, we made some tests with an API endpoint that
    was using Flask, which, in turn, was leveraging Werkzeug. During a simple test,
    we received an error message that revealed that information. We could then look
    for vulnerabilities involving those components and craft special payloads to exploit
    them. Quite straightforward.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们对一个使用 Flask 的 API 端点进行了测试，而 Flask 又依赖于 Werkzeug。在一次简单的测试中，我们收到了一个错误消息，暴露了这些信息。接着我们可以寻找涉及这些组件的漏洞，并编写特定的负载来利用它们。非常直接。
- en: 'There are some points you should pay attention to when analyzing error messages
    thrown by API endpoints:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析 API 端点抛出的错误消息时，有一些要点需要注意：
- en: '`/admin/users`, might return a 404 status code with a reason phrase such as
    `No route found for /admin/users`. This suggests the existence of an `admin` directory
    or a user management functionality within the API. You could use FFUF to recursively
    fuzz all endpoints under `/`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/admin/users` 可能返回 404 状态码，附带原因短语，如 `No route found for /admin/users`。这表明
    API 中可能存在 `admin` 目录或用户管理功能。你可以使用 FFUF 递归地对 `/` 下的所有端点进行模糊测试。'
- en: '`java.lang.RuntimeException: Unsupported file format at com.example.api.UploadController.processFile(UploadController.java:123)`.
    This exposes the use of Java and reveals the location of the function handling
    file processing within the application code.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.RuntimeException: Unsupported file format at com.example.api.UploadController.processFile(UploadController.java:123)`。这暴露了
    Java 的使用，并揭示了处理文件的函数在应用程序代码中的位置。'
- en: '`1003` due to an unauthorized attempt to update a user’s role. This code could
    hint at the existence of different permission levels or specific functionalities
    being mapped to these codes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1003` 由于未经授权尝试更新用户角色。此代码可能暗示了不同权限级别的存在，或特定功能被映射到这些代码。'
- en: '**Automated tools**: Several utilities can assist in parsing and analyzing
    error responses. We’ve played with some of them, such as OWASP ZAP and Burp Suite.
    In terms of fuzzing, we just used Radamsa to mutate CSV files and crafted a custom
    script to leverage them to test an API endpoint.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化工具**：有几个工具可以帮助解析和分析错误响应。我们尝试过一些工具，比如 OWASP ZAP 和 Burp Suite。在模糊测试方面，我们使用
    Radamsa 来变异 CSV 文件，并编写了一个自定义脚本，利用这些文件来测试 API 端点。'
- en: Using Burp Suite’s Intruder tool, you can fuzz parameter values within an API
    request and monitor the returned error messages. By analyzing patterns or specific
    details revealed in the error responses for different fuzzed inputs, they can
    potentially identify information disclosure vulnerabilities. We’ve done this for
    JWTs too.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 的 Intruder 工具，您可以在 API 请求中对参数值进行模糊测试，并监视返回的错误消息。通过分析不同模糊输入导致的错误响应中的模式或特定细节，他们可能会识别信息泄露漏洞。我们也对
    JWT 进行了这样的操作。
- en: '**Combining techniques**: The effectiveness of leveraging error responses is
    often amplified when combined with other pentesting techniques. Fuzzing techniques,
    as demonstrated earlier, can be used to generate unexpected inputs, and trigger
    informative error messages. Additionally, manually analyzing the application behavior
    and code (should you have access to it) can provide valuable context for interpreting
    the information disclosed in error responses.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结合技术**：当与其他渗透测试技术结合使用时，利用错误响应的效果通常会得到增强。正如之前演示的，模糊测试技术可以用来生成意外的输入，并触发信息丰富的错误消息。此外，手动分析应用程序行为和代码（如果您可以访问）可以为解释错误响应中披露的信息提供有价值的背景。'
- en: As general best practice advice, API developers can take several steps to mitigate
    the risk of information disclosure through error responses. Generic error messages
    with minimal technical details are a good first step. Additionally, proper configuration
    of logging and error handling mechanisms can prevent sensitive information from
    being included in error responses that reach external users. For example, avoid
    raising the programming language exception as a last resort. You, as a developer,
    completely lose control when doing that. Instead, try to map as many exceptions
    as possible and as a last resort, send a generic error message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般的最佳实践建议，API 开发人员可以采取几个步骤来减轻通过错误响应泄露信息的风险。具有最少技术细节的通用错误消息是一个良好的第一步。此外，正确配置日志记录和错误处理机制可以防止敏感信息包含在传递给外部用户的错误响应中。例如，避免将编程语言异常作为最后手段。当这样做时，作为开发人员，您完全失去了控制。相反，尽可能映射尽可能多的异常，作为最后手段，发送一个通用错误消息。
- en: Talking about logs, be sure to protect the access to them. Do not solely rely
    on the OS’s security mechanisms, such as filesystem permissions. A good approach
    is to have at least one copy of them elsewhere, such as a secondary data center
    or even a public cloud provider, and encrypt them at rest with a strong algorithm
    that applies a reasonable key length. Consider keys with at least 256 bits.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到日志时，一定要保护对其的访问。不要仅仅依赖于操作系统的安全机制，比如文件系统权限。一个好的方法是至少在其他地方备份一份，比如次要数据中心或者甚至公共云提供商，并且使用强大的算法对其进行加密，应用一个合理的密钥长度。考虑至少使用
    256 位密钥。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this practical chapter, we looked at how error messages that are thrown by
    API endpoints when handling requests can be useful not only to reveal information
    about their environment and configurations (data leakage) but also to cause more
    damage, such as DoS attacks (when the endpoint can’t heal itself after receiving
    an aggressive payload). We got our hands dirty with mutation and fuzzing and leveraged
    them in an exercise to bomb an API endpoint with bizarre data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实用的章节中，我们看到当处理请求时 API 端点抛出的错误消息不仅可以揭示关于其环境和配置的信息（数据泄露），还可以造成更多的损害，比如 DoS
    攻击（当端点在接收到激进负载后无法自我修复时）。我们亲自动手进行了变异和模糊测试，并利用它们来轰炸一个 API 端点，使用奇怪的数据。
- en: In the next chapter, we will get knee-deep in terms of DoS attacks and rate-limiting
    testing. Some APIs are protected by control mechanisms that reduce the number
    of requests a client can set at once. However, there are some techniques we can
    leverage to increase the chances of a successful attack.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究 DoS 攻击和速率限制测试。一些 API 受到控制机制的保护，减少客户端一次设置的请求数量。然而，我们可以利用一些技术来增加成功攻击的机会。
- en: Further reading
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涵盖的主题更多内容，请查看以下资源：
- en: 'The Werkzeug code implementing the Flask “not found” error message: [https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6](https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Flask “未找到”错误消息的 Werkzeug 代码：[https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6](https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L345C1-L348C6)
- en: 'More information about WSGI: [https://wsgi.readthedocs.io/en/latest/](https://wsgi.readthedocs.io/en/latest/)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于WSGI的更多信息: [https://wsgi.readthedocs.io/en/latest/](https://wsgi.readthedocs.io/en/latest/)  '
- en: 'American Fuzzy Lop, a widely used fuzzer for various types of applications:
    [https://github.com/google/AFL](https://github.com/google/AFL)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'American Fuzzy Lop，一个广泛使用的模糊测试工具，适用于各种类型的应用程序: [https://github.com/google/AFL](https://github.com/google/AFL)'
- en: 'What is LLVM?: [https://llvm.org/](https://llvm.org/)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '什么是LLVM?: [https://llvm.org/](https://llvm.org/)  '
- en: 'QEMU: [https://www.qemu.org/](https://www.qemu.org/)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'QEMU: [https://www.qemu.org/](https://www.qemu.org/)  '
- en: 'Sulley – Fuzz Testing Framework: [https://github.com/OpenRCE/sulley](https://github.com/OpenRCE/sulley)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sulley – 模糊测试框架: [https://github.com/OpenRCE/sulley](https://github.com/OpenRCE/sulley)  '
- en: 'Boofuzz – Sulley’s replacement: [https://github.com/jtpereyda/boofuzz](https://github.com/jtpereyda/boofuzz)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boofuzz – Sulley的替代品: [https://github.com/jtpereyda/boofuzz](https://github.com/jtpereyda/boofuzz)  '
- en: 'Radamsa – a very good command-line fuzzer: [https://gitlab.com/akihe/radamsa](https://gitlab.com/akihe/radamsa)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Radamsa – 一个非常好的命令行模糊测试工具: [https://gitlab.com/akihe/radamsa](https://gitlab.com/akihe/radamsa)  '
- en: 'A free Burp extension for Radamsa: [https://github.com/ikkisoft/bradamsa](https://github.com/ikkisoft/bradamsa)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个免费的Burp扩展，用于Radamsa: [https://github.com/ikkisoft/bradamsa](https://github.com/ikkisoft/bradamsa)  '
- en: 'FFUF – a fast web fuzzer written in Golang: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FFUF – 用Golang编写的快速Web模糊测试工具: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)  '
- en: 'Generate random files: [https://extendsclass.com/csv-generator.html](https://extendsclass.com/csv-generator.html)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '生成随机文件: [https://extendsclass.com/csv-generator.html](https://extendsclass.com/csv-generator.html)  '
